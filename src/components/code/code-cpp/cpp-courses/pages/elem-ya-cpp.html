<article class="article">
  <h1>Яндекс Образования. Хендбук. Основы С++</h1>
  <p>Конспект курса</p>
  <p><a href="https://education.yandex.ru/handbook/cpp" target="_blank">https://education.yandex.ru/handbook/cpp</a></p>
  <p>Авторы: Алексей Зобнин (Яндекс), Владимир Кузнецов (Яндекс), Артём Брустовецкий (Clever Inc. (Kahoot)).</p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
    <a href="#p1.1">1 Введение</a>
    <br><a href="#p1.1">1.1 Введение</a>
  </p>

  <p>
    <a href="#p2.1">2 Базовые конструкции C++</a>
    <br><a href="#p2.1">2.1 Первые шаги</a>
    <br><a href="#p2.2">2.2 Типы данных</a>
    <br><a href="#p2.3">2.3 Ветвления и циклы</a>
    <br><a href="#p2.4">2.4 Векторы и строки</a>
    <br><a href="#p2.5">2.5 Составные типы данных</a>
    <br><a href="#p2.6">2.6 Ссылки, указатели, константность</a>
    <br><a href="#p2.7">2.7 Функции</a>
    <br><a href="#p2.8">2.8 Шаблоны</a>
    <br><a href="#p2.9">2.9 Разбор задач к главе «Базовые конструкции C++»</a>
  </p>

  <p>
    <a href="#p3.1">3 Стандартная библиотека C++</a>
    <br><a href="#p3.1">3.1 Последовательные контейнеры</a>
    <br><a href="#p3.2">3.2 Ассоциативные контейнеры</a>
    <br><a href="#p3.3">3.3 Алгоритмы</a>
    <br><a href="#p3.4">3.4 Адаптеры и представления</a>
    <br><a href="#p3.5">3.5 Разбор задач к главе «Стандартная библиотека C++»</a>
  </p>

  <p>
    <a href="#p4.1">4 Идиомы C++</a>
    <br><a href="#p4.1">4.1 Классы</a>
    <br><a href="#p4.2">4.2 Шаблонные классы</a>
    <br><a href="#p4.3">4.3 Жизненный цикл объекта</a>
    <br><a href="#p4.5">4.4 Наследование и полиморфизм</a>
    <br><a href="#p4.4">4.5 Обработка исключений</a>
    <br><a href="#p4.6">4.6 Идиома RAII и умные указатели</a>
    <br><a href="#p4.7">4.7 Разбор задач к главе «Идиомы C++»</a>
  </p>

  <p>
    <a href="#p5.1">5 Приложение</a>
    <br><a href="#p5.1">5.1 Как работать с системой проверки заданий</a>
    <br><a href="#p5.2">5.2 Как пользоваться хендбуком</a>
  </p>

</article>


<!-- 1.1 Введение -->
<article class="article">
  <div class="anchor" id="p1.1"></div>
  <h2>1 Введение</h2>
  <h3>1.1 Введение</h3>

  <p>Перед вами учебник по основам языка C++. При его создании мы вдохновлялись специализацией «Искусство разработки на современном C++» на «Курсере», созданной при поддержке Яндекса, и курсом «Основы и методология программирования», который читался в 2014–2021 годах на факультете компьютерных наук ВШЭ.</p>

  <p>Языку C++ почти 40 лет, но он по-прежнему очень актуален и востребован. Он оказал огромное влияние на индустрию и на другие языки. C++ был разработан Бьярне Страуструпом в начале 1980-х годов как расширение языка C (и даже изначально назывался «Си с классами»).</p>

  <p>Однако для изучения C++ совсем не обязательно знать C. Тем не менее мы предполагаем, что вы знакомы с основами информатики и владеете каким-либо языком программирования на уровне школьной программы — например, языком Python.</p>

  <p>Впрочем, C++ во многом полностью противоположен Python:</p>
  <ul>
    <li>это компилируемый, а не интерпретируемый язык;</li>
    <li>С++ — язык со статической, а не динамической типизацией;</li>
    <li>в C++ возможно ручное управление памятью (в отличие от автоматической сборки мусора).</li>
  </ul>

  <p>Чтобы исходный код программы на C++ превратился в исполняемый файл для конкретной архитектуры процессора, программу нужно скомпилировать. Существует несколько популярных компиляторов C++:</p>
  <ul>
    <li>GNU Compiler Collection (GCC);</li>
    <li>Clang — построен поверх инфраструктуры LLVM;</li>
    <li>Microsoft Visual C++ (MSVC) — входит в состав Microsoft Visual Studio;</li>
    <li>Intel C++ Compiler.</li>
  </ul>

  <p>Мы будем использовать в примерах и при проверке задач компилятор Clang 16-й версии.</p>

  <p>С 1998 года международный комитет по стандартизации C++ выпускает стандарты — версии языка, в которых описываются его возможности. В первую очередь это руководства для создателей компиляторов, но при возникновении спорных моментов всегда полезно обратиться к стандарту. Мы будем ориентироваться на стандарт C++20, а по ссылке можно ознакомиться с черновиком будущего стандарта. Важно понимать, что стандарт определяет лишь общие требования и не фиксирует детали реализации, которые в разных компиляторах могут отличаться.</p>

  <p>Чтобы проверить, поддерживает ли ваша версия компилятора ту или иную особенность C++, советуем пользоваться специальной таблицей.</p>

  <p>При изучении вам будут полезны следующие англоязычные ресурсы:</p>
  <ul>
    <li>cppreference.com — онлайн-документация по C++;</li>
    <li>isocpp.org — сайт Standard C++ Foundation;</li>
    <li>C++ Core Guidelines — гайдлайны по C++ от Бьярне Страуструпа и Герба Саттера;</li>
    <li>godbolt.org — Compiler Explorer, онлайн-компилятор;</li>
    <li>learncpp.com — современный учебник по C++;</li>
    <li>hacking C++ — наглядный справочник по C++ с картинками и инфографикой.</li>
  </ul>

  <p>В тексте мы будем часто ссылаться на англоязычную версию cppreference.com и на английскую «Википедию».</p>

  <p>Написать программу для C++ можно в любом текстовом редакторе, но удобнее пользоваться средой разработки (IDE). IDE включают редактор кода с подсветкой синтаксиса, а также позволяют компилировать, запускать и отлаживать программы.</p>

  <p>Примеры IDE:</p>
  <ul>
    <li>Microsoft Visual Studio Community</li>
    <li>Eclipse CDT</li>
    <li>Code::Blocks</li>
    <li>Qt Creator</li>
    <li>Xcode</li>
  </ul>

  <p>Мы рассчитываем, что вы сможете самостоятельно разобраться с настройкой и использованием среды разработки, и не будем заострять на этом внимание. В наших примерах мы будем запускать компилятор из консоли.</p>

  <p>К нашему учебнику прилагается набор задач по соответствующим темам. Вы можете сдавать их в автоматическую проверяющую систему. В одних задачах требуется написать полноценную программу, а в других — сдать только код функции или класса. Обратите внимание, что ко всем задачам имеются разборы с авторскими решениями. Найти разборы вы можете в конце глав.</p>

  <p>Ho прежде чем мы двинемся дальше — небольшое объявление: для этого хендбука у нас есть коммьюнити студентов. В нём можно найти единомышленников, обсудить материалы и задания. Вступить в него можно по <a href="https://t.me/handbook_cpp">ссылке</a>. А чтобы быть в курсе обновлений хендбука — советуем подписаться на рассылку.</p>
</article>


<!-- 2.1 Первые шаги -->
<article class="article">
  <div class="anchor" id="p2.1"></div>
  <h2>2 Базовые конструкции C++</h2>
  <h3>2.1 Первые шаги</h3>

  <p>В этом параграфе мы напишем первую программу на C++ и научимся печатать и считывать с клавиатуры строки и числа.</p>

  <h4>Функция main</h4>
  <p>Пожалуй, самая простая и короткая программа на C++ — это программа, которая ничего не делает. Она выглядит так:</p>
<pre>
int main() {
  return 0;
}
</pre>
  <p>Здесь определяется функция с именем main, которая не принимает никаких аргументов (внутри круглых скобок ничего нет) и не выполняет никаких содержательных команд. В каждой программе на C++ должна быть ровно одна функция main — с неё начинается выполнение программы.</p>

  <p>У функции указан тип возвращаемого значения int (целое число), и она возвращает 0 — в данном случае это сообщение для операционной системы, что программа выполнилась успешно. И наоборот, ненулевой код возврата означает, что при выполнении возникла ошибка (например, программа получила некорректные входные данные).</p>

  <p>Для функции main разрешается не писать завершающий return 0, чем мы и будем пользоваться далее для краткости. Поэтому самую короткую программу можно было бы написать вот так:</p>
  <code>int main() {}</code>

  <h4>Hello, world!</h4>
  <p>Соблюдая традиции, напишем простейшую программу на C++ — она выведет приветствие в консоль:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  std::cout &lt;&lt; "Hello, world!\n";
}
</pre>
  <p>Разберём её подробнее.</p>

  <p>Директива #include &lt;iostream&gt; подключает стандартный библиотечный заголовочный файл для работы с потоками ввода-вывода (input-output streams). Для печати мы используем поток вывода std::cout, где cout расшифровывается как character output, то есть «символьный вывод».</p>

  <p>В теле функции main мы передаём в std::cout строку Hello, world! с завершающим переводом строки \n. В зависимости от операционной системы \n будет преобразован в один или в два управляющих байта с кодами 0A или 0D 0A соответственно.</p>

  <p>Инструкции внутри тела функции завершаются точками с запятой.</p>

  <h4>Компиляция из командной строки</h4>
  <p>Вы можете запустить эту программу из какой-нибудь IDE. Мы же покажем, как собрать её в консоли Linux с помощью компилятора clang++.</p>

  <p>Пусть файл с программой называется hello.cpp. Запустим компилятор:</p>
  <code>$ clang++ hello.cpp -o hello</code>
  <p>В результате мы получим исполняемый файл с именем hello, который теперь можно просто запустить. Он напечатает на экране ожидаемую фразу:</p>
<pre>
$ ./hello
Hello, world!
</pre>
  <p>Если опцию -o не указать, то сгенерированный исполняемый файл будет по умолчанию назван a.out. В дальнейшем для простых примеров мы будем использовать краткую форму записи команды:</p>
<pre>
$ clang++ hello.cpp && ./a.out
Hello, world!
</pre>
  <p>С её помощью мы компилируем программу и в случае успеха компиляции сразу же запускаем.</p>

  <h4>Комментарии</h4>
  <p>Комментарии — это фрагменты программы, которые игнорируются компилятором и предназначены для программиста. В C++ есть два вида комментариев — однострочные и многострочные:</p>
<pre>
int main() {  // однострочный комментарий продолжается до конца строки

/* Пример
   многострочного
   комментария */
}
</pre>
  <p>Мы будем использовать комментарии в примерах кода для пояснений, а в реальных программах ими лучше не злоупотреблять.</p>

  <p>Хорошо: комментировать, что делает библиотека, функция или класс или почему этот код написан именно так.</p>

  <p>Плохо: комментировать, что происходит на отдельных строчках. Это признак того, что код можно написать лучше.</p>

  <h4>Библиотеки и заголовочные файлы</h4>
  <p>Библиотека — это код, который можно переиспользовать в разных программах. В стандарт языка C++ входит спецификация так называемой стандартной библиотеки, которая поставляется вместе с компилятором. Она содержит различные структуры данных (контейнеры), типовые алгоритмы, средства ввода-вывода и т. д. Конструкции из этой библиотеки предваряются префиксом std::, который обозначает пространство имён.</p>

  <p>Чтобы воспользоваться теми или иными библиотечными конструкциями, в начале программы надо подключить нужные заголовочные файлы. Так, в программе, которая печатала Hello, world!, нам уже встречался заголовочный файл iostream и конструкция std::cout из стандартной библиотеки.</p>

  <p>Для C++ существует также множество сторонних библиотек. Наиболее известной коллекцией сторонних библиотек для C++ является Boost.</p>

  <h4>Ошибки компиляции</h4>
  <p>Перед запуском программу необходимо скомпилировать. Компилятор проверяет корректность программы и генерирует исполняемый файл. Во время компиляции компилятор может обнаружить синтаксические ошибки.</p>

  <p>Рассмотрим пример такой программы:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  cout &lt;&lt; "Hello, world\n"
</pre>
  <p>Первая ошибка — вместо std::cout мы написали cout. Вторая ошибка — не поставили точку запятой после "Hello, world!\n". Наконец, третья – не закрыли фигурную скобку с телом функции.</p>

  <p>Ошибки компиляции (compile errors) следует отличать от возможных ошибок времени выполнения (runtime errors), которые происходят после запуска программы и, как правило, зависят от входных данных, неизвестных во время компиляции.</p>

  <h4>Отступы и оформление кода</h4>
  <p>Фрагменты программы на C++ могут быть иерархически вложены друг в друга. На верхнем уровне находятся функции, внутри них написаны их тела, в теле могут быть составные операторы, и так далее.</p>

  <p>Среди программистов есть соглашение — писать внутренние блоки кода с отступами вправо: компилятор полностью игнорирует эти отступы, а код читать удобнее. Мы будем использовать отступы в четыре пробела. Также мы будем придерживаться стиля оформления кода, принятого в Яндексе. Имена переменных мы будем писать с маленькой буквы, имена функций и классов — с большой (если речь не идёт о конструкциях стандартной библиотеки, где действуют другие соглашения).</p>

  <h4>Переменные</h4>
  <p>Любая содержательная программа так или иначе обрабатывает данные в памяти. Переменная — это именованный блок данных определённого типа. Чтобы определить переменную, нужно указать её тип и имя. В общем виде это выглядит так:</p>
  <code>Type name;</code>
  <p>где Type — конкретный тип данных (например, строка или число), а name — имя переменной. Имена переменных должны состоять из латинских букв, цифр и знаков подчёркивания и не должны начинаться с цифры. Также можно в одной строке определить несколько переменных одного типа:</p>
  <code>Type name1, name2, name3;</code>
  <p>Например:</p>
<pre>
// библиотека, в которой
// определён тип std::string
#include &lt;string&gt;

int main() {
  // Определяем переменную value
  // целочисленного типа int
  int value;

  // Определяем переменные name и surname
  // типа std::string (текстовая строка)
  std::string name, surname;
}
</pre>
  <p>В этом примере мы используем встроенный в язык тип int (от слова integer — целое число) и поставляемый со стандартной библиотекой тип std::string. (Можно было бы использовать для строк встроенный тип с массивом символов, но это неудобно.)</p>

  <p>Тип переменной должен быть известен компилятору во время компиляции.</p>

  <p>От типа зависит:</p>
  <ul>
    <li>сколько байтов памяти потребуется для хранения данных;</li>
    <li>как интерпретировать эти байты;</li>
    <li>какие операции с этой переменной возможны.</li>
  </ul>

  <p>Например, переменной типа int можно присваивать значения и с ней можно производить арифметические операции. Подробнее про разные типы данных и их размер в памяти мы поговорим ниже.</p>
  <p>Важно понимать, что тип остаётся с переменной навсегда. Например, присвоить целочисленной переменной строку не получится — это вызовет ошибку компиляции:</p>
<pre>
int main() {
  int value;
  value = 42;  // OK
  value = "Hello!";  // ошибка компиляции!
}
</pre>
  <p>Переменные можно сразу проинициализировать значением. В С++ есть много разных способов инициализации. Нам пока будет достаточно способа, который называется copy initialization:</p>
<pre>
#include &lt;string&gt;

int main() {
  int value = 42;
  std::string title = "Bjarne Stroustrup";
}
</pre>
  <p>Если переменная была объявлена, но нигде дальше не использовалась, то компилятор выдаёт об этом предупреждение. При проверке решений мы используем опцию -Werror, которая считает предупреждения компилятора ошибками компиляции.</p>

  <h4>Потоковый ввод и вывод</h4>
  <p>Поток — это абстракция для чтения и записи последовательности данных в форматированном виде.</p>

  <p>Записывать данные можно на экран консоли, в файл, буфер в памяти или в строку. Считывать их можно с клавиатуры, из файла, из памяти. Причём с каждым таким «устройством» можно связать свой поток.</p>

  <p>Важно, что потоки не просто пересылают байты памяти, а применяют форматированный человекочитаемый ввод-вывод. Например, числа печатаются и считываются в десятичной нотации, хотя в памяти компьютера они хранятся в двоичном виде.</p>

  <p>В программе Hello, world! нам уже встречался поток вывода std::cout, по умолчанию связанный с экраном консоли. Познакомимся с потоком ввода std::cin, связанным с клавиатурой. Для его использования нужен тот же заголовочный файл iostream.</p>

  <p>Рассмотрим программу, которая спрашивает имя пользователя и печатает персональное приветствие:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string name;  // объявляем переменную name
  std::cout &lt;&lt; "What is your name?\n";
  std::cin >> name;  // считываем её значение с клавиатуры
  std::cout &lt;&lt; "Hello, " &lt;&lt; name &lt;&lt; "!\n";
}
</pre>
  <p>Обратите внимание на направление угловых скобок в этом примере — они условно показывают направление потока данных. При печати данные выводятся на экран, и стрелки направлены от текста к cout. При вводе данные поступают с клавиатуры, и стрелки направлены от cin к переменной.</p>

  <p>В нашем примере в переменную name считается одно слово, которое будет выведено в ответном сообщении. Пример работы программы:</p>
<pre>
What is your name?
Alice
Hello, Alice!
</pre>
  <p>Однако если ввести строку из нескольких слов с пробелами, то в name запишется только первое слово:</p>
<pre>
$ ./a.out
What is your name?
Alice Liddell
Hello, Alice!
</pre>
  <p>Дело в том, что cin читает поток данных до ближайшего пробельного разделителя (пробела, табуляции, перевода строки или просто конца файла). Чтобы считать в строковую переменную всю строчку целиком (не включая завершающий символ перевода строки), нужно использовать функцию std::getline из заголовочного файла string:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string name;
  std::getline(std::cin, name);
  std::cout &lt;&lt; "Hello, " &lt;&lt; name &lt;&lt; "!\n";
}
</pre>
  <p>В этом примере мы печатаем в одном выражении друг за другом несколько строк ("Hello, ", name и "!\n"), разделённых угловыми скобками &lt;&lt;. Таким образом, cin и cout позволяют кратко считывать и печатать несколько объектов одной командой.</p>

  <p>Например, считывание нескольких чисел целого типа, набранных через пробельные разделители, может выглядеть так:</p>
<pre>
int main() {
  int a;
  int b;
  int c;
  std::cin >> a >> b >> c;
}
</pre>
  <p>Напечатать их значения можно следующим образом:</p>
  <code>std::cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; " " &lt;&lt; c &lt;&lt; "\n";</code>
  <p>Обратите внимание, что мы дополнительно вставляем между ними пробелы, чтобы в выводе числа не слиплись вместе. В конце вывода мы вставляем символ перевода строки \n, чтобы отделить этот результат от последующего вывода или от сообщений командной строки.</p>

  <p>Итак, параграф позади! Впереди вас ждут первые задачи. Но прежде чем приступить к ним, советуем сперва взглянуть на небольшое руководство о том, как пользоваться системой проверки заданий.</p>
</article>


<!-- 2.2 Типы данных -->
<article class="article">
  <div class="anchor" id="p2.2"></div>
  <h3>2.2 Типы данных</h3>
  <p>C++ — язык со статической типизацией. У каждой переменной на этапе компиляции должен быть чётко определённый тип данных. Про каждый тип данных заранее известно, сколько места в памяти занимает переменная такого типа.</p>

  <p>В этом параграфе мы познакомимся с некоторыми базовыми типами данных и с понятием области видимости переменных.</p>

  <h4>Области видимости</h4>

  <p>В С++ существует понятие области видимости (scope) переменной. Эта область ограничивается блоком кода, в котором переменная определена. Рассмотрим пример:</p>
<pre>
#include &lt;iostream&gt;

int a = 1;  // глобальная переменная

int main() {
  int b = 2;  // локальная переменная
  {
    int c = 3;  // локальная переменная внутри блока
    std::cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b
    &lt;&lt; " " &lt;&lt; c &lt;&lt; "\n";  // корректно
  }

  // Эта строчка не скомпилируется,
  // так как переменная c не определена в данной области:
  std::cout &lt;&lt; c &lt;&lt; "\n";
}
</pre>
  <p>В этом примере есть три области:</p>
  <ul>
    <li>глобальная, в которой определена переменная a;</li>
    <li>тело функции main, в которой определена переменная b;</li>
    <li>внутренний блок, в котором определена переменная c.</li>
  </ul>
  <p>В последней строке примера переменная c недоступна, так как её область видимости уже закончилась. В случае коллизии имён компилятор всегда выбирает самую вложенную область видимости.</p>

  <p>Рассмотрим пример:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int x = 1;
  // напечатает 1
  std::cout &lt;&lt; x &lt;&lt; "\n";
  {
    // новая переменная, к предыдущему x не имеет отношения
    int x = 2;
    // напечатает 2
    std::cout &lt;&lt; x &lt;&lt; "\n";
  }
  // снова напечатает 1
  std::cout &lt;&lt; x &lt;&lt; "\n";
}
</pre>

  <h4>Инициализация локальных переменных</h4>
  <p>Локальные переменные простых типов, таких как int, не инициализируются по умолчанию нулём. Компилятор просто выделяет для них байты в стековой памяти, но при этом он не обязан как-либо их заполнять. Это один из принципов C++: мы не должны платить за то, что не используем.</p>

  <p>Следующий фрагмент кода может напечатать всё что угодно:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int x;
  // неопределённое поведение!
  std::cout &lt;&lt; x &lt;&lt; "\n";
  int y;
  // а это допустимый сценарий
  std::cin >> y;
}
</pre>
  <p>Компиляторы g++ и clang++ обычно дают предупреждения о чтении неинициализированных переменных при использовании опции -Wall или -Wuninitialized:</p>
  <p>Заметим, что std::string является сложным типом и переменные такого типа всегда по умолчанию инициализируются пустой строкой. Поэтому нет необходимости писать std::string s = "";. Пишите просто std::string s;.</p>

  <h4>Простые типы данных</h4>
  <p>С типом int мы уже знакомы. Рассмотрим другие фундаментальные типы данных в С++. Это так называемые интегральные типы и типы для вещественных чисел.</p>
<pre>
int main() {
  char c = '1';           // символ
  bool b = true;          // логическая переменная, принимает значения false и true
  int i = 42;             // целое число (занимает, как правило, 4 байта)
  short int si = 17;      // короткое целое (занимает 2 байта)
  long li = 12321321312;  // длинное целое (как правило, 8 байт)
  long long lli = 12321321312; // длинное целое (как правило, 8 байт)
  float f = 2.71828;      // дробное число с плавающей запятой (4 байта)
  double d = 3.141592;    // дробное число двойной точности (8 байт)
  long double ld = 1e15;  // длинное дробное (как правило, 16 байт)
}
</pre>
  <p>Обратите внимание, что символы, в отличие от строк (то есть массивов символов), записываются в апострофах, а не в кавычках. В примере выше мы записываем в переменную c символ единицы. Фактически в памяти хранится ASCII-код этого символа, который равен 49.</p>

  <p>Напомним, что каждый тип данных занимает заранее известное количество байтов памяти. Стандарт языка С++ не накладывает жёстких ограничений на размеры типов, они могут отличаться для разных платформ и компиляторов.</p>

  <p>О том, что делать с этой особенностью, мы расскажем ниже. А пока отметим, что узнать размер переменной или типа на этапе компиляции можно с помощью оператора sizeof.</p>

  <p>Например, на 64-битной Linux-системе компилятор clang++ использует такие размеры для типов:</p>
<pre>
int main() {
  std::cout &lt;&lt; "char: "      &lt;&lt; sizeof(char) &lt;&lt; "\n";                 //  1
  std::cout &lt;&lt; "bool: "      &lt;&lt; sizeof(bool) &lt;&lt; "\n";                 //  1
  std::cout &lt;&lt; "short int: " &lt;&lt; sizeof(short int) &lt;&lt; "\n";       //  2 (по стандарту >= 2)
  std::cout &lt;&lt; "int: "       &lt;&lt; sizeof(int) &lt;&lt; "\n";                   //  4 (по стандарту >= 2)
  std::cout &lt;&lt; "long int: "  &lt;&lt; sizeof(long int) &lt;&lt; "\n";         //  8 (по стандарту >= 4)
  std::cout &lt;&lt; "long long int: " &lt;&lt; sizeof(long long) &lt;&lt; "\n";   //  8 (по стандарту >= 8)
  std::cout &lt;&lt; "float: "     &lt;&lt;sizeof(float) &lt;&lt; "\n";               //  4
  std::cout &lt;&lt; "double: "    &lt;&lt; sizeof(double) &lt;&lt; "\n";             //  8
  std::cout &lt;&lt; "long double: " &lt;&lt; sizeof(long double) &lt;&lt; "\n";   // 16
}
</pre>

  <h4>Размеры стандартных типов</h4>
  <p>По умолчанию числовые типы – знаковые. Они имеют диапазон значений от -2<sup>n-1</sup> до 2<sup>n-1</sup> - 1, где n – количество битов, занимаемых типом. Приставка unsigned перед типом делает его беззнаковым. В этом случае диапазон допустимых значений будет от 0 до 2<sup>n</sup> - 1:</p>
<pre>
int main() {
  unsigned int ui = 4294967295;  // 2^32 - 1
}
</pre>
  <p>Минимальное и максимальное значение, помещающееся в данный числовой тип, можно получить так:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;limits&gt;  // необходимо для numeric_limits

int main() {
  // посчитаем для типа int:
  std::cout &lt;&lt; "minimum value: "
            &lt;&lt; std::numeric_limits&lt;int&gt;::min()
            &lt;&lt; "\n"
            &lt;&lt; "maximum value: "
            &lt;&lt; std::numeric_limits&lt;int&gt;::max()
            &lt;&lt; "\n";
}
</pre>
  <p>Данный пример на 64-битной Linux-системе напечатает:</p>
<pre>
minimum value: -2147483648
maximum value: 2147483647
</pre>
  <p>Приведённые выше примеры вывода оператора sizeof верны для 64-битных архитектур, которые на сегодняшний день распространены повсеместно. Однако если бы мы скомпилировали и запустили такую программу на компьютере с 32-битной архитектурой, то получили бы другие результаты. Например, sizeof(long int) стал бы равен 4, в то время как на современных компьютерах мы получили бы 8. Также бывают встраиваемые системы, под которые тоже можно писать на С++. Там битность архитектуры может быть ещё меньше, чем 32.</p>
  <p>В заголовочном файле cstdint стандартной библиотеки имеются целочисленные типы с фиксированным размером:</p>
  <ul>
    <li>int8_t / uint8_t</li>
    <li>int16_t / uint16_t</li>
    <li>int32_t / uint32_t</li>
    <li>int64_t / uint64_t</li>
  </ul>
  <p>Число в имени типа означает количество бит, используемых для хранения в памяти. Например, int32_t содержит 32 бита (4 байта) и часто соответствует типу int. Если система не поддерживает какой-то тип, то программа с ним просто не скомпилируется.</p>

  <h4>Переполнение целочисленных типов</h4>

  <p>Стандартные числовые типы имеют ограниченный размер и ограниченное множество допустимых значений. При арифметических операциях над числами таких типов может возникнуть переполнение — ситуация, когда результат операции не помещается в тип:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  // на 64-битной платформе sizeof(a) == 4
  unsigned int a = 123456;

  // Произведение a * a не помещается в 4 байта,
  // так как оно больше 2^32
  std::cout &lt;&lt; a * a &lt;&lt; "\n";
}
</pre>

  <p>В этом примере выражение a * a будет иметь тот же тип, что и аргументы. То, что на самом деле будет вычислено, зависит от знаковости типа.</p>
  <p>Беззнаковые типы можно спокойно переполнять: вычисления будут производиться по модулю соответствующей степени двойки. Другими словами, будут учтены только младшие биты результата:</p>
<pre>
int main() {
  // на 64-битной платформе sizeof(x) == 4
  unsigned int x = 0;
  // 4294967295, то есть 2**32 - 1
  unsigned int y = x - 1;
  unsigned int z = y + 1;  // 0
}
</pre>
  <p>Наоборот, для знаковых типов переполнение приводит к так называемому неопределённому поведению (UB, undefined behavior).</p>
  <p>Такая ситуация не считается ошибкой компиляции (в самом деле, на стадии компиляции значения переменных могут быть ещё неизвестны). Но в этом случае стандарт С++ перестаёт что-либо гарантировать по поводу поведения программы. Компиляторы могут использовать такие случаи для оптимизации программ, полагаясь на то, что разработчики пишут код корректно и никогда не допускают неопределённого поведения. Далее нам встретятся и другие случаи неопределённого поведения.</p>
  <p>Беззнаковые типы следует использовать, когда вы имеете дело с битовыми наборами. В остальных случаях предпочтительнее использовать знаковые типы.</p>

  <h4>Арифметические операции</h4>
  <p>Бинарные операции +, - и * работают для чисел стандартным образом. Результат операции деления /, применённой к целым числам, всегда округляется в сторону нуля. Таким образом, для положительных чисел операция / возвращает неполное частное. Остаток от деления целых чисел можно получить с помощью операции %.</p>
<pre>
int main() {
  int a = 7, b = 3;
  int q = a / b;  // 2
  int r = a % b;  // 1
}
</pre>
  <p>Если при делении нужно получить обычное частное, то один из аргументов нужно привести к вещественному типу (например, double) с помощью оператора static_cast:</p>
<pre>
int main() {
  int a = 6, b = 4;
  double q = static_cast&lt;double&gt;(a) / b;  // 1.5
}
</pre>
  <p>Можно было бы написать чуть более кратко: double q = a * 1.0 / b;. Тогда преобразование аргументов произошло бы неявно.</p>
  <p>Арифметические операции над символами, а также сравнение символов друг с другом — это фактически операции над их ASCII-кодами:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  char c = 'A';
  c += 25;  // увеличиваем ASCII-код символа на 25
  std::cout &lt;&lt; c &lt;&lt; "\n";  // Z
}
</pre>
  <p>Операция + применительно к строкам означает конкатенирование (то есть склейку). Это пример перегрузки операции: изначальному оператору сложения чисел в стандартной библиотеке для строки придали новый смысл.</p>
<pre>
#include &lt;string&gt;

int main() {
  std::string a = "Hello, ";
  std::string b = "world!";
  std::string c = a + b;  // Hello, world!
}
</pre>
  <p>Для каждой бинарной операции (например, +) есть версия со знаком равенства (+=) для случая, когда левый аргумент совпадает с переменной, которой присваивается результат:</p>
<pre>
int main() {
  int x = 5;
  x += 3;  // x = x + 3
  x *= x;  // x = x * x
}
</pre>
  <p>Наконец, имеются операторы ++ и -- для увеличения или уменьшения переменной на единицу. Они бывают префиксные (++x) и постфиксные (x++). Отличие состоит в значении выражения, которое будет вычисляться при применении такого оператора. Мы рассмотрим это позже, а пока привыкнем по умолчанию использовать префиксный оператор для обычных чисел:</p>
<pre>
int main() {
  int x = 5;
  ++x;  // 6
  --x;  // снова 5
}
</pre>

  <h4>Числа с плавающей точкой</h4>

  <p>В языке C++ существуют три встроенных типа для записи дробных чисел: float (4 байта), double (8 байт) и long double (16 или 8 байт, в зависимости от платформы). В большинстве случаев рекомендуется использовать тип double.Тип float разумно использовать там, где обрабатываются огромные массивы чисел, и возникает необходимость экономить память.</p>
  <p>Как правило, хранение дробных чисел в С++ основано на стандарте IEEE 754. Число представляется в виде двоичной дроби в экспоненциальной записи: отдельно хранятся бит знака, порядок и мантисса. Мантисса 23 бита (0-22), порядок 8 бит (23-30), знак 1 бит (31).</p>
  <p>Такое представление выгодно отличается от чисел с фиксированной точкой, где хранится фиксированное количество разрядов. Оно позволяет, хотя и с разной степенью точности, представлять числа, отличающиеся на порядки.</p>
  <p>При работе с рациональными числами, знаменатель которых не является степенью двойки, неизбежно возникают погрешности представления. В следующем параграфе мы разберём как следует сравнивать такие числа.</p>

  <h4>Автоматический вывод типа</h4>

  <p>Компилятор C++ умеет автоматически выводить тип переменной по значению, которое ей присваивается. Для этого вместо типа надо написать ключевое слово auto:</p>
<pre>
int main() {
  auto x = 42;  // int
  auto pi = 3.14159;  // double
}
</pre>
  <p>Ключевое слово auto позволяет сократить код и не выписывать сложные типы (нам встретятся дальше монстры вроде std::unordered_multimap&lt;Key, Value&gt;::const_iterator). Важно подчеркнуть, что точный тип переменной всё равно становится известен в момент компиляции.</p>
  <p>При использовании auto со строками нужно быть осторожным. Важно знать, что конструкция auto s = "hello" выведет низкоуровневый тип const char * (указатель на неизменяемый набор символов в памяти), а не тип-обёртку std::string.</p>
  <p>Точные правила вывода типов похожи на правила вывода шаблонных параметров, с которыми мы познакомимся в параграфе про шаблоны.</p>
  <p>В следующем параграфе мы подробнее поговорим о ветвлении и циклах.</p>
</article>


<!-- 2.3 Ветвления и циклы -->
<article class="article">
  <div class="anchor" id="p2.3"></div>
  <h3>2.3 Ветвления и циклы</h3>

  <p>В этом параграфе мы познакомимся с операторами ветвления if и switch, циклами while, do-while и for, а также с оператором goto.</p>

  <h4>Оператор if</h4>
  <p>Условный оператор if записывается так:</p>
<pre>
if (condition) {
  // код, который исполнится в случае,
  // когда условие condition истинно
}
</pre>
  <p>Дополнительно можно добавить ветку кода для случая, когда условие ложно:</p>
<pre>
if (condition) {
  // код, который исполнится,
  // если condition истинно
} else {
  // код, который исполнится,
  // если condition ложно
}
</pre>
  <p>Также можно выстроить цепочку условных операторов:</p>
<pre>
if (condition1) {
  // случай, когда condition1 истинно
} else if (condition2) {
  // случай, когда condition1 ложно,
  // а condition2 истинно
} else if (condition3) {
  // случай, когда condition1 и condition2 ложны,
  // а condition3 истинно
} else {
  // случай, когда condition1,
  // condition2 и condition3 ложны
}
</pre>
  <p>Если код внутри фигурных скобок состоит из одной инструкции, то фигурные скобки можно не писать. Однако рекомендуется ставить фигурные скобки всегда во избежание ошибок.</p>
  <p>На месте condition может стоять любое выражение логического типа. Простейшие примеры таких выражений — это проверка на равенство (==) и неравенство (!=), а также сравнения на меньше / больше (&lt;, &lt;=, > и >=):</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int x;
  std::cin >> x;
  if (x &lt;= 0) {
    std::cout &lt;&lt; "zero or negative\n";
  } else if (x == 1) {
    std::cout &lt;&lt; "one\n";
  } else if (x == 2) {
    std::cout &lt;&lt; "two\n";
  } else {
    std::cout &lt;&lt; "many\n";
  }
}
</pre>

  <h4>Сложные условия</h4>
  <p>Условия можно комбинировать с помощью логических операторов && (и), || (или) и ! (не). Рассмотрим пример, где проверяется принадлежность точки разным интервалам на прямой.</p>
<pre>
int main() {
  int a, b, x;
  /* Тут должна быть логика заполнения объявленных переменных,
  но мы её опустили, чтобы не отвлекаться */

  if (a &lt;= x && x &lt;= b) {
    // точка x лежит на отрезке [a; b]
  } else {
    // точка x лежит вне отрезка [a; b]
  }

  // то же самое можно было бы проверить так:
  if (!(x &lt; a || x > b)) {  // отрицание
    // точка x лежит на отрезке [a; b]
  } else {
    // точка x лежит вне отрезка [a; b]
  }
}
</pre>
  <p>Обратите внимание, что двойное неравенство некорректно проверять через a &lt;= x &lt;= b. Так можно написать, но смысл будет совсем другим: результат сравнения a &lt;= x будет приведён к нулю или единице, и полученное число будет сравниваться с b.</p>
  <p>Операторы сравнения имеют больший приоритет, чем логические операторы, поэтому скобки вокруг элементарных сравнений в сложных условиях не обязательны. А вот оператор отрицания имеет высокий приоритет, поэтому в последнем примере он применяется к условию в скобках. Таблицу приоритета операторов C++ можно посмотреть здесь.</p>
  <p>Операторы && и || ведут себя лениво: если первого аргумента уже достаточно для ответа, то второй аргумент вычисляться не будет. Например, в выражении condition1 && condition2 второе условие не вычисляется, если первое ложно. Это часто используют для проверок корректности:</p>
<pre>
int a, b;
// ...
if (a != 0 && b % a == 0) {
  // b делится на a
}
</pre>

  <h4>Сравнение чисел с плавающей точкой</h4>

  <p>Рассмотрим программу, которая проверяет равенство 0.1 + 0.2 == 0.3:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  double x = 0.1, y = 0.2;
  if (x + y == 0.3) {
    std::cout &lt;&lt; "EQUAL ";
  } else {
    std::cout &lt;&lt; "NOT EQUAL ";
  }

  std::cout &lt;&lt; x + y &lt;&lt; "\n";
}
</pre>
  <p>Логично было бы предположить, что программа выведет EQUAL 0.3, потому что 0.1 + 0.2 = 0.3. Однако программа напечатает NOT EQUAL 0.3. Данная «ошибка вычисления» встречается в большинстве современных языков программирования и обусловлена погрешностью представления этих чисел. Если повысить число знаков дробной части в выводе, мы увидим, что 0.1 + 0.2 == 0.30000000000000004. Подробнее об этом можно прочитать здесь и в этой статье.</p>
  <p>Поскольку операции над числами с плавающей точкой могут содержать погрешность, обычное сравнение через == некорректно. Поэтому правильнее сравнивать модуль разности величин с некой допустимой для нас погрешностью. Модуль дробного числа можно получить с помощью функции std::abs из заголовочного файла cmath. Исходную программу можно было бы переписать так:</p>
<pre>
#include &lt;cmath&gt;
#include &lt;iostream&gt;

int main() {
  double delta = 0.000001;

  double x = 0.1, y = 0.2;
  double sum = x + y;

  if (std::abs(sum - 0.3) &lt; delta) {
    std::cout &lt;&lt; "EQUAL ";
  } else {
    std::cout &lt;&lt; "NOT EQUAL ";
  }

  std::cout &lt;&lt; sum &lt;&lt; "\n";
}
</pre>
  <p>Теперь программа выведет EQUAL 0.3.</p>

  <h4>Оператор switch</h4>

  <p>Рассмотрим простейший калькулятор, считывающий число, затем знак арифметической операции, а затем другое число и печатающий результат. Напишем сначала программу с помощью if и else.</p>
<pre>
#include &lt;cstdint&gt;
#include &lt;iostream&gt;

int main() {
  int64_t a, b;
  char operation;
  std::cin >> a >> operation >> b;

  int64_t result = 0;
  if (operation == '+') {
    result = a + b;
  } else if (operation == '-') {
    result = a - b;
  } else if (operation == '*') {
    result = a * b;
  } else if (operation == '/' || operation == ':') {
    result = a / b;
  } else if (operation == '%') {  // остаток от деления
    result = a % b;
  }

  std::cout &lt;&lt; result &lt;&lt; "\n";
}
</pre>
  <p>Перепишем эту программу через оператор switch. Этот оператор следует рассматривать как условный прыжок на соответствующую метку в зависимости от значения выражения.</p>
<pre>
#include &lt;cstdint&gt;
#include &lt;iostream&gt;

int main() {
  int64_t a, b;
  char operation;
  std::cin >> a >> operation >> b;

  int64_t result;
  switch (operation) {
    case '+':
        result = a + b;
        break;  // если не написать этот break,
                // программа просто пойдёт дальше
                // в код следующего блока case
    case '-':
        result = a - b;
        break;
    case '*':
        result = a * b;
        break;
    case '/':
    case ':':
        result = a / b;
        break;
    case '%':
        result = a % b;
        break;
    default:  // здесь обрабатывается случай,
              // когда ни один case не сработал.
        result = 0;
  }

  std::cout &lt;&lt; result &lt;&lt; "\n";
}
</pre>
  <p>Выражения внутри скобок оператора switch и в блоках case должны быть простого целочисленного или символьного типа. В приведённой выше программе значение + относится к типу char. Использование сложных типов (например, строк) приведёт к ошибке компиляции:</p>
<pre>
int main() {
  std::string name;
  std::cin >> name;
  switch (name) {  // ошибка компиляции
    case "Alice":
        std::cout &lt;&lt; "Hello, Alice!\n";
        break;
  }
}
</pre>

  <h4>Оператор goto</h4>

  <p>Есть шутка, что оператор безусловного перехода goto — это ругательное слово из четырёх букв. Безусловные переходы ломают иерархичность программы, затрудняют чтение и отладку. Доказано, что любую программу можно переписать без оператора goto. Поэтому во многих современных языках goto отсутствует.</p>
  <p>Однако в C++ этот оператор есть по следующим причинам:</p>
  <ul>
    <li>обратная совместимость с языком С;</li>
    <li>удобный выход из вложенных циклов;</li>
    <li>применение в автосгенерированном коде (например, коде конечного автомата), не предназначенном для чтения человеком.</li>
  </ul>
  <p>Мы познакомимся с его синтаксисом, но дальше использовать нигде не будем — и вам не советуем.</p>
<pre>
int main() {
  again:  // метка — это произвольное имя с двоеточием

  std::cout &lt;&lt; "How old are you?\n";
  int age;
  std::cin >> age;

  if (age &lt; 0 || age >= 128) {
    std::cout &lt;&lt; "Wrong age...\n";
    // безусловный прыжок в место, помеченное меткой
    goto again;
  }

  std::cout &lt;&lt; "Your age is " &lt;&lt; age &lt;&lt; ".\n";

  // ...
}
</pre>
  <p>Здесь вводится метка again, на которую осуществляется переход, если возраст введён некорректно. Ниже мы покажем, как можно избавиться от оператора goto.</p>
  <p>С помощью оператора goto нельзя выйти из функции или зайти в неё, а также нельзя перепрыгнуть через объявления переменных (кроме тривиальных случаев):</p>
<pre>
#include &lt;iostream&gt;

int main() {
  goto label;
  int x = 42;
  label:  // ошибка компиляции!
  std::cout &lt;&lt; x &lt;&lt; "\n";
}
</pre>

  <h4>Цикл while</h4>

  <p>В C++ существует несколько видов циклов. Цикл while — это цикл с предусловием. Перед очередной итерацией проверяется условие, и если оно истинно, то цикл продолжается. Рассмотрим пример печати таблицы квадратов чисел от 1 до 10:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int n = 1;
  while (n &lt;= 10) {
    // выводим число и его квадрат через табуляцию
    std::cout &lt;&lt; n &lt;&lt; "\t" &lt;&lt; n * n &lt;&lt; "\n";
    ++n;
  }
}
</pre>
  <p>Здесь мы намеренно разделяем числа и их квадраты не пробелом, а знаком табуляции \t. В консоли такой вывод будет выглядеть выровненным по колонкам с фиксированной шириной:</p>
<pre>
1&#x9;1
2&#x9;4
3&#x9;9
4&#x9;16
5&#x9;25
6&#x9;36
7&#x9;49
8&#x9;64
9&#x9;81
10&#x9;100
</pre>

  <h4>Цикл do-while</h4>

  <p>Это цикл с постусловием. Отличие от цикла while заключается в том, что первая итерация всегда выполняется безусловно. Только после её завершения проверяется условие цикла. Если оно истинно, то цикл продолжается.</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int n = 1;
  do {
    std::cout &lt;&lt; n &lt;&lt; "\t" &lt;&lt; n * n &lt;&lt; "\n";
    ++n;
  } while (n &lt;= 10);
}
</pre>
  <p>Без особых причин пользоваться этим видом циклов не стоит, старайтесь использовать циклы while или for.</p>

  <h4>Цикл for</h4>

  <p>Цикл for — самый гибкий. Он записывается так:</p>
<pre>
for (initialization; condition; action) {
  // тело цикла
}
</pre>
  <p>Как правило, с циклом ассоциируется некоторый параметр, который меняется от итерации к итерации, а цикл выполняется до тех пор, пока некоторое условие на этот параметр истинно.</p>

  <p>Начальное значение такого параметра можно задать в разделе initialization, условие — в condition, а действие над параметром, выполняющееся после каждой итерации, — в action.</p>

  <p>Напечатаем таблицу квадратов через цикл for:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  for (int i = 1; i &lt;= 10; ++i) {
    std::cout &lt;&lt; i &lt;&lt; "\t" &lt;&lt; i * i &lt;&lt; "\n";
  }
}
</pre>
  <p>Напомним, что ++i — традиционная краткая форма записи для выражения i = i + 1.</p>
  <p>Цикл for эквивалентен такому циклу while:</p>
<pre>
{
  initialization;
  while (condition) {
    // тело цикла
    action;
  }
}
</pre>

  <h4>Цикл range-based for</h4>

  <p>Этот цикл применим к контейнерам разной природы (массивам, векторам, спискам и т. д.), с которыми мы познакомимся позже. Пока рассмотрим его на примере строк. Цикл позволяет удобно проитерироваться по символам строки, не используя индексов. В этом примере мы считываем строку и печатаем отдельно все символы строки и их ASCII-коды:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string line;
  std::getline(std::cin, line);
  for (char symbol : line) {
    std::cout &lt;&lt; symbol &lt;&lt; "\t"
    &lt;&lt; static_cast&lt;int&gt;(symbol) &lt;&lt; "\n";
  }
}
</pre>
  <p>Здесь оператор static_cast преобразует символ к числовому типу int, чтобы получить его код. Результат для строки Hello, world! выглядит так:</p>
<pre>
H	72
e	101
l	108
l	108
o	111
,	44
 	32
w	119
o	111
r	114
l	108
d	100
!	33
</pre>
  <p>Обратите внимание, что std::string хранит внутри байты. Если вы вводите символы русского алфавита и у вас используется кодировка UTF-8, ставшая де-факто стандартом, то эти символы будут кодироваться парами байтов. И при такой итерации вы увидите отдельные байты, а не символы.</p>

  <h4>Вложенные циклы</h4>

  <p>Циклы могут быть вложенными. Напечатаем таблицу умножения:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  for (int i = 1; i &lt;= 10; ++i) {
    for (int j = 1; j &lt;= 10; ++j) {
      std::cout &lt;&lt; i * j &lt;&lt; "\t";
    }
    std::cout &lt;&lt; "\n";
  }
}
</pre>
  <p>Результат:</p>
<pre>
  1	   2	 3	 4	 5	 6	 7	 8	 9	10
  2	   4	 6	 8	10	12	14	16	18	20
  3	   6	 9	12	15	18	21	24	27	30
  4	   8	12	16	20	24	28	32	36	40
  5	  10	15	20	25	30	35	40	45	50
  6   12	18	24	30	36	42	48	54	60
  7	  14	21	28	35	42	49	56	63	70
  8	  16	24	32	40	48	56	64	72	80
  9	  18	27	36	45	54	63	72	81	90
  10  20	30	40	50	60	70	80	90	100
</pre>

  <h4>Операторы break и continue</h4>

  <p>Оператор break досрочно заканчивает текущий цикл. Оператор continue прыгает в самый конец тела цикла и, если условие цикла позволяет, переходит на следующую итерацию.</p>
  <p>Типичный пример использования оператора break — выход из формально бесконечного цикла:</p>
<pre>
while (true) {
  // ...
  if (condition) {
    break;
  }
  // ...
}
</pre>
  <p>Кстати, рассмотрим другие способы записать бесконечный цикл.</p>
  <p>Через цикл do-while:</p>
<pre>
do {
  // ...
} while (true);
</pre>
  <p>Через цикл for:</p>
<pre>
for (;;) {
  // ...
}
</pre>
  <p>Напишем программу, которая считывает числа с клавиатуры до тех пор, пока пользователь не введёт ноль, а затем печатает их сумму:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int sum = 0;
  while (true) {
    int x;
    std::cin >> x;
    if (x == 0) {
      break;
    }
    sum += x;
  }
  std::cout &lt;&lt; sum &lt;&lt; "\n";
}
</pre>
  <p>(Здесь, конечно, неявно предполагается, что и сами числа, и результат суммирования помещаются в тип int, и в ходе вычислений не происходит переполнений.)</p>

  <h4>Считывание до конца ввода</h4>

  <p>В предыдущем примере мы считывали числа до тех пор, пока на вход не поступит ноль. Это не очень удобно. Предположим, что вместо ввода с клавиатуры мы читали бы эти числа из файла. Это легко сделать, перенаправив файл на стандартный ввод при запуске программы из консоли:</p>
  <code>./a.out &lt; input.txt</code>
  <p>Следующий цикл считывает числа до тех пор, пока поступающие данные не закончатся:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int sum = 0;
  int x;
  while (std::cin >> x) {
    sum += x;
  }
  std::cout &lt;&lt; sum &lt;&lt; "\n";
}
</pre>
  <p>Здесь вместо условия цикла подставлено выражение std::cin >> x. Кроме считывания x это выражение преобразуется к логическому типу, показывающему, есть ли ещё данные в потоке ввода.</p>
  <p>При вводе данных не из файла, а с клавиатуры можно сымитировать конец ввода комбинацией клавиш Ctrl+D в Linux и macOS или Ctrl+Z в Windows.</p>
  <p>Аналогично можно прочитать строки до конца ввода с помощью std::getline:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string name;
  while (std::getline(std::cin, name)) {
    std::cout &lt;&lt; "Hello, " &lt;&lt; name &lt;&lt; "!\n";
  }
}
</pre>
</article>


<!-- 2.4 Векторы и строки -->
<article class="article">
  <div class="anchor" id="p2.4"></div>
  <h3>2.4 Векторы и строки</h3>

  <p>Вектор (std::vector) и строка (std::string) — это важные базовые контейнеры стандартной библиотеки C++. Они хранят свои элементы в непрерывном фрагменте памяти. Оба этих контейнера предоставляют доступ к элементам по индексу и позволяют эффективно добавлять новые элементы в конец.</p>

  <h4>Контейнер std::vector</h4>

  <p>В стандартной библиотеке C++ вектором (std::vector) называется динамический массив, обеспечивающий быстрое добавление новых элементов в конец и меняющий свой размер при необходимости. Вектор гарантирует отсутствие утечек памяти (об этом мы поговорим в других параграфах, сейчас просто считайте, что это хорошо).</p>

  <p>Для работы с вектором нужно подключить заголовочный файл vector.</p>

  <p>Элементы вектора должны быть одинакового типа, и этот тип должен быть известен при компиляции программы. Он задаётся в угловых скобках после std::vector: например, std::vector&lt;int&gt; — это вектор целых чисел типа int, а std::vector&lt;std::string&gt; — вектор строк.</p>

  <p>Само имя std::vector не является типом данных: это шаблон, в который требуется подставить нужные параметры (тип элемента), чтобы получился конкретный тип данных. Подробнее о том, что такое шаблоны и как их применять, мы расскажем в параграфе «Шаблоны».</p>

  <p>Рассмотрим пример программы, которая заполняет вектор элементами и печатает их через пробел:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; data = {1, 2, 3, 4, 5};
  for (int elem : data) {
    std::cout &lt;&lt; elem &lt;&lt; " ";
  }
  std::cout &lt;&lt; "\n";
}
</pre>
  <p>Здесь мы инициализируем вектор через список инициализации, в котором элементы перечислены через запятую. Другой способ инициализации вектора — указать число элементов и (при необходимости) образец элемента:</p>
<pre>
#include &lt;string&gt;
#include &lt;vector&gt;

int main() {
  // пустой вектор строк
  std::vector&lt;std::string&gt; v1;
  // вектор из пяти пустых строк
  std::vector&lt;std::string&gt; v2(5);
  // вектор из пяти строк "hello"
  std::vector&lt;std::string&gt; v3(5, "hello");
}
</pre>

  <h4>Обращение к элементам</h4>

  <p>Выше мы использовали для печати элементов вектора цикл range-for. Но иногда удобнее работать с индексами. Вектор хранит элементы в памяти последовательно, поэтому по индексу элемента можно быстро найти его положение в памяти. Индексация начинается с нуля:</p>
<pre>
std::vector&lt;int&gt; data = {1, 2, 3, 4, 5};
// начальный элемент вектора
int a = data[0];
// последний элемент вектора (в нём пять элементов)
int b = data[4];
// меняем элемент 3 на -3
data[2] = -3;
</pre>
  <p>Чтобы узнать общее количество элементов в векторе, можно воспользоваться функцией size:</p>
  <code>std::cout &lt;&lt; data.size() &lt;&lt; "\n";</code>
  <p>Отрицательные индексы, как в некоторых других языках программирования, не допускаются.</p>
  <p>Обратите внимание: когда мы обращаемся по индексу через квадратные скобки, проверки его корректности не происходит. Это ещё одно проявление принципа «мы не должны платить за то, что не используем».</p>
  <p>Встроенные валидаторы замедляют программу: предполагается, что программист пишет правильный код и уверен, что индекс i в выражении data[i] неотрицателен и удовлетворяет условию i &lt; data.size(). В этом случае они ему не нужны.</p>
  <p>Если всё же обратиться к вектору по некорректному индексу, то программа во время выполнения попадёт в неопределённое поведение: фактически она попробует прочитать память, не принадлежащую вектору.</p>
  <p>Если вам не хочется делать много лишних проверок, а в корректности индекса вы не уверены, то можно использовать функцию at:</p>
<pre>
std::vector&lt;int&gt; data = {1, 2, 3, 4, 5};
// неопределённое поведение: может произойти всё что угодно
std::cout &lt;&lt; data[42] &lt;&lt; "\n";
// напечатается 1
std::cout &lt;&lt; data.at(0) &lt;&lt; "\n";
// произойдёт исключение std::out_of_range
// его можно будет перехватить и обработать
std::cout &lt;&lt; data.at(42) &lt;&lt; "\n";
</pre>
  <p>Про работу с исключениями мы поговорим отдельно в параграфе «Обработка исключений».</p>
  <p>Рассмотрим функции вектора front и back, которые возвращают его первый и последний элемент без использования индексов:</p>
<pre>
std::vector&lt;int&gt; data = {1, 2, 3, 4, 5};
// то же, что data[0]
std::cout &lt;&lt; data.front() &lt;&lt; "\n";
// то же, что data[data.size() - 1]
std::cout &lt;&lt; data.back() &lt;&lt; "\n";
</pre>
  <p>Важно учитывать, что вызов этих функций на пустом векторе приведёт к неопределённому поведению.</p>
  <p>Для проверки вектора на пустоту вместо сравнения data.size() == 0 принято использовать функцию empty, которая возвращает логическое значение:</p>
<pre>
if (!data.empty()) {
  // вектор не пуст, с ним можно работать
}
</pre>

  <h4>Итерация по индексам</h4>

  <p>Так сложилось, что в стандартной библиотеке индексы и размеры контейнеров имеют беззнаковый тип. Вместо unsigned int или unsigned long int для него используется традиционный псевдоним size_t (а точнее, std::vector&lt;T&gt;::size_type). Тип size_t на самом деле совпадает с uint32_t или uint64_t в зависимости от битности платформы. Его использование в программе дополнительно подчёркивает, что мы имеем дело с индексами или с размером.</p>

  <p>Итерацию по элементам data с помощью индексов можно записать так:</p>
<pre>
for (size_t i = 0; i != data.size(); ++i) {
  std::cout &lt;&lt; data[i] &lt;&lt; " ";
}
</pre>
  <p>Это каноническая форма записи такого цикла: в ней принято использовать сравнение != и префиксный ++i. Для целых чисел не будет разницы, если написать это как-то иначе (например, через &lt; и постфиксный i++), но потом, когда вы будете писать аналогичные циклы для итераторов других контейнеров, разница появится. Давайте привыкнем всегда оформлять цикл по индексам так.</p>
  <p>Беззнаковость типа возвращаемого значения функции size порождает следующую проблему. По правилам, унаследованным ещё от языка C, результат арифметических действий над беззнаковым и знаковым типами приводится к беззнаковому типу. Поэтому выражение data.size() - 1, например, тоже будет беззнаковым. Если data.size() окажется нулём, то такое выражение будет вовсе не минус единицей, а самым большим беззнаковым целым (для 64-битной платформы это 2<sup>64</sup>-1).</p>
  <p>Рассмотрим следующий ошибочный код, который проверяет, есть ли в векторе дубликаты, идущие подряд:</p>
<pre>
// итерация по всем элементам, кроме последнего:
for (size_t i = 0; i &lt; data.size() - 1; ++i) {
  if (data[i] == data[i + 1]) {
    std::cout &lt;&lt; "Duplicate value: " &lt;&lt; data[i] &lt;&lt; "\n";
  }
}
</pre>
  <p>Эта программа будет некорректно работать на пустом векторе. Условие i &lt; data.size() - 1 на первой итерации окажется истинным, и произойдёт обращение к элементам пустого вектора. Правильнее было бы переписать это условие через i + 1 &lt; data.size() или воспользоваться внешней функцией std::ssize, которая появилась в C++20. Она возвращает знаковый размер вектора:</p>
<pre>
for (std::int64_t i = 0; i &lt; std::ssize(data) - 1; ++i) {
  if (data[i] == data[i + 1]) {
    std::cout &lt;&lt; "Duplicate value: " &lt;&lt; data[i] &lt;&lt; "\n";
  }
}
</pre>

  <h4>Добавление и удаление элементов</h4>

  <p>В вектор можно эффективно добавлять элементы в конец и удалять их с конца. Для этого существуют функции push_back и pop_back. Рассмотрим программу, считывающую числа с клавиатуры в вектор и затем удаляющую все нули в конце:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  int x;
  std::vector&lt;int> data;

  // читаем числа, пока не закончится ввод
  while (std::cin >> x) {
    // добавляем очередное число в вектор
    data.push_back(x);
  }

  // Пока вектор не пуст и последний элемент равен нулю
  while (!data.empty() && data.back() == 0) {
    // удаляем этот нулевой элемент
    data.pop_back();
  }
}
</pre>
  <p>Добавление элементов в другие части вектора или их удаление неэффективно, так как требует сдвига соседних элементов. Поэтому отдельных функций, например, для добавления или удаления элементов из начала у вектора нет. Это можно сделать с помощью общих функций insert/erase и итераторов. Мы рассмотрим такие примеры позже.</p>
  <p>Удалить все элементы из вектора можно с помощью функции clear.</p>

  <h4>Резерв памяти</h4>
  <p>Вектор хранит элементы в памяти в виде непрерывной последовательности, друг за другом. При этом в конце последовательности резервируется дополнительное место для быстрого добавления новых элементов. Когда этот резерв заканчивается, при вставке очередного элемента происходит реаллокация: элементы вектора копируются в новый, более просторный блок памяти.</p>
  <p>Реаллокация — довольно дорогая процедура, но если она происходит достаточно редко, то её влияние незначительно. Можно доказать, что если размер нового блока выбирать в два раза больше предыдущего размера, то амортизационная сложность добавления элемента будет константной.</p>
  <p>Текущий резерв вектора можно узнать с помощью функции capacity (не путайте её с функцией size).</p>
  <p>Рассмотрим программу, в которой в вектор последовательно добавляются элементы и после каждого шага печатается размер и резерв:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; data = {1, 2};
  std::cout &lt;&lt; data.size() &lt;&lt; "\t" &lt;&lt; data.capacity() &lt;&lt; "\n";

  data.push_back(3);
  std::cout &lt;&lt; data.size() &lt;&lt; "\t" &lt;&lt; data.capacity() &lt;&lt; "\n";

  data.push_back(4);
  std::cout &lt;&lt; data.size() &lt;&lt; "\t" &lt;&lt; data.capacity() &lt;&lt; "\n";

  data.push_back(5);
  std::cout &lt;&lt; data.size() &lt;&lt; "\t" &lt;&lt; data.capacity() &lt;&lt; "\n";
}
</pre>
  <p>Вот вывод этой программы:</p>
<pre>
2	2
3	4
4	4
5	8
</pre>
  <p>Видно, что размер вектора увеличивается на единицу, а резерв удваивается после исчерпания. Так, при добавлении четвёрки используется имеющаяся в резерве память, а при добавлении тройки и пятёрки происходит реаллокация.</p>
<pre>
vector&lt;int&gt; data = {1, 2, 3, 4};
data.push_back(5);
</pre>
  <p>Иногда требуется заполнить вектор элементами, причём число элементов известно заранее. В таком случае можно сразу зарезервировать нужный размер памяти с помощью функции reserve, чтобы при добавлении элементов не происходили реаллокации. Пусть, например, нам сначала задаётся число слов, а потом сами эти слова, и нам требуется сложить их в вектор:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;std::string&gt; words;

  size_t words_count;
  std::cin >> words_count;

  // Размер вектора остаётся нулевым, меняется только резерв:
  words.reserve(words_count);

  for (size_t i = 0; i != words_count; ++i) {
    std::string word;
    std::cin >> word;
    // Все добавления будут дешёвыми, без реаллокаций:
    words.push_back(word);
  }
}
</pre>
  <p>Если передать в reserve величину меньше текущего резерва, то ничего не поменяется — резерв останется прежним.</p>
  <p>Функцию reserve не следует путать с функцией resize, которая меняет количество элементов в векторе. Если аргумент функции resize меньше текущего размера, то лишние элементы в конце вектора удаляются. Если же он больше текущего размера, то при необходимости происходит реаллокация и в вектор добавляются новые элементы с дефолтным значением данного типа.</p>
<pre>
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; data = {1, 2, 3, 4, 5};

  // поменяли резерв, но размер вектора остался равным пяти
  data.reserve(10);

  data.resize(3);  // удалили последние элементы 4 и 5
  data.resize(6);  // получили вектор 1, 2, 3, 0, 0, 0
}
</pre>

  <h4>Многомерные векторы</h4>

  <p>Воспользуемся вектором векторов, чтобы сохранить матрицу (таблицу) целых чисел. Пусть на вход программы сначала поступают число строк и число столбцов матрицы, а потом — сами элементы построчно:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  size_t m, n;
  std::cin >> m >> n;  // число строк и столбцов

  // создаём матрицу matrix из m строк, каждая из которых — вектор из n нулей
  std::vector&lt;std::vector&lt;int&gt; &gt; matrix(m, std::vector&lt;int&gt;(n));

  for (size_t i = 0; i != m; ++i) {
    for (size_t j = 0; j != n; ++j) {
      std::cin >> matrix[i][j];
    }
  }

  // напечатаем матрицу, выводя элементы через табуляцию
  for (size_t i = 0; i != m; ++i) {
    for (size_t j = 0; j != n; ++j) {
      std::cout &lt;&lt; matrix[i][j] &lt;&lt; "\t";
    }
    std::cout &lt;&lt; "\n";
  }
}
</pre>
  <p>В этом примере мы заранее создали матрицу из нулей, а потом просто меняли её элементы.</p>

  <h4>Сортировка вектора</h4>

  <p>Рассмотрим типичную задачу — отсортировать вектор по возрастанию. Для этого в стандартной библиотеке в заголовочном файле algorithm есть готовая функция sort. Гарантируется, что сложность её работы в худшем случае составляет O(nlogn), где n — число элементов в векторе. Типичные реализации используют алгоритм сортировки Introsort.</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; data = {3, 1, 4, 1, 5, 9, 2, 6};

  // Сортировка диапазона вектора от начала до конца
  std::sort(data.begin(), data.end());

  // получим вектор 1, 1, 2, 3, 4, 5, 6, 9
}
</pre>
  <p>В функцию sort передаются так называемые итераторы, ограничивающие рассматриваемый диапазон. В нашем случае мы передаём диапазон, совпадающий со всем вектором, от начала до конца. Соответствующие итераторы возвращают функции begin и end (не путать с front и back!). Итераторы можно считать обобщёнными индексами (но они могут быть и у контейнеров, не допускающих обычную индексацию). Подробнее про итераторы мы поговорим в отдельном параграфе.</p>
  <p>Для сортировки по убыванию можно передать на вход обратные итераторы rbegin() и rend(), представляющие элементы вектора в перевёрнутом порядке:</p>
<pre>
std::sort(data.rbegin(), data.rend());
// 9, 6, 5, 4, 3, 2, 1, 1
</pre>
  <p>В C++20 доступен более элегантный способ сортировки через std::ranges::sort:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; data = {3, 1, 4, 1, 5, 9, 2, 6};
  // можно передать сам вектор, а не его диапазоны
  std::ranges::sort(data);
}
</pre>
  <p>Для сортировки по умолчанию используется сравнение элементов с помощью оператора &lt;. Этот оператор работает и для самих векторов: они сравниваются лексикографически. Поэтому можно без проблем отсортировать, например, строки в матрице (векторе векторов целых чисел).</p>

  <h4>Строки</h4>

  <p>Контейнер std::string можно рассматривать как особый случай вектора символов std::vector&lt;char&gt;, имеющий набор дополнительных функций. В частности, у строки есть все те же рассмотренные нами функции, что и у вектора (например, pop_back или resize). Рассмотрим некоторые специфические функции строки:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string s = "Some string";

  // приписывание символов и строк
  // добавляем отдельный символ в конец, это аналог push_back
  s += ' ';
  s += "functions";  // добавляем строку в конец
  std::cout &lt;&lt; s &lt;&lt; "\n";  // Some string functions

  // выделение подстроки
  // подстрока "string" из 6 символов начиная с 5-й позиции
  std::string sub1 = s.substr(5, 6);
  // подстрока "functions" с 12-й позиции и до конца
  std::string sub2 = s.substr(12);

  // поиск символа или подстроки
  // позиция первого пробела, в данном случае 4
  size_t pos1 = s.find(' ');
  // позиция следующего пробела (11)
  size_t pos2 = s.find(' ', pos1 + 1);
  // вернётся 5
  size_t pos3 = s.find("str");
  вернётся std::string::npos
  size_t pos4 = s.find("#");  //
}
</pre>

  <p>Вставку, замену и удаление подстрок можно сделать через указание индекса начала и длины подстроки:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string s = "Some string functions";

  // вставка подстроки
  s.insert(5, "std::");
  std::cout &lt;&lt; s &lt;&lt; "\n";  // Some std::string functions

  // замена указанного диапазона на новую подстроку
  s.replace(0, 4, "Special");
  std::cout &lt;&lt; s &lt;&lt; "\n";  // Special std::string functions

  // удаление подстроки
  s.erase(8, 5);  // Special string functions
}
</pre>
  <p>Аналогичные действия для других контейнеров (например, для того же вектора) можно сделать через итераторы. Мы рассмотрим такие примеры в одном из следующих параграфов.</p>
  <p>В C++20 появились удобные функции starts_with и ends_with для проверки префикса или суффикса строк:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string phrase;
  std::getline(std::cin, phrase);

  if (phrase.starts_with("hello")) {
    std::cout &lt;&lt; "Greeting\n";
  }

  if (phrase.ends_with("bye")) {
    std::cout &lt;&lt; "Farewell\n";
  }
}
</pre>
</article>


<!-- 2.5 Составные типы данных -->
<article class="article">
  <div class="anchor" id="p2.5"></div>
  <h3>2.5 Составные типы данных</h3>

  <p>C++ позволяет конструировать новые типы данных на основе базовых типов. В этом параграфе мы познакомимся с перечислениями и структурами, а также рассмотрим конструкции std::pair и std::tuple из стандартной библиотеки.</p>

  <h4>Перечисления</h4>

  <p>Предположим, что мы пишем программу для обработки изображений и хотим работать с цветами. Для каждого цвета заводить отдельную константу не очень удобно. Воспользуемся перечислением — специальным типом данных, который состоит из конечного набора именованных констант:</p>
<pre>
enum class Color {
  White,
  Red,
  Orange,
  Blue,
};
</pre>
  <p>Мы описали новый тип данных Color с четырьмя допустимыми значениями. Теперь к каждому цвету можно обращаться через префикс Color:::</p>
<pre>
int main() {
  Color color1 = Color::Red;
  Color color2 = Color::Blue;
}
</pre>
  <p>Фактически перечисления — это удобный способ описывать однотипные именованные константы. По умолчанию перечисления хранятся как тип int, а их значения последовательно нумеруются с нуля. И тип, и конкретное значение можно поменять.</p>
  <p>Преобразовать перечисление в число и обратно можно с помощью оператора static_cast:</p>
<pre>
int value = static_cast&lt;int&gt;(color2);  // 3
Color color3 = static_cast&lt;Color&gt;(2);  // Color::Orange
</pre>
  <p>Раньше в C++ перечисления объявлялись вот так, без слова class:</p>
<pre>
enum Color {
  White,
  Red,
  Orange,
  Blue,
};

// можно даже без названия
enum {
  Apple,
  Orange,
  Banana
};
</pre>
  <p>Этот способ остался в языке. Но в таком случае все имена внутри перечислений являются глобальными, и могут происходить конфликты имён (Orange в примере). Такая программа просто не скомпилируется.</p>

  <h4>Структуры</h4>

  <p>Часто хочется собрать «под одной крышей» несколько переменных. В таких случаях можно использовать структуры. Например, давайте опишем структуру точек из трёхмерного пространства:</p>
<pre>
struct Point {
  double x = 0.0;
  double y = 0.0;
  double z = 0.0;
  Color color;  // пусть у нас будет цветная точка
};
</pre>
  <p>В данном случае мы описали новый тип данных — Point, который содержит в себе четыре переменные.</p>
  <p>Давайте поработаем с этой структурой:</p>
<pre>
int main() {
  // по умолчанию координаты будут нулевыми,
  // а color никак не будет проинициализирован
  Point point1;
  point1.color = Color::Blue;

  Point point2 = {1.4, -2.2, -3.98, Color::Red};
  // x = 1.4, y = -2.2, z = -3.98, color = Color::Red

  // обращаться к полям можно через точку
  point2.z = 32;
  // и вообще работать с ними как с обычными переменными
  point2.x += 2;
}
</pre>
  <p>В С++20 появилась новая форма инициализации структур — designated initializers:</p>
<pre>
int main() {
  Point point3 = {.x = 1.4, .y = -2.2, .z = -3.98};
  Point point4 = {.color = Color::Orange};
}
</pre>
  <p>Такой способ записи понятнее: сразу видно, какое поле структуры каким значением инициализируется. Важно, что поля должны быть перечислены в том же порядке, в каком они указываются при описании структуры (причину этого мы узнаем в параграфе про конструкторы и жизненный цикл объекта). Пропущенные поля будут инициализироваться значением по умолчанию. Так, point3.color будет равно Color::White — нулевому значению перечисления Color.</p>

  <h4>Выравнивание</h4>

  <p>Теперь давайте поговорим про размеры перечислений и структур:</p>
<pre>
int main() {
  std::cout &lt;&lt; sizeof(double) &lt;&lt; "\n";  // 8
  std::cout &lt;&lt; sizeof(Color) &lt;&lt; "\n";   // 4 (фактически это int)
  std::cout &lt;&lt; sizeof(Point) &lt;&lt; "\n";   // 32
}
</pre>
  <p>Получается, что размер структуры Point (32 байта) не равен сумме размеров её частей (8 + 8 + 8 + 4 = 28). Всё дело в выравнивании: компилятору не очень удобно работать со структурой в 28 байт при условии, что внутри этой структуры есть переменные, размер которых — 8 байт (так как 28 не кратно 8). Поэтому компилятор резервирует за структурой несколько лишних байтов (в нашем случае — 4).</p>
  <p>Можно явно попросить компилятор не выделять мнимых байтов, но в таком случае пострадает скорость — потому что если данные в памяти выровнены, то их легче достать и проще обрабатывать.</p>

  <h4>Кортежи и пары</h4>

  <p>В заголовочном файле utility есть шаблонная структура std::pair с полями first и second. Из названия просто догадаться, что она хранит два объекта:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;utility&gt;

int main() {
  // в угловых скобках нужно указывать два типа:
  std::pair&lt;int, double&gt; p = {42, 3.14};

  // обращаться к полям можно через .first и .second:
  std::cout &lt;&lt; p.first &lt;&lt; "\n";  // 42
  std::cout &lt;&lt; p.second &lt;&lt; "\n"; // 3.14
}
</pre>
  <p>Однако у std::pair есть проблема — её поля обезличены, и не очень ясно, какую смысловую нагрузку несёт first, а какую — second. Из-за этого мы советуем не злоупотреблять данной структурой, кроме случаев, когда она используется в функциях стандартной библиотеки.</p>
  <p>Обобщением пары на несколько переменных является кортеж — std::tuple, объявленный в заголовочном файле tuple:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;tuple&gt;

struct Point;  // определена выше

int main() {
  std::tuple&lt;int, double, Point&gt; t = {42, 3.14, {.color = Color::Orange}};

  // тут уже нет полей .first и .second,
  // но есть стандартная функция std::get&lt;&gt;,
  // которая принимает в угловых скобках
  // индекс элемента (индексация с нуля):
  std::cout &lt;&lt; std::get&lt;0&gt;(t) &lt;&lt; "\n";   // 42
  std::cout &lt;&lt; std::get&lt;1&gt;(t) &lt;&lt; "\n";   // 3.14
  std::cout &lt;&lt; std::get&lt;2&gt;(t).x &lt;&lt; "\n"; // 0.0

  // вызов std::get может появляться и слева от присваивания:
  std::get&lt;2&gt;(t).color = Color::Red;
}
</pre>
  <p>Важно понимать, что типы элементов пары или кортежа, а также размер кортежа фиксируются на этапе компиляции.</p>
  <p>Пару, кортеж или структуру можно «распаковать» с помощью structured binding.</p>
<pre>
#include &lt;string&gt;
#include &lt;utility&gt;

int main() {
  std::pair&lt;std::string, int&gt; p = {"hello", 42};
  auto [word, freq] = p;  // word = "hello"; freq = 42;
}
</pre>
  <p>Здесь конструкция auto [word, freq] = p вводит две новые переменные word и freq соответствующих типов и присваивает им значения из пары.</p>
</article>


<!-- 2.6 Ссылки, указатели, константность -->
<article class="article">
  <div class="anchor" id="p2.6"></div>
  <h3>2.6 Ссылки, указатели, константность</h3>

  <p>Ссылки позволяют вводить псевдонимы для переменных. Указатели — это самостоятельные типы данных, которые могут хранить адреса других переменных в памяти. Ключевое слово const позволяет подчеркнуть, что переменная используется только для чтения. Часто оно используется совместно с объявлением ссылок и указателей.</p>

  <h4>Копии переменных</h4>

  <p>Для начала давайте рассмотрим такой фрагмент кода:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string s1 = "Elementary, my dear Watson!";
  std::string s2 = s1;

  s1.clear();  // s2 никак не изменится

  std::cout &lt;&lt; s1 &lt;&lt; "\n";  // пустая строка
  std::cout &lt;&lt; s2 &lt;&lt; "\n";  // Elementary, my dear Watson!
}
</pre>
  <p>Важно понимать, что здесь s2 будет совершенно новой строкой, которая проинициализирована значением s1, но более никак с s1 не связана. Это отличает С++ от некоторых других языков программирования — например, языка Python. В них после аналогичного присваивания строка осталась бы той же самой.</p>
  <p>Создание новой строки s2 требует ресурсов: нужно выделить новый блок памяти и скопировать туда старую строку.</p>

  <h4>Ссылки</h4>
  <p>Впрочем, в C++ есть возможность обращаться к уже существующему в памяти объекту под другим именем. Рассмотрим это на примере целых чисел:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int x = 42;
  int& ref = x;  // ссылка на x

  ++x;
  std::cout &lt;&lt; ref &lt;&lt; "\n";  // 43
}
</pre>
  <p>Здесь ref — псевдоним для x. Это не самостоятельная переменная, а просто ссылка на объект, уже живущий в памяти. Формально типом ref является int& — ссылка на int.</p>
  <p>Аналогично для строк:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string s1 = "Elementary, my dear Watson!";
  std::string& s2 = s1;  // тут ссылка!

  s1.clear();

  std::cout &lt;&lt; s2.size() &lt;&lt; "\n";  // напечатает 0
}
</pre>
  <p>Ссылка должна быть проинициализирована сразу в момент объявления. Например, так написать нельзя:</p>
<pre>
int main() {
  int my_variable = 42;
  int& ref;  // ошибка!
  // ...
  ref = my_variable;
}
</pre>
  <p>Ссылка привязана к одному и тому же объекту со своего рождения. Переназначить её нельзя:</p>
<pre>
int main() {
  int x = 42, y = 13;
  int& ref = x;  // OK
  ref = y;
  // ссылка останется привязанной к x,
  // значение x поменяется
}
</pre>
  <p>Ссылки удобны там, где исходное имя слишком громоздко (например, является вложенным полем какой-либо структуры).</p>

  <h4>Указатели</h4>
  <p>Другой (более базовый) способ сослаться на что-то уже существующее в памяти — указатели. Это специальные типы данных, которые могут хранить адрес какой-либо другой переменной в памяти. Здесь мы можем представлять себе память как длинную ленту с пронумерованными ячейками (байтами). Сам адрес переменной можно получить с помощью унарного оператора &:</p>
<pre>
int main() {
  int x = 42;
  // сохраняем адрес в памяти переменной x в указатель ptr
  int* ptr = &x;

  ++x;  // увеличим x на единицу
  std::cout &lt;&lt; *ptr &lt;&lt; "\n";  // 43
}
</pre>
  <p>Формально указатель — это не номер ячейки памяти, а отдельный тип. Но обычно он может быть преобразован к целому числу. Вот такой код напечатает адреса переменных в шестнадцатеричном виде:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int x = 1, y = 2, z = 3;
  std::cout &lt;&lt; &x &lt;&lt; "\n";
  std::cout &lt;&lt; &y &lt;&lt; "\n";
  std::cout &lt;&lt; &z &lt;&lt; "\n";
}
</pre>
  <p>Пример вывода:</p>
<pre>
0x7ffdfee3188c
0x7ffdfee31888
0x7ffdfee31884
</pre>
  <p>Можно заметить, что адреса будут идти «рядом» с шагом sizeof(int) по возрастанию или убыванию — это зависит от платформы и компилятора. Но при повторном запуске программы они могут отличаться, так как программе может быть назначен совсем другой сегмент памяти.</p>
  <p>Кроме адреса ячейки памяти переменная-указатель обладает ещё и типом данных, значение которого в этой ячейке лежит. Это позволяет компилятору правильно интерпретировать обращение к памяти по этому адресу. Поэтому мы используем не какой-либо абстрактный тип «указатель», а именно «указатель на int».</p>
  <p>Оператор разыменования (унарная звёздочка) противоположен оператору взятия адреса (унарному амперсанду). Сравните: &x — это адрес x в памяти, а *ptr — это значение, живущее по адресу, записанному в ptr.</p>
  <p>Указатели, в отличие от ссылок, можно переназначать. Кроме того, есть выделенное значение никуда не ссылающегося указателя — nullptr («нулевой» указатель):</p>
<pre>
#include <iostream>

int main() {
  int x = 42, y = 13;
  // по умолчанию не инициализируется, тут лежит «случайный» адрес
  int* ptr;
  ptr = nullptr;  // «нулевой» указатель
  ptr = &x;  // теперь в ptr лежит адрес переменной x
  std::cout &lt;&lt; *ptr &lt;&lt; "\n";  // 42
  ptr = &y;  // можно поменять адрес, записанный в ptr
  std::cout &lt;&lt; *ptr &lt;&lt; "\n";  // 13
}
</pre>
  <p>Указатель nullptr нельзя разыменовывать: это приведёт к неопределённому поведению.</p>
  <p>Часто указатели используются вместе с динамическим выделением памяти (malloc/new). Мы познакомимся с динамической памятью в параграфе «Жизненный цикл объекта». А сейчас лишь стоит заметить, что указатель сам по себе совершенно не означает, что память, на которую он ссылается, была выделена динамически. Например, во всех примерах выше указатель ссылался на обычную переменную на стеке.</p>
  <p>Отдельно рассмотрим <strong>указатели на структуру</strong>. Для обращения к полям структуры через указатель есть отдельный оператор ->:</p>
<pre>
#include &lt;iostream&gt;

struct Point {
  double x, y, z;
};

int main() {
  Point p = {3.0, 4.0, 5.0};

  Point* ptr = &p;

  // обращение через * и . требует скобок
  std::cout &lt;&lt; (*ptr).x &lt;&lt; "\n";
  // то же самое, но чуть короче
  std::cout &lt;&lt; ptr->x &lt;&lt; "\n";
}
</pre>

  <h4>Константность</h4>

  <p>Константа — это переменная, предназначенная только для чтения. Её значение должно быть зафиксировано в момент присваивания. При этом оно не обязательно должно быть известно в момент компиляции:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  // эта константа известна в compile time
  const int c1 = 42;

  int x;
  std::cin >> x;
  // значение становится известным только в runtime
  const int c2 = 2 * x;

  // ошибка компиляции: константе нельзя присвоить новое значение
  с2 = 0;
}
</pre>
  <p>У константного вектора или строки нельзя будет вызвать функции, которые их будут изменять:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  const std::vector&lt;int&gt; v = {1, 3, 5};

  // OK, напечатает 3
  std::cout &lt;&lt; v.size() &lt;&lt; "\n";

  // ошибка компиляции: константный вектор нельзя изменять
  v.clear();

  // тоже ошибка компиляции
  v[0] = 0;
}
</pre>
  <p>Ссылки и указатели можно комбинировать с константностью:</p>
<pre>
int main() {
  int x = 42;

  // обычная ссылка
  int& ref = x;

  // константная ссылка
  const int& cref = x;
  ++x;  // OK
  ++ref;  // OK

  // ошибка компиляции: псевдоним cref предназначен только для чтения
  ++cref;

  // обычный указатель
  int* ptr = &x;

  // указатель на константу
  const int* cptr = &x;
  ++*ptr;  // OK

  // ошибка компиляции: разыменованный cptr — константа!
  ++*cptr;
}
</pre>
  <p>Если исходная переменная уже была константной, то взять обычную ссылку или указатель на неё не получится. Другими словами, константность нельзя просто так отменить, её можно только добавить:</p>
<pre>
int main() {
  const int cx = 42;

  // ошибка компиляции: константность нельзя убрать
  int& ref = cx;
  const int& cref = cx;  // OK

  // тоже ошибка компиляции
  int* ptr = &cx;
  const int* cptr = &cx;  // OK
}
</pre>
  <p>Базовый тип и слово const можно менять местами. Так что const T и T const — это одно и то же. Но следует различать указатель на константу (const T*) и константу типа «указатель» (T* const):</p>
<pre>
int main() {
  int x = 42;
  const int cx = 13;

  // обычный указатель
  int* ptr = &x;
  // ошибка компиляции
  ptr = &cx;

  // OK: через *cptr нельзя будет изменить x
  const int* cptr = &x;
  cptr = &cx;  // OK

  // OK: *ptrc можно менять, но сам ptrc менять нельзя
  int* const ptrc = &x;
  ptrc = nullptr;  // ошибка компиляции

  // OK, для &cx тоже бы сработало
  const int* const cptrc = &x;
}
</pre>
  <p>Пример в последней строке похож на константную ссылку: указатель cptrc не позволяет менять содержимое ячейки &x (первый const) и в него нельзя записать адрес другой переменной (второй const).</p>

  <h4>Ссылки в цикле range-for</h4>

  <p>Рассмотрим итерацию по элементам вектора строк. Намеренно положим в вектор много длинных строк и в цикле попробуем подсчитать их длину (которую, конечно, можно было бы сразу вычислить):</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  // создаём вектор из m строк длины n
  // и искусственно заполняем его:
  const size_t m = 1000000;
  const size_t n = 10000;
  std::vector&lt;std::string&gt; v(m);
  for (size_t i = 0; i != m; ++i) {
    v[i].resize(n, '@');  // кладём в вектор строку из n символов @
  }

  // нам интересен этот цикл:
  size_t sum = 0;
  for (auto row : v) {
    sum += row.size();
  }
  std::cout &lt;&lt; sum &lt;&lt; "\n";
}
</pre>
  <p>Скомпилируем программу с умеренным уровнем оптимизаций (ключ -O2) и измерим время её работы с помощью консольной утилиты time:</p>
<pre>
$ clang++ -O2 -o runnable test.cpp
$ time ./runnable

real   0m4,255s
user   0m1,948s
sys    0m2,307s
</pre>
  <p>Программа работала 4,255 секунды. Давайте её ускорим. Заметим, что в цикле мы пишем</p>
<pre>
for (auto row : v) {
  // ...
}
</pre>
  <p>На самом деле это эквивалентно такому:</p>
<pre>
for (size_t i = 0; i != v.size(); ++i) {
  std::string row = v[i];  // здесь создаётся копия!
  // ...
}
</pre>
  <p>Понятно, что вместо копирования очередной строки можно воспользоваться константной ссылкой:</p>
<pre>
for (const auto& row : v) {
  // ...
}
</pre>
  <p>Время работы такой программы уже будет меньше:</p>
<pre>
$ time ./runnable

real   0m3,462s
user   0m1,157s
sys    0m2,305s
</pre>
  <p>Давайте запомним: чтобы избегать лишнего копирования, в range-for используйте константную ссылку при итерации по набору «тяжёлых» объектов — строк, векторов, структур. Если вы хотите в цикле менять элементы контейнера — используйте обычную ссылку. Нашу программу можно было бы переписать так:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  const size_t m = 1000000;
  const size_t n = 10000;
  std::vector&lt;std::string&gt; v(m);
  for (auto& row : v) {  // обычная ссылка
    row.resize(n, '@');
  }

  size_t sum = 0;
  for (const auto& row : v) {  // константная ссылка
    sum += row.size();
  }
  std::cout &lt;&lt; sum &lt;&lt; "\n";
}
</pre>

  <h4>«Висячие» ссылки и указатели</h4>

  <p>Может так оказаться, что переменная, на адрес которой ссылается указатель, уже вышла из своей области видимости. Похожая ситуация может произойти и со ссылками. В таком случае обращаться к памяти через ссылку или указатель нельзя — это приведёт к неопределённому поведению.</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int* ptr = nullptr;

  {
    int x = 42;
    ptr = &x;
  }

  // обращаться к памяти, в которой жила переменная x, уже нельзя:
  // неопределённое поведение!
  std::cout &lt;&lt; *ptr &lt;&lt; "\n";
}
</pre>
  <p>Аналогичная ситуация произойдёт при обращении к уже не существующему элементу вектора:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;std::string&gt; words = {"one", "two", "three"};

  std::string& ref = words[0];  // псевдоним для начального элемента вектора

  words.clear();

  // обращаться к ссылке ref уже нельзя!
  std::cout &lt;&lt; ref &lt;&lt; "\n";  // неопределённое поведение!
}
</pre>
  <p>Важно не допускать в программах таких ситуаций.</p>
</article>


<!-- 2.7 Функции -->
<article class="article">
  <div class="anchor" id="p2.7"></div>
  <h3>2.7 Функции</h3>

  <p>Функции позволяют отделить часто используемый код и переиспользовать его с разными значениями аргументов. С примером функции мы уже знакомы: в каждой программе вы пишете функцию main, которая не принимает аргументов и возвращает int.</p>

  <h4>Примеры функций</h4>

  <p>Напишем простейшую функцию, вычисляющую сумму двух целых чисел:</p>
<pre>
// в заголовке функции указывается
// тип возвращаемого значения
// и типы аргументов
int Sum(int a, int b) {
  return a + b;
}
</pre>
  <p>Если функция ничего не должна возвращать, её можно объявить как void:</p>
<pre>
void DoSomething(double d, char c) {
  // ...
  // писать return в конце такой функции не обязательно,
  // но если требуется завершить функцию, можно написать просто return;
}

int main() {
  int x = 17, y = 42;
  int z = Sum(x, y);
   DoSomething(3.14, '@');
}
</pre>
  <p>Вот пример рекурсивной функции, вычисляющей факториал:</p>
<pre>
#include &lt;cstdint&gt;
#include &lt;iostream&gt;

std::uint64_t Factorial(std::uint64_t n) {
  if (n == 0) {
    return 1;
  }
  return n * Factorial(n - 1);  // рекурсивный вызов
}

int main() {
  std::cout &lt;&lt; Factorial(5) &lt;&lt; "\n";  // 120
}
</pre>
  <p>Помните, что если делать очень много рекурсивных вызовов, то рано или поздно переполнится стек — область памяти, в которой хранятся аргументы и локальные переменные текущей функции.</p>

  <h4>Аргументы функций</h4>

  <p>Параметры в функции по умолчанию передаются «по значению». Другими словами, функция работает с копиями аргументов. Чтобы лучше представить это, давайте посмотрим, что бы получилось, если бы компилятор заменил вызов функции на непосредственное исполнение кода.</p>
  <p>Возьмём такой фрагмент кода:</p>
<pre>
void f(int x, int y) {
  // работаем с аргументами x и y
}

int main() {
  int a, b;
  // какая-то инициализация a и b

  f(a, b);
}
</pre>
  <p>Заменим его на такой код:</p>
<pre>
int main() {
  int a, b;
  // какая-то инициализация a и b

  {
    // этот блок просто ограничивает время жизни
    // находящихся внутри переменных
    int x = a;
    int y = b;
    // работаем с аргументами x и y
  }
}
</pre>
  <p>Теперь видно, что любое изменение x или y внутри функции никак не затронет a и b.</p>
  <p>Можем ли мы изменить переданный аргумент внутри функции, чтобы это повлияло на аргументы в месте вызова? Да, для этого надо передать аргументы через ссылку или указатель. Вот классический пример функции, меняющей два аргумента местами:</p>
<pre>
void Swap(int& x, int& y) {  // передаём аргументы по ссылке
  int z = x;
  x = y;
  y = z;
}

int main() {
  int a = 1, b = 2;
  Swap(a, b);
  std::cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; "\n";  // 2 1
}
</pre>
  <p>Чтобы понять, как это работает, раскроем снова код функции в месте вызова:</p>
<pre>
int main() {
  int a = 1, b = 2;

  {
    int& x = a;
    int& y = b;
    int z = x;
    x = y;
    y = z;
  }

  std::cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; "\n";  // 2 1
}
</pre>
  <p>Видно, что x и y — это просто псевдонимы для a и b.</p>
  <p>Заметьте, что вызов Swap(1, 2), в отличие от Swap(a, b), не скомпилируется, потому что обычная ссылка должна быть привязана к изменяемому объекту.</p>
  <p>Примером функции из стандартной библиотеки, которая принимает аргумент по ссылке и изменяет его, является std::getline:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string line;

  // Второй аргумент передаётся по ссылке и изменяется внутри функции:
  std::getline(std::cin, line);
}
</pre>
  <p>Иногда копирование объекта может быть очень дорогим (и ненужным). Например, копирование вектора приведёт к копированию всех его элементов. Поэтому вот так передавать вектор в функцию неэффективно:</p>
<pre>
void f(std::vector&lt;int&gt; v) {
  // плохо: при вызове функции создаётся копия вектора
}
</pre>
  <p>Копии можно было бы избежать, если бы вектор передавался по ссылке:</p>
<pre>
void f(std::vector&lt;int&gt;& v) {
  // Но теперь есть другие недостатки:
  // 1. В такую функцию нельзя передать константный вектор.
  // 2. Функция не защищена от случайного изменения вектора:
  v.clear();  // тут компилятор нас не схватит за руку
}
</pre>
  <p>Поэтому самое правильное — передавать такой параметр по константной ссылке:</p>
<pre>
void f(const std::vector&lt;int&gt;& v) {
  // Такой аргумент не требует дорогого копирования,
  // его нельзя случайно изменить внутри,
  // и такую функцию можно вызывать от констант!
}
</pre>
  <p>Давайте запомним: аргументы сложных типов (векторы, строки, любые контейнеры, большие структуры) всегда лучше передавать в функцию по константной ссылке, если функция использует их только для чтения. Из этого правила бывают исключения, но о них мы поговорим отдельно.</p>
  <p>Впрочем, это правило не стоит распространять на обычные встроенные типы:</p>
<pre>
void g(const int& a, const char& c) {
  // так делать не надо, это уже перебор!
  // передавайте такие параметры просто
  // по значению, как int или char
}
</pre>

  <h4>Возвращаемые значения функций</h4>

  <p>В отличие от аргументов, значения сложных типов можно без проблем возвращать из функций. Здесь от ненужного копирования (по крайней мере, для стандартных контейнеров) спасает copy elision.</p>
  <p>Рассмотрим, например, функцию, которая возвращает конкатенацию всех строк из вектора:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

std::string Concatenate(const std::vector&lt;std::string&gt;& parts) {
  std::string result;
  for (const auto& part : parts) {
    result += part;
  }
  return result;
}

int main() {
  std::vector&lt;std::string&gt; parts = {"abra", "ca", "dabra"};
  std::cout &lt;&lt; Concatenate(parts) &lt;&lt; "\n";  // abracadabra
}
</pre>
  <p>Опасно возвращать из функции ссылку на локальную переменную, так как эта ссылка сразу же станет «висячей»:</p>
<pre>
#include &lt;iostream&gt;

int& Sum(int a, int b) {  // ошибка!
  int result = a + b;
  return result;
}

int main() {
  // неопределённое поведение!
  std::cout &lt;&lt; Sum(2, 3) &lt;&lt; "\n";
}
</pre>
  <p>Компиляторы в таких случаях генерируют предупреждения.</p>
  <p>Возвращать значение по ссылке можно только в случае, если оно заведомо будет доступно после завершения функции. Например, так можно вернуть глобальную переменную или аргумент, также переданный по ссылке.</p>

  <h4>Функции-компараторы</h4>

  <p>Пусть имеется структура Date, описывающая день, месяц и год какой-то даты. Создадим вектор дат:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

struct Date {
  int year = 1970;
  int month = 1;
  int day = 1;
};

int main() {
  std::vector&lt;Date&gt; dates = {
    {2020, 3, 15},
    {2019, 1, 21},
    {2021, 1, 30}
  };

  // напечатаем содержимое:
  for (const auto& [year, month, day] : dates) {
    std::cout &lt;&lt; year &lt;&lt; "." &lt;&lt; month
    &lt;&lt; "." &lt;&lt; day &lt;&lt; "\n";
  }
}
</pre>
  <p>Предположим, нам требуется отсортировать даты. Для сортировки нам поможет уже знакомая функция std::sort, но есть нюанс: вызов std::sort(dates.begin(), dates.end()) не скомпилируется, так как компилятор не умеет сравнивать даты между собой. Функция std::sort пытается найти оператор &lt; для сравнения дат, но, увы, для нашей даты такого нет. Мы можем его определить. Он выглядит как функция с особым именем operator &lt;, возвращающая true, если первый аргумент меньше второго:</p>
<pre>
bool operator &lt; (const Date& lhs, const Date& rhs) {
  if (lhs.year != rhs.year) {
    return lhs.year &lt; rhs.year;
  }
  if (lhs.month != rhs.month) {
    return lhs.month &lt; rhs.month;
  }
  return lhs.day &lt; rhs.day;
}
</pre>
  <p>Здесь lhs и rhs — сокращения от left-hand side и right-hand side. Это левый и правый аргументы оператора &lt;. Этот громоздкий код можно записать лаконичнее с использованием функции std::tie, возвращающей кортеж из ссылок, для которого уже определено лексикографическое (покомпонентное) сравнение:</p>
<pre>
bool operator &lt; (const Date& lhs, const Date& rhs) {
  return std::tie(lhs.year, lhs.month, lhs.day) &lt; std::tie(rhs.year, rhs.month, rhs.day);
}
</pre>
  <p>После определения operator &lt; сортировка заработает. Но что, если нам в разных случаях нужно по-разному сортировать даты — например, где-то в хронологическом порядке, а где-то — без учёта года? Можно передать в std::sort третьим аргументом свою функцию сравнения, которая будет использована вместо operator &lt;:</p>
<pre>
bool CompareWithoutYear(const Date& lhs, const Date& rhs) {
  return std::tie(lhs.month, lhs.day) &lt; std::tie(rhs.month, rhs.day);
}

int main() {
  // ...
  std::sort(dates.begin(), dates.end(), CompareWithoutYear);
}
</pre>
  <p>Обратите внимание, что третьим аргументом в std::sort мы передаём саму функцию (без круглых скобок), а не результат её вызова от каких-то аргументов.</p>

  <h4>Лямбда-функции</h4>

  <p>Иногда бывает неудобно определять отдельную именованную функцию для сравнения. Тогда можно определить анонимную лямбда-функцию прямо в месте её использования:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;vector&gt;

struct Date {
  int year, month, day;
};

int main() {
  std::vector&lt;Date&gt; dates;
  std::sort(dates.begin(), dates.end(), [](const Date& lhs, const Date& rhs) {
    return std::tie(lhs.month, lhs.day) &lt; std::tie(rhs.month, rhs.day);
  });
}
</pre>
  <p>Тип возвращаемого значения тут не указывается, компилятор умеет его угадывать по return (его можно указать после круглых скобок на «питоновский» манер через ->, но не обязательно).</p>
  <p>Разберём синтаксис лямбда-функций. Тут видны три блока.</p>
  <ol>
    <li>Квадратные скобки отвечают за контекст. В них мы можем передать переменные, которые объявлены вне лямбда-функции через запятую, и они будут доступны в самой лямбда-функции.</li>
    <li>Круглые скобки отвечают за аргументы функции.</li>
    <li>Фигурные скобки отвечают за тело лямбда-функции.</li>
  </ol>
  <p>Когда лямбды добавлялись в стандарт C++11, разработчики очень не хотели вводить для них новое ключевое слово (как lambda в Python) и обошлись комбинацией скобок. Есть шутка про то, что вот такая программа является вполне корректной:</p>
  <code>int main() {[](){}();}</code>
  <p>Попробуйте разобраться, что тут происходит.</p>
</article>


<!-- 2.8 Шаблоны -->
<article class="article">
  <div class="anchor" id="p2.8"></div>
  <h3>2.8 Шаблоны</h3>

  <p>Шаблоны — это фрагменты обобщённого кода, в котором некоторые типы или константы вынесены в параметры. Шаблонными могут быть функции, структуры (классы) и даже переменные. Компилятор превращает использование шаблона в конкретный код, подставляя в него нужные параметры на этапе компиляции. Шаблоны позволяют писать общий код, пригодный для использования с разными типами данных.</p>
  <p>Стандартная библиотека C++ построена на шаблонах. Раньше её даже называли Standard Template Library (STL, стандартная библиотека шаблонов). Её контейнеры и итераторы являются шаблонными классами, а алгоритмы — шаблонными функциями. Примеры шаблонных конструкций из стандартной библиотеки нам уже встречались: это, например, контейнер std::vector и функция std::sort. В следующем параграфе мы рассмотрим контейнер std::array, размер которого задаётся шаблонной константой времени компиляции. В этом параграфе мы рассмотрим шаблоны функций и структур, параметры которых являются типами. Но прежде чем говорить про шаблоны, рассмотрим перегрузку функций.</p>

  <h4>Перегрузка функций</h4>

  <p>Количество и типы аргументов функции должны быть известны заранее, на этапе компиляции. Но в языке C++ можно создавать функции с одним и тем же именем, но разным набором или типами аргументов и с разными телами. Такие функции называются перегруженными. Рассмотрим, например, семейство перегруженных функций для печати переменной на экран:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

void Print(int value) {
  std::cout &lt;&lt; value &lt;&lt; "\n";
}

void Print(const std::string& name, int value) {
  // печатаем название и саму величину
  std::cout &lt;&lt; name &lt;&lt; ": " &lt;&lt; value &lt;&lt; "\n";
}

void Print(const std::string& str) {
  std::cout &lt;&lt; str &lt;&lt; "\n";
}

int main() {
  Print(42);  // версия 1
  Print("x", 42);  // версия 2
  Print("good bye");  // версия 3
}
</pre>
  <p>Компилятор, сравнивая разные версии функции друг с другом, смотрит на их имена и набор типов аргументов. При этом имена аргументов ни на что не влияют. Также нельзя перегружать функции по типу возвращаемого значения. Действительно, возвращаемое значение может просто игнорироваться в месте вызова, и компилятор не сможет определить, какая версия функции имеется в виду.</p>
<pre>
int f(int x) {
  return x;
}

// ошибка компиляции: функция с таким
// именем и типом параметра уже была
int f(int y) {
  return 2 * y;
}

// ошибка компиляции: перегружать
// по возвращаемому значению нельзя
double f(int x) {
  return 3 * x;
}
</pre>

  <h4>Шаблонные функции</h4>

  <p>Рассмотрим классический пример. Предположим, у нас есть функция, вычисляющая максимум целых чисел:</p>
<pre>
int Max(int x, int y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}
</pre>
  <p>Она определена для аргументов типа int. Однако, если применить её к аргументам типа double, результат получится неожиданным. А её применение к строкам или векторам вообще не скомпилируется:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::cout &lt;&lt; Max(1, 2) &lt;&lt; "\n";  // 2
  std::cout &lt;&lt; Max(3.14159, 2.71828) &lt;&lt; "\n";  // внезапно 3

  std::string word1 = "hello", word2 = "world";
  std::cout &lt;&lt; Max(word1, word2);  // ошибка компиляции
}
</pre>
  <p>В вызове Max(3.14159, 2.71828) аргументы будут преобразованы к типу int, то есть получится Max(3, 2). Вызов Max(word1, word2) не скомпилируется, так как строки нельзя привести к типу int. Чтобы эти вызовы корректно заработали, надо определить перегруженные версии функции Max:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int Max(int x, int y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}

double Max(double x, double y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}

std::string Max(const std::string& x, const std::string& y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}

int main() {
  std::cout &lt;&lt; Max(1, 2) &lt;&lt; "\n";  // 2
  std::cout &lt;&lt; Max(3.14159, 2.71828) &lt;&lt; "\n";  // 3.14159

  std::string word1 = "hello", word2 = "world";
  std::cout &lt;&lt; Max(word1, word2);  // world
}
</pre>
  <p>Выписывать похожие друг на друга версии функций утомительно. Кроме того, такие функции не смогут работать с новыми, неизвестными нам заранее типами. Шаблоны позволяют описать такую функцию один раз, вынеся тип в параметры:</p>
<pre>
template &lt;typename T&gt;
T Max(const T& x, const T& y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}
</pre>
  <p>Шаблон начинается с шапки template. Далее в угловых скобках перечисляются формальные имена параметров. В нашем случае параметр один — это тип T (от слова type). Вместо ключевого слова typename в этом месте допускается использовать слово class (вы можете встретить такие описания шаблонов на cppreference.com). А вместо имени T можно было бы использовать любой другой идентификатор.</p>
  <p>Так как мы не знаем, будет ли тип T встроенным или сложным, то на всякий случай передаём аргументы в функцию по константной ссылке, чтобы избежать лишнего копирования.</p>
  <p>В нашей шаблонной функции Max используется оператор >. Он определён для обычных чисел, строк и векторов (если, конечно, для элементов вектора тоже определён этот оператор). Но если попробовать применить наш шаблон к типу, не поддерживающему оператор >, то произойдёт ошибка компиляции:</p>
<pre>
struct Point {
  double x = 0.0;
  double y = 0.0;
  double z = 0.0;
};

int main() {
  Point p1, p2;
  Point p = Max(p1, p2);  // ошибка компиляции
}
</pre>

  <h4>Вывод шаблонных параметров</h4>

  <p>Конкретные версии шаблонной функции Max для нужных типов получаются подстановкой шаблонных аргументов в угловые скобки. Так, Max&lt;int&gt; — это версия нашей функции для типа int, а Max&lt;std::string&gt; — версия для строк. Важно понимать, что, несмотря на общий шаблон, это разные функции, которые просто порождаются компилятором по образцу.</p>
  <p>Вызвать шаблонную функцию можно было бы так:</p>
<pre>
Max&lt;double&gt;(3.14159, 2.71828);  // 3.14159
Max&lt;int&gt;(3.14159, 2.71828);  // вызывается int-версия, вернётся 3
</pre>
  <p>Однако параметры шаблона в угловых скобках можно не писать: компилятор попытается сам угадать эти параметры по типу аргументов:</p>
<pre>
int main() {
  // 2, вызывается Max&lt;int&gt;
  std::cout &lt;&lt; Max(1, 2) &lt;&lt; "\n";
   // 3.14159, вызывается Max&lt;double&gt;
  std::cout &lt;&lt; Max(3.14159, 2.71828) &lt;&lt; "\n";

  std::string word1 = "hello", word2 = "world";
  // world, вызывается Max&lt;std::string&gt;
  std::cout &lt;&lt; Max(word1, word2);
}
</pre>
  <p>В случае неоднозначностей, например в вызове Max(3.14159, 2), компилятор не сможет автоматически вывести параметр, и ему придётся подсказать тип: Max&lt;double&gt;(3.14159, 2).</p>

  <h4>Перегрузка шаблонных функций</h4>

  <p>Шаблонные функции тоже можно перегружать. Пусть, например, мы хотим вычислять максимум двух векторов, но при этом сравнивать векторы сначала по размеру, а затем уже лексикографически. Стандартное сравнение векторов через оператор > не будет учитывать размер. Поэтому напишем отдельную перегрузку для векторов:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

// общая версия
template &lt;typename T&gt;
T Max(const T& x, const T& y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}

// перегрузка для векторов
template &lt;typename T&gt;
const std::vector&lt;T&gt;& Max(const std::vector&lt;T&gt;& v1, const std::vector&lt;T&gt;& v2) {
  if (v1.size() > v2.size()) {
    return v1;
  } else if (v1.size() &lt; v2.size()) {
    return v2;
  } else if (v1 > v2) {
    return v1;
  } else {
    return v2;
  }
}

int main() {
  std::cout &lt;&lt; Max(1, 2) &lt;&lt; "\n";  // вызов общей версии

  std::vector&lt;int&gt; v1 = {1, 2, 3};
  std::vector&lt;int&gt; v2 = {4, 5};
  for (int x : Max(v1, v2)) {  // вызов перегруженной версии
    std::cout &lt;&lt; x &lt;&lt; " ";  // 1 2 3
  }
  std::cout &lt;&lt; "\n";
}
</pre>

  <h4>Разрешение неоднозначностей</h4>

  <p>Когда компилятор видит вызов функции, ему нужно правильно определить, в каком пространстве имён её искать, какую из перегруженных версий выбрать, а в случае шаблонной функции — как вывести параметры шаблона. Для шаблонных функций после выбора перегруженной версии возможен ещё выбор из вариантов полной специализации шаблона. Общие правила поиска нужной функции достаточно сложны, и мы не будем их здесь приводить полностью. Однако в случаях, которые мы будем рассматривать в этом учебнике, выбор нужной функции будет интуитивно понятен.</p>

  <h4>Шаблонные структуры</h4>

  <p>Структуры и классы также могут быть описаны в общем виде и параметризованы типами или константами времени компиляции. Типичный пример шаблонной структуры — std::pair. Определим по аналогии свою структуру Triple с тремя шаблонными типами:</p>
<pre>
#include &lt;string&gt;

template &lt;typename T1, typename T2, typename T3&gt;
struct Triple {
  T1 first;
  T2 second;
  T3 third;
};

int main() {
  Triple&lt;int, int, int&gt; point = {-1, 3, 2};
  Triple&lt;std::string, std::string, int&gt; wordPairsFreq = {"hello", "world", 42};
}
</pre>
  <p>Здесь так же, как и в случае функций, компилятор генерирует по образцу две никак не связанные друг с другом структуры Triple&lt;int, int, int&gt; и Triple&lt;std::string, std::string, int&gt;.</p>
  <p>В следующих параграфах мы будем подробно рассматривать шаблонные классы, в которых могут быть шаблонные функции-члены.</p>
</article>


<!-- 2.9 Разбор задач к главе «Базовые конструкции C++» -->
<article class="article">
  <div class="anchor" id="p2.9"></div>
  <h3>2.9 Разбор задач к главе «Базовые конструкции C++»</h3>

  <h3>Параграф «Первые шаги»</h3>

  <h4>Задача «Печать текста»</h4>

  <details>
    <summary>Условие</summary>
    <p>Напишите программу, печатающую на экране первые строчки со страницы Бьярне Страуструпа про C++:</p>
<pre>
C++ is a general-purpose programming language with a bias towards systems programming that
  - is a better C
  - supports data abstraction
  - supports object-oriented programming
  - supports generic programming.
</pre>
    <p>Не потеряйте парные пробелы в начале строк и переносы в конце строк.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Задача очень похожа на программу Hello world. Отличие в том, что здесь надо напечатать несколько строк текста. Сам символ перевода строки не может содержаться в обычных строковых литералах, поэтому в программе его придётся заменить на \n. Можно просто вывести каждую строчку отдельно:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  std::cout &lt;&lt; "C++ is a general-purpose programming language with a bias towards systems programming that\n";
  std::cout &lt;&lt; "  - is a better C\n";
  std::cout &lt;&lt; "  - supports data abstraction\n";
  std::cout &lt;&lt; "  - supports object-oriented programming\n";
  std::cout &lt;&lt; "  - supports generic programming.\n";
}
</pre>
    <p>Однако писать каждый раз std::cout утомительно. В конструкции std::cout поддерживается вывод нескольких величин сразу. Можно оставить только самый первый std::cout, а остальные строки вывести через &lt;&lt;:</p>
<pre>
#include <iostream>

int main() {
  std::cout &lt;&lt; "C++ is a general-purpose programming language with a bias towards systems programming that\n"
            &lt;&lt; "  - is a better C\n"
            &lt;&lt; "  - supports data abstraction\n"
            &lt;&lt; "  - supports object-oriented programming\n"
            &lt;&lt; "  - supports generic programming.\n";
}
</pre>
    <p>Здесь мы нарочно для лучшей читаемости отформатировали программу так, чтобы символы &lt;&lt; стояли друг под другом.</p>
    <p>Рассмотрим ещё два способа решить задачу. Строковые константы, расположенные просто друг за другом, автоматически конкатенируются при компиляции программы. Так "Hello," " world!" даст "Hello, world!. Поэтому можно написать так:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  std::cout &lt;&lt; "C++ is a general-purpose programming language with a bias towards systems programming that\n"
               "  - is a better C\n"
               "  - supports data abstraction\n"
               "  - supports object-oriented programming\n"
               "  - supports generic programming.\n";
}
</pre>
    <p>Можно ли избавиться от необходимости писать \n в конце каждой строки? Да, для этого можно воспользоваться raw-литералами. Они могут содержать внутри без экранирования любые символы, в том числе перевод строки, лишь бы они были отличны от выбранных ограничителей. Такие литералы предваряются символом R, а в начале и в конце должна стоять произвольно выбранная одинаковая последовательность символов и круглые скобки. Например, raw(...)raw, или ~~~(...)~~~:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  std::cout &lt;&lt;
R"~~~(C++ is a general-purpose programming language with a bias towards systems programming that
  - is a better C
  - supports data abstraction
  - supports object-oriented programming
  - supports generic programming.
)~~~";
}
</pre>
  </details>

  <h4>Задача «Сумма чисел»</h4>

  <details>
    <summary>Условие</summary>
    <p>Вам даны два целых числа. Напечатайте их сумму.</p>

    <h4>Формат ввода</h4>
    <p>Вводятся два числа, по модулю не превосходящие миллиарда.</p>

    <h4>Формат вывода</h4>
    <p>Напечатайте сумму этих чисел. В конце поставьте перевод строки.</p>

    <h4>Пример</h4>
    <code>1 2</code>
    <code>3</code>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;

int main() {
  int a, b;
  std::cin >> a >> b;
  std::cout &lt;&lt; a + b &lt;&lt; "\n";
}
</pre>
    <p>Проверять корректность условия (то, что числа по модулю не превосходят миллиарда) в программе не нужно.</p>
    <p>Из условия следует, что сумма этих чисел по модулю не будет превосходить двух миллиардов. Забегая немного вперёд, скажем, что это гарантирует, что сумма поместится в тип int. Такие условия позволяют выбрать правильный тип данных для решения задачи.</p>
  </details>

  <h3>Параграф «Типы данных»</h3>

  <h4>Задача «Дюймы»</h4>

  <details>
    <summary>Условие</summary>
    <p>Напишите программу для перевода сантиметров в дюймы. В одном дюйме 2.54 сантиметра.</p>

    <h4>Формат ввода</h4>
    <p>На вход поступает длина в сантиметрах. Значение может быть дробным. Используйте тип double для его хранения.</p>

    <h4>Формат вывода</h4>
    <p>Напечатайте эту длину в дюймах. Округление не требуется. Достаточно использовать стандартную точность вывода до 6 знаков после запятой, которая установлена по умолчанию.</p>

    <h4>Пример</h4>
    <code>1.1</code>
    <code>0.433071</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Если в одном дюйме 2.54 сантиметра, то в одном сантиметре 1/2.54 дюйма:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  double centimeters;
  std::cin >> centimeters;

  double inches = centimeters / 2.54;

  std::cout &lt;&lt; inches &lt;&lt; "\n";
}
</pre>
  </details>

  <h4>Задача «Арифметическая прогрессия»</h4>

  <details>
    <summary>Условие</summary>
    <p>Перед вами программа, которая считает сумму первых n натуральных чисел по формуле суммы арифметической прогрессии:</p>
<pre>
#include <iostream>

int main() {
  int n;
  std::cin >> n;
  std::cout &lt;&lt; n * (n + 1) / 2 &lt;&lt; "\n";
}
</pre>
    <p>Программа должна работать для всех n≤4000000000, но оказывается, что для некоторых n она работает неправильно. Найдите причину проблемы и исправьте программу.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Никакой ошибки в формуле нет. Всё дело в используемом типе данных. При n=46341 происходит переполнение типа int32_t, а при n = 3037000500 происходит переполнение типа int64_t. При выборе беззнакового типа uint64_t переполнения на n=4000000000 не случится. Поэтому просто заменим тип данных на uint64_t.</p>
<pre>
#include &lt;cstdint&gt;
#include &lt;iostream&gt;

int main() {
  std::uint64_t n = 0;
  std::cin >> n;
  std::cout &lt;&lt; n * (n + 1) / 2 &lt;&lt; "\n";
}
</pre>
    <p>Можно было бы сначала выяснить, является ли n чётным, чтобы сначала произвести деление, а потом умножить:</p>
<pre>
#include &lt;cstdint&gt;
#include &lt;iostream&gt;

int main() {
  std::uint64_t number = 0;
  std::cin >> number;

  if (number % 2 == 0) {
    std::cout &lt;&lt; (number / 2) * (number + 1);
  } else {
    std::cout &lt;&lt; ((number + 1) / 2) * number;
  }
  std::cout &lt;&lt; "\n";
}
</pre>
    <p>Тогда лимиты выросли бы ещё больше. Но в решении этого не потребовалось.</p>
  </details>

  <h3>Параграф «Ветвления и циклы»</h3>

  <h4>Задача «Ход ферзя»</h4>

  <details>
    <summary>Условие</summary>
    <p>Шахматный ферзь ходит на любое количество клеток по диагонали, горизонтали или вертикали. Даны две различные клетки на шахматной доске без фигур. Определите, может ли ферзь попасть с первой клетки на вторую одним ходом.</p>

    <h4>Формат ввода</h4>
    <p>Программа получает на вход четыре целых числа от 1 до 8. Первая пара чисел задаёт номер столбца и номер строки для первой клетки. Вторая пара чисел аналогично задаёт вторую клетку.</p>

    <h4>Формат вывода</h4>
    <p>Программа должна вывести YES, если из первой клетки ходом ферзя можно попасть во вторую, или NO в противном случае.</p>

    <h4>Пример 1</h4>
    <code>1 1 2 2</code>
    <code>YES</code>

    <h4>Пример 2</h4>
    <code>1 1 2 3</code>
    <code>NO</code>

    <h4>Пример 3</h4>
    <code>5 6 3 3</code>
    <code>NO</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Ферзь может ходить по вертикали, горизонтали и диагонали. Для того чтобы проверить, является ли ход вертикальным или горизонтальным, достаточно сравнить координаты x1 x2 или y1 y2. Для проверки является ли ход диагональным достаточно сравнить модуль разности координат |x1-x2| и |y1-y2| . Если ни одно из условий не выполняется — ход не может быть совершён ферзём. Для нахождения модуля удобно использовать стандартную функцию std::abs.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;cmath&gt;

int main() {
  int x1, y1, x2, y2;
  std::cin >> x1 >> y1;
  std::cin >> x2 >> y2;

  if (x1 == x2 || y1 == y2 || std::abs(x1 - x2) == std::abs(y1 - y2)) {
    std::cout &lt;&lt; "YES\n";
  } else {
    std::cout &lt;&lt; "NO\n";
  }
}
</pre>
  </details>

  <h4>Задача «Прямоугольный треугольник»</h4>

  <details>
    <summary>Условие</summary>
    <p>Напишите программу, которая проверяет является ли треугольник прямоугольным.</p>

    <h4>Формат ввода</h4>
    <p>На стандартный поток ввода подаётся три целых положительных числа — стороны треугольника. Числа не превосходят 30000.</p>

    <h4>Формат вывода</h4>
    <p>Если полученный треугольник является прямоугольным, напечатайте YES. Если треугольник не является прямоугольным, напечатайте NO. Если с заданными сторонами невозможно построить треугольник, напечатайте UNDEFINED.</p>

    <h4>Пример 1</h4>
    <code>3 2 5</code>
    <code>YES</code>

    <h4>Пример 2</h4>
    <code>3 2 10</code>
    <code>UNDEFINED</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Во-первых, нам необходимо проверить существует ли такой треугольник. Для этого достаточно воспользоваться неравенством треугольника: a+b>c, a+c>b, c+b>a. Если хотя бы одно из этих условий не выполняется, программа должна выводить UNDEFINED.</p>
    <p>Далее необходимо проверить является ли треугольник прямоугольным. Есть несколько способов это сделать. Самый простой — воспользоваться теоремой Пифагора. Если одно из равенств a²+b²=c², a²+c²=b², b²+c²=a² выполняется, программа должна вывести YES. В противном случае надо вывести NO.</p>
    <p>По условию задачи стороны треугольника не превосходят 2¹⁵, а значит выражение a²+b² не будет превосходить 2³⁰+2³⁰=2³¹ и поместится в тип int.</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int a, b, c;
  std::cin >> a >> b >> c;

  if (a + b &lt;= c || a + c &lt;= b || b + c &lt;= a) {
    std::cout &lt;&lt; "UNDEFINED\n";
  } else if (a * a + b * b == c * c || a * a + c * c == b * b || b * b + c * c == a * a) {
    std::cout &lt;&lt; "YES\n";
  } else {
    std::cout &lt;&lt; "NO\n";
  }
}
</pre>
  </details>

  <h4>Задача «Високосный год»</h4>

  <details>
    <summary>Условие</summary>
    <p>Определите, является ли год високосным по григорианскому календарю.</p>
    <p>Напоминание:</p>
    <ol>
      <li>год, номер которого кратен 400, — високосный;</li>
      <li>остальные годы, номер которых кратен 100, — невисокосные (например, годы 1700, 1800, 1900, 2100, 2200, 2300);</li>
      <li>остальные годы, номер которых кратен 4, — високосные.</li>
      <li>все остальные годы — невисокосные.</li>
    </ol>

    <h4>Формат ввода</h4>
    <p>Вводится целое положительное четырёхзначное число — номер года.</p>

    <h4>Формат вывода</h4>
    <p>Программа выводит YES если год високосный и NO в противном случае.</p>

    <h4>Пример 1</h4>
    <code>2003</code>
    <code>NO</code>

    <h4>Пример 2</h4>
    <code>2004</code>
    <code>YES</code>

    <h4>Пример 3</h4>
    <code>3000</code>
    <code>NO</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Грамотно перепишем определения из условия через if/else и проверку остатка от деления:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int year;
  std::cin >> year;

  if (year % 400 == 0) {
    std::cout &lt;&lt; "YES\n";
  } else if (year % 100 == 0) {
    std::cout &lt;&lt; "NO\n";
  } else if (year % 4 == 0) {
    std::cout &lt;&lt; "YES\n";
  } else {
    std::cout &lt;&lt; "NO\n";
  }
}
</pre>
    <p>Заметим, что в получившимся коде дублируются ветви условий. Попробуем его упростить. Для этого достаточно заметить, что високосным является любой год, который делится на 400 или делится на 4, но не делится на 100. После этого упрощения получим следующий код:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int year;
  std::cin >> year;

  if ((year % 400 == 0 || year % 100 != 0) && year % 4 == 0) {
    std::cout &lt;&lt; "YES\n";
  } else {
    std::cout &lt;&lt; "NO\n";
  }
}
</pre>
  </details>

  <h4>Задача «Количество дней в месяце»</h4>

  <details>
    <summary>Условие</summary>
    <p>Напишите программу, выводящую количество дней в месяце по заданному номеру месяца и году.</p>

    <h4>Формат ввода</h4>
    <p>На вход программе подается два целых положительных числа: номер месяца (от 1 до 12) и четырёхзначный год.</p>

    <h4>Формат вывода</h4>
    <p>Необходимо вывести одно число — количество дней в заданном месяце.</p>

    <h4>Пример 1</h4>
    <code>1 2001</code>
    <code>31</code>

    <h4>Пример 2</h4>
    <code>6 3000</code>
    <code>30</code>

    <h4>Пример 3</h4>
    <code>2 2012</code>
    <code>29</code>

    <p>Рекомендуется сначала решить задачу «Високосный год» и использовать её решение для вывода количества дней в феврале.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Эту задачу можно решать либо через if/else, либо через switch/case. Мы воспользуемся вторым вариантом, потому что в таком случае удобно описывать ветви, у которых много разных возможных условий.</p>
    <p>Перечислим все возможные месяцы, для которых ответ будет 31: это январь (1), март (3), май (5), июль (7), август (8), октябрь (10), декабрь (12). Для февраля (2) ответ будет зависеть от года. Воспользуемся кодом из задачи «Високосный год», заменив вывод с YES/NO на 29/28. Для остальных месяцев воспользуемся инструкцией default и выведем 30.</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int month, year;
  std::cin >> month >> year;

  switch (month) {
    case 1:
    case 3:
    case 5:
    case 7:
    case 8:
    case 10:
    case 12:
      std::cout &lt;&lt; "31\n";
      break;
    case 2:
      if ((year % 400 == 0 || year % 100 != 0) && year % 4 == 0) {
        std::cout &lt;&lt; "29\n";
      } else {
        std::cout &lt;&lt; "28\n";
      }
      break;
    default:
      std::cout &lt;&lt; "30\n";
  }
}
</pre>
  </details>

  <h4>Задача «Печать календаря»</h4>

  <details>
    <summary>Условие</summary>
    <p>Напечатайте месяц из календаря по заданному начальному дню и количеству дней. Ваш ответ должен выглядеть примерно так:</p>
<pre>
                   1
 2  3  4  5  6  7  8
 9 10 11 12 13 14 15
16 17 18 19 20 21 22
23 24 25 26 27 28 29
30 31
</pre>
    <h4>Формат ввода</h4>
    <p>Вводится два числа: n — номер дня недели первого числа месяца (целое число от 1 до 7) и k — количество дней в этом месяце (целое число от 1 до 99). n ≤ k. Обратите внимание, что число дней в месяце не обязательно должно быть таким же, как в привычном календаре.</p>
    <h4>Формат вывода</h4>
    <p>Необходимо напечатать календарь как в примере. Пустые позиции в первой строке заполняйте пробелами. Соседние числа также разделяйте пробелами. Под одно число всегда выделяется два символа. В конце строчек до перевода строки пробелов быть не должно. Вывод должен завершаться ровно одним подряд идущим переводом строки.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Для начала выведем отступ перед первым днём. Номер одного дня записывается в два символа, все дни разделены пробелом. Соответственно, необходимо вывести n - 1 раз строку из трёх пробелов.</p>
    <p>Далее введём счётчик dayOfWeek и выставим ему начальное значение, равное n. Будем использовать его для отсчета текущего столбца. Воспользуемся циклом for от 1 до k включительно. Будем выводить текущее число и прибавлять к счётчику 1. Каждый раз, когда счётчик достигает семи, сбрасываем его в единицу и печатаем символ переноса строки \n. Также нужно не забыть, что числа от 1 до 9 занимают всего один символ в нашем календаре. Чтобы это исправить добавим дополнительный if, который ставит пробел перед числом.</p>
    <p>В самом конце проверим, в какой день недели закончился месяц. Если он закончился не в воскресенье, то необходимо допечатать перевод строки.</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int n, k;
  std::cin >> n >> k;

  int dayOfWeek = n;

  for (int i = 1; i &lt; n; ++i) {
    std::cout &lt;&lt; "   ";
  }

  for (int day = 1; day &lt;= k; ++day) {
    if (day &lt; 10) {
      std::cout &lt;&lt; " ";
    }

    std::cout &lt;&lt; day;

    if (dayOfWeek == 7) {
      std::cout &lt;&lt; "\n";
      dayOfWeek = 1;
    } else {
      std::cout &lt;&lt; " ";
      dayOfWeek += 1;
    }
  }

  if (dayOfWeek != 1) {
    std::cout &lt;&lt; "\n";
  }
}
</pre>
  </details>

  <h4>Задача «Сумма цифр»</h4>

  <details>
    <summary>Условие</summary>
    <p>Вычислите сумму цифр неотрицательного целого числа.</p>
    <h4>Формат ввода</h4>
    <p>На вход подаётся одно неотрицательное целое число, не превосходящее 10⁹</p>
    <h4>Формат вывода</h4>
    <p>Выведите сумму цифр этого числа.</p>
    <h4>Пример</h4>
    <code>59</code>
    <code>14</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>По условию задачи число помещается в тип int. Поэтому можно написать цикл, который будет прибавлять к ответу последнюю цифру этого числа (остаток при делении на 10) и делить число на 10 без учёта остатка.</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int x;
  std::cin >> x;

  int s = 0;
  while (x != 0) {
    s += x % 10;
    x /= 10;
  }

  std::cout &lt;&lt; s &lt;&lt; "\n";
}
</pre>

    <p>Есть более общее решение, которое подойдёт для чисел любого размера, не обязательно влезающих в int. Можно считать цифры числа в строку и обработать их посимвольно. Правда, для очень больших строк уже сама сумма цифр может не поместиться в int.</p>
    <p>Чтобы превратить очередной символ в цифру, воспользуемся тем, что символы цифр в таблице ASCII идут подряд. Поэтому разность кодов символов c - '0' будет как раз давать числовое представление очередной цифры.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string digits;
  std::cin >> digits;

  int s = 0;
  for (char digit : digits) {
    s += digit - '0';
  }

  std::cout &lt;&lt; s &lt;&lt; "\n";
}
</pre>
  </details>

  <h4>Задача «ln 2»</h4>

  <details>
    <summary>Условие</summary>
    <p>Значение натурального логарифма ln2 представляется в виде суммы 1 - 1/2 + 1/3 - 1/4 + ... + n(-1)n+1 с точностью до O(n). Напишите программу, выводящую сумму первых n членов этого ряда. Попробуйте также обойтись без использования инструкции if. Указание: используйте тип double для работы с числами с плавающей точкой. Используйте стандартную точность вывода.</p>
    <h4>Формат ввода</h4>
    <p>Вводится целое положительное число n, помещающееся в тип int.</p>
    <h4>Формат вывода</h4>
    <p>Программа выводит ответ на задачу.</p>

    <h4>Пример 1</h4>
    <code>3</code>
    <code>0.833333</code>

    <h4>Пример 2</h4>
    <code>2</code>
    <code>0.5</code>

    <h4>Пример 3</h4>
    <code>1</code>
    <code>1</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Объявим две переменные sign и result. В result будем складывать итоговое значение, а в sign будем хранить 1 или -1. Знак переменной sign будет каждый раз меняться.</p>
    <p>Важно привести один из аргументов дроби sign / i к типу double, чтобы не получилось целочисленного деления.Проще всего это сделать, выбрав для переменной sign тип double.</p>
<pre>
#include <iostream>

int main() {
  int n;
  std::cin >> n;

  double sign = 1;
  double result = 0.0;

  for (int i = 1; i &lt;= n; ++i) {
    result += sign / i;
    sign = -sign;
  }
  std::cout &lt;&lt; result &lt;&lt; "\n";
}
</pre>
  </details>

  <h3>Параграф «Векторы и строки»</h3>

  <h4>Задача «Пароли»</h4>

  <details>
    <summary>Условие</summary>

    <p>Пароль от некоторого сервиса должен удовлетворять таким ограничениям:</p>
    <ul>
      <li>состоять из символов таблицы ASCII с кодами от 33 до 126;</li>
      <li>быть не короче 8 символов и не длиннее 14;</li>
      <li>из 4 классов символов — большие буквы, маленькие буквы, цифры, прочие символы — в пароле должны присутствовать не менее трёх любых.</li>
    </ul>

    <p>Напишите программу, которая проверит, что введённый пароль подходит под эти ограничения.</p>

    <h4>Формат ввода</h4>
    <p>На входе дана одна строка с паролем.</p>

    <h4>Формат вывода</h4>
    <p>Выведите YES, если пароль удовлетворяет требованиям, и NO в противном случае.</p>

    <h4>Пример</h4>
    <code>Vasya123</code>
    <code>YES</code>

    <p>Вы можете воспользоваться функциями из заголовочного файла cctype или реализовать самостоятельно их аналоги.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Решение можно целиком записать внутри функции main, но нам будет удобнее оформить проверку пароля в виде отдельной функции IsGood, которая возвращает логическое значение. Из такой функции всегда можно удобно выйти с помощью return, если ответ уже известен.</p>
<pre>
#include &lt;iostream>
#include &lt;string>

bool IsGood(const std::string& password) {
  if (password.size() &lt; 8 || password.size() > 14) {
    return false;
  }
  int upper = 0;
  int lower = 0;
  int digit = 0;
  int other = 0;

  for (char c : password) {
    if (c &lt; 33 || c > 126) {
      return false;
    }
    if ('A' &lt;= c && c &lt;= 'Z') {
      upper = 1;
    } else if ('a' &lt;= c && c &lt;= 'z') {
      lower = 1;
    } else if ('0' &lt;= c && c &lt;= '9') {
      digit = 1;
    } else {
      other = 1;
    }
  }

  return upper + lower + digit + other >= 3;
}

int main() {
  std::string password;
  std::getline(std::cin, password);
  if (IsGood(password)) {
    std::cout &lt;&lt; "YES\n";
  } else {
    std::cout &lt;&lt; "NO\n";
  }
}
</pre>
    <p>Здесь мы используем явные сравнения с другими символами вида '0' &lt;= c && c &lt;= '9'. Можно было бы использовать функции std::isupper, std::islower и std::isdigit из заголовочного файла cctype.</p>
  </details>

  <h4>Задача «Soundex»</h4>

  <details>
    <summary>Условие</summary>
    <p>Известный алгоритм Soundex определяет, похожи ли два английских слова по звучанию. На вход он принимает слово и заменяет его на некоторый четырёхсимвольный код. Если коды двух слов совпадают, то слова, как правило, звучат похоже.</p>

    <p>Вам требуется реализовать этот алгоритм. Он работает так:</p>
    <ol>
      <li>Первая буква слова сохраняется.</li>
      <li>В остальной части слова буквы a, e, h, i, o, u, w и y удаляются;</li>
      <li>Оставшиеся буквы заменяются на цифры от 1 до 6, причём похожим по звучанию буквам соответствуют одинаковые цифры:
        <ul>
          <li>b, f, p, v: 1</li>
          <li>c, g, j, k, q, s, x, z: 2</li>
          <li>d, t: 3</li>
          <li>l: 4</li>
          <li>m, n: 5</li>
          <li>r: 6</li>
        </ul>
      </li>
      <li>Любая последовательность идущих подряд одинаковых цифр сокращается до одной такой цифры.</li>
      <li>Итоговая строка обрезается до первых четырёх символов.</li>
      <li>Если длина строки получилась меньше четырёх символов, в конце добавляются нули.</li>
    </ol>

    <p>Примеры:</p>
    <code>аmmonium → ammnm → a5555 → a5 → a500.</code>
    <code>implementation → implmnttn → i51455335 → i514535 → i514.</code>

    <h4>Формат ввода</h4>
    <p>На вход подаётся одно непустое слово из строчных латинских букв. Длина слова не превосходит 20 символов.</p>

    <h4>Формат вывода</h4>
    <p>Напечатайте четырёхбуквенный код, соответствующий слову.</p>

    <h4>Пример 1</h4>
    <code>ammonium</code>
    <code>a500</code>

    <h4>Пример 2</h4>
    <code>implementation</code>
    <code>i514</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Хотя задачу можно решить и без функций, нам будет удобно оформить её решение в виде отдельной функции Soundex. Шаги 3 и 4 можно оформить в виде оператора switch.</p>

    <p>Напишем также вспомогательную функцию Append, добавляющую символ к ответу в случае, если он не дублируется. В эту функцию удобно передать параметр res по ссылке, чтобы его можно было изменять.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

void Append(std::string& res, char c) {
  if (res.back() != c) {
    res.push_back(c);
  }
}

std::string Soundex(const std::string& word) {
  std::string res;
  res.push_back(word[0]);
  for (size_t i = 1; i != word.size(); ++i) {
    char c = word[i];
    switch (c) {
      case 'b':
      case 'f':
      case 'p':
      case 'v':
        Append(res, '1');
        break;
      case 'c':
      case 'g':
      case 'j':
      case 'k':
      case 'q':
      case 's':
      case 'x':
      case 'z':
        Append(res, '2');
        break;
      case 'd':
      case 't':
        Append(res, '3');
        break;
      case 'l':
        Append(res, '4');
        break;
      case 'm':
      case 'n':
        Append(res, '5');
        break;
      case 'r':
        Append(res, '6');
        break;
    }
  }
  while (res.size() &lt; 4) {
    res.push_back('0');
  }
  res.resize(4);
  return res;
}

int main() {
  std::string word;
  std::cin >> word;
  std::cout &lt;&lt; Soundex(word) &lt;&lt; "\n";
}
</pre>
  </details>

  <h4>Задача «Обратная перестановка»</h4>

  <details>
    <summary>Условие</summary>

    <p>На мероприятие приглашены n гостей. Им предлагают занять места с номерами от 1 до n в зале. Гости занимают эти места в произвольном порядке. Известно, на каком месте сел очередной гость.</p>

    <p>Выпишите для каждого очередного места номер гостя, который на него сел.</p>

    <h4>Формат ввода</h4>
    <p>Дано число n, а затем n различных чисел a1, a2, ... , an от 1 до n. Число ak — это номер места, на которое сел k-й гость.</p>

    <p>Число n не превосходит 20000.</p>

    <h4>Формат вывода</h4>
    <p>Выведите n чисел b1, b2, ... , bn от 1 до n. Число bk должно обозначать номер гостя, который сел на k-е место.</p>

    <h4>Пример 1</h4>
<pre>
4
3 1 2 4
</pre>
  <code>2 3 1 4</code>

    <h4>Пример 2</h4>
<pre>
11
11 6 8 2 10 9 4 7 3 1 5
</pre>
  <code>10 4 9 7 11 2 8 3 6 5 1</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Будем заполнять вектор seats, в котором для каждого номера места будет указан номер гостя. Не забудьте: элементы вектора индексируются с нуля, а номера мест и гостей в задаче начинаются с единицы.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  int n;
  std::cin >> n;

  std::vector&lt;int&gt; seats(n);
  for (int guest = 1; guest &lt;= n; ++guest) {
    int seat;
    std::cin >> seat;
    seats[seat - 1] = guest;
  }

  for (int guest : seats) {
    std::cout &lt;&lt; guest &lt;&lt; " ";
  }
  std::cout &lt;&lt; "\n";
}
</pre>
  </details>

  <h4>Задача «Сортировка по убыванию»</h4>

  <details>
    <summary>Условие</summary>
    <p>Вам даны строки текстового файла. Отсортируйте набор этих строк по убыванию.</p>

    <h4>Формат ввода</h4>
    <p>Количество строк не превосходит 1000. Каждая строка состоит из символов ASCII с кодами от 32 до 126, длина строки не превосходит 100.</p>

    <h4>Формат вывода</h4>
    <p>Напечатайте строки в отсортированном по убыванию порядке. Для сравнения строк друг с другом достаточно использовать стандартные операторы сравнения, определённые для std::string.</p>

    <h4>Пример</h4>
<pre>
one
two
three
</pre>
<pre>
two
three
one
</pre>
    <p>Примечания</p>
    <p>Компилятор не поддерживает std::ranges.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Строки необходимо прочитать и сложить в вектор, а затем отсортировать и вывести. По умолчанию они будут сортироваться по возрастанию. Есть несколько способов сделать сортировку и вывод в нужном порядке:</p>
    <ol>
      <li>строки можно напечатать в обратном порядке;</li>
      <li>можно передать в std::sort обратные итераторы;</li>
      <li>можно передать в std::sort свою функцию сравнения;</li>
      <li>можно передать в std::sort уже готовый компаратор std::greater&lt;std::string&gt;().</li>
    </ol>
    <p>Воспользуемся, например, вторым способом:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;std::string&gt; lines;

  std::string line;
  while (std::getline(std::cin, line)) {
    lines.push_back(line);
  }

  std::sort(lines.rbegin(), lines.rend());

  for (size_t i = 0; i != lines.size(); ++i) {
    std::cout &lt;&lt; lines[i] &lt;&lt; "\n";
  }
}
</pre>
    <p>Типичная ошибка в решении этой задачи — считывать строки через std::cin >> line вместо std::getline. Такой код прочитает строку не целиком, а до ближайшего пробельного разделителя.</p>
  </details>

  <h4>Задача «Палиндромы»</h4>

  <details>
    <summary>Условие</summary>
    <p>Дана строка из строчных латинских букв и пробелов. Проверьте, является ли она палиндромом без учета пробелов.</p>

    <h4>Формат ввода</h4>
    <p>На вход подается одна строка. В строке могут быть пробелы. Подряд может идти произвольное число пробелов. Длина строки не превосходит 100.</p>

    <h4>Формат вывода</h4>
    <p>Представьте, что из строки удалили все пробелы. Необходимо вывести YES, если полученная строка — палиндром, и NO в противном случае.</p>

    <h4>Пример 1</h4>
    <code>hello world</code>
    <code>NO</code>

    <h4>Пример 2</h4>
    <code>never odd or even</code>
    <code>YES</code>

    <p>Примечание</p>
    <p>Пустая строка считается палиндромом.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Будем поддерживать два индекса i и j, которые будут идти с разных сторон строки навстречу друг другу. Будем повторять цикл до тех пор, пока первый индекс меньше второго. В цикле будем игнорировать пробелы. Если будет найдено несоответствие символов, цикл можно досрочно закончить.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

int main() {
  std::string s;
  std::getline(std::cin, s);

  int i = 0;
  int j = static_cast&lt;int&gt;(s.size()) - 1;
  bool isPalindrome = true;

  while (i &lt; j) {
    if (s[i] == ' ') {
      ++i;
    } else if (s[j] == ' ') {
      --j;
    } else if (s[i] != s[j]) {
      isPalindrome = false;
      break;
    } else {
      ++i;
      --j;
    }
  }

  if (isPalindrome) {
    std::cout &lt;&lt; "YES\n";
  } else {
    std::cout &lt;&lt; "NO\n";
  }
}
</pre>
    <p>Вот изящное решение этой задачи для тех, кто прочитал параграф про алгоритмы стандартной библиотеки:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string s;
  std::getline(std::cin, s);

  std::erase(s, ' ');  // С++20

  // В С++17 пришлось бы написать
  // s.erase(std::remove(s.begin(), s.end(), ' '), s.end());

  if (std::equal(s.begin(), s.begin() + s.size() / 2, s.rbegin())) {
    std::cout &lt;&lt; "YES\n";
  } else {
    std::cout &lt;&lt; "NO\n";
  }
}
</pre>
  </details>

  <h4>Задача «Сапёр»</h4>

  <details>
    <summary>Условие</summary>
    <p>Вам необходимо построить поле для игры «Сапёр» по его конфигурации — высоте, ширине и координатам расставленных на нем мин.</p>
    <p>Вкратце напомним правила построения поля для игры «Сапёр»:</p>
    <ul>
      <li>поле состоит из клеток с минами и пустых клеток;</li>
      <li>клетки с миной обозначаются символом *;</li>
      <li>пустые клетки содержат число от 0 до 8 — количество мин на соседних клетках.</li>
    </ul>

    <h4>Формат ввода</h4>
    <p>В первой строке содержатся три числа:</p>
    <ul>
      <li>число m от 1 до 100 — количество строк на поле;</li>
      <li>число n от 1 до 100 — количество столбцов на поле;</li>
      <li>число k от 0 до mn — количество мин на поле.</li>
    </ul>
    <p>В следующих k строках содержатся пары чисел с координатами мин (номерами строки и столбца). Нумерация ведётся с единицы.</p>

    <h4>Формат вывода</h4>
    <p>Выведите построенное поле, разделяя строки поля символом \n, а столбцы — пробелом.</p>

    <h4>Пример</h4>
<pre>
3 2 2
1 1
2 2
</pre>
<pre>
* 2
2 *
1 1
</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Заведём двумерный вектор и будем записывать в него мины и количество мин в соседних клетках. Мины будет удобно обозначать минус единицей.</p>

    <p>Будем по очереди добавлять мины на игровое поле и для каждой мины сразу обновлять числа в соседних клетках.</p>

    <p>Чтобы не выписывать восемь однотипных проверок на соседние клетки, удобно будет создать вектор «сдвигов» и перебирать эти сдвиги в цикле.</p>

    <p>Можно также добавить к нашему игровому полю дополнительные клетки по краям, чтобы не делать проверки на корректность при обращении к соседней клетке. Поэтому размер поля в нашей программе на 2 больше указанного.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

struct Shift {
  int x = 0;
  int y = 0;
};

const std::vector&lt;Shift&gt; SHIFTS = {
  {-1, -1},
  {-1,  0},
  {-1,  1},
  { 0,  1},
  { 1,  1},
  { 1,  0},
  { 1, -1},
  { 0, -1},
};

int main() {
  size_t rows;
  size_t columns;
  size_t mines;
  std::cin >> rows >> columns >> mines;

  const int mineLabel = -1;

  std::vector&lt;std::vector&lt;int&gt; &gt; field(rows + 2, std::vector&lt;int&gt;(columns + 2));

  for (size_t index = 0; index != mines; ++index) {
    int row, column;
    std::cin >> row >> column;

    field[row][column] = mineLabel;

    for (auto shift : SHIFTS) {
      auto& cell = field[row + shift.x][column + shift.y];
      if (cell != mineLabel) {
        ++cell;
      }
    }
  }

  for (size_t row = 1; row &lt;= rows; ++row) {
    for (size_t column = 1; column &lt;= columns; ++column) {
      if (column > 1) {
        std::cout &lt;&lt; " ";
      }
      if (field[row][column] == mineLabel) {
        std::cout &lt;&lt; "*";
      } else {
        std::cout &lt;&lt; field[row][column];
      }
    }
    std::cout &lt;&lt; "\n";
  }
}
</pre>
    <p>Обратите внимание на инициализацию ссылки cell. Мы специально объявили cell как ссылку, чтобы по этому краткому имени можно было изменить значение.</p>
  </details>

  <h3>Параграф «Функции»</h3>

  <h4>Задача «ArgMax в матрице»</h4>

  <details>
    <summary>Условие</summary>
    <p>Вам требуется написать на C++ функцию со следующим заголовком:</p>
    <code>std::pair&lt;size_t, size_t&gt; MatrixArgMax(const std::vector&lt;std::vector&lt;int&gt; &gt;& matrix);</code>
    <p>Функция должна вернуть пару из индексов максимального элемента в матрице. Если максимальных элементов несколько, то нужно вернуть наименьшую такую пару.</p>

    <p>Примечания</p>
    <p>Считайте, что матрица задана корректно: все строки одинаковой длины, пустых строк нет. В матрице всегда есть хотя бы один элемент.</p>
    <p>Подключите необходимые заголовочные файлы и напишите только код функции MatrixArgMax. Мы скомпилируем решение с нашей функцией main.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Сохраним в переменной argMax позицию начального элемента матрицы, а в переменной max — значение этого элемента. Обойдём все элементы матрицы с помощью вложенного цикла. Если обнаружим новый максиммум, то обновим эти переменные.</p>
<pre>
#include &lt;utility&gt;
#include &lt;vector&gt;

std::pair&lt;size_t, size_t&gt; MatrixArgMax(const std::vector&lt;std::vector&lt;int&gt; &gt;& matrix) {
  std::pair&lt;size_t, size_t&gt; argMax = {0, 0};
  int max = matrix[0][0];
  for (size_t i = 0; i != matrix.size(); ++i) {
    for (size_t j = 0; j != matrix[i].size(); ++j) {
      if (matrix[i][j] > max) {
        max = matrix[i][j];
        argMax = {i, j};
      }
    }
  }
  return argMax;
}
</pre>
  </details>

  <h4>Задача «Общий префикс»</h4>

  <details>
    <summary>Условие</summary>
    <p>Напишите функцию для вычисления наибольшего общего префикса строк, переданных в векторе words:</p>
    <code>std::string CommonPrefix(const std::vector&lt;std::string&gt;& words);</code>
    <p>Например, для пустого вектора функция должна вернуть пустую строку, а для вектора из строк "apple", "apricot" и "application" — строку "ap".</p>

    <p>Примечание</p>
    <p>В решении не должно быть функции main: она будет в нашей тестирующей программе. Подключите необходимые библиотеки и напишите код функции CommonPrefix.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Давайте напишем вспомогательную функцию для вычисления общего префикса двух строк. Для этого будем идти по символам строк и проверять, равны ли они. Важно не выйти за пределы строки.</p>
<pre>
#include &lt;string&gt;
#include &lt;vector&gt;

std::string CommonPrefix(const std::string& a, const std::string& b) {
  size_t i = 0;
  while (i != a.size() && i != b.size() && a[i] == b[i]) {
    ++i;
  }
  return a.substr(0, i);
}
</pre>
    <p>Теперь можно просто перебрать поданные на вход строки и вычислять на каждом шаге общий префикс у текущей строки и старого префикса:</p>
<pre>
std::string CommonPrefix(const std::vector&lt;std::string&gt;& words) {
  if (words.empty()) {
    return {};
  }
  std::string prefix = words[0];
  for (size_t i = 1; i != words.size() && !prefix.empty(); ++i) {
    prefix = CommonPrefix(prefix, words[i]);
  }
  return prefix;
}
</pre>
    <p>Здесь мы вызываем в цикле первую функцию CommonPrefix. Компилятор понимает какую из функций надо вызвать по типам аргументов (здесь передаётся не вектор строк, а две строки).</p>

    <p>Недостаток этого решения в том, что мы много раз создаём новые строки (префиксы), хотя на самом деле все они являются подстроками первой строки. Поэтому давайте перепишем первую функцию, чтобы она использовала std::string_view — конструкцию, о которой мы поговорим в параграфе «Адаптеры и представления». Во второй функции объявим prefix с явным типом std::string_view, а в конце вернём std::string(prefix): преобразование из string_view обратно в string надо описывать явно.</p>
<pre>
#include &lt;string&gt;
#include &lt;string_view&gt;
#include &lt;vector&gt;

std::string_view CommonPrefix(const std::string_view a, const std::string_view b) {
  size_t i = 0;
  while (i != a.size() && i != b.size() && a[i] == b[i]) {
    ++i;
  }
  return a.substr(0, i);
}

std::string CommonPrefix(const std::vector&lt;std::string&gt;& words) {
  if (words.empty()) {
    return {};
  }
  std::string_view prefix = words[0];
  for (size_t i = 1; i != words.size() && !prefix.empty(); ++i) {
    prefix = CommonPrefix(prefix, words[i]);
  }
  return std::string(prefix);
}
</pre>
    <p>Рассмотрим альтернативное решение с синхронным проходом. Будем одновременно идти по всем словам. Для этого удобно сначала вычислить их минимальную длину, чтобы было проще проверять, когда пора остановиться.</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

std::string CommonPrefix(const std::vector&lt;std::string&gt;& words) {
  if (words.empty()) {
    return {};
  }

  size_t minLen = words[0].size();
  for (const auto& word : words) {
    minLen = std::min(minLen, word.size());
  }

  for (size_t i = 0; i &lt; minLen; ++i) {
    const char c = words[0][i];
    for (const auto& word : words) {
      if (word[i] != c) {
        return word.substr(0, i);
      }
    }
  }

  return words[0].substr(0, minLen);
}
</pre>
  </details>

  <h4>Задача «Функция Split»</h4>

  <details>
    <summary>Условие</summary>
    <p>Вам требуется написать функцию со следующим заголовком:</p>
    <code>std::vector<std::string> Split(const std::string& str, char delimiter);</code>
    <p>Функция должна вернуть вектор строк, полученный разбиением строки str на части по указанному символу-разделителю delimiter. Если разделитель встретился в начале или в конце строки str, то в начале (соответственно, в конце) вектора с результатом должна быть пустая строка. Если два разделителя встретились рядом, то пустая строка между ними тоже должна попасть в ответ. Для пустой строки надо вернуть вектор, содержащий одну пустую строку.</p>
    <p>Например, Split("What_is_your_name?", '_') должна вернуть вектор из строк What, is, your иname?.</p>

    <p>Примечание</p>
    <p>Подключите необходимые заголовочные файлы и напишите только код функции Split. Мы скомпилируем решение с нашей функцией main.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Заметим, что количество элементов в ответе должно оказаться на единицу больше количества символов-разделителей в строке.</p>
    <p>Будем поддерживать два индекса: начало и конец очередного фрагмента строки. Будем сдвигать конец вправо. Если нам встретится разделитель, добавим этот фрагмент к ответу и переназначим начало будущего фрагмента на следующий индекс.</p>
    <p>В конце надо будет отдельно добавить к ответу последний фрагмент.</p>
<pre>
#include &lt;string&gt;
#include &lt;vector&gt;

std::vector&lt;std::string&gt; Split(const std::string& str, char delimiter) {
  std::vector&lt;std::string&gt; result;
  size_t i = 0;
  for (size_t j = 0; j != str.size(); ++j) {
    if (str[j] == delimiter) {
      result.push_back(str.substr(i, j - i));
      i = j + 1;
    }
  }
  result.push_back(str.substr(i));
  return result;
}
</pre>
    <p>Заметим, что если исходная строка будет существовать после вызова функции, то может оказаться эффективнее разбивать строку на std::string_view (мы поговорим об этой конструкции в параграфе «Адаптеры и представления»).</p>
<pre>
#include &lt;string&gt;
#include &lt;string_view&gt;
#include &lt;vector&gt;

std::vector&lt;std::string_view&gt; Split(const std::string& s, char delimiter) {
  std::string_view str = s;
  std::vector&lt;std::string_view&gt; result;
  size_t i = 0;
  for (size_t j = 0; j != str.size(); ++j) {
    if (str[j] == delimiter) {
      result.push_back(str.substr(i, j - i));
      i = j + 1;
    }
  }
  result.push_back(str.substr(i));
  return result;
}
</pre>
  </details>

  <h4>Задача «Функция Join»</h4>

  <details>
    <summary>Условие</summary>
    <p>Вам требуется написать функцию Join со следующим заголовком:</p>
    <code>std::string Join(const std::vector&lt;std::string&gt;& tokens, char delimiter);</code>
    <p>Функция должна вернуть строку, полученную склейкой элементов вектора через указанный разделитель. Например, Join({"What", "is", "your", "name?"}, '_') должна вернуть строку "What_is_your_name?".</p>

    <p>Примечание</p>
    <p>Если вектор tokens пустой, то функция должна вернуть пустую строку. Если в векторе tokens ровно один элемент, то он и должен вернуться в ответе.</p>
    <p>Подключите необходимые заголовочные файлы и напишите только код функции Join. Мы скомпилируем решение с нашей функцией main.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Будем идти по вектору и добавлять в ответ разделитель и очередной токен. Важно, чтобы разделители не оказались по краям — они должны быть только между токенами.</p>
<pre>
#include &lt;string&gt;
#include &lt;vector&gt;

std::string Join(std::vector&lt;std::string&gt;& tokens, char delim) {
  std::string result;
  for (size_t i = 0; i != tokens.size(); ++i) {
    if (i > 0) {
      result += delim;
    }
    result += tokens[i];
  }
  return result;
}
</pre>
  </details>

  <h4>Задача «Транспонировать матрицу»</h4>

  <details>
    <summary>Условие</summary>
    <p>Дана прямоугольная матрица A из m строк и n столбцов. Транспонированной матрицей AT называется матрица из n строк и m столбцов, в которой строки и столбцы поменялись ролями: элемент  Aij равен элементу Aji.</p>
    <p>Напишите функцию, которая возвращает транспонированную матрицу:</p>
    <code>std::vector&lt;std::vector&lt;int&gt; &gt; Transpose(const std::vector&lt;std::vector&lt;int&gt; &gt;& matrix);</code>

    <p>Примечание</p>
    <p>Гарантируется, что вектор matrix непуст и все его элементы имеют равную ненулевую длину.</p>
    <p>Подключите необходимые заголовочные файлы и напишите только код функции Transpose. Мы скомпилируем решение с нашей функцией main.</p>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;vector&gt;

std::vector&lt;std::vector&lt;int&gt; &gt; Transpose(const std::vector&lt;std::vector&lt;int&gt; &gt;& matrix) {
  const size_t m = matrix.size();
  const size_t n = matrix[0].size();

  std::vector&lt;std::vector&lt;int&gt; &gt; result(n);
  for (size_t j = 0; j != n; ++j) {
    result[j].resize(m);
    for (size_t i = 0; i != m; ++i) {
      result[j][i] = matrix[i][j];
    }
  }
  return result;
}
</pre>
  </details>

  <h4>Задача «Сортировка точек»</h4>

  <details>
    <summary>Условие</summary>
    <p>Вам даны координаты точек на плоскости. Выведите эти точки в порядке возрастания расстояний до начала координат.</p>

    <h4>Формат ввода</h4>
    <p>Сначала задано количество точек n. Затем идет последовательность из n строк, каждая из которых содержит два целых числа — координаты точки. Величина n не превосходит 100. Координаты точек по модулю не превосходят 1000.</p>

    <h4>Формат вывода</h4>
    <p>Выведите через пробел кординаты точек в порядке возрастания расстояний до начала координат. После каждой пары координат печатайте перевод строки.</p>

    <h4>Пример</h4>
<pre>
2
2 3
1 2
</pre>
<pre>
1 2
2 3
</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Создадим структуру Point для хранения точки. Заполним вектор этих структур. Напишем лямбда-функцию для сравнения двух точек. Заметим, что вычислять квадратный корень не обязательно: достаточно сравнить целочисленную сумму квадратов.</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

struct Point {
  int x;
  int y;
};

int main() {
  size_t n;
  std::cin >> n;

  std::vector&lt;Point&gt; points(n);

  for (size_t i = 0; i != n; ++i) {
    std::cin >> points[i].x >> points[i].y;
  }

  std::sort(
    points.begin(),
    points.end(),
    [](const Point& p1, const Point& p2) {
      return p1.x * p1.x + p1.y * p1.y &lt; p2.x * p2.x + p2.y * p2.y;
    }
  );

  for (const auto& point : points) {
    std::cout &lt;&lt; point.x &lt;&lt; " "
              &lt;&lt; point.y &lt;&lt; "\n";
  }
}
</pre>
    <p>Недостаток этого решения в том, что для каждого сравнения пары точек приходится вычислять сумму квадратов заново. Можно было бы предрассчитать расстояния от каждой точки до начала координат отдельно и отсортировать уже по готовым значениям.</p>
  </details>
</article>


<!-- 3.1 Последовательные контейнеры -->
<article class="article">
  <div class="anchor" id="p3.1"></div>
  <h2>3 Стандартная библиотека C++</h2>
  <h3>3.1 Последовательные контейнеры</h3>

  <p>Стандартная библиотека C++ содержит набор шаблонных контейнеров. С некоторыми из них мы уже знакомы: это std::vector и std::string. Эти два контейнера гарантируют, что элементы (в случае string — символы строки) будут храниться в непрерывном фрагменте памяти. Эти контейнеры умеют эффективно добавлять элементы в конец, делая реаллокацию при необходимости, но не могут обеспечить эффективную вставку или удаление элементов в других позициях.</p>
  <p>В этом параграфе мы рассмотрим другие последовательные контейнеры. Они не обязательно хранят элементы в непрерывном куске памяти, но позволяют обойти элементы в последовательном порядке.</p>
  <p>Как правило, контейнеры определены в одноимённом заголовочном файле стандартной библиотеки.</p>

  <h4>Контейнер std::array</h4>

  <p>Если вам нужен массив фиксированного, известного в момент компиляции размера, то используйте std::array. Вот так можно объявить array из трёх элементов:</p>
<pre>
#include &lt;array&gt;

int main() {
  std::array&lt;int, 3&gt; point = {1, 2, -3};
}
</pre>
  <p>Внутри array&lt;T, N&gt; является обёрткой над низкоуровневым массивом T[N], но предоставляет интерфейс стандартного контейнера: знает свой размер, умеет присваиваться, предоставляет итераторы и т. д. Как и у вектора, элементы array располагаются в памяти непрерывно, но хранятся не в динамической памяти, а на стеке (мы разберём подробности в параграфе «Жизненный цикл объекта»).</p>
  <p>Важно подчеркнуть, что размер array должен быть задан в момент компиляции и не может изменяться во время работы программы.</p>

  <h4>Контейнер std::deque</h4>

  <p>Deque расшифровывается как double-ended queue (двусторонняя очередь).</p>
  <p>Если вектор располагает элементы в памяти непрерывно, то std::deque располагает их кусочно-непрерывно, в отдельных страницах (непрерывных блоках) памяти фиксированного размера. Но даже для хранения одного элемента в деке будет выделена целая страница. Сами страницы не обязательно расположены в памяти подряд. Отдельно поддерживается перечень указателей на начала страниц. Размеры страниц зависят от sizeof(T) и от конкретной реализации дека. Например, для std::deque&lt;int&gt; они могут занимать 4 килобайта.</p>
  <p>Дек умеет эффективно добавлять и удалять элементы в начале и в конце: это приводит к выделению новой страницы при необходимости. Вставка по краям в деке эффективнее, чем в векторе, так как реаллокаций нет и старые элементы никогда не приходится копировать. В отличие от вектора, дек гарантирует, что при вставке или удалении по краям элементы останутся в тех же самых ячейках памяти, что и были. Вставка в середину дека и удаление из неё уже требуют сдвига элементов.</p>
  <p>Как и вектор, дек поддерживает обращение к элементу по индексу за O(1): так как размер страниц фиксирован и начальная позиция в первой странице известна, то можно легко вычислить нужную страницу и позицию в ней. Однако для обращения к элементу деку приходится делать два разыменования указателей, а вектору — только одно.</p>
<pre>
#include &lt;deque&gt;
#include &lt;iostream&gt;

int main() {
  std::deque&lt;int&gt; d = {1, 2, 3, 4};

  d.push_back(5);  // добавление в конец, как у вектора
  d.push_back(6);
  d.pop_back();  // удаление из конца, как у вектора

  d.push_front(0);  // добавление в начало
  d.push_front(-1);
  d.pop_front();  // удаление из начала

  // элементы дека: 0, 1, 2, 3, 4, 5

  // обращение по индексам:
  for (size_t i = 0; i != d.size(); ++i) {
    std::cout &lt;&lt; d[i] &lt;&lt; "\n";
  }

  // range-based for:
  for (int x : d) {
    std::cout &lt;&lt; x &lt;&lt; "\n";
  }
}
</pre>

  <h4>Контейнер std::list</h4>

  <p>Двусвязный список std::list хранит элементы в отдельных узлах. Узлы могут располагаться в разных местах памяти, никакого требования непрерывности нет. В узле рядом с самим элементом хранится указатель на предыдущий и следующий узлы. Можно представить себе отдельный узел двусвязного списка для элементов типа T примерно так:</p>
<pre>
template &lt;typename T&gt;
struct Node {
  T value;
  Node* prev;
  Node* next;
};
</pre>
  <p>Сам список хранит указатели на начальный и конечный узлы. К узлу нельзя эффективно обратиться по номеру (для этого пришлось бы идти в цикле по списку начиная от головы). Поэтому пройтись по списку можно только с помощью range-based for или итераторов:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;list&gt;

int main() {
  std::list&lt;int&gt; l = {10, 15, 20};
  l.push_front(5);
  l.push_front(0);

  l.push_back(25);
  l.push_back(30);

  l.pop_front();
  l.pop_back();

  for (int x : l) {
    std::cout &lt;&lt; x &lt;&lt; "\n";  // 5 10 15 20 25
  }
}
</pre>

  <h4>Итераторы списка</h4>

  <p>Итераторы — это специальные объекты, предназначенные для навигации по контейнеру. Итераторы позволяют обращаться к текущему элементу контейнера и сдвигаться к соседним элементам. Итератор, указывающий на начальный элемент контейнера, возвращает функция begin.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;list&gt;

int main() {
  std::list&lt;int&gt; l = {10, 15, 20};

  // Используем auto, чтобы не писать громоздкий тип std::list&lt;int>::iterator
  auto iter = l.begin();
  // печатаем начальный элемент
  std::cout &lt;&lt; *iter &lt;&lt; "\n";
  ++iter;  // сдвигаемся к следующему элементу
  --iter;  // возвращаемся назад
}
</pre>
  <p>Итераторы в C++ создавались по подобию указателей: их можно разыменовывать (*) и сдвигать (++ и --). Однако операторы ++ и -- для обычных указателей сдвигаются на соседние ячейки памяти, а двусвязный список хранит свои элементы разрозненно. Поэтому указатели могут подойти на роль итераторов лишь для контейнеров с непрерывным хранением (array, vector и string).</p>
  <p>Функция end у контейнера возвращает особый итератор, который указывает за последний элемент контейнера. Этот итератор нельзя разыменовывать. С ним можно только сравниваться:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;list&gt;

int main() {
  std::list&lt;int&gt; l = {10, 15, 20};
  for (auto iter = l.begin(); iter != l.end(); ++iter) {
    // печатаем элементы списка через итератор
    std::cout &lt;&lt; *iter &lt;&lt; "\n";
  }

  for (auto iter = l.rbegin(); iter != l.rend(); ++iter) {
    // проход по списку в обратном порядке
    std::cout &lt;&lt; *iter &lt;&lt; "\n";
  }
}
</pre>
  <p>С помощью итераторов можно вставлять (insert) или удалять (erase) элементы или целые цепочки элементов в любом месте списка:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;list&gt;

int main() {
  std::list&lt;int&gt; l = {0, 10, 15, 20};

  auto iter = l.begin();
  ++iter;
  l.insert(iter, 5);  // вставляем на эту позицию элемент

  // Удаляем из списка чётные числа
  for (auto iter = l.begin(); iter != l.end(); ) {
    if (*iter % 2 == 0) {
      // возвращается итератор на элемент, следующий за удалённым
      iter = l.erase(iter);
    } else {
      ++iter;
    }
  }

}
</pre>
  <p>С итераторами стандартных контейнеров мы познакомимся подробнее в других параграфах. Заметим пока, что к итераторам списка (в отличие от итераторов вектора) нельзя прибавлять произвольные целые числа, чтобы сдвинуть их на несколько позиций вперёд: эта операция не может быть реализована эффективно за константное время. Стандартная функция std::advance из заголовочного файла iterator умеет делать это за константное время для итераторов контейнеров с индексацией и за линейное время для итераторов списка. А функции std::next и std::prev возвращают следующее и предыдущее значения итератора соответственно.</p>
<pre>
#include &lt;iterator&gt;
#include &lt;list&gt;

int main() {
  std::list&lt;int&gt; l = {0, 10, 15, 20};

  // вместо этого удобнее воспользоваться функцией std::next:
  // auto iter = l.begin();
  // ++iter;

  // итератор указывает на второй элемент списка
  auto iter = std::next(l.begin());

  // итератор указывает на последний элемент
  std::advance(iter, 2);
}
</pre>

  <h4>Контейнер std::forward_list</h4>

  <p>Односвязный список std::forward_list нужен там, где требуется сэкономить память на хранении ссылок на предыдущий узел. По такому контейнеру можно пройтись только вперёд, а вставка разрешена только в начало (или после указанного итератора). Этот контейнер встречается в некоторых реализациях хеш-таблицы unordered_map для хранения элементов с одинаковыми хешами.</p>
<pre>
#include &lt;forward_list&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;

int main() {
  std::forward_list&lt;int&gt; fl = {3, 42, 5};
  fl.push_front(2);
  // fl.push_back(10);  // ошибка компиляции!

  auto iter = std::next(fl.begin());
  iter = fl.erase_after(iter);
  fl.insert_after(iter, 4);

  for (int x : fl) {
    std::cout &lt;&lt; x &lt;&lt; "\n";  // 2 3 5 4
  }
}
</pre>
  <p>Функции insert_after и erase_after своими названиями подчёркивают своё отличие от insert и erase у других контейнеров, работающих с текущей позицией. В односвязном списке не получится вставить элемент на текущую позицию, как это делает insert в std::list, поскольку к предыдущему элементу невозможно обратиться, а его ссылку на следующий элемент надо поправить</p>
  <p>Упражнение: сравните интерфейсы (набор функций) контейнеров list и forward_list и объясните различия.</p>

  <h4>Инвалидация итераторов и ссылок</h4>

  <p>Если контейнер изменяется, то в некоторых случаях итераторы и ссылки (указатели) на элементы могут стать невалидными. Рассмотрим пример:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; v = {1, 2, 3, 4};

  auto iter = v.begin();  // итератор
  int* ptr = &v.front();  // указатель
  int& ref = v.front();  // ссылка

  std::cout &lt;&lt; *iter &lt;&lt; " " &lt;&lt; *ptr
  &lt;&lt; " " &lt;&lt; ref &lt;&lt; "\n";  // 1 1 1

  v.push_back(5);  // происходит реаллокация

  // обращаться к старым итераторам, указателям и ссылкам больше нельзя:
  std::cout &lt;&lt; *iter &lt;&lt; " " &lt;&lt; *ptr
  &lt;&lt; " " &lt;&lt; ref &lt;&lt; "\n";  // неопределённое поведение!
}
</pre>
  <p>В этом примере показано, что итераторы, указатели или ссылки могут оказаться невалидными, если у вектора произошла реаллокация. Рассмотрим, как ведут себя итераторы других последовательных контейнеров при добавлении элементов в конец. Указатели и ссылки тут либо вместе инвалидируются, либо вместе остаются валидными, так как они в конечном итоге смотрят на память, которую занимал элемент.</p>
  <ol>
    <li>Строка std::string ведёт себя так же, как и вектор: все итераторы и ссылки инвалидируются.</li>
    <li>В std::array ничего вставить нельзя, его размер фиксирован.</li>
    <li>В std::deque инвалидируются итераторы, но не инвалидируются ссылки и указатели! Сами элементы дека остаются в тех же местах памяти, но во внутреннем векторе страниц, про который должен знать итератор дека, вообще говоря, может произойти реаллокация.</li>
    <li>В std::list и std::forward_list ни итераторы, ни ссылки не инвалидируются. Так что если в приведённом примере заменить vector на list, то он будет корректно работать.</li>
  </ol>
  <p>Валидность итераторов и ссылок после вызова той или иной функции контейнера описывается в документации</p>
</article>


<!-- 3.2 Ассоциативные контейнеры -->
<article class="article">
  <div class="anchor" id="p3.2"></div>
  <h3>3.2 Ассоциативные контейнеры</h3>

  <p>Ассоциативные контейнеры сопоставляют ключам некоторые значения.</p>
  <p>В стандартной библиотеке есть ассоциативные контейнеры, основанные на сбалансированных деревьях поиска (map, set) и контейнеры, основанные на хеш-таблицах (unordered_map, unordered_set). В этих контейнерах ключи уникальны, то есть, не могут повторяться. Также существуют и multi-версии этих контейнеров, в которых допускаются повторы ключей.</p>
  <p>Так как C++ — статически типизированный язык, типы ключей и значений должны быть строго зафиксированы на этапе компиляции.</p>

  <h4>Контейнер std::map</h4>

  <p>Начнём с контейнера std::map. Он определен в заголовочном файле map. Аналогично вектору, std::map является шаблонным: в угловых скобках нужно указать типы ключей и значений. Рассмотрим пример:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;string&gt;

int main() {
  // инициализируем map набором пар {ключ, значение}
  std::map&lt;std::string, int&gt; years = {
    {"Moscow", 1147},
    {"Rome", -753},
    {"London", 47},
  };

  for (const auto& [city, year] : years) {
    std::cout &lt;&lt; city &lt;&lt; ": " &lt;&lt; year &lt;&lt; "\n";
  }
}
</pre>
  <p>Вывод программы:</p>
<pre>
London: 47
Moscow: 1147
Rome: -753
</pre>
  <p>При итерации с помощью ranged-based for возвращаются пары std::pair из константного ключа и значения. Для итерации по элементам мы использовали structured binding, прикрепив ссылки city и year к элементам возвращаемой пары, а также auto для автоматического вывода типа. Согласитесь, это удобнее, чем такая форма записи:</p>
<pre>
for (const std::pair&lt;const std::string, int&gt;& item : years) {
  std::cout &lt;&lt; item.first &lt;&lt; ": " &lt;&lt; item.second &lt;&lt; "\n";
}
</pre>
  <p>Контейнер map реализован как красно-чёрное дерево — сбалансированное дерево поиска с особыми свойствами. Поэтому его элементы при итерации обходятся в порядке возрастания ключей, а на самих ключах должен быть определён оператор &lt; для сравнения.</p>
  <p>Внутренне устройство красно-чёрных деревьев мы оставим за рамками этого учебника: для нас важнее научиться пользоваться таким контейнером и знать, что три основных операции — поиск, вставка и удаление элемента — выполняются за логарифмическое время O(logn) от числа элементов в контейнере. Покажем, как воспользоваться этими операциями.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;string&gt;

int main() {
  std::map&lt;std::string, int&gt; data;
  std::string key;
  int value;

  while (std::cin >> key >> value) {
    data[key] = value;  // вставка
  }

  data.erase("hello");  // удаление

  // поиск
  if (auto iter = data.find("test"); iter != data.end()) {
    std::cout &lt;&lt; "Found the key " &lt;&lt; iter->first
    &lt;&lt; " with the value " &lt;&lt; iter->second &lt;&lt; "\n";
  } else {
    std::cout &lt;&lt; "Not found\n";
  }
}
</pre>
  <p>Рассмотрим эту программу подробнее.</p>
  <p>Для вставки мы использовали обращение по ключу в квадратных скобках: data[key] = value. В отличие от вектора или дека, ключ теперь не обязательно является индексом: в нашем случае это строка. Альтернативные способы вставки — data.insert({key, value}) или data.insert_or_assign(key, value).</p>
  <p>Эти функции принимают пару из ключа и значения, поэтому нам пришлось обрамить в фигурные скобки key и value, чтобы экземпляр std::pair сконструировался на лету. Если ключ key уже существует в контейнере, то data[key] = value и функция insert_or_assign его перезапишут, а insert — нет (но вернет информацию о старом значении).</p>
  <p>Удаляя элемент по ключу, можно не заботиться о его наличии в контейнере: если ключа нет, то функция erase просто ничего не поменяет.</p>
  <p>Для поиска элемента мы вызываем функцию find, которая возвращает итератор. Мы пользуемся версией if с инициализатором, чтобы сразу сохранить этот итератор в переменную iter и потом проверить его значение. Такая переменная будет видна только внутри условного оператора: таким образом мы подчеркнём, что iter нам нужен только здесь. Итератор будет либо указывать на пару из найденного ключа и его значения, либо окажется равен значению data.end(), если ключ не найден. Обратиться к найденной паре можно через унарную звёздочку или стрелочку (iter->first означает (*iter).first). Это похоже на указатели, но важно понимать, что итератор ассоциативного контейнера — это не указатель, а самостоятельный объект.</p>
  <p>Вернёмся ещё раз к конструкции data[key]. Она возвращает ссылку на значение, которому можно что-то присвоить. Сначала она проверяет, есть ли уже такой ключ в контейнере. Если ключа нет, он тут же вставляется в контейнер со значением по умолчанию (0 для int). Затем возвращается ссылка на значение в контейнере.</p>
  <p>Такое поведение оператора [] требует, чтобы контейнер data был изменяемым. Поэтому выражение data[key] не скомпилируется, если data — константа:</p>
<pre>
void Check(const std::map&lt;std::string, int&gt;& data) {
  if (data["total"] > 0) {  // ошибка компиляции!
    // ...
  }
}
</pre>
  <p>Если мы уверены, что ключ в контейнере есть, то можно воспользоваться функцией at:</p>
<pre>
void Check(const std::map&lt;std::string, int&gt;& data) {
  if (data.at("total") > 0) {  // OK, это скомпилируется
    // ...
  }
}
</pre>
  <p>Если же ключа всё же не окажется, то at во время работы программы сгенерирует исключение — «цивилизованную» ошибку, которую можно перехватить и обработать. Исключения мы обсудим в параграфе «Обработка исключений».</p>

  <h4>Задача о подсчёте частот слов</h4>

  <p>Рассмотрим классическую задачу: построить частотный словарь из текстового файла. Возьмём для тестирования файл text8 с сайта mattmahoney.net. Это архив со словами статей из английской «Википедии» общим объёмом 100 мегабайт. Его часто используют для оценки эффективности алгоритмов сжатия и для машинного обучения систем обработки текстов.</p>
  <p>Напишем программу, которая подсчитывает количество повторов для каждого слова. Слова будем читать со стандартного ввода просто до ближайшего пробельного разделителя.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;string&gt;

int main() {
  std::map&lt;std::string, int&gt; freqs;
  std::string word;
  while (std::cin >> word) {
    ++freqs[word];
  }
  for (const auto& [word, freq] : freqs) {
    std::cout &lt;&lt; word &lt;&lt; "\t"
     &lt;&lt; freq &lt;&lt; "\n";
  }
}
</pre>
  <p>Посмотрите, как мы элегантно добавляем очередное слово в ассоциативный массив через ++freqs[word]! Если слово уже встречалось, то мы просто увеличиваем его частоту. Если такого слова не было, то во freqs автоматически вставится такой ключ со значением 0, и мы тут же увеличим это значение на 1.</p>
  <p>Запустим программу, передав ей на вход файл text8, и посмотрим на первые 10 строк её вывода:</p>
<pre>
$ clang++ --std=c++20 -o count_freqs count_freqs.cpp
$ ./count_freqs &lt; text8 | head
a	325873
aa	276
aaa	57
aaaa	7
aaaaaacceglllnorst	1
aaaaaaccegllnorrst	1
aaaaaah	1
aaaaaalmrsstt	1
aaaaaannrstyy	1
aaaaabbcdrr	1
</pre>
  <p>Мы уже знаем, что итерация по контейнеру map обходит узлы в порядке возрастания ключей. Поэтому мы увидели первые «слова» по алфавиту. Позже мы попробуем сделать так, чтобы слова были отсортированы по убыванию частоты. А сейчас давайте попробуем замерить время работы нашей программы. Скомпилируем её с максимальным уровнем оптимизаций (ключ -O3) и направим её вывод в /dev/null (он нам не нужен). Замеряем время с помощью консольной утилиты time.</p>
<pre>
$ clang++ --std=c++20 -O3 -o count_freqs count_freqs.cpp
$ time ./count_freqs &lt; text8 > /dev/null
real    0m5,541s
user    0m5,500s
sys     0m0,040s
</pre>
  <p>Конечно, реальное время работы зависит от процессора и других факторов. Но нельзя ли обработать файл быстрее, чем за пять с половиной секунд? В этом нам поможет контейнер std::unordered_map.</p>

  <h4>Контейнер std::unordered_map</h4>

  <p>Воспользуемся другой реализацией ассоциативного массива из стандартной библиотеки C++ — хеш-таблицей unordered_map. Само название этого класса подчёркивает, что данные будут храниться не упорядоченными по ключу. Предполагается, что для каждого ключа определена хеш-функция (по умолчанию std::hash&lt;Key&gt;()), а по ней вычисляется номер корзины (bucket), в которую должен попасть ключ.</p>
  <p>Случай, когда два разных ключа оказываются в одной корзине, называется коллизией. В С++ для разрешения коллизий используется метод цепочек, то есть, внутри одной корзины все элементы выстраиваются в односвязный список.</p>
  <p>Если хеш-функция достаточно равномерна и корзин достаточно много, то в среднем время поиска, добавления и удаления элементов для unordered_map будет константным O(1).</p>
  <p>Интерфейс unordered_map специально сделан похожим на интерфейс map. Нам будет достаточно заменить только заголовочный файл и имя контейнера:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;

int main() {
  std::unordered_map&lt;std::string, int&gt; freqs;
  std::string word;
  while (std::cin >> word) {
    ++freqs[word];
  }
  for (const auto& [word, freq] : freqs) {
    std::cout &lt;&lt; word &lt;&lt; "\t" &lt;&lt; freq &lt;&lt; "\n";
  }
}
</pre>
  <p>Порядок обхода теперь выглядит произвольным (но на самом деле он диктуется хеш-функцией):</p>
<pre>
$ clang++ --std=c++20 -o count_freqs count_freqs.cpp
$ ./count_freqs &lt; text8 | head
storerooms	2
fretensis	1
metzada	1
workmans	1
mikhailgorbachev	1
naevus	3
buildups	1
clandenstine	1
democratised	1
wilgoren	2
</pre>
  <p>Время работы сократилось с 5,5 до 3,1 секунды:</p>
<pre>
$ clang++ --std=c++20 -O3 -o count_freqs count_freqs.cpp
$ time ./count_freqs &lt; text8 > /dev/null
real    0m3,117s
user    0m3,080s
sys     0m0,036s
</pre>
  <p>У контейнера unordered_map есть функция max_load_factor, которая задаёт максимально допустимое соотношение между числом элементов и количеством корзин. По умолчанию эта величина равна единице, так что unordered_map пытается в среднем вообще избежать коллизий. Но это не означает отсутствия коллизий в отдельных корзинах.</p>
  <p>Если при вставке очередного элемента среднее число элементов в корзинах превышает этот порог, число корзин автоматически увеличивается и происходит рехеширование. Чем-то это напоминает реаллокацию у вектора.</p>
  <p>Если нам заранее известно финальное количество ключей, то можно вызвать заранее функцию reserve и избежать лишних рехеширований при вставках. Тем самым можно отыграть дополнительное время:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;

int main() {
  std::unordered_map&lt;std::string, int&gt; freqs;
  freqs.reserve(300'000);  // можно использовать апостроф для выделения разрядов
  std::string word;
  while (std::cin >> word) {
    ++freqs[word];
  }
  for (const auto& [word, freq] : freqs) {
    std::cout &lt;&lt; word &lt;&lt; "\t" &lt;&lt; freq &lt;&lt; "\n";
  }
}
</pre>
<pre>
$ clang++ --std=c++20 -O3 -o count_freqs count_freqs.cpp
$ time ./count_freqs &lt; text8 > /dev/null
real   0m3,067s
user   0m3,035s
sys    0m0,032s
</pre>

  <h4>Из контейнера в контейнер</h4>

  <p>Вернёмся к сортировке слов по убыванию частоты. Для этого проще всего будет переложить слова с частотами в вектор пар и отсортировать его, используя свою функцию сравнения:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;tuple&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;

int main() {
  std::unordered_map&lt;std::string, int&gt; freqs;
  std::string word;
  while (std::cin >> word) {
    ++freqs[word];
  }

  // копируем пары в вектор, используя шаблонный конструктор от двух итераторов:
  std::vector&lt;std::pair&lt;std::string, int&gt; &gt; sortedByFreq(
    freqs.begin(),
    freqs.end()
  );

  // сортируем с помощью своей лямбда-функции:
  std::sort(
    sortedByFreq.begin(),
    sortedByFreq.end(),
    [](const auto& p1, const auto& p2) {
      // сначала сравниваем частоты по убыванию, потом — слова по возрастанию
      return std::tie(p2.second, p1.first) &lt; std::tie(p1.second, p2.first);
    }
  );

  for (const auto& [word, freq] : sortedByFreq) {
    std::cout &lt;&lt; word &lt;&lt; "\t" &lt;&lt; freq &lt;&lt; "\n";
  }
}
</pre>
  <p>Здесь мы элегантно копируем данные из unordered_map в вектор, указывая при инициализации переменной sortedByFreq пару итераторов другого контейнера. Цикл, копирующий элементы из этого диапазона, скрыт в конструкторе вектора.</p>
  <p>Посмотрим на первые 10 результатов с помощью консольной утилиты head. Теперь мы в самом деле получили наиболее частотные слова из файла:</p>
<pre>
$ clang++ --std=c++20 -o count_freqs count_freqs.cpp
$ ./count_freqs &lt; text8 | head
the	1061396
of	593677
and	416629
one	411764
in	372201
a	325873
to	316376
zero	264975
nine	250430
two	192644
</pre>

  <h4>Контейнеры std::set и std::unordered_set</h4>

  <p>Контейнеры std::set и std::unordered_set похожи на map и unordered_map по внутреннему устройству, но они хранят только ключи, без ассоциированных значений. Вот как можно выписать повторяющиеся слова текста в алфавитном порядке (по одному разу каждое):</p>
<pre>
#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;string&gt;
#include &lt;unordered_set&gt;

int main() {
  // здесь будем хранить все слова (каждое по одному разу)
  std::unordered_set&lt;std::string&gt; words;

  // здесь будем хранить повторяющиеся слова
  // используем set, а не unordered_set, чтобы потом напечатать их по алфавиту
  std::set&lt;std::string&gt; duplicate_words;

  std::string word;
  while (std::cin >> word) {
    if (words.contains(word)) {
      duplicate_words.insert(word);
    } else {
    words.insert(word);
    }
  }

  for (const auto& word : duplicate_words) {
    std::cout &lt;&lt; word &lt;&lt; "\n";
  }
}
</pre>
  <p>Здесь мы применили функцию contains, которая появилась только в C++20. При использовании более старого стандарта нужно написать if (words.find(word) != words.end()).</p>
  <p>Заметим, что при попадании в else мы ищем слово в words дважды: один раз для проверки в contains, а другой раз — в insert. Можно было бы обойтись только одним поиском, воспользовавшись тем, что insert возвращает пару из итератора на элемент и флажка с результатом поиска:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;string&gt;
#include &lt;unordered_set&gt;

int main() {
  std::unordered_set&lt;std::string&gt; words;
  std::set&lt;std::string&gt; duplicate_words;
  std::string word;
  while (std::cin >> word) {
    auto [iter, has_been_inserted] = words.insert(word);
    if (!has_been_inserted) {
      duplicate_words.insert(word);
    }
  }
  for (const auto& word : duplicate_words) {
    std::cout &lt;&lt; word &lt;&lt; "\n";
  }
}
</pre>
  <p>Название set происходит от математического понятия множества, где элементы хранятся только по одному разу. Однако никаких теоретико-множественных операций (объединения, пересечения, разности) у set и unordered_set не предусмотрено. В параграфе «Алгоритмы» мы рассмотрим алгоритмы для выполнения таких операций над отсортированными последовательностями.</p>

  <h4>Мультиконтейнеры</h4>

  <p>В стандартной библиотеке C++ есть четыре мультиконтейнера:</p>
  <ul>
    <li>std::multimap (в заголовочном файле map);</li>
    <li>std::multiset (в заголовочном файле set);</li>
    <li>std::unordered_multimap (в заголовочном файле unordered_map);</li>
    <li>std::unordered_multiset (в заголовочном файле unordered_set).</li>
  </ul>
  <p>Они аналогичны обычным ассоциативным контейнерам, которые мы рассматривали выше, но в мультиконтейнерах один и тот же ключ может встретиться несколько раз.</p>
  <p>Пусть, например, мы хотим сохранять для каждого слова в текстовом файле его порядковый номер. Слова в тексте могут повторяться, поэтому воспользуемся контейнером multimap:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;map&gt;

int main() {
  std::multimap&lt;std::string, int&gt; positions;

  std::string word;
  int position = 0;
  while (std::cin >> word) {
    positions.insert({word, position});
    ++position;
  }
}
</pre>
  <p>В этом случае мы могли бы применить вместо std::multimap&lt;std::string, int&gt; контейнер std::map&lt;std::string, std::vector&lt;int&lt; &lt;. Разница будет в использовании и в накладных расходах.</p>
  <p>Для обхода multimap потребуется один цикл, а для map с вектором — два вложенных цикла (по ключам и по элементам вектора для данного ключа). Вектор имеет накладные расходы на хранение метаинформации и резерва, а в multimap все данные будут храниться в одном сбалансированном дереве.</p>
  <p>Наконец, итераторы multimap стабильны, а у вектора могут инвалидироваться. Применять multimap имеет смысл там, где повторы ключей сравнительно редки.</p>

  <h4>Итераторы ассоциативных контейнеров</h4>

  <p>Контейнеры map, set и их мультиверсии предоставляют двусторонние итераторы, которые можно сдвигать на соседние позиции вперёд и назад. Как и в случае последовательных контейнеров, запрещено выходить за пределы диапазона, ограниченного begin() и end(), и разыменовывать итератор, равный end(). Итераторы таких контейнеров и ссылки (указатели) на элементы никогда не инвалидируются.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;map&gt;
#include &lt;string&gt;

int main() {
  std::map&lt;int, std::string&gt; numbers = {
    {100, "hundred"},
    {3, "three"},
    {42, "forty two"},
    {11, "eleven"},
  };

  auto iter = numbers.find(11);

  if (iter != numbers.end()) {
    // печатаем найденный элемент
    const auto& [key, value] = *iter;
    std::cout &lt;&lt; "Found: " &lt;&lt; key
    &lt;&lt; ": " &lt;&lt; value &lt;&lt; "\n";  // Found: 11: eleven

    // печатаем предыдущий элемент
    if (iter != numbers.begin()) {
      const auto& [key, value] = *std::prev(iter);
      std::cout &lt;&lt; "Previous: " &lt;&lt; key
      &lt;&lt; ": " &lt;&lt; value &lt;&lt; "\n";  // Previous: 3: three
    } else {
      std::cout &lt;&lt; "No previous element\n";
    }

    // печатаем следующий элемент
    if (auto nextIter = std::next(iter); nextIter != numbers.end()) {
      const auto& [key, value] = *nextIter;
      std::cout &lt;&lt; "Next: " &lt;&lt; key
      &lt;&lt; ": " &lt;&lt; value &lt;&lt; "\n";  // Next: 42: forty two
    } else {
      std::cout &lt;&lt; "No next element\n";
    }
  } else {
    std::cout &lt;&lt; "Not found\n";
  }
}
</pre>
  <p>Может показаться, что в строке const auto& [key, value] = *std::prev(iter) мы строим висячие ссылки, так как возвращаемое значение функции prev после вычисления всего выражения сразу станет невалидным. Однако константные ссылки продлевают жизнь объекта до конца текущего блока.</p>
  <p>Итераторы unordered-контейнеров однонаправленные: их можно сдвигать только вперёд. Это связано с тем, что коллизии в хеш-таблице обычно разрешаются с помощью односвязного списка элементов, а по односвязному списку нельзя двигаться назад. Итераторы unordered-контейнеров могут инвалидироваться только если произошло рехеширование при вставке. Ссылки и указатели никогда не инвалидируются.</p>
  <p>Отдельно отметим функцию erase у ассоциативных контейнеров. У неё есть несколько перегруженных версий. Одна версия принимает ключ, другая — итератор удаляемого элемента, третья — диапазон итераторов. Разница будет для мультиконтейнеров: если какой-то ключ повторяется, то первая версия erase удалит все вхождения таких ключей, а вторая — только конкретные:</p>
<pre>
#include &lt;unordered_map&gt;

int main() {
  std::unordered_multimap&lt;std::string, int&gt; data = {
    {"a", 1},
    {"a", 2},
    {"a", 3},
    {"b", 4},
  };

  auto iter = data.find("a");
  if (iter != data.end()) {
    // удаляем первое найденное вхождение с ключом "a"
    data.erase(iter);
  }

  // удаляем все остальные вхождения с ключом "a"
  data.erase("a");
}
</pre>
</article>


<!-- 3.3 Алгоритмы -->
<article class="article">
  <div class="anchor" id="p3.3"></div>
  <h3>3.3 Алгоритмы</h3>

  <p>В этом параграфе мы обсудим алгоритмы стандартной библиотеки. Они представляют из себя шаблонные функции для обработки последовательностей: подсчёта, поиска, сортировки и т. д. Такие функции, как правило, принимают на вход два итератора, которые ограничивают рассматриваемый диапазон.</p>
  <p>Мы уже знакомы с одной из таких функций: это std::sort. В этом параграфе мы познакомимся с некоторыми другими важными примерами алгоритмов, а полный их перечень можно найти на cppreference.com.</p>

  <h4>Пары итераторов</h4>

  <p>В функции стандартной библиотеки часто требуется передать два итератора, которые ограничивают диапазон элементов. К ним предъявляются такие требования:</p>
  <ul>
    <li>это должны быть итераторы одного и того же контейнера;</li>
    <li>от первого итератора ко второму можно перейти, применяя оператор ++.</li>
  </ul>
  <p>Предполагается, что второй итератор при этом ссылается за последний элемент диапазона. Его нельзя разыменовывать оператором *, даже если он ссылается на валидный элемент.</p>
  <p>Можно рассматривать пару итераторов как математический полуинтервал, где левый конец включается в диапазон, а правый — нет.</p>
  <p>Все контейнеры имеют функции begin и end. Они возвращают итераторы, указывающие на начальный и за последний элемент всей последовательности элементов контейнера.</p>
  <p>Контейнеры, которые допускают обход в обратном порядке (все кроме forward_list и unordered-контейнеров), имеют также функции rbegin и rend. Они возвращают обратные итераторы. С их помощью можно проходить по элементам из конца в начало.</p>
  <p>Однако можно строить и другие диапазоны. Например, вот так можно отсортировать по возрастанию «середину» вектора кроме первого и последнего элемента:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; data = {100, 42, 17, 80, 20, 0};
  std::sort(data.begin() + 1, data.end() - 1);  // 100, 17, 20, 42, 80, 0
}
</pre>
  <p>Впрочем, так можно делать только если мы уверены, что в векторе есть хотя бы два элемента. В противном случае диапазон получится некорректным и поведение программы будет неопределённым.</p>
  <p>Заметим, что с помощью итераторов реализован цикл range-based for. В самом деле, конструкция</p>
<pre>
for (const auto& element : container) {
  // делаем что-то с element
}
</pre>
  <p>просто превращается компилятором в примерно такой код:</p>
<pre>
for (auto iter = container.begin(); iter != container.end(); ++iter) {
  const auto& element = *iter;
  // делаем что-то с element
}
</pre>
  <p>В C++20 для каждого алгоритма были добавлены так называемые constrained-версии. Эти версии вместо пары итераторов принимают диапазон (range), оформленный в виде отдельного объекта. В частности, в роли такого объекта может выступать сам контейнер. Это позволяет вызывать сортировку, например, так:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; data = {100, 42, 17, 80, 20, 0};
  std::ranges::sort(data);  // 0, 17, 20, 42, 80, 100
}
</pre>
  <p>Мы пока ограничимся классическими версиями алгоритмов.</p>

  <h4>Подсчёт</h4>

  <p>Рассмотрим, пожалуй, самый простой пример — алгоритм std::count. Эта функция подсчитывает, сколько элементов последовательности равны заданному. Конечно, такую задачу можно решить с помощью банального цикла:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; v = {2, 7, 1, 8, 2, 8};

  // сколько в последовательности восьмёрок?
  int counter = 0;
  for (int elem : v) {
    if (elem == 8) {
      ++counter;
    }
  }
  std::cout &lt;&lt; counter &lt;&lt; "\n";  // 2
}
</pre>
  <p>Однако использование готового стандартного алгоритма всегда предпочтительнее:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; v = {2, 7, 1, 8, 2, 8};
  std::cout &lt;&lt; std::count(v.begin(), v.end(), 8)
   &lt;&lt; "\n";  // 2
}
</pre>
  <p>Функцию std::count можно применять к итераторам любого последовательного контейнера. Применим её, например, к списку:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;list&gt;

int main() {
  std::list&lt;int&gt; v = {2, 7, 1, 8, 2, 8};
  std::cout &lt;&lt; std::count(v.begin(), v.end(), 8) &lt;&lt; "\n";
}
</pre>
  <p>Такие функции как std::count позволяют упростить код и сделать его более лаконичным и выразительным. Важно понимать, что это самые обыкновенные шаблонные функции, написанные на C++. Вы даже можете посмотреть их реализацию, если откроете заголовочный файл algorithm. Давайте попробуем в качестве упражнения написать такую функцию самостоятельно.</p>
<pre>
template &lt;typename Iter, typename Value&gt;  // два шаблонных параметра: тип итератора и тип эталонного элемента
int count(Iter first, Iter last, const Value& value) {
  int counter = 0;
  for (Iter iter = first; iter != last; ++iter) {
    if (*iter == value) {
      ++counter;
    }
  }
  return counter;
}
</pre>
  <p>На самом деле тип возвращаемого значения этой функции не в точности int, а typename iterator_traits&lt;Iter&gt;::difference_type, построенный по типу итератора.</p>

  <h4>Поиск</h4>

  <p>Алгоритм std::find ищет последовательным перебором первое вхождение элемента, равного заданному. Результатом является итератор, который указывает на найденный элемент. Если же ничего не найдено, то возвращается правый конец переданного полуинтервала.</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;deque&gt;
#include &lt;iostream&gt;

int main() {
  std::deque&lt;int&gt; d = {3, 14, 15, 92, 6};

  // Такой элемент есть, мы его точно найдём
  auto iter1 = std::find(d.begin(), d.end(), 15);
  // Итераторы дека можно вычитать, напечатается индекс найденного элемента
  std::cout &lt;&lt; (iter1 - d.begin()) &lt;&lt; "\n";

  auto start = d.begin();
  // К итераторам дека и вектора можно прибавлять целые числа
  auto end = start + 3;
  // Полуинтервал [start; end&#x29; теперь ограничивает подпоследовательность 3, 14, 15

  auto iter2 = std::find(start, end, 19);
  if (iter2 == end) {
    std::cout &lt;&lt; "No such element!\n";
  } else {
    std::cout &lt;&lt; *iter2 &lt;&lt; "\n";
  }
  // Напечатает No such element
}
</pre>
  <p>Вот его возможная реализация:</p>
<pre>
template &lt;typename Iter, typename Value&gt;
Iter find(Iter first, Iter last, const Value& value) {
  while (first != last) {
    if (*first == value) {
      return first;
    }
    ++first;
  }
  return last;
}
</pre>
  <p>Имеется также алгоритм std::search, который ищет не отдельный элемент, а подпоследовательность элементов.</p>

  <h4>Алгоритмы и встроенные функции</h4>

  <p>У ассоциативных контейнеров есть встроенная функция find, которая возвращает похожий по смыслу итератор. Разберёмся, в чём различие между общим алгоритмом find и встроенной функцией. Алгоритм std::find написан в общем виде. Он работает только с итераторами и ничего не знает о физическом устройстве контейнера. Поэтому он ищет элемент последовательным перебором с линейной сложностью O(n). Но в ассоциативных контейнерах можно найти элемент быстрее: за O(logn) в set и map и в среднем за O(1) в unordered_set и unordered_map.</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;set&gt;

int main() {
  std::set&lt;int&gt; numbers = {2, 3, 5, 7, 11, 13, 17, 19};

  // Предпочтительный способ:
  auto iter1 = numbers.find(15);

  // Допустимо, но неэффективно!
  auto iter2 = std::find(numbers.begin(), numbers.end(), 15);
}
</pre>
  <p>Тут мы встречаемся с общей идеей, заложенной в дизайн стандартной библиотеки C++: если некоторый алгоритм имеет более эффективную реализацию для конкретного контейнера, то он будет реализован у этого контейнера в виде встроенной функции. Наоборот, если возможна лишь общая реализация, то специальной встроенной функции не будет. Поэтому, например, у вектора и дека нет своей встроенной функции find.</p>
  <p>Заметим, что найти элемент по ключу в контейнерах map и unordered_map с помощью алгоритма std::find вообще не получится. Дело в том, что итераторы таких контейнеров ссылаются на пару из константного ключа и значения, а не просто на ключ. А значение как правило нам заранее неизвестно: его как раз обычно и требуется получить по ключу.</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;utility&gt;

int main() {
  std::map&lt;int, int&gt; m = {
    {1, 30},
    {2, 28},
    {3, 31},
    // ...
  };

  // правильный способ поиска по ключу
  auto it1 = m.find(12);
  // не скомпилируется!
  auto it2 = std::find(m.begin(), m.end(), 12);

  std::pair&lt;const int, int&gt; value = {12, 31};
  // Скомпилируется, но неэффективно и бессмысленно:
  auto it3 = std::find(m.begin(), m.end(), value);
}
</pre>

  <h4>Алгоритмы, принимающие предикат</h4>

  <p>В алгоритмах count и find мы передавали третьим аргументом конкретное значение, которое требовалось найти в последовательности. Но иногда бывает нужно найти любое значение, удовлетворяющее некоторому условию. Такое условие можно оформить в виде функции, получающей на вход элемент последовательности и возвращающей логический ответ (true, если элемент подходит и false, если не подходит). Такие функции называют предикатами. Для работы с ними имеются алгоритмы, в названии которых добавляется суффикс _if.</p>
  <p>Например, подсчитаем, сколько заглавных латинских букв в строке. Передадим в функцию count_if предикат, оформленный в виде лямбда-функции:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string s = "iPhone SE";

  std::cout &lt;&lt; std::count_if(
    s.begin(),
    s.end(),
    [](char c) {
      return 'A' &lt;= c && c &lt;= 'Z';
    }
  ) &lt;&lt; "\n";  // 3
}
</pre>
  <p>Можно было бы внутри лямбда-функции вместо двойного неравенства воспользоваться функцией std::isupper. К сожалению, просто передать std::isupper в std::count_if не получится: компилятор не сможет без конкретных аргументов отличить эту функцию от другой перегруженной версии.</p>
  <p>Напишем для примера собственную реализацию алгоритма find_if. Тип предиката сделаем просто шаблонным параметром.</p>
<pre>
template &lt;typename Iter, typename Predicate&gt;
Iter find_if(Iter first, Iter last, Predicate p) {
  while (first != last) {
    if (p(*first)) {  // применяем предикат
      return first;
    }
    ++first;
  }
  return last;
}
</pre>
  <p>Отметим семейство алгоритмов std::all_of, std::any_of и std::none_of, также принимающих предикаты. Их смысл понятен из названия. Например, any_of проверяет, что какой-то элемент последовательности удовлетворяет предикату. Типичная реализация any_of сводится к вызову find_if и сравнению результата с итератором last.</p>

  <h4>Алгоритмы, модифицирующие последовательность</h4>

  <p>Рассмотрим алгоритм std::reverse. Он переставляет элементы последовательности в обратном порядке:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string s = "No lemon, no melon!";
  std::reverse(s.begin(), s.end());
  std::cout &lt;&lt; s &lt;&lt; "\n";  // !nolem on ,nomel oN
}
</pre>
  <p>Его возможная реализация выглядит так:</p>
<pre>
template &lt;typename Iter&gt;
void reverse(Iter first, Iter last) {
  while (first != last) {
    --last;
    if (first == last) {
      break;
    }
    std::swap(*first, *last);
    ++first;
  }
}
</pre>
  <p>Сложность тут в том, что last указывает за последний элемент, и этот итератор надо аккуратно подвинуть назад, прежде чем переставлять элементы. Здесь вызывается функция std::swap, реализацию которой мы уже писали в параграфе «Функции».</p>
  <p>Важно понимать, что алгоритмы работают с итераторами, и поэтому они ничего не знают о физическом способе хранения элементов в контейнерах. Алгоритмы знают лишь о логическом порядке перебора элементов. Поэтому алгоритмы не могут физически что-либо удалить из контейнера или добавить в него. Лучшее, что они могут сделать, — это переупорядочить элементы в последовательности.</p>
  <p>Рассмотрим алгоритм std::unique. Этот алгоритм переставляет элементы так, чтобы в последовательности не было подряд идущих дубликатов. Уменьшить размер последовательности алгоритм не может. Поэтому в конце последовательности остаётся некоторый набор ненужных элементов. Их можно потом явно удалить, вызвав функцию erase у контейнера:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; v = {5, 5, 3, 2, 2, 5, 9, 1};
  auto iter = std::unique(v.begin(), v.end());
  // В векторе окажется 5, 3, 2, 5, 9, 1, 9, 1
  //                                      ^ iter будет указывать сюда
  v.erase(iter, v.end());  // удаляем хвост из ненужных элементов
}
</pre>
  <p>Обратите внимание, что третья пятёрка не удалилась, потому что она не расположена рядом с другими пятёрками. Обычно std::unique применяют вместе с std::sort, чтобы одинаковые элементы оказались рядом:</p>
<pre>
std::sort(v.begin(), v.end());
v.erase(std::unique(v.begin(), v.end()), v.end());
</pre>
  <p>Среди других алгоритмов, модифицирующих последовательность, имеются</p>
  <ul>
    <li>std::fill и std::generate (заполнение заданными значениями),</li>
    <li>std::rotate (циклический сдвиг),</li>
    <li>std::replace (замена элементов),</li>
    <li>std::remove (переупорядочивание элементов, чтобы указанный элемент не встречался в начале),</li>
    <li>std::shuffle (случайная перестановка элементов).</li>
  </ul>

  <h4>Запись в другую последовательность</h4>

  <p>Алгоритм std::copy копирует содержимое одной последовательности в другую последовательность. Он принимает три аргумента: обычную пару итераторов, задающих входной диапазон, и итератор, обозначающий начало выходного диапазона. Четвёртый аргумент не нужен: никаких проверок корректности всё равно не делается.</p>
  <p>В этом примере мы копируем диапазон элементов в обратном порядке из вектора в список:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; v = {3, 14, 15, 92, 6};
  std::list&lt;int&gt; l;
  l.resize(v.size());  // теперь в списке l 5 нулей

  std::copy(v.rbegin(), v.rend(), l.begin());

  for (int x : l) {
    std::cout &lt;&lt; x &lt;&lt; " ";
  }
  std::cout &lt;&lt; "\n";  // 6 92 15 14 3
}
</pre>
  <p>В контейнере, в который мы копируем элементы, должно быть достаточно места, чтобы они поместились. Если бы мы не вызвали resize для списка l, то программа попала бы в неопределенное поведение!</p>
<pre>
Вот возможная реализация алгоритма copy:
template &lt;typename InputIter, typename OutputIter&gt;
OutputIter copy(InputIter first, InputIter last, OutputIter out) {
  while (first != last) {
    *out = *first;
    ++first;
    ++out;
  }
  return out;
}
</pre>
  <p>Обратите внимание, что шаблонные типы входных и выходных итераторов, вообще говоря, разные. Функция возвращает выходной итератор, указывающий за последний записанный элемент. Этот итератор позволяет потом физически удалить лишние элементы выходной последовательности, которые больше не нужны:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;list&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; v = {3, 14, 15, 92, 6};
  std::list&lt;int&gt; l(10);  // 10 нулей

  auto iter = std::copy(v.begin(), v.end(), l.begin());
  // 3 14 15 92 6 0 0 0 0 0, iter указывает на первый ноль

  l.erase(iter, l.end());  // 3 14 15 92 6
}
</pre>
  <p>В стандартной библиотеке для модифицирующих алгоритмов есть версии с суффиксом _copy в имени, которые ведут себя похожим образом. Вместо модификации исходной последовательности они записывают результат в отдельную выходную последовательность. В ней должно быть достаточно места, чтобы результат поместился. Вот пример использования функции std::replace_copy:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;std::string&gt; words1 = {"a", "cat", "and", "a", "dog"};
  std::vector&lt;std::string&gt; words2(words1.size());  // 5 пустых строк

  const std::string from = "a";
  const std::string to = "the";
  std::replace_copy(words1.begin(), words1.end(), words2.begin(), from, to);

  for (const auto& word : words1) {
    std::cout &lt;&lt; word &lt;&lt; " ";  // a cat and a dog
  }
  std::cout &lt;&lt; "\n";

  for (const auto& word : words2) {
    std::cout &lt;&lt; word &lt;&lt; " ";  // the cat and the dog
  }
  std::cout &lt;&lt; "\n";
}
</pre>

  <h4>Адаптеры для вставки</h4>

  <p>В стандартной библиотеке есть конструкции, которые притворяются обычными итераторами, но на самом деле не являются таковыми. Например, шаблонная функция std::back_inserter принимает последовательный контейнер и возвращает адаптер, который ведёт себя как итератор, но при попытке записи в него добавляет элемент в контейнер через push_back. Такие адаптеры удобно использовать с модифицирующими алгоритмами.</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;list&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; v = {3, 14, 15, 92, 6};
  std::list&lt;int&gt; l;  // список пустой!
  std::copy(v.begin(), v.end(), std::back_inserter(l));  // 3 14 15 92 6
}
</pre>
  <p>Также есть функции std::front_inserter и std::inserter. Последняя кроме контейнера принимает ещё и итератор, перед которым должна производиться вставка. Разумеется, этот итератор не должен инвалидироваться в процессе работы алгоритма.</p>

  <h4>Сортировка</h4>

  <p>Мы уже знакомы с std::sort. Заметим, что этот алгоритм нестабильный: после сортировки порядок одинаковых элементов может измениться. Это может быть заметно, например, во время сортировки вектора структур при сравнении по какому-то ключевому полю. В стандартной библиотеке имеется чуть менее эффективная функция stable_sort с асимптотической сложностью O(n(logn)²), сохраняющая порядок эквивалентных элементов.</p>
  <p>Важно заметить, что алгоритмы сортировки требуют, чтобы на входе были итераторы произвольного доступа. Такие итераторы предоставляют контейнеры с индексами — vector, string, array, deque. К итераторам этих контейнеров можно прибавлять целые числа и их можно вычитать друг из друга. В сортировке это используется для быстрого обращения к элементу в середине последовательности.</p>
  <p>Вызов общего алгоритма сортировки с итераторами списка просто не скомпилируется. Однако, как и с функцией find у ассоциативных контейнеров, у списков есть встроенная функция sort. Она использует сортировку слиянием, которая чуть менее эффективна на практике, но имеет ту же асимптотическую сложность O(nlogn), что и std::sort.</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;list&gt;

int main() {
  std::list&lt;int&gt; data = {3, 14, 15, 92, 6};
  std::sort(data.begin(), data.end());  // не скомпилируется!
  data.sort();  // OK, встроенная функция сортировки списка
}
</pre>
  <p>Проверить, отсортирована ли последовательность, можно с помощью функции std::is_sorted. А с помощью функции std::partial_sort можно построить только начало отсортированного массива, не сортируя хвост:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; data = {3, 14, 15, 92, 6};
  std::partial_sort(data.begin(), data.begin() + 3, data.end());
  // первыми тремя элементами в векторе будут 3, 6, 14
}
</pre>

  <h4>Алгоритмы бинарного поиска</h4>

  <p>К отсортированным последовательностям в контейнерах можно применять особый набор алгоритмов. Рассмотрим алгоритмы для бинарного поиска:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  // Отсортирован по возрастанию:
  std::vector&lt;int&gt; data = {1, 4, 5, 9, 9, 13, 47};

  // Элемент будет найден:
  if (std::binary_search(data.begin(), data.end(), 5)) {
    std::cout &lt;&lt; "Found\n";
  } else {
    std::cout &lt;&lt; "Not found\n";
  }
}
</pre>
  <p>Если <strong>binary_search</strong> возвращает true или false, то алгоритмы <strong>lower_bound</strong> и <strong>upper_bound</strong> возвращают итераторы. Алгоритм <strong>lower_bound</strong> возвращает итератор на первый элемент, не меньший заданного. Алгоритм <strong>upper_bound</strong> возвращает итератор на первый элемент, больший заданного:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  // Числа идут по возрастанию:
  std::vector&lt;int&gt; data = {1, 4, 5, 9, 9, 13, 47};

  auto iter1 = std::lower_bound(
    data.begin(), data.end(),
    8
  );  // *iter1 == 9

  auto iter2 = std::upper_bound(
    data.begin(), data.end(),
    47
  );  // iter2 == data.end()

  // все элементы исходной последовательности,
  // такие, что 8 &lt;= x &lt;= 47,
  // попадут в полуинтервал [iter1, iter2)
  for (auto iter = iter1; iter != iter2; ++iter) {
    std::cout &lt;&lt; *iter &lt;&lt; " ";  // 9 9 13 47
  }
  std::cout &lt;&lt; "\n";
}
</pre>
  <p>В частности, пара std::lower_bound(first, last, x) и std::upper_bound(first, last, x) ограничивает диапазон элементов, эквивалентных x. Пару таких итераторов можно получить за один вызов из функции <strong>std::equal_range</strong>.</p>
  <p>Как и в случае с find, у ассоциативных контейнеров есть собственные встроенные реализации функций lower_bound, upper_bound и equal_range.</p>
  <p>Если последовательность не будет упорядочена, то результат работы всех этих функций может быть некорректным.</p>
  <p>Формально эти функции можно применять и к итераторам списка, не имеющим произвольного доступа. В этом случае время работы будет не логарифмическим, а линейным.</p>

  <h4>Теоретико-множественные алгоритмы</h4>

  <p>Над отсортированными последовательностями можно выполнять операции</p>
  <ul>
    <li>слияния (std::merge),</li>
    <li>объединения (std::set_union)</li>
    <li>пересечения (std::set_intersection),</li>
    <li>разности (std::set_difference),</li>
    <li>симметрической разности (std::set_symmetric_difference).</li>
  </ul>
  <p>Также можно проверять вложения (std::includes).</p>
  <p>Эти алгоритмы работают за линейное время от суммарной длины последовательностей. Перечисленные операции соответствуют математическим мультимножествам, а не множествам, потому что элементы в последовательностях могут повторяться. Каждый элемент учитывается со своей кратностью.</p>
  <p>Все эти операции (кроме includes) принимают пять аргументов:</p>
  <ul>
    <li>два итератора первого диапазона,</li>
    <li>два итератора второго диапазона,</li>
    <li>итератор выходной последовательности для записи ответа.</li>
  </ul>
  <p>Элементы выходной последовательности также будут отсортированы.</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;deque&gt;
#include &lt;iterator&gt;
#include &lt;list&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; in1 = {1, 3, 5, 5, 7};
  std::list&lt;int&gt; in2 = {1, 1, 2, 3};
  std::deque&lt;int&gt; out;

  std::merge(
    in1.begin(), in1.end(),
    in2.begin(), in2.end(),
    std::back_inserter(out)
  );  // 1, 1, 1, 2, 3, 3, 5, 5, 7

  out.clear();
  std::set_union(
    in1.begin(), in1.end(),
    in2.begin(), in2.end(),
    std::back_inserter(out)
  );  // 1, 1, 2, 3, 5, 5, 7

  out.clear();
  std::set_intersection(
    in1.begin(), in1.end(),
    in2.begin(), in2.end(),
    std::back_inserter(out)
  );  // 1, 3

  out.clear();
  std::set_difference(
    in1.begin(), in1.end(),
    in2.begin(), in2.end(),
    std::back_inserter(out)
  );  // 5, 5, 7

  out.clear();
  std::set_symmetric_difference(
    in1.begin(), in1.end(),
    in2.begin(), in2.end(),
    std::back_inserter(out)
  );  // 1, 2, 5, 5, 7

  std::includes(
    in2.begin(), in2.end(),
    in1.begin(), in1.end()
  );  // false
}
</pre>
</article>


<!-- 3.4 Адаптеры и представления -->
<article class="article">
  <div class="anchor" id="p3.4"></div>
  <h3>3.4 Адаптеры и представления</h3>

  <p>Адаптеры над стандартными контейнерами — это не самостоятельные контейнеры. Они используют какой-нибудь другой контейнер (например, дек или вектор) для хранения своих элементов, но при этом предоставляют свой набор функций для работы с ними. В стандартной библиотеке есть адаптеры std::stack, std::queue и std::priority_queue.</p>
  <p>Представления (views) не владеют памятью, а лишь ссылаются на диапазон значений другого контейнера. Представлением можно считать пару итераторов. В С++20 появилась обширная библиотека ranges для работы с представлениями. В этом параграфе мы рассмотрим конструкцию string_view, представляющую фрагмент строки.</p>

  <h4>Адаптер std::stack</h4>

  <p>Стек — это последовательность элементов, в которую разрешается добавлять и извлекать элементы только с одной стороны. Обращение к промежуточным элементам не допускается. Говорят, что структура данных «стек» реализует идею LIFO (last in — first out).</p>
  <p>Понятно, что эти действия можно сделать с помощью вектора или дека и операций push_back и pop_back. Адаптер std::stack является обёрткой над такими контейнерами с особым интерфейсом — функциями push, pop и top. Это позволяет более выразительно подчеркнуть, что используется не просто какой-то контейнер, а именно стек как структура данных.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;stack&gt;

int main() {
  std::stack&lt;int&gt; s;
  s.push(1);
  s.push(13);
  // удалить элемент с вершины стека (в стеке останется 1)
  s.pop();

  // получить элемент на вершине стека, не удаляя его
  std::cout &lt;&lt; s.top() &lt;&lt; "\n";

  if (s.empty()) {  // проверка на пустоту
    std::cout &lt;&lt; "Stack is empty\n";
  }
}
</pre>
  <p>Функция pop ничего не возвращает. Напротив, функция top возвращает элемент, но никак не меняет состояние стека. Так было сделано для гарантий безопасности исключений. Мы поговорим об этом в параграфе «Обработка исключений».</p>
  <p>По умолчанию стек использует контейнер std::deque для хранения элементов. При желании мы можем указать другой тип этого контейнера. Всё, что требуется от этого контейнера, — это поддержка операций push_back, pop_back, back и empty:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;stack&gt;

int main() {
  // используем std::list для хранения элементов в стеке
  std::stack&lt;int, std::list&lt;int&gt; &gt; s;
  // ...
}
</pre>
  <p>В C++ есть ещё понятие стека как области памяти для локальных переменных и аргументов функций. Оно так называется потому, что переменные автоматически помещаются туда при создании и автоматически удаляются при выходе из области видимости. То есть, последняя созданная переменная удалится первой, как в обычном стеке. Не следует путать это понятие с адаптером std::stack. Подробнее про жизненный цикл объектов мы поговорим в параграфе «Жизненный цикл объекта».</p>

  <h4>Адаптер std::queue</h4>

  <p>Другой похожий адаптер — очередь (std::queue). Очередь реализует идею FIFO (first in — first out). Можно считать, что элементы встают в очередь с одного конца, а извлекаются с другого. Очередь предоставляет функции push, pop, front и back.</p>
  <p>Не следует путать адаптер queue с контейнером deque.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;queue&gt;

int main() {
  std::queue&lt;int&gt; s;
  s.push(1);
  s.push(13);

  std::cout &lt;&lt; s.front() &lt;&lt; "\n";  // 1
  std::cout &lt;&lt; s.back() &lt;&lt; "\n";  // 13

  s.pop();  // в очереди останется 13

  if (s.empty()) {
    std::cout &lt;&lt; "Queue is empty\n";
  }
}
</pre>
  <p>Так же как и в std::stack, в очереди по умолчанию используется std::deque для хранения элементов. Этот контейнер точно так же можно заменить. Для этого нужно указать тип нового контейнера во втором шаблонном параметре. Однако в отличие от стека здесь не получится использовать std::vector, так как у него нет функций push_front и pop_front.</p>

  <h4>Адаптер std::priority_queue</h4>

  <p>Рассмотрим адаптер std::priority_queue — очередь с приоритетами. Эта структура данных позволяет за логарифмическое время добавлять и удалять элементы и за константное время получать максимальный элемент. Типичная реализация очереди с приоритетами основана на структуре данных «куча». Для хранения элементов используется контейнер с индексами и с возможностью добавления в конец. На эту роль подходят std::vector и std::deque, но не подходит std::list. По умолчанию используется std::vector.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;queue&gt;  // именно queue, а не priority_queue

int main() {
  std::priority_queue&lt;int&gt; pq;
  for (int x : {3, 14, 15, 92, 6, 0, 1, 10}) {
    pq.push(x);
  }
  while (!pq.empty()) {
    std::cout &lt;&lt; pq.top() &lt;&lt; "\n";
    pq.pop();
  }
  // Будет напечатано 92, 15, 14, 10, 6, 3, 1, 0
}
</pre>
  <p>Для сравнения элементов по умолчанию используется оператор &lt;. Чтобы воспользоваться оператором &gt; и, соответственно, извлекать из очереди минимальные элементы вместо максимальных, можно передать в третьем шаблонном параметре специальную обёртку std::greater&lt;int&gt;.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;functional&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;

int main() {
  std::priority_queue&lt;
    int,
    // тип внутреннего контейнера;
    // его приходится указывать,
    // если нам нужен третий параметр
    std::vector&lt;int&gt;,
    // вспомогательная обёртка над оператором &gt; (а не &lt;)
    std::greater&lt;int&gt;
  > pq;

  for (int x : {3, 14, 15, 92, 6}) {
    pq.push(x);
  }

  while (!pq.empty()) {
    std::cout &lt;&lt; pq.top() &lt;&lt; "\n";
    pq.pop();
  }
  // Будет напечатано 3 6 14 15 92
}
</pre>

  <h4>Представление std::string_view</h4>

  <p>Конструкция std::string_view не является адаптером. Это не самостоятельная строка, а отсылка к подстроке какой-то другой строки. Объекты такого класса не выделяют память для размещения символов строки и не копируют подстроки. Упрощённо их можно представлять себе просто как такие структуры:</p>
<pre>
struct string_view {
  // указатель на начало подстроки в чужой памяти
  const char* start;
  size_t len;   // длина этой подстроки
};
</pre>
  <p>Давайте взглянем на следующий код:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string s = "Hello, world! How do you do?";
  auto sub = s.substr(7, 5);  // тип sub — std::string
  sub[0] = 'W';
  std::cout &lt;&lt; sub &lt;&lt; "\n";  // World
  // В исходной строке всё осталось по-прежнему:
  std::cout &lt;&lt; s &lt;&lt; "\n";  // Hello, world! How do you do?
}
</pre>
  <p>Здесь имеется исходная строка s, у которой мы выделяем подстрочку sub. Эта подстрока является самостоятельной копией фрагмента исходной строки. С одной стороны, это позволяет её независимо изменять. С другой стороны, если такие изменения не требуются, на такое копирование тратится время и память.</p>
  <p>Перепишем теперь это через string_view:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;string_view&gt;

int main() {
  std::string s = "Hello, world! How do you do?";
  std::string_view sv = s;  // смотрим через string_view на строку s
  auto sub = sv.substr(7, 5);  // теперь тип sub — std::string_view
  // sub[0] = 'W';  // изменять через string_view символы строки нельзя
  std::cout &lt;&lt; sub &lt;&lt; "\n";  // world
  std::cout &lt;&lt; s &lt;&lt; "\n";  // Hello, world! How do you do?
}
</pre>
  <p>Обёртка string_view рассматривает исходную строчку как константную: она не позволяет её изменять. В то же время через string_view можно читать символы фрагмента исходной строки, а также можно брать новые подстроки и сужать длину подстроки:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;string_view&gt;

int main() {
  std::string s = "Hello, world! How do you do?";
  std::string_view sv = s;
  sv.remove_prefix(7);  // убрали из sv первые 7 символов
  sv.remove_suffix(16);  // убрали последние 16 символов
  std::cout &lt;&lt; sv &lt;&lt; "\n";  // world
  std::cout &lt;&lt; s &lt;&lt; "\n";  // строка s при этом никак не изменилась
}
</pre>
  <p>Обёртка string_view позволяет избежать ненужных копирований и ускорить программу там, где ведётся работа с подстроками одной большой строки. Например, это могут быть фрагменты JSON- или XML-файлов. Однако важно помнить, что string_view валиден только при условии, что объемлющая строка жива. Например, следующая программа некорректна и приведёт к неопределённому поведению:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;string_view&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;std::string_view&gt; lines;
  for (int i = 0; i &lt; 5; ++i) {
    std::string line;
    std::getline(std::cin, line);
    // string_view в векторе ссылается на память строки line
    lines.push_back(line);
  }
  for (auto item : lines) {
    // Ошибка! Все эти строки уже невалидны!
    std::cout &lt;&lt; item &lt;&lt; "\n";
  }
}
</pre>
  <p>Программа компилируется, но при запуске попадает в неопределённое поведение, так как исходные строки line выходят из своей области видимости после каждой итерации цикла, и обращаться к их памяти больше нельзя.</p>
  <p>По аналогии со string_view, std::span является оберткой над произвольной непрерывной последовательностью элементов в памяти. Можно сказать, что span — это аналог string_view для массивов или векторов.</p>
</article>


<!-- 3.5 Разбор задач к главе «Стандартная библиотека C++» -->
<article class="article">
  <div class="anchor" id="p3.5"></div>
  <h3>3.5 Разбор задач к главе «Стандартная библиотека C++»</h3>

  <h3>Параграф «Последовательные контейнеры»</h3>

  <h4>Задача «Шаблонный Print»</h4>

  <details>
    <summary>Условие</summary>
    <p>Вам надо написать функцию Print, которая умеет печатать в поток std::cout элементы переданного контейнера через указанную строку-разделитель. Первый аргумент функции — контейнер. Гарантируется, что по этому контейнеру можно проитерироваться с помощью стандартного цикла range-based for, и что элементы контейнера можно напечатать в поток std::cout с помощью стандартного оператора &lt;&lt;. Второй аргумент функции — строка-разделитель, которую надо печатать между элементами. В конце необходимо напечатать перевод строки \n.</p>
    <p>Пример вызова:</p>
<pre>
int main() {
  std::vector&lt;int&gt; data = {1, 2, 3};
  Print(data, ", ");  // 1, 2, 3
}
</pre>
    <p>Примечание</p>
    <p>В вашем решении должен быть только код функции Print без функции main. Подключите все необходимые для реализации библиотеки. Используйте константные ссылки для получения параметров и при итерации в цикле, чтобы избежать лишних копирований: если этого не сделать, то программа не скомпилируется.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Прежде всего определимся с заголовком функции Print. Она должна работать с любым контейнером. Проще всего будет сделать тип контейнера шаблонным параметров функции (да и название задачи на это намекает):</p>
<pre>
template &lt;typename Container&gt;
void Print(const Container& data, const std::string& delimiter);
</pre>
    <p>Сам контейнер и строку-разделитель мы будем принимать по константной ссылке, чтобы избежать лишних и ненужных копирований. Про необходимость передачи по константной ссылке даже написано в примечании к условию (это специально проверяется в тестах).</p>
    <p>Постараемся решить задачу, не предполагая ничего дополнительного о контейнере, кроме того, что сказано в условии. Гарантируется, что по контейнеру можно пройтись с помощью range-based for:</p>
<pre>
for (const auto& elem : data) {
  // ...
}
</pre>
    <p>Строку-разделитель следует печатать только между элементами. Для этого нам нужно понимать, последний ли элемент сейчас печатается. Но гораздо проще проверять, первый ли это элемент. Заведём для этого логическую переменную, изначально установленную в true, и сбросим её на первой итерации цикла.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

template &lt;typename Container&gt;
void Print(const Container& data, const std::string& delimiter) {
  bool first = true;

  for (const auto& elem : data) {
    if (!first) {
      std::cout &lt;&lt; delimiter;
    } else {
      first = false;
    }

    std::cout &lt;&lt; elem;
  }

  std::cout &lt;&lt; "\n";
}
</pre>
    <p>Решения, использующие итераторы, тоже допустимы, так как range-based for на самом деле под капотом обращается к функциям begin и end:</p>
<pre>
for (auto iter = std::begin(data); iter != std::end(data); ++it) {
  // ...
}
</pre>
    <p>Однако не следуют проверять, является ли элемент последним, с помощью такого сравнения:</p>
<pre>
if (iter == std::prev(std::end(data))) {
  // ...
}
</pre>
    <p>У однонаправленных итераторов (например, у односвязного списка forward_list) взятие prev приведёт к неопределенному поведению. По аналогичной причине это не будет работать с некоторыми реализациями unordered_set.</p>
    <p>Вместо этого можно либо написать next(iter) == end(data), либо, как в решении выше, проверять не на конец, а на начало (сравнивать iter с begin(data)):</p>
<pre>
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;string&gt;

template &lt;typename Container&gt;
void Print(const Container& data, const std::string& delimiter) {
  for (auto iter = std::begin(data); iter != std::end(data); ++iter) {
    std::cout &lt;&lt; *iter;
    if (std::next(iter) != std::end(data)) {
      std::cout &lt;&lt; delimiter;
    }
  }
  std::cout &lt;&lt; "\n";
}
</pre>
    <p>Отметим также, что первое решение скорее всего покажет большую производительность, так как компилятору будет проще оптимизировать инструкцию if над логической переменной, а процессору будет проще предугадать правильную ветку исполнения. Однако реальная разность в производительности на такой примитивной задаче вряд ли будет заметна на уровне погрешности.</p>
  </details>

  <h4>Задача «Проверка работ»</h4>

  <details>
    <summary>Условие</summary>
    <p>В университете проводится письменная контрольная работа. N студентов сдают свои работы в общую стопку, причем некоторые кладут свою работу сверху, а другие (считая, что чем позже их работу проверят, тем лучше) — снизу. Проверяются работы в том порядке, в котором лежат, начиная с верхней. Определите, чья работа будет проверена k-й по счёту.</p>

    <h4>Формат ввода</h4>
    <p>Первая строка содержит одно натуральное число N, не превосходящее 10000, — число студентов.</p>
    <p>Каждая из последующих N строк содержит фамилию студента — строку из латинских букв длиной от 2 до 10 символов, и через пробел слово top или bottom — положил этот студент свою работу сверху или снизу.</p>
    <p>Следующая строка содержит одно целое число M от 0 до 10000 — для какого числа работ нужно определить их автора.</p>
    <p>Следующие M строк содержат по одному числу xi от 1 до N — номер в стопке очередной интересующей нас работы.</p>

    <h4>Формат вывода</h4>
    <p>Выведите M строк. В i-й строке выведите фамилию студента, чья работа будет проверена xi-й по счёту.</p>

    <h4>Пример 1</h4>
<pre>
3
Ivanov top
Petrov top
Sidorov bottom
2
1
3
</pre>
<pre>
Petrov
Sidorov
</pre>

    <h4>Пример 2</h4>
<pre>
3
Ivanov top
Ivanov bottom
Ivanov top
4
1
2
3
1
</pre>
<pre>
Ivanov
Ivanov
Ivanov
Ivanov
</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Самая подходящая для нашей задачи структура данных — std::deque. В этот контейнер можно эффективно вставлять новые элементы по краям и обращаться к элементам по индексам. Будем хранить в деке имена студентов в том порядке, в котором их работы попадают в стопку. Для этого при считывании позиции top будем использовать функцию push_front, а в случае позиции bottom — функцию push_back. Обе функции в среднем работают за константное время.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;deque&gt;
#include &lt;string&gt;

int main() {
  std::deque&lt;std::string&gt; works;

  int n = 0;
  std::cin >> n;

  for (int i = 0; i &lt; n; ++i) {
    std::string name, position;
    std::cin >> name >> position;

    if (position == "top") {
      works.push_front(name);
    } else {
      works.push_back(name);
    }
  }

  int k = 0;
  std::cin >> k;
  for (int i = 0; i &lt; k; ++i) {
    int x = 0;
    std::cin >> x;
    std::cout &lt;&lt; works[x - 1] &lt;&lt; "\n";
  }
}
</pre>
  </details>
  <h4>Задача «Вагоны»</h4>

  <details>
    <summary>Условие</summary>
    <p>Вы — машинист. Вам поручено реализовать функцию void MakeTrain(), чтобы сформировать поезд из набора вагонов.</p>
    <p>У каждого вагона есть номер (помещается в int). Номера вагонов внутри состава могут повторяться. Изначально путь, на котором формируется состав, пустой. Вы должны уметь выполнять следующие команды, которые поступают в отдельных строках на входе:</p>
    <ul>
      <li>+left W — добавить вагон с номером W слева</li>
      <li>+right W — добавить вагон с номером W справа</li>
      <li>-left N — отцепить и убрать N вагонов слева</li>
      <li>-right N — отцепить и убрать N вагонов справа</li>
    </ul>
    <p>В последних двух командах N может быть больше текущей длины состава — в этом случае надо убрать весь состав целиком. Отцеплять вагоны по одному может быть долго: постарайтесь сразу отцеплять по N штук. Напечатайте через пробел номера вагонов получившегося состава, если смотреть на них слева направо. В самом конце напечатайте перевод строки.</p>
    <p>На вход подаются строки с командами в указанном формате. Всего будет не более 1 млн команд. Оформите ваше решение в функции void MakeTrain(). Эта функция должна читать данные со стандартного потока ввода и печатать их в стандартный поток вывода. Подключите все необходимые библиотеки. В вашем решении не должно быть функции main.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Для хранения последовательности вагонов нам нужен контейнер, позволяющий эффективно добавлять и удалять элементы с обоих концов. Мы знаем два таких контейнера в стандартной библиотеке - std::list и std::deque.</p>
    <p>В условии есть совет отцеплять вагоны сразу по N штук. Это намекает на то, что deque будет более подходящим контейнером: его итераторы являются итераторами произвольного доступа, а значит, можно будет быстро найти место расцепки.</p>
    <p>К тому же в задании есть нестандартные ограничения по времени. Контейнер std::list может оказаться медленнее дека, потому что он аллоцирует отдельные ячейки памяти под каждый элемент. Напротив, std::deque аллоцирует сразу большие страницы памяти.</p>
    <p>Итак, выбираем std::deque&lt;int&gt;:</p>
<pre>
#include &lt;deque&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

void MakeTrain() {
  using Wagon = int;
  std::deque&lt;Wagon&gt; train;

  std::string command;
  Wagon wagon;
  size_t k;
  while (std::cin >> command) {
    if (command == "+left") {
      std::cin >> wagon;
      train.push_front(wagon);
    } else if (command == "+right") {
      std::cin >> wagon;
      train.push_back(wagon);
    } else if (command == "-left") {
      std::cin >> k;
      k = std::min(k, train.size());
      train.erase(train.begin(), train.begin() + k);
    } else if (command == "-right") {
      std::cin >> k;
      k = std::min(k, train.size());
      train.erase(train.end() - k, train.end());
    }
  }

  for (const auto& wagon : train) {
    std::cout &lt;&lt; wagon &lt;&lt; " ";
  }
  std::cout &lt;&lt; "\n";
}
</pre>
    <p>Здесь мы используем псевдоним Wagon вместо int, чтобы в будущем можно было легко поменять тип. (В конце при выводе вагонов по-хорошему не надо было бы печатать последний пробел, но в тестах ответ проверяется с точность до пробельных символов в конце, и такое решение проходит.)</p>
    <p>Мы специально просим в этой задаче написать код в отдельной функции, чтобы в своей функции main позвать std::ios_base::sync_with_stdio(false) и ускорить ввод-вывод, так что накладные расходы на ввод-вывод данных будут минимальными.</p>
    <p>Можно сгенерировать искусственный тест, где будут случайные добавления вагонов с разных сторон, а потом — серия мелких удалений (и так несколько раз). Попробуем сравнить скорость работы этой программы для deque и для list на таком тесте с опцией компилятора -O3 (то есть, с полностью включенными оптимизациями). Оказывается, что list медленнее на 20%.</p>
    <p>Заметим, что в решении с deque отцепка вагонов по одному через pop_back или pop_front на самом деле оказывается не медленнее вызова erase с парой итераторов.</p>

    <h4>Неверные решения</h4>
    <p>Разберём два неправильных решения этой задачи. Первое — пытаться считывать данные через getline в строку, а потом отдельно разбирать её через stringstream:</p>
<pre>
std::string line;
std::string command;
Wagon wagon;
while (std::getline(std::cin, line)) {
  std::istringstream ss(line);
  ss >> command >> wagon;
  // ...
}
</pre>
    <p>Это удобно, но в данном случае сильно замедляет программу. Поток istringstream внутри хранит копию исходной строки, а на это требуются накладные расходы.</p>
    <p>Второе ошибочное решение — такое:</p>
<pre>
if (command == "+left") {
  std::cin >> wagon;
  train.push_front(wagon);
} else if (command == "+right") {
  std::cin >> wagon;
  train.push_back(wagon);
} else if (command == "-left") {
  std::cin >> k;
  for (size_t i = 0; i &lt; std::min(k, train.size()); ++i) {
    train.pop_front();
  }
} else if (command == "-right") {
  std::cin >> k;
  for (size_t i = 0; i &lt; std::min(k, train.size()); ++i) {
    train.pop_back();
  }
}
</pre>
    <p>Тут просто будет неверный ответ. Найдите ошибку самостоятельно.</p>
  </details>

  <h4>Задача «Ctrl+X, Ctrl+V»</h4>

  <details>
    <summary>Условие</summary>
    <p>Петя решил написать свой собственный текстовый редактор и просит вас помочь протестировать его прототип. На текущей стадии разработки в редакторе есть только возможность загрузить файл и выполнять с ним такие действия:</p>
    <ul>
      <li>переместить курсор на строчку вниз (Down)</li>
      <li>переместить курсор на строчку вверх (Up)</li>
      <li>вырезать текущую строку в буфер обмена (Ctrl+X)</li>
      <li>вставить строку из буфера перед текущей строкой (Ctrl+V)</li>
    </ul>
    <p>Изначально курсор находится на первой (начальной) строке.</p>
    <p>Операции Down с курсором на последней строке и Up с курсором на первой строке должны игнорироваться.</p>
    <p>Любой текстовый файл в системе заканчивается переводом строки. Поэтому последняя строка любого файла является пустой. Операция Ctrl+X на пустой строке ничего не делает.</p>
    <p>Изначально буфер редактора пустой. Операция Ctrl+X перезаписывает буфер, если в нём уже было какое-то значение. Операция Ctrl+V не очищает буфер и может быть использована несколько раз подряд. Операция Ctrl+V при пустом буфере ничего не делает.</p>
    <p>Помогите Пете протестировать его текстовый редактор. Напишите программу, которая по заданному файлу и набору команд выводит получившийся файл.</p>

    <h4>Формат ввода</h4>
    <p>Программе на вход подаётся набор строк, разделённых переносом строки. Длина каждой строки не превышает 3000 символов. Последняя строка в файле является пустой. Она означает завершение ввода файла. Других пустых строк в файле быть не может.</p>
    <p>После этого и до окончания ввода программе подаются команды Down, Up, Ctrl+X, Ctrl+V.</p>

    <h4>Формат вывода</h4>
    <p>Выведите получившийся файл построчно.</p>

    <h4>Пример 1</h4>
<pre>
program
is awesome
My
is awful

Down
Down
Down
Ctrl+X
Up
Ctrl+X
Up
Up
Ctrl+V
</pre>
<pre>
My
program
is awesome
</pre>

    <h4>Пример 2</h4>
<pre>
copy
paste

Ctrl+X
Ctrl+V
Ctrl+V
Ctrl+V
Ctrl+X
Ctrl+V
Ctrl+V
Ctrl+V
</pre>
<pre>
copy
copy
copy
paste
paste
paste
</pre>
    <p>Примечание</p>
    <p>Если условие кажется вам запутанным, попробуйте воспользоваться настоящим текстовым редактором, например Sublime. Создайте пустой файл, вставьте любой пример из условия и исполняйте заданные команды. В итоге вы должны получить точно такой же файл, как в ответе. Таким образом описанное в условии поведение в точности соответствует поведению множества настоящих текстовых редакторов.</p>
    <p>Используйте std::getline для считывания строчек файла.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Для работы со строками нам нужен контейнер для хранения данных, в котором вставка в середину возможна за константное время. При этом нам не нужно иметь произвольный доступ по индексу, так как курсор в файле перемещается последовательно. Подходящим контейнером является двусвязный список std::list.</p>
    <p>Запишем все строки (кроме последней пустой) в список. В роли курсора будет выступать итератор списка. Вспомним, что операции над списком не инвалидируют существующие итераторы.</p>
    <p>Далее будем последовательно обрабатывать команды.</p>
    <ol>
      <li>
        <h4>Команда Up.</h4>
        <p>Необходимо передвинуть итератор на одну позицию назад. Для этого можно воспользоваться конструкцией --cursor. Необходимо не забыть про случай, когда курсор уже находится на первой строке.</p>
      </li>
      <li>
        <h4>Команда Down.</h4>
        <p>Необходимо передвинуть итератор на одну позицию вперёд, воспользовавшись конструкцией ++cursor. Перед этим надо проверить, не находится ли курсор на последний строке.</p>
      </li>
      <li>
        <h4>Команда Ctrl+X.</h4>
        <p>Копируем текущее значение итератора в буфер. После этого перезаписываем курсор с помощью cursor = file.erase(cursor). Напомним, что erase возвращает итератор на следующий элемент в списке, что соответствует требуемому поведению.</p>
      </li>
      <li>
        <h4>Команда Ctrl+V.</h4>
        <p>Проверяем, что буфер не пуст, и используем функцию insert.</p>
      </li>
    </ol>
<pre>
#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;string&gt;
#include &lt;utility&gt;

int main() {
  std::list&lt;std::string&gt; file;

  while (true) {
    std::string line;
    std::getline(std::cin, line);

    if (line.empty()) {
      break;
    }

    file.push_back(line);
  }

  auto cursor = file.begin();
  std::string buffer;

  std::string command;
  while (std::cin >> command) {
    if (command == "Up") {
      if (cursor == file.begin()) {
        continue;
      }
      --cursor;
    } else if (command == "Down") {
      if (cursor == file.end()) {
        continue;
      }
      ++cursor;
    } else if (command == "Ctrl+X") {
      if (cursor == file.end()) {
        continue;
      }
      buffer = std::move(*cursor);
      cursor = file.erase(cursor);
    } else if (command == "Ctrl+V") {
      if (buffer.empty()) {
        continue;
      }
      file.insert(cursor, buffer);
    }
  }

  for (const auto &x: file) {
    std::cout &lt;&lt; x &lt;&lt; "\n";
  }
}
</pre>
    <p>Обратите внимание, что при вырезании строки в буфер мы используем функцию std::move. Она позволяет забрать владение строкой, которая вот-вот будет удалена из списка, и сэкономить на её копировании. Подробнее про move-семантику рассказано в параграфе «Жизненный цикл объекта».</p>
  </details>

  <h4>Задача «Ctrl+X, Ctrl+V - 2»</h4>

  <details>
    <summary>Условие</summary>
    <p>Эта задача — продолжение предыдущей задачи Ctrl+X, Ctrl+V. В качестве основы вы можете взять код оттуда.</p>
    <p>Петя продолжает разработку своего текстового редактора. На этот раз добавилось еще одна операция — зажать клавишу Shift (Shift).</p>
    <p>Операции Up и Down при зажатой клавише Shift выделяют строки в текстовом редакторе. Если курсор находится на строке n, то после операций Shift, Down, Down выделенными окажутся строки n и n+1.</p>
    <p>Операция Ctrl+X вырезает выделенные строки из файла в буфер. Операция Ctrl+V копирует строки из буфера, заменяя выделенные строки в файле.</p>
    <p>Операции Ctrl+X и Ctrl+V сбрасывают выделение после исполнения и отпускают клавишу Shift. Если при исполнении этих операций в файле не выделена ни одна строка, поведение должно соответствовать предыдущей задаче Ctrl+X, Ctrl+V.</p>

    <h4>Формат ввода</h4>
    <p>Программе на вход подаётся набор строк, разделённых переносом строки. Длина каждой строки не превышает 3000 символов. Последняя строка в файле является пустой. Она означает завершение ввода файла. Других пустых строк в файле быть не может.</p>
    <p>После этого и до окончания ввода программе подаются команды Down, Up, Ctrl+X, Ctrl+V, Shift.</p>

    <h4>Формат вывода</h4>
    <p>Выведите получившийся файл построчно.</p>

    <h4>Пример</h4>
<pre>
My
program
is
awful
bad
poor
wrong
awesome

Down
Down
Down
Shift
Down
Down
Down
Down
Ctrl+X
</pre>
<pre>
My
program
is
awesome
</pre>
    <p>Примечание</p>
    <p>Для вырезания строк из файла в буфер удобно использовать функцию splice. Разберитесь самостоятельно по документации, как она устроена.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Как и рекомендуется в условии, возьмём за основу код из предыдущей задачи. Однако теперь в качестве буфера у нас будет не одна строка, а лист строк.</p>
    <p>Также нам понадобятся дополнительные переменные для обработки нажатия клавиши Shift:</p>
    <ul>
      <li>В логической переменной shiftPressed будем поддерживать текущее состояние клавиши: true если клавиша нажата и false если нет.</li>
      <li>В переменной shift будем хранить указатель на строчку, на которой произошло нажатие клавиши Shift.</li>
      <li>В переменной shiftOffset будем поддерживать разность номера строки где сейчас находится курсор и номера
        строки на которой была нажата клавиша Shift.</li>
    </ul>
    <p>Далее будем последовательно обрабатывать команды.</p>
    <ol>
      <li>
        <h4>Команда Up.</h4>
        <p>Добавим проверку нажата ли сейчас клавиша Shift. Если нажата – уменьшим shiftOffset на единицу. Иначе передвинем указатель shift вместе с курсором.</p>
      </li>
      <li>
        <h4>Команда Down.</h4>
        <p>Аналогично команде Up, только здесь мы будем увеличивать shiftOffset на единицу.</p>
      </li>
      <li>
        <h4>Команда Shift.</h4>
        <p>Единственное, что мы должны сделать при вызове этой команды – поставить переменной shiftPressed значение true.</p>
      </li>
      <li>
        <h4>Команда Ctrl+X.</h4>
        <p>Воспользуемся функцией .splice, которая позволит нам эффективно и без копирования «вырезать» элементы из одного листа и вставить их в другой. Достаточно лишь передать этой функции два итератора cursor и shift. Воспользуемся переменной shiftOffset чтобы понять, какой из этих двух итераторов должен идти первым. Также нужно корректно обработать операцию Ctrl+X без зажатой клавиши Shift (cursor == shift). В таком случае необходимо заранее сделать копию курсора, иначе после операции .splice старый курсор будет ссылаться на элемент в буфере, а не в файле. В конце не забудем «обнулить» все переменные, связанные с клавишей Shift.</p>
      </li>
      <li>
        <h4>Команда Ctrl+V.</h4>
        <p>Сначала сделаем операцию .erase, аналогично определяя порядок итераторов с помощью shiftOffset. После сделаем .insert, передав ему итераторы на наш буфер. В конце также не забудем обнулить Shift переменные.</p>
      </li>
    </ol>
    <p>Итоговое решение:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;string&gt;

int main() {
  std::list&lt;std::string&gt; file;

  while (true) {
    std::string line;
    std::getline(std::cin, line);

    if (line.empty()) {
      break;
    }

    file.push_back(line);
  }

  auto cursor = file.begin();

  std::list&lt;std::string&gt; buffer;

  bool shiftPressed = false;
  int shiftOffset = 0;
  auto shift = file.begin();

  std::string command;
  while (std::cin >> command) {
    if (command == "Up") {
      if (cursor == file.begin()) {
        continue;
      }

      --cursor;
      if (!shiftPressed) {
        shift = cursor;
      } else {
        --shiftOffset;
      }
    } else if (command == "Down") {
      if (cursor == file.end()) {
        continue;
      }

      ++cursor;
      if (!shiftPressed) {
        shift = cursor;
      } else {
      ++shiftOffset;
      }
    } else if (command == "Ctrl+X") {
      if (shift == cursor && cursor == file.end()) {
        continue;
      }

      buffer.clear();

      if (shift == cursor) {
        auto toSplice = cursor;
        cursor = std::next(cursor);
        buffer.splice(buffer.begin(), file, toSplice);
      } else if (shiftOffset &lt; 0) {
        buffer.splice(buffer.begin(), file, cursor, shift);
        cursor = shift;
      } else {
        buffer.splice(buffer.begin(), file, shift, cursor);
      }

      shiftPressed = false;
      shift = cursor;
      shiftOffset = 0;
    } else if (command == "Ctrl+V") {
      if (buffer.empty()) {
        continue;
      }

      if (shiftOffset &lt; 0) {
        cursor = file.erase(cursor, shift);
      } else if (shiftOffset > 0) {
        cursor = file.erase(shift, cursor);
      }

      file.insert(cursor, buffer.begin(), buffer.end());

      shiftPressed = false;
      shift = cursor;
      shiftOffset = 0;
    } else if (command == "Shift") {
      shiftPressed = true;
    }
  }

  for (const auto &x: file) {
    std::cout &lt;&lt; x &lt;&lt; "\n";
  }
}
</pre>
  </details>

  <h3>Параграф «Ассоциативные контейнеры»</h3>

  <h4>Задача «Встречалось ли число раньше?»</h4>

  <details>
    <summary>Условие</summary>
    <p>На вход подаётся последовательность целых чисел. Для каждого числа выведите в отдельной строке слово YES, если это число ранее встречалось в последовательности, и NO, если не встречалось.</p>

    <h4>Формат ввода</h4>
    <p>Вводится список чисел. Все числа списка находятся на одной строке и разделены пробелом. Каждое число представимо типом int.</p>

    <h4>Формат вывода</h4>
    <p>Выведите ответ на задачу.</p>

    <h4>Пример</h4>
    <code>1 2 1 2 2 1 6</code>
<pre>
NO
NO
YES
YES
YES
YES
NO
</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Эту задачу удобно решить через std::set, но так как нам не важен порядок элементов, то лучше будет использовать std::unordered_set. Будем сохранять прочитанные числа и выводить каждый раз YES, если это число уже есть в нашем множестве, и NO в противном случае. Не забудем сохранить само число во множестве.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;unordered_set&gt;

int main() {
  std::unordered_set&lt;int&gt; numbers;
  int number;
  while (std::cin >> number) {
    if (numbers.contains(number)) {
      std::cout &lt;&lt; "YES\n";
    } else {
      std::cout &lt;&lt; "NO\n";
      numbers.insert(number);
    }
  }
}
</pre>
    <p>Можно было бы вместо вызова contains воспользоваться тем, что функция insert возвращает пару из итератора и успешности вставки:</p>
<pre>
if (numbers.insert(number).second) {
  std::cout &lt;&lt; "NO\n";
} else {
  std::cout &lt;&lt; "YES\n";
}
</pre>
  </details>

  <h4>Задача «Общие буквы»</h4>

  <details>
    <summary>Условие</summary>
    <p>Вам даны слова. Выведите в алфавитном порядке список общих букв всех слов.</p>

    <h4>Формат ввода</h4>
    <p>На вход поступают слова (по одному в строке), состоящие из маленьких латинских букв алфавита. Длина слов не превосходит 100 символов, а количество слов не превосходит 1000.</p>

    <h4>Формат вывода</h4>
    <p>Выведите в алфавитном порядке без пробелов список букв, которые присутствуют в каждом слове.</p>

    <h4>Пример 1</h4>
<pre>
apple
peach
</pre>
    <code>aep</code>

    <h4>Пример 2</h4>
<pre>
alpha
beta
gamma
delta
epsilon
</pre>
    <code></code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Воспользуемся контейнером std::map&lt;char, int&gt;. Будем для каждой буквы подсчитывать число слов, в которых эта буква встретилась. Затем напечатаем все буквы, которые встретились во всех словах.</p>
    <p>Если какая-то буква повторяется в слове, то важно не посчитать её дважды. Для этого сначала буквы всех слов сложим в set или unordered_set.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;string&gt;

int main() {
  std::map&lt;char, int&gt; counter;
  std::string word;
  int wordsCount = 0;
  while (std::cin >> word) {
    ++wordsCount;
    std::set&lt;char&gt; letters(word.begin(), word.end());
    for (char c : letters) {
      ++counter[c];
    }
  }
  for (auto [c, freq] : counter) {
    if (freq == wordsCount) {
      std::cout &lt;&lt; c;
    }
  }
  std::cout &lt;&lt; "\n";
}
</pre>
  </details>

  <h4>Задача «Файловая система»</h4>

  <details>
    <summary>Условие</summary>
    <p>Дан список всех файлов в некоторой файловой системе. Необходимо вывести все непустые директории этой файловой системы в лексикографическом порядке.</p>
    <p>Гарантируется, что все пути начинаются от корня файловой системы. Все пути состоят из слешей (/), латинских символов, цифр и точек. Два слеша никогда не стоят подряд.</p>

    <h4>Формат ввода</h4>
    <p>На вход подаются строки, описывающие пути ко всем файлам в системе. Каждый путь содержится в отдельной строке. Число строк не превосходит 10000.</p>

    <h4>Формат вывода</h4>
    <p>Выведите все непустые директории в этой файловой системе в лексикографическом порядке. Каждый путь должен начинаться со слеша и заканчиваться слешом.</p>

    <h4>Пример 1</h4>
<pre>
/docs/README.txt
/docs/LICENSE.txt
/boot/grub
/init
</pre>
<pre>
/
/boot/
/docs/
</pre>

    <h4>Пример 2</h4>
<pre>
/root/test.cpp
/root/tests/01
/root/tests/01.a
/bin/bash
</pre>
<pre>
/
/bin/
/root/
/root/tests/
</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Воспользуемся контейнером set. Если нам дан путь к некоторому файлу, то все его родительские директории заведомо непустые. Надо будет аккуратно вырезать из этого пути все подстроки, которые заканчиваются на /, и сложить их в set.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;string&gt;

int main() {
  std::set&lt;std::string&gt; dirs;
  std::string path;
  while (std::getline(std::cin, path)) {
    for (size_t i = 0; i != path.size(); ++i) {
      if (path[i] == '/') {
        dirs.insert(path.substr(0, i + 1));
      }
    }
  }
  for (const auto& dir : dirs) {
    std::cout &lt;&lt; dir &lt;&lt; "\n";
  }
}
</pre>
  </details>

  <h4>Задача «Предметный указатель»</h4>

  <details>
    <summary>Условие</summary>
    <p>Профессор написал научную книгу и составил для неё предметный указатель. Это список ключевых слов, для каждого из которых указана страница, на которой это слово встречается. Теперь профессор хочет для каждой страницы выписать в алфавитном порядке все ключевые слова, которые на эту страницу попали (если такие вообще есть). Помогите профессору решить эту задачу.</p>

    <h4>Формат ввода</h4>
    <p>Сначала задано натуральное число n, не превосходящее 1000 — количество слов, которое требуется обработать. Далее идут n строк. В каждой строке сначала записано ключевое слово. Затем идёт натуральное число, также не превосходящее 1000, — номер страницы. Ключевые слова состоят из латинских букв, не бывают пустыми и по длине не превосходят 16 символов. Слова в списке, конечно, могут повторяться.</p>

    <h4>Формат вывода</h4>
    <p>Выпишите в порядке возрастания все страницы, на которых присутствуют ключевые слова. После каждого номера страницы через пробел выпишите в алфавитном порядке сами эти слова. Если на какой-то странице слово встретилось несколько раз, то повторять его не нужно. Завершающего пробела в конце строк быть не должно.</p>

    <h4>Пример</h4>
<pre>
5
derivative 10
function 2
function 10
function 10
limit 7
</pre>
<pre>
2 function
7 limit
10 derivative function
</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Воспользуемся ассоциативным контейнером, который будет номерам страниц сопоставлять множества слов на этой странице. Так как в ответе надо вывести страницы по возрастанию, а слова — по алфавиту, то нам подойдут упорядоченные контейнеры std::map и std::set.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;string&gt;

int main() {
  std::map&lt;int, std::set&lt;std::string&gt; &gt; index;

  int n;
  std::cin >> n;
  for (int i = 0; i &lt; n; ++i) {
    std::string word;
    int page;
    std::cin >> word >> page;
    index[page].insert(word);
  }

  for (const auto& [page, words] : index) {
    std::cout &lt;&lt; page;
    for (const auto& word : words) {
      std::cout &lt;&lt; " " &lt;&lt; word;
    }
    std::cout &lt;&lt; "\n";
  }
}
</pre>
  </details>

  <h4>Задача «Символьные n-граммы»</h4>

  <details>
    <summary>Условие</summary>
    <p>Будем называть символьной n-граммой последовательность из n последовательно идущих символов в одном слове в тексте. Для данного числа n подсчитайте суммарное количество каждой  n-граммы в тексте.</p>

    <h4>Формат ввода</h4>
    <p>В первой строке заданы два числа: m — число слов в тексте (от 1 до 100000) и n — длина n-граммы (от 1 до 5). Далее идет m слов. Можно считать, что слова отделены пробелами или переносами строк. Обработку пунктуации и регистра реализовывать не нужно. Читайте слова просто через std::cin >> word.</p>

    <h4>Формат вывода</h4>
    <p>Выведите все n-граммы, отсортированные по убыванию частоты, а в случае равных частот — лексикографически (по алфавиту). Для каждой n-граммы напечатайте также её частоту (смотрите формат в примере).</p>

    <h4>Пример</h4>
<pre>
6 2
to be or not to be
</pre>
<pre>
be - 2
to - 2
no - 1
or - 1
ot - 1
</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Задача похожа на классическую задачу про подсчёт частоты слов в тексте, только вместо слов надо будет подсчитывать подстроки слов длины N.</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;tuple&gt;
#include &lt;unordered_map&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

int main() {
  size_t m, n;
  std::cin >> m >> n;

  std::unordered_map&lt;std::string, int&gt; freqs;

  for (size_t i = 0; i != m; ++i) {
    std::string word;
    std::cin >> word;
    for (size_t j = n; j &lt;= word.size(); ++j) {
      ++freqs[word.substr(j - n, n)];
    }
  }

  std::vector&lt;std::pair&lt;std::string, int&gt; &gt; sorted(freqs.begin(), freqs.end());
  std::sort(
    sorted.begin(),
    sorted.end(),
    [](const auto& p1, const auto& p2) {
      return std::tie(p2.second, p1.first) &lt; std::tie(p1.second, p2.first);
    }
  );

  for (const auto& [word, freq] : sorted) {
    std::cout &lt;&lt; word &lt;&lt; " - "
    &lt;&lt; freq &lt;&lt; "\n";
  }
}
</pre>
    <p>Пожалуй, самый нетривиальный фрагмент здесь — выделение подстрок:</p>
<pre>
for (size_t j = n; j &lt;= word.size(); ++j) {
  ++freqs[word.substr(j - n, n)];
}
</pre>
    <p>Здесь j пробегает все позиции за последним символом подстроки. Соотвественно, j - n — всевозможные начальные позиции подстрок длины n. Так организованный цикл защищён от случайных переполнений и вычитаний большего числа из меньшего в беззнаковом типе size_t. В таких конструкциях всегда полезно проверять себя на "крайних" случаях (например, когда n совпадает с word.size()).</p>
    <p>Если известно, что n мало по сравнению со средним размером слова, то более выгодным по скорости может оказаться другое решение: сначала сохраняем в std::unordered_map все слова, а сами n-граммы строим как std::unordered_map&lt;std::string_view, int&gt;:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;string_view&gt;
#include &lt;tuple&gt;
#include &lt;unordered_map&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

int main() {
  size_t m, n;
  std::cin >> m >> n;

  std::unordered_map&lt;std::string, int&gt; words;
  words.reserve(m);
  for (size_t i = 0; i != m; ++i) {
    std::string word;
    std::cin >> word;
    ++words[word];
  }

  std::unordered_map&lt;std::string_view, int&gt; freqs;

  for (const auto& [word, freq] : words) {
    std::string_view sv = word;
    for (size_t j = n; j &lt;= sv.size(); ++j) {
      freqs[sv.substr(j - n, n)] += freq;
    }
  }

  std::vector&lt;std::pair&lt;std::string_view, int>> sorted(freqs.begin(), freqs.end());
  std::sort(
    sorted.begin(),
    sorted.end(),
    [](const auto& p1, const auto& p2) {
      return std::tie(p2.second, p1.first) &lt; std::tie(p1.second, p2.first);
    }
  );

  for (const auto& [word, freq] : sorted) {
    std::cout &lt;&lt; word &lt;&lt; " - "
    &lt;&lt; freq &lt;&lt; "\n";
  }
}
</pre>
  </details>

  <h3>Параграф «Алгоритмы»</h3>

  <h4>Задача «Удвоить вектор»</h4>

  <details>
    <summary>Условие</summary>
    <p>Требуется написать шаблонную функцию Dublicate, которая получает на вход вектор и дублирует все его элементы в конце вектора. Например, из вектора с элементами 1, 2, 3 должен получиться вектор с элементами 1, 2, 3, 1, 2, 3. Вася написал вот такую реализацию, которая почему-то не работает:</p>
<pre>
#include &lt;vector&gt;

template &lt;typename T&gt;
void Dublicate(std::vector&lt;T&gt;& v) {
  for (auto it = v.begin(); it != v.end(); ++it) {
    v.push_back(*it);
  }
}
</pre>
    <p>Вам надо исправить код Васи.</p>
    <p>Примечания</p>
    <p>Сдайте в систему только исправленный код функции Dublicate без функции main. Подключите все необходимые для вашей реализации библиотеки. Заголовок функции Вася написал правильно, в этом можете не сомневаться.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Решение Васи не работает, так как в процессе вставки итераторы вектора инвалидируются и программа попадает в неопределённое поведение. Самый простой способ исправить проблему — переписать цикл через индексы. При этом исходный размер вектора надо запомнить в начале цикла. Это можно сделать прямо в секции инициализации цикла for:</p>
<pre>
#include &lt;vector&gt;

template &lt;typename T&gt;
void Dublicate(std::vector&lt;T&gt;& v) {
  for (size_t n = v.size(), i = 0; i &lt; n; ++i) {
    v.push_back(v[i]);
  }
}
</pre>
    <p>Другой способ — зарезервировать в векторе заранее удвоенное число элементов. Тогда при вставке не будет происходить реаллокаций, и итераторы не будут инвалидироваться. Исходное решение заработает. Но его всё же удобнее переписать через алгоритм copy:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;vector&gt;

template &lt;typename T&gt;
void Dublicate(std::vector&lt;T&gt;& v) {
  v.reserve(v.size() * 2);
  std::copy(v.begin(), v.end(), std::back_inserter(v));
}
</pre>
  </details>

  <h3>Задача «Алгоритм unique»</h3>

  <details>
    <summary>Условие</summary>
    <p>Вам надо написать свою реализацию стандартного алгоритма unique. Заголовок функции должен быть таким:</p>
<pre>
template &lt;typename Iter&gt;
Iter Unique(Iter first, Iter last);
</pre>
    <p>Функция должна переупорядочить элементы диапазона [first; last) так, чтобы подряд идущие одинаковые элементы в ней не встречались. Функция возвращает итератор за последний элемент итоговой последовательности. Что останется в пределах от этого вернувшегося итератора до старого last — не важно. Время работы функции должно линейно зависеть от длины диапазона.</p>
    <p>В вашем решении должен быть только код этой шаблонной функции и не должно быть функции main. Использовать вызов std::unique нельзя.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Будем идти по диапазону от начала до конца двумя итераторами. Первый итератор будет сдвигаться всегда на одну позицию вправо. А второй итератор будет проматывать повторы, сдвигаясь на ближайший правый элемент, отличный от текущего. Будем записывать значение из второго итератора в ячейку, на которую указывает первый итератор. В конце цикла первый итератор как раз будет указывать за последний записанный элемент.</p>
<pre>
template &lt;typename Iter&gt;
Iter Unique(Iter first, Iter last) {
  auto it1 = first;
  auto it2 = first;
  while (it2 != last) {
    if (it1 != it2) {
      *it1 = *it2;
    }
    ++it1;
    const auto& value = *it2;
    while (it2 != last && *it2 == value) {
      ++it2;
    }
  }
  return it1;
}
</pre>
    <p>Заметим, что вместо *it1 = *it2 правильнее было бы написать *it1 = std::move(*it2), так как нам больше не потребуется значение в ячейке *it2, и у него можно отобрать владение. Это имеет смысл, если значения — сложные типы с нетривиальным копированием (например, контейнеры). Подробнее про move-семантику рассказано в параграфе «Жизненный цикл объекта».</p>
  </details>

  <h4>Задача «Алгоритм set_difference»</h4>

  <details>
    <summary>Условие</summary>
    <p>Напишите свою реализацию стандартного алгоритма set_difference. Заголовок функции должен быть таким:</p>
<pre>
template &lt;typename InIter1, typename InIter2, typename OutIter&gt;
OutIter SetDifference(InIter1 first1, InIter1 last1,
                      InIter2 first2, InIter2 last2,
                      OutIter out);
</pre>
    <p>Функция должна сформировать элементы разности диапазонов [first1, last1) и [first2, last2) и записать их в последовательность, начинающуюся с out. Исходные диапазоны предполагаются отсортированными. Каждый элемент считается со своей кратностью. Функция должна вернуть итератор, который указывает за последний записанный элемент.</p>
    <p>В вашем решении должен быть только код этой шаблонной функции и не должно быть функции main. Программа должна использовать константную память и быть линейной по сложности. Допускается сравнивать итераторы с помощью == и !=, а также сравнивать элементы с помощью &lt;. Использовать вызов std::set_difference нельзя.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Будем идти двумя итераторами it1 и it2 по первому и второму диапазонам. Если текущий элемент во втором диапазоне меньше элемента в первом, то промотаем второй итератор вперёд. Если текущие элементы в диапазонах оказались разными, то элемент первого диапазона не встречается во втором и должен попасть в ответ. Если же элементы оказались равными, то нужно продвинуть оба итератора на одну позицию вперёд.</p>
    <p>В реализации необходимо следить за тем, чтобы итераторы не вышли за допустимые границы. К тому же, сравнивать сами элементы можно только с помощью оператора &lt;.</p>
<pre>
template &lt;typename InIter1, typename InIter2, typename OutIter&gt;
OutIter SetDifference(InIter1 first1, InIter1 last1, InIter2 first2, InIter2 last2, OutIter out) {
  auto it1 = first1;
  auto it2 = first2;

  while (it1 != last1) {
    while (it2 != last2 && *it2 &lt; *it1) {
      ++it2;
    }
    if (it2 == last2 || *it1 &lt; *it2) {
      *out = *it1;
      ++out;
    } else if (it2 != last2) {
      ++it2;
    }
    ++it1;
  }
  return out;
}
</pre>
  </details>

  <h4>Задача «Приближённый двоичный поиск»</h4>

  <details>
    <summary>Условие</summary>
    <p>В этой задаче нужно применить функцию std::lower_bound и итераторы для быстрого поиска ближайшего элемента в отсортированном массиве.</p>

    <h4>Формат ввода</h4>
    <p>В первой строке входных данных содержатся натуральные числа n и k, не превосходящие 100000. Во второй строке задаются целых n чисел первого массива, отсортированного по неубыванию, а в третьей строке – k целых чисел второго массива. Каждое число в обоих массивах по модулю не превосходит 2⋅10⁹. Второй массив, в отличие от первого, не отсортирован.</p>

    <h4>Формат вывода</h4>
    <p>Для каждого из k чисел выведите в отдельной строке число из первого массива, наиболее близкое к данному. Если таких несколько, выведите меньшее из них.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Сложим числа первого массива в вектор. Второй массив складывать в вектор не нужно: мы сможем подбирать ближайший элемент из первого массива на лету. Оформим этот подбор в функции Approx. Она получает на вход первый массив и число x из второго массива. Так как первый массив отсортирован, то мы можем применить алгоритм std::lower_bound, чтобы бинарным поиском найти итератор первого элемента, большего или равного x. Дальше возможны такие взаимоисключающие случаи:</p>
    <ol>
      <li>Все числа в массиве меньше x. Тогда вернётся итератор end(). Достаточно вернуть последнее число из массива.</li>
      <li>Все числа в массиве больше x. Тогда вернётся итератор begin(). Возвращаем первое число из массива.</li>
      <li>В массиве есть число x. Его и возвращаем.</li>
      <li>В массиве есть числа как меньшие x, так и большие x, но нет самого x. Тогда надо сравнить с x два элемента: *std::prev(iter) и *iter.</li>
    </ol>
<pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;

int Approx(const std::vector&lt;int&gt;& v, int x) {
  auto iter = std::lower_bound(v.begin(), v.end(), x);
  if (iter == v.end()) {
    return *std::prev(iter);
  } else if (iter == v.begin()) {
    return *iter;
  } else if (*iter == x) {
    return *iter;
  } else {
    int x1 = *std::prev(iter);
    int x2 = *iter;
    if (std::abs(x1 - x) &lt;= std::abs(x2 - x)) {
      return x1;
    } else {
      return x2;
    }
  }
}

int main() {
  int n, k;
  std::cin >> n >> k;

  std::vector&lt;int&gt; v(n);
  for (int i = 0; i != n; ++i) {
    std::cin >> v[i];
  }

  for (int i = 0; i != k; ++i) {
    int x;
    std::cin >> x;
    std::cout &lt;&lt; Approx(v, x) &lt;&lt; "\n";
  }
}
</pre>
  </details>

  <h4>Задача «Функция Process»</h4>

  <details>
    <summary>Условие</summary>
    <p>Андрею надо написать шаблонную функцию Process, которая обрабатывает вектор с числами некоторого типа T. Его функция должна вызвать другую функцию PrintResults, чтобы напечатать с определенным форматированием положительные числа из вектора. Функция PrintResults принимает на вход пару итераторов, как и многие алгоритмы стандартной библиотеки. Поэтому Андрей решил сначала скопировать нужные элементы исходного вектора в другой массив, чтобы передать его начало и конец в эту функцию. Вот код Андрея:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;vector&gt;

template &lt;typename T&gt;
void Process(const std::vector&lt;T&gt;& data) {
  std::vector&lt;T> filtered;

  auto filteredLast = std::copy_if(
    data.begin(),
    data.end(),
    filtered.begin(),
    [](const T& x) { return x > 0; }
  );

  PrintResults(filtered.begin(), filteredLast);
16}
</pre>
    <p>Этот код почему-то не работает. Найдите ошибку и сдайте исправленное решение.</p>
    <p>Вам нужно сдать только исправленный код Андрея. В вашей программе не должно быть функции main.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Проблема в том, что в решении Андрея применяется алгоритм std::copy_if к пустой выходной последовательности. Правильнее всего будет воспользоваться функций std::back_inserter. Теперь можно не запоминать результат работы copy_if: он всё равно будет равен filtered.end().</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;

template &lt;typename T&gt;
void Process(const std::vector&lt;T&gt;& data) {
  std::vector&lt;T&gt; filtered;

  std::copy_if(
    data.begin(),
    data.end(),
    std::back_inserter(filtered),
    [](const T& x) { return x > 0; }
  );

  PrintResults(filtered.begin(), filtered.end());
}
</pre>
  </details>

  <h3>Параграф «Адаптеры и представления»</h3>

  <h4>Задача «Скобочная последовательность»</h4>

  <details>
    <summary>Условие</summary>
    <p>На вход подаётся скобочная последовательность — строка, которая состоит из скобок ()[]{}. Вам нужно определить, является ли она правильной. В правильной скобочной последовательности каждой открывающей скобке соответствует закрывающая и пары скобок корректно вложены друг в друга.</p>

    <h4>Формат ввода</h4>
    <p>Строка, состоящая из символов ()[]{}.</p>

    <h4>Формат вывода</h4>
    <p>Напечатайте YES, если скобочная последовательность является правильной, и NO в противном случае.</p>

    <h4>Пример 1</h4>
    <code>({{{[]})</code>
    <code>NO</code>

    <h4>Пример 2</h4>
    <code>}()[]{</code>
    <code>NO</code>

    <h4>Пример 3</h4>
    <code>{(())()}[]</code>
    <code>YES</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Воспользуемся адаптером std::stack. Будем помещать в стек открывающие скобки. Если нам встретилась закрывающая скобка, то убедимся, что она соответствует открывающей скобке на вершине стека и уберём из стека эту вершину. Скобочная последовательность будет правильной, если в конце стек окажется пустым. Удобно оформить этот алгоритм в виде функции IsCorrect, которая принимает строку.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;stack&gt;
#include &lt;string&gt;

bool IsCorrect(const std::string& sequence) {
  std::stack&lt;char&gt; brackets;

  for (char bracket : sequence) {
    if (bracket == '(' || bracket == '{' || bracket == '[') {
      brackets.push(bracket);
    } else {
      if (brackets.empty()) {
        return false;
      }
      char top = brackets.top();
      if ((top == '(' && bracket == ')') || (top == '{' && bracket == '}') || (top == '[' && bracket == ']')) {
      brackets.pop();
      } else {
        return false;
      }
    }
  }

  return brackets.empty();
}

int main() {
  std::string sequence;
  std::getline(std::cin, sequence);
  if (IsCorrect(sequence)) {
    std::cout &lt;&lt; "YES\n";
  } else {
    std::cout &lt;&lt; "NO\n";
  }
}
</pre>
  </details>

  <h4>Задача «Минимум на отрезке»</h4>

  <details>
    <summary>Условие</summary>
    <p>Рассмотрим последовательность целых чисел длины n. По ней с шагом 1 двигается «окно» длины k. Другими словами, сначала в «окне» видны первые k чисел, на следующем шаге в «окне» уже будут находиться k чисел, начиная со второго, и так далее до конца последовательности. Требуется для каждого положения «окна» определить в нём минимальное число.</p>

    <h4>Формат ввода</h4>
    <p>В первой строке входных данных содержатся два натуральных числа n и k — длины последовательности и «окна». При этом n⩽150000, k⩽10000, k⩽n. На следующей строке находятся n чисел — сама последовательность.</p>

    <h4>Формат вывода</h4>
    <p>Выходые данные должны содержать n-k+1 строк — минимумы для каждого положения «окна».</p>

    <h4>Пример</h4>
<pre>
7 3
1 3 2 4 5 3 1
</pre>
<pre>
1
2
2
3
1
</pre>
    <p>Для решения задачи рекомендуется использовать std::multiset для хранения окна. Решение с непосредственным подсчётом минимума для каждого положения окна будет неэффективным.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>С одной стороны, нам потребуется хранить последовательность чисел в окне, чтобы знать, в каком порядке они будут выходить из окна. Можно было бы сложить все числа в std::vector, но это слишком расточительно. Достаточно хранить только элементы из окна. На эту роль отлично подходит адаптер std::queue.</p>
    <p>С другой стороны, нам надо уметь быстро находить минимальный элемент в окне. Для этого можно воспользоваться контейнером std::multiset (числа могут повторяться, поэтому std::set не подойдёт).</p>
    <p>Итак, алгоритм таков:</p>
    <ol>
      <li>Добавляем в окно новый элемент.</li>
      <li>Если окно заполнено, то печатаем минимальный элемент окна и удаляем из него крайний элемент.</li>
    </ol>
<pre>
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;set&gt;

int main() {
  int n, k;
  std::cin >> n >> k;

  std::queue&lt;int&gt; numbers;
  std::multiset&lt;int&gt; window;

  for (int i = 1; i &lt;= n; ++i) {
    int x;
    std::cin >> x;
    numbers.push(x);
    window.insert(x);
    if (i >= k) {
      std::cout &lt;&lt; *window.begin() &lt;&lt; "\n";
      auto iter = window.find(numbers.front());
      window.erase(iter);
      numbers.pop();
    }
  }
}
</pre>
  </details>

  <h4>Задача «Очередь с приоритетами»</h4>

  <details>
    <summary>Условие</summary>
    <p>Напишите программу, которая будет обрабатывать последовательность запросов таких видов:</p>
    <ol>
      <li>CLEAR — сделать очередь с приоритетами пустой (если в очереди уже были какие-то элементы, то удалить все).</li>
      <li>ADD n — добавить в очередь с приоритетами число n (вмещается в стандартный тип int).</li>
      <li>EXTRACT — вынуть из очереди с приоритетами максимальное значение. Следует изменить данные в памяти и вывести на экран найденное максимальное значение, или, если очередь была пустой, слово CANNOT.</li>
    </ol>

    <h4>Формат ввода</h4>
    <p>Во входных данных записана произвольная последовательность запросов CLEAR, ADD и EXTRACT — каждый в отдельной строке. Суммарное количество всех запросов не превышает 200000.</p>

    <h4>Формат вывода</h4>
    <p>Для каждого запроса типа EXTRACT выведите его результат в отдельной строке.</p>

    <h4>Пример</h4>
<pre>
ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
</pre>
<pre>
192168812
321
555
7
CANNOT
</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Название задачи подсказывает, что нужно использовать контейнер std::priority_queue. Фактически, нужно реализовать обработчик команд. Так как отдельной функции clear у адаптеров нет, то придётся очищать очередь поэлементно.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;queue&gt;

int main() {
  std::priority_queue&lt;int&gt; pq;

  std::string command;
  while (std::cin >> command) {
    if (command == "CLEAR") {
      while (!pq.empty()) {
        pq.pop();
      }
    } else if (command == "ADD") {
      int x;
      std::cin >> x;
      pq.push(x);
    } else if (command == "EXTRACT") {
      if (pq.empty()) {
        std::cout &lt;&lt; "CANNOT\n";
      } else {
        std::cout &lt;&lt; pq.top() &lt;&lt; "\n";
        pq.pop();
      }
    }
  }
}
</pre>
  </details>

  <h4>Задача «Next token»</h4>

  <details>
    <summary>Условие</summary>
  <p>Вам надо написать функцию NextToken для выделения очередного токена в строке. Токеном считается последовательность символов до указанного символа-разделителя (или до конца строки).</p>
  <p>Использоваться функция будет примерно так:</p>
<pre>
int main() {
  std::string_view sv = "Hello world and good bye";

  const char delimiter = ' ';
  std::string_view token;

  // Делим строку на токены по разделителю и перебираем эти токены:
  while (NextToken(sv, delimiter, token)) {
    // обрабатываем очередной token
    // например, печатаем его на экране:
    std::cout &lt;&lt; token &lt;&lt; "\n";
  }
}
</pre>
    <p>Результатом выполнения такой программы будет</p>
<pre>
Hello
world
and
good
bye
</pre>
    <p>Сдайте только код функции NextToken и подключите необходимые библиотеки. Ваша функция будет скомпилирована с нашей функцией main. Гарантируется, что входная строка не заканчивается на разделитель. Догадайтесь сами, какие аргументы должна принимать функция NextToken. Эта функция может менять первый аргумент (sv).</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Первый аргумент функции имеет тип std::string_view: это не самостоятельная строка, а отсылка к подстроке какой-то другой строки. По условию задачи её можно изменять. Будем при каждом вызове функции сдвигать её к началу следующего токена. Для этого будем этот аргумент будем принимать по ссылке. Аналогично, последний аргумент функции тоже изменяется (в него должен быть записан токен), поэтому он тоже должен быть принят по ссылке.</p>
    <p>Заметим, что функция возвращает false, если токенов больше нет.</p>
<pre>
#include &lt;string_view&gt;

bool NextToken(std::string_view& sv, char delim, std::string_view& tok) {
  if (sv.empty()) {
    return false;
  }

  auto pos = sv.find(delim);
  if (pos != sv.npos) {  // разделитель найден
    tok = sv.substr(0, pos);  // вырезаем очередной токен
    sv.remove_prefix(pos + 1);  // сдвигаем sv за разделитель
  } else {
    tok = sv;
    sv.remove_prefix(sv.size());  // формально тут получится пустая строка
  }
  return true;
}
</pre>
    <p>Такая функция не может отличить случай изначально пустой строки от случая последнего пустого токена в строке, которая заканчивается на разделитель. Однако по условию задачи это не важно.</p>
  </details>

  <h4>Задача «Самые частотные слова»</h4>

  <details>
    <summary>Условие</summary>
    <p>Выведите k самых частотных слов текста и их частоты.</p>

    <h4>Формат ввода</h4>
    <p>В первой строке указано натуральное число k, не превосходящее 1000. Далее идут строки текста объёмом до 1 Mб. Слова в тексте разделены пробелами или переводами строк. Различать регистр и обрабатывать пунктуацию не нужно.</p>

    <h4>Формат вывода</h4>
    <p>В выводе должно быть не более k самых частотных слов текста. Через табуляцию после слова напечатайте его частоту. Слова должны быть упрядочены по убыванию частоты, а при равенстве частот — по алфавиту.</p>

    <h4>Пример</h4>
<pre>
3
to be or not to be
that is the question
</pre>
<pre>
be&#9;2
to&#9;2
is&#9;1
</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <p>В параграфе про ассоциативные контейнеры мы рассматривали задачу про частотный словарь. Там мы печатали весь словарь целиком. В этой задаче требуется вывести только k самых частотных слов, где k мало по сравнению с размером словаря. Для этого можно было бы переложить слова в вектор и воспользоваться алгоритмомpartial_sort:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;tuple&gt;
#include &lt;unordered_map&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

int main() {
  size_t k;
  std::cin >> k;

  // Подсчитываем частоты слов
  std::unordered_map&lt;std::string, int&gt; words;
  std::string word;
  while (std::cin >> word) {
    ++words[word];
  }

  // Переносим слова и их частоты в вектор
  std::vector&lt;std::pair&lt;std::string, int&gt; &gt; v(words.begin(), words.end());

  // Находим максимальные k элементов
  std::partial_sort(
    v.begin(),
    v.begin() + std::min(v.size(), k),  // k может оказаться больше размера вектора
    v.end(),
    [](const auto& p1, const auto& p2) { return std::tie(p2.second, p1.first) &lt; std::tie(p1.second, p2.first); }
  );

  // Печатаем топовые слова
  for (size_t i = 0; i &lt; k && i &lt; v.size(); ++i) {
    const auto& [word, freq] = v[i];
    std::cout &lt;&lt; word &lt;&lt; "\t" &lt;&lt; freq &lt;&lt; "\n";
  }
}
</pre>
    <p>Рассмотрим аналогичное решение, где вместо std::partial_sort используется адаптер std::priority_queue. Мы будем поддерживать в очереди с приоритетами не более k элементов. В качестве значений положим туда пары из частоты и самого слова, причём частоту умножим на -1, чтобы она стала отрицательной. Этот трюк позволит выкидывать с вершины очереди пару с минимальной по модулю частотой, а в случае равенства частот — с лексикографически максимальным словом.</p>
    <p>Когда все слова будут обработаны, в очереди с приоритетами останутся нужные нам слова. Но извлекаться они будут в противоположном порядке. Чтобы получить правильный порядок, проще всего скопировать их в вектор и развернуть этот вектор наоборот.</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

int main() {
  size_t k;
  std::cin >> k;

  std::unordered_map&lt;std::string, int&gt; words;
  std::string word;
  while (std::cin >> word) {
    ++words[word];
  }

  using TPair = std::pair&lt;int, std::string&gt;;  // удобный псевдоним для типа

  std::priority_queue&lt;TPair&gt; pq;
  for (const auto& [word, freq] : words) {
    pq.push({-freq, word});  // нарочно кладём отрицательную частоту
    if (pq.size() > k) {
      pq.pop();  // выкидываем элемент с минимальной (то есть, максимальной отрицательной) частотой
    }
  }

  // Копируем элементы в вектор
  std::vector&lt;TPair&gt; top;
  top.reserve(k);

  while (!pq.empty()) {
    const auto& [freq, word] = pq.top();
    top.push_back({-freq, word});  // возвращаем настоящую частоту
    pq.pop();
  }

  // Переворачиваем вектор
  std::reverse(top.begin(), top.end());

  for (const auto& [freq, word] : top) {
    std::cout &lt;&lt; word &lt;&lt; "\t" &lt;&lt; freq &lt;&lt; "\n";
  }
}
</pre>
  </details>
</article>

<!-- 4.1 Классы -->
<article class="article">
  <div class="anchor" id="p4.1"></div>
  <h2>4 Идиомы C++</h2>
  <h3>4.1 Классы</h3>

  <p>Классы похожи на структуры: это пользовательские типы данных, в которых хранятся поля. Синтаксически даже ключевые слова struct и class взаимозаменяемы (только объявления внутри struct по умолчанию публичны, а внутри class — приватны, об этом ниже). Однако мы будем различать семантику структуры и класса:</p>
  <ol>
    <li>Мы будем использовать struct в типах, где не требуется сложная логика по инициализации и обработке значений. Структуры — это просто набор полей, не связанных какими-либо ограничениями. Типичный пример — struct Point из параграфа «Составные типы данных».</li>
    <li>Мы будем использовать class там, где требуются какие-либо действия при инициализации и обработке данных. Класс предполагает некоторый инвариант: он не позволяет изменить данные произвольным образом. Хороший пример — class Time, который мы рассмотрим ниже. Часы, минуты и секунды не могут быть произвольными числами, и класс должен гарантировать, что они всегда корректны.</li>
  </ol>
  <p>Класс, как и структура, задаёт тип данных, но дополнительно определяет его поведение. Переменные этого типа по традиции называются объектами.</p>

  <h4>Объявление класса</h4>

  <p>Рассмотрим сначала простую структуру, которая хранит число время в сутках в виде часов, минут и секунд:</p>
<pre>
struct Time {
  int hours = 0;
  int minutes = 0;
  int seconds = 0;
};
</pre>
  <p>Такая структура очень проста, но она никак не проверяет корректность времени. Предполагается, что hours находится в пределах от 0 до 23, а minutes и seconds — от 0 до 59. Но никто не помешает нам присвоить им другие значения:</p>
<pre>
int main() {
  Time t;
  t.hours = 42;
  t.minutes = -5;
  t.seconds = 61;
}
</pre>
  <p>Чтобы контролировать значения этих полей и гарантировать их корректность, объявим класс Time. Три наших поля в классе будут объявлены в приватной, или закрытой области. Это значит, что доступ к ним будут иметь только особо указанные дружественные функции и функции из класса (member functions). Кстати, в других языках программирования функции из класса именуют методами, но в стандарте C++ термина «метод» нет.</p>
  <p>В публичной области объявим конструктор для начальной инициализации переменной класса Time и три функции для чтения полей:</p>
<pre>
class Time {
private:
  int hours;
  int minutes;
  int seconds;

public:
  Time(int h, int m, int s);  // объявляем конструктор

  // Объявляем три функции для чтения полей:
  int GetHours() const;
  int GetMinutes() const;
  int GetSeconds() const;
};
</pre>
  <p>Здесь мы пока только объявили эти функции, но пока не написали их тела. Мы это сделаем чуть позже. А пока обратите внимание, что конструктор — это особая функция, которая вызывается при создании объекта. Имя конструктора совпадает с именем класса, а возвращаемое значение не указывается. Три функции GetHours, GetMinutes и GetSeconds объявлены константными — с пометой const в конце. Это значит, что эти функции не могут менять состояние объекта (в нашем случае — не изменяют значения полей hours, minutes и seconds).</p>
  <p>Фактически мы скрыли детали реализации нашего класса и предоставили публичный интерфейс — набор функций, через которые можно что-то сделать с объектом.</p>

  <h4>Определение функций из класса</h4>

  <p>Давайте теперь определим эти функции, — то есть, напишем их тела. Это можно сделать прямо внутри объявления класса (и дальше мы будем для краткости писать их именно так). Но, вообще говоря, определить функцию из класса можно и отдельно. Пишем после объявления класса:</p>
<pre>
Time::Time(int h, int m, int s) {
  if (s &lt; 0 || s > 59) {
    // обрабатываем ошибочные секунды
  }
  if (m &lt; 0 || m > 59) {
    // обрабатываем ошибочные минуты
  }
  if (h &lt; 0 || h > 23) {
    // обрабатываем ошибочные часы
  }
  hours = h;
  minutes = m;
  seconds = s;
}

int Time::GetHours() const {
  return hours;
}

int Time::GetMinutes() const {
  return minutes;
}

int Time::GetSeconds() const {
  return seconds;
}
</pre>
  <p>Обратите внимание, что при внешнем определении функции из класса мы предваряем её имя префиксом с именем класса и двумя двоеточиями. Это напоминает пространства имён (вспомните, что мы везде пишем std:: перед именами из стандартной библиотеки).</p>
  <p>Каждая такая функция из класса неявно применяется к текущему объекту. Например, вызов t.GetHours() в этом коде будет применён к объекту t:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  Time t(13, 30, 0);  // 13:30:00
  std::cout &lt;&lt; t.GetHours() &lt;&lt; "\n";  // 13
}
</pre>
  <p>Тела функций из класса написаны так, как будто поля этого неявно переданного объекта попали в текущую область видимости. Сам же этот объект доступен в теле функции через указатель this. Можно было бы написать</p>
<pre>
int Time::GetHours() const {
  return this->hours;  // то же самое, что (*this).hours
}
</pre>
  <p>Но так обычно не пишут. То, что this — это указатель, а не более удобная ссылка, — историческое недоразумение.</p>
  <p>Обратите внимание, что теперь из кода любой другой функции, которая не является функцией из класса, нельзя обратиться к полям и изменить их:</p>
<pre>
int main() {
  Time t(13, 30, 0);
  t.hours = 42;  // ошибка компиляции: приватное поле недоступно!
}
</pre>
  <p>Следует отличать функции из класса от обычных функций. Например, вот это — самая обычная функция, которая просто принимает аргумент типа Time:</p>
<pre>
bool IsAfternoonTime(const Time& time) {
  return time.GetHours() >= 12;
}

#include &lt;iostream&gt;

int main() {
  Time t(13, 30, 0);
  if (IsAfternoonTime(t)) {  // вызываем обычную функцию
    std::cout &lt;&lt; t.GetHours() - 12 &lt;&lt; "PM\n";
    // вызываем функцию из класса
  }
}
</pre>
  <p>Обратите внимание, что у внешней функции IsAfternoonTime никакой пометы const указывать не нужно: сведения о константности уже заложены в описание типа параметра time.</p>

  <h4>Конструктор и обработка ошибок</h4>

  <p>Вернёмся к нашему конструктору. Мы пока не написали в нём код обработки ошибочных аргументов. Было бы слишком плохо просто выйти из конструктора в случае ошибки:</p>
<pre>
Time::Time(int h, int m, int s) {
  if (s &lt; 0 || s > 59) {
    return;
  }
  // ...
}
</pre>
  <p>В таком случае как ни в чём не бывало был бы создан объект, причём его поля никак не были бы проинициализированы. Поскольку у полей примитивный тип int, то в них, как и в непроинициализированных локальных переменных, содержался бы «мусор»:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  Time t(42, -5, 61);

  // Неопределённое поведение: может быть напечатано всё, что угодно:
  std::cout &lt;&lt; t.GetHours() &lt;&lt; "\n";
}
</pre>
  <p>Программисту надо решить, как должен вести себя конструктор в этой ситуации. Есть два варианта:</p>
  <ol>
    <li>
      <p>Сгенерировать исключение — специальное сообщение об ошибке.</p>
      <p>Работа конструктора в этом случае прерывается. Объект не считается созданным. Такое исключение должно быть перехвачено специальным обработчиком try/catch. Подробнее об исключениях мы будем говорить в отдельном параграфе, а пока просто научимся их генерировать:</p>
<pre>
#include &lt;stdexcept&gt;

Time::Time(int h, int m, int s) {
  if (s &lt; 0 || s > 59 || m &lt; 0 || m > 59 || h &lt; 0 || h > 23) {
    throw std::out_of_range("Wrong time!");
  }
  // ...
}
</pre>
    </li>
    <li>
      <p>Всё же создать объект, выполнив инициализацию его полей какими-то значениями.</p>
      <p>Давайте сейчас поступим именно таким способом. Приведём часы, минуты и секунды к привычной шкале, перекидывая лишнее в другие разряды.</p>
<pre>
Time::Time(int h, int m, int s) {
  m += s / 60;
  s %= 60;
  // Если s было отрицательным, то остаток тоже будет отрицательным
  if (s &lt; 0) {
    // Уменьшим в этом случае минуты и сделаем секунды положительными
    m -= 1;
    s += 60;
  }

  h += m / 60;
  m %= 60;
  if (m &lt; 0) {
    h -= 1;
    m += 60;
  }

  h %= 24;
  if (h &lt; 0) {
    h += 24;
  }

  hours = h;
  minutes = m;
  seconds = s;
}
</pre>
    <p>Теперь все создаваемые объекты класса Time будут поддерживать инвариант «время задано корректно в пределах от 00:00:00 до 23:59:59»:</p>
<pre>
int main() {
  Time t1(10, 18, -5);  // 10:17:55
  Time t2(25, 10, 42);  // 01:10:42
  Time t3(23, 59, 61);  // 00:00:01
}
</pre>
    </li>
  </ol>

  <h4>Перегрузка конструкторов</h4>

  <p>Заметим, что нельзя создать объект, не указав параметры конструктора или указав их неправильно:</p>
<pre>
int main() {
  Time t;
  // ошибка компиляции: у класса Time
  // нет конструктора без аргументов!

  Time t2(3600);  // ошибка компиляции: у класса Time
  // нет конструктора от одного аргумента!
}
</pre>
  <p>Однако в классе может быть несколько конструкторов. Добавим перегруженные версии для конструктора без аргументов (он будет инициализировать время нулями) и для конструктора, получающего число секунд с начала дня. Удобно будет указать нулевые значения наших полей в качестве значений по умолчанию.</p>
<pre>
class Time {
private:
  int hours = 0;
  int minutes = 0;
  int seconds = 0;

public:
  Time() = default;

  Time(int h, int m, int s);  // этот конструктор уже был написан раньше

  Time(int s): Time(0, 0, s) {
  }
};
</pre>
  <p>Здесь мы объявили конструктор Time() с пометой default. Это значит, что компилятор сгенерирует его по умолчанию (в данном случае с пустым телом). Такая пометка встретится нам дальше при изучении других специальных функций класса. Конечно, мы могли бы просто написать тут пустое тело, но default здесь выразительнее.</p>
  <p>Конструктор Time(int s) объявлен делегирующим: он ссылается на другой конструктор.</p>
  <p>Подробнее про конструкторы мы поговорим в параграфе о жизненном цикле объектов.</p>

  <h4>Константные и неконстантные функции из класса</h4>

  <p>Сейчас мы можем проинициализировать объекты класса Time только в момент создания и далее никак не можем их изменить. Они пока ведут себя как константы. Давайте теперь добавим в класс функции для изменения состояния объекта. Напишем функцию AddSeconds, которая добавляет ко времени заданное количество секунд. Для краткости определим её тело прямо внутри объявления класса, а тела конструктора и Get-функций не будем повторять:</p>
<pre>
class Time {
private:
  int hours, minutes, seconds;

public:
  Time(int h, int m, int s);

  int GetHours() const;
  int GetMinutes() const;
  int GetSeconds() const;

  void AddSeconds(int s) {
    seconds += s;
    // дальше следует выполнить такие же
    // преобразования, как в конструкторе
  }
};
</pre>
  <p>Функцию AddSeconds мы не объявили константной, так как она изменяет поля объекта. Однако вызвать такую функцию у константного объекта, конечно, не получится:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  Time t(10, 8, 0);  // 10:08:00
  t.AddSeconds(40);  // 10:08:40

  // Константная ссылка: через псевдоним cref объект нельзя изменять
  const Time& cref = t;

  // Константную функцию из класса вызвать можно
  std::cout &lt;&lt; cref.GetHours() &lt;&lt; "\n";  // OK

  // Неконстантную функцию из класса нельзя вызвать у константной сущности
  cref.AddSeconds(20);  // ошибка компиляции
}
</pre>
  <p>Её потребуется вызывать только в конструкторе и в функции AddSeconds, а внешним пользователям класса она не нужна. Фактически, эта функция будет поддерживать инвариант класса.</p>
<pre>
class Time {
private:
  int hours, minutes, seconds;

  void Normalize() {
    minutes += seconds / 60;
    seconds %= 60;
    if (seconds &lt; 0) {
      minutes -= 1;
      seconds += 60;
    }

    hours += minutes / 60;
    minutes %= 60;
    if (minutes &lt; 0) {
      hours -= 1;
      minutes += 60;
    }

    hours %= 24;
    if (hours &lt; 0) {
      hours += 24;
    }
  }

public:
  Time(int h, int m, int s) {
    hours = h;
    minutes = m;
    seconds = s;
    Normalize();
  }

  void AddSeconds(int s) {
    seconds += s;
    Normalize();
  }

  int GetHours() const;
  int GetMinutes() const;
  int GetSeconds() const;
};
</pre>
  <p>Кстати, более правильный синтаксис для нашего конструктора такой:</p>
<pre>
class Time {
  // ...

public:
  Time(int h, int m, int s):
    hours(h),  // явно указываем, как инициализировать поля
    minutes(m),
    seconds(s)

    Normalize();
};
</pre>
  <p>Мы подробнее поговорим об этом в параграфе «Жизненный цикл объекта».</p>

  <h4>Перегрузка операторов</h4>

  <p>Вместо вызова t.AddSeconds(40) было бы заманчиво написать просто t += 40. Для этого нужно перегрузить соответствующие арифметические операторы для нашего класса. А для этого достаточно переименовать нашу функцию AddSeconds в operator +=.</p>
  <p>Согласно канонам, такой оператор обычно возвращает ссылку на текущий объект *this. В выражении t += 40 это возвращаемое значение игнорируется, однако оно позволяет писать странные цепочки вида (t += 40) += 20. Не будем отступать от традиции:</p>
<pre>
class Time {
  // пропустим объявления полей и функций

public:
  Time& operator += (int s) {
    seconds += s;
    Normalize();
    return *this;
  }
};
</pre>
  <p>Аналогично, объявим operator + для сложения объекта Time и целого числа секунд. В отличие от оператора += он будет создавать новый объект Time, а не модифицировать текущий.</p>
<pre>
class Time {
  // ...

public:
  Time operator + (int s) const {
    return Time(hours, minutes, seconds + s);
  }
};
</pre>
  <p>Проверяем:</p>
<pre>
int main() {
  Time t(13, 30, 0);
  t += 40;
  // теперь в t записано время 13:30:40

  Time t2 = t + 20;
  // объект t не изменился, а в t2 записано 13:31:00
}
</pre>
  <p>Вообще-то этот оператор + мы могли бы объявить и как внешнюю функцию. Если интерфейс класса это позволяет сделать, то такой способ более предпочтителен:</p>
<pre>
Time operator + (const Time& t, int s) {
  // обратите внимание: тут не может быть
  // модификатора const, это внешняя функция
  return Time(t.GetHours(), t.GetMinutes(), t.GetSeconds() + s);
}
</pre>
  <p>Более того, можно воспользоваться готовым оператором +=:</p>
<pre>
// Принимаем t по значению, чтобы эту копию можно было изменить
Time operator + (Time t, int s) {
  t += s;
  return t;
}
</pre>
  <p>Было бы большой ошибкой возвращать из operator + значение по ссылке, как в operator +=. Действительно, в операторе + возвращается по значению новый объект, который был сконструирован локально. Ссылка на него сразу бы стала висячей.</p>
  <p>Перегрузим теперь оператор вычитания. Он позволит вычитать одно время из другого и получать число секунд между этими временными метками. Но сначала добавим в класс полезную функцию TotalSeconds, которая вернёт число секунд с начала суток:</p>
<pre>
class Time {
  // ...

public:
  int TotalSeconds() const {
    return hours * 60 * 60 + minutes * 60 + seconds;
  }
};
</pre>
  <p>Теперь можно определить operator - просто как внешнюю функцию:</p>
<pre>
int operator - (const Time& t1, const Time& t2) {
  return t1.TotalSeconds() - t2.TotalSeconds();
}
</pre>
  <p>Перегружать можно большинство операторов. Часто используется перегрузка оператора (), чтобы объект мог имитировать вызов функции. Особенно важно правильно перегружать оператор присваивания = там, где это нужно (мы встретимся с этим в параграфe «Жизненный цикл объекта»).</p>
  <p>Примерами перегрузок операторов у классов стандартной библиотеки являются оператор обращения по индексу в массиве [] у контейнеров std::vector и std::map, или оператор &lt;&lt; для вывода в поток. Встречаются и экзотические случаи вроде перегрузки оператора / для формирования пути в файловой системе или конструирования дат. Однако в общем случае, если речь не идёт о математическом классе, контейнере или потоковом вводе-выводе, увлекаться перегрузкой операторов не стоит.</p>

  <h4>Перегрузка операторов ввода-вывода</h4>

  <p>Операторы &lt;&lt; и >> на самом деле применяются к целым числам и выполняют побитовые сдвиги. Как мы знаем, в стандартной библиотеке они перегружены для форматированного потокового ввода и вывода. Покажем, как сделать это для своего класса.</p>
<pre>
#include &lt;iostream&gt;

std::ostream& operator &lt;&lt; (std::ostream& out, const Time& t) {
  out &lt;&lt; t.GetHours() &lt;&lt; ":" &lt;&lt; t.GetMinutes() &lt;&lt; ":" &lt;&lt; t.GetSeconds();
  return out;
}

std::istream& operator >> (std::istream& in, Time& t) {
  int h, m, s;
  char dummy;
  // Считываем число и любой непробельный символ за ним
  in >> h >> dummy;
  in >> m >> dummy;
  in >> s >> dummy;

  // У нас нет другого способа изменить время через публичный интерфейс
  // кроме присваивания нового значения
  t = Time(h, m, s);
  return in;
}
</pre>
  <p>Мы перегрузили два оператора &lt;&lt; и >>. Первым аргументом они получают по ссылке входной или выходной поток. Второй аргумент — переменная нашего класса. Для оператора &lt;&lt; она передаётся по константной ссылке, а для >> — просто по ссылке, так как будет изменяться. Оба оператора возвращают ссылку на поток, чтобы можно было создавать цепочки вида std::cout &lt;&lt; x &lt;&lt; y &lt;&lt; z.</p>
  <p>Обратите внимание, что оба перегруженных оператора работают с абстрактными потоками in и out, а не с конкретными std::cin или std::cout. Это позволяет их применять к потокам, связанным с файлами или строками.</p>
  <p>Теперь можно читать и печатать время:</p>
<pre>
int main() {
  Time t;
  // Считываем время в формате hh:mm:ss,
  // где на самом деле вместо двоеточия
  // может быть любой разделитель
  std::cin >> t;

  t += 40;
  std::cout &lt;&lt; t &lt;&lt; "\n";
  // печатаем время в формате hh:mm:ss
}
</pre>

  <h4>Меняем реализацию, сохраняем интерфейс</h4>

  <p>Интерфейсом мы называем объявления из открытой части класса и объявления внешних функций, которые связаны с классом. Это то, что доступно пользователю нашего класса. Напомним, как выглядит интерфейс нашего класса Time:</p>
<pre>
class Time {
private:
// детали реализации

public:
Time(int h, int m, int s);

int GetHours() const;
int GetMinutes() const;
int GetSeconds() const;

int TotalSeconds() const;

Time& operator += (int s);
};

Time operator + (const Time& t, int s);

int operator - (const Time& t1, const Time& t2);
</pre>
  <p>Предположим, что мы включили этот класс в библиотеку, а разные пользователи её используют в своих программах. В какой-то момент мы можем захотеть улучшить библиотеку и сделать новую версию класса. При этом программы пользователей не должны от этого сломаться: наши изменения должны оказаться обратно совместимыми. Разделение на интерфейс и на детали реализации как раз позволяет менять эти детали, сохраняя интерфейс неизменным.</p>
  <p>Переделаем класс Time, чтобы он хранил не три переменных типа int (часы, минуты и секунды), а одну переменную с числом секунд, прошедших с начала суток. Реализация большинства функций от этого упростится, хотя функции вида GetHours станут чуть сложнее.</p>
<pre>
class Time {
private:
int totalSeconds;

void Normalize() {  // смотрите, как упростилась эта функция!
  const int secondsInDay = 24 * 60 * 60;

  totalSeconds %= secondsInDay;
  if (totalSeconds &lt; 0) {
    totalSeconds += secondsInDay;
  }
}

public:
Time(int h, int m, int s) {
  totalSeconds = h * 60 * 60 + m * 60 + s;
  Normalize();
}

int GetHours() const {
  return totalSeconds / (60 * 60);
}

int GetMinutes() const {
  return (totalSeconds / 60) % 60;
}

int GetSeconds() const {
  return totalSeconds % 60;
}

int TotalSeconds() const {
  return totalSeconds;
}

Time& operator += (int s) {
  totalSeconds += s;
  Normalize();
  return *this;
}
};
</pre>
  <p>Заметьте, что реализация внешних функций operator + и operator - никак не изменится, потому что они написаны в терминах публичного интерфейса класса.</p>
</article>



<!-- 4.2 Шаблонные классы -->
<article class="article">
  <div class="anchor" id="p4.2"></div>
  <h3>4.2 Шаблонные классы</h3>

  <p>Классы, как и функции, могут быть параметризованы типами или константами. Такие классы называются шаблонными. Примерами шаблонов классов являются все контейнеры стандартной библиотеки. В этом параграфе мы напишем шаблонный класс «Матрица». Мы также рассмотрим на его примере не связанные с шаблонами вещи: перегрузку по константности и итерацию в цикле range-based for.</p>
  <p>Матрица — это таблица чисел, для которой определены математические операции сложения, вычитания и (при подходящих размерах) — умножения. Элементы матрицы могут иметь разную природу: например, это могут быть целые, рациональные, комплексные числа или даже многочлены. Напишем класс-контейнер для хранения матрицы и для выполнения операций над ней.</p>

  <h4>Выбор шаблонных параметров</h4>

  <p>Наш класс должен поддерживать работу с разными типами элементов. Поэтому вынесем тип элемента в шаблонные параметры:</p>
<pre>
template &lt;typename T&gt;
class Matrix;
</pre>
  <p>Дальше нам надо решить, будут ли размеры матрицы известны во время компиляции. Если да, их тоже разумно сделать шаблонными параметрами, а хранить матрицу можно в двумерном контейнере std::array:</p>
<pre>
#include &lt;array&gt;

template &lt;typename T, int Rows, int Columns&gt;
class Matrix {
private:
  // Массив из Rows строк, каждая из которых
  // — массив из Columns элементов типа T
  std::array&lt;std::array&lt;T, Columns&gt;, Rows&gt; data;
};

int main() {
  Matrix&lt;int, 3, 4&gt; m;  // матрица размера 3 x 4
}
</pre>
  <p>Однако чаще размеры матрицы становятся известными только во время выполнения программы. Тогда шаблонные размеры не подойдут, так как аргументы шаблона должны быть известны в момент компиляции. В этом случае размеры должны содержаться в данных самой матрицы, а не в её типе. Мы напишем именно такую реализацию. Хранить матрицу будем в двумерном векторе, хотя возможны и другие способы. Сами размеры матрицы явно хранить не обязательно: их можно достать из самого вектора. Но следует написать удобные функции GetRows и GetColumns для их получения:</p>
<pre>
#include &lt;vector&gt;

template &lt;typename T&gt;
class Matrix {
private:
  std::vector&lt;std::vector&lt;T&gt; &gt; data;

public:
  size_t GetRows() const {
    return data.size();
  }

  size_t GetColumns() const {
    // У пустого вектора data обращаться
    // к нулевому элементу нельзя
    if (data.empty()) {
      return 0;
    }
    return data[0].size();
  }
};
</pre>
  <p>Мы будем поддерживать в классе инвариант «в строках матрицы одинаковое количество элементов». Поэтому число столбцов можно будет получить через обращение к нулевой строке.</p>

  <h4>Конструкторы</h4>

  <p>Напишем конструктор, соблюдающий этот инвариант.</p>
<pre>
#include &lt;vector&gt;

template &lt;typename T&gt;
class Matrix {
private:
  std::vector&lt;std::vector&lt;T&gt; &gt; data;

  // Вспомогательная функция, чтобы сделать массив прямоугольным
  void MakeRectangle() {
    // Вычисляем максимальную длину строки
    size_t maxSize = 0;
    for (const auto& row : data) {
      if (row.size() > maxSize) {
        maxSize = row.size();
      }
    }

    for (auto& row : data) {
    // итерация без const позволяет изменять row
      row.resize(maxSize);
      // увеличиваем длины строк при необходимости
    }
  }

public:
  // Конструктор
  Matrix(const std::vector&lt;std::vector&lt;T&gt; &gt;& d): data(d) {
    // инициализируем вектор переданным значением
    MakeRectangle();  // соблюдаем инвариант
  }

  // ...
};
</pre>
  <p>Наша матрица теперь может быть сконструирована примерно так:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  Matrix&lt;int&gt; m({
    {1, 2, 3},
    {4, 5, 6},
  });

  std::cout &lt;&lt; m.GetRows() &lt;&lt; "\n";  // 2
  std::cout &lt;&lt; m.GetColumns() &lt;&lt; "\n";  // 3
}
</pre>
  <p>Добавим ещё один конструктор для построения нулевой матрицы заданных размеров. Он нам пригодится в дальнейшем. Будем считать, что нулевое значение элемента матрицы — это значение по умолчанию типа T. Для примитивных числовых типов, таких как int или double, это соблюдается. Для более сложных типов элементов (например, рациональных чисел или многочленов) это будет результат вызова конструктора без аргументов: T(). Вызов этого конструктора в приведённом ниже коде спрятан внутри функции resize у вектора.</p>
<pre>
#include &lt;vector&gt;

template &lt;typename T&gt;
class Matrix {
private:
  std::vector&lt;std::vector&lt;T&gt; &gt; data;

public:
  Matrix(size_t rows, size_t columns) {
    data.resize(rows);
    for (auto& row : data) {
      row.resize(columns);
    }
  }

  // ...
};

int main() {
  Matrix&lt;double&gt; m(3, 4);
  // создаём нулевую матрицу из 3 строк и 4 столбцов
}
</pre>

  <h4>Обращение к элементам и перегрузка по константности</h4>

  <p>Наша матрица пока бесполезна: мы можем её создать, но не можем обратиться к её элементам. Хочется делать это так же, как и с двумерным массивом:</p>
<pre>
int main() {
  Matrix&lt;int&gt; m(3, 4);
  int element = m[0][0];
  m[1][1] = 1;
  m[2][3] = 5;
}
</pre>
  <p>Было бы заманчиво определить в матрице оператор [] для обращения по индексу. Он может получать ровно один аргумент (то, что написано в скобках). Каким должно быть его возвращаемое значение? Очевидно, это должно быть нечто, к чему можно снова применить оператор [] со вторым индексом. На эту роль может подойти внутренний вектор элементов std::vector&lt;T&gt;, который задаёт отдельную строку в матрице. Напишем вот такую версию:</p>
<pre>
#include &lt;vector&gt;

template &lt;typename T&gt;
class Matrix {
private:
  std::vector&lt;std::vector&lt;T&gt; &gt; data;

public:
  const std::vector&lt;T&gt;& operator [] (size_t i) const {
    return data[i];
  }
};
</pre>
  <p>Мы написали константную версию этого оператора. Она возвращает вектор по константной ссылке. Эта версия вполне годится для чтения элемента матрицы, но пока не пригодна для его изменения:</p>
<pre>
int main() {
  Matrix&lt;int&gt; m(3, 4);
  int element = m[0][0];  // OK
  m[1][1] = 1;
  // не скомпилируется: у константного
  // вектора m[1] нельзя изменить элемент
}
</pre>
  <p>Давайте разберёмся, как соотносятся друг с другом два слова const в объявлении этого оператора. Попробуем рассмотреть другие реализации, где одно из этих слов убрано.</p>
  <ol>
    <li>
      <p>Уберём первый const:</p>
<pre>
std::vector&lt;T&gt;& operator [] (size_t i) const {
  return data[i];  // ошибка компиляции!
}
</pre>
      <p>Мы получим ошибку компиляции в теле оператора. В самом деле, константная функция видит поле data у текущего объекта как константное. Значит, и data[i] будет константой. А к константе нельзя привязать обычную, неконстантную ссылку.</p>
    </li>
    <li>
      <p>Уберём второй const:</p>
<pre>
const std::vector&lt;T&gt;& operator [] (size_t i) {
  return data[i];
}
</pre>
      <p>Такое тело оператора скомпилируется, но по сравнению с исходной версией этот оператор будет бесполезен. Его нельзя будет применить к константной матрице, так как нет синтаксических гарантий, что он ничего не изменяет. А к неконстантной матрице его применить можно, но результат всё равно будет константным. Поэтому поменять значение в матрице всё равно не получится:</p>
<pre>
int main() {
  Matrix&lt;int&gt; m(3, 4);
  int element = m[0][0];  // OK

  const Matrix&lt;int&gt;& cm = m;
  int element2 = cm[0][0];  // не скомпилируется

  m[1][1] = 1;  // не скомпилируется
}
</pre>
    </li>
    <li>
      <p>Уберём оба const:</p>
<pre>
std::vector&lt;T&gt;& operator [] (size_t i) {
  return data[i];
}
</pre>
      <p>Такая версия позволит изменять элемент у неконстантных матриц. Однако к константным матрицам применить её для чтения всё равно не получится. Впрочем, C++ позволяет перегружать функции из класса по константности. Другими словами, в классе можно написать две версии, отличающиеся наличием const в конце объявления:</p>
<pre>
const std::vector&lt;T&gt;& operator [] (size_t i) const {
  return data[i];
}

std::vector&lt;T&gt;& operator [] (size_t i) {
  // перегрузка по константности
  return data[i];
}
</pre>
      <p>Теперь первая версия будет применяться к константным матрицам, а вторая — к неконстантным.</p>
    </li>
  </ol>

  <p>Перегрузку функций из класса по константности можно понимать чуть иначе.</p>
  <p>Предположим, что указатель на текущий объект this передаётся в наш оператор явно (кстати, такая возможность появится в C++23). Тогда константность функции означала бы просто константость этого указателя. Наши функции выглядели бы так:</p>
<pre>
const std::vector&lt;T&gt;& operator [] (const Matrix&lt;T&gt;* const this, size_t i) {  // константная версия
  return data[i];
}

std::vector&lt;T&gt;& operator [] (Matrix&lt;T&gt;* const this, size_t i) {  // неконстантная версия
  return data[i];
}
</pre>
  <p>Теперь видно, что у функций формально различаются типы первого аргумента, а значит к ним применимы стандартные правила перегрузки.</p>
  <p>Однако нас ожидает подвох. Неконстантная версия оператора [] может привести к нарушению инварианта класса:</p>
<pre>
int main() {
  Matrix&lt;int&gt; m(3, 4);  // матрица 3 x 4
  m[0].resize(10);  // синтаксически допустимо!
  // Теперь в матрице есть строка
  // из 10 элементов и ещё две строки
  // из четырёх элементов
}
</pre>
  <p>Есть два способа, чтобы избежать такой ситуации.</p>
  <ol>
    <li>Можно сделать специальный класс, представляющий строку матрицы. У этого класса не будет опасных функций, таких как resize у вектора. Из неконстантной версии оператора [] вместо std::vector&lt;T&gt;& можно возвращать объект этого класса.</li>
    <li>Можно сделать обращение к элементу не через оператор [], а иначе. Например, можно перегрузить «оператор вызова функции» (). Этот оператор в отличие от [] может принимать несколько аргументов.</li>
  </ol>
<pre>
#include &lt;vector&gt;

template &lt;typename T&gt;
class Matrix {
private:
  std::vector&lt;std::vector&lt;T&gt; &gt; data;

public:
  T& operator () (size_t i, size_t j) {
    return data[i][j];
  }

  // ...
};

int main() {
  Matrix&lt;int&gt; m(3, 4);
  m(1, 1) = 1;
}
</pre>
  <p>Для чтения элементов константных матриц можно оставить как константную версию оператора [], так и добавить перегруженную по константности версию оператора ():</p>
<pre>
const T& operator () (size_t i, size_t j) const {
  return data[i][j];
}
</pre>

  <h4>Итерация по матрице</h4>

  <p>Чтобы можно было писать цикл range-based for по строкам матрицы, нужно добавить к классу функции begin и end, возвращающие итераторы. В нашем случае это могут быть просто итераторы вектора data. Можно представить себе более сложный случай, где требуется обходить матрицу не построчно, а поэлементно. Для этого можно было бы написать свои итераторы. Впрочем, это выходит за рамки этого параграфа.</p>

  <p>Сделаем функции begin и end константными, чтобы не столкнуться с проблемой из предыдущего пункта (фактически, пожертвуем возможностью изменять строки матрицы через range-based for).</p>

  <p>Некоторая сложность тут возникает с типом возвращаемого значения функций begin и end. Это должен быть такой итератор вектора std::vector&lt;std::vector&lt;T&gt;&gt;, который не позволяет изменять элементы. Такой итератор возвращают константные функции data.cbegin() и data.cend(). Тип этого итератора — std::vector&lt;std::vector&lt;T&gt;&gt;::const_iterator. Так как это имя зависит от неизвестного заранее шаблонного параметра T, то, вообще говоря, компилятору нужно подсказать с помощью ключевого слова typename, что это действительно имя типа:</p>
  <code>typename std::vector&lt;std::vector&lt;T&gt;&gt;::const_iterator</code>

  <p>Впрочем, в C++20 это требование смягчили: в типе возвращаемого значения функции слово typename можно не писать.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

template &lt;typename T&gt;
class Matrix {
private:
  std::vector&lt;std::vector&lt;T&gt;&gt; data;

public:
  // Определим для краткости псевдоним для типа
  using const_iterator = typename std::vector&lt;std::vector&lt;T&gt;&gt;::const_iterator;

  // Используем этот псевдоним в объявлении функций
  const_iterator begin() const {
    return data.cbegin();
  }

  const_iterator end() const {
    return data.cend();
  }
};

int main() {
  Matrix m(3, 4);
  std::cin >> m;

  for (const auto& row : m) {  // работает!
    // обрабатываем строку row
  }
}
</pre>

  <p>Заметим, что этот тип можно вывести проще с помощью конструкции decltype, которая определяет на этапе компиляции тип выражения:</p>
<pre>
using const_iterator = decltype(data.cbegin());  // определим псевдоним для типа

const_iterator begin() const {
  return data.cbegin();
}

const_iterator end() const {
  return data.cend();
}
</pre>

  <h4>Потоковый ввод и вывод</h4>

  <p>Перегрузим для удобства операторы ввода и вывода. Напомним, что они являются внешними функциями. Так как Matrix — шаблонный класс, эти функции тоже должны быть шаблонными:</p>
<pre>
#include &lt;iostream&gt;

template &lt;typename T&gt;
std::ostream& operator &lt;&lt; (std::ostream& out, const Matrix&lt;T&gt;& matrix) {
  const size_t rows = matrix.GetRows();
  const size_t columns = matrix.GetColumns();
  for (size_t i = 0; i != rows; ++i) {
    for (size_t j = 0; j != columns; ++j) {
      if (j > 0) {
        out &lt;&lt; "\t";
      }
      out &lt;&lt; matrix[i][j];
    }
    out &lt;&lt; "\n";
  }
  return out;
}

template &lt;typename T&gt;
std::istream& operator >> (std::istream& in, Matrix&lt;T&gt;& matrix) {
  const size_t rows = matrix.GetRows();
  const size_t columns = matrix.GetColumns();
  for (size_t i = 0; i != rows; ++i) {
    for (size_t j = 0; j != columns; ++j) {
      in >> matrix(i, j);
    }
  }
  return in;
}
</pre>

  <p>В операторе >> мы считаем, что размеры матрицы уже заданы в самой матрице:</p>
<pre>
int main() {
  Matrix&lt;double&gt; m(3, 4);  // создаём нулевую матрицу из 3 строк и 4 столбцов
  std::cin >> m; // заполняем построчно её 12 элементов из потока ввода
}
</pre>

  <h4>Арифметические операции</h4>

  <p>Напишем для примера перегрузку операторов + и +=. Здесь важно проверить, что складываются матрицы одинакового размера. Так как размер не является шаблонным параметром, мы не можем проверить это на этапе компиляции. Если размеры не совпадают, необходимо сгенерировать исключение. Про обработку исключений мы будем говорить в параграфе «Обработка исключений», а пока просто сгенерируем его оператором throw.</p>
<pre>
#include &lt;stdexcept&gt;
#include &lt;vector&gt;

template &lt;typename T&gt;
class Matrix {
private:
  std::vector&lt;std::vector&lt;T&gt;&gt; data;

public:
  // ...

  Matrix&lt;T&gt;& operator += (const Matrix&lt;T&gt;& other) {
    const size_t rows = GetRows();
    const size_t columns = GetColumns();
    if (rows != other.GetRows() || columns != other.GetColumns()) {
      throw std::invalid_argument("Matrices have different size!");
    }
    for (size_t i = 0; i != rows; ++i) {
      for (size_t j = 0; j != columns; ++j) {
        data[i][j] += other.data[i][j];
      }
    }
    return *this;
  }
};

template &lt;typename T&gt;
Matrix&lt;T&gt; operator + (const Matrix&lt;T&gt;& m1, const Matrix&lt;T&gt;& m2) {
  auto tmp = m1;
  tmp += m2;
  return tmp;
}
</pre>

  <p>Мы реализовали оператор += как функцию из класса, а оператор + — как внешнюю функцию. Мы могли бы в операторе += воспользоваться уже написанным оператором () для доступа к элементам матрицы, но в этом нет необходимости, так как встроенная функция имеет доступ к приватным полям. Обратите внимание, что в операторе += мы обращаемся к приватному полю data у другого объекта (other) того же типа Matrix&lt;T&gt;. Это вполне допустимо.</p>

  <p>Наш оператор + вызывает оператор +=, и это позволяет избежать дублирования кода. В реализации оператора умножения для матриц удобнее будет сделать наоборот, так как проще выписать формулу для элементов произведения матриц, чем формулу для изменения элементов текущей матрицы после умножения на другую.</p>

  <p>Подчеркнём ещё раз, что оператор += возвращает ссылку на текущий объект, а оператор + возвращает по значению новую матрицу.</p>

  <h4>Сравнение матриц</h4>

  <p>Напишем операторы == и != для сравнения двух матриц. Вообще говоря, в таких матрицах элементы могут быть разных типов (например, int и long). Важно лишь, чтобы сами такие элементы можно было сравнивать. Сделаем поэтому для примера шаблонные параметры матриц разными. Чисто для иллюстрации напишем оператор == как функцию из класса, а оператор != — как внешнюю функцию.</p>
<pre>
#include &lt;vector&gt;

template &lt;typename T&gt;
class Matrix {
private:
  std::vector&lt;std::vector&lt;T&gt;&gt; data;

public:
  // Шаблонный оператор внутри шаблонного класса
  // Параметр T2 никак не связан с параметром T
  template &lt;typename T2&gt;
  bool operator == (const Matrix&lt;T2&gt;& other) const {
    const size_t rows = GetRows();
    const size_t columns = GetColumns();
    if (rows != other.GetRows() || columns != other.GetColumns()) {
      return false;
    }
    for (size_t i = 0; i != rows; ++i) {
      for (size_t j = 0; j != columns; ++j) {
        if (!((*this)(i, j) == other(i, j))) {
          return false;
        }
      }
    }
    return true;
  }

  // ...
};

template &lt;typename T1, typename T2&gt;
bool operator != (const Matrix&lt;T1&gt;& m1, const Matrix&lt;T2&gt;& m2) {
  return !(m1 == m2);
}
</pre>

  <p>Если бы не требовалось сравнивать матрицы разных типов, код оператора == мог быть предельно простым:</p>
<pre>
bool operator == (const Matrix&lt;T&gt;& other) const {
  // векторы умеют сравниваться на равенство
  return data == other.data;
}
</pre>

  <p>Однако мы решили сделать сам этот оператор шаблонным. Поэтому матрицы *this и other теперь имеют, вообще говоря, разный тип. В первом случае это Matrix&lt;T&gt;, а во втором — Matrix&lt;T2&gt;. Поэтому, во-первых, код оператора == больше не имеет доступа к приватному полю data у объекта other, а во-вторых, векторы разных типов сравниваться друг с другом не умеют. Нам остаётся только вручную сравнить элементы матрицы.</p>
  <p>Обратите внимание на сравнение внутри вложенного цикла:</p>
<pre>
1if (!((*this)(i, j) == other(i, j))) {
2    return false;
3}
</pre>

  <p>Тут мы написали (*this)(i, j), чтобы показать, как вызвать оператор () у текущего объекта. И ещё мы намеренно используем отрицание равенства вместо !=: так как мы сравниваем матрицы с помощью ==, то предполагается, что именно такой оператор будет применяться и к самим элементам. Вообще говоря, если T и T2 — сложные типы, то перегруженного оператора != у них может вообще не быть.</p>
  <p>Сравнение матриц с помощью операторов &lt; и > не имеет смысла, поэтому мы не будем их перегружать.</p>
</article>


<!-- 4.3 Жизненный цикл объекта -->
<article class="article">
  <div class="anchor" id="p4.3"></div>
  <h3>4.3 Жизненный цикл объекта</h3>

  <p>В этом параграфе мы узнаем подробнее про конструкторы, деструктор и оператор присваивания, проследим эволюцию объекта от создания до уничтожения, поговорим про временные объекты, а также рассмотрим два разных способа создать объект: на стеке или в динамической памяти. Это потребуется нам в параграфе «Идиома RAII и умные указатели» для понимания того, как объекты класса могут владеть ресурсами.</p>
  <p>Для знакомства с жизненным циклом объекта мы напишем особый класс, который в своих специальных функциях выводит на экран соответствующие сообщения.</p>

  <h4>Класс для логгирования сообщений</h4>

  <p>Раньше мы определяли у классов только конструкторы. Они принимали параметры для инициализации объекта. На самом деле в классе можно определить ещё несколько специальных функций:</p>
  <ul>
    <li>конструктор копирования: он вызывается при создании копии другого объекта;</li>
    <li>оператор присваивания: вызывается при присваивании нового значения уже существующему объекту;</li>
    <li>деструктор: вызывается при уничтожении объекта.</li>
  </ul>

  <p>Раньше в наших классах эти функции неявно дописывал за нас компилятор. Их реализация была тривиальной: конструктор просто копировал поля из объекта-образца, оператор присваивания присваивал их значения полям текущего объекта, а деструктор ничего не делал.</p>
  <p>Напишем класс Logger, в котором мы нарочно переопределим эти специальные функции и будем выводить в них сообщения об их вызове. Дальше мы создадим объекты этого класса и проследим по логу, в каком порядке эти функции вызываются. Начнём с конструктора и деструктора:</p>
<pre>
#include &lt;iostream&gt;

class Logger {
public:
  Logger() {  // конструктор без аргументов
    std::cout &lt;&lt; "Logger()\n";
  }

  ~Logger() {  // деструктор
    std::cout &lt;&lt; "~Logger()\n";
  }
};
</pre>

  <p>Имя деструктора состоит из тильды и имени класса. Как мы узнаем позже, деструкторы необходимы для освобождения ресурсов, захваченных классом. Но сейчас наш деструктор, как и конструктор, просто печатает сообщение о вызове.</p>

  <h4>Автоматические объекты</h4>

  <p>Напишем теперь простую тестовую программу, которая создаёт переменную типа Logger и больше ничего не делает.</p>
<pre>
#include &lt;iostream&gt;

int main() {
  Logger x;
  std::cout &lt;&lt; "Hello!\n";
}
</pre>

  <p>Эта программа напечатает такой текст:</p>
<pre>
Logger()
Hello!
~Logger()
</pre>

  <p>Первую строчку печатает конструктор при создании объекта x. А последнюю строчку печатает деструктор, когда выполнение программы доходит до конца блока. В нашем примере таким блоком служит тело функции. Мы видим, что для обычных переменных компилятор автоматически вызывает деструкторы, когда эти переменные выходят из своей области видимости. Поэтому иногда такие переменные называют автоматическими. Позже мы познакомимся с другими способами создать объект.</p>
  <p>Добавим к нашей программе ещё один объект:</p>
<pre>
int main() {
  Logger x1;
  Logger x2;
}
</pre>

  <p>Программа напечатает такой вывод:</p>
<pre>
Logger()
Logger()
~Logger()
~Logger()
</pre>

  <p>У каждого из объектов был вызван конструктор, а затем — деструктор. К сожалению, по этому выводу невозможно понять, в каком порядке вызывались деструкторы. Добавим индивидуальности нашим объектам, чтобы отличать их логи: будем хранить в них различные целые числа.</p>
<pre>
#include &lt;iostream&gt;

class Logger {
private:
  int id = 0;

public:
  Logger() {
    std::cout &lt;&lt; "Logger(): " &lt;&lt; id &lt;&lt; "\n";
  }

  Logger(int x) {  // новый конструктор для инициализации объекта целым числом
    id = x;
    std::cout &lt;&lt; "Logger(int): " &lt;&lt; id &lt;&lt; "\n";
  }

  ~Logger() {
    std::cout &lt;&lt; "~Logger(): " &lt;&lt; id &lt;&lt; "\n";
  }
};
</pre>

  <p>Здесь мы нарочно в функции main создали вложенный блок и поместили туда переменную x2. Теперь программа напечатает</p>
<pre>
Logger(int): 1
Logger(int): 2
~Logger(): 2
Logger(int): 3
~Logger(): 3
~Logger(): 1
</pre>

  <p>Мы видим, что автоматические объекты удаляются в порядке, который противоположен порядку создания. Объект, созданный последним, выйдет из области видимости первым. Именно таким образом ведёт себя стек. Поэтому часто про автоматические объекты говорят, что они созданы на стеке. Память для хранения таких объектов выделяется и освобождается очень быстро: для этого достаточно передвинуть «границу», которая отделяет занятую область от незанятой.</p>

  <h4>Объекты в динамической памяти</h4>

  <p>Модель стека не всегда подходит для создания объектов. Например, функция push_back для добавления нового элемента в std::list не может создать новый узел на стеке: он бы автоматически разрушился деструктором при выходе из функции.</p>

  <p>В C++ можно управлять жизнью объекта вручную. Ручные объекты будут расположены уже не на стеке, а в динамической памяти. Программист сам должен следить за временем жизни таких объектов и удалять их, когда они не нужны. Создаются такие объекты конструкцией new, которая выбирает свободный блок памяти, создаёт там объект и возвращает указатель на эту память. Такие объекты необходимо обязательно удалять конструкцией delete, когда они станут не нужны.</p>
<pre>
int main() {
  Logger* ptr1 = new Logger(1);
  Logger* ptr2 = new Logger(2);

  delete ptr1;  // удаляем сначала объект *ptr1
  delete ptr2;  // потом удаляем *ptr2
}
</pre>

  <p>В этой программе мы смогли поменять порядок удаления объектов по сравнению со стеком: *ptr1, который был создан раньше *ptr2, также удаляется раньше. Вывод такой программы:</p>
<pre>
Logger(int): 1
Logger(int): 2
~Logger(): 1
~Logger(): 2
</pre>

  <p>Объекты в динамической памяти не обязательно расположены подряд — они могут появляться и уничтожаться в произвольном порядке.</p>
  <p>Сразу заметим, что непосредственные конструкции new и delete довольно опасны. Очень легко допустить ситуацию, в которой delete или будет забыт, или не будет вызван. Это в свою очередь может привести к утечке памяти и, возможно, утечке других ресурсов, которые могли быть захвачены объектом. Подробнее об этом мы поговорим в параграфе «Идиома RAII и умные указатели». Там же мы рассмотрим более безопасные способы работы с динамическими объектами.</p>
  <p>Конструкции new и delete следует рассматривать как транзакции. Так, new сначала выделяет блок динамической памяти подходящего размера, а потом конструирует в этой памяти элемент. Наоборот, delete сначала вызывает деструктор объекта, а потом возвращает динамическую память системе.</p>
  <p>Контейнеры стандартной библиотеки (кроме std::array) также размещают свои элементы в динамической памяти. Например, мы могли бы получить тот же эффект, воспользовавшись контейнером std::list. Удаление элемента из такого контейнера приводит к вызову деструктора элемента.</p>
<pre>
#include &lt;list&gt;

int main() {
  std::list&lt;Logger&gt; loggers(2);  // создаём список из двух элементов
  loggers.pop_front();  // удаляем первый элемент
  loggers.pop_back();  // удаляем второй элемент
}   // тут вызывается деструктор самого списка loggers
</pre>

  <h4>Копирование и присваивание</h4>

  <p>Запустим такую программу:</p>
<pre>
int main() {
  Logger x1(1);
  Logger x2 = x1;  // создаём копию
}
</pre>

  <p>Мы увидим, что как будто бы вызывается один конструктор и два деструктора:</p>
<pre>
Logger(int): 1
~Logger(): 1
~Logger(): 1
</pre>

  <p>На самом деле каждому вызову деструктора должен соответствовать вызов конструктора. В этом примере для объекта x2 вызывается конструктор копирования. Мы не переопределили его в классе Logger, и компилятор любезно предоставил нам его реализацию по умолчанию.</p>
  <p>Похожая странность будет и в таком примере:</p>
<pre>
int main() {
  Logger x1(1);
  Logger x2(2);
  x2 = x1;  // присваиваем значение уже созданному объекту
}
</pre>

  <p>Из лога может показаться, что объект x2 вообще не удаляется, а объект x1 удаляется дважды:</p>
<pre>
Logger(int): 1
Logger(int): 2
~Logger(): 1
~Logger(): 1
</pre>

  <p>Здесь компилятор нам предоставил по умолчанию оператор присваивания, который просто поменял значение поля id.</p>
  <p>Вот как примерно выглядят версии конструктора копирования и оператора присваивания, которые генерирует компилятор:</p>
<pre>
class Logger {
private:
  int id = 0;

public:
  // ...

  // Конструктор копирования
  Logger(const Logger& other) {
    id = other.id;  // инициализируем поле id значением из объекта-образца
  }

  // Оператор присваивания
  Logger& operator = (const Logger& other) {
    id = other.id;  // пользуемся тем же оператором = для поля id
    return *this;
  }
};
</pre>

  <p>Дефолтный конструктор копирования просто вызывает аналогичные конструкторы копирования для всех полей класса. Аналогично, дефолтный оператор присваивания вызывает операторы присваивания для полей. В конструкторе копирования нельзя принимать параметр const Logger& other по значению как Logger other: в этом случае параметр должен был бы копироваться, и этот конструктор стал бы рекурсивно вызывать сам себя.</p>
  <p>Оператор присваивания по оформлению похож на оператор +=, который мы писали раньше. Предполагается, что он возвращает ссылку на текущий объект *this. Это позволяет писать каскадные присваивания a = b = c: они превращаются компилятором в a = (b = c).</p>
  <p>Важно понимать разницу между конструктором копирования и оператором присваивания. Конструктор копирования создаёт новый объект, а оператор присваивания модифицирует уже существующий.</p>
  <p>Как мы знаем, каждый объект занимает определённую память, в которой расположены его поля. Если у класса есть нетривиальные конструктор или оператор присваивания, то объекты такого класса нельзя копировать или изменять, просто меняя байты в этой памяти, например, функцией std::memcpy. Необходим полноценный вызов этих специальных функций.</p>
  <p>Добавим логгирование в конструктор копирования и оператор присваивания. Однако нам по-прежнему хочется различать номера исходного объекта и его копии. Здесь бы нам помог глобальный счётчик объектов. Каждому новому объекту — неважно, копия это или нет, — мы бы присвоили уникальный номер. Такой счётчик можно было бы хранить в глобальной переменной. Но лучше всего спрятать его внутрь класса и сделать статическим полем, чтобы не засорять глобальное пространство имён.</p>

  <h4>Статические поля и функции</h4>

  <p>Ключевое слово static в C++ используется в нескольких разных смыслах.</p>
  <p>В объявлении поля в классе оно обозначает, что значение этого поля одинаково для всех объектов класса. Фактически, статическое поле является глобальной переменной, которую просто поместили в класс как в пространство имён. Ниже мы пользуемся словом static в сочетании с inline — этот синтаксис позволяет инициализировать такие поля прямо в классе:</p>
<pre>
#include &lt;iostream&gt;

class C {
public:
  int x = 0;  // обычное поле
  inline static int sx = 0;  // статическое поле, проинициализированное прямо в классе
  static const int scx = 100;  // статическая константа
};

int main() {
  // Обращаемся со статическим полем просто как с глобальной переменной с особым именем:
  std::cout &lt;&lt; C::sx &lt;&lt; " " &lt;&lt; C::scx &lt;&lt; "\n";  // 0 100

  C::sx = 1;
  std::cout &lt;&lt; C::sx &lt;&lt; " " &lt;&lt; C::scx &lt;&lt; "\n";  // 1 100

  C c1, c2;  // создадим два объекта типа C
  // Обычное поле value привязано к конкретному объекту класса:
  c1.x = 42;
  c2.x = 17;
  c2.sx = 13;  // к статическому полю можно обратиться как к обычному, но оно поменяется глобально

  std::cout &lt;&lt; c1.x &lt;&lt; " " &lt;&lt; c1.sx &lt;&lt; " " &lt;&lt; c1.scx &lt;&lt; "\n";  // 42 13 100
  std::cout &lt;&lt; c2.x &lt;&lt; " " &lt;&lt; c2.sx &lt;&lt; " " &lt;&lt; c2.scx &lt;&lt; "\n";  // 17 13 100
}
</pre>

  <p>Примером статической константы в стандартной библиотеке является std::string::npos. Напомним, что это значение возвращает функция find у строки, если подстрока не найдена.</p>

  <p>Статические функции имеют похожую семантику.</p>

  <p>Статическая функция — это просто обычная функция, которую поместили в класс как в пространство имён по семантическим соображениям. В отличие от функции из класса она не принимает неявным образом текущий объект, но может обращаться к статическим полям.</p>
<pre>
#include &lt;iostream&gt;

class C {
private:
  int x = 0;
  inline static int sx = 0;

public:
  // обычная функция из класса
  void f(int y) {
    x = y;  // есть текущий объект и доступ к его полям
    sx = y;
  }

  // статическая функция:
  static void sf(int y) {
    // нет текущего объекта, и поэтому нет доступа к полю x
    // но есть доступ к статическому полю
    sx = y;
  }
};

int main() {
  C obj;
  obj.f(1);  // вызываем обычную функцию, в неё неявно передаётся объект obj

  C::sf(2);  // вызываем статическую функцию через имя класса
  obj.sf(3);  // вызываем статическую функцию через объект, но сам объект obj в неё не передаётся
}
</pre>

  <h4>Класс Logger с глобальным счётчиком</h4>

  <p>Воспользуемся статической переменной, чтобы подсчитывать количество когда-либо созданных объектов класса. Изменять этот счётчик объектов будем в конструкторе объектов.</p>
<pre>
#include &lt;iostream&gt;

class Logger {
private:
  inline static int counter = 0;

  const int id;  // константа должна быть проинициализирована в конструкторе

public:
  Logger(): id(++counter) {  // инициализируем id текущего объекта
    std::cout &lt;&lt; "Logger(): " &lt;&lt; id &lt;&lt; "\n";
  }

  Logger(const Logger& other): id(++counter) {
    std::cout &lt;&lt; "Logger(const Logger&): " &lt;&lt; id &lt;&lt; " " &lt;&lt; other.id &lt;&lt; "\n";
  }

  Logger& operator = (const Logger& other) {
    // Тут никакие счётчики не меняются, ведь объект уже создан
    std::cout &lt;&lt; "Logger& operator = (const Logger&) " &lt;&lt; id &lt;&lt; " " &lt;&lt; other.id &lt;&lt; "\n";
    return *this;
  }

  ~Logger() {
    std::cout &lt;&lt; "~Logger() " &lt;&lt; id &lt;&lt; "\n";
  }
};
</pre>

  <p>В конструкторах мы не можем написать инициализацию id вот так прямо в теле:</p>
<pre>
Logger() {
  ++counter;
  id = counter;
  // ...
}
</pre>

  <p>Дело в том, что id мы теперь сделали константным полем. Единственная возможность его проинициализировать — явно указать его значение с помощью вот такого синтаксиса перед телом конструктора:</p>
<pre>
Logger(): id(++counter) {
  // ...
}
</pre>

  <p>Обратите внимание на префиксный оператор ++ перед counter. Он сначала увеличивает значение счётчика counter, а затем уже обновлённое значение используется для инициализации поля id. Поэтому все наши объекты будут нумероваться с единицы.</p>

  <p>Рассмотрим теперь такую программу:</p>
<pre>
int main() {
  Logger x1;
  Logger x2 = x1;  // это не присваивание, а инициализация нового объекта через конструктор копирования
  Logger x3;
  x3 = x1;  // а вот это уже оператор присваивания
}
</pre>

  <p>На экране мы увидим такой лог:</p>
<pre>
Logger(): 1  // создали объект x1
Logger(const Logger&): 2 1  // создали объект x2 по образцу x1
Logger() 3  // создали объект x3
Logger& operator = (const Logger&) 3 1  // вызвали оператор присваиваниия x3 = x1
~Logger() 3
~Logger() 2
~Logger() 1
</pre>

  <h4>Инициализация подполей</h4>

  <p>Поместим наш класс Logger внутрь другого класса, также логгирующего свои вызовы:</p>
<pre>
class OuterLogger {
private:
  // Делаем два поля типа Logger
  Logger innerLogger1;
  Logger innerLogger2;

  inline static int counter = 0;
  const int id;

public:
  OuterLogger(): id(++counter) {
    std::cout &lt;&lt; "OuterLogger(): " &lt;&lt; id &lt;&lt; "\n";
  }

  OuterLogger(const OuterLogger& other):
    innerLogger1(other.innerLogger1),  // инициализируем поля
    innerLogger2(other.innerLogger2),  // в порядке их объявления
    id(++counter)
    {
      std::cout &lt;&lt; "OuterLogger(const OuterLogger&): " &lt;&lt; id &lt;&lt; " " &lt;&lt; other.id &lt;&lt; "\n";
    }

    OuterLogger& operator = (const OuterLogger& other) {
    innerLogger1 = other.innerLogger1;  // вызываем оператор присваивания для полей
    innerLogger2 = other.innerLogger2;
    std::cout &lt;&lt; "OuterLogger& operator = (const OuterLogger&) " &lt;&lt; id &lt;&lt; " " &lt;&lt; other.id &lt;&lt; "\n";
    return *this;
  }

  ~OuterLogger() {
    std::cout &lt;&lt; "~OuterLogger() " &lt;&lt; id &lt;&lt; "\n";
  }
};

int main() {
  OuterLogger outerLogger;
}
</pre>

  <p>Заметьте, что у классов Logger и OuterLogger имеются свои независимые счётчики объектов.</p>
  <p>Мы получим следующий лог:</p>
<pre>
Logger(): 1
Logger(): 2
OuterLogger(): 1
~OuterLogger(): 1
~Logger(): 2
~Logger(): 1
</pre>

  <p>Мы видим, что перед входом в тело конструктора инициализируются поля создаваемого объекта, если они, конечно, не имеют примитивного типа вроде int. Мы можем указать, с какими аргументами их инициализировать: это сделано в конструкторе копирования класса OuterLogger. Если инициализация поля пропущена, то для него будет вызван конструктор без аргументов. Только после этого начинает выполняться тело конструктора. Поэтому мы видим лог в таком порядке:</p>
<pre>
Logger(): 1  // конструирование поля innerLogger1
Logger(): 2  // конструирование поля innerLogger2
OuterLogger(): 1  // тело конструктора класса OuterLogger
</pre>

  <p>В деструкторе всё происходит наоборот. Сначала выполняется его тело, а затем автоматически вызываются деструкторы для полей, причём в обратном порядке.</p>

  <h4>Временные объекты</h4>

  <p>Рассмотрим такой код:</p>
<pre>
#include &lt;iostream&gt;

void f(const Logger& x) {
  std::cout &lt;&lt; "void f(const Logger&)\n";
}

int main() {
  f(Logger());
  std::cout &lt;&lt; "Hello!\n";
}
</pre>

  <p>Здесь мы передаём в функцию f временный объект Logger(). У него нет имени. Он существует лишь пока вычисляется выражение f(Logger()). Поэтому сообщение о вызове его деструктора мы увидим до строки Hello!:</p>
<pre>
Logger(): 1
void f(const Logger&)
~Logger(): 1
Hello!
</pre>

  <p>В C++ имеется возможность различать в функциях временные и обычные объекты. Напишем перегруженную версию функции f, принимающую на вход так называемую rvalue-ссылку:</p>
<pre>
#include &lt;iostream&gt;

void f(const Logger& x) {  // версия для обычных аргументов
  std::cout &lt;&lt; "void f(const Logger&)\n";
}

void f(Logger&& x) {  // версия для временных аргументов типа Logger
  std::cout &lt;&lt; "void f(Logger&&)\n";
}

int main() {
  f(Logger());  // вызывается перегруженная версия для временных аргументов
  std::cout &lt;&lt; "\n";

  Logger x;
  f(x);  // вызывается обычная версия
  std::cout &lt;&lt; "\n";
}
</pre>

  <p>Вывод будет таким:</p>
<pre>
Logger(): 1
void f(Logger&&)
~Logger(): 1

Logger(): 2
void f(const Logger&)

~Logger(): 2
</pre>

  <p>Термин «временный объект», который мы используем, не совсем корректен. Правильнее было бы говорить об объектах категории prvalue или xvalue, но мы не будем сейчас переусложнять наш рассказ. Добавим только, что обычный объект можно принудительно рассмотреть как временный, применив к нему функцию std::move из заголовочного файла utility. Это может потребоваться для вызова правильной перегруженной версии какой-либо функции.</p>
  <p>Перегрузка функций по rvalue-ссылкам особенно полезна в контейнерах и в классах, владеющих ресурсами. Она позволяет отобрать владение ресурсами у временного объекта и избежать дорогих операций копирования и инициализации. Мы увидим это в параграфе «Идиома RAII и умные указатели».</p>
  <p>Давайте добавим в наш класс Logger конструктор перемещения и оператор присваивания, которые будут принимать временный объект.</p>
<pre>
class Logger {
  // ...

public:
  // ...

  // Конструктор перемещения:
  Logger(Logger&& other): id(++counter) {
    std::cout &lt;&lt; "Logger(Logger&&): " &lt;&lt; id &lt;&lt; " " &lt;&lt; other.id &lt;&lt; "\n";
  }

  Logger& operator = (Logger&& other) {
    std::cout &lt;&lt; "Logger& operator = (Logger&&) " &lt;&lt; id &lt;&lt; " " &lt;&lt; other.id &lt;&lt; "\n";
    return *this;
  }
};
</pre>

  <p>Запустим такой код:</p>
<pre>
#include &lt;utility&gt;

int main() {
  Logger x1;
  Logger x2 = x1;  // вызывается обычный конструктор копирования
  Logger x3 = Logger();  // сработает copy elision: временный объект даже не будет создаваться
  Logger x4 = std::move(x1);  // вызывается конструктор перемещения
}
</pre>

  <p>Мы увидим на экране</p>
<pre>
Logger(): 1
Logger(const Logger&): 2 1
Logger(): 3
Logger(Logger&&): 4 1
~Logger(): 4
~Logger(): 3
~Logger(): 2
~Logger(): 1
</pre>

  <p>Пояснить здесь нужно инициализацию объекта x3. Начиная с C++17 компилятор обязан упрощать такое выражение до простого Logger x3. Это упрощение называется copy elision.</p>
  <p>Аналогично, протестируем оператор присваивания:</p>
<pre>
#include &lt;utility&gt;

int main() {
  Logger x1;
  Logger x2;

  x2 = x1;  // обычный оператор присваивания
  x2 = Logger();  // присваиваем временный объект с номером 3, который тут же умирает
  x2 = std::move(x1);  // рассматриваем x1 как временный объект (но он при этом продолжает жить)
}
</pre>

  <p>Вывод:</p>
<pre>
Logger(): 1
Logger(): 2
Logger& operator = (const Logger&): 2 1
Logger(): 3
Logger& operator = (Logger&&): 2 3
~Logger(): 3
Logger& operator = (Logger&&): 2 1
~Logger(): 2
~Logger(): 1
</pre>

  <h4>Объекты в контейнерах</h4>

  <p>Попробуем сложить элементы нашего типа Logger в различные контейнеры. Начнем с std::list:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;list&gt;

int main() {
  std::list&lt;Logger&gt; container;
  container.push_back(Logger());
  std::cout &lt;&lt; "\n";

  Logger x;
  container.push_back(x);
  std::cout &lt;&lt; "\n";
}
</pre>

  <p>Вывод на экран зависит от конкретной реализации контейнера std::list в стандартной библиотеке. Будет примерно следующее:</p>
<pre>
Logger(): 1  // создаём временный объект Logger(), который передаётся в push_back
Logger(Logger&&): 2 1  // в контейнере создаётся новый объект через конструктор перемещения
~Logger(): 1  // временный объект умирает

Logger(): 3  // создаётся объект x
Logger(const Logger&): 4 3  // объект x копируется в контейнер

~Logger(): 3  // умирает объект x
~Logger(): 2  // умирает сам containter: сначала умирает его первый элемент
~Logger() 4  // умирает второй элемент контейнера
</pre>

  <p>В нашем контейнере всего два элемента, но в итоге было создано четыре объекта! Заметим, что вместо push_back можно было бы воспользоваться функцией emplace_back. Она принимает на вход не сам объект, копию которого надо поместить в контейнер, а аргументы конструктора объекта, и создаёт новый объект сама:</p>
<pre>
int main() {
  std::list&lt;Logger&gt; container;
  container.emplace_back();  // аргументов нет: создаём в контейнере новый объект конструктором без аргументов
  container.emplace_back();
}
</pre>

  <p>Вывод на экран теперь такой:</p>
<pre>
Logger(): 1
Logger(): 2
~Logger(): 1
~Logger(): 2
</pre>

  <p>Теперь положим элементы в вектор:</p>
<pre>
#include <vector>

int main() {
  std::vector&lt;Logger&gt; container;
  container.emplace_back();
  std::cout &lt;&lt; "\n";
  container.emplace_back();
  std::cout &lt;&lt; "\n";
}
</pre>

  <p>Вывод, опять же, зависит от реализации std::vector и будет примерно таким:</p>
<pre>
Logger(): 1  // создаём первый объект в векторе

Logger(): 2  // создаём второй объект в векторе
Logger(const Logger&): 3 1  // но что это?
~Logger(): 1

~Logger(): 3
~Logger(): 2
</pre>

  <p>Откуда здесь конструктор копирования, создающий третий объект? Это произошла реаллокация. После первого emplace_back в векторе была зарезервирована память только под один элемент. Когда выполнился второй emplace_back, произошло следующее:</p>
  <ul>
    <li>выделился новый фрагмент памяти, достаточный для хранения двух элементов;</li>
    <li>в нём был создан новый (второй) элемент на нужном месте: это строка Logger(): 2 в логе;</li>
    <li>в новый фрагмент памяти был скопирован первый элемент из старой памяти: Logger(const Logger&): 3 1;</li>
    <li>элемент в старой части памяти был уничтожен: ~Logger(): 1.</li>
  </ul>
  <p>Порядок удаления элементов в деструкторе вектора стандартом не определён и может различаться в разных реализациях стандартной библиотеки. В нашем примере элементы удалялись в прямом порядке.</p>
</article>


<!-- 4.4 Наследование и полиморфизм -->
<article class="article">
  <div class="anchor" id="p4.4"></div>
  <h3>4.4 Наследование и полиморфизм</h3>

  <p>Наследование — это способ организовывать иерархии классов. При этом класс-наследник приобретает поля и функции базового класса, модифицируя их область видимости.</p>
  <p>Язык C++ — один из немногих языков с множественным наследованием: у класса может быть несколько базовых классов. Множественное наследование считается сложным (и не всегда оправданным). Мы не будем его здесь рассматривать. В этом параграфе мы познакомимся с публичным одиночным наследованием.</p>

  <h4>Наследование</h4>

  <p>Сначала приведём синтаксические детали. Пусть есть некоторый класс A.</p>
<pre>
class A {
private:
  int x;

public:
  void Func1();
  void Func2();
};
</pre>

  <p>В нашем классе A для примера объявлено приватное поле x и публичные функции Func1 и Func2. Пусть их реализация написана где-то отдельно. Публично унаследуем от этого класса новый класс B:</p>
<pre>
class B: public A {
private:
  int y;

public:
  void Func2();
  void Func3();
};
</pre>

  <p>Технически класс B включает в себя подобъект класса A. Класс B приобретает поля и функции базового класса A, возможно, меняя их уровень доступа.</p>
<pre>
int main() {
  B b;
  b.Func1();  // унаследована от A
  b.Func2();  // переопределена в классе B
  b.A::Func2();  // версия Func2 из класса A
  b.Func3();  // определена в классе B
}
</pre>

  <p>Приватное поле x в функциях класса B оказывается недоступным (как и в любом другом месте кода), однако оно хранится внутри объекта типа B и может быть изменено функциями из A:</p>
<pre>
#include <iostream>

int main() {
  std::cout &lt;&lt; sizeof(A) &lt;&lt; "\n";  // 4 байта (x)
  std::cout &lt;&lt; sizeof(B) &lt;&lt; "\n";  // 8 байт (x и у)
}
</pre>

  <p>Самое заманчивое, что тип B может быть приведён к типу A. Поэтому объект класса B может использоваться везде, где ожидается A:</p>
<pre>
void DoSomething(const A&);

int main() {
  B b;
  DoSomething(b);  // ok
}
</pre>

  <p>Отнаследуемся от класса Logger из предыдущего параграфа, чтобы посмотреть, как рождается и умирает объект базового класса.</p>
<pre>
#include &lt;iostream&gt;

class InheritedLogger: public Logger {
public:
  InheritedLogger() {
    std::cout &lt;&lt; "InheritedLogger()\n";
  }

  ~InheritedLogger() {
    std::cout &lt;&lt; "~InheritedLogger()\n";
  }
};

int main() {
  InheritedLogger x;
}
</pre>

  <p>Вывод программы будет таким:</p>
<pre>
Logger(): 1
InheritedLogger()
~InheritedLogger()
~Logger(): 1
</pre>

  <p>Здесь перед входом в тело конструктора инициализируется неявный объект базового класса, а затем уже выполняется код конструктора класса-наследника. В деструкторе всё происходит наоборот. Это очень похоже на поведение класса OuterLogger, в котором объект типа Logger хранился как поле. В самом деле, наследование чисто технически можно свести к композиции.</p>

  <h4>Наследование и композиция</h4>

  <p>Сравним наследование с композицией — использованием класса в качестве типа поля другого класса. Напишем класс C, который будет вместо наследования от A использовать композицию.</p>
<pre>
class C {
private:
  A a;  // используем явное поле типа A
  int y;

public:
  void Func1() {  // эмулируем наследование Func1 от A
    return a.Func1();
  }

  void Func2();

  void Func3();

  const A& GetA() const {
    return a;
  }
};
</pre>

  <p>Наш класс хранит фактически те же данные, что и класс B, только поле x теперь спрятано внутрь поля a. Нам пришлось явно написать функцию Func1, которая просто вызывает аналогичную функцию у поля a. К тому же, больше нет возможности использовать класс C вместо класса A. Для этого пришлось написать функцию GetA, которая возвращает константную ссылку на поле a.</p>
<pre>
int main() {
  C c;
  c.Func1();  // вызывает Func1 у поля a
  c.Func2();  // определена в классе C
  c.Func3();  // определена в классе C
  DoSomething(c.GetA());  // нет явного приведения к типу A
}
</pre>

  <p>Мы видим синтаксические различия между публичным наследованием и композицией. Публичное наследование автоматически приносит в интерфейс класса-наследника функции из базового класса и позволяет наследнику притворяться объектом базового типа. Напротив, композиция приносит объект исходного класса как именованное поле, а для предоставления доступа к его функциям требуется писать обёртки.</p>
  <p>Теперь давайте обсудим семантические различия. Считается, что композиция реализует отношение has-a между объектами C и A. Перевести это можно как «A — часть C», или «C реализован с помощью A». Наоборот, публичное наследование обозначает отношение is-a: «B является A», или «B — особый случай A».</p>
  <p>Пусть, например, мы разрабатываем классы для моделирования транспортного средства (Vehicle), автомобиля (Car) и двигателя (Engine). Тогда класс Car следовало бы унаследовать от Vehicle (автомобиль является транспортным средством), а Engine сделать полем внутри Car (двигатель — часть автомобиля).</p>
  <p>Иногда бывает сложно сделать правильный выбор между композицией и наследованием. Тогда помогает так называемый принцип подстановки Барбары Лисков. Надо рассмотреть все возможные сценарии использования базового класса A (например, все функции, использующие A). Принцип требует, чтобы поведение таких функций не изменялось, если вместо объекта базового класса A вдруг будет подставлен объект производного класса B. Если это не так, то наследование — неправильный выбор.</p>
  <p>Пусть, например, мы рассматриваем классы «Квадрат» (Square) и «Прямоугольник» (Rectangle). Кажется, что квадрат — частный случай прямоугольника. Должен ли Square быть наследником Rectangle? Ответ зависит от того, какой интерфейс у этих классов. Если Rectangle позволяет через публичный интерфейс независимо изменять стороны прямоугольника, то наследование использовать нельзя: такая операция над квадратом нарушит его инвариант.</p>
  <p>Важная особенность наследования — возможность заменять поведение функций базового класса в классах-наследниках. Она называется полиморфизмом.</p>

  <h4>Параметрический полиморфизм</h4>

  <p>Обычно про полиморфизм рассказывают на хрестоматийном примере с иерархией животных. Мы не будем отходить от этой традиции. Пусть нам для разработки некоторой игры требуются классы для кошки и собаки. В классах должно храниться имя животного и должна быть функция Voice. Напишем эти классы по отдельности.</p>
<pre>
#include &lt;string&gt;

class Cat {
private:
  std::string name;

public:
  Cat(const std::string& n): name(n) {
  }

  const std::string& GetName() const {
    return name;
  }

  std::string Voice() const {
    return "Meow!";
  }
};

class Dog {
private:
  std::string name;

public:
  Dog(const std::string& n): name(n) {
  }

  const std::string& GetName() const {
    return name;
  }

  std::string Voice() const {
    return "Woof!";
  }
};
</pre>

  <p>Мы возвращаем голос из функции, а не храним его в константном поле. Это более гибкое решение: представьте, например, что голос может зависеть от времени суток.</p>
  <p>Эти два класса похожи друг на друга, но никак не связаны. Использоваться они будут примерно так:</p>
<pre>
#include &lt;iostream&gt;

void Process(const Cat& creature) {
  std::cout &lt;&lt; creature.GetName() &lt;&lt; ": " &lt;&lt; creature.Voice() &lt;&lt; "\n";
}

void Process(const Dog& creature) {
  std::cout &lt;&lt; creature.GetName() &lt;&lt; ": " &lt;&lt; creature.Voice() &lt;&lt; "\n";
}

int main() {
  Cat c("Tom");
  Dog d("Buffa");
  Process(c);  // Tom: Meow!
  Process(d);  // Buffa: Woof!
}
</pre>

  <p>В этом коде сразу заметно дублирование. Уберём его с помощью шаблонов:</p>
<pre>
template &lt;typename Creature&gt;
void Process(const Creature& creature) {
  std::cout &lt;&lt; creature.GetName() &lt;&lt; ": " &lt;&lt; creature.Voice() &lt;&lt; "\n";
}
</pre>

  <p>Код функции main не изменится. В каком-то смысле это уже полиморфизм: у нас есть разные классы с однотипным интерфейсом, а также набор одноименных перегруженных функций для их обработки. Вызов такой функции синтаксически никак не зависит от того, какой тип животного используется, хотя функции на самом деле разные. Выбор нужной функции происходит во время компиляции. Такой подход называется параметрическим полиморфизмом.</p>
  <p>Дублирования в самих классах Cat и Dog можно было бы избежать с помощью дополнительного поля, описывающего тип:</p>
<pre>
#include &lt;string&gt;

enum class AnimalType {
  Cat,
  Dog,
};

class Animal {
private:
  AnimalType type;
  std::string name;

public:
  Animal(AnimalType t, const std::string& n):
    type(t), name(n)
  {
  }

  const std::string& GetName() const {
    return name;
  }

  std::string Voice() const {
    switch (type) {
      case AnimalType::Cat:
        return "Meow!";
      case AnimalType::Dog:
        return "Woof!";
      default:
        return "Unknown creature type";
    }
  }
};

int main() {
  Animal c(AnimalType::Cat, "Tom");
  Animal d(AnimalType::Dog, "Buffa");
  Process(c);  // Tom: Meow!
  Process(d);  // Buffa: Woof!
}
</pre>

  <p>Однако такой подход плохо масштабируется. Представьте, что у нас много типов животных и много функций, подобных Voice. В каждой из таких функций пришлось бы писать код, который рассматривает все варианты типов. Для добавления нового типа животного к такой иерархии потребовалось бы расширить перечисление CreatureType и изменить код всех таких функций. Если бы такой класс Creature поставлялся бы со сторонней библиотекой, в код которой мы не можем вносить изменения, то добавить новый тип в иерархию было бы просто невозможно.</p>

  <h4>Полиморфизм через наследование</h4>

  <p>Организуем наши классы в иерархию наследования с базовым классом Animal. Это позволит избавиться от дублирования поля name и функции GetName в коде, а также позволит по-своему определить функцию Voice.</p>
  <p>Конструктор у каждого класса-наследника всё-таки придётся написать свой. Он будет просто вызывать конструктор базового класса.</p>
<pre>
#include &lt;string&gt;

class Animal {
private:
std::string name;

public:
Animal(const std::string& n): name(n) {
}

const std::string& GetName() const {
  return name;
}

std::string Voice() const {
  return "Generic creature voice";
}
};

class Cat: public Animal {
public:
Cat(const std::string& n): Animal(n) {
}

std::string Voice() const {
  return "Meow!";
}
};

class Dog: public Animal {
public:
Dog(const std::string& n): Animal(n) {
}

std::string Voice() const {
  return "Woof!";
}
};
</pre>

  <p>Со старым кодом функции Process всё работает:</p>
<pre>
#include &lt;iostream&gt;

template &lt;typename Creature&gt;
void Process(const Creature& creature) {
std::cout &lt;&lt; creature.GetName() &lt;&lt; ": " &lt;&lt; creature.Voice() &lt;&lt; "\n";
}

int main() {
Cat c("Tom");
Dog d("Buffa");
Process(c);  // Tom: Meow!
Process(d);  // Buffa: Woof!
}
</pre>

  <p>Как мы помним, классы-наследники могут быть автоматически приведены к типу базового класса. Попробуем убрать шаблон в функции Process, чтобы передавать в неё аргумент базового класса Animal.</p>
<pre>
#include &lt;iostream&gt;

void Process(const Animal& creature) {
std::cout &lt;&lt; creature.GetName() &lt;&lt; ": " &lt;&lt; creature.Voice() &lt;&lt; "\n";
}

int main() {
Cat c("Tom");
Dog d("Buffa");
Process(c);  // Tom: Generic creature voice
Process(d);  // Buffa: Generic creature voice
}
</pre>

  <p>Наша программа компилируется, но животные внезапно теряют свой голос. Вместо переопределённых версий функции Voice вызывается версия Animal::Voice из базового класса. В самом деле, функция Process работает с параметром типа Animal и ничего не знает о том, что у этого класса могут быть наследники со своими версиями функций. Решить эту проблему можно, объявив функцию Voice в базовом классе Animal виртуальной.</p>

  <h4>Виртуальные функции</h4>

  <p>В предыдущем примере выбор функции Voice осуществлялся на этапе компиляции программы. Компилятор выбирал её исходя из формального типа аргумента creature — внутри функции это был const Animal&. Этот стандартный для C++ подход называется ранним связыванием. Имеется в виду, что ещё до запуска программы адрес выбранной функции Animal::Voice в памяти был заранее привязан к этому месту кода.</p>
  <p>Виртуальные функции класса позволяют осуществить позднее связывание. В этом случае выбор подходящей функции будет происходить уже во время выполнения программы.</p>
  <p>Функция должна быть объявлена виртуальной в базовом классе:</p>
<pre>
#include &lt;string&gt;

class Animal {
public:
// ...

virtual std::string Voice() const {
  return "Generic creature voice";
}
};
</pre>

  <p>В классах-наследниках её следует переопределять с дополнительной пометкой override:</p>
<pre>
class Cat: public Animal {
public:
// ...

std::string Voice() const override {
  return "Meow!";
}
};

class Dog: public Animal {
public:
// ...

std::string Voice() const override {
  return "Woof!";
}
};
</pre>

  <p>Слово override писать не обязательно, но желательно. При его наличии компилятор сможет проверить, действительно ли в базовом классе есть виртуальная функция с такой сигнатурой. Это позволит заранее найти вот такие ошибки:</p>
<pre>
class Dog: public Animal {
public:
// ...

std::string Voice() override {  // забыли const!
  return "Woof!";
}
};
</pre>

  <p>Здесь виртуальная функция базового класса имеет другую сигнатуру. Без слова override компилятор бы решил, что мы просто хотим создать новую перегруженную функцию в классе-наследнике.</p>

  <p>Теперь в функции Process выбор нужной функции происходит динамически, во время исполнения программы. Он зависит от реального типа аргумента, который был приведён к базовому классу Animal:</p>
<pre>
#include &lt;iostream&gt;

void Process(const Animal& creature) {
std::cout &lt;&lt; creature.GetName() &lt;&lt; ": " &lt;&lt; creature.Voice() &lt;&lt; "\n";
}

int main() {
Cat c("Tom");
Dog d("Buffa");
Process(c);  // Tom: Meow!
Process(d);  // Buffa: Woof!
}
</pre>

  <p>Если в базовом классе объявлена хотя бы одна виртуальная функция, то компилятор добавляет к классу ещё одно неявное поле — указатель на таблицу виртуальных функций. Конструкторы базового класса и классов-наследников меняют этот указатель, чтобы он указывал на таблицу виртуальных функций именно этого класса. Чем-то это напоминает подход с перечислением AnimalType и полем type в базовом классе, но только вместо перечисления здесь указатель. Для выбора нужной функции надо сначала перейти по этому указателю на таблицу, а потом уже вызвать функцию. Это медленнее, чем обычный вызов функции. Виртуальные функции имеют свои накладные расходы, и поэтому функции класса не являются виртуальными по умолчанию.</p>

  <p>Заметим, что мы нигде явно не создаём объекты базового класса Animal. Поэтому функцию Animal::Voice можно объявить чисто виртуальной вот так:</p>
<pre>
class Animal {
public:
// ...

virtual std::string Voice() const = 0;  // чисто виртуальная функция
};
</pre>

  <p>Разработчики C++ очень не хотели вводить для чисто виртуальных функций новое ключевое слово, и поэтому придумали такой странный синтаксис.</p>
  <p>У чисто виртуальной функции даже не обязательно должна быть реализация. Если в классе есть такая функция, то класс считается абстрактным. Создать объект такого класса (например, написать Animal a) не получится, так как класс считается не полностью определенным. Назначение чисто виртуальных функций — потребовать, чтобы классы-наследники переопределили это поведение, иначе они тоже будут считаться абстрактными.</p>
  <p>В примерах ниже мы пока не будем считать функцию Voice чисто виртуальной. Но в окончательной версии класса мы сделаем её такой.</p>

  <h4>Полиморфизм и контейнеры</h4>

  <p>Давайте устроим зоопарк и сложим наших животных в контейнер. У стандартных контейнеров должен быть явно указан тип элемента. Попробуем указать в качестве такого типа базовый класс Animal:</p>
<pre>
#include &lt;vector&gt;

int main() {
std::vector&lt;Animal&gt; zoo;

zoo.push_back(Cat("Tom"));
zoo.push_back(Dog("Buffa"));

// Тут можно было бы написать цикл,
// но мы напишем два вызова для наглядности
Process(zoo[0]);  // Tom: Generic creature voice!
Process(zoo[1]);  // Buffa: Generic creature voice!
}
</pre>

  <p>Внезапно виртуальное поведение сломалось: мы снова видим результат работы базовой функции Animal::Voice. Это произошло потому, что в векторе хранятся копии переданных в push_back объектов, и эти копии имеют тип Animal.То же самое бы случилось, если функция Process принимала бы свой параметр по значению, а не по константной ссылке.</p>
  <p>Чтобы виртуальные функции заработали, в вектор можно положить указатели на Animal:</p>
<pre>
#include &lt;vector&gt;

int main() {
std::vector&lt;Animal*&gt; zoo;

// Создадим пока что объекты на стеке
Cat c("Tom");
Dog d("Buffa");

// Кладём в вектор адреса этих объектов
zoo.push_back(&c);
zoo.push_back(&d);

// Для разыменования нужна звёздочка
Process(*zoo[0]);  // Tom: Meow!
Process(*zoo[1]);  // Buffa: Woof!
}
</pre>

  <p>Такой пример работает, однако он не очень интересен. Мы положили в вектор адреса автоматических объектов на стеке. Эти объекты разрушаются при выходе из блока. Поэтому будет плохо возвращать такой вектор из функции — все указатели в нём станут сразу невалидными.</p>
  <p>Попробуем создать объекты в динамической памяти:</p>
<pre>
#include &lt;vector&gt;

int main() {
std::vector&lt;Animal*&gt; zoo;

zoo.push_back(new Cat("Tom"));
zoo.push_back(new Dog("Buffa"));

Process(*zoo[0]);  // Tom: Meow!
Process(*zoo[1]);  // Buffa: Woof!
}
</pre>

  <p>Мы создали объекты в динамической памяти, но не освободили эту память в конце. Это грубая ошибка. Мы должны были вызвать delete, когда эта память станет ненужной. Ещё важно, чтобы для животных вызывался правильный деструктор — ~Cat для кошки, ~Dog для собаки. Поэтому, если в базовом классе есть виртуальные функции, и с ним предполагается полиморфная работа с созданием объектов в динамической памяти, то деструктор базового класса необходимо объявить виртуальным:</p>
<pre>
class Animal {
public:
// ...

virtual ~Animal() {
}
};

// ...

int main() {
// ...

for (Animal* animal : zoo) {
  delete animal;  // вызов виртуального деструктора и освобождение памяти
}
}
</pre>

  <p>Заметим, что такая работа с динамическими объектами очень опасна. Мы можем по какой-то причине не дойти до цикла с уничтожением объектов. Более правильным было бы использовать вектор умных указателей std::vector&lt;std::unique_ptr&lt;Animal&gt;&gt;. Тогда писать цикл с вызовами delete было бы не нужно. Об этом будет рассказано в параграфе «Идиома RAII и умные указатели».</p>

  <p>Напишем окончательную иерархию классов с учётом всех исправлений.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

class Animal {
private:
std::string name;

public:
Animal(const std::string& n): name(n) {
}

const std::string& GetName() const {
  return name;
}

virtual std::string Voice() const = 0;

virtual ~Animal() {
}
};

class Cat: public Animal {
public:
Cat(const std::string& n): Animal(n) {
}

std::string Voice() const override {
  return "Meow!";
}
};

class Dog: public Animal {
public:
Dog(const std::string& n): Animal(n) {
}

std::string Voice() const override {
  return "Woof!";
}
};

void Process(const Animal& creature) {
std::cout &lt;&lt; creature.GetName() &lt;&lt; ": " &lt;&lt; creature.Voice() &lt;&lt; "\n";
}
</pre>

  <p>Основная программа теперь может выглядеть так</p>
<pre>
#include &lt;memory&gt;
#include &lt;vector&gt;

int main() {
// Подробности в параграфе 3.6
std::vector&lt;std::unique_ptr&lt;Animal>> zoo;

zoo.emplace_back(std::make_unique&lt;Cat&gt;("Tom"));
zoo.emplace_back(std::make_unique&lt;Dog&gt;("Buffa"));

Process(*zoo[0]);  // Tom: Meow!
Process(*zoo[1]);  // Buffa: Woof!
}
</pre>

  <p>Можно ли было сложить животных в контейнер, не используя базовый класс? Да. Для этого подойдут шаблонный класс std::variant и функция std::visit из стандартной библиотеки.</p>

  <p>Класс std::variant позволяет хранить значение одного из указанных типов. При этом он не использует динамическое выделение памяти. От типов не требуется, чтобы они имели общий базовый класс — они могут быть независимыми, как в разделе про статический полиморфизм. Вот как выглядит эта магия:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;variant&gt;
#include &lt;vector&gt;

// Как-то определены, не обязательно наследуются от базового класса
class Cat;
class Dog;

template &lt;typename Creature&gt;
void Process(const Creature& creature) {
std::cout &lt;&lt; creature.GetName() &lt;&lt; ": " &lt;&lt; creature.Voice() &lt;&lt; "\n";
}

int main() {
std::vector&lt;std::variant&lt;Cat, Dog&gt;&gt; zoo;  // либо кошки, либо собаки

zoo.push_back(Cat("Tom"));
zoo.push_back(Dog("Buffa"));

for (const auto& animal : zoo) {
  std::visit(
  [](const auto& creature) {  // шаблонная лямбда-функция
  Process(creature);
  },
  animal
  );
}
}
</pre>

  <p>Это тоже динамический полиморфизм, так как выбор нужной функции происходит во время работы программы. Но он не использует наследование. Недостатком этого подхода является то, что при объявлении вектора надо сразу указать, какие типы могут храниться в std::variant. Полиморфизм, который реализован через наследование, лишён этого недостатка.</p>
</article>


<!-- 4.5 Обработка исключений -->
<article class="article">
  <div class="anchor" id="p4.5"></div>
  <h3>4.5 Обработка исключений</h3>

  <p>В C++ различают ошибки времени компиляции и ошибки времени выполнения. Ошибки первого типа обнаруживает компилятор до запуска программы. К ним относятся, например, синтаксические ошибки в коде. Ошибки второго типа проявляются при запуске программы. Примеры ошибок времени выполнения: ввод некорректных данных, некорректная работа с памятью, недостаток места на диске и т. д. Часто такие ошибки могут привести к неопределённому поведению программы.</p>
  <p>Некоторые ошибки времени выполнения можно обнаружить заранее с помощью проверок в коде. Например, такими могут быть ошибки, нарушающие инвариант класса в конструкторе. Обычно, если ошибка обнаружена, то дальнейшее выполение функции не имеет смысла, и нужно сообщить об ошибке в то место кода, откуда эта функция была вызвана. Для этого предназначен механизм исключений.</p>

  <h4>Коды возврата и исключения</h4>

  <p>Рассмотрим функцию, которая считывает со стандартного потока возраст и возвращает его вызывающей стороне. Добавим в функцию проверку корректности возраста: он должен находиться в диапазоне от 0 до 128 лет. Предположим, что повторный ввод возраста в случае ошибки не предусмотрен.</p>
<pre>
int ReadAge() {
int age;
std::cin >> age;
if (age &lt; 0 || age >= 128) {
  // Что вернуть в этом случае?
}
return age;
}
</pre>

  <p>Что вернуть в случае некорректного возраста? Можно было бы, например, договориться, что в этом случае функция возвращает ноль. Но тогда похожая проверка должна быть и в месте вызова функции:</p>
<pre>
int main() {
if (int age = ReadAge(); age == 0) {
  // Произошла ошибка
} else {
  // Работаем с возрастом age
}
}
</pre>

  <p>Такая проверка неудобна. Более того, нет никакой гарантии, что в вызывающей функции программист вообще её напишет. Фактически мы тут выбрали некоторое значение функции (ноль), обозначающее ошибку. Это пример подхода к обработке ошибок через коды возврата. Другим примером такого подхода является хорошо знакомая нам функция main. Только она должна возвращать ноль при успешном завершении и что-либо ненулевое в случае ошибки.</p>
  <p>Другим способом сообщить об обнаруженной ошибке являются исключения. С каждым сгенерированным исключением связан некоторый объект, который как-то описывает ошибку. Таким объектом может быть что угодно — даже целое число или строка. Но обычно для описания ошибки заводят специальный класс и генерируют объект этого класса:</p>
<pre>
#include &lt;iostream&gt;

struct WrongAgeException {
int age;
};

int ReadAge() {
int age;
std::cin >> age;
if (age &lt; 0 || age >= 128) {
  throw WrongAgeException(age);
}
return age;
}
</pre>

  <p>Здесь в случае ошибки оператор throw генерирует исключение, которое представлено временным объектом типа WrongAgeException. В этом объекте сохранён для контекста текущий неправильный возраст age. Функция досрочно завершает работу: у неё нет возможности обработать эту ошибку, и она должна сообщить о ней наружу. Поток управления возвращается в то место, откуда функция была вызвана. Там исключение может быть перехвачено и обработано.</p>

  <h4>Перехват исключения</h4>

  <p>Мы вызывали нашу функцию ReadAge из функции main. Обработать ошибку в месте вызова можно с помощью блока try/catch:</p>
<pre>
int main() {
try {
  age = ReadAge();  // может сгенерировать исключение
  // Работаем с возрастом age
} catch (const WrongAgeException& ex) {  // ловим объект исключения
std::cerr &lt;&lt; "Age is not correct: " &lt;&lt; ex.age &lt;&lt; "\n";
return 1;  // выходим из функции main с ненулевым кодом возврата
}
// ...
}
</pre>

  <p>Мы знаем заранее, что функция ReadAge может сгенерировать исключение типа WrongAgeException. Поэтому мы оборачиваем вызов этой функции в блок try. Если происходит исключение, для него подбирается подходящий catch-обработчик. Таких обработчиков может быть несколько. Можно смотреть на них как на набор перегруженных функций от одного аргумента — объекта исключения. Выбирается первый подходящий по типу обработчик и выполняется его код. Если же ни один обработчик не подходит по типу, то исключение считается необработанным. В этом случае оно пробрасывается дальше по стеку — туда, откуда была вызвана текущая функция. А если обработчик не найдётся даже в функции main, то программа аварийно завершается.</p>
  <p>Усложним немного наш пример, чтобы из функции ReadAge могли вылетать исключения разных типов. Сейчас мы проверяем только значение возраста, считая, что на вход поступило число. Но предположим, что поток ввода досрочно оборвался, или на входе была строка вместо числа. В таком случае конструкция std::cin >> age никак не изменит переменную age, а лишь возведёт специальный флаг ошибки в объекте std::cin. Наша переменная age останется непроинициализированной: в ней будет лежать неопределённый мусор. Можно было бы явно проверить этот флаг в объекте std::cin, но мы вместо этого включим режим генерации исключений при таких ошибках ввода:</p>
<pre>
int ReadAge() {
std::cin.exceptions(std::istream::failbit);
int age;
std::cin >> age;
if (age &lt; 0 || age >= 128) {
  throw WrongAgeException(age);
}
return age;
}
</pre>

  <p>Теперь ошибка чтения в операторе >> у потока ввода будет приводить к исключению типа std::istream::failure. Функция ReadAge его не обрабатывает. Поэтому такое исключение покинет пределы этой функции. Поймаем его в функции main:</p>
<pre>
int main() {
try {
  age = ReadAge();  // может сгенерировать исключения разных типов
  // Работаем с возрастом age
} catch (const WrongAgeException& ex) {
  std::cerr &lt;&lt; "Age is not correct: " &lt;&lt; ex.age &lt;&lt; "\n";
  return 1;
} catch (const std::istream::failure& ex) {
  std::cerr &lt;&lt; "Failed to read age: " &lt;&lt; ex.what() &lt;&lt; "\n";
  return 1;
} catch (...) {
  std::cerr &lt;&lt; "Some other exception\n";
  return 1;
}
// ...
}
</pre>

  <p>При обработке мы воспользовались функцией ex.what у исключения типа std::istream::failure. Такие функции есть у всех исключений стандартной библиотеки: они возвращают текстовое описание ошибки.</p>
  <p>Обратите внимание на третий catch с многоточием. Такой блок, если он присутствует, будет перехватывать любые исключения, не перехваченные ранее.</p>

  <h4>Исключения стандартной библиотеки</h4>

  <p>Функции и классы стандартной библиотеки в некоторых ситуациях генерируют исключения особых типов. Все такие типы выстроены в иерархию наследования от базового класса std::exception. Иерархия классов позволяет писать обработчик catch сразу на группу ошибок, которые представлены базовым классом: std::logic_error, std::runtime_error и т. д.</p>

  <p>Вот несколько примеров:</p>
  <ol>
    <li>Функция at у контейнеров std::array, std::vector и std::deque генерирует исключение std::out_of_range при некорректном индексе.</li>
    <li>Аналогично, функция at у std::map, std::unordered_map и у соответствующих мультиконтейнеров генерирует исключение std::out_of_range при отсутствующем ключе.</li>
    <li>Обращение к значению у пустого объекта std::optional приводит к исключению std::bad_optional_access.</li>
    <li>Потоки ввода-вывода могут генерировать исключение std::ios_base::failure.</li>
  </ol>

  <h4>Исключения в конструкторах</h4>

  <p>В параграфе «Классы» мы написали класс Time. Этот класс должен был соблюдать инвариант на значение часов, минут и секунд: они должны были быть корректными. Если на вход конструктору класса Time передавались некорректные значения, мы приводили их к корректным, используя деление с остатком.</p>
  <p>Более правильным было бы сгенерировать в конструкторе исключение. Таким образом мы бы явно передали сообщение об ошибке во внешнюю функцию, которая пыталась создать объект.</p>
<pre>
class Time {
private:
int hours, minutes, seconds;

public:
// Заведём класс для исключения и поместим его внутрь класса Time как в пространство имён
class IncorrectTimeException {
};

Time::Time(int h, int m, int s) {
  if (s &lt; 0 || s > 59 || m &lt; 0 || m > 59 || h &lt; 0 || h > 23) {
    throw IncorrectTimeException();
  }
  hours = h;
  minutes = m;
  seconds = s;
}

// ...
};
</pre>
  <p>Генерировать исключения в конструкторах — совершенно нормальная практика. Однако не следует допускать, чтобы исключения покидали пределы деструкторов. Чтобы понять причины, посмотрим подробнее, что происходит при генерации исключения.</p>

  <h4>Свёртка стека</h4>

  <p>Вспомним класс Logger из предыдущего параграфа. Посмотрим, как он ведёт себя при возникновении исключения. Воспользуемся в этом примере стандартным базовым классом std::exception, чтобы не писать свой класс исключения.</p>
<pre>
#include &lt;exception&gt;
#include &lt;iostream&gt;

void f() {
std::cout &lt;&lt; "Welcome to f()!\n";
Logger x;
// ...
throw std::exception();  // в какой-то момент происходит исключение
}

int main() {
try {
  Logger y;
  f();
} catch (const std::exception&) {
  std::cout &lt;&lt; "Something happened...\n";
  return 1;
}
}
</pre>

<p>Мы увидим такой вывод:</p>
<pre>
Logger(): 1
Welcome to f()!
Logger(): 2
~Logger(): 2
~Logger(): 1
Something happened...
</pre>

  <p>Сначала создаётся объект y в блоке try. Затем мы входим в функцию f. В ней создаётся объект x. После этого происходит исключение. Мы должны досрочно покинуть функцию. В этот момент начинается свёртка стека (stack unwinding): вызываются деструкторы для всех созданных объектов в самой функции и в блоке try, как если бы они вышли из своей области видимости. Поэтому перед обработчиком исключения мы видим вызов деструктора объекта x, а затем — объекта y.</p>
  <p>Аналогично, свёртка стека происходит и при генерации исключения в конструкторе. Напишем класс с полем Logger и сгенерируем нарочно исключение в его конструкторе:</p>
<pre>
#include &lt;exception&gt;
#include &lt;iostream&gt;

class C {
private:
Logger x;

public:
C() {
  std::cout &lt;&lt; "C()\n";
  Logger y;
  // ...
  throw std::exception();
}

~C() {
  std::cout &lt;&lt; "~C()\n";
}
};

int main() {
try {
  C c;
} catch (const std::exception&) {
  std::cout &lt;&lt; "Something happened...\n";
}
}
</pre>

  <p>Вывод программы:</p>
<pre>
Logger(): 1  // конструктор поля x
C()
Logger(): 2  // конструктор локальной переменной y
~Logger(): 2  // свёртка стека: деструктор y
~Logger(): 1  // свёртка стека: деструктор поля x
Something happened...
</pre>

  <p>Заметим, что деструктор самого класса C не вызывается, так как объект в конструкторе не был создан.</p>
  <p>Механизм свёртки стека гарантирует, что деструкторы для всех созданных автоматических объектов или полей класса в любом случае будут вызваны. Однако он полагается на важное свойство: деструкторы самих классов не должны генерировать исключений. Если исключение в деструкторе произойдёт в момент свёртки стека при обработке другого исключения, то программа аварийно завершится.</p>

  <h4>Пример с динамической памятью</h4>

  <p>Подчеркнём, что свёртка стека работает только с автоматическими объектами. В этом нет ничего удивительного: ведь за временем жизни объектов, созданных в динамической памяти, программист должен следить самостоятельно. Исключения вносят дополнительные сложности в ручное управление динамическими объектами:</p>
<pre>
void f() {
Logger* ptr = new Logger();  // конструируем объект класса Logger в динамической памяти
// ...
g();  // вызываем какую-то функцию
// ...
delete ptr;  // вызываем деструктор и очищаем динамическую память
}
</pre>

  <p>На первый взгляд кажется, что в этом коде нет ничего опасного: delete вызывается в конце функции. Однако функция g может сгенерировать исключение. Мы не перехватываем его в нашей функции f. Механизм свёртки уберёт со стека лишь сам указатель ptr, который является автоматической переменной примитивного типа. Однако он ничего не сможет сделать с объектом в памяти, на которую ссылается этот указатель. В логе мы увидим только вызов конструктора класса Logger, но не увидим вызова деструктора. Нам придётся обработать исключение вручную:</p>
<pre>
void f() {
Logger* ptr = new Logger();
// ...
try {
  g();
} catch (...) {  // ловим любое исключение
  delete ptr;  // вручную удаляем объект
  throw;  // перекидываем объект исключения дальше
}
// ...
delete ptr;

}
</pre>

  <p>Здесь мы перехватываем любое исключение и частично обрабатываем его, удаляя объект в динамической памяти. Затем мы прокидываем текущий объект исключения дальше с помощью оператора throw без аргументов.</p>
  <p>Согласитесь, этот код очень далёк от совершенства. При непосредственной работе с объектами в динамической памяти нам приходится оборачивать в try/catch любую конструкцию, из которой может вылететь исключение. Понятно, что такой код чреват ошибками. В параграфе «Идиома RAII и умные указатели» мы узнаем, как с точки зрения C++ следует работать с такими ресурсами, как память.</p>

  <h4>Гарантии безопасности исключений</h4>

  <p>Предположим, что мы пишем свой класс-контейнер, похожий на двусвязный список. Наш контейнер позволяет добавлять элементы в хранилище и отдельно хранит количество элементов в некотором поле elementsCount. Один из инвариантов этого класса такой: значение elementsCount равно реальному числу элементов в хранилище.</p>
  <p>Не вдаваясь в детали, давайте посмотрим, как могла бы выглядеть функция добавления элемента.</p>
<pre>
template &lt;typename T&gt;
class List {
private:
struct Node {  // узел двусвязного списка
  T element;
  Node* prev = nullptr;  // предыдущий узел
  Node* next = nullptr;  // следующий узел
};

Node* first = nullptr;  // первый узел списка
Node* last = nullptr;  // последний узел списка
int elementsCount = 0;

public:
// ...

size_t Size() const {
  return elementsCount;
}

void PushBack(const T& elem) {
  ++elementsCount;

  // Конструируем в динамической памяти новой узел списка
  Node* node = new Node(elem, last, nullptr);

  // Связываем новый узел с остальными узлами
  if (last != nullptr) {
    last->next = node;
  } else {
    first = node;
  }
  last = node;
}
};
</pre>

  <p>Не будем здесь рассматривать другие функции класса — конструкторы, деструктор, оператор присваивания... Рассмотрим функцию PushBack. В ней могут произойти такие исключения:</p>
  <ol>
    <li>Выражение new может сгенерировать исключение std::bad_alloc из-за нехватки памяти.</li>
    <li>Конструктор копирования класса T может сгенерировать произвольное исключение. Этот конструктор вызывается при инициализации поля element создаваемого узла в конструкторе класса Node. В этом случае new ведёт себя как транзакция: выделенная перед этим динамическая память корректно вернётся системе.</li>
  </ol>
  <p>Эти исключения не перехватываются в функции PushBack. Их может перехватить код, из которого PushBack вызывался:</p>
<pre>
#include &lt;iostream&gt;

class C;  // какой-то класс

int main() {
List&lt;C&gt; data;
C element;

try {
  data.PushBack(element);
} catch (...) {  // не получилось добавить элемент
  std::cout &lt;&lt; data.Size() &lt;&lt; "\n";  // внезапно 1, а не 0
}

// работаем дальше с data
}
</pre>

  <p>Наша функция PushBack сначала увеличивает счётчик элементов, а затем выполняет опасные операции. Если происходит исключение, то в классе List нарушается инвариант: значение счётчика elementsCount перестаёт соответствовать реальности. Можно сказать, что функция PushBack не даёт гарантий безопасности.</p>
  <p>Всего выделяют четыре уровня гарантий безопасности исключений (exception safety guarantees):</p>
  <ol>
    <li>Гарантия отсутствия сбоев.
      Функции с такими гарантиями вообще не выбрасывают исключений. Примерами могут служить правильно написанные деструктор и конструктор перемещения, а также константные функции вида Size.</li>
    <li>Строгая гарантия безопасности.
      Исключение может возникнуть, но от этого объект нашего класса не поменяет состояние: количество элементов останется прежним, итераторы и ссылки не будут инвалидированы и т. д.</li>
    <li>Базовая гарантия безопасности.
      При исключении состояние объекта может поменяться, но оно останется внутренне согласованным, то есть, инварианты будут соблюдаться.</li>
    <li>Отсутствие гарантий.
      Это довольно опасная категория: при возникновении исключений могут нарушаться инварианты.</li>
  </ol>

  <p>Всегда стоит разрабатывать классы, обеспечивающие хотя бы базовую гарантию безопасности. При этом не всегда возможно эффективно обеспечить строгую гарантию.</p>
  <p>Переместим в нашей функции PushBack изменение счётчика в конец:</p>
<pre>
void PushBack(const T& elem) {
Node* node = new Node(elem, last, nullptr);

if (last != nullptr) {
  last->next = node;
} else {
  first = node;
}
last = node;

++elementsCount;  // выполнится только если раньше не было исключений
}
</pre>

  <p>Теперь такая функция соответствует строгой гарантии безопасности.</p>
  <p>В документации функций из классов стандартной библиотеки обычно указано, какой уровень гарантии они обеспечивают. Рассмотрим, например, гарантии безопасности класса std::vector.</p>
  <ul>
    <li>Деструктор, функции empty, size, capacity, а также clear предоставляют гарантию отсутствия сбоев.</li>
    <li>Функции push_back и resize предоставляют строгую гарантию.</li>
    <li>Функция insert предоставляет лишь базовую гарантию.</li>
  </ul>

  <p>Можно было бы сделать так, чтобы она предоставляла строгую гарантию, но за это пришлось бы заплатить её эффективностью: при вставке в середину вектора пришлось бы делать реаллокацию.</p>
  <p>Функции класса, которые гарантируют отсутствие сбоев, следует помечать ключевым словом noexcept:</p>
<pre>
class C {
public:
void f() noexcept {
  // ...
}
};
</pre>

  <p>С одной стороны, эта подсказка позволяет компилятору генерировать более эффективный код. С другой — эффективно обрабатывать объекты таких классов в стандартных контейнерах. Например, std::vector&lt;C&gt; при реаллокации будет использовать конструктор перемещения класса C, если он помечен как noexcept. В противном случае будет использован конструктор копирования, который может быть менее эффективен, но зато позволит обеспечить строгую гарантию безопасности при реаллокации.</p>
</article>


<!-- 4.6 Идиома RAII и умные указатели -->
<article class="article">
  <div class="anchor" id="p4.6"></div>
  <h3>4.6 Идиома RAII и умные указатели</h3>

  <p>Идиома RAII (Resource Acquisition Is Initialization) переводится как «захват ресурса должен быть инициализацией объекта». Пусть программе требуется какой-то ресурс (память, файл), который надо обязательно «вернуть», когда он будет уже не нужен. Идея состоит в том, что лучше всего запрашивать этот ресурс в конструкторе некоторого объекта, а освобождать — в деструкторе. На этой идее построены стандартные контейнеры и так называемые «умные указатели» — классы unique_ptr и shared_ptr из стандартной библиотеки.</p>
  <p>Название идиомы, как замечает сам Бьярне Страуструп, выбрано неудачно. Лучше отражают её смысл альтернативные названия:</p>
  <ul>
    <li>CADR (Constructor Acquires, Destructor Releases) — в конструкторе захватываем ресурс, в деструкторе — освобождаем;</li>
    <li>SBRM (Scope-Bound Resource Management) — управление ресурсами с привязкой к области видимости.</li>
  </ul>

  <h4>Файл как ресурс</h4>

  <p>Рассмотрим хрестоматийный пример ресурса: файл. Работу программы с файлами обеспечивает операционная система. Файл вначале нужно «открыть» для чтения или записи, а в конце работы — «закрыть».</p>
  <p>Давайте посмотрим, как работали с файлами в языке С, из которого вырос C++. С каждым файлом связывался так называемый файловый дескриптор. Это был просто указатель на объект специальной структуры std::FILE.</p>
  <p>Этот способ возможен и в C++. Мы обсудим его недостатки и напишем позже более удобную замену.</p>
<pre>
#include &lt;cstdio&gt;

int main() {
// Открываем файл input.txt для чтения и получаем его дескриптор
if (std::FILE* f = std::fopen("input.txt", "r"); f != nullptr) {
  // Если дескриптор не является нулевым указателем, то файл успешно окрыт
  char buf[100];  // массив символов размера 100
  std::fscanf(f, "%99s", buf);  // считываем из файла максимум 99 символов текста в буфер
  // ...
  std::fclose(f);  // закрываем файл
} else {
  std::cout &lt;&lt; "File open failure!\n";
}
}
</pre>

  <p>Мы не будем останавливаться на деталях работы функции fscanf. Нас сейчас интересует открытие и закрытие файла, а также поведение программы в случае ошибок.</p>
  <p>В приведённом примере обрабатывается случай, когда файл не получается открыть. Такое может произойти если файла с указанным именем, например, не существует. В строках кода, обозначенных многоточием, тоже возможны аварийные ситуации. Например, в файле могут оказаться некорректные данные. В каждой из таких ситуаций важно не забыть закрыть файл. Код с такими проверками становится слишком громоздким.</p>
  <p>Согласно идиоме RAII, нам следует «обернуть» файловый дескриптор в объект специального класса. Тогда открытие файла соответствовало бы инициализации объекта в его конструкторе, а закрытие файла — уничтожению объекта в деструкторе. В случае ошибки при открытии файла мы бы сгенерировали исключение, и объект нашего класса не был бы создан.</p>
<pre>
#include &lt;cstdio&gt;
#include &lt;exception&gt;
#include &lt;string&gt;

class CannotOpenFileException {
};

class File {
private:
std::FILE* f;  // тот самый файловый дескриптор, который мы оборачиваем

public:
File(const std::string& name) {
  if (f = std::fopen(name.c_str(), "r"); f == nullptr) {
    throw CannotOpenFileException();
  }
}

~File() noexcept {
  std::fclose(f);
}

std::string Read() const {
  char buf[100];
  std::fscanf(f, "%99s", buf);
  return buf;
}
};
</pre>

  <p>Теперь можно работать так:</p>
<pre>
int main() {
try {
  File file("input.txt");
  auto str = file.Read();
  // ...
} catch (const CannotOpenFileException&) {
  std::cout &lt;&lt; "File open failure!\n";
}
}
</pre>

  <p>Что бы ни произошло в строках с многоточием, для объекта file всегда будет вызван деструктор, а значит, файл будет корректно закрыт.</p>

  <h4>Копирование и присваивание</h4>

  <p>Наша обёртка File пока не идеальна: у неё есть проблемы с копированием и присваиванием. Рассмотрим такой пример:</p>
<pre>
int main() {
File f1("a.txt");
File f2 = f1;  // конструктор копирования
File f3("b.txt");
f3 = f1;  // оператор присваивания
}
</pre>

  <p>Все эти три объекта хранят внутри на самом деле один и тот же файловый дескриптор. Когда для них вызовутся деструкторы, то один и тот же файл будет закрыт несколько раз, что ошибочно.</p>
  <p>Один из способов решить эту проблему — просто запретить такое копирование и присваивание. Это можно сделать так:</p>
<pre>
class File {
public:
// Запрещаем компилятору автоматически генерировать
// конструктор копирования и оператор присваивания:
File(const File&) = delete;
File& operator = (const File&) = delete;

// ...
};
</pre>

  <p>Теперь код функции main как в примере выше просто не скомпилируется. Но всё-таки хочется, чтобы вот такой код был допустимым:</p>
<pre>
// Вспомогательная функция
File GetFile() {
File f("a.txt");
// ...
return f;
}

int main() {
// Сейчас не сработает — конструктор копирования запрещён!
File f = GetFile();  // ошибка компиляции!
// ...
}
</pre>

  <p>В отличие от предыдущего примера с копированием именованных объектов, здесь копируется временный объект — результат функции GetFile. Как мы знаем, для таких объектов предусмотрены особые rvalue-ссылки. Можно просто написать конструктор перемещения, который заберет данные из такого объекта:</p>
<pre>
class File {
public:
File(const File&) = delete;
File& operator = (const File&) = delete;

// Конструктор перемещения
File(File&& other) noexcept {  // File&& — ссылка на временный объект
  f = other.f;
  other.f = nullptr;  // забираем владение дескриптором у временного объекта other!
}

// Оператор присваивания с семантикой перемещения
File& operator = (File&& other) noexcept {
  if (f != nullptr && f != other.f) {
    fclose(f);  // закрываем файл у текущего объекта
  }
  f = other.f;  // забираем владение у временного объекта other
  other.f = nullptr;
  return *this;
}

// Добавим проверку в деструктор:
~File() noexcept {
  if (f != nullptr) {
    fclose(f);
  }
}

// ...
};
</pre>

  <p>Теперь копирование и присваивание обычных именованных объектов запрещены, но для временных объектов они возможны. Так как временный объект всё равно скоро будет уничтожен деструктором, можно отобрать у него владение ресурсом и оставить его «сиротой», то есть, сделать указатель f нулевым. У такого объекта уже нельзя вызывать функцию Read, но никто это и не будет делать</p>
  <p>В деструкторе мы добавляем проверку и закрываем файл только если дескриптор f ненулевой. Это обеспечивает корректную работу деструктора для «осиротевших» временных объектов.</p>
  <p>Заметим, что оператор перемещающего присваивания можно было бы реализовать чуть иначе с помощью функции std::swap. Это позволяет избавиться от неуклюжей проверки и от вызова fclose внутри тела оператора:</p>
<pre>
#include &lt;utility&gt;

class File {
public:
File& operator = (File&& other) noexcept {
  std::swap(f, other.f);  // обмениваемся дескрипторами с other
  return *this;
}

// ...
};
</pre>

  <p>Здесь мы просто обмениваемся дескрипторами с временным объектом other. Файловый дескриптор текущего объекта будет закрыт в деструкторе объекта other, который должен быть вызван вскоре после присваивания.</p>
  <p>В отличие от оператора перемещающего присваивания, в конструкторе перемещения закрывать файловый дескриптор у текущего объекта не нужно, так как текущего объекта пока просто не существует.</p>

  <h4>RAII в стандартной библиотеке</h4>

  <p>В стандартной библиотеке уже есть готовая обёртка над файловыми дескрипторами std::fstream, которая позволяет работать с файлами как с потоками ввода-вывода. Она написана в стиле RAII и напоминает наш класс File. Некоторое отличие заключается в том, что конструктор std::fstream не генерирует исключение в случае ошибки.</p>

  <p>Вот как ей можно воспользоваться:</p>
<pre>
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::fstream file("input.txt");

  std::string data;
  file >> data;

  std::cout &lt;&lt; data &lt;&lt; "\n";
}   // файл автоматически закроется при вызове деструктора
</pre>

  <p>Другим примером ресурса является динамическая память. Все контейнеры стандартной библиотеки (кроме, пожалуй, std::array) так или иначе исповедуют идиому RAII: в их конструкторах выделяется память, которой они владеют, а в деструкторах эта память освобождается. Таким образом, эти контейнеры надёжно защищают программиста от ошибок из-за утечек памяти.</p>
  <p>Другим примером использования RAII в стандартной библиотеке является класс std::lock_guard. Он предназначен для синхронизации мьютексов в многопоточном приложении. Многопоточность выходит за рамки этого пособия. Но тем не менее приведём такой пример для иллюстрации.</p>
<pre>
#include &lt;mutex&gt;

std::mutex m;

void f();  // какая-то функция

void Bad() {
  m.lock();  // захватываем мьютекс
  f();  // если произойдёт исключение, то мьютекс никогда не освободится
  m.unlock();  // освобождаем мьютекс
}

void Good() {
  std::lock_guard&lt;std::mutex&gt; lock(m);  // класс-обёртка в стиле RAII
  f();  // если произойдёт исключение, то мьютекс будет освобождён!
}   // вызов m.unlock() не требуется — это сделает деструктор объекта lock
</pre>

  <h4>Владение несколькими ресурсами</h4>

  <p>Решим задачу, которую часто предлагают на собеседованиях. Пусть дан некоторый класс A. Нужно написать конструкторы и деструктор класса C, который владеет переменной типа A и хранит её в динамической памяти.</p>
  <p>Напишем сначала наивный вариант решения.</p>
<pre>
template &lt;typename A&gt;
class C {
private:
  A* x;

public:
  C() {
    x = new A();
  }

  // ...

  ~C() {
    delete x;
  }
};
</pre>

  <p>Тут есть такая же проблема, как и с классом File: конструктор копирования и оператор присваивания по умолчанию просто скопируют указатель на ту же память:</p>
<pre>
int main() {
  C&lt;int&gt; c1;
  C&lt;int&gt; c2(c1);  // указатели c1.x и c2.x равны!
}  // проблема: в деструкторе c1 память будет освобождена повторно!
</pre>

  <p>Допишем конструктор копирования и оператор присваивания. В отличие от класса File мы не будем их запрещать, а сделаем «глубокое» копирование:</p>
<pre>
template &lt;typename A&gt;
class C {
private:
  A* x;

public:
  C() {
    x = new A();
  }

  // Создаём новый объект с помощью конструктора копирования класса A
  C(const C& other) {
    x = new A(*other.x);
  }

  // Вызываем оператор присваивания не для указателей, а для объектов класса A
  C& operator = (const C& other) {
    *x = *other.x;
    return *this;
  }

  ~C() {
    delete x;
  }
};
</pre>

  <p>Наш класс владеет динамической памятью в стиле RAII: в конструкторах память выделяется, в деструкторе — освобождается. Теперь усложним задачу. Пусть даны два класса A и B. В нашем классе D должны быть два указателя: и на объект класса A, и на объект класса B. Наш класс D должен владеть и той, и другой динамической памятью.</p>
<pre>
template &lt;typename A, typename B&gt;
class D {
private:
  A* x;
  B* y;

public:
  D() {
    x = new A();
    y = new B();
  }

  D(const D& other) {
    x = new A(*other.x);
    y = new B(*other.y);
  }

  D& operator = (const D& other) {
    *x = *other.x;
    *y = *other.y;
    return *this;
  }

  ~D() {
    delete x;
    delete y;
  }
};
</pre>

  <p>Казалось бы, здесь нет никакого подвоха. Однако такой класс по сравнению с предыдущей версией является опасным. Дело в том, что в конструкторе при инициализации поля y может произойти ошибка. Во-первых, может просто не хватить динамической памяти. Во-вторых, может произойти исключение в конструкторе класса B. Сама ошибка не является чем-то опасным. Однако давайте посмотрим, что произойдёт при этом с полем x. При исключении будет сворачиваться стек. В частности, будет вызван деструктор для уже проинициализированной переменной x. Но деструктор указателя тривиален. Этот деструктор не сделает ничего. Поэтому объект *x не будет корректно уничтожен и память в x «утечёт». Напомним, что деструктор ~D не будет вызван, так как конструктор завершится с ошибкой.</p>
  <p>Первое приходящее в голову решение проблемы: обернуть инициализацию в конструкторе в try/catch:</p>
<pre>
template &lt;typename A, typename B&gt;
class D {
private:
  A* x;
  B* y;

public:
  D() {
    x = new A();  // тут тоже может произойти ошибка, но она не приведёт к утечкам!
    try {
      y = new B();
    } catch (...) {
      delete x;  // если что-то пошло не так, то освобождаем уже созданный x
      throw;  // и прокидываем исключение дальше
    }
  }

  // Примерно такой же код придётся написать
  // в конструкторе копирования и в операторе присваивания
  // ...

  ~D() {
    delete x;
    delete y;
  }
};
</pre>

  <p>Мы решили проблему, но это выглядит коряво. Если ли лучшее решение? Следуя идиоме RAII нам следовало бы каждую переменную — и x, и y — хранить вместо обычного указателя в какой-нибудь умной «обёртке». В конструкторе такой обёртки выделялась бы память, а в деструкторе она бы освобождалась. В чём-то такая обёртка была бы похожа на класс C с одним указателем. Тогда в самом классе D нам не пришлось бы ни обрабатывать исключения, ни писать деструктор. Более того, не надо было бы вообще определять свои методы: сгодились бы все те, что компилятор предоставляет по умолчанию.</p>
<pre>
template &lt;typename A, typename B&gt;
class D {
private:
  C&lt;A&gt; x;
  C&lt;B&gt; y;
};
</pre>

  <p>Заметьте, никаких конструкторов, операторов присваивания и деструктора в классе D теперь вообще писать не нужно! Что, например, произойдёт, если в конструкторе по умолчанию при инициализации поля y будет выброшено исключение? В этом случае будет сворачиваться стек. Для уже проинициализированного поля x будет вызван деструктор. Но теперь тип поля x — это не «голый» указатель A*, а наша обёртка C&lt;A&gt;. В её деструкторе и будет освобождена память. Утечки не произойдёт.</p>
  <p>Зачем может понадобиться хранить в классе не обычные поля, а указатели?</p>
  <p>Рассмотрим, например, вот такую альтернативу классу D:</p>
<pre>
template &lt;typename A, typename B&gt;
class E {
private:
  A a;
  B b;
};
</pre>

  <p>Здесь поля a и b являются автоматическими. Если такой вариант решения возможен, то он является более предпочтительным. Однако указатели могут понадобиться по следующим причинам:</p>
  <ol>
    <li>Объекты типа A и B могут быть «тяжёлыми», то есть, иметь большой sizeof. Поэтому их может быть выгоднее создавать не на стеке, который ограничен, а в динамической памяти.</li>
    <li>Может потребоваться отложенная инициализация для полей a и b. Класс E требует, чтобы эти поля были проинициализированы сразу в его конструкторе. Но инициализация a или b может быть долгой или дорогой, или у нас пока может не быть для неё достаточного набора данных. Если там будет указатель (изначально — нулевой), то создать объекты типов A и B можно будет и позже. Впрочем, для этого можно использовать и обёртку std::optional.</li>
    <li>Мы пишем класс-контейнер, который хранит свои данные в динамической памяти. Обычно двумя указателями тут не обойтись, но аналогия распространяется и на более сложные случаи. Например, можно реализовать матрицу через низкоуровневое выделение памяти для двумерного массива. А можно вместо этого воспользоваться готовой RAII-обёрткой — стандартным вектором векторов, что мы и сделали в параграфе «Шаблоны классов».</li>
  </ol>

  <h4>Умный указатель std::unique_ptr</h4>

  <p>Умные обёртки над отдельным указателем, следующие идиоме RAII, есть в стандартной библиотеке. Это так называемые умные указатели (smart pointers).</p>
  <p>Рассмотрим умный указатель std::unique_ptr.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;memory&gt;  // все умные указатели объявлены здесь

int main() {
  int* ptr = new int(17);  // обычный указатель
  std::cout &lt;&lt; *ptr &lt;&lt; "\n";  // 17
  delete ptr;  // важно не забыть!

  // А это — умный указатель
  std::unique_ptr<int> smart = std::make_unique<int>(17);  // вместо new int(17)

  // Он притворяется обычным указателем — у него перегружены соответствующие операторы:
  std::cout &lt;&lt; *smart &lt;&lt; "\n";  // 17

}   // вызывать delete не надо, выделенная память освободится при выходе из блока
</pre>

  <p>Умный указатель «владеет» ресурсом: память будет освобождена в его деструкторе. Слово unique в его названии подчёркивает, что это единственный владелец ресурса. Такой указатель, как и наш класс File, нельзя скопировать. Иначе будет непонятно, кто должен владеть ресурсом и кто должен удалять его: исходный объект или копия?</p>
  <code>auto smart2 = smart;  // не скомпилируется!</code>

  <p>Заметим, что std::unique_ptr отличается от класса C, который мы написали ранее. Класс C выполнял глубокое копирование хранимого объекта, в то время как std::unique_ptr копирование запрещает. В этом смысле std::unique_ptr больше похож на наш класс File. Как и у File, у std::unique_ptr есть конструктор перемещения и оператор перемещающего присваивания. Поэтому, хотя объекты std::unique_ptr нельзя копировать, их можно возвращать из функции:</p>
<pre>
#include &lt;memory&gt;
#include &lt;utility&gt;

// Странная функция: она неявно требует, чтобы вызывающая сторона взяла на себя владение ресурсом
int* f() {
  // ...
  return new int(123);
}

// Эта функция возвращает умный указатель:
std::unique_ptr&lt;int&gt; g() {
  // ...
  return std::make_unique&lt;int&gt;(123);  // OK
}

int main() {
  f();  // возвращаемое значение проигнорировано, память утекла!
  g();  // а тут ничего страшного: деструктор временного объекта очистил память
}
</pre>

  <p>Может показаться, что std::unique_ptr фактически не отличается от автоматической переменной. Это не так. Объект, созданный в динамической памяти и обёрнутый в std::unique_ptr, всегда имеет одного чётко определённого владельца. Невозможно случайно создать копию такого объекта. Владение можно передавать в функции и возвращать из них.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;utility&gt;

void PutIn(std::unique_ptr&lt;Logger&gt; x) {
  // Получаем x по значению
  // что-то делаем с x
}

int main() {
  auto smart = std::make_unique&lt;Logger&gt;();
  // ...

  // Притворяемся, что smart — временный объект.
  // Фактически, передаём владение в функцию.
  PutIn(std::move(smart));

  // Объект smart теперь всё ещё живой, но он больше ничем не владеет
  if (smart.get() == nullptr) {
    std::cout &lt;&lt; "Empty!\n";  // Empty!
  }
}
</pre>

  <p>Рассмотрим элегантную реализацию односвязного списка через std::unique_ptr.</p>
<pre>
#include &lt;memory&gt;

template &lt;typename T&gt;
class ForwardList {
private:
  struct Node {
    T data;
    std::unique_ptr&lt;Node&gt; next;  // узел владеет следующим узлом
  };

  std::unique_ptr&lt;Node&gt; head;  // сам список владеет начальным узлом

public:
  void PushFront(const T& elem) {
    head = std::make_unique&lt;Node&gt;(elem, std::move(head));
  }

  void PopFront() {
    head = std::move(head->next);
  }

  const T& Front() const {
    return head->data;
  }

  bool Empty() const {
    return head == nullptr;
  }

  ~ForwardList() {
    // Можно было бы оставить деструктор пустым — всё корректно бы удалилось,
    // но на больших списках мог бы переполниться стек вызовов из-за рекурсии в деструкторе Node.
    while (!Empty()) {
      PopFront();
    }
  }

};
</pre>

  <p>Сравните это с реализацией класса List из предыдущего параграфа!</p>

  <h4>Умный указатель std::shared_ptr</h4>

  <p>Другая разновидность умного указателя — умный указатель с подсчётом ссылок на объект. Это std::shared_ptr. Такой указатель уже можно копировать. При копировании увеличивается счётчик созданных копий. В деструкторе этот счётчик уменьшается. Объект удаляется последним владельцем, когда счётчик дойдёт до нуля. Этот счётчик хранится в отдельной ячейке динамической памяти. На неё ссылаются все объекты shared_ptr, которые разделяют владение одним и тем же объектом в динамической памяти. Текущее значение счётчика можно узнать с помощью функции use_count.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;memory&gt;

int main() {
  std::shared_ptr&lt;int> ptr1 = std::make_shared&lt;int>(17);
  std::cout &lt;&lt; *ptr1 &lt;&lt; "\n";  // 17
  std::cout &lt;&lt; ptr1.use_count() &lt;&lt; "\n";  // 1

  auto ptr2 = ptr1;  // копирование разрешено!
  std::cout &lt;&lt; *ptr1 &lt;&lt; "\n";  // 17
  std::cout &lt;&lt; *ptr2 &lt;&lt; "\n";  // 17 — это всё тот же объект
  std::cout &lt;&lt; ptr1.use_count() &lt;&lt; "\n";  // 2
  std::cout &lt;&lt; ptr2.use_count() &lt;&lt; "\n";  // 2

  std::shared_ptr<int> ptr3;
  std::cout &lt;&lt; ptr3.use_count() &lt;&lt; "\n";  // 0

  ptr3 = ptr1;  // присваивание тоже разрешено!
  std::cout &lt;&lt; *ptr3 &lt;&lt; "\n";  // 17
  std::cout &lt;&lt; ptr1.use_count() &lt;&lt; "\n";  // 3
  std::cout &lt;&lt; ptr2.use_count() &lt;&lt; "\n";  // 3
  std::cout &lt;&lt; ptr3.use_count() &lt;&lt; "\n";  // 3
}
</pre>

  <p>Классический случай применения std::shared_ptr — реализация направленного ациклического графа. В этой реализации каждая вершина хранит вектор умных указателей на соседние вершины, в которые ведут рёбра. Умные указатели на начальные вершины хранятся отдельно.</p>
  <p>Пример направленного ациклического графа.</p>
  <p>Требование ацикличности графа важно: если допустить циклы в таком графе, то может оказаться, что вершина A ссылается через std::shared_ptr на вершину B, а та, в свою очередь, ссылается через std::shared_ptr на вершину A. Такой цикл никогда не сможет быть разрушен с помощью счётчика ссылок. Это приведёт к утечке памяти. Решением может быть замена одной из ссылок на std::weak_ptr, но это выходит за рамки этого пособия.</p>
  <p>Следует помнить, что счётчик ссылок и выделение динамической памяти — это дополнительные накладные расходы. Поэтому предпочитайте класс std::unique_ptr классу std::shared_ptr, а обычный объект на стеке — умному указателю std::unique_ptr там, где это возможно.</p>
</article>


<!-- 4.7 Разбор задач к главе «Идиомы C++» -->
<article class="article">
  <div class="anchor" id="p4.7"></div>
  <h3>4.7 Разбор задач к главе «Идиомы C++»</h3>

  <h3>Параграф «Классы»</h3>

  <h4>Задача «Дата»</h4>

  <details>
    <summary>Условие</summary>
    <p>Вам надо написать класс Date для хранения даты григорианского календаря. Используйте три переменных типа int для хранения дня, месяца и года. В вашем классе должен быть следующий публичный интерфейс:</p>
    <ol>
      <li>Конструктор, принимающий на вход три числа: день, месяц и год. В случае некорректной даты должна создаваться дата 1 января 1970 года.</li>
      <li>Константные функции GetDay, GetMonth и GetYear.</li>
      <li>Бинарные операторы + и -, где вторым аргументом является целое число — количество дней. Эти операторы должны вернуть новую дату, отстоящую от заданной на указанное число дней.</li>
      <li>Бинарный оператор -, вычисляющий разность между двумя датами и возвращающий int – количество дней.</li>
    </ol>
    <p>Считайте, что все обрабатываемые даты будут лежать в пределах от 1 января 1970 года до 31 декабря 2099 года.</p>
    <p>Примечания</p>
    <p>Сдайте в систему только код класса Date без функции main.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Для начала запишем главное условие — «Используйте три переменных типа int для хранения дня, месяца и года», также определим константы.</p>
<pre>
const int DEFAULT_DATE_DAY = 1;
const int DEFAULT_DATE_MONTH = 1;
const int DEFAULT_DATE_YEAR = 1970;
const int DAYS_IN_YEAR_WITHOUT_FEB = 337;

class Date {
private:
  int d = DEFAULT_DATE_DAY, m = DEFAULT_DATE_MONTH, y = DEFAULT_DATE_YEAR;

  // Дальше реализуем вспомогательные функции-члены.
  // Нам нужно будет понимать високосный ли перед нами год, корректную ли дату ввели:
  int GetDaysInFeb(int year) const {
    if ((!(year % 4) && (year % 100)) || !(year % 400)) {
      return 29;
    }
    return 28;
  }

  int GetDaysInMonth(int month, int year) const {
    switch (month) {
      case 2:
        return GetDaysInFeb(year);
      case 1:
      case 3:
      case 5:
      case 7:
      case 8:
      case 10:
      case 12:
        return 31;
      default:
        return 30;
    }
  }

  int GetDaysInYear(int year) const {
    return DAYS_IN_YEAR_WITHOUT_FEB + GetDaysInFeb(year);
  }

  bool IsCorrectDate() const {
    return GetMonth() &lt;= 12 && GetMonth() >= 1 && GetDay() &lt;= GetDaysInMonth(GetMonth(), GetYear()) && GetDay() > 0;
  }

  // Помимо прочего будет полезно уметь переводить текущую дату в число — количество дней от 01.01.1970 и обратно.
  int DaysPassedToMonth(int month, int year) const {
    int days = 0;
    for (int i = 1; i &lt; month; ++i) {
      days += GetDaysInMonth(i, year);
    }
    return days;
  }

  int GetDays() const {
    int days = 0;
    for (int i = DEFAULT_DATE_YEAR; i &lt; GetYear(); ++i) {
      days += GetDaysInYear(i);
    }
    return days + DaysPassedToMonth(GetMonth(), GetYear()) + GetDay();
  }

  void SetFromDays(int inp_days) {
    m = DEFAULT_DATE_MONTH;
    y = DEFAULT_DATE_YEAR;

    while (inp_days > GetDaysInYear(GetYear())) {  // сначала определяем год
      inp_days -= GetDaysInYear(GetYear());
      ++y;
    }

    while (inp_days > DaysPassedToMonth(GetMonth() + 1, GetYear())) {  // определяем месяц
      ++m;
    }

    d = inp_days - DaysPassedToMonth(GetMonth(), GetYear());  // остаток в дни
  }

// Когда подготовительная часть закончена, реализуем публичный интерфейс:
public:
  Date(int day, int month, int year)
    : d{day}, m{month}, y{year} {
      if (!IsCorrectDate()) {
      d = DEFAULT_DATE_DAY;
      m = DEFAULT_DATE_MONTH;
      y = DEFAULT_DATE_YEAR;
    }
  }

  int GetDay() const {
    return d;
  }

  int GetMonth() const {
    return m;
  }

  int GetYear() const {
    return y;
  }

  Date operator + (int k) const {
    Date result(*this);
    result.SetFromDays(result.GetDays() + k);
    return result;
  }

  Date operator - (int k) const {
    Date result(*this);
    result.SetFromDays(result.GetDays() - k);
    return result;
  }

  int operator - (const Date& other) const {
    return GetDays() - other.GetDays();
  }
};
</pre>
  </details>

  <h4>Задача «Дата - 2»</h4>

  <details>
    <summary>Условие</summary>
    <p>Вам надо переделать реализацию класса Date из предыдущей задачи, сохранив публичный интерфейс неизменным. Теперь для хранения даты используйте одну переменную типа int — количество дней, прошедших с некоторого начала отсчёта.</p>
    <p>Считайте, что все обрабатываемые даты будут лежать в пределах от 1 января 1970 года до 31 декабря 2099 года.</p>
    <p>Примечания</p>
    <p>Сдайте в систему только код класса Date без функции main.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Изменим нашу реализацию из предыдущей задачи. Часть вспомогательных функций-членов не меняется:</p>
<pre>
#include &lt;tuple&gt;

const int DEFAULT_DATE_DAY = 1;
const int DEFAULT_DATE_MONTH = 1;
const int DEFAULT_DATE_YEAR = 1970;
const int DAYS_IN_YEAR_WITHOUT_FEB = 337;

class Date {
private:
  int days{0};

  int GetDaysInFeb(int year) const {
    if ((!(year % 4) && (year % 100)) || !(year % 400)) {
      return 29;
    }
    return 28;
  }

  int GetDaysInMonth(int month, int year) const {
    switch (month) {
      case 2:
        return GetDaysInFeb(year);
      case 1:
      case 3:
      case 5:
      case 7:
      case 8:
      case 10:
      case 12:
        return 31;
      default:
        return 30;
      }
    }

  int GetDaysInYear(int year) const {
    return DAYS_IN_YEAR_WITHOUT_FEB + GetDaysInFeb(year);
  }

  int DaysPassedToMonth(int month, int year) const {
    int result = 0;
    for (int i = 1; i &lt; month; ++i) {
      result += GetDaysInMonth(i, year);
    }
    return result;
  }

  // Отредактируем перевод из даты в дни и обратно:
  void SetDays(int day, int month, int year) {
    days = 0;
    for (int i = DEFAULT_DATE_YEAR; i &lt; year; ++i) {
      days += GetDaysInYear(i);
    }
    days = days + DaysPassedToMonth(month, year) + day;
  }

  std::tuple&lt;int, int, int&gt; ToDate() const {
    int inp_days = days;
    int month = DEFAULT_DATE_MONTH;
    int year = DEFAULT_DATE_YEAR;

    while (inp_days > GetDaysInYear(year)) {  // сначала определяем год
      inp_days -= GetDaysInYear(year);
        ++year;
      }

      while (inp_days > DaysPassedToMonth(month + 1, year)) {  // определяем месяц
      ++month;
    }

    int day = inp_days - DaysPassedToMonth(month, year);  // остаток в дни
    return {day, month, year};
  }

  void SetFromDays(int inp_days) {
    days = inp_days;
  }

  int GetDays() const {
    return days;
  }

// Осталось поменять публичные интерфейсы.
// Так как в них мы почти не завязывались на тип хранения,
//     правки будут только в функциях-членах чтения и конструкторе:
public:
  Date(int day, int month, int year) {
    if (month > 12 || month &lt; 1 || day > GetDaysInMonth(month, year) || day &lt; 1) {
      days = 0;
    } else {
      SetDays(day, month, year);
    }
  }

  int GetDay() const {
    return std::get&lt;0&gt;(ToDate());
  }

  int GetMonth() const {
    return std::get&lt;1&gt;(ToDate());
  }

  int GetYear() const {
    return std::get&lt;2&gt;(ToDate());
  }

  Date operator + (int k) const {
    Date result(*this);
    result.SetFromDays(result.GetDays() + k);
    return result;
  }

  Date operator - (int k) const {
    Date result(*this);
    result.SetFromDays(result.GetDays() - k);
    return result;
  }

  int operator - (const Date& other) const {
    return GetDays() - other.GetDays();
  }
};
</pre>
  </details>

  <h4>Задача «Rational»</h4>

  <details>
    <summary>Условие</summary>
    <p>Напишите класс Rational (рациональное число). Конструктор класса должен получать на вход два числа типа int (числитель и знаменатель). Считайте, что по умолчанию числитель равен 0, а знаменатель — 1.</p>
    <p>Переопределите бинарные операторы сложения, вычитания, умножения и деления (работающие в том числе и с аргументами типа int), унарные плюс и минус. Предусмотрите функции-члены Numerator и Denominator для получения числителя и знаменателя несократимого представления этой дроби (знаменатель должен быть положительным). Переопределите также операторы +=, -=, *= и /=. Не забудьте определить операторы == и !=.</p>
    <p>Примечания</p>
    <p>Используйте функцию std::gcd стандартной библиотеки.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Одно и то же число может быть задано разными парами числитель/знаменатель (1/2, 2/4, 3/6, ...). Мы же будем хранить рацинальное число в виде несократимой дроби. Для этого нам потребуется функция std::gcd, которая появилась в C++17. Впрочем, можно написать самостоятельно её реализацию с помощью алгоритма Евклида:</p>
<pre>
int gcd(int a, int b) {
  if (b == 0) {
    return a;
  }
  return gcd(b, a % b);
}
</pre>
    <p>Мы введём вспомогательную приватную функцию Reduce, которая будет сокращать дробь и гарантировать, что знаменатель неотрицателен. Эту функцию мы будем вызывать всякий раз, когда при вычислениях дробь могла стать сократимой.</p>
<pre>
#include &lt;numeric&gt;

class Rational {
private:
  int num;
  int denom;

  void Reduce() {
    int d = std::gcd(num, denom);
    num /= d;
    denom /= d;
    if (denom &lt; 0) {
      num *= -1;
      denom *= -1;
    }
  }

public:
  Rational(int num_ = 0, int denom_ = 1) : num(num_), denom(denom_) {
    Reduce();
  }

  int Numerator() const {
    return num;
  }

  int Denominator() const {
    return denom;
  }

  // унарный плюс (формально ничего не меняет)
  Rational operator + () const {
    return {num, denom};
  }

  // унарный минус
  Rational operator - () const {
    return Rational(-num, denom);
  }

  // rhs - сокращение от right hand side (правый аргумент бинарного оператора)
  Rational& operator += (const Rational& rhs) {
    num = num * rhs.denom + rhs.num * denom;
    denom *= rhs.denom;
    Reduce();
    return *this;
  }

  Rational& operator -= (const Rational& rhs) {
    num = num * rhs.denom - rhs.num * denom;
    denom *= rhs.denom;
    Reduce();
    return *this;
  }

  Rational& operator *= (const Rational& rhs) {
    num *= rhs.num;
    denom *= rhs.denom;
    Reduce();
    return *this;
  }

  Rational& operator /= (const Rational& rhs) {
    // сохраняем старый числитель, чтобы корректно работало выражение q /= q.
    int tmp = rhs.num;
    num *= rhs.denom;
    denom *= tmp;
    Reduce();
    return *this;
  }
};

Rational operator + (const Rational& lhs, const Rational& rhs) {
  Rational result = lhs;
  result += rhs;
  return result;
}

Rational operator - (const Rational& lhs, const Rational& rhs) {
  Rational result = lhs;
  result -= rhs;
  return result;
}

Rational operator * (const Rational& lhs, const Rational& rhs) {
  Rational result = lhs;
  result *= rhs;
  return result;
}

Rational operator / (const Rational& lhs, const Rational& rhs) {
  Rational result = lhs;
  result /= rhs;
  return result;
}

bool operator == (const Rational& lhs, const Rational& rhs) {
  return lhs.Numerator() == rhs.Numerator() && lhs.Denominator() == rhs.Denominator();
}

bool operator != (const Rational& lhs, const Rational& rhs) {
  return !(lhs == rhs);
}
</pre>
  </details>

  <h4>Задача «Tree»</h4>

  <details>
    <summary>Условие</summary>
    <p>Вася пишет новую структуру данных — дерево. В узлах и листьях дерева хранятся строковые ключи. Каждый путь от корня до какого-нибудь узла можно записать, перечисляя последовательные ключи узлов. Типичный пример — иерархия папок в файловой системе. Вася уже выбрал способ хранения дерева:</p>
<pre>
#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

struct Node {
  std::map&lt;std::string, Node&gt; children;
};

class Tree {
private:
  Node root;

public:
  bool Has(const std::vector&lt;std::string&gt;& node) const;
  void Insert(const std::vector&lt;std::string&gt;& node);
  void Delete(const std::vector&lt;std::string&gt;& node);
};

// Ваш код будет вставлен сюда
#include "your_code"
</pre>
    <p>Не будем обсуждать, насколько это эффективно.</p>
    <p>Ваша задача — написать реализации функций Has, Insert и Delete для этого класса. В примере с папками в файловой системе функция Has должна проверить, существует ли такая папка, функция Insert должна создать папку (возможно, с промежуточными родительскими папками), а Delete — удалить папку со всеми вложенными подпапками, если такая папка существует.</p>
    <p>Можно считать, что вектор, передаваемый на вход этих функций, всегда непустой.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Рассмотрим для начала функцию Has. Её структура должна выглядеть так:</p>
<pre>
bool Tree::Has(const std::vector&lt;std::string&gt;& node) const {
  // заводим переменную current, «смотрящую» на корень дерева
  for (const auto& item : node) {
    if (/* среди потомков current есть item */) {
      // заменить current на этого потомка
    } else {
      return false;
    }
  }
  return true;
}
</pre>
    <p>Какого типа может быть current? Правильный ответ: это должен быть указатель на Node. При спуске по дереву его можно будет переназначать на вложенный узел:</p>
<pre>
bool Tree::Has(const std::vector&lt;std::string&gt;& node) const {
  const Node* current = &amp;root;
  for (const auto& item : node) {
    if (!current->children.contains(item)) {
      return false;
    }
    current = &current->children.at(item);
  }
  return true;
}
</pre>
    <p>Мы здесь используем const Node*, потому что функция Has константная, а значит, поле root тоже рассматривается как константное. По этой же причине мы пишем children.at(item), а не children[item]: оператор [] у map не является константным, и его не получится использовать. Вместо children.contains(item) можно было бы взять children.find(item) и сравнить полученный итератор с children.end().</p>
    <p>Теперь напишем Insert:</p>
<pre>
void Tree::Insert(const std::vector&lt;std::string&gt;& node) {
  Node* current = &amp;root;
  for (const auto& item : node) {
    if (!current->children.contains(item)) {
      current->children[item];  // просто вставляем новый ключ с пустым Node в качестве значения
    }
    current = &current->children.at(item);
  }
}
</pre>
    <p>В функции Delete нам не нужно спускаться на самый последний узел: вместо этого его имя надо будет удалить из предпоследнего узла. Поэтому воспользуемся индексами для итерации по списку промежуточных узлов node:</p>
<pre>
void Tree::Delete(const std::vector&lt;std::string&gt;& node) {
  Node* current = &amp;root;
  for (size_t i = 0; i &lt; node.size(); ++i) {
    const auto& item = node[i];
    if (!current->children.contains(item)) {
      return;
    }
    if (i + 1 == node.size()) {
      current->children.erase(item);
    } else {
      current = &current->children.at(item);
    }
  }
}
</pre>
    <p>Грубая ошибка в этой задаче — пытаться использовать Node current вместо указателя. Смотрите, вот такой Has на первый взгляд даже будет работать:</p>
<pre>
bool Tree::Has(const std::vector&lt;std::string&lt;& node) const {
  Node current = root;
  for (const auto& item : node) {
    if (!current.children.contains(item)) {
      return false;
    }
    current = current.children.at(item);
  }
  return true;
}
</pre>
    <p>Однако можно заметить, что здесь на каждой итерации происходит полное копирование поддерева. В этом можно убедиться, если определить для struct Node конструктор копирования, печатающий сообщения на экран. Конечно же, при навигации по дереву никаких лишних копирований происходить не должно. Более того, из-за особенностей внутренней реализации std::map выражение current = current.children.at(item) приведет к неопределённому поведению программы (родительское дерево будет разрушено до обращения к поддереву).</p>
  </details>

  <h4>Задача «Крестики-нолики»</h4>

  <details>
    <summary>Условие</summary>
    <p>Один студент решил написать класс для своей реализации игры «крестики-нолики». Игра ведётся на квадратном поле размера NxN двумя игроками. Игроки должны составить K крестиков или ноликов в ряд (по горизонтали, по вертикали или по диагонали).</p>
    <p>Класс должен уметь создавать квадратное поле заданных размеров, выполнять очередной ход в пустую клетку, а также проверять, не наступил ли выигрыш. Кроме того, должен быть оператор &lt;&lt;, который печатает поле.</p>
    <p>Студент пока не реализовал проверку выигрыша по диагоналям. А ещё его программа почему-то «падает» при попытке напечатать поле. Помогите ему исправить и сдать программу. Вот код студента:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector>

class TicTacToe {
public:
  const size_t N;  // размер игрового поля
  const size_t K;  // сколько фишек нужно поставить в ряд, чтобы выиграть

private:
  // 0 - пусто, 1 - фишка первого игрока (крестик), 2 - фишка второго игрока (нолик)
  std::vector&lt;std::vector<int>> Table;

  // номер текущего игрока (1 или 2)
  int currentPlayer;

public:
  TicTacToe(size_t n, size_t k): N(n), K(k), currentPlayer(1) {
    Table.reserve(N);
    for (size_t i = 0; i != N; ++i) {
      Table[i].reserve(N);
    }
  }

  int operator()(size_t i, size_t j) const {
    return Table[i][j];
  }

  int GetCurrentPlayer() const {
    return currentPlayer;
  }

  bool Set(size_t i, size_t j) {  // возвращает true, если ход завершился выигрышем
    Table[i][j] = currentPlayer;
    currentPlayer = currentPlayer % 2 + 1;
    bool wins = CheckRow(i, j) || CheckColumn(i, j) || CheckDiagonal1(i, j) || CheckDiagonal2(i, j);
    return wins;
  }

private:
  bool CheckRow(size_t i, size_t j) const {
    size_t d1 = 0;
    while (d1 &lt;= j && Table[i][j - d1] == Table[i][j]) {
      ++d1;
    }

    size_t d2 = 0;
    while (j + d2 &lt; N && Table[i][j + d2] == Table[i][j]) {
      ++d2;
    }

    return d1 + d2 > K;
  }

  bool CheckColumn(size_t i, size_t j) const {
    size_t d1 = 0;
    while (d1 &lt;= i && Table[i - d1][j] == Table[i][j]) {
      ++d1;
    }

    size_t d2 = 0;
    while (i + d2 &lt; N && Table[i + d2][j] == Table[i][j]) {
      ++d2;
    }

    return d1 + d2 > K;
  }

  bool CheckDiagonal1(size_t i, size_t j) const;

  bool CheckDiagonal2(size_t i, size_t j) const;
};

std::ostream& operator &lt;&lt; (std::ostream& out, TicTacToe& field) {
  for (size_t i = 0; i != field.N; ++i) {
    for (size_t j = 0; j != field.N; ++j) {
      switch (field(i, j)) {
        case 0:
          std::cout &lt;&lt; '.';
          break;
        case 1:
          std::cout &lt;&lt; 'X';
          break;
        case 2:
          std::cout &lt;&lt; 'O';
      }
    }
    std::cout &lt;&lt; "\n";
  }
  return out;
}
</pre>

  <p>Примечания</p>
  <p>Вам требуется сдать только исправленный (и дополненный для проверки выигрыша по диагоналям) код класса TicTacToe и оператора &lt;&lt;. Функции main в Вашем коде быть не должно. Ваша программа будет автоматически собрана с нашей функцией main примерно такого содержания:</p>
<pre>
#include &lt;iostream&gt;

#include "tic_tac_toe.correct.h"  // это ваше решение

int main() {
  size_t n, m;
  std::cin >> n >> m;
  TicTacToe game(n, m);
  size_t x, y;
  while (std::cin >> x >> y) {
    int curPlayer = game.GetCurrentPlayer();
    if (game.Set(x, y)) {
      std::cout &lt;&lt; "Player #" &lt;&lt; curPlayer &lt;&lt; " wins!\n";
    }
  }
  std::cout &lt;&lt; game;
}
</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Прежде всего заметим, что неверно написан конструктор. В нём лишь резервируется память для вектора, но не меняется его размер. Перепишем его так:</p>
<pre>
TicTacToe(size_t n, size_t k): N(n), K(k), currentPlayer(1) {
  Table.resize(N);
  for (size_t i = 0; i != N; ++i) {
    Table[i].resize(N);
  }
}
</pre>
  <p>Во-вторых, в операторе &lt;&lt; есть две ошибки: ответ печатается в std::cout вместо out, и второй аргумент принимается по обычной, а не по константной ссылке.</p>
  <p>Наконец, нам нужно реализовать функции CheckDiagonal1 и CheckDiagonal2. Вопреки заблуждению некоторых студентов, видимо, много решавших задачи про матрицы, диагональ тут (как в самых обычных крестиках-ноликах) может быть любая, а не только главная или побочная. Рассмотрим, как сделана, например, аналогичная функция CheckRow, проверяющая, образуется ли K подряд идущих фишек по горизонтали после хода в указанную позицию:</p>
<pre>
bool CheckRow(size_t i, size_t j) const {
  size_t d1 = 0;
  // считаем, сколько слева от нас таких же фишек
  while (d1 &lt;= j && Table[i][j - d1] == Table[i][j]) {
    ++d1;
  }

  size_t d2 = 0;
  // считаем, сколько справа от нас таких же фишек
  while (j + d2 &lt; N && Table[i][j + d2] == Table[i][j]) {
    ++d2;
  }

  // всего мы насчитали d1 + 1 + d2 фишек вместе с
  // текущей, это число должно быть не меньше K
  return d1 + d2 > K;
}
</pre>

  <p>Тут важно проверять корректности индексов: они должны быть неотрицательны и меньше N. Напишем по аналогии проверку наличия диагональных выигрышных позиций:</p>
<pre>
bool CheckDiagonal1(size_t i, size_t j) const {
  size_t d1 = 0;
  while (d1 &lt;= i && d1 &lt;= j && Table[i - d1][j - d1] == Table[i][j]) {
    ++d1;
  }

  size_t d2 = 0;
  while (i + d2 &lt; N && j + d2 &lt; N && Table[i + d2][j + d2] == Table[i][j]) {
    ++d2;
  }

  return d1 + d2 > K;
}

bool CheckDiagonal2(size_t i, size_t j) const {
  size_t d1 = 0;
  while (d1 &lt;= i && j + d1 &lt; N && Table[i - d1][j + d1] == Table[i][j]) {
    ++d1;
  }

  size_t d2 = 0;
  while (i + d2 &lt; N && d2 &lt;= j && Table[i + d2][j - d2] == Table[i][j]) {
    ++d2;
  }

  return d1 + d2 > K;
}
</pre>
  </details>

  <h4>Задача «Работа склада»</h4>

  <details>
    <summary>Условие</summary>
    <p>Вы работаете оператором на складе. Время от времени вам привозят новые коробки. Каждая коробка имеет свою грузоподъемность wi и объем vi. Получая новую коробку, вы ставите на ней серийный номер, используя все целые неотрицательные числа последовательно, начиная с нуля.</p>
    <p>Иногда вас просят выдать коробку минимальной грузоподъемности, чтобы она выдержала предмет весом w, или же коробку минимальной вместимости, в которую можно насыпать песок объемом v. Вам нужно быстро определять серийный номер коробки, которая будет выдана. Коробки обратно на склад не возвращаются. Если подходящих коробок несколько, нужно выбрать ту, которая пролежала на складе меньше.</p>
    <p>Нужно реализовать класс Stock, у которого, среди прочих, будет три функции:</p>
    <ol>
      <li>void Add(int w, int v); — добавить коробку на склад;</li>
      <li>int GetByW(int min_w); — вернуть номер коробки грузоподъемности хотя бы minw;</li>
      <li>int GetByV(int min_v); — вернуть номер коробки объема хотя бы minv.</li>
    </ol>
    <p>Если подходящей коробки нет, соответствующая функция должна вернуть -1.</p>
    <p>Примечания</p>
    <p>Обратите внимание, что вам нужно отправить только ваш класс Stock, без функции main. Не забудьте, что необходимые функции-члены должны быть доступны вне класса.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Реализуем три дополнительные структуры:</p>
    <ol>
      <li>WeightNumber — структура для хранения вместимостей коробок;</li>
      <li>VolumeNumber — структура для хранения объёмов коробок;</li>
      <li>Iterators — структура для хранения итераторов на коробки. Сами коробки мы будем хранить в двух std::set, итераторы на эти множества мы и будем хранить в Iterators.</li>
    </ol>
    <p>Так как мы планируем хранить данные о коробках в двух разных std::set, то для них нужно реализовать компараторы. Идея простая — сначала сортируем по вместимости / объёму, потом по индексу (порядковому номеру).</p>
    <p>Все Iterators будем хранить в std::vector, так мы просто поддержим требуемые от нас «серийные номера» (индексы).</p>
    <p>Теперь разберём функции-члены:</p>
    <ol>
      <li>Add — нам нужно добавить коробку в оба множества и полученные итераторы записать в конец вектора.</li>
      <li>GetByW — вызовем lower_bound от множества грузоподъёмностей. Если результатом стал end(), то коробок, способных поднять такой вес нет. Иначе — мы получим итератор на нужную нам коробку. Удалим её из обоих множеств и вернём искомый индекс.</li>
      <li>GetByV — полный аналог GetByW, лишь lower_bound вызываем от множества объёмов.</li>
    </ol>
<pre>
#include &lt;set&gt;
#include &lt;vector&gt;
#include &lt;cstdint&gt;

class Stock {
private:
  struct WeightNumber {
    int w;
    size_t i;

    bool operator &lt; (const WeightNumber& other) const {
      if (w == other.w) {
        return i > other.i;
      }
      return w &lt; other.w;
    }
  };

  struct VolumeNumber {
    int v;
    size_t i;

    bool operator &lt; (const VolumeNumber& other) const {
      if (v == other.v) {
        return i > other.i;
      }
      return v &lt; other.v;
    }
  };

  struct Iterators {
    std::set&lt;WeightNumber>::iterator byW;
    std::set&lt;VolumeNumber>::iterator byV;
  };

  std::vector&lt;Iterators> boxes;
  std::set&lt;WeightNumber> sortedByW;
  std::set&lt;VolumeNumber> sortedByV;

public:
  void Add(int w, int v) {
    size_t num = boxes.size();
    boxes.push_back({sortedByW.insert({w, num}).first, sortedByV.insert({v, num}).first});
  }

  int GetByW(int min_w) {
    const auto it = sortedByW.lower_bound({min_w, boxes.size()});
    if (it == sortedByW.end()) {
      return -1;
    }

    size_t res = it->i;
    sortedByW.erase(it);
    sortedByV.erase(boxes[res].byV);
    return res;
  }

  int GetByV(int min_v) {
    const auto it = sortedByV.lower_bound({min_v, boxes.size()});
    if (it == sortedByV.end()) {
      return -1;
    }

    size_t res = it->i;
    sortedByV.erase(it);
    sortedByW.erase(boxes[res].byW);
    return res;
  }
};
</pre>

  <p>Явным минус такой реализации — из boxes не удаляются коробки. Рано или поздно, если бы это был реальный продукт, у вас случится переполнение. Но это решение всё равно проходит тесты, мы не требовали от вас лучшей реализации.</p>
  <p>Но в большой продуктовой задаче очень важно чистить за собой ненужные данные. Проблему накопления мусора в этой задаче можно решить через std::list, в нём удобное удаление из центра, но нет индексирования.</p>
  <p>Чтобы решить проблему с индексированием воспользуемся дополнительным std::unordered_map. Да, если коробки сначала только накапливаются, а потом разбираются, то эффективней будет первое решение, но если коробки можно накапливать постепенно, то сильно лучше второе решение.</p>
  <p>Для демонстрации мы специально сделали тест, который последовательно вызывает Add, а за ним один из GetBy*. В первой реализации итоговый boxes будет размером с количество вызовов Add, во второй же он всегда будет размером 0 или 1.</p>
  <p>Это никак не сказывается на времени работы (так как удаление из sortedBy* происходит и там, и там), но сказывается на используемой памяти. Для двух миллионов коробок разница занимаемой памяти составляет 60 раз!</p>
<pre>
#include &lt;list&gt;
#include &lt;set&gt;
#include &lt;cstdint&gt;
#include &lt;unordered_map&gt;

class Stock {
private:
  struct WeightNumber {
    int w;
    size_t i;

    bool operator &lt; (const WeightNumber& other) const {
      if (w == other.w) {
        return i > other.i;
      }
      return w &lt; other.w;
    }
  };

  struct VolumeNumber {
    int v;
    size_t i;

    bool operator &lt; (const VolumeNumber& other) const {
      if (v == other.v) {
        return i > other.i;
      }
      return v &lt; other.v;
    }
  };

  struct Iterators {
    std::set&lt;WeightNumber&gt;::iterator byW;
    std::set&lt;VolumeNumber&gt;::iterator byV;
  };

  std::list&lt;Iterators&gt; boxes;
  std::set&lt;WeightNumber&gt; sortedByW;
  std::set&lt;VolumeNumber&gt; sortedByV;
  std::unordered_map&lt;size_t, std::list&lt;Iterators&gt;::iterator&gt; indexes;
  size_t current_index{0};

public:
  void Add(int w, int v) {
    boxes.push_front({sortedByW.insert({w, current_index}).first,
      sortedByV.insert({v, current_index}).first});
    indexes.insert({current_index, boxes.begin()});
    ++current_index;
  }

  int GetByW(int min_w) {
    const auto it = sortedByW.lower_bound({min_w, current_index});
    if (it == sortedByW.end()) {
      return -1;
    }

    size_t res = it->i;
    sortedByW.erase(it);
    sortedByV.erase(indexes[res]->byV);
    boxes.erase(indexes[res]);
    indexes.erase(res);
    return res;
  }

  int GetByV(int min_v) {
    const auto it = sortedByV.lower_bound({min_v, current_index});
    if (it == sortedByV.end()) {
      return -1;
    }

    size_t res = it->i;
    sortedByV.erase(it);
    sortedByW.erase(indexes[res]->byW);
    boxes.erase(indexes[res]);
    indexes.erase(res);
    return res;
  }
};
</pre>
  </details>

  <h3>Параграф «Шаблоны классов»</h3>

  <h4>Задача «Table»</h4>

  <details>
    <summary>Условие</summary>
    <p>Вам надо написать шаблонный класс Table для электронной таблицы. Для простоты будем считать, что все ячейки таблицы имеют один и тот же тип данных T. Таблица должна уметь менять свой размер по требованию пользователя. Вновь созданные ячейки должны заполняться значениями по умолчанию типа T.</p>
    <p>Требования к классу такие:</p>
    <ol>
      <li>Класс должен называться Table.</li>
      <li>У класса должен быть шаблонный параметр T — тип элемента в ячейке.</li>
      <li>У класса должен быть конструктор, получающий на входе два числа типа size_t, — начальные размеры таблицы.</li>
      <li>У класса должны быть константная и неконстантная версии оператора [], возвращающего нечто такое, к чему снова можно было бы применить оператор []. То есть, должны работать конструкции вида std::cout &lt;&lt; table[i][j]; и table[i][j] = value;. Проверять корректность индексов при этом не нужно.</li>
      <li>У класса должна быть функция resize, получающая на вход два параметра типа size_t и меняющая размер таблицы. Старые данные, умещающиеся в новый размер, должны при этом сохраниться.</li>
      <li>У класса должна быть функция size, возвращающая std::pair&lt;size_t, size_t&gt; — размер таблицы (в том же порядке, в котором эти аргументы передавались в конструктор).</li>
    </ol>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;vector&gt;
#include &lt;utility&gt;

template &lt;typename T&gt;
class Table {
private:
  std::vector&lt;std::vector&lt;T&gt; &gt; data;

public:
  Table(size_t m, size_t n) {
    resize(m, n);
  }

  // версия для неконстантных таблиц
  std::vector&lt;T&gt;& operator [] (size_t i) {
    return data[i];
  }

  // версия для константных таблиц
  const std::vector&lt;T&gt;& operator [] (size_t i) const {
    return data[i];
  }

  void resize(size_t m, size_t n) {
    data.resize(m);
    for (size_t i = 0; i &lt; m; ++i) {
      data[i].resize(n);
    }
  }

  std::pair&lt;size_t, size_t&gt; size() const {
    if (data.empty()) {
      return {0, 0};
    } else {
      return {data.size(), data[0].size()};
    }
  }
};
</pre>

    <p>Часто задаваемый вопрос — какой индекс в таблице отвечает за строки, а какой — за столбцы. На самом деле это совершенно не важно. Главное, чтобы пара индексов i и j, по которым будут обращаться в таблицу, была бы согласованной с размерами: i должен быть меньше m, а j меньше n.</p>
    <p>Другая типичная ошибка — возврат {data.size(), data[0].size()} в функции size() без проверки пустоты вектора. На пустом data тут будет некорректное обращение к памяти в data[0].</p>
  </details>

  <h4>Задача «Queue»</h4>

  <details>
    <summary>Условие</summary>
    <p>Вам требуется реализовать класс Queue, аналогичный адаптеру std::queue. Он является обёрткой над некоторым стандартным контейнером и реализует интерфейс очереди. Класс должен быть шаблонным. Первый шаблонный параметр T — тип хранимых элементов. Второй шаблонный параметр — контейнер, используемый для хранения элементов (по умолчанию — std::deque&lt;T&gt;):</p>
<pre>
template &lt;typename T, typename Container = std::deque&lt;T&lt; &lt;
class Queue;
</pre>

  <p>Предусмотрите в классе следующее:</p>
  <ol>
    <li>Конструктор по умолчанию, создающий пустую очередь.</li>
    <li>Константную функцию front, которая возвращает элемент, стоящий в начале очереди.</li>
    <li>Неконстантную функцию front, которая возвращает по ссылке элемент, стоящий в начале очереди — тем самым давая возможность его изменить.</li>
    <li>Функцию pop, которая убирает элемент из начала очереди (и ничего не возвращает)</li>
    <li>Функцию push, которая кладёт переданный элемент в конец очереди.</li>
    <li>Функцию size, которая возвращает количество элементов.</li>
    <li>Функцию empty, которая возвращает true тогда и только тогда, когда очередь пуста</li>
    <li>Операторы == и != для сравнения двух очередей.</li>
  </ol>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Наш класс будет просто обёрткой над контейнером. Все функции нашего класса будут сводиться к вызову соответствующих функций контейнера. Смысл нашего класса в том, что мы ограничиваем публичный интерфейс, оставляя только функции, специфичные для очереди. Например, у нас не будет оператора [] или функций begin и end, так как для очереди они не нужны. Кроме того, некоторые функции у очереди будут называться иначе (push и pop вместо push_back и pop_front), так как для очереди бессмысленно указывать, с какой стороны в неё поступают элементы, и с какой извлекаются.</p>
    <p>Конструктор класса Queue можно не писать, так как компилятор предоставит автоматически конструктор по умолчанию.</p>
<pre>
#include &lt;deque&gt;

template &lt;typename T, typename Container = std::deque&lt;T&lt; &lt;
class Queue {
private:
  Container data;

public:
  const T& front() const {
    return data.front();
  }

  T& front() {
    return data.front();
  }

  void push(const T& elem) {
    data.push_back(elem);
  }

  void pop() {
    data.pop_front();
  }

  size_t size() const {
    return data.size();
  }

  bool empty() const {
    return data.empty();
  }

  bool operator == (const Queue& other) const {
    return data == other.data;
  }

  bool operator != (const Queue& other) const {
    return !operator==(other);
  }
};
</pre>

  <p>Обратите внимание, что операторы == и !=, а также функции size и empty объявлены константными, так как они не меняют очередь. Это позволяет применять их к константным очередям. Также функция front перегружена по константности: для константных очередей элемент возвращается для чтения, а для неконстантных — для записи.</p>
  </details>

  <h4>Задача «Key-Value storage»</h4>

  <details>
    <summary>Условие</summary>
    <p>Вася разрабатывает свою структуру — базу данных «ключ-значение». Эта структура данных должна хранить значение, ассоциированное с ключом, и она будет делать это суперэффективно. Пока для простоты Вася выбрал за основу std::unordered_map, но потом он это переделает.</p>
    <p>Какие операции должно поддерживать такое хранилище? Правильно: вставка элемента, удаление элемента и поиск элемента. Вася написал прототипы функций Insert, Remove и Find, но функция Find почему-то не работает. Помогите Васе её исправить. Вот код Васи:</p>
<pre>
#include &lt;unordered_map>

template &lt;typename Key, typename Value>
class KeyValueStorage {
private:
  std::unordered_map&lt;Key, Value> data;

public:
  void Insert(const Key& key, const Value& value) {
    data[key] = value;
  }

  void Remove(const Key& key) {
    data.erase(key);
  }

  bool Find(const Key& key, Value* const value = nullptr) const;
};


// Почему-то не работает...
//
// template &lt;typename Key, typename Value>
// bool KeyValueStorage&lt;Key, Value>::Find(const Key& key, Value* const value) const {
//   auto it = std::find(data.begin(), data.end(), key);
//   auto val = *it;
//   if (value != nullptr)
//     value = &amp;val;
//   return it != data.end();
// }
31
32// Ваша реализация функции KeyValueStorage::find будет вставлена сюда:
33#include "your_version_of_find.h"
</pre>

  <p>Ваша версия функции Find будет вставлена в конце этого кода. Её заголовок должен быть таким же, как в закомментированной части.</p>
  <p>Функция Find по задумке должна возвращать true, если ключ был найден, и false в противном случае. Если второй аргумент функции Find отличен от nullptr и ключ найден, то функция должна записать найденное значение в тот объект, на который ссылается этот аргумент (предполагается, что новая структура данных сможет быстро определять наличие ключа, но само значение будет извлекаться дорого, и делать это нужно лишь при необходимости). Использовать эту функцию предполагается примерно так:</p>
<pre>
#include "key_value_storage.h"

#include &lt;string&gt;

int main() {
  KeyValueStorage&lt;std::string, int&gt; kv;
  kv.Insert("hello", 42);
  kv.Insert("bye", -13);
  int value = 123;

  // должно вернуться false, а value не должен меняться
  auto res = kv.Find("wrong", &value);

  // должно вернуться true, в value должно быть -13
  res = kv.Find("bye", &value);

  // должно вернуться true
  res = kv.Find("hello", nullptr);
}
</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Наш код будет вставлен после класса. Поэтому для описания тела функции нам потребуется написать шапку template <typename Key, typename Value>, а имя функции предварить префиксом с именем класса - как в закомментированном примере.</p>
<pre>
template &lt;typename Key, typename Value&gt;
bool KeyValueStorage&lt;Key, Value&gt;::Find(const Key& key, Value* const value) const {
  auto it = data.find(key);
  if (it != data.end() && value != nullptr) {
    *value = it->second;
  }
  return it != data.end();
}
</pre>

    <p>Примечания</p>
    <p>Разберём типичные ошибки:</p>
    <ol>
      <li>Не надо пытаться использовать общий алгоритм std::find или std::find_if. Нужно использовать встроенную функцию find контейнера unordered_map. Во-первых, встроенный find будет работать быстрее (а std::find будет выполнять линейный поиск). Во-вторых, std::find не предназначен для поиска по ключу. Он ищет в контейнере готовый образец, а значит, ему придётся передать пару из ключа и значения (которого мы не знаем).</li>
      <li>Если значение не найдено, не надо ничего делать с value. Это можно понять по примеру использования. В этом случае надо просто вернуть false.</li>
      <li>Неправильно писать value = &it->second. Сам указатель value мы поменять не сможем; мы лишь записываем найденное значение в ту ячейку памяти, на которую он указывает (если он не nullptr). По условию мы предполагаем, что он в таком случае указывает на корректный существующий объект.</li>
    </ol>
  </details>

  <h4>Задача «Deque»</h4>

  <details>
    <summary>Условие</summary>
    <p>В этой задаче вам надо будет написать свой дек. Писать его по-честному долго и сложно, поэтому мы пошли вам навстречу: вам нужно написать упрощенную версию дека без итераторов, и умеющую только добавлять элементы в начало и конец. Поддерживать удаление элементов из дека не требуется.</p>
    <p>В отличие от стандартного дека возьмите за основу два вектора, растущих каждый в свою сторону. Предлагаем такой прототип — а вам нужно реализовать указанные функции:</p>
<pre>
#include &lt;cstddef&gt;
#include &lt;vector&gt;

template &lt;typename T&gt;
class Deque {
private:
  std::vector&lt;T&gt; head, tail;

public:
  bool Empty() const;

  size_t Size() const;

  void Clear();

  const T& operator [] (size_t i) const;

  T& operator [] (size_t i);

  const T& At(size_t i) const;  // throws std::out_of_range on incorrect index

  T& At(size_t i);  // throws std::out_of_range on incorrect index

  const T& Front() const;

  T& Front();

  const T& Back() const;

  T& Back();

  void PushFront(const T& elem);

  void PushBack(const T& elem);
};
</pre>

  <p>Примечания</p>
  <p>Сдайте в систему класс Deque с написанными функциями.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Дек должен уметь эффективно расти в обе стороны. А вектор умеет эффективно расти только в одну сторону. Поэтому предлагается реализовать решение с помощью двух векторов, смотрящих в разные стороны. По условию удаляться из дека ничего не будет, поэтому в эти векторы будут только добавляться новые элементы в конец. Однако важно помнить, что один из этих векторов может оставаться пустым, если с соответствующей стороны вставок еще не было. Поэтому, например, при вызовe Front мы должны сначала посмотреть на первый вектор, а если он пуст — то на второй.</p>
    <p>Часто задаваемые вопросы</p>
    <p>Q. Какой из векторов (head или tail) соотвествует началу, а какой — концу дека?</p>
    <p>A. На самом деле это детали нашей реализации, никак не связанные с объявленным публичным интерфейсом, который требуется реализовать. Можно выбрать любое соответствие и придерживаться его.</p>
    <p>Q. Какой должен быть конструктор дека? Нужен ли конструктор от двух векторов?</p>
    <p>A. Заметим, что в представленном публичном интерфейсе конструктора нет. Значит, компилятор предоставит по умолчанию конструктор без аргументов, инициализирующий поля head и tail их дефолтными конструкторами. Конечно, такой конструктор создаёт пустой дек. Другие конструкторы не требуются. Итак, конструктор можно вообще не писать — нам достаточно дефолтного.</p>
    <p>Q. Что должны делать функции Front и Back на пустом деке?</p>
    <p>A. Как и в std::deque, они не должны делать никаких проверок. То, что эти функции не вызываются на пустом деке, лежит на совести программиста.</p>
    <p>Q. Что должна делать функция At?</p>
    <p>A. Как и в контейнерах стандартной библиотеки, она аналогична оператору [], но проверяет корректность индекса. В случае некорректного индекса она должна генерировать исключение.</p>
    <p>Q. Не получается сгенерировать исключение.</p>
    <p>A. Во-первых, надо подключить &lt;stdexcept&gt; — этот заголовочный файл указан в документации std::out_of_range. В конструктор std::out_of_range надо передать текстовую строку с описанием ошибки. Строка может быть любой, мы её не проверяем.</p>
    <p>Итоговый класс:</p>
<pre>
#include &lt;cstddef&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;

template &lt;typename T&gt;
class Deque {
private:
  std::vector&lt;T&gt; head, tail;

  void CheckIndex(size_t i) const {
    if (i >= Size()) {
      throw std::out_of_range("Index is out of range");
    }
  }

public:
  bool Empty() const {
    return head.empty() && tail.empty();
  }

  size_t Size() const {
    return head.size() + tail.size();
  }

  void Clear() {
    head.clear();
    tail.clear();
  }

  const T& operator [] (size_t i) const {
    if (i &lt; head.size()) {
      return head[head.size() - i - 1];
    }
    return tail[i - head.size()];
  }

  T& operator [] (size_t i) {
    if (i &lt; head.size()) {
      return head[head.size() - i - 1];
    }
    return tail[i - head.size()];
  }

  const T& At(size_t i) const {
    CheckIndex(i);
    return (*this)[i];
  }

  T& At(size_t i) {
    CheckIndex(i);
    return (*this)[i];
  }

  const T& Front() const {
    if (head.empty()) {
      return tail.front();
    }
    return head.back();
  }

  T& Front() {
    if (head.empty()) {
      return tail.front();
    }
    return head.back();
  }

  const T& Back() const {
    if (tail.empty()) {
      return head.front();
    }
    return tail.back();
  }

  T& Back() {
    if (tail.empty()) {
      return head.front();
    }
    return tail.back();
  }

  void PushFront(const T& elem) {
    head.push_back(elem);
  }

  void PushBack(const T& elem) {
    tail.push_back(elem);
  }
};
</pre>
  </details>

  <h4>Задача «MathVector»</h4>

  <details>
    <summary>Условие</summary>
    <p>Математический вектор (не путать с std::vector!) – структура линейной алгебры, определяющаяся набором упорядоченных чисел (координат). Обозначается как (x1, x2, ...,xn). Число n в таком случае называется размерностью вектора.</p>
    <p>В качестве примера можно рассмотреть вектора размерности два с координатами в вещественных числах. В таком случае вектор (1,2) будет задавать знакомый нам со школы геометрический вектор с началом в координате (0,0) и концом в (1,2).</p>
    <p>Также заметим, что координаты вектора необязательно вещественные числа. Это могут быть рациональные, комплексные или любые другие математические объекты, обладающие набором базовых операций сложения и умножения (например математические матрицы).</p>
    <p>Над математическим вектором можно проводить две операции:</p>

    <ol>
      <li>Сложение двух векторов одинаковой размерности: пусть a = (x1, x2, ..., xn), b = (y1, y2, ...,yn), тогда a + b = (x1 + y1, x2 + y2, ..., xn + yn);</li>
      <li>Умножение вектора на число (тип числа должен быть одинаковым с типом чисел координат у вектора): пусть c = (x1, x2, ..., xn), α - какое-то число, тогда α⋅c = (αx1, αx2, ..., αxn).</li>
    </ol>
    <p>Вам дан шаблонный класс MathVector<T>, представляющий собой математический вектор с координатами типа T:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

template &lt;typename T&gt;
class MathVector {
private:
  std::vector&lt;T&gt; data;

public:
  // Храним в `data` нулевой вектор длины `n`
  MathVector(size_t n) {
    data.resize(n);
  }

  template &lt;typename Iter&gt;
  MathVector(Iter first, Iter last) {
    while (first != last) {
      data.push_back(*first);
    }
  }

  size_t Dimension() const {
    return data.size();
  }

  T& operator [] (size_t i) {
    return data[i];
  }

  const T& operator [] (size_t i) const {
    return data[i];
  }
};

// Output format: (1, 2, 3, 4, 5)
template &lt;typename T&gt;
std::ostream& operator &lt;&lt; (std::ostream& out, const MathVector&lt;T&gt;& v) {
  out &lt;&lt; '(';
  for (size_t i = 0; i != v.Dimension(); ++i) {
    if (i > 0) {
      out &lt;&lt; ", ";
    }
    out &lt;&lt; v[i];
  }
  out &lt;&lt; ')';
  return out;
}

template &lt;typename T&gt;
MathVector&lt;T&gt;& operator *= (MathVector&lt;T&gt;& v, const T& scalar) {
  for (size_t i = 0; i != v.Dimension(); ++i) {
    v[i] *= scalar;
  }
  return v;
}

template &lt;typename T&gt;
MathVector&lt;T&gt; operator * (const MathVector&lt;T&gt;& v, const T& scalar) {
  auto tmp(v);
  tmp *= scalar;
  return tmp;
}

template &lt;typename T&gt;
MathVector&lt;T&gt; operator * (const T& scalar, const MathVector&lt;T&gt;& v) {
  return v * scalar;
}
</pre>

  <p>Вам требуется исправить ошибки в коде этого класса и дописать операторы += и + для сложения векторов. Считайте, что складываться друг с другом всегда будут только векторы одинаковой размерности.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Для начала исправим существующие в коде ошибки:</p>
    <p>Первая ошибка находится в конструкторе вектора по двум итераторам. В цикле while нет инкремента для итератора, из-за чего получается бесконечный цикл. Правильнее всего переписать цикл на for.</p>
    <p>Вторая ошибка в константном операторе operator []. Чтобы явно обозначить константное получение элемента из std::vector, необходимо использовать функцию .at.</p>
    <p>Когда все ошибки исправлены – остаётся только дописать недостающие функции по аналогии с уже существующими.</p>
    <p>Итоговый файл:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

template&lt;typename T&gt;
class MathVector {
private:
  std::vector&lt;T&gt; data;

public:
  // Храним в `data` нулевой вектор длины `n`
  MathVector(size_t n) {
    data.resize(n);
  }

  template&lt;typename Iter&gt;
  MathVector(Iter first, Iter last) {
    for (; first != last; ++first) {
      data.push_back(*first);
    }
  }

  size_t Dimension() const {
    return data.size();
  }

  T& operator [] (size_t i) {
    return data[i];
  }

  const T& operator [] (size_t i) const {
    return data.at(i);
  }
};

// Output format: (1, 2, 3, 4, 5)
template&lt;typename T&gt;
std::ostream& operator &lt;&lt; (std::ostream& out, const MathVector&lt;T&gt;& v) {
  out &lt;&lt; '(';
  for (size_t i = 0; i != v.Dimension(); ++i) {
    if (i > 0) {
      out &lt;&lt; ", ";
    }
    out &lt;&lt; v[i];
  }
  out &lt;&lt; ')';
  return out;
}

template&lt;typename T&gt;
MathVector&lt;T&gt;& operator *= (MathVector&lt;T&gt;& v, const T& scalar) {
  for (size_t i = 0; i != v.Dimension(); ++i) {
    v[i] *= scalar;
  }
  return v;
}

template&lt;typename T&gt;
MathVector&lt;T&gt; operator * (const MathVector&lt;T&gt;& v, const T& scalar) {
  auto tmp(v);
  tmp *= scalar;
  return tmp;
}

template&lt;typename T>
MathVector&lt;T> operator * (const T& scalar, const MathVector&lt;T&gt;& v) {
  return v * scalar;
}


template&lt;typename T&gt;
MathVector&lt;T&gt;& operator += (MathVector&lt;T&gt;& v1, const MathVector&lt;T&gt;& v2) {
  for (size_t i = 0; i != v1.Dimension(); ++i) {
    v1[i] += v2[i];
  }
  return v1;
}


template&lt;typename T&gt;
MathVector&lt;T&gt; operator + (const MathVector&lt;T&gt;& v1, const MathVector&lt;T&gt;& v2) {
  MathVector&lt;T&gt; tmp = v1;
  tmp += v2;
  return tmp;
}
</pre>
  </details>

  <h4>Задача «Многочлены»</h4>

  <details>
    <summary>Условие</summary>
    <p>Многочлен от одной переменной – алгебраическое выражение, состоящие из суммы нескольких произведений числовых коэффициентов на переменную в натуральной степени. Пример: x²+2x+1. Слагаемыми в многочлене называют одночленами.</p>
    <p>Так же как и в задаче о математическом векторе, числами здесь могут являться любые объекты со стандартным набором базовых математических операций (сложение, вычитание, умножение, деление), например дробные, вещественные или комплексные числа, а так же математические матрицы и другие алгебраические объекты.</p>
    <p>Реализуйте шаблонный класс Polynomial (многочлен от одной переменной) на основе контейнера std::vector. Тип коэффициентов многочлена передавайте в качестве параметра шаблона. Хранение коэффициентов должно быть плотным (то есть должны храниться все коэффициенты, в том числе и промежуточные нулевые).</p>
    <p>Сделайте следующее:</p>
    <ol>
      <li>Напишите конструкторы, которые
        <ul>
          <li>создают многочлен по заданному вектору коэффициентов (коэффициенты задаются по возрастанию степени).</li>
          <li>создают многочлен по заданному коэффициенту (многочлен нулевой степени), который равен значению по умолчанию параметра шаблона.</li>
          <li>создают многочлен по заданным итераторам на начало и следующий за концом последовательности коэффициентов (аналогично, по возрастанию степени).</li>
        </ul>
      </li>
      <li>Перегрузите операторы == и !=. Ваш код должен быть очень простым. Операторы должны работать и в том случае, когда один из аргументов является скалярной величиной.</li>
      <li>Перегрузите операторы +, - и *, а также соответствующие операторы +=, -= и *=. Учтите, что должны быть определены и такие арифметические операции, в которых один из аргументов является скалярной величиной.</li>
      <li>Перегрузите оператор [] для получения коэффициента многочлена перед заданной степенью переменной. Достаточно константной версии этого оператора. Оператор должен работать для любых степеней (в том числе больше текущей максимальной). Напишите также метод Degree для вычисления степени многочлена (считайте, что у нулевого многочлена степень равна -1).</li>
      <li>Перегрузите оператор () для вычисления значения многочлена в точке. В качестве аргумента этот оператор принимает значение того типа, от которого создан многочлен. Постарайтесь написать эффективный код.</li>
      <li>Перегрузите оператор &lt;&lt; для печати многочлена в поток вывода. Для простоты будем выводить коэффициенты через пробел от старшей степени к младшей.</li>
      <li>Предусмотрите методы begin() и end() для доступа к константным итераторам, позволяющим перебрать коэффициенты многочлена (это могут быть просто итераторы вектора). При этом ведущие нули коэффициентами не считаются. Итерация должна происходить по возрастанию степени.</li>
    </ol>

    <p>Примечание</p>
    <p>В вашем решении должен быть только код класса и не должно быть функции main. При проверке наша программа будет использовать ваш класс Polynomial. Она сама прочитает из входного потока коэффициенты многочленов и выведет их сумму, разность, произведение и т. д.</p>
    <p>Обратите внимание, что если какой-то из операторов реализован в вашем решении, но при этом его вызов не компилируется (т. е. реализован неправильно), то вы будете получать не ошибку компиляции, а неправильный ответ, так как тестирующая программа доопределяет те операторы, вызов которых не компилируется.</p>
    <p>Вы можете считать, что шаблонный параметр — это числовой тип, для которого реализованы все арифметические операции, операции сравнения и вывод в поток. Также переменную этого типа можно сконструировать от int. Обратите внимание, что наличие неявного конструктора и оператора приведения типа не гарантируется: необходимо вызывать конструктор явно.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Для начала реализуем конструкторы класса:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

template &lt;typename T&gt;
class Polynomial {
public:
  using Container = typename std::vector&lt;T&gt;;
  using ConstIterator = typename Container::const_iterator;

private:
  Container coefficients;
  inline static const T valueTypeZero{0};

  void Normalize() {
    while (!coefficients.empty() && coefficients.back() == valueTypeZero) {
      coefficients.pop_back();
    }
  }

  Container& GetCoefficients() {
    return coefficients;
  }

public:
  Polynomial(const Container& coeffs)
    : coefficients{coeffs} {
    Normalize();
  }

  Polynomial(const T& value = {}) {
    if (value != valueTypeZero) {
      coefficients.push_back(value);
    }
  }

  template&lt;typename ForwardIt&gt;
  Polynomial(ForwardIt first, ForwardIt last)
    : coefficients{first, last} {
    Normalize();
  }

  const Container& GetCoefficients() const {
    return coefficients;
  }
</pre>

    <p>Для удобства будем удалять все нулевые коэффициенты с конца вектора. Для этого используем функцию Normalize (см. выше). Чтобы проверять, является ли элемент нулевым, создадим в классе приватное константное поле valueTypeZero типа T равное нулю. Ключевое слово static указывает, что новое поле относится к самому классу, а не к его объектам. Ключевое слово inline позволяет проинициализировать static-поле в момент определения (напоминаем, оно инициализируется нулём).</p>
    <p>Хранить же наши коэффициенты будем в векторе, где coefficients[i] будет значить, что мы смотрим на коэффициент перед xi. У вектора есть конструктор копирования, чем мы воспользуемся при реализации конструктора, который принимает вектор. Аналогично поступим с конструктором, который принимает два итератора. Конструктор, создающий многочлен по заданному коэффициенту будет добавлять в наш вектор этот самый коэффициент, только если он не ноль. Это позволяет лишний раз не вызывать Normalize().</p>
    <p>Также реализуем вспомогательные методы, которые будем использовать в дальнейшем: GetCoefficients() и GetCoefficients() const. Будем использовать эти методы для явного обращения к коэффициентам.</p>
    <p>Далее реализуем операторы == и !=:</p>
<pre>
friend bool operator == (const Polynomial&lt;T&gt;& lhs, const Polynomial&lt;T&gt;& rhs) {
  return lhs.GetCoefficients() == rhs.GetCoefficients();
}

friend bool operator != (const Polynomial&lt;T&gt;& lhs, const Polynomial&lt;T&gt;& rhs) {
  return !(lhs == rhs);
}
</pre>

  <p>У std::vector переопределён operator ==, чем мы и воспользуемся.</p>
  <p>Так как при декларации конструктора класса не используется ключевое слово explicit, операторы будут работать и в том случае, когда один из аргументов является скалярной величиной.</p>
  <p>Далее реализуем арифметические операции:</p>
<pre>
Polynomial&lt;T&gt;& operator += (const Polynomial&lt;T&gt;& other) {
  if (other.Degree() > Degree()) {
    GetCoefficients().resize(other.Degree() + 1);
  }

  for (int i = 0; i &lt;= Degree() && i &lt;= other.Degree(); ++i) {
    GetCoefficients()[i] += other.GetCoefficients()[i];
  }
  Normalize();
  return *this;
}

Polynomial&lt;T&gt;& operator -= (const Polynomial&lt;T&gt;& other) {
  if (other.Degree() > Degree()) {
    GetCoefficients().resize(other.Degree() + 1);
  }

  for (int i = 0; i &lt;= Degree() && i &lt;= other.Degree(); ++i) {
    GetCoefficients()[i] -= other.GetCoefficients()[i];
  }
  Normalize();
  return *this;
}

Polynomial&lt;T&gt;& operator *= (const Polynomial&lt;T&gt;& other) {
  if (Degree() == -1 || other.Degree() == -1) {
    GetCoefficients().resize(0);
    return *this;
  }

  std::vector&lt;T&gt; tmp(Degree() + other.Degree() + 1);
  for (int i = 0; i &lt;= Degree(); ++i) {
    for (int j = 0; j &lt;= other.Degree(); ++j) {
      tmp[i + j] += GetCoefficients()[i] * other.GetCoefficients()[j];
    }
  }
  GetCoefficients() = std::move(tmp);
  Normalize();
  return *this;
}
</pre>

    <p>Заметьте, что в реализации этих методов используется ещё нереализованный метод Degree(). Этот метод будет объявлен чуть позже (когда до него дойдёт очередь). Всё что нам надо знать сейчас – он возвращает степень полинома, а если полином равен нулю, то -1.</p>
    <p>Все три оператора изначально делают resize(), чтобы избежать неопределённое поведение, и согласно правилам математики складывают, вычитают или умножают два многочлена. При этом в умножении рассматривается отдельно краевой случай, когда один из полиномов равен нулю. После каждой операции вызываем функцию Normalize().</p>
<pre>
friend Polynomial&lt;T&gt; operator + (Polynomial&lt;T&gt; lhs, const Polynomial&lt;T&gt;& rhs) {
  return lhs += rhs;
}

friend Polynomial&lt;T&gt; operator - (Polynomial&lt;T&gt; lhs, const Polynomial&lt;T&gt;& rhs) {
  return lhs -= rhs;
}

friend Polynomial&lt;T&gt; operator * (Polynomial&lt;T&gt; lhs, const Polynomial&lt;T&gt;& rhs) {
  return lhs *= rhs;
}
</pre>

    <p>lhs будем принимать не по ссылке, а создавать копию на лету. Это позволит нам изменить и сразу же вернуть её, применив соответствующий оператор.</p>
    <p>Далее реализуем оператор [] и функцию Degree:</p>
<pre>
int Degree() const {
  return static_cast&lt;int&gt;(GetCoefficients().size()) - 1;
}

const T& operator [] (size_t power) const {
  if (static_cast&lt;int&gt;(power) > Degree()) {
    return valueTypeZero;
  }
  return GetCoefficients()[power];
}
</pre>

    <p>Обратите внимание, из-за того что мы в самом начале договорились не хранить незначащие нули в конце вектора, код функции Degree помещается в одну строчку. Действительно, в таком случае степенью многочлена будет являться длина вектора коэффициентов минус один.</p>
    <p>Далее реализуем оператор (). Воспользуемся для этого алгоритмом Горнера:</p>
<pre>
T operator () (const T& given_value) const {
  T result = valueTypeZero;

  for (auto i = Degree(); i >= 0; --i) {
    result *= given_value;
    result += GetCoefficients()[i];
  }

  return result;
}
</pre>

    <p>Проще говоря, для многочлена a1 + a2x + a3x² +...+ anxⁿ мы вынесем за скобки x везде, где это возможно. Получится следующее выражение a1 + x(a2 + x(a3 +...+ x(an-1anx)...)). Таким образом нужно просто реализовать цикл с умножением на заданную переменную и сложением со следующим коэффициентом.</p>
    <p>Реализация методов .begin и .end является тривиальной, поскольку мы можем вернуть итераторы самого вектора коэффициентов:</p>
<pre>
ConstIterator begin() const {
  return GetCoefficients().cbegin();
}

ConstIterator end() const {
  return GetCoefficients().cend();
}
};
</pre>

    <p>Оператор &lt;&lt; принято реализовывать вне класса. Тут всё просто, пробежим по всем степеням от последней к первой.</p>
<pre>
template&lt;typename T&gt;
std::ostream& operator&lt;&lt;(std::ostream& out, const Polynomial&lt;T&gt;& polynomial) {
  for (auto i = polynomial.Degree(); i >= 0; --i) {
    out &lt;&lt; polynomial[i];
    if (i != 0) {
      out &lt;&lt; ' ';
    }
  }
  return out;
}
</pre>
  </details>

  <h3>Параграф «Жизненный цикл объекта»</h3>

  <h4>Задача «Жизнь объекта - 0»</h4>

  <details>
    <summary>Условие</summary>
    <p>Вам дан готовый класс Logger, который в своих конструкторах, операторах присваивания и деструкторе печатает соответствующие сообщения:</p>
<pre>
#include &lt;iostream&gt;

class Logger {
private:
  static int counter;
  const int id;

public:
  Logger(): id(++counter) {
    std::cout &lt;&lt; "Logger(): " &lt;&lt; id &lt;&lt; "\n";
  }

  Logger(const Logger& other): id(++counter) {
    std::cout &lt;&lt; "Logger(const Logger&): " &lt;&lt; id &lt;&lt; " " &lt;&lt; other.id &lt;&lt; "\n";
  }

  Logger(Logger&& other): id(++counter) {
    std::cout &lt;&lt; "Logger(Logger&&): " &lt;&lt; id &lt;&lt; " " &lt;&lt; other.id &lt;&lt; "\n";
  }

  Logger& operator = (const Logger& other) {
    std::cout &lt;&lt; "Logger& operator = (const Logger&): " &lt;&lt; id &lt;&lt; " " &lt;&lt; other.id &lt;&lt; "\n";
    return *this;
  }

  Logger& operator = (Logger&& other) {
    std::cout &lt;&lt; "Logger& operator = (Logger&&): " &lt;&lt; id &lt;&lt; " " &lt;&lt; other.id &lt;&lt; "\n";
    return *this;
  }

  ~Logger() {
    std::cout &lt;&lt; "~Logger(): " &lt;&lt; id &lt;&lt; "\n";
  }
};

int Logger::counter = 0;
</pre>

    <p>Вам требуется написать программу, которая работает с этим классом и выводит следующий текст:</p>
<pre>
Logger(): 1
~Logger(): 1
Logger(): 2
~Logger(): 2
</pre>

    <p>Примечания</p>
    <p>Не вставляйте код класса в решение. Используйте вместо этого директиву #include "logger.h" в начале программы. Не пытайтесь вывести нужный текст с помощью непосредственной печати: мы при проверке всё равно заменяем отладочные сообщения в классе на свои.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Тут нужно создать два объекта и как-то искусственно ограничить жизнь второго. Это можно сделать несколькими способами:</p>
    <p>Например, использовать блоки:</p>
<pre>
#include "logger.h"

int main() {
  { Logger logger; }
  { Logger logger; }
}
</pre>

    <p>Также можно реализовать дополнительную функцию и вызвать её два раза:</p>
<pre>
#include "logger.h"

void CreateLogger() {
  Logger logger;
}

int main() {
  CreateLogger();
  CreateLogger();
}
</pre>
  </details>

  <h4>Задача «Жизнь объекта - 1»</h4>

  <details>
    <summary>Условие</summary>
    <p>В предыдущей задаче вам был дан готовый класс Logger, который в своих конструкторах, операторах присваивания и деструкторе печатает соответствующие сообщения.</p>
    <p>Вам требуется написать программу, которая работает с этим классом и выводит следующий текст:</p>
<pre>
Logger(): 1
Logger(const Logger&): 2 1
~Logger(): 2
~Logger(): 1
</pre>

    <p>Примечания</p>
    <p>Не вставляйте код класса в решение. Используйте вместо этого директиву #include "logger.h" в начале программы. Не пытайтесь вывести нужный текст с помощью непосредственной печати: мы при проверке всё равно заменяем отладочные сообщения в классе на свои.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>В этой задаче так же создаётся два объекта, но в этот раз вызывается конструктор копирования второго объекта от первого.</p>
<pre>
#include "logger.h"

int main() {
  Logger logger1;
  Logger logger2(logger1);  //  Можно записать иначе: Logger logger2 = logger1;
}
</pre>
  </details>

  <h4>Задача «Жизнь объекта - 2»</h4>

  <details>
    <summary>Условие</summary>
    <p>В предыдущей задаче вам был дан готовый класс Logger, который в своих конструкторах, операторах присваивания и деструкторе печатает соответствующие сообщения.</p>
    <p>Вам требуется написать программу, которая работает с этим классом и выводит следующий текст:</p>
<pre>
Logger(): 1
Logger(Logger&&): 2 1
~Logger(): 2
~Logger(): 1
</pre>

    <p>Примечания</p>
    <p>Не вставляйте код класса в решение. Используйте вместо этого директиву #include "logger.h" в начале программы. Не пытайтесь вывести нужный текст с помощью непосредственной печати: мы при проверке всё равно заменяем отладочные сообщения в классе на свои.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Полный аналог предыдущей задачи за исключением того, что вызывается не конструктор копирования, а move-конструктор:</p>
<pre>
#include &lt;utility&gt;

#include "logger.h"

int main() {
  Logger logger1;
  Logger logger2(std::move(logger1));  // Можно записать иначе: Logger logger2 = std::move(logger1);
}
</pre>
  </details>

  <h4>Задача «Жизнь объекта - 3»</h4>

  <details>
    <summary>Условие</summary>
    <p>В предыдущей задаче вам был дан готовый класс Logger, который в своих конструкторах, операторах присваивания и деструкторе печатает соответствующие сообщения.</p>
    <p>Вам требуется написать программу, которая работает с этим классом и выводит следующий текст:</p>
<pre>
1Logger(): 1
2Logger(): 2
3Logger& operator = (const Logger&): 1 2
4Logger& operator = (Logger&&): 1 2
5~Logger(): 2
6~Logger(): 1
</pre>

    <p>Примечания</p>
    <p>Не вставляйте код класса в решение. Используйте вместо этого директиву #include "logger.h" в начале программы. Не пытайтесь вывести нужный текст с помощью непосредственной печати: мы при проверке всё равно заменяем отладочные сообщения в классе на свои.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Давайте прочитаем требуемый вывод: создаётся два объекта, в первый копируется второй, в первый «перемещается» второй, вызываются деструкторы.</p>
    <p>Теперь давайте тоже самое запишем кодом, буквально слово в слово:</p>
<pre>
#include &lt;utility&gt;

#include "logger.h"

int main() {
  Logger logger1, logger2;
  logger1 = logger2;
  logger1 = std::move(logger2);
}
</pre>
  </details>

  <h4>Задача «Жизнь объекта - 4»</h4>

  <details>
    <summary>Условие</summary>
    <p>В предыдущей задаче вам был дан готовый класс Logger, который в своих конструкторах, операторах присваивания и деструкторе печатает соответствующие сообщения.</p>
    <p>Вам требуется написать программу, которая работает с этим классом и выводит следующий текст:</p>
<pre>
Logger(): 1
Logger(): 2
Logger(): 3
~Logger(): 2
~Logger(): 3
~Logger(): 1
</pre>

    <p>Примечания</p>
    <p>Не вставляйте код класса в решение. Используйте вместо этого директиву #include "logger.h" в начале программы. Не пытайтесь вывести нужный текст с помощью непосредственной печати: мы при проверке всё равно заменяем отладочные сообщения в классе на свои.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>В этой задаче важно было заметить, что второй и третий созданные объекты удаляются в противоположном порядке. Есть много способов получить такой порядок, самый простой, пожалуй, через указатели:</p>
<pre>
#include "logger.h"

int main() {
  Logger logger1;
  Logger* logger2 = new Logger;
  Logger* logger3 = new Logger;
  delete logger2;
  delete logger3;
}
</pre>

    <p>Так же можно было использовать какой-нибудь контейнер, например, std::list:</p>
<pre>
#include &lt;list&gt;

#include "logger.h"

int main() {
  Logger logger1;  // создаём первый объект
  std::list&lt;Logger&gt; loggers(2);  // создаём 2 и 3 объекты
  loggers.pop_front();  // уничтожаем второй объект
}
</pre>
  </details>

  <h4>Задача «Жизнь объекта - 5»</h4>

  <details>
    <summary>Условие</summary>
    <p>В предыдущей задаче вам был дан готовый класс Logger, который в своих конструкторах, операторах присваивания и деструкторе печатает соответствующие сообщения.</p>
    <p>Вам требуется написать программу, которая работает с этим классом и выводит по заданному n следующий текст:</p>
<pre>
Logger(): 1
Logger(): 2
...
Logger(): n
~Logger(): n
...
~Logger(): 2
~Logger(): 1
</pre>

  <p>Примечания</p>
  <p>Не вставляйте код класса в решение. Используйте вместо этого директиву #include "logger.h" в начале программы. Не пытайтесь вывести нужный текст с помощью непосредственной печати: мы при проверке всё равно заменяем отладочные сообщения в классе на свои.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Тут так же было можно пойти несколькими путями, наилучший, на наш взгляд, был через вектор:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

#include "logger.h"

int main() {
  size_t n = 0;
  std::cin >> n;

  std::vector&lt;Logger&gt; loggers(n);
  for (size_t i = 0; i != n; ++i) {
    loggers.pop_back();
  }
}
</pre>

    <p>Некоторые, эксперементируя локально, могли получать искомый ответ при примерно такой версии кода:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

#include "logger.h"

int main() {
  size_t n = 0;
  std::cin >> n;
  std::vector&lt;Logger&gt; loggers(n);
}
</pre>

    <p>Но в тесты этот код не проходит. Дело в том, что порядок удаления элементов в векторе в деструкторе не детерминирован и может разниться от реализации к реализации. В контесте это прямой порядок, где-то он может быть обратным (и, вообще говоря, любым).</p>
  </details>

  <h4>Задача «Жизнь объекта - 6»</h4>

  <details>
    <summary>Условие</summary>
    <p>В предыдущей задаче вам был дан готовый класс Logger, который в своих конструкторах, операторах присваивания и деструкторе печатает соответствующие сообщения.</p>
    <p>Вам требуется написать программу, которая работает с этим классом и выводит по заданному n следующий текст:</p>
<pre>
Logger(): 1
Logger(): 2
...
Logger(): n
~Logger(): 1
~Logger(): 2
...
~Logger(): n
</pre>

    <p>Примечания</p>
    <p>Не вставляйте код класса в решение. Используйте вместо этого директиву #include "logger.h" в начале программы. Не пытайтесь вывести нужный текст с помощью непосредственной печати: мы при проверке всё равно заменяем отладочные сообщения в классе на свои.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Задачу можно было решать через любой известный контейнер двумя способами: через указатели:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

#include "logger.h"

int main() {
  size_t n = 0;
  std::cin >> n;

  std::vector&lt;Logger*&gt; pointers(n);
  for (size_t i = 0; i != n; ++i) {
    pointers[i] = new Logger;
  }

  for (size_t i = 0; i != n; ++i) {
    delete pointers[i];
  }
}
</pre>

    <p>Но в указателях особо не было смысла, так как у нас есть контейнеры, которые поддерживают удаление из начала, например, std::list:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;list&gt;

#include "logger.h"

int main() {
  size_t n = 0;
  std::cin >> n;

  std::list&lt;Logger&gt; loggers(n);
  for (size_t i = 0; i != n; ++i) {
    loggers.pop_front();
  }
}
</pre>
  </details>

  <h4>Задача «TimerGuard»</h4>

  <details>
    <summary>Условие</summary>
    <p>Вася хочет замерять время работы разных частей своей программы. Сейчас он делает это средствами стандартной библиотеки так:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;chrono&gt;

#include "some_long_stuff.h"

void SomeFunc() {
  auto start1 = std::chrono::high_resolution_clock::now();
  FirstLongFunction();
  std::chrono::duration&lt;double&gt; diff1 = std::chrono::high_resolution_clock::now() - start1;
  std::cout &lt;&lt; "FirstLongFunction elapsed: " &lt;&lt; diff1.count() &lt;&lt; "\n";

  auto start2 = std::chrono::high_resolution_clock::now();
  SecondLongFunction();
  std::chrono::duration&lt;double&gt; diff2 = std::chrono::high_resolution_clock::now() - start2;
  std::cout &lt;&lt; "SecondLongFunction elapsed: " &lt;&lt; diff2.count() &lt;&lt; "\n";

  auto start3 = std::chrono::high_resolution_clock::now();
  ThirdLongFunction();
  std::chrono::duration&lt;double&gt; diff3 = std::chrono::high_resolution_clock::now() - start3;
  std::cout &lt;&lt; "ThirdLongFunction elapsed: " &lt;&lt; diff3.count() &lt;&lt; "\n";
}

int main() {
  SomeFunc();
  return 0;
}
</pre>

    <p>Но ему очень не удобно каждый раз прописывать начало замера и конец. Помогите ему сделать это удобнее.</p>
    <p>Напишите обёртку TimerGuard. Это класс, который создается перед началом вычислений и при выходе из своего scope пишет в поток время работы, которое он существовал. С его помощью Вася сможет писать так:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;chrono&gt;

#include "some_long_stuff.h"

void SomeFunc() {
  {
    TimerGuard timer("FirstLongFunction elapsed: ", std::cout);
    FirstLongFunction();
  }
  {
    TimerGuard timer("SecondLongFunction elapsed: ", std::cout);
    SecondLongFunction();
  }
  {
    TimerGuard timer("ThirdLongFunction elapsed: ", std::cout);
    ThirdLongFunction();
  }
}

int main() {
  SomeFunc();
  return 0;
}
</pre>

    <p>Класс TimerGuard должен содержать следующий конструктор:</p>
    <code>TimerGuard(std::string message = "", std::ostream& out = std::cout);</code>
    <p>message — сообщение, печатаемое перед перед временем. out — поток, в который нужно печатать сообщение.</p>
    <p>Деструктор класса должен печатать сообщение в формате "{message} {time}" (обратите внимание на пробел).</p>

    <p>Примечания</p>
    <p>Сдайте в систему только код конструкции TimerGuard без функции main. Подключите необходимые библиотеки.</p>
    <p>Обратите внимание, что данный guard очень полезен даже вне этой задачи. Его можно использовать при отладке медленных участков вашей программы!</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>В блоках Васи TimerGuard дёргается два раза — при создании (конструктор) и при выходе из блока (деструктор). Так что давайте напишем класс, который при создании будет запоминать все необходимые переменные в поля класса, а в деструкторе выводить их:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;chrono&gt;
#include &lt;string&gt;

class TimerGuard {
  std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt; start;
  std::string outMessage;
  std::ostream& outStream;
public:

  TimerGuard(std::string message = "", std::ostream& out = std::cout):
    start(std::chrono::high_resolution_clock::now()),  // start - вызов конструктора
    outMessage(message),
    outStream(out)
  {
  }

  ~TimerGuard() {
    auto end = std::chrono::high_resolution_clock::now();  // конец - вызов деструктора
    std::chrono::duration&lt;double&gt; diff = end - start;
    outStream &lt;&lt; outMessage &lt;&lt; " " &lt;&lt; diff.count() &lt;&lt; "\n";
  }
};
</pre>
  </details>

  <h3>Параграф «Наследование и полиморфизм»</h3>

  <h4>Задача «Периметр фигуры»</h4>

  <details>
    <summary>Условие</summary>
    <p>Вам надо написать базовый класс Figure (геометрическая фигура) и унаследованные от него классы Triangle (треугольник) и Rectangle (прямоугольник).</p>
    <p>Класс Triangle должен иметь конструктор, принимающий на вход три числа типа int — стороны треугольника. Считайте, что треугольник с такими сторонами всегда существует.</p>
    <p>Класс Rectangle должен иметь конструктор, принимающий на вход два числа типа int — стороны прямоугольника.</p>
    <p>Класс Figure должен объвлять виртуальную функцию int Perimeter() const, возвращающую периметр фигуры.</p>
    <p>Классы-наследники должны переопределить эту функцию правильным образом.</p>
    <p>Функцию main писать в вашем коде не надо: она будет в нашей проверяющей программе. Наша программа выглядит так:</p>
<pre>
#include "figures.h"

#include &lt;vector&gt;
#include &lt;iostream&gt;

int main() {
  std::vector&lt;Figure*&gt; figures;

  std::string type;

  while (std::cin >> type) {
    if (type == "Triangle") {
      int a, b, c;
      std::cin >> a >> b >> c;
      figures.push_back(new Triangle(a, b, c));
    } else if (type == "Rectangle") {
      int a, b;
      std::cin >> a >> b;
      figures.push_back(new Rectangle(a, b));
    }
  }

  for (Figure* f : figures) {
    std::cout &lt;&lt; f->Perimeter() &lt;&lt; "\n";
  }

  for (Figure* f : figures) {
    delete f;
  }
}
</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Видно, что работа с объектами будет производиться полиморфно, через указатель на базовый класс Figure. В частности, фигуры будут удаляться через вызов delete f, где f имеет тип Figure*. Чтобы это корректно работало, в базовом классе нужно предусмотреть виртуальный деструктор.</p>
<pre>
class Figure {
public:
  virtual int Perimeter() const = 0;

  virtual ~Figure() {
  }
};


class Triangle: public Figure {
  int A, B, C;

public:
  Triangle(int x, int y, int z): A(x), B(y), C(z) {
  }

  int Perimeter() const override {
    return A + B + C;
  }
};


class Rectangle: public Figure {
  int A, B;

public:
  Rectangle(int a, int b): A(a), B(b) {
  }

  int Perimeter() const override {
    return 2 * (A + B);
  }
};
</pre>
  </details>

  <h4>Задача «Notifications»</h4>

  <details>
    <summary>Условие</summary>
    <p>Вам даны функции SendSms и SendEmail, которые «умеют» отправлять сообщения:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

void SendSms(const std::string& number, const std::string& message) {
  std::cout &lt;&lt; "Send '" &lt;&lt; message &lt;&lt; "' to number " &lt;&lt; number &lt;&lt; std::endl;
}

void SendEmail(const std::string& email, const std::string& message) {
  std::cout &lt;&lt; "Send '" &lt;&lt; message &lt;&lt; "' to e-mail "  &lt;&lt; email &lt;&lt; std::endl;
}

// Ваш код будет вставлен здесь:
#include "your_solution.h"

// Реализуйте в вашем решении классы NotifierBase, SmsNotifier и EmailNotifier,
// чтобы следующий код заработал как ожидается:

void Notify(const NotifierBase& notifier, const std::string& message) {
  notifier.Notify(message);
}

int main() {
  SmsNotifier sms("+7-495-777-77-77");
  EmailNotifier email("na-derevnyu@dedushke.ru");

  Notify(sms, "Hello! How are you?");
  Notify(email, "Let's learn C++!");
  return 0;
}
</pre>

    <p>Вам нужно написать классы SmsNotifier и EmailNotifier, унаследованные от базового класса NotifierBase и переопределяющие функцию Notify, чтобы приведённый код заработал. Функция Notify в этих классах должна вызывать данные вам функции SendSms или SendEmail.</p>
    <p>Примечания</p>
    <p>Сдайте в систему только код классов без функции main и без уже написанных функций. Подключите все необходимые для вашей реализации библиотеки.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>NotifierBase — родительский абстрактный класс, который не должен содержать функционала, у него должны быть виртуальные метод Notify и деструктор.</p>
    <p>SmsNotifier и EmailNotifier наследуются от него и в переопределениях Notify вызывают соответствующие функции:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

class NotifierBase {
public:
  virtual void Notify(const std::string& message) const = 0;
  virtual ~NotifierBase() {}
};

class SmsNotifier : public NotifierBase {
public:
  SmsNotifier(const std::string& number)
    : Number(number) {}

  virtual void Notify(const std::string& message) const override {
    SendSms(Number, message);
  }

private:
  const std::string Number;
};

class EmailNotifier : public NotifierBase {
public:
  EmailNotifier(const std::string& email)
    : Email(email) {}

  virtual void Notify(const std::string& message) const override {
    SendEmail(Email, message);
  }

private:
  const std::string Email;
};
</pre>
  </details>

  <h4>Задача «JSON»</h4>

  <details>
    <summary>Условие</summary>
    <p>Данные часто нужно сериализовывать, то есть превращать в строку. Это нужно для сохранения на диске, для отправки по сети, для передачи другому процессу. Часто для этого используются несколько общепринятых форматов данных, таких как JSON, YAML, XML. Поскольку на этапе компиляции не всегда известно, в каком именно формате надо сериализовывать данные, часто приходится прибегать к наследованию. Вам необходимо реализовать класс Serializer с чисто виртуальными методами:</p>
<pre>
void BeginArray()
void AddArrayItem(const std::string &)
void EndArray()
</pre>

    <p>После этого унаследуйте от него класс JsonSerializer, определив все эти методы.</p>
    <p>JsonSerializer должен печатать упрощенную версию JSON (https://ru.wikipedia.org/wiki/JSON), состояющую только из массивов и строк. Массив начинается с квадратной скобки. После каждого элемента, кроме последнего, должна стоять запятая. Заканчивается массив квадратной скобкой. Все строки должны быть взяты в двойные кавычки. Гарантируется, что все строки состоят только из латинских символов и пробелов, поэтому экранировать их не надо.</p>
    <p>Сдайте в систему только код классов, без функции main. Для полной ясности формата вывода посмотрите на примеры из условия.</p>

    <h4>Пример 1</h4>
<pre>
BeginArray
EndArray
</pre>
    <code>[]</code>

    <h4>Пример 2</h4>
<pre>
BeginArray
AddArrayItem second
EndArray
</pre>
    <code>["second"]</code>

    <h4>Пример 3</h4>
<pre>
BeginArray
AddArrayItem first
AddArrayItem second
EndArray
</pre>
    <code>["first","second"]</code>

    <p>Примечания</p>
    <p>Не надо определять для вашего класса operator &lt;&lt;. Печать должна происходить в функциях, указанных в условии. Мы будем работать с экземпляром вашего класса JsonSerializer полиморфно, через указатель на базовый класс Serializer. Поэтому не забудьте про виртуальный деструктор.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Из примеров понятна проблема — она кроется в запятой, которую непонятно когда ставить. Определим приватное поле isFirst. Оно будет указывать, первый ли элемент мы добавляем, и не важно, что тут назвать элементом — Array или Item. Если мы завершаем Array, то isFirst устанавливаем на false, потому что следующий элемент уже не будет первым. Аналогично с AddArrayItem. И лишь в случае BeginArray мы не должны рисовать никаких запятых. Дефолтно поле выставляем на true, так как первый Array действительно будет первым:</p>
<pre>
#include &lt;vector&gt;
#include &lt;iostream&gt;

class Serializer {
public:
  virtual void BeginArray() = 0;
  virtual void AddArrayItem(const std::string &s) = 0;
  virtual void EndArray() = 0;
  virtual ~Serializer() {}
};

class JsonSerializer : public Serializer {
public:
  void BeginArray() override {
    if (!isFirst) {
      std::cout &lt;&lt; ",[";
    } else {
      std::cout &lt;&lt; "[";
    }

    isFirst = true;
  }

  void AddArrayItem(const std::string& str) override {
    if (!isFirst) {
      std::cout &lt;&lt; ",";
    }
    std::cout &lt;&lt; "\"" &lt;&lt; str &lt;&lt; "\"";
    isFirst = false;
  }

  void EndArray() override {
    std::cout &lt;&lt; "]";
    isFirst = false;
  }

private:
  bool isFirst = true;
};
</pre>
  </details>

  <h4>Задача «AdvancedVector»</h4>

  <details>
    <summary>Условие</summary>
    <p>Реализуйте класс AdvancedVector. Продвинутый вектор отличается от обычного тем, что позволяет обращаться по отрицательным индексам к элементам вектора в обратном порядке ( прямо как в Python). Например, vec[-1] возвращает последний элемент, vec[-2] возвращает предпоследний и так далее.</p>
    <p>Класс AdvancedVector должен хранить элементы шаблонного типа T. Требуемый функционал не сильно отличается от стандартного std::vector:</p>
    <ol>
      <li>Класс должен называться AdvancedVector.</li>
      <li>У класса должен быть шаблонный параметр T — тип элементов.</li>
      <li>У класса должен быть конструктор по умолчанию.</li>
      <li>У класса должен быть конструктор копирования (возможно, предоставленный компилятором).</li>
      <li>У класса должен быть шаблонный конструктор, принимающий два итератора и заполняющий вектор из данного диапазона.</li>
      <li>У класса должен быть оператор присваивания (возможно, предоставленный компилятором).</li>
      <li>У класса должны быть операторы сравнения == и !=.</li>
      <li>У класса должны быть константные функции empty() и size().</li>
      <li>У класса должны быть функции pop_back() и push_back(const T&).</li>
      <li>У класса должны быть константная и неконстантная версии оператора [].</li>
    </ol>

    <p>В случае положительного индекса нужно вернуть элемент с соответствующим индексом, если он меньше размера вектора. Иначе нужно бросить исключение std::out_of_range. В случае отрицательного индекса нужно вернуть элемент с соответствующим индексом, предполагая, что последний элемент имеет номер -1, предпоследний -2 и так далее. Но только пока модуль индекса не превосходит size(). Если же std::abs(index) > size, то нужно бросить исключение std::out_of_range.</p>

    <h4>Формат ввода</h4>
    <p>Гарантируется, что передаваемый в operator [] индекс лежит в отрезке [-10⁹; 10⁹].</p>

    <p>Примечания</p>
    <p>Сдайте в систему только код класса AdvancedVector без функции main. Подключите все необходимые для вашей реализации библиотеки.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Можно было бы написать класс, в котором будет использоваться композиция со стандартным вектором:</p>
<pre>
#include &lt;vector&gt;

template &lt;typename T&gt;
class AdvancedVector {
private:
  std::vector&lt;T&gt; data;

public:
  // ...
};
</pre>

    <p>Однако в таком классе пришлось бы заново определять все публичные операторы и функции, такие как size, empty, push_back и т. д. Попробуем поступить иначе: воспользуемся наследованием от std::vector&lt;T&gt;. В таком случае будет достаточно переопределить лишь оператор [], а также шаблонный конструктор и конструктор по умолчанию. Все остальные операторы и функции будут автоматически унаследованы от вектора.</p>
<pre>
#include &lt;cstdint&gt;
#include &lt;vector&gt;

template &lt;typename T&gt;
class AdvancedVector: public std::vector&lt;T&gt; {
public:
  AdvancedVector() = default;

  template &lt;typename Iter&gt;
  AdvancedVector(Iter first, Iter last): std::vector&lt;T&gt;(first, last) {
  }

  const T& operator [](std::int64_t i) const {
    if (i &lt; 0) {
      i += this->size();
    }
    return this->at(i);
  }

  T& operator [](std::int64_t i) {
    if (i &lt; 0) {
      i += this->size();
    }
      return this->at(i);
    }
};
</pre>

    <p>В этом решении есть одна особенность. Базовый класс зависит от неизвестного заренее шаблонного параметра. Поэтому вызов функций базового класса требуется явно предварять либо префиксом с именем базового класса std::vector&lt;T&gt;::, либо конструкцией this->. Это позволит компилятору отложить поиск этого имени до момента инстранцирования шаблона с конкретным типом T.</p>
    <p>Обратите внимание на реализацию оператора []. Идея в том, чтобы получить настоящий индекс элемента, а затем вызвать унаследованную от вектора функцию at. Эта функция делает проверку корректности аргумента: он должен быть меньше размера контейнера. В случае некорректного значения она сама сгенерирует требуемое исключение std::out_of_range.</p>
    <p>Функция at принимает беззнаковый аргумент типа size_t. Если в неё передать знаковый тип, то произойдёт неявное преобразование. Например, если size_t занимает 8 байт (64 бита), то отрицательный аргумент i будет преобразован в 2⁶⁴-i. Покажите самостоятельно, что если после прибавления size() индекс i остался отрицательным, то аргумент функции at всё равно будет некорректным.</p>
    <p>В решении реализованы две версии оператора [] — константная и неконстантная. Они отличаются лишь версиями функции at, которая в векторе тоже перегружена по константности.</p>
  </details>

  <h4>Задача «Жизнь объекта с наследованием»</h4>
</article>


<!-- 5.1 Как работать с системой проверки заданий -->
<article class="article">
  <div class="anchor" id="p5.1"></div>
  <h2>5 Приложение</h2>
  <h3>5.1 Как работать с системой проверки заданий</h3>
</article>


<!-- 5.2 Как пользоваться хендбуком -->
<article class="article">
  <div class="anchor" id="p5.2"></div>
  <h3>5.2 Как пользоваться хендбуком</h3>
</article>

