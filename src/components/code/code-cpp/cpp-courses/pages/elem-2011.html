<article class="article">
  <h1>2011 Евгений Линский - Основы C++ 1 семестр</h1>
  <p>Конспект видео курса</p>
  <p>12 уроков. Длительность 16ч 22м.</p>
</article>


<!-- Содержание -->
<article class="article">
  <h3>Содержание</h3>

  <p><a href="#p1">Урок 1</a></p>
  <p><a href="#p2">Урок 2</a></p>
  <p><a href="#p3">Урок 3</a></p>
  <p><a href="#p4">Урок 4</a></p>
  <p><a href="#p5">Урок 5</a></p>
  <p><a href="#p6">Урок 6</a></p>
  <p><a href="#p7">Урок 7</a></p>

</article>


<!-- Урок 1 -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Урок 1</h3>

  <p>Язык C++ появился после языка C для того чтобы большие программы можно было писать удобно.</p>

  <h4>Библиотека STL</h4>
  <p>Программисту при написании программ требуется набор стандартных компонентов. Например, компонент для хранения данных. А именно деревья, связанные списки, динамические массивы. Это сложные структуры данных. Чтобы каждый раз не изобретать велосипед и не писать эти компоненты самому с нуля, они включены в стандартную библиотеку.</p>

  <h3>Тема 1. Программа, состоящая из нескольких файлов</h3>

  <p>Для начала немного истории. В 1970 году в Bell Labs Кен Томпсон и Ден Ритчи решают задачу написать переносимую операционную систему. Было несколько моделей компьютеров с разным набором регистров, которые по разному назывались. Для этой цели они разработали язык Си, а операционная система называлась Unix.</p>
  <p>К языку Си предъявлялись требования: он должен быть таким же эффективным как язык ассемблера, на нем должно быть более удобно программировать чем на языке ассемблера, должна быть переносимость на уровне исходных текстов программ. Это значит что для каждой новой платформы достаточно написать компилятор языка Си и тогда на ней можно написать все программы на языке Си, которые уже были написаны для других платформ.</p>
  <p>Язык ассемблера близок машинному коду. Нет переносимости исходных текстов программ на языке ассемблера и на языке машинного кода.</p>
  <p>В 1980 году в Bell Labs Бьерн Страуструп на основе языка Си предложил новый язык, который он назвал Си с классами или C++. Необходимость нового языка была обусловлена необходимостью программистам работать с большими базами данных.</p>
  <p>Минимальная программа в файле main.c</p>
<pre>
int main() {
  return 0;
}
</pre>
  <p>Все домашние задания я попрошу вас делать в операционно системе Linux на компиляторе gcc. При этом не пользуясь средами разработки. Самый простой вариант поставить систему Ubuntu 10.04. Второй вариант поставить виртуальную машину VirtualBox. И для нее найти виртуальную машину уже с поставленной Ubuntu.</p>
  <p>Иногда нужно запустить несколько команд. Это делается с помощью скриптов командной оболочки. Это языки сценариев. Под линуксом самый популярный язык сценариев это bash. Под windows это bat файлы. Из сценария можно запустить программу и посмотреть какой результат она вернет операционной системе. Это может использоваться для контроля за ошибками.</p>
  <p>Скомпилируем программу в файле main.c</p>
  <code>gcc main.c</code>
  <p>В результате рядом с файлом main.c появится файл a.out. Мы можем скомпилировать программу так, чтобы появился файл с именем main</p>
  <code>gcc main.c -o main</code>
  <p>Запустим программу</p>
  <code>./main</code>
  <p>Операционная система Windows и Linux по разому ищут файл, который нужно запустить. По умолчанию Windows сначала ищет файл в текущей директории ./, затем в директориях, указанных в системной переменной PATH. По умолчанию Linux сначала ищет файл в директориях /bin, /sbin, /usrbin? Затем в директориях, указанных в системной переменной PATH. Поэтому, когда мы запускаем файл ".main" мы явно говорим операционной системе, что запускать нужно программу из текущей директории.</p>

  <p>Пусть в программе будет два файла main.c и hello.c.</p>

  <p>Файл main.c</p>
<pre>
int main() {
  hello();
  return 0;
}
</pre>

  <p>Файл hello.c</p>
<pre>
#include &lt;stdio.h&gt;

void hello() {
  printf("Hello!");
}
</pre>

  <p>Причина разбиения программы на несколько файлов:</p>
  <ol>
    <li>Абстракция. При создании большой системы хочется выделять отдельные чисти и забывать как они устроены внутри. Создавать систему из черных ящиков.</li>
    <li>Независимость. Над разными файлами могут работать разные программисты.</li>
    <li>Быстрая компиляция.</li>
  </ol>

  <p>Один из дистрибутивов лиукс называется Gentoo. В нем мало что делается автоматически и все приходится делать руками. Его автор Дэниел Роббинс написал очень хорошую книгу Основы Linux от основателя Gentoo.</p>

  <p>Чтобы скомпилировать программу, состоящую из двух файлов main.c и hello.c нужно выполнить команду</p>
  <code>gcc main.c hello.c -o main</code>

  <p>Вот что происходит:</p>
  <ol>
    <li>
      <p><strong>Компиляция</strong>. Каждый файл компилируется отдельно от остальных. Из языка Си в ассемблер, из ассемблера в машинный код. Вместе с компиляцией происходит <strong>оптимизация</strong> для того чтобы программа занимала меньше места и выполнялась быстрее.</p>
      <p>В результате компиляции вместо каждого файла .c поясляются объектные файлы .o. То есть main.o и hello.o.</p>
      <p>Все инструкции языка Си заменяются на машинные коды, кроме вызовов функций. Вызов функции hello() заменяется на инструкцию "вызови функцию hello". А вызов функции printf() заменается на инструкцию "вызови функцию printf". На ассемблере вызов функции это инструкция call.</p>
      <p>Что происходит, когда мы запускаем программу? Операционная система записывает программу в оперативную память и передает процессору адрес первой инструкции. Процессор начинает по очереди выполнять инструкции программы. Программа занимает в памяти множество блоков, каждый блок соответствует функции.</p>
      <p>Программа всегда начинается с функции main, с первой инструкции. Когда процессор дойдет до вызова функции hello(), ему нужно в памяти перейти на начало функции hello(). Он не знает, что такое функция hello(). Он видит инструкцию "выполни код по адресу 0xFFFFF". Процессор выполняет код по адресу 0xFFFFF (функцию hello()), а потом возвращается обратно.</p>
      <p>Компиляция это сложный процесс, который занимает много времени.</p>
    </li>
    <li>
      <p><strong>Линковка</strong>. Собирает из отдельных объектных файлов с машинным кодом один исполняемый файл, соединить все блоки вместе один под другим и выполнить разрешение адресов. Именно при разрешении адресов происходит замена с "вызови функцию hello()" на "выполняй инструкции с адреса 0xFFFFF". Адреса функций вычисляются относительно адреса функции main.</p>
      <p>Линковка это очень простой процесс и занимает немного времени.</p>
    </li>
  </ol>

  <h4>Плюс раздельной компиляции</h4>
  <p>Проведем отдельно компиляцию и линковку программы. Сначала выполним компиляцию</p>
  <code>gcc -c main.c</code>
  <code>gcc -c hello.c</code>
  <p>После компиляции создадутся объектные файлы main.o и hello.c. А затем выполним линковку</p>
  <code>gcc main.o hello.o -o main</code>
  <p>Когда программа разбита на много файлов, то при изменении только одного файла, нужно будет перекомпилировать только один файл и сделать линковку всей программы. Поскольку компиляция это долгий процесс, а линковка недолгий, то перекомпиляция при этом займет меньше времени, чем если бы вся программа была написана в одном файле.</p>

  <h4>Минус раздельной компиляции</h4>
  <p>Если нужно не просто поменять код внутри функции, но поменять и сигнатуру.</p>

  <p>Файл hello.c</p>
<pre>
#include &lt;stdio.h&gt;

void hello(int n) {
  printf("%d", n);
}
</pre>

  <p>При компиляции ошибки не будет</p>
  <code>gcc -c hello.c</code>
  <p>Но при линковке выскочит ошибка что вызов функции hello() из функции main() не соответсвтует сигнатуре самой функции.</p>
  <p>Для решения этой проблемы используют заголовочные файлы.</p>

  <h4>Заголовочные файлы</h4>
  <p>Разделим функцию на две части: объявление и определение.</p>
  <p>Объявление (declaration) это сигнатура функции. Возвращаемое значение, имя функции, число и тип параметров.</p>
  <p>Определение (definition) это все то что пишут при объявлении плюс имена параметров и код функции.</p>
  <p>Теперь поместим объявление функции hello() во всех файлах, где упоминается функция hello().</p>

  <p>Файл main.c</p>
<pre>
void hello(int);

int main() {
  hello();
  return 0;
}
</pre>

  <p>Файл hello.c</p>
<pre>
#include &lt;stdio.h&gt;
void hello(int);

void hello(int n) {
  printf("%d", n);
}
</pre>

  <p>Теперь в файле hello.c компилятор проконтролирует соответствие между объявлением и определением функции hello(). Если они не совпадают, то выдаст ошибку.</p>
  <p>В файле main.c компилятор проконтролирует соответствие между объявлением и вызовом функции hello(). Если они не совпадают, то выдаст ошибку.</p>
  <p>Если программист изменит объявление и определение функции в одном файле, но забудет изменить объявление в другом, то компилятор не найдет ошибку, но ошибка выскочит во время линковки.</p>
  <p>На этом этапе наша проблема еще не решена.</p>

  <p>Чтобы решить проблему, нужно в программе иметь только одно объявление функции. Такое объявление выносится в отдельный файл. Такой файл называется <strong>заголовочный</strong>.</p>
  <p>Теперь программа будет состоять из трех файлов main.c, hello.h, hello.c</p>

  <p>Файл hello.h</p>
<pre>
void hello(int);
</pre>

  <p>Файл main.c</p>
<pre>
#include "hello.h"

int main() {
  hello();
  return 0;
}
</pre>

  <p>Файл hello.c</p>
<pre>
#include &lt;stdio.h&gt;
#include "hello.h"

void hello(int n) {
  printf("%d", n);
}
</pre>

  <p>#include это директива препроцессора. Препроцессор вставляет на мето этой директивы содержимое файла hello.h. Одно и то же объявление теперь вставляется и в файл main.c и в файл hello.c. В файле main.c проверяется соответствие между объявлением и вызовом функции. В файле hello.c проверяется соответствие между объявлением и определением функции.</p>
  <p>Теперь наша проблема решена.</p>
  <p>printf это функция стандартной библиотеки языка Си.</p>
  <p>stdio.h это заголовочный файл стандартной библиотеки языка Си.</p>
  <p>libc это стандартная библиотека языка Си.</p>
  <p>stl это стандартная библиотека языка C++.</p>

  <p>Обозначим еще две проблемы</p>
  <ol>
    <li>Почему нельзя сразу включить файл hello.c в файл main.c? Почему мы должны делать отдельный заголовочный файл и включать его?</li>
    <li>Если два файла a.c и b.c используют функции друг из друга, то при подключении их с помощью #include, файлы будут бесконечно вставляться один в другой.</li>
  </ol>

  <p>Рассмотрим сначала первую проблему. Пусть у нас есть файл hello.c, содержащий функцию hello(). И есть два файла main.c и util.c, которым нужен доступ к функции hello(). Если мы в каждый файл включим hello.c</p>
  <p>Файл hello.c</p>
  <code>void hello(int);</code>
  <p>Файл main.c</p>
  <code>#include "hello.c"</code>
  <p>Файл util.c</p>
  <code>#include "hello.c"</code>
  <p>Проходя по первому файлу main.c компилятор создаст первую копию функции hello() в памяти. Проходя по второму файлу util.c компилятор создаст вторую копию функцию hello() в памяти. Линковщик не знает на какой адрес настраивать вызов функции hello() и выдаст ошибку. В программе не может быть две функции с одинаковым именем в одной области видимости.</p>

  <p>Рассмотрим вторую проблему.</p>
  <p>Файл a.h</p>
  <code>#include "b.h"</code>
  <p>Файл b.h</p>
  <code>#include "a.h"</code>
  <p>Вставим директивы условной компиляции.</p>

  <p>Файл a.h</p>
<pre>
#ifndef _a_h_
#define _a_h_
#include "b.h"
#endif
</pre>

  <p>Файл b.h</p>
<pre>
#ifndef _b_h_
#define _b_h_
#include "a.h"
#endif
</pre>
</article>


<!-- Урок 2 -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>Урок 2</h3>

  <h4>Makefile</h4>
  <p>С помощью gcc каждый этап компиляции можно запустить по отдельности.</p>
  <p>Запустить только препроцессор. Преобразует текстовый файл .c в текстовый файл .c, обрабатывая директивы препроцессора.</p>
  <code>gcc -E</code>
  <p>Запустить только компилятор. Преобразует текстовый файл .c в объектный файл .o на языке ассемблера.</p>
  <code>gcc -c</code>
  <p>Запустить только компилятор. Преобразует объектный файл .o на языке ассемблера в исполняемый файл .out на машинных кодах.</p>
  <code>gcc -s</code>
  <p>Если мы какой-то файл поменяли, то нет смысла заново компилировать все файлы. Достаточно скомпилировать измененный файл и провести затем компоновку и линковку. Но каждый раз помнить какие файлы поменялись, а какие нет это очень тяжело. Поэтому хотелось бы иметь какую-то утилиту, которая бы за нас следила за всеми изменениями.</p>
  <p>Пусть у нас есть файл main.cpp, который использует функции из файла util.cpp, объявленные в util.h и функции из файла str.cpp, объявленные в str.h.</p>
  <p>Рассмотрим зависимости. Файл main.o зависит от файлов main.cpp, util.h, str.h. Это значит, что требуется перекомпилировать файл main.o если изменится один из этих трех файлов.</p>
  <p>Файл util.o зависит от файлов util.cpp и util.h.</p>
  <p>Файл str.o зависит от файлов str.cpp и str.h.</p>
  <p>Исполняемый файл main.out зависит от файлов main.o, util.o, str.o.</p>
  <p><strong>Makefile</strong> это текстовый файл, в котором записана вся информация о зависимостях. То есть какие файлы от каких зависят. Если какой-то файл поменялся, то нужна инструкция что и как нужно перекомпилировать. Makefile обрабатывает утилита <strong>make</strong>.</p>
  <p>Если вызвать утилиту make в директории, в которой содержится файл Makefile, утилита make начнет обрабатывать этот файл. Сначала она выяснит что же поменялось. Потом выполнит необходимые инструкции.</p>
  <p>Напишем Makefile для этого примера. Сначала пишется цель, потом двоеточие, потом файлы от которых зависит цель. На новой строчке после знака табуляции пишутся инструкции. Каждая инструкция отделяется от другой знаком табуляции.</p>

  <p>Файл Makefile</p>
<pre>
main: main.o util.o str.o
  gcc main.o util.o str.o -o main
main.o: main.cpp util.h str.h
  gcc -c main.cpp
util.o: util.cpp util.h
  gcc -c util.cpp
str.o: str.cpp str.h
  gcc -c str.cpp
</pre>

  <p>Утилита make может принимать один параметр - цель, которую нужно отследить.</p>
  <p>Файл Makefale может содержать еще одну цель, которая не имеет зависимостей</p>
<pre>
clean:
  rm -rf *.o
</pre>
  <p>rm это утилита удаления. -rf это ключ, который означает ничего не спрашивать.</p>
  <p>Удалим все объектные файлы</p>
  <code>make clean</code>

  <h4>Библиотека STL</h4>
  <p>Библиотека это набор объектных файлов. Это файл в котором склеено много объектных файлов. Есть два вида библиотек: <strong>статические</strong> и <strong>динамические</strong>.</p>
  <p><strong>Статическая библиотека</strong> в линуксе имеет расширение .a от слова archive, в Windows имеет расширение .lib от слова library. Статическая библиотека присоединяется к объектному файлу. Файл <strong>libc.a</strong> представляет собой архив объектных файлов. Когда линковщик встречает функцию из стандартной библиотеки, он достает из нее объектный файл этой функции и пакует вместе с остальными файлами в исполняемый файл.</p>
  <p>Недостаток статической линковки: размер у получившегося файла вырастает.</p>
  <p>Достоинство статической линковки: когда мы запускаем программу на другом компьютере, то к нему нет требований, чтобы он содержал какие-либо библиотеки, потому что все необходимые библиотеки уже зашиты в программе.</p>
  <p><strong>Динамическая библиотека</strong> в линуксе имеет расширение .so от слов shared of object, в Windows имеет расширение .dll. Файл <strong>libc.so</strong>. Никаких новых объектных файлов к программе не присоединяется. В операционной системе есть специальный компонент загрузчик динамических библиотек. Когда программа запускается, он из ее заголовка понимает какие библиотеки должны быть загружены в память, обеспечивает их загрузку и связь с функциями из программы.</p>
  <p>Недостаток динамической линковки: на другой машине будет работать только если там есть файл lib.so. Такие библиотеки могут обновляться в операционной системе. Например, для исправления багов и при выходе новых версий. Отсюда второй недостаток: ваши программы могут требовать разных версий библиотек.</p>
  <p>Достоинство динамической линковки: занимает меньше места.</p>
  <p>gcc это семейство компиляторов. Для языка Си, Pascal, C++. Какой компилятор нужно запускать, он понимает по расширению файла.</p>
  <p>В следующем случае запустится компилятор gcc для языка Си</p>
  <code>gcc -c file.c</code>
  <p>В следующем случае запустится компилятор g++ для языка C++</p>
  <code>gcc -c file.cpp</code>
  <p>g++ это компилятор для C++, он уже не смотрит на расширение файла и любой файл компилирует по правилам C++</p>
  <code>g++ -c file.c</code>
  <code>g++ -c file.cpp</code>
  <p>Библиотека libc всегда подключается автоматически. По умолчанию используется динамическая линковка и динамические библиотеки. Если нужно провести статическую сборку, то надо добавить ключ -static</p>
  <code>gcc -c -static file.c</code>
  <p>Библиотека stl хранится в файле libstdc++. В линуксе лежит в каталоге /usr/lib. При компиляции компилятором g++, она подключается по умолчанию. При компиляции компилятором gcc библиотеку нужно подключить после ключа -l без пробела.</p>
  <code>gcc -lstdc++</code>

  <h3>Тема 3. Указатели</h3>

  <h4>Массивы</h4>

  <p>Оъявление статического массива на 10 элементов типа int. В квадратных скобках должна быть константа. Размер массива определяется на этапе компиляции.</p>
  <code>int array[10];</code>
  <p>В памяти будет выделено место для размера массива в байтах.</p>
  <code>sizeof(array); // 40 байт</code>
  <p>Посчитаем размер массива в элементах.</p>
  <code>sizeof(array) / sizeof(array[0]); // 10 элементов</code>
  <p>Способ инициализации массива через фигурные скобки</p>
  <code>int array[10] = {0,1,2,3,4,5,6,7,8,9};</code>
  <p>При такой инициализации, можно не указывать размер массива в квадратных скобках, потому что его компилятор вычислит автоматически по числу задаваемых значений.</p>
  <code>int array[] = {0,1,2,3,4,5,6,7,8,9};</code>
  <p>Можно инициализировать все элементы одним значением</p>
  <code>int array[10] = {0};</code>
  <p>Создадим статический массив на 5 элементов типа char.</p>
  <code>char array[] = {'H','e','l','l','o'};</code>
  <p>Создадим строку, содержащуюся в статическом массиве из 6 элементов типа char. В массиве будет на 1 элемент больше, за счет того, что для строк компилятор автоматически добавляет последним символом символ терминатор '\0'.</p>
  <code>char str[] = "Hello";</code>

  <h4>Двумерные массивы</h4>
  <code>int M[2][2];</code>
  <code>int M[2][2] = { {1,2},{3,4} };</code>

  <h4>Индексы массива</h4>
  <p>Выход за границы массива ни во время компиляции ни во время выполнения программы не котролируется.</p>

  <h4>Указатели</h4>
<pre>
int *p;
int a;
p = &amp;a; // взятие адреса переменной
int b = *p; // разименование указателя
</pre>
  <p>В результате в переменной b будет то же самое что и в переменной a.</p>
  <p>Размер указателя связан с разрядностью машины. На 32-битной машине размер указателя равен 4 байта. Посмотрим на адрес в переменной p</p>
  <code>printf("%p",p);</code>

  <h4>Связь указателей и массивов</h4>
<pre>
char array[10];
char *p;
p = &array[0];
p = array;
</pre>

  <p>Имя массива является указателем на его начало.</p>

  <h4>Арифметика указателей</h4>
<pre>
int i[10];
char c[10];
int *pi = &i[0];
char *pc = &c[0];
pi += 1;
ci += 1;
</pre>

  <p>Запись вида i[3] компилятор преобразует в *(i+3). Тогда и запись вида 3[i] компилятор преобразует в *(i+3). При работе с массивами, компилятор на самом деле работает с указателями и с памятью.</p>
  <p>Складывать указатели нельзя, но вычитать можно.</p>

  <h4>Различие между указателями разных типов</h4>
</article>


<!-- Урок 3 -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>Урок 3</h3>

  <h4>Применение указателей</h4>
  <ol>
    <li>Поменять местами две переменные
      <code>void swap(int *a, int *b);</code>
    </li>
    <li>Передача массивов в функцию</li>
    <li>Быстродействие
      <code>while (*p) p++;</code>
      вместо
      <code>while (p[i]) p++;</code>
    </li>
  </ol>

  <h4>Ссылки</h4>
  <p>После указателей в язык C++ ввели новую сущность - <strong>ссылки</strong>.</p>
  <p>До появления ссылок можно было с помощью указателей поменять две переменные местами.</p>
<pre>
void swap(int *a, int *b) {
  int tmp = *a;
  *a = *b;
  *b = tmp;
}

int main() {
  int x = 3;
  int y = 5;
  swap(&x, &y);
}
</pre>

  <p>Теперь в C++ появился такой синтаксис, который позволяет эту запись упростить.</p>
<pre>
void swap(int &a, int &b) {
  int tmp = a;
  a = b;
  b = tmp;
}

int main() {
  int x = 3;
  int y = 5;
  swap(x, y);
}
</pre>
  <p>Здесь int &a это ссылка на переменную типа int. В момент компиляции ссылки внутри функции заменятся на указатели.</p>
  <p>У ссылок есть два отличия от указателей.</p>
  <ol>
    <li>Ссылка не может быть неинициализирована. Нельзя написать int &amp;a;</li>
    <li>Ссылка не может быть равна NULL. Нельзя написать int &a = NULL;</li>
  </ol>
  <p>Ссылки ничего нового в язык C++ не принесли. Просто изменилась запись на более понятную.</p>
  <p>Теперь амперсанд используется для двух разных вещей. Это взятие адреса переменных int *p = &a и ссылка на переменную f(int &a).</p>

  <h4>Глобальная память</h4>
  <p>Переменные объявленные за пределами функций называются глобальными. Сколько памяти выделять глобальным переменным, определяет компилятор в момент компиляции. При загрузке программы в память, сразу загружаются в память все ее глобальные переменные. Если в памяти не хватает места для всех глобальных переменных, то программа не загрузится.</p>
  <p>Если программа состоит из нескольких файлов: main.cpp и hello.cpp.</p>

  <p>Файл main.cpp</p>
<pre>
int main() {
  a = 5;
}
</pre>

  <p>Файл hello.cpp</p>
<pre>
int a = 3;
void hello() {}
</pre>
  <p>В этом коде есть проблема. В языке Си компиляция файлов раздельная. При компиляции main() компилятор не знает откуда брать переменную a.</p>
  <p>Файл main.cpp</p>
<pre>
#include "hello.h"

int main() {
  a = 5;
}
</pre>

  <p>Файл hello.h</p>
<pre>
#ifndef _h_h_
int a = 3;
void hello() {}
#endif
</pre
</article>
