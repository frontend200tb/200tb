<article class="article">
  <h1>2011 Евгений Линский - Основы C++ 1 семестр</h1>
  <p>Конспект видео курса</p>
  <p>12 уроков. Длительность 16ч 22м.</p>
</article>


<!-- Содержание -->
<article class="article">
  <h3>Содержание</h3>

  <p><a href="#p1">Урок 1</a></p>
  <p><a href="#p2">Урок 2</a></p>
  <p><a href="#p3">Урок 3</a></p>
  <p><a href="#p4">Урок 4</a></p>
  <p><a href="#p5">Урок 5</a></p>
  <p><a href="#p6">Урок 6</a></p>
  <p><a href="#p7">Урок 7</a></p>
  <p><a href="#p8">Урок 8</a></p>
  <p><a href="#p9">Урок 9</a></p>
  <p><a href="#p10">Урок 10</a></p>
  <p><a href="#p11">Урок 11</a></p>
  <p><a href="#p12">Урок 12</a></p>

</article>


<!-- Урок 1 -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Урок 1</h3>

  <p>Язык C++ появился после языка C для того чтобы большие программы можно было писать удобно.</p>

  <h4>Библиотека STL</h4>
  <p>Программисту при написании программ требуется набор стандартных компонентов. Например, компонент для хранения данных. А именно деревья, связанные списки, динамические массивы. Это сложные структуры данных. Чтобы каждый раз не изобретать велосипед и не писать эти компоненты самому с нуля, они включены в стандартную библиотеку.</p>

  <h3>Тема 1. Программа, состоящая из нескольких файлов</h3>

  <p>Для начала немного истории. В 1970 году в Bell Labs Кен Томпсон и Ден Ритчи решают задачу написать переносимую операционную систему. Было несколько моделей компьютеров с разным набором регистров, которые по разному назывались. Для этой цели они разработали язык Си, а операционная система называлась Unix.</p>
  <p>К языку Си предъявлялись требования: он должен быть таким же эффективным как язык ассемблера, на нем должно быть более удобно программировать чем на языке ассемблера, должна быть переносимость на уровне исходных текстов программ. Это значит что для каждой новой платформы достаточно написать компилятор языка Си и тогда на ней можно написать все программы на языке Си, которые уже были написаны для других платформ.</p>
  <p>Язык ассемблера близок машинному коду. Нет переносимости исходных текстов программ на языке ассемблера и на языке машинного кода.</p>
  <p>В 1980 году в Bell Labs Бьерн Страуструп на основе языка Си предложил новый язык, который он назвал Си с классами или C++. Необходимость нового языка была обусловлена необходимостью программистам работать с большими базами данных.</p>
  <p>Минимальная программа в файле main.c</p>
<pre>
int main() {
  return 0;
}
</pre>
  <p>Все домашние задания я попрошу вас делать в операционно системе Linux на компиляторе gcc. При этом не пользуясь средами разработки. Самый простой вариант поставить систему Ubuntu 10.04. Второй вариант поставить виртуальную машину VirtualBox. И для нее найти виртуальную машину уже с поставленной Ubuntu.</p>
  <p>Иногда нужно запустить несколько команд. Это делается с помощью скриптов командной оболочки. Это языки сценариев. Под линуксом самый популярный язык сценариев это bash. Под windows это bat файлы. Из сценария можно запустить программу и посмотреть какой результат она вернет операционной системе. Это может использоваться для контроля за ошибками.</p>
  <p>Скомпилируем программу в файле main.c</p>
  <code>gcc main.c</code>
  <p>В результате рядом с файлом main.c появится файл a.out. Мы можем скомпилировать программу так, чтобы появился файл с именем main</p>
  <code>gcc main.c -o main</code>
  <p>Запустим программу</p>
  <code>./main</code>
  <p>Операционная система Windows и Linux по разому ищут файл, который нужно запустить. По умолчанию Windows сначала ищет файл в текущей директории ./, затем в директориях, указанных в системной переменной PATH. По умолчанию Linux сначала ищет файл в директориях /bin, /sbin, /usrbin? Затем в директориях, указанных в системной переменной PATH. Поэтому, когда мы запускаем файл ".main" мы явно говорим операционной системе, что запускать нужно программу из текущей директории.</p>

  <p>Пусть в программе будет два файла main.c и hello.c.</p>

  <p>Файл main.c</p>
<pre>
int main() {
  hello();
  return 0;
}
</pre>

  <p>Файл hello.c</p>
<pre>
#include &lt;stdio.h&gt;

void hello() {
  printf("Hello!");
}
</pre>

  <p>Причина разбиения программы на несколько файлов:</p>
  <ol>
    <li>Абстракция. При создании большой системы хочется выделять отдельные чисти и забывать как они устроены внутри. Создавать систему из черных ящиков.</li>
    <li>Независимость. Над разными файлами могут работать разные программисты.</li>
    <li>Быстрая компиляция.</li>
  </ol>

  <p>Один из дистрибутивов лиукс называется Gentoo. В нем мало что делается автоматически и все приходится делать руками. Его автор Дэниел Роббинс написал очень хорошую книгу Основы Linux от основателя Gentoo.</p>

  <p>Чтобы скомпилировать программу, состоящую из двух файлов main.c и hello.c нужно выполнить команду</p>
  <code>gcc main.c hello.c -o main</code>

  <p>Вот что происходит:</p>
  <ol>
    <li>
      <p><strong>Компиляция</strong>. Каждый файл компилируется отдельно от остальных. Из языка Си в ассемблер, из ассемблера в машинный код. Вместе с компиляцией происходит <strong>оптимизация</strong> для того чтобы программа занимала меньше места и выполнялась быстрее.</p>
      <p>В результате компиляции вместо каждого файла .c поясляются объектные файлы .o. То есть main.o и hello.o.</p>
      <p>Все инструкции языка Си заменяются на машинные коды, кроме вызовов функций. Вызов функции hello() заменяется на инструкцию "вызови функцию hello". А вызов функции printf() заменается на инструкцию "вызови функцию printf". На ассемблере вызов функции это инструкция call.</p>
      <p>Что происходит, когда мы запускаем программу? Операционная система записывает программу в оперативную память и передает процессору адрес первой инструкции. Процессор начинает по очереди выполнять инструкции программы. Программа занимает в памяти множество блоков, каждый блок соответствует функции.</p>
      <p>Программа всегда начинается с функции main, с первой инструкции. Когда процессор дойдет до вызова функции hello(), ему нужно в памяти перейти на начало функции hello(). Он не знает, что такое функция hello(). Он видит инструкцию "выполни код по адресу 0xFFFFF". Процессор выполняет код по адресу 0xFFFFF (функцию hello()), а потом возвращается обратно.</p>
      <p>Компиляция это сложный процесс, который занимает много времени.</p>
    </li>
    <li>
      <p><strong>Линковка</strong>. Собирает из отдельных объектных файлов с машинным кодом один исполняемый файл, соединить все блоки вместе один под другим и выполнить разрешение адресов. Именно при разрешении адресов происходит замена с "вызови функцию hello()" на "выполняй инструкции с адреса 0xFFFFF". Адреса функций вычисляются относительно адреса функции main.</p>
      <p>Линковка это очень простой процесс и занимает немного времени.</p>
    </li>
  </ol>

  <h4>Плюс раздельной компиляции</h4>
  <p>Проведем отдельно компиляцию и линковку программы. Сначала выполним компиляцию</p>
  <code>gcc -c main.c</code>
  <code>gcc -c hello.c</code>
  <p>После компиляции создадутся объектные файлы main.o и hello.c. А затем выполним линковку</p>
  <code>gcc main.o hello.o -o main</code>
  <p>Когда программа разбита на много файлов, то при изменении только одного файла, нужно будет перекомпилировать только один файл и сделать линковку всей программы. Поскольку компиляция это долгий процесс, а линковка недолгий, то перекомпиляция при этом займет меньше времени, чем если бы вся программа была написана в одном файле.</p>

  <h4>Минус раздельной компиляции</h4>
  <p>Если нужно не просто поменять код внутри функции, но поменять и сигнатуру.</p>

  <p>Файл hello.c</p>
<pre>
#include &lt;stdio.h&gt;

void hello(int n) {
  printf("%d", n);
}
</pre>

  <p>При компиляции ошибки не будет</p>
  <code>gcc -c hello.c</code>
  <p>Но при линковке выскочит ошибка что вызов функции hello() из функции main() не соответсвтует сигнатуре самой функции.</p>
  <p>Для решения этой проблемы используют заголовочные файлы.</p>

  <h4>Заголовочные файлы</h4>
  <p>Разделим функцию на две части: объявление и определение.</p>
  <p>Объявление (declaration) это сигнатура функции. Возвращаемое значение, имя функции, число и тип параметров.</p>
  <p>Определение (definition) это все то что пишут при объявлении плюс имена параметров и код функции.</p>
  <p>Теперь поместим объявление функции hello() во всех файлах, где упоминается функция hello().</p>

  <p>Файл main.c</p>
<pre>
void hello(int);

int main() {
  hello();
  return 0;
}
</pre>

  <p>Файл hello.c</p>
<pre>
#include &lt;stdio.h&gt;
void hello(int);

void hello(int n) {
  printf("%d", n);
}
</pre>

  <p>Теперь в файле hello.c компилятор проконтролирует соответствие между объявлением и определением функции hello(). Если они не совпадают, то выдаст ошибку.</p>
  <p>В файле main.c компилятор проконтролирует соответствие между объявлением и вызовом функции hello(). Если они не совпадают, то выдаст ошибку.</p>
  <p>Если программист изменит объявление и определение функции в одном файле, но забудет изменить объявление в другом, то компилятор не найдет ошибку, но ошибка выскочит во время линковки.</p>
  <p>На этом этапе наша проблема еще не решена.</p>

  <p>Чтобы решить проблему, нужно в программе иметь только одно объявление функции. Такое объявление выносится в отдельный файл. Такой файл называется <strong>заголовочный</strong>.</p>
  <p>Теперь программа будет состоять из трех файлов main.c, hello.h, hello.c</p>

  <p>Файл hello.h</p>
<pre>
void hello(int);
</pre>

  <p>Файл main.c</p>
<pre>
#include "hello.h"

int main() {
  hello();
  return 0;
}
</pre>

  <p>Файл hello.c</p>
<pre>
#include &lt;stdio.h&gt;
#include "hello.h"

void hello(int n) {
  printf("%d", n);
}
</pre>

  <p>#include это директива препроцессора. Препроцессор вставляет на мето этой директивы содержимое файла hello.h. Одно и то же объявление теперь вставляется и в файл main.c и в файл hello.c. В файле main.c проверяется соответствие между объявлением и вызовом функции. В файле hello.c проверяется соответствие между объявлением и определением функции.</p>
  <p>Теперь наша проблема решена.</p>
  <p>printf это функция стандартной библиотеки языка Си.</p>
  <p>stdio.h это заголовочный файл стандартной библиотеки языка Си.</p>
  <p>libc это стандартная библиотека языка Си.</p>
  <p>stl это стандартная библиотека языка C++.</p>

  <p>Обозначим еще две проблемы</p>
  <ol>
    <li>Почему нельзя сразу включить файл hello.c в файл main.c? Почему мы должны делать отдельный заголовочный файл и включать его?</li>
    <li>Если два файла a.c и b.c используют функции друг из друга, то при подключении их с помощью #include, файлы будут бесконечно вставляться один в другой.</li>
  </ol>

  <p>Рассмотрим сначала первую проблему. Пусть у нас есть файл hello.c, содержащий функцию hello(). И есть два файла main.c и util.c, которым нужен доступ к функции hello(). Если мы в каждый файл включим hello.c</p>
  <p>Файл hello.c</p>
  <code>void hello(int);</code>
  <p>Файл main.c</p>
  <code>#include "hello.c"</code>
  <p>Файл util.c</p>
  <code>#include "hello.c"</code>
  <p>Проходя по первому файлу main.c компилятор создаст первую копию функции hello() в памяти. Проходя по второму файлу util.c компилятор создаст вторую копию функцию hello() в памяти. Линковщик не знает на какой адрес настраивать вызов функции hello() и выдаст ошибку. В программе не может быть две функции с одинаковым именем в одной области видимости.</p>

  <p>Рассмотрим вторую проблему.</p>
  <p>Файл a.h</p>
  <code>#include "b.h"</code>
  <p>Файл b.h</p>
  <code>#include "a.h"</code>
  <p>Вставим директивы условной компиляции.</p>

  <p>Файл a.h</p>
<pre>
#ifndef _a_h_
#define _a_h_
#include "b.h"
#endif
</pre>

  <p>Файл b.h</p>
<pre>
#ifndef _b_h_
#define _b_h_
#include "a.h"
#endif
</pre>
</article>


<!-- Урок 2 -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>Урок 2</h3>

  <h4>Makefile</h4>
  <p>С помощью gcc каждый этап компиляции можно запустить по отдельности.</p>
  <p>Запустить только препроцессор. Преобразует текстовый файл .c в текстовый файл .c, обрабатывая директивы препроцессора.</p>
  <code>gcc -E</code>
  <p>Запустить только компилятор. Преобразует текстовый файл .c в объектный файл .o на языке ассемблера.</p>
  <code>gcc -c</code>
  <p>Запустить только компилятор. Преобразует объектный файл .o на языке ассемблера в исполняемый файл .out на машинных кодах.</p>
  <code>gcc -s</code>
  <p>Если мы какой-то файл поменяли, то нет смысла заново компилировать все файлы. Достаточно скомпилировать измененный файл и провести затем компоновку и линковку. Но каждый раз помнить какие файлы поменялись, а какие нет это очень тяжело. Поэтому хотелось бы иметь какую-то утилиту, которая бы за нас следила за всеми изменениями.</p>
  <p>Пусть у нас есть файл main.cpp, который использует функции из файла util.cpp, объявленные в util.h и функции из файла str.cpp, объявленные в str.h.</p>
  <p>Рассмотрим зависимости. Файл main.o зависит от файлов main.cpp, util.h, str.h. Это значит, что требуется перекомпилировать файл main.o если изменится один из этих трех файлов.</p>
  <p>Файл util.o зависит от файлов util.cpp и util.h.</p>
  <p>Файл str.o зависит от файлов str.cpp и str.h.</p>
  <p>Исполняемый файл main.out зависит от файлов main.o, util.o, str.o.</p>
  <p><strong>Makefile</strong> это текстовый файл, в котором записана вся информация о зависимостях. То есть какие файлы от каких зависят. Если какой-то файл поменялся, то нужна инструкция что и как нужно перекомпилировать. Makefile обрабатывает утилита <strong>make</strong>.</p>
  <p>Если вызвать утилиту make в директории, в которой содержится файл Makefile, утилита make начнет обрабатывать этот файл. Сначала она выяснит что же поменялось. Потом выполнит необходимые инструкции.</p>
  <p>Напишем Makefile для этого примера. Сначала пишется цель, потом двоеточие, потом файлы от которых зависит цель. На новой строчке после знака табуляции пишутся инструкции. Каждая инструкция отделяется от другой знаком табуляции.</p>

  <p>Файл Makefile</p>
<pre>
main: main.o util.o str.o
  gcc main.o util.o str.o -o main
main.o: main.cpp util.h str.h
  gcc -c main.cpp
util.o: util.cpp util.h
  gcc -c util.cpp
str.o: str.cpp str.h
  gcc -c str.cpp
</pre>

  <p>Утилита make может принимать один параметр - цель, которую нужно отследить.</p>
  <p>Файл Makefale может содержать еще одну цель, которая не имеет зависимостей</p>
<pre>
clean:
  rm -rf *.o
</pre>
  <p>rm это утилита удаления. -rf это ключ, который означает ничего не спрашивать.</p>
  <p>Удалим все объектные файлы</p>
  <code>make clean</code>

  <h4>Библиотека STL</h4>
  <p>Библиотека это набор объектных файлов. Это файл в котором склеено много объектных файлов. Есть два вида библиотек: <strong>статические</strong> и <strong>динамические</strong>.</p>
  <p><strong>Статическая библиотека</strong> в линуксе имеет расширение .a от слова archive, в Windows имеет расширение .lib от слова library. Статическая библиотека присоединяется к объектному файлу. Файл <strong>libc.a</strong> представляет собой архив объектных файлов. Когда линковщик встречает функцию из стандартной библиотеки, он достает из нее объектный файл этой функции и пакует вместе с остальными файлами в исполняемый файл.</p>
  <p>Недостаток статической линковки: размер у получившегося файла вырастает.</p>
  <p>Достоинство статической линковки: когда мы запускаем программу на другом компьютере, то к нему нет требований, чтобы он содержал какие-либо библиотеки, потому что все необходимые библиотеки уже зашиты в программе.</p>
  <p><strong>Динамическая библиотека</strong> в линуксе имеет расширение .so от слов shared of object, в Windows имеет расширение .dll. Файл <strong>libc.so</strong>. Никаких новых объектных файлов к программе не присоединяется. В операционной системе есть специальный компонент загрузчик динамических библиотек. Когда программа запускается, он из ее заголовка понимает какие библиотеки должны быть загружены в память, обеспечивает их загрузку и связь с функциями из программы.</p>
  <p>Недостаток динамической линковки: на другой машине будет работать только если там есть файл lib.so. Такие библиотеки могут обновляться в операционной системе. Например, для исправления багов и при выходе новых версий. Отсюда второй недостаток: ваши программы могут требовать разных версий библиотек.</p>
  <p>Достоинство динамической линковки: занимает меньше места.</p>
  <p>gcc это семейство компиляторов. Для языка Си, Pascal, C++. Какой компилятор нужно запускать, он понимает по расширению файла.</p>
  <p>В следующем случае запустится компилятор gcc для языка Си</p>
  <code>gcc -c file.c</code>
  <p>В следующем случае запустится компилятор g++ для языка C++</p>
  <code>gcc -c file.cpp</code>
  <p>g++ это компилятор для C++, он уже не смотрит на расширение файла и любой файл компилирует по правилам C++</p>
  <code>g++ -c file.c</code>
  <code>g++ -c file.cpp</code>
  <p>Библиотека libc всегда подключается автоматически. По умолчанию используется динамическая линковка и динамические библиотеки. Если нужно провести статическую сборку, то надо добавить ключ -static</p>
  <code>gcc -c -static file.c</code>
  <p>Библиотека stl хранится в файле libstdc++. В линуксе лежит в каталоге /usr/lib. При компиляции компилятором g++, она подключается по умолчанию. При компиляции компилятором gcc библиотеку нужно подключить после ключа -l без пробела.</p>
  <code>gcc -lstdc++</code>

  <h3>Тема 3. Указатели</h3>

  <h4>Массивы</h4>

  <p>Оъявление статического массива на 10 элементов типа int. В квадратных скобках должна быть константа. Размер массива определяется на этапе компиляции.</p>
  <code>int array[10];</code>
  <p>В памяти будет выделено место для размера массива в байтах.</p>
  <code>sizeof(array); // 40 байт</code>
  <p>Посчитаем размер массива в элементах.</p>
  <code>sizeof(array) / sizeof(array[0]); // 10 элементов</code>
  <p>Способ инициализации массива через фигурные скобки</p>
  <code>int array[10] = {0,1,2,3,4,5,6,7,8,9};</code>
  <p>При такой инициализации, можно не указывать размер массива в квадратных скобках, потому что его компилятор вычислит автоматически по числу задаваемых значений.</p>
  <code>int array[] = {0,1,2,3,4,5,6,7,8,9};</code>
  <p>Можно инициализировать все элементы одним значением</p>
  <code>int array[10] = {0};</code>
  <p>Создадим статический массив на 5 элементов типа char.</p>
  <code>char array[] = {'H','e','l','l','o'};</code>
  <p>Создадим строку, содержащуюся в статическом массиве из 6 элементов типа char. В массиве будет на 1 элемент больше, за счет того, что для строк компилятор автоматически добавляет последним символом символ терминатор '\0'.</p>
  <code>char str[] = "Hello";</code>

  <h4>Двумерные массивы</h4>
  <code>int M[2][2];</code>
  <code>int M[2][2] = { {1,2},{3,4} };</code>

  <h4>Индексы массива</h4>
  <p>Выход за границы массива ни во время компиляции ни во время выполнения программы не котролируется.</p>

  <h4>Указатели</h4>
<pre>
int *p;
int a;
p = &amp;a; // взятие адреса переменной
int b = *p; // разименование указателя
</pre>
  <p>В результате в переменной b будет то же самое что и в переменной a.</p>
  <p>Размер указателя связан с разрядностью машины. На 32-битной машине размер указателя равен 4 байта. Посмотрим на адрес в переменной p</p>
  <code>printf("%p",p);</code>

  <h4>Связь указателей и массивов</h4>
<pre>
char array[10];
char *p;
p = &array[0];
p = array;
</pre>

  <p>Имя массива является указателем на его начало.</p>

  <h4>Арифметика указателей</h4>
<pre>
int i[10];
char c[10];
int *pi = &i[0];
char *pc = &c[0];
pi += 1;
ci += 1;
</pre>

  <p>Запись вида i[3] компилятор преобразует в *(i+3). Тогда и запись вида 3[i] компилятор преобразует в *(i+3). При работе с массивами, компилятор на самом деле работает с указателями и с памятью.</p>
  <p>Складывать указатели нельзя, но вычитать можно.</p>

  <h4>Различие между указателями разных типов</h4>
</article>


<!-- Урок 3 -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>Урок 3</h3>

  <h4>Применение указателей</h4>
  <ol>
    <li>Поменять местами две переменные
      <code>void swap(int *a, int *b);</code>
    </li>
    <li>Передача массивов в функцию</li>
    <li>Быстродействие
      <code>while (*p) p++;</code>
      вместо
      <code>while (p[i]) p++;</code>
    </li>
  </ol>

  <h4>Ссылки</h4>
  <p>После указателей в язык C++ ввели новую сущность - <strong>ссылки</strong>.</p>
  <p>До появления ссылок можно было с помощью указателей поменять две переменные местами.</p>
<pre>
void swap(int *a, int *b) {
  int tmp = *a;
  *a = *b;
  *b = tmp;
}

int main() {
  int x = 3;
  int y = 5;
  swap(&x, &y);
}
</pre>

  <p>Теперь в C++ появился такой синтаксис, который позволяет эту запись упростить.</p>
<pre>
void swap(int &a, int &b) {
  int tmp = a;
  a = b;
  b = tmp;
}

int main() {
  int x = 3;
  int y = 5;
  swap(x, y);
}
</pre>
  <p>Здесь int &a это ссылка на переменную типа int. В момент компиляции ссылки внутри функции заменятся на указатели.</p>
  <p>У ссылок есть два отличия от указателей.</p>
  <ol>
    <li>Ссылка не может быть неинициализирована. Нельзя написать int &amp;a;</li>
    <li>Ссылка не может быть равна NULL. Нельзя написать int &a = NULL;</li>
  </ol>
  <p>Ссылки ничего нового в язык C++ не принесли. Просто изменилась запись на более понятную.</p>
  <p>Теперь амперсанд используется для двух разных вещей. Это взятие адреса переменных int *p = &a и ссылка на переменную f(int &a).</p>

  <h4>Глобальная память</h4>
  <p>Переменные объявленные за пределами функций называются глобальными. Сколько памяти выделять глобальным переменным, определяет компилятор в момент компиляции. При загрузке программы в память, сразу загружаются в память все ее глобальные переменные. Если в памяти не хватает места для всех глобальных переменных, то программа не загрузится.</p>
  <p>Если программа состоит из нескольких файлов: main.cpp и hello.cpp.</p>

  <p>Файл main.cpp</p>
<pre>
int main() {
  a = 5;
}
</pre>

  <p>Файл hello.cpp</p>
<pre>
int a = 3;
void hello() {}
</pre>
  <p>В этом коде есть проблема. В языке Си компиляция файлов раздельная. При компиляции main() компилятор не знает откуда брать переменную a.</p>

  <p>Файл main.cpp</p>
<pre>
#include "hello.h"

int main() {
  a = 5;
}
</pre>

  <p>Файл hello.h</p>
<pre>
#ifndef _h_h_
extern int a = 3;
void hello() {}
#endif
</pre>

  <p>Файл hello.cpp</p>
<pre>
a = 3;
void hello() {}
</pre>

  <p>Не хорошо использовать глобальные переменные. Возникает две проблемы. Первая проблема: сложно следить за логикой программы. Вторая проблема: возможны конфликты имен, если глобальные переменные объявлены в разных файлах, в том числе в объектных файлах библиотек.</p>

  <h4>Стек</h4>
  <p>В стеке хранятся данные, необходимые для работы функции. Когда вызывается новая функия, то выделяется новая память для кадра стека.</p>
  <p>В кадре стека хранятся входные параметры функции, локальные переменные и адрес возврата из функции. Таким образом стек растет вверх. При рекурсивных вызовах стек может переполниться и программа аварийно завершится. Когда функция заканчивает свою работу, то она освобождает свою память в стеке.</p>
  <p>Для фукции объем выделяемой памяти в стеке определяется в момент компиляции. Нужно знать объем под параметры и под локальные переменные.</p>
  <p>Для программы объем выделяемой памяти в стеке на этапе компиляции определить нельзя, потому что мы не знаем сколько раз и как функции будут вызываться в программе.</p>

  <h4>Динамическая память</h4>
  <p>Динамическая память выделяется в момент работы программы. Если объем данных заранее неизвесен, например вводится с клавиатуры, поступает из сети, вводится из файла, то память под такие данные нужно выделять динамически.</p>
  <p>Динамическая память выделается и освобождается с помощью функций операционной системы из библиотеки stdlib.h.</p>
  <p>Выделим динамическую память для хранения 10000 элементов типа int (40000 байт) и запишем указатель на эту память в переменную p.</p>
  <code>int *p = malloc(10000 * sizeof(int));</code>
  <p>Теперь к элеменам этой памяти можно обращаться как к элементам массива</p>
  <code>int a = p[0]; int b = p[9999];</code>
  <p>Когда работа с выделенной памятью закончена и эти 10000 элементов нам не нужны, то память нужно освободить.</p>
  <code>free(p);</code>
  <p>Сигнатура вызова функции malloc()</p>
  <code>void *malloc(size_t size);</code>
  <p>Причем тип данных size_t опрделяется как</p>
  <code>typedef unsigned int size_t;</code>
  <p>Функция malloc() возвращает указатель на void</p>
  <p>В языке Си произойдет неявное приведение типов.</p>
  <code>int *p = malloc(10000 * sizeof(int));</code>
  <p>В языке C++ нужно явно приводить указатель на void к указателю на нужный тип данных.</p>
  <code>int *p = (int *)malloc(10000 * sizeof(int));</code>

  <p>Проблемы динамической памяти</p>
  <ol>
    <li>Выход за границы. Программист должен следить, чтобы программа не могла обратиться за границы динамической памяти.</li>
    <li>Утечка памяти (memory leak). Программист должен следить, чтобы вся выделенная память затем была освобождена.
    <code>int *p = malloc(10000 * sizeof(int));</code>
    <code>p = malloc(10 * sizeof(int));</code>
    <p>Указатель p показывает только на вторую область памяти из 40 байт. К первой области памяти в 40000 байт нет доступа и ее невозможно освободить, так как на нее не указывает ни один указатель.</p>
    <p>После завершения работы программы операционная система сама автоматически очищает всю выделенную в этой программе динамическую память. Поэтому, если это небольшая программа, которой требуется мало памяти то это ни к чему страшному не приведет. Другое дело если это сервер, который работает без перерыва. При утечках памяти, сначала у него закончится вся оперативная память и тогда операционная система чтобы освободить ее будет скидывать данные из оперативной памяти в файл подкачки, при этом сервер и все остальные программы запущенные на этом компьютере начнут тормозить.</p>
    <p>При эволюции языков программирования, в языке C# уже нет операции освобождения памяти free(). Это делается автоматически сборщиком мусора, который сканирует оперативную память и сам находит такие участки которые больше никому не нужны.</p>
    </li>
    <li>Выделение динамической памяти это самый медленный процесс из трех видов памяти. Операционная система должна просмотреть свои таблицы, чтобы найти в них свободный непрерывный кусок памяти и вернуть указатель на нее.</li>
    <li>В динамической памяти имеет смысл размещать массивы и объекты большого размера. Если в динамической памяти хранить простую переменную, например
      <code>int *p = (int *)malloc(4);</code>
      то она займет 4 байта в динамической памяти, под тип int и еще 4 байта на стеке под указатель на тип int.
    </li>
  </ol>

  <h4>Выделение динамической памяти для двумерного массива</h4>
  <p>Работать с двумерным массивом в динамической памяти можно двумя способами.</p>
  <p>Первый способ. Выделим динамическую память для матрицы n x n, которая вернет указатель на int.</p>
  <code>int *M = (int *)malloc(sizeof(int) * n * n);</code>
  <p>Чтобы обратимся к элементу M[1][2] нужно записать M[1*N+2]. Чтобы обратимся к элементу M[i][j] нужно записать M[i*N+j].</p>
  <p>Заметим, что первым способом мы один раз обращаемся к функции malloc().</p>
  <p>Второй способ. Сначала выделим динамическую память для массива указателей размера n, которая вернет указатель на массив указателей типа int*.</p>
  <code>int **M = (int **)malloc(sizeof(int *) * n);</code>
  <p>Потом в каждый элемент массива записать указатель на свой массив размера n.</p>
<pre>
for (int i = 0; i &lt; n; i++) {
  M[i] = (int *)malloc(sizeof(int) * n);
}
</pre>
  <p>Чтобы обратимся к элементу M[1][2] нужно записать M[1][2]. Чтобы обратимся к элементу M[i][j] нужно записать M[i][j], то есть мы разыменовываем указатель *(*(M+i)+j).</p>
  <p>В этом случае, на самом деле, массив не находится весь целиком в непрерывной области памяти. Сначала выделяется непрерывная область памяти для массива указателей. А потом для каждого указателя выделяется непрерывная область под массив типа int.</p>

  <h4>Освобождение динамической памяти для двумерного массива</h4>
  <p>Сначала нужно освободить память выделенную под каждый внутренний массив, а потом выделенную под указатели.</p>
  <p>Функция malloc() очень медленная. и нам пришлось n+1 раз выделять память функцией malloc().</p>
<pre>
for (int i = 0; i &lt; n; i++) {
  free(M[i]);
}
free(M);
</pre>

  <h4>Третий способ</h4>
  <p>Третий способ это выделение памяти функцией malloc() за два обращения. Доступ к элементам массива имеет вид M[i][j].</p>
  <p>Выделить один массив tmp размером n x n. Выделить второй массив M размером n. В массиве M хранить указатели, которые указывают на адреса из массива tmp, отстоящие друг от друга на размер элемента.</p>

  <h4>Функция calloc()</h4>
  <p>Функция calloc() работает так же как и функция malloc() с одним отличием. Она заполняет выделенную память нулями. Поэтому работает медленнее.</p>

  <h4>Функция realloc()</h4>
  <p>Функция realloc() позволяет изменить размер памяти, выделенной динамически с помощью функии malloc() или calloc().</p>
  <code>int *p = (int*)malloc(sizeof(int)*1000);</code>
  <code>p = realloc(p, sizeof(int)*10000);</code>

  <p>Каждая из функций malloc, calloc, realloc пытается выделить непрерывную память заданного размера. Если выделить память удается, то в качестве значения возвращается указатель на начало памяти. Если этого сделать не удается, то в качестве значения возвращается NULL. Поэтому после каждой операции выделения памяти необходимо проверять, что она выделилась.</p>
  <code>if (p == NULL) {}</code>

  <h4>Выделение динамической памяти в языке C++</h4>
  <p>В C++ для выделения памяти появились два ключевых слова new и delete.</p>
  <code>int *p = new int [1000];</code>
  <code>delete [] p;</code>
  <p>Если в языке Си функции malloc, calloc, realloc принимали в качестве параметра размер памяти, то в языке C++ оператор new требует после себя тип и число элементов.</p>
  <p>После оператора delete нужны квадратные скобки, чтобы компилятор мог обратиться к ячейке памяти, в которой записан размер массива и правильно рассчитать сколько элементов нужно удалить. Это касается только массивов.</p>
</article>


<!-- Урок 4 -->
<article class="article">
  <div class="anchor" id="p4"></div>
  <h3>Урок 4</h3>

  <p>Задание: посмотреть как работает malloc. Принципы поиска свободной памяти.</p>
  <p>Функция free() освобождает память выделенную и под переменную и под массив.</p>
  <p>Оператор delete освобождает память выделенную под переменную.</p>
  <p>Оператор delete [] освобождает память выделенную под массив.</p>
  <p>Оператор delete [] вызывает деструкторы. Для которых нужно знать не только размер массива, но и размеры ячеек из которых он состоит.</p>

  <h4>Стандартная библиотека языка Си libc.</h4>
  <p>stdio.h это заголовочный файл с сигнатурами функций ввода - вывода. Язык Си писался для операционной системы Unix. В философии Unix заложено что любое устройство это файл. Экран это файл, в который можно писать. Клавиатура это файл, с которого можно читать. Области памяти на жестком диске это файлы, в которые можно писать и читать.</p>

  <p>Ввод с клавиатуры scanf(). Вывод на экран printf().</p>

  <h4>Работа с файлом</h4>
  <p>Сначала нужно открыть файл</p>
  <code>FILE* f = fopen("a.txt", "r");</code>
  <p>Если файл не открылся, то fopen() возвращает NULL. Всегда нужно проверять открылся ли файл, прежде чем с ним работать</p>
  <code>if (f == NULL) {}</code>
  <p>Ввод из файла fscanf(). Вывод в файл fprintf().</p>
  <p>Поскольку операции чтения и записи в файл медленные, то используется буфер. Перед тем как в файл запишутся байты данных, они сперва накапливаются в буфере. И потом содержимое буфера пишется в файл целиком.</p>
  <p>Мы не знаем заполнился уже буфер или нет, не знаем сбросил ли он уже байты в файл или нет. Мы можем сами принудительно сбросить байты в файл из буфера командой fflush().</p>
  <code>fflush(f);</code>
  <p>После завершения работы с файлом, его нужно закрыть</p>
  <code>fclose(f);</code>
  <p>Перед закрытием файла команда fclose сбрасывает оставшиеся байты из буфера в файл.</p>

  <h4>Работа с вводом-выводом</h4>
  <p>stdin ввод с клавиатуры, stdout вывод на экран, stderr вывод на экран сообщений об ошибках. stderr не имеет буфера.</p>
  <p>printf("%d",n) это то же самое, что и fprintf(stdout, "%d",n).</p>

  <p>Вывод в файл:</p>
<pre>
FILE* f = fopen("a.txt", "w");
fprintf(f, "...");
</pre>

  <p>Вывод на экран:</p>
<pre>
FILE* f = stdout;
fprintf(f, "...");
</pre>

  <h4>Текстовые и двоичные файлы</h4>
  <p>Отличие текстовых и двоичных файлов в их отображении. Текстовый файл предназначен для чтения человеком. Двоичный файл предназначен для чтения программой. Текстовый файл отображается как набор графических символов из таблицы ASCII. Двоичный файл отображается как набор шестнадцатеричных цифр.</p>
  <p>Для записи английский букв достаточно первой половины таблицы ASCII от 0 до 127 символа. Вторая половина отдана для национальных алфавитов. Национальные алфавиты записываются в различных кодировках. Русский алфавит записывается кодировкой cp866 в системе MS-DOS, кодировкой CP1251 в Windows, кодировкой koi-8r в Unux.</p>
  <p>127 символов хватает не для всех алфавитов. Поэтому была предложена кодировка unicode, в которой символ кодируется четырьмя байтами. Правда используются пока только два байта, так как их хватает для всех известных символов. Есть разные способы записи символов unicode в файл. Первый способ UCS-4, когда символ записывается как 4 байта, где первые два это нули. Второй способ UCS-2, когда символ зависывается как 2 байта, без ведущих нулей. Третий способ UTF-8, когда символы кодируются последовательностями разной длины. Для английских букв длина символа 1 байт. Для совместимости с таблицей ASCII, символы из первой половины таблицы ASCII являются корректными в кодировке UTF-8. Для русского и других языков длина символа 2 байта.</p>
  <p>Для конца строки используются различные символы в различных операционных системах. Linux 10, Mac 13, Windows 1013.</p>
  <p>Для открытия текстовых файлов в функцию fopen дописывают в второй параметр буку t, для двоичных - буку b. Это влияет только на то как в файле будет записан символ перевода строки '\n'.</p>
  <p>Попробуем выполнить один и тот же код в Linux, Windows, с файлом открытом в режимах t или b.</p>
  <code>fprintf(f, "hello\n");</code>
  <p>В Linux в файл запишется 6 символов в любом режиме t или b.</p>
  <p>В Windows в режиме t в файл запишется 7 символов. В режиме b запишется 6 символов.</p>

  <h4>Функция fgets()</h4>
  <p>Считаем из файла a.txt 9 байт в переменную s.</p>
<pre>
FILE* f = fopen("a.txt", "tr");
char s[10];
fgets(s, 9, f);
</pre>

  <h4>Функция sscanf()</h4>
  <p>Считаем из строки в переменную s.</p>
<pre>
char s[10];
sscanf(s, "%d", &n);
</pre>

  <h4>Функция sprintf()</h4>
  <p>Функция sprintf() записывает в строку.</p>

  <h4>Функция feof()</h4>
  <p>Функция feof() определяет конец файла.</p>

  <h4>Работа с двоичными файлами</h4>
  <p>Функция fread() работает с файлами, открытыми в двоичном формате и имеет прототип:</p>
  <code>size_t fread(void *ptr, size_t size, size_t n, FILE* f);</code>

  <p>Считаем из файла 100 целых чисел.</p>
<pre>
int a[100];
fread(a, 4, 100, f);
</pre>

  <p>Функция fwrite() работает с файлами, открытыми в двоичном формате и имеет прототип:</p>
  <code>size_t fwrite(void *ptr, size_t size, size_t n, FILE* f);</code>
  <p>Функция fseek() перемещает указатель на номер текущей позиции внутри файла.</p>
  <p>Функция ftell() возвращает номер текущей позиции.</p>
</article>


<!-- Урок 5 -->
<article class="article">
  <div class="anchor" id="p5"></div>
  <h3>Урок 5</h3>
</article>
