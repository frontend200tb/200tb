<article class="article">
  <h1>2011 Евгений Линский - Основы C++ 1 семестр</h1>
  <p>Конспект видео курса</p>
  <p>12 уроков. Длительность 16ч 22м.</p>
</article>


<!-- Содержание -->
<article class="article">
  <h3>Содержание</h3>

  <p><a href="#p1">Урок 1</a></p>
  <p><a href="#p2">Урок 2</a></p>
  <p><a href="#p3">Урок 3</a></p>
  <p><a href="#p4">Урок 4</a></p>
  <p><a href="#p5">Урок 5</a></p>
  <p><a href="#p6">Урок 6</a></p>
  <p><a href="#p7">Урок 7</a></p>
  <p><a href="#p8">Урок 8</a></p>
  <p><a href="#p9">Урок 9</a></p>
  <p><a href="#p10">Урок 10</a></p>
  <p><a href="#p11">Урок 11</a></p>
  <p><a href="#p12">Урок 12</a></p>

</article>


<!-- Урок 1 -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Урок 1</h3>

  <p>Язык C++ появился после языка C для того чтобы большие программы можно было писать удобно.</p>

  <h4>Библиотека STL</h4>
  <p>Программисту при написании программ требуется набор стандартных компонентов. Например, компонент для хранения данных. А именно деревья, связанные списки, динамические массивы. Это сложные структуры данных. Чтобы каждый раз не изобретать велосипед и не писать эти компоненты самому с нуля, они включены в стандартную библиотеку.</p>

  <h3>Тема 1. Программа, состоящая из нескольких файлов</h3>

  <p>Для начала немного истории. В 1970 году в Bell Labs Кен Томпсон и Ден Ритчи решают задачу написать переносимую операционную систему. Было несколько моделей компьютеров с разным набором регистров, которые по разному назывались. Для этой цели они разработали язык Си, а операционная система называлась Unix.</p>
  <p>К языку Си предъявлялись требования: он должен быть таким же эффективным как язык ассемблера, на нем должно быть более удобно программировать чем на языке ассемблера, должна быть переносимость на уровне исходных текстов программ. Это значит что для каждой новой платформы достаточно написать компилятор языка Си и тогда на ней можно написать все программы на языке Си, которые уже были написаны для других платформ.</p>
  <p>Язык ассемблера близок машинному коду. Нет переносимости исходных текстов программ на языке ассемблера и на языке машинного кода.</p>
  <p>В 1980 году в Bell Labs Бьерн Страуструп на основе языка Си предложил новый язык, который он назвал Си с классами или C++. Необходимость нового языка была обусловлена необходимостью программистам работать с большими базами данных.</p>
  <p>Минимальная программа в файле main.c</p>
<pre>
int main() {
  return 0;
}
</pre>
  <p>Все домашние задания я попрошу вас делать в операционно системе Linux на компиляторе gcc. При этом не пользуясь средами разработки. Самый простой вариант поставить систему Ubuntu 10.04. Второй вариант поставить виртуальную машину VirtualBox. И для нее найти виртуальную машину уже с поставленной Ubuntu.</p>
  <p>Иногда нужно запустить несколько команд. Это делается с помощью скриптов командной оболочки. Это языки сценариев. Под линуксом самый популярный язык сценариев это bash. Под windows это bat файлы. Из сценария можно запустить программу и посмотреть какой результат она вернет операционной системе. Это может использоваться для контроля за ошибками.</p>
  <p>Скомпилируем программу в файле main.c</p>
  <code>gcc main.c</code>
  <p>В результате рядом с файлом main.c появится файл a.out. Мы можем скомпилировать программу так, чтобы появился файл с именем main</p>
  <code>gcc main.c -o main</code>
  <p>Запустим программу</p>
  <code>./main</code>
  <p>Операционная система Windows и Linux по разому ищут файл, который нужно запустить. По умолчанию Windows сначала ищет файл в текущей директории ./, затем в директориях, указанных в системной переменной PATH. По умолчанию Linux сначала ищет файл в директориях /bin, /sbin, /usrbin? Затем в директориях, указанных в системной переменной PATH. Поэтому, когда мы запускаем файл ".main" мы явно говорим операционной системе, что запускать нужно программу из текущей директории.</p>

  <p>Пусть в программе будет два файла main.c и hello.c.</p>

  <p>Файл main.c</p>
<pre>
int main() {
  hello();
  return 0;
}
</pre>

  <p>Файл hello.c</p>
<pre>
#include &lt;stdio.h&gt;

void hello() {
  printf("Hello!");
}
</pre>

  <p>Причина разбиения программы на несколько файлов:</p>
  <ol>
    <li>Абстракция. При создании большой системы хочется выделять отдельные чисти и забывать как они устроены внутри. Создавать систему из черных ящиков.</li>
    <li>Независимость. Над разными файлами могут работать разные программисты.</li>
    <li>Быстрая компиляция.</li>
  </ol>

  <p>Один из дистрибутивов лиукс называется Gentoo. В нем мало что делается автоматически и все приходится делать руками. Его автор Дэниел Роббинс написал очень хорошую книгу Основы Linux от основателя Gentoo.</p>

  <p>Чтобы скомпилировать программу, состоящую из двух файлов main.c и hello.c нужно выполнить команду</p>
  <code>gcc main.c hello.c -o main</code>

  <p>Вот что происходит:</p>
  <ol>
    <li>
      <p><strong>Компиляция</strong>. Каждый файл компилируется отдельно от остальных. Из языка Си в ассемблер, из ассемблера в машинный код. Вместе с компиляцией происходит <strong>оптимизация</strong> для того чтобы программа занимала меньше места и выполнялась быстрее.</p>
      <p>В результате компиляции вместо каждого файла .c поясляются объектные файлы .o. То есть main.o и hello.o.</p>
      <p>Все инструкции языка Си заменяются на машинные коды, кроме вызовов функций. Вызов функции hello() заменяется на инструкцию "вызови функцию hello". А вызов функции printf() заменается на инструкцию "вызови функцию printf". На ассемблере вызов функции это инструкция call.</p>
      <p>Что происходит, когда мы запускаем программу? Операционная система записывает программу в оперативную память и передает процессору адрес первой инструкции. Процессор начинает по очереди выполнять инструкции программы. Программа занимает в памяти множество блоков, каждый блок соответствует функции.</p>
      <p>Программа всегда начинается с функции main, с первой инструкции. Когда процессор дойдет до вызова функции hello(), ему нужно в памяти перейти на начало функции hello(). Он не знает, что такое функция hello(). Он видит инструкцию "выполни код по адресу 0xFFFFF". Процессор выполняет код по адресу 0xFFFFF (функцию hello()), а потом возвращается обратно.</p>
      <p>Компиляция это сложный процесс, который занимает много времени.</p>
    </li>
    <li>
      <p><strong>Линковка</strong>. Собирает из отдельных объектных файлов с машинным кодом один исполняемый файл, соединить все блоки вместе один под другим и выполнить разрешение адресов. Именно при разрешении адресов происходит замена с "вызови функцию hello()" на "выполняй инструкции с адреса 0xFFFFF". Адреса функций вычисляются относительно адреса функции main.</p>
      <p>Линковка это очень простой процесс и занимает немного времени.</p>
    </li>
  </ol>

  <h4>Плюс раздельной компиляции</h4>
  <p>Проведем отдельно компиляцию и линковку программы. Сначала выполним компиляцию</p>
  <code>gcc -c main.c</code>
  <code>gcc -c hello.c</code>
  <p>После компиляции создадутся объектные файлы main.o и hello.c. А затем выполним линковку</p>
  <code>gcc main.o hello.o -o main</code>
  <p>Когда программа разбита на много файлов, то при изменении только одного файла, нужно будет перекомпилировать только один файл и сделать линковку всей программы. Поскольку компиляция это долгий процесс, а линковка недолгий, то перекомпиляция при этом займет меньше времени, чем если бы вся программа была написана в одном файле.</p>

  <h4>Минус раздельной компиляции</h4>
  <p>Если нужно не просто поменять код внутри функции, но поменять и сигнатуру.</p>

  <p>Файл hello.c</p>
<pre>
#include &lt;stdio.h&gt;

void hello(int n) {
  printf("%d", n);
}
</pre>

  <p>При компиляции ошибки не будет</p>
  <code>gcc -c hello.c</code>
  <p>Но при линковке выскочит ошибка что вызов функции hello() из функции main() не соответсвтует сигнатуре самой функции.</p>
  <p>Для решения этой проблемы используют заголовочные файлы.</p>

  <h4>Заголовочные файлы</h4>
  <p>Разделим функцию на две части: объявление и определение.</p>
  <p>Объявление (declaration) это сигнатура функции. Возвращаемое значение, имя функции, число и тип параметров.</p>
  <p>Определение (definition) это все то что пишут при объявлении плюс имена параметров и код функции.</p>
  <p>Теперь поместим объявление функции hello() во всех файлах, где упоминается функция hello().</p>

  <p>Файл main.c</p>
<pre>
void hello(int);

int main() {
  hello();
  return 0;
}
</pre>

  <p>Файл hello.c</p>
<pre>
#include &lt;stdio.h&gt;
void hello(int);

void hello(int n) {
  printf("%d", n);
}
</pre>

  <p>Теперь в файле hello.c компилятор проконтролирует соответствие между объявлением и определением функции hello(). Если они не совпадают, то выдаст ошибку.</p>
  <p>В файле main.c компилятор проконтролирует соответствие между объявлением и вызовом функции hello(). Если они не совпадают, то выдаст ошибку.</p>
  <p>Если программист изменит объявление и определение функции в одном файле, но забудет изменить объявление в другом, то компилятор не найдет ошибку, но ошибка выскочит во время линковки.</p>
  <p>На этом этапе наша проблема еще не решена.</p>

  <p>Чтобы решить проблему, нужно в программе иметь только одно объявление функции. Такое объявление выносится в отдельный файл. Такой файл называется <strong>заголовочный</strong>.</p>
  <p>Теперь программа будет состоять из трех файлов main.c, hello.h, hello.c</p>

  <p>Файл hello.h</p>
<pre>
void hello(int);
</pre>

  <p>Файл main.c</p>
<pre>
#include "hello.h"

int main() {
  hello();
  return 0;
}
</pre>

  <p>Файл hello.c</p>
<pre>
#include &lt;stdio.h&gt;
#include "hello.h"

void hello(int n) {
  printf("%d", n);
}
</pre>

  <p>#include это директива препроцессора. Препроцессор вставляет на мето этой директивы содержимое файла hello.h. Одно и то же объявление теперь вставляется и в файл main.c и в файл hello.c. В файле main.c проверяется соответствие между объявлением и вызовом функции. В файле hello.c проверяется соответствие между объявлением и определением функции.</p>
  <p>Теперь наша проблема решена.</p>
  <p>printf это функция стандартной библиотеки языка Си.</p>
  <p>stdio.h это заголовочный файл стандартной библиотеки языка Си.</p>
  <p>libc это стандартная библиотека языка Си.</p>
  <p>stl это стандартная библиотека языка C++.</p>

  <p>Обозначим еще две проблемы</p>
  <ol>
    <li>Почему нельзя сразу включить файл hello.c в файл main.c? Почему мы должны делать отдельный заголовочный файл и включать его?</li>
    <li>Если два файла a.c и b.c используют функции друг из друга, то при подключении их с помощью #include, файлы будут бесконечно вставляться один в другой.</li>
  </ol>

  <p>Рассмотрим сначала первую проблему. Пусть у нас есть файл hello.c, содержащий функцию hello(). И есть два файла main.c и util.c, которым нужен доступ к функции hello(). Если мы в каждый файл включим hello.c</p>
  <p>Файл hello.c</p>
  <code>void hello(int);</code>
  <p>Файл main.c</p>
  <code>#include "hello.c"</code>
  <p>Файл util.c</p>
  <code>#include "hello.c"</code>
  <p>Проходя по первому файлу main.c компилятор создаст первую копию функции hello() в памяти. Проходя по второму файлу util.c компилятор создаст вторую копию функцию hello() в памяти. Линковщик не знает на какой адрес настраивать вызов функции hello() и выдаст ошибку. В программе не может быть две функции с одинаковым именем в одной области видимости.</p>

  <p>Рассмотрим вторую проблему.</p>
  <p>Файл a.h</p>
  <code>#include "b.h"</code>
  <p>Файл b.h</p>
  <code>#include "a.h"</code>
  <p>Вставим директивы условной компиляции.</p>

  <p>Файл a.h</p>
<pre>
#ifndef _a_h_
#define _a_h_
#include "b.h"
#endif
</pre>

  <p>Файл b.h</p>
<pre>
#ifndef _b_h_
#define _b_h_
#include "a.h"
#endif
</pre>
</article>


<!-- Урок 2 -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>Урок 2</h3>

  <h4>Makefile</h4>
  <p>С помощью gcc каждый этап компиляции можно запустить по отдельности.</p>
  <p>Запустить только препроцессор. Преобразует текстовый файл .c в текстовый файл .c, обрабатывая директивы препроцессора.</p>
  <code>gcc -E</code>
  <p>Запустить только компилятор. Преобразует текстовый файл .c в объектный файл .o на языке ассемблера.</p>
  <code>gcc -c</code>
  <p>Запустить только компилятор. Преобразует объектный файл .o на языке ассемблера в исполняемый файл .out на машинных кодах.</p>
  <code>gcc -s</code>
  <p>Если мы какой-то файл поменяли, то нет смысла заново компилировать все файлы. Достаточно скомпилировать измененный файл и провести затем компоновку и линковку. Но каждый раз помнить какие файлы поменялись, а какие нет это очень тяжело. Поэтому хотелось бы иметь какую-то утилиту, которая бы за нас следила за всеми изменениями.</p>
  <p>Пусть у нас есть файл main.cpp, который использует функции из файла util.cpp, объявленные в util.h и функции из файла str.cpp, объявленные в str.h.</p>
  <p>Рассмотрим зависимости. Файл main.o зависит от файлов main.cpp, util.h, str.h. Это значит, что требуется перекомпилировать файл main.o если изменится один из этих трех файлов.</p>
  <p>Файл util.o зависит от файлов util.cpp и util.h.</p>
  <p>Файл str.o зависит от файлов str.cpp и str.h.</p>
  <p>Исполняемый файл main.out зависит от файлов main.o, util.o, str.o.</p>
  <p><strong>Makefile</strong> это текстовый файл, в котором записана вся информация о зависимостях. То есть какие файлы от каких зависят. Если какой-то файл поменялся, то нужна инструкция что и как нужно перекомпилировать. Makefile обрабатывает утилита <strong>make</strong>.</p>
  <p>Если вызвать утилиту make в директории, в которой содержится файл Makefile, утилита make начнет обрабатывать этот файл. Сначала она выяснит что же поменялось. Потом выполнит необходимые инструкции.</p>
  <p>Напишем Makefile для этого примера. Сначала пишется цель, потом двоеточие, потом файлы от которых зависит цель. На новой строчке после знака табуляции пишутся инструкции. Каждая инструкция отделяется от другой знаком табуляции.</p>

  <p>Файл Makefile</p>
<pre>
main: main.o util.o str.o
  gcc main.o util.o str.o -o main
main.o: main.cpp util.h str.h
  gcc -c main.cpp
util.o: util.cpp util.h
  gcc -c util.cpp
str.o: str.cpp str.h
  gcc -c str.cpp
</pre>

  <p>Утилита make может принимать один параметр - цель, которую нужно отследить.</p>
  <p>Файл Makefale может содержать еще одну цель, которая не имеет зависимостей</p>
<pre>
clean:
  rm -rf *.o
</pre>
  <p>rm это утилита удаления. -rf это ключ, который означает ничего не спрашивать.</p>
  <p>Удалим все объектные файлы</p>
  <code>make clean</code>

  <h4>Библиотека STL</h4>
  <p>Библиотека это набор объектных файлов. Это файл в котором склеено много объектных файлов. Есть два вида библиотек: <strong>статические</strong> и <strong>динамические</strong>.</p>
  <p><strong>Статическая библиотека</strong> в линуксе имеет расширение .a от слова archive, в Windows имеет расширение .lib от слова library. Статическая библиотека присоединяется к объектному файлу. Файл <strong>libc.a</strong> представляет собой архив объектных файлов. Когда линковщик встречает функцию из стандартной библиотеки, он достает из нее объектный файл этой функции и пакует вместе с остальными файлами в исполняемый файл.</p>
  <p>Недостаток статической линковки: размер у получившегося файла вырастает.</p>
  <p>Достоинство статической линковки: когда мы запускаем программу на другом компьютере, то к нему нет требований, чтобы он содержал какие-либо библиотеки, потому что все необходимые библиотеки уже зашиты в программе.</p>
  <p><strong>Динамическая библиотека</strong> в линуксе имеет расширение .so от слов shared of object, в Windows имеет расширение .dll. Файл <strong>libc.so</strong>. Никаких новых объектных файлов к программе не присоединяется. В операционной системе есть специальный компонент загрузчик динамических библиотек. Когда программа запускается, он из ее заголовка понимает какие библиотеки должны быть загружены в память, обеспечивает их загрузку и связь с функциями из программы.</p>
  <p>Недостаток динамической линковки: на другой машине будет работать только если там есть файл lib.so. Такие библиотеки могут обновляться в операционной системе. Например, для исправления багов и при выходе новых версий. Отсюда второй недостаток: ваши программы могут требовать разных версий библиотек.</p>
  <p>Достоинство динамической линковки: занимает меньше места.</p>
  <p>gcc это семейство компиляторов. Для языка Си, Pascal, C++. Какой компилятор нужно запускать, он понимает по расширению файла.</p>
  <p>В следующем случае запустится компилятор gcc для языка Си</p>
  <code>gcc -c file.c</code>
  <p>В следующем случае запустится компилятор g++ для языка C++</p>
  <code>gcc -c file.cpp</code>
  <p>g++ это компилятор для C++, он уже не смотрит на расширение файла и любой файл компилирует по правилам C++</p>
  <code>g++ -c file.c</code>
  <code>g++ -c file.cpp</code>
  <p>Библиотека libc всегда подключается автоматически. По умолчанию используется динамическая линковка и динамические библиотеки. Если нужно провести статическую сборку, то надо добавить ключ -static</p>
  <code>gcc -c -static file.c</code>
  <p>Библиотека stl хранится в файле libstdc++. В линуксе лежит в каталоге /usr/lib. При компиляции компилятором g++, она подключается по умолчанию. При компиляции компилятором gcc библиотеку нужно подключить после ключа -l без пробела.</p>
  <code>gcc -lstdc++</code>

  <h3>Тема 3. Указатели</h3>

  <h4>Массивы</h4>

  <p>Оъявление статического массива на 10 элементов типа int. В квадратных скобках должна быть константа. Размер массива определяется на этапе компиляции.</p>
  <code>int array[10];</code>
  <p>В памяти будет выделено место для размера массива в байтах.</p>
  <code>sizeof(array); // 40 байт</code>
  <p>Посчитаем размер массива в элементах.</p>
  <code>sizeof(array) / sizeof(array[0]); // 10 элементов</code>
  <p>Способ инициализации массива через фигурные скобки</p>
  <code>int array[10] = {0,1,2,3,4,5,6,7,8,9};</code>
  <p>При такой инициализации, можно не указывать размер массива в квадратных скобках, потому что его компилятор вычислит автоматически по числу задаваемых значений.</p>
  <code>int array[] = {0,1,2,3,4,5,6,7,8,9};</code>
  <p>Можно инициализировать все элементы одним значением</p>
  <code>int array[10] = {0};</code>
  <p>Создадим статический массив на 5 элементов типа char.</p>
  <code>char array[] = {'H','e','l','l','o'};</code>
  <p>Создадим строку, содержащуюся в статическом массиве из 6 элементов типа char. В массиве будет на 1 элемент больше, за счет того, что для строк компилятор автоматически добавляет последним символом символ терминатор '\0'.</p>
  <code>char str[] = "Hello";</code>

  <h4>Двумерные массивы</h4>
  <code>int M[2][2];</code>
  <code>int M[2][2] = { {1,2},{3,4} };</code>

  <h4>Индексы массива</h4>
  <p>Выход за границы массива ни во время компиляции ни во время выполнения программы не котролируется.</p>

  <h4>Указатели</h4>
<pre>
int *p;
int a;
p = &amp;a; // взятие адреса переменной
int b = *p; // разименование указателя
</pre>
  <p>В результате в переменной b будет то же самое что и в переменной a.</p>
  <p>Размер указателя связан с разрядностью машины. На 32-битной машине размер указателя равен 4 байта. Посмотрим на адрес в переменной p</p>
  <code>printf("%p",p);</code>

  <h4>Связь указателей и массивов</h4>
<pre>
char array[10];
char *p;
p = &array[0];
p = array;
</pre>

  <p>Имя массива является указателем на его начало.</p>

  <h4>Арифметика указателей</h4>
<pre>
int i[10];
char c[10];
int *pi = &i[0];
char *pc = &c[0];
pi += 1;
ci += 1;
</pre>

  <p>Запись вида i[3] компилятор преобразует в *(i+3). Тогда и запись вида 3[i] компилятор преобразует в *(i+3). При работе с массивами, компилятор на самом деле работает с указателями и с памятью.</p>
  <p>Складывать указатели нельзя, но вычитать можно.</p>

  <h4>Различие между указателями разных типов</h4>
</article>


<!-- Урок 3 -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>Урок 3</h3>

  <h4>Применение указателей</h4>
  <ol>
    <li>Поменять местами две переменные
      <code>void swap(int *a, int *b);</code>
    </li>
    <li>Передача массивов в функцию</li>
    <li>Быстродействие
      <code>while (*p) p++;</code>
      вместо
      <code>while (p[i]) p++;</code>
    </li>
  </ol>

  <h4>Ссылки</h4>
  <p>После указателей в язык C++ ввели новую сущность - <strong>ссылки</strong>.</p>
  <p>До появления ссылок можно было с помощью указателей поменять две переменные местами.</p>
<pre>
void swap(int *a, int *b) {
  int tmp = *a;
  *a = *b;
  *b = tmp;
}

int main() {
  int x = 3;
  int y = 5;
  swap(&x, &y);
}
</pre>

  <p>Теперь в C++ появился такой синтаксис, который позволяет эту запись упростить.</p>
<pre>
void swap(int &a, int &b) {
  int tmp = a;
  a = b;
  b = tmp;
}

int main() {
  int x = 3;
  int y = 5;
  swap(x, y);
}
</pre>
  <p>Здесь int &a это ссылка на переменную типа int. В момент компиляции ссылки внутри функции заменятся на указатели.</p>
  <p>У ссылок есть два отличия от указателей.</p>
  <ol>
    <li>Ссылка не может быть неинициализирована. Нельзя написать int &amp;a;</li>
    <li>Ссылка не может быть равна NULL. Нельзя написать int &a = NULL;</li>
  </ol>
  <p>Ссылки ничего нового в язык C++ не принесли. Просто изменилась запись на более понятную.</p>
  <p>Теперь амперсанд используется для двух разных вещей. Это взятие адреса переменных int *p = &a и ссылка на переменную f(int &a).</p>

  <h4>Глобальная память</h4>
  <p>Переменные объявленные за пределами функций называются глобальными. Сколько памяти выделять глобальным переменным, определяет компилятор в момент компиляции. При загрузке программы в память, сразу загружаются в память все ее глобальные переменные. Если в памяти не хватает места для всех глобальных переменных, то программа не загрузится.</p>
  <p>Если программа состоит из нескольких файлов: main.cpp и hello.cpp.</p>

  <p>Файл main.cpp</p>
<pre>
int main() {
  a = 5;
}
</pre>

  <p>Файл hello.cpp</p>
<pre>
int a = 3;
void hello() {}
</pre>
  <p>В этом коде есть проблема. В языке Си компиляция файлов раздельная. При компиляции main() компилятор не знает откуда брать переменную a.</p>

  <p>Файл main.cpp</p>
<pre>
#include "hello.h"

int main() {
  a = 5;
}
</pre>

  <p>Файл hello.h</p>
<pre>
#ifndef _h_h_
extern int a = 3;
void hello() {}
#endif
</pre>

  <p>Файл hello.cpp</p>
<pre>
a = 3;
void hello() {}
</pre>

  <p>Не хорошо использовать глобальные переменные. Возникает две проблемы. Первая проблема: сложно следить за логикой программы. Вторая проблема: возможны конфликты имен, если глобальные переменные объявлены в разных файлах, в том числе в объектных файлах библиотек.</p>

  <h4>Стек</h4>
  <p>В стеке хранятся данные, необходимые для работы функции. Когда вызывается новая функия, то выделяется новая память для кадра стека.</p>
  <p>В кадре стека хранятся входные параметры функции, локальные переменные и адрес возврата из функции. Таким образом стек растет вверх. При рекурсивных вызовах стек может переполниться и программа аварийно завершится. Когда функция заканчивает свою работу, то она освобождает свою память в стеке.</p>
  <p>Для фукции объем выделяемой памяти в стеке определяется в момент компиляции. Нужно знать объем под параметры и под локальные переменные.</p>
  <p>Для программы объем выделяемой памяти в стеке на этапе компиляции определить нельзя, потому что мы не знаем сколько раз и как функции будут вызываться в программе.</p>

  <h4>Динамическая память</h4>
  <p>Динамическая память выделяется в момент работы программы. Если объем данных заранее неизвесен, например вводится с клавиатуры, поступает из сети, вводится из файла, то память под такие данные нужно выделять динамически.</p>
  <p>Динамическая память выделается и освобождается с помощью функций операционной системы из библиотеки stdlib.h.</p>
  <p>Выделим динамическую память для хранения 10000 элементов типа int (40000 байт) и запишем указатель на эту память в переменную p.</p>
  <code>int *p = malloc(10000 * sizeof(int));</code>
  <p>Теперь к элеменам этой памяти можно обращаться как к элементам массива</p>
  <code>int a = p[0]; int b = p[9999];</code>
  <p>Когда работа с выделенной памятью закончена и эти 10000 элементов нам не нужны, то память нужно освободить.</p>
  <code>free(p);</code>
  <p>Сигнатура вызова функции malloc()</p>
  <code>void *malloc(size_t size);</code>
  <p>Причем тип данных size_t опрделяется как</p>
  <code>typedef unsigned int size_t;</code>
  <p>Функция malloc() возвращает указатель на void</p>
  <p>В языке Си произойдет неявное приведение типов.</p>
  <code>int *p = malloc(10000 * sizeof(int));</code>
  <p>В языке C++ нужно явно приводить указатель на void к указателю на нужный тип данных.</p>
  <code>int *p = (int *)malloc(10000 * sizeof(int));</code>

  <p>Проблемы динамической памяти</p>
  <ol>
    <li>Выход за границы. Программист должен следить, чтобы программа не могла обратиться за границы динамической памяти.</li>
    <li>Утечка памяти (memory leak). Программист должен следить, чтобы вся выделенная память затем была освобождена.
    <code>int *p = malloc(10000 * sizeof(int));</code>
    <code>p = malloc(10 * sizeof(int));</code>
    <p>Указатель p показывает только на вторую область памяти из 40 байт. К первой области памяти в 40000 байт нет доступа и ее невозможно освободить, так как на нее не указывает ни один указатель.</p>
    <p>После завершения работы программы операционная система сама автоматически очищает всю выделенную в этой программе динамическую память. Поэтому, если это небольшая программа, которой требуется мало памяти то это ни к чему страшному не приведет. Другое дело если это сервер, который работает без перерыва. При утечках памяти, сначала у него закончится вся оперативная память и тогда операционная система чтобы освободить ее будет скидывать данные из оперативной памяти в файл подкачки, при этом сервер и все остальные программы запущенные на этом компьютере начнут тормозить.</p>
    <p>При эволюции языков программирования, в языке C# уже нет операции освобождения памяти free(). Это делается автоматически сборщиком мусора, который сканирует оперативную память и сам находит такие участки которые больше никому не нужны.</p>
    </li>
    <li>Выделение динамической памяти это самый медленный процесс из трех видов памяти. Операционная система должна просмотреть свои таблицы, чтобы найти в них свободный непрерывный кусок памяти и вернуть указатель на нее.</li>
    <li>В динамической памяти имеет смысл размещать массивы и объекты большого размера. Если в динамической памяти хранить простую переменную, например
      <code>int *p = (int *)malloc(4);</code>
      то она займет 4 байта в динамической памяти, под тип int и еще 4 байта на стеке под указатель на тип int.
    </li>
  </ol>

  <h4>Выделение динамической памяти для двумерного массива</h4>
  <p>Работать с двумерным массивом в динамической памяти можно двумя способами.</p>
  <p>Первый способ. Выделим динамическую память для матрицы n x n, которая вернет указатель на int.</p>
  <code>int *M = (int *)malloc(sizeof(int) * n * n);</code>
  <p>Чтобы обратимся к элементу M[1][2] нужно записать M[1*N+2]. Чтобы обратимся к элементу M[i][j] нужно записать M[i*N+j].</p>
  <p>Заметим, что первым способом мы один раз обращаемся к функции malloc().</p>
  <p>Второй способ. Сначала выделим динамическую память для массива указателей размера n, которая вернет указатель на массив указателей типа int*.</p>
  <code>int **M = (int **)malloc(sizeof(int *) * n);</code>
  <p>Потом в каждый элемент массива записать указатель на свой массив размера n.</p>
<pre>
for (int i = 0; i &lt; n; i++) {
  M[i] = (int *)malloc(sizeof(int) * n);
}
</pre>
  <p>Чтобы обратимся к элементу M[1][2] нужно записать M[1][2]. Чтобы обратимся к элементу M[i][j] нужно записать M[i][j], то есть мы разыменовываем указатель *(*(M+i)+j).</p>
  <p>В этом случае, на самом деле, массив не находится весь целиком в непрерывной области памяти. Сначала выделяется непрерывная область памяти для массива указателей. А потом для каждого указателя выделяется непрерывная область под массив типа int.</p>

  <h4>Освобождение динамической памяти для двумерного массива</h4>
  <p>Сначала нужно освободить память выделенную под каждый внутренний массив, а потом выделенную под указатели.</p>
  <p>Функция malloc() очень медленная. и нам пришлось n+1 раз выделять память функцией malloc().</p>
<pre>
for (int i = 0; i &lt; n; i++) {
  free(M[i]);
}
free(M);
</pre>

  <h4>Третий способ</h4>
  <p>Третий способ это выделение памяти функцией malloc() за два обращения. Доступ к элементам массива имеет вид M[i][j].</p>
  <p>Выделить один массив tmp размером n x n. Выделить второй массив M размером n. В массиве M хранить указатели, которые указывают на адреса из массива tmp, отстоящие друг от друга на размер элемента.</p>

  <h4>Функция calloc()</h4>
  <p>Функция calloc() работает так же как и функция malloc() с одним отличием. Она заполняет выделенную память нулями. Поэтому работает медленнее.</p>

  <h4>Функция realloc()</h4>
  <p>Функция realloc() позволяет изменить размер памяти, выделенной динамически с помощью функии malloc() или calloc().</p>
  <code>int *p = (int*)malloc(sizeof(int)*1000);</code>
  <code>p = realloc(p, sizeof(int)*10000);</code>

  <p>Каждая из функций malloc, calloc, realloc пытается выделить непрерывную память заданного размера. Если выделить память удается, то в качестве значения возвращается указатель на начало памяти. Если этого сделать не удается, то в качестве значения возвращается NULL. Поэтому после каждой операции выделения памяти необходимо проверять, что она выделилась.</p>
  <code>if (p == NULL) {}</code>

  <h4>Выделение динамической памяти в языке C++</h4>
  <p>В C++ для выделения памяти появились два ключевых слова new и delete.</p>
  <code>int *p = new int [1000];</code>
  <code>delete [] p;</code>
  <p>Если в языке Си функции malloc, calloc, realloc принимали в качестве параметра размер памяти, то в языке C++ оператор new требует после себя тип и число элементов.</p>
  <p>После оператора delete нужны квадратные скобки, чтобы компилятор мог обратиться к ячейке памяти, в которой записан размер массива и правильно рассчитать сколько элементов нужно удалить. Это касается только массивов.</p>
</article>


<!-- Урок 4 -->
<article class="article">
  <div class="anchor" id="p4"></div>
  <h3>Урок 4</h3>

  <p>Задание: посмотреть как работает malloc. Принципы поиска свободной памяти.</p>
  <p>Функция free() освобождает память выделенную и под переменную и под массив.</p>
  <p>Оператор delete освобождает память выделенную под переменную.</p>
  <p>Оператор delete [] освобождает память выделенную под массив.</p>
  <p>Оператор delete [] вызывает деструкторы. Для которых нужно знать не только размер массива, но и размеры ячеек из которых он состоит.</p>

  <h4>Стандартная библиотека языка Си libc.</h4>
  <p>stdio.h это заголовочный файл с сигнатурами функций ввода - вывода. Язык Си писался для операционной системы Unix. В философии Unix заложено что любое устройство это файл. Экран это файл, в который можно писать. Клавиатура это файл, с которого можно читать. Области памяти на жестком диске это файлы, в которые можно писать и читать.</p>

  <p>Ввод с клавиатуры scanf(). Вывод на экран printf().</p>

  <h4>Работа с файлом</h4>
  <p>Сначала нужно открыть файл</p>
  <code>FILE* f = fopen("a.txt", "r");</code>
  <p>Если файл не открылся, то fopen() возвращает NULL. Всегда нужно проверять открылся ли файл, прежде чем с ним работать</p>
  <code>if (f == NULL) {}</code>
  <p>Ввод из файла fscanf(). Вывод в файл fprintf().</p>
  <p>Поскольку операции чтения и записи в файл медленные, то используется буфер. Перед тем как в файл запишутся байты данных, они сперва накапливаются в буфере. И потом содержимое буфера пишется в файл целиком.</p>
  <p>Мы не знаем заполнился уже буфер или нет, не знаем сбросил ли он уже байты в файл или нет. Мы можем сами принудительно сбросить байты в файл из буфера командой fflush().</p>
  <code>fflush(f);</code>
  <p>После завершения работы с файлом, его нужно закрыть</p>
  <code>fclose(f);</code>
  <p>Перед закрытием файла команда fclose сбрасывает оставшиеся байты из буфера в файл.</p>

  <h4>Работа с вводом-выводом</h4>
  <p>stdin ввод с клавиатуры, stdout вывод на экран, stderr вывод на экран сообщений об ошибках. stderr не имеет буфера.</p>
  <p>printf("%d",n) это то же самое, что и fprintf(stdout, "%d",n).</p>

  <p>Вывод в файл:</p>
<pre>
FILE* f = fopen("a.txt", "w");
fprintf(f, "...");
</pre>

  <p>Вывод на экран:</p>
<pre>
FILE* f = stdout;
fprintf(f, "...");
</pre>

  <h4>Текстовые и двоичные файлы</h4>
  <p>Отличие текстовых и двоичных файлов в их отображении. Текстовый файл предназначен для чтения человеком. Двоичный файл предназначен для чтения программой. Текстовый файл отображается как набор графических символов из таблицы ASCII. Двоичный файл отображается как набор шестнадцатеричных цифр.</p>
  <p>Для записи английский букв достаточно первой половины таблицы ASCII от 0 до 127 символа. Вторая половина отдана для национальных алфавитов. Национальные алфавиты записываются в различных кодировках. Русский алфавит записывается кодировкой cp866 в системе MS-DOS, кодировкой CP1251 в Windows, кодировкой koi-8r в Unux.</p>
  <p>127 символов хватает не для всех алфавитов. Поэтому была предложена кодировка unicode, в которой символ кодируется четырьмя байтами. Правда используются пока только два байта, так как их хватает для всех известных символов. Есть разные способы записи символов unicode в файл. Первый способ UCS-4, когда символ записывается как 4 байта, где первые два это нули. Второй способ UCS-2, когда символ зависывается как 2 байта, без ведущих нулей. Третий способ UTF-8, когда символы кодируются последовательностями разной длины. Для английских букв длина символа 1 байт. Для совместимости с таблицей ASCII, символы из первой половины таблицы ASCII являются корректными в кодировке UTF-8. Для русского и других языков длина символа 2 байта.</p>
  <p>Для конца строки используются различные символы в различных операционных системах. Linux 10, Mac 13, Windows 1013.</p>
  <p>Для открытия текстовых файлов в функцию fopen дописывают в второй параметр буку t, для двоичных - буку b. Это влияет только на то как в файле будет записан символ перевода строки '\n'.</p>
  <p>Попробуем выполнить один и тот же код в Linux, Windows, с файлом открытом в режимах t или b.</p>
  <code>fprintf(f, "hello\n");</code>
  <p>В Linux в файл запишется 6 символов в любом режиме t или b.</p>
  <p>В Windows в режиме t в файл запишется 7 символов. В режиме b запишется 6 символов.</p>

  <h4>Функция fgets()</h4>
  <p>Считаем из файла a.txt 9 байт в переменную s.</p>
<pre>
FILE* f = fopen("a.txt", "tr");
char s[10];
fgets(s, 9, f);
</pre>

  <h4>Функция sscanf()</h4>
  <p>Считаем из строки в переменную s.</p>
<pre>
char s[10];
sscanf(s, "%d", &n);
</pre>

  <h4>Функция sprintf()</h4>
  <p>Функция sprintf() записывает в строку.</p>

  <h4>Функция feof()</h4>
  <p>Функция feof() определяет конец файла.</p>

  <h4>Работа с двоичными файлами</h4>
  <p>Функция fread() работает с файлами, открытыми в двоичном формате и имеет прототип:</p>
  <code>size_t fread(void *ptr, size_t size, size_t n, FILE* f);</code>

  <p>Считаем из файла 100 целых чисел.</p>
<pre>
int a[100];
fread(a, 4, 100, f);
</pre>

  <p>Функция fwrite() работает с файлами, открытыми в двоичном формате и имеет прототип:</p>
  <code>size_t fwrite(void *ptr, size_t size, size_t n, FILE* f);</code>
  <p>Функция fseek() перемещает указатель на номер текущей позиции внутри файла.</p>
  <p>Функция ftell() возвращает номер текущей позиции.</p>
</article>


<!-- Урок 5 -->
<article class="article">
  <div class="anchor" id="p5"></div>
  <h3>Урок 5</h3>

  <h4>Заголовочный файл assert.h</h4>

  <h4>Функция assert()</h4>
  <p>Функция assert() используется при отладке приложения.</p>
  <p>Пусть мы написали функцию strcmp() в которую нельзя передавать NULL. Функция assert() принимает логическое выражение, если оно не выполняется, то программа аварийно завершается. Эта функция нужна на этапе отладки.</p>
<pre>
// пример 1
strcmp(string s1, string s2) {
  assert(s1 != NULL);
}
</pre>
  <p>Такие проверки нужны только на этапе тестирования.Когда программа попадет к пользователю, то этих проверок в коде остаться не должно.</p>
  <p>Будем добавлять в код определение DEBUG, когда нам нужно скомпилировать программу в режиме DEBUG.</p>
  <code>#define DEBUG</code>
  <p>Чтобы не добавлять эту строчку, можно запустить компилятор с ключем -D и определить DEBUG</p>
  <code>gcc -DDEBUG</code>
<pre>
// пример 2
FILE *f = fopen("a.txt", "r");
assert(f != NULL);
</pre>
  <p>Почему пример 1 можно писать, а пример 2 нельзя писать? Потому что в примере 1 мы ищем ошибку которая не должна произойти не когда. А в примере 2 ошибка может произойти. Аварийно завершать программу при наличии такой ошибки это неправильно. Такую ошибку можно проверить через условие if и выполнить какое-то другое действие.</p>

  <h4>Заголовочный файл complex.h</h4>
  <p>Содержит функции для операций с комплексными числами.</p>

  <h4>Заголовочный файл ctype.h</h4>
  <p>Содержит функции для проверки символа. Нарпимер, isalpha(), isdigit() и т.д.</p>

  <h4>Заголовочный файл errno.h</h4>
  <p>Есть соглашения об ошибках. Если функция не может выполниться, то она должна сообщить об ошибке. Сделать она это может одним из двух способов. Например, вернуть значение, которое сообщит нам об ошибке. Если функция должна вернуть указатель, но не может это сделать, то она возвращает NULL. Если функция должна вернуть положительное число, но не может это сделать, то она возвращает -1.</p>
  <p>В заголовочном файле errno.h определена переменная int errno. Второй способ сообщить об ошибке, если функция записывает код ошибки в переменную errno.</p>

  <h4>Заголовочный файл float.h</h4>
  <p>Содержит константы с вещественными числами.</p>
  <p>FLT_MAX это максимальное число, которое может хранить float</p>
  <p>DBL_MAX это максимальное число, которое может хранить double</p>
  <p>FLT_EPSILON и DBL_EPSILON нужны для сравнения дробных чисел</p>
<pre>
double a = f();
double b = g();
if (a == b) {} // так нельзя
if (fabs(a-b) &lt; DBL_EPSILON) {} // так правильно
</pre>

  <h4>Заголовочный файл limits.h</h4>
  <p>Содержит константы с целыми числами.</p>
  <p>INT_MIN это минимальное число, которое может хранить int</p>
  <p>INT_MAX это максимальное число, которое может хранить int</p>
  <p>UINT_MAX это максимальное число, которое может хранить unsigned int</p>

  <h4>Заголовочный файл inttypes.h</h4>
  <p>На разных платформах размер типа данных int разный. Для 16 битный платформ это 2 байта, для 32 битных платформ это 4 байта, для 64 битных платформ это 8 байт</p>

  <h4>Заголовочный файл math.h</h4>
  <p>Содержит математические функции.</p>

  <h4>Заголовочный файл stdlib.h</h4>
  <p>Содержит функции преобразования типов atof(), atoi().</p>
  <p>Содержит функции для генерации псевдослучайного числа. Функция srand() задает псевдослучайную последовательность, из которой будут доставаться по очереди числа. Функция rand() возвращает следующее число.</p>
  <p>Функция srand(seed) принимает целое число seed и если это константа, то при каждом запуске программы будет генерироваться одна и та же последовательность. Чтобы последовательность всегда была разная, нужно передавать функции srand метку времени time(NULL). Поскольку время при каждом запуске программы разное, то и последовательности всегда будут разные.</p>
  <p>Псевдослучайная последовательность является периодической, то есть с какого-то момента она начнет повторяться.</p>
  <p>Содержит функции для выделения памяти malloc, calloc, realloc, free.</p>
  <p>Содержит функцию exit(), которая аварийно завершает программу и может вернуть в операционную систему какое-то целое число.</p>
  <p>Содержит функцию system(), которая позволяет запустить другую программу и проконтролировать с каким кодом она завершится.</p>
  <p>Содержит функцию qsort() для быстрой сортировки.</p>
  <p>Содержит функцию bsearch() для бинарного поиска в отсортированном массиве.</p>

  <h4>Заголовочный файл string.h</h4>
  <p>Содержит функции для работы со строками strchr, strlen, strcmp.</p>

  <p>Функция strstr() ищет подстроку внутри строки. strstr(s1,s2) вернет NULL если не найдет подстроку s2 внутри строки s1. Или вернет указатель на первое вхождение подстроки s2 внутри строки s1 если оно там есть.</p>
  <p>Функция strtok() разбивает строку по некоторым правилам. При вызове strtok принимает два параметра - строку, с которой будет работать и символ-разделитель. Если вместо строки передать NULL, то функция продолжает работать со строкой, с которой она вызывалась в прошлый раз. Возвращает часть строки до символа-разделителя.Символ разделитель может быть каждый раз разный или один и тот же.</p>
<pre>
char str[] = "This is a simple string";
char *p;
p = strtok(str, " ");
while (p != NULL) {
  printf("%s", p);
  p = strtok(NULL, " ");
}
</pre>

  <h4>Заголовочный файл time.h</h4>
  <p>Функции для работы с временем. Тип данных time_t хранит число милисекунд. Функция time возвращает число милисекунд прошедших с 1 января 1970 года</p>
<pre>
time_t a;
a = time(NULL);
time(&a);
</pre>
  <p>Тип данных clock_t хранит чило тиков (единица процессорного времени). Функция clock возвращает число тиков, прошедших с момента запуска программы. С помощью функции clock можно замерить время выполнения кода в программе.</p>
<pre>
clock_t start = clock();
f();
clock_t finish = clock();
clock_t diff = finish - start;
</pre>

  <h3>Три взгляда на ООП</h3>
  <ol>
    <li>
      <h4>Исторический</h4>
      <p>Размер программы становится больше. Программистов, которые пишут одну программу становится больше. Времени на написание одной программы становится меньше. При этом жертвуются ресурсы. Чем быстрее программист пишет программу, тем больше она занимает памяти и медленнее работает.</p>
      <p>Машинный код -> ассемблер -> языки с ветвлениями и циклами -> группировка переменных в структурах -> группировка функций в классах</p>
    </li>
    <li>
      <h4>Лингвистический</h4>
      <p>Процедурные языки состоят из сказуемых: открой файл, нарисуй дом и т.д.</p>
      <p>В ООП есть подлежащее и сказуемое: файл откройся, дом нарисуйся и т.д.</p>
    </li>
    <li>
      <h4>Практический</h4>
      <p>Хочу собирать программу из готовых модулей, которые друг с другом взаимодействуют.</p>
    </li>
  </ol>
</article>


<!-- Урок 6 -->
<article class="article">
  <div class="anchor" id="p6"></div>
  <h3>Урок 6</h3>

  <h4>Классы</h4>
  <p>Создадим массив, поработаем с ним и удалим его.</p>
<pre>
int *a = new int[100];
a[i] = 1;
delete [] a;
</pre>
  <p>Какие проблемы могут быть при этом:</p>
  <ol>
    <li>можно забыть написать new</li>
    <li>можно обратиться к несуществующему индексу</li>
    <li>можно забыть написать delete</li>
  </ol>
  <p>Напишем класс, который решит за нас эти проблемы.</p>

  <p>Файл array.h</p>
<pre>
#ifndef ARRAY_H_
#define ARRAY_H_

class Array {
private:
  size_t mySize;
  int *myData;

public:
  Array(size_t size);
  ~Array();
  void set(int i, int val);
  int get(int i);
  size_t getSize();
};
#endif
</pre>

  <p>Файл array.cpp</p>
<pre>
#include "Array.h"

Array::Array(size_t size) {
  mySize = size;
  myData = new int[mySize];
}

Array::~Array() {
  delete [] myData;
}

void Array::set(int i. int val) {
  if (i &lt; 0 || i > mySize - 1) {
    return;
  }
  myData[i] = val;
}

size_t Array::get(int i) {
  if (i &lt; 0 \\ i > mySeze - 1) {
    return -1;
  }
  return myData[i];
}

void Array::getSize() {
  return mySize;
}
</pre>

  <p>Файл main.cpp</p>
<pre>
Array a(100);

for (int i = 0; i &lt; a.getSize(); i++) {
  a.set(i, 1);
}
</pre>

  <h4>Проблема копирования и присваивания объектов</h4>
  <p>Рассмотрим две проблемы. Первая. Мы хотим создать массив b, такой же как и массив a.</p>
<pre>
Array a(10);
a.set(0, 5);
Array b(a);
</pre>
  <p>Вторая. Мы создали массив b и хотив присвоить ему массив a.</p>
<pre>
Array a(10);
Array b(20);
b = a;
</pre>
  <p>Отличия этих проблем в том, что в первом случае массив b еще не существует, а во втором случае он уже есть.</p>

  <h4>Конструктор копирования</h4>
  <p>Конструктор копирования по умолчанию, который компилятор добавит сам, выглядит так:</p>
<pre>
Array::Array(Array &a) {
  mySize = a.mySize;
  myData = a.myData;
}
</pre>
  <p>С конструктором по умолчанию есть проблемы. Он делает поверхностное копирование. Все указатели будут указывать на уже существующие области памяти и не будут создаваться новых. Если после этого вызывать деструкторы, то первый деструктор удалит память, а остальные будут пытаться удалить несуществующую память, что приведет к ошибке.</p>
  <p>Если прописать конструктор копирования в приватной части класса, то он никогда не может быть вызван вне класса.</p>

  <p>Файл array.h. Добавим свой конструктор копирования</p>
<pre>
public:
  Array(Array &a);
</pre>
  <p>Файл array.cpp. Добавим свой конструктор копирования</p>
<pre>
Array::Array(Array &a) {
  mySize = a.mySize;
  myData = new int[mySize];
  for (int i = 0; i &lt; mySize; i++) {
    myData[i] = a.myData[i];
  }
}
</pre>

  <h4>Перегрузка оператора присваивания</h4>
  <p>Для того чтобы с объектами можно было производить операции присваивания, нужно написать перегрузку оператора присваивания для класса.</p>

  <p>Файл array.h. Добавим в класс перегрузку оператора присваивания.</p>
<pre>
public:
  Array& operator=(Array &a);
</pre>
  <p>В языке C++ есть две эквивалентные записи b = a и b.operator=(a);</p>
  <p>Файл array.cpp. Добавим свой оператор присваивания</p>
<pre>
Array& Array::operator=(Array &a) {
  if (this != &a) {
    mySize = a.mySize;
    delete [] myData;
    myData = new int[mySize];
    for (int i = 0; i &lt; mySize; i++) {
      myData[i] = a.myData[i];
    }
  }
  return *this;
}
</pre>
</article>


<!-- Урок 7 -->
<article class="article">
  <div class="anchor" id="p7"></div>
  <h3>Урок 7</h3>

  <h4>Ключевое слово const</h4>

  <p>Три варианта расположения const</p>
  <ol>
    <li>
      <p>Константная переменная. Изменить значение нельзя.</p>
      <code>const char n = 10;</code>
      <code>n = 15; // не скомпилируется</code>
    </li>
    <li>
      <p>Указатель на константное значение. Значение *c менять нельзя. Поменять адрес можно, чтобы переменная c указывала на другой адрес.</p>
      <code>const char *c;</code>
      <code>char const *c;</code>
      <code>c[1] = 'a'; // не скомпилируется</code>
      <code>c = c1; // так можно</code>
    </li>
    <li>
      <p>Константный указатель. Поменять адрес нельзя. Значение *c поменять можно.</p>
      <code>char * const c;</code>
      <code>c = c1; // не скомпилируется</code>
      <code>c[1] = 'a'; // так можно</code>
    </li>
    <li>
      <p>Константные указатель на константное значение. Их менять нельзя.</p>
      <code>const char * const c;</code>
    </li>
    <li>
      <p>Массив это как константный указатель. Имя массива указывает на адрес памяти, но этот адрес менять нельзя. Поэтому запись</p>
      <code>char ss[10];</code>
      <p>аналогична константному указателю</p>
      <code>char * const</code>
    </li>
    <li>
      <p>Ссылка это как константный указатель, за исключением того что указатель может равняться NULL.</p>
      <p>Ссылка в отличие от указателя не может быть равна NULL и всегда должна быть инициализирована.</p>
      <p>Записи вида</p>
      <code>int& ref;</code>
      <p>аналогична записи</p>
      <code>int* const ref;</code>
    </li>
    <li>
      <p>Константное поле внутри класса.</p>
      <p>Внутри класса тоже может быть константа, то так как она должна быть инициализирована, то инициализировать ее можно в конструкторе в списке инициализации. А при копировании объектов, константа инициализируется в конструкторе копирования в списке инициализации. А вот оператор присваивания мы определить не можем, потому что в нем нет списка инициализации и константу невозможно будет инициализировать.</p>
<pre>
class Array {
private:
  const int mySize;
public:
  Array(int size): mySize(size) {}
  Array(Array& a): mySize(size) {}
}
</pre>
    </li>
    <li>Константный параметр функции или метода класса.
<pre>
Array(const Array& a) {
  const Array* const a;
}
Array b(10);
Array &a = b;
Array &a = c; // не скомпилируется
</pre>
    </li>
    <li>Константное возвращаемое значение функции
<pre>
const Array& operator=(const Array &a)
</pre>
    </li>
    <li>
      <p>const у метода означает что метод не меняет поля класса, а только их читает.</p>
<pre>
int getSize() const;
int get(int index) const;
</pre>
    </li>
  </ol>

  <p>Пример константный данных:</p>
  <code>char *s = "aaa";</code>
  <p>Строка "aaa" будет размещена в константной области памяти, которую менять нельзя. Поэтому s[0] = 'b'; не скомпилируется.</p>

  <p>Пример константного адреса:</p>
  <code>char s1[] = "bbb";</code>
  <p>Строка "bbb" будет размещена на стеке, поэтому можно поменять любой символ этой строки s1[1] = 'a';. Но поскольку s1 это массив, то его нельзя переприсвоить другому значению. s1 = s2; не скомпилируется</p>
  <p>Константы контроллируются только на этапе компиляции. В объектном коде никаких консант уже нет, соответственно нет проверок, что константа может измениться.</p>

  <p>Файл go.h</p>
<pre>
extern const int X_WIN;
extern const int Y_WIN;
extern const int DRAW;
extern const int NO_WIN;
</pre>

  <p>Файл go.cpp</p>
<pre>
const int X_WIN = 1;
const int Y_WIN = 2;
const int DRAW = 3;
const int NO_WIN = 4;

int isWin() {
  if (...) {
    return X_WIN;
  } else if (...) {
    return Y_WIN;
  } else if (...) {
    return DRAW;
  } else if (...) {
    return 3; // так скомпилируется
  }
}
</pre>

  <p>Если мы хотим, чтобы функция isWin возвращала только одно из перечислинных четырех значений, то можно создать новый тип данных с помощью enum. Это нужно, чтобы был более понятный код.</p>

<pre>
enum {X_WIN, Y_WIN, DRAW, NO_WIN} WinType;
WinType isWin() {
  return 3; // так не скомпилируется
}
</pre>

  <p>Пример 1. Так делать нельзя. Внутри функции создается массив и память для него выделяется на стеке. После выхода из функции массив уничтожается. А указателю b присваивается адрес чужих данных.</p>
<pre>
int *f() {
  int a[100];
  a[0] = 1;
  return a;

}
int main() {
  int *b = f();
  b[0] = 100;
}
</pre>

  <p>Пример 2. Так делать правильно. Внутри функции динамически выделяется память в куче (heap) и создается указатель который указывает на нее. При выходе из функции указатель уничтожается, а выделенная память остается. Указатель на нее возвращается в функцию main и присваивается указателю b.</p>
<pre>
int* f() {
  int *a = new int[100];
  a[0] = 1;
  return a;
}

int main() {
  int* b = f();
  b[0] = 10;
  delete [] b;
}
</pre>

  <p>Пример 3.</p>
<pre>
class Array {
private:
  int myData[100];

public:
  int *getData() {
    return myData;
  }
}

int main() {
  Array a;
  int *b = &getData();
}
</pre>
</article>


<!-- Урок 8 -->
<article class="article">
  <div class="anchor" id="p8"></div>
  <h3>Урок 8</h3>

  <p>Преподаватель Александр Смаль.</p>

  <h3>Компиляция программы на языках C++ и Си</h3>

  <p>Мы пишем текст программы на языке C++ в текстовых файлах с расширением .cpp. Когда мы запускаем компилятор, то происходит следующее:</p>
  <ol>
    <li>Препроцессор из файла .cpp делает файл .cpp в котором уже не содержится никаких инструкций для препроцессора. Получается файл без #.</li>
    <li>Транслятор из файла .cpp без # переводит код программы с одного языка на другой и получается файл на языке ассемблера.</li>
    <li>
      <p>Здесь есть небольшая путаница. Потому что есть язык ассемблер, а есть программа Ассемблер, которая из языка Ассемблера делает двоичный код. Программа Ассемблера переводит программу на языке ассемблера в программу в машинных кодах. Получается бинарный файл с расширением .obj.</p>
      <p>В объектном коде есть таблица всех функций, которые есть в этом объектном файле.</p>
      <p>В объектном файле имена локальных переменных заменяются на их адреса. Остаются только имена глобальных переменных, которые можно использовать между файлами.</p>
    </li>
    <li>
      <p>Из каждого .cpp файла получается свой .obj файл. Чтобы получить из них один исполняемый файл, нужна программа линковка. Линковщик собирает все полученные .obj файлы вместе и на выходе выдает один исполняемый файл .exe.</p>
      <p>Линковщик собирает все таблицы функций со всех объектных файлов и знает какая функция в каком файле описана. После этого ему нужно пройтись по исполняемому коду и посмотреть где какая функция вызывается. Если он видит вызов функции, то смотрит в табличку, находит такую же функцию и подставляет в место вызова вместо имени функции конкретный адрес этой функции в памяти. В исполняемом файле уже имен функций нету.</p>
      <p>Имена глобальных переменных заменяются на их адреса.</p>
      <p>В исполняемом коде нет не только имен функций, но и имен переменных.</p>
    </li>
  </ol>

  <p>В языке C++ можно писать функции с одинаковым именем и разной сигнатурой. Например, void f(int) и void f(double). Тогда в таблице будут записаны две разные функции и имена у них будут тоже разные.</p>
  <p>Так происходит только в языке C++, потому что в языке Си нельзя иметь две разные функции с одинаковым названием. Весь процесс компиляции в языке Си будет точно такой же за одним исключением. Имена функций останутся такими же какие они были в файле cpp.</p>
  <p>Файл объектного кода можно открывать и смотреть какие функции в нем определены.</p>

  <h3>Глобальные переменные</h3>
  <p>У нас есть 2 файла 1.cpp и 2.cpp. Мы хотим чтобы у нас был счетчик, который можно использовать одновременно в этих двух файлах.</p>

  <p>Файл 1.cpp</p>
  <code>int c = 0;</code>

  <p>Файл 2.cpp</p>
<pre>
extern int c;
void f() {
  c = c + 1;
}
</pre>

  <p>Эти файлы скомпилируются. На этапе линковке вместо глобальных переменных подставятся их адреса. Если не написать слово extern, то файлы тоже скомпилируются. Но произойдет ошибка на этапе линковке, потому что есть две глобальные переменные с одинаковым именем.</p>
  <p>Если мы хотим использовать переменную c еще в каком-то файле, то можно ее объявление extern int c; вынести в отдельный заголовочный файл и подключать его там где она нужна.</p>

  <h3>Ключевое слово static</h3>

  <p>Ключевое слово static имеет пять различных значений:</p>
  <ol>
    <li>
      <h4>Глобальные static переменные</h4>
      <p>Можно создать глобальную переменную с одим из двух уровней видимости. Глобальная переменная видна везде:</p>
      <code>int a = 0;</code>
      <p>Глобальная переменная видна только в том файле, где объявлена:</p>
      <code>static int b = 0;</code>
      <p>Создадим два файла 1.cpp и 2.cpp. Создадим в них глобальные переменные разным способом но с одинаковым именем. Во втором файле, переменная a является глобальной для всего проекта, а в первом файле, переменная a является глобальной только для файла 1.cpp.</p>

      <p>Файл 1.cpp</p>
      <code>static int a = 0;</code>

      <p>Файл 2.cpp</p>
      <code>int a = 0;</code>

      <p>Линковка происходит в два этапа: внутренняя (internel) и внешняя (external). Сначала линковщик в каждом объектном модуле создает таблицу, в которой именам переменных и функций сопоставляет их адреса. После этого он проводит внутреннюю линковку. Оставшиеся в модулях глобальные имена заменяются их адресами в результате внешней линковки.</p>
      <p>Создадим заголовочный файл 3.h и создадим в нем глобальную статическую переменную. Подключим этот заголовочный файл в несколько cpp файлов.</p>

      <p>Файл 4.h</p>
      <code>static int k = 0;</code>

      <p>Файл 1.cpp</p>
      <code>#include "4,h"</code>

      <p>Файл 2.cpp</p>
      <code>#include "4,h"</code>

      <p>Файл 3.cpp</p>
      <code>#include "4,h"</code>

      <p>При этом в каждом файле создастся своя переменная k. И это будут три разные переменные.</p>
    </li>
    <li>
      <h4>Локальные static переменные</h4>
      <p>Локальная переменная создается и видна только внутри функции. При каждом вызове функии переменная создается, при выходе из функции переменная уничтожается. В примере, функция всегда будет возвращать 1.</p>
<pre>
int f() {
  int c = 0;
  c = c + 1;
  return c;
}
</pre>
    <p>Локальная переменная, созданная с помощью ключевого слова static создается один раз - при первом вызове функции, видна только внутри функции, не уничтожается и сохраняет свои значения между вызовами функции. В примере, статическая переменная будет служит счетчиком вызовов функции. Функция всегда будет возвращать число своих вызовов.</p>
<pre>
int f() {
  static int c = 0;
  c = c + 1;
  return c;
}
</pre>
    <p>Можно инициализировать такой счетчик параметром функции.</p>
<pre>
int f(int k) {
  static int c = k;
  c = c + 1;
  return c;
}
</pre>
    <p>Инструкция после слова static выполнится только один раз - при первом вызове функции.</p>
    </li>
    <li>
      <h4>static функции</h4>
      <p>По умолчанию все функции объявляются как внешние (с ключевым словом extern). Они имеют глобальную область видимости и видны во всех файлах. Такие функции можно вызывать из любого модуля.</p>
      <code>void f(); то же что и extern void f()</code>
      <p>Ключевое слово static запрещает использование функции из другого модуля. В этом случае происходит внутренняя линковка.</p>
      <code>statis void f();</code>
      <p>При этом можно объявлять статические функции с одинаковыми именами в разных файлах. Они имеют локальную область видимости.</p>
      <p>Пусть в заголовочном файле есть статические переменные и функции</p>
      <p>Файл header.h</p>
<pre>
statis int c = 0;
static void f() {}
</pre>
      <p>Если функция не будет объявлена как статическая и заголовочный файл будет подключен к нескольким файлам, то у нас будет несколько глобальных функций с одинаковым именем, что является ошибкой.</p>
    </li>
    <li>
      <h4>static поле класса</h4>
      <p>Переменная объявленная внутри класса с ключевым словом static является глобальной переменной, которая видна только внутри класса, но не содержится в экземпляре объекта.</p>
<pre>
class Process {
public:
  Process() { c++; }
  ~Process() {c--; }
  statis int c;
};
</pre>
    <p>К статической переменной класса можно получить доступ вне класса, даже если не создан ни один объект. Потому что эта переменная не содержится в экземпляре объекта.</p>
    <code>Process::c;</code>
    <p>Хорошо делать инкапсуляцию, чтобы к переменной можно было обратиться только через функцию getCounnter</p>
<pre>
class Process {
private:
  statis int c;

public:
  Process() { c++; }
  ~Process() {c--; }
  getCounter() {
    return c;
  }
};

Process::getCounter;
</pre>
    <p>Инициализировать статическое поле класса нужно в файле .cpp</p>
    <code>int Process::c = 0;</code>
    </li>

    <li>
      <h4>static метод класса</h4>
      <p>Статический метод класса имеет доступ к приватным полям класса.</p>
<pre>
class Process {
private:
  int d;

public:
  static void f(Process p) {
    p.d = 10;
  }
}
</pre>
    <p>Статический метод существует независимо от объекта и может быть вызван через пространство имен класса</p>
    <code>Process::f(p);</code>
    </li>
  </ol>

  <h3>Ключевое слово inline</h3>
  <p>Мы можем объявить функцию f() внутри заголовочного файла f.h и включить ее в несколько .cpp файлов: 1.cpp, 2.cpp, 3.cpp. При компиляции будет ошибка, потому что мы получим три функции с одинаковым именем.</p>
  <p>Чтобы решить эту проблему, внутри заголовочного файла f.h создадим класс F, внутри которого объявим метод f(). Функции, созданные внутри класса автоматически становятся inline функциями.</p>

  <h3>Структуры</h3>
<pre>
struct Point {
  double x,
  double y,
  double z
};

Point p;
p.x = 10;
</pre>

<pre>
struct Point {
  double norm() {
    return sqrt(x*x+y*y+z*z);
  }
}
</pre>
</article>


<!-- Урок 9 -->
<article class="article">
  <div class="anchor" id="p9"></div>
  <h3>Урок 9</h3>

  <h4>Выделение объектов на стеке</h4>

<pre>
int a = 3;
int *pa;
pa = &amp;a;
</pre>

<pre>
Complex c(3,3);
Complex *pc;
pc = &amp;c;
</pre>

  <p>Внутри функции foo создается объект a, память для которого выделяется на стеке. При выходе из функции вся память выделенная на стеке уничтожается. Функция возвращает указатель на уже не существующую память.</p>
<pre>
Complex *foo() {
  Complex a(3,3);
  return &amp;a;
}
</pre>

  <p>Для таких объектов нужно выделять память на куче.</p>

  <h4>Освобождение объектов на стеке</h4>
  <p>Память на стеке освобождается только при выходе из функции. Это делается автоматически.</p>

  <h4>Выделение объектов на куче</h4>
  <p>Выделение памяти на куче происходит при помощи оператора new.</p>
  <code>Complex *pc = new Complex(); // контруктор по умолчанию</code>
  <code>Complex *pc = new Complex(3,3); // конструктор с параметрами</code>

  <p>Если нужно выделять массив объектов на куче, то тоже можно воспользоваться оператором new. Синтаксис new не предусматривает после себя ничего кроме имени типа. Поэтому тип обязательно должен иметь конструктор по умолчанию, иначе такой код не скомпилируется.</p>
  <code>Complex *pArr = new Complex[100];</code>

  <h4>Освобождение объектов на куче</h4>
  <p>Освобождение памяти на куче происходит при помощи оператора delete</p>
  <code>delete pc;</code>
  <code>delete [] pArr;</code>

  <p>Оператор языка Си free освобождает память и ничего не знает об объектах. Оператор языка C++ delete знает про объекты и прежде чем освободить память, вызывает деструктор.</p>

  <p>Если у объекта нужно вызвать функцию, то синтаксис позволяет использовать два варианта: через точку и через стрелочку</p>
  <code>(*pc).getValue();</code>
  <code>pc->getValue();</code>

  <p>Следующий код скомпилируется, потому что компилятор ошибку не заметит. Но будет ошибка во время выполнения программы.</p>
<pre>
Complex c(3,3);
Complex *pc = 0;
pc->add(c);
</pre>

  <p>При создании объекта на куче, нужно не забывать его освобождать</p>
<pre>
Complex *pc = new Complex(3,3);
delete pc;
</pre>

  <p>Для того чтобы объект всегда уничтожался, можно сделать класс-обертку над указателем и в деструкторе прописать для него delete. Это называется умный указатель smart pointer.</p>
  <p>Рассмотрим 3 случая когда класс A зависит от класса B.</p>
  <p>Класс A содержит указатель</p>
<pre>
class A {
  B& b;
}
</pre>
  <p>Класс A содержит указатель на класс B.</p>
<pre>
class A {
  B *b;
}
</pre>
  <p>Класс A содержит класс B как поле.</p>
<pre>
class A {
  B b;
}
</pre>
</article>


<!-- Урок 10 -->
<article class="article">
  <div class="anchor" id="p10"></div>
  <h3>Урок 10 Умные указатели (Smart Pointers)</h3>

  <h4>1. scoped_ptr</h4>
  <p>Напишем  - оболочку для указателя. Пусть нам нужно выделить на куче объект с помощью new, который будет виден только в пределах фигурных скобок области видимости. Пусть при выходе из области видимости автоматически вызывается delete для созданного объекта.</p>
  <p>Файл scoped_ptr.h</p>
<pre>
class scoped_ptr {
private:
  Object *pObj;

public:
  scoped_ptr(Object *pObject);
  ~scoped_ptr();
  Object *ptr;
};
</pre>

  <p>Файл scoped_ptr.cpp</p>
<pre>
scoped_ptr::scoped_ptr(Object *pObject) {
  pObj = pObject;
}
scoped_ptr::~scoped_ptr() {
  deletepObj;
}
Object *scoped_ptr::ptr() {
  return pObj;
}
</pre>

  <p>Файл main.cpp</p>
<pre>
int main() {
  if (true) {
    scoped_ptr p = new Object();
  }
}
</pre>
  <p>Когда закончится область видимости объекта, то деструктор удалит объект из памяти.</p>

  <p>Если мы создадим второй умный указатель на ту же область памяти, то эта память удалится дважды</p>

  <p>Рассмотрим два примера.</p>
  <p>Первый пример. Файл main.cpp</p>
<pre>
int main() {
  if (true) {
    scoped_ptr p1 = new Object();
    scoped_ptr p2 = p1;
  }
}
</pre>
  <p>Когда программа дойдет до закрывающей скобки. То начнут срабатывать деструкторы. Первым сработает деструктор объекта p1 и удалит объект из памяти. Теперь объект p2 указывает на удаленный объект, которого уже нет. Вторым сработает деструктор объекта p2 и это вызовет ошибку.</p>

  <p>Второй пример. Файл main.cpp</p>
<pre>
int main() {
  if (true) {
    scoped_ptr p1 = new Object();
    scoped_ptr p2 = new Object();
    p2 = p1;
  }
}
</pre>
  <p>Сначала произойдет утечка памяти когда указатель p2 отвязывается от второго объекта и начинает показывать на первый объект. Потом программа дойдет до закрывающей скобки и произойдет проблема, как и в прошлый раз.</p>
  <p>Для решения этой проблемы надо запретить конструктор копирования и оператор присваивания для объектов scoped_ptr. Для этого в классе scoped_ptr сделаем приватные конструктор копирования и оператор присваивания.</p>
  <p>Файл scoped_ptr.h</p>
<pre>
class scoped_ptr {
private:
  Object *pObj;

public:
  scoped_ptr(Object *pObject);
  ~scoped_ptr();
  Object *ptr;

private:
  scoped_ptr(const scoped_ptr &p);
  scoped_ptr& operator=(const scoped_ptr &p);
};
</pre>
  <p>Попытка скопировать или присвоить теперь вызовет ошибку на этапе компиляции, потому что это приватные методы и к ним обращаться извне нельзя.</p>
  <p>Но мы по прежнему можем создать один объект и два указателя на него. И при выходе из области видимости по прежнему будет вызываться двойной delete на одну и ту же область памяти.</p>
  <p>Файл main.cpp</p>
<pre>
Object *pObj = new Object();
scoped_ptr p1 = pObj;
scoped_ptr p2 = pObj;
</pre>
  <p>Есть еще одна ситуация, когда происходит ошибка. Это если записать ноль в scoped_ptr</p>
  <code>scoped_ptr p = 0;</code>
  <p>Самое простое это сделать проверку в деструкторе</p>
  <code>if (pObj) delete pObj;</code>
  <p>И добавить проверку на 0</p>
<pre>
bool isNull();
bool scoped_ptr::isNull() {
  return pObj == 0;
}
</pre>
  <p>Все что scoped_ptr умеет делать это в нужный момент вызывать деструктор и удалять объект. Но он имеет ограничения. Его нельзя передавать в функцию и возвращать из функции. Хотелось бы чтобы умным указателем можно было пользоваться так же как и обычным указателем. Создадим умный указатель на объект</p>
  <code>scoped_ptr p = new Object;</code>
  <p>Нам нужно уметь обращаться к методам объекта и уметь разименовывать указатель и передавать объект по указателю в функцию</p>
  <code>p->doSomething();</code>
  <code>(*p).doSomething();</code>
  <code>func(Object o) {}</code>
  <code>func(*p);</code>

  <h4>Перегрузка (overloading)</h4>
  <p>Функция называется перегруженная если она имеет одно и тоже имя, тип возвращаемого значения, но разный набор параметров.</p>
<pre>
void f(int a);
void f(int a, int b);

int main() {
  f(3);
  f(5,5);
}
</pre>
  <p>При вызове функции компилятор понимает какую функцию нужно вызвать только по набору параметров.</p>
  <p>Для scoped_ptr нам нужно перегрузить операторы</p>
  <code>Object* operator->();</code>
  <code>Object* operator*()</code>
<pre>
Object* scoped_ptr::operator->() {
  return pObj; // возвращает указатель
}

Object* scoped_ptr::operator*() {
  return *pObj; // возвращает объект
}
</pre>
  <p>Теперь можно использовать эти операторы</p>
<pre>
scoped_ptr p1 = new Object();

p1.operator->()->doSomething(); // вызов метода
p1->doSomething(); // это то же самое

Object o = *p;
</pre>

  <h4>2. auto_ptr</h4>
  <p>Напишем auto_ptr - оболочку для указателя, который работает точно также как scoped_ptr за исключением конструктора копирования и оператора присваивания. Смысл указателя auto_ptr в том, чтобы на один объект был только один указатель. Поэтому при копировании и присваивании старый указатель больше не должен указывать на объект.</p>
<pre>
auto_ptr(auto_ptr &p2) {
  pObj = p2.pObj;
  p2.pObj = 0;
}
</pre>

<pre>
auto_ptr p1 = new Object();
auto_ptr p2 = new Object();
p1 = p2;
p1 = p1; // ничего не делать
</pre>

<pre>
auto_ptr& operator=(auto_ptr &p2) {
  if (this == p2) {
    return;
  }
  delete pObj;
  pObj = p2.pObj;
  p2.Obj = 0;
}
</pre>

  <h4>3. shared_ptr</h4>
<pre>
shared_ptr p1 = new Object();
shared_ptr p2 = p1;
</pre>
  <p>shared_ptr хранит в себе переменную count - счетчик ссылок, который показывает сколько существует указателей на данный объект. p1 и p2 это два указателя на объект storage, который хранит счетчик указателей на объект и свой указатель на объект.</p>
<pre>
storage {
  pObj;
  int count;
}
</pre>
  <p>Теперь в деструкторе мы можем проверить сколько ссылок на объект существует. Если больше одной, то уменьшаем счетчик на 1. Если осталась одна ссылка, то уничтожаем объект. Такая техника называется подсчет ссылок.</p>
</article>


<!-- Урок 11 -->
<article class="article">
  <div class="anchor" id="p11"></div>
  <h3>Урок 11 Связный список (Linked List)</h3>

  <p>Напишем класс для связного списка, который хранит целые числа.</p>
  <p>Файл List.h</p>
<pre>
class List {
protected:
  int myValue;
  List *myNext;

public:
  List(int value) {
    myValue = value;
    myNext = 0;
  }

  virtual void addValue(int value) {
    List *current = this;
    while (current->myNext != 0) {
      current = current->myNext;
    }
    current->myNext = new List(value);
  }

  int len() {
    int counter = 0;
    for (List *current = this; current != 0; current = current->myNext) {
      counter++;
    }
    return counter;
  }
};
</pre>

  <p>Файл main.cpp</p>
<pre>
#include "List.h"

int main() {
  List l(5);
  l.addValue(6);
  l.addValue(7);
}
</pre>

  <p>По односвязному списку идти можно только вперед.</p>

  <h4>Двусвязный список (Double Linked List)</h4>
  <p>Напишем класс для двусвязного списка, который хранит целые числа. Он будет незначительно отличаться от класса List. Чтобы не писать весь класс заново, можем использовать уже готоый класс List. Создадим класс DList, который наследуется от класса List.</p>
  <p>Файл DList.h</p>
<pre>
class DList: public List {
private:
  DList *myPrev;

public:
  DList(int value): List(value) {
    myPrev = 0;
  }

  void addValue(int value) {
    DList *current = this;
    while (current->myNext != 0) {
      current = (DList*)current->myNext;
    }
    current->myNext = new DList(value);
    ((DList*)current->myNext)->myPrev = current;
  }
};
</pre>

  <p>Файл main.cpp</p>
<pre>
#include "List.h"

int main() {
  DList l(5);
  l.addValue(6);
  l.addValue(7);
}
</pre>

  <p>List это базовый (base) класс, или родительский. Dlist это производный (derived) класс, или наследник.</p>
  <p>Напишем функцию addSequence, которая добавляет в список l, num раз, значение val.</p>

  <p>Файо main.cpp</p>
<pre>
void addSequence(List *l, int num, int val) {
  for (int i = 0; i &lt; num; i++) {
    l->addValue(val);
  }
}

int main() {
  Dlist l(6);
  addSequence(&l,10,5);
  addSequence(&l,10,6);
}
</pre>
  <p>Объект производного класса является и объектом базового класса. Объект производного класса наследует все функции из базового класса, то есть он умеет все то что умеет и базовый класс.</p>
  <p>Файл main.cpp</p>
<pre>
int tmp = 0;
scanf("%d", &tmp);
List *l = 0;
if (tmp == 1) {
  l = new List(5);
} else {
  l = new DList(6);
}
l->addValue(6);
</pre>
  <p>На момент компиляции неизвестно какой будет объект - класса List или DList. Но потом у этого объекта все равно можно вызвать метод addValue, потому что это метод родительского класса Lis, а это значит, что он обязательно есть в дочернем классе DList</p>

  <h4>Перекрытие (override)</h4>
  <p>Если в классе-наследнике мы хотим переопределить функцию из родительского класса, то перед функцией в родительском классе должно стоять ключевое слово virtual. В этом случае функция в классе-наследнике перекрывает родительскую функцию. При этом сигнатуры обеих функций должны быть одинаковые.</p>

  <h4>Связывание (binding) (статическое и динамическое)</h4>
  <p>Связывание это сопоставление имени функции и адреса в памяти с кодом функции.</p>
  <p>Статическое связывание происходит во время компиляции. На стадии линковки вместо имен функций подставляются их адреса.</p>
  <p>После того как появилось наследование - все изменилось. На этапе компиляции невозможно определить какая функция вызовется - из родительского класса или из дочернего.</p>
  <p>Динамическое связывание происходит во время выполнения программы. Ключевое слово virtual, стоящее перед объявлением функции, означает, что для этой функции нужно использовать динамическое свзывание. В этом есть полиморфизм.</p>
</article>


<!-- Урок 12 -->
<article class="article">
  <div class="anchor" id="p12"></div>
  <h3>Урок 12 Связывание (binding) (статическое и динамическое)</h3>

  <p>Если в классе есть виртуальная функция, то компилятор создает таблицу виртуальных функций.</p>
  <p>Чисто виртуальная функция не имеет тела и приравнивается нулю. Она нужна для построения абстрактного класса. Абстрактный класс должен содержать хотя бы одну чисто виртуальную функцию. От абстрактного класса нельзя создать объект. Абстрактный класс нужен только для того чтобы от него наследовались другие классы. Он задает интерфейс, обязательный для реализации классами-наследниками.</p>
  <p>Если в классе есть хотя бы одна виртуальная функция, то нужно делать виртуальный деструктор. Чтобы при удалении объекта производного класса, созданного как объект родительского класса, также вызывался деструктор и у него.</p>
  <p>Если деструктор родительского класса не сделать виртуальным, то произойдет статическое связывание и при удалении объекта вызовется только деструктор родительского класса, а деструктор производного класса не вызовется.</p>
  <code>Base *p = new Derived();</code>
  <code>delete p;</code>
</article>
