<h1>C++</h1>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p><a href="#install">install</a></p>
  <ol>
    <li><a href="#wsl">Командная строка wsl</a></li>
    <li><a href="#gcc">Компилятор gcc</a></li>
    <li><a href="#clang">Компилятор clang</a></li>
    <li><a href="#vscode">Редактор кода VS Code</a></li>
    <li><a href="#visualstudio">IDE Visual Studio</a></li>
    <li><a href="#first">Первая программа</a></li>
    <li><a href="#gcc-setup">Настройка компилятора g++ и clang++</a></li>
  </ol>
  <p>Практика</p>
  <ul>
    <li><a href="#endl">Конец строки</a></li>
    <li><a href="#namespace">namespase</a></li>
    <li><a href="#locale">Локализация и кириллица в консоли</a></li>
  </ul>
  <p><a href="#struct">Структура программы</a></p>
  <ol>
    <li><a href="#instr">Инструкции</a></li>
    <li><a href="#block">Блок кода</a></li>
    <li><a href="#fmain">Функция main</a></li>
    <li><a href="#include">Директива include</a></li>
    <li><a href="#comments">Комментарии</a></li>
    <li><a href="#compil">Компиляция</a></li>
    <li><a href="#var">Переменная</a></li>
    <li><a href="#init">Инициализация переменной</a></li>
    <li><a href="#const">Константа</a></li>
  </ol>
  <p><a href="#types">Типы данных</a></p>
  <ol>
    <li><a href="#bool">Логический тип bool</a></li>
    <li><a href="#integer">Целочисленные типы</a></li>
    <li><a href="#float">Числа с плавающей точкой</a></li>
    <li><a href="#sizeof">Оператор sizeof()</a></li>
    <li><a href="#char">Символьные типы</a></li>
    <li><a href="#auto">Спецификатор auto</a></li>
    <li><a href="#cast1">Неявное преобразование типа</a></li>
    <li><a href="#cast2">Явное преобразование типа</a></li>
  </ol>
  <p><a href="#using">using Пространство имен и псевдонимы</a></p>
  <p><a href="#assoc">Ассоциативность операторов</a></p>
  <p><a href="#inout">Ввод и вывод</a></p>
  <ol>
    <li><a href="#inout1">Ввод и вывод в консоли</a></li>
    <li><a href="#inout2">Ввод и вывод из файла</a></li>
    <li><a href="#inout3">Перенаправление потока stdin, stdout</a></li>
    <li><a href="#freopen">Как решить ошибку компиляции freopen</a></li>
  </ol>
</article>


<!-- install-->
<article class="article">
  <div class="anchor" id="install"></div>
  <h2>install</h2>

  <p>Для того чтобы написать свою первую программу на языке C++, достаточно редактора кода и компилятора. В редакторе кода будем писать код, а компилятором компилировать его в исполняемый файл.</p>
  <p>Три самых популярных компилятора это</p>
  <ol>
    <li>Компилятор gcc от проекта GNU</li>
    <li>Компилятор Clang от проекта LLVM</li>
    <li>Компилятор C++ от компании Microsoft (используется в Visual Studio)</li>
  </ol>
  <p>В качестве редактора кода можно использовать и Notepad++ (тоже два плюса как и в C++). Но мы будем использовать VS Code. В него можно поставить расширение для языка C++.</p>
  <p>После того, как первая программа написана, можно поставить среду разработки IDE.</p>
  <p>Самый профессиональный вариант это использовать Microsoft Visual Studio</p>
  <p>Можно использовать Code Blocks</p>
</article>


<!-- Командная строка -->
<article class="article">
  <div class="anchor" id="wsl"></div>
  <h3>Командная строка</h3>

  <p>Проверим что установлена командная строка wsl</p>
  <code>wsl -v</code>
  <code>Версия WSL: 2.3.24.0</code>
  <p>(сокращение от wsl --version)</p>

  <p>На Windows 10 рекомендуем установить WSL (Windows Subsystem for Linux) или WSL2</p>
  <code><a href="https://learn.microsoft.com/ru-ru/windows/wsl/install">https://learn.microsoft.com/ru-ru/windows/wsl/install</a></code>
  <p>Команда установки wsl</p>
  <code>wsl --install</code>
</article>


<!-- Компилятор gcc-->
<article class="article">
  <div class="anchor" id="gcc"></div>
  <h2>Компилятор gcc от проекта GNU</h2>

  <p>Проверим что установлен компилятор gcc</p>
  <code>gcc -v</code>
  <code>gcc.exe (GCC) 14.1.0</code>
  <p>(сокращение от gcc --version)</p>

  <p><a href="https://gcc.gnu.org/">https://gcc.gnu.org/</a> Бесплатный компилятор Си и C++</p>
</article>


<!-- Компилятор clang-->
<article class="article">
  <div class="anchor" id="clang"></div>
  <h2>Компилятор clang от проекта LLVM</h2>

  <p>Проверим что установлен компилятор clang</p>
  <code>clang -v</code>
  <code>clang version 18.1.8</code>
  <p>(сокращение от clang --version)</p>

  <p><a href="https://clang.llvm.org/">https://clang.llvm.org/</a> Бесплатный компилятор Си и C++</p>
</article>


<!-- Редактор кода VS Code-->
<article class="article">
  <div class="anchor" id="vscode"></div>
  <h2>Редактор кода VS Code</h2>
  <h3>Установим бесплатный редактор кода Visual Studio Code</h3>
  <ol>
    <li>
      <p>Переходим на сайт</p>
      <code><a href="https://visualstudio.microsoft.com/ru">https://visualstudio.microsoft.com/ru</a></code>
    </li>
    <li>
      <p>Выбираем Бесплатныя версия Visual Studio - и попадаем на страницу</p>
      <code><a href="https://visualstudio.microsoft.com/ru/free-developer-offers/">https://visualstudio.microsoft.com/ru/free-developers-offers</a></code>
    </li>
    <li>
      <p>Выбираем</p>
      <code>Visual Studio Code - Скачать бесплатно -Пользовательский установщик</code>
      <p>Сохраняем установочный файл на компьютере и запускаем его</p>
      <code>VSCodeUserSetup-x64-q.93.1.exe</code>
    </li>
  </ol>
</article>


<!-- Среда разработки Visual Studio-->
<article class="article">
  <div class="anchor" id="visualstudio"></div>
  <h2>Среда разработки Visual Studio</h2>

  <h3>Установим бесплатную версию Visual Studio Community</h3>
  <ol>
    <li>
      <p>Переходим на сайт</p>
      <code><a href="https://visualstudio.microsoft.com/ru">https://visualstudio.microsoft.com/ru</a></code>
    </li>
    <li>
      <p>Выбираем Бесплатныя версия Visual Studio - и попадаем на страницу</p>
      <code><a href="https://visualstudio.microsoft.com/ru/free-developer-offers/">https://visualstudio.microsoft.com/ru/free-developers-offers</a></code>
    </li>
    <li>
      <p>Выбираем</p>
      <code>Visual Studio Community - Скачать бесплатно</code>
      <p>Сохраняем установочный файл на компьютере и запускаем его</p>
    </li>
    <li>
      <p>Откроется окно</p>
      <code>Идет установка - Visual Studio Community 2022 - 17.11.4</code>
    </li>
    <li>
      <p>Выбираем пункт</p>
      <code>Разработка классических приложений на C++</code>
    </li>
    <li>
      <p>Нажимаем Установить</p>
    </li>
  </ol>

  <h3>Напишем первую программу на C++ в Visual Studio</h3>
  <ol>
    <li>
      <p>Откроем Visual Studio 2022 и выберем пункт</p>
      <code>Начало работы - Создание проекта</code>
    </li>
    <li>
      <p>Откроется окно</p>
      <code>Создание проекта</code>
      <p>Выбираем шаблон</p>
      <code>C++ - Консольное приложение</code>
      <p>Нажимаем Далее</p>
    </li>
    <li>
      <p>Откроется окно</p>
      <code>Настроить новый проект</code>
      <p>Зададим имя проекта</p>
      <code>hello</code>
      <p>Нажимаем Создать</p>
    </li>
    <li>
      <p>Visual Studio создаст новый проект для консольного приложения с файлом hello.cpp который содержит код вывода в консоль строки Hello World. Выбираем меню</p>
      <code>Сборка - Собрать решение (Ctrl+Shift+B)</code>
    </li>
    <li>
      <p>Выбираем меню</p>
      <code>Отладка - Запуск без отладки (Ctrl+F5)</code>
    </li>
  </ol>
</article>


<!-- Первая программа-->
<article class="article">
  <div class="anchor" id="first"></div>
  <h3>Первая программа</h3>

  <ol>

    <li>
      <p>Создадим файл</p>
      <code>hello.cpp</code>
    </li>

    <li>
      <p>Запишем в него код первой программы</p>
<pre>#include &lt;iostream&gt;
int main() {
  std::cout &lt;&lt; "Hello, world!";
  return 0;
}</pre>
    </li>

    <li>
      <p>Откроем терминал и запустим компилятор</p>
      <code>g++ hello.cpp</code>
    </li>

    <li>
      <p>По умолчанию компилятор создаст исполняемый файл <strong>a.exe</strong>. Запустим его</p>
      <code>./a</code>
    </li>

    <li>
      <p>Увидим результат работы программы</p>
      <code>Hello, world!</code>
    </li>

  </ol>
</article>


<!-- Настройка компилятора g++ и clang++ -->
<article class="article">
  <div class="anchor" id="gcc-setup"></div>
  <h3>Настройка компилятора g++ и clang++</h3>

  <p>Можно совместить компиляцию и выполнение одной командой</p>
  <code>g++ source.cpp && ./a</code>

  <p>Можно задать имя исполняемого файла после флага <strong>-o</strong></p>
  <code>g++ source.cpp -o source</code>

  <p>Для компиляции с предупреждениями применяется флаг <strong>-Wall</strong></p>
  <code>g++ -Wall source.cpp</code>

  <p>Можно задать компиляцию в определенный стандарт после флага <strong>-std=</strong></p>
  <code>g++ -std=c++20 source.cpp</code>

  <p>Чтобы гарантировать, что программа будет строго соответствовать определенному стандарту дополнительно используют флаг <strong>-pedantic</strong></p>
  <code>g++ -std=c++20 -Wall -pedantic source.cpp</code>
  <p>В этом случае компилятор будет генерировать предупреждения, если код не соответствует правилам стандарта</p>
</article>


<!-- Конец строки -->
<article class="article">
  <div class="anchor" id="endl"></div>
  <h3>Конец строки</h3>

  <p>Добавим в выводе на консоль конец строки и переход на новую строку</p>
<pre>#include &lt;iostream&gt;
int main() {
  std::cout &lt;&lt; "Hello, world!\n";
  return 0;
}</pre>

  <p>или</p>
<pre>#include &lt;iostream&gt;
int main() {
  std::cout &lt;&lt; "Hello, world!" &lt;&lt; std::endl;
  return 0;
}</pre>
</article>


<!-- namespace -->
<article class="article">
  <div class="anchor" id="namespace"></div>
  <h3>namespace</h3>

  <p>Избавимся от префиксов std::</p>
<pre>#include &lt;iostream&gt;
using namespace std;
int main() {
  cout &lt;&lt; "Hello, world!" &lt;&lt; endl;
  return 0;
}</pre>
</article>


<!-- Локализация и кириллица в консоли-->
<article class="article">
  <div class="anchor" id="locale"></div>
  <h3>Локализация и кириллица в консоли</h3>

  <p>Встроенная функция <strong>setlocale()</strong> явным образом задает текущую локаль для вывода символов. Вместо объекта <strong>cout</strong> применяется объект <strong>wcout</strong>, который работает с символами <strong>Unicode</strong>. В этом случае кодировка исходного кода должна быть в <strong>UTF-8</strong>, а перед строкой указан символ <strong>L</strong></p>
<pre>#include &lt;iostream&gt;
int main() {
  setlocale(LC_ALL, "");
  std::wcout &lt;&lt; L"Привет, мир!";
  return 0;
}</pre>
</article>


<!-- Структура программы -->
<article class="article">
  <div class="anchor" id="struct"></div>
  <h3>Структура программы</h3>
</article>


<!-- Инструкции -->
<article class="article">
  <div class="anchor" id="locale"></div>
  <h3>Инструкции</h3>

  <p>Программа на C++ состоит из набора инструкций. Каждая инструкция (statement) выполняет определенное действие. В конце инструкции ставится точка с запятой (;)</p>
  <code>std::cout &lt;&lt; "Hello world";</code>
</article>


<!-- Блок кода -->
<article class="article">
  <div class="anchor" id="block"></div>
  <h3>Блок кода</h3>

  <p>Набор инструкций может представлять блок кода. Блок кода заключается в фигурные скобки, а инструкции помещаются между открывающей и закрывающей фигурными скобками.</p>
<pre>{
  std::cout &lt;&lt; "Hello world";
  std::cout &lt;&lt; "Bye world";
}</pre>
</article>


<!-- Функция main -->
<article class="article">
  <div class="anchor" id="fmain"></div>
  <h3>Функция main</h3>

  <p>Каждая программа на языке C++ должна иметь как минимум одну функцию - функцию main(). Именно с этой функции начинается выполнение приложения. Ее имя main фиксировано и для всех программ на C++ всегда одинаково.</p>
  <p>Функция также является блоком кода, поэтому ее тело обрамляется фигурными скобками.</p>
<pre>#include &lt;iostream&gt;
int main() {
  std::cout &lt;&lt; "Hello world!";
  return 0;
}</pre>
  <p>Определение функции main начинается с возвращаемого типа. Функция main в любом случае должна возвращать число. Поэтому ее определение начинается с ключевого слова int</p>
</article>


<!-- Директива include -->
<article class="article">
  <div class="anchor" id="include"></div>
  <h3>Директива include</h3>

  <p>Чтобы использовать вывод на консоль, необходимо в начале файла подключать библиотеку iostream с помощью директивы include</p>
  <code>#include &lt;iostream&gt;</code>
  <p>Каждая директива препроцессора размещается на одной строке. В отличие от обычных инструкций, которые завершаются точкой с запятой, директива завершается переводом на новую строку, а начинается со знака решетки #.</p>
</article>


<!-- Комментарии -->
<article class="article">
  <div class="anchor" id="comments"></div>
  <h3>Комментарии</h3>

  <p>При компиляции комментарии игнорируются и не оказывают никакого влияния на работу и размер программы.</p>
  <p>Однострочный комментарий начинается с двойного слеша // и заканчивается концом стоки</p>
  <p>Многострочный комментарий может занимать несколько строк и записывается между символами /* и */</p>
</article>


<!-- Компиляция -->
<article class="article">
  <div class="anchor" id="compil"></div>
  <h3>Компиляция</h3>

  <p>Компиляция исходного кода в исполняемый файл состоит из трех этапов</p>
  <ol>
    <li>Препроцессор обрабатывает все директивы препроцессора (например, #include)</li>
    <li>Компилятор обрабатывает каждый файл с исходным кодом и создает из него объектный файл, который содержит машинный код. Если код написан в нескольких исходный файлах, то для каждого создается свой объектный файл</li>
    <li>Компоновщик (он же линтер) объединяет все объектные файлы в единую программу. Данный процесс называется компоновкой/линковкой</li>
  </ol>
</article>


<!-- Переменная -->
<article class="article">
  <div class="anchor" id="var"></div>
  <h3>Переменная</h3>

  <p>Переменная представляет именнованный участок памяти. Переменная имеет тип, имя, значение. Тип определяет размер занимаемой памяти, какие данные может хранить переменная, какие действия можно делать с этими данными.</p>
  <p>Перед использованием переменной, ее надо определить</p>
  <code>int age;</code>
  <p>Мы определили переменную age с типом int.</p>
</article>


<!-- Инициализация переменной -->
<article class="article">
  <div class="anchor" id="init"></div>
  <h3>Инициализация переменной</h3>

  <p>После определения переменной можно присвоить значение. Присвоение переменной начального значения называется инициализацией.</p>
  <code>age = 20;</code>
  <p>Можно в одной строке выполнить и определение и инициализацию переменной</p>
  <code>int age = 20;</code>
  <p>В C++ есть три вида инициализации</p>
  <ol>
    <li>
      <h4>Нотация присваивания (assignment notation)</h4>
      <p>Значение переменной присваивается с помощью знака равно =</p>
      <code>int age = 38;</code>
      <p>Постоянные значения любого типа называются литералами. Переменной присваивается целочисленный литерал.</p>
    </li>
    <li>
      <h4>Функциональная нотация (function notation)</h4>
      <p>Значение переменной указывается в круглых скобках</p>
      <code>int age (38);</code>
    </li>
    <li>
      <h4>Инициализация в фигурных скобках (braced initialization)</h4>
      <p>Значение переменной указывается в фигурных скобках</p>
      <code>int age {38};</code>
      <p>Инициализация в фигурных скобках безопаснее когда применяется сужающее преобразование. Ожидается, что переменной передается значение, соответствующее ее типу. Если это не так, компилятор попытается преобразовать значение в тип переменной. Сужающее преобразование изменяет значение одного типа на тип с более ограниченным диапазоном значений. Такое преобразование может привести к потери информации.</p>
    </li>
  </ol>
</article>


<!-- Константа -->
<article class="article">
  <div class="anchor" id="const"></div>
  <h3>Константа</h3>

  <p>Константа определяется так же как и переменная, но вначале идет ключевое слово const. Константу нужно определять и инициализировать сразу в одном выражении.</p>
  <code>const int age = 38;</code>
  <code>const float pi {3.14};</code>
</article>


<!-- Типы данных -->
<article class="article">
  <div class="anchor" id="types"></div>
  <h3>Типы данных</h3>

  <p>Каждая переменная имеет определенный тип. Этот тип пишется перед переменной в момент ее определения и его потом нельзя изменить.</p>
</article>


<!-- Логический тип bool -->
<article class="article">
  <div class="anchor" id="bool"></div>
  <h3>Логический тип bool</h3>

  <p>Логический тип bool может хранить одно из двух значений <strong>true</strong> или <strong>false</strong></p>
</article>


<!-- Целочисленные типы -->
<article class="article">
  <div class="anchor" id="integer"></div>
  <h3>Целочисленные типы</h3>

  <p>К целочисленным относятся следующие типы данных</p>
  <ul>
    <li>
      <h4>signed char</h4>
      <p>Занимает 1 байт памяти. Хранит значение от -128 до 127</p>
    </li>
    <li>
      <h4>unsigned char</h4>
      <p>Занимает 1 байт памяти. Хранит значение от 0 до 255</p>
    </li>
    <li>
      <h4>char</h4>
      <p>Занимает 1 байт памяти. Представляет один символ в кодировке ASCII</p>
    </li>
    <li>
      <h4>short</h4>
      <p>Занимает 2 байта памяти. Хранит значение от -32768 до 32767</p>
    </li>
    <li>
      <h4>unsigned short</h4>
      <p>Занимает 2 байта памяти. Хранит значение от 0 до 65535</p>
    </li>
    <li>
      <h4>int</h4>
      <p>Занимает 2 или 4 байта в зависимости от архитектуры процессора. Хранит значение от -32768 до 32767 (при 2 байтах) или от -2 147 483 648 до 2 147 483 647 (при 4 байтах)</p>
    </li>
    <li>
      <h4>unsigned int</h4>
      <p>Занимает 2 или 4 байта в зависимости от архитектуры процессора. Хранит значение от 0 до 65535 (при 2 байтах) или от 0 до 4 294 967 295 (при 4 байтах)</p>
    </li>
    <li>
      <h4>long</h4>
      <p>Занимает 4 или 8 байт в зависимости от архитектуры процессора. Хранит значение от -2 147 483 648 до 2 147 483 647 (при 4 байтах) или от -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807 (при 8 байтах)</p>
    </li>
    <li>
      <h4>unsigned long</h4>
      <p>Занимает 4 байта. Хранит значение от 0 до 4 294 967 295</p>
    </li>
    <li>
      <h4>long long</h4>
      <p>Занимает 8 байт. Хранит значение от -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807</p>
    </li>
    <li>
      <h4>unsigned long long</h4>
      <p>Занимает 8 байт. Хранит значение от 0 до 18 446 744 073 709 551 615</p>
    </li>
  </ul>
  <p>Начиная со стандарта с++14 в язык добавлена возможность разделения разрядов числа с помощью одинарной кавычки</p>
  <code>1'234'567'890</code>
  <p>По умолчанию числа пишутся в десятичной системе счисления. Но можно указать и другие системы</p>
  <p>Шестнадцатеричная система использует префикс 0x или 0X</p>
  <code>int num = 0x1A; // 26 в десятичной</code>
  <p>Восьмеричная системма использует префикс 0</p>
  <code>int num = 0377; // 255 в десятичной</code>
  <p>Двоичная система использует префикс 0b или 0B</p>
  <code>int num = 0b11111111; // 255 в десятичной</code>
</article>


<!-- Числа с плавающей точкой -->
<article class="article">
  <div class="anchor" id="float"></div>
  <h3>Числа с плавающей точкой</h3>

  <p>Число с плавающей точкой состоит из двух частей - мантисы и степени. Оба могут быть положительными или отрицательными. Величина числа - это мантиса, умноженная на десять в степени экспоненты.</p>

  <ul>
    <li>
      <h4>float</h4>
      <p>Занимает 4 байта. Хранит значение от +/- 3.4e-38 до 3.4e+38</p>
      <p>1 бит занимает знак числа. 8 бит для экспоненты. 23 бита для мантиссы (с точностью в 7 десятичных знаков). В сумме 32 бита</p>
    </li>
    <li>
      <h4>double</h4>
      <p>Занимает 8 байт. Хранит значение от +/- 1.7e-308 до 1.7e+308</p>
      <p>1 бит занимает знак числа. 11 бит для экспоненты. 52 бита для мантиссы (с точностью в 16 десятичных знаков). В сумме 64 бита</p>
    </li>
    <li>
      <h4>long double</h4>
      <p>Занимает 10 байт (80 бит). Хранит значение от -3.4e-4932 до 1.1e+4932</p>
    </li>
  </ul>
</article>


<!-- Оператор sizeof() -->
<article class="article">
  <div class="anchor" id="sizeof"></div>
  <h3>Оператор sizeof()</h3>

  <p>Оператор sizeof() возвращает размер памяти в байтах, которую занимает переменная</p>
</article>


<!-- Символьные типы -->
<article class="article">
  <div class="anchor" id="char"></div>
  <h3>Символьные типы</h3>

  <p>В C++ есть следующие символьные типы данных</p>
  <ul>
    <li>
      <h4>char</h4>
      <p>Занимает 1 байт. Представляет один символ в кодировке ASCII. Хранит значение от 0 до 255</p>
      <code>char a1 {'A'};</code>
      <code>char a2 {65};</code>
    </li>
    <li>
      <h4>wchar_t</h4>
      <p>Занимает 2 байта. Представляет расширенный символ. Хранит значение от 0 до 65 535</p>
      <code>wchar_t a1 {L'A'};</code>
      <code>wchar_t a2 {L'\x41'};</code>
      <p>Для вывода в консоль символов wchar_t нужно использовать не std::cout, а поток std::wcout</p>
      <code>std::wcout &lt;&lt; L'\x41';</code>
      <p>При этом поток td::wcout может работать как с char, так и с wchar_t</p>
    </li>
    <li>
      <h4>char8_t</h4>
      <p>Занимает 1 байт. Представляет один символ в кодировке Unicode. Хранит значение от 0 до 255</p>
    </li>
    <li>
      <h4>char16_t</h4>
      <p>Занимает 2 байта. Представляет один символ в кодировке Unicode. Хранит значение от 0 до 65 535</p>
    </li>
    <li>
      <h4>char32_t</h4>
      <p>Занимает 4 байта. Представляет один символ в кодировке Unicode. Хранит значение от 0 до 4 294 967 295</p>
    </li>
  </ul>
</article>


<!-- Спецификатор auto -->
<article class="article">
  <div class="anchor" id="auto"></div>
  <h3>Спецификатор auto</h3>

  <p>Спецификатор auto позволяет компилятору самому определить тип переменной. При объявлении со спецификатором auto переменная должна быть сразу инициализирована.</p>
</article>


<!-- Неявное преобразование типа -->
<article class="article">
  <div class="anchor" id="cast1"></div>
  <h3>Неявное преобразование типа</h3>

  <p>Все целочисленные литералы без суффиксов по умолчанию имеют тип int (signed int). При инициализации переменной с типом unsigned int произойдет неявное преобразование. Компилятор автоматически преобразует тип signed int к типу unsigned int</p>
  <code>unsigned int age {25};</code>
  <p>Если такое преобразование невозможно то будет ошибка компиляции</p>
  <code>unsigned int age {-25};</code>

  <h4>Преобразование в логический тип</h4>
  <p>Значение 0 преобразуется в <strong>false</strong>, все остальные значения преобразуются в <strong>true</strong></p>
  <code>bool a = 1; // true</code>
  <code>bool b = 3.14; // true</code>
  <code>bool c = 'c'; // true</code>
  <code>bool d = 0; // false</code>

  <h4>Преобразование в целый тип из логического</h4>
  <p>Логическое <strong>true</strong> преобразуется в 1, логическое <strong>false</strong> в 0</p>
  <code>int a = true; // 1</code>
  <code>int b = false; // 0</code>

  <h4>Преобразование целого числа в дробное</h4>
  <p>Может произойти потеря точности</p>
  <code>double a = 35005000000333; // 3.5005e+012</code>

  <h4>Преобразование в беззнаковый тип</h4>
  <p>Если значение выходит за диапазон допустимых, то присваивается остаток от деления по модулю</p>
  <code>unsigned char a = -5; // 251</code>
  <code>unsigned short b = -3500; // 62036</code>
</article>


<!-- Явное преобразование типа -->
<article class="article">
  <div class="anchor" id="cast2"></div>
  <h3>Явное преобразование типа</h3>

  <p>Для выполнения явных преобразований типов (explicit type conversion) применяется оператор static_cast</p>
</article>


<!-- using Пространство имен и псевдонимы -->
<article class="article">
  <div class="anchor" id="using"></div>
  <h3>using Пространство имен и псевдонимы</h3>

  <p>В объектах std::cout, std::cin, std::endl используется префикс std:: который указывает что объекты cout, cin, endl определены в пространстве имен std. А само двойное двоеточие :: это оператор области видимости, который указывает пространство имен в котором определен объект. Без префикса std:: мы эти объекты использовать не можем.</p>
  <p>Оператор using позволяет ввести в программу объекты из различных пространств имен</p>
  <code>using namespace std</code>
  <code>cout &lt;&lt; "age";</code>
  <p>Второе предназанчение слова using это определять псевдонимы для типов. Например, можно сократить название длинных типов</p>
  <code>using ullong = unsigned long long;</code>
  <code>ullong n {10234};</code>
  <p>Для определения псевдонимов можно использовать и старый подход в стиле языка Си с помощью оператора typedef</p>
  <code>typedef unsigned long long ullong;</code>
  <code>ullong n {10234};</code>
</article>


<!-- Ассоциативность операторов -->
<article class="article">
  <div class="anchor" id="assoc"></div>
  <h3>Ассоциативность операторов</h3>

  <p>Операторы могут быть <strong>левоассоциативными</strong> - выполняются слева направо и <strong>правоассоциативными</strong> - выполняются справа налево</p>
  <p>В основном все операторы левоассоциативные</p>
  <p>Правоассоциативные операторы - унарные операторы, операторы присваивания и условный оператор</p>
</article>


<!-- Ввод и вывод -->
<article class="article">
  <div class="anchor" id="inout"></div>
  <h3>Ввод и вывод</h3>
</article>


<!-- Ввод и вывод в консоли -->
<article class="article">
  <div class="anchor" id="inout1"></div>
  <h3>Ввод и вывод в консоли</h3>

  <p>Для ввода и вывода в консоли нужно подключить библиотеку <strong>iostream</strong>.</p>
  <code>#include &lt;iostream&gt;</code>
  <p>Поток - это последовательность символов, которая записывается на устройство ввода-вывода или считывается с него.Консоль - это устройство ввода-вывода.</p>
  <p>Для чтения с консоли применяется объект <strong>cin</strong> и оператор <strong>&gt;&gt;</strong>.</p>
  <code>std::cin >> n;</code>
  <p>Для вывода символов на консоль применяется объект <strong>cout</strong> и оператор <strong>&lt;&lt;</strong>.</p>
  <code>std::cout &lt;&lt; n;</code>
</article>


<!-- Ввод и вывод из файла -->
<article class="article">
  <div class="anchor" id="inout2"></div>
  <h3>Ввод и вывод из файла</h3>

  <p>Для ввода и вывода из файла нужно подключить библиотеку <strong>fstream</strong>.</p>
  <code>#include &lt;fstream&gt;</code>
  <p>Для ввода символов из файла нужно файл связать с входным потоком</p>
  <code>ifstream fin("input.txt");</code>
  <code>fin >> n;</code>
  <p>Для вывода символов в файл нужно файл связать с выходным потоком</p>
  <code>ofstream fout("output.txt");</code>
  <code>fout &lt;&lt; n;</code>
  <p>После работы с файлами, нужно их закрыть</p>
  <code>fin.close();</code>
  <code>fin.close();</code>
</article>


<!-- Перенаправление потока stdin, stdout -->
<article class="article">
  <div class="anchor" id="inout3"></div>
  <h3>Перенаправление потока stdin, stdout</h3>

  <h4>Перенаправление stdin, stdout и stderr на файлы, определенные пользователем</h4>

  <p>Используем функцию freopen() для перенаправления заранее открытых файлов stdin, stdout и stderr на файлы, определенные пользователем.</p>
  <ul>
    <li>"r" Открывает для чтения. Если файл не существует или не удается найти, вызов завершается ошибкой freopen.</li>
    <li>"w"	Открывает пустой файл для записи. Если указанный файл существует, его содержимое удаляется.</li>
  </ul>
<pre>
freopen("input.txt", "rt", stdin);
freopen("output.txt", "wt", stdout);

int n;
cin >> n;
cout &lt;&lt; n * n;
</pre>

  <h4>Использование файлов</h4>
  <p>Мы запускаем часть кода в Debug режиме. В Release он не будет виден, поэтому при запуске на сервере Codeforces не будет происходить подключение файлов</p>
<pre>
int main() {

#ifdef _DEBUG
freopen("input1.txt", "rt", stdin);
freopen("output1.txt", "wt", stdout);
#endif
}
</pre>
  <p>Добавим файлы <strong>input1.txt</strong> и <strong>output1.txt</strong> в проект.</p>
  <ol>
    <li>
      <p>В окне <strong>Обозреватель решений</strong> выбираем</p>
      <code>Исходный файл - Добавить - Создать элемент (Ctrl+Shift+A)</code>
    </li>
    <li>
      <p>В открывшемся окне <strong>Добавление нового элемента</strong> выбираем <strong>Файл C++ (.cpp)</strong>. Задаем имя файла <strong>input1.txt</strong>. Нажимаем <strong>Добавить</strong></p>
    </li>
    <li>
      <p>В окне <strong>Обозреватель решений</strong> создается текстовый файл</p>
      <code>Исходные файлы - input1.txt</code>
    </li>
    <li>Также создаем файл <strong>output2.txt</strong></li>
  </ol>
</article>


<!-- Как решить ошибку компиляции freopen -->
<article class="article">
  <div class="anchor" id="freopen"></div>
  <h3>Как решить ошибку компиляции freopen</h3>

  <p>Если в проекте на C++ изпользовать функцию freopen().</p>
  <p>Если при компиляции выдается предупреждение</p>
  <code>error C4996: 'freopen': This function or variable may be unsafe. Consider using freopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.</code>

  <p>Microsoft объявила ряд функций устаревшими (deprecated) - freopen, fopen, fscanf, chsize и т.д. Это связано с тем, что данные функции не проверяют возможности переполнения буфера. Например, может произойти запись за пределами выделенного буфера, что может привести к изменению значений других данных, затиранию информации на стеке - к трудно находимым ошибкам при выполнении программы. Для устранения этого недостатка были разработаны безопасные функции с суффиксом _s (freopen_s)</p>

  <p>Есть 2 способа решения этой проблемы.</p>

  <h4>1 способ</h4>
  <p>Изменяем настройки в Visual Studio и этой проблемы на этой Visual Studio больше не будет.</p>
  <p>В Visual Studio выбрать пункт меню</p>
  <code>Проект - Свойства Alt+F7</code>
  <p>Откроется окно <strong>Страница свойств</strong>. Выбрать пункт</p>
  <code>Свойства конфигурации - C/C++ - Препроцессор</code>
  <p>В строке <strong>Определения препроцессора</strong> справа будет стрелочка выбора, нажать на нее и выбрать <strong>Изменить</strong></p>
  <p>Откроется окно <strong>Определения препроцессора</strong>. В верхнем текстовом поле надо добавить строчку, для того чтобы снять ограничения на открытия других файлов функцией freopen().</p>
  <code>_CRT_SECURE_NO_WARNINGS</code>
  <p>Нажимаем <strong>OK</strong>, <strong>Применить</strong>, <strong>ОК</strong></p>

  <h4>2 способ</h4>
  <p>Добавляем директиву в исходный код программы и этой проблемы для этой программы больше не будет.</p>
  <p>Чтобы продолжать пользоваться старыми функциями, можно попробовать отключить сообщения с ошибкой C4996. Для этого объявите макросы <strong>перед заголовочными файлами</strong> стандартных библиотек. Мне помог первый макрос</p>
  <code>#define _CRT_SECURE_NO_WARNINGS</code>
  <code>#define _CRT_SECURE_NO_DEPRECATE</code>
  <code>#define _CRT_NONSTDC_NO_DEPRECATE</code>
</article>
