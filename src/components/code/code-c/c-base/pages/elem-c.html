<h1>Язык Си</h1>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p><a href="#dir">Директивы препроцессора</a></p>
  <ol>
    <li><a href="#dir1">#include</a></li>
    <li><a href="#dir2">#define</a></li>
    <li><a href="#dir3">#undef</a></li>
    <li><a href="#dir4">#ifdef #endif</a></li>
    <li><a href="#dir5">#ifndef #endif</a></li>
    <li><a href="#dir6">#if #elif #else #endif</a></li>
  </ol>
  <p><a href="#var">Переменные</a></p>
  <ol>
    <li><a href="#var1">Объявление переменной</a></li>
    <li><a href="#var2">Ключевые слова при объявлении переменных</a></li>
    <li><a href="#var3">Область видимости</a></li>
    <li><a href="#var4">Массив переменных</a></li>
    <li><a href="#var5">Константа const</a></li>
    <li><a href="#var6">Перечисление констант enum</a></li>
    <li><a href="#var7">Создание константного типа</a></li>
    <li><a href="#var8">Размер переменной sizeof()</a></li>
  </ol>
  <p><a href="#point">Указатели</a></p>
  <p><a href="#flag">Флаги и маски</a></p>
  <p><a href="#types">Типы данных</a></p>
  <ol>
    <li><a href="#types1">Символьные типы char, wchar_t</a></li>
    <li><a href="#types2">Модификаторы типа int</a></li>
    <li><a href="#types3">Суффиксы целочисленных типов</a></li>
    <li><a href="#types4">Платформонезависимые типы данных</a></li>
    <li><a href="#types5">Вещественные типы данных float, double</a></li>
    <li><a href="#types6">Тип без значения void</a></li>
    <li><a href="#types7">Создание пользовательского типа typedef</a></li>
    <li><a href="#sizeof">Размер типа данных sizeof()</a></li>
    <li>
      <a href="#types6">Преобразование типов</a>
      <ol>
        <li><a href="#types61">Неявное преобразование</a></li>
        <li><a href="#types62">Явное преобразование (приведение)</a></li>
      </ol>
    </li>
  </ol>
  <p><a href="#lex">Лексемы языка Си</a></p>
  <ol>
    <li><a href="#lex1">Алфавит языка Си</a></li>
    <li><a href="#lex2">Идентификаторы</a></li>
    <li><a href="#lex3">Ключевые слова</a></li>
    <li><a href="#lex4">Константы</a></li>
    <li><a href="#lex5">Знаки операций</a></li>
    <li><a href="#lex6">Разделители и пунктуаторы</a></li>
  </ol>
  <p><a href="#comments">Комментарии</a></p>
  <p><a href="#eof">Признак конца файла EOF</a></p>
  <p><a href="#oper">Выражения и операции</a></p>
  <ol>
    <li><a href="#oper1">Приоритет операций</a></li>
    <li><a href="#oper2">Адресные операции</a></li>
    <li><a href="#oper3">Арифметические операции</a></li>
    <li><a href="#oper4">Битовые операции</a></li>
    <li><a href="#oper5">Логические операции</a></li>
    <li><a href="#oper6">Условная операция (тернарный оператор &:)</a></li>
    <li><a href="#oper7">Операции доступа</a></li>
    <li><a href="#oper8">Операции присваивания</a></li>
    <li><a href="#oper9">Операции сравнения</a></li>
    <li><a href="#oper10">Операция запятая</a></li>
  </ol>
  <p><a href="#operator">Операторы</a></p>
  <p><a href="#inout">Операции ввода-вывода</a></p>
  <ol>
    <li><a href="#printf">Функция printf()</a></li>
    <li><a href="#printf1">Спецификатор формата</a></li>
    <li><a href="#printf2">Печать символа</a></li>
    <li><a href="#printf3">Печать целого числа</a></li>
    <li><a href="#printf4">Печать дробного числа</a></li>
    <li><a href="#printf5">Печать строки</a></li>
    <li><a href="#fprintf">Функция fprintf()</a></li>
    <li><a href="#sprintf">Функция sprintf()</a></li>
    <li><a href="#wprintf">Функция wprintf()</a></li>
    <li><a href="#scanf">Функция scanf()</a></li>
    <li><a href="#fscanf">Функция fscanf()</a></li>
    <li><a href="#puts">Функция puts()</a></li>
    <li><a href="#fputs">Функция fputs()</a></li>
    <li><a href="#gets">Функция gets()</a></li>
    <li><a href="#fgets">Функция fgets()</a></li>
  </ol>
  <p><a href="#file">Работа с файлами</a></p>
  <ol>
    <li><a href="#fopen">Функция fopen()</a></li>
    <li><a href="#fread">Функция fread()</a></li>
    <li><a href="#fwrite">Функция fwrite()</a></li>
  </ol>
  <p><a href="#rand">Рандомные числа</a></p>
</article>


<!-- Директивы препроцессора -->
<article class="article">
  <div class="anchor" id="dir"></div>
  <h3>Директивы препроцессора</h3>

  <p>Когда компилятор смотрит исходный код, то первым делом он выполняет директивы препроцессора.</p>
  <p>Каждая директива размещается на одной строке и начинается символом #.</p>
  <p>Концом директивы является перевод на новую строку. Точка с запятой (;) не ставится.</p>
  <p>Если в конце строки последним симолом будет прямой слеш /, то директиву можно продолжить на следующей строке.</p>
</article>


<!-- #include -->
<article class="article">
  <div class="anchor" id="dir1"></div>
  <h3>#include</h3>

  <p>Директива <strong>#include</strong> определяет какие файлы надо включить в данном месте в текст программы. Компилятор заменяет директиву #include на текст программы из этого файла</p>
  <code>#include ИМЯ_ФАЙЛА</code>
  <p>Подключим файл заголовков стандартной библиотеки ввода-вывода</p>
  <code>#include &lt;stdio.h&gt;</code>
</article>


<!-- #define -->
<article class="article">
  <div class="anchor" id="dir2"></div>
  <h3>#define</h3>

  <p>Директива <strong>#define</strong> определяет константы и макросы</p>
  <code>#define ИМЯ_КОНСТАНТЫ ЗНАЧЕНИЕ</code>
  <p>Директива #define должна быть в самом начале файла с кодом программы. Все определенные таким образом константы будут заменены в коде программы препроцессором еще до ее компиляции.</p>
  <p>Определим целочисленную константу</p>
  <code>#define STO 100</code>
  <p>Определим вещественнуб константу</p>
  <code>#define PI 3.1415</code>
  <p>Определим строковую константу</p>
  <code>#define VERSION "version 2"</code>
</article>


<!-- #undef -->
<article class="article">
  <div class="anchor" id="dir3"></div>
  <h3>#undef</h3>

  <p>Директива <strong>#undef</strong> уничтожает константы и макросы, определенные директивой <strong>#define</strong>.</p>
  <code>#undef STO</code>
  <code>#undef PI</code>
  <code>#undef VERSION</code>
</article>


<!-- #ifdef #endif-->
<article class="article">
  <div class="anchor" id="dir4"></div>
  <h3>#ifdef #endif</h3>

  <p>Директива <strong>#ifdef</strong> используется для условной компиляции. Проверяется условие, если константа, написанная после директивы #ifdef определена директивой #define, то все что ниже и до директивы #endif будет компилироваться.</p>
  <p>После директивы #ifdef используют директиву #define для определения константы.</p>
  <p>Директива <strong>#ifdef</strong> всегда должна заканчиваться директивой <strong>#endif</strong></p>
  <p>Директива #ifdef может определить операционную систему компьютера. В windows определена константа _WIN32, а в LINUX - linux.</p>
<pre>
#ifdef _WIN32
#define SYSTEM "Windows"
#endif
</pre>
</article>


<!-- #ifndef #endif -->
<article class="article">
  <div class="anchor" id="dir5"></div>
  <h3>#ifndef #endif</h3>

  <p>Директива <strong>#ifndef</strong> используется для условной компиляции. Проверяется условие, если константа не определена, то все что ниже и до директивы #endif будет компилироваться.</p>
  <p>После директивы #ifndef используют директиву #define для определения константы.</p>
  <p>Директива <strong>#ifndef</strong> всегда должна заканчиваться директивой <strong>#endif</strong></p>
</article>


<!-- #if #elif #else #endif -->
<article class="article">
  <div class="anchor" id="dir6"></div>
  <h3>#if #elif #else #endif</h3>

  <p>Директива <strong>#if</strong> используется для условной компиляции и всегда должна заканчиваться директивой <strong>#endif</strong></p>
</article>


<!-- Переменные -->
<article class="article">
  <div class="anchor" id="var"></div>
  <h3>Переменные</h3>

  <p>Переменная это контейнер для хранения данных. Данные хранятся в памяти компьютера в двоичном виде. Переменная любого типа будет записана в память компьютера в двоичном виде.</p>
</article>


<!-- Объявление переменной -->
<article class="article">
  <div class="anchor" id="var1"></div>
  <h3>Объявление переменной</h3>

  <p>Перед использованием переменной ее надо объявить, иначе будет ошибка и программа не скомпилируется.</p>

  <p>При объявлении переменной сначала указывается ее тип, потом ее имя</p>
  <code>int number;</code>
  <p>Объявление нескольких переменных одного типа можно выполнить через запятую</p>
  <code>char a, b, c, d;</code>

  <p>При <strong>объявлении переменной</strong> определяется <strong>адрес переменной</strong> в памяти и <strong>число байт</strong> для хранения <strong>значения переменной</strong>. Если <strong>значение переменной</strong> занимает больше одного байта, то <strong>адрес переменной</strong> указывает на первый байт.</p>

  <h4>Инициализация переменной</h4>

  <p><strong>Инициализация переменной</strong> это присвоение значения переменной в первый раз. Инициализацию можно выполнить при объявлении переменной или после объявления</p>
  <code>int number = 10;</code>
  <code>char a, b, c; a = 'A'; b = 'B'; c = 'C';</code>
  <p>При присвоении значения переменной левая часть от знака равно называется <strong>L-value</strong>, а правая часть <strong>R-value</strong>.</p>

  <h4>Переменная примитивного типа</h4>
  <p>Переменная <strong>примитивного типа</strong> по <strong>адресу переменной</strong> хранит свое значение. При объявлении переменной примитивного типа компилятор выделяет в памяти столько байт, сколько нужно для хранения данных данного типа. При инициализации переменной примитивного типа по адресу переменной в выделенную память записывается ее значение</p>

  <h4>Переменная ссылочного типа</h4>
  <p>Переменная <strong>ссылочного типа</strong> по <strong>адресу переменной</strong> хранит другой адрес на место в памяти, где хранится ее значение. При объявлении переменной ссылочного типа компилятор выделяет в памяти 8 байт для хранения адреса. Переменные ссылочного типа всегда занимают одинаковый размер, потому что хранят только адрес.</p>
</article>


<!-- Ключевые слова при объявлении переменных -->
<article class="article">
  <div class="anchor" id="var2"></div>
  <h3>Ключевые слова при объявлении переменных</h3>

  <p>При объявлении переменных можно использовать одно из пяти ключевых слов:</p>
  <ol>
    <li>
      <h4>auto</h4>
      <p>Создает переменную с ограниченной областью видимости. Переменная объявляется внутри функции и доступна только внутри этой функции. </p>
      <code>auto char a;</code>
      <p><em>Современный стандарт делает все переменные объявленные внутри функции доступными только внутри этой функции. Поэтому нет необходимости использовать ключевое слово <strong>auto</strong>. Но оно осталось в языке для совместимости со старыми программами.</em></p>
    </li>
    <li>
      <h4>extern</h4>
      <p>Если глобальную переменную нужно использовать внутри функции, то внутри функции ее надо объявить с ключевым словом <strong>extern</strong></p>
      <code>extern char b;</code>
    </li>
    <li>
      <h4>static</h4>
      <p>Создает переменную или функцию с ограниченной областью видимости. Область видимости переменной или функции ограничена одним файлом, в котором она объявлена. В разных файлах можно использовать разные глобальные переменные с одинаковым именем, если они объявлены с ключевым словом <strong>static</strong></p>
      <code>static char c;</code>
    </li>
    <li>
      <h4>register</h4>
      <p>Дает указание компилятору создать переменную в регистре компьютера для быстрого доступа к ней. Так можно объявить только локальные переменные, их число строго ограничено и переменные могут быть только определенных типов. Компиляторы игнорируют это указание если не могут поместить переменные в регистры.</p>
      <code>register int num = 100;</code>
      <p><em>В современном стандарте это слово уже не используют и оно осталось лишь для совместимости со старыми программами.</em></p>
      <p>Если для переменной, объявленной с помощью ключевого слова register использовать операцию &, компилятор разместит переменную в памяти компьютера, а не в регистре</p>
    </li>
    <li>
      <h4>volatile</h4>
      <p>Противоположно слову register. Дает указание компилятору что переменную нельзя помещать в регистр, так как она может в любой момент поменять свое значение.</p>
      <code>volatile char d = 'Q';</code>
      <p><em>В современном стандарте это слово уже не используют и оно осталось лишь для совместимости со старыми программами.</em></p>
    </li>
  </ol>
</article>


<!-- Область видимости -->
<article class="article">
  <div class="anchor" id="var3"></div>
  <h3>Область видимости</h3>

  <p><strong>Область видимости</strong> переменной это место в программе, где доступна данная переменная</p>

  <h4>Локальные переменные</h4>
  <p><strong>Локальные переменные</strong> объявляются внутри функции и по умолчанию доступны только внутри данной функции.Чтобы принудительно сделать локальную переменную доступную только внутри функции, используют ключевое слово auto в объявлении переменной. Локальная переменная будет создана после каждого вызова функции и будет удалена после каждого завершения функции</p>
  <code>auto char a;</code>

  <h4>Глобальные переменные</h4>
  <p><strong>Глобальные переменные</strong> объявляются вне функций и по умолчанию доступны внутри любой функции. Глобальная переменная объявляется всего один раз в начале программы. Глобальная переменная будет создана после запуска программы и будет удалена после завершения программы.</p>
  <p>Глобальные переменные нужно объявить внутри каждой функции, которая их использует. Такое объявление начинается со слова extern, которое указывает что переменная является внешней</p>
  <code>extern char b;</code>

  <p>Глобальные переменные и все функции доступны из любой функции любого файла программы. Чтобы область видимости глобальной переменной или функции была ограничена только тем файлом, в котором она объявлена, нужно в объявлении использовать ключевое слово <strong>static</strong></p>
  <code>static char c;</code>

  <p>Обычно программа не способна использовать несколько переменных с одинаковым именем. Но переменные, объявленные с ключевым словом <strong>static</strong> и являющиеся уникальными текущем файле, могут иметь одинаковые имена в разных файлах.</p>

  <p>Внутренние глобальные переменные, объявленные со словом <strong>static</strong> доступны только внутри функции, в которой они объявлены, но не пропадут после завершения работы функции</p>
</article>


<!-- Массив переменных -->
<article class="article">
  <div class="anchor" id="var4"></div>
  <h3>Массив переменных</h3>

  <p>Массив переменных хранит несколько элементов данных в отличие от обычных переменных, которые могут хранить только один элемент. Элементы данных хранятся последовательно в ячейках массива, которые нумеруются начиная с нуля.</p>

  <h4>Объявление массива</h4>
  <p>Перед использованием массива его надо объявить, иначе будет ошибка и программа не скомпилируется.</p>
  <p>При объявлении массива сначала указывается тип переменных, которые он будет хранить, потом имя массива, потом в квадратных скобках количество элементов в массиве - размер</p>
  <code>int nums[3];</code>

  <p>Объявление нескольких переменных одного типа можно выполнить через запятую</p>
  <code>int nums[3], nums2[6], nums3[9];</code>

  <p>Если не присваивать значения при объявлении, то в массиве будет храниться "мусор" - данные, оставшиеся в памяти от других программ.</p>
  <p>При объявлении <strong>массива</strong> определяется <strong>адрес массива</strong> в памяти и <strong>число байт</strong> для хранения массива. Адрес массива указывает на первый байт.</p>

  <p>Если при объявлении массива сразу его <strong>инициализировать</strong>, то в <strong>объявлении массива</strong> можно оставить квадратные скобки пустыми и не писать в них размер. В таком случае размер массива будет определен автоматически.</p>
  <code>int nums[] = {1, 2, 3, 4};</code>

  <h4>Инициализация массива</h4>
  <p><strong>Инициализация массива</strong> это присвоение значений элементам массива в первый раз. Инициализацию можно выполнить при объявлении массива</p>
  <code>int nums[3] = [10, 20, 30];</code>
  <p>После объявления массива можно проинициализировать только его отдельные элементы, а не весь массив сразу</p>
  <code>int nums2[3];</code>
  <code>nums2[0] = 40;</code>

  <h4>Текстовые строки в массиве типа char</h4>
  <p>Создадим массив типа char. Это массив символов</p>
  <code>char sym = {'a', 'b', 'c'}; // массив символов</code>

  <p>Чтобы создать строку, надо в конец массива типа char поместить символ-терминатор '\0'.</p>
  <code>char str = {'a', 'b', 'c', '\0'}; // строка</code>
</article>


<!-- Константа const -->
<article class="article">
  <div class="anchor" id="var5"></div>
  <h3>Константа const</h3>

  <p>Если значение переменной никогда меняться не будет, то ее надо объявлять с ключевым словом const и инициализировать при объявлении. Такая переменная называется константа.</p>
  <code>const int MILLION = 1000000;</code>

  <p>Если элементы массива никогда не будут меняться, то массив тоже надо объявлять с ключевым словом const и инициализировать при объявлении.</p>
  <code>const int FIVE[] = {1, 2, 3, 4, 5};</code>
</article>


<!-- Перечисление констант enum -->
<article class="article">
  <div class="anchor" id="var6"></div>
  <h3>Перечисление констант enum</h3>

  <p>Ключевое слово enum создает удобное <strong>перечисление</strong> целочисленных констант. Для объявления последовательности констант надо написать ключевое слово <strong>enum</strong>, после этого можно написать <strong>имя перечисления</strong>, а можно и не писать. Затем в фигурных скобках пишут имена констант через запятую.</p>
  <code>enum {MON, TUE, WED, THU, FRI}; // MON = 0, TUE = 1 ...</code>

  <p>Если значения констант не указаны, то первая будет иметь значение 0, а каждая следующая на 1 больше</p>

  <code>enum days{MON = 1, TUE, WED, THU = 30, FRI}; // MON = 1, TUE = 2 ... FRI = 31</code>
  <p>При объявлении любой константе может быть присвоено свое значение. Тогда следующая константа без значения будет на 1 больше</p>

  <code>enum {NIL = 0, NONE = 0};</code>
  <p>Константы в перечислении могут содержать одинаковые значения</p>
</article>


<!-- Создание константного типа -->
<article class="article">
  <div class="anchor" id="var7"></div>
  <h3>Создание константного типа</h3>

  <p>Можно создавать новые типы данных с помощью перечислений enum. Перечисление enum должно иметь имя, чтобы у нового типа данных тоже было имя. Свойствами такого типа данных будут имена констант и связанные с ними значения.</p>
  <p>Создадим перечисление, которое будет новым типом данных</p>
  <code>enum month {JAN = 1, FEB, MAR};</code>

  <p>Объявим переменную season с типом enum month, которая способна хранить значения перечисления, определяемого этим типом</p>
  <code>enum month season;</code>

  <p>Переменную типа перечисления можно создать при объявлении enum, после него</p>
  <p>Объявим перечисление и создадим переменную day с типом enum days</p>
  <code>enum days {MON, TUE, WED} day;</code>

  <p>Создадим переменную flag с типом enum BOOLEAN</p>
  <code>enum BOOLEAN {FALSE, TRUE} flag;</code>
</article>


<!-- Размер переменной sizeof() -->
<article class="article">
  <div class="anchor" id="var8"></div>
  <h3>Размер переменной sizeof()</h3>

  <p><strong>Размер переменной</strong> можно узнать с помощью оператора sizeof(). Оператор sizeof() возвращает целое число - <strong>количество байт</strong> для хранения переменной. Оператор sizeof() принимает <strong>переменную</strong>, которую пишут в скобках или без них</p>
  <code>int a = 100;</code>
  <code>printf("%d", sizeof(a)); // 4</code>
  <code>printf("%d", sizeof a); // 4</code>

  <p><strong>Размер массива</strong> из переменных одного типа вычисляется умножением количества перменных в массиве на размер типа данных</p>
  <code>sizeof(int[3]); // 4 * 3 = 12 bytes</code>

  <p><strong>Размер структуры данных</strong> из переменных разного типа может быть больше чем сумма размеров для каждой переменной из этой структуры. Обычно операционная система считывает данные <strong>словами по 4 байта</strong>. Поэтому при выделении памяти добавляют необходимое число байт до 4. Правильный размер структуры может показать только оператор sizeof()</p>
  <code>struct {int score; char grade;} result;</code>
  <code>printf("%d", sizeof result); // 8</code>
</article>


<!-- Указатели -->
<article class="article">
  <div class="anchor" id="point"></div>
  <h3>Указатели</h3>

  <p>Указатель - это переменная, хранящая адрес в оперативой памяти компьютера. Это может быть адрес любой переменной, массива, структуры, функции и т.д.</p>
  <p>Указатели используются для оптимизации выполнения программы и динамического выделения блоков памяти</p>
  <p>Адрес переменной - это адрес в оперативной памяти компьютера, где записано значение этой переменной</p>
  <p>Напрямую обращаться из программы к любому адресу в оперативной памяти нельзя. Это может делать только операционная система. Операционная система резервирует диапазон свободных ячеек памяти для своей работы и динамически выделяет блоки памяти для работы запущенных программ</p>
  <p>С помощью указателей мы можем обратиться к адресу, где хранится значение переменной. При попытке обратиться к адресу, не выделенному для нашей программы, произойдет крах и программа завершится с ошибкой.</p>
  <p>Указатель объявляется как обычная переменная. Сначала указывается тип указателя. Тип указателя должен быть таким же как у переменной, адрес которой он будет хранить. После типа ставится знак *. После знака * пишется имя указателя.</p>
  <p>При объявлении указателя рекомендуется его сразу же инициализировать значением NULL, если он не инициализируется другим значением</p>
  <code>int num = 10;</code>
  <code>int *pnum = NULL;</code>
  <p>Для получения адреса переменной перед ее именем нужно указать знак &. Адрес можно хранить только в указателе</p>
  <code>*pnum = &amp;num;</code>
  <p>Теперь указатель pnum хранит адрес переменной num. И может получать и изменять ее значение.</p>

  <h4>Указатель на указатель</h4>
  <p>Указатель это переменная. Как и любая переменная, указатель имеет свой адрес в памяти</p>
  <code>int *p = NULL;</code>

  <h4>Разименование</h4>
  <p>Имея указатель с адресом, мы можем получить значение переменной с помощью оператора *</p>
  <p>Операция получения значения переменной по ее адресу называеся <strong>разименование</strong></p>
  <code>int num = 30;</code>
  <code>int *pnum = &amp;num;</code>
  <p>Переменная num и указатель pnum указывают на один адрес. Благодаря одному адресу, указатель и переменная имеют общий доступ к ячейке памяти со значением переменной</p>
</article>


<!-- Флаги и маски -->
<article class="article">
  <div class="anchor" id="flag"></div>
  <h3>Флаги и маски</h3>

  <p>Наиболее распространенный вариант использования битовых операций это управление битовым полем, содержащим набор булевых флагов.</p> <p>Тип char занимает 1 байт памяти. В одном байте можно хранить 8 флагов. Это эффективнее чем каждый флаг хранить в отдельной переменной. Например, если в переменной типа char хранить только один флаг, то для 8 флагов потребуется уже 8 байт</p>
  <p>Исходное значение флагов может быть установлено с помощью десятичного числа, которое имеет единицы в тех битах, в которых нужно включить флаг</p>
  <p>Установим флаги в 1 и 4 разряд</p>
  <code>char flag = 9; // 0000 1001</code>

  <p>Тип short занимает 2 байта памяти. В двух байтах можно хранить 16 флагов.</p>
  <p>Тип int занимает 4 байта памяти. В четырех байтах можно хранить 32 флага.</p>
</article>


<!-- Типы данных -->
<article class="article">
  <div class="anchor" id="types"></div>
  <h3>Типы данных</h3>

  <p>Каждая переменная должна иметь свой тип данных. Тип данных определяет размер памяти, диапазон значений переменной, список операторов для работы с переменной.</p>
  <p>Элементарные типы данных:</p>
  <ol>
    <li><strong>_Bool</strong> логический тип (стандарт C99)</li>
    <li><strong>char</strong> код символа</li>
    <li><strong>int</strong> целое число</li>
    <li><strong>float</strong> вещественное число</li>
    <li><strong>double</strong> вещественное число двойной точности</li>
    <li><strong>void</strong> отсутствие типа</li>
  </ol>
</article>


<!-- Символьные типы char, wchar_t -->
<article class="article">
  <div class="anchor" id="types1"></div>
  <h3>Символьные типы char, wchar_t</h3>

  <h4>char</h4>
  <p>Занимает в памяти 1 байт</p>
  <p>Символьный тип в кодировке ASCII. В него помещаются все символы таблицы ASCII. В первой половине (от 0 до 127) английский алфавит, во второй половине (от 128 до 255 для unsigned char или от -128 до -1 для char (signed char)) зависит от выбранной кодировки операционной системы</p>

  <h4>wchar_t</h4>
  <p>Занимает в памяти 2 байта</p>
  <p>Символьный тип в кодировке UNICODE</p>
</article>


<!-- Модификаторы типа int -->
<article class="article">
  <div class="anchor" id="types2"></div>
  <h3>Модификаторы типа int</h3>

  <p>Тип данных int может использоваться с модификаторами.</p>

  <p>Модификаторы знака: <strong>signed</strong>, <strong>unsigned</strong></p>
  <p>Модификаторы длины: <strong>short</strong>, <strong>long</strong></p>
  <p>Размеры стандартных типов данных char, short, int, long, long long четко не определены и могут быть разными на разных платформах (компьютерах, операционных системах и компиляторах для них).</p>
  <ol>
    <li>
      <h4>char (signed char)</h4>
      <p>1 байт (8 бит)</p>
      <code>SCHAR_MIN = -2<sup>7</sup> (-128)</code>
      <code>SCHAR_MAX = 2<sup>7</sup>-1 (127)</code>
    </li>
    <li>
      <h4>short int(short, signed short, signed short int)</h4>
      <p>Явно указывает что размер 2 байта (16 бит):</p>
      <code>SHRT_MIN = -2<sup>15</sup> (-32768)</code>
      <code>SHRT_MAX = 2<sup>15</sup>-1 (32767)</code>
    </li>
    <li>
      <h4>int (signed, signed int)</h4>
      <p>2 байта (16 бит) или 4 байта (32 бита) зависит от платформы</p>
    </li>
    <li>
      <h4>long int (long, signed long, signed long int)</h4>
      <p>Явно указывает что размер 4 байта (32 бита):</p>
      <code>LONG_MIN = -2<sup>31</sup> (-2,147,483,648)</code>
      <code>LONG_MAX = 2<sup>31</sup>-1 (2,147,483,647)</code>
      <p>или от -2*10<sup>9</sup> до 2*10<sup>9</sup></p>
    </li>
    <li>
      <h4>long long (signed long long, long long int, signed long long int)</h4>
      <p>8 байт (64 бита):</p>
      <code>LLONG_MIN = -2<sup>63</sup> (-9,223,372,036,854,775,808)</code>
      <code>LLONG_MAX = 2<sup>63</sup>-1 (9,223,372,036,854,775,807)</code>
      <p>или от -9*10<sup>18</sup> до 9*10<sup>18</sup></p>
    </li>
  </ol>
  <p>У каждого целочисленного типа со знаком, есть парный тип без знака unsigned</p>
  <ol>
    <li>
      <h4>unsigned char</h4>
      <p>1 байт (8 бит)</p>
      <code>от 0 до UCHAR_MAX 255</code>
    </li>
    <li>
      <h4>unsigned short (unsigned short int)</h4>
      <p>2 байта (16 бит)</p>
      <code>от 0 до USHRT_MAX = 65535</code>
    </li>
    <li>
      <h4>unsigned (unsigned int)</h4>
      <p>2 байта (16 бит) или 4 байта (32 бита) зависит от платформы</p>
      <code>от 0 до UINT_MAX = 4294967295</code>
    </li>
    <li>
      <h4>unsigned long (unsigned long int)</h4>
      <p>4 байта (32 бита)</p>
      <code>от 0 до ULONG_MAX = 4,294,967,295</code>
    </li>
    <li>
      <h4>unsigned long long (unsigned long long int)</h4>
      <p>8 байт (64 бита)</p>
      <code>от 0 до ULLONG_MAX = 18,446,744,073,709,551,615</code>
    </li>
  </ol>
</article>


<!-- Суффиксы целочисленных типов -->
<article class="article">
  <div class="anchor" id="types3"></div>
  <h3>Суффиксы целочисленных типов</h3>

  <p>Целое число по умолчанию имеет тип int. При присвоении его другому типу произойдет преобразование к этому типу. С помощью суффикса можно явно указать тип целого числа.</p>
  <ul>
    <li>
      <h4>u или U</h4>
      <p>unsigned short, unsigned, unsigned long, unsigned long long</p>
      <code>unsigned num = 200u;</code>
    </li>
    <li>
      <h4>l или L</h4>
      <p>long, long long</p>
      <code>long num = 200L;</code>
    </li>
    <li>
      <h4>ul или UL</h4>
      <p>unsigned long, unsigned long long</p>
      <code>unsigned long num = 200ul;</code>
    </li>
    <li>
      <h4>ll или LL</h4>
      <p>long long</p>
      <code>long long num = 200LL;</code>
    </li>
    <li>
      <h4>ull или ULL</h4>
      <p>unsigned long long</p>
      <code>unsigned long long num = 200ull;</code>
    </li>
  </ul>
  <p>Не для всех типов есть отдельные суффиксы. Для некоторых типов можно применять несколько суффиксов. Суффиксы u и ul можно применить для нескольких типов.</p>
</article>


<!-- Платформонезависимые типы данных -->
<article class="article">
  <div class="anchor" id="types4"></div>
  <h3>Платформонезависимые типы данных</h3>

  <p>Начиная с С99 определены типы данных, в которых можно указать размер для различных целей. Они считаются платформонезависимыми.</p>
  <ul>
    <li><strong>__int8</strong> имеет размер 8 бит.</li>
    <li><strong>__int16</strong> имеет размер 16 бит.</li>
    <li><strong>__int32</strong> имеет размер 32 бита.</li>
    <li><strong>__int64</strong> имеет размер 64 бита.</li>
    <li>
      <strong>int8_t</strong> и <strong>uint8_t</strong> - размер ровно 8 бит (знаковый и беззнаковый).
      <code>INT8_MIN = -2<sup>7</sup> (-128)</code>
      <code>INT8_MAX = 2<sup>7</sup>-1 (127)</code>
      <code>UINT8_MAX = 2<sup>8</sup>-1 (255)</code>
    </li>
    <li>
      <strong>int16_t</strong> и <strong>uint16_t</strong> - размер ровно 16 бит (знаковый и беззнаковый).
      <code>INT16_MIN = -2<sup>15</sup> (-32768)</code>
      <code>INT16_MAX = 2<sup>15</sup>-1 (32767)</code>
      <code>UINT16_MAX = 2<sup>16</sup>-1 (65535)</code>
    </li>
    <li>
      <strong>int32_t</strong> и <strong>uint32_t</strong> - размер ровно 32 бита (знаковый и беззнаковый).
      <code>INT32_MIN = -2<sup>31</sup> (-2,147,483,648)</code>
      <code>INT32_MAX = 2<sup>31</sup>-1 (2,147,483,647)</code>
      <code>UINT32_MAX = 2<sup>32</sup>-1 (4,294,967,295)</code>
    </li>
    <li>
      <strong>int64_t</strong> и <strong>uint64_t</strong> - размер ровно 64 бита (знаковый и беззнаковый).
      <code>INT64_MIN = -2<sup>63</sup> (-9,223,372,036,854,775,808)</code>
      <code>INT64_MAX = 2<sup>63</sup>-1 (9,223,372,036,854,775,807)</code>
      <code>UINT64_MAX = 2<sup>64</sup>-1 (18,446,744,073,709,551,615)</code>
    </li>
    <li>int_least32_t и uint_least32_t- ближайший по длине, не менее 32 бит (может и больше).</li>
    <li>int_fast32_t и uint_fast32_t- самый быстрый длиной не менее 32, для этого типа данных самая быстрая работа на данной платформе и есть 32 бита (или больше). То есть если самые быстрые вычисления будут на 64 битах, то int_fast32_t будет иметь размер 64 бита.</li>
  </ul>
  <p>Аналогичные типы не только для 32, но и для 8, 16, 64. int128_t присутствует не везде.</p>
</article>


<!-- Вещественные типы данных float, double -->
<article class="article">
  <div class="anchor" id="types5"></div>
  <h3>Вещественные типы данных float, double</h3>

  <p>Модификатор длины: <strong>long</strong></p>

  <ul>
    <li>
      <h4>float</h4>
      <p>Выделяется памяти 4 байта. Значение от 3.4E-38 до 3.4E38. Точность 6 знаков</p>
    </li>
    <li>
      <h4>double</h4>
      <p>Выделяется памяти 8 байт. Значение от 1.7E-308 до 1.7E308. Точность 10 знаков</p>
    </li>
    <li>
      <h4>long double</h4>
      <p>Выделяется памяти 16 байт.</p>
    </li>
  </ul>

  <p>На тип float отводится 32 бита (0..31). В 31 бите хранится знак sign (1 бит), с 23 по 30 бит хранится экспонента exponent (8 бит), с 0 по 22 бит хранится дробная часть fraction (23 бита)</p>
  <p>На тип double отводится 64 бита (0..63). В 63 бите хранится знак sign (1 бит), с 52 по 62 бит хранится экспонента exponent (11 бит), с 0 по 51 бит хранится дробная часть fraction (52 бита)</p>

  <h4>int и float</h4>
  <p>Даже если int и float имеет одинаковый размер, они будут иметь разный диапазон и разную точность. У float большой диапазон, но низкая точность. У int большая точность, но более узкий диапазон представления чисел. Поэтому при преобразовании из int в float и наоборот может быть потеря точности или переполнение.</p>

  <h4>Остальные типы данных</h4>
  <ul>
    <li>enum. 32 бита. от -2147483648 до 2147483647</li>
  </ul>
</article>


<!-- Тип без значения void -->
<article class="article">
  <div class="anchor" id="types6"></div>
  <h3>Тип без значения void</h3>
</article>


<!-- Создание пользовательского типа typedef -->
<article class="article">
  <div class="anchor" id="types7"></div>
  <h3>Создание пользовательского типа typedef</h3>

  <p>Чтобы сократить длинные названия типов, можно создать пользовательский тип с коротким именем</p>
  <code>typedef unsigned short int USINT;</code>
  <code>USINT a;</code>
  <p>Объявили переменную a с типом unsigned short int</p>
</article>


<!-- Размер типа данных sizeof() -->
<article class="article">
  <div class="anchor" id="sizeof"></div>
  <h3>Размер типа данных sizeof()</h3>

  <p><strong>Размер типа данных</strong> можно узнать с помощью оператора sizeof(). Оператор sizeof() возвращает целое число - <strong>количество байт</strong> для хранения данного типа данных. Если в качестве аргумента передается <strong>тип данных</strong>, то он должен быть помещен в круглые скобки</p>
  <code>printf("%d", sizeof(int)); // 4</code>

  <h3>Минимальное и максимальное значение типа данных</h3>
  <p>Минимальное и максимальное значение типа данных можно узнать с помощью констант из заголовочного файла limits.h</p>

  <h4>char</h4>
  <code>printf("char size %d byte\n", sizeof(char));</code>
  <code>char size 1 byte</code>
  <code>printf("from %d to %d\n", CHAR_MIN, CHAR_MAX);</code>
  <code>from -128 to 127</code>

  <h4>short int</h4>
  <code>printf("short int size %d bytes\n", sizeof(short int));</code>
  <code>short int size 2 bytes</code>
  <code>printf("from %d to %d\n", SHRT_MIN, SHRT_MAX);</code>
  <code>from -32768 to 32767</code>

  <h4>int</h4>
  <code>printf("int size %d bytes\n", sizeof(int));</code>
  <code>int size 4 bytes</code>
  <code>printf("from %d to %d\n", INT_MIN, INT_MAX);</code>
  <code>from -2147483648 to 2147483647</code>

  <h4>long int</h4>
  <code>printf("long int size %d bytes\n", sizeof(long int));</code>
  <code>long int size 4 bytes</code>
  <code>printf("from %ld to %ld\n", LONG_MIN, LONG_MAX);</code>
  <code>from -2147483648 to 2147483647</code>

  <h4>long long int</h4>
  <code>printf("long long int size %d bytes\n", sizeof(long long int));</code>
  <code>long long int size 8 bytes</code>
  <code>printf("from %lld to %lld\n", LLONG_MIN, LLONG_MAX);</code>
  <code>from -9223372036854775808 to 9223372036854775807</code>

  <h4>float</h4>
  <code>printf("float size %d bytes\n", sizeof(float));</code>
  <code>float size 4 bytes</code>

  <h4>double</h4>
  <code>printf("double size %d bytes\n", sizeof(double));</code>
  <code>double size 8 bytes</code>

  <h4>long double</h4>
  <code>printf("long double size %d bytes\n", sizeof(long double));</code>
  <code>long double size 16 bytes</code>
</article>


<!-- Преобразование типов -->
<article class="article">
  <div class="anchor" id="types6"></div>
  <h3>Преобразование типов</h3>
</article>


<!-- Неявное преобразование -->
<article class="article">
  <div class="anchor" id="types61"></div>
  <h3>Неявное преобразование</h3>

  <p><strong>Неявное преобразование</strong> компилятор выполняет сам в двух случаях.</p>
  <ol>
    <li>Если в арифметической операции участвуют значения разных типов, то сначала они преобразуются в один тип</li>
    <code>1.1 + 2; // 1.1 + 2.0</code>
    <li>Если в операции присваивания мы присваиваем значение переменной, то сначала значение приводится к типу переменной</li>
    <code>double d = 2; // d = 2.0</code>
  </ol>

  <p>Из двух переменных, произойдет неявное преобразование к типу который левее</p>
  <code>long double -- double -- float -- unsigned long int -- long -- unsigned -- int</code>
</article>


<!-- Явное преобразование (приведение) -->
<article class="article">
  <div class="anchor" id="types62"></div>
  <h3>Явное преобразование (приведение)</h3>

  <p><strong>Явное преобразование</strong> приводит данные к нужному типу, после эти значения участвуют в операциях.</p>
  <p>Синтаксис приведения</p>
  <code>имя_переменной2 = (модификаторы тип_данных) имя_переменной1</code>
  <code>int a = 5;</code>
  <code>double d = (double) a;</code>

  <p>Явное преобразование может привести к потере данных если преобразовывать к типу который левее</p>
  <code>char -- short -- int -- long</code>
  <code>unsigned char -- unsigned short -- unsigned int -- unsigned long</code>
  <code>float -- double -- long double</code>

  <p><strong>Приведение</strong> не изменяет исходный тип данных переменной, выполняется копирование ее значения в переменную, имеющую другой тип данных</p>

  <h4>Приведение float к int</h4>
  <code>int a = (int)5.75; // 5</code>
  <p>Берется только значение переменной типа float до запятой</p>

  <h4>Приведение int к char</h4>
  <code>char a = (char)257; // 1</code>
  <p>Берется только значение переменной типа int в первом байте (от 0 до 255)</p>

  <h4>Приведение double к float</h4>
  <code>float a = (float)0.1234567; // 0.123457</code>
  <p>Значение переменной типа double округляется в шестом знаке после запятой</p>
</article>


<!-- Лексемы языка Си -->
<article class="article">
  <div class="anchor" id="lex"></div>
  <h3>Лексемы языка Си</h3>

  <p>Единицы текста программы, которые при компиляции воспринимаются как единое целое и по смыслу не могут быть разделены на более мелкие элементы</p>
</article>


<!-- 1. Алфавит языка Си -->
<article class="article">
  <div class="anchor" id="lex1"></div>
  <h3>1. Алфавит языка Си</h3>
  <ol>
    <li>буквы: A - Z, a - z</li>
    <li>цифры: 0 - 9</li>
    <li>специальные символы: + - / % . ? ! " &lt; &gt; | \ ' _ & ~ ^</li>
    <li>знаки пунктуации языка: [] () {} , ; : ... * = #</li>
    <li>пробельные символы: пробел, символ табуляции, символ перевода строки</li>
    <li>прочие символы - только в комментариях</li>
    <li><strong>НЕ ВКЛЮЧЕНЫ</strong> в алфавит @ $ ` (обратная кавычка)</li>
  </ol>
</article>


<!-- 2. Идентификаторы -->
<article class="article">
  <div class="anchor" id="lex2"></div>
  <h3>2. Идентификаторы</h3>

  <p>Идентификаторы используются как</p>
  <ul>
    <li>имена переменных</li>
    <li>имена функций</li>
    <li>имена типов данных</li>
    <li>метки</li>
  </ul>
  <p>Допустимые символы - буквы A-Z, a-z, цифры 0-9, символ подчеркивания _. Первый символ не может быть цифрой</p>
  <p>По стандарту ANSI длина идентификатора не более 31 символа</p>
  <p>Современные компиляторы допускают длину до 247 символов</p>
</article>


<!-- 3. Ключевые слова -->
<article class="article">
  <div class="anchor" id="lex3"></div>
  <h3>3. Ключевые слова</h3>

  <p>Ключевые слова не могут быть идентификаторами и использоваться в качестве имени переменной или функции.</p>
  <p>Ключевые слова используются в типах данных, классах памяти, операторах</p>
  <p>В стандарте 32 слова</p>
  <ol>
    <li>
      <h4>Типы данных</h4>
      <p>char, const, double, enum, float, int, long, short, signed, struct, union, unsigned, void</p>
    </li>
    <li>
      <h4>Классы памяти</h4>
      <p>auto, extern, register, static, volatile</p>
    </li>
    <li>
      <h4>Операторы</h4>
      <p>break, case, continue, default, do, else, for, goto, if, return, sizeof, switch, typedef, while</p>
    </li>
  </ol>
  <p>В стандарте C99 добавили еще 5 слов</p>
  <p>_Bool, _Complex, _Imaginary, inline, restrict</p>
  <p>В стандарте C11 добавили еще 7 слов</p>
  <p>_Alignas, _Alignof, _Atomic, _Generic, _Noreturn, _Static_assert, _Thread_local</p>
</article>


<!-- 4. Константы -->
<article class="article">
  <div class="anchor" id="lex4"></div>
  <h3>4. Константы</h3>

  <p>Константа - неизменяемое арифметическое значение целого, вещественного, символьного или перечислимого типа, нулевой указатель либо строковый литерал.</p>

  <ol>
    <li>
      <h4>Целые константы</h4>
      <p>Целые числа записываются в системах счисления по основаниям 10, 8, 16. Целочисленный ноль в любой системе счисления - 0. Десятичные целые не начинаются с нуля. Восьмеричные целые начинаются с нуля. Шестнадцатеричные целые начинаются с 0x или 0X.</p>
      <p><strong>1.1 Десятичные.</strong> Цифры 0-9. Первой цифрой не может быть 0. Если значение превышает наибольшее целое, то оно представляется как длинное целое. Например, 12 976 2024</p>
      <p><strong>1.2 Восьмеричные.</strong> Цифры 0-7. Первая цифра должна быть 0. Например, 012 011 0743</p>
      <p><strong>1.3 Шестнадцатеричные.</strong> Цифры 0-9, буквы a-f или A-F. Начинаются с 0x или 0X. Например, 0x12 0X12 0x5ef3 0X5EF3</p>
    </li>
    <li>
      <h4>Длинные целые константы</h4>
      <p>Длинная целая константа явно определяется буквой l или L, стоящей после константы.</p>
      <p><strong>2.1 Длинная десятичная.</strong> Например, 12l 345L</p>
      <p><strong>2.2 Длинная восьмеричная.</strong> Например, 012l 074L</p>
      <p><strong>2.3 Длинная шестнадцатеричная.</strong> Например, 0x12l 0XAAL</p>
    </li>
    <li>
      <h4>Вещественные константы</h4>
      <p>Вещественные записываются в десятичной системе в следующих форматах:</p>
      <p>{целая часть}.{дробная часть}</p>
      <p>{целая часть}{e|E}{порядок}</p>
      <p>.{дробная часть}{e|E}{порядок}</p>
      <p>Например, 345. 3.1415 2.1e5 .12E3 234e-5</p>
    </li>
    <li>
      <h4>Символьные константы</h4>
      <p>Символьная константа состоит из одного символа кода ASCII, который пишется в апострофах. Например, 'A' 'a' '5' '%'</p>
      <p>Символьные константы считаются данными типа int</p>
    </li>
    <li>
      <h4>Строковые константы</h4>
      <p>Строковая константа состоит из последовательности символов кода ASCII, которая пишется в кавычках</p>
      <p>Например, "This is string" "012345" "0"</p>
      <p>В конце каждой строки компилятор помещает нулевой символ '\0', отмечающий конец строки</p>
      <p>Каждая строковая константа сохраняется в отдельном месте в памяти</p>
      <p>Строковая константа это массив символов, она имеет тип char[]</p>
    </li>
    <li>
      <h4>Перечислимые константы</h4>
    </li>
  </ol>
</article>


<!-- 5. Знаки операций -->
<article class="article">
  <div class="anchor" id="lex5"></div>
  <h3>5. Знаки операций</h3>

  <p>В языке Си 47 операций. Каждая операция обозначается своей лексемой</p>
  <p>() [] -> . ! ~ + - ++ --</p>
  <p>& * sizeof * / % + - &lt;&lt; &gt;&gt;</p>
  <p>&lt; &lt;= &gt;= &gt; == != & ^ | &&</p>
  <p>|| ?: = *= /= %= += -= &= ^=</p>
  <p>|= &lt;&lt;= &gt;&gt;= ,</p>
</article>


<!-- 6. Разделители и пунктуаторы -->
<article class="article">
  <div class="anchor" id="lex6"></div>
  <h3>6. Разделители и пунктуаторы</h3>

  <p>В языке Си 10 разделителей и пунктуаторов</p>
  <p>* = () [] {} , : ; _ #</p>
</article>


<!-- Комментарии -->
<article class="article">
  <div class="anchor" id="comments"></div>
  <h3>Комментарии</h3>

  <p>Комментарии не обрабатываются компилятором и отсутствуют в исполняемом файле. Нужны только для программистов читающих код. Бывают двух видов:</p>
  <ul>
    <li>Однострочные. Начинаются с символов // и до конца строки</li>
    <li>Многострочные. Заключаются между символами /* */</li>
  </ul>
</article>


<!-- Признак конца файла EOF -->
<article class="article">
  <div class="anchor" id="eof"></div>
  <h3>Признак конца файла EOF</h3>

  <p>Константа EOF определена в stdio.h как</p>
  <code>#define EOF    (-1)</code>
  <p>Если признак конца файла EOF нужно ввести с клавиатуры, то:</p>
  <ul>
    <li>В UNIX EOF вводится по Ctrl+D</li>
    <li>В Windows EOF вводится по Ctrl+Z</li>
  </ul>
  <p>EOF не является символом. Функция getchar(), как и большинство функций, возвращает -1 когда происходит внутренняя ошибка. Такой ошибкой является конец файла. Закрытие файла.</p>
  <p>Все является файлом. Консольный (терминальный) ввод и вывод на более низком уровне представляется как файлы с хэндлами 0 и 1. Функция getchar() читает данные из файла и как только обнаруживает что файл закрыт то выдает код ошибки EOF = -1</p>
</article>


<!-- Выражения и операции -->
<article class="article">
  <div class="anchor" id="oper"></div>
  <h3>Выражения и операции</h3>

  <p>Выражение вычисляет и возвращает значение. Выражение состоит из операций и операндов</p>
  <p>Операнд - аргумент операции, участвующий в вычислениях. Операндом может быть идентификатор, константа, другое выражение</p>
  <p>Операция - действие, выполняемое с операндами. Операции отличаются:</p>
  <ul>
    <li>приоритетом</li>
    <li>количеством операндов (унарные, бинарные, тернарная)</li>
    <li>положению операндов (префиксная ++a, инфиксная a+b, постфиксная a++)</li>
    <li>ассоциативностью (выполняются слева направо или справа налево)</li>
  </ul>
</article>


<!-- Приоритет операций -->
<article class="article">
  <div class="anchor" id="oper1"></div>
  <h3>Приоритет операций</h3>

  <p><strong>Приоритет операций</strong> определяет порядок, в котором вычисляется значение выражения</p>
  <p><strong>Ассоциативность операций</strong> определяет порядок тех операций, у которых одинаковый приоритет</p>

  <ol>
    <li>() вызов функции [] индекс массива -> указатель на структуру . член структуры</li>
    <li>! не ~ битовое не + знак плюс - знак минус ++ инкремент -- декремент & взятие адреса * разыменование (приведение типа) sizeof</li>
    <li>* / %</li>
    <li>+ сложение - вычитание</li>
    <li>&lt;&lt; &gt;&gt;</li>
    <li>&lt; &lt;= &gt;= &gt;</li>
    <li>== !=</li>
    <li>& битовое И</li>
    <li>^ битовое исключающее ИЛИ</li>
    <li>| битовое ИЛИ</li>
    <li>&&</li>
    <li>||</li>
    <li>?:</li>
    <li>= *= /= %= += -= &= ^= |= &lt;&lt;= &gt;&gt;= операции присваивания</li>
    <li>, запятая</li>
  </ol>

  <p>Операции с приоритетом 2,13,14,15 имеют ассоциативность справа налево. Все остальные - слева направо.</p>
</article>


<!-- Адресные операции -->
<article class="article">
  <div class="anchor" id="oper2"></div>
  <h3>Адресные операции</h3>

  <ol>
    <li>Взятие адреса переменной &. Например, &a возвращает указатель на адрес переменной a.</li>
    <li>Разименование указателя *. Например, *p возвращает значение переменной по адресу который содержится в указателе p</li>
    <li>Доступ к полю структуры через указатель ->. Например, pointerToMan -> name возвращает значение поля name в структуре данных man.</li>
  </ol>
</article>


<!-- Арифметические операции -->
<article class="article">
  <div class="anchor" id="oper3"></div>
  <h3>Арифметические операции</h3>

  <p>Перечислим арифметические операции в порядке убывания приоритета</p>
  <ol>
    <li>Унарный плюс (+) и унарный минус (-)</li>
    <li>
      <p>Инкремент (++) и декремент (--).</p>
      <p>Может быть префиксный ++a, --b и постфиксный a++, b--</p></li>
    <li>Умножение (*), деление (/) и остаток от деления (%)</li>
    <li>Сложение (+) и вычитание (-)</li>
    <li>Арифметические операции с присваиванием (+=, -=, *=, /=, %=)</li>
  </ol>
</article>


<!-- Битовые операции -->
<article class="article">
  <div class="anchor" id="oper4"></div>
  <h3>Битовые операции</h3>

  <p>Каждый байт состоит из 8 бит. Каждый бит состоит из одного значения 0 или 1. Байт записывается справа налево от менее значимого бита (LSB, Less Significant Bit) до более значимого бита (MSB, Most Significant Bit). Каждый байт может содержать десятичное число от 0 до 255</p>
<pre>
              MSB                         LSB
Номер бита     8   7   6   5   4   3   2   1
Значение      128 64  32  16   8   4   2   1  // 32+16+2=50
Двоичный код   0   0   1   1   0   0   1   0  // 00110010
</pre>

  <h4>& поразрядное И</h4>
  <p>Возвращает 1 если оба бита имеют значение 1, иначе возвращает 0</p>
  <code>1010 & 1100 = 1000</code>

  <h4>| поразрядное ИЛИ</h4>
  <p>Возвращает 1 если хотя бы один бит имеет значение 1, иначе возвращает 0</p>
  <code>1010 | 0101 = 1111</code>

  <h4>^ поразрядное исключающее ИЛИ</h4>
  <p>Возвращает 1 если только один бит имеет значение 1, иначе возвращает 0</p>
  <code>1010 ^ 0100 = 1110</code>

  <h4>~ поразрядное НЕ</h4>
  <p>Возвращает 1 если ни один бит не имеет значение 1, иначе возвращает 0</p>
  <code>1010 ~ 0011 = 0100</code>

  <h4>&lt;&lt; битовый сдвиг влево</h4>
  <p>Перемещает биты влево на заданное количество разрядов</p>
  <code>0010 &lt;&lt; 2 = 1000</code>

  <h4>&gt;&gt; битовый сдвиг вправо</h4>
  <p>Перемещает биты вправо на заданное количество разрядов</p>
  <code>1000 &gt;&gt; 2 = 0010</code>

  <p>Битовые операции необходимы для программирования устройств с ограниченными ресурсами. Операция Исключающее ИЛИ позволяет менять значения двух переменных без создания третьей.</p>
</article>


<!-- Логические операции -->
<article class="article">
  <div class="anchor" id="oper5"></div>
  <h3>Логические операции</h3>

  <p>&& логическое И</p>
  <p>|| логическое ИЛИ</p>
  <p>! логическое НЕ</p>
  <p>XOR логическое исключающее ИЛИ</p>
</article>


<!-- Условная операция (тернарный оператор ?:) -->
<article class="article">
  <div class="anchor" id="oper6"></div>
  <h3>Условная операция (тернарный оператор ?:)</h3>

  <p>Тернарный оператор это сокращенная запись конструкции if else</p>
  <code>max = (x > y) ? x: y;</code>
</article>


<!-- Операции доступа -->
<article class="article">
  <div class="anchor" id="oper7"></div>
  <h3>Операции доступа</h3>

  <ol>
    <li>Доступ к элементу массива array[element]</li>
    <li>Вызов функции function()</li>
    <li>Доступ к полям структуры . (точка)</li>
  </ol>
</article>


<!-- Операции присваивания -->
<article class="article">
  <div class="anchor" id="oper8"></div>
  <h3>Операции присваивания</h3>

  <p>=</p>
  <p>+=</p>
  <p>-=</p>
  <p>*=</p>
  <p>/=</p>
  <p>%=</p>
  <p>&= поразрядное И с присваиванием</p>
  <p>|= поразрядное ИЛИ с присваиванием</p>
  <p>^= поразрядное исключающее ИЛИ с присваиванием</p>
  <p>&lt;&lt;= сдвиг влево с присваиванием</p>
  <p>&gt;&gt; сдвиг вправо с присваиванием</p>
</article>


<!-- Операции сравнения -->
<article class="article">
  <div class="anchor" id="oper9"></div>
  <h3>Операции сравнения</h3>

  <p>Операции сравнения позволяют сравнить два значения и возвращают 1 если выражение истинно, и 0 если выражение ложно.</p>
  <p><strong>&lt;</strong> меньше</p>
  <code>int a = 10 &lt; 20; // a = 1</code>
  <p><strong>&gt;</strong> больше</p>
  <code>int a = 10 &gt; 20; // a = 0</code>
  <p><strong>&lt;=</strong> меньше или равно</p>
  <code>int a = 10 &lt;= 20; // a = 1</code>
  <p><strong>&gt;=</strong> больше или равно</p>
  <code>int a = 10 &gt;= 20; // a = 0</code>
  <p><strong>==</strong> равно</p>
  <code>int a = 10 == 20; // a = 0</code>
  <p><strong>!=</strong> не равно</p>
  <code>int a = 10 != 20; // a = 1</code>
</article>


<!-- Операция запятая -->
<article class="article">
  <div class="anchor" id="oper10"></div>
  <h3>Операция запятая</h3>

  <p>Операция запятая имеет самый низкий приоритет и выполняется самой последней. Выражения разделенные запятой вычисляются слева направо как части одного выражения. Тип и значение результата совпадают с типом и значением правого выражения.</p>
  <code>int c = 3;</code>
  <p>Чему равен x?</p>
  <code>x = c + 5, 21;</code>
  <p>Здесь два выражения разделенные запятой. Первое, в x запишется целое число 8. Второе, 21. Результат второго выражения никуда не записывается. Ответ x = 8</p>
  <code>x = (c + 5, 21);</code>
  <p>В скобках два выражения разделенные запятой. Первое выражение вернет 8, второе вернет 21. Результат второго выражения запишется в переменную x. Ответ x = 21</p>
</article>


<!-- Операторы -->
<article class="article">
  <div class="anchor" id="operator"></div>
  <h3>Операторы</h3>

  <h4>Метка оператора</h4>

  <p>Метка оператора может стоять перед любым оператором, чтобы на этот оператор можно было перейти с помощью оператора goto. Метка состоит из идентификатора, за которым стоит двоеточие.</p>
  <p>Например, L: x = 2;</p>

  <h4>Оператор завершения break</h4>

  <p>Прекращает выполнение ближайшего вложенного внешнего оператора switch, while, do или for. Выходит за операторные скобки и передает управление следующему оператору.</p>

  <h4>Оператор продолжения contunue</h4>

  <p>Используется только внутри цикла while, do или for. Заканчивает текущую итерацию цикла. Управление передается в начало цикла для следующей итерации.</p>

  <h4>Оператор возврата return</h4>

  <p>Используется только внутри функции. Прекращает выполнение функции и передает управление вызвавшей его программе. Если функция должна вернуть результат, то return возвращает результат.</p>

  <h4>Оператор перехода goto</h4>

  <p>Передает управление на оператор с меткой. Область действия ограничена функцией.</p>

  <h4>Условный оператор if-else</h4>

  <p>Если условие истинно, то выполняется блок оператора if. Если условие ложно, то выполняется блок оператора else. Оператора else может и не быть.</p>

  <h4>Оператор выбора switch</h4>

  <p>Сравнивает значение выражения с константами во всех вариантах case. Передает управление оператору, который соответствует значению выражения. Если ни одна из констант не равна значению выражения, то выполняется оператор с меткой default. Метки default может и не быть. Если после выполненного оператора нет слова break, то будет выполняться оператор следующей метки case.</p>

  <h4>Оператор цикла while</h4>

  <p>while (выражение) оператор. Сначала проверяется выражение. Если выражение истинно, то оператор выполняется. После опять проверяется выражение и т.д. пока выражение не станет ложным.</p>

  <h4>Оператор цикла do-while</h4>

  <p>do оператор while (выражение). Сначала выполняется оператор. Потом проверяется выражение. Если выражение истинно, то опять выполняется оператор и т.д. пока выражение не станет ложным.</p>

  <h4>Оператор цикла for</h4>

  <p>for(выражение 1; выражение 2; выражение 3) оператор. Сначала выполняется Выражение 1 - это инициализацию цикла. Потом проверяется Выражение 2. Если Выражение 2 истинно, то выполняется тело цикла. Выражение 3 выполняется восле выполнения всех операторов в теле цикла. Потом опять проверяется Выражение 2 и т.д. пока выражение 2 не станет ложным.</p>
  <p>Любые из трех выражений могут отсутствовать, но разделяющие их точки с запятыми опускать нельзя. Тело цикла может отсутствовать, тогда обязательно ставить точку с запятой в конце цикла.</p>
</article>


<!-- Операции ввода-вывода -->
<article class="article">
  <div class="anchor" id="inout"></div>
  <h3>Операции ввода-вывода</h3>

  <p>В языке Си нет команд работающих с вводом-выводом и с памятью. Все операции ввода-вывода происходят через "поток". "Поток" это абстракция, которая находится между программой и конкретным устройством. Это позволяет программисту не заботиться о взаимодействии программы с конкретными устройствами. При запуске программы автоматически открываются и подключаются к ней 5 стандартных потоков (3 основных и 2 вспомогательных)</p>
  <ol>
    <li>stdout - выходной</li>
    <li>stdin - входной</li>
    <li>stderr - сообщений об ошибках</li>
    <li>stdprn - принтера (параллельного порта)</li>
    <li>stdaux - последовательного порта</li>
  </ol>
</article>


<!-- Функция printf() -->
<article class="article">
  <div class="anchor" id="printf"></div>
  <h3>Функция printf()</h3>

  <p>Функция printf() обеспечивает форматный вывод данных в поток stdout (на экран, в консоль).</p>
  <p><strong>Форматный</strong> вывод означает, что функция printf() сначала форматирует данные и потом выводит их на экран</p>
  <p>В функцию printf() первым аргументом передается <strong>строка форматирования</strong> в двойных кавычках "". На экран выведется содержимое этой строки.</p>
  <code>printf("Hello");</code>
  <code>Hello</code>
  <p><strong>Строка форматирования</strong> может содержать <strong>escape-последовательности</strong> и <strong>спецификатор формата</strong>. Если сторока содержит спецификаторы формата, то вторым аргументом передаются переменные, которые нужно поставить на место спецификаторов.</p>
  <code>printf(строка_форматирования, список_аргументов);</code>
  <p>Если <strong>спецификатор формата</strong> не передается, то список_аргументв не нужен.</p>

  <h4>Escape-последовательности</h4>
  <ol>
    <li><strong>\a</strong> звуковой сигнал</li>
    <li><strong>\b</strong> удаление предыдущего символа</li>
    <li><strong>\f</strong> перевод страницы</li>
    <li><strong>\n</strong> перевод на новую строку</li>
    <li><strong>\r</strong> возврат в начало строки</li>
    <li><strong>\t</strong> горизонтальная табуляция</li>
    <li><strong>\v</strong> вертикальная табуляция</li>
    <li><strong>\'</strong> одинарная кавычка</li>
    <li><strong>\"</strong> двойная кавычка</li>
    <li><strong>\\</strong> обратный слэш</li>
    <li><strong>\?</strong> вопросительный знак</li>
    <li><strong>\0</strong> конец строки</li>
    <li><strong>%%</strong> знак процента</li>
  </ol>
</article>


<!-- Спецификатор формата -->
<article class="article">
  <div class="anchor" id="printf1"></div>
  <h3>Спецификатор формата</h3>

  <p>В printf спецификатор формата имеет общий вид:</p>
  <code>%[флаги][ширина][.точность][размер]тип</code>
  <p>Знак % означает - возьми переменную после запятой и распечатай ее значение.</p>

  <ol>
    <li>
      <h4>Тип</h4>
      <p>Тип - это тип переменной, единственный обязательный параметр спецификатора. Остальные параметры могут быть а могут и не быть. Тип переменной задается после знака % и может быть одним из</p>
      <ul>
        <li><strong>%c</strong> один символ (char)</li>
        <li><strong>%d</strong> целое со знаком (int)</li>
        <li><strong>%i</strong> целое со знаком (int)</li>
        <li><strong>%u</strong> положительное число (unsigned)</li>
        <li><strong>%s</strong> строка Символы строки печатаются до первого нулевого символа ("\0") или до заданной точности</li>
        <li><strong>%o</strong> восьмеричное целое без знака (int)</li>
        <li><strong>%x</strong> шестнадцатеричное целое без знака, использующее abcdef (int)</li>
        <li><strong>%X</strong> шестнадцатеричное целое без знака, использующее ABCDEF (int)</li>
        <li><strong>%f</strong> дробное число в формате d.d (float, double)</li>
        <li><strong>%F</strong> дробное число в формате d.d (float, double)</li>
        <li><strong>%e</strong> дробное число в формате ded (float, double)</li>
        <li><strong>%E</strong> дробное число в формате dEd (float, double)</li>
        <li><strong>%g</strong> более короткий из форматов %f или %e</li>
        <li><strong>%G</strong> более короткий из форматов %F или %E</li>
        <li><strong>%%</strong> знак процента</li>
        <li><strong>%p</strong> указатель far на void Печатается адрес, указанный аргументом, в формате xxxx:yyyy, где xxxx - сегмент, yyyy- смещение, а x и y -строчные шестнадцатеричные цифры</li>
      </ul>
    </li>
    <li>
      <h4>Размер</h4>
      <p>Размер типа может быть одним из:</p>
      <ul>
        <li><strong>h</strong> short</li>
        <li><strong>l</strong> long и unsigned long</li>
        <li><strong>ll</strong> long long и unsigned long long</li>
        <li><strong>L</strong> long double</li>
      </ul>
    </li>
    <li>
      <h4>Точность</h4>
      <p>.точность указывает сколько знаков после точки печатать</p>
    </li>
    <li>
      <h4>Ширина</h4>
      <p>Ширина - на печать данных отведено ширина символов (или больше).</p>
    </li>
    <li>
      <h4>Флаги</h4>
      <ul>
        <li>+ - указывать явно знак числа, в том числе положительного</li>
        <li>- - выравнивание влево по указанной ширине</li>
        <li>пробел - вставляет пробел на месте знака перед положительным числом</li>
        <li>0 - дополнять слева числа до указанной ширины не пробелами, а 0.</li>
        <li># - при использовании со спецификаторами "o", "x", "X" будут выводиться и "0", "0x", "0X'. При использовании со спецификаторами "f", "g", "G" десятичная точка будет выводиться, даже если в числе нет дробной части</li>
      </ul>
    </li>
  </ol>
</article>


<!-- Печать символа -->
<article class="article">
  <div class="anchor" id="printf2"></div>
  <h3>Печать символа</h3>

  <h4>%c char</h4>
  <p>Напечатает символ соответствующий переданному числу в коде ASCII</p>
  <p>Передадим на печать символ</p>
  <code>printf("%c", 'A'); // A</code>
  <p>Передадим на печать символ, записанный в переменную типа char</p>
  <code>char sym = 'B';</code>
  <code>printf("%c", sym); // B</code>
  <p>Передадим на печать число</p>
  <code>printf("%c", 100); // d</code>
  <p>Передадим на печать число, записанное в переменную типа char</p>
  <code>char sym = 101;</code>
  <code>printf("%c", sym); // e</code>
</article>


<!-- Печать целого числа -->
<article class="article">
  <div class="anchor" id="printf3"></div>
  <h3>Печать целого числа</h3>

  <h4>%d char</h4>
  <p>Можно получить код символа</p>
  <code>printf("%d", 'A'); // 65</code>
  <code>char sym = 'B';</code>
  <code>printf("%d", sym); // 66</code>

  <h4>%hi short</h4>
  <code>short sh = 1001;</code>
  <code>printf("%hi", 1000);</code>
  <code>printf("%hi", sh);</code>

  <h4>%hd short</h4>
  <code>short sh = 100;</code>
  <code>printf("%hd", sh);</code>

  <h4>%i int</h4>
  <code>int a = 100;</code>
  <code>printf("%i", a);</code>

  <h4>%d int</h4>
  <code>int a = 100;</code>
  <code>printf("%d", a);</code>

  <h4>%ld long</h4>
  <code>long c = 100L;</code>
  <code>printf("%ld", c);</code>

  <h4>%lld long long</h4>
  <code>long long e = 100LL;</code>
  <code>printf("%lld", e);</code>

  <p>Для беззнаковых типов к спецификатору добавляют букву u</p>
  <h4>%hu unsigned short</h4>
  <code>unsigned short b = 100u;</code>
  <code>printf("%hu", b);</code>

  <h4>%du unsigned int</h4>
  <code>unsigned int d = 100u;</code>
  <code>printf("%du", d);</code>

  <h4>%lu unsigned long</h4>
  <code>unsigned long d = 100ul;</code>
  <code>printf("%lu", d);</code>

  <h4>%llu unsigned long long</h4>
  <code>unsigned long long f = 100ull;</code>
  <code>printf("%llu", f);</code>
</article>


<!-- Печать дробного числа -->
<article class="article">
  <div class="anchor" id="printf4"></div>
  <h3>Печать дробного числа</h3>

  <h4>%f float, double</h4>
  <code>float a = 1.1;</code>
  <code>printf("%f", a);</code>

  <h4>%F float, double</h4>
  <code>float a = 1.1;</code>
  <code>printf("%F", a);</code>

  <h4>%e float, double</h4>
  <code>float a = 1.1;</code>
  <code>printf("%e", a);</code>

  <h4>%E float, double</h4>
  <code>float a = 1.1;</code>
  <code>printf("%E", a);</code>

  <h4>%g float, double</h4>
  <code>float a = 1.1;</code>
  <code>printf("%g", a);</code>

  <h4>%G float, double</h4>
  <code>float a = 1.1;</code>
  <code>printf("%G", a);</code>

</article>


<!-- Печать строки -->
<article class="article">
  <div class="anchor" id="printf5"></div>
  <h3>Печать строки</h3>

  <p>Число до точки задает минимальную ширину строки вывода</p>
  <p>Для печати строк используют тип s (string).</p>
  <p><strong>%5s</strong>. Строка менее 5 символов дополняется пробелами слева до 5 символов</p>
  <code>printf("/%5s/\n", "abc");         // /  abc/</code>
  <p><strong>%05s</strong>. Строка менее 5 символов дополняется нулями слева до 5 символов</p>
  <code>printf("/%05s/\n", "abc");        // /00abc/</code>
  <p><strong>%-5s</strong>. Строка менее 5 символов дополняется пробелами справа до 5 символов</p>
  <code>printf("/%-5s/\n", "abc");        // /abc  /</code>
  <p><strong>%5s</strong>. На строки длинее заданной ширины никак не влияет</p>
  <code>printf("/%5s/\n", "abcdefgh");    // /abcdefgh/</code>
  <p>Число после точки задает максимальную ширину строки вывода</p>
  <p><strong>%.5s</strong>. Строка более 5 символов будет обрезана до 5 символов</p>
  <code>printf("/%.5s/\n", "abcdefgh");   // /abcde/</code>
  <p><strong>%.5s</strong>. На строки короче заданной ширины никак не влияет</p>
  <code>printf("/%.5s/\n", "abc");        // /abc/</code>
</article>


<!-- Функция fprintf() -->
<article class="article">
  <div class="anchor" id="fprintf"></div>
  <h3>Функция fprintf()</h3>
</article>


<!-- Функция sprintf() -->
<article class="article">
  <div class="anchor" id="sprintf"></div>
  <h3>Функция sprintf()</h3>
</article>


<!-- Функция wprintf() -->
<article class="article">
  <div class="anchor" id="wprintf"></div>
  <h3>Функция wprintf()</h3>

  <p>Функция wprintf() работает с кодировкой unicode, в отличие от функции printf(), которая работает только с однобайтовыми символами</p>
</article>


<!-- Функция scanf() -->
<article class="article">
  <div class="anchor" id="scanf"></div>
  <h3>Функция scanf()</h3>

  <p>Функция scanf() обеспечивает форматный ввод данных из потока stdin. Текст внутри будет пропущен. Знак % означает - возьми переменную после запятой и запиши в нее значение определенного размера. Размер значения задается после знака % и может быть одним из</p>
  <ol>
    <li>h используется как префикс перед типами d, i, o, x, X для указания того, что тип аргумента short int, или с u для указания того, что тип аргумента short unsigned int</li>
    <li>l используется как префикс перед типами d, i, o, x, X для указания того, что тип аргумента long int, или с u для указания того, что тип аргумента long unsigned int. А также перед типами e, E, f, g, G для указания того, что тип аргумента double, а не float</li>
  </ol>
</article>


<!-- Функция fscanf() -->
<article class="article">
  <div class="anchor" id="fscanf"></div>
  <h3>Функция fscanf()</h3>
</article>


<!-- Функция puts() -->
<article class="article">
  <div class="anchor" id="puts"></div>
  <h3>Функция puts()</h3>
</article>


<!-- Функция fputs() -->
<article class="article">
  <div class="anchor" id="fputs"></div>
  <h3>Функция fputs()</h3>
</article>


<!-- Функция gets() -->
<article class="article">
  <div class="anchor" id="gets"></div>
  <h3>Функция gets()</h3>
</article>


<!-- Функция fgets() -->
<article class="article">
  <div class="anchor" id="fgets"></div>
  <h3>Функция fgets()</h3>
</article>


<!-- Работа с файлами -->
<article class="article">
  <div class="anchor" id="file"></div>
  <h3>Работа с файлами</h3>

  <p>FILE * тип данных указатель на файл</p>
  <code>FILE *pf;</code>
</article>


<!-- Функция fopen() -->
<article class="article">
  <div class="anchor" id="fopen"></div>
  <h3>Функция fopen()</h3>

  <p>fopen(имя файла, режим)</p>
  <p>режим</p>
  <ul>
    <li>r read чтение</li>
    <li>w write запись</li>
    <li>a append дозапись в конец</li>
    <li>r+ чтение или запись в текстовый файл</li>
    <li>w+ чтение или запись в текстовый файл</li>
    <li>a+ чтение или дозапись в конец текстового файла</li>
    <li>rb чтение бинарного файла</li>
    <li>wb запись в бинарный файл</li>
  </ul>

  <code>pf = fopen("a.txt", "w");</code>
  <p>В случае удачи в pf запишется указатель на файл. В случае неудачи в pf запишется NULL</p>
</article>


<!-- Функция fread() -->
<article class="article">
  <div class="anchor" id="fread"></div>
  <h3>Функция fread()</h3>

  <p>Функция fread() принимает четыре параметра и возвращает в случае успеха количество прочитанных символов</p>
  <p>Входные параметры: массив, куда записывать символы, количество символов прочитанных за один раз, количество всех символов которые нужно прочитать, указатель на файл откуда читать</p>
</article>


<!-- Функция fwrite() -->
<article class="article">
  <div class="anchor" id="fwrite"></div>
  <h3>Функция fwrite()</h3>

  <p>Функция fwrite() принимает четыре параметра и возвращает в случае успеха количество записанных символов</p>
  <p>Входные параметры: массив, откуда читать символы, количество символов прочитанных за один раз, количество всех символов которые нужно прочитать, указатель на файл куда записывать символы</p>
</article>


<!-- Рандомные числа -->
<article class="article">
  <div class="anchor" id="rand"></div>
  <h3>Рандомные числа</h3>

  <p>rand() генерерует положительное целое число 0 ... 32767</p>
  <p>rand % 9 + 10 вернет число от 10 до 19</p>
  <code>rand() % (max - min +1) + min</code>
  <p>rand() вернет не случайное число, а одну и ту же последовательность при ее вызовах</p>

  <p>srand(int) принимает зерно для функции rand()</p>
  <p>Если не использовать функцию srand(), то по умолчанию зерно равно 1.</p>
  <p>для каждого зерна генерируется разная последовательность, поэтому в качестве зерна передают функцию time(), что бы числа казались случайными</p>
  <code>srand(time(0));</code>
</article>

