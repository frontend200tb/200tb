<article class="article">
  <h1>1985 Керниган, Ритчи - Язык программирования Си. Задачи по языку. 279c</h1>
  <p>Конспект книги</p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
        <a href="#p1">Предисловие (10)</a>
    <br><a href="#p2">Глава 1. Введение (11)</a>
    <br><a href="#p3">Глава 2. Обзор языка (15)</a>
    <br><a href="#p4">Глава 3. Типы, операции и выражения (38)</a>
    <br><a href="#p5">Глава 4. Управление (53)</a>
    <br><a href="#p6">Глава 5. Функции и структура программы (64)</a>
    <br><a href="#p7">Глава 6. Ссылки и массивы (84)</a>
    <br><a href="#p8">Глава 7. Записи (108)</a>
    <br><a href="#p9">Глава 8. Ввод и вывод (129)</a>
    <br><a href="#p10">Глава 9. Взаимодействие с системой UNIX (142)</a>
    <br><a href="#p11">Справочное руководство по языку Си (157)</a>
    <br><a href="#p12">Задачи по языку Си (193)</a>
  </p>
</article>


<!-- Предисловие -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Предисловие (10)</h3>

  <p>Язык Си позволяет максимально использовать ресурсы ЭВМ и практически полностью отказаться от ассемблера.</p>
  <p>Книга Кернигана и Ритчи - авторское введение в язык. Язык в нем описывается так как они желали. Они учат не самому языку, а тому как надо на нем программировать.</p>
  <p>Первоначально язык Си был создан Ритчи для UNIX на ЭВМ PDP-11 и реализован в этой системе.</p>
</article>


<!-- Глава 1. Введение -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>Глава 1. Введение (11)</h3>

  <p>Язык Си работает с теми же объектами, с которыми работает и большинство вычислительных машин, а именно с символами, числами и адресами. В языке си нет операций ввода-вывода и встроенных методов доступа к файлам. Эти механизмы обеспечиваются вызовом функций.</p>
  <p>Язык Си был написан на основе языков BCPL и B. Но он на них не похож. В языках BCPL и B нет типов данных, единственными данными в них были машинные слова, обращение к другим объектам идет через специальные операции и функции.В Си есть основные типы данных из которых можно построить много производных типов.</p>
</article>


<!-- Глава 2. Обзор языка -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>Глава 2. Обзор языка (15)</h3>

  <p>Как можно быстрее начнем сами писать программы.</p>

  <h4>2.1 Начнем, пожалуй (15)</h4>

  <p>Единственный способ обучиться новому языку программирования - начать писать на нем программы.</p>
  <p>Напишем первую программу, которая выводит на экран hello, world.</p>
  <p>Первое препятствие - сначала надо где-то написать текст программы, потом его скомпилировать, запустить готовую программу и разобраться что у нас получилось.</p>
  <p>Будем использовать операционную систему <strong>Windows 10</strong>  и редактор кода <strong>VSCode</strong>.</p>
  <p>Создадим текстовый файл с расширением <strong>.c</strong>, назовем его, например, <strong>hello.c.</strong> Напишем в нем текст программы</p>
  <p>Выведем на экран hello, world и переведем курсор на новую строку</p>

  <details>
    <summary>Программа 1 (16)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  printf("hello, world\n");

  return 0;
}
</pre>
  <code>hello, world!</code>
  </details>

  <p>Откроем терминал и скомпилируем этот файл командой</p>
  <code>gcc hello.c</code>
  <p>Если нет ошибок и компиляция закончится успешно, то будет создан файл</p>
  <code>a.exe</code>
  <p>Запустим файл a.exe командой</p>
  <code>./a</code>
  <p>В консоли должен быть результат выполнения программы, выводится строчка</p>
  <code>hello, world</code>

  <p>Любая программа ня языке Си состоит из одной или более функций. Функциям можно давать любые имена, согласно правилам именования переменных и функций. Функция main() это особая функция. Она должна быть в каждой программе. С нее начинается выполнение программы.</p>
  <p>Выводим на экран hello, world и переводим курсор на новую строку три раза вызвав функцию printf()</p>

  <details>
    <summary>Программа 2 (17)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  printf("hello, ");
  printf("world!");
  printf("\n");

  return 0;
}
</pre>
  <code>hello, world!</code>
  </details>
  <p>Если в функцию printf() включить '\s', где s это не символ управляющей последовательности, то получим предупреждение. Программа скомпилируется и выполнится как будто символа '\' не было</p>

  <details>
    <summary>Программа 3 (17)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  printf("\shello, world!\n");

  return 0;
}
</pre>
  <code>warning: unknown escape sequence: '\s'</code>
  <code>shello, world!</code>
  </details>

  <h4>2.2 Переменные и арифметика (17)</h4>
  <p>Программа печатает таблицу температур по Фаренгейту и  по Цельсию. Для перевода используется формула</p>
  <code>C = (5/9)(F-32)</code>

  <details>
    <summary>Программа 4 (18)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int lower, upper, step;
  float fahr, celsius;

  lower = 0;
  upper = 300;
  step = 20;
  fahr = lower;

  while (fahr &lt;= upper) {
    celsius = (5.0 / 9.0) * (fahr - 32.0);
    printf("%4.0f %6.1f\n", fahr, celsius);
    fahr = fahr + step;
  }

  return 0;
}
</pre>
  </details>

  <p>Спецификатор %4.0f означает что дробное число при печати должно занимать минимум 4 символа (если цифр меньше то перед ними ставятся пробелы) и без цифр после десятичной точки</p>
  <p>Спецификатор %6.1f означает что дробное число при печати должно занимать минимум 6 символов (включая точку и цифры после нее, если цифр меньше то перед ними ставятся пробелы) и после десятичной точки доолжна быть одна цифра</p>

  <h4>2.3 Цикл for (20)</h4>
  <p>Программа печатает таблицу температур по Фаренгейту и  по Цельсию, используя цикл for</p>

  <details>
    <summary>Программа 5 (21)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int fahr;

  for (fahr = 0; fahr &lt;= 300; fahr += 20) {
    printf("%4d %6.1f\n", fahr, (5.0 / 9.0) * (fahr - 32));
  }

  return 0;
}
</pre>
  </details>
  <p>Напечатаем температуры в обратном порядке от 300 до 0 градусов</p>

  <details>
    <summary>Программа 6 (21)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int fahr;

  for (fahr = 300; fahr >= 0; fahr -= 20) {
    printf("%4d %6.1f\n", fahr, (5.0 / 9.0) * (fahr - 32));
  }

  return 0;
}
</pre>
  </details>

  <h4>2.4 Символические константы (21)</h4>

  <p>Плохо когда в программе встречаются загадочные числа вроде 300 или 20. Хорошо использовать для них конструкцию со словом #define в начале программы. Тогда можно определить символические константы. Препроцессор до выполнения компиляции заменит все символические константы на их значения. Так что полученная программа будет точно такое же, а вот читаемость программы на языке Си будет лучше.</p>
  <p>Заменим цифры в программе символическими константами</p>

  <details>
    <summary>Программа 7 (22)</summary>
<pre>
#include &lt;stdio.h&gt;
#define LOWER 0
#define UPPER 300
#define STEP 20

int main() {
  int fahr;

  for (fahr = LOWER; fahr &lt;= UPPER; fahr += STEP) {
    printf("%4d %6.1f\n", fahr, (5.0 / 9.0) * (fahr - 32));
  }

  return 0;
}
</pre>
  </details>

  <h4>2.5 Некоторые простые программы (22)</h4>

  <p>Чтение одного символа (обычно из терминала)</p>
  <code>c = getchar();</code>
  <p>Запись одного символа (обысно в терминал)</p>
  <code>putchar(c);</code>
  <p>Копируем по одному символу со входа на выход после нажатия на клавишу ENTER. Если нужно остановать программу, надо нажать Ctrl+Z это константа EOF которая приведет к выходу из цикла while</p>

  <details>
    <summary>Программа 8 (23)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int c;

  c = getchar();
  while (c != EOF) {
    putchar(c);
    c = getchar();
  }

  return 0;
}
</pre>
  </details>
  <p>Программа может стать компактнее, если записать getchar() прямо условии цикла while. Здесь считывается один символ, присваивается переменной, проверяется на равенство символу EOF</p>

  <details>
    <summary>Программа 9 (23)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int c;

  while ((c = getchar()) != EOF) {
    putchar(c);
  }

  return 0;
}
</pre>
  </details>
  <p>Подсчитаем количество введенных символов в переменной типа int (включая пробелы и ENTER) пока не введем EOF</p>

  <details>
    <summary>Программа 10 (24)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int nc = 0;
  while (getchar() != EOF) {
    ++nc;
  }
  printf("count=%d\n", nc);

  return 0;
}
</pre>
  </details>
  <p>Подсчитаем количество введенных символов в переменной типа long (включая пробелы и ENTER) пока не введем EOF</p>

  <details>
    <summary>Программа 11 (24)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  long nc = 0;
  while (getchar() != EOF) {
    ++nc;
  }
  printf("count=%ld\n", nc);

  return 0;
}
</pre>
  </details>
  <p>Подсчитаем количество введенных символов в переменной типа double (включая пробелы и ENTER) пока не введем EOF</p>

  <details>
    <summary>Программа 12 (24)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  double nc = 0;
  while (getchar() != EOF) {
    ++nc;
  }
  printf("count=%.0f\n", nc);

  return 0;
}
</pre>
  </details>
  <p>Вместо цикла while напишем цикл for и всю работу цикл будет делать при проверке и повторной инициализации. Вместо пустого тела цикла необходимо поставить точку с запятой</p>

  <details>
    <summary>Программа 13 (25)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  double nc;
  for (nc = 0; getchar() != EOF; ++nc) ;
  printf("count=%.0f\n", nc);

  return 0;
}
</pre>
  </details>
  <p>Подсчитаем строки входного текста. Каждая строка заканчивается символом '\n'.</p>

  <details>
    <summary>Программа 14 (25)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int c, nl = 0;
  while ((c = getchar()) != EOF) {
    if (c == '\n') {
      ++nl;
    }
  };
    printf("count line = %d\n", nl);

  return 0;
}
</pre>
  </details>
  <p>Подсчитаем пробелы, символы табуляции и новые строки</p>

  <details>
    <summary>Программа 15 (26)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int c,
  n_ws = 0,
  n_tab = 0,
  n_l = 0;

  while ((c = getchar()) != EOF) {
    if (c == ' ') {
      ++n_ws;
    } else if (c == '\t') {
      ++n_tab;
    } else if (c == '\n') {
      ++n_l;
    }
 };
    printf("count whitespace = %d\n", n_ws);
    printf("count tab = %d\n", n_tab);
    printf("count new line = %d\n", n_l);

  return 0;
}
</pre>
  </details>
  <p>Напишем программу копирования ввода на вывод с заменой одного или более пробелов на один пробел</p>

  <details>
    <summary>Программа 16 (26)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int c, w = ' ', flag = 0;

  while ((c = getchar()) != EOF) {
    if (c == ' ') {
      flag = 1;
    } else {
      if (flag == 1) {
        putchar(w);
        flag = 0;
      }
      putchar(c);
    }
  };

  return 0;
}
</pre>
  </details>
  <p>Напишем программу копирования ввода на вывод с заменой каждого символа табуляции на символы >>>, а каждого символа возврата на один шаг на символ &lt;</p>

  <details>
    <summary>Программа 17 (26)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char c;
  char t = '\t', tt = '>';
  char b = '\b', bb = '&lt;';

  while ((c = getchar()) != EOF) {
    if (c == t) {
      putchar(tt);
      putchar(tt);
      putchar(tt);
    } else if (c == b) {
      putchar(bb);
    } else {
      putchar(c);
    }
  };

  return 0;
}
</pre>
  </details>
  <p>Подсчитаем строки, слова и символы. Слово это последовательность символов, не содержащая пробелов, табуляции и символа перехода на новую строку. Как только программа встречает первый символ, она начинает считать</p>

  <details>
    <summary>Программа 18 (26)</summary>
<pre>
#include &lt;stdio.h&gt;

#define YES 1
#define NO  0

int main() {
  int c, n_line, n_word, n_char, inword;
  inword = NO;
  n_line = n_word = n_char = 0;

  while ((c = getchar()) != EOF) {
    ++n_char;
    if (c == '\n') {
      ++n_line;
    }
    if (c == ' ' || c == '\t' || c == '\n') {
      inword = NO;
    } else if (inword == NO) {
      inword = YES;
      ++n_word;
    }
  }
  printf("count line = %d\n", n_line);
  printf("count word = %d\n", n_word);
  printf("count char = %d\n", n_char);

  return 0;
}
</pre>
  </details>
  <p>Напечатаем вводимые слова по одному в строке</p>

  <details>
    <summary>Программа 19 (28)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int c, w = 0;

  while ((c = getchar()) != EOF) {
    if (c == ' ' || c == '\t' || c == '\n') {
      if (w == 0) {
        putchar('\n');
      }
      w++;
    } else {
      putchar(c);
      w = 0;
    }
  }

  return 0;
}
</pre>
  </details>
  <p>Напечатаем вводимые слова по одному в строке. Слова должны начинаться с буквы</p>

  <details>
    <summary>Программа 20 (28)</summary>
<pre>
#include &lt;stdio.h&gt;

#define YES 1
#define NO  0

int main() {
  int c;
  int n_word = 0;
  int inword = NO;

  while ((c = getchar()) != EOF) {
    if (c == ' ' || c == '\t' || c == '\n') {
      inword = NO;
    } else if (inword == NO && (
              (c > 64 && c &lt; 91) ||
              (c > 96 && c &lt; 123))) {
      inword = YES;
      ++n_word;
    } else {
      inword = YES;
    }
  }
  printf("count word = %d\n", n_word);

  return 0;
}
</pre>
  </details>

  <h4>2.6 Массивы (28)</h4>
  <p>Посчитаем вхождения каждой из цифр, невидимых (пустых) симовол (пробелов, табуляций, перехода на новую строку) и других символов</p>

  <details>
    <summary>Программа 21 (28)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int c, i;
  int nwhite = 0, nother = 0;
  int ndigit[10];

  for (i = 0; i &lt; 10; i++) {
    ndigit[i] = 0;
  }

  while ((c = getchar()) != EOF) {
    if (c >= '0' && c &lt;= '9') {
      ndigit[c - '0']++;
    } else if (c == ' ' || c == '\t' || c == '\n') {
      nwhite++;
    } else {
      nother++;
    }
  }
  for (i = 0; i &lt; 10; i++) {
    printf("%d %d\n", i, ndigit[i]);
  }
  printf("white space = %d\n", nwhite);
  printf("other = %d\n", nother);

  return 0;
}
</pre>
  </details>
  <p>Напечатаем гистограмму длин читаемых слов. Гистограмму расположим горизонтально</p>

  <details>
    <summary>Программа 22 (29)</summary>
<pre>
#include &lt;stdio.h&gt;

#define YES 1
#define NO  0

int main() {
  int c;
  int n_word = 0;
  int inword = NO;
  int inother = NO;
  int len[256] = {0};

  while ((c = getchar()) != EOF) {
    // если пробельный символ
    if (c == ' ' || c == '\t' || c == '\n') {
      inword = NO;
      inother = NO;
    // если это первая буква после пробельного символа
    } else if (inword == NO && inother == NO && (
              (c > 64 && c &lt; 91) ||
              (c > 96 && c &lt; 123))) {
      inword = YES;    // мы внутри слова
      ++n_word;        // увеличиваем число слов
      len[n_word] = 1; // в слове одна буква
    // если не пробельный символ и мы внутри слова
    } else if (inword == YES) {
        len[n_word]++;
    } else {
      inother = YES;
    }
  }

  for (int i = 1; i &lt;= n_word; i++) {
    for (int j = 1; j &lt;= len[i]; j++) {
      printf("#");
    }
    printf("\n");
  }

  return 0;
}
</pre>
  </details>

  <h4>2.7 Функции (29)</h4>
  <p>Напишем функцию power для возведения целого числа в целую положительную степень. В программе вычисли 2⁵ и 2¹⁰</p>

  <details>
    <summary>Программа 23 (30)</summary>
<pre>
#include &lt;stdio.h&gt;

int power(int, int);

int main() {
  printf("2**5=%d\n", power(2,5));
  printf("2**10=%d\n", power(2,10));

  return 0;
}

int power(int m, int n) {
  int i, p = 1;
  for (i = 0; i &lt; n; i++) {
    p *= m;
  }

  return p;
}
</pre>
  <code>2**5=32</code>
  <code>2**10=1024</code>
  </details>
  <p>Напишем программу, которая принимает два целых числа и возводит первое число в степень равную второму числу</p>

  <details>
    <summary>Программа 24 (30)</summary>
<pre>
#include &lt;stdio.h&gt;

int power(int, int);

int main() {
  int a, b;
  printf("Enter integer ");
  scanf("%d", &a);
  printf("Enter power ");
  scanf("%d", &b);
  printf("%d**%d = %d\n", a, b, power(a, b));

  return 0;
}

int power(int m, int n) {
  int i, p = 1;
  for (i = 0; i &lt; n; i++) {
    p *= m;
  }

  return p;
}
</pre>
  </details>
  <p>Напишем программу, которая принимает строку и преобразует буквы к нижнему регистру.</p>

  <details>
    <summary>Программа 25 (31)</summary>
<pre>
#include &lt;stdio.h&gt;

char lower(char);

int main() {
  int ch;
  while ((ch = getchar()) != '\n') {
    printf("%c", lower(ch));
  }

  return 0;
}

char lower(char c) {
  char res;
  if (c >= 65 && c &lt;= 91) {
    res = c + 32;
  } else {
    res = c;
  }

  return res;
}
</pre>
  </details>

  <h4>2.8 Аргументы - вызов по значению (31)</h4>

  <p>Все аргументы функции передаются "по-значению". Внутри функции создаются новые переменные со значениями, переданными в параметрах. В основной программе передаваемые аргументы остаются неизменными, внутри функции меняется только их копия.</p>
  <p>Функция power() работает с копиями переменных.</p>

  <details>
    <summary>Программа 26 (31)</summary>
<pre>
#include &lt;stdio.h&gt;

int power(int, int);

int main() {
  printf("2**5=%d\n", power(2,5));
  printf("2**10=%d\n", power(2,10));

  return 0;
}

int power(int m, int n) {
  int p;
  for (p = 1; n > 0; --n) {
    p *= m;
  }

  return p;
}
</pre>
  </details>

  <p>Чтобы в программе поменялось значение переменной, надо в функцию передать ее адрес. и тогда адрес не изменится, так как внутри функции будет действовать копия адреса, а переменную по этому адресу можно поменять.</p>
  <p>Если в качестве аргумента берется имя массива, то передаваемое функции значение фактически есть адрес начала массива. Никакое копирование элементов массива не производится. Обращаясь по индексу, функция может выбирать или изменять любые элементы массива.</p>

  <h4>2.9 Массивы символов (32)</h4>
  <p>Напишем программу, которая читает несколько строк и затем печатает самую длинную из них. Программа читает строки. В цикле, пока есть еще строки, сравнивает строку с самой длинной, выбирает самую длинную и запоминает строку и ее длину.</p>

  <details>
    <summary>Программа 27 (32)</summary>
<pre>
#include &lt;stdio.h&gt;
#define MAXLINE 1000

int getline(char [], int);
void copy(char [], char []);

int main() {
  int len;
  int max;
  char line[MAXLINE];
  char save[MAXLINE];
  max = 0;
  while((len = getline(line, MAXLINE)) > 0) {
    if (len > max) {
      max = len;
      copy(line, save);
    }
  }
  if (max > 0) {
    printf("%s", save);
  }

  return 0;
}

int getline(char s[], int lim) {
    int c, i;
    for (i=0; i &lt; lim - 1 && (c=getchar())!=EOF && c!='\n'; i++){
      s[i] = c;
    }
    if (c == '\n') {
      s[i] = c;
      i++;
    }
    s[i] = '\0';
    return i;
  }

void copy(char s1[], char s2[]) {
  int i = 0;
  while ((s2[i] = s1[i]) != '\0') {
    i++;
  }
}
</pre>
  </details>

  <h4>2.10 Области действия. Внешние переменные (34)</h4>

  <p>Внутренние переменные функции main() это локальные переменные, поскольку они объявлены и действуют внутри нее. Никакие другие функции не имеют к ним прямого доступа. Это же справедливо для переменных других функций. Любая локальная переменная начинает существовать при входе в функцию и уничтожается при выходе из функции. Такие переменные еще можно назвать автоматическими, потому что они сами независимо от нас создаются и уничтожаются автоматически.</p>
  <p>Внешние переменные, объявленные вне функций, это глобальные переменные. К ним можно обращаться из любой функции. Их можно использовать для связи между функциями. Эти переменные существуют всегда, а не возникают и исчезают при входе и выходе из функции.</p>
  <p>Чтобы в функции использовать глобальную переменную, ее нужно пометить как extern.</p>
  <p>Перепишем программу для самой большой строки, сделав переменные line, save и max внешними.</p>

  <details>
    <summary>Программа 28 (35)</summary>
<pre>
#include &lt;stdio.h&gt;
#define MAXLINE 1000

char line[MAXLINE];
char save[MAXLINE];
int max;

int getline();
void copy();

int main() {
  int len;
  extern int max;
  extern char save[];
  max = 0;
  while((len = getline()) > 0) {
    if (len > max) {
      max = len;
      copy();
    }
  }
  if (max > 0) {
    printf("%s", save);
  }

  return 0;
}

int getline() {
    int c, i;
    extern char line[];
    for (i=0; i &lt; MAXLINE - 1 && (c=getchar())!=EOF && c!='\n'; i++){
      line[i] = c;
    }
    if (c == '\n') {
      line[i] = c;
      i++;
    }
    line[i] = '\0';
    return i;
  }

void copy() {
  int i = 0;
  extern char line[], save[];
  while ((save[i] = line[i]) != '\0') {
    i++;
  }
}
</pre>
  </details>

  <p>Определение глобальных переменных приводит к выделению памяти, согласно их типу. Прежде чем функция сможет использовать глобальную переменную, нужно сделать имя этой переменной известным для функции. Один из спопобов сделать это - включить в функцию описание внешней переменной с помощью слова extern.</p>
  <p>При описании переменной с помощью слова extern, память для нее не выделяется.</p>

  <h4>2.11 Заключение (36)</h4>
</article>


<!-- Глава 3. Типы, операции и выражения -->
<article class="article">
  <div class="anchor" id="p4"></div>
  <h3>Глава 3. Типы, операции и выражения (38)</h3>

  <h4>3.1 Имена переменных (38)</h4>

  <p>Имена могут состоять из букв, цифр, символа подчеркивания. Первым символом в имени не может быть цифра.</p>

  <h4>3.2 Типы данных и размеры (38)</h4>

  <p>Основные типы данных в Си char, int, float, double. Несколько "уточнителей" для типа int: short, long, unsigned. Точность целых чисел зависит от конкретной машины.</p>

  <h4>3.3 Константы (39)</h4>

  <p>Целочисленная константа, например 123</p>
  <p>Вещественная константа, например 123.01</p>
  <p>Длинная константа, например 123L</p>
  <p>Символьная константа это единственный символ заключенный в одиночные кавычки, например 'x'.</p>
  <p>Константное выражение - это выражение из одних констант. Такие выражения вычисляются во время трансляции, а не во время выполнения программы, поэтому их можно использовать везде, где может стоять константа.</p>
<pre>
#define MAXLINE 1000
char line[MAXLINE + 1]
hours = 60 * 60 * seconds;
</pre>
  <p>Строковая константа это последовательность нуля или более символов, заключенная в двойные кавычки, например "string".</p>
  <p>Строка представляет собой массив с элементами из одного символа. В конце каждой такой строки транслятор автоматически помещает нулевой символ '\0'. Размер строки не ограничен, но для определения ее длины строку нужно полностью просмотреть.</p>
  <p>Напишем функцию strlen() определяющую длину строки, включая последний символ '\0'.</p>

  <details>
    <summary>Программа 29 (40)</summary>
<pre>
strlen(char s[]) {
  int i;
  i = 0;
  while (s[i] != '\0') {
    i++;
  }
  return i;
}
</pre>
  </details>

  <p>Символьная константа и строка из одного символа это не одно и то же. 'x' != "x". 'x' это символ для буквы x. "x" это строка, содержащая один символ и символ "\0".</p>

  <h4>3.4 Описания (40)</h4>

  <p>Перед использованием переменная должна быть объявлена. При объявлении можно задавать начальные значения.</p>

  <h4>3.5 Арифметические операции (41)</h4>

  <p>Операцию % остаток от деления нельзя использовать для типа float и double.</p>
  <p>Год будет високосным, если он  делится на 4, но не делится на 100, однако если делится на 400 то он тоже високосный.</p>

  <details>
    <summary>Программа 30 (41)</summary>
<pre>
if (year % 4 == 0 && year % 100 != 0 || year % 400 == 0) {
  printf("високосный");
} else {
  printf("не високосный");
}
</pre>
  </details>

  <h4>3.6 Отношения и логические операции (42)</h4>

  <p>Цикл из функции getline, из одной из прошлых программ</p>
<pre>
for (i = 0; i &lt; lim - 1 && (c = getchar()) != '\n' && c != EOF; i++) {
  s[i] = c;
}
</pre>
  <p>Прежде чем считывать новый символ, нужно проверить, есть ли в массиве s для него место, поэтому в начале необходимо выполнить проверку i &lt; lim - 1. Если эта проверка даст отрицательный результат, то getchar выполнять уже не нужно. Также нет смысла сравнивать символ с EOF, пока не выполнится getchar.</p>
  <p>Напишем функцию atoi() для преобразования строки, состоящей из цифр в число.</p>

  <h4>3.7 Преобразование типов (43)</h4>

  <details>
    <summary>Программа 31 (43)</summary>
<pre>
atoi(char s[]) {
  int i, n;
  n = 0;
  for (i = 0; s[i] >= '0' && s[i] &lt;= '9; i++') {
    n =  10 * n + s[i] - '0';
  }
  return n;
}
</pre>
  </details>
  <p>Напишем функцию lower() для преобразования заглавной буквы в строчную</p>

  <details>
    <summary>Программа 32 (43)</summary>
<pre>
lower(char c) {
  if (c >= 'A' && c &lt;= 'Z') {
    return (c + 'a' - 'A');
  } else {
    return c;
  }
}
</pre>
  </details>

  <p>Автоматическое преобразование типов происходит в трех случаях</p>
  <ol>
    <li>Если в одном выражении операнды разных типов, то они преобразуются к одному типу.</li>
    <li>При присваивании значение правой части преобразуется к типу левой части.</li>
    <li>При передачи аргументов в функцию их типы преобразуются к типам параметров функции</li>
  </ol>
  <p>Явное преобразование называется приведением</p>
  <code>(имя типа) выражение</code>

  <h4>3.8 Операции увеличения и уменьшения (45)</h4>

  <p>Операции инкремента и декремента можно применять только к переменным и нельзя применять к выражениям. Например (i + i)++ выполнить нельзя.</p>
  <p>Напишем функцию squeeze() выбрасывающую все вхождения символа из строки.</p>

  <details>
    <summary>Программа 33 (46)</summary>
<pre>
squeeze(char s[], int c) {
  int i, j;
  for (i = j = 0; s[i] != '\0'; i++) {
    if (s[i] != c) {
      s[j++] = s[i];
    }
  }
  s[j] = '\0';
}
</pre>
  </details>

  <p>Если встречается символ, отличный от c, он копируется в текущую j-ю позицию, а затем j увеличивается для следующего символа.</p>
  <p>Напишем функцию strcat() присоединяющую строку в конец другой строки. Мы должны позаботиться о том чтобы с строке хватило места для присоединения другой строки.</p>

  <details>
    <summary>Программа 34 (47)</summary>
<pre>
strcat(char s[], char t[]) {
  int i, j;
  i = j = 0;
  while (s[i] != '\0') {
    i++;
  }
  while ((s[i++] = t[j++]) != '\0') ; // пустой оператор
}
</pre>
  </details>

  <h4>3.9 Поразрядные логическин операции (47)</h4>

  <p>Порязрядные операции нельзя применить к float и double.</p>
  <p>Напишем функцию getbits() дающую n-разряднов из числа x, начиная с позиции p.</p>

  <details>
    <summary>Программа 35 (48)</summary>
<pre>
getbits(unsigned x, unsigned p, unsigned n) {
  return (x >> (p + 1 - n)) & ~(~0 &lt;&lt; n);
}
</pre>
  </details>

  <h4>3.10 Операции присваивания и выражения (48)</h4>
  <p>Напишем функцию bitcount() считающую число 1-х разрядов в числе</p>

  <details>
    <summary>Программа 36 (49)</summary>
<pre>
bitcount(unsigned n) {
  int b;
  for (b = 0; n != 0; n >>= 1) {
    if (n & 01) {
      b++;
    }
  }
  return b;
}
</pre>
  </details>

  <h4>3.11 Условные выражения (50)</h4>

  <p>Найдем максимум из двух чисел</p>
  <code>if (a>b) max=a; else max=b;</code>
  <code>max = (a>b) & a : b;</code>

  <p>Цикл печати N элементов массива по 10 чисел в строке. Колонка от колонки отделяется пробелом, а каждая строка заканчивается одним переходом на новую строку.</p>
<pre>
for (i = 0; i &lt; N; i++) {
  printf("%6d%c", a[i], (i%10 == 9 || i == N-1) & '\n' : ' ');
}
</pre>

  <h4>3.12 Приоритеты и порядок вычислений (50)</h4>

  <p>Обращение к функциям, вложенные операторы присваивания, операции инкремента, декремента обладают побочным эффектом, связанным с порядком обращения к переменным.</p>
</article>


<!-- Глава 4 Управление -->
<article class="article">
  <div class="anchor" id="p5"></div>
  <h3>Глава 4 Управление (53)</h3>

  <h4>4.1 Операторы и блоки (53)</h4>

  <p>Любое выражение становится оператором, если за ним идет точка с запятой. В языке Си точка с запятой заканчивает оператор. Если операторы группируются в блок, окруженный фигурными скобками, то после закрывающей фигурной скобки точка с запятой не ставится.</p>

  <h4>4.2 if - else (53)</h4>

  <p>Оператор if-else применяется для принятия решения. Часть else может присутствовать, а может и не присутствовать. Если часть с else пропускается во вложенных условных операторах, то возникает неясность в толковании. Компилятор сопоставляет else с ближайшим if, не имеющим своего else. Если это не то что вам нужно, то используйте фигурные скобки перед оператором else чтобы показать к какому if он относится.</p>

  <h4>4.3 else if (55)</h4>

  <p>Конструкция else if используется когда нужно выбирать из многих решений.</p>
  <p>Функция двоичного поиска, определяющая встречается ли значение x  в упорядоченном массиве v.</p>

  <details>
    <summary>Программа 37 (55)</summary>
<pre>
binary(int x, int v[], int n) {
  int low, high, mid;
  low = 0;
  high = n-1;
  while (low &lt;= high) {
    mid = (low + high) / 2;
    if (x &lt; v[mid]) high = mid - 1;
    else if (x > v[mid]) low = mid + 1;
    else return (mid);
  }
  return (-1);
}
</pre>
  </details>

  <h4>4.4 Переключатель (56)</h4>

  <p>Переключатель (оператор switch) предназначен для принятия одного из многих решений. В нем проверяется совпадение значения выражения с одной из нескольких констант и выполняется соответствующая ветвь.</p>
  <p>Напишем программу посчета цифр и пустых символов</p>

  <details>
    <summary>Программа 38 (56)</summary>
<pre>
main() {
  int c, i, nwhite, nother, ndigit[10];
  nwhite = nother = 0;

  for (i = 0; i &lt; 10; i++) {
    ndigit[i] = 0;
  }

  while ((c = getchar()) != EOF) {
    switch(c) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        ndigit[c-'0']++;
        break;
      case ' ':
      case '\n':
      case '\t':
        nwhite++;
        break;
      default:
        nother++;
        break;
    }
  }

  printf("digits = ");
  for (i = 0; i &lt; 10; i++) {
    printf("%d", ndigit[i]);
  }
  printf("\nwhite space = %d, other = %d\n", nwhite, nother);
}
</pre>
  </details>

  <h4>4.5 Циклы while и for (57)</h4>
  <p>Напишем функцию atoi() преобразующую строку в число. Эта версия работает с путс=ыми символами в начале и допускает знаки + или -.</p>

  <details>
    <summary>Программа 39 (58)</summary>
<pre>
atoi(char s[]) {
  int i, n, sign;

  for (i = 0; s[i] == ' ' || s[i] == '\n' || s[i] == '\t'; i++) ;

  sign = 1;
  if (s[i] == '+' || s[i] == '-') {
    sign = (s[i++] == '+') ? 1 : -1;
  }

  for (n = 0; s[i] >= '0' && s[i] &lt;= '9'; i++) {
    n = 10 * n + s[i] - '0';
  }

  return sign * n;
}
</pre>
  </details>
  <p>Напишем функцию shell(), которая упорядочивает массив целых чисел. На ранних этапах сравниваются элементы, расположенные далеко друг от друга, а не соседние. Поэтому на поздних этапах работы становится меньше. Интервал между сравниваемыми элементами постепенно уменьшается до 1, когда сортировка сводится к обычным перестановкам соседних элементов.</p>

  <details>
    <summary>Программа 40 (59)</summary>
<pre>
shell(int v[], int n) {
  int gap, i, j, temp;

  for (gap = n/2; gap > 0; gap /=2) {
    for (i = gap; i &lt; n; i++) {
      for (j = i-gap; j >= 0 && v[j] > v[j+gap]; j-=gap) {
        temp = v[j];
        v[j] = v[j+gap];
        v[j+gap] = temp;
      }
    }
  }
}
</pre>
  </details>
  <p>Напишем функцию reverse() - поворот строки на месте</p>

  <details>
    <summary>Программа 41 (59)</summary>
<pre>
reverse(char s[]) {
  int c, i, j;
  for (i = 0, j = strlen(s) - 1; i &lt; j; i++, j--) {
    c = s[i];
    s[i] = s[j];
    s[j] = c;
  }
}
</pre>
  </details>

  <h4>4.6 Цмклы do-while (60)</h4>
  <p>Напишем функцию itoa() - перевод числа в символы строки</p>

  <details>
    <summary>Программа 42 (60)</summary>
<pre>
itoa(char s[], int n) {
  int i, sign;
  if ((sign = n) &lt; 0) {
    n = -n;
  }
  i = 0;
  do {
    s[i++] = n % 10 + '0';
  } while ((n /= 10) > 0);
  if (sign &lt; 0) {
    s[i++] = '-';
  }
  s[i] = '\0';
  reverse(s);
}
</pre>
  </details>

  <p>Конструкция do-while здесь нужна потому что в массиве должен быть хотя бы один символ.</p>

  <h4>4.7 Break (разрыв) (61)</h4>

  <p>Оператор break обеспечивает выход из таких конструкций как while, dor, do-while и switch.</p>
  <p>Напишем программу, которая выбрасывает лишние символы пробела и табуляции из конца каждой входной строки. Оператор break используется для окончания цикла при обнаружении самого правого символа, отличного от пробела или табуляции.</p>

  <details>
    <summary>Программа 43 (61)</summary>
<pre>
#define MAXLINE 1000

main() {
  int n;
  char line[MAXLINE];

  while ((n = getline(line, MAXLINE)) > 0) {
    while (iin >= 0) {
      if (line[n] != ' ' && line[n] != '\t' && line[n] != '\n') {
        break;
      }
    }
    line[n+1] = '\0';
    printf("s\n", line);
  }
}
</pre>
  </details>

  <p>Программа getline выдает размер строки. Внутренний цикл while начинается с последнего символа в line и идет просмотр строки в обратном направлении в поисках первого символа, который не есть пробел или табуляция.</p>

  <h4>4.8 Continue (продолжение) (62)</h4>

  <p>Оператор continue переходит к началу следующей итерации в конструкциях while, for, do-while.</p>
  <p>Напечатаем положительные числа, пропуская отрицательные в цикле.</p>

  <details>
    <summary>Программа 44 (62)</summary>
<pre>
for (i = 0; i &lt; N; i++) {
  if (a[i] &lt; 0) {
    continue;
  }
  printf("%d ", a[i]);
}
</pre>
  </details>

  <h4>4.9 Переходы и метки (62)</h4>

  <p>Переходы и метки это плохой стиль программирования. Их на практике не используют. Но это простой способ выйти из внутреннего цикла с большим уровнем вложенности.</p>
  <p>Оператор перехода goto. Метку можно поставить перед любым оператором в той же функции, где находится оператор перехода на нее.</p>
</article>


<!-- Глава 5. Функции и структура программы -->
<article class="article">
  <div class="anchor" id="p6"></div>
  <h3>Глава 5. Функции и структура программы (64)</h3>

  <p>Программа может находиться в одном или нескольких файлах. В свои программы можно добавлять функции из библиотек.</p>

  <h4>5.1 Основы (64)</h4>

  <p>Если программу можно разбить на несколько частей, то лучше каждую часть вынести в отдельную функцию. С небольшими частями легче иметь дело, чем с одной большой программой. Кроме того, небольшие функции могут оказаться полезными и в других программах.</p>
  <p>Напише еще один вариант функции getline() для поиска всех строчек, содержащих заданный шаблон.</p>

  <details>
    <summary>Программа 45 (65)</summary>
<pre>
#define MAXLINE 1000

main() {
  char line[MAXLINE];
  while (getline(line, MAXLINE) > 0) {
    if (index(line, "the") >= 0) {
      printf("%s", line);
    }
  }
}

// записать строчку в s, вернуть длину
getline(char s[], int lim) {
  int c, i;
  i = 0;
  while (--lim > 0 && (c = getchar()) != EOF && c !='\n') {
    s[i++] c;
  }
  if (c == '\n') {
    s[i++] = c;
  }
  s[i] = '\0';
  return i;
}

// выдать начало t в c
index(char s[], char t[]) {
  int i, j, k;
  for (i = 0; s[i] != '\0'; i++) {
    for (j=i, k=0; t[k] != '\0' && s[j] == t[k]; j++, k++) ;
    if (t(k) == '0') {
      return i;
    }
  }
}
</pre>
  </details>

  <p>Во входном файле функции идут в любом порядке, а программа может быть разделена на много файлов. Функцию разделять на несколько файлов нельзя. Передавать значение из функции надо через оператор return.</p>
  <p>Предположим есть три функции в трех разных файлах main.c, getline.c, index.c. Запустим команду</p>
  <code>gcc main.c getline.c, index.c</code>
  <p>Эта команда транслирует эти три файла и создает объектные файлы main.o, getline.o, index.o и загружает их все в исполняемый файл a.exe. Если в одном файле встретилась ошибка, то его можно отредактировать и оттедльно затем транслировать.</p>

  <h4>5.2 Функции, выдающие не целые значения (67)</h4>

  <p>Если перед функцией не стоит тип возвращаемого значения, то по умолчанию функция возвращает целое число int.</p>
  <p>Напишем функцию atof() преобразующую строку в число с плавающей точкой двойной точности.</p>

  <details>
    <summary>Программа 46 (67)</summary>
<pre>
double atof(char s[]) {
  double val, power;
  int i, sign;

  // пропуск пустых символов
  for (i = 0; s[i] == ' ' || s[i] == '\n' || s[i] == '\t'; i++) ;

  // знак числа
  sign = 1;
  if (s[i] == '+' || s[i] == '-') {
    sign = (s[i++] == '+') ? 1 : -1;
  }

  for (val = 0; s[i] >= '0' && s[i] &lt;= '9'; i++) {
    val = 10 * val + s[i] - '0';
  }
  if (s[i] == '.') {
    i++;
  }
  for (power = 1; s[i] >= '0' && s[i] &lt;= '9'; i++) {
    val = 10 * val + s[i] - '0';
    power *= 10;
  }

  return (sign * val / power);
}
</pre>
  </details>
  <p>Напишем программу, которая считывает по одному числу на строку, возможно со знаком, складывает их все и печатает после каждого ввода сумму.</p>

  <details>
    <summary>Программа 47 (68)</summary>
<pre>
#define MAXLINE 100

// простейший калькулятор
main() {
  double sum, atof();
  char line[MAXLINE];
  sum = 0;

  while (getline(line, MAXLINE) > 0) {
    printf("\t%.2f\n", sum += atof(line));
  }
}
</pre>
  </details>
  <p>Напишем функцию atoi() преобразующую строку в целое число. Внутри функции будем использовать готовую функцию atof() преобразующую строку в тип double. Поскольку функция atoi() имеет тип возвращаемого значения int, то ее результат автоматически будет приводиться к типу int.</p>

  <details>
    <summary>Программа 48 (68)</summary>
<pre>
int atoi(char s[]) {
  double atof();
  return atof(s);
}
</pre>
  </details>

  <h4>5.3 Дополнительные сведения об аргументах (69)</h4>

  <p>Аргументы функции передаются по значению. При каждом вызове функция получает свою собственную, временную копию каждого аргумента. Функция не может изменять оригинальный аргумент в вызвавшей ее программе. Внутри функции каждый аргумент становится обычной локальной переменной.</p>
  <p>Если функции передать имя массива, то передается адрес на начало массива, сами элементы не копируются. Функция может обращаться к оригинальным элементам, используя адрес на начало и сдвиг относительно этого адреса. Массив передается по ссылке, поэтому функция может воздействовать на элементы массива в основной программе.</p>
  <p>Нет способа определить число элементов в массиве, если в функцию передается только его имя.</p>

  <h4>5.4 Внешние переменные (69)</h4>

  <p>Внешние переменные определены вне любой функции и доступны для многих функций. Все функции являются внешними, так как язык Си не позволяет определить функции внутри других функций.</p>
  <p>Все внешни переменные являются так же и глобальлными. Но можно определить внешнюю переменную или функцию, чтобы она не была глобально доступной и к ней можно было бы обращаться только из одного единственного файла.</p>
  <p>Внешние переменные можно использовать для передачи аргументов функции и для получения от них результата.</p>

  <p>Напишем программу калькулятор. Программа будет допускать операции +, -, *, / и = для печати ответа. Для реализации будем использовать обратную польскую нотацию, а не традиционную инфиксную. При такой нотации каждая операция идет следом за своими операндами, например польская запись</p>
  <code>1 2 - 4 5 + * =</code>
  <p>означает обычную запись</p>
  <code>(1 - 2) * (4 + 5) =</code>
  <p>Реализация очень простая. Строка с записью разбирается посимольно. Символы и числа отделены друг от друга пробелами. Если пришел операнд, то он помещается в стек. Если пришла операция, из стека выбирается нужное число операндов (для бинарной операции - два), к ним применяется операция и результат вновь опускается в стек.</p>
  <p>В нашем примере числа 1 и 2 помещаются в стек, затем к ним применяется операция минус и в стек помещается число -1. Следом в стек помещаются числа 4 и 5, затем к ним применяется операция плюс и в стек помещается число 9. В стеке остаются -1 и 9. Затем к ним применяется операция умножение и в стек помещается -9. Операция = печатает верхний элемент стека, не убирая его.</p>
  <p>Структура программы</p>
<pre>
while (следующая операция или операнд это не конец файла) {
  if (число) {
    поместить число в стек
  } else if (операция) {
    достать из стека два числа
    сделать операцию
    поместить в стек результат
  } else {
    ошибка
  }
}
</pre>

  <p>При конструировании программы надо решить где находится стек. Стек и связанная с ним информация будут внешними переменными, доступными для функций push() и pop(), но не доступными для функции main(). Функции main() ничего не нужно знать о стеке, она должна лишь пользоваться функциями push() и pop().</p>
  <p>Напишем калькулятор для польской записи</p>

  <details>
    <summary>Программа 49 (71)</summary>
<pre>
#define MAXOP      20
#define NUMBER    '0'
#define TOOBIG    '9'

main() {
  int type;
  char s[MAXOP];
  double op2, atof(), pop(), push();

  while ((type = getop(s, MAXOP)) != EOF) {
    switch (type) {
      case NUMBER:
        push(atof(s));
        break;
      case '+':
        push(pop() + pop());
        break;
      case '*':
        push(pop() * pop());
        break;
      case '-':
        op2 = pop();
        push(pop() - op2);
        break;
      case '/':
        op2 = pop();
        if (op2 != 0.0) {
          push(pop() / op2);
        } else {
          printf("zero divisor popped\n");
        }
        break;
        case '=':
          printf("\t%f\n", push(pop()));
          break;
        case 'c':
          clear();
          break;
        case TOOBIG:
          printf("%.20s ... is too long\n", s);
          break;
        default:
          printf("unknown command %c\n", type);
          break;
    }
  }
}

// максимальная глубина стека
#define MAXVAL 100
// указатель стека
int sp = 0;
double val[MAXVAL];

// поместить в стек
double push(double f) {
  if (sp &lt; MAXVAL) {
    return (val[sp++] = f);
  } else {
    printf("error: stack full\n");
    clear();
    return 0;
  }
}

// забрать из стека
double pop() {
  if (sp > 0) {
    return val[--sp];
  } else {
    printf("error: stack empty\n");
    clear;
    return 0;
  }
}

// очистить стек
clear() {
  sp = 0;
}
</pre>
  </details>

  <p>Для операций '+' и '*' порядок операндов не важен. Однако для '-' и '/' нужно следить где левый операнд а где правый. </p>

  <h4>5.5 Правила областей действия (73)</h4>

  <p>Функции и внешние переменные не обязательно хранить в одном файле и компилировать одновременно. Исходный текст программы можно хранить в нескольких файлах, а предварительно скомпилированные подпрограммы можно загружать из библиотеки.</p>
  <p>Область действия имени это часть программы, в которой это имя определено. Для автоматической переменной, описанной в начале функции, областью действия будет вся функция. Переменные с одинаковым именем в разных функциях никак не связаны. Область действия аргументов в функциях такая же как и автоматических переменных.</p>
  <p>Область действия внешней переменной от точки во входном файле, где она была описана и до конца файла.</p>
  <p>Если нужно использовать внешнюю переменную, описанную в другом файле, то ее не описывают повторно, а ссылаются на нее с помощью слова extern.</p>
  <p>При объявлении переменной, выделяется под нее память. А при ссылке на нее с помощью слова extern мы успокаиваем компилятор, говоря ему что такая переменная уже есть.</p>
  <p>Переменные val и sp можно определить и инициировать в одном файле, а функции push, pop, clear определить в другом.</p>
  <p>Файл 1</p>
<pre>
int sp = 0;
double val[MAXVAL];
</pre>
  <p>Файл 2</p>
<pre>
extern int sp;
extern double val[];
double push(double f) {}
double pop() {}
clear() {}
</pre>
  <p>Напишем функцию getop(), которая выбирает следующий операнд или операцию. Она пропускает пробелы, символы табуляции и перехода на новую строку. Если следующий символ не цифра или десятичная точка, то он не выдается. Иначе набирается строка цифр, которая может включать десятичную точку, и выдается NUMBER - сигнал о том, что введено число. Если приходит слишком длинное число, то выдается сигнал переполнения TOOBIG.</p>

  <details>
    <summary>Программа 50 (75)</summary>
<pre>
getop(char s[], int lim) {
  int i, c;
  while ((c = getch()) == ' ' || c == '\t' || c == '\n') ;

  if (c != '.' && (c &lt; '0' || c > '9')) {
    return c;
  }

  s[0] = c;
  for (i = 1; (c = getchar()) >= '0' && c &lt;= '9'; i++) {
    if (i &lt; lim) {
      s[i] = c;
    }
  }

  // дробная часть
  if (c == '.') {
    if (i &lt; lim) {
      s[i] = c;
    }
    for (i++; (c = getchar()) >= '0' && c &lt;= '9'; i++) {
      if (i &lt; lim) {
        s[i] = c;
      }
    }
  }

  // если число правильное
  if (i &lt; lim) {
    ungetch(c);
    s[i] = '\0';
    return(NUMBER);
  // если число слишком длинное
  } else {
    // пропустить все до конца строки
    while (c != '\n' && c != EOF) {
      c = getchar();
    }
    s[lim - 1] = '\0';
    return TOOBIG;
  }
}
</pre>
  </details>
  <p>Функция getch() берет следующий символ из входного потока. Функция ungetch() возвращает символ обратно во входной поток так, что следующее обращение к getch() опять выдаст этот символ. Как это работает? Функция ungetch() сохраняет возвращаемые символы в некотором буфере - символьнгом массиве. Функция getch() сначала читает информацию из этого буфера, если она там есть. Если буфер пустой, то обращается к getchar() и забирает следующий символ из входного потока.</p>

  <details>
    <summary>Программа 51 (76)</summary>
<pre>
#define BUFSIZE 100

// буфер для возврата символов
char buf[BUFSIZE]

// следующая свободная позиция в буфере
int bufp = 0;

// выдача возвращенного символа
getch() {
  return (bufp > 0) ? buf[--bufp] : getchar();
}

// возврат символа в буфер
ungetch(int c) {
  if (bufp > BUFSIZE) {
    printf("ungetch: too many characters\n");
  } else {
    buf[bufp++] = c;
  }
}
</pre>
  </details>

  <h4>5.6 Статические переменные (76)</h4>

  <p>Статическая переменная объявляется со словом static и может быть внутренней или внешней.</p>
  <p>Внутренние статические переменные локальны по отношению к отдельной функции, но они не возникают и не уничтожаются при каждом вызове функции, являясь постоянной памятью для функции.</p>
  <p>Внешние статические переменные видны только ниже их объявления в том файле где они объявлены и не видны в других файлах. Их имена не конфликтует с именами внешних переменных из других файлов.</p>
  <p>Функции являются внешними и их имена известны везде, однако можно объявить функцию как статическую и она будет видна только внутри файла, где она объявлена.</p>

  <h4>5.7 Регистровые переменные (77)</h4>

  <p>Если переменную объявить со словом register, то компилятор будет знать, что переменная будет часто использоваться и ее можно поместить в регистр машины. На практике в регистрах можно хранить только небольшое число переменных, поэтому компилятор сам решает хранить переменную в регистре или нет. Для регистровой переменной невозможна операция & взятия адреса.</p>
  <p>Со словом register можно объявить только автоматическую переменную или параметр функции.</p>

  <h4>5.8 Блочная структура (78)</h4>

  <p>Язык Си не относится к языкам с блочной структурой. Нельзя определять функцию внутри другой функции. Однако переменные можно определять как и в блочных языках. Если переменная объявлена внутри блока, ограниченного фигурными скобками, то в этом блоке она затеняет все другие переменные с таким же именем.</p>

  <h4>5.9 Инициация (78)</h4>

  <p>Если при объявлении переменной не происходит ее инициализация, то гарантируется, что внешние и статичкеские переменные будут иметь значение ноль, а автоматические и регистровые переменные будут содержать мусор (то что осталось в ячейках памяти от других программ).</p>
  <p>Простые переменные (не массивы или записи) можно инициировать при их определении, если постваить знак равенства и константное выражение</p>
  <code>int x = 1;</code>
  <code>char letter = 'a';</code>
  <p>Внешние и статические переменные инициируются только один раз по время компиляции.</p>
  <p>Автоматические и регистровые переменные инициируются при каждом входе в функцию или блок. Они могут инициироваться не только константами, можно использовать любые выражения, даже вызов функции.</p>
  <p>Автоматические массивы инициировать нельзя. Внешние и статические массивы можно инициировать, поместив в описании список значений через запятую в фигурных скобках.</p>
  <code>int digits[10] = {0,1,2,3,4,5,6,7,8,9};</code>
  <p>Если инициирующих значений меньше чем размер массива, то остальные элементы получают нулевые значения.</p>
  <p>Для символьных массивов существует специальный способ инициации</p>
  <code>char s[] = "the";</code>
  <code>char s[] = {'t', 'h', 'e', '\0'};</code>
  <p>Если не указать размер массива при инициации, то его длина равна числу инициирующих значений. В последнем случае длина равна 4.</p>

  <h4>5.10 Рекурсия (80)</h4>

  <p>Рекурсивная функция обращается сама к себе. Например напечатать числа как последовательность символов. Младшие разряды числа получаются раньше старших, а печататься должны в обратном порядке.</p>
  <p>Первый способ. Сохраним цифры в массиве и распечатаем массив в обратном порядке.</p>

  <details>
    <summary>Программа 52 (80)</summary>
<pre>
printd(int n) {
  char s[10];
  int i;
  if (n &lt; 0) {
    putchar('-';
    n = -n;)
  }
  i = 0;
  do {
    s[i++] = n % 10 + '0';
  } while ((n /= 10) > 0);

  while (--i >= 0) {
    putchar(s[i]);
  }
}
</pre>
  </details>
  <p>Второй способ. Рекурсивный. При каждом обращении к функции printd() она сначала обращается к себе, чтобы напечатать начальные цифры, а затем печатает замыкающую цифру.</p>

  <details>
    <summary>Программа 53 (81)</summary>
<pre>
printd(int n) {
  int i;

  if (n &lt; 0) {
    putchar('0');
    n = -n;
  }
  if ((i = n / 10) != 0) {
    printd(i);
  }
  putchar(n % 10+ '0');
}
</pre>
  </details>

  <p>Рекурсия не предусматривает защиту памяти, поэтому стек вызовов может переполняться. Однако рекурсивные программы более компактные и их легче писать и понимать.</p>

  <h4>5.11 Препроцессор для Си (81)</h4>

  <p>Конструкция</p>
  <code>#include "file"</code>
  <p>заменяется содержимым файла с указанным именем.</p>

  <p>Конструкция</p>
  <code>#define true 1</code>
  <p>Заменяет все имена true на 1.</p>
  <p>Если конструкция #define не умещается на одну строку, ее можно разбить на несколько строк, ставя в конце строки символ '\'.</p>

  <p>Можно определить макроподстановку с аргументами</p>
  <code>#define max(A, B) ((A) > (B) ? (A) : (B)</code>

  <p>После такого определения, везде в программе функция max будет заменена на ее тело.</p>
</article>


<!-- Глава 6. Ссылки и массивы -->
<article class="article">
  <div class="anchor" id="p7"></div>
  <h3>Глава 6. Ссылки и массивы (84)</h3>

  <p>Ссылка представляет собою переменную, содержащую адрес другой переменной. С помощью ссылок получаются более компактные и эффективные программы.</p>

  <h4>6.1 Ссылки и массивы (84)</h4>

  <p>Ссылка содержит адрес объекта, поэтому возможно косвенное обращение к объекту через ссылку.</p>
<pre>
int x, y;
int *px;
px = &x;
y = *px;
</pre>
  <p>В указателе px будет записан адрес переменной x.</p>
  <p>Операцию & взятия адреса можно применить только к переменным и элементам массива.</p>
  <p>В переменной y будет записано содержимое, по адресу px, то есть значение y будет равно значению x.</p>
  <p>Операция * разименования применяется к указателю и возвращает значение по адресу, на который указывает указатель.</p>

  <h4>6.2 Ссылки и аргументы функции (86)</h4>

  <p>Если передавая аргументы функции нужно изменить значения переменных в программе, то надо передавать их не по значению а по ссылке. Вызывать функцию нужно передавая адреса переменных.</p>
  <code>swap(&a, &b);</code>
  <p>Сама функция должна принимать указатели</p>
  <code>void swap(int *px, int *py) {}</code>
  <p>Напишем цикл, который заполняет целыми числами массив, обращаясь к getint()</p>
<pre>
int n, v, array[SIZE];
for (n = 0; n &lt; SIZE && getint(&v) != EOF; n++) {
  array[n] = v;
}
</pre>
  <p>Теперь напишем саму функцию getint(), которая берет очередное целое число</p>

  <details>
    <summary>Программа 54 (87)</summary>
<pre>
getint(int *pn) {
  int c, sign;

  // пропуск пустых символов
  while ((c = getch()) == ' ' || c == '\n' || c == '\t') ;

  sign = 1;
  if (c == '+' || c == '-') {
    sign = (c == '+') ? 1 : -1;
    c = getch();
  }
  for (*pn = 0; c >= '0' && c &lt;= '9'; c = getch()) {
    *pn = 10 * *pn + c - '0';
  }
  *pn *= sign;
  if (c != EOF) {
    ungetch(c);
  }

  return c;
}
</pre>
  </details>

  <h4>6.3 Ссылки и массивы (87)</h4>

  <p>Между ссылками и массивами существует сильная взаимосвязь. Любое действие по доступу к элементам массива через индекс, может быть выполнено также через ссылки.</p>
  <p>Объявим массив на 10 целых элементов</p>
  <code>int a[10];</code>
  <p>Объявим ссылку (указатель) на целове число</p>
  <code>int *pa;</code>
  <p>Присвоим указателю адрес первого элемента массива</p>
  <code>pa = &a[0];</code>
  <p>С помощью указателя получим доступ к первому элементу массива и скопируем его в переменную x</p>
  <code>int x = *pa;</code>
  <p>pa + 1 указывает на следующий элемент массива. pa - 1 указывает на предыдущий элемент массива.</p>
  <code>*(pa + 1) == a[1]</code>
  <code>*(pa + i) == a[i]</code>
  <code>pa == &a[0]</code>
  <code>pa == a</code>

  <p>Есть различие между ссылкой на массив и именем массива. Ссылка это переменная. Ссылке можно присвоить другое значение</p>
  <code>pa = a; pa = b;</code>
  <p>Ссылку можно увеличить на 1</p>
  <code>pa++;</code>
  <p>Имя массива это константа. Если имя массива передается функциии, то оно передается как местоположение начала массива. Внутри функции имя массива это обычная переменная, содержащая адрес.</p>
  <p>Напишем функцию strlen(), которая подсчитывает длину строки</p>

  <details>
    <summary>Программа 55 (89)</summary>
<pre>
strlen(char *s) {
  int n;
  for (n = 0; *s != '\0'; s++) {
    n++;
  }
  return n;
}
</pre>
  </details>

  <p>Увеличение s внутри функции допустимо, так как это ссылочная переменная. Операция s++ никак не изменяет строку символов, а просто увеличивает собственную копию адреса.</p>
  <p>При объявлении функции, параметры char s[] и char *s эквивалентны.</p>
  <p>Чтобы передать функции подмассив, нужна задать ссылку на начало подмассива</p>
  <code>f(&a[2]); или f(a + 2);</code>
  <p>При этом для функции нет никакой разницы, придет ли ей ссылка на начало массива или на начало подмассива.</p>

  <h4>6.4 Адресная арифметика (89)</h4>

  <p>Функция alloc(n) возвращает ссылку p на n последователых ячеек памяти. Функция free(p) освобождает выделенную память и ее можно повторно использовать. Самая простая реализация функции alloc() это брать память из мольшого массива ячеек памяти. Будем называть такой массив allocbuf. Это собственный массив для функций alloc() и free().Он работает по принципц стека. Освобождать память нужно в порядке, противоположном тому, как она выделялась. Нужно хранить указатель allocp на следующую свободную ячейку памяти в буфере allocbuf.</p>
  <p>Напишем функции alloc() и free()</p>

  <details>
    <summary>Программа 56 (90)</summary>
<pre>
#define NULL 0
#define ALLOCSIZE 1000

static char allocbuf[ALLOCSIZE];
static char *allocp = allocbuf;

char *alloc(int n) {
  if (allocp + n &lt;= allocbuf + ALLOCSIZE) {
    allocp += n;
    return (allocp - n);
  } else {
    return NULL;
  }
}

free(char *p) {
  if (p >= allocbuf && p &lt; allocbuf + ALLOCSIZE) {
    allocp = p;
  }
}
</pre>
  </details>

  <p>Если два указателя p и q указывают на элементы одного и того же массива, то их можно сравнивать между собой. Такие указатели можно даже вычитать и получим число элементов между указателями p и q.</p>
  <p>Напишем функцию strlen() для подсчета длины строки.</p>

  <details>
    <summary>Программа 57 (92)</summary>
<pre>
strlen(char *s) {
  char *p = s;
  while (*p != '\0') {
    p++;
  }
  return p - s;
}
</pre>
  </details>

  <h4>6.5 Символьные ссылки и функции (92)</h4>

  <p>Любая строковая константа, например "string", представляет собой массив символов. Компилятор закончит такой массив символом '\0', чтобы программа могла обнаружить конец строки. Поэтому строка занимает в памяти на один символ больше, чем указано между двойными кавычками. В языке Си нет операций для работы со строками целиком.</p>
  <p>Напишем функцию strcpy() копирования одной строки в другую используя массив символов.</p>

  <details>
    <summary>Программа 58 (93)</summary>
<pre>
strcpy(chars[], char t[]) {
  int i = 0;
  while ((s[i] = t[i]) != '\0') {
    i++;
  }
}
</pre>
  </details>
  <p>Напишем функцию strcpy() копирования одной строки в другую используя указатели.</p>

  <details>
    <summary>Программа 59 (93)</summary>
<pre>
strcpy(char *s, char *t) {
  while ((*s = *t) != '\0') {
    s++;
    t++;
  }
}
</pre>
  </details>
  <p>Напишем функцию strcpy() копирования одной строки в другую используя указатели, немного сократим программу.</p>

  <details>
    <summary>Программа 60 (93)</summary>
<pre>
strcpy(char *s, char *t) {
  while ((*s++ = *t++) != '\0')
    ;
}
</pre>
  </details>
  <p>Напишем функцию strcpy() копирования одной строки в другую используя указатели, еще немного сократим программу.</p>

  <details>
    <summary>Программа 61 (94)</summary>
<pre>
strcpy(char *s, char *t) {
  while (*s++ = *t++)
    ;
}
</pre>
  </details>
  <p>Напишем функцию strcmp(), которая сравнивает две строки и выдает отрицательное, нулевое или положительное число. Вариант с массивами символов.</p>

  <details>
    <summary>Программа 62 (94)</summary>
<pre>
strcmp(char s[], char t[]) {
  int i = 0;
  while (s[i] == t[i]) {
    if (s[i++] == '\0') {
      return 0;
    }
  }
  return s[i] - t[i];
}
</pre>
  </details>
  <p>Напишем функцию strcmp(), которая сравнивает две строки и выдает отрицательное, нулевое или положительное число. Вариант с указателями.</p>

  <details>
    <summary>Программа 63 (94)</summary>
<pre>
strcmp(char *s, char *t) {
  for(; *s == *t; s++, t++) {
    if (*s == '\0') {
      return 0;
    }
  }
  return *s - *t;
}
</pre>
  </details>

  <h4>6.6 Ссылки - не целевые значения (95)</h4>
  <p>Напишем функцию strsave(), копирующую строку на свободное место, выделенное функцией alloc().</p>

  <details>
    <summary>Программа 64 (95)</summary>
<pre>
char *strsave(char *s) {
  char *p, *alloc();
  if ((p = alloc(strlen(s) + 1)) != NULL) {
    strcpy(p, s);
  }
  return p;
}
</pre>
  </details>
  <p>Напишем функцию strsave(), копирующую строку на свободное место, выделенное функцией alloc(), пропуская объявление alloc().</p>

  <details>
    <summary>Программа 65 (95)</summary>
<pre>
char *strsave(char *s) {
  char *p;
  if ((p = alloc(strlen(s) + 1)) != NULL) {
    strcpy(p, s);
  }
  return p;
}
</pre>
  </details>

  <p>Такая программа работать будет потому что тип функции и аргументов - int, а целые и ссылки можно присваивать друг другу. Но в зависимости от архитектуры компьютера, компилятор может реализовать их по другому. Мудрее будет сохранять все объявления.</p>

  <h4>6.7 Многомерные массивы (95)</h4>

  <h4>6.8 Массивы ссылок. Ссылки на ссылки (97)</h4>

  <p>Так как ссылки представляют собою переменные, то можно использовать и массивы ссылок. Если хранимые строки распологаются плотно одна за другой в одном длинном символьном массиве (например, полученном с помощью alloc), то до каждой строки можно добраться с помощью ссылки на ее первый символ. Сами ссылки можно хранить в массиве. Сравнить две строки можно с помощью функции strcmp() передавая ей ссылки на них. Если строки нужно поменять местами, то менять местами можно только ссылки в массиве ссылок, а не сами строки.</p>
  <p>Напишем программу сортировки входных строк.</p>

  <details>
    <summary>Программа 66 (98)</summary>
<pre>
#define NULL 0
#define LINES 100

int main() {
  char *lineptr[LINES];
  int nlines;
  if ((nlines = readlines(lineptr, LINES)) >= 0) {
    sort(lineptr, nlines);
    writelines(lineptr, nlines);
  } else {
    printf("input too big to sort\n");
  }
}

#define MAXLEN 1000
readlines(char *lineptr, int maxlines) {
  int len, nlines;
  char *p, *alloc(), line[MAXLEN];
  nlines = 0;
  while ((len = getline(line, MAXLEN)) > 0) {
    if (nlines >= maxlines) {
      return -1;
    } else if ((p = alloc(len)) == NULL) {
      return -1;
    } else {
      line[len - 1] = '\0';
      strcpy(p, line);
      lineptr[nlines++] = p;
    }
  }
  return nlines;
}

writelines(char *lineptr, int nlines) {
  int i;
  for (i = 0; i &lt; nlines; i++) {
    printf("s\n", lineptr[i]);
  }
}
</pre>
  </details>

  <h4>6.9 Инициация массивов ссылок (100)</h4>
  <p>Напишем функцию month_name(), которая выдает название месяца.</p>

  <details>
    <summary>Программа 67 (100)</summary>
<pre>
char *month_name(int n) {
  static char *name[] {
    "illegal month",
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "Septemper",
    "October",
    "November",
    "December"
  };
  return (n &lt; 1 || n > 12) ? name[0] : name[n];
}
</pre>
  </details>

  <h4>6.10 Ссылки и многомерные массивы (101)</h4>

  <p>Зададим двумерный массив и массив ссылок</p>
  <code>int a[10][10];</code>
  <code>int *b[10];</code>
  <p>К элементам массивов можно обращаться одинаково a[5][5] и b[5][5]. Для двумерного массива выделены 100 ячеек памяти и для определения нужного элемента выполняются индексные вычисления. Если в массиве ссылок каждая ссылка указывает на массив из десяти элементов, то всего будет занято 100 ячеек памяти под эти массивы плюс еще 10 ячеек на ссылки. Таким образом, массив ссылок занимает чуть больше памяти чем двумерный массив.</p>
  <p>Массив ссылок имеет преимущества. Доступ к элементам идет косвенно через ссылку и не требует умножения и сложения. Строки массива могут быть различного размера. Ссылка может указывать на массив из 10, 100 или 0 элементов.</p>

  <h4>6.11 Внешние аргументы (101)</h4>

  <p>При вызове программы на языке Си, ей можно передавать аргументы. argc - число переданных аргументов, argv - ссылка на массив строк, содержащих переданные аргументы.</p>
  <p>Если при вызове никакие аргументы не передаются, то они все равно есть и их можно достать. argv[0] это всегда имя программы. Так что argc = 1.</p>
  <p>Напишем программу echo, которая принимает строку и выводит ее на экран</p>

  <details>
    <summary>Программа 68 (102)</summary>
<pre>
int main(int argc, char *argv[]) {
  for (int i = 1; i &lt; argc; i++) {
    printf("%s%c", argv[i], (i &lt; argc - 1) & ' ' : '\n');
  }
}
</pre>
  </details>
  <p>Поскольку argv это ссылка на массив ссылок, то есть несколько способов написать такую прогамму, манипулируя массивами с помощью ссылок, а не индексов.</p>

  <details>
    <summary>Программа 69 (102)</summary>
<pre>
int main(int argc, char *argv[]) {
  while (--argc > 0) {
    printf("%s%c", *++argv, (argc > 1) & ' ' : '\n');
  }
}
</pre>
  </details>

  <details>
    <summary>Программа 70 (102)</summary>
<pre>
int main(int argc, char *argv[]) {
  while (--argc > 0) {
    printf((argc > 1) ? "%s ", : '\n', *++argv);
  }
}
</pre>
  </details>
  <p>Напишем программу, в которой искомый шаблон строки задается аргументом из командной строки при вызове программы.</p>

  <details>
    <summary>Программа 71 (103)</summary>
<pre>
#define MAXLINE 1000

int main(int argc, char *argv[]) {
  char line[MAXLINE]

  if (argc != 2) {
    printf("Usage: find pattern\n");
  } else {
    while (getline(line, MAXLINE) > 0) {
      if (index(line, argv[1]) >= 0) {
        printf("%s", line);
      }
    }
  }
}
</pre>
  </details>
  <p>Параметр со знаком минус в шаблоне должен искать все строки кроме содержащих данный шаблон. Напишем программу, которая ищет строки содержащие шаблон и не содержащие другой шаблон, например</p>
  <code>find -nx the</code>

  <details>
    <summary>Программа 72 (103)</summary>
<pre>
#define MAXLINE 1000

int main(int argc, char *argv[]) {
  char line[MAXLINE], *s;
  lomglineno = 0;
  int except = 0. number = 0;

  while (--argc > 0 && *++argv()[0] == '-') {
    for (s = argv[0] + 1; *s != '\0'; s++) {
      switch (*s) {
        case 'x':
          except = 1;
          break;
        case 'n':
          number = 1;
          break;
        default:
          printf("find: illegal option %c\n", *s);
          argc = 0;
          break;
      }
    }
  }

  if (argc != 1) {
    printf("Usage: find -x -n pattern\n");
  } else {
    while (getline(line, MAXLINE) > 0) {
      lineno++;
      if ((index(line, *argv) >= 0) != except) {
        if (number) {
          printf("%ld: ", lineno);
        }
        printf("%s", line;)
      }
    }
  }
}
</pre>
  </details>

  <h4>6.5 Ссылки на функции (105)</h4>

  <p>Сама функция не может быть значением перемнной, но можно определить ссылку на функцию. И с этой ссылкой можно работать как с переменной. Ее можно помещать в массив или передать другой функции.</p>
  <p>Для алгоритма сортировки всегда требуется функция сравнения. Функция strcmp() делает лексикографическое сравнение.</p>
  <p>Напишем программу сортировки строк.</p>

  <details>
    <summary>Программа 73 (105)</summary>
<pre>
#define LINES 100

int main(int argc, char *argv[]) {
  char *lineptr[LINES];
  int nlines;
  int strcmp(), numcmp();
  int swap();
  int numeric = 0;

  if (argc > 1 && argv[1][0] == '-' && argv[1][1] = 'n') {
    numeric = 1;
  }
  if ((nlines = readlines(lineptr, LINES)) >= 0) {
    if (numeric) {
      sort(lineptr, nlines, numcmp, swap);
    } else {
      sort(lineptr, nlines, strcmp, swap);
    }
    writelines(lineptr, nlines);
  } else {
    printf("input too big to sort\n");
  }
}
</pre>
  </details>
  <p>Модифицируем функцию сортировки строк sort</p>

  <details>
    <summary>Программа 74 (106)</summary>
<pre>
sort(char *v[], int n, int (*comp)(), int (*exch)()) {
  int gap, i, j;
  for (gap = n / 2; gap > 0; gap /= 2) {
    for (i = gap; i &lt; n; i++) {
      for (j = i - gap; j >= 0; j -= gap) {
        if ((*comp)(v[j], v[j+gap]) &lt;= 0) {
          break;
        }
        (*exch)(&v[j], &v[j+gap]);
      }
    }
  }
}
</pre>
  </details>
  <p>Напишем функцию numcmp() сравнивающую две строки по начальным числовым значениям.</p>

  <details>
    <summary>Программа 75 (106)</summary>
<pre>
numcmp(char *s1, char *s2) {
  double atof(), v1, v2;
  v1 = atof(s1);
  v2 = atof(s2);
  if (v1 &lt; v2) {
    return -1;
  } else if (v1 > v2) {
    return 1;
  } else {
    return 0;
  }
}
</pre>
  </details>
  <p>Напишем функцию swap() меняющую местами две ссылки.</p>

  <details>
    <summary>Программа 76 (107)</summary>
<pre>
swap(char *px[], char *py[]) {
  char *temp;
  temp = *px;
  *px = *py;
  *py = temp;
}
</pre>
  </details>
</article>


<!-- Глава 7. Записи -->
<article class="article">
  <div class="anchor" id="p8"></div>
  <h3>Глава 7. Записи (108)</h3>

  <p>Записи нужны для организации сложных данных в больших программах. Они группируют переменные различных типов и позволяют работать с ними как с одним целым.</p>

  <h4>7.1 Основы (108)</h4>

  <p>Создадим новую структуру данных date, содержащюу информацию о дате</p>
<pre>
struct date {
  int day;
  int month;
  int year;
  int yearday;
  char mon_name[4];
} d1, d2;
</pre>
  <p>Если после определения записи идет список переменных, то программа сразу выделяет для них память. Переменные можно определить и позже.</p>
  <code>struct date d3, d4;</code>
  <p>При объявлении можно задать и значения полей записи.</p>
  <code>struct date d5 = {4, 7, 1776, 186, "Jul"};</code>
  <p>Задать или изменить поля в записи можно через точечную нотацию</p>
  <code>d5.year = 1995;</code>
  <p>Преобразование первого символа названия месяца к нижнему регистру</p>
  <code>d5.mon_name[0] = lower(d5.mon_name[0]);</code>
  <p>Записи можно вкладывать одна в другую.</p>

  <p>Создадим новую структуру данных person, содержащую внутри структуру date</p>
<pre>
struct person {
  char name[NAMESIZE];
  char address[ADRSIZE];
  double salary;
  struct date birthdate;
}
</pre>

  <h4>7.2 Записи и функции (110)</h4>

  <p>Саму запись нельзя передать в функцию. Но в функцию можно передать элемент записи или ссылку на запись.</p>
  <p>Напишем функцию day_of_year() принимающую ссылку на запись и возвращающую номер дня по месяцу и чилу.</p>

  <details>
    <summary>Программа 77 (111)</summary>
<pre>
day_of_year(struct date *pd) {
  int i, day, leap;
  day = pd->day;
  leap =  pd->year % 4 == 0 &&
          pd->year % 100 !=0 ||
          pd->year % 400 == 0;
  for (i = 1; i &lt; pd->month; i++) {
    day += day_tab[leap][i];
  }
  return day;
}
</pre>
  </details>
  <p>Напишем функцию month_day которая выдает месяц и число по номеру дня.</p>

  <details>
    <summary>Программа 78 (112)</summary>
<pre>
month_day(struct date *pd) {
  int i, leap;
  leap =  pd->year % 4 == 0 &&
          pd->year % 100 !=0 ||
          pd->year % 400 == 0;
  pd->day = pd->yearday;
  for (i = 1; pd->day > day_tab[leap][i]; i++) {
    pd->day -= day_tab[leap][i];
  }
  pd->month = i;
}
</pre>
  </details>

  <h4>7.3 Массивы записей (112)</h4>

  <h4>7.4 Ссылки на записи (116)</h4>

  <h4>7.5 Записи со ссылками на самое себя (118)</h4>
  <p>Напишем функцию treeprint которая рекурсивно печатает дерево.</p>

  <details>
    <summary>Программа 79 (120)</summary>
<pre>
treeprint(struct tnode *p) {
  if (p != NULL) {
    treeprint(p->left);
    printf("4d %s\n", p->count, p->word);
    treeprint(p->right);
  }
}
</pre>
  </details>

  <h4>7.6 Просмотре таблиц (121)</h4>

  <p>Любой блок в цепочке это запись, состоящая из ссылок на имя, на замещающих текст и на следующий блок в этой цепочке. Нулевая ссылка на следующий блок сигнализирует о конце цепочки</p>
  <p>Напишем основную строку таблицы</p>

  <details>
    <summary>Программа 80 (122)</summary>
<pre>
struct nlist {
  char *name;
  char *def;
  struct nlist *next;
}
</pre>
  </details>

  <p>Напишем массив ссылок</p>
<pre>
#define HASHSIZE 100
static struct nlist *hashtab[HASHSIZE];
</pre>

  <p>Функция свертки, используемая в lookup и install, просто складывает значения символов в строке по модулю размера массива.</p>
<pre>
hash(char *s) {
  int hashval;
  for (hashval = 0; *s != '\0') {
    hashval += *s++;
  }
  return hashval % HASHSIZE;
}
</pre>

  <h4>7.7 Поля (123)</h4>

  <p>На одних машинах поля размещаются в слове слева направо, а на других - справа налево, все зависит от особенностей аппаратуры.</p>
  <p>Поля не имеют знака. Их можно хранить лишь в целых без знака переменных. Они не могут быть массивами и не имеют адресов, поэтому к ним нельзя применять операцию &.</p>

  <h4>7.8 Смеси (125)</h4>

  <p>Смесь это некоторая переменная, могущая хранить объекты различного типа и размера. Смеси дают возможность работать в одной и той же области памяти с данными различного вида.</p>
<pre>
union u_tag {
  int ival;
  float fval;
  char *pval;
}
</pre>
  <p>Переменная u_tag достаточно велика чтобы сохранить самый большой из этих трех типов. Любой из этих трех типов можно присвоить *uval. Помнить о том какой тип сейчас хранится в переменой типа смесь это обязанность программиста.</p>
  <p>Практически смесь это запись, все элементы которой имеют нулевое смещение, причем сама запись достаточно велика, чтобы сохранить самый объемный элемент и выровнена так, чтобы можно было работать со всеми смешиваемыми типами.</p>
  <p>Можно только обращаться к отдельным элементам смеси или брать ее адрес, но смеси нельзя передавать функциям и получать от функций.</p>

  <h4>7.9 Определение типа (126)</h4>

  <p>В языке Си можно создавать имена для новых типов данных. Для этого используется определение типа</p>
  <code>typedef int LENGTH;</code>
  <p>Теперь имя LENGTH это псевдоним типа int.</p>
  <code>typedef char* STRING;</code>
  <p>Теперь имя STRING это синоним типа char*, т.е. ссылки на символ.</p>
  <p>Определим тип для ветвей дерева</p>

  <details>
    <summary>Программа 81 (127)</summary>
<pre>
typedef struct tnode {
  char *word;
  int count;
  struct tnode *left;
  struct tnode *right;
} TREENODE, *TREEPTR;
</pre>
  </details>

  <p>Теперь имя TREENODE это запись, а TREEPTR это ссылка на эту запись.</p>

  <p>Описание typedef не создает никакого нового типа, просто обавляет новое имя для существующего типа.</p>
  <p>Описание типа обеспечивает лучшую документируемость программ. Ведь TREEPTR оенче преяить, чем ссылку на какую-то сложную запись.</p>
</article>


<!-- Глава 8. Ввод и вывод -->
<article class="article">
  <div class="anchor" id="p9"></div>
  <h3>Глава 8. Ввод и вывод (129)</h3>

  <p>В языке Си не предусмотрены возможности для ввода и вывода. В стандартной библиотеке есть множество функций, обеспечивающих ввод и вывод для программ на Си. Функции отражают только те операции, которые можно найти в большинстве современных операционных систем.</p>

  <h4>8.1 Обращение к стандартной библиотеке (129)</h4>

  <p>Чтобы в программе обратиться к стандартной библиотеке, нужно нписать такую строку</p>
  <code>#include &lt;stdio.h&gt;</code>

  <h4>8.2 Стандартный ввод и вывод (130)</h4>
  <p>Перевод вводимых символов в нижний регистр</p>

  <details>
    <summary>Программа 82 (131)</summary>
#include &lt;stdio.h&gt;

int main() {
  int c;
  while ((c = getchar()) != EOF) {
    putchar(isupper(c) ? tolower(c) : c);
  }
}
</pre>
  </details>

  <h4>8.3 Форматный вывод printf (131)</h4>

  <code>printf(control [, arg1, arg2, ...]);</code>

  <p>Функция printf() печатает в выходной поток управляющую строку, заменяя спецификаторы переданными аргументами.</p>
  <p>Если управляющая строка содержит только обычные символы, то аргументы не передаются. Если управляющая строка содержит N спецификаторов, то передается ровно N аргументов. Каждый спецификатор начинается символом % и содержит спецификацию преобразования. Функция printf использует первый параметр control, чтобы определить сколько всего параметров.</p>

  <h4>8.4 Форматный ввод scanf (133)</h4>

  <code>scanf(control [, arg1, arg2, ...]);</code>

  <p>Функция scanf() читает символы из входного потока и записывает результаты в параметры, заданными в управляющей строке и переданные как аргументы.</p>
  <p>Каждый параметр должен быть ссылкой, указывающей где нужно сохранять преобразованную согласно спецификатору входную информацию. Пробелы, табуляция, переход на новую строку игнорируются. Обычные символы должны совпадать с символами во входном потоке. Спецификаторы начинаются с символа % и задают преобразование для входного символа.</p>
  <p>Примитивный калькулятор</p>

  <details>
    <summary>Программа 83 (134)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  double sum, v;
  sum = 0;
  while (scanf("%lf", &v) != EOF) {
    putchar("\t%.2f\n", sum += v);
  }
}
</pre>
  </details>

  <h4>8.5 Форматные преобразования в памяти (135)</h4>

  <p>Функции printf и scanf имеют двойников sprintf и sscanf.</p>

  <code>sprintf(string, control [, arg1, arg2, ...]);</code>
  <p>Функция sprintf работает со строкой и берет информацию из строки string</p>

  <code>sscanf(string, control [, arg1, arg2, ...]);</code>
  <p>Функция sscanf работает со строкой и выводит информацию в string</p>

  <h4>8.6 Доступ к файлам (135)</h4>

  <p>Прежде чем читать или записывать в файл, нужно его открыть с помощью стандартной библиотечной функции fopen. Эта функция обращается к операционной системе, находит нужный файл и возвращает ссылку на файл, которую следует присвоить переменной типа FILE и использовать при чтении или записи в файл. Ссылка на файл содержит местоположение файла, позицию текущего символа, режим в котором открыт файл - чтение или запись.</p>
  <code>FILE fp = fopen(name, mode);</code>
  <p>Первый параметр name это строка, содержащая имя файла. Второй параметр это строка, задающая режим работы с файлом. Если происходит ошибка при открытии файла, то fopen возвращает NULL.</p>
  <p>Прочитаем символ из открытого файла</p>
  <code>char c = getc(fp);</code>
  <p>Запишем символ в открытый файл</p>
  <code>putc(c, fp);</code>

  <p>С началом работы любой программы автоматически открываются три файл это стандартный вход, стандартный выход и стандартный выход ошибок. Есть три ссылки на эти файлы stdin, stdout, stderr. Первоначально они связаны с терминалом, но по ходу программы их можно переопределять на другие устройства, например на файлы.</p>
  <code>#define getchar() getc(stdin)</code>
  <code>#define putchar() putc(c, stdout)</code>

  <p>Функции printf и scanf имеют еще одних двойников fprintf и fscanf.</p>

  <code>fprintf(*file, control [, arg1, arg2, ...]);</code>
  <p>Функция fprintf работает с файлом, на который указывает ссылка *file</p>

  <code>fscanf(*file, control [, arg1, arg2, ...]);</code>
  <p>Функция fscanf работает с файлом, на который указывает ссылка *file</p>
  <p>Напишем программу cat, объединяющую два файла</p>

  <details>
    <summary>Программа 84 (137)</summary>
<pre>
#include &lt;stdio.h&gt;

void filecopy(FILE *fp);

int main(int argc, char *argv[]) {
  FILE *fp;
  if (argc == 1) {
    filecopy(stdin);
  } else {
    while (--argc > 0) {
      if ((fp = fopen(*++argv, "r")) == NULL) {
        printf("cat: can't open %s file\n", *argv);
        break;
      } else {
        filecopy(fp);
        fclose(fp);
      }
    }
  }
}

filecopy(FILE *fp) {
  int c;
  while ((c = getc(fp)) != EOF) {
    putc(c, stdout);
  }
}
</pre>
  </details>

  <p>Ссылки на файлы stdin и stdout определены в библиотеке stdio.h как ссылки на стандартные входной и выходной потоки. Их можно использовать везде, где допускаются объекты типа FILE*. Однако это константы, а не переменные и им нельзя что-любо присваивать.</p>
  <p>После работы с файлом, открытым функцией fopen, его нужно обязательно закрыть функцией fclose. После этого ссылка на файл будет свободна и ее можно использовать для другого файла. Операционная система ограничивает число одновременно открытых файлов в одной программе, поэтому ненужные ссылки надо сразу освобождать. Функция fclose также опустошает буфер, где putc накапливает информацию. При нормальном завершении программы, для каждого открытого в программе файла автоматически вызывается fclose.</p>

  <h4>8.7 Реакция на ошибки. stderr и exit (138)</h4>

  <p>Информация, записанная в stderr появляется на экране, даже если стандартный выходной поток от экрана отключен.</p>
  <p>Перепишем программу cat, чтобы она выдавала сообщение об ошибке в стандартный файл ошибок</p>

  <details>
    <summary>Программа 85 (138)</summary>
<pre>
#include &lt;stdio.h&gt;

void filecopy(FILE *fp);

int main(int argc, char *argv[]) {
  FILE *fp;
  if (argc == 1) {
    filecopy(stdin);
  } else {
    while (--argc > 0) {
      if ((fp = fopen(*++argv, "r")) == NULL) {
        fprintf(stderr,
              "cat: can't open %s file\n", *argv);
        exit(1);
      } else {
        filecopy(fp);
        fclose(fp);
      }
    }
  }
  exit(0);
}

filecopy(FILE *fp) {
  int c;
  while ((c = getc(fp)) != EOF) {
    putc(c, stdout);
  }
}
</pre>
  </details>

  <p>При обращении к стандартной библиотечной функции exit, выполнение программы заканчивается. Если возвращается значение 0, то все прошло хорошо. Отличное от нуля значение означает аварийное завершение программы. Перед выходом из программы, функция exit обращается к функции fclose для каждого открытого в программе файла.</p>

  <h4>8.8 Ввод и вывод строк (139)</h4>

  <p>Функция fgets() читает из файла fp в символьный массив line очередную входную строчку, включая символ новой строки.</p>
  <code>fgets(line, MAXLINE, fp);</code>
  <p>Может быть считано не молее MAXLINE - 1 символов, последним к ним добавится символ '\0'.</p>

  <p>Функци fputs() записывает в файл fp строку, не обязательно содержащую символ новой строки.</p>
  <p>Напишем функции fgets, fputs также, как они находятся в библиотеке ввода-вывода</p>

  <details>
    <summary>Программа 86 (139)</summary>
<pre>
#include &lt;stdio.h&gt;

char *fgets(char *s, int n, register FILE *iop) {
  register int c;
  register char *cs;

  cs = s;
  while (--n > 0 && (c = getc(iop)) != EOF) {
    if ((*cs++ = c) == '\n') {
      break;
    }
  }
  *cs = '\0';
  return (c == EOF && cs == s) ? NULL : s;
}

fputs(register char *s, register FILE *iop) {
  register int c;
  while (c = *s++) {
    putc(c, iop);
  }
}
</pre>
  </details>

  <h4>8.9 Некоторые полезные функции (140)</h4>

  <code>system("date");</code>
  <p>Печатает дату и запрашивает новую.</p>

  <code>p = calloc(n, sizeof(object));</code>
  <p>Выделяет память на n элементов размером sizeof(object) и возвращает ссылку на нее.</p>

  <code>cfree(p);</code>
  <p>Освобождает память выделенную обращением к calloc(). Будет ужасной ошибкой освобождать память, не полученную путем обращения к calloc().</p>
</article>


<!-- Глава 9. Взаимодействие с системой UNIX -->
<article class="article">
  <div class="anchor" id="p10"></div>
  <h3>Глава 9. Взаимодействие с системой UNIX (142)</h3>

  <p>Основные темы: ввод-вывод, система файлов и выделение памяти.</p>

  <h4>9.1 Дескрипторы файлов (142)</h4>

  <p> В ОС UNIX все работы по вводу и выводу это чтение и запись в файлы, поскольку все внешние устройства, даже терминал, это файлы в системе файлов. Прежде чем читать или записывать в файл, его нужно открыть. Система проверяет, имеете ли вы право сделать это. Если да, то выдает положительное число, называемое дескриптором файла. Вся информация об открытом файле сохраняется в системе, а пользователь работает с файлом только с помощью дескриптора.</p>
  <p>Когда запускается программа, то открывается три файла с дескрипторами 0, 1, 2 для stdin, stdout, stderr. Можно сказать интерпретатору перевести присваивание на другие файлы. При этом программа, использующая дескрипторы 0, 1, 2 не знает откуда и куда идет информация.</p>

  <h4>9.2 Нижний уровень ввода-вывода. read и write (143)</h4>

  <h4>9.3 open, creat, close, unlink (144)</h4>

  <h4>9.4 Случайный доступ. seek и lseek (146)</h4>

  <h4>9.5 Пример. Реализация foren и gets (147)</h4>

  <h4>9.6 Пример. Распечатка каталогов (150)</h4>

  <p>В UNIX любой каталог это просто файл. Команда ls выводит имена файлов и каталогов в том каталоге, где она запущена. Многие программы просто используют ту информацию, которую формирует операционная система.</p>

  <h4>9.7 Пример. Распределитель памяти (152)</h4>

  <p>Процесс выделения памяти машинно-зависим. Управление памятью в своей программе будет машинно-зависимой.</p>
</article>


<!-- Справочное руководство по языку Си -->
<article class="article">
  <div class="anchor" id="p11"></div>
  <h3>Справочное руководство по языку Си (157)</h3>

  <p>В языке Си 28 служебных слов (до появления стандарта C99).</p>

  <code>int i, *ip, f(), *fip(), (*pfi)();</code>
  <p>Объявляются целое i, ссылка ip на целое, функция f, дающая целое, функция fip, дающая ссылку на целое, ссылка pfi на функцию, дающую целое.</p>

  <code>float fa[17], *afp[17];</code>
  <p>Объявляется массив чисел типа float и массив ссылок на числа типа float.</p>

  <p>Имя массива в выражении преобразуется в ссылку на первый элемент массива. Из-за этого преобразования массивы не являются значениями.</p>
</article>


<!-- Задачи по языку Си -->
<article class="article">
  <div class="anchor" id="p12"></div>
  <h3>Задачи по языку Си (193)</h3>

  <h3>Глава 1. Операции (194)</h3>

  <p>Процесс изучения языка программирования состоит из трех этапов. Первый этап это освоение синтаксиса языка настолько, что транслятор перестает ругаться, обнаружив в программе бессмысленные конструкции. Второй этап это осмысление правильно построенных транслятором конструкций языка. Третий этап это умение писать ясные, краткие и правильные программы.
  </p>

  <h4>1 Основные арифметические операции</h4>

  <details>
    <summary>Программа 87 (195)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int x;

  x = - 3 + 4 * 5 - 6;
  printf("%d\n", x);

  x = 3 + 4 % 5 - 6;
  printf("%d\n", x);

  x = - 3 * 4 % - 6 / 5;
  printf("%d\n", x);

  x = (7 + 6) % 5 / 2;
  printf("%d\n", x);
}
</pre>
  </details>

  <h4>2 Операции присваивания</h4>

  <details>
    <summary>Программа 88 (195)</summary>
<pre>
#include &lt;stdio.h&gt;
#define PRINTX printf("%d\n", x)

int main() {
  int x = 2, y, z;

  x *= 3 + 2; PRINTX;
  x *= y = z = 4; PRINTX;
  x = y == z; PRINTX;
  x == ( y = z ); PRINTX;
}
</pre>
  </details>

  <h4>3 Логические операции и операции увеличения</h4>

  <details>
    <summary>Программа 89 (195)</summary>
<pre>
#include &lt;stdio.h&gt;
#define PRINT(int) printf("%d\n", int)

int main() {
  int x = 2, y = 1, z = 0;

  x = x && y || z; PRINT(x) ;
  PRINT( x || ! y && z);
  x = y = 1;
  z = x ++ - 1; PRINT(x); PRINT(z);
  z += - x ++ + ++ y; PRINT(x); PRINT(z);
  z = x / ++ x; PRINT(z);
}
</pre>
  </details>

  <h4>4 Поразрядные операции</h4>

  <details>
    <summary>Программа 90 (196)</summary>
<pre>
#include &lt;stdio.h&gt;
#define PRINT(int) printf("int = %d\n", int)

int main() {
  int x = 03, y = 02, z = 01;

  PRINT( x | y & z);
  PRINT( x | y & - z);
  PRINT( x ^ y & - z);
  PRINT( x & y && z);

  x = 1; y = -1;
  PRINT( ! x | x);
  PRINT( - x | x);
  PRINT( x ^ x);
  x &lt;&lt;= 3; PRINT(x);
  y &lt;&lt;= 3; PRINT(y);
  y >>= 3; PRINT(y);
}
</pre>
  </details>

  <h4>5 Отношения и условия</h4>

  <details>
    <summary>Программа 91 (197)</summary>
<pre>
#include &lt;stdio.h&gt;
#define PRINT(int) printf("int = %d\n", int)

int main() {
  int x = 1, y = 1, z = 1;

  x += y += z;
  PRINT( x &lt; y ? y : x);
  PRINT( x &lt; y ? x++ : y++);
  PRINT(x); PRINT(y);
  PRINT(z += x &lt; y ? x++ : y++);
  PRINT(x); PRINT(y);

  x = 3; y = z = 4;
  PRINT( (z >= y >= x) ? 1 : 0);
  PRINT( z >= y && y >= x );
}
</pre>
  </details>

  <h4>6 Выполнение операций и их приоритеты</h4>

  <details>
    <summary>Программа 92 (198)</summary>
<pre>
#include &lt;stdio.h&gt;
#define PRINT3(x, y, z) printf("x = %d\t y = %d\t z = %d\n", x, y, z)

int main() {
  int x, y, z;

  x = y = z = 1;
  ++x || ++y && ++z; PRINT3(x, y, z);

  x = y = z = 1;
  ++x && ++y || ++z; PRINT3(x, y, z);

  x = y = z = 1;
  ++x && ++y && ++z; PRINT3(x, y, z);

  x = y = z = - 1;
  ++x && ++y || ++z; PRINT3(x, y, z);

  x = y = z = - 1;
  ++x || ++y && ++z; PRINT3(x, y, z);

  x = y = z = - 1;
  ++x && ++y && ++z; PRINT3(x, y, z);
}
</pre>
  </details>

  <h3>Глава 2. Основные типы (198)</h3>

  <h4>1 Символ, строка и целый тип</h4>

  <details>
    <summary>Программа 93 (199)</summary>
<pre>
#include &lt;stdio.h&gt;
#define PRINT3(format.x) printf("x = %format\n", x)

int integer = 5;
char character = '5';
char *string = "5";

int main() {
  PRINT(d,string);
  PRINT(d,character);
  PRINT(d,integer);
  PRINT(s,string);
  PRINT(c,character);
  PRINT(c,integer = 53);
  PRINT(d,( '5' > 5 ));
  {
    int sx = -8;
    unsigned ux = -8;
    PRINT(o,sx);
    PRINT(o.ux);
    PRINT(o,sx>>3);
    PRINT(o,ux>>3);
    PRINT(d,sx>>3);
    PRINT(d,ux>>3);
  }
}
</pre>
  </details>

  <h4>2 Приведение целых чисел и чисел с плавающей точкой</h4>

  <details>
    <summary>Программа 94 (200)</summary>
<pre>
#include &lt;stdio.h&gt;
#define PR(x) printf("x = %.8g\t", (double)x)
#define NL putchar('\n')
#define PRINT4(x1, x2, x3, x4) PR(x1); PR(x2); PR(x3); PR(x4); NL

int main() {
  double d;
  float f;
  long l;
  int i;

  i = l = f = d = 100 / 3; PRINT4(i, l, f, d);
  d = f = l = i = 100 / 3; PRINT4(i, l, f, d);
  i = l = f = d = 100 / 3.; PRINT4(i, l, f, d);
  d = f = l = i = (double)100 / 3; PRINT4(i, l, f, d);
  i = l = f = d = (double)100000 / 3; PRINT4(i, l, f, d);
  d = f = l = i = 100000 / 3; PRINT4(i, l, f, d);
}
</pre>
  </details>

  <h4>3 Еще о приведении типов</h4>

  <details>
    <summary>Программа 95 (201)</summary>
<pre>
#include &lt;stdio.h&gt;
#define PR(x) printf("x = %.8g\t", (double)x)
#define NL putchar('\n')
#define PRINT1(x1) PR(x1); NL
#define PRINT2(x1, x2) PR(x1); PR(x2); NL

int main() {
  double d = 3.2, x;
  int i = 2, y;

  x = (y = d / i) * 2; PRINT2(x, y);
  y = (x = d / i) * 2; PRINT2(x, y);
  y = d * (x = 2.5 / d); PRINT1(y);
  x = d * (y = ((int)2.9 + 1.1) / d); PRINT2(x, y);
}
</pre>
  </details>

  <h3>Глава 3. Включение файлов (201)</h3>

  <p>Следующие программы будут начинаться с оператора препроцессора</p>
  <code>#include "defs.h"</code>

  <p>Создадим заголовочный файл "defs.h"</p>

  <details>
    <summary>Программа 96 (201)</summary>
<pre>
#include &lt;stdio.h&gt;

#define PR(format, value) printf("value = %format\t", (value))
#define NL putchar('\n')

#define PRINT1(f, x1) PR(f, x1); NL
#define PRINT2(f, x1, x2) PR(f, x1); PRINT1(f, x2)
#define PRINT3(f, x1, x2, x3) PR(f, x1); PRINT2(f, x2, x3)
#define PRINT4(f, x1, x2, x3, x4) PR(f, x1); PRINT3(f, x2, x3, x4)
</pre>
  </details>

  <h3>Глава 4. Управление (202)</h3>

  <h4>1 Условный оператор</h4>

  <details>
    <summary>Программа 97 (202)</summary>
<pre>
#include "defs.h"

int main() {
  int x, y = 1, z;

  if (y != 0) x = 5;
  PRINT1(d, x);

  if (y == 0) x = 3;
  else x = 5;
  PRINT1(d, x);

  x = 1;
  if (y &lt; 0) if (y > 0) x = 3;
  else x = 5;
  PRINT1(d, x);

  if (z = y &lt; 0) x = 3;
  else if (y == 0) x = 5;
  else x = 7;
  PRINT2(d, x, z);

  if (z = (y == 0)) x = 5; x = 3;
  PRINT2(d, x, z);

  if (x = z = y); x = 3;
  PRINT2(d, x, z);
}
</pre>
  </details>

  <h4>2 Операторы while и for</h4>

  <details>
    <summary>Программа 98 (203)</summary>
<pre>
#include "defs.h"

int main() {
  int x, y, z;

  x = y = 0;
  while (y &lt; 10) ++y; x += y;
  PRINT2(d, x, y);

  x = y = 0;
  while (y &lt; 10) x += ++y;
  PRINT2(d, x, y);

  y = 1;
  while (y &lt; 10) {
    x = y++; z = ++y;
  }
  PRINT3(d, x, y, z);

  for (y = 1; y &lt; 10; y++) x = y;
  PRINT2(d, x, y);

  for (y = 1; (x = y) &lt; 10; y++) ;
  PRINT2(d, x, y);

  for (x = 1, y = 1000; y > 1; x++, y /= 10) {
  PRINT2(d, x, y);
  }
}
</pre>
  </details>

  <h4>3 Вложенность операторов</h4>

  <details>
    <summary>Программа 99 (204)</summary>
<pre>
#include "defs.h"

#define ENUF 3
#define EOS '\0'
#define NEXT(i) input[i++]
#define FALSE 0
#define TRUE 1

char input[] = "PI=3.14159, approximately";

int main() {
  char c;
  int done, high, i, in, low;

  i = low = in = high = 0;
  while (c = NEXT(i) != EOS)
    if (c &lt; '0') low++;
    else if (c > '9') high++;
    else in++;
  PRINT3(d, low, in, high);

  i = low = in = high = 0; done = FALSE;
  while ( (c = NEXT(i)) != EOS && !done)
    if (c &lt; '0') low++;
    else if (c > '9') high++;
    else in++;
    if (low >= ENUF || high >= ENUF || in >= ENUF)
      done = TRUE;
  PRINT3(d, low, in, high);

  i = low = in = high = 0; done = FALSE;
  while ( (c = NEXT(i)) != EOS && !done)
    if (c &lt; '0') done = (++low == ENUF);
    else if (c > '9') done = (++high == ENUF);
    else done = (++in == ENUF);
  PRINT3(d, low, in, high);
}
</pre>
  </details>

  <h4>4 Переключатели и операторы разрыва и продолжения</h4>

  <details>
    <summary>Программа 100 (205)</summary>
<pre>
#include "defs.h"

char input[] = "SSSWILTECH1\1\11W\1WALLMP1";

int main() {
  int i, c;

  for (i = 2; (c = input[i]) != '\0'; i++) {
    switch(c) {
      case 'a': putchar('i'); continue;
      case '1': break;
      case 1: while ( (c = input[++i]) != '-1' && c != '\0') ;
      case 9: putchar('S');
      case 'E': case 'L': continue;
      default: putchar(c); continue;
    }
    putchar(' ');
  }
  putchar('\n');
}
</pre>
  </details>

  <h3>Глава 5. Стили программирования (206)</h3>

  <p>Рекомендация по стилю программирования:</p>
  <ol>
    <li>Четко сформулируйте основную идею программы</li>
    <li>Составьте программу, соответствующую по структуре этой идее</li>
  </ol>

  <h4>1 Составьте правильно условие</h4>

  <h4>2 Выберите подходящую конструкцию</h4>

  <h3>Глава 6. Классы памяти (208)</h3>

  <p>С каждой переменной связан тип и класс памяти. Класс памяти определяет область действия и время существования переменной. Область действия переменной и время ее существования ограничены блоками, функциями и файлами.</p>

  <h4>1 Блоки</h4>

  <details>
    <summary>Программа 101 (208)</summary>
<pre>
#include "defs.h"

int i = 0;

int main() {
  auto int i = 1;
  PRINT1(d, i);
  {
    int i = 2;
    PRINT1(d, i);
    {
      i += 1;
      PRINT1(d, i);
    }
    PRINT1(d, i);
  }
  PRINT1(d, i);
}
</pre>
  </details>

  <h4>2 Функции</h4>

  <details>
    <summary>Программа 102 (209)</summary>
<pre>
#include "defs.h"

#define LOW 0
#define HIGH 5
#define CHANGE 2

int i = LOW;

int main() {
  auto int i = HIGH;
  reset(i/2); PRINT1(d, i);
  reset(i=i/2); PRINT1(d, i);
  i = reset(i/2); PRINT1(d, i);

  workover(i); PRINT1(d, i);
}

int workover(int i) {
  i = (i%i) * ((i*i)/(2*i) + 4);
  PRINT1(d. i);
  return i;
}

int reset(int i) {
  i = i &lt; CHANGE & HIGH : LOW;
  return i;
}
</pre>
  </details>

  <h4>3 Снова функции</h4>

  <details>
    <summary>Программа 103 (210)</summary>
<pre>
#include "defs.h"

int i = 1;

int main() {
  auto int i, j;
  i = reset();
  for (j=1; j&lt;=3; j++) {
    PRINT2(d, i, j);
    PRINT1(d, next(i));
    PRINT1(d, last(i));
    PRINT1(d, new(i+j));
  }
}

int reset() {
  return i;
}

int next(int j) {
  return j = i++;
}

int last(int j) {
  static int i = 10;
  return j = i--;
}

int new(int i) {
  auto int j = 10;
  return i =  j+= i;
}
</pre>
  </details>

  <h4>4 Файлы</h4>

  <details>
    <summary>Программа 104 (211)</summary>
    <p>Это программа в двух файлах.</p>
    <p>Файл 103.c</p>
<pre>
#include "defs.h"

int i = 1;

int main() {
  auto int i, j;
  i = reset();
  for (j=1; j&lt;=3; j++) {
    PRINT2(d, i, j);
    PRINT1(d, next(i));
    PRINT1(d, last(i));
    PRINT1(d, new(i));
  }
}

static int i = 10;

int next(int j) {
  return j += 1;
}

int last(int j) {
  return i -= 1;
}

int new(int i) {
  static int j = 5;
  return i =  j+= i;
}
</pre>

    <p>Файл 103a.c</p>
<pre>
extern int i;

int reset() {
  return i;
}
</pre>
  </details>

  <h3>Глава 7. Ссылки и массивы (212)</h3>

  <p>Любую программу, использующую индексацию массива, можно переписать с помощью ссылок.</p>

  <h4>1 Простые ссылки и массивы</h4>

  <details>
    <summary>Программа 105 (212)</summary>
<pre>
#include "defs.h"

int a[] = {0, 1, 2, 3, 4};

int main() {
  int i, *p;

  for (i = 0; i &lt;= 4; i++) {
    PR(d, a[i]);
  }
  NL;

  for (p = &a[0]; p &lt;= &a[4]; p++) {
    PR(d, *p);
  }
  NL;

  for (p = &a[0], i = 1; i &lt;= 5; i++) {
    PR(d, p[i]);
  }
  NL;

  for (p = a + 4; p >= a; p--) {
    PR(d, *p);
  }
  NL;

  for (p = a + 4, i = 0; i &lt;= 4; i++) {
    PR(d, p[-i]);
  }
  NL;

  for (p = a + 4; p >= a; p--) {
    PR(d, p[p-a]);
  }
  NL;
}
</pre>
  </details>

  <h4>2 Массив ссылок</h4>

  <details>
    <summary>Программа 106 (213)</summary>
<pre>
#include "defs.h"

int a[] = {0, 1, 2, 3, 4};
int *p[] = {a, a+1, a+2, a+3, a+4};
int **pp = p;

int main() {
  PRINT2(d, a, *a);
  PRINT3(d, p, *p, **p);
  PRINT3(d, pp, *pp, **pp);
  NL;

  pp++; PRINT3(d, pp-p, *pp-a, **pp);
  *pp++; PRINT3(d, pp-p, *pp-a, **pp);
  *++pp; PRINT3(d, pp-p, *pp-a, **pp);
  ++*pp; PRINT3(d, pp-p, *pp-a, **pp);
  NL;

  pp = p;
  **pp++; PRINT3(d, pp-p, *pp-a, **pp);
  *++*pp; PRINT3(d, pp-p, *pp-a, **pp);
  ++**pp; PRINT3(d, pp-p, *pp-a, **pp);
}
</pre>
  </details>

  <h4>3 Многомерные массивы</h4>

  <details>
    <summary>Программа 107 (214)</summary>
<pre>
#include "defs.h"

int a[3][3] = {
  {1,2,3},
  {4,5,6},
  {7,8,9}
};
int *pa[3] = {a[0],a[1],a[2]};
int *p = a[0];

int main() {
  int i;

  for (i = 0; i &lt; 3; i++) {
    PRINT3(d, a[i][2-i], *a[i], *(*(a+i)+i));
  }
  NL;

  for (i = 0; i &lt; 3; i++) {
    PRINT2(d, *pa[i], p[i]);
  }
}
</pre>
  </details>

  <h4>4 Хитросплетение ссылок</h4>

  <details>
    <summary>Программа 108 (215)</summary>
<pre>
#include "defs.h"

char *c[] = {
  "ENTER",
  "NEW",
  "POINT",
  "FIRST"
};
char **cp[] = {c+3, c+2, c+1, c};
char ***cpp = cp;

int main() {
  printf("%s", **++cpp);
  printf("%s", *--*++cpp+3);
  printf("%s", *cpp[-2]+3);
  printf("%s", cpp[-1][-1]+1);
}
</pre>
  </details>

  <h3>Глава 8. Записи (216)</h3>

  <h4>1 Простые записи. Вложенные записи</h4>

  <details>
    <summary>Программа 109 (216)</summary>
<pre>
#include "defs.h"

int main() {
  static struct S1 {
    char c[4], *s;
  } s1 = {"abc", "def"};

  static struct S2 {
    char cp;
    struct S1 ss1;
  } s2 = {"ghi", {"jkl", "mno"}};

  PRINT2(c, s1.c[0], *s1.s);
  PRINT2(s, s1.c, s1.s);
  PRINT2(s, s2.cp, s2.ss1.s);
  PRINT2(s, ++s2.cp, ++s2.ss1.s);
}
</pre>
  </details>

  <h4>2 Массив записей</h4>

  <details>
    <summary>Программа 110 (216)</summary>
<pre>
#include "defs.h"

struct S1 {
  char *s;
  int i;
  struct S1 *s1p;
};

int main() {
  static struct S1 a[] {
    {"abcd", 1, a + 1},
    {"efgh", 2, a + 2},
    {"ijkl", 3, a}
  };
  struct S1 *p = a;
  int i;

  PRINT3(s, a[0].s, p->s, a[2].s1p->s);

  for (i = 0; i &lt; 2; i++) {
    PR(d, --a[i].i);
    PR(c, ++a[i].s[3]);
    NL;
  }

  PRINT3(s, ++(p->s), a[(++p)->i].s, a[--(p->s1p->i)].s);
}
</pre>
  </details>

  <h4>3 Массив ссылок на записи</h4>

  <details>
    <summary>Программа 111 (217)</summary>
<pre>
#include "defs.h"

struct S1 {
  char *s;
  struct S1 *s1p;
};

void swap(struct S1 *p1, struct S1 *p2) {
  char *temp;
  temp = p1->s;
  p1->s = p2->s;
  p2->s = temp;
}

int main() {
  static struct S1 a[] {
    {"abcd", a + 1},
    {"efgh", a + 2},
    {"ijkl", a}
  };
  struct S1 *p[3];
  int i;

  for (i = 0; i &lt; 3; i++) {
    p[i] = a[i].s1p;
  }
  PRINT3(s, p[0]->s, (*p)->s, (**p).s);

  swap(*p, a);
  PRINT3(s, p[0]->s, (*p)->s, (**p).s);

  swap(p[0], p[0]->s1p);
  PRINT3(s, p[0]->s, (*++p[0]).s, ++(*++(*p)->s1p).s);
}
</pre>
  </details>

  <h3>Глава 9. Препроцессор (218)</h3>

  <p>Препроцессор не относится к языку Си. Однако почти все программыы написаны с помощью препроцессора. Две наиболее важные функции препроцессора - это макроподстановка @define и включение файлов #include</p>

  <h4>1 Препроцессор не знает Си</h4>

  <details>
    <summary>Программа 112 (219)</summary>
<pre>
#include &lt;stdio.h&gt;
#define FUDGE(k) k + 3.14159
#define PR(a) printf("a = %d\t", (int)(a))
#define PRINT(a) PR(a); putchar('\n')
#define PRINT2(a, b) PR(a); PRINT(b)
#define PRINT3(a,b,c) PR(a); PRINT2(b, c)
#define MAX(a, b) (a &lt; b ? b : a)

int main() {
  {
    int x = 2;
    PRINT(x * FUDGE(2));
  }
  {
    int cel;
    for (cel = 0; cel &lt;= 100; cel += 50) {
      PRINT2(cel, 9./5*cel+32);
    }
  }
  {
    int x = 1, y = 2;
    PRINT3(MAX(x++, y), x, y);
    PRINT3(MAX(x++, y), x, y);
  }
}
</pre>
  </details>

  <h4>2 Осторожность вознаграждается</h4>

  <details>
    <summary>Программа 113 (219)</summary>
<pre>
#include &lt;stdio.h&gt;
#define NEG(a) -a
#define weeks(mins) (days(mins)/7)
#define days(mins) (hours(mins)/24)
#define hours(mins) (mins/60)
#define mins(secs) (secs/60)
#define TAB(c,i,oi,t) if(c=='\t')\
  for(t=8-(i-oi-1)%8,oi=i;t;t--)\
  putchar(' ')
#define PR(a) printf("a = %d\t", (int)(a))
#define PRINT(a) PR(a); putchar('\n')

int main() {
  {
    int x = 1;
    PRINT(-NEG(x));
  }
  {
    PRINT(weeks(10080));
    PRINT(days(mins(86400)));
  }
  {
    static char input[] = "\twhich\tif?";
    char c;
    int i, oldi, temp;

    for (oldi = -1, i = 0; (c=input[i]) != '\0'; i++) {
      if (c &lt; ' ') TAB(c,i,oldi,temp);
      else putchar(c);
      putchar('\n');
    }
  }
}
</pre>
  </details>
</article>

