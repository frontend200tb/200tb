<article class="article">
  <h1>2020 Дейтел - Как программировать на C (7е). 1000c</h1>
  <p>Конспект книги</p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
        <a href="#p1">1 Введение в компьютеры, Internet и World Wide Web (21)</a>
    <br><a href="#p2">2 Введение в программирование на C (43)</a>
    <br><a href="#p3">3 Структурная разработка программ на C (71)</a>
    <br><a href="#p4">4 Управление программой в C (113)</a>
    <br><a href="#p5">5 Функции в C (153)</a>
    <br><a href="#p6">6 Массивы в C (207)</a>
    <br><a href="#p7">7 Указатели в C (263)</a>
    <br><a href="#p8">8 Символы и строки в C (320)</a>
    <br><a href="#p9">9 Форматированный ввод/вывод в C (364)</a>
    <br><a href="#p10">10 Структуры, объединения, перечисления и операции с битами в C (392)</a>
    <br><a href="#p11">11 Работа с файлами в C (426)</a>
    <br><a href="#p12">12 Структуры данных в C (461)</a>
    <br><a href="#p13">13 Препроцессор C (513)</a>
    <br><a href="#p14">14 Специальные вопросы языка C (524)</a>
    <br><a href="#p15">15 C++ как улучшенный C (545)</a>
    <br><a href="#p16">16 Введение в классы и объекты (576)</a>
    <br><a href="#p17">17 Классы: часть 1 (618)</a>
    <br><a href="#p18">18 Классы: часть 2 (654)</a>
    <br><a href="#p19">19 Перегрузка операций. Объекты Array и String (690)</a>
    <br><a href="#p20">20 ООП. Наследование (758)</a>
    <br><a href="#p21">21 ООП. Полиморфизм (810)</a>
    <br><a href="#p22">22 Шаблоны (866)</a>
    <br><a href="#p23">23 Потоковый ввод/вывод (885)</a>
    <br><a href="#p24">24 Управление исключениями (925)</a>
  </p>
</article>


<!-- 1 Введение в компьютеры, Internet и World Wide Web -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>1 Введение в компьютеры, Internet и World Wide Web (21)</h3>

  <h4>1.1 Введение (22)</h4>
  <h4>1.2 Что такое компьютер (23)</h4>
  <h4>1.3 Внутренняя организация компьютера (24)</h4>
  <h4>1.4 Персональные вычисления, распределенные вычисления и вычисления в модели клиент/сервер (25)</h4>
  <h4>1.5 Интернет и всемирная паутина (25)</h4>

  <h4>1.6 Машинные языки, языки ассемблера и языки высокого уровня (26)</h4>

  <p>Все языки разбиты на три категории</p>
  <ol>
    <li>Машинные языки</li>
    <li>Ассемблерные языки</li>
    <li>Языки высокого уровня</li>
  </ol>
  <p>Каждый компьютер может понимать только свой машинный язык, связанный с его архитектурой и аппаратурой. Машинные языки состоят из последовательностей единиц и нулей, которые являются командами на выполнение элементарных операций. Программы на машинных языках не переносимы на компьютеры с разной архитектурой и неудобны для восприятия человеком.</p>
  <p>Программирование на машинных языках тормозило развитие компьютерной техники, очень медленное и непосильное занятие для большинства программистов.</p>
  <p>Вместо последовательности чисел стали применяться англоязычные аббревиатуры, которые стали применяться  в языке ассемблера.</p>
  <p>Программисты стали писать на языке ассемблера, а специальные программы-трансляторы преобразовывали программы на машинный язык.</p>
  <p>С появлением языков ассемблера использование компьютеров значительно расширилось, однако все еще писалось большое количество кода для решения простейших задач. Для ускорения программирования были разработаны языки высокого уровня, в которых выполнение сложных действий заменялось одним оператором. Программисты стали писать на языках высокого уровня, а программы-компиляторы переводили написанное на машинный язык.</p>
  <p>Языки высокого уровня предпочтительнее чем ассемблерные и машинные языки.</p>

  <h4>1.7 История языка Си (27)</h4>

  <p>Язык Си берет свое начало от двух языков BCPL и B. В 1967 году Мартин Ричардс разработал BCPL как язык для написания системного ПО и компиляторов. В 1970 году Кен Томпсон использовал B для создания ранних версий ОС UNIX на компьютере DEC PDP-7. В языках BCPL и B переменные не разделялись на типы. Каждое значение данных занимало одно слово в памяти. Ответственность за различие целых и действительных чисел целиком ложилась на плечи программиста.</p>
  <p>Язык Си был разработан Денисом Ричи и реализован в 1972 году на компьютере DEC PDP-11.</p>

  <h4>1.8 Стандартная библиотека Си (28)</h4>

  <p>Есть два аспекта изучения языка. Первый - изучение непосредственно Си. Второй - умение пользоваться стандартной библиотекой. Не следует изобретать велосипед. Повторное использование кода это ключевой момент. При написании программы на языке Си вы будете использовать</p>
  <ol>
    <li>функции стандартной библиотеки Си</li>
    <li>функции, которые вы создадите сами</li>
    <li>Функции, написанные другими программистами</li>
  </ol>
  <p>Преимущества создания своих собственных функций - вы отлично значете и понимаете как они работают. Недостаток - затраты времени на создание новых функций.</p>

  <h4>1.9 C++</h4>

  <p>Язык C++ является надмножеством языка Си. Язык C++ разработал Бьерн Страуструп. В языке реализованы средства для ООП. В программном мире происходит революция. Быстрое, надежное, экономичное создание программ остается труднодостижимой целью. Применение ООП позволяет повысить производительность программистов.</p>

  <p>Сегодня наилучшей стратегией обучения будет освоение языка Си, а затем изучение C++.</p>

  <h4>1.10 Java</h4>

  <p>Родственным C и C++ является язык Java. Корпорация Sun Microsystems в 1991 году на основе C/C++ стали разрабатывать новый язык, которому его создатель Джеймс Гослинг дал имя Oak в честь дуба, который рос за окном его кабинета в Sun. Однако, оказалось, что уже есть компьютерный язык под названием Oak, тогда в местной кофейне предложили назвать язык Java и это название прижилось. Sun формально объявила о языке Java на торговой выставке в мае 1995 года.</p>

  <h4>1.11 Fortran, Cobol, Pascal и Ada (30)</h4>

  <p>В 1950-х годах корпорация IBM разработала Fortran (FORmula TRANslation) в качестве языка для научных и технических приложений, в которых требуются сложные математические вычисления.</p>
  <p>Ы 1959 году разработали язык Cobol (COmmon Business OrientedLanguage) для коммерческих прикладных программ в которых требовалась высокая точность при обработке большого количества данных.</p>
  <p>В 1960-е годы большие программные проекты сталкивались с трудностями. Сроки разработки затягивались, расходы значительно превышали бюджет, а продукты получались ненадежны. Это привело к структурному прошграммированию - упорядоченному подходу к написанию более ясных программ, которые легче тестировать, отлаживать и модифицировать чем неструктурнированные.</p>
  <p>В резуьтате, в 1971 году профессором Никласом Виртом был разработан язык Pascal, который предназначался как язык для обучения структурному программированию. В нем отсутствуют многие элементы для коммерческих, промышленных и административных приложений, поэтому он не получил широкого распространения.</p>
  <p>В начале 1980-х под эгидой министерства обороны США был создан язык Ada. Для создания огромной массы программных систем управлени и контроля МО использовались сотни различных языков. Хотелось иметь единственный язык, который удовлетворял бы всем нуждам. Важная особенность языка Ada - многозадачность, позволяющая выполнять действия параллельно. Многие языки, в том числе C/C++ однозадачны.</p>

  <h4>1.12 Basic, Visual Basic, Visual C++, C# и .NET (30)</h4>

  <p>В середине 1960-х годов был написан язык Basic (Beginner's All-Purpose Symbolic Instruction Code) для написания простых программ. Основной целью было ознакомить новичков с программированием.</p>
  <p>В 1991 году корпорация Microsoft представила язык Visual Basic для упрощения разработки приложений Microsoft Windows.</p>
  <p>Visual Basic .NET, Visual C++ .NET и C# были разработаны для новой программной платформы .NET от Microsoft.</p>

  <h4>1.13 Ключевая тенденция в программировании: объектная технология (31)</h4>

  <p>Язык C++ унаследовал все возможности языка Си, дополнив их средствами манипулирования объектами, заимствованными у Simula. Ни Си, ни C++ не предназначались для широкого использования вне стен лабораторий AT&T. Но очень быстро оба стали доступны для рядовых программистов.</p>
  <p>Мы живем в мире объектов. Машины, самолеты, люди, животные, здания... Программные языки (Fortran, Pascal, Basic, C) концентрировали внимание на действиях (глаголах), а не вещах или объектах (существительных). Объектные языки (C++, Java) позволяют программистам живущим в мире объектов писать программы с помощью объектов, что делает труд гораздо производительнее. Это порождает более понятные, лучше организованные программы, которые проще сопровождать, модифицировать и отлаживать. Это важно, так как 80% стоимости программного продукта связано с его сопровождением на протяжении долгих лет.</p>

  <h4>1.4 Схема типичной среды разработки Си (32)</h4>

  <p>Система среды разработки на языке Си состоит из трех частей</p>
  <ol>
    <li>Среда программирования</li>
    <li>Язык Си</li>
    <li>Стандартная библиотека</li>
  </ol>
  <p>Создание программы проходит через 6 стадий</p>
  <ol>
    <li>Написание кода в редакторе кода и сохранение его в файле с расширением .c</li>
    <li>Препроцессорная обработка. Когда вводится команда на компиляцию программы, первой выполняется программа препроцессора. Она выполняет все директив препроцессора, написанные в программе.Например, добавление файлов к коду программы, замена символов в тексте программы</li>
    <li>Компиляция. Компилятор преобразует программу в машинный язык и в результате сохраняет объектный код в файле с расширением .o</li>
    <li>Компоновка. В программах на языке Си содержатся обращения к функциям, определенным в стандартной библиотеке. Поэтому объектный код после работы компилятора содержит "дыры", обусловленные отсутствием определенных функций, к которым происходит обращение. Компоновщик связывает объектный код с определениями отсутствующих функций и результат сохраняет в файл с расширением .exe в котором уже нет отсутствующих частей.</li>
    <li>Загрузка. Перед выполнением программа должна быть размещена в памяти. Загрузчик помещает в память исполняемый код, также могут загружаться библиотеки не входящие в исполняемый код.</li>
    <li>Исполнение. Компьютер выполняет программу, последовательно прочитывая инструкции одна за другой</li>
  </ol>

  <p>Программы получают и выводят данные. Конкретные функции получают входные данные от stdin стандартный входной поток. Обычно это клавиатура, но stdin может быть подключен и к другому устройству. Вывод данных осуществляется на stdout стандартный выходной поток. Обычно это экран, но stdout также может быть подключен к другому устройству. Имеется еще один поток stderr стандартный поток ошибок.</p>

  <h4>1.15 Тенденции в области аппаратных средств (35)</h4>

  <p>Сообщество программистов процветает на волне непрерывного прогресса в технологиях оборудования, программного обеспечения и коммуникации. Каждый год возможности компьютеров, объемы памяти, быстродействие процессоров увеличиваются.</p>

  <h4>1.16 Общие замечания о Си и этой книге (36)</h4>

  <p>Хороший стиль программирования. Пишите программы в простой, четкой манере придерживаясь принципа KISS Keep It Simple.</p>
  <p>Совет по переносимости. Существует много проблем совместимости между разными версиями Си и разными компьютерами, что затрудняет достижение переносимости. Само по себе написание программ на Си не обеспечивает их переносимости.</p>
</article>


<!-- 2 Введение в программирование на C -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>2 Введение в программирование на C (43)</h3>

  <h4>2.1 Введение (44)</h4>

  <p>Далее будет рассматриваться структурное программирование на языке Си.</p>

  <h4>2.2 Простая программа на Си. Печать строки текста (44)</h4>

  <details>
    <summary>Программа 1 (44)</summary>
    <p>Печать строки текста.</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  printf("Welcome to C!\n");

  return 0;
}
</pre>
    <code>Welcome to C!</code>
  </details>

  <details>
    <summary>Программа 2 (47)</summary>
    <p>Печать в одну строку несколькими операторами printf.</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  printf("Welcome ");
  printf("to C!\n");

  return 0;
}
</pre>
    <code>Welcome to C!</code>
  </details>

  <details>
    <summary>Программа 3 (47)</summary>
    <p>Печать несколько строк одним оператором printf.</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  printf("Welcome\nto\nC!\n");

  return 0;
}
</pre>
<pre>
Welcome
to
C!
</pre>
  </details>

  <h4>2.3 Еще одна простая программа на Си. Сложение двух целых чисел (48)</h4>

  <details>
    <summary>Программа 4 (48)</summary>
    <p>Считать два числа оператором scanf, сложить их и вывести результат.</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int a;
  int b;
  int sum;

  printf("Enter first integer\n");
  scanf("%d", &a);

  printf("Enter second integer\n");
  scanf("%d", &b);

  sum = a + b;

  printf("Sum is %d\n", sum);

  return 0;
}
</pre>
<pre>
Enter first integer
5
Enter second integer
3
Sum is 8
</pre>
  </details>

  <h4>2.4 Общие понятия о памяти компьютера (53)</h4>

  <p>Имена переменных в действительности соответствуют ячейкам памяти. Когда присваивается значение переменной, то это значение сохранается в соответствующей ячейке памяти. При этом старое значение в этой ячейке памяти уничтожается.</p>

  <h4>2.5 Арифметика в Си (54)</h4>

  <h4>2.6 Принятие решений. Операции равенства и отношения (58)</h4>

  <details>
    <summary>Программа 5 (59)</summary>
    <p>Программа вызывает scanf чтобы считать два числа. Шесть операторов if сравнивают два введенных числа.</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int num1;
  int num2;

  printf("Enter two integers by space \n");
  scanf("%d %d", &num1, &num2);

  if (num1 == num2) {
    printf("%d is equal to %d\n", num1, num2);
  }

  if (num1 != num2) {
    printf("%d is not equal to %d\n", num1, num2);
  }

  if (num1 &lt; num2) {
    printf("%d is less than %d\n", num1, num2);
  }

  if (num1 > num2) {
    printf("%d is greater than %d\n", num1, num2);
  }

  if (num1 &lt;= num2) {
    printf("%d is less than or equal to %d\n", num1, num2);
  }

  if (num1 >= num2) {
    printf("%d is greater than or equal to %d\n", num1, num2);
  }

  return 0;
}
</pre>
  </details>
</article>


<!-- 3 Структурная разработка программ на C -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>3 Структурная разработка программ на C (71)</h3>

  <h4>3.1 Введение (72)</h4>

  <h4>3.2 Алгоритмы (72)</h4>

  <h4>3.3 Псевдокод (73)</h4>

  <p>Программы на псевдокоде не выполняются на компьютерах. Они помогают программисту продумывать программу перед написанием ее на языке программирования.</p>

  <h4>3.4 Управляющие структуры (74)</h4>

  <p>В 60-е годы последовательное выполнение программ, при котором оператор GOTO передавал управление по одному из возможных путей, сильно затрудняло программирование. В 70-е годы структурное программирование, также известное как программирование без GOTO, стало эпохальным девизом профессиональных программистов. Уменьшилось время разработки, программы стали более понятные, их проще отлаживать, модифицировать и в них меньше ошибок.</p>
  <p>Всего в языке Си семь типов управляющих структур. Три типа структуры выбора if, if else, switch. Три типа структур повторение for, while, do while. И, наконец, последовательное выполнение команд.</p>

  <h4>3.5 Оператор выбора if (76)</h4>

  <h4>3.6 Оператор выбора if else (77)</h4>

  <h4>3.7 Оператор повторения while (81)</h4>

  <h4>3.8 Формулирование алгоритмов: пример 1 (повторение, управляемое счетчиком) (82)</h4>

  <details>
    <summary>Программа 6 (83)</summary>
    <p>Программа подсчета средней оценки за экзамен десяти студентов.</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int counter = 1;
  int total = 0;
  int grade;
  int average;

  while (counter &lt;= 10) {
    printf("%s", "Enter grade ");
    scanf("%d", &grade);
    total += grade;
    counter++;
  }

  average = total / 10;
  printf("Average = %d", average);

  return 0;
}
</pre>
  </details>

  <h4>3.9 Формулирование алгоритмов методом нисходящего последовательного уточнения: пример 2 (повторение, управляемое контрольным значением) (84)</h4>

  <details>
    <summary>Программа 7 (88)</summary>
    <p>Программа подсчета средней оценки за экзамен. Число студентов заранее неизвестно.</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int counter = 0;
  int total = 0;
  int grade;
  float average;

  printf("%s", "Enter grade, -1 to end ");
  scanf("%d", &grade);

  while (grade != -1) {
    total += grade;
    counter++;
    printf("%s", "Enter grade, -1 to end ");
    scanf("%d", &grade);
  }

  if (counter != 0) {
    average = (float)total / counter;
    printf("Average = %.2f", average);
  } else {
    puts("No grades were entered");
  }

  return 0;
}
</pre>
  </details>

  <p>При делении двух целых чисел total / counter получается целое число. Унарная операция приведения типа (float)total создает для своего операнда total временную копию с плавающей точкой. Значение, хранимое в переменной total, по-прежнему является целым числом. Компилятор Си вычисляет выражение только с одинаковым типом операндов, поэтому встретив операнд типа float, он автоматически делает временную копию второго операнда и выполняет неявное преобразове в тип float. Вычисленный результат деления двух переменных типа float будет типа float и запишется в переменную average типа float.</p>

  <h4>3.10 Формулирование алгоритмов методом нисходящего последовательного уточнения: пример 3 (вложенные управляющие структуры) (91)</h4>

  <details>
    <summary>Программа 8 (94)</summary>
    <p>Студент после экзамена имеет результат 1, если сдал экзамен, и 0 если не сдал. Из 10 студентов подсчитать число сдавших и не сдавших экзамен. Если экзамен сдали больше 8 студентов, то премировать преподавателя.</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int passes = 0;
  int failures = 0;
  int student = 1;
  int result;

  while (student &lt;= 10) {
    printf("Enter result %d (0 or 1) ", student);
    scanf("%d", &result);

    if (result == 1) {
      passes++;
    } else {
      failures++;
    }

    student++;
  }

  printf("Passed %d\n", passes);
  printf("Failed %d\n", failures);

  if (passes > 8) {
    puts("Bonus to teacher");
  }

  return 0;
}
</pre>
  </details>

  <h4>3.11 Операции присваивания (95)</h4>

  <p>+=, -=, *=, /=, %=</p>

  <h4>3.12 Операции инкремента и декремента (96)</h4>

  <details>
    <summary>Программа 9 (97)</summary>
    <p>Студент после экзамена имеет результат 1, если сдал экзамен, и 0 если не сдал. Из 10 студентов подсчитать число сдавших и не сдавших экзамен. Если экзамен сдали больше 8 студентов, то премировать преподавателя.</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int c = 5;

  printf("c = %d\n", c);
  printf("c++ = %d\n", c++);
  printf("c = %d\n", c);
  printf("++c = %d\n", ++c);
  printf("c = %d\n", c);

  return 0;
}
</pre>
  </details>
</article>


<!-- 4 Управление программой в C -->
<article class="article">
  <div class="anchor" id="p4"></div>
  <h3>4 Управление программой в C (113)</h3>

  <h4>4.1 Введение (114)</h4>

  <h4>4.2 Основы структур повторения (114)</h4>

  <h4>4.3 Повторение, управляемое счетчикм (115)</h4>

  <p>Выведем числа от 1 до 10.</p>

  <details>
    <summary>Программа 10 (115)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int counter = 1;

  while (counter &lt;=10) {
    printf("%d ", counter);
    counter++;
  }

  return 0;
}
</pre>
  </details>

  <h4>4.4 Оператор повторения for (117)</h4>

  <p>Выведем числа от 1 до 10.</p>

  <details>
    <summary>Программа 11 (117)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int counter;

  for (counter = 1; counter &lt;=10; counter++) {
    printf("%d ", counter);
  }

  return 0;
}
</pre>
  </details>

  <h4>4.5 Оператор for. Замечания и рекомендации (119)</h4>

  <p>Сначала выполняется инициализация управляющей переменной (int i = 0), затем проверка условия (i != 10), затем выполняется тела цикла. После этого изменяется управляющая переменная (i++). Управляющую переменную можно изменять и в теле цикла, но это не рекомендуется из-за трудно уловимых ошибок в коде. Управляющую переменную можно как увеличивать так и уменьшать (i--). Шаг переменной может быть любым (i += 10).</p>

  <h4>4.6 Примеры структур for (120)</h4>

  <p>Найдем сумму всех четных чисел от 2 до 100.</p>

  <details>
    <summary>Программа 12 (121)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int sum = 0;

  for (int i = 2; i &lt;=100; i += 2) {
    sum += i;
  }

  printf("sum = %d", sum);

  return 0;
}
</pre>
  </details>

  <p>Задача. Клиент открыл в банке 5%-ый счет на 1000$. Предполагая, что вся прибыль остается на депозите счета, расчитайте и выведите сумму денег на счете на конец каждого года за 10 лет по формуле</p>
  <code>a = p * (1 + r)ⁿ</code>
  <p>где p - первоначальная сумма, r - годовая процентная ставка, n - число лет, a - сумма на депозите  на конец n-го года.</p>

  <details>
    <summary>Программа 13 (122)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main() {
  double amount; // сумма на счете
  double principal = 1000.0; // начальная сумма
  double rate = .05; // процентная ставка
  int year; // счетчик лет

  // вывести заголовки колонок таблицы
  printf("%4s%21s\n", "Year", "Amount on deposit");

  // вычислить сумму на счете для каждого из 10 лет
  for (year = 1; year &lt;=10; year++) {
    amount = principal * pow(1.0 + rate, year);
    printf("%4d%21.2f\n", year, amount);
  }

  return 0;
}
</pre>
  </details>

  <h4>4.7 Оператор множественного выбора switch (124)</h4>

  <p>Подсчитаем количество различных буквенных оценок, полученных студентами на экзамене.</p>

  <details>
    <summary>Программа 14 (124)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int grade; // одна оценка
  int aCount = 0; // число оценок A
  int bCount = 0; // число оценок B
  int cCount = 0; // число оценок C
  int dCount = 0; // число оценок D
  int fCount = 0; // число оценок F

  puts("Enter the letter grades (a,b,c,d,f)");
  puts("Enter the EOF for end");

  while ((grade = getchar()) != EOF) {
    switch (grade) {
      case 'A':
      case 'a':
        ++aCount;
        break;
      case 'B':
      case 'b':
        ++bCount;
        break;
      case 'C':
      case 'c':
        ++cCount;
        break;
      case 'D':
      case 'd':
        ++dCount;
        break;
      case "F":
      case 'f':
        ++fCount;
        break;
      case '\n':
      case '\t':
      case ' ':
        break;
      default:
        printf("%s is incorrect letter grade", grade);
        puts("Enter new grade");
        break;
    }
  }

  puts("\nTotal:\n");
  printf("A %d\n", aCount);
  printf("B %d\n", bCount);
  printf("C %d\n", cCount);
  printf("D %d\n", dCount);
  printf("F %d\n", fCount);

  return 0;
}
</pre>
  </details>

  <p>Для Windows EOF можно ввести нажав CTRL+z.</p>
  <p>Оператор switch проверяет переданное ему выражение на равенство <strong>константному целочисленному значению</strong>. Это просто целые значения, символьная константа, заключенная в одиночные кавычки, также равна целому значению.</p>

  <h4>4.8 Оператор повторения do...while (129)</h4>

  <p>Оператор while проверяет условие до выполнения тела цикла. Оператор do while проверяет условие после выполнения тела цикла. После конструкции while не ставится точка с запятой. После конструкции do while ставится точка с запятой.</p>

  <details>
    <summary>Программа 15 (130)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int counter = 1;

  do {
    printf("%d ", counter;)
  } while (++counter &lt;= 10);

  return 0;
}
</pre>
  </details>

  <h4>4.9 Операторы break и continue (131)</h4>

  <p>Оператор break немедленно выходит из структур for, while, do while, switch. Оператор continue пропускает оставшиеся операторы в структурах for, while, do while и переходит к проверке условия продолжения цикла, в операторе for выполняется приращение а затем проверяется условие повторения цикла.</p>

  <p>Использование оператора break в цикле for</p>

  <details>
    <summary>Программа 16 (131)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int x;

  for (x = 1; x &lt;= 10; x++) {
    if (x == 5) {
      break;
    }
    printf("%d ", x);
  }
  printf("\nBroke out of loop at x = %d", x);

  return 0;
}
</pre>
  </details>

  <p>Использование оператора continue в цикле for</p>

  <details>
    <summary>Программа 17 (132)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int x;

  for (x = 1; x &lt;= 10; x++) {
    if (x == 5) {
      continue;
    }
    printf("%d ", x);
  }
  puts("\nUsed continue to skip value 5");

  return 0;
}
</pre>
  </details>

  <h4>4.10 Логические операции (133)</h4>

  <p>Логическое И &&, логическое ИЛИ ||, логическое отрицание !.</p>

  <h4>4.11 Смешивание операций равенства (==) и присваивания (=) (136)</h4>

  <p>Ошибка написания оператора присваивания = вместо оператора равенства == очень частая и опасная. Эта ошибка не вызывает синтаксических ошибок при компиляции потому что присваивание так же возвращает значение как и сравнение. Однако программа выдает неверные результаты при выполнении.</p>

  <h4>4.12 Резюме структурного программирования (137)</h4>
</article>


<!-- 5 Функции в C -->
<article class="article">
  <div class="anchor" id="p5"></div>
  <h3>5 Функции в C (153)</h3>

  <h4>5.1 Введение (154)</h4>

  <p>Наилучшим способом разработки и поддержки больших программ является конструирование программы из небольших частей, модулей, с каждым из которых обращаться проще, чем со всей программой целиком.</p>

  <h4>5.2 Программные модули в Си (154)</h4>

  <p>Модули в Си называются функциями. Функции поставляются в составе стандатной библиотеки, а новые функции пишутся программистами. Освойте функции из стандартной библитеки и по возможности используйте их, чтобы не создавать точно такие же новые функции.</p>

  <h4>5.3 Функции математической библиотеки (155)</h4>

  <p>Описание математических функций содержатся в заголовочном файле math.h</p>

  <h4>5.4 Функции (157)</h4>

  <p>Написание кода в виде простых функций позволяет избежать дублирования кода. Каждая функция должна выполнять одну задачу, а имя функции должно отражать смысл данной задачи.</p>

  <h4>5.5 Определения функций (157)</h4>

  <p>Напишем функцию square для вычисления квадрата целых чисел от 1 до 10.</p>

  <details>
    <summary>Программа 18 (158)</summary>
<pre>
#include &lt;stdio.h&gt;

int square(int y);

int main() {
  int x;

  for (x = 1; x &lt;= 10; x++) {
    printf("%d ", square(x));
  }
  puts("");

  return 0;
}

int square(int y) {
  return y * y;
}
</pre>
  </details>

  <p>Напишем функцию maximum для определения и возврата наибольшего из трех целых чисел.</p>

  <details>
    <summary>Программа 19 (160)</summary>
<pre>
#include &lt;stdio.h&gt;

int maximum(int x, int y, int z);

int main() {
  int num1;
  int num2;
  int num3;

  printf("s", "Enter three integers: ");
  scanf("%d%d%d", &num1, &num2, &num3);

  printf("Maximum is %d ", maximum(num1, num2, num3));

  puts("");

  return 0;
}

int maximum(int x, int y, int z) {
  int max = x;

  if (y > max) {
    max = y;
  }
  if (z > max) {
    max = z;
  }
  return max;
}
</pre>
  </details>

  <h4>5.6 Прототипы функций (162)</h4>

  <p>Прототипы функций в языке Си были позаимствованы у разработчиков C++. Прототипы сообщают компилятору тип данных, возвращаемых функцией, число, тип и порядок следования параметров, получаемых функцией. Компилятор использует прототипы для проверки корректности обращения к функции.</p>
  <p>Ранние версии Си не выполняли такие проверки, неправильные вызовы функций не обнаруживались при компиляции и приводили к труднообнаружимым ошибкам во время выполнения программы.</p>
  <p>Включайте в программу прототипы всех функций чтобы воспользоваться преимуществом проверки типов.</p>
  <p>В прототипе пишутся только типы параметров и их порядок следования. Если в прототипе написать имена параметров, то компилятор игнорирует эти имена. В конце прототипа обязательно ставить точку с запятой.</p>
  <code>int square(int);</code>
  <code>int maximum(int, int, int);</code>

  <p>Прототип функции можно разместить вне любой функции или внутри функции. Прототип, размещенный вне любой функции, применяется ко всем вызовам функции внутри файла. Прототип, размещенный внутри функции, применяется только к вызовам из этой функции.</p>

  <h4>5.7 Стек вызовов и активационные записи (164)</h4>

  <p>Каждый раз, когда функция вызывает другую функцию, в стек заталкивается блок информации. Этот блок называется кадром стека или активационной записью. Она содержит адрес возврата, чтобы вызванная функция могла возвратиться в вызывающую функцию. Когда функция выполняет возврат, кадро стека для ее вызова выталкивается и управление передается адресу возврата в вытолкнутом кадре.</p>
  <p>Все локальные переменные функции должны существовать только во время выполнения функции. Но когда функция выполнится и возвращает выполнение вызывающей функции, ее локальные переменные должны исчезнуть. Кадр стека также резервирует память для таких локальных переменных функции.</p>
  <p>Компьютер выделяет ограниченный объем памяти для стека вызовов, поэтому если вызывается слишком много функций, то стек может не вместить все их активационные записи и происходит ошибка переполнения стека.</p>

  <h4>5.8 Заголовочные файлы (165)</h4>

  <p>Каждая стандартная библиотека имеет свой заголовочный файл, содержащий прототипы всех функций и определение различных типов данных и константа данной библиотеки</p>
  <p>При написании собственных функций, их прототипы можно включать в свой заголовочный файл с расширением .h, который затем подключать в нужные файлы своей программы.</p>
  <code>#include "maximum.h"</code>

  <h4>5.9 Вызов функций. Вызов по значению и вызов по ссылке (166)</h4>

  <p>Если аргумент передается по значению, то создается копия значения аргумента, с которой работает функция. При этом оригинальное значение переданной переменной не может измениться.</p>
  <p>Если аргумент передается по ссылке, то функция получает адрес переданной переменной и в процессе работы может записать в этот адрес любое другое значение. При этом оригинальное значение переданной переменной тоже изменится.</p>

  <h4>5.10 Генерация случайных чисел (166)</h4>

  <p>Функция rand() генерирует и возвращает случайное целое значение в диапазоне от 0 до RAND_MAX. Сама функция rand() и константа RAND_MAX определены в заголовочном файле stdlib.h. Присвоим целочисленной переменной случайное число</p>
  <code>int i = rand();</code>
  <p>Если нужно случайное число в диапазоне от 1 до 6, то можно применить операцию взятия по модулю и прибавить 1</p>
  <code>rand() % 6 + 1</code>

  <p>Напишем программу, которая 20 раз подбросит кубик с 6 гранями и выведет результат выпавшей грани на экран.</p>

  <details>
    <summary>Программа 20 (167)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
  for (int i = 1; i &lt;= 20; i++) {
    printf("%10d", rand() % 6 + 1);
    if (i % 5 == 0) {
      puts("");
    }
  }

  return 0;
}
</pre>
  </details>

  <p>Чтобы показать, что эти числа появляются приблизительно с равной вероятностью, смоделируем 6000 бросков. Каждое целое число от 1 до 6 должно выпасть приблизительно 1000 раз.</p>

  <details>
    <summary>Программа 21 (168)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
  int f1 = 0, f2 = 0, f3 = 0;
  int f4 = 0, f5 = 0, f6 = 0;
  int roll, face;

  for (roll = 1; roll &lt;= 6000; roll++) {
    face = rand() % 6 + 1;

    switch(face) {
      case 1: f1++; break;
      case 2: f2++; break;
      case 3: f3++; break;
      case 4: f4++; break;
      case 5: f5++; break;
      case 6: f6++; break;
    }
  }

  printf("%s%13s\n", "Face", "Frequency");
  printf("  1%13d\n", f1);
  printf("  2%13d\n", f2);
  printf("  3%13d\n", f3);
  printf("  4%13d\n", f4);
  printf("  5%13d\n", f5);
  printf("  6%13d\n", f6);

  return 0;
}
</pre>
  </details>

  <p>При каждом запуске программы, функция rand() дает одинаковый результат. На самом деле функция rand() возвращает определенную последовательность чисел. Каждая такая последовательность определяется семенем. По умолчанию семя равно 0. Но его можно изменить при помощи функции srand(). Тогда функция rand() будет возвращать другую последовательность, по одному числу в каждом вызове. Функция srand() получает в качестве аргумента значение типа unsigned.</p>
  <p>Напишем программу, которая при каждом вызове выдает разные результаты.</p>

  <details>
    <summary>Программа 22 (170)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
  unsigned seed;

  printf("Enter seed: ");
  scanf("%u", &seed);
  srand(seed);

  for (int i = 1; i &lt;= 10; i++) {
    printf("%10d", rand() % 6 + 1);
  }

  return 0;
}
</pre>
  </details>

  <p>Хорошая рандомизация получится если в качестве семени ввести показания системных часов.</p>
  <code>srand( time(NULL) );</code>
  <p>Функция time возвращает число секунд, прошедшее с 1 января 1970 года.</p>
  <p>Значение, генерируемые функцией rand всегда находятся в диапазоне</p>
  <code>0 ≤ rand() ≤ RAND_MAX</code>
  <p>Можно получить значения от 1 до 6</p>
  <code>face = 1 + rand() % 6;</code>
  <p>Чтобы получить нужный диапазон значений надо применить формулу</p>
  <code>n = a + rand() % b;</code>
  <p>где a это значение сдвига, b это коэффициент масштабирования.</p>

  <h4>5.11 Пример: стохастическая игра (172)</h4>

  <p>Напишем игру "Крепс". Игрок бросает две кости. Каждая кость имеет 6 граней с точками от 1 до 6. Вычисляется сумма точек на двух гранях повернутых вверх. Если сумма при первом броске равна 7 или 11, то победил игрок. Если сумма при первом броске равна 2, 3 или 12 то победило казино. Если сумма при первом броске равна 4, 5, 6, 8, 9 или 10 то эта сумма становится очком игрока. Чтобы выиграть нужно бросать кости до тех пор, пока не наберете свое очко еще раз. Если при очередном броске выпадает 7, то игрок проигрывает.</p>

  <details>
    <summary>Программа 23 (172)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

enum Status { CONTINUE, WON, LOST };

int rollDice();

int main() {
  int sum;
  int myPoint;
  enum Status gameStatus;
  srand( time(NULL) );
  sum = rollDice();

  switch (sum) {
    case 7:
    case 11:
      gameStatus = WON;
      break;
    case 2:
    case 3:
    case 12:
      gameStatus = LOST;
      break;
    default:
      gameStatus = CONTINUE;
      myPoint = sum;
      printf("Point is %d\n", myPoint);
      break;
  }

  while (gameStatus == CONTINUE) {
    sum = rollDice();
    if (sum == myPoint) {
      gameStatus = WON;
    } else {
      if (sum == 7) {
        gameStatus = LOST;
      }
    }
  }

  if (gameStatus == WON) {
    puts("Player wins");
  } else {
    puts("Player loses");
  }

  return 0;
}

int rollDice() {
  int die1;
  int die2;
  int workSum;

  die1 = 1 + rand() % 6;
  die2 = 1 + rand() % 6;
  workSum = die1 + die2;

  printf("Player rolled %d + %d = %d\n", die1, die2, workSum);

  return workSum;
}
</pre>
  </details>

  <h4>5.12 Классы памяти (175)</h4>

  <p>Язык Си поддерживает четыре класса памяти, обозначаемые спецификаторами класса памяти: auto, regidter, extern, static. Класс памяти определяет период хранения, область дейтсвия и тип компоновки. Классы памяти имеют все переменные и функции.</p>
  <p>Есть два периода хранения: автоматический и статический.</p>
  <p>Автоматический период хранения могут иметь только переменные. Переменные с автоматическим периодом хранения (auto и register) создаются, когда начинает выполняться блок в котором они определены и уничтожаются, когда программа выходит из этого блока.</p>
  <p>Все локальные переменные имеют автоматический период хранения по умолчанию, поэтому ключевое слово auto можно не использоваеть при их объявлении.</p>
  <p>Данные в программе на машинном языке для вычислений загружаются из памяти в регистры. Если часто используемые переменные создавать сразу в регистрах, то можно исключить затраты на загрузку переменных из памяти в регистры. Например, счетчик в цикле. Ключевое слово register рекомендует компилятору создавать переменную сразу в регистре. Обычно компиляторы игнорируют данную рекомендацию и размещают переменную как им удобно.</p>
  <p>Статический период хранения могут иметь переменные и функции. Для переменых и функций со статическим периодом хранения (extern и static) память распределяется и инициализируется один раз, когда программа запускается. Но это не означает, что они доступны во всей программе. Период хранения и область действия это разные вещи.</p>
  <p>Глобальные переменные и функции имеют по умолчанию класс памяти extern. Они создаются вне функций и сохраняют свои значения в течении всего времени выполнения программы. Обращение к глобальнымм переменным и функциям возможно из любого места после их объявления. По этой причине в начале файла всегда пишут прототипы функций. Нужно избегать использования глобальных переменных.</p>
  <p>Локальные переменные с классом памяти static известны только той функции в которой они определены, но сохраняют свое значение при выходе из функции.</p>
  <p>Все числовые переменные со статическим периодом хранения инициализируются нулем, если они явно не инициализируются программистом.</p>

  <h4>5.13 Правила области действия (178)</h4>

  <p>Есть четыре области действия: область действия функции, область действия файла, область действия блока, область действия прототипа функции.</p>
  <p>Область действия функции имеют только метки с двоеточием. Метки используются только в операторах switch и goto. Метки это подробности реализации, которые функции скрывают друг от друга</p>
  <p>Область действия файла имеет идентификатор, объявленый вне любой функции. Он действует с момента объявления и до конца файла. Глобальные переменные, определения функций и прототипы функций, помещенные вне функций имеют облать действия файла.</p>
  <p>Область действия блока имеют идентификаторы, определенные внутри блока. Локальные переменные, параметры функции имеют область действия блока</p>
  <p>Локальные переменные, объявленные как static, имеют область действия блока, но существуют во все время выполнения программы. В этом случае период хранения не совпадает с областью действия.</p>
  <p>Область действия прототипа функции имеют только идентификаторы, которые используются в списке параметров прототипа. Прототипы функций не требуют, чтобы в списке параметров стояли имена идентификаторов, прототипы требуют только их тип. Если в списке параметров прототипа используется имя, то компилятор его игнорирует. Поэтому имена параметров в прототипе функций могут встречаться в любом месте программы и это не вызовет конфликта имен.</p>
  <p>Нужно избегать дублирования имен переменных в программе.</p>

  <h4>5.14 Рекурсия (181)</h4>

  <p>Рекурсию можно использовать для определения факториала n!</p>
  <code>n*(n-1)*(n-2)* ... *2*1</code>
  <p>Базовым случаем будет</p>
  <code>1! = 1</code>
  <p>Рекурсивным определением функции будет</p>
  <code>n! = n * (n-1)!</code>

  <details>
    <summary>Программа 24 (183)</summary>
<pre>
#include &lt;stdio.h&gt;

long factorial(int);

int main() {
  for (int i = 0; i &lt;= 10; i++) {
    printf("%2d! = %ld\n", i, factorial(i));
  }

  return 0;
}

long factorial(int num) {
  if (num &lt;= 1) {
    return 1;
  } else {
    return num * factorial(num-1);
  }
}
</pre>
  </details>

  <h4>5.15 Пример применения рекурсии: числа Фибоначчи (185)</h4>

  <p>Числа Фибоначчи начинаются с 0 и 1, каждое следующее число это сумма двух предыдущих чисел.</p>
  <code>0 1 1 2 3 5 8 13 21 ...</code>
  <p>Числа Фибоначчи встречаются в природе, например описывают форму спирали. Отношения последовательных чисел Фибоначчи сходятся к значению константы 1,618... и назывваются золотым сечением.</p>

  <details>
    <summary>Программа 25 (185)</summary>
<pre>
#include &lt;stdio.h&gt;

long fibonacci(int);

int main() {
  long result;
  long number;

  printf("%s", "Enter an integer");
  scanf("%ld", &number);
  result = fibonacci(number);

  return 0;
}

long fibonacci(int n) {
  if (n == 0 || n == 1) {
    return n;
  } else {
    return fibonacci(n-1) + fibonacci(n-2);
  }
}
</pre>
  </details>

  <h4>5.16 Рекурсия в сравнении с итерацией (188)</h4>

  <p>Итерация завершается когда перестает выполняться условие продолжения цикла. Рекурсия завершается, когда выполняется базовый случай.</p>
  <p>Рекурсия имеет много отрицательных сторон. Она многократно инициирует механизм вызова функции. Это дорого стоит в плане процессорного времени и в плане расхода памяти. Итерация происходит в пределах функции, поэтому дополнительных расходов на вызовы функции и выделение памяти нет.</p>
  <p>Любая проблема, которая может быть решена рекурсивно, может быть решена и итеративно (без рекурсии). Рекурсивное решение проще для понимания и отладки.</p>

  <p>Стандарт ANSI не определяет порядок, в котором должны вычисляться значения операндов большинства операций. Порядок определен только в четырех операциях: логическое И "&&"",  логическое ИЛИ ""||", запятая ",", тернарный оператор "?:". В этих операциях порядок слева направо.</p>
</article>


<!-- 6 Массивы в C -->
<article class="article">
  <div class="anchor" id="p6"></div>
  <h3>6 Массивы в C (207)</h3>

  <h4>6.1 Введение (208)</h4>

  <p>Массив это группа соседних ячеек памяти, которые содержат элементы одного типа данных. Массивы это статические объекты, потому что их размер не изменяется. Списки, очереди, стеки и деревья это динамические объекты, потому что их размер можно увеличивать и уменьшать.</p>

  <h4>6.2 Массивы (208)</h4>

  <p>Для обращения к элементу массива, мы указываем имя массива и номер позиции элемента относительно начала массива. Номера позиций (индексы) элементов массива начинаются с 0.</p>

  <h4>6.3 Определение массивов (210)</h4>

  <h4>6.4 Примеры действий над массивами (210)</h4>

  <p>Определение массива и использование цикла для инициализации его элементов.</p>

  <details>
    <summary>Программа 26 (211)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int n[10];
  int i;

  for (i = 0; i &lt; 10; i++) {
    n[i] = 0;
  }

  printf("%s%13s\n", "Element", "Value");

  for (i = 0; i &lt; 10; i++) {
    printf("%7d%13d\n", i, n[i]);
  }

  return 0;
}
</pre>
  </details>

  <p>Инициализация массива в определении с помощью списка инициализации.</p>

  <details>
    <summary>Программа 27 (212)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int n[10] = {32, 27, 64, 18, 95, 14, 90, 70, 60, 37};
  int i;

  printf("%s%13s\n", "Element", "Value");

  for (i = 0; i &lt; 10; i++) {
    printf("%7d%13d\n", i, n[i]);
  }

  return 0;
}
</pre>
  </details>

  <p>Если инициализирующих значений меньше, чем элементов массива, то оставшиеся элементы автоматически инициализируются нулями. Массивы не инициализируются нулями автоматически, нужно инициализировать хотя бы один элемент, чтобы оставшиеся элементы были заполнены нулями автоматически.</p>

  <p>Инициализируем элементы массива четными числами от 2 до 20</p>

  <details>
    <summary>Программа 28 (213)</summary>
<pre>
#include &lt;stdio.h&gt;
#define SIZE 10

int main() {
  int n[SIZE];
  int i;

  for (i = 0; i &lt; SIZE; i++) {
    n[i] = 2 + 2 * i;
  }

  printf("%s%13s\n", "Element", "Value");

  for (i = 0; i &lt; SIZE; i++) {
    printf("%7d%13d\n", i, n[i]);
  }

  return 0;
}
</pre>
  </details>

  <p>Вычисление суммы элементов массива (215)</p>

  <details>
    <summary>Программа 29 (215)</summary>
<pre>
#include &lt;stdio.h&gt;
#define SIZE 12

int main() {
  int n[SIZE] = {1,3,5,4,7,2,99,16,45,67,89,45};
  int i;
  int total = 0;

  for (i = 0; i &lt; SIZE; i++) {
    total += n[i];
  }

  printf("Total is %d\n", total);

  return 0;
}
</pre>
  </details>

  <p>Задача. Сорок студентов попросили оценить качество питания в студенческой столовой по шкале от 1 до 10. Поместите 40 ответов в целочисленный массив и определите результат опроса.</p>

  <details>
    <summary>Программа 30 (216)</summary>
<pre>
#include &lt;stdio.h&gt;
#define RESPONSE_SIZE 40
#define FREQUENCY_SIZE 11

int main() {
  int answer;
  int raiting;

  int frequency[FREQUENCY_SIZE] = {0};
  int responses[RESPONSE_SIZE] = {1,2,6,4,8,5,9,7,8,10,1,6,3,8,6,10,3,8,2,7,6,5,7,6,8,6,7,5,6,6,5,6,7,5,6,4,8,6,8,10};

  for (answer = 0; answer &lt; RESPONSE_SIZE; answer++) {
    ++frequency[responses[answer]];
  }

  printf("%s%17s\n", "Raiting", "Frequency");

  for (raiting = 1; raiting &lt; FREQUENCY_SIZE; raiting++) {
    printf("%6%17d\n", raiting, frequensy[raiting]);
  }

  return 0;
}
</pre>
  </details>

  <p>Вывести элементы массива в виде гистограммы.</p>

  <details>
    <summary>Программа 31 (218)</summary>
<pre>
#include &lt;stdio.h&gt;
#define SIZE 10

int main() {
  int n[SIZE] = {19,3,15,7,11,9,13,5,17,1};

  printf("%s%13s%17s\n", "Element", "Value", "Histogram");

  for (int i = 0; i &lt; SIZE; i++) {
    printf("%7d%13d     ", i, n[i]);

    for (int j = 1; j &lt;= n[i]; j++) {
      printf("%c", '*');
    }

    puts("");
  }

  return 0;
}
</pre>
  </details>

  <p>Бросание игральной кости 6000 раз</p>

  <details>
    <summary>Программа 32 (219)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#define SIZE 7

int main() {
  int face;
  int roll;
  int frequency[SIZE] = {0};

  srand(time(NULL));

  for (roll = 1; roll &lt;= 6000; roll++) {
    face = 1 + rand() % 6;
    ++frequency[face];
  }

  printf("%s%17s\n", "Face", "Frequency");

  for (face = 1; face &lt; SIZE; face++) {
    printf("%4d%17d\n", face, frequency[face]);
  }

  return 0;
}
</pre>
  </details>

  <h4>Использование символьных массивов для хранения строк и действий над ними</h4>

  <p>Символьный массив может быть инициализирован строковым литералом.</p>
  <code>char string1[] = "first";</code>

  <p>Компилятор определяет размер массива исходя из длины строки. Строка "first" содержит пять символов и специальный символ окончания строки - нулевой символ '\0'. Все строки языка Си заканчиваются нулевым символом '\0'.</p>
  <p>Символьный массив может быть также инициализирован списком символьных констант.</p>
  <code>char string1[] = {'f', 'i', 'r', 's', 't', '\0'};</code>

  <p>Символьный массив можно ввести с помощью функции scanf() и спецификатора %s.</p>
  <code>char string2[20];</code>
  <code>scanf("%s", string2)</code>
  <code>printf("%s\n", string2);</code>
  <p>Создаем символьный массив на 19 символов и завершающий нулевой символ. Имя массива является адресом его начала в памяти, поэтому символ & перед ним не ставится.</p>
  <p>Программист должен следить за размером массива сам. Если пользователь введет больше символов, чем содержит символьный массив, переданный в функцию scanf(), то функция scanf() запишет информацию за пределы массива это может привести к потере других данных и ошибкам в программе.</p>
  <p>Функция printf(), также как и функция scanf(), не следит за размером массива, она будет выводить символы до тех пор, пока не встетит завершающий символ '\0'.</p>

  <p>Инициализация символьного массива строковым литералом, чтение строки в символьный массив, вывод символьного массива в виде строки и доступ к отдельным символам строки.</p>

  <details>
    <summary>Программа 33 (221)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char string1[20];
  char string2[] = "string literal";

  printf("Enter a string (less than 20 chars) ");
  scanf("%s", string1);

  printf("%s", "string1 is %s\nstring2 is %s\n", "string1 with spaces between characters is\n", string1, string2);

  for (int i = 0; string1[i] != '\0'; i++) {
    printf("%c", string1[i]);
  }

  puts("");

  return 0;
}
</pre>
  </details>

  <h4>Статические и автоматические локальные массивы</h4>

  <p>Статическая локальная переменная (объявленная со словом static внутри функции) существует всегда, но видна только в теле функции. Если локальный массив объявить как статический, он будет создан и проинициализирован один раз. Каждый раз при вызове функции массив не будет создаваться и потом уничтожаться. Это уменьшит время выполнения программы.</p>

  <p>Напишем две функции. Функция staticArrayInit с локальным статическим массивом. В ней массив создается один раз и сразу инициализируется нулями. Вызовем эту функцию дважды. Каждый вызов значения в массиве сохраняются после предыдущего вызова функциии. Функция automaticArrayInit с локальным автоматическим массивом. В ней массив создается при каждом вызове функции и инициализируется значениями 1, 2, 3. Вызываем эту функцию тоже дважды.</p>

  <details>
    <summary>Программа 34 (222)</summary>
<pre>
#include &lt;stdio.h&gt;

void staticArrayInit();
void automaticArrayInit();

int main() {
  puts("First call to each function ");
  staticArrayInit();
  automaticArrayInit();

  puts("Second call to each function ");
  staticArrayInit();
  automaticArrayInit();

  return 0;
}

void staticArrayInit() {
  static init array[3]; // {0, 0, 0}
  puts("Values on entering of static array ");
  for (int i = 0; i &lt; 3; i++) {
    printf("array[%d] = %d ", i, array[i]);
  }
  puts("Values on exiting of static array ");
  for (int i = 0; i &lt; 3; i++) {
    printf("array[%d] = %d ", i, array[i] += 5);
  }
}

void automaticArrayInit() {
  static init array[3] = {1, 2, 3}
  puts("Values on entering of automatic array ");
  for (int i = 0; i &lt; 3; i++) {
    printf("array[%d] = %d ", i, array[i]);
  }
  puts("Values on exiting of automatic array ");
  for (int i = 0; i &lt; 3; i++) {
    printf("array[%d] = %d ", i, array[i] += 5);
  }
}
</pre>
  </details>

  <h4>6.5 Передача массивов функциям (224)</h4>

  <p>Для передачи функции массива, нужно указать его имя. Также необходимо передавать размер массива отдельным параметром. Имя массива является адресом его первого элемента. Поэтому такая передача массива в функцию является передачей по ссылке. Функция в этом случае работает не с копиями значений, а с оригинальными элементами массива, находящимися по переданному адресу.</p>

  <p>Покажем что имя массива array и адрес его первого элемента &array[0] это одно и то же.</p>

  <details>
    <summary>Программа 35 (225)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char array[5];

  printf("array = %p\n", array);
  printf("&array = %p\n", &array);
  printf("&array[0] = %p\n", &array[0]);

  return 0;
}
</pre>
  </details>

  <p>Покажем что массив передается по ссылке, а отдельные элементы массива передаются по значению.</p>

  <details>
    <summary>Программа 36 (226)</summary>
<pre>
#include &lt;stdio.h&gt;
#define SIZE 5

void modifyArray(int [], int);
void modifyElement(int);

int main() {
  int a[SIZE] = {1, 2, 3, 4, 5};
  puts("Values of original array ");
  for (int i = 0; i &lt; SIZE; i++) {
    printf("%3d", a[i]);
  }
  puts("");

  modifyArray(a, SIZE);
  puts("Values of modified array ");
  for (int i = 0; i &lt; SIZE; i++) {
    printf("%3d", a[i]);
  }
  puts("");

  puts("Value of array element [3] ");
  printf("%d", a[3]);

  modifyElement(a[3]);
  puts("Value of modified element [3] ");
  printf("%d", a[3]);

  return 0;
}

void modifyArray(int b[], int size) {
  for (int i = 0; i &lt; size; i++) {
    b[i] *= 2;
  }
}

void modifyElement(int e) {
  e *= 2;
  printf("Value in modifyElement is %d", e);
}
</pre>
  </details>

  <p>Чтобы уберечь элементы массива от изменений, при передаче массива в функцию по ссылке, нужно использовать слово const.</p>
  <code>void change(const int array[], int size);</code>
  <p>Теперь любая попытка изменить элемент приведет к ошибке компиляции.</p>

  <details>
    <summary>Программа 37 (228)</summary>
<pre>
#include &lt;stdio.h&gt;

void tryToModifyArray(const int []);

int main() {
  int a[] = {10, 20, 30};
  printf("%d %d %d", a[0], a[1], a[2]);

  tryToModifyArray(a);
  printf("%d %d %d", a[0], a[1], a[2]);

  return 0;
}

void tryToModifyArray(const int b[]) {
  for (int i = 0; i &lt; size; i++) {
    b[i] *= 2; // ошибка компиляции
  }
}
</pre>
  </details>

  <h4>6.6 Сортировка массивов (229)</h4>

  <p>Напишем сортировку пузырьком массива из 10 целых чисел.</p>

  <details>
    <summary>Программа 38 (229)</summary>
<pre>
#include &lt;stdio.h&gt;
#define SIZE 10

int main() {
  int a[SIZE] = {2,6,4,8,10,12,89,68,45,37};
  int tmp;

  puts("Original order ");
  for (int i = 0; i &lt; SIZE; i++) {
    printf("%4d ", a[i]);
  }
  puts("");

  for (int i = 1; i &lt; SIZE; i++) {
    for (int j = 0; j &lt; SIZE - 1; j++) {
      if (a[j] > a[j+1]) {
        tmp = a[j];
        a[j] = a[j+1];
        a[j+1] = tmp;
      }
    }
  }

  puts("Ascending order ");
  for (int i = 0; i &lt; SIZE; i++) {
    printf("%4d ", a[i]);
  }

  return 0;
}
</pre>
  </details>

  <h4>6.7 Пример: вычисление среднего, медианы и наиболее вероятного значения массива (231)</h4>

  <details>
    <summary>Программа 39 (231)</summary>
<pre>
#include &lt;stdio.h&gt;
#define SIZE 99

void mean(const int []);
void median(int []);
void mode(int [], const int []);
void bubbleSort(int []);
void printArray(const int []);

int main() {
  int frequency[10] = {0};
  int response[SIZE] = {
    6,7,8,9,8,7,8,9,8,9,
    7,8,9,5,9,8,7,8,7,8,
    6,7,8,9,3,9,8,7,8,7,
    7,8,9,8,9,8,9,7,8,9,
    6,7,8,7,8,7,9,8,9,2,
    7,8,9,8,9,8,9,7,5,3,
    5,6,7,2,5,3,9,4,6,4,
    7,8,9,6,8,7,8,9,7,8,
    7,4,4,2,5,3,8,7,5,6,
    4,5,6,1,6,5,7,8,7
  }

  mean(response);
  median(response);
  mode(frequency, response);

  return 0;
}

// вычислить среднее значение
void mean(const int answer[]) {
  int total = 0;
  printf("%s\n%s\n%s\n", "********", "  Mean", "********");
  for (int i = 0; i &lt; SIZE; i++) {
    total += answer[i];
  }
  printf("Average is %d\n", total);
}

// вычислить медианный элемент
void median(int answer[]) {
  printf("%s\n%s\n%s\n", "********", "  Median", "********");
  puts("Unsorted array\n");
  printArray(answer);
  bubbleSort(answer);
  puts("Sorted array\n");
  printArray(answer);
  printf("Median is %d\n", answer[SIZE / 2]);
}

// определить наиболее частый отклик
void mode(int freq[], const int answer[]) {
  int raiting;
  int h;
  int largest = 0;
  int modeValue = 0;
  printf("%s\n%s\n%s\n", "********", "  Mode", "********");
  for (raiting = 1; raiting &lt;= 9; raiting++) {
    freq[raiting] = 0;
  }
  for (int i = 0; i &lt; SIZE; i++) {
    freq[answer[i]]++;
  }
  printf("%s%11s%19s\n\n%54s\n%54s\n\n",
         "Response", "Frequency", "Histogram",
         "1   1   2   2", "5   0   5   0   5");
  for (raiting = 1; raiting &lt;= 9; raining++) {
    printf("%8d%11d       ", raiting, freq[raiting]);
    if (freq[raiting] > largest) {
      largest = freq[raiting];
      modeValue = raiting;
    }
    for (h = 1; h &lt;= freq[raiting]; h++) {
      printf("%s", "*");
    }
    puts("");
    printf("Mode is %d occurred %d times\n", modeValue, largest);
  }
}

// пузырьковая сортировка
void bubbleSort(int a[]){
  int pass;
  int hold;
  for (pass = 1; pass &lt; SIZE; pass++){
    for (int i = 0; i &lt; SIZE - 1; i++) {
      if (a[i] > a[i + 1]) {
        hold = a[i];
        a[i] = a[i + 1];
        a[i + 1] = hold;
      }
    }
  }
}

// печать массива
void printArray(const int a[]) {
  for (int i = 0; i &lt; SIZE; i++) {
    if (i % 20 == 0) {
      puts("");
    }
    printf("%2d", a[i]);
  }
}
</pre>
  </details>

  <h4>6.8 Поиск в массивах (236)</h4>

  <h4>Линейный поиск</h4>

  <p>При линейном поиске сравнивают значения каждого элемента с ключом поиска. Алгоритм проводится на несортированном массиве.</p>

  <details>
    <summary>Программа 40 (236)</summary>
<pre>
#include &lt;stdio.h&gt;
#define SIZE 100

int linearSearch(const int [], int, int);

int main() {
  int a[SIZE];
  int key;
  int element;
  for (int i = 0; i &lt; SIZE; i++) {
    a[i] = 2 * i;
  }
  puts("Enter integer key ");
  scanf("%d", &key);
  element = linearSearch(a, key, SIZE);
  if (element != -1) {
    printf("Fount in element %d\n", element);
  } else {
    puts("Element not found");
  }

  return 0;
}

// линейнй поиск
int linearSearch(const int array[], int key, int size) {
  for (int i = 0; i &lt; size; i++) {
    if (array[i] == key) {
      return i;
    }
  }
  return -1;
}
</pre>
  </details>

  <h4>Двоичный поиск</h4>

  <p>При двоичном поиске после каждого сравнения исключается половина массива. Алгоритм проводится на сортированном массиве.</p>

  <details>
    <summary>Программа 41 (238)</summary>
<pre>
#include &lt;stdio.h&gt;
#define SIZE 15

int binarySearch(const int [], int, int, int);
void printHeader();
void printRow(const int [], int, int, int);

int main() {
  int a[SIZE];
  int key;
  int element;
  for (int i = 0; i &lt; SIZE; i++) {
    a[i] = 2 * i;
  }
  puts("Enter number from 0 to 28 ");
  scanf("%d", &key);
  printHeader();
  element = binarySearch(a, key, 0, SIZE - 1);
  if (element != -1) {
    printf("%d found in element %d\n", key, element);
  } else {
    printf("Element %d not found", key);
  }

  return 0;
}

// двоичный поиск
int binarySearch(const int b[], int key, int low, int high) {
  int middle;
  while (low &lt;= high) {
    middle = (low + high) / 2;
    printRow(b, low, middle, high);
    if (key == b[middle]) {
      return middle;
    } else if (key &lt; b[middle]) {
      high = middle - 1;
    } else {
      low = middle + 1;
    }
  }

  return -1;
}

// печать заголовка
void printHeader() {
  puts("\nSubscripts:");
  for (int i = 0; i &lt; SIZE; i++) {
    printf("%3d", i)
  }
  puts("";)
  for (int i = 0; i &lt; 4 * SIZE; i++) {
    printf("%s", "-");
  }
  puts("";)
}

// напечатать ряд массива
void printRow(const int b[], int low, int mid, int high) {
  for (int i = 0; i &lt; SIZE; i++) {
    if (i &lt; low || i > high) {
      printf("%s", "   ");
    } else if (i == mid) {
      printf("%3d", b[i]);
    } else {
      printf("%3d", b[i]);
    }
  }
  puts("";)
}
</pre>
  </details>

  <h4>6.9 Многомерные массивы (241)</h4>

  <p>Для работы с таблицами используют двумерные массивы. Каждую ячейку таблицы можно указать с помощью двух индексов: первый индекс указывает строку таблицы, второй индекс - столбец.</p>
  <p>Определим и инициализируем массив 2 на 2.</p>
  <code>int b[2][2] = { {1,2}, {3,4} };</code>
  <p>Если указывать не все значения, то последние в каждой строке инициализируются нулями</p>
  <code>int b[2][2] = { {1}, {3} }; // { {1,0}, {3,0}}</code>

  <details>
    <summary>Программа 42 (242)</summary>
<pre>
#include &lt;stdio.h&gt;

void printArray(const int [][3]);

int main() {
  int array1[2][3] = { {1,2,3}, {4,5,6} };
  int array1[2][3] = { 1, 2, 3, 4, 5, 6 };
  int array1[2][3] = { {1,2}, {4} };

  puts("array1");
  printArray(array1);

  puts("array2");
  printArray(array2);

  puts("array3");
  printArray(array3);

  return 0;
}

void printArray(const int a[][3]) {
  for (int i = 0; i &lt;= 1; i++) {
    for (int j = 0; j &lt;= 2; j++) {
      printf("%d", a[i][j]);
    }
  }
  puts("");
}
</pre>
  </details>

  <p>Все элементы многомерного массива хранятся в памяти последовательно , независимо от количества индексов. В двумерных массивах каждая строка является одномерным массивом.</p>
  <p>В следующей программе есть массив studentGrages размером 3 на 4. Каждая строка массива это студент, а каждый столбец это оценка за экзамен. Функция minimum() определяет самую низкую оценку. Функция maximum() - самую высокую. Функция average() для каждого студента определяет среднюю оценку.</p>

  <details>
    <summary>Программа 43 (245)</summary>
<pre>
#include &lt;stdio.h&gt;
#define STUDENTS 3
#define EXAMS 4

int minimum(const int [][EXAMS], int, int);
int maximum(const int [][EXAMS], int, int);
double average(const int [][EXAMS], int);
void printArray(const int [][EXAMS], int, int);

int main() {
  int student;
  const int studentGrades[STUDENTS][EXAMS] = {
    {77, 68, 86, 73},
    {96, 87, 89, 78},
    {70, 90, 86, 81}
  }

  puts("Array is");
  printArray(studentGrades, STUDENTS, EXAMS);

  printf("Lowest grade %d\n Highest grade %d\n",
    minimum(studentGrades, STUDENTS, EXAMS),
    maximum(studentGrades, STUDENTS, EXAMS),)

  for (student = 0; student &lt; STUDENTS, student++) {
    printf("Average for student %d is %d\n",
    student,
    average(studentGrades[student], EXAMS));
  }

  return 0;
}

int minimum(const int grades[][EXAMS], int pupils, int tests){
  int lowGrade = 100;
  for (int i = 0; i &lt; pupils; i++) {
    for (int j = 0; j &lt; tests; j++) {
      if (grades[i][j] &lt; lowGrade) {
        lowGrade = grades[i][j];
      }
    }
  }
  return lowGrade;
}

int maximum(const int grades[][EXAMS], int pupils, int tests){
  int highGrade = 0;
  for (int i = 0; i &lt; pupils; i++) {
    for (int j = 0; j &lt; tests; j++) {
      if (grades[i][j] > highGrade) {
        highGrade = grades[i][j];
      }
    }
  }
  return highGrade;
}

double average(const int setOfGrades[][EXAMS], int tests) {
  int total = 0;
  for (int i = 0; i &lt; tests; i++) {
    total += setOgGrades[i];
  }

  return (double)total / tests;
}

void printArray(const int grades[][EXAMS], int pupils, int tests) {
  printf("%s", "            [0]  [1]  [2]  [3]");
  for (int i = 0; i &lt; pupils; i++) {
    printf("\nstudentGrades[%d] ", i);
    for (int j = 0; j &lt; tests; j++) {
      printf("%-5d", grades[i][j]);
    }
  }
}
</pre>
  </details>

  <p>Двумерный массив это одномерный массив одномерных массивов. Имя одномерного массива является адресом этого массива в памяти.</p>
</article>


<!-- 7 Указатели в C -->
<article class="article">
  <div class="anchor" id="p7"></div>
  <h3>7 Указатели в C (263)</h3>

  <h4>7.1 Введение (264)</h4>

  <h4>7.2 Определение и инициализация переменных-указателей (264)</h4>

  <p>Указатель это переменная, значением которой является адрес в памяти другой переменной. Переменная непосредственно ссылается на значение, а указатель косвенно ссылается на значение. Ссылка на значение через указатель это косвенная адресация. Указатели могут ссылаться на объекты любого типа.</p>
  <p>Указатель инициализируют адресом. Если указатель ни на что не ссылается, то его надо инициализировать значением 0 или NULL. Лучше использовать NULL, потому что 0 сперва преобразовывается к указателю соответствующего типа.</p>

  <h4>7.3 Операции над указателями (265)</h4>

  <p>Если y это переменная, &y это адрес переменной, то указателю yPtr можно присвоить адрес переменной y.</p>
  <code>int y = 5; int *yPtr = &y;</code>
  <p>Указатель yPtr указывает на переменную y.</p>
  <p>Операция взятия адреса & не может применяться к константам, выражениям или к переменным объявленным со словом register.</p>
  <p>Операция косвенной адресации * (разыменование) возвращает значение объекта на который ссылается указатель.</p>

  <details>
    <summary>Программа 44 (266)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int a;
  int *aPtr;
  a = 7;
  aPtr = &a;

  printf("Addres a is %p\nValue aPtr is %p\n", &a, aPtr);
  printf("&*aPtr = %p\n*&aPtr = %p\n", &*aPtr, *&aPtr);

  return 0;
}
</pre>
  </details>

  <h4>7.4 Вызов по ссылке (268)</h4>

  <p>Параметры в функцию можно передать двумя способами: по значению и по ссылке. Все вызовы в языке Си являются вызовами по значению. В этом случае <strong>всегда создается копия</strong> каждого передаваемого параметра.</p>
  <p>Если нужно обработать в функции большой объект, то на создание копии потребуется дополнительное время и память. Чтобы этого избежать в функцию передают не сам объект, а указатель на него. То есть адрес в памяти этого объекта.</p>
  <p>Оператор return возвращает из функции одно значение, тип которого заранее определен при объявлении функции. Если функции нужно изменить значения переданных ей переменных, то передают не сами переменные, а указатели на них. То есть адреса в памяти этих переменных.</p>

  <p>Рассмотрим две программы, вычисляющие куб целого числа. В первой программе используется функция cubeByValue, в которую число передается по значению, функция возвращает куб этого числа.</p>

  <details>
    <summary>Программа 45 (268)</summary>
<pre>
#include &lt;stdio.h&gt;

int cubeByValue(int);

int main() {
  int number = 5;
  printf("Number before = %d", number);
  number = cubeByValue(number);
  printf("Number after = %d", number);

  return 0;
}

int cubeByValue(int n) {
  return n * n * n;
}
</pre>
  </details>
  <p>Во второй программе используется функция cubeByReference, в которую передается адрес переменной, содержащей число. Функция ничего не возвращает, она изменяет значение переменной по переданному адресу.</p>

  <details>
    <summary>Программа 46 (269)</summary>
<pre>
#include &lt;stdio.h&gt;

int cubeByReference(int *);

int main() {
  int number = 5;
  printf("Number before = %d", number);
  cubeByReference(&number);
  printf("Number after = %d", number);

  return 0;
}

void cubeByReference(int *nPtr) {
  *nPtr = *nPtr * *nPtr * *nPtr;
}
</pre>
  </details>

  <p>В заголовке функции, принимающей в качестве аргумента <strong>одномерный массив</strong>, в качестве параметра можно использовать или <strong>одномерный массив</strong> или <strong>указатель</strong>. Когда в качестве параметра используется <strong>указатель</strong> int *, компилятор не знает придет ли в функцию <strong>одиночная переменная</strong> или <strong>одномерный массив</strong>.Когда в качестве параметра используется <strong>одномерный массив</strong> int [], компилятор преобразует этот параметр в указатель <strong>int *</strong>.</p>

  <h4>7.5 Использование квалификатора const с указателями (272)</h4>

  <p>Квалификатор const сообщает компилятору, что значение переменной нельзя изменять.</p>

  <p>Существует шесть вариантов использования квалификатора const с параметрами функции - два при передаче параметра по значению и четыре при передаче параметра по ссылке. Всегда используйте const если функция не должна изменять переданные ей параметры.</p>
  <p>Все вызовы в языке Си это вызовы по значению. При вызове функции, создается копия аргумента. Если эту копию можно изменять, то используют первый вариант - без квалификатора const. Если эту копию нельзя изменять, то используют второй вариан - с квалификатором const в списке параметров функции.</p>
  <p>Теперь рассмотрим четыре варианта вызова по ссылке. Если указатель и данные, на который он указывает можно изменять, то используют первый вариант - без квалификатора const. Еще три варианта это неконстантный указатель на константные данные, константный указатель на неконстантные данные и константный указатель на константные данные.</p>

  <p>Преобразование букв нижнего регистра в верхний с помощью неконстантного указателя на неконстантные данные</p>

  <details>
    <summary>Программа 47 (274)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

void convertToUppercase(char *);

int main() {
  char string[] = "characters and $32.98";
  printf("String before %s\n", string);
  convertToUppercase(string);
  printf("String after %s\n", string);

  return 0;
}

void convertToUppercase(char *sPtr) {
  while (*sPtr != '\0') {
    if (islower(*sPtr)) {
      *sPtr = toupper(*sPtr);
    }
    sPtr++;
  }
}
</pre>
  </details>

  <p>Печать строки по одному символу с помощью неконстантного указателя на константные данные</p>

  <details>
    <summary>Программа 48 (275)</summary>
<pre>
#include &lt;stdio.h&gt;

void printCharacters(const char *);

int main() {
  char string[] = "print characters of a string";
  puts("The string is ")
  printCharacters(string);
  puts("");

  return 0;
}

void printCharacters(const char *sPtr) {
  while (*sPtr != '\0') {
    printf("%c", *sPtr);
    sPtr++;
  }
}
</pre>
  </details>

  <p>Попытка изменения данных через неконстантный указатель на константные данные вызовет ошибку компиляции.</p>

  <details>
    <summary>Программа 49 (275)</summary>
<pre>
#include &lt;stdio.h&gt;

void f(const int *);

int main() {
  int y;
  f(&y);

  return 0;
}

void f(const int *xPtr) {
  //xPtr нельзя использовать для изменения
  //переменной на которую он указывает
  *xPtr = 100;
}
</pre>
  </details>

  <p>Имеются отличия при передаче функции <strong>массива</strong> и <strong>структуры</strong>. При передаче массива, функции передается указатель на массив, происходит вызов по ссылке При передаче структуры, функция создает копию всей структуры, происходит вызов по значению. Создание копии требует дополнительного времени и памяти. Чтобы этого избежать нужно передавать функции указатель на структуру. Функция принимающая только адрес размером 4 байта будет выполняться быстрее, чем функция создающая копию тысячи байтов структуры. Чтобы данные структуры сохранить без изменения используйте константный указатель на константные данные.</p>

  <p>При пердачи массива, по умолчанию передается константный указатель на неконстантные данные. Функция может менять элементы массива, но не может изменить указатель, который всегда будет указаывать на начало массива.</p>

  <p>Попытка изменить константный указатель на неконстантные данные приведет к ошибке компиляции.</p>

  <details>
    <summary>Программа 50 (277)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int x, y;
  int * const ptr = &x;

  // допустимо менять данные
  *ptr = 7;
  // недопустимо менять константный указатель
  ptr = y; // ошибка компиляции

  return 0;
}
</pre>
  </details>

  <p>Попытка изменить константный указатель на константные данные приводит к ошибке компиляции.</p>

  <details>
    <summary>Программа 51 (278)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int x = 5, y;
  const int * const ptr = &x;
  printf("%d\n", *ptr);
  *ptr = 7; // ошибка
  ptr = &y; // ошибка

  return 0;
}
</pre>
  </details>

  <h4>7.6 Пузырьковая сортировка, использующая вызов по ссылке (278)</h4>

  <p>Программа помещает значения в массив, сортирует их в восходящем порядке и печатает получившийся массив.</p>

  <details>
    <summary>Программа 52 (279)</summary>
<pre>
#include &lt;stdio.h&gt;
#define SIZE 10

void bubbleSort(int * const, const int);
void swap(int *, int *);

int main() {
  int a[SIZE] = {2,6,4,8,12,10,89,68,45,37};

  puts("original array\n");
  for (int i = 0; i &lt; SIZE; i++) {
    printf("%4d", a[i]);
  }

  bubbleSort(a, SIZE);

  puts("sorted array\n");
  for (int i = 0; i &lt; SIZE; i++) {
    printf("%4d", a[i]);
  }

  return 0;
}

void bubbleSort(int * const array, const int size) {
  for (int pass = 0; pass &lt; size - 1; pass++) {
    for (int j = 0; j &lt; size - 1; j++) {
      if (array[j] > array[j + 1]) {
        swap(&array[j], &array[j+1]);
      }
    }
  }
}

void swap(int *ptr1, int *ptr2) {
  int hold = *ptr1;
  *ptr1 = *ptr2;
  *ptr2 = hold;
}
</pre>
  </details>

  <h4> 7.7 Операция sizeof (282)</h4>

  <p>Операция sizeof может определить размер типа данных, переменной, массива. Например, массив типа int из 20 элементов определится как 80 байт, потому что каждый элемент типа int занимает 4 байта.</p>
  <p>Операция sizeof выполняется во время компиляции, поэтому она не вносит никаких затрат времени выполнения.</p>

  <p>Операция sizeof, примененная к имени массива, возвращает число байт в массиве.</p>

  <details>
    <summary>Программа 53 (282)</summary>
<pre>
#include &lt;stdio.h&gt;

size_t getSize(float *ptr);

int main() {
  float array[20];
  printf("number bytes in array %d\n", sizeof(array));
  printf("number bytes returned by getSize %d\n", getSize(array));

  return 0;
}

size_t getSize(float *ptr) {
  return sizeof(ptr);
}
</pre>
  </details>

  <p>sizeof возвращает тип данных size_t, который определен в заголовочном файле stddef.h и некоторых других, например stdio.h</p>
  <p>Определим размер стандартных типов данный с помощью операции sizeof.</p>

  <details>
    <summary>Программа 54 (283)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char c;
  short s;
  int i;
  long l;
  float f;
  double d;
  long double ld;
  int array[20];
  int *ptr = array;

  printf("sizeof char = %d sizeof c = %d\n", sizeof(char), sizeof(c));
  printf("sizeof short = %d sizeof s = %d\n", sizeof(short), sizeof(s));
  printf("sizeof int = %d sizeof i = %d\n", sizeof(int), sizeof(i));
  printf("sizeof long = %d sizeof l = %d\n", sizeof(long), sizeof(l));
  printf("sizeof float = %d sizeof f = %d\n", sizeof(float), sizeof(f));
  printf("sizeof double = %d sizeof d = %d\n", sizeof(double), sizeof(d));
  printf("sizeof long double = %d sizeof ld = %d\n", sizeof(long double), sizeof(ld));
  printf("sizeof array = %d\n", sizeof(array));
  printf("sizeof ptr = %d\n", sizeof(ptr));

  return 0;
}
</pre>
  </details>

  <h4>7.8 Выражения и арифметические операции с указателями (284)</h4>

  <p>К указателям может применяться только ограниченный набор арифметических операций. Инкремент (++), декремент (--), прибавить целое число (+, +=), вычесть целое число (-, -=), вычесть указатель из указателя.</p>
  <p>В символьном массиве под каждый символ отводится 1 байт. Если указатель указывает на символьный массив, то при прибавлении или вычитании из указателя целого числа значение будет изменяться на это число.</p>
  <p>В целочисленном массиве под каждое число отводится 4 байта. Если указатель указывает на целочисленный массив, то при прибавлении или вычитании из указателя целого числа  n значение будет изменяться на n * 4.</p>
  <p>Обычно арифметические операции с указателями имеют смысл только при работе с элементами одного массива. Элементы одного массива всегда находятся одной области памяти в соседних ячейках последовательно друг за другом.</p>
  <p>Указатель типа void может быть присвоен указателю любого типа и наоборот. Указатель типа void не может быть разыменован, поскольку компилятор не знает сколько байт в памяти занимает переменная, на которую он указывает.</p>
  <p>Указатели можно сравнивать операциями сравнения (==, !=, >, >=, &lt;, &lt;=). Сравнение указателей длуг с другом имеет смысл только при работе с элементами одного массива. Часто проверяют равенство указателя значению NULL.</p>

  <h4>7.9 Связь между указателями и массивами (287)</h4>

  <p>Имя массива можно рассматривать как указатель-константу.</p>
  <p>Указателю можно присвоить адрес первого элемента через его имя и через ссылку на первый элемент.</p>
  <code>aPtr = array;</code>
  <code>aPtr = &array[0];</code>
  <p>Имя массива рассматривается как указатель, поэтому его можно использовать в арифметике указателей. Найдем значение третьего элемента массива.</p>
  <code>el3 = *(aPtr + 2);</code>
  <code>el3 = *(array + 2);</code>
  <p>Все имена массивов с индексами могут быть преобразованы в указатели со смещениями.</p>

  <p>Есть 4 способа обратиться к элементам массива. В программе ниже показано использование для массивов нотаций индексов и указателей.</p>

  <details>
    <summary>Программа 55 (288)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int b[] = {10, 20, 30, 40};
  int *bPtr = b;

  // имя массива и нотация индексации
  puts("Name and subscript notation\n");
  for (int i = 0; i &lt; 4; i++) {
    printf("b[%d] = %d ", i, b[i]);
  }
  puts("");

  // имя массива и нотация указателя
  puts("Name and pointer notation\n");
  for (int i = 0; i &lt; 4; i++) {
    printf("*(b + %d) = %d ", i, *(b + i));
  }
  puts("");

  // указатель и нотация индексации
  puts("Pointer and subscript notation\n");
  for (int i = 0; i &lt; 4; i++) {
    printf("bPtr[%d] = %d ", i, bPtr[i]);
  }
  puts("");

  // указатель и нотация указателя
  puts("Pointer and pointer notation\n");
  for (int i = 0; i &lt; 4; i++) {
    printf("*(bPtr + %d) = %d ", i, *(bPtr + i));
  }
  puts("");

  return 0;
}
</pre>
  </details>

  <p>В следующей программе две функции копируют строки, но делают это по разному - с помощью индексов и указателей.</p>

  <details>
    <summary>Программа 56 (290)</summary>
<pre>
#include &lt;stdio.h&gt;

void copy1(char *, const char *);
void copy2(char *, const char *);

int main() {
  char string1[10];
  char *string2 = "Hello";
  char string3[10];
  char string4[] = "Good bye";

  copy1(string3, string4);
  printf("string3 = %s\n", string3;)

  copy2(string1, string2);
  printf("string1 = %s\n", string1;)

  return 0;
}

// копирование с нотацией индексов массива
void copy1(char *s1, const char *s2) {
  for (int i = 0; (s1[i] = s2[i]) != '\0'; i++) { ; }
}

// копирование с нотацией указателей
void copy2(char *s1, const char *s2) {
  for ( ; (*s1 = *s2) != '\0'; s1++, s2++) { ; }
}
</pre>
  </details>

  <h4>7.10 Массивы указателей (291)</h4>

  <p>Пример массива указателей это массив строк. Строка это указатель на первый символ строки.</p>
  <code>char *suit[4] = {"Hearts", "Diamonds", "Clubs", "Spades"};</code>
  <p>Эти четыре строки "Hearts", "Diamonds", "Clubs", "Spades" состоят из 6, 8, 5 и 6 символов плюс символ '\0', распологаются в памяти и занимают в памяти место 7,9,9 и 7 байт. Но сам массив хранит только указатели на эти строки. Каждый указатель ссылается на первый символ строки. Поэтому массив suits имеет фиксированный размер, но может хранить строки произвольной длины.</p>

  <h4>7.11 Пример: программа тасования и сдачи карт (292)</h4>

  <p>Напишем программу, которая перетасует колоду из 52 карт и затем все их раздаст. Для представления колоды мы используем двумерный массив deck размером 4 на 13. Четыре строки от 0 до 3 это масти. 13 столбцов от 0 до 12 это номиналы от туза до короля.</p>
  <p>Перед перетасовкой карт, заполним массив нулями. Затем случайным образом разместим в массиве числа от 1 до 52. Каждое число это порядок в котором будут сдаваться карты. Эта программа не эффективная, ее можно улучшить.</p>

  <details>
    <summary>Программа 57 (295)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

void shuffle(int wDeck[][13]);
void deal(const int wDeck[][13],
          constchar *wFace[],
          const char *wSuit[]);

int main() {
  const char *suit[4] = {"Hearts", "Diamonds", "Clubs", "Spades"};
  const char *face[13] = {"Ace", "Deuse", "Three", "Four", "Five",
  "Six", " Seven", "Eight", "Nine", "Ten", "Jack", "Queen, "King"}
  int deck[4][13] = {0};
  srand(time(0));
  shuffle(deck);
  deal(deck, face, suit);

  return 0;
}

void shuffle(int wDeck[][13]) {
  int row, column, card;
  for (card = 1; card &lt;= 52; card++) {
    do {
      row = rand() % 4;
      column = rand() % 13;
    } while (wDeck[row][column] != 0);
    wDeck[row][column] = card;
  }
}

void deal(const int wDeck[][13],
          constchar *wFace[],
          const char *wSuit[]) {
  int row, column, card;
  for (card = 1; card &lt;= 52; card++) {
    for (row = 0; row &lt;= 3; row++) {
      for (column = 0; column &lt;= 12; column++) {
        if (wDeck[row][column] == card) {
          printf("%5s of %-8s%c", wFace[column], wSuit[row], card % 2 == 0 ? '\n' : '\t');
        }
      }
    }
  }
}
</pre>
  </details>

  <h4>7.12 Указатели на функции (297)</h4>

  <p>Указатель на функцию - это переменная, содержащая адрес в памяти, по которому расположена функция.</p>
  <p>Напишем программу пузырьковой сортировки, использующую указатели на функцию.</p>

  <details>
    <summary>Программа 58 (297)</summary>
<pre>
#include &lt;stdio.h&gt;
#define SIZE 10

void bubble(int work[], const int size,
  int (*compare)(int a, int b));
int ascending(int a, int b);
int descending(int a, int b);

int main() {
  int order;
  int a[SIZE] = {2,6,4,8,10,12,89,68,45,37};
  puts("Enter 1 to sort in ascending order");
  puts("Enter 2 to sort in descending order ");
  scanf("%d", &order);

  puts("Original order\n");
  for (i = 0; i &lt; SIZE; i++) {
    printf("%5", a[i]);
  }

  if (order == 1) {
    bubble(a, SIZE, ascending);
    puts("Ascending order");
  } else {
    bubble(a, SIZE, descending);
    puts("Descending order");
  }
  for (i = 0; i &lt; SIZE; i++) {
    printf("%5", a[i]);
  }

  return 0;
}

void bubble(int work[], const int size,
  int (*compare)(int a, int b)) {
  int pass;
  int count;

  void swap(int *aPtr, int *bPtr);
  for (pass = 1; pass &lt; size; pass++) {
    for (count = 0; count &lt; size - 1; count++) {
      if ((*compare)(work[count], work[count + 1])) {
        swap(&work[count], &work[count + 1]);
      }
    }
  }
}

void swap(int *aPtr, int *bPtr) {
  int hold;
  hold = *aPtr;
  *aPtr = *bPtr;
  *bPtr = hold;
}

int ascending(int a, int b) {
  return a > b;
}

int descending(int a, int b) {
  return b > a;
}
</pre>
  </details>

  <p>В следующей программе используется массив указателей на функцию.</p>

  <details>
    <summary>Программа 59 (301)</summary>
<pre>
#include &lt;stdio.h&gt;

void function1(int);
void function2(int);
void function3(int);

int main() {
  void (*f[3])(int) = {function1, function2, function3};
  int choice;
  puts("Enter number 0, 1, 2 or 3 to end");
  scanf("%d", &choice);

  while (choice >= 0 && choice &lt; 3) {
    (*f[choice])(choice);
    puts("Enter number 0, 1, 2 or 3 to end");
    scanf("%d", &choice);
  }

  puts("The end");

  return 0;
}

void function1(int a) {
  printf("You enter number %d", a);
}

void function2(int b) {
  printf("You enter number %d", b);
}

void function3(int c) {
  printf("You enter number %d", c);
}
</pre>
  </details>
</article>


<!-- 8 Символы и строки в C -->
<article class="article">
  <div class="anchor" id="p8"></div>
  <h3>8 Символы и строки в C (320)</h3>

  <h4>8.1 Введение (321)</h4>

  <p>В этой главе мы познакомимся с функциями стандартных библиотек <strong>ctype, stdio, stdlib, string</strong> для обработки строк и символов.</p>

  <h4>8.2 Элементарные сведения о строках и символах (321)</h4>

  <p>Символы записываются в одинарных кавычках. Строки записываются в двойных кавычках. Строка может быть записана в виде массива символов, который заканчивается символом '\0'. Имя строки это переменная в которую записан адрес на первый символ строки. Сама строка располагается в памяти по адресу, на который указывает имя строки. Доступ к строке осуществляется через указатель на первый символ строки. Строка аналогична массиву. Массив указывает на адрес первого элемента массива.</p>
  <p>Два способа объявить строку: в виде указателя на строку, в виде указателя на массив символов.</p>
  <code>char *sPtr = "string";</code>
  <p>Объявляется переменная sPtr, которая указывает на первый символ строки "string", которая находится в каком-то месте в памяти.</p>
  <code>char s[] = "string";</code>
  <p>Это тоже самое, что и</p>
  <code>char s[] = { 's', 't', 'r', 'i', 'n', 'g', '\0' };</code>
  <p>Объявляется массив s, состоящий из 7 элементов и содержащий символы 's', 't', 'r', 'i', 'n', 'g', '\0'. Переменная s ссылается на первый символ массива, который находится в каком-то месте в памяти.</p>
  <p>Когда нужно использовать функцию scanf() чтобы считать с клавиатуры массив символов или строку, то использовать амперсанд &amp; для взятия адреса переменной не нужно, потому что имя массива или имя строки уже являются указателями на адрес начала массива или строки.</p>
  <code>scanf("%s", s);</code>

  <h4>8.3 Библиотека обработки символов ctype.h (323)</h4>

  <p>Функции из библиотеки обработки символов ctype.h:</p>

  <p>isalnum(), isalpha(), isdigit(), isxdigit(), islower(), isupper(), tolower(), toupper(), isspace(), ispunct(), iscntrl(), isprint(), isgraph()</p>

  <p>Напишем программу, использующую функции isalnum(), isalpha(), isdigit(), isxdigit().</p>

  <details>
    <summary>Программа 60 (324)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

int main() {
  printf("%s\n%s%s\n%s%s\n\n", "isdigit ",
          isdigit('8') ? "8 is " : " 8 is not ", "digit",
          isdigit('#') ? "# is " : " # is not ", "digit");

  printf("%s\n%s%s\n%s%s\n%s%s\n%s%s\n\n", "isalpha ",
          isalpha('A') ? "A is " : " A is not ", "letter",
          isalpha('b') ? "b is " : " b is not ", "letter",
          isalpha('&') ? "& is " : " & is not ", "letter",
          isalpha('4') ? "4 is " : " 4 is not ", "letter");

  printf("%s\n%s%s\n%s%s\n%s%s\n\n", "isalnum ",
          isalnum('A') ? "A is " : " A is not ", "digit or letter",
          isalnum('8') ? "8 is " : " 8 is not ", "digit or letter",
          isalnum('#') ? "# is " : " # is not ", "digit or letter");

  printf("%s\n%s%s\n%s%s\n%s%s\n%s%s\n%s%s\n\n", "isxdigit ",
          isxdigit('F') ? "F is " : " F is not ", "hex digit",
          isxdigit('J') ? "J is " : " J is not ", "hex digit",
          isxdigit('7') ? "7 is " : " 7 is not ", "hex digit",
          isxdigit('$') ? "$ is " : " $ is not ", "hex digit",
          isxdigit('f') ? "f is " : " f is not ", "hex digit");

  return 0;
}
</pre>
  </details>

  <p>Напишем программу, использующую функции islower(), isupper(), tolower(), toupper().</p>

  <details>
    <summary>Программа 61 (326)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

int main() {
  printf("%s\n%s%s\n%s%s\n%s%s\n%s%s\n\n", "islower ",
          islower('y') ? "y is " : " y is not ", "lowercase",
          islower('Y') ? "Y is " : " Y is not ", "lowercase",
          islower('5') ? "5 is " : " 5 is not ", "lowercase",
          islower('!') ? "! is " : " ! is not ", "lowercase");

  printf("%s\n%s%s\n%s%s\n%s%s\n%s%s\n\n", "isupper ",
          isupper('D') ? "D is " : " D is not ", "uppercase",
          isupper('d') ? "d is " : " d is not ", "uppercase",
          isupper('8') ? "8 is " : " 8 is not ", "uppercase",
          isupper('$') ? "$ is " : " $ is not ", "uppercase");

  printf("%s%c\n%s%c\n%s%c\n%s%c\n\n", "toupper ",
          "u to uppercase is ", toupper('u'),
          "7 to uppercase is ", toupper('7'),
          "$ to uppercase is ", toupper('$'));

  printf("%s\n%s%s\n\n", "tolower ",
          "L to lowercase is ", tolower('L'),);

  return 0;
}
</pre>
  </details>

  <p>Напишем программу, использующую функции isspace(), iscntrl(), ispunct(), isprint(), isgraph().</p>

  <details>
    <summary>Программа 62 (327)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

int main() {
  printf("%s\n%s%s%s\n%s%s%s\n%s%s\n\n", "isspace ",
      "Newline", isspace('\n') ? " is " : " is not ", "whitespace",
      "Horiz tab", isspace('\t') ? " is " : " is not ", "whitespace",
      "Whitespace", isspace(' ') ? " is " : " is not ", "whitespace");

  printf("%s\n%s%s%s\n%s%s\n\n", "iscntrl ",
      "Newline", iscntrl('\n') ? " is " : " is not ", "control",
      iscntrl('$') ? "$ is " : "$ is not ", "control");

  printf("%s\n%s%s\n%s%s\n%s%s\n\n", "ispunct ",
      ispunct(';') ? "; is " : "; is not ", "punctuation",
      ispunct('Y') ? "Y is " : "Y is not ", "punctuation",
      ispunct('#') ? "# is " : "# is not ", "punctuation");

  printf("%s\n%s%s\n%s%s%s\n\n", "isprint ",
      isprint('$') ? "$ is " : "$ is not ", "printing",
      "Alert", isprint('\a') ? " is " : " is not ", "printing");

  printf("%s\n%s%s\n%s%s%s\n\n", "isgraph ",
      isgraph('Q') ? "Q is " : "Q is not ", "graph",
      "Space", isgraph(' ') ? " is " : " is not ", "graph");

  return 0;
}
</pre>
  </details>

  <h4>8.4 Функции преобразования строк stdlib.h (329)</h4>

  <p>Функции преобразования строк из библиотеки stdlib.h:</p>

  <p>double atof(), int atoi(), long atol(), double strtod(), long strtol(), unsigned long strtoul().</p>

  <p>Функция atof()</p>

  <details>
    <summary>Программа 63 (329)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
  double d;
  d = atof("99.0");

  printf("%s%.3f\n%s%.3f\n",
    "The string \"99.0\" converted to double is ", d,
    "The converted value divided by 2 is ", d / 2.0);

  return 0;
}
</pre>
  </details>

  <p>Функция atoi()</p>

  <details>
    <summary>Программа 64 (330)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
  int i;
  i = atoi("2593");

  printf("%s%d\n%s%d\n",
    "The string \"2593\" converted to int is ", i,
    "The converted value minus 593 is ", i - 593);

  return 0;
}
</pre>
  </details>

  <p>Функция atol()</p>

  <details>
    <summary>Программа 65 (330)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
  long l;
  l = atol("1000000");

  printf("%s%ld\n%s%ld\n",
    "The string \"1000000\" converted to long is ", l,
    "The converted value divided by 2 is ", l / 2);

  return 0;
}
</pre>
  </details>

  <p>Функция strtod()</p>

  <details>
    <summary>Программа 66 (331)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
  const char *string = "51.2% are admitted";
  double d;
  char *stringPtr;
  d = strtod(string, &stringPtr);

  printf("The string \"%s\" converted to double is ", string,
    "%.2f and the string \"%s\"\n", d, stringPtr);

  return 0;
}
</pre>
  </details>

  <p>Функция strtol()</p>

  <details>
    <summary>Программа 67 (332)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
  const char *string = "-1234567abc";
  char *stringPtr;
  long l;
  l = strtol(string, &stringPtr, 0);

  printf("%s\"%s\"\n%s%ld\n%s\"%s\"\n%s%ld\n",
    "The string is ", string,
    "The converted value is ", l,
    "The remainder is ", stringPtr,
    "The converted value plus 567 is ", l + 567);

  return 0;
}
</pre>
  </details>

  <p>Функция strtoul()</p>

  <details>
    <summary>Программа 68 (332)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
  const char *string = "1234567abc";
  char *stringPtr;
  unsigned long ul;
  ul = strtoul(string, &stringPtr, 0);

  printf("%s\"%s\"\n%s%lu\n%s\"%s\"\n%s%lu\n",
    "The string is ", string,
    "The converted value is ", ul,
    "The remainder is ", stringPtr,
    "The converted value minus 567 is ", ul - 567);

  return 0;
}
</pre>
  </details>

  <h4>8.5 Функции стандартной библиотеки ввода-вывода stdio.h (333)</h4>

  <p>getchar(), gets(), putchar(), puts(), sprintf(), sscanf()</p>

  <p>Функции gets() и putchar().</p>

  <details>
    <summary>Программа 69 (334)</summary>
<pre>
#include &lt;stdio.h&gt;

void reverse(const char * const sPtr);

int main() {
  char sentence[80];
  puts("Enter a line of text: ");
  gets(sentence);
  puts("Text in reverse order: ");
  reverse(sentence);

  return 0;
}

void reverse(const char * const sPtr) {
  if (sPtr[0] == '\0') {
    return;
  } else {
    reverse(&sPtr[1]);
    putchar(sPtr[0]);
  }
}
</pre>
  </details>

  <p>Функции puts() и getchar().</p>

  <details>
    <summary>Программа 70 (335)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char c;
  char sentence[80];
  int i = 0;
  puts("Enter a line of text: ");

  while ( (c == getchar()) != '\n') {
    sentence[i++] = c;
  }

  sentence[i] = '\0';

  puts("The line entered was: ");
  puts(sentence);

  return 0;
}
</pre>
  </details>

  <p>Функция sprintf().</p>

  <details>
    <summary>Программа 71 (336)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char s[80];
  int x;
  double y;

  puts("Enter int and double: ");
  scanf("%d%lf", &x, &y);

  sprintf(s, "integer: %6d\ndouble: %8.2f", x, y);

  printf("%s\n%s\n", "Array s is: ", s);

  return 0;
}
</pre>
  </details>

  <p>Функция sscanf().</p>

  <details>
    <summary>Программа 72 (337)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char s[] = "31298 87.375";
  int x;
  double y;

  sscanf(s, "%d%lf", &x, &y);

  printf("%s\n%s%6d\n%s%8.3f\n", "Values in array s are: ",
         "integer: ", x, "double: ", y);

  return 0;
}
</pre>
  </details>

  <h4>8.6 Функции операций над строками из библиотеки обработки строк string (337)</h4>

  <p>strcpy(), strncpy(), strcft(), strncat()</p>

  <p>size_t это тип данных, который возвращает оператор sizeof. Тип size_t это системно-зависимый синоним либо для unsigned int, либо unsigned long.</p>

  <p>Функции strcpy(), strncpy().</p>

  <details>
    <summary>Программа 73 (338)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
  char x[] = "Happy birthday to You";
  char y[25];
  char z[15];

  printf("%s%s\n%s%s\n",
         "The string in array x is: ", x,
         "The string in array y is: ", strcpy(y, x));
  strncpy(z, x, 14);
  z[14] = '\0';

  printf("The string in array z is: %s\n", z);

  return 0;
}
</pre>
  </details>

  <p>Функции strcat(), strncat().</p>

  <details>
    <summary>Программа 74 (339)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
  char s1[20] = "Happy ";
  char s2[] = "New Year ";
  char s3[40] = "";

  printf("s1 = %s\ns2 = %s\n", s1, s2);
  printf("strcat(s1, s2) = %s\n", strcat(s1, s2));
  printf("strncat(s3, s1, 6) = %s\n", strncat(s3, s1, 6));
  printf("strcat(s3, s1) = %s\n", strcat(s3, s1));

  return 0;
}
</pre>
  </details>

  <h4>8.7 Функции сравнения из библиотеки обработки строк string.h (340)</h4>

  <p>Функции strcmp(), strncmp().</p>

  <p>Когда компьютер сравнивает две строки, он сравнивает числовые коды символов этих строк.</p>

  <details>
    <summary>Программа 75 (341)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
  const char *s1 = "Happy New Year";
  const char *s2 = "Happy New Year";
  const char *s2 = "Happy Holidays";

  printf("%s%s\n%s%s\n%s%s\n\n%s%2d\n%s%2d\n%s%2d\n\n",
         "s1 = ", s1, "s2 = ", s2, "s3 = ", s3,
         "strcmp(s1, s2) = ", strcmp(s1, s2),
         "strcmp(s1, s3) = ", strcmp(s1, s3),
         "strcmp(s3, s1) = ", strcmp(s3, s1));

  printf("%s%2d\n%s%2d\n%s%2d\n\n",
         "strncmp(s1, s3, 6) = ", strncmp(s1, s3, 6),
         "strncmp(s1, s3, 7) = ", strncmp(s1, s3, 7),
         "strncmp(s3, s1, 7) = ", strncmp(s3, s1, 7));

  return 0;
}
</pre>
  </details>

  <h4>8.8 Функции поиска из библиотеки обработки строк string.h (342)</h4>

  <p>strchr(), strcspn(), strspn(), strprbk(), strrchr(), strstr(), strtok()</p>

  <p>Функция strchr()</p>

  <details>
    <summary>Программа 76 (343)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
  const char *s = "This is a test";
  char c1 = 'a';
  char c2 = 'z';

  if (strchr(s, c1) != NULL) {
    printf("\'%c\' was found in \"%s\"\n", c1, s);
  } else {
    printf("\'%c\' was not found in \"%s\"\n", c1, s);
  }

  if (strchr(s, c2) != NULL) {
    printf("\'%c\' was found in \"%s\"\n", c2, s);
  } else {
    printf("\'%c\' was not found in \"%s\"\n", c2, s);
  }

  return 0;
}
</pre>
  </details>

  <p>Функция strcspn()</p>

  <details>
    <summary>Программа 77 (344)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
  const char *s1 = "This value is 3.14159";
  const char *s2 = "1234567890";

  printf("%s%s\n%s%s\n\n%n%s%u",
         "s1 = ", s1, "s2 = ", s2,
         "length of s1 without char in s2 = ", strcspn(s1, s2));

  return 0;
}
</pre>
  </details>

  <p>Функция strpbrk()</p>

  <details>
    <summary>Программа 78 (344)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
  const char *s1 = "This is a test";
  const char *s2 = "beware";

  printf("%s\"%s\"\n'%c'%s\n\"%s\"\n",
         "Of the characters in ", s2,
         *strpbrk(s1, s2), " appears earliest in ", s1);

  return 0;
}
</pre>
  </details>

  <p>Функция strrchr()</p>

  <details>
    <summary>Программа 79 (345)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
  const char *s1 = "A zoo has many zebras";
  int c = "z";

  printf("%s\n%s'%c'%s\"%s\"\n",
         "Last character ", c,
         " is ", strrchr(s1, c));

  return 0;
}
</pre>
  </details>

  <p>Функция strspn()</p>

  <details>
    <summary>Программа 80 (345)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
  const char *s1 = "This value is 3.14159";
  const char *s2 = "aehi lsTuv";

  printf("%s%s\n%s%s\n\n%s\n%s%u\n",
         "s1 = ", s1, "s2 = ", s2,
         "The length s1 contains only chars of s2 is ", strspn(s1, s2));

  return 0;
}
</pre>
  </details>

  <p>Функция strstr()</p>

  <details>
    <summary>Программа 81 (346)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
  const char *s1 = "abcdefabcdef";
  const char *s2 = "def";

  printf("%s%s\n%s%s\n\n%s\n%s%s\n",
         "s1 = ", s1, "s2 = ", s2,
         "The remainder s1 beginning with s2 is ", strstr(s1, s2));

  return 0;
}
</pre>
  </details>

  <p>Функция strtok()</p>

  <details>
    <summary>Программа 82 (347)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
  char s = "This is a sentence with 7 tokens";
  char *tokenPtr;

  printf("%s\n%s\n\n%s\n",
         "s = ", s, "The tokens are: ");

  tokenPtr = strtok(s, " ");

  while (tokenPtr != NULL) {
    printf("%s\n", tokenPtr);
    tokenPtr = strtok(NULL, " ");
  }

  return 0;
}
</pre>
  </details>

  <h4>8.9 Функции памяти из библиотеки обработки строк string.h (348)</h4>

  <p>memcpy(), memmove(), memcmp(), memchr(), memset()</p>

  <p>Эти функции обращаются с блоками памяти как с массивами символов и могут оперировать с любыми блоками данных.</p>

  <p>Функция memcpy() копирует заданное число символов из объекта, на который ссылается ее второй аргумент, в объект, на который ссылается первый аргумент. Если два объекта перекрываются в памяти, то поведение функции не определено.</p>

  <details>
    <summary>Программа 83 (349)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
  char s1[17];
  char s2[] = "Copy this string";

  memcpy(s1, s2, 17);
  printf("%s\n%s\"%s\"\n",
         "s2 copied in s1 = ",
         "s1 contains ", s1);

  return 0;
}
</pre>
  </details>

  <p>Функция memmove() сначала копирует заданное число байтов из объекта, на который ссылается ее второй аргумент, во временный символьный массив. Затем копирует этот массив в объект, на который ссылается первый аргумент. Это позволяет копировать символы даже если два объекта перекрываются в памяти. Так копируются символы внутри одной строки или массива.</p>

  <details>
    <summary>Программа 84 (350)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
  char s[] = "Home Sweet Home";

  printf("%s%s\n", "string befor memmove = ", s);
  printf("%s%s\n", "string after memmove = ", memmove(s, &s[5], 10));

  return 0;
}
</pre>
  </details>

  <p>Функция memcmp() сравнивает заданное число символов первого аргумента с соответствующими символами второго аргумента.</p>

  <details>
    <summary>Программа 85 (350)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
  char s1[] = "ABCDEFG";
  char s2[] = "ABCDXYZ";

  printf("%s%s\n%s%s\n\n%s%2d\n%s%2d\n%s%2d\n",
         "s1 = ", s1, "s2 = ", s2,
         "memcmp(s1, s2, 4) = ", memcmp(s1, s2, 4),
         "memcmp(s1, s2, 7) = ", memcmp(s1, s2, 7),
         "memcmp(s2, s1, 7) = ", memcmp(s2, s1, 7));

  return 0;
}
</pre>
  </details>

  <p>Функция memchr() выполняет поиск байта и возвращает указатель на найденный байт.</p>

  <details>
    <summary>Программа 86 (351)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
  char *s1 = "This is a string";

  printf("%s\'%c\'%s\"%s\"\n",
         "The reminder of s after character  ", 'r',
         "is found is ", memchr(s, 'r', 16));

  return 0;
}
</pre>
  </details>

  <p>Функция memset() копирует значение байта второго аргумента в заданное число байтов объекта, на который указывает первый аргумент.</p>

  <details>
    <summary>Программа 87 (351)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
  char s[15] = "BBBBBBBBBBBBB";

  printf("s = %s\n", s);
  printf("s after memset = %s\n", memset(s, 'b', 7));

  return 0;
}
</pre>
  </details>

  <h4>8.10 Другие функции из библиотеки обработки строк string.h (352)</h4>

  <p>strerror(), strlen()</p>

  <p>Функция strerror() принимает номер ошибки и создает строку сообщения об ошибке.</p>

  <details>
    <summary>Программа 88 (352)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
  printf("%s\n", strerror(2));

  return 0;
}
</pre>
  </details>

  <p>Функция strlen() принимает строку и возвращает число символов в строке не включая последний символ '\0'.</p>

  <details>
    <summary>Программа 89 (352)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
  const char *s1 = "abcdefghijklmn";
  const char *s2 = "four";
  const char *s3 = "Boston";

  printf("s1 = %s, length = %lu\n", s1, (unsigned long) strlen(s1));
  printf("s2 = %s, length = %lu\n", s2, (unsigned long) strlen(s2));
  printf("s3 = %s, length = %lu\n", s3, (unsigned long) strlen(s3));

  return 0;
}
</pre>
  </details>
</article>


<!-- 9 Форматированный ввод/вывод в C -->
<article class="article">
  <div class="anchor" id="p9"></div>
  <h3>9 Форматированный ввод/вывод в C (364)</h3>

  <h4>9.1 Введение (365)</h4>

  <p>6 функций работают со страндартными потоками ввода-вывода: <strong>printf(), scanf(), puts(), gets(), putchar(), getchar()</strong>. Форматированный вывод только у функции <strong>printf()</strong>. Форматированный ввод только у функции <strong>scanf()</strong>. Вывод строки <strong>puts()</strong>. Ввод строки <strong>gets()</strong>. Вывод символа <strong>putchar()</strong>. Ввод символа <strong>getchar()</strong>.</p>

  <h4>9.2 Потоки (365)</h4>

  <p>Весь ввод и вывод выполняется посредством потоков - последовательностей символов с построчной огранизацией. Каждая строка заканчивается символом новой строки. Стандарт языка поддерживает строки длиной 254 символа, включая символ новой строки.</p>
  <p>При запуске программы к ней автоматически присодиняются три потока. <strong>Стандартный поток ввода</strong> обычно присоединяется к клавиатуре. <strong>Стандартный поток вывода</strong> - к экрану монитора. <strong>Стандартный поток ошибок</strong> - к экрану монитора. Операционные системы позволяют переадресовать эти потоки на другие устройства.</p>

  <h4>9.3 Форматированный вывод функцией printf() (366)</h4>

  <p>Функция printf() первым аргументом принимает <strong>строку управления форматом</strong>. <strong>Строка управления форматом</strong> содержит спецификаторы преобразования, флаги, ширину полей, точность и литеральные символы.</p>

  <h4>9.4 Печать целых чисел (366)</h4>

  <p>Целые числа не содержат десятичную точку.</p>
  <p>Спецификаторы для целых чисел:</p>
  <ol>
    <li>d целое десятичное число со знаком</li>
    <li>i целое десятичное число со знаком</li>
    <li>u целое десятичное число без знака</li>
    <li>o целое восьмеричное число без знака</li>
    <li>x целое шестнадцатеричное число без знака, с маленькими a-f</li>
    <li>X целое шестнадцатеричное число без знака, с большими A-F</li>
  </ol>
  <p>Отличие между d и i проявляется в функции scanf().</p>
  <p>Перед спецификатором может стоять модификатор длины.</p>
  <p>Модификаторы длины:</p>
  <ol>
    <li>h для типа short</li>
    <li>l для типа long</li>
  </ol>

  <details>
    <summary>Программа 90 (367)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  printf("d 455 = %d\n", 455);
  printf("i 455 = %i\n", 455);
  printf("d +455 = %d\n", +455);
  printf("d -455 %d\n", -455);
  printf("hd 32000 %hd\n", 32000);
  printf("ld 2000000000 %ld\n", 2000000000);
  printf("o 455 %o\n", 455);
  printf("u 455 %u\n", 455);
  printf("u -455 %u\n", -455);
  printf("x 455 %x\n", 455);
  printf("X 455 %X\n", 455);

  return 0;
}
</pre>
  </details>

  <h4>9.5 Печать чисел с плавающей точкой (368)</h4>

  <p>Числа с плавающей точкой содержат десятичную точку.</p>
  <p>Спецификаторы для чисел с плавающей точкой:</p>
  <ol>
    <li>f число с плавающй точкой</li>
    <li>e число в экспоненциальной нотации, с маленькой e</li>
    <li>E число в экспоненциальной нотации, с большой E</li>
    <li>g число в формате f или e</li>
    <li>G число в формате f или E</li>
  </ol>
  <p>Перед спецификатором может стоять модификатор длины.</p>
  <p>Модификаторы длины:</p>
  <ol>
    <li>L для типа long double</li>
  </ol>
  <p>Спецификаторы e, E, f по умолчанию выводят 6 разрядов после точки.</p>
  <p>Спецификаторы g, G выводят число в формате f, но нули справа в дробной части не печатаются. Если значение экспоненты меньше -4 или значение экспоненты равно заданной точности представления (по умолчанию 6 значащих цифр), то выводится число в формате e, E.</p>
  <p>При выводе данных, форматирование может давать неточные данные, связанные с округлением числа до заданной точности.</p>

  <details>
    <summary>Программа 91 (369)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  printf("e 1234567.89 = %e\n", 1234567.89);
  printf("e +1234567.89 = %e\n", +1234567.89);
  printf("e -1234567.89 = %e\n", -1234567.89);
  printf("E 1234567.89 = %E\n", 1234567.89);
  printf("f 1234567.89 = %f\n", 1234567.89);
  printf("g 1234567.89 = %g\n", 1234567.89);
  printf("G 1234567.89 = %G\n", 1234567.89);

  return 0;
}
</pre>
  </details>

  <h4>9.6 Печать строк и символов (370)</h4>

  <p>Для спецификатора <strong>c</strong> требуется аргумент <strong>char</strong>. Для спецификатора <strong>s</strong> требуется аргумент указатель на <strong>char</strong>. Спецификатор преобразования s выводит символы до тех пор, пока не встретит символ '\0'.</p>

  <p>Печать строк и символов</p>

  <details>
    <summary>Программа 92 (370)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char c = 'A';
  char s[] = "string";
  const char *sPtr = "string2";

  printf("%c\n", c);
  printf("%s\n", "this string");
  printf("%s\n", s);
  printf("%s\n", sPtr);

  return 0;
}
</pre>
  </details>

  <h4>9.7 Другие спецификаторы преобразования (371)</h4>

  <p>Рассмотрим три оставшихся спецификатора</p>
  <ol>
    <li>p - выводит указатель. В зависимости от операционной системы в десятичном или шестнадцатеричном виде.</li>
    <li>n - ничего не выводит. Аргумент для него - целая переменная, сохранающая в себе количество уже выведенных символов оператором printf.</li>
    <li>% - выводит знак процента</li>
  </ol>
  <p>Функция printf() возвращает число выведенных символов или -1 если произошла ошибка.</p>
  <p>Использование спецификаторов p, n и %.</p>

  <details>
    <summary>Программа 93 (372)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int *ptr;
  int x = 12345;
  int y;
  ptr = &amp;x;

  printf("ptr = %p\n", ptr);
  printf("address x = %p\n", &x);
  printf("total characters in the line %n", &y);
  printf("%d\n", y);

  y = printf("this line\n");
  printf("%d characters were printed\n", y);
  printf("printing %% in format line\n");

  return 0;
}
</pre>
  </details>

  <h4>9.8 Печать с заданием ширины поля и точности (372)</h4>

  <p><strong>Ширина поля</strong> может использоваться со всеми спецификаторами и задается целым числом между знаком процента и спецификатором.</p>
  <p>Если ширина поля это положительное число, то число при печати выравнивается по правому краю. Если отрицательное - то по левому.</p>
  <p>Печать целых с выравниванием вправо.</p>

  <details>
    <summary>Программа 94 (373)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  printf("%4d\n", 1);
  printf("%4d\n", 12);
  printf("%4d\n", 123);
  printf("%4d\n", 1234);
  printf("%4d\n", 12345);

  printf("%4d\n", -1);
  printf("%4d\n", -12);
  printf("%4d\n", -123);
  printf("%4d\n", -1234);
  printf("%4d\n", -12345);

  return 0;
}
</pre>
  </details>

  <p><strong>Точность представления</strong> задается целым числом, записанным после знака процента, между точной и спецификатором. Точность представления может быть только положительным числом.</p>
  <p><strong>Точность представления</strong> для целых чисел показывает минимальное количество цифр, которое должно быть выведено. Если целое число содержит меньше цифр, то перед ним будут выведены префиксные нули. Для целых чисел точность по умолчанию равна 1.</p>
  <p>Для спецификаторов g и G это максимальное количество значащих цифр. Для спецификаторов e, E, f это количество цифр после десятичной точки. Для спецификатора s это максимальное количество символов строки, которое будет напечатано.</p>
  <p>Если точность числа с плавающей точкой меньше исходной точности, то при печати происходит округление.</p>
  <p>Использование точности</p>

  <details>
    <summary>Программа 95 (374)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int i = 873;
  double f = 123.94536;
  char s[] = "Happy Birthday";

  puts("precision for integers");
  printf("\t%.4d\n\t%9d\n\n", i, i);

  puts("precision for float");
  printf("\t%.3f\n\t%.3e\n\t%.3g\n\n", f, f, f);

  puts("precision for string");
  printf("\t%.11s\n", s);

  return 0;
}
</pre>
  </details>

  <p>Ширину поля и точность также можено задать в списке аргументов. Для этого в строке управления форматом нужно поставить на их месте звездочки *. Звездочки при мечати будут заменены соответствующими значениями из списка аргументов.</p>
  <code>printf("%*.*f", 7, 2, 98.736); // 98.74</code>

  <h4>9.9 Использование флагов в строке управления форматом printf() (375)</h4>

  <p>В строке управления форматом можно использовать пять флагов</p>
  <ul>
    <li>- выравнивание по левому краю в пределах заданной ширины поля</li>
    <li>+ вывод знака плюс перед положительными числами и знака минус перед отрицательными</li>
    <li>пробел - вывод пробела перед положительными числами при отсутствии флага +</li>
    <li># - печать префикса 0, при спецификаторе восьмеричных значений o.</li>
    <li># - печать префикса 0x или 0X при спецификаторе шестнадцатеричных значений x или X</li>
    <li># - печать десятичной точки для чисел без дробной части при спецификаторах e, E, f, g, G. Отменяет подавление правых нулей дробной части для спецификаторов g и G</li>
    <li>0 - дополняет поле до заданной ширины нулями слева</li>
  </ul>

  <p>Флаг ставится сразу после знака процента. Флагов может быть несколько или не быть вовсе.</p>
  <p>Выравнивание значений по правому и левому полю</p>

  <details>
    <summary>Программа 96 (376)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  printf("%10s%10d%10c%10f\n\n", "hello", 7, 'a', 1.23);
  printf("%-10s%-10d%-10c%-10f\n\n", "hello", 7, 'a', 1.23);

  return 0;
}
</pre>
  </details>

  <p>Печать чисел с флагом + и без него.</p>

  <details>
    <summary>Программа 97 (376)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  printf("%d\n%d\n", 786, -786);
  printf("%+d\n%+d\n", 786, -786);

  return 0;
}
</pre>
  </details>

  <p>Печать пробела перед значениями со знаком, которым не предшествует знак + или -</p>

  <details>
    <summary>Программа 98 (376)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  printf("% d\n% d\n", 547, -547);

  return 0;
}
</pre>
  </details>

  <p>Использование флага # со спецификаторами o, x, X, g</p>

  <details>
    <summary>Программа 99 (377)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int c = 1427;
  double p = 1427.0;

  printf("%#o\n", c);
  printf("%#x\n", c);
  printf("%#X\n", c);
  printf("%g\n", p);
  printf("%#g\n", p);

  return 0;
}
</pre>
  </details>

  <p>Печать с флагом 0 заполняет поле ведущими нулями</p>

  <details>
    <summary>Программа 100 (377)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  printf("%+09d\n", 452);
  printf("%09d\n", 452);

  return 0;
}
</pre>
  </details>

  <h4>9.10 Печать литералов и esc-последовательностей (378)</h4>

  <p>Большинство литералов можно распечатать прямо в управляющей строке. Но есть символы, которые печатаются только с помощью esc-последовательности. esc-последовательность это обратный слеш с последующим esc-символом. Всего есть 11 esc-последовательностей</p>
  <ol>
    <li>\' одинарная кавычка</li>
    <li>\" двойная кавычка</li>
    <li>\? знак вопроса</li>
    <li>\\ обратный слеш</li>
    <li>\a предупреждение в виде звукового сигнала</li>
    <li>\b вернуть курсор на одну позицию назад</li>
    <li>\f переместить курсор на начало следующей страницы</li>
    <li>\n переместить курсор на начало новой строки</li>
    <li>\r переместить курсор на начало текущей строки</li>
    <li>\t горизонтальная табуляция</li>
    <li>\v вертикальная табуляция</li>
  </ol>

  <h4>9.11 Форматированный ввод функцией scanf() (378)</h4>

  <p>Функция scanf() может выполнить</p>
  <ol>
    <li>Ввод всех типов данных</li>
    <li>Ввод определенных символов из входного потока</li>
    <li>Пропуск определенных символов из входного потока</li>
  </ol>
  <p>Фнкция sacanf() принимает в качестве первого аргумента строку управления форматом, в качестве остальных аргументов - указатели, в которых сохраняются введенные данные.</p>

  <p>Спецификаторы для функции scanf()</p>
  <ol>
    <li>d - десятичное целое число</li>
    <li>i - десятичное, восьмеричное или шестнадцатеричное целое число</li>
    <li>o - восьмеричное целое число без знака</li>
    <li>u - десятичное целое число без знака</li>
    <li>x или X - шестнадцатеричное целое число без знака</li>
    <li>h или l - short или long, ставится перед любым спецификатором целых чисел</li>
    <li>e, E, f, g, G - число с плавающей точкой</li>
    <li>l или L - double или long double, ставится перед любым спецификатором чисел с плавающей точкой</li>
    <li>c - символ</li>
    <li>s - строка, указатель на массив символов</li>
    <li>[символы] - ввод символов, входящих в набор</li>
    <li>p - адрес</li>
    <li>n - сохранить число символов, введенных до этого момента функцией scanf, в целой переменной</li>
    <li>% - пропустить при вводе знак процента</li>
  </ol>

  <p>Чтение целых</p>

  <details>
    <summary>Программа 101 (380)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int a, b, c, d, e, f, g;

  puts("Enter 7 integers ");
  scanf("%d%i%i%i%o%u%x", &a, &b, &c, &d, &e, &f, &g);

  puts("7 integers as decimal is ");
  printf("%d %d %d %d %d %d %d\n", a, b, c, d, e, f, g);

  return 0;
}
</pre>
  </details>

  <p>Чтение чисел с плавающей точкой</p>

  <details>
    <summary>Программа 102 (381)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  double a, b, c;

  puts("Enter 3 double ");
  scanf("%le%lf%lg", &a, &b, &c);

  puts("3 double is ");
  printf("%f\n%f\n%f\n", a, b, c);

  return 0;
}
</pre>
  </details>

  <p>Чтение символов и строк</p>

  <details>
    <summary>Программа 103 (381)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char x;
  char y[9];

  puts("Enter a string less 9 chars ");
  scanf("%c%s", &x, y);

  puts("string is  ");
  printf("%c", x);
  printf("%s", y);

  return 0;
}
</pre>
  </details>

  <p>Использование сканирующего набора. Из входного потока выбирают только те символы, которые есть в наборе сканирования. Если символ есть в наборе сканирования, то он записывается в массив символов. Если символя нет в наборе сканирования, то в массив записывается символ '\0' и ввод прекращается.</p>

  <details>
    <summary>Программа 104 (382)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char z[9];

  puts("Enter a string less 9 chars ");
  scanf("%[aeiou]", z);

  puts("string is  ");
  printf("%s", z);

  return 0;
}
</pre>
  </details>

  <p>Инвертированный набор сканирования будет выбирать из входного потока только те символы, которых нет в наборе сканирования. Чтобы инвертировать набор сканирования нужно поместить ^ знак перед первым символом набора.</p>

  <details>
    <summary>Программа 105 (383)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char z[9];

  puts("Enter a string less 9 chars ");
  scanf("%[^aeiou]", z);

  puts("string is  ");
  printf("%s", z);

  return 0;
}
</pre>
  </details>

  <p>Ввод данных с шириной поля</p>

  <details>
    <summary>Программа 106 (384)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int x, y;

  puts("Enter 6 digit integer ");
  scanf("%2d%d", &x, &y);

  puts("integers is  ");
  printf("%d %d", x, y);

  return 0;
}
</pre>
  </details>

  <p>Чтение и отбрасывание символов из входного потока</p>

  <details>
    <summary>Программа 107 (384)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int m1, d1, y1, m2, d2, y2;

  puts("Enter date in mm-dd-yyyy format ");
  scanf("%d%*c%d%*c%d", &m1, &d1, &y1);
  printf("month = %d day = %d year = %d", m1, d1, y1);

  puts("Enter date in mm/dd/yyyy format ");
  scanf("%d%*c%d%*c%d", &m2, &d2, &y2);
  printf("month = %d day = %d year = %d", m2, d2, y2);

  return 0;
}
</pre>
  </details>
</article>


<!-- 10 Структуры, объединения, перечисления и операции с битами в C -->
<article class="article">
  <div class="anchor" id="p10"></div>
  <h3>10 Структуры, объединения, перечисления и операции с битами в C (392)</h3>

  <h4>10.1 Введение(393)</h4>

  <p>Структуры - это наборы логически связанных переменных, объединенных под одним именем. Могут содержать переменные разных типов данных. В отличие от массивов, которые содержат переменные одного типа данных.</p>

  <h4>10.2 Определение структур (393)</h4>

  <p>Элемент структуры не может быть того же типа, что и сама структура. Однако элемент может быть указателем на тип самой структуры.</p>
  <p>Определение структуры не резервирует место под элементы структуры в памяти. Определение просто создает новый тип данных.</p>
  <p>Переменные структуры объявляются так же как переменные других типов.</p>
<pre>
struct card {
  char name[20];
  int age;
};

struct card man, people[30], *manPtr;
</pre>
  <p>Переменные структуры можно объявить в месте определения структуры</p>
<pre>
struct card {
  char name[20];
  int age;
} man, people[30], *manPtr;
</pre>
  <p>Имя структуры не является обязательным. Если у структуры нет имени, то переменные для этой структуры можно объявить только в месте ее определения.</p>
<pre>
struct {
  char name[20];
  int age;
} man, people[30], *manPtr;
</pre>
  <p>Нельзя сравнивать структуры операциями == или !=, поскольку элементы структуры не обязательно хранятся в последовательных байтах памяти. Способ хранения информации требует, чтобы каждая переменная хранилась на границе слова или двойного слова. Поэтому в памяти могут быть "дыры".</p>
  <p>По этой же причине размер структуры не равен сумме размеров ее элементов. Память которую занимает структура можно определить оператором sizeof().</p>

  <h4>10.3 Инициализация структур (396)</h4>

  <p>Структуры можно инициализировать как массивы, указывая список инициализации.</p>
  <code>struct card man = {"Donald", 35};</code>
  <p>Структуры можно инициализировать с помощью оператора присваивания, присваивая переменной структуры переменную того же типа.</p>
  <code>struct card man2 = man;</code>
  <p>Структуры можно инициализировать присваивая значения полям структуры</p>
  <code>struct card man3; man3.name = "Kit"; man3.age = 30;</code>

  <h4>10.4 Доступ к элементам структур (396)</h4>

  <p>Для обращения к элементам структуры используются две операции:</p>
  <ol>
    <li>Операция элемента структуры (. точка). Обращается к элементу через имя структуры
      <code>man.name</code>
    </li>
    <li>Операция указателя структуры (-> стрелка). Обращается к элементы через указатель структуры. Указатель содержит адрес структуры в памяти
      <code>manPtr->name</code>
    </li>
  </ol>
  <p>Выражение manPtr->name эквивалентно (*manPtr).name</p>
  <p>Использование операций элемента структуры и указателя структуры</p>

  <details>
    <summary>Программа 108 (397)</summary>
<pre>
#include &lt;stdio.h&gt;

struct card {
  char *face;
  char *suit;
};

int main() {
  struct card aCard;
  struct card *cardPtr;

  aCard.face = "Ace";
  aCard.suit = "Spades";
  cardPtr = &amp;aCard;

  printf("aCard.face = ", aCard.face);
  printf("aCard.suit = ", aCard.suit);
  printf("cardPtr->face = ", cardPtr->face);
  printf("cardPtr->suit = ", cardPtr->suit);

  return 0;
}
</pre>
  </details>

  <h4>10.5 Использование структур с функциями (398)</h4>

  <p>В функцию можно передавать структуру или элементы структуры. При этом происходит передача по значению. Такая функция не сможет изменить структуру или элементы в ней.</p>
  <p>В функцию можно передать указатель на структуру (ее адрес). При этом происходит передача по ссылке. Массивы структур, как и все массивы, автоматически передаются по ссылке.</p>
  <p>Есть способ передать в функцию массив по значению. Для этого нужно создать структуру и сделать элементом структуры этот массив. Передать структуру в функцию. Структура со всеми ее элементами передается в функцию по значению.</p>
  <p>Передача структуры по ссылке более эффективна, чем передача по значению (при которой происходит копирование всей структуры целиком)</p>

  <h4>10.6 Ключевое слово typedef (398)</h4>

  <p>Можно дать новое короткое имя для типа данных структуры после ее определения</p>
  <code>typedef struct card Card;</code>
  <p>Можно дать новое имя типу данных структуры во время ее определения. При этом имя самой структуре можно не указывать</p>
<pre>
typedef struct {
  char *face;
  char *suit;
} Card;
</pre>

  <h4>10.7 Пример: моделирование высокоэффективного тасования и сдачи карт (399)</h4>

  <p>Программа тасования и сдачи карт, использующая структуры</p>

  <details>
    <summary>Программа 109 (399)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

struct card {
  char *face;
  char *suit;
};

typedef struct card Card;

void fillDeck(Card* const wDeck,
  const char* wFace[],
  const char* wSuit[]);
void shuffle(Card* const wDeck);
void deal(const Card* const wDeck);

int main() {
  Card deck[52];
  const char *face[] = {
    "Ace", "Deuce", "Three", "Four",
    "Five", "Six", "Seven", "Eight",
    "Nine", "Ten", "Jack", "Queen", "King"};
  const char *suit[] = {"Hearts", "Diamonds", "Clubs", "Spades"};
  srand(time(NULL));

  fillDeck(deck, face, suit);
  shuffle(deck);
  deal(deck);

  return 0;
}

void fillDeck(Card* const wDeck,
  const char* wFace[],
  const char* wSuit[]) {
  for (int i = 0; i &lt; 52; i++) {
    wDeck[i].face = wFace[i % 13];
    wDeck[i].suit = wSuit[i % 13];
  }
}

void shuffle(Card* const wDeck) {
  Card temp;
  int j;
  for (int i = 0; i &lt; 52; i++) {
    j = rand() % 52;
    temp = wDeck[i];
    wDeck[i] = wDeck[j];
    wDeck[j] = temp;
  }
}

void deal(const Card* const wDeck) {
  for (int i = 0; i &lt; 52; i++) {
    printf("%5s of %-8s%c", wDeck[i].face,
    wDeck[i].suit, (i + 1) % 2 ? '\t' : '\n');
  }
}
</pre>
  </details>

  <h4>10.8 Объединения (402)</h4>

  <p>Объединение - производный тип данных, подобный структуре, элементы которого разделяют одну и ту же область памяти. Памяти для объединения должно быть достаточно для хранения наибольшего из его элементов. Элементы объединения могут принадлежать любому типу. В разных местах программы используется только одна из переменных объединения.</p>
<pre>
union number {
  int x;
  float y;
};
</pre>
  <p>Объявление union, как и объявление struct, просто создает новый тип и не выделяет место в памяти для переменной.</p>
  <p>При объявлении объединение можно инициализировать только значениями того же типа, что и его первый элемент.</p>
  <code>union number value = {10};</code>
  <p>Объединения позволяют сэкономить память.</p>
  <p>Объявим переменную value типа union number и будем отображать значение переменной и как типа int и как типа double.</p>

  <details>
    <summary>Программа 110 (403)</summary>
<pre>
#include &lt;stdio.h&gt;

union number {
  int x;
  double y;
};

int main() {
  union number value;

  value.x = 100;
  puts("put integer value");
  printf("value.x = %d", value.x);
  printf("value.y = %f", value.y);

  value.y = 100.0;
  puts("put double value");
  printf("value.x = %d", value.x);
  printf("value.y = %f", value.y);

  return 0;
}
</pre>
  </details>

  <h4>10.9 Порязрядные операции (404)</h4>

  <p>Поразрядные операции используются для операций над битами целочисленных операндов. Обычно это беззнаковые числа.</p>
  <ol>
    <li>& порязрядное И</li>
    <li>| поразрядное ИЛИ</li>
    <li>^ поразрадное исключающее ИЛИ</li>
    <li>~ поразрядное НЕ (дополнение)</li>
    <li>&lt;&lt; сдвиг влево</li>
    <li>&gt;&gt; сдвиг вправо</li>
  </ol>
  <p>Печать битов беззнакового целого значения</p>

  <details>
    <summary>Программа 111 (405)</summary>
<pre>
#include &lt;stdio.h&gt;

void displayBits(unsigned);

int main() {
  unsigned x;
  puts("Enter unsigned integer");
  scanf("%u", &x);

  displayBits(x);

  return 0;
}

void displayBits(unsigned value) {
  unsigned mask = 1 &lt&lt 31;
  printf("%10u = ", value);

  for (int i = 1; i &lt;= 32; i++) {
    putchar(value & mask ? '1' : '0');
    value &lt;&lt; 1;
    if (i % 8 == 0) {
      putchar(' ');
    }
  }

  putchar('\n');
}
</pre>
  </details>

  <p>Маска нужна для того чтобы спрятать определенные биты числа</p>
  <code>mask = 1 &lt&lt 31;</code>
  <code>10000000 00000000 00000000 00000000</code>
  <p>Когда мы применяем операцию value & mask, все биты value кроме старшего становятся "замаскированными" (скрытыми).</p>
  <p>Использование операций порязрядного И, поразрядного ИЛИ, поразрядного исключающего ИЛИ, порязрядного НЕ.</p>

  <details>
    <summary>Программа 112 (407)</summary>
<pre>
#include &lt;stdio.h&gt;

void displayBits(unsigned);

int main() {
  unsigned n1;
  unsigned n2;
  unsigned mask;
  unsigned setBits;

  // поразрядное И
  n1 = 65535;
  mask = 1;
  puts("result of &");
  displayBits(n1);
  displayBits(mask);
  displayBits(n1 & mask);

  // поразрядное ИЛИ
  n1 = 15;
  setBits = 241;
  puts("result of |");
  displayBits(n1);
  displayBits(setBits);
  displayBits(n1 | setBits);

  // поразрядное исключающее ИЛИ
  n1 = 139;
  n2 = 199;
  puts("result of ^");
  displayBits(n1);
  displayBits(n2);
  displayBits(n1 ^ n2);

  // поразрядное НЕ
  n1 = 21845;
  puts("result of ~");
  displayBits(n1);
  displayBits(~n1);

  return 0;
}

void displayBits(unsigned value) {
  unsigned mask = 1 &lt&lt 31;
  printf("%10u = ", value);

  for (int i = 1; i &lt;= 32; i++) {
    putchar(value & mask ? '1' : '0');
    value &lt;&lt; 1;
    if (i % 8 == 0) {
      putchar(' ');
    }
  }

  putchar('\n');
}
</pre>
  </details>

  <p>Использование операций поразрядного сдвига</p>

  <details>
    <summary>Программа 113 (410)</summary>
<pre>
#include &lt;stdio.h&gt;

void displayBits(unsigned);

int main() {
  unsigned n1 = 960;

  puts("number");
  displayBits(n1);
  puts("8 bit of left shifting");
  displayBits(n1 &lt;&lt; 8);

  puts("number");
  displayBits(n1);
  puts("8 bit of right shifting");
  displayBits(n1 >> 8);

  return 0;
}

void displayBits(unsigned value) {
  unsigned mask = 1 &lt&lt 31;
  printf("%10u = ", value);

  for (int i = 1; i &lt;= 32; i++) {
    putchar(value & mask ? '1' : '0');
    value &lt;&lt; 1;
    if (i % 8 == 0) {
      putchar(' ');
    }
  }

  putchar('\n');
}
</pre>
  </details>

  <h4>Порязрядные операции присваивания</h4>

  <p>&=, |=, ^=, &lt;&lt;=, >>=</p>

  <h4>10.10 Битовые поля (413)</h4>

  <p>В языке Си существует возможность задать число бит для хранения элемента структуры или объединения типа unsigned или int посредством определения битовых полей. Битовые поля экономят память.</p>
<pre>
struct bitCard {
  unsigned face : 4;
  unsigned suit : 2;
  ubsigned color : 1;
};
</pre>
  <p>Битовое поле объявляется с помощью двоеточия и целой константы, задающей число бит для хранения элемента. Обращение к битовым полям происходит точно так же, как и к любым другим элементам структуры.</p>
  <p>Представление карт битовыми полями в структурах</p>

  <details>
    <summary>Программа 114 (413)</summary>
<pre>
#include &lt;stdio.h&gt;

struct bitCard {
  unsigned face : 4;
  unsigned suit : 2;
  ubsigned color : 1;
};

typedef struct bitCard Card;

void fillDeck(Card* const wDeck);
void deal(const Card* const wDeck);

int main() {
  Card deck[52];
  fillDeck(deck);
  deal(deck);

  return 0;
}

void fillDeck(Card* const wDeck) {
  for (int i = 0; i &lt; 52; i++) {
    wDeck[i].face = i % 13;
    wDeck[i].suit = i / 13;
    wDeck[i].color = i / 26;
  }
}

void deal(const Card* const wDeck) {
  for (int k1 = 0, k2 = k1 + 26; k1 &lt;= 25; k1++, k2++) {
    printf("Card:%3d Suit:%2d Color:%2d ",
      wDeck[k1].face, wDeck[k1].suit, wDeck[k1].color);
    printf("Card:%3d Suit:%2d Color:%2d ",
      wDeck[k2].face, wDeck[k2].suit, wDeck[k2].color);
  }
}
</pre>
  </details>

  <p>Допускается определение неименованного поля. Такое поле служит заполнителем структуры. В битах неименованного поля невозможно что-либо сохранить.</p>
<pre>
struct example {
  unsigned a : 13;
  unsigned   : 19;
  unsigned b : 4;
};
</pre>
  <p>Если в компьютере используются 32 разрядные ячейки памяти (4 байта), то структура будет занимать 2 ячейки памяти. В первой элемент a размером 13 бит. Дальше в первой ячейке будет 19 бит, которые невозможно использовать. Во второй ячейке элемент b размером 4 бита.</p>
  <p>Неименованное битовое поле нулевой ширины служит для выравнивания следующего битового поля по границе новой ячейки памяти.</p>
<pre>
struct example {
  unsigned a : 13;
  unsigned   : 0;
  unsigned b : 4;
};
</pre>
  <p>Элементы a и b будут записаны в разных ячейках. Поле длиной 0 объявлено для того чтобы перескочить через оставшиеся биты первой ячейки памяти.</p>
  <p>Битовые поля позволяют экономить память, но обращение к ним и операции с ними медленнее.</p>

  <h4>10.11 Перечисляемые константы (416)</h4>

  <p>Перечисление объявляется словом enum и названием, далее в фигурных скобках перечисляются его элементы. Значение первого элемента по умолчанию равно нулю, каждого следующего на 1 больше. Можно любым элементам присвоить свои целочисленные значения.</p>
  <code>enum months {JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC};</code>
  <p>Здесь идентификаторы нового типа enum month имеют значения от 0 до 11</p>
  <code>enum months {JAN = 1, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC};</code>
  <p>Здесь идентификаторы нового типа enum month имеют значения от 1 до 12</p>
  <p>В перечислении элементы должны иметь разные имена, но могут иметь одинаковое значение.</p>
  <p>Использование перечислимого типа.</p>

  <details>
    <summary>Программа 115 (416)</summary>
<pre>
#include &lt;stdio.h&gt;

enum months {JAN = 1, FEB, MAR, APR, MAY,
  JUN, JUL, AUG, SEP, OCT, NOV, DEC};

int main() {
  enum months month;
  const char *monthName[] = {"", "January",
    "February", "March", "April", "May",
    "June", "July", "August", "September",
    "October", "November", "December"};

  for (month = Jan; month &lt;= DEC; month++) {
    printf("%2d%11s\n", month, monthName[month]);
  }

  return 0;
}
</pre>
  </details>
</article>


<!-- 11 Работа с файлами в C -->
<article class="article">
  <div class="anchor" id="p11"></div>
  <h3>11 Работа с файлами в C (426)</h3>

  <h4>11.1 Введение (427)</h4>

  <p>Хранение данных в переменных и массивах является временным, пока работает программа. По завершению работы программы эти данные уничтожаются. Для постоянного хранения данных используются файлы на жестком диске или ином носителе.</p>

  <h4>11.2 Иерархия данных (427)</h4>

  <p>Данные в программах и в файлах хранятся в двоичном виде - в виде последовательностей 1 и 0. Наименьший элемент данных это бит, в котором может храниться только одно значение или 0 или 1.</p>
  <p>Бит это слишком маленькая единица информации. Компьютеры за один такт обрабатывают сразу набор бит. Первые, 8-разрядные, процессоры работали с 8 битами сразу. 8 бит это 1 байт. Далее, 16-разрядные процессоры работали уже с 2 байтами за один такт. Сейчас 64 разрядные процессоры каждый такт обрабатывают 64 бита. 64 бита это машинное слово для 64-разрядных процессоров.</p>
  <p>Чтобы программисты работали не с битами, а с цифрами, буквами и другими символами, создаются специальные таблицы, например ASCII, в которой каждому символу однозначно определен набор бит со своим значением. Программист работает с символами, символы по таблице ASCII кодируются в двоичные данные, с двоичными данными работает процессор.</p>
  <p>Данные хранятся в файлах в виде структур данных. Иерархия структур данных такова: биты образуют байты, байты образуют машинное слово, машинные слова образуют поля записей. Поля образуют структуру данных, структуры данных хранятся в файлах, файлы образуют базу данныйх.</p>

  <h4>11.3 Файлы и потоки (429)</h4>

  <p>Язык Си рассматривает любой файл как последовательный поток байтов. Каждый файл заканчивается символом конца файла EOF. Когда файл открывается, ему ставится в соответствие поток. При запуске любой программы автоматически открываются три файла и связанные с ними потоки - стандартный поток ввода, стандартный поток вывода и стандартный поток ошибок. Открытый файл возвращает указатель на структуру FILE (определенную в stdio.h), которая содержит информацию для работы с файлом. Эта структура содержит дескриптор файла - индекс в массиве, который называется таблицей открытых файлов операционной системы. Каждый элемент массива содерит блок управления файлом FCB.</p>

  <h4>Функции для работы с файлами</h4>

  <p>Функция fgetc() считывает один символ из файла. fgetc(stdin) считывает один символ из входного потока, как и функция getchar()</p>
  <p>Функция fputc() записывает один символ в файл. fputc('a', stdout) записывает символ 'a' в выходной поток, как и функция putchar('a')</p>
  <p>Функция fgets() считывает одну строку из файла. fgets(stdin) считывает одну строку из входного потока, как и функция gets()</p>
  <p>Функция fputs() записывает одну строку в файл. fputs("aa", stdout) записывает строку "aa" в выходной поток, как и функция puts("aa")</p>
  <p>Функция fscanf() это аналог функции scanf(), но работает с файлами.</p>
  <p>Функция fprintf() это аналог функции printf(), но работает с файлами.</p>
  <p>Функции fread() и fwrite() рассмотрим позже.</p>

  <h4>11.4 Создание файла последовательного доступа (430)</h4>

  <p>Создание пользовательского файла</p>

  <details>
    <summary>Программа 116 (430)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int account;
  char name[30];
  double balance;
  FILE *cfPtr;

  if ((cfPtr = fopen("client.dat", "w")) == NULL) {
    puts("File could not be opened");
  } else {
    puts("Enter account, name, balance");
    puts("Enter EOF to end");
    printf("%s", "? ");
    scanf("%d%s%lf", &account, name, &balance);

    while (!feof(stdin)) {
      fprintf(cfPtr, "%d %s %.2f\n", account, name, balance);
      printf("%s", "? ");
      scanf("%d%s%lf", &account, name, &balance);
    }

    fclose(cfPtr);
  }

  return 0;
}
</pre>
  </details>

  <p>Структура FILE косвенно ссылается на блок управления файлом FCB операционной системы для заданного файла.</p>
  <p>Ctrl-z комбинация клавиш для ввода символа EOF в Windows</p>
  <p>Ctrl-d комбинация клавиш для ввода символа EOF в Linux и Macintosh</p>

  <h4>11.5 Чтение данных из файла последовательного доступа (435)</h4>

  <p>Чтение и распечатка последовательного файла</p>

  <details>
    <summary>Программа 117 (436)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int account;
  char name[30];
  double balance;
  FILE *cfPtr;

  if ((cfPtr = fopen("client.dat", "r")) == NULL) {
    puts("File could not be opened");
  } else {
    printf("%-10s%-13s%s\n", "account", "name", "balance");
    fscanf(cfPtr, "%d%s%lf", &account, name, &balance);

    while (!feof(cfPtr)) {
      printf("%-10d%-13s%7.2f\n", account, name, balance);
      fscanf(cfPtr, "%d%s%lf", &account, name, &balance);
    }

    fclose(cfPtr);
  }

  return 0;
}
</pre>
  </details>

  <p>Указатель позиции файла - это целое значение, определяющее байт в файле, который будет считан, или в который будет записан байт информации. Указатель позиции файла это смещение относительно начала файла, нулевого байта файла.</p>
  <p>Функция rewind() перемещает в начало указатель файла.</p>

  <p>Программа для справок о кредите. Получает список клиентов, которые не должны денег, которым компания должна денег, которые компании должны денег.</p>

  <details>
    <summary>Программа 118 (437)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int request;
  int account;
  char name[30];
  double balance;
  FILE *cfPtr;

  if ((cfPtr = fopen("client.dat", "r")) == NULL) {
    puts("File could not be opened");
  } else {
    printf("%s", "Enter request\n"
    "1 - List accounts wuth zero balances\n"
    "2 - List accounts with credit balances\n"
    "3 - List accounts with debit balances\n"
    "4 - End of run\n");
    scanf("%d", &request);

    while (request != 4) {
      fscanf(cfPtr, "%d%s%lf", &account, name, &balance);

      switch (request) {

        case 1:
          puts("Accounts with zero balances");
          while (!feof(cfPtr)) {
            if (balance == 0) {
              printf("%-10d%-13s%7.2f\n", account, name, balance);
            }
            fscanf(cfPtr, "%d%s%lf", &account, name, &balance);
          }
          break;

        case 2:
          puts("Accounts with credit balances");
          while (!feof(cfPtr)) {
            if (balance &lt; 0) {
              printf("%-10d%-13s%7.2f\n", account, name, balance);
            }
            fscanf(cfPtr, "%d%s%lf", &account, name, &balance);
          }
          break;

        case 3:
          puts("Accounts with debit balances");
          while (!feof(cfPtr)) {
            if (balance > 0) {
              printf("%-10d%-13s%7.2f\n", account, name, balance);
            }
            fscanf(cfPtr, "%d%s%lf", &account, name, &balance);
          }
          break;
      }
      rewind(cfPtr);
      printf("%s", "\n? ");
      scanf("%d", &request);
    }

    puts("End of run");
    fclose(cfPtr);
  }

  return 0;
}
</pre>
  </details>

  <p>Если в файле последовательного доступа нужно обновить запись, которая больше чем первоначальная, то она будет записана поверх первоначальной и следующей записи. Поэтому последовательный доступ с помощью fprintf и fscanf обычно не используется для обновления записей в файле. Вместо этого переписывают весь файл целиком.</p>
  <p>Записи в файлах, созданных функцией fprintf() могут иметь разную длину и чтобы дойти до нужной записи нужно последовательно пройти по всем предыдущим записям. Это файлы последовательного доступа к данным.</p>

  <h4>11.6 Файлы произвольного доступа (440)</h4>

  <p>Записи в файле произвольного доступа имеют фиксированную длину, что позволяет получить к ним быстрый доступ без прохода по всем записям. Поэтому файлы с произвольным доступам используют там где необходим быстрый доступ к данным.</p>
  <p>Даже когда размер файла очень велик, можно вычислить точное положение записи относительно начала файла из-за того что записи имеют одинаковую длину.</p>
  <p>Записи не идут последовательно, между ними могут быть пропуски. Поэтому можно вставлять новые данные, не разрушая при этом те, что уже находятся в файле. Данные также можно обновить или удалить без перезаписывания всего файла.</p>

  <h4>11.7 Создание файла произвольного доступа (441)</h4>

  <p>Функция fwrite() записывает в файл заданное число байт, начиная с указанного адреса памяти. Место записи в файл определяется указателем позиции файла.</p>
  <p>Функция fread() читает из файла заданное число байт, начиная с указателя позиции файла в память, начиная с указанного адреса.</p>
  <code>fprintf(fPtr, "%d", number);</code>
  <p>Функция fprintf() запишет целое число от одной до 11 цифр требующие по одному байту каждый для четырехбайтного целого.</p>
  <code>fwrite(&number, sizeof(int), 1, fPtr);</code>
  <p>Функция fwrite() записывает на диск одно целое число, всегда записывает 4 байта из переменной number в файл, определяемый fPtr.</p>
  <p>Функции fwrite и fread дают возможность чтения и записи массивов данных с диска на диск. Третий аргумент это число элементов массива.</p>
  <p>Последовательное создание файла произвольного доступа.</p>

  <details>
    <summary>Программа 119 (442)</summary>
<pre>
#include &lt;stdio.h&gt;

struct clientData {
  int acctNum;
  char lastName[15];
  char firstName[10];
  double balance;
};

int main() {
  struct clientData blankClient = {0, "", "", 0.0};
  FILE *cfPtr;

  if ((cfPtr = fopen("credit.dat", "wb")) == NULL) {
    puts("File could not be opened");
  } else {
    for (int i = 1; i &lt;= 100; i++) {
      fwrite(&blankClient, sizeof(struct clientData), 1, cfPtr);
    }

    // закрываем файл
    fclose(cfPtr);
  }

  return 0;
}
</pre>
  </details>

  <p>Здесь fwrite записывает один объект, который не является элементом массива. Поэтому в вызове fwrite третьим аргументом стоит 1.</p>

  <h4>11.8 Произвольная запись данных в файл произвольного доступа (443)</h4>

  <p>Запись в файл произвольного доступа.</p>

  <details>
    <summary>Программа 120 (443)</summary>
<pre>
#include &lt;stdio.h&gt;

struct clientData {
  int acctNum;
  char lastName[15];
  char firstName[10];
  double balance;
};

int main() {
  struct clientData client = {0, "", "", 0.0};
  FILE *cfPtr;

  if ((cfPtr = fopen("credit.dat", "rb+")) == NULL) {
    puts("File could not be opened");
  } else {
    //запросить у пользователя номер счета
    puts("Enter account number 1 to 100 (0 to end input)\n");
    scanf("%d", &client.accntNum);

    while (acctNum != 0) {
      // запросить имя, фамилию, баланс
      puts("Enter lastname, firstname, balance\n");
      fscanf(stdin, "%s%s%lf", client.lastName,
      client.firstName, &client.balance);

      // найти позицию счета в файле
      fseek(cfPtr, (client.acctNum - 1) *
        sizeof(struct clientData), SEEK_SET);

      // записать информацию в файл
      fwrite(&client, sizeof(struct clientData), 1, cfPtr);

      //запросить номер другого счета
      puts("Enter account number 1 to 100 (0 to end input)\n");
      scanf("%d", &client.accntNum);
    }

    // закрываем файл
    fclose(cfPtr);
  }

  return 0;
}
</pre>
  </details>

  <p>Функция fseek() устанавливает указатель позиции файла в заданное положение, после чего fwrite() записывает данные. Константа SEEK_SET показывает, что указатель позиции файла устанавливается относительно начала файла на величину смещения.</p>
  <p>Прототип функции fseek</p>
  <code>int fseek(FILE *stream, long int offset, int whence);</code>
  <p>где offset это число байт от положения, задаваемого параметром whence. whence может иметь одно из трех значений - SEEK_SET, SEEK_CUR, SEEK_END. Что означает, начинать поиск с начала, с текущего места или с конца.</p>

  <h4>11.9 Чтение данных из файла произвольного доступа (445)</h4>

  <p>Последовательное чтение файла произвольного доступа</p>

  <details>
    <summary>Программа 121 (446)</summary>
<pre>
#include &lt;stdio.h&gt;

struct clientData {
  int acctNum;
  char lastName[15];
  char firstName[10];
  double balance;
};

int main() {
  struct clientData client = {0, "", "", 0.0};
  FILE *cfPtr;

  if ((cfPtr = fopen("credit.dat", "rb")) == NULL) {
    puts("File could not be opened");
  } else {
    printf("%-6s%-16s%-11s%10s\n", "Acct", "Last Name",
      "First Name", "Balance");

    // пока не достигнут конец файла
    while (!feof(cfPtr)) {
      fread(&client, sizeof(struct clientData), 1, cfPtr);

      if (client.acctNum != 0) {
        printf("%-6d%-16s%-11s%10.2f\n", client.acctNum,
        client.lastName, client.firstName, client.balance);
      }
    }

    // закрываем файл
    fclose(cfPtr);
  }

  return 0;
}
</pre>
  </details>

  <h4>11.10 Пример: программа обработки транзакций (447)</h4>

  <p>Сначала нужно выполнить программу 119, создающую файл credit.dat.</p>
  <p>Следующая программа имеет 5 опций.</p>
  <ol>
    <li>Опция 1 вызывает функцию textFile для сохранения отформатированного списка всех счетов в текстовом файле accounts.dat</li>
    <li>Опция 2 вызывавет функцию updateRecord для обновления счета.</li>
    <li>Опция 3 вызывает функцию newRecord для добавления в файл нового счета.</li>
    <li>Опция 4 вызывает функцию deleteRecord для удаления записи из файла.</li>
    <li>Опция 5 прерывает выполнение программы.</li>
  </ol>

  <p>Программа последовательно читает файл произвольного доступа, обновляет данные, уже записанные в файл, создает новые данные для размещения в файле и удаляет ранее записанные данные.</p>

  <details>
    <summary>Программа 122 (448)</summary>
<pre>
#include &lt;stdio.h&gt;

struct clientData {
  int acctNum;
  char lastName[15];
  char firstName[10];
  double balance;
};

int enterChoice();
void textFile(FILE *readPtr);
void updateRecord(FILE *fPtr);
void deleteRecord(FILE *fPtr);
void newRecord(FILE *fPtr);

int main() {
  FILE *cfPtr;
  int choice;

  if ((cfPtr = fopen("credit.dat", "rb+")) == NULL) {
    puts("File could not be opened");
  } else {
    while ((choice = enterChoice()) != 5) {
      switch (choice) {

        // создать текстовый файл
        case 1:
          textFile(cfPtr);
          break;

        // обновить запись
        case 2:
          updateRecord(cfPtr);
          break;

        // создать запись
        case 3:
          newRecord(cfPtr);
          break;

        // удалить запись
        case 4:
          deleteRecord(cfPtr);
          break;

        // если указан неверный номер
        default:
          puts("Incorrect choice");
          break;
      }
    }
    fclose(cfPtr);
  }

  return 0;
}

void textFile(FILE *readPtr) {
  FILE *writePtr;
  struct clientData client = {0, "", "", 0.0};

  if ((writePtr = fopen("accounts.txt", "w")) == NULL) {
    puts("File cpuld not be opened");
  } else {
    rewind(readPtr);
    fprints(writePtr, "%-6s%-16s%-11s%10s\n",
    "Acct", "Last Name", "First Name", "Balance");

    while (!feof(readPtr)) {
      fread(&client, sizeof(struct clientData), 1, readPtr);
      if (client.acctNum != 0) {
        fprints(writePtr, "%-6s%-16s%-11s%10.2f\n",
        client.acctNum, client.lastName,
        client.firstName, client.balance);
      }
    }
    fclose(writePtr);
  }
}

void updateRecord(FILE *fPtr) {
  int account;
  double transaction;
  struct clientData client = {0, "", "", 0.0};

  printf("%s", "Enter account to update (1-100) ");
  scanf("%d", &account);

  fseek(fPtr, (account - 1) * sizeof(struct clientData), SEEK_SET);
  fread(&client, sizeof(struct clientData), 1, fPtr);

  if (client.acctNum == 0) {
    printf("Account #%d has no information\n", account);
  } else {
    printf("%-6d%-16s%-11s%10.2f\n\n",
    client.acctNum, client.lastName,
    client.firstName, client.balance);

    fseek(fPtr, (account - 1) * sizeof(struct clientData), SEEK_SET);
    fwrite(&client, sizeof(struct clientData), 1, fPtr);
  }
}

void deleteRecord(FILE *fPtr) {
  struct clientData client;
  struct clientData blankClient = {0, "", "", 0.0};
  int accountNum;

  printf("%s", "Enter account to update (1-100) ");
  scanf("%d", &account);

  fseek(fPtr, (account - 1) * sizeof(struct clientData), SEEK_SET);
  fread(&client, sizeof(struct clientData), 1, fPtr);

  if (client.acctNum == 0) {
    printf("Account #%d does not exist\n", account);
  } else {
    fseek(fPtr, (account - 1) * sizeof(struct clientData), SEEK_SET);
    fwrite(&blankClient, sizeof(struct clientData), 1, fPtr);
  }
}

void newRecord(FILE *fPtr) {
  struct clientData client = {0, "", "", 0.0};
  int accountNum;

  printf("%s", "Enter account to update (1-100) ");
  scanf("%d", &account);

  fseek(fPtr, (account - 1) * sizeof(struct clientData), SEEK_SET);
  fread(&client, sizeof(struct clientData), 1, fPtr);

  if (client.acctNum != 0) {
    printf("Account #%d already contains information\n", client.acctNum);
  } else {
    printf("%s", "Enter lastname, firstname, balance\n ");
    scanf("%s%s%lf", &client.lastName,
    &client.firstName, &client.balance);
    client.acctNum = accountNum;

    fseek(fPtr, (client.acctNum - 1) * sizeof(struct clientData), SEEK_SET);
    fwrite(&client, sizeof(struct clientData), 1, fPtr);
  }
}

int enterChoice() {
  int menuChoice;

  printf("%s", "Enter your choice\n"
  "1 - store information of account in text file\n"
  "2 - update an account\n"
  "3 - add a new account\n"
  "4 - delete an account\n"
  "5 - end program\n");

  scanf("%d", &menuChoice);
  return menuChoice;
}
</pre>
  </details>
</article>


<!-- 12 Структуры данных в C -->
<article class="article">
  <div class="anchor" id="p12"></div>
  <h3>12 Структуры данных в C (461)</h3>

  <h4>12.1 Введение (462)</h4>

  <p>Мы изучили структуры данных фиксированного размера: массивы, матрицы, структуры. В этой главе изучим динамические структуры данных, их размер может изменяться во время работы программы: связные списки, стеки, очереди, деревья</p>

  <h4>12.2 Автореферентные структуры (463)</h4>

  <p>Автореферентные структуры содержат в качестве элемента указатель на структуру того же типа.</p>
<pre>
struct node {
  int data;
  struct node *nextPtr;
}
</pre>
  <p>Автореферентные структуры используются для построения связных списков, стеков, очередей, деревьев. Указатель NULL обозначает конец структуры, так же как символ '\0' обозначает конец строки.</p>

  <h3>12.3 Динамическое распределение памяти (464)</h3>

  <p>Динамическое распределение памяти - это возможность получать дополнительные блоки памяти и освобождать ненужные блоки памяти. Максимальный размер выделяемой динамической памяти определяется доступной физической памятью, однако этот размер значительно меньше, потому что память разделяется между многими программами.</p>
  <p>Получить дополнительную память можно с помощью функций malloc, calloc, realloc.</p>
  <code>newPtr = malloc(sizeof(struct node));</code>
  <p>Функция malloc принимает число байт, которое необходимо выделить и возвращает указатель типа void* на первый байт выделенной памяти. Указатель типа void* можно присвоить любому типу указателя. Если память выделить не удалось, то возвращает указатель NULL.</p>
  <code>free(newPtr);</code>
  <p>Функция free принимает указатель на память выделенную с помощью функция malloc, calloc, realloc и освобождает ее.</p>
  <p>Если не освобождать память после ее использования, то это всегда приводит к утечке памяти.</p>

  <h4>12.4 Связные списки (465)</h4>

  <p>Связный список это набор узлов с данными задается на первый узел списка, где каждый узел содержит указатель на следующий узел, а последний узел содержит указатель на NULL. Узел может содержать данные любого типа, даже другие структуры. Связные списки, стеки и очереди это линейные структуры данных. Деревья являются нелинейными структурами данных.</p>
  <p>Связный список удобен когда заранее неизвестно сколько элементов будет содержать структура. Новый узел легко вставить в любое место связного списка. Связный список это непрерывная последовательность, хотя элементы списка могут располагаться не в соседних ячейках памяти.</p>
  <p>Напишем программу, которая управляет списком символов. Программа может вставить символ в алфавитном порядке и удалить символ из списка.</p>

  <details>
    <summary>Программа 123 (466)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct listNode {
  char data;
  struct listNode *nextPtr;
};

typedef struct listNode ListNode;
typedef ListNode *ListNodePtr;

void instructions();
void insert(ListNodePtr *sPtr, char value);
char delete(ListNodePtr *sPtr, char value);
int isEmpty(ListNodePtr sPtr);
void printList(ListNodePtr currentPtr);

int main() {
  ListNodePtr startPtr = NULL;
  int choice;
  char item;

  instructions();
  printf("%s", "? ");
  scanf("%d", &choice);

  while (choice != 3) {

    switch (choice) {

      case 1:
        printf("%s", "Enter a character: "");
        scanf("\n%c", &item);
        insert(&startPtr, item);
        printList(startPtr);
        break;

      case 2:
        if (!isEmpty(startPtr)) {
          printf("%s", "Enter character to delete: "");
          scanf("\n%c", &item);
          if (delete(&startPtr, item)) {
            printf("%c deleted\n", item);
            printList(startPtr);
          } else {
            printf("%c not found\n", item);
          }
        } else {
          puts("List is empty\n");
        }
        break;

      default:
        puts("Invalid choice\n");
        instructions();
        break;
    }

    printf("%s", "? ");
    scanf("%d", &choice);
  }

  puts("End of run");

  return 0;
}

void instructions() {
  puts("Enter your choice:\n"
  "1 to insert an element into the list\n"
  "2 to delete an element from the list"
  "3 to end");
}

void insert(ListNodePtr *sPtr, char value) {
  ListNodePtr newPtr;
  ListNodePtr prevPtr;
  ListNodePtr curPtr;

  newPtr = malloc(sizeof(ListNode));

  if (newPtr != 0) {
    newPtr->data = value;
    newPtr->nextPtr = NULL;
    prevPtr = NULL;
    curPtr = *sPtr;

    while (curPtr != NULL && value > curPtr->data) {
      prevPtr = curPtr;
      curPtr = curPtr->nextPtr;
    }

    if (prevPtr == NULL) {
      newPtr->nextPtr = *sPtr;
      *sPtr = newPtr;
    } else {
      prevPtr->nextPtr = newPtr;
      newPtr->nextPtr = curPtr;
    }
  } else {
    printf("%c not inserted. No mamory available\n", value);
  }
}

char delete(ListNodePtr *sPtr, char value) {
  ListNodePtr prevPtr;
  ListNodePtr curPtr;
  ListNodePtr tempPtr;

  if (value == (*sPtr)->data) {
    tempPtr = *sPtr;
    *sPtr = (*sPtr)->nextPtr;
    free(tempPtr);
    return value;
  } else {
    prevPtr = *sPtr;
    curPtr = (*sPtr)->nextPtr;

    while (curPtr != NULL && curPtr->data != value) {
      prevPtr = curPtr;
      curPtr = curPtr->nextPtr;
    }

    if (curPtr != NULL) {
      tempPtr = curPtr;
      prevPtr->nextPtr = curPtr->nextPtr;
      free(tempPtr);
      return value;
    }
  }
  return '\0';
}

int isEmpty(ListNodePtr sPtr) {
  return sPtr == NULL;
}

void printList(ListNodePtr curPtr) {
  if (curPtr == NULL) {
    puts("List is empty");
  } else {
    puts("The list is:");

    while (curPtr != NULL) {
      printf("%c --&gt; ", curPtr->data);
      curPtr = curPtr->nextPtr;
    }

    puts("NULL\n");
  }
}
</pre>
  </details>

  <p>Функции insert передается адрес списка и символ. Передача адреса позволяет изменять список через вызов по ссылке. Так как список это указатель на первый элемент, то при передаче адреса списка создается указатель на указатель, т.е. двойная адресация.</p>

  <h4>12.5 Стеки (474)</h4>

  <p>Стек это упрощенный вариант связного списка. Новые узлы могут вставляться и удаляться из стека только в конце. Это структура вида LIFO (последний пришел - первый вышел). На стек ссылаются через указатель на последний элемент стека. Основные функции работы со стеками - push добавить новый узел на вершину стека, pop удалить узел с вершины стека и вернуть его значение.</p>
  <p>Напишем программу динамического стека, которая выполняет три действия: помещает значение в стек, достает значение из стека и завершает работу.</p>

  <details>
    <summary>Программа 124 (474)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct stackNode {
  char data;
  struct stackNode *nextPtr;
};

typedef struct stackNode StackNode;
typedef StackNode *StackNodePtr;

void instructions();
void push(StackNodePtr *topPtr, int info);
int pop(StackNodePtr *topPtr);
void printStack(StackNodePtr currentPtr);
int isEmpty(StackNodePtr topPtr);

int main() {
  StackNodePtr stackPtr = NULL;
  int choice;
  int value;

  instructions();
  printf("%s", "? ");
  scanf("%d", &choice);

  while (choice != 3) {

    switch (coice) {

      case 1:
        printf("%s", "Enter an integer: ");
        scanf("%d", &value);
        push(&stackPtr, value);
        printStack(stackPtr);
        break;

      case 2:
        if (!isEmpty(stackPtr)) {
          printf("Value is %d\n", pop(&stackPtr));
        }
        printStack(stackPtr);
        break;

      default:
        puts("Invalid choice\n");
        instructions();
        break;
    }

    printf("%s", "? ");
    scanf("%d", &choice);
  }

  puts("End of run");

  return 0;
}

void instructions() {
  puts("Enter choice\n"
       "1 to push a value on the stack\n"
       "2 to pop a value off the stack\n"
       "3 to end");
}

void push(StackNodePtr *topPtr, int info) {
  StackNodePtr newPtr;
  newPtr = malloc(sizeof(StackNode));

  if (newPtr != NULL) {
    newPtr->data = info;
    newPtr->nextPtr = *topPtr;
    *topPtr = newPtr;
  } else {
    printf("%d not inserted. No memory available\n", info);
  }
}

int pop(StackNodePtr *topPtr) {
  StackNodePtr tempPtr;
  int popValue;
  tempPtr = *topPtr;
  popValue = (*topPtr)->data;
  *topPtr = (*topPtr)->nextPtr;
  free(tempPtr);

  return popValue;
}

void printStack(StackNodePtr currentPtr) {
  if (currentPtr == NULL) {
    puts("The stack is empty\n");
  } else {
    puts("The stack is\n");

    while (currentPtr != NULL) {
      printf("%d --&gt; ", currentPtr->data);
      currentPtr = currentPtr->nextPtr;
    }
    puts("NULL\n")
  }
}

int isEmpty(StackNodePtr topPtr) {
  return topPtr == NULL;
}
</pre>
  </details>

  <p>На стеке выделяется память для автоматических переменных при каждом вызове функции. Когда происходит выход из функции, автоматические переменные удаляются из стека и память освобождается.</p>

  <h4>12.6 Очереди (479)</h4>

  <p>Очередь это упрощенный вариант связного списка. Новые узлы могут добавляться только в конец, а удаляться только сначала. Это структура вида FIFO (первым пришел - первым вышел). На стек ссылаются через указатель на последний элемент стека. Основные функции работы со стеками - enqueue добавить новый узел в конец очереди, dequeue удалить узел с начала очереди и вернуть его значение.</p>
  <p>Очереди используются для организации буфера печати, для передачи пакетов в сети.</p>
  <p>Напишем программу, которая может поставить узел в очередь, удалить узел из очереди и выйти из программы.</p>

  <details>
    <summary>Программа 125 (480)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct queueNode {
  char data;
  struct queueNode *nextPtr;
};

typedef struct queueNode QueueNode;
typedef QueueNode *QueueNodePtr;

void instructions();
void enqueue(QueueNodePtr *headPtr, QueueNodePtr *tailPtr, char value);
void dequeue(QueueNodePtr *headPtr, QueueNodePtr *tailPtr);
void printQueue(QueueNodePtr currentPtr);
int isEmpty(QueueNodePtr headPtr);

int main() {
  QueueNodePtr headPtr = NULL;
  QueueNodePtr tailPtr = NULL;
  int choice;
  char item;

  instructions();
  printf("%s", "? ");
  scanf("%d", &choice);

  while (choice != 3) {

    switch (coice) {

      case 1:
        printf("%s", "Enter an character: ");
        scanf("%c", &item);
        enqueue(&headPtr, &tailPtr, item);
        printQueue(headPtr);
        break;

      case 2:
        if (!isEmpty(headPtr)) {
          item = dequeue(&headPtr, &tailPtr);
          printf("%c is qedueued\n", item);
        }
        printQueue(headPtr);
        break;

      default:
        puts("Invalid choice\n");
        instructions();
        break;
    }

    printf("%s", "? ");
    scanf("%d", &choice);
  }

  puts("End of run");

  return 0;
}

void instructions() {
  puts("Enter choice\n"
       "1 to add an item to the queue\n"
       "2 to remove an item from the queue\n"
       "3 to end");
}

void enqueue(QueueNodePtr *headPtr, QueueNodePtr *tailPtr, char value) {
  QueueNodePtr newPtr;
  newPtr = malloc(sizeof(QueueNode));

  if (newPtr != NULL) {
    newPtr->data = value;
    newPtr->nextPtr = NULL;
    if (isEmpty(*headPtr)) {
      *headPtr = newPtr;
    } else {
      (*tailPtr)->nextPtr = newPtr;
    }
    *tailPtr = newPtr;
  } else {
    printf("%c not inserted. No memory available\n", value);
  }
}

void dequeue(QueueNodePtr *headPtr, QueueNodePtr *tailPtr) {
  QueueNodePtr tempPtr;
  char value;
  tempPtr = *headPtr;
  value = (*headPtr)->data;
  *headPtr = (*headPtr)->nextPtr;

  if (*headPtr == NULL) {
    *tailPtr = NULL;
  }

  free(tempPtr);

  return value;
}

void printQueue(QueueNodePtr currentPtr) {
  if (currentPtr == NULL) {
    puts("The queue is empty\n");
  } else {
    puts("The queue is\n");

    while (currentPtr != NULL) {
      printf("%c --&gt; ", currentPtr->data);
      currentPtr = currentPtr->nextPtr;
    }
    puts("NULL\n")
  }
}

int isEmpty(QueueNodePtr headPtr) {
  return headPtr == NULL;
}
</pre>
  </details>

  <h4>12.7 Деревья (485)</h4>

  <p>Дерево - это нелинейная, двумерная структура данных. Узлы дерева содержат две или более связей. Двоичные деревья - деревья, узлы которых содержат две связи. Одна или обе связи могут быть NULL. Дерево представлено своим первым узлом, который называется корнем дерева. От корня связь идет влево в левого потомка и вараво в правого потомка. Если у узла нет потомков, то он называется лист. Двоичное дерево поиска это двоичное дерево с неповторяющимися значениями в листах, значения в любом узле левого поддерева меньше чем в родительском узле, а значения в любом узле правого поддерева больше чем в родительском узле. Форма двоичного дерева с одинаковыми значениями может быть разной в зависимости от порядка, в котором эти значения вставлялись в дерево.</p>
  <p>Напишем программу, которая создает двоичное дерево поиска и обходит его тремя способами: с порядковой выборкой (inorder), предварительной выборкой (preoeder) и отложенной выборкой (postorder).</p>

  <details>
    <summary>Программа 126 (486)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

struct treeNode {
  int data;
  struct treeNode *leftPtr;
  struct treeNode *rightPtr;
};

typedef struct treeNode TreeNode;
typedef TreeNode *TreeNode;

void insertNode(TreeNodePtr *treePtr, int value);
void inOrder(TreeNodePtr treePtr);
void preOrder(TreeNodePtr treePtr);
void postOrder(TreeNodePtr treePtr);

int main() {
  int item;
  TreeNodePtr rootPtr = NULL;

  srand(time(NULL));
  puts("Numbers in tree:");

  for (int i = 1; i &lt;=10; i++) {
    item = rand() % 15;
    printf("%3d", item);
  }

  puts("\nThe preOrder traversal is:"");
  preOrder(rootPtr);

  puts("\nThe inOrder traversal is:"");
  inOrder(rootPtr);

  puts("\nThe postOrder traversal is:"");
  postOrder(rootPtr);

  return 0;
}

void insertNode(TreeNodePtr *treePtr, int value) {
  if (*treePtr == NULL) {
    *treePtr = malloc(sizeof(TreeNode));
    if (*treePtr != NULL) {
      (*treePtr)->data = value;
      (*treePtr)->leftPtr = NULL;
      (*treePtr)->rightPtr = NULL;
    } else {
      printf("%d not inserted. No memory available\n", value);
    }
  } else {
    if (value &lt; (*treePtr)->data) {
      insertNode(&((*treePtr)->leftPtr), value);
    } else if (value > (*treePtr)->data) {
      insertNode(&((*treePtr)->rightPtr), value);
    } else {
      printf("%s", "dup");
    }
  }
}

void inOrder(TreeNodePtr treePtr) {
  if (treePtr != NULL) {
    inOrder(treePtr->leftPtr);
    printf("%3d", treePtr->data);
    inOrder(treePtr->rightPtr;)
  }
}

void preOrder(TreeNodePtr treePtr) {
  if (treePtr != NULL) {
    printf("%3d", treePtr->data);
    preOrder(treePtr->leftPtr);
    preOrder(treePtr->rightPtr;)
  }
}

void postOrder(TreeNodePtr treePtr) {
  if (treePtr != NULL) {
    postOrder(treePtr->leftPtr);
    postOrder(treePtr->rightPtr;)
    printf("%3d", treePtr->data);
  }
}
</pre>
  </details>
</article>


<!-- 13 Препроцессор C -->
<article class="article">
  <div class="anchor" id="p13"></div>
  <h3>13 Препроцессор C (513)</h3>

  <h4>13.1 Введение (514)</h4>

  <p>Препроцессор выполняет обработку программы до ее компиляции: включение других файлов, определение символических констант и макросов, условная компиляция, условное выполнение директив препроцессора. Все директивы препроцессора начинаются с новой строки с символа '#' и заканчиваются концом строки.</p>

  <h4>13.2 Директива #include (514)</h4>

  <p>На ее место подставляется копия файла с указанным именем.</p>
  <code>#include &lt;stdio.h&gt;</code>
  <code>#include "header.h"</code>
  <p>Файл stdio.h указан в угловых скобках, поэтому будет взят из папки стандартной библиотеки. Файл header.h указан в двойных кавычках, поэтому будет взят из текущей папки.</p>
  <p>Директива #include нужна для подключения файлов стандартных библиотек, а также для программ, состоящих из нескольких файлов, которые нужно компилировать вместе.</p>

  <h4>13.3 Директива #define. Символические константы (515)</h4>

  <p>Определяет константы, которые подставляюся во всей программе до ее компиляции</p>
  <code>#define PI 3.14159</code>
  <p>Во всей программе имя PI будет заменено на константу 3.14159. Если необходимо изменить константу во всей программе, достаточно это сделать в одном месте, в директиве #define.</p>

  <h4>13.4 Директива #define. Макросы (515)</h4>

  <p>Определяет макросы, которые подставляются во всей программе до ее компиляции. Отличие макросов от символических констант в том, что макросы могут быть с аргументами или без них, а вместо константы используется выражение.</p>
  <p>Макрос без аргументов обрабатывается аналогично символической константе.</p>
  <code>#define PI2 = 2 * 3.14</code>
  <p>Макросы с аргументами похожи на функции. Аргументы подставляются в выражение и вместе с выражением подставляются в месте вызова макроса в программе.</p>
  <code>#define CIRCLE_AREA(x) ( (PI) * (x) * (x) )</code>
  <p>Строка программы</p>
  <code>area = CIRCLE_AREA(4);</code>
  <p>до компиляции будет заменена на</p>
  <code>area = ( (3.14159) * (4) * (4) );</code>
  <p>Скобки в определении макроса обязательны, потому что они обеспечивают правильный порядок выполнения. Например, при вызове</p>
  <code>area = CIRCLE_AREA(с + 4);</code>
  <p>будет заменена на</p>
  <code>area = ( (3.14159) * (c + 4) * (c + 4) );</code>
  <p>В отличие от функции макросы выполняются быстрее. Нет вызова функции, нет создания копий параметров в стеке вызова.</p>
  <p>Любая директива заканчивается в конце строки. Если макрос не умещается на одну строку, то в конце строки ставят обратный слеш \ и текст продолжают на следующей строке.</p>

  <h4>Директива #undef</h4>

  <p>Директива #undef отменяет определение символической константы или макроса. После нее замена в тексте программы препроцессором не производится. После отмены определения, константу можно переопределить повторно любым значением.</p>
<pre>
#define SIZE 100
int A[SIZE];
#undef SIZE
#define SIZE 80
char Str[SIZE];
</pre>
  <p>Создали массив A из 100 целых чисел и строку Str из 80 символов</p>

  <h4>13.5 Условная компиляция (517)</h4>

  <p>Условной компиляция начинается с директивы #if и заканчивается директивой #endif. После #if идет выражение, которое оценивается. Если выражение истинно, то выполняются следующий код до директивы #endif. Если нет, то условная компиляция пропускается</p>
  <p>Проверим определена ли константа NULL и если нет, то определим ее</p>
<pre>
#if !defined(NULL)
  #define NULL 0
#endif
</pre>
  <p>Директивы #ifdef и #ifndef это сокращения для #if defined(имя) и #if !defined(имя). Если в конструкции #if несколько вариантов, то используют директивы #else и #elif.</p>
  <p>Чтобы во время отладки не выполнять код программы, содержащий комментарии, можно его заключить в условную директиву</p>
<pre>
#if 0
код программы
#endif
</pre>
  <p>Чтобы код программы снова компилировался, надо заменить 0 на 1.</p>
  <p>Если нужно вывести значения переменных во время отладки, то пользуются следующей коснтрукцией.</p>
<pre>
#define DEBUG
  ... много кода
#ifdef DEBUG
  printf("x = %d", x);
#endif
</pre>
  <p>Когда отладка завершается, #define DEBUG нужно убрать.</p>

  <h4>13.6 Директивы #error и #pragma (518)</h4>

  <p>Директива #error выводит на печать сообщение, включая лексемы, содержащиеся в директиве</p>
  <code>#error 1 - Out of range error</code>
  <p>Эта директива содержит 6 лексем, которые отображаются как сообщение об ошибки. Препроцессор останавливается, компиляция программы не производится.</p>

  <p>Директива #pragma указывает действие, зависящее от реализации.</p>

  <h4>13.7 Операции # и ## (518)</h4>

  <p>Операция # выполняет преобразование текстовой лексемы в строку, заключенную в кавычки. Операция # должна использоваться в макросах с аргументами, поскольку операнд после # ссылается на аргумент макроса</p>
  <code>#define HELLO(x) puts("Hello, " #x);</code>
  <p>В программе выражение HELLO(John) заменится на</p>
  <code>puts()"Hello, John";</code>

  <p>Операция ## выполняет конкатенацию двух лексем. Операция ## должна тметь два аргумента и использоваться в макросах с аргументами, поскольку операнды до и после ## конкатенируются.</p>
  <code>#define TOKENCONCAT(x, y) x ## y</code>
  <p>В программе выражение TOKENCONCAT(O, K) заментятся на OK.</p>

  <h4>13.8 Нумерация строк (519)</h4>

  <p>Директива #line используется для нумерации строк исходного кода программы.</p>
  <code>#line 100</code>
  <p>Нумерация строк начнется со следующей строки, которая будет иметь номер 100</p>
  <code>#line 100 "file1.c"</code>
  <p>Во всех сообщениях компилятор будет использовать данную нумерацию строки и название указанного файла. Нумерация строк нужна только компилятору, в исходном файле номера строк не появятся.</p>

  <h4>13.9 Предопределенные символические константы (519)</h4>

  <p>Существует пять предопределенных символических констант. Они начинаются и заканчиваются двумя символами подчеркивания. Они не могут входить в директивы #define и #undef:</p>
  <ol>
    <li>__LINE__ целая константа, номер текущей обрабатываемой строки исходного кода программы</li>
    <li>__FILE__ символьная строка, имя компилируемого исходного файла</li>
    <li>__DATE__ строка вида "mmm dd yyyy", дата начала компиляции текущего исходного файла</li>
    <li>__TIME__ строка вида "hh:mm:ss", время начала компиляции текущего исходного файла</li>
    <li>__STDC__ целая константа 1, показывает, что данная реализация совместима со стандартом ANSI</li>
  </ol>

  <h4>13.10 Макрос подтверждения (520)</h4>

  <p>Заголовочный файл assert.h содержит макрос assert, который проверяет значение выражения. Если значение выражения равно 0, то assert распечатывает сообщение об ошибке и вызывает функцию abort из библиотеки stdlib.h, завершающую работу программы.</p>
  <p>Если определена символическая константа NDEBUG, последующие операторы предупреждения будут игнорироваться.</p>
  <code>#define NDEBUG</code>
</article>


<!-- 14 Специальные вопросы языка C -->
<article class="article">
  <div class="anchor" id="p14"></div>
  <h3>14 Специальные вопросы языка C (524)</h3>

  <h4>14.1 Введение (525)</h4>

  <h4>14.2 Переадресация ввода/вывода (525)</h4>

  <p>Существует несколько способов переадресации ввода/вывода в командной строке. Если программе нужно ввести входные данные, то при переадресации ввода данные, которые необходимо ввести, можно взять из файла</p>
  <code>$ sum &lt; input</code>
  <p>Запустится программа sum, символ переадресации &lt; показывает что данные нужно взять из файла input</p>
  <p>Файл a.c</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int n, m;
  puts("Enter 2 integer");
  scanf("%d %d", &n, &m);
  puts("You enter");
  printf("%d %d", n, m);

  return 0;
}
</pre>
  <p>Файл a.dat</p>
  <code>33 900</code>
  <p>Вводим команду компиляции</p>
  <code>$ gcc a.c</code>
  <p>Получаем файл</p>
  <code>a.exe</code>
  <p>Запускаем программу с переадресацией ввода</p>
  <code>./a &lt; a.dat</code>

  <p>Вторым способом переназначения ввода является конвейер |. Конвейер вызывает переадресацию вывода одной программы на ввод другой программы.</p>
  <code>$ random | sum</code>
  <p>Программа random выводит 2 случайных числа и они попадут на ввод программы sum, которая принимает два числа и считает их сумму.</p>

  <p>Если нужно переадресовать вывод данных не на экран, а в файл, используется символ переадресации вывода ></p>
  <code>$ random > out</code>

  <p>Если нужно вывод программы присоединить в конец существующего файла, используется символ переадресации вывода >></p>
  <code>$ random >> out</code>

  <h4>14.3 Списки аргументов переменной длины (526)</h4>

  <p>Можно создавать функции, число аргументов которых не определено. Например, функция printf принимает как минимум один аргумент - строку формата, а далее может быть переменное число аргументов. В заголовочном файле stdarg.h содержатся средства для построения функций с переменным числом аргументов.</p>
  <p>Макросы и определения из заголовочного файла stdarg.h:</p>
  <ol>
    <li>va_list тип, с которым объявляется объект для информации необходимой макросам va_start, va_arg, va_end, чтобы получить доступ к аргументам переменной длины</li>
    <li>va_start макрос, который вызывается перед обращением к аргументам переменной длины, он инициализирует объект, объявленный с типом va_list, необходимый макросам va_arg и va_end</li>
    <li>va_arg макрос, который при каждом вызове указывает на следующий аргумент в списке аргументов переменной длины</li>
    <li>va_end макрос, который обеспечивает нормальный возврат, после вызова макроса va_start</li>
  </ol>
  <p>В определении функции с переменным числом параметров, многоточие может находиться только в конце списка параметров.</p>
  <p>Напишем программу, в которой функция average принимает первым параметром число переменных, потом сами переменные и возвращает их среднее значение.</p>

  <details>
    <summary>Программа 127 (527)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;

double average(int i, ...);

int main() {
  double w = 37.5;
  double x = 22.5;
  double y = 1.7;
  double z = 10.2;
  printf("w = %lf, x = %lf, y = %lf, z = %lf", w, x, y, z);
  printf("average of w and x is ", average(2, w, x));
  printf("average of w, x and y is ", average(3, w, x, y));
  printf("average of w, x, y and z is ", average(4, w, x, y, z));

  return 0;
}

double average(int n, ...) {
  double total = 0;
  va_list ap;
  va_start(ap, n);
  for (int i = 1; i &lt;= n; i++) {
    total += va_arg(ap, double);
  }
  va_end(ap);

  return total / n;
}
</pre>
  </details>

  <h4>14.4 Аргументы командной строки (529)</h4>

  <p>Функция main() может получать аргументы из командной строки через параметры argc и *argv[]</p>
  <code>int main(int argc, char *argv[]) {}</code>
  <ol>
    <li>argc количество аргументов</li>
    <li>argv массив строк, в который сохраняются переданные аргументы</li>
  </ol>
  <p>Напишем программу, которая будет посимвольно копировать один файл в другой. Вызываться такая программу будет с двумя аргументами</p>
  <code>mycopy in.dat out.dat</code>
  <p>in.dat файл из которого посимвольно все копируется в файл out.dat</p>

  <details>
    <summary>Программа 128 (529)</summary>
<pre>
#include &lt;stdio.h&gt;

int main(int argc, char *argv[]) {
  FILE *inPtr;
  FILE *outPtr;
  int c;

  if (argc != 3) {
    puts("usage: copy infile outfile\n");
  } else {
    if ((inPtr = fopen(argv[1], "r")) != NULL) {
      if ((outPtr = fopen(argv[2], "w")) != NULL) {

        while ((c = fgetc(inPtr)) != EOF) {
          fputc(c, outPtr)
        }
      } else {
        puts("file %s could not be opened", argv[2]);
      }
    } else {
      puts("file %s could not be opened", argv[1]);
    }
  }

  return 0;
}
</pre>
  </details>

  <h4>14.5 Замечания относительно компиляции программ из нескольких исходных файлов (530)</h4>

  <p>Определение функции должно целиком находиться в одном файле, его нельзя разделить на несколько файлов. Глобальные переменные доступны любой функции, определенной в том же файле после объявления этих переменных. Чтобы глобальные переменные стали доступны и функциям в других файлах, они должны быть объявлены в каждом из них с помощью слова extern.</p>
  <code>extern int flag;</code>
  <p>После этого можно уже обращаться к переменной. Слово extern указывает компилятору что переменная или уже объявлена в другом файле, или будет объявлена в этом файле но позже.</p>
  <p>Компилятор не знает где будет объявлена эта переменная и предоставляет ее поиск компоновщику. Если компоновщик не найдет объявление переменной flag, то возникнет ошибка компоновки и не будет создано исполняемого файла.</p>
  <p>Чтобы функция была доступна в других файлах достаточно в каждом файле прописать ее прототип и компилировать все вайлы вместе.</p>
  <code>int sum(int, int);</code>
  <p>После этого можно уже обращаться к функции. Прототип функции указывает компилятору что функция или уже объявлена в другом файле, или будет объявлена в этом файле но позже. Слово extern для функций не требуется.</p>
  <p>Компилятор не знает где будет объявлена эта функция и предоставляет ее поиск компоновщику. Если компоновщик не найдет объявление функции, то возникнет ошибка компоновки и не будет создано исполняемого файла.</p>
  <p>Если создавать полезные функции и сохранять их в отдельрных файлах, то их можно переиспользовать в разных программах.</p>
  <p>Если определить функцию или глобальную переменную со словом static, то обратиться к этой функции или переменной из другого файла уже нельзя.</p>
  <p>При разработке больших программ, состоящих из нескольких исходных файлов, компиляция становится утомительной, даже если только в одном файле сделаны небольшие изменения, проиходится перекомпилировать всю программу.</p>

  <h4>14.6 Выход из программы с помощью exit и atexit (532)</h4>

  <p>Программа успешно завершается, когда вызывается команда return в функции main, или когда функция main доходит до своего конца. Но есть и другие способы успешного завершения программы.</p>
  <p>Функция exit вызывает завершение, как если бы она выполнилась нормально. Функция atexit регистрирует функцию, которая должна выполнится при успешном завершении программы.</p>

  <h4>14.7 Квалификатор типа volatile (533)</h4>

  <h4>14.8 Суффиксы для целых констант и констант с плавающей точкой (533)</h4>

  <ul>
    <li>Суффиксы u и U используются для целого unsigned (174u).</li>
    <li>Суффиксы l и L используются для целого long (8358L).</li>
    <li>Суффиксы ul и UL используются для целого unsigned long (28373ul).</li>
  </ul>
  <p>Если целая константа не имеет суффикса, то ее тип определяется ближайшим типом, способным хранить значение такой величины (сначала int, потом long int, потом unsigned long int)</p>
  <ul>
    <li>Суффиксы f и F используются для float (1.28f).</li>
    <li>Суффиксы l и L используются для long double (3.14159L).</li>
  </ul>
  <p>Если константа с правающей точко не имеет суффикса, то она автоматически получает тип double.</p>

  <h4>14.9 Еще раз о файлах (534)</h4>

  <p>Функция tmpfile открывает временный файл в режиме "wb+". Временный файл существует до тех пор пока не будет закрыт функцией fclose, или пока не завершится программа.</p>

  <h4>14.10 Обработка событий (536)</h4>

  <p>Во время выполнения программы могут произойти некоторые события: прерывание, недопустимые инструкции, нарушение сегментации, запрос на завершение от операционной системы, различные ошибки - деление на ноль, переполнение.</p>
  <p>Библиотека signal.h обеспечивает восможность перехвата событий с помощью функции signal, которая принимает два аргумента: целое число - номер сигнала и указатель на функцию обработки сигнала. Сигналы могут генерироваться функцией raise, которая принимает на вход целое число - номер сигнала.</p>

  <h4>14.11 Динамическое выделение памяти: функции calloc и realloc (538)</h4>

  <h4>14.12 Безусловный переход goto (539)</h4>

  <p>Оператор goto можно использовать для эффективного выхода из глубоких уровней вложенных управляющих структур.</p>
</article>


<!-- 15 C++ как улучшенный C -->
<article class="article">
  <div class="anchor" id="p15"></div>
  <h3>15 C++ как улучшенный C (545)</h3>

  <h4>15.1 Введение (546)</h4>

  <p>В первых 14 главах мы разобрали процедурное программирование на языке Си. Главы 15 - 24 мы посвятим языку C++ и объектно-ориентированному программырованию. Рассмотрим классы, инкапсуляцию, объекты, перегрузку операций, наследование, полиморфизм, шаблоны функций и классов.</p>

  <h4>15.2 C++ (546)</h4>

  <p>ООП повышает производительность труда программистов, качество и повторне использования кода.</p>
  <p>C++ был разработан Бьёрном Страуструпом и первоначально назывался "Си с классами". Название языка содержит операцию инкремента ++, намекая на то, что C++ это улучшенная версия Си.</p>
  <p>Версии языка C++ в Америке стандартизируются Американским институтом национальных стандартов ANSI, а во всем мире Международной организацией стандартов ISO.</p>

  <h4>15.3 Простая программа: сложение двух целых (547)</h4>

  <p>Файлы на языке Си имеют расширение .c. Файлы на языке C++ имеют расширение .cpp.</p>

  <details>
    <summary>Программа 129 (547)</summary>
<pre>
#include &lt;iostream&gt;

int main() {
  int integer1;
  std::cout &lt;&lt; "Enter first integer\n";
  std::cin >> integer1;

  int integer2;
  std::cout &lt;&lt; "Enter second integer\n";
  std::cin >> integer2;

  int sum = integer1 + integer2;
  std::cout &lt;&lt; "Sum is " &lt;&lt; sum &lt;&lt; std::endl;

  return 0;
}
</pre>
  </details>

  <p>'\n' выводит символ новой строки. endl выводит символ новой строки и сбрасывает буфер вывода.</p>
  <p>В записи std::cout двойное двоеточие означает что имя cout принадлежит пространству имен std.</p>
  <p>В языке C++ можно создавать собственные типы данных, а также научить C++ вводить и выводить значения этих типов операциями &lt;&lt; и &gt;&gt; (это называется перегрузкой операторов).</p>

  <h4>15.4 Стандартная библиотека C++ (549)</h4>

  <p>Программы на языке C++ конструируются из функций и пользовательских типов данных, называемых классами. Много готовых функций и классов содержится в стандартной библиотеке C++. Поэтому изучение языка C++ сводится к двум аспектам. Первый - это обучение самому языку, второй - изучение как пользоваться функциями и классами стандартной библиотеки. Стандартная библиотека поставляется вместе с компилятором.</p>
  <p>Преимущество создания собственных классов и функций в том, что вы в точности знаете как они работают. Их можно исследовать на уровне исходного кода. Недостаток - значительные затраты сил и времени на разработку и сопровождению новывх функций и классов.</p>

  <h4>15.5 Заголовочные файлы (550)</h4>

  <p>Каждая стандартная библиотека имеет свой заголовочный файл, содержащий прототипы всех функций, определения типов данных и константы.</p>

  <h4>15.6 Inline-функции (552)</h4>

  <p>Все вызовы функции связаны с накладными расходами времени исполнения. Чтобы уменьшить их для функций небольшого размера предусмотрены inline-функции.</p>
  <code>inline int sum(int a, int b){return a + b;}</code>
  <p>Слово inline рекомендует компилятору создавать новую копию функции в месте ее вызова. Копии кода увеличивают размер программы. Но компилятор сам решает создавать копии или нет.</p>
  <p>Использование inline-функций уменьшает время выполнения программы, но увеличивает ее размер. Определение функции всегда располагается перед ее использованием в программе, чтобы компилятор мог раскрыть код функции в точке вызова. Встроенные функции обычно описываются в заголовочных файлах.</p>

  <details>
    <summary>Программа 130 (553)</summary>
<pre>
#include &lt;iostream&gt;

using std::cout;
using std::cin;
using std::endl;

inline double cube(const double s) {
  return s * s * s;
}

int main() {
  double side;

  for (int k = 1; k &lt; 4; k++) {
    cout &lt;&lt; "enter side cube: ";
    cin >> side;
    cout &lt;&lt; "volume cube is " &lt;&lt; cube(side) &lt;&lt; endl;
  }

  return 0;
}
</pre>
  </details>

  <h4>Ссылки и параметры-ссылки (554)</h4>

  <p>Одним из недостатков передачи по значению это то, что копирование большого размера данных может занимать большое время</p>
  <p>Передать аргумент в функцию по ссылке можно двумя способами. Первый это указатели. Второй это передача по ссылке, когда в заголовке функции после типа аргумента стоит & амперсанд.</p>

  <details>
    <summary>Программа 131 (555)</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int squareByValue(int);
void squareByReference(int&);

int main() {
  int x = 2, z = 4;

  cout &lt;&lt; "x = " &lt;&lt; x
       &lt;&lt; "squareByValue(x) = "  &lt;&lt; squareByValue(x)
       &lt;&lt; "x = " &lt;&lt; x &lt;&lt; endl;

  cout &lt;&lt; "z = " &lt;&lt; z
       &lt;&lt; "squareByReference(z) = " &lt;&lt; squareByReference(z)
       &lt;&lt; "z = " &lt;&lt; z &lt;&lt; endl;

  return 0;
}

int squareByValue(int a) {
  return a *= a;
}

void squareByReference(int &cRef) {
  cRef *= cRef;
}
</pre>
  </details>

  <p>Ссылочная переменная должна инициализироваться при объявлении</p>
  <code>int a = 1; int &aRef = a;</code>
  <p>Ссылочная переменная может использоваться как псевдоним для одной переменной. Ссылочную переменную нельзя переприсвоить или использовать как псевдоним другой переменной</p>

  <details>
    <summary>Программа 132 (557)</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int x = 3, &y = x;

  cout &lt;&lt; "x = " &lt;&lt; x
       &lt;&lt; " y = " &lt;&lt; y &lt;&lt; endl;
  y = 7;
  cout &lt;&lt; "x = " &lt;&lt; x
       &lt;&lt; " y = " &lt;&lt; y &lt;&lt; endl;

  return 0;
}
</pre>
  </details>

  <h4>15.8 Пустые списки параметров (559)</h4>

  <p>Есть два способа оставить список параметров функции пустым</p>
  <code>void print1();</code>
  <code>void print2(void);</code>

  <p>В языке Си это означает что отключена всякая проверка аргументов, то есть можно передавать любые аргументы.</p>
  <p>В языке C++ это означает что функция не принимает аргументов.</p>

  <h4>15.9 Аргументы по умолчанию (559)</h4>

  <p>Если в функции есть аргументы по умолчанию, то при вызове функции такие аргументы можно не передавать. Их значения будут взяты из прототипа функции. Определение параметров по умолчанию и в заголовке и в прототипе является синтаксической ошибкой.</p>

  <details>
    <summary>Программа 133 (559)</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int boxVolume(int a = 1, int b = 1, int c = 1);

int main() {
  int x = 3, &y = x;

  cout &lt;&lt; "boxVolume() = " &lt;&lt; boxVolume() &lt;&lt; '\n'
       &lt;&lt; " boxVolume(10) = " &lt;&lt; boxVolume(10); &lt;&lt; '\n'
       &lt;&lt; " boxVolume(10, 5) = " &lt;&lt; boxVolume(10, 5) &lt;&lt; '\n'
       &lt;&lt; " boxVolume(10, 5, 2) = " &lt;&lt; boxVolume(10, 5, 2); &lt;&lt; '\n';

  return 0;
}

int boxVolume(int a, int b, int c) {
  return a * b * c;
}
</pre>
  </details>

  <h4>15.10 Унарная операция разрешения области действия (::) (561)</h4>

  <p>Можно объявлять локальную и глобальную переменную с одинаковым именем. В локальной области видимости глобальная переменная будет скрыта локальной переменной. В этом случае для доступа к глобальной переменной используют <strong>унарную операцию разрешения области действия (::)</strong>. Если имя глобальной переменной не совпадает ни с каким локальным именем, то к ней можно обращаться непосредственно, без разрешения области действия.</p>

  <details>
    <summary>Программа 134 (561)</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int num = 7; // глобальная переменная

int main() {
  double num = 10.5; // локальная переменная

  cout &lt;&lt; "Local num = " &lt;&lt; num &lt;&lt; '\n'
       &lt;&lt; "Global num = " &lt;&lt; ::num &lt;&lt; '\n';

  return 0;
}
</pre>
  </details>

  <p>Нельзя использовать унарную операцию разрешения области действия во внешнем блоке, это будет синтаксической ошибкой.</p>

  <h4>15.11 Перегрузка функций (562)</h4>

  <p>Перегрузка функции это определение нескольких функций с одинаковым именем, но различным набором параметров. Параметры должны иметь разное число или порядок следования их типов. Когда вызывается перегруженная функция, компилятор анализирует порядок и число, порядок и типы аргументов и вызывает нужную.</p>
  <p>Напишем функцию square, которая расчитывает квадрат переменной типа int или double.</p>

  <details>
    <summary>Программа 135 (562)</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int square(int x) {
  return x * x;
}

double square(double y) {
  return y * y;
}

int main() {
  cout &lt;&lt; square(7) &lt;&lt; '\n';
  cout &lt;&lt; square(7.5) &lt;&lt; '\n';

  return 0;
}
</pre>
  </details>

  <h4>Как компилятор различает перегруженные функции</h4>

  <p>Перегруженные функции различаются по их сигнатурам. Сигнатура - это комбинация имени функции и параметров в определенном порядке и с определенными типами. Компилятор кодирует идентификатор каждой функции в зависимости от сигнатуры. Это гарантирует что будет вызвана нужная функция.</p>
  <p>Закодированное имя выглядит так</p>
  <ol>
    <li>__ два символа подчеркивания</li>
    <li>Z</li>
    <li>Число - количество букв в имени функции</li>
    <li>Имя функции</li>
    <li>Список параметров в порядке их следования. c - char, i - int, d - double, Ri - int&, Rf - float&</li>
  </ol>
  <code>int square(int x);  // __Z6squarei</code>
  <code>double square(double y);  // __Z6squared</code>
  <code>void print(char a, int b, float& c, double& d); // __Z5printciRfRd</code>

  <h4>15.12 Шаблоны функций (565)</h4>

  <p>Если действие перегруженных функций для всех типов идентично, то удобно и компактно можно их записать в виде <strong>шаблона функций</strong>. Один шаблон функции определяет целое семейство перегруженных функций.</p>
  <p>Шаблон функции начинается со слова <strong>template</strong>, за которым следует список параметров шаблона в угловых скобках &lt; &gt;. Параметр шаблона называются <strong>формальным параметром типа</strong>. Перед каждым параметром пишется ключевое слово <strong>class</strong> или <strong>typename</strong>.</p>
  <code>template &lt;class T&gt;</code>
  <code>template &lt;typename T&gt;</code>
  <p>Напишем функцию нахождения максимума трех чисел и поместим ее в заголовочный файл maximum.h</p>

  <details>
    <summary>Программа 136 (566)</summary>
<pre>
template &lt;class T&gt;
T maximum(T a, T b, T c) {
  T maxValue = a;
  if (b > maxValue) {
    maxValue = b;
  }
  if (c > maxValue) {
    maxValue = c;
  }

  return maxValue;
}
</pre>
  </details>
  <p>Напишем программу, которая сначала подключает заголовочный файл maximum.h, затем находит максимум трех чисел типа int, трех чисел типа double и трех чисел типа char</p>

  <details>
    <summary>Программа 137 (566)</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;maximum.h&gt;

using namespace std;

int main() {
  int i1 = 2, i2 = 5, i3 = 10;
  cout &lt;&lt; "maximum of 2, 5, 10 is " &lt;&lt; maximum(i1, i2, i3) &lt;&lt; '\n';

  double d1 = 2.9, d2 = 5.12, d3 = 10.7;
  cout &lt;&lt; "maximum of 2.9, 5.12, 10.7 is " &lt;&lt; maximum(d1, d2, d3) &lt;&lt; '\n';

  char c1 = 'a', c2 = 'B', c3 = 'v';
  cout &lt;&lt; "maximum of 'a', 'B', 'v' is " &lt;&lt; maximum(c1, c2, c3) &lt;&lt; '\n';

  return 0;
}
</pre>
  </details>

  <h4>Введение в объектную технологию и UML (567)</h4>

  <p>Унифицированный язык моделирования UML (Unified Modeling Language) - графический язык, позволяющий при разработке систем программного обеспечения, пользоваться стандартными обозначениями.</p>

  <h4>Основные понятия объектной технологии</h4>

  <p>Объект, свойство, метод, наследование, инкапсуляция, интерфейс, класс, экземпляр.</p>

  <h4>Классы, элементы данных и элемент-функции</h4>

  <p>Классы - это созданные пользователем типы данных. Каждый класс содержит как данные, так и функции для работы с ними. Класс это план, чертеж для построения объекта. Классы можно использовать при написании новых классов.</p>

  <h4>Введение в объектно-ориентированный анализ и проектирование</h4>

  <p>Чтобы написать небольшую программу, проектирование не требуется. Чтобы написать большую программу необходимо анализировать требования задания и разработать проект. Когда в команде 1000 человек, требуется делится друг с другом результатами своей работы. Широкое распространение получил графический язык UML для передачи результатов любого процесса. UML был разработан в середине 90-х годов под руководством Грейди Буча.</p>
  <p>Унифицированный язык моделирования UML является сейчас наиболее широко распространенной схемой графического представления для моделирования объектно-ориентированных систем. Все разработчики могут выразить свои проекты с помощью единого стандартного набора графических обозначений.</p>

  <h4>5.14 Заключение</h4>
</article>


<!-- 16 Введение в классы и объекты -->
<article class="article">
  <div class="anchor" id="p16"></div>
  <h3>16 Введение в классы и объекты (576)</h3>

  <h4>16.1 Введение (577)</h4>

  <p>Разработчикам приходится работать с программами, состоящими из тысяч классов.</p>

  <h4>16.2 Классы, объекты, элемент-функции и элементы данных (577)</h4>

  <p>В C++ мы начинаем с создания программной единицы, называемой классом, в которую входит функция. Функция, принадлежащая классу, называется его элемент-функцией. Атрибуты, принадлежащие классу, называются элементами данных класса. Сам класс это чертеж, проект для создания объекта. Реальными функуиями, которые можно выполнить и реальными данными, с которыми можно работать, обладает только объект, созданный как экземпляр класса.</p>

  <h4>16.3 Определение класса с элемент-функцией (579)</h4>

  <p>Определим класс GradeBook с элемент-функцией displayMessage.</p>

  <details>
    <summary>Программа 138 (579)</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

class GradeBook {
public:
  void displayMessage() {
    cout &lt;&lt; "Welcome to the Grade Book" &lt;&lt; endl;
  }
};

int main() {
  GradeBook myGradeBook;
  myGradeBook.displayMessage;

  return 0;
}
</pre>
  </details>

  <p>В программе 138 сначала определяется класс GradeBook. Определение класса GradeBook содержит элемент-функцию displayMessage, которая выводит сообщение на экран. Нельзя вызвать элемент-функцию класса, пока не будет создан объект этого класса. В функции main мы создаем объект класса GradeBook. И вызываем функцию displayMessage у этого объекта. Тип переменной myGradeBook является класс GradeBook, который мы написали заранее. Каждый новый класс, который вы создаете, становится новым типом, который можно использовать для создания объектов.</p>

  <h4>Классовая диаграмма UML для класса GradeBook</h4>

  <p>В UML каждый класс обозначается прямоугольником с тремя отделениями. Верхнее отделение содержит имя класса. Среднее отделение перечисляет атрибуты класса, это элементы данных. Нижнее отделение перечисляет элемент-функции класса. Знак + перед элемент-функцией означает, что функция является открытой, то есть доступной другим функциям.</p>

  <h4>16.4 Определение элемент-функции с параметром (582)</h4>

  <p>При вызове функции в круглых скобках пишутся аргументы, которые передаются функции. Значения аргументов копируются в параметры функции.</p>
  <p>Определим новый класс GradeBook с функцией displayMessage, которая принимает параметр courseName.</p>

  <details>
    <summary>Программа 139 (582)</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

class GradeBook {
public:
  void displayMessage(string courseName) {
    cout &lt;&lt; "Welcome to the Grade Book for\n"
    &lt;&lt; courseName &lt;&lt; endl;
  }
};

int main() {
  string nameOfCourse;
  GradeBook myGradeBook;

  cout &lt;&lt; "Enter course name: ";
  getline(cin, nameOfCourse);
  myGradeBook.displayMessage(nameOfCourse);

  return 0;
}
</pre>
  </details>

  <p>Функция getline читает строку целиком. Почему мы не использовали извлечения "cin &lt;&lt;"? Потому что "cin &lt;&lt;" читает строку только до пробельного символа.</p>

  <h4>16.5 Элементы данных, set-функции и get-функции (585)</h4>

  <p>Напишем новый класс GradeBook, который содержит элемент-функции setCourseName, getCourseName и displayMessage.</p>

  <details>
    <summary>Программа 140 (586)</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

class GradeBook {
public:

  void setCourseName(string name) {
    courseName = name;
  }

  string getCourseName() {
    return courseName;
  }

  void displayMessage() {
    cout &lt;&lt; "Welcome to the Grade Book for\n"
    &lt;&lt; getCourseName() &lt;&lt; endl;
  }

private:
  string courseName;
};

int main() {
  string nameOfCourse;
  GradeBook myGradeBook;

  cout &lt;&lt; "Initial course name is "
  &lt;&lt; myGradeBook.getCourseName() &lt;&lt; endl;

  cout &lt;&lt; "Enter course name: ";
  getline(cin, nameOfCourse);

  myGradeBook.setCourseName(nameOfCourse);
  myGradeBook.displayMessage();

  return 0;
}
</pre>
  </details>

  <h4>Спецификаторы доступа public и private</h4>

  <p>После метки private переменные и функции доступны только для элемент-функций данного класса. Если данные и функции используются только элемен-функциями класса, то их нужно объявлять как private. По умолчанию данные и функции объявленные в классе закрытые (private).</p>
  <p>Сокрытие данных и функций класса от доступа извне называется инкапсуляцией.</p>

  <h4>16.6 Инициализация объектов при помощи конструкторов (592)</h4>

  <p>Конструктор используется для инициализации объекта класса при его создании. Конструктор это элемент-функция класса, имеющая то же имя что и класс, чтобы компилятор мог отличить его от других функций класса. Конструкторы не возвращают значение, поэтому перед ними не пишется никакой тип, даже void.</p>
  <p>Когда объект создается, конструктор вызывается автоматически. Если в классе не определен конструктор, то компилятор предоставляет ему конструктор по умолчанию, то есть без параметров. Для элементов данных, являющихся объектами других классов, конструктор по умолчанию неявно вызывает их конструкторы по умолчанию, чтобы гарантировать корректную инициализацию элементов данных. Например, объявляя элемент данных типа string, конструктор по умолчанию класса string устанавливает в качестве значения элементу данных пустую строку.</p>

  <details>
    <summary>Программа 141 (593)</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

class GradeBook {
public:

  GradeBook(string name) {
    setCourseName(name);
  }

  void setCourseName(string name) {
    courseName = name;
  }

  string getCourseName() {
    return courseName;
  }

  void displayMessage() {
    cout &lt;&lt; "Welcome to the Grade Book for\n"
    &lt;&lt; getCourseName() &lt;&lt; endl;
  }

private:
  string courseName;
};

int main() {
  GradeBook gradeBook1("CS101 Introduction to C++");
  GradeBook gradeBook1("CS102 Data Structures in C++");

  cout &lt;&lt; "gradeBook1 for "
  &lt;&lt; gradeBook1.getCourseName() &lt;&lt; '\n';

  cout &lt;&lt; "gradeBook2 for "
  &lt;&lt; gradeBook2.getCourseName() &lt;&lt; '\n';

  return 0;
}
</pre>
  </details>

  <p>Любой конструктор, не принимающий аргументов, называется конструктором по умолчанию. Класс получает конструктор по умолчанию в двух случаях:</p>
  <ol>
    <li>Если программист не определил конструктор, то его создает компилятор. Такой конструктор не инициализирует данные, а вызывает конструкторы по умолчанию для каждого элемента данных, являющегося объектом другого класса.</li>
    <li>Если программист определил конструктор, то он произведен инициализацию, определенную программистом. Также будет вызван конструктор для каждого элемента данных, являющегося объектом другого класса.</li>
  </ol>

  <h4>16.7 Размещение класса в отдельном файле (596)</h4>

  <p>Создадим файл GradeBook.h, в который вынесем описание класса GradeBook</p>

  <details>
    <summary>Файл GradeBook.h (597)</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

class GradeBook {
public:

  GradeBook(string name) {
    setCourseName(name);
  }

  void setCourseName(string name) {
    courseName = name;
  }

  string getCourseName() {
    return courseName;
  }

  void displayMessage() {
    cout &lt;&lt; "Welcome to the Grade Book for\n"
    &lt;&lt; getCourseName() &lt;&lt; endl;
  }

private:
  string courseName;
};
</pre>
  </details>

  <p>В файле с программой подключим заголовочный файл GradeBook.h, чтобы можно было воспользоваться классом GradeBook</p>

  <details>
    <summary>Программа 142 (598)</summary>
<pre>
#include &lt;iostream&gt;
#include "GradeBook.h"

using namespace std;

int main() {
  GradeBook gradeBook1("CS101 Introduction to C++");
  GradeBook gradeBook2("CS102 Data Structures in C++");

  cout &lt;&lt; "gradeBook1 for "
  &lt;&lt; gradeBook1.getCourseName() &lt;&lt; '\n';

  cout &lt;&lt; "gradeBook2 for "
  &lt;&lt; gradeBook2.getCourseName() &lt;&lt; '\n';

  return 0;
}
</pre>
  </details>

  <p>Хотя классы содержат элементы-дынные и элементы-функции, объекты C++ обычно содержат только данные. Компилятор создает только один экземпляр элемент-функций класса, поскольку они одинаковые для всех объектов данного класса. Но каждому объекту нужен свой экземпляр элементов данных, поскольку их значения различаются у разных объектов. Поэтому размер объекта зависит от размера памяти, необходимой для хранения элементов данных класса.</p>
  <p>После того, как мы создали класс GradeBook и поместили его в отдельный файл GradeBook.h, мы можем включить этот файл в любую программу и создавать объекты класса GradeBook</p>
  <p>Для использования объекта класса коду клиента необходимо знать только то, какие нужно вызывать элемент-функции, какие аргументы нужно передавать и какой результат ожидать. Коду клиента не требуется знать как эти функции реализованы. Если код клиента знает, как реализован класс, то программист может использовать знание деталей реализации. И если реализвация функций изменится, то придется переписывать и код клиента. Поэтому сокрытие реализации класса устраняет изменения в коде клиента.</p>
  <p>Для сокрытия реализации функций класса нужно код класса разбить на два файла. Первый файл .h заголовочный с прототипами функций, второй файл исохдного кода .cpp с реализацией функций. Оба файла должны именть одинаковое имя и названы именем класса, который в них описывается.</p>

  <h4>16.8 Отделение интерфейса от реализации (600)</h4>

  <p>Интерфейс класса определяет какие действия можно производить с объектом, а не как эти действия реализованы внутри класса. Интерфейс класса состоит из открытых (доступных) элемент-функций. Описать интерфейс класса можно написав определение класса, в котором будут перечислены только имена, возвращаемые типы и типы параметров элемент-функций.</p>
  <p>Чтобы программисты не писали код, зависящий от делатей реализации класса, лучше определять элемент-функции вне определения класса, чтобы скрыть от клиента детали их реализации.</p>
  <p>Перепишем программу так, чтобы она размещалась в трех файлах GradeBook.h, GradeBook.cpp, main.cpp</p>

  <details>
    <summary>Файл GradeBook.h (601)</summary>
<pre>
#include &lt;string&gt;

using namespace std;

class GradeBook {
public:

  GradeBook(string);
  void setCourseName(string);
  string getCourseName();
  void displayMessage();

private:
  string courseName;
};
</pre>
  </details>

  <details>
    <summary>Файл GradeBook.cpp (602)</summary>
<pre>
#include &lt;iostream&gt;
#include "GradeBook.h"

using namespace std;

GradeBook::GradeBook(string name) {
  setCourseName(name);
}

void GradeBook::setCourseName(string name) {
  courseName = name;
}

string GradeBook::getCourseName() {
  return courseName;
}

void GradeBook::displayMessage() {
  cout &lt;&lt; "Welcome to the Grade Book for\n"
  &lt;&lt; getCourseName() &lt;&lt; endl;
}
</pre>
  </details>

  <p>В файле GradeBook.cpp перед каждым именем элемент-функции стоит тип возвращаемого значения, имя класса, оператор :: разрешения области действия. Без этого компилятор не знал бы что эти функции принадлежат классу GradeBook.</p>
  <p>Отделение интерфейса класса (файл GradeBook.h) от реализации его элемент-функций (файл GradeBook.cpp) не влияет на то как код клиента использует его класс. Изменяется только процесс компиляции и компоновки программы.</p>

  <details>
    <summary>Программа 143 (604)</summary>
<pre>
#include &lt;iostream&gt;
#include "GradeBook.h"

using namespace std;

int main() {
  GradeBook gradeBook1("CS101 Introduction to C++");
  GradeBook gradeBook2("CS102 Data Structures in C++");

  cout &lt;&lt; "gradeBook1 for "
  &lt;&lt; gradeBook1.getCourseName() &lt;&lt; '\n';

  cout &lt;&lt; "gradeBook2 for "
  &lt;&lt; gradeBook2.getCourseName() &lt;&lt; '\n';

  return 0;
}
</pre>
  </details>

  <h4>Процесс компиляции и компоновки</h4>

  <p><strong>Программист класса</strong> GradeBook пишет заголовочный файл GradeBook.h и файл исходного кода GradeBook.cpp, который подключает директивой #include заголовочный файл, а затем компилирует файл исходного кода, чтобы получить <strong>объектный файл</strong> с кодом класса GradeBook. Чтобы скрыть детали реализации элемент-функций класса GradeBook, <strong>программист класса</strong> передает <strong>программисту кода клиента</strong> только заголовочный файл GradeBook.h. и <strong>объектный файл</strong> с кодом класса GradeBook. Объектный файл содержит инструкции машинного языка.</p>
  <p><strong>Программист кода клиента</strong> пишет свой код и в его начале подключает директивой #include заголовочный файл GradeBook.h. Когда код клиента компилируется, компилятор использует определение класса в GradeBook.h для того, чтобы убедиться в корректности создания объектов класса GradeBook и действий с ними.</p>
  <p>При компоновке соединяются вместе в одной программе код клиента, код реализации класса GradeBook и код стандартных библиотек. На выходе компоновщика получается исполняемое приложение.</p>

  <h4>16.9 Верификация данных посредством set-функций (606)</h4>

  <p>Set-функции предоставляют клиентам возможность модификации закрытых элементов данных. Перед тем как новые данные будут записаны, set-функции могут проверить их на корректность.</p>
  <p>В нашей программе перепишем функцию setCourseName так, чтобы она проверяла длину имени курса. Если длина больше 25 символов, то она урезается до 25 символов и записывается в переменную courseName.</p>

  <details>
    <summary>Файл GradeBook.h (607)</summary>
<pre>
#include &lt;string&gt;

using namespace std;

class GradeBook {
public:

  GradeBook(string);
  void setCourseName(string);
  string getCourseName();
  void displayMessage();

private:
  string courseName;
};
</pre>
  </details>

  <details>
    <summary>Файл GradeBook.cpp (607)</summary>
<pre>
#include &lt;iostream&gt;
#include "GradeBook.h"

using namespace std;

GradeBook::GradeBook(string name) {
  setCourseName(name);
}

void GradeBook::setCourseName(string name) {
  if (name.length() &lt;= 25) {
    courseName = name;
  }
  if (name.length() > 25) {
    courseName = name.substr(0, 25);
    cout &lt;&lt; "Name " &lt;&lt; name
    &lt;&lt; "exceeds maximum length 25 characters" &lt;&lt; endl;
  }

}

string GradeBook::getCourseName() {
  return courseName;
}

void GradeBook::displayMessage() {
  cout &lt;&lt; "Welcome to the Grade Book for\n"
  &lt;&lt; getCourseName() &lt;&lt; endl;
}
</pre>
  </details>

  <details>
    <summary>Программа 144 (609)</summary>
<pre>
#include &lt;iostream&gt;
#include "GradeBook.h"

using namespace std;

int main() {
  GradeBook gradeBook1("CS101 Introduction to Programming in C++");
  GradeBook gradeBook2("CS102 C++ Data Structures");

  cout &lt;&lt; "gradeBook1 for "
  &lt;&lt; gradeBook1.getCourseName() &lt;&lt; '\n';

  cout &lt;&lt; "gradeBook2 for "
  &lt;&lt; gradeBook2.getCourseName() &lt;&lt; '\n';

  GradeBook gradeBook1("CS101 C++ Programming");

  cout &lt;&lt; "gradeBook1 for "
  &lt;&lt; gradeBook1.getCourseName() &lt;&lt; '\n';

  return 0;
}
</pre>
  </details>
</article>


<!-- 17 Классы: часть 1 -->
<article class="article">
  <div class="anchor" id="p17"></div>
  <h3>17 Классы: часть 1 (618)</h3>

  <h4>17.1 Введение (619)</h4>

  <p>Класс в программе может определяться только один раз. Нужно использовать препроцессорную обработку в заголовочных файлах, чтобы исключить повторное включение кода из заголовочного файла в исходный файл.</p>
  <p>К отдельным элементам класса можно обращаться через дескрипторы. Есть три типа дескриптора: имя объекта, ссылка на объект, указатель на объект. Имя и ссылка на объект предоставляют доступ к элементу через операцию "." точка. Указатель на объект - через операцию "->" стрелка.</p>
  <p>Объекты одного класса могут присваиваться друг другу посредством поэлементного присваивания, которое копирует элементы объекта.</p>

  <h4>17.2 Пример: класс Time(620)</h4>

  <details>
    <summary>Файл Time.h (620)</summary>
<pre>
#ifndef TIME_H
#define TIME_H

class Time {
public:
  Time();
  void setTime(int, int, int);
  void printUniversal();
  void printStandard();

private:
  int hour;
  int minute;
  int second;
};

#endif
</pre>
  </details>

  <p>Директивы #ifndef, #define, #endif используются для препроцессорной обертки, предотвращающей многократное включение заголовочного файла в программу.</p>

  <details>
    <summary>Файл Time.cpp (622)</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include "Time.h"

using namespace std;

Time::Time() {
  hour = minute = second = 0;
}

void Time::setTime(int h, int m, int s) {
  hour = (h >= 0 && n &lt; 24) ? h : 0;
  minute = (m >= 0 && m &lt; 60) ? m : 0;
  second = (s >= 0 && s &lt; 60) ? s : 0;
}

void Time::printUniversal() {
  cout &lt;&lt; setfill('0') &lt;&lt; setw(2)
  &lt;&lt; hour &lt;&lt; ":" &lt;&lt; setw(2)
  &lt;&lt; minute &lt;&lt; ":" &lt;&lt; setw(2)
  &lt;&lt; second;
}

void Time::printStandard() {
  cout &lt;&lt; ((hour == 0 || hour == 12) ? 12 : hour % 12)
  &lt;&lt; ":" &lt;&lt; setfill('0') &lt;&lt; setw(2)
  &lt;&lt; minute &lt;&lt; ":" &lt;&lt; setw(2)
  &lt;&lt; second &lt;&lt; (hour &lt; 12 ? " AM" : " PM");
}
</pre>
  </details>

  <details>
    <summary>Программа 145 (625)</summary>
<pre>
#include &lt;iostream&gt;
#include "Time.h"

using namespace std;

int main() {
  Time t;

  cout &lt;&lt; "initial universal time is ";
  t.printUniversal();
  cout &lt;&lt; "initial standard time is ";
  t.printStandard();

  t.setTime(13, 27, 6);

  cout &lt;&lt; "initial universal time is ";
  t.printUniversal();
  cout &lt;&lt; "initial standard time is ";
  t.printStandard();

  t.setTime(99, 99, 99);

  cout &lt;&lt; "initial universal time is ";
  t.printUniversal();
  cout &lt;&lt; "initial standard time is ";
  t.printStandard();

  return 0;
}
</pre>
  </details>

  <h4>О композиции и наследовании</h4>

  <p>Включение объектов класса в качестве элементов других классов называется композицией. Порождение новых классов от существующих называется наследованием.</p>

  <h4>Размер объекта</h4>

  <p>Объекты содержат только данные, поэтому они меньше, чем если бы они содержали еще и функции. Применение к имени класса или объекту операции sizeof покажет только размер данных этого класса. Компилятор создает всего один экземпляр элемент-функций, отдельный от всех объектов класса.</p>

  <h4>17.3 Область действия класса и доступ к элементам класса (627)</h4>

  <details>
    <summary>Программа 146 (628)</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

class Count {
public:
  void setX(int value) {
    x = value;
  }

  void print() {
    cout &lt;&lt; x &lt;&lt; endl;
  }

private:
  int x;
}

int main() {
  Count counter;
  Count *counterPtr = &counter;
  Count &counterRef = counter;

  cout &lt;&lt; "Set x to 1 and print";
  counter.setX(1);
  counter.print();

  cout &lt;&lt; "Set x to 2 and print";
  counterRef.setX(2);
  counterRef.print();

  cout &lt;&lt; "Set x to 3 and print";
  counterPtr->setX(3);
  counterPtr->print();

  return 0;
}
</pre>
  </details>

  <h4>17.4 Отделение интерфейса от реализации (629)</h4>

  <p>Чтобы использовать класс, его клиентам не требуется доступ к исходному коду класса. Производители классовых библиотек поставляют заголовочные файлы и объектные модули. Информация, важная для клиента в плане использования интерфейса класса, должна включаться в заголовочный файл.</p>

  <h4>17.5 Функции доступа и сервисные функции (630)</h4>

  <p>Функции доступа читают или выводят данные, а также могут проверять истинность некоторого условия. Функция isEmpty может проверять любой объект класса-контейнер не пустой ли он, перед попыткой прочитать из него данные. Функция isFull может проверять любой объект класса контейнер есть ли в нем еще свободное место, перед попыткой записать в него данные.</p>
  <p>Сервисная функция не входит в состав открытого интерфейса класса. Сервисные функции не предназначены для использования клиентами класса, но могут вызываться другими функциями класса.</p>

  <details>
    <summary>Файл SalesPerson.h</summary>
<pre>
#ifndef SALESP_H
#define SALESP_H

class SalesPerson {
public:
  SalesPersoon();
  void getSalesFromUser();
  void setSales(int, double);
  void printAnnualSales();

private:
  double totalAnnualSales();
  double sales[12];
};

#endif
</pre>
  </details>

  <details>
    <summary>Файл SalesPerson.cpp</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include "SalesPerson.h"

using namespace std;

SalesPerson::SalesPerson() {
  for (int i = 0; i &lt; 12; i++) {
    sales[i] = 0.0;
  }
}

void SalesPerson::getSalesFromUser() {
  double salesFigure;
  for (int i = 1; i &lt;= 12; i++) {
    cout &lt;&lt; "Enter sales amount for month " &lt;&lt; i;
    cin >> salesFigure;
    setSales(i, salesFigure);
  }
}

void SalesPerson::setSales(int month, double amount) {
  if (month >= 1 && month &lt;= 12 && amount > 0) {
    sales[month - 1] = amount;
  } else {
    cout &lt;&lt; "Invalid month or sales figure" &lt;&lt; endl;
  }
}

void SalesPerson::printAnnualSales() {
  cout &lt;&lt; setprecision(2) &lt;&lt; fixed
  &lt;&lt; "\nThe total annual sales are: $"
  &lt;&lt; totalAnnualSales() &lt;&lt; endl;
}

double SalesPerson::totalAnnualSales() {
  double total = 0.0;
  for (int i = 0; i &lt; 12; i++) {
    total += sales[i];
  }
  return total;
}
</pre>
  </details>

  <details>
    <summary>Программа 147 (632)</summary>
<pre>
#include "SalesPerson.h"

int main() {
  SalesPerson s;

  s.getSalesFromUser();
  s.printAnnualSales();

  return 0;
}
</pre>
  </details>

  <h4>17.6 Пример: класс Time. Конструкторы с аргументами по умолчанию</h4>

  <details>
    <summary>Файл Time.h</summary>
<pre>
#ifndef TIME_H
#define TIME_H

class Time {
public:
  Time(int = 0, int = 0, int = 0);

  void setTime(int, int, int);
  void setHour(int);
  void setMinute(int);
  void setSecond(int);

  int getHour();
  int getMinute();
  int getSecond();

  void printUniversal();
  void printStandard();

private:
  int hour;
  int minute;
  int second;
};

#endif
</pre>
  </details>

  <details>
    <summary>Файл Time.cpp</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include "Time.h"

using namespace std;

Time::Time(int hr, int min, int sec) {
  setTime(hr, min, sec);
}

void Time::setTime(int h, int m, int s) {
  setHour(h);
  setMinute(m);
  setSecond(s);
}

void Time::setHour(int h) {
  hour = (h >= 0 && h &lt; 24) ? h : 0;
}

void Time::setMinute(int m) {
  minute = (m >= 0 && m &lt; 60) ? m : 0;
}

void Time::setSecond(int s) {
  second = (s >= 0 && s &lt; 60) ? s : 0;
}

int Time::getHour() {
  return hour;
}

int Time::getMinute() {
  return minute;
}

int Time::getSecond() {
  return second;
}

void Time::printUniversal() {
  cout &lt;&lt; setfill('0')
  &lt;&lt; setw(2) &lt;&lt; getHour() &lt;&lt; ":"
  &lt;&lt; setw(2) &lt;&lt; getMinute() &lt;&lt; ":"
  &lt;&lt; setw(2) &lt;&lt; getSecond();

}

void Time::printStandard() {
  cout &lt;&lt; ((getHour() == 0 || getHour() == 12) ? 12 : getHour() % 12)
  &lt;&lt; ":" &lt;&lt; setfill('0')
  &lt;&lt; setw(2) &lt;&lt; getMinute() &lt;&lt; ":"
  &lt;&lt; setw(2) &lt;&lt; getSecond()
  &lt;&lt; (hour &lt; 12 ? " AM" : " PM");
}
</pre>
  </details>

  <details>
    <summary>Программа 148 (636)</summary>
<pre>
#include &lt;iostream&gt;
#include "Time.h"

using namespace std;

int main() {
  Time t1;
  Time t2(2);
  Time t3(21, 34);
  Time t4(12, 25, 42);
  Time t5(27, 74, 99);

  cout &lt;&lt; "t1 = ";
  t1.printUniversal();
  t1.printStandard();

  cout &lt;&lt; "t2 = ";
  t2.printUniversal();
  t2.printStandard();

  cout &lt;&lt; "t3 = ";
  t3.printUniversal();
  t3.printStandard();

  cout &lt;&lt; "t4 = ";
  t4.printUniversal();
  t4.printStandard();

  cout &lt;&lt; "t5 = ";
  t5.printUniversal();
  t5.printStandard();

  return 0;
}
</pre>
  </details>

  <p>set и get функции вызываются в теле класса в других функциях повсюду. Функция setTime вызывает функции setHour, setMinute, setSecond. Функции printUniversal и printStandard вызывают функции getHour, getMinute, getSecond. Конечно, можно было бы обращаться к закрытым данным напрямую, но если представление данных изменится, то все эти функции придется тоже изменять. А когда обращаются к данным через set и get функции, то достаточно будет изменить только их.</p>

  <h4>17.7 Деструкторы (638)</h4>

  <p>Деструктор это специальная элемент-функция класса, которая образуется из имени класса, перед которым ставит символ тильды ~. Деструктор вызывается неявно при уничтожении объекта. Например, когда программа выходит из области видимости объекта. Сам деструктор не освобождает память, но позволяет выполнить некоторые действия перед тем, как система освободит память.</p>
  <p>Деструктор не принимает параметров, ничего не возвращает и не может иметь возвращаемый тип, даже void.</p>
  <p>Деструктор, как и конструктор, есть в каждом классе. Если деструктор не определяется явным образом, то компилятор создаст автоматически деструктор по умолчанию.</p>

  <h4>17.8 Когда вызываются конструкторы и деструкторы (639)</h4>

  <p>Конструкторы и деструкторы вызываются компилятором неявно. Порядок вызовов зависит от области действия и класса памяти объекта.</p>
  <p>Конструктор объекта в глобальной области вызывается до выполнения любых функций (даже функции main). Деструкторы вызываются по завершении функции main. Функции exit и abort заставляют завершиться программу немедленно, не вызывая никаких деструкторов глобальных объектов.</p>
  <p>Конструктор автоматического объекта вызывается в том месте, где объект определяется. Деструктор вызывается, когда программа выходит из области действия объекта. Конструкторы и деструкторы вызываются каждый раз когда программа входит и выходит из области действия объекта. Функции exit и abort заставляют завершиться программу немедленно, не вызывая никаких деструкторов автоматических объектов.</p>
  <p>Конструктор статического локального объекта вызывается только один раз в точке определения объекта. Деструктор вызывается когда завершается функция main или вызывается функция exit. Функция abort не вызывает деструктора статического локального объекта.</p>

  <h4>17.9 Пример: класс Time. Скрытая ошибка - возвращение ссылки на закрытый элемент данных (642)</h4>

  <h4>17.10 Поэлементное присваивание по умолчанию (645)</h4>

  <p>Операция присваивания (=) может примняться для присваивания одного объекта другому объекту того же типа.</p>
  <p>Объекты могут передаваться функциям в качестве аргументов и могут возвращаться функциями. По умолчанию передается или возвращается копия объекта. Передача по значению ухудшает эффективность, когда приходится делать копию большого объекта. Передача по ссылке обеспечивает хорошую эффективность. Если при этом нужно, чтобы объект оставался неизменным, нужна передача по константной ссылке.</p>
</article>


<!-- 18 Классы: часть 2 -->
<article class="article">
  <div class="anchor" id="p18"></div>
  <h3>18 Классы: часть 2 (654)</h3>

  <h4>18.2 Константные объекты и константные элемент-функции (655)</h4>

  <p>Используя слово const, можно указать, что объект нельзя модифицировать</p>
  <code>const Time noon(12, 0, 0);</code>
  <p>Попытки измнить объект noon выявляются во время компиляции, а не приводят к ошибкам времени выполнения.</p>
  <p>Конструкторы и деструкторы обычно изменяют свои объекты и не могут объявляться как const.</p>

  <h4>18.3 Композиция: объекты в качестве элементов класса (665)</h4>

  <p>Композиция это когда класс содержит в качестве элементов объекты других классов.</p>

  <h4>18.4 Дружественные функции и дружественные классы (671)</h4>

  <p>Дружественная функция класса определяется вне области действия этого класса и имеет доступ к приватным и публичным его элементам. Внутри класса ClassOne объявим дружественный класс ClassTwo</p>
  <code>friend class ClassTwo;</code>

  <h4>18.5 Указатель this (673)</h4>

  <p>Каждый объект имеет доступ к своему собственному адресу через указатель this. Указатель this передается компилятором объекту в качестве неявного аргумента вызова каждой не статической его функции.</p>
  <p>Объекты используют указатель this для доступа к своим элементам</p>

  <h4>18.6 Статические элементы класса (679)</h4>

  <p>Если все объекты класса должны иметь какие-то общие данные, то эти данные делают статическими элементами класса. Статические элементы класса существуют даже если не существует ни одного объекта этого класса.</p>
  <p>Статическая элемент-функция не имеет указателя this. Указатель this должен ссылаться на конкретный объект, но в памяти может не быть никаких объектов класса.</p>

  <h4>18.7 Абстракция данных и сокрытие информации (683)</h4>

  <p>Класс обычно скрывает подробности своей реализации от клиентов. Например, стек может быть реализован на массиве или на связном списке. Клиенту класса стека не нужно знать о его внутреннем устройстве. Клиент должне значть какие действия можно произвести со стеком, а не то, как они реализуются. Даже если программист знает детали реализации класса, он не должен писать код, зависящий от этих деталей.</p>
  <p>Понятие абстрактных типов данных позволяет улучшить процесс разработки программ. Например, сравним целое число и компьютерный тип int. Тип int это не целое число, а его абстрактное представление. Он имеет фиксированный размер. Если результат вычислений выходит за диапазон типа int, то происходит его переполнение. С математическими целыми этой проблемы не возникает. Тип int это только приближение к понятию целого числа.</p>
</article>


<!-- 19 Перегрузка операций. Объекты Array и String -->
<article class="article">
  <div class="anchor" id="p19"></div>
  <h3>19 Перегрузка операций. Объекты Array и String (690)</h3>

  <h4>19.1 Введение (691)</h4>

  <p>Пример перегруженной операции &lt;&lt;, которая используется и как передача в поток и как побитовый сдвиг влево. Еще одна перегруженная операция >>, которая используется и как извлечение из потока и как побитовый сдвиг вправо. Обе эти операции перегружаются в стандартной библиотеке C++.</p>
  <p>Еще примеры перегруженных операций это + и -. Они работают по разному в зависимости от контекста (типа и количества операндов). Действия можно выполнить и посредством вызова функций, но если выполнять их перегруженными операциями, то это будет яснее и понятней.</p>
  <p>В библиотечном классе string используется много перегруженных операций.</p>

  <h4>19.2 Основы перегрузки операций (692)</h4>

  <p>С++ не позволяет создавать новые операции, но позволяет перегружать существующие для применения их к новым типам, созданным пользователем.</p>
  <p>Ддля перегрузки операции, применяемой к объектам класса, необходимо написать нестатическую элемент-функцию . Нужно написать слово operator и дописать к нему символ перегружаемой операции. Например, <strong>operator+</strong> перегружает операцию сложения. Операции присваивания =, взятия адреса &, запятая , могут использоваться с объектами класса без перегрузки.</p>

  <h4>19.3 Ограничения на перегрузку операций (693)</h4>

  <p>5 операций, которые не могут быть перегружены . .* :: ?: sizeof</p>
  <p><strong>Приоритет</strong>, <strong>ассоциативность</strong>, <strong>число операндов</strong> операций не могут быть изменены посредством перегрузки. При перегрузке унарная операция остается унарной, бинарная остается бинарной. А единственный тернарный оператор не может быть перегружен. Операторы &, *, -, + имеют унарную и бинарную форму. Для каждой формы можно перегрузить их раздельно.</p>
  <p>Нельзя перегрузить оператор для основных типов. Перегрузка работает только с объектами, определенными пользователями или когда в операции участвуют два типа - определенный пользователем и стандартный тип.</p>
  <p>Если для класса есть перегруженный оператор +, то это не значит, что автоматически есть и оператор +=, его надо создавать отдельно.</p>
  <code>object2 = object2 + object1;</code>
  <code>object2 += object1;</code>

  <h4>19.4 Функции-операции как элементы класса и как глобальные функции (695)</h4>

  <p>Глобальная функция-операция может быть сделана другом, если она должна иметь доступ к закрытым элементам класса.</p>

  <h4>Почему операции перадачи в поток и извлечения из потока перегружаются как глобальные функции</h4>

  <p>У операции передачи в поток &lt;&lt; левый операнд имеет тип ostream &. Элемент-функция для операции &lt;&lt; должна была бы быть элементом класса ostream. Это невозможно, так как нельзя модифицировать классы стандартной библиотеки. Аналогично, операция извлечения из потока >> имеет в качестве левого операнда istream &. Поэтому эти операции должны быть глобальными функциями.</p>

  <h4>19.5 Перегрузка операции передачи в поток и извлечения из потока (696)</h4>

  <p>Операции передачи и извлечения из потока могут быть перегружены, чтобы выполнять ввод и вывод типов, созданных пользователем.</p>

  <h4>19.6 Перегрузка одноместных операций (700)</h4>

  <p>Одноместная (унарная) операция для класса может быть перегружена как не-статическая элемент-функция без аргументов или как глобальная функция с одним аргументом. Аргументом должен быть объект класса или ссылка на него.</p>

  <h4>19.7 Перегрузка двухместных операций (700)</h4>

  <p>Двухместная (бинарная) операция для класса может быть перегружена как не-статическая элемент-функция с одним аргументом или как глобальная функция с двумя аргументами. Один из аргументов должен быть объект класса или ссылка на него.</p>

  <h4>19.8 Динамическое управление памятью с помощью операций new и delete (701)</h4>

  <p>Оператор new динамически выделяет точный объем памяти и возвращает указатель на него. По этому указателю можно обращаться к выделенной памяти.</p>
  <p>Оператор delete возвращает динамически выделенную память и делает ее доступной для следующих операций new.</p>
  <code>Time *timePtr;</code>
  <code>timePtr = new Time;</code>
  <p>Создадим указатель на объект типа Time. Выделим для него память и указатель на выделенную память сохраним в указателе на созданный объект.</p>
  <p>Если оператор new не может найти в памяти достаточно места для объекта, то вместо указателя он выбрасывает исключение, сигнализирующее об ошибке. Если программа не "перехватывает" исключение, она немедленно завершится.</p>
  <code>delete timePtr;</code>
  <p>Уничтожим объект и освободим динамически выделенную память. Оператор delete сначала вызывает деструктор объекта, а затем сообщает системе, что память свободна и ее можно повторно использовать.</p>
  <p>Оператор new позволяет сразу же инициализировать динамически выделенную память.</p>
  <code>double *ptr = new double(3.14159);</code>
  <code>Time *timePtr = Time(12, 45, 0);</code>
  <p>Выделим память под массив целых чисел на 10 элементов.</p>
  <code>int *a = new int[10];</code>
  <code>int a[] = new int[10]; // так выделять массив нельзя</code>
  <p>Удалим динамически выделенный массив.</p>
  <code>delete [] a;</code>

  <h4>19.9 Пример: класс Array (703)</h4>

  <h4>19.10 Преобразование типов (715)</h4>

  <p>Компилятор не знает как преобразовывать типы, определенные пользователем. Конструктор преобразований имеет один аргумент и превращает объекты различных типов в объекты класса, созданного пользователем.</p>
  <p>Операция преобразования может применяться к объекту класса, преобразуя его в объект другого класса.</p>

  <h4>19.11 Пример: класс String (716)</h4>
</article>


<!-- 20 ООП. Наследование -->
<article class="article">
  <div class="anchor" id="p20"></div>
  <h3>20 ООП. Наследование (758)</h3>
</article>


<!-- 21 ООП. Полиморфизм -->
<article class="article">
  <div class="anchor" id="p21"></div>
  <h3>21 ООП. Полиморфизм (810)</h3>
</article>


<!-- 22 Шаблоны -->
<article class="article">
  <div class="anchor" id="p22"></div>
  <h3>22 Шаблоны (866)</h3>
</article>


<!-- 23 Потоковый ввод/вывод -->
<article class="article">
  <div class="anchor" id="p23"></div>
  <h3>23 Потоковый ввод/вывод (885)</h3>
</article>


<!-- 24 Управление исключениями -->
<article class="article">
  <div class="anchor" id="p24"></div>
  <h3>24 Управление исключениями (925)</h3>
</article>

