<article class="article">
  <h1>2019 Кольцов - Си на примерах. Практика, практика и только практика. 288c</h1>
  <p>Конспект книги</p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
        <a href="#p1">1 Выражения в Си (23)</a>
    <br><a href="#p2">2 Операторы в Си (55)</a>
    <br><a href="#p3">3 Массивы и строки в Си (75)</a>
    <br><a href="#p4">4 Указатели в Си (95)</a>
    <br><a href="#p5">5 Функции в Си (109)</a>
    <br><a href="#p6">6 Пользовательские типы в Си (128)</a>
    <br><a href="#p7">7 Ввод/вывод в Си (138)</a>
    <br><a href="#p8">8 Очереди и стеки в Си (173)</a>
    <br><a href="#p9">9 Связанные списки и деревья в Си (180)</a>
    <br><a href="#p10">10 Алгоритмы поиска и сортировки в Си (201)</a>
    <br><a href="#p11">11 Многопоточность в Си (234)</a>
    <br><a href="#p12">12 Работа с сетью в Си (254)</a>
    <br><a href="#p13">13 Практический пример: компьютерная игра (271)</a>
  </p>
</article>


<!-- 1 Выражения в Си -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>1 Выражения в Си (23)</h3>

  <p>Стандарты языка Си: ANSI C, C89, C99, C11.</p>
  <p>Напишем программу, которая запрашивает число и выводит это число на экран.</p>

  <details>
    <summary>Программа 1 (18)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int k;
  printf("Enter number: ");
  scanf("%d", &k);
  printf("Number is: %d\n", k);

  return 0;
}
</pre>
  </details>

  <p>Выражения (expressions) это элементы языка Си состоящие из данных и операторов. Данные могут быть в виде переменных или в виде констант. Операторы выполняют операции над данными.</p>

  <h4>1.1 Основные типы данных (24)</h4>

  <p>В языке Си существует пять элементарных типов данных:</p>
  <ol>
    <li>char</li>
    <li>int</li>
    <li>float</li>
    <li>double</li>
    <li>void</li>
  </ol>
  <p>Остальные типы данных создаются на основе этих элементарных типов.</p>
  <p>Тип void используется для определения типа функции, не возвращающей значения или для создания обобщенного указателя.</p>
  <p>Типы данных char, int, double могут имеют модификаторы типа</p>
  <p>Тип char имеет два модификатора signed, unsigned. Тип int имеет четыре модификатора signed, unsigned, short, long. Тип double имеет один модификатор long.</p>
  <p>Для signed старший бит определяет знак числа: 0 для положительного, 1 для отрицательного.</p>

  <h4>1.2 Идентификаторы (26)</h4>

  <p>Имена идентификаторов чувствительны к регистру.</p>

  <h4>1.3 Переменные (27)</h4>

  <p>Переменная это область памяти, размером в соответсвии с ее типом, в которую записывается значение.</p>

  <h4>1.3.1 Локальные переменные</h4>

  <p>Локальные переменные объявляются внутри функции. Они используются только внутри функции, в которой объявлены, и не видны за ее пределами.</p>
  <p>Для объявления локальной переменной, используется ключевое слово auto. Но поскольку все локальные переменные по умолчанию являются auto, то это слово не используется.</p>
  <p>Переменную можно объявить в любом месте функции, но до первого ее использования.</p>
  <p>Если локальная переменная объявлена в блоке внутри фигурных скобок, то она уничтожается и ее значение теряется при выходе из блока. Локальная переменная также уничтожается и ее значение теряется при выходе из функции. Чтобы сохранить ее значение при следующих вызовах функции, надо ее объявить с ключевым словом static.</p>
  <p>Локальные переменные хранятся в стеке.</p>

  <h4>1.3.2 Формальные параметры</h4>

  <p>Аргументы передаются в функцию с помощью формальных параметров. Формальные параметры объявляются в круглых скобках после названия функции</p>
  <code>int sum(int a, int b);</code>
  <p>Внутри функции формальные параметры это локальные переменные, которые динамически создаются при вызове функции и разрушаются при выходе из нее.</p>

  <h4>1.3.3 Глобальные переменные</h4>

  <p>Глобальные переменные объявляются вне функций и доступны везде после их объявления.</p>

  <details>
    <summary>Программа 2 (31)</summary>
<pre>
#include &lt;stdio.h&gt;

int counter = 0;

void f1();
void f2();

int main() {
  counter = 100;
  f1();
  f2();

  return 0;
}

void f1() {
  int z = counter;
  printf("counter = %d\n", z);
}

void f2() {
  int z = counter;
  printf("counter = %d\n", z);
}
</pre>
  </details>

  <details>
    <summary>Программа 3 (32)</summary>
<pre>
#include &lt;stdio.h&gt;

int counter = 0;

void f1();
void f2();

int main() {
  counter = 100;
  f1();
  f2();

  return 0;
}

void f1() {
  int z = counter;
  printf("counter = %d\n", z);
}

void f2() {
  int counter = 200;
  printf("counter = %d\n", counter);
}
</pre>
  </details>

  <h4>1.3.4 Области видимости</h4>

  <p>В языке Си четыре области видимости:</p>
  <ol>
    <li>Файл. Глобальные переменные, объявленные вне функций.</li>
    <li>Блок. Локальные переменные, объявленные внутри блока из фигурных скобок. Область видимости с момента объявления до закрывающей фигурной скобки.</li>
    <li>Прототип функции. Переменные объявляются и видны только внутри прототипа функции.</li>
    <li>Функция. Локальные переменные, объявленные внутри функции, доступны только внутри функции.</li>
  </ol>

  <h4>1.3.5 Квалификаторы типа</h4>

  <p>Квалификаторы типа указывают на доступность и модифицируемость переменной. Есть три квалификатора</p>
  <ol>
    <li>
      <h4>const</h4>
      <p>Переменная не может быть изменена. Переменная должна быть инициализирована одновременно с объявлением.</p>
      <code>const port = 8080;</code>
      <p>Если в прототипе функции написать const перед указателем на переменную, то внутри функции ее изменить нельзя.</p>
      <code>size_t strlen(const char *str);</code>
    </li>
    <li>
      <h4>volatile</h4>
      <p>Переменная может изменяться неявно. Компиляторы оптимизируют выражения, считая что значения переменных не изменяются если они указаны справа от знака равенства и нет смысла перепроверять их значение при каждом обращении. Компиляторы меняют порядок вычисления выражений в ходе компиляции.</p>
    </li>
    <li>
      <h4>restrict</h4>
      <p>Появился в стандарте C99 и применяется только для указателей. К объекту на который ссылается такой указатель можно обратиться только с помощью этого указателя или с помощью выражений, вычисленных с помощью этого указателя.</p>
    </li>
  </ol>

  <h4>1.3.6 Спецификаторы хранения</h4>

  <p>Спецификатор хранения указывает где должна храниться переменная. Есть три спецификатора</p>
  <ol>
    <li>
      <h4>extern</h4>
      <p>Переменная объявлена в другом файле. В одном файле объявляются все глобальные переменные, а во всех остальных используется слово extern</p>
    </li>
    <li>
      <h4>static</h4>
      <p>Статические переменные не известны вне своей функции и файла, но сохраняет свое значение между вызовами функции. Статическая глобальная переменная не видна в других файлах. Статическая локальная переменная имеет постоянное место для хранения, как и глобальная.</p>
    </li>
    <li>
      <h4>register</h4>
      <p>Рекомендует компилятору размещать переменную не в области памяти, а в регистре центрального процессора. Операции над регистровыми переменными выполняются намного быстрее. Применяется только к локальным переменным.</p>
    </li>
  </ol>

  <h4>1.3.7 Инициализация переменных. Оператор присваивания</h4>

  <p>При объявлении переменной ее можно инициализировать константой или результатом выражения. После значение переменной можно менять с помощью оператора присваивания.</p>

  <h4>1.4 Константы (37)</h4>

  <p>Константы - это фиксированные значения, которые программа не может изменить. Константы могут быть целочисленные, символьные, строковые, с плавающей точкой.</p>

  <h4>1.5 Операторы (39)</h4>

  <h4>1.5.1 Оператор присваивания (39)</h4>

  <p>Слева от оператора присваивания должна стоять переменная, в которую будет записано значение справа от оператора присваивания. Справа может стоять константа или выражение. Если тип переменной слева и тип значения справа отличается, то происходит преобразование типов. Если типы невозможно преобразовать, то компилятор выдаст ошибку. Можно выполнить несколько присваиваний в одном выражении</p>
  <code>a = b = c = 0;</code>

  <h4>1.5.2 Арифметические операторы (41)</h4>

  <p>Напишем программу для нахождения частного и остатка при делении двух целых чисел.</p>

  <details>
    <summary>Программа 4 (42)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int dividend, divisor, quotient, reminder;

  printf("Enter divident: ");
  scanf("%d", &dividend);

  printf("Enter divisor: ");
  scanf("%d", &divisor);

  quotitent = dividend / divisor;
  reminder = dividend % divisor;

  printf("quotitent = %d\n", quotitent);
  printf("reminder = %d", reminder);

  return 0;
}
</pre>
  </details>

  <h4>1.5.3 Операторы сравнения и логические операторы (44)</h4>

  <p>В языке Си нет оператора XOR, но его можно реализовать самому.</p>
<pre>
int XOR(int x, int y) {
  return (x || y) && !(x && y);
}
</pre>

  <h4>1.5.4 Побитовые операторы (45)</h4>

  <p>Язык Си разрабатывался как замена языку ассемблера, поэтому в него вошли операции низкого уровня, такие как побитовые операции (bitwise operation) для проверки, установки и сдвига битов в байтах и машинных словах. Побитовые операции можно применить только к типам char и int. Они находят применения в написании драйверов устройств и в шифровальных программах.</p>

  <h4>1.5.5 Тернарный оператор (46)</h4>

  <p>Тернарный оператор это компактная форма записи оператора if-then-else</p>

  <h4>1.5.6 Оператор получения адреса (&) и разыменования ссылки (*) (47)</h4>

  <p>Указатель это переменная хранящая адрес объекта определенного типа. Адрес объекта можно получить, применив к нему операцию получения адреса &.</p>
  <code>int count = 1; int *addr = &count;</code>
  <p>Полученный адрес это адрес ячейки памяти, в которой находится переменная count. Адрес не связан со значением переменной. Изменяя значение переменной, ее адрес не изменится.</p>
  <p>Оператор разыменования указателя (*) возвращает значение объекта, расположенного по указанному адресу.</p>
  <code>int value = *addr; // 1</code>

  <h4>1.5.7 Статический оператор sizeof (48)</h4>

  <p>Оператор sizeof принимает тип или объект и возвращает размер в байтах. Тип нужно заключать в скобки, объект может быть в скобках, а может и без.</p>
<pre>
double v = 0;
printf("%d\n", sizeof v);       // 8
printf("%d\n", sizeof(double)); // 8
</pre>

  <h4>1.5.8 Оператор последовательного вычисления или запятая (49)</h4>

  <p>В одном выражении можно через запятую записать несколько выражений. Все эти выражения выполнятся последовательно. Результатом всего выражения станет значение после последней запятой</p>
  <code>z = (x = 2, x + 1);</code>

  <h4>1.5.9 Оператор доступа к члену структуры (50)</h4>

<pre>
struct car {
  float speed;
} priora;
</pre>
  <p>Для доступа к элементу speed структуры priora можно использовать оператор  . точка</p>
  <code>priora.speed = 55</code>
  <p>Если объявить указатель на структуру</p>
  <code>struct car *c = &priora;</code>
  <p>то доступ к элементу структуры через указатель происходит по оператору -> стрелка</p>
  <code>c->speed = 55;</code>

  <h4>1.5.10 Операторы [] и ()</h4>

  <p>Квадратные скобки нужны для доступа к элементам массива. Круглые скобки нужны для изменения приоритета операций.</p>

  <h4>1.5.11 Приоритеты операторов</h4>

  <p>Если в одном выражении встречается несколько операторов, то они выполняюстя в порядке их приоритета.</p>

  <h4>1.6 Практический пример: меняем местами два числа (52)</h4>

  <p>Введем два числа и поменяем их местами при помощи третьей переменной.</p>

  <details>
    <summary>Программа 5 (53)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  double a, b, temp;

  printf("Enter A: ");
  scanf("%lf", &a);
  printf("Enter B: ");
  scanf("%lf", &b);

  temp = a;
  a = b;
  b = temp;

  printf("A = %.2lf\n", a);
  printf("B = %.2lf\n", b);

  return 0;
}
</pre>
  </details>

  <p>Введем два числа и поменяем их местами без помощи третьей переменной.</p>

  <details>
    <summary>Программа 6 (54)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  double a, b;

  printf("Enter A: ");
  scanf("%lf", &a);
  printf("Enter B: ");
  scanf("%lf", &b);

  a = a - b;
  b = a + b;
  a = a - b;

  printf("A = %.2lf\n", a);
  printf("B = %.2lf\n", b);

  return 0;
}
</pre>
  </details>
</article>


<!-- 2 Операторы в Си -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>2 Операторы в Си (55)</h3>

  <p>Операторы друг от друга отделяются точкой с запятой.</p>

  <h4>2.1 Условные операторы (56)</h4>

  <p>Условный оператор проверяет выражение. Если выражение истинно, то выполняются какие-то действия.</p>

  <h4>2.1.1 Оператор if</h4>

  <p>Проверим является ли число четным.</p>

  <details>
    <summary>Программа 7 (57)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int num;

  printf("Enter integer: ");
  scanf("%d", &num);

  if (num % 2 == 0) {
    printf("%d - even", num);
  } else {
    printf("%d - odd", num);
  }

  return 0;
}
</pre>
  </details>

  <p>Проверим является ли год високосным.</p>

  <details>
    <summary>Программа 8 (58)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int year;

  printf("Enter year: ");
  scanf("%d", &year);

  if (year % 4 == 0) {
    if (year % 100 == 0) {
      if (year % 400 == 0) {
        printf("%d - visokosni", year);
      } else {
        printf("%d - ne visokosni", year);
      }
    } else {
      printf("%d - visokosni", year);
    }
  } else {
    printf("%d - ne visokosni", year);
  }

  return 0;
}
</pre>
  </details>

  <h4>2.1.2 Оператор switch</h4>

  <p>Оператор switch последовательно сравнивает значение выражения со списком целых чисел или символьных констант. При этом символьные константы автоматически преобразуются в целочисленные.</p>

  <details>
    <summary>Программа 9 (61)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char operator;
  double num1, num2;

  printf("Enter operator (+, -, *, /) ");
  scanf("%c", &operator);

  printf("Enter 2 numbers ");
  scanf("%lf %lf", &num1, &num2);

  switch(operator) {
    case '+':
      printf("%.11f + %.11f = %.11f", num1, num2, num1 + num2);
      break;
    case '-':
      printf("%.11f - %.11f = %.11f", num1, num2, num1 - num2);
      break;
    case '*':
      printf("%.11f * %.11f = %.11f", num1, num2, num1 * num2);
      break;
    case '/':
      if (num2 != 0) {
        printf("%.11f / %.11f = %.11f", num1, num2, num1 / num2);
      } else {
        printf("Division by zero prohibiten");
      }
      break;
    default:
      printf("Error operator");
  }

  return 0;
}
</pre>
  </details>

  <h4>2.2 Операторы цикла (63)</h4>

  <p>Циклы выполняют повторяющиеся инструкции пока истинно заданное условие.</p>

  <h4>2.2.1 Цикл for</h4>

  <p>Цикл for это цикл со счетчиком. Его применяют когда заранее известно число повторений.</p>

  <details>
    <summary>Программа 10 (63)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int n, sum = 0;
  printf("Enter positive integer ");
  scanf("%d", &n);

  for (int i = 1; i &lt;= n; i++) {
    sum += i;
  }

  printf("Sum = %d", sum);

  return 0;
}
</pre>
  </details>

  <p>Если условие выполнения цикла не указано, то оно считается истинным и цикл получится бесконечным.</p>

  <h4>2.2.2 Цикл while</h4>

  <p>Такой цикл удобно использовать когда заранее не известно количество повторений.</p>

  <details>
    <summary>Программа 11 (65)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
  int k = 0, i = 0;

  while (k &lt; 7) {
    k = 1 + rand() % 10;
    printf("%d ", k);
    i++;
  }

  printf("repeat %d times", i);

  return 0;
}
</pre>
  </details>

  <details>
    <summary>Программа 12 (66)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int n, i = 1, sum = 0;
  printf("Enter positive integer ");
  scanf("%d", &n);

  while (i &lt;= n) {
    sum += i;
    i++;
  }

  printf("Sum = %d", sum);

  return 0;
}
</pre>
  </details>

  <p>Бесконечные циклы часто используются на практике. Например, сервер в бесконечном цикле обрабатывает подключения клиентов. Для него даже не нужно условие выхода из цикла, так как сервер должен обрабатывать запросы постоянно. Впрочем, прервать цикл можно и в самой консоли. Для этого надо нажать Ctrl+C в терминале, где запущена программа с бесконечным циклом.</p>

  <h4>2.2.3 Цикл do-while</h4>

  <p>Сначала выполняется тело цикла, потом проверяется условие. Это нужно, чтобы цикл выполнился хотя бы один раз.</p>

  <details>
    <summary>Программа 13 (68)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int n, sum = 0;

  do {
    printf("Enter positive integer ");
    scanf("%d", &n);
  } while (n &lt; 0);

  for (int i = 1; i &lt;= n; i++) {
    sum += i;
  }

  printf("Sum = %d", sum);

  return 0;
}
</pre>
  </details>

  <h4>2.3 Операторы перехода (69)</h4>

  <p>В языке Си есть четыре оператора безусловного перехода: return, goto, break, continue.</p>

  <h4>2.3.1 Оператор return</h4>

  <p>Это оператор возврата из функции. Применяется только внутри функции и выполняет возврат в точку вызова функции. Если функция имеет тип void, то есть не возвращает значение, то оператор return можно не писать. В этом случае компилятор сам подставит оператор return перед закрывающей фигурной скобкой функции.</p>

  <h4>2.3.2 Оператор goto</h4>

  <p>Оператор производит безусловный переход к указанной метке. Оператор и метка должны находиться в одной функции. В современных программах этот оператор не используется.</p>

  <h4>2.3.3 Операторы break и continue</h4>

  <p>Оператор break используется в циклах и конструкции switch и выполняет выход из них.</p>
  <p>Оператор continue используется только в циклах и выполняет переход на проверку условия цикла и после этого к следующей итерации.</p>

  <h4>2.4 Операторы-выражения (72)</h4>

  <p>Оператор (инструкция) это выражение, которое завершается точкой с запятой. Например</p>
  <code>a = b + c; // присваивание</code>
  <code>sum(a, b); // вызов функции</code>
  <code>b + c; // значение оператора будет потеряно</code>
  <code>; // пустой оператор</code>

  <h4>2.5 Блоки</h4>

  <p>Блок это группа операторов, заключенная в фигурные скобки.</p>

  <h4>2.6 Функция exit()</h4>

  <p>Функция exit завершает программу и передает управление программе (операционной системе) вызвавшей ее. Функция exit возвращает целое значение в то место, где была вызвана программа.</p>
</article>


<!-- 3 Массивы и строки в Си -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>3 Массивы и строки в Си (75)</h3>

  <h4>3.1 Одномерные массивы</h4>

  <p>Одномерный массив представляет собой список переменных, имеющих одинаковый тип и хранящихся в соседних ячейках памяти в порядке возрастания индексов. Младший адрес занимает первый элемент массива, старший - последний. Массив занимает память равную размеру типа умноженному на число элементов.</p>

  <h4>3.2 Указатель на массив</h4>

  <p>Имя массива это адрес ячейки памяти, с которой начинается массив. По этому адресу также находится первый элемент массива. Если у нас есть массив nums, то выражения nums и &nums[0] эквивалентны и указывают на один и тот же элемент.</p>
  <p>В языке Си нельзя передать массив в функцию. Вместо этого передают указатель на массив. Есть три способа передачи в функцию указателя на массив:</p>
  <ol>
    <li>В качестве аргумента объявить указатель
      <code>int max(int *x) {}</code>
    </li>
    <li>Передать указатель на массив фиксированного размера
      <code>int max(int x[10]) {}</code>
    </li>
    <li>Использовать массив неопределенного размера
      <code>int max(int x[]) {}</code>
    </li>
  </ol>
  <p>Размер массива, передаваемого в функцию, не имеет никакого значения, поскольку проверка выхода индекса за пределы в языке Си не предусмотрена. В функцию передается не массив, а указатель на его первый элемент и тип элемента, который определяет размер элемента.</p>

  <h4>3.3 Работа со строками (81)</h4>

  <h4>3.3.1 Объявление строки</h4>

  <p>Константы символьных строк помещаются в класс статической памяти. Длину строки компилятор вычислит автоматически.</p>
  <p>Объявим массив символов</p>
  <code>char name[21];</code>
  <p>Объявим строку как массив символов</p>
  <code>char s[] = "string";</code>
  <p>Объявим строку как указатель на символ. В память запишется строка, но ps это указатель на символ.</p>
  <code>char *ps = "string";</code>

  <h4>3.3.2 Правильное выделение памяти под строку</h4>

  <p>Строка всегда должна заканчиваться символом '\0', который занимает еще один байт памяти.</p>

  <h4>3.3.3 Функции для работы со строками</h4>

  <p>Заголовочный файл string.h содержит прототипы функций для работы со строками.</p>

  <h4>3.3.4 Работа со строкой как с массивом символов</h4>

  <p>Напишем программу, которая удаляет из массива все символы, кроме цифр.</p>

  <details>
    <summary>Программа 14 (84)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char line[101];
  int i, j;
  gets(line);

  for (i = 0; line[i] != '\0'; i++) {
    while (!((line[i] >= '0' && line[i] &lt;= '9') || line[i] == '\0')) {
      for (j = i; line[j] != '\0'; j++) {
        line[j] = line[j+1];
      }
      line[j] = '\0';
    }
  }

  printf("%s", line);

  return 0;
}
</pre>
  </details>

  <p>Пользователь вводит строку в переменную line. Проверяем каждый символ. Если это не цифра, то все символы после него сдвигаем влево на один.</p>

  <h4>3.3.5 Пример использования библиотечных функций</h4>

  <h4>3.3.6 Многобайтовые строки. Работа с UTF-8</h4>

  <p>При работе с английским языком, который располагается в таблице ASCII, все символы занимают 1 байт. При работе в кодировке unicode символы национальных алфавитов занимают 2 байта, но символы таблицы ASCII по прежнему занимают 1 байт, потому что они расположены в первом байте символов unicode.</p>
  <p>Для работы с юникодом надо использовать широкие символы с типом wchar_t и функции для работы с ними из заголовочного файла wchar.h.</p>

  <details>
    <summary>Программа 15 (87)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;wchar.h&gt;
#include &lt;locale.h&gt;
#include &lt;stdlib.h&gt;

int main() {
  wchar_t buf[BUFSIZ];
  wchar_t *pch;
  size_t count;

  setlocale(LC_ALL, "");

  fputws(L"Введите свое имя: ", stdout);
  fflush(stdout);

  fgetws(buf, BUFSIZ, stdin);
  fputws(L"Ваше имя ", stdout);

  if ((pch = wcschr(buf, L'\n')) != NULL) {
    *pch = L'\0';
  }

  for (pch = buf, cout = 0; *pch != L'\0'; pch++, cout++) {
    putwchar(*pch);
  }

  putwchar(L'\n');

  wprintf(L"Введено букв %zd\n", count);

  return 0;
}
</pre>
  </details>

  <h4>3.4 Многомерные массивы (88)</h4>

  <p>Объявим двумерный массив из 100 строк и 200 столбцов</p>
  <code>int c[100][200];</code>
  <p>Если двумерный массив передается в функцию, то как и при одномерном массиве, в функцию передается указатель на его первый элемент.</p>
  <p>Напишем программу сложения двух матриц, используя многомерные массивы.</p>

  <details>
    <summary>Программа 16 (89)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int r, c, a[100][100], b[100][100], sum[100][100];
  printf("Enter number of rows");
  scanf("%d", &r);
  printf("Enter number of colons");
  scanf("%d", &c);

  printf("Enter elements of A matrix");
  for (int i = 0; i &lt; r; i++) {
    for (int j = 0; j &lt; c; j++) {
      printf("Enter element A[%d][%d] ", i+1, j+1);
      scanf("%d", &a[i][j]);
    }
  }

  printf("Enter elements of B matrix");
  for (int i = 0; i &lt; r; i++) {
    for (int j = 0; j &lt; c; j++) {
      printf("Enter element B[%d][%d] ", i+1, j+1);
      scanf("%d", &b[i][j]);
    }
  }

  // сложение двух матриц
  for (int i = 0; i &lt; r; i++) {
    for (int j = 0; j &lt; c; j++) {
      sum[i][j] = a[i][j] + b[i][j];
    }
  }

  // вывод результата
  printf("Sum of 2 matrix");
  for (int i = 0; i &lt; r; i++) {
    for (int j = 0; j &lt; c; j++) {
      printf("%d ", sum[i][j]);
    }
    printf("\n");
  }

  return 0;
}
</pre>
  </details>
</article>


<!-- 4 Указатели в Си -->
<article class="article">
  <div class="anchor" id="p4"></div>
  <h3>4 Указатели в Си (95)</h3>

</article>


<!-- 5 Функции в Си -->
<article class="article">
  <div class="anchor" id="p5"></div>
  <h3>5 Функции в Си (109)</h3>

</article>


<!-- 6 Пользовательские типы в Си -->
<article class="article">
  <div class="anchor" id="p6"></div>
  <h3>6 Пользовательские типы в Си (128)</h3>

</article>


<!-- 7 Ввод/вывод в Си -->
<article class="article">
  <div class="anchor" id="p7"></div>
  <h3>7 Ввод/вывод в Си (138)</h3>

</article>


<!-- 8 Очереди и стеки в Си -->
<article class="article">
  <div class="anchor" id="p8"></div>
  <h3>8 Очереди и стеки в Си (173)</h3>

</article>


<!-- 9 Связанные списки и деревья в Си -->
<article class="article">
  <div class="anchor" id="p9"></div>
  <h3>9 Связанные списки и деревья в Си (180)</h3>

</article>


<!-- 10 Алгоритмы поиска и сортировки в Си -->
<article class="article">
  <div class="anchor" id="p10"></div>
  <h3>10 Алгоритмы поиска и сортировки в Си (201)</h3>

</article>


<!-- 11 Многопоточность в Си -->
<article class="article">
  <div class="anchor" id="p11"></div>
  <h3>11 Многопоточность в Си (234)</h3>

</article>


<!-- 12 Работа с сетью в Си -->
<article class="article">
  <div class="anchor" id="p12"></div>
  <h3>12 Работа с сетью в Си (254)</h3>

</article>


<!-- 13 Практический пример: компьютерная игра -->
<article class="article">
  <div class="anchor" id="p13"></div>
  <h3>13 Практический пример: компьютерная игра (271)</h3>

</article>

