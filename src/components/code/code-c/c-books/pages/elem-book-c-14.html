<article class="article">
  <h1>2020 Прохоренок - Язык Си. Самое необходимое. 480c</h1>
  <p>Конспект книги</p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
        <a href="#p1">1 Установка программ под Windows (11)</a>
    <br><a href="#p2">2 Первые шаги (44)</a>
    <br><a href="#p3">3 Переменные и типы данных (91)</a>
    <br><a href="#p4">4 Операторы и циклы (133)</a>
    <br><a href="#p5">5 Числа (156)</a>
    <br><a href="#p6">6 Массивы (181)</a>
    <br><a href="#p7">7 Символы и C-строки (206)</a>
    <br><a href="#p8">8 Широкие символы и L-строки (244)</a>
    <br><a href="#p9">9 Работа с датой и временем (300)</a>
    <br><a href="#p10">10 Пользовательские функции (312)</a>
    <br><a href="#p11">11 Обработка ошибок (336)</a>
    <br><a href="#p12">12 Чтение и запись файлов (351)</a>
    <br><a href="#p13">13 Низкоуровневые потоки ввода и вывода (374)</a>
    <br><a href="#p14">14 Работа с файловой системой (386)</a>
    <br><a href="#p15">15 Потоки и процессы (407)</a>
    <br><a href="#p16">16 Создание библиотек (430)</a>
    <br><a href="#p17">17 Прочее (448)</a>
  </p>
</article>


<!-- 1 Установка программ под Windows (11) -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>1 Установка программ под Windows (11)</h3>

  <p>Язык Си - это компилируемый язык высокого уровня. Это кроссплатформенный язык, позволяющий создавать программы, которые будут работать во всех операционных системах, но для каждой операционной системы компиляцию нужно проводить отдельно. В этой книге мы будем получать исполняемые exe-файлы с помощью компилятора gcc из состава популярной библиотеки MinGW-W64 для 64-битной операционной системы Windows.</p>
  <p>Существует несколько стандартов языка Си:</p>
  <code>C90, C99, C11.</code>
  <p>Чтобы использовать правила конкретного стандарта, при компиляции нужно указать флаги:</p>
  <code>-std=c90, -std=c99, -std=c11.</code>
  <p>Без этих флагов компилятор будет использовать последний стандарт. Узнать используемый стандарт языка Си внутри программы можно с помощью макроса __STDC_VERSION__</p>
  <code>printf("%ld\n", __STDC_VERSION__);</code>
  <p>Получить информацию о версии компилятора позволяет макрос __VERSION__</p>
  <code>printf("s\n", __VERSION__);</code>
  <p>Для комфортного программирования, имя компьютера, имена файлов и катлогов должны содержать только символы латинского алфавита, цифры, тире, подчеркивания. Это нужно чтобы не было проблем с компиляцией и запуском программ.</p>

  <h4>1.2 Добавление пути в переменную PATH (12)</h4>

  <p>Когда в командной строке мы вводим название программы, то вначале поиск программы выполняется в текущем каталоге, а затем в путях, указанных в системной переменной PATH. Пути в системной переменной PATH просматриваются слева направо до первого вхождения искомого названия. Если в путях прописано несколько объектов с одинаковым названием, то выдаваться всегда будет один - только первый найденный объект.</p>
  <p>Чтобы  добавить объект в системную переменную PATH, необходимо открыть</p>
  <code>Параметры - Панель управления - Система и безопасность - Система - Дополнительные параметры системы</code>
  <p>В открывшемся окне <strong>Свойства системы</strong> выбрать</p>
  <code>Дополнительно - Переменные среды</code>
  <p>В открывшемся окне <strong>Переменные среды</strong> в списке <strong>Системные переменные</strong> выделяем строку с переменной <strong>Path</strong> и нажимаем кнопку <strong>Изменить</strong></p>

  <h4>1.4 Установка MinGW и MSYS (14)</h4>

  <p>Для преобразования текста программы в файле с расширением .c в исполняемый файл с расширением .exe потребуется установить компилятор. Мы установим беспратный компилятор gcc, входящий в состав популярной библиотеки MinGW. Установим ее в каталог</p>
  <code>c:\gcc</code>
  <p>Путь к компилятору gcc.exe и g++.exe пропишем в систмную переменную PATH</p>
  <code>c:\gcc\bin</code>
  <p>Если компилятор успешно установился и путь к нему прописан, то мы получим версию компилятора, если введем в командной строке команду</p>
  <code>gcc --version</code>
  <code>g++ --version</code>
</article>


<!-- 2 Первые шаги (44) -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>2 Первые шаги (44)</h3>

  <h4>2.1 Первая программа (44)</h4>

  <p>Напишем первую программу, которая выводит в консоль надпись Hello, world!</p>

  <details>
    <summary>Программа 1 (45)</summary>
<pre>
#include &lt;stdio.h&gt;

int main () {
  printf("Hello, world!");
  return 0;
}
</pre>
  </details>

  <p>Чтобы скомпилировать программу, нужно запустить компилятор и передать ему в качестве аргумента название файла. Наберем в терминале следующую команду</p>

  <code>gcc helloworld.c</code>

  <p>После компиляции, если нет ошибок, компилятор создаст исполняемый файл a.exe, который можно запустить командой</p>
  <code>./a</code>

  <p>В терминале получится результат работы программы</p>
  <code>Hello, world!</code>

  <h4>2.4 Добавление в проект заголовочного файла (50)</h4>

  <p>В программе могут быть заголовочные файлы. В заголовочных файлах указывают прототипы функций и различные объявления. Заголовочный файл имеет расширение .h</p>
  <p>Создадим файл helloworld.h</p>
<pre>
#ifndef HELLOWORLD_H_
#define HELLOWORLD_H_

#endif /* HELLOWORLD_H_ */
</pre>
  <p>Для того чтобы избежать повторное объявление идентификаторов, все прототипы и прочие объявления нужно вкладывать в блок #ifndef #endif.</p>
  <p>Второй способ избежать повторного объявления идентификаторов это указать директиву #pragma со значением once</p>
  <code>#pragma once</code>

  <h4>2.6 Структура программы (57)</h4>

<pre>
Подключение заголовочных файлов
Объявление глобальных переменных
Объявление функций
int main() {
  код функции
  return 0;
}
Определение функций
</pre>
  <p>В самом начале программы подключаются заголовочные файлы, в которых содержатся объявления идентификаторов без их реализации.</p>
  <p>Объявление переменной</p>
  <code>int x;</code>
  <p>Присвоение значения переменной при объявлении называется инициализацией переменной</p>
  <code>int x = 10;</code>
  <p>Если глобальной переменной не присвоено значение при объявлении, то она будет иметь значение 0. Если локальной переменной не присвоено значение, то она будет содержать мусор - данные оставшиеся в памяти от других программ.</p>
  <p>Объявление функции без ее реализации называется прототипом функции.</p>
  <code>int sum(int x, int y);</code>
  <p>В прототипе указывается тип возвращаемого значения, имя, тип и порядок аргументов функции. Имена аргументов можно писать, а можно и не писать. После прототипа функции нужно написать ее реализацию. После прототипа ставится точка с запятой ;.</p>
  <p>Прототип функции обычно пишут перед функцией main, чтобы функция main знала и могла использовать объявленные функции, а реализацию функции пишут после функции main.</p>
  <p>Реализация функции sum</p>
<pre>
int sum(int x, int y) {
  return x + y;
}
</pre>
  <p>Первая строка в реализации функции совпадает с прототипом. Но вместо точки с запятой ставятся фигурные скобки {} внутри которых находится код функции.</p>
  <p>Функция main имеет три прототипа</p>
  <code>int main(void);</code>
  <code>int main(int argc, char *argv[]);</code>
  <code>int main(int argc, char *argv[], char **penv);</code>
  <p>В первом прототипе значение void означает что функция не принимает параметров.</p>
  <p>Во втором прототипе параметр argc это количество строковых значений, переданных из командной сроки. Причем первое значение это имя программы, а остальные значения передаются через параметр argv</p>
  <p>В третьем прототипе параметр penv позволяет получить значения переменных окружения.</p>
  <p>Функция main при успешном выполнении должна возвращать 0. Вместо этого можно написать EXIT_SUCCESS, а при завершении с ошибкой EXIT_FAILURE. Для этого нужно подключить библиотеку stdlib, в которой определены две переменные</p>
<pre>
#include &lt;stdlib.h&gt;
#define EXIT_SUCCESS 0
#define EXIT_FAILURE 1
</pre>
  <code>return EXIT_SUCCESS;</code>

  <p>Программа вычисления суммы двух чисел.</p>

  <details>
    <summary>Программа 2 (62)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int x = 21;
int y = 85;

int sum(int, int);
void print(int);

int main() {
  int z = sum(x, y);
  print(z);

  return EXIT_SUCCESS;
}

int sum(int x, int y) {
  return x + y;
}

void print(int) {
  printf("%d", x);
}
</pre>
  </details>

  <p>Вынесем объявления функций в отдельный заголовочный файл</p>

  <details>
    <summary>Программа 3 (63)</summary>
    <p>Заголовочный файл 3sum.h</p>
<pre>
#ifndef SUM_H_
#define SUM_H_

int sum(int, int);
void print(int);

#endif
</pre>

  <p>Файл 3.c</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include "3sum.h"

int x = 21;
int y = 85;

int main() {
  int z = sum(x, y);
  print(z);

  return EXIT_SUCCESS;
}

int sum(int x, int y) {
  return x + y;
}

void print(int x) {
  printf("%d", x);
}
</pre>
  </details>

  <h4>Комментарии в программе (63)</h4>

  <p>Компилятор полностью игнорирует комментарии. Комментарии синтаксически бывают однострочные и многострочные.</p>
  <p>Чтобы закомментировать одну строку, нужно поставить курсор на эту строку и нажать Ctrl + /. Строка будет закомментирована однострочным комментарием. Чтобы закомментировать более одной строки, их нужно выделить и нажать Ctrl + /. Выделенные строки будут закомментированы однострочными комментариями.</p>
  <p>Многострочные комментарии не могут быть вложенные. Однострочные комментарии могут быть вложены друг в друга и в многострочные комментарии.</p>

  <h4>Вывод данных (65)</h4>

  <p>Печать одного символа putchar()</p>
  <code>putchar('w'); // w</code>
  <code>putchar('119'); // w</code>

  <p>Печать одной строки puts()</p>
  <code>puts("string"); // string</code>

  <p>Форматированная печать printf()</p>
  <code>printf("string\n"); // string</code>
  <code>printf("%d", 10); // 10</code>
  <code>printf("%s %d", "number", 10); // number 10</code>

  <p>Напишем индикатор выполнения процесса</p>

  <details>
    <summary>Программа 4 (70)</summary>
    <p>Версия из книги</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;

int main() {
  printf("... 0%%");
  for (int i = 5; i &lt; 101; i += 5) {
    Sleep(1000);
    printf("\r... %d%%", i);
    fflush(stdout);
  }
  printf("\n");

  return 0;
}
</pre>
  <p>Моя версия</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;

int main() {
  for (int i = 5; i &lt; 100; i += 5) {
    Sleep(200);
    printf("\r.    %d%%", i);
    Sleep(200);
    printf("\r..   %d%%", i += 5);
    Sleep(200);
    printf("\r...  %d%%", i += 5);
    Sleep(200);
    printf("\r.... %d%%", i += 5);
    fflush(stdout); // сброс буфера вывода
  }

  // держим консоль открытой
  printf("\nPress any key for continue");
  fflush(stdin); // сброс буфера ввода
  getchar();

  return 0;
}
</pre>
  </details>

  <h4>2.9 Ввод данных (71)</h4>

  <h4>2.9.1 Ввод одного символа (71)</h4>

  <p>Для ввод одного символа предназначена функция getchar()</p>
  <code>char ch = getchar();</code>

  <p>Полученный символ будет в кодировке консоли. По умолчанию кодировка консоли <strong>windows-866</strong>. Чтобы принимать русские буквы в кодировке <strong>windows-1251</strong>, необходимо сменить кодировку.</p>

  <details>
    <summary>Программа 5 (72)</summary>
    <p>Сохраним файл программы в кодировке <strong>Windows-1251</strong></p>

<pre>
#include &lt;stdio.h&gt;

int main() {
  puts("Введите символ");
  char ch = getchar();
  printf("%c", ch);

  return 0;
}
</pre>

    <p>Если русские буквы не выводятся, то сменим кодировку в консоли</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;locale.h&gt;

int main() {
  // смена кодировки консоли
  system("chcp 1251");
  setlocale(LC_ALL,"Russian_Russia.1251");

  puts("Введите символ");
  char ch = getchar();
  printf("%c", ch);

  return 0;
}
</pre>
  </details>

  <h4>2.9.2 Функция scanf() (72)</h4>

  <p>Для получения и автоматического преобразования данных в корректный тип предназначена функция scanf(). Введем число</p>
  <code>int x;</code>
  <code>scanf("%d", &x);</code>

  <p>При вводе строки, функция scanf() не производит никакой проверки длины строки, что может привести к переполнению буфера. Обязательно используйте ширину при использовании спецификатора строки. Введем строку, не превышающую 255 символов</p>
  <code>char str[256] = "";</code>
  <code>scanf("%255s", str);</code>

  <details>
    <summary>Программа 6 (73)</summary>
    <p>Сохраним файл программы в кодировке <strong>Windows-1251</strong></p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;locale.h&gt;

int main() {
  // смена кодировки консоли
  system("chcp 1251");
  setlocale(LC_ALL,"Russian_Russia.1251");

  puts("Введите строку (max 255 symbols)");
  char str[256] = "";
  scanf("%255s", str);
  printf("%s", str);

  // держим консоль открытой
  printf("\nPress any key for continue");
  fflush(stdin); // сброс буфера ввода
  getchar();

  return 0;
}
</pre>
  </details>

  <p>Суммирование двух введенных чисел. Функция scanf() возвращает количество успешных операций присваивания. Мы можем проверить, что если мы ожидаем число и присвоилось число, то это успешная операция присваивания.</p>
  <details>
    <summary>Программа 7 (73)</summary>
    <p>Сохраним файл программы в кодировке <strong>Windows-1251</strong></p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;locale.h&gt;

int main() {
  // смена кодировки
  system("chcp 1251");
  setlocale(LC_ALL,"Russian_Russia.1251");

  int x = 0, y = 0;

  puts("Введите первое число");
  if (scanf("%d", &x) != 1) {
    puts("Вы ввели не число");
    return 1;
  }

  puts("Введите второе число");
  if (scanf("%d", &y) != 1) {
    puts("Вы ввели не число");
    return 1;
  }

  printf("Сумма равна %d", x + y);

  return 0;
}
</pre>
  </details>

  <h4>2.9.3 Ввод строки (77)</h4>

  <p>Для ввода строки предназначена функция gets(), но применять ее в программе не следует, т.к. функция не производит никакой проверки длины строки, что может привести к переполнению буфера. Лучше получать строку посимвольно с помощью функции getchar() или воспользоваться функцией fgets(). Функция fgets() имеет прототип</p>
  <code>char *fgets(char *buf, int maxCount, FILE *stream);</code>
  <p>Функция fgets() принимает три параметра. Первый имя переменной куда запишет строку. Второй максимальная длина строки. Третий указатель на поток, откуда брать строку. Считывание происходит до первого символа перевода строки или конца файла или пока не будет прочитано maxCount-1 символов. Символ конца строки тоже запишется в буфер.</p>

  <details>
    <summary>Программа 8 (78)</summary>
    <p>Сохраним файл программы в кодировке <strong>Windows-1251</strong></p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;locale.h&gt;
#include &lt;string.h&gt;

int main() {
  // смена кодировки консоли
  system("chcp 1251");
  setlocale(LC_ALL,"Russian_Russia.1251");

  char buf[256] = "";
  char *p = NULL;

  puts("Введите строку (max 255 symbols)");
  p = fgets(buf, 256, stdin);
  if (p) {
    // удаляем символ перевода строки
    size_t len = strlen(buf);
    if (len != 0 && buf[len - 1] == '\n') {
      buf[len - 1] = '\0';
    }
    printf("%s", buf);
  } else {
    puts("Возникла ошибка");
  }

  return 0;
}
</pre>
  </details>

  <h4>2.10 Интерактивный ввод символов (80)</h4>

  <p>Функция getchar() получает символ только после нажатия клавиши Enter.</p>
  <p>В библиотеке conio.h есть две функции _getche() и _getch().</p>
  <p>Функция _getche() возвращает код символа. Она получает символ сразу после нажатия на клавишу и выводит его на экран.</p>
  <code>char ch = _getche();</code>
  <p>Функция _getch() возвращает код символа, но не выводит его на экран.</p>
  <code>char ch2 = _getch();</code>

  <h4>2.11 Получение данных из командной строки (82)</h4>

  <p>При вызове программы, после ее имени можно передать ей данные через пробел. Эти данные функция main() примет как аргументы.</p>
  <code>int main(int argc, char* argv[]) {}</code>
  <p>Параметр argc это количество принятых аргументов. Первый аргумент это всегда название файла с программой. Поэтому argc не может быть меньше 1. Второй аргумент содержит все переданные данные в виде массива строк.</p>

  <details>
    <summary>Программа 9 (83)</summary>
<pre>
#include &lt;stdio.h&gt;

int main(int argc, char* argv[]) {
  printf("argc = %d\n", argc);
  for (int i = 0; i &lt; argc; i++) {
    printf("%s\n", argv[i]);
  }

  return 0;
}
</pre>
  </details>

  <h4>2.12 Предотвращение закрытия окна консоли (84)</h4>

  <p>Чтобы окно консоли не закрылось, надо вставить инструкцию, ожидающую нажатие клавиши. Есть несколько способов сделать это.</p>
  <p>Первый способ. Подключить библиотеку conio.h и использовать функцию _getch().</p>

  <details>
    <summary>Программа 10 (84)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;

int main(int argc, char* argv[]) {
  printf("argc = %d\n", argc);
  for (int i = 0; i &lt; argc; i++) {
    printf("%s\n", argv[i]);
  }

  _getch();  // задержка окна консоли

  return 0;
}
</pre>
  </details>

  <p>Второй способ. Подключить библиотеку stdlib.h и использовать функцию system("pause").</p>

  <details>
    <summary>Программа 11 (85)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char* argv[]) {
  printf("argc = %d\n", argc);
  for (int i = 0; i &lt; argc; i++) {
    printf("%s\n", argv[i]);
  }

  system("pause");  // задержка окна консоли

  return 0;
}
</pre>
  </details>

  <p>Третий способ. Сбросить буфер ввода fflush(stdin) и использовать функцию getchar(). Консоль закроется после нажатия клавиши Enter.</p>

  <details>
    <summary>Программа 12 (85)</summary>
<pre>
#include &lt;stdio.h&gt;

int main(int argc, char* argv[]) {
  printf("argc = %d\n", argc);
  for (int i = 0; i &lt; argc; i++) {
    printf("%s\n", argv[i]);
  }

  fflush(stdin); // сброс буфера ввода
  getchar();  // задержка окна консоли

  return 0;
}
</pre>
  </details>

  <h4>2.13 Настройка отображения русских букв в консоли (86)</h4>

  <p>Если сохранить файл с программой в кодировке windows-1251, то русские буквы отображаться в консоли не будут. Причина в том, что по умолчанию в консоли используется кодировка windows-866. Кодировку можно сменить системной командой прямо из консоли</p>
  <code>chcp 1251</code>
  <p>Кодировку консоли можно изменить и внутри программы</p>
  <code>system("chcp 1251");</code>
  <p>Чтобы в программе настроить локаль (локальные настройки компьютера), нужно подключить библиотеку locale.h и использовать функцию setlocale()</p>
  <code>#include &lt;locale.h&gt;</code>
  <code>setlocale(LC_ALL, "Russian_Russia.1251");</code>
  <p>В функции setlocale первый аргумент это число от 0 до 5, указывающее категорию. Вместо чисел можно использовать константы LC_ALL, LC_COLLATE, LC_CTYPE, LC_MONETARY, LC_NUMERIC, LC_TIME. Второй аргумент это строка, содержащая название локали, после которого через точку указывается кодировка файла с программой. Русские буквы будут правильно отображаться вне зависимости от текущей кодировки.</p>

  <details>
    <summary>Программа 13 (88)</summary>
    <p>Сохраним файл программы в кодировке <strong>Windows-1251</strong></p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;locale.h&gt;

int main() {
  setlocale(LC_ALL, "Russian_Russia.1251");
  printf("Привет, мир!\n");

  return 0;
}
</pre>
  </details>

  <h4>2.14 Преждевременное завершение выполнения программы (89)</h4>

  <p>Подключим библиотеку stdlib.h и вызовем функцию exit().</p>

  <code>#include &lt;stdlib.h&gt;</code>

  <p>Для успешного завершения можно передать значение 0 или EXIT_SUCCESS.</p>
  <code>exit(0);</code>
  <code>exit(EXIT_SUCCESS);</code>

  <p>Для аварийного завершения можно передать значение 1 или EXIT_FAILURE.</p>
  <code>exit(0);</code>
  <code>exit(EXIT_SUCCESS);</code>

  <p>Для аварийного завершения можно также использовать функцию abort. В этом случае завершение программы осуществляется операционной системой с выводом диалогового окна.</p>
  <code>abort();</code>

  <p>Внутри функции main() для завершения программы лучше использовать инструкцию return. Если завершить программу нужно вне функции main, то в этом случае инструкция return не поможет.</p>
</article>


<!-- 3 Переменные и типы данных (91) -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>3 Переменные и типы данных (91)</h3>

  <p>Переменная это участок памяти для хранения данных. Каждой переменной присваивается имя, чтобы можно было обратиться к памяти для записи или чтения данных. Каждой переменной указывается тип, чтобы была выделена память подходящего размера. В одной переменной можно хранить только одно значение.</p>

  <h4>3.1 Объявление переменной (91)</h4>

  <p>Глобальные переменные объявляются вне функций и видны во всех функциях в файле.</p>
  <p>Локальные переменные объявляются внутри функции и видны только в той функции, в которой объявлены.</p>
  <p>В одной инструкции может быть объявлена одна или несколько переменных</p>
  <code>int x;</code>
  <code>int x, y, z;</code>

  <h4>3.2 Именование переменных (92)</h4>

  <h4>3.3 Типы данных (93)</h4>

  <p>В языке Си доступны следующие элементарные типы данных</p>
  <p>char символьный тип данных.</p>
  <p>int целое число со знаком</p>
  <p>float вещественное число</p>
  <p>double вещественное число двойной точности</p>
  <p>bool логический тип данных. Если он не доступен, подключите файл</p>
  <code>#include &lt;stdbool.h&gt;</code>

  <p>Перед целым типом можно указывать модификаторы</p>
  <p>signed целое число со знаком</p>
  <p>unsugned целое число без знака</p>
  <p>short целое число, занимает 2 байта</p>
  <p>long целое число, занимает 4 байта</p>
  <p>long long целое число, занимает 8 байт</p>
  <p>При использовании модификаторов, ключевое слово int можно писать, а можно и не писать.</p>

  <p>Перед типом double можно использовать следующие модификаторы</p>
  <p>long вещественное число, занимает 12 байт в 32 разрядных системах, занимает 16 байт в 64 разрядных системах.</p>
  <code>long double x = 8e+245L;</code>

  <h4>3.4 Целочисленные типы фиксированного размера (97)</h4>

  <p>В заголовочном файле stdint.h объявлены знаковые и беззнаковые целочисленные типы фиксированного размера:</p>
  <code>int8_t, uint8_t</code>
  <code>int16_t, uint16_t</code>
  <code>int32_t, uint32_t</code>
  <code>int64_t uint64_t</code>
  <p>Минимальные и максимальные значения этих типов можно получить используя константы:</p>
  <code>INT8_MIN, INT8_MAX, UINT8_MAX</code>
  <code>INT16_MIN, INT16_MAX, UINT16_MAX</code>
  <code>INT32_MIN, INT32_MAX, UINT32_MAX</code>
  <code>INT64_MIN, INT64_MAX, UINT64_MAX</code>

  <h4>3.5 Оператор sizeof и тип size_t (99)</h4>

  <p>В зависимости от архитектуры процессора, компилятор может выделять разный размер памяти для целых типов. Точный размер типа и переменной можно узнать оператором sizeof. Имя переменной можно писать в скобках, а можно и без них. Тип данных пишется только в скобках. Оператор sizeof возвращает значение типа size_t</p>
  <code>size_t a = sizeof x;</code>
  <code>size_t b = sizeof(x);</code>
  <code>size_t c = sizeof (int);</code>

  <p>Поскольку размер типа может быть очень огромным, например большие структуры или массивы, то обычно тип size_t равен самому большому беззнаковому целому типу uint64_t</p>

  <h4>3.6 Инициализация переменных (100)</h4>

  <p>Инициализация это присвоение начального значения переменной. Инициализацию можно сделать в одной инструкции вместе с объявлением переменной, или после объявления.</p>
  <code>int x =10;</code>
  <code>int y;</code>
  <code>y = 20;</code>

  <p>Глобальные переменные инициализируются один раз и автоматически получают значение 0. Локальные переменные инициализируются каждый раз при входе в функцию и получают неопределенное значение "мусор". Статические локальные переменные инициализируются один раз и автоматически получают значени 0 и сохраняют свое значение между вызовами функции.</p>

  <h4>3.7 Оператор typedef (100)</h4>

  <p>Оператор typedef позволяет создать псевдоним для существующего типа данных.</p>
  <code>typedef long long ll;</code>
  <code>ll x = 5L;</code>

  <p>После создания псевдонима его имя можно использовать при создании другого псевдонима</p>
  <code>typedef ll lint;</code>
  <code>lint y = 10L;</code>

  <p>Псевдонимы используются для создания машинно-независимых программ и часто используются в стандартной библиотеке. Например, тип size_t это псевдоним, его размер зависит от компилятора.</p>

  <h4>3.8 Константы (101)</h4>

  <p>Константа это переменная, объявленная с ключевым словом const. Значение константы задается только один раз при ее обявлении и не меняется во время работы программы. В названии константы принято использовать большие буквы.</p>
  <code>const int CX = 10;</code>

  <p>Второй способ объявить переменную с постоянным значением это директива #define. Константа, созданная с помощью директивы #define называется макроопределением или макросом. Но такую константу, все же, можно изменить прямо в программе. Если разопределить ее директивой #undef, а затем ее снова определить с тем же именем, но другим значением.</p>
  <code>#define PI 3.14</code>
  <code>#undef PI</code>
  <code>#define PI 3.14159</code>

  <p>Посмотрим значения встроенных макросов:</p>
  <ul>
    <li>__FILE__ имя файла</li>
    <li>__LINE__ номер текущей строки</li>
    <li>__DATE__ дата компиляции файла</li>
    <li>__TIME__ время компиляции файла</li>
  </ul>

  <details>
    <summary>Программа 14 (103)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  printf("FILE %s\n", __FILE__);
  printf("LINE %d\n", __LINE__);
  printf("DATE %s\n", __DATE__);
  printf("TIME %s\n", __TIME__);

  return 0;
}
</pre>
  </details>

  <h4>3.9 Спецификаторы хранения (104)</h4>

  <p>Перед модификатором и типом могут быть указаны спецификаторы.</p>
  <ol>
    <li>auto - автоматическая локальная переменная. Она создается при входе в блок и удаляется при выходе из блока. Практически не используется, потому что локальная переменная по умолчанию является автоматической,
      <code>auto int x = 10;</code>
    </li>
    <li>register - регистровая переменная. Это подсказка компилятору, что переменная будет часто использоваться и ее надо поместить в регистр. Применяется к локальным переменным и параметрам функции. Современные компиляторы просто игнорируют этот спецификатор. Раньше использовали для счетчиков в цикле.
      <code>register int i = 0;</code>
    </li>
    <li>extern - внешняя переменная. Сообщает компилятору что переменная объявлена в другом месте, например, в другом файле. При этом компилятор память под нее повторно не выделяет.
      <code>extern int x;</code>
    </li>
    <li>static - статическая переменная. Инициализация локальной статической переменной производится только один раз. Она не уничтожается при выходе из функции, а ее значение сохраняется между вызовами функции. Глобальная статическая переменная будет видна только в пределах одного файла.</li>
  </ol>

  <h4>3.10 Области видимости переменных (105)</h4>

  <p>Глобальная переменная - это переменная объявленная вне функций и видна сразу после ее объявления и во всех функциях. Она инициализируется один раз при объявлении. По умолчанию инициализируется нулем.</p>
  <p>Локальная переменная - это переменная объявленная внутри функции или блока ограниченного фигурными скобками. Локальная переменная видна только внутри функции или блока, где она объявлена. По умолчанию инициализируется "мусором" (значением в памяти, оставшимся после других программ).</p>

  <h4>3.11 Массивы (107)</h4>

  <p>Определим массив из трех элементов</p>
  <code>int arr[3] = {10, 20, 30};</code>
  <code>int arr[] = {10, 20, 30};</code>
  <p>После определения массива выделяется необходимый размер памяти, а в переменную записывается адрес первого элемента массива</p>
  <p>Определим размер массива из 3 элементов</p>
  <code>size_t razm = sizeof(int) * 3;</code>
  <p>Обратиться к элементам массива можно с помощью квадратных скобок, в которых указывается индекс элемента. При указании индекса внутри квадратных скобок производится вычисление адреса элемента массива относительно адреса первого элемента, который записан в переменной с именем массива.</p>
  <p>Массивы могут быть много мерными. Создадим двумерный массив</p>
  <code>int arr[2][4];</code>
  <p>Элементы двумерного массива располагаются в памяти друг за другом. Сначала элементы первой строки, затем второй и т.д. При инициализации двумерного массива, элементы каждой строки можно указать в фигурных скобках.</p>
  <code>int arr[2][4] = { {1,2,3,4}, {5,6,7,8} };</code>

  <h4>3.12 Строки (110)</h4>

  <p>Строка это массив символов, последний элемент которого содержит символ конца строки '\0'.</p>
  <p>Объявление строки без инициализации</p>
  <code>char str[7];</code>
  <p>Объявление и инициализация строки. При инициализации по-символьно, последним нужно указывать символ конца строки '\0'.</p>
  <code>char str[7] = {'s','t','r','i','n','g','\0'};</code>
  <p>При инициализации строкой используют двойные кавычки и пишут на 1 символ меньше. Потому что послений символ - символ конца строки '\0' будет добавлен автоматически.</p>
  <code>char str[7] = "string";</code>

  <h4>3.13 Указатели (111)</h4>

  <p>Указатель это переменная, которая предназначена для хранения адреса. Если при объявлении указателя, он никуда не должен указывать, то его инициализируют значением NULL.</p>
  <code>int *p = NULL;</code>
  <p>Чтобы присвоить указателю адрес переменной, тип данных указателя и переменной должны совпадать. Адресная арифметика использует тип данных указателя для рассчета адресов следующих подряд переменных.</p>
  <code>int x = 10;</code>
  <code>int *p1 = &amp;x;</code>
  <p>Указателю можно присвоить значение другого указателя. Их типы данных должны совпадать.</p>
  <code>int *p2 = p1;</code>
  <p>Помимо копирования адреса из указателя в указатель, можно создать указатель на указатель. Для этого при объявлении указывают два оператора звездочка</p>
  <code>int **p3 = NULL;</code>
  <code>p3 = &amp;p2;</code>
  <p>Указатель можно использовать при обращении к строке или элементам массива.</p>
  <p>Указатели можно использовать при передачи параметров в функцию. По умолчанию переменная в функцию передается <strong>по значению</strong>. Это значит, что создается копия значения переменной, сама же переменная вне функции остается неизменной. При передачи в функцию указателя, переменная на которую он указывает передается <strong>по ссылке</strong>. Значение такой перенной можно изменить внутри функции. Тогда вне функции она тоже изменится.</p>

  <h3>3.14 Динамическое выделение памяти (118)</h3>

  <p>При объявлении переменной указывается тип данных. При объявлении массива указывается тип данных и количество элементов. По этой информации компилятор выделяет необходимый размер памяти, который автоматически освобождается при завершении программы. Память, размер которой определяется компилятор и известен до начала программы, называется статическая. Изменить ее во время выполнения программы невозможно.</p>
  <p>Если размер массива заранее неизвестен, то используют динамическую память. Выделение и освобождение памяти осуществляется во время выполнения программы и заботиться об этом должен программист. Если память не освободить, то она становится недоступной и происходит "утечка" памяти.</p>

  <h4>Функции malloc() и free() (118)</h4>

<pre>
#include &lt;stdlib.h&gt;

const int SIZE = 10;
int *p = malloc(SIZE * sizeof(int));
</pre>

  <p>Библиотека stdlib.h содержит функцию malloc, которая принимает один аргумент - размер памяти в байтах и возвращает указатель типа void*. Если память выделить не удалось, возвращается указатель на NULL. Все элементы выделенной памяти до инициализации содержат мусор.</p>
  <p>В языке Си указатель типа void* автоматически неявно приводится к другому типу, поэтому использовать явное приведение не нужно. В языке C++ нужно обязательно выполнять явное приведение.</p>
  <p>Для освобождения динамической памяти, выделенной функцией malloc(), используют функцию free().</p>

  <h4>3.14.2 Функция calloc*() (119)</h4>

<pre>
#include &lt;stdlib.h&gt;

const int SIZE = 10;
int *p = calloc(SIZE, sizeof(int));
</pre>
  <p>Функция calloc() принимает два параметра - количество элементов и размер одного элемента и возвращает указатель типа void*. Если память выделить не удалось, возвращается указатель на NULL. Все элементы выделенной памяти автоматически инициализируются значением 0.</p>

  <h4>3.14.3 Функция realloc() (122)</h4>

<pre>
#include &lt;stdlib.h&gt;

const int SIZE = 10;
int *p = calloc(SIZE, sizeof(int));
const int SIZE2 = 100;
int *p2 = realloc(p, SIZE2 * sizeof(int));
</pre>

  <p>Функция realloc() выполняет перераспределение памяти. Она принимает два параметра - указатель на выделенную ранее память и размер новой памяти в байтах. Функция выделит новую память, скопирует в нее элементы из старой памяти, освободит старую память и вернет указатель на новую память. Если размер новой памяти больше чем старой, то новые элементы памяти будут содержать мусор. Если размер новой памяти меньше чем старой, то лишние элементы будут удалены. Если память не может быть выделена, то функция вернет указатель на NULL, при этом прежняя память не изменится</p>

  <h4>3.15 Структуры (123)</h4>

<pre>
struct Student {
  string name;
  int age;
};
</pre>

  <p>Структура - это совокупность переменных, объединенных под одним именем. Объявление структуры только описывает новый тип данных, а не определяет переменную, поэтому память под нее не выделяется.</p> <p>Чтобы объявить переменную, ее название указывается после закрывающей фигурной скобки при объявлении структуры. Допустимо не задавать имя структуры, если сразу объявляется имя переменной.</p>
<pre>
struct Point {
  int x;
  int y;
} p1;

struct {
  string name;
  int age;
} Vova;
</pre>

  <p>Также переменную структуры можно объявить отдельно от нее как и другие переменные, указав тип данных. При объявлении можно выполнить инициализацию переменной. При инициализации можно в списке указывать точку и название поля структуры.</p>
  <code>struct Point p2, p3;</code>
  <code>struct Point p2 = {10, 20};</code>
  <code>struct Point p2 = {.x = 10, .y = 20};</code>

  <p>При объявлении переменной типа структуры выделяется необходимый размер памяти. Для вычисления этого размера используют оператор sizeof.</p>
  <code>sizeof(p1);</code>

  <p>Одну структуру можно присвоить другой структуре, при этом копируются значения всех полей структуры. Структуры можно вкладывать в другие структуры. Адрес структуры можно сохранить в указателе с типом этой структуры.</p>
  <code>struct Point *p = &amp;p1;</code>

  <h4>3.16 Битовые поля (126)</h4>

  <p>Битовые поля это поля структуры, позволяющие в одной переменной хранить несколько значений, используя доступ к отдельным битам. При этом никакой экономии памяти не происходит, потому что минимальный размер битового поля соответствует типу int. Битовые поля объявляются только с типом int.</p>

<pre>
struct Bit {
  int a : 2; // размер в 2 бита
  int b : 4; // размер в 4 бита
};
</pre>

  <p>В одной структуре можно использовать одновременно битовые поля и обычные поля. Название битового поля можно не указывать. Если размер поля составляет 1 бит, то необходимо указать ключевое слово unsigned.</p>

  <h4>3.17 Объединения (127)</h4>

  <p>Объединение - это одна область памяти, используемая для хранения данных разных типов. В один момент времени в этой области могут храниться данные только одного типа. Размер объединения равен размеру самого большого типа.</p>

<pre>
union Num {
  int x;
  float y;
  double z;
};

union Num num1;
union Num num2 = {10};
union Num num3 = {.z = 1.2};
</pre>

  <h4>3.18 Перечисления (129)</h4>

<pre>
enum Color {
  RED, GREEN, BLUE, BLACK
} color1;
</pre>

  <h4>3.19 Приведение типов (130)</h4>

  <p>Если в выражении используются переменные разных типов, то тип результата выражения будет соответствовать более сложному типу.</p>
</article>


<!-- 4 Операторы и циклы (133) -->
<article class="article">
  <div class="anchor" id="p4"></div>
  <h3>4 Операторы и циклы (133)</h3>

  <h4>4.1 Математические операторы (133)</h4>

  <p>Деление целого числа на 0 вызовет ошибку. Деление вещественного числа на 0 вернет +INFINITY или -INFINITY (бесконечность). Деление вещественного числа 0.0 на 0.0 вернет значение NAN (нет числа).</p>

  <h4>4.2 Побитовые операторы (135)</h4>

  <p>Побитовые операторы предназначены для манипуляции отдельными битами и применяются только к целым числам.</p>

  <h4>4.3 Операторы присваивания (138)</h4>

  <p>Операторы присваивания предназначены для сохранения значения в переменной.</p>

  <h4>4.4 Оператор запятая (138)</h4>

  <p>Оператор запятая позволяет разместить сразу несколько выражений внутри одной инструкции. Результат вычисления последнего выражения можно присвоить переменной.</p>
  <code>int x, y;</code>
  <code>x = (y = 10, z = 20, y + z);</code>

  <h4>4.5 Операторы сравнения (139)</h4>

  <p>Операторы сравнения возвращают логический тип данных.</p>

  <h4>4.6 Приоритет выполнения операторов (141)</h4>

  <p>Все операторы имеют приоритет. Если в выражении более одного оператора, то сначала будут вычисляться выражения, в котором оператор имеет более высокий приоритет.</p>

  <h4>4.7 Оператор ветвления if (142)</h4>

  <p>Оператор ветвления позволяет выполнить отдельный блок программы, если выполняется некоторое условие. Условие в операторе if всегда автоматически преобразовывается в логический тип.</p>

  <h4>4.8 Тернарный оператор ?: (146)</h4>

  <p>Если в зависимости от условия должно обязательно выполниться одно или другое действие, то можно использовать тернарный оператор &:. Присвоим переменной x единицу, если переменная y содержит четное число, иначе присвоим ноль.</p>
  <code>int x = y % 2 == 0 ? 1 : 0;</code>

  <h4>4.9 Оператор выбора switch (147)</h4>

  <p>Оператор switch в качестве условия принимает выражение, которое должно быть целое число или символ.</p>

  <h4>4.10 Цикл for (149)</h4>

  <h4>4.11 Цикл while (152)</h4>

  <h4>4.12 Цикл do while (152)</h4>

  <h4>4.13 Оператора continue: переход на следующую итерацию цикла (153)</h4>

  <h4>4.14 Оператора break: прерывание цикла (153)</h4>

  <h4>4.15 Оператор goto (154)</h4>
</article>


<!-- 5 Числа (156) -->
<article class="article">
  <div class="anchor" id="p5"></div>
  <h3>5 Числа (156)</h3>

  <h4>5.1 Математические константы (159)</h4>

  <p>В заголовочном файле math.h определены математические константы.</p>

  <h4>5.2 Основные функции для работы с числами (160)</h4>

  <h4>5.3 Округление чисел (164)</h4>

  <h4>5.4 Тригонометрические функции (165)</h4>

  <h4>5.5 Преобразование строки в число (165)</h4>

  <p>Для преобразования строки в число используют функции из библиотеки stdlib.h.</p>

  <h4>5.6 Преобразование числа в строку (174)</h4>

  <h4>5.7 Генерация псевдослучайных чисел (177)</h4>

  <h4>5.8 Бесконечность и значение NAN (179)</h4>

  <p>Деление целого числа на 0 приведет к неопределенности.</p>
  <p>Деление вещественного числа на 0 приведет к +INFINITY и -INFINITY.</p>
  <p>Деление вещественного числа 0.0 на 0.0 приведет к неопределенности или значению NAN (нет числа).</p>
  <p>Значение NAN не равно самому себе, поэтому</p>
  <code>NAN == NAN; // 0</code>

  <p>Заголовочный файл math.h содержит константы INFINITY, -INFINITY, NAN и функции проверки этих констант</p>
  <ol>
    <li>Функции _finite() и _finitef() возвращают 0, если значение равно INFINITY, -INFINITY или NAN, иначе возвращают ненулевое значение.</li>
    <li>Функции isnan(), _isnan(), _isnanf() возвращают ненулевое значение, если значение равно NAN, иначе возвращают 0</li>
    <li>Функция isinf() возвращает ненулевое число, если значение равно INFINITY или -INFINITY, иначе возвращает 0.</li>
  </ol>
</article>


<!-- 6 Массивы (181) -->
<article class="article">
  <div class="anchor" id="p6"></div>
  <h3>6 Массивы (181)</h3>

  <h4>6.1 Объявление и инициализация массива (181)</h4>

  <p>Объявление массива</p>
  <code>int arr[3];</code>
  <p>Объявление и инициализация массива</p>
  <code>int arr[3] = {10, 20, 30}; // 10 20 30</code>
  <code>int arr[3] = {10, 20}; // 10 20 0</code>
  <code>int arr[3] = {0}; // 0 0 0</code>
  <p>Инициализация по индексу</p>
  <code>int arr[3] = {[0] = 5, [2] = 11}; // 5 0 11</code>
  <p>Можно комбинировать инициализацию по позиции и по индексу</p>
  <code>int arr[8] = {5, [2] = 11, 15, [6] = 22, 55}; // 5 0 11 15 0 0 22 55</code>

  <h4>6.2 Определение количества элементов и размера массива (183)</h4>

  <code>int arr[15] = {0};</code>
  <p>Определить количество элементов массива можно используя оператор sizeof</p>
  <code>(int) (sizeof(arr) / sizeof(int)); // 15</code>
  <p>Можно воспользоваться макросом _countof() из stdlib.h</p>
  <code>(int)_countof(arr); // 15</code>

  <h4>6.3 Получение и изменение значения элемента массива (184)</h4>

  <h4>6.4 Перебор элементов массива (185)</h4>

  <h4>6.5 Доступ к элементам массива с помощью указателя (186)</h4>

  <h4>6.6 Массивы указателей (189)</h4>

  <p>Указатели можно сохранять в массиве.</p>

  <h4>6.7 Динамические массивы (189)</h4>

  <h4>6.8 Многомерные массивы (190)</h4>

  <code>int arr[2][4];</code>

  <h4>6.9 Поиск минимального и максимального значений (193)</h4>

  <h4>6.10 Сортировка массива (195)</h4>

  <h4>6.11 Проверка наличия значения в массиве (198)</h4>

  <h4>6.12 Копирование элементов из одного массива в другой (201)</h4>

  <p>Библиотека string.h содержит функцию memcpy() для копоирования элементов из одного массива в другой.</p>
  <code>memcpy(dst, src, size);</code>
  <p>Функция memcpy() копирует первые size байтов из массива src в массив dst и возвращает указатель на массив dst.</p>
  <code>memcpy_s(dst, dstSize, src, maxCount);</code>
  <p>Функция memcpy_s() копирует первые maxCount байтов из массива src в массив dst. Массив dst имеет размер dstSize. При успешном копировании функция возвращает 0.</p>
  <code>memmove(dst, src, size);</code>
  <p>Функция memmove() копирует первые size байтов из массива src в массив dst.</p>
  <code>memmove_s(dst, dstSize, src, maxCount);</code>
  <p>Функция memmove_s() копирует первые maxCount байт из массива src в массив dst. Массив dst имеет размер dstSize. При успешном копировании функция возвращает 0.</p>

  <h4>6.13 Сравнение массивов (203)</h4>

  <code>memcmp(buf1, buf2, size);</code>
  <p>Функция memcmp() сравнивает первые size байт массивов buf1 и buf2.</p>

  <code>_memicmp(buf1, buf2, size);</code>
  <p>Функция _memicmp() сравнивает первые size байт массивов buf1 и buf2.</p>

  <code>_memicmp_l(buf1, buf2, size, locale);</code>
  <p>Функция _memicmp_l() сравнивает первые size байт массивов buf1 и buf2. Параметр locale задает локаль.</p>

  <h4>6.14 Переворачивание массива (204)</h4>
</article>


<!-- 7 Символы и C-строки (206) -->
<article class="article">
  <div class="anchor" id="p7"></div>
  <h3>7 Символы и C-строки (206)</h3>

  <p>В языке Си доступны два типа строк: C-строка и L-строка. C-строка является массивом однобайтовых символов (тип char), последний элемент которого содержит нулевой символ '\0'. L-строка является массивом широких символов (тип wchar_t), последний элемент которого содержит нулевой символ '\0'.</p>

  <h4>7.1 Символы и C-строки (206)</h4>

  <p>Символы, имеющие код меньше 128, соответствуют кодировке ASCII. Символы, имеющие код от 129 до 255 предназначены для кодировки национальных алфавитов.</p>
  <p>Для кодировки русских букв предназначено пять кодировок - windows1251 (cp1251), windows-866 (cp866), iso8859-5, koi8-r, mac-cyrillic. По умолчанию, в окне консоли используктся кодировка cp866.</p>

  <h4>7.2 Настройка локали (212)</h4>

  <p>Библиотека locale.h содержит функцию setlocale(), которая позволяет настроить локаль (совокупность локальных настроек системы).</p>
  <code>setlocale(category, locale);</code>

  <h4>7.3 Изменение регистра символов (216)</h4>

  <ol>
    <li>toupper(ch) возвращает код символа в верхнем регистре</li>
    <li>_toupper_l(ch, locale) возвращает код символа в верхнем регистре</li>
    <li>tolower(ch) возвращает код символа в нижнем регистре</li>
    <li>_tolower_l(ch, locale) возвращает код символа в нижнем регистре</li>
    <li>_strupr(str) заменяет все буквы в C-строке буквами в верхнем регистре</li>
    <li>_strupr_s(str, size) заменяет все буквы в C-строке размером size буквами в верхнем регистре</li>
    <li>_strlwr(str) заменяет все буквы в C-строке буквами в нижнем регистре</li>
    <li>_strlwr_s(str, size) заменяет все буквы в C-строке размером size буквами в нижнем регистре</li>
    <li></li>
    <li></li>
  </ol>

  <h4>7.4 Проверка типа содержимого символа (218)</h4>

  <h4>7.5 Объявление и инициализация C-строки (222)</h4>

  <p>Строку можно присвоить указателю, но через указатель строка будет доступна толко для чтения</p>
  <code>const char *p = "string";</code>
  <p>Можно объявить несколько указателей и присвоить им одинаковую строку, но все они будут ссылаться на один и тот же адрес.</p>
  <code>const char *p1 = "string";</code>
  <code>const char *p2 = "string";</code>
  <code>const char *p3 = "string";</code>

  <h4>7.6 Доступ к символам внутри C-строки (224)</h4>

  <p>Доступ к символам в строке может быть как по индексу, так и с использованием адресной арифметики.</p>
  <code>char str[] = "string";</code>
  <code>char ch1 = str[1];</code>
  <code>char ch2 = *(str + 1);</code>

  <h4>7.7 Определение длины строки (225)</h4>

  <code>char str[] = "string";</code>
  <code>int len = (int)strlen(str);</code>

  <h4>7.8 Перебор символов C-строки (226)</h4>

<pre>
char str[] = "string";
int len = (int)strlen(str);

for (int i = 0; i &lt; len; i++) {
  printf("%c\n", str[i]);
}

for (char *p = str; *p; p++) {
  printf("%c\n", *p);
}
</pre>

<h4>7.9 Основные функции для работы с C-строками (227)</h4>

<h4>7.10 Поиск и замена в C-строке (232)</h4>

<h4>7.11 Сравнение C-строк (237)</h4>

<h4>7.12 Форматирование C-строк (242)</h4>

<p>Выполнить форматирование C-строки, а также преобразовать значения элементарных типов в C-строку можно с помощью функций sprintf() и _sprintf_l().</p>
</article>


<!-- 8 Широкие символы и L-строки (244) -->
<article class="article">
  <div class="anchor" id="p8"></div>
  <h3>8 Широкие символы и L-строки (244)</h3>

  <p>Широкие символы имеют тип wchar_t. Из широких символов состоят L-строки.</p>

  <h4>8.1 Объявление и инициализация широкого символа (245)</h4>

  <p>Тип wchar_t содержится в библиотеке wchar.h и имеет определение</p>
  <code>typedef usigned short wchar_t</code>
  <p>Диапазон допустимых значений от WCHAR_MIN = 0 до WCHAR_MAX = 65535</p>

  <p>Еще есть тип wint_t</p>
  <code>typedef usigned short wint_t</code>
  <p>Диапазон допустимых значений от WINT_MIN = 0 до WINT_MAX = 65535</p>

  <p>Объявим переменную типа wchar_t</p>
  <code>wchar_t a = 1087;</code>
  <code>wchar_t b = L'a';</code>
  <code>wchar_t b = L'u043F';</code>

  <h4>8.2 Вывод и ввод широких символов (247)</h4>

  <p>Для ввода и вывода широких символов нужно настроить локаль с помощью функции setlocale()</p>
<pre>
#include &lt;locale.h&gt;
setlocale(LC_ALL, "Russian_Russia.1251");
</pre>
  <p>Или с помощью функции _wsetlocale()</p>
<pre>
#include &lt;locale.h&gt;
_wsetlocale(LC_ALL, L"Russian_Russia.1251");
</pre>

  <p>Функция putwchar() выводит широкий символ</p>
<pre>
wchar_t ch = L'п';
putwchar(ch);
</pre>
  <p>Функция wprintf() выводит широкий символ</p>
<pre>
wchar_t ch = L'п';
wprintf(L"%c\n", ch);
printf("%lc\n", ch);
printf("%C\n", ch);
</pre>

  <p>Функция getwchar() вводит широкий символ. Получить символ можно только после нажатия клавиши Enter</p>
<pre>
wchar_t ch;
ch = getwchar();
wprintf(L"%c\n", ch);
printf("%u\n", ch);
</pre>
  <p>Функциия _getwche() вводит широкий символ сразу после нажатия на клавишу и выводит его на экран. Функциия _getwche() возвращает код символа</p>
<pre>
wchar_t ch;
ch = _getwche();
</pre>
  <p>Функциия _getwch() вводит широкий символ сразу после нажатия на клавишу. Функциия _getwch() возвращает код символа</p>
<pre>
wchar_t ch;
ch = _getwch();
</pre>
  <p>Функция wscanf() вводит широкие символы</p>
<pre>
wchar_t ch;
wscanf(L"%c", &ch);
</pre>

  <h4>8.3 Изменение регистра символов (249)</h4>

  <h4>8.4 Проверка типа содержимого широкого символа (251)</h4>

  <h4>8.5 Преобразование широких символов в обычные и наоборот (255)</h4>

  <p>Функция btowc(ch) принимает обычный символ, преобразовывает его в широкий и возвращает широкий символ. В случае ошибки возвращает символ WEOF (65535)</p>
<pre>
setlocale(LC_ALL, "Russian_Russia.1251");
char ch = 'п';
wchar_t wch = btowc((unsigned char)ch);
wprintf(L"%c\n", wch);
</pre>

  <p>Функция wctob(ch) принимает широкий символ, преобразовывает его в обычный и возвращает обычный символ. В случае ошибки возвращает -1</p>
<pre>
setlocale(LC_ALL, "Russian_Russia.1251");
wchar_t wch = L'п';
char ch = (char)wctob(wch);
printf("%c\n", ch);
</pre>

  <h4>8.6 Объявление и инициализация L-строки (256)</h4>

  <p>L-строки являются массивами, содержащими символы типа wchar_t. Последним символом строки является нулевой символ.</p>
  <code>wchar_t str[7];</code>
  <code>wchar_t str[] = {L'т', L'е', L'к', L'с', L'т', L'\0'};</code>
  <code>wchar_t str[] = {L'\u0442', L'\u0435', L'\u043A', L'\u0441', L'\u0442', L'\0'};</code>
  <code>wchar_t str[] = { 1090, 1077, 1082, 1089, 1090, 0};</code>
  <p>Присвоить строку в двойных кавычках можно только при инициализации</p>
  <code>wchar_t str[] = L"текст";</code>
  <p>Внутри одной инструкции строки объединяются в одну строку.</p>
  <code>wchar_t str[] = L"хороший" L"текст";</code>

  <h4>8.7 Доступ к символам внутри L-строки (257)</h4>

  <p>После определения новой строки в переменной сохраняется адрес первого символа. Доступ к символам строки осуществляется по индексу или с использованием адресной арифметики.</p>
<pre>
wchar_t str[] = L"строка";
wprintf(L"%c\n", str[1]);
wprintf(L"%c\n", *(str + 1));
</pre>
  <p>Можно объявить указатель и присвоить ему адрес строки</p>
<pre>
wchar_t str[] = L"строка";
wchar_t *p = NULL;
p = str;
*p = L'С';
++p;
*p = L"Т";
wprintf(L"%s\n", str); // СТрока
</pre>

  <h4>8.8 Определение длины L-строки(258)</h4>

  <p>Функция wcslen() возвращает количество символов без учета нулевого символа.</p>
  <p>Длина L-строки и длина символьного массива - это разные вещи. Длина L-строки это количество символов с начала массива  до первого нулевого символа. Длина символьного массива - это общее количество символов в массиве.</p>

  <h4>8.9 Перебор симоволов L-строки (259)</h4>

<pre>
_wsetlocale(LC_ALL, L"Russian_Russia.1251");
wchar_t str[] = L"строка";
int len = (int)wcslen(str);
for (int i = 0; i &lt; len; i++) {
  wprintf(L"%c\n", str[i]);
}
</pre>

<pre>
_wsetlocale(LC_ALL, L"Russian_Russia.1251");
wchar_t str[] = L"строка";
for (wchar_t *p = str; *p; p++) {
  wprintf(L"%c\n", *p);
}
</pre>
  <p>При достижении конца строки мы получим нулевой символ. Поскольку нулевой символ трактуется как ложное значение, то цикл на нем закончится.</p>

<pre>
_wsetlocale(LC_ALL, L"Russian_Russia.1251");
wchar_t str[] = L"строка";
wchar_t *p = str;
while (*p) {
  wprintf(L"%c\n", *p++);
}
</pre>

  <h4>8.10 Вывод и ввод L-строк (260)</h4>

  <ol>
    <li>Функция _putws(str) выводит L-строку и вставляет символ перевода строки</li>
    <li>Функция wprintf() форматированный вывод L-строк</li>
    <li>Функция _getws(str) вводит L-строку, но не проверяет длину строки</li>
    <li>Функция fgetws(str, n, stream) вводит L-строку до первого символа перевода строки или до конца потока или пока не будет прочитано n-1 символов.</li>
    <li>Функция wscanf() форматированный ввод L-строк</li>
  </ol>

  <h4>8.11 Преобразование C-строки в L-строку и наоборот (263)</h4>

  <p>Функция mbstowcs(str, wstr, n) преобразует C-строку str в L-строку wstr. Максимальное количество символов строки wstr равно n.</p>
  <p>Функция mbstowcs_s(str_size, str, wstr_size, wstr, n) преобразует C-строку str в L-строку wstr. Максимальное количество символов строки wstr равно n.</p>
  <p>Функция wcstombs(str, wstr, n) преобразует L-строку wstr в C-строку str. Максимальное количество символов строки wstr равно n.</p>
  <p>Функция wcstombs_s(str_size, str, wstr_size, wstr, n) преобразует L-строку wstr в C-строку str. Максимальное количество символов строки wstr равно n.</p>

  <h4>8.12 Преобразование кодировок (265)</h4>

  <p>Все символы L-строки кодируются двумя байтами. Не следует рассматривать L-строку как строку в какой-то кодировке.</p>
  <p>Когда мы говорим о строке в какой-нибудь кодировке, мы всегда подразумеваем C-строку. По умолчанию во всех проектах надо настраивать для C-строк кодировку windows-1251.</p>
  <p>Используя функции mbstowcs() и wcstombs() можно преобразовать C-строку из одной однобайтовой кодировки в другую. В этом случае L-строка используется как промежуточная стадия.</p>
  <p>Преобразуем строку из кодировки windows-1251 в кодировку windows-866</p>
  <p>Для преобразования кодировок в Windows можно воспользоваться функциями из WinAPI</p>
  <ol>
    <li>Функция CharToOemA(src, dst) преобразует строку src в кодировке windows-1251 в строку dst в кодировке windows-866</li>
    <li>Функция CharToOemBuffA(src, dst, len) преобразует строку src в кодировке windows-1251 в строку dst в кодировке windows-866. len - количество символов</li>
    <li>Функция OemToCharA(src, dst) преобразует строку src в кодировке windows-866 в строку dst в кодировке windows-1251</li>
    <li>Функция OemToCharBuffA(src, dst, len) преобразует строку src в кодировке windows-866 в строку dst в кодировке windows-1251. len - количество символов</li>
    <li>Функция MultiByteToWideChar(codePage, dwFlags, lpMultiByteStr, cbMultiByte, lpWideCharStr, cchWideChar) преобразует C-строку lpMultiByteStr в L-строку lpWideCharStr. Параметр codePage задает кодировку C-строки. Параметр cbMultiByte задает количество байт C-строки. Параметр cchWideChar задает максимальный размер L-строки в символах.</li>
    <li>Функция WideCharToMultiByte(codePage, dwFlags, lpWideCharStr, cchWideChar, lpMultiByteStr, cbMultiByte, lpDefaultChar, lpUsedDefaultChar) преобразует L-строку lpWideCharStr в C-строку lpMultiByteStr. Параметр codePage задает кодировку C-строки. Параметр cbMultiByte задает количество байт C-строки. Параметр cchWideChar задает максимальный размер L-строки в символах. Параметр lpDefaultChar задает символ, который будет использоваться, если символ в L-строке не может быть преобразован.</li>
  </ol>

  <h4>8.13 Основные функции для работы с L-строками (271)</h4>

  <h4>8.14 Поиск и замена в L-строке (277)</h4>

  <h4>8.15 Сравнение L-строк (282)</h4>

  <h4>8.16 Преобразование L-строки в число (286)</h4>

  <h4>8.17 Преобразование числа в L-строку (294)</h4>

  <h4>8.18 Типы char16_t и char32_t (297)</h4>

  <p>В стандарте C11 появилось два новых типа char16_t и char32_t в библиотеке uchar.h</p>
  <p>Тип char16_t описывает символ в кодировке UTF-16. При инициализации символа или строки перед литералом указывается строчная буква u</p>
  <code>char16_t ch = u'я';</code>
  <code>char16_t str[] = u'строка';</code>
  <p>Тип char32_t описывает символ в кодировке UTF-32. При инициализации символа или строки перед литералом указывается заглавная буква U</p>
  <code>char32_t ch = U'я';</code>
  <code>char32_t str[] = U'строка';</code>

  <p>Функция size_t c16rtomb(buf, ch, state) преобразует символ ch из кодировки UTF-16 в кодировку, указанную с помощью локали и записывает результат в символьный массив buf. Функция возвращает число байтов, записанных в массив buf или -1 в случае ошибки.</p>
  <p>Функция size_t mbrtoc16(ch, str, n, state) преобразует многобайтовый символ, записанный в строку str, в кодировку UTF-16 и сохраняет его в переменной ch. Кодировка указывается с помощью локали. Максимально просматривается n символов строки str.</p>
  <p>Функция size_t c32rtomb(buf, ch, state) преобразует символ ch и записывает результат в символьный массив buf. Функция возвращает число байтов, записанных в массив buf, или -1 в случае ошибки.</p>
  <p>Функция size_t mbrtoc32(ch, str, n, state) преобразует многобайтовый символ, записанный в строку str в символ в кодировке UTF-32 и сохраняет его в переменной ch.</p>
</article>


<!-- 9 Работа с датой и временем (300) -->
<article class="article">
  <div class="anchor" id="p9"></div>
  <h3>9 Работа с датой и временем (300)</h3>

  <h4>9.1 Получение текущей даты и времени (301)</h4>

  <p>Функцию time можно вызвать двумя способами.</p>
  <code>time_t t1 = time(NULL);</code>
  <code>time_t t2; time(&t2);</code>

  <h4>9.2 Форматирование даты и времени (305)</h4>

  <h4>9.3 "Засыпание" программы (309)</h4>

  <p>Прервем выполнение программы на 1 секунду</p>
  <code>#include &lt;unistd.h&gt;</code>
  <code>sleep(1);</code>

  <p>В Windows есть функция Sleep(). Заснем на 1 секунду</p>
  <code>#include &lt;windows.h&gt;</code>
  <code>Sleep(1000);</code>

  <h4>9.4 Измерение времени выполнения фрагментов кода (311)</h4>

<pre>
#include &lt;time.h&gt;
#include &lt;windows.h&gt;

int main() {
  clock_t t1, t2, t3;
  t1 = clock();
  Sleep(2000);
  t2 = clock();
  t3 = t2 - t1;
}
</pre>
</article>


<!-- 10 Пользовательские функции (312) -->
<article class="article">
  <div class="anchor" id="p10"></div>
  <h3>10 Пользовательские функции (312)</h3>

  <h4>10.1 Создание функции и ее вызов (312)</h4>

  <p>Создание функции состоит из двух частей: объявление и определение. Объявление (называется прототипом функции) содержит информацию о типе возвращаемого значения и типах и количестве параметров функции. Определение функции содержит еще и названия параметров и реализацию функции.</p>

  <h4>10.2 Расположение объявлений и определений функции (315)</h4>

  <p>Поскольку одна функция может вызывать другую, перед каждым вызовом функции, она должна быть определена. Кроме функции main(), потому что она вызвается первой. Следует размещать в начале программы, до функции main(), все прототипы функций, а их определения размещать после функции main().</p>
  <p>Если размер программы становится большим, то ее разделяют на несколько файлов. Объявления функций выносят в заголовочный файл с расширением .h, а определения функций размещают в файле с тем же именем с расширением .c. Там где эти функции используются, подключают заголовочный файл с помощью директивы #include.</p>

  <p>Заголовочный файл my_module.h</p>
<pre>
#ifndef MY_MODULE_H_
#define MY_MODULE_H_

#include &lt;stdio.h&gt;
int sum_i(int, int);
#endif
</pre>

  <h4>10.3 Способы передачи параметров в функцию (318)</h4>

  <p>Функция без параметров</p>
  <code>int func(void) {}</code>
  <p>Передача параметров по значению</p>
  <code>int func(int a, int b) {}</code>
  <p>Передача параметров по ссылке через указатель</p>
  <code>int func(int *pa, int *pb) {}</code>

  <h4>10.4 Передача массивов и строк в функцию (320)</h4>

  <code>int func(char *s) {}</code>
  <code>int func(char s[]) {}</code>

  <p>Оператор sizeof вне функции вернет размер всего символьного массива. Оператор sizeof внутри функции вернет размер указателя. Если нужно узнать размер всего массива, в функцию нужно передать еще и количество элементов в нем, которое внутри функции нужно умножить на размер типа данных чтобы получить размер массива.</p>

  <p>При передаче много мерного массива, нужно явно указать все размеры</p>
  <code>int func(int a[2][4]) {}</code>
  <p>Но первый размер можно и не указывать</p>
  <code>int func(int a[][4]) {}</code>

  <h4>10.5 Переменное количество параметров (324)</h4>

  <p>Количество параметров в функции может быть произвольным, если хотябы один первый параметр является обязательный. Остальные параметры указываются тремя точками.</p>
  <code>int printf(const char *format, ...);</code>
  <p>Получить доступ к этим параметрам внутри функции можно с помощью специальных макросов va_start(), va_arg(), va_end()</p>

  <h4>10.6 Константные параметры (325)</h4>

  <p>Если внутри функции параметр не должен меняться, то его следует объявить константным</p>
  <code>int sum(const int x, const int y);</code>

  <h4>10.7 Статические переменные и функции (326)</h4>

  <p>Параметры функции и переменные объявленные внутри нее являются локальными переменными, которые создаются при входе в функцию и уничтожаются при выходе из нее. Локальные переменные инициализируются каждый раз при вызове функции.</p>
  <p>Статические переменные предназначены для сохранения промежуточных значений между вызовами функции. Инициализация статической переменной производится только один раз при первом вызове функции. Статическая переменная объявляется с ключевым словом static.</p>

  <h4>10.8 Способы возврата значения из функции (328)</h4>

  <p>Функция может вернуть значение любого типа кроме массива. Работать с массивом необходимо через параметры функции, передавая указатель на него и возвращая указатель на него. Можно вернуть указатель на конкретный элемент. Нельзя возвращать указатель на массив или другие элементы, созданные внутри функции, т.к. при выходе из функции они будут уничтожены.</p>

  <h4>10.9 Указатели на функции (330)</h4>

  <p>Функции так же, как и переменные, имеют адрес, который можно сохранить в указателе. Функцию можно вызвать через указатель на функцию. Указатель на функцию можно передавать как параметр в другую функцию.</p>

  <h4>10.10 Передача в функцию и возврат данных произвольного типа (331)</h4>

  <p>Если в функцию можно передать или вернуть указатель любого типа, то при объявлении функции необходимо использовать указатель типа void*. Чтобы получить значение в указателе неопределенного типа, нужно привести указатель к определенному типу.</p>
<pre>
void *p = NULL;
int x = 10;
p = &amp;x;
printf("%d\n", *((int *)p));
</pre>
  <p>Можно сохранить в указателе данные любого типа, но чтобы получить данные, нужно привести указатель к определенному типу.</p>

  <h4>10.11 Рекурсия (332)</h4>

  <p>Рекурсия - это возможность функции вызывать саму себя. При каждом вызове создается новый набор локальных переменных.</p>

  <h4>10.12 Встраиваемые функции (333)</h4>

  <p>Вызов функции, создание копии параметров, возврат значения требует дополнительных затрат времени. Если размер функции небольшой, то имеет смысл объявить такую функцию встраиваемой. В этом случае при компиляции содержимое функции будет вставлено в место вызова функции. Но при этом происходит увеличение размера исполняемого файла.</p>
  <p>Перед объявлением встраиваемой функции пишут ключевое слово inline или __inline. Ключевое слово __inline является лишь рекомендацией и может быть проигнорировано компилятором.</p>
  <code>static __inline int sum (int x, int y) {}</code>

  <p>Создать встраиваемую функцию можно также с помощью директивы #define.</p>
  <code>#define SUM(x, y) ( (x) + (y) )</code>
</article>


<!-- 11 Обработка ошибок (336) -->
<article class="article">
  <div class="anchor" id="p11"></div>
  <h3>11 Обработка ошибок (336)</h3>


  <h4>11.1 Типы ошибок (336)</h4>

  <p>Есть три типа ошибок в программе</p>

  <ol>
    <li>Синтаксические - ошибки в имени оператора, отсутствие скобки или точки с запятой и т.д. Компилятор находит такие ошибки, выводит сообщение об ошибке и программа не будет скомпилирована.</li>
    <li>Логические - ошибки в логике работы программы. Компилятор не находит такие ошибки, не предупреждает о них и скомпилирует программу. В результате программа будет работать, но выдавать неверный результат. Поиск логических ошибок очень сложный и долгий процесс.</li>
    <li>Ошибки времени выполнения - ошибки связанные с недопустимыми операциями, такими как, деление на ноль, выход за границы массивы, обращение к не своей памяти, ошибки обращения к файлам.</li>
  </ol>

  <h4>11.2 Предупреждающие сообщения при компиляции (337)</h4>

  <p>При компиляции можно указывать флаги. Флаг -Wall включает вывод предупреждений об ошибках. Флаг -Wconversion включает предупреждения о несоответствии типов.</p>

  <h4>11.3 Переменная errno и вывод сообщения об ошибке (338)</h4>

  <p>Отдельные функции из стандартной библиотеки при ошибке возвращают некоторое значение и присваивают переменной errno номер ошибки.</p>

  <p>Получить текстовое описание ошибки по ее коду позволяют функции strerror() и _wcserror().</p>
  <ol>
    <li>Функция <strong>char *strerror(errNum)</strong> возвращает текстовое описание ошибки с номером <strong>int errNum</strong></li>
    <li>Функция <strong>wchar_t *_wscerror(errNum)</strong> возвращает текстовое описание ошибки с номером <strong>int errNum</strong></li>
    <li>Функция <strong>errno_t *strerror_s(buf, buf_size, errNum)</strong> записывает текстовое описание ошибки с номером <strong>int errNum</strong> в переменную <strong>char *buf</strong> размером <strong>size_t buf_size</strong>.</li>
    <li>Функция <strong>errno_t *_wscerror_s(buf, buf_size, errNum)</strong> записывает текстовое описание ошибки с номером <strong>int errNum</strong> в переменную <strong>wchar_t *buf</strong> размером <strong>size_t buf_size</strong>.</li>
  </ol>

  <p>Получить описание последней ошибки позволяют функции _strerror() и __wcserror()</p>
  <ol>
    <li>Функция <strong>char *_strerror(errMsg)</strong> выводит сообщение <strong>const char *errMsg</strong> и после него описание последней ошибки</li>
    <li>Функция <strong>wchar_t *__wcserror(errMsg)</strong> выводит сообщение <strong>const wchar_t *errMsg</strong> и после него описание последней ошибки</li>
    <li>Функция <strong>errno_t _strerror_s(buf, buf_size, errMsg)</strong> запишет сообщение <strong>const char *errMsg</strong> и после него описание последней ошибки в переменную <strong>char *buf</strong> размером <strong>size_t buf_size</strong>.</li>
    <li>Функция <strong>errno_t __wcserror(errMsg)</strong> запишет сообщение <strong>const wchar_t *errMsg</strong> и после него описание последней ошибки в переменную <strong>wchar_t *buf</strong> размером <strong>size_t buf_size</strong>.</li>
    <li>Функция <strong>void perror(errMsg)</strong> выводит сообщение <strong>const char *errMsg</strong> в стандартный поток вывода</li>
    <li>Функция <strong>void _wperror(errMsg)</strong> выводит сообщение <strong>const wchar_t *errMsg</strong> в стандартный поток вывода</li>
  </ol>

  <h4>11.4 Способы поиска ошибок в программе (341)</h4>

  <p>Есть несколько рекомендаций для поиска ошибок, не прибегая к отладке</p>
  <ol>
    <li>Хорошее форматирование кода. Обратим внимание на отступы, на расположение открывающих и закрывающих фигурных скобок.</li>
    <li>Длина строки кода не более 80 символов, чтобы вся строка помещалась на один экран без использования горизонтальной полосы прокрутки.</li>
    <li>Если программа слишком большая, то ее следует разбить на функции, а функции поместить в отдельных файлах.</li>
    <li>Добавьте проверку всех данных, вводимых пользователем</li>
    <li>Используйте функцию printf() для вывода на печать промежуточных значений в программе.</li>
    <li>Определите макрос #define DEBUG, расставьте в программе кусочки кода с условной компиляцией. Если макрос DEBUG определен, то выполняйте printf() для вывода промежуточных значений. Удалите макрос, когда программу нужно компилировать в продакшн.</li>
  </ol>

  <h4>11.5 Отладка программы в редакторе Eclipse (345)</h4>

  <p>Отладчик gdb.exe позволяет запустить программу по шагам, при этом контроллируя значения переменных на каждом шаге. Чтобы программа остановилась на какой-либо строчке кода, нужно в начале этой строки поставить точку останова. Когда точки останова расставлены можно начинать отладку. Когда программа остановилась в точке останова и показала значения всех переменных, можно или выполнить программу до следующей точки останова, или выполнять программу по шагам, строчка за строчкой.</p>
  <p>Применение отладки - самый эффективный способ нахождения ошибок, не требующий вставки никаких инструкций вывода промежуточных значений в текст программы.</p>
</article>


<!-- 12 Чтение и запись файлов (351) -->
<article class="article">
  <div class="anchor" id="p12"></div>
  <h3>12 Чтение и запись файлов (351)</h3>

  <h4>12.1 Открытие и закрытие файла (351)</h4>

  <h4>12.2 Указание пути к файлу (354)</h4>

  <h4>12.3 Режимы открытия файла (356)</h4>

  <h4>12.4 Запись в файл (358)</h4>

  <h4>12.5 Чтение из файла (360)</h4>

  <h4>12.6 Чтение и запись двоичных файлов (363)</h4>

  <h4>12.7 Файлы произвольного доступа (365)</h4>

  <p>Записывать и считывать из файла можно не только с самого начала, но и с произвольной позиции.</p>

  <h4>12.8 Создание временных файлов (367)</h4>

  <h4>12.9 Перенаправление ввода-вывода (369)</h4>

  <p>Стандартные потоки можно перенаправить таким образом, чтобы данные записывались в файл или считывались из файла. Для этого есть три способа</p>
  <ol>
    <li>
      <h4>Из командной строки</h4>
      <p>Перенаправим поток stdin на ввод из файла file.txt</p>
      <code>test.exe &lt; file.txt</code>
      <p>Перенаправим поток stdout на вывод в файл file.txt. Если файл не существует, то будет создан, если существует, то будет перезаписан.</p>
      <code>test.exe > file.txt</code>
      <p>Чтобы дописать в конец файла</p>
      <code>test.exe >> file.txt</code>
      <p>Для перенаправления можно использовать дескриптор потока. Поток stdout имеет дескриптор 1, а поток stderr - дескриптор 2</p>
      <code>test.exe 1> out.txt 2> err.txt</code>
    </li>
    <li>
      <h4>Функции freopen() или _wfreopen()</h4>
    </li>
    <li>
      <h4>Функция _dup2()</h4>
    </li>
  </ol>

  <h4>12.10 Работа с буфером ввода и вывода (372)</h4>

  <p>Для ускорения работы производится буферизация записываемых данных. Информация из буфера записывается в файл полностью только при заполнении буфера или в момент закрытия файла. Сбросить буфер явным образом можно с помощью функции fflush().</p>
</article>


<!-- 13 Низкоуровневые потоки ввода и вывода (374) -->
<article class="article">
  <div class="anchor" id="p13"></div>
  <h3>13 Низкоуровневые потоки ввода и вывода (374)</h3>

  <p>Функции для выполнения низкоуровневых операций ввода-вывода не поддерживают буферизацию и позволяют читать и писать только байты.</p>

  <h4>13.1 Открытие и закрытие файла (374)</h4>

  <h4>13.2 Чтение из файла и запись в файл (377)</h4>

  <h4>13.3 Файлы произвольного доступа (380)</h4>

  <h4>13.4 Создание временных файлов (381)</h4>

  <p>Для создания временного файла нужно при открытии файла указать комбинацию флагов _O_CREAT | _O_TEMPORARY. Файл будет удален автоматически при закрытии файла или при выходе из программы. Для использования флагов нужно подключить библиотеку fcntl.h.</p>

  <h4>13.5 Дескрипторы потоков ввода-вывода (382)</h4>

  <h4>13.6 Преобразование низкоуровневого потока в обычный (383)</h4>

  <h4>13.7 Создание копии потока (384)</h4>

  <h4>13.8 Перенаправление потоков (384)</h4>
</article>


<!-- 14 Работа с файловой системой (386) -->
<article class="article">
  <div class="anchor" id="p14"></div>
  <h3>14 Работа с файловой системой (386)</h3>

  <p>Работа с файлами в языке Си зависит от операционной системы. Мы рассмотрим как переименовать, удалить файлы, создать, удалить каталоги в операционной системе Windows.</p>

  <h4>14.1 Преобразование пути к файлу или каталогу (387)</h4>

  <h4>14.2 Переименование, перемещение и удаление файла (390)</h4>

  <h4>14.3 Проверка прав доступа к файлу и каталогу (391)</h4>

  <h4>14.4 Изменение прав доступа к файлу (393)</h4>

  <h4>14.5 Делаем файл скрытым (394)</h4>

  <p>Для того чтобы в Windows сделать файл скрытым, нужно воспользоваться макросами GetFileAttributes() и SetFilleAttributes().</p>

  <h4>14.6 Получение информации о файле (395)</h4>

  <p>Получить размер файла, время создания, изменения, доступа и др. можно с помощью функций _stat(), _stat32(), _stat64(), _stati64(), _stat32i64(), _stat64i32()</p>

  <h4>14.7 Функции для работы с дисками (399)</h4>

  <h4>14.8 Функции для работы с каталогами (401)</h4>

  <h4>14.9 Перебор объектов, расположенных в каталоге (403)</h4>
</article>


<!-- 15 Потоки и процессы (407) -->
<article class="article">
  <div class="anchor" id="p15"></div>
  <h3>15 Потоки и процессы (407)</h3>

  <p>Потоки управления позволяют выполнять задачи параллельно. Потоки выполняются в рамках процесса и имеют общий доступ к его ресурсам, например к глобальным переменным. Помимо запуска задачи в отдельном потоке, можно запустить задачу в отдельном процессе, который будет выполняться параллельно или заменит текущий процесс.</p>

  <h4>15.1 Потоки в WinAPI (407)</h4>

  <p>В Windows доступны три способа создания потоков управления:</p>

  <ol>
    <li>С помощью функций WinAPI (библиотека windows.h)</li>
    <li>С помощью функций библиотеки process.h</li>
    <li>С помощью функций библиотеки pthread.h</li>
  </ol>

  <h4>15.1.1 Создание и завершение потока (407)</h4>

  <h4>15.1.2 Синхронизация потоков (412)</h4>

  <h4>15.2 Функции для работы с потоками, объявленные в файле process.h</h4>

  <p>Для создания потока вместо функции CreateThread() из WinAPI лучше использовать функцию _beginthreadex() из файла process.h. Такой поток можно завершить функцией _endthreadex().</p>

  <h4>Потоки POSIX (420)</h4>

  <p>Функции создания и управления потоками POSIX находятся в библиотеке pthread.h</p>

  <h4>15.3.1 Создание и завершение потока (420)</h4>

  <ol>
    <li>Функция pthread_create() создает поток в модели posix.</li>
    <li>Функция pthread_join() дожидается завершения работы потока.</li>
    <li>Функция pthread_exit() блокирует поток до завершения всех потоков.</li>
  </ol>

  <h4>15.3.2 Синхронизация потоков (423)</h4>

  <h4>15.4 Запуск процессов (426)</h4>

  <h4>15.5 Получение идентификатора процесса (429)</h4>

  <p>Функция _getpid() получает идентификатор текущего процесса.</p>
</article>


<!-- 16 Создание библиотек (430) -->
<article class="article">
  <div class="anchor" id="p16"></div>
  <h3>16 Создание библиотек (430)</h3>

  <p>Функции следует размещать в отдельных файлах и подключать эти файлы в основной программе директивой #include. В больших программах функции объединяют в библиотеки. Различают библиотеки статические и динамические. Статические библиотеки становятся частью программы, а динамические библиотеки подгружаются при запуске программы или во время ее выполнения.</p>

  <h4>16.1 Статические библиотеки (430)</h4>

  <p>Во время компиляции программы на первом этапе каждый файл с исходным кодом с расширением .c преобразуется в отдельный объектный файл с расширением .o. На этом этапе достигается ускорение компиляции, т.к. нужно компилировать только измененные файлы. На втором этапе объектные файлы собираются в один исполняемый файл с расширением .exe. На этом этапе вместо исполняемого файла, мы можем создать библиотеку - файл с расширением .lib.</p>

  <h4>16.1.1 Создание статической библиотеки из командной строки (16.1.1)</h4>

  <p>Создадим файл module1.h</p>
<pre>
#ifndef MODULE1_H_
#define MODULE1_H_

#ifndef __cplusplus
extern "C" {
#endif

int sum_int(int x, int y);

ifdef __cplusplus
}
#endif

#endif /* MODULE1_H_ */
</pre>

  <p>Создадим файл module1.c</p>
<pre>
#include "module1.h"

int sum_int(int x, int y) {
  return x + y;
}
</pre>

  <p>Создадим файл module2.h</p>
<pre>
#ifndef MODULE2_H_
#define MODULE2_H_

#ifndef __cplusplus
extern "C" {
#endif

double sum_double(double x, double y);

ifdef __cplusplus
}
#endif

#endif /* MODULE2_H_ */
</pre>

  <p>Создадим файл module2.c</p>
<pre>
#include "module2.h"

double sum_double(double x, double y) {
  return x + y;
}
</pre>

  <h4>16.1.2 Создание статической библиотеки в редакторе Eclipse (434)</h4>

  <h4>16.2 Динамические библиотеки (438)</h4>

  <p>Размер программы со статическими библиотеками больше размера программ с динамическими библиотеками. Статические библиотеки содержатся внутри программы, динамические библиотеки содержатся и подгружаются отдельно.</p>

  <h4>16.2.1 Создание динамической библиотеки из командной строки (438)</h4>

  <h4>16.2.2 Создание динамической библиотеки в редакторе Eclipse (434)</h4>

  <h4>16.2.3 Загрузка динамической библиотеки во время выполнения программы (443)</h4>

  <h4>16.2.4 Экспортируемые и внутренние функции (446)</h4>

  <h4>16.2.5 Функция DllMain() (446)</h4>
</article>


<!-- 17 Прочее (448) -->
<article class="article">
  <div class="anchor" id="p17"></div>
  <h3>17 Прочее (448)</h3>

  <h4>17.1 Регистрация функции, выполняемой при завершении программы (448)</h4>

  <p>Функции atexit() и _onexit() позволяют зарегистрировать функцию, которая будет выполняться при завершении программы. Внутри этой функции можно выполнить различные завершающие действия. Можно зарегистрировать несколько функций. В этом случае они будут вызываться в обратном порядке: вначале будет вызвана последняя зарегистрированная функция, а последней - самая первая зарегистрированная функция.</p>

  <h4>17.2 Выполнение системных команд (449)</h4>

  <p>Функции system() и _wsystem() позволяют вывполнить системную команду.</p>
  <p>Очистим консоль:</p>
  <code>system("cls");</code>
  <p>Зададим кодировку windows-1251 для консоли:</p>
  <code>_wsystem(L"chcp 1251");</code>

  <h4>17.3 Получение и изменение значений системных переменных (451)</h4>

  <p>Все системные переменные доступны через третий параметр функции main()</p>
<pre>
#include &lt;stdio.h&gt;

int main(int argc, char *argv[], char **penv) {

  printf("argc = %d\n", argc);

  for (int i = 0; i &lt; argc; i++) {
    printf("%s\n", argv[i]);
  }

  while (*penv != NULL) {
    printf("%s\n", *(penv++));
  }

}
</pre>

  <h4>17.4 Директивы препроцессора (454)</h4>

  <h4>17.5 Создание значка приложения (455)</h4>

  <p>По умолчанию для exe-файла используется стандартный значек. В Windows мы можем добавить собственный значек, внедрив его в exe-файл как ресурс.</p>

  <h4>Заключение (459)</h4>

  <p>Подробную информацию по компилятору GCC можно найти на сайтах:</p>
  <ol>
    <li><a href="https://www.mingw.org/">https://www.mingw.org/</a></li>
    <li><a href="https://gcc.gnu.org/">https://gcc.gnu.org/</a></li>
  </ol>

  <p>Оконные приложения можно создавать с помощью библиотеки GTK:</p>
  <ol>
    <li><a href="https://www.gtk.org/">https://www.gtk.org/</a></li>
  </ol>

  <p>Исходные коды программ из этой книги:</p>
  <ol>
    <li><a href="ftp://ftp.bhv.ru/9785977541169.zip">ftp://ftp.bhv.ru/9785977541169.zip</a></li>
  </ol>
</article>

