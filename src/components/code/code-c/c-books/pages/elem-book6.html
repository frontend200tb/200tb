<article class="article">
  <h1>1985 Керниган, Ритчи - Язык программирования Си. Задачи по языку. 279c</h1>
  <p>Конспект книги</p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
    <a href="#p1">Предисловие (10)</a>
    <br><a href="#p2">Глава 1. Введение (11)</a>
    <br><a href="#p3">Глава 2. Обзор языка (15)</a>
    <br><a href="#p4">Глава 3. Типы, операции и выражения (38)</a>
    <br><a href="#p5">Глава 4. Управление (53)</a>
    <br><a href="#p6">Глава 5. Функции и структура программы (64)</a>
    <br><a href="#p7">Глава 6. Ссылки и массивы (84)</a>
    <br><a href="#p8">Глава 7. Записи (108)</a>
    <br><a href="#p9">Глава 8. Ввод и вывод (129)</a>
    <br><a href="#p10">Глава 9. Взаимодействие с системой UNIX (142)</a>
    <br><a href="#p11">Справочное руководство по языку Си (157)</a>
    <br><a href="#p12">Задачи по языку Си (157)</a>
  </p>
</article>


<!-- Предисловие -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Предисловие (10)</h3>

  <p>Язык Си позволяет максимально использовать ресурсы ЭВМ и практически полностью отказаться от ассемблера.</p>
  <p>Книга Кернигана и Ритчи - авторское введение в язык. Язык в нем описывается так как они желали. Они учат не самому языку, а тому как надо на нем программировать.</p>
  <p>Первоначально язык Си был создан Ритчи для UNIX на ЭВМ PDP-11 и реализован в этой системе.</p>
</article>


<!-- Глава 1. Введение -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>Глава 1. Введение (11)</h3>

  <p>Язык Си работает с теми же объектами, с которыми работает и большинство вычислительных машин, а именно с символами, числами и адресами. В языке си нет операций ввода-вывода и встроенных методов доступа к файлам. Эти механизмы обеспечиваются вызовом функций.</p>
  <p>Язык Си был написан на основе языков BCPL и B. Но он на них не похож. В языках BCPL и B нет типов данных, единственными данными в них были машинные слова, обращение к другим объектам идет через специальные операции и функции.В Си есть основные типы данных из которых можно построить много производных типов.</p>
</article>


<!-- Глава 2. Обзор языка -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>Глава 2. Обзор языка (15)</h3>

  <p>Как можно быстрее начнем сами писать программы.</p>

  <h4>2.1 Начнем, пожалуй (15)</h4>

  <p>Единственный способ обучиться новому языку программирования - начать писать на нем программы.</p>
  <p>Напишем первую программу, которая выводит на экран hello, world.</p>
  <p>Первое препятствие - сначала надо где-то написать текст программы, потом его скомпилировать, запустить готовую программу и разобраться что у нас получилось.</p>
  <p>Будем использовать операционную систему <strong>Windows 10</strong>  и редактор кода <strong>VSCode</strong>.</p>
  <p>Создадим текстовый файл с расширением <strong>.c</strong>, назовем его, например, <strong>hello.c.</strong> Напишем в нем текст программы</p>

  <h4>Программа 1 (16)</h4>
  <p>Выводим на экран hello, world и переводим курсор на новую строку</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  printf("hello, world\n");

  return 0;
}
</pre>
  <code>hello, world!</code>

  <p>Откроем терминал и скомпилируем этот файл командой</p>
  <code>gcc hello.c</code>
  <p>Если нет ошибок и компиляция закончится успешно, то будет создан файл</p>
  <code>a.exe</code>
  <p>Запустим файл a.exe командой</p>
  <code>./a</code>
  <p>В консоли должен быть результат выполнения программы, выводится строчка</p>
  <code>hello, world</code>

  <p>Любая программа ня языке Си состоит из одной или более функций. Функциям можно давать любые имена, согласно правилам именования переменных и функций. Функция main() это особая функция. Она должна быть в каждой программе. С нее начинается выполнение программы.</p>

  <h4>Программа 2 (17)</h4>
  <p>Выводим на экран hello, world и переводим курсор на новую строку три раза вызвав функцию printf()</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  printf("hello, ");
  printf("world!");
  printf("\n");

  return 0;
}
</pre>
  <code>hello, world!</code>

  <h4>Программа 3 (17)</h4>
  <p>Если в функцию printf() включить '\s', где s это не символ управляющей последовательности, то получим предупреждение. Программа скомпилируется и выполнится как будто символа '\' не было</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  printf("\shello, world!\n");

  return 0;
}
</pre>
  <code>warning: unknown escape sequence: '\s'</code>
  <code>shello, world!</code>

  <h4>2.2 Переменные и арифметика (17)</h4>

  <h4>Программа 4 (18)</h4>
  <p>Программа печатает таблицу температур по Фаренгейту и  по Цельсию. Для перевода используется формула</p>
  <code>C = (5/9)(F-32)</code>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int lower, upper, step;
  float fahr, celsius;

  lower = 0;
  upper = 300;
  step = 20;
  fahr = lower;

  while (fahr &lt;= upper) {
    celsius = (5.0 / 9.0) * (fahr - 32.0);
    printf("%4.0f %6.1f\n", fahr, celsius);
    fahr = fahr + step;
  }

  return 0;
}
</pre>
  <p>Спецификатор %4.0f означает что дробное число при печати должно занимать минимум 4 символа (если цифр меньше то перед ними ставятся пробелы) и без цифр после десятичной точки</p>
  <p>Спецификатор %6.1f означает что дробное число при печати должно занимать минимум 6 символов (включая точку и цифры после нее, если цифр меньше то перед ними ставятся пробелы) и после десятичной точки доолжна быть одна цифра</p>

  <h4>2.3 Цикл for (20)</h4>

  <h4>Программа 5 (21)</h4>
  <p>Программа печатает таблицу температур по Фаренгейту и  по Цельсию, используя цикл for</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int fahr;

  for (fahr = 0; fahr &lt;= 300; fahr += 20) {
    printf("%4d %6.1f\n", fahr, (5.0 / 9.0) * (fahr - 32));
  }

  return 0;
}
</pre>

  <h4>Программа 6 (21)</h4>
  <p>Напечатаем температуры в обратном порядке от 300 до 0 градусов</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int fahr;

  for (fahr = 300; fahr >= 0; fahr -= 20) {
    printf("%4d %6.1f\n", fahr, (5.0 / 9.0) * (fahr - 32));
  }

  return 0;
}
</pre>

  <h4>2.4 Символические константы (21)</h4>

  <p>Плохо когда в программе встречаются загадочные числа вроде 300 или 20. Хорошо использовать для них конструкцию со словом #define в начале программы. Тогда можно определить символические константы. Препроцессор до выполнения компиляции заменит все символические константы на их значения. Так что полученная программа будет точно такое же, а вот читаемость программы на языке Си будет лучше.</p>

  <h4>Программа 7 (22)</h4>
  <p>Заменим цифры в программе символическими константами</p>
<pre>
#include &lt;stdio.h&gt;
#define LOWER 0
#define UPPER 300
#define STEP 20

int main() {
  int fahr;

  for (fahr = LOWER; fahr &lt;= UPPER; fahr += STEP) {
    printf("%4d %6.1f\n", fahr, (5.0 / 9.0) * (fahr - 32));
  }

  return 0;
}
</pre>

  <h4>2.5 Некоторые простые программы (22)</h4>

  <p>Чтение одного символа (обычно из терминала)</p>
  <code>c = getchar();</code>
  <p>Запись одного символа (обысно в терминал)</p>
  <code>putchar(c);</code>

  <h4>Программа 8 (23)</h4>
  <p>Копируем по одному символу со входа на выход после нажатия на клавишу ENTER. Если нужно остановать программу, надо нажать Ctrl+Z это константа EOF которая приведет к выходу из цикла while</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int c;

  c = getchar();
  while (c != EOF) {
    putchar(c);
    c = getchar();
  }

  return 0;
}
</pre>

  <h4>Программа 9 (23)</h4>
  <p>Программа может стать компактнее, если записать getchar() прямо условии цикла while. Здесь считывается один символ, присваивается переменной, проверяется на равенство символу EOF</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int c;

  while ((c = getchar()) != EOF) {
    putchar(c);
  }

  return 0;
}
</pre>

  <h4>Программа 10 (24)</h4>
  <p>Подсчитаем количество введенных символов в переменной типа int (включая пробелы и ENTER) пока не введем EOF</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int nc = 0;
  while (getchar() != EOF) {
    ++nc;
  }
  printf("count=%d\n", nc);

  return 0;
}
</pre>

  <h4>Программа 11 (24)</h4>
  <p>Подсчитаем количество введенных символов в переменной типа long (включая пробелы и ENTER) пока не введем EOF</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  long nc = 0;
  while (getchar() != EOF) {
    ++nc;
  }
  printf("count=%ld\n", nc);

  return 0;
}
</pre>

  <h4>Программа 12 (24)</h4>
  <p>Подсчитаем количество введенных символов в переменной типа double (включая пробелы и ENTER) пока не введем EOF</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  double nc = 0;
  while (getchar() != EOF) {
    ++nc;
  }
  printf("count=%.0f\n", nc);

  return 0;
}
</pre>

  <h4>Программа 13 (25)</h4>
  <p>Вместо цикла while напишем цикл for и всю работу цикл будет делать при проверке и повторной инициализации. Вместо пустого тела цикла необходимо поставить точку с запятой</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  double nc;
  for (nc = 0; getchar() != EOF; ++nc) ;
  printf("count=%.0f\n", nc);

  return 0;
}
</pre>

  <h4>Программа 14 (25)</h4>
  <p>Подсчитаем строки входного текста. Каждая строка заканчивается символом '\n'.</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int c, nl = 0;
  while ((c = getchar()) != EOF) {
    if (c == '\n') {
      ++nl;
    }
  };
    printf("count line = %d\n", nl);

  return 0;
}
</pre>

  <h4>Программа 15 (26)</h4>
  <p>Подсчитаем пробелы, символы табуляции и новые строки</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int c,
  n_ws = 0,
  n_tab = 0,
  n_l = 0;

  while ((c = getchar()) != EOF) {
    if (c == ' ') {
      ++n_ws;
    } else if (c == '\t') {
      ++n_tab;
    } else if (c == '\n') {
      ++n_l;
    }
 };
    printf("count whitespace = %d\n", n_ws);
    printf("count tab = %d\n", n_tab);
    printf("count new line = %d\n", n_l);

  return 0;
}
</pre>

  <h4>Программа 16 (26)</h4>
  <p>Напишем программу копирования ввода на вывод с заменой одного или более пробелов на один пробел</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int c, w = ' ', flag = 0;

  while ((c = getchar()) != EOF) {
    if (c == ' ') {
      flag = 1;
    } else {
      if (flag == 1) {
        putchar(w);
        flag = 0;
      }
      putchar(c);
    }
  };

  return 0;
}
</pre>

  <h4>Программа 17 (26)</h4>
  <p>Напишем программу копирования ввода на вывод с заменой каждого символа табуляции на символы >>>, а каждого символа возврата на один шаг на символ &lt;</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char c;
  char t = '\t', tt = '>';
  char b = '\b', bb = '&lt;';

  while ((c = getchar()) != EOF) {
    if (c == t) {
      putchar(tt);
      putchar(tt);
      putchar(tt);
    } else if (c == b) {
      putchar(bb);
    } else {
      putchar(c);
    }
  };

  return 0;
}
</pre>

  <h4>Программа 18 (26)</h4>
  <p>Подсчитаем строки, слова и символы. Слово это последовательность символов, не содержащая пробелов, табуляции и символа перехода на новую строку. Как только программа встречает первый символ, она начинает считать</p>
<pre>
#include &lt;stdio.h&gt;

#define YES 1
#define NO  0

int main() {
  int c, n_line, n_word, n_char, inword;
  inword = NO;
  n_line = n_word = n_char = 0;

  while ((c = getchar()) != EOF) {
    ++n_char;
    if (c == '\n') {
      ++n_line;
    }
    if (c == ' ' || c == '\t' || c == '\n') {
      inword = NO;
    } else if (inword == NO) {
      inword = YES;
      ++n_word;
    }
  }
  printf("count line = %d\n", n_line);
  printf("count word = %d\n", n_word);
  printf("count char = %d\n", n_char);

  return 0;
}
</pre>

  <h4>Программа 19 (28)</h4>
  <p>Напечатаем вводимые слова по одному в строке</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int c, w = 0;

  while ((c = getchar()) != EOF) {
    if (c == ' ' || c == '\t' || c == '\n') {
      if (w == 0) {
        putchar('\n');
      }
      w++;
    } else {
      putchar(c);
      w = 0;
    }
  }

  return 0;
}
</pre>

  <h4>Программа 20 (28)</h4>
  <p>Напечатаем вводимые слова по одному в строке. Слова должны начинаться с буквы</p>
<pre>
#include &lt;stdio.h&gt;

#define YES 1
#define NO  0

int main() {
  int c;
  int n_word = 0;
  int inword = NO;

  while ((c = getchar()) != EOF) {
    if (c == ' ' || c == '\t' || c == '\n') {
      inword = NO;
    } else if (inword == NO && (
              (c > 64 && c &lt; 91) ||
              (c > 96 && c &lt; 123))) {
      inword = YES;
      ++n_word;
    } else {
      inword = YES;
    }
  }
  printf("count word = %d\n", n_word);

  return 0;
}
</pre>

  <h4>2.6 Массивы (28)</h4>

  <h4>Программа 21 (28)</h4>
  <p>Посчитаем вхождения каждой из цифр, невидимых (пустых) симовол (пробелов, табуляций, перехода на новую строку) и других символов</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int c, i;
  int nwhite = 0, nother = 0;
  int ndigit[10];

  for (i = 0; i &lt; 10; i++) {
    ndigit[i] = 0;
  }

  while ((c = getchar()) != EOF) {
    if (c >= '0' && c &lt;= '9') {
      ndigit[c - '0']++;
    } else if (c == ' ' || c == '\t' || c == '\n') {
      nwhite++;
    } else {
      nother++;
    }
  }
  for (i = 0; i &lt; 10; i++) {
    printf("%d %d\n", i, ndigit[i]);
  }
  printf("white space = %d\n", nwhite);
  printf("other = %d\n", nother);

  return 0;
}
</pre>

  <h4>Программа 22 (29)</h4>
  <p>Напечатаем гистограмму длин читаемых слов. Гистограмму расположим горизонтально</p>
<pre>
#include &lt;stdio.h&gt;

#define YES 1
#define NO  0

int main() {
  int c;
  int n_word = 0;
  int inword = NO;
  int inother = NO;
  int len[256] = {0};

  while ((c = getchar()) != EOF) {
    // если пробельный символ
    if (c == ' ' || c == '\t' || c == '\n') {
      inword = NO;
      inother = NO;
    // если это первая буква после пробельного символа
    } else if (inword == NO && inother == NO && (
              (c > 64 && c &lt; 91) ||
              (c > 96 && c &lt; 123))) {
      inword = YES;    // мы внутри слова
      ++n_word;        // увеличиваем число слов
      len[n_word] = 1; // в слове одна буква
    // если не пробельный символ и мы внутри слова
    } else if (inword == YES) {
        len[n_word]++;
    } else {
      inother = YES;
    }
  }

  for (int i = 1; i &lt;= n_word; i++) {
    for (int j = 1; j &lt;= len[i]; j++) {
      printf("#");
    }
    printf("\n");
  }

  return 0;
}
</pre>

  <h4>2.7 Функции (29)</h4>

  <h4>Программа 23 (30)</h4>
  <p>Напишем функцию power для возведения целого числа в целую положительную степень. В программе вычисли 2⁵ и 2¹⁰</p>
<pre>
#include &lt;stdio.h&gt;

int power(int, int);

int main() {
  printf("2**5=%d\n", power(2,5));
  printf("2**10=%d\n", power(2,10));

  return 0;
}

int power(int m, int n) {
  int i, p = 1;
  for (i = 0; i &lt; n; i++) {
    p *= m;
  }

  return p;
}
</pre>
  <code>2**5=32</code>
  <code>2**10=1024</code>

  <h4>Программа 24 (30)</h4>
  <p>Напишем программу, которая принимает два целых числа и возводит первое число в степень равную второму числу</p>
<pre>
#include &lt;stdio.h&gt;

int power(int, int);

int main() {
  int a, b;
  printf("Enter integer ");
  scanf("%d", &a);
  printf("Enter power ");
  scanf("%d", &b);
  printf("%d**%d = %d\n", a, b, power(a, b));

  return 0;
}

int power(int m, int n) {
  int i, p = 1;
  for (i = 0; i &lt; n; i++) {
    p *= m;
  }

  return p;
}
</pre>

  <h4>Программа 25 (31)</h4>
  <p>Напишем программу, которая принимает строку и преобразует буквы к нижнему регистру.</p>
<pre>
#include &lt;stdio.h&gt;

char lower(char);

int main() {
  int ch;
  while ((ch = getchar()) != '\n') {
    printf("%c", lower(ch));
  }

  return 0;
}

char lower(char c) {
  char res;
  if (c >= 65 && c &lt;= 91) {
    res = c + 32;
  } else {
    res = c;
  }

  return res;
}
</pre>

  <h4>2.8 Аргументы - вызов по значению (31)</h4>

  <p>Все аргументы функции передаются "по-значению". Внутри функции создаются новые переменные со значениями, переданными в параметрах. В основной программе передаваемые аргументы остаются неизменными, внутри функции меняется только их копия.</p>

  <h4>Программа 26 (31)</h4>
  <p>Функция power() работает с копиями переменных.</p>
<pre>
#include &lt;stdio.h&gt;

int power(int, int);

int main() {
  printf("2**5=%d\n", power(2,5));
  printf("2**10=%d\n", power(2,10));

  return 0;
}

int power(int m, int n) {
  int p;
  for (p = 1; n > 0; --n) {
    p *= m;
  }

  return p;
}
</pre>

  <p>Чтобы в программе поменялось значение переменной, надо в функцию передать ее адрес. и тогда адрес не изменится, так как внутри функции будет действовать копия адреса, а переменную по этому адресу можно поменять.</p>
  <p>Если в качестве аргумента берется имя массива, то передаваемое функции значение фактически есть адрес начала массива. Никакое копирование элементов массива не производится. Обращаясь по индексу, функция может выбирать или изменять любые элементы массива.</p>

  <h4>2.9 Массивы символов (32)</h4>

  <h4>Программа 27 (32)</h4>
  <p>Напишем программу, которая читает несколько строк и затем печатает самую длинную из них. Программа читает строки. В цикле, пока есть еще строки, сравнивает строку с самой длинной, выбирает самую длинную и запоминает строку и ее длину.</p>
<pre>
#include &lt;stdio.h&gt;
#define MAXLINE 1000

int getline(char [], int);
void copy(char [], char []);

int main() {
  int len;
  int max;
  char line[MAXLINE];
  char save[MAXLINE];
  max = 0;
  while((len = getline(line, MAXLINE)) > 0) {
    if (len > max) {
      max = len;
      copy(line, save);
    }
  }
  if (max > 0) {
    printf("%s", save);
  }

  return 0;
}

int getline(char s[], int lim) {
    int c, i;
    for (i=0; i &lt; lim - 1 && (c=getchar())!=EOF && c!='\n'; i++){
      s[i] = c;
    }
    if (c == '\n') {
      s[i] = c;
      i++;
    }
    s[i] = '\0';
    return i;
  }

void copy(char s1[], char s2[]) {
  int i = 0;
  while ((s2[i] = s1[i]) != '\0') {
    i++;
  }
}
</pre>

  <h4>Программа 28 (34)</h4>
  <p>Напишем программу, убирающую начальные пробелы и символы табуляции из каждой входно стрки и исключающую пустые строки.</p>

  <h4>Программа 29 (34)</h4>
  <p>Напишем программу, переставляющую символы строки в обратном порядке.</p>

  <h4>2.10 Области действия. Внешние переменные (34)</h4>

  <p>Внутренние переменные функции main() это локальные переменные, поскольку они объявлены и действуют внутри нее. Никакие другие функции не имеют к ним прямого доступа. Это же справедливо для переменных других функций. Любая локальная переменная начинает существовать при входе в функцию и уничтожается при выходе из функции. Такие переменные еще можно назвать автоматическими, потому что они сами независимо от нас создаются и уничтожаются автоматически.</p>
  <p>Внешние переменные, объявленные вне функций, это глобальные переменные. К ним можно обращаться из любой функции. Их можно использовать для связи между функциями. Эти переменные существуют всегда, а не возникают и исчезают при входе и выходе из функции.</p>
  <p>Чтобы в функции использовать глобальную переменную, ее нужно пометить как extern.</p>

  <h4>Программа 30 (35)</h4>
  <p>Перепишем программу для самой большой строки, сделав переменные line, save и max внешними.</p>
<pre>
#include &lt;stdio.h&gt;
#define MAXLINE 1000

char line[MAXLINE];
char save[MAXLINE];
int max;

int getline();
void copy();

int main() {
  int len;
  extern int max;
  extern char save[];
  max = 0;
  while((len = getline()) > 0) {
    if (len > max) {
      max = len;
      copy();
    }
  }
  if (max > 0) {
    printf("%s", save);
  }

  return 0;
}

int getline() {
    int c, i;
    extern char line[];
    for (i=0; i &lt; MAXLINE - 1 && (c=getchar())!=EOF && c!='\n'; i++){
      line[i] = c;
    }
    if (c == '\n') {
      line[i] = c;
      i++;
    }
    line[i] = '\0';
    return i;
  }

void copy() {
  int i = 0;
  extern char line[], save[];
  while ((save[i] = line[i]) != '\0') {
    i++;
  }
}
</pre>
  <p>Определение глобальных переменных приводит к выделению памяти, согласно их типу. Прежде чем функция сможет использовать глобальную переменную, нужно сделать имя этой переменной известным для функции. Один из спопобов сделать это - включить в функцию описание внешней переменной с помощью слова extern.</p>
  <p>При описании переменной с помощью слова extern, память для нее не выделяется.</p>

  <h4>2.11 Заключение (36)</h4>
</article>


<!-- Глава 3. Типы, операции и выражения -->
<article class="article">
  <div class="anchor" id="p4"></div>
  <h3>Глава 3. Типы, операции и выражения (38)</h3>

  <h4>3.1 Имена переменных (38)</h4>

  <p>Имена могут состоять из букв, цифр, символа подчеркивания. Первым символом в имени не может быть цифра.</p>

  <h4>3.2 Типы данных и размеры (38)</h4>

  <p>Основные типы данных в Си char, int, float, double. Несколько "уточнителей" для типа int: short, long, unsigned. Точность целых чисел зависит от конкретной машины.</p>

  <h4>3.3 Константы (39)</h4>

  <p>Целочисленная константа, например 123</p>
  <p>Вещественная константа, например 123.01</p>
  <p>Длинная константа, например 123L</p>
  <p>Символьная константа это единственный символ заключенный в одиночные кавычки, например 'x'.</p>
  <p>Константное выражение - это выражение из одних констант. Такие выражения вычисляются во время трансляции, а не во время выполнения программы, поэтому их можно использовать везде, где может стоять константа.</p>
<pre>
#define MAXLINE 1000
char line[MAXLINE + 1]
hours = 60 * 60 * seconds;
</pre>
  <p>Строковая константа это последовательность нуля или более символов, заключенная в двойные кавычки, например "string".</p>
  <p>Строка представляет собой массив с элементами из одного символа. В конце каждой такой строки транслятор автоматически помещает нулевой символ '\0'. Размер строки не ограничен, но для определения ее длины строку нужно полностью просмотреть.</p>
  <p>Напишем функцию strlen() определяющую длину строки, включая последний символ '\0'.</p>
<pre>
strlen(char s[]) {
  int i;
  i = 0;
  while (s[i] != '\0') {
    i++;
  }
  return i;
}
</pre>
  <p>Символьная константа и строка из одного символа это не одно и то же. 'x' != "x". 'x' это символ для буквы x. "x" это строка, содержащая один символ и символ "\0".</p>

  <h4>3.4 Описания (40)</h4>

  <p>Перед использованием переменная должна быть объявлена. При объявлении можно задавать начальные значения.</p>

  <h4>3.5 Арифметические операции (41)</h4>

  <p>Операцию % остаток от деления нельзя использовать для типа float и double.</p>
  <p>Год будет високосным, если он  делится на 4, но не делится на 100, однако если делится на 400 то он тоже високосный.</p>
<pre>
if (year % 4 == 0 && year % 100 != 0 || year % 400 == 0) {
  printf("високосный");
} else {
  printf("не високосный");
}
</pre>

  <h4>3.6 Отношения и логические операции (42)</h4>

  <p>Цикл из функции getline, из одной из прошлых программ</p>
<pre>
for (i = 0; i &lt; lim - 1 && (c = getchar()) != '\n' && c != EOF; i++) {
  s[i] = c;
}
</pre>
  <p>Прежде чем считывать новый символ, нужно проверить, есть ли в массиве s для него место, поэтому в начале необходимо выполнить проверку i &lt; lim - 1. Если эта проверка даст отрицательный результат, то getchar выполнять уже не нужно. Также нет смысла сравнивать символ с EOF, пока не выполнится getchar.</p>

  <h4>3.7 Преобразование типов (43)</h4>

  <p>Напишем функцию atoi() для преобразования строки, состоящей из цифр в число.</p>
<pre>
atoi(char s[]) {
  int i, n;
  n = 0;
  for (i = 0; s[i] >= '0' && s[i] &lt;= '9; i++') {
    n =  10 * n + s[i] - '0';
  }
  return n;
}
</pre>

  <p>Напишем функцию lower() для преобразования заглавной буквы в строчную</p>
<pre>
lower(char c) {
  if (c >= 'A' && c &lt;= 'Z') {
    return (c + 'a' - 'A');
  } else {
    return c;
  }
}
</pre>
  <p>Автоматическое преобразование типов происходит в трех случаях</p>
  <ol>
    <li>Если в одном выражении операнды разных типов, то они преобразуются к одному типу.</li>
    <li>При присваивании значение правой части преобразуется к типу левой части.</li>
    <li>При передачи аргументов в функцию их типы преобразуются к типам параметров функции</li>
  </ol>
  <p>Явное преобразование называется приведением</p>
  <code>(имя типа) выражение</code>

  <h4>3.8 Операции увеличения и уменьшения (45)</h4>

  <p>Операции инкремента и декремента можно применять только к переменным и нельзя применять к выражениям. Например (i + i)++ выполнить нельзя.</p>

  <p>Напишем функцию squeeze() выбрасывающую все вхождения символа из строки.</p>
<pre>
squeeze(char s[], int c) {
  int i, j;
  for (i = j = 0; s[i] != '\0'; i++) {
    if (s[i] != c) {
      s[j++] = s[i];
    }
  }
  s[j] = '\0';
}
</pre>
  <p>Если встречается символ, отличный от c, он копируется в текущую j-ю позицию, а затем j увеличивается для следующего символа.</p>

  <p>Напишем функцию strcat() присоединяющую строку в конец другой строки. Мы должны позаботиться о том чтобы с строке хватило места для присоединения другой строки.</p>
<pre>
strcat(char s[], char t[]) {
  int i, j;
  i = j = 0;
  while (s[i] != '\0') {
    i++;
  }
  while ((s[i++] = t[j++]) != '\0') ; // пустой оператор
}
</pre>

  <h4>3.9 Поразрядные логическин операции (47)</h4>

  <p>Порязрядные операции нельзя применить к float и double.</p>

  <p>Напишем функцию getbits() дающую n-разряднов из числа x, начиная с позиции p.</p>
<pre>
getbits(unsigned x, unsigned p, unsigned n) {
  return (x >> (p + 1 - n)) & ~(~0 &lt;&lt; n);
}
</pre>

  <h4>3.10 Операции присваивания и выражения (48)</h4>

  <p>Напишем функцию bitcount() считающую число 1-х разрядов в числе</p>
<pre>
bitcount(unsigned n) {
  int b;
  for (b = 0; n != 0; n >>= 1) {
    if (n & 01) {
      b++;
    }
  }
  return b;
}
</pre>

  <h4>3.11 Условные выражения (50)</h4>

  <p>Найдем максимум из двух чисел</p>
  <code>if (a>b) max=a; else max=b;</code>
  <code>max = (a>b) & a : b;</code>

  <p>Цикл печати N элементов массива по 10 чисел в строке. Колонка от колонки отделяется пробелом, а каждая строка заканчивается одним переходом на новую строку.</p>
<pre>
for (i = 0; i &lt; N; i++) {
  printf("%6d%c", a[i], (i%10 == 9 || i == N-1) & '\n' : ' ');
}
</pre>

  <h4>3.12 Приоритеты и порядок вычислений (50)</h4>

  <p>Обращение к функциям, вложенные операторы присваивания, операции инкремента, декремента обладают побочным эффектом, связанным с порядком обращения к переменным.</p>
</article>


<!-- Глава 4 Управление -->
<article class="article">
  <div class="anchor" id="p5"></div>
  <h3>Глава 4 Управление (53)</h3>

  <h4>4.1 Операторы и блоки (53)</h4>

  <p>Любое выражение становится оператором, если за ним идет точка с запятой. В языке Си точка с запятой заканчивает оператор. Если операторы группируются в блок, окруженный фигурными скобками, то после закрывающей фигурной скобки точка с запятой не ставится.</p>

  <h4>4.2 if - else (53)</h4>

  <p>Оператор if-else применяется для принятия решения. Часть else может присутствовать, а может и не присутствовать. Если часть с else пропускается во вложенных условных операторах, то возникает неясность в толковании. Компилятор сопоставляет else с ближайшим if, не имеющим своего else. Если это не то что вам нужно, то используйте фигурные скобки перед оператором else чтобы показать к какому if он относится.</p>

  <h4>4.3 else if (55)</h4>

  <p>Конструкция else if используется когда нужно выбирать из многих решений.</p>

  <h4>Программа 34 (55)</h4>
  <p>Функция двоичного поиска, определяющая встречается ли значение x  в упорядоченном массиве v.</p>
<pre>
binary(int x, int v[], int n) {
  int low, high, mid;
  low = 0;
  high = n-1;
  while (low &lt;= high) {
    mid = (low + high) / 2;
    if (x &lt; v[mid]) high = mid - 1;
    else if (x > v[mid]) low = mid + 1;
    else return (mid);
  }
  return (-1);
}
</pre>

  <h4>4.4 Переключатель (56)</h4>

  <p>Переключатель (оператор switch) предназначен для принятия одного из многих решений. В нем проверяется совпадение значения выражения с одной из нескольких констант и выполняется соответствующая ветвь.</p>

  <p>Напишем программу посчета цифр и пустых символов</p>
<pre>
main() {
  int c, i, nwhite, nother, ndigit[10];
  nwhite = nother = 0;

  for (i = 0; i &lt; 10; i++) {
    ndigit[i] = 0;
  }

  while ((c = getchar()) != EOF) {
    switch(c) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        ndigit[c-'0']++;
        break;
      case ' ':
      case '\n':
      case '\t':
        nwhite++;
        break;
      default:
        nother++;
        break;
    }
  }

  printf("digits = ");
  for (i = 0; i &lt; 10; i++) {
    printf("%d", ndigit[i]);
  }
  printf("\nwhite space = %d, other = %d\n", nwhite, nother);
}
</pre>

  <h4>4.5 Циклы while и for (57)</h4>

  <p>Напишем функцию atoi() преобразующую строку в число. Эта версия работает с путс=ыми символами в начале и допускает знаки + или -.</p>
<pre>
atoi(char s[]) {
  int i, n, sign;

  for (i = 0; s[i] == ' ' || s[i] == '\n' || s[i] == '\t'; i++) ;

  sign = 1;
  if (s[i] == '+' || s[i] == '-') {
    sign = (s[i++] == '+') ? 1 : -1;
  }

  for (n = 0; s[i] >= '0' && s[i] &lt;= '9'; i++) {
    n = 10 * n + s[i] - '0';
  }

  return sign * n;
}
</pre>

  <p>Напишем функцию shell(), которая упорядочивает массив целых чисел. На ранних этапах сравниваются элементы, расположенные далеко друг от друга, а не соседние. Поэтому на поздних этапах работы становится меньше. Интервал между сравниваемыми элементами постепенно уменьшается до 1, когда сортировка сводится к обычным перестановкам соседних элементов.</p>
<pre>
shell(int v[], int n) {
  int gap, i, j, temp;

  for (gap = n/2; gap > 0; gap /=2) {
    for (i = gap; i &lt; n; i++) {
      for (j = i-gap; j >= 0 && v[j] > v[j+gap]; j-=gap) {
        temp = v[j];
        v[j] = v[j+gap];
        v[j+gap] = temp;
      }
    }
  }
}
</pre>

  <p>Напишем функцию reverse() - поворот строки на месте</p>
<pre>
reverse(char s[]) {
  int c, i, j;
  for (i = 0, j = strlen(s) - 1; i &lt; j; i++, j--) {
    c = s[i];
    s[i] = s[j];
    s[j] = c;
  }
}
</pre>

  <h4>4.6 Цмклы do-while (60)</h4>

  <p>Напишем функцию itoa() - перевод числа в символы строки</p>
<pre>
itoa(char s[], int n) {
  int i, sign;
  if ((sign = n) &lt; 0) {
    n = -n;
  }
  i = 0;
  do {
    s[i++] = n % 10 + '0';
  } while ((n /= 10) > 0);
  if (sign &lt; 0) {
    s[i++] = '-';
  }
  s[i] = '\0';
  reverse(s);
}
</pre>

  <p>Конструкция do-while здесь нужна потому что в массиве должен быть хотя бы один символ.</p>

  <h4>4.7 Break (разрыв) (61)</h4>

  <p>Оператор break обеспечивает выход из таких конструкций как while, dor, do-while и switch.</p>

  <p>Напишем программу, которая выбрасывает лишние символы пробела и табуляции из конца каждой входной строки. Оператор break используется для окончания цикла при обнаружении самого правого символа, отличного от пробела или табуляции.</p>
<pre>
#define MAXLINE 1000

main() {
  int n;
  char line[MAXLINE];

  while ((n = getline(line, MAXLINE)) > 0) {
    while (iin >= 0) {
      if (line[n] != ' ' && line[n] != '\t' && line[n] != '\n') {
        break;
      }
    }
    line[n+1] = '\0';
    printf("s\n", line);
  }
}
</pre>
  <p>Программа getline выдает размер строки. Внутренний цикл while начинается с последнего символа в line и идет просмотр строки в обратном направлении в поисках первого символа, который не есть пробел или табуляция.</p>

  <h4>4.8 Continue (продолжение) (62)</h4>

  <p>Оператор continue переходит к началу следующей итерации в конструкциях while, for, do-while.</p>
  <p>Напечатаем положительные числа, пропуская отрицательные в цикле.</p>
<pre>
for (i = 0; i &lt; N; i++) {
  if (a[i] &lt; 0) {
    continue;
  }
  printf("%d ", a[i]);
}
</pre>

  <h4>4.9 Переходы и метки (62)</h4>

  <p>Переходы и метки это плохой стиль программирования. Их на практике не используют. Но это простой способ выйти из внутреннего цикла с большим уровнем вложенности.</p>
  <p>Оператор перехода goto. Метку можно поставить перед любым оператором в той же функции, где находится оператор перехода на нее.</p>
</article>


<!-- Глава 5. Функции и структура программы -->
<article class="article">
  <div class="anchor" id="p6"></div>
  <h3>Глава 5. Функции и структура программы (64)</h3>

  <p>Программа может находиться в одном или нескольких файлах. В свои программы можно добавлять функции из библиотек.</p>

  <h4>5.1 Основы (64)</h4>

  <p>Если программу можно разбить на несколько частей, то лучше каждую часть вынести в отдельную функцию. С небольшими частями легче иметь дело, чем с одной большой программой. Кроме того, небольшие функции могут оказаться полезными и в других программах.</p>

  <p>Напише еще один вариант функции getline() для поиска всех строчек, содержащих заданный шаблон.</p>
<pre>
#define MAXLINE 1000

main() {
  char line[MAXLINE];
  while (getline(line, MAXLINE) > 0) {
    if (index(line, "the") >= 0) {
      printf("%s", line);
    }
  }
}

// записать строчку в s, вернуть длину
getline(char s[], int lim) {
  int c, i;
  i = 0;
  while (--lim > 0 && (c = getchar()) != EOF && c !='\n') {
    s[i++] c;
  }
  if (c == '\n') {
    s[i++] = c;
  }
  s[i] = '\0';
  return i;
}

// выдать начало t в c
index(char s[], char t[]) {
  int i, j, k;
  for (i = 0; s[i] != '\0'; i++) {
    for (j=i, k=0; t[k] != '\0' && s[j] == t[k]; j++, k++) ;
    if (t(k) == '0') {
      return i;
    }
  }
}
</pre>

  <p>Во входном файле функции идут в любом порядке, а программа может быть разделена на много файлов. Функцию разделять на несколько файлов нельзя. Передавать значение из функции надо через оператор return.</p>
  <p>Предположим есть три функции в трех разных файлах main.c, getline.c, index.c. Запустим команду</p>
  <code>gcc main.c getline.c, index.c</code>
  <p>Эта команда транслирует эти три файла и создает объектные файлы main.o, getline.o, index.o и загружает их все в исполняемый файл a.exe. Если в одном файле встретилась ошибка, то его можно отредактировать и оттедльно затем транслировать.</p>

  <h4>5.2 Функции, выдающие не целые значения (67)</h4>

  <p>Если перед функцией не стоит тип возвращаемого значения, то по умолчанию функция возвращает целое число int.</p>

  <p>Напишем функцию atof() преобразующую строку в число с плавающей точкой двойной точности.</p>
<pre>
double atof(char s[]) {
  double val, power;
  int i, sign;

  // пропуск пустых символов
  for (i = 0; s[i] == ' ' || s[i] == '\n' || s[i] == '\t'; i++) ;

  // знак числа
  sign = 1;
  if (s[i] == '+' || s[i] == '-') {
    sign = (s[i++] == '+') ? 1 : -1;
  }

  for (val = 0; s[i] >= '0' && s[i] &lt;= '9'; i++) {
    val = 10 * val + s[i] - '0';
  }
  if (s[i] == '.') {
    i++;
  }
  for (power = 1; s[i] >= '0' && s[i] &lt;= '9'; i++) {
    val = 10 * val + s[i] - '0';
    power *= 10;
  }

  return (sign * val / power);
}
</pre>

  <p>Напишем программу, которая считывает по одному числу на строку, возможно со знаком, складывает их все и печатает после каждого ввода сумму.</p>
<pre>
#define MAXLINE 100

// простейший калькулятор
main() {
  double sum, atof();
  char line[MAXLINE];
  sum = 0;

  while (getline(line, MAXLINE) > 0) {
    printf("\t%.2f\n", sum += atof(line));
  }
}
</pre>

  <p>Напишем функцию atoi() преобразующую строку в целое число. Внутри функции будем использовать готовую функцию atof() преобразующую строку в тип double. Поскольку функция atoi() имеет тип возвращаемого значения int, то ее результат автоматически будет приводиться к типу int.</p>
<pre>
int atoi(char s[]) {
  double atof();
  return atof(s);
}
</pre>

  <h4>5.3 Дополнительные сведения об аргументах (69)</h4>

  <p>Аргументы функции передаются по значению. При каждом вызове функция получает свою собственную, временную копию каждого аргумента. Функция не может изменять оригинальный аргумент в вызвавшей ее программе. Внутри функции каждый аргумент становится обычной локальной переменной.</p>
  <p>Если функции передать имя массива, то передается адрес на начало массива, сами элементы не копируются. Функция может обращаться к оригинальным элементам, используя адрес на начало и сдвиг относительно этого адреса. Массив передается по ссылке, поэтому функция может воздействовать на элементы массива в основной программе.</p>
  <p>Нет способа определить число элементов в массиве, если в функцию передается только его имя.</p>

  <h4>5.4 Внешние переменные (69)</h4>

  <p>Внешние переменные определены вне любой функции и доступны для многих функций. Все функции являются внешними, так как язык Си не позволяет определить функции внутри других функций.</p>
  <p>Все внешни переменные являются так же и глобальлными. Но можно определить внешнюю переменную или функцию, чтобы она не была глобально доступной и к ней можно было бы обращаться только из одного единственного файла.</p>
  <p>Внешние переменные можно использовать для передачи аргументов функции и для получения от них результата.</p>

  <p>Напишем программу калькулятор. Программа будет допускать операции +, -, *, / и = для печати ответа. Для реализации будем использовать обратную польскую нотацию, а не традиционную инфиксную. При такой нотации каждая операция идет следом за своими операндами, например польская запись</p>
  <code>1 2 - 4 5 + * =</code>
  <p>означает обычную запись</p>
  <code>(1 - 2) * (4 + 5) =</code>
  <p>Реализация очень простая. Строка с записью разбирается посимольно. Символы и числа отделены друг от друга пробелами. Если пришел операнд, то он помещается в стек. Если пришла операция, из стека выбирается нужное число операндов (для бинарной операции - два), к ним применяется операция и результат вновь опускается в стек.</p>
  <p>В нашем примере числа 1 и 2 помещаются в стек, затем к ним применяется операция минус и в стек помещается число -1. Следом в стек помещаются числа 4 и 5, затем к ним применяется операция плюс и в стек помещается число 9. В стеке остаются -1 и 9. Затем к ним применяется операция умножение и в стек помещается -9. Операция = печатает верхний элемент стека, не убирая его.</p>
  <p>Структура программы</p>
<pre>
while (следующая операция или операнд это не конец файла) {
  if (число) {
    поместить число в стек
  } else if (операция) {
    достать из стека два числа
    сделать операцию
    поместить в стек результат
  } else {
    ошибка
  }
}
</pre>

  <p>При конструировании программы надо решить где находится стек. Стек и связанная с ним информация будут внешними переменными, доступными для функций push() и pop(), но не доступными для функции main(). Функции main() ничего не нужно знать о стеке, она должна лишь пользоваться функциями push() и pop().</p>

  <h4>Программа калькулятор для польской записи (72)</h4>
<pre>
#define MAXOP      20
#define NUMBER    '0'
#define TOOBIG    '9'

main() {
  int type;
  char s[MAXOP];
  double op2, atof(), pop(), push();

  while ((type = getop(s, MAXOP)) != EOF) {
    switch (type) {
      case NUMBER:
        push(atof(s));
        break;
      case '+':
        push(pop() + pop());
        break;
      case '*':
        push(pop() * pop());
        break;
      case '-':
        op2 = pop();
        push(pop() - op2);
        break;
      case '/':
        op2 = pop();
        if (op2 != 0.0) {
          push(pop() / op2);
        } else {
          printf("zero divisor popped\n");
        }
        break;
        case '=':
          printf("\t%f\n", push(pop()));
          break;
        case 'c':
          clear();
          break;
        case TOOBIG:
          printf("%.20s ... is too long\n", s);
          break;
        default:
          printf("unknown command %c\n", type);
          break;
    }
  }
}

// максимальная глубина стека
#define MAXVAL 100
// указатель стека
int sp = 0;
double val[MAXVAL];

// поместить в стек
double push(double f) {
  if (sp &lt; MAXVAL) {
    return (val[sp++] = f);
  } else {
    printf("error: stack full\n");
    clear();
    return 0;
  }
}

// забрать из стека
double pop() {
  if (sp > 0) {
    return val[--sp];
  } else {
    printf("error: stack empty\n");
    clear;
    return 0;
  }
}

// очистить стек
clear() {
  sp = 0;
}
</pre>

  <p>Для операций '+' и '*' порядок операндов не важен. Однако для '-' и '/' нужно следить где левый операнд а где правый. </p>

  <h4>5.5 Правила областей действия (73)</h4>

  <p>Функции и внешние переменные не обязательно хранить в одном файле и компилировать одновременно. Исходный текст программы можно хранить в нескольких файлах, а предварительно скомпилированные подпрограммы можно загружать из библиотеки.</p>
  <p>Область действия имени это часть программы, в которой это имя определено. Для автоматической переменной, описанной в начале функции, областью действия будет вся функция. Переменные с одинаковым именем в разных функциях никак не связаны. Область действия аргументов в функциях такая же как и автоматических переменных.</p>
  <p>Область действия внешней переменной от точки во входном файле, где она была описана и до конца файла.</p>
  <p>Если нужно использовать внешнюю переменную, описанную в другом файле, то ее не описывают повторно, а ссылаются на нее с помощью слова extern.</p>
  <p>При объявлении переменной, выделяется под нее память. А при ссылке на нее с помощью слова extern мы успокаиваем компилятор, говоря ему что такая переменная уже есть.</p>
  <p>Переменные val и sp можно определить и инициировать в одном файле, а функции push, pop, clear определить в другом.</p>
  <p>Файл 1</p>
<pre>
int sp = 0;
double val[MAXVAL];
</pre>
  <p>Файл 2</p>
<pre>
extern int sp;
extern double val[];
double push(double f) {}
double pop() {}
clear() {}
</pre>

  <p>Напишем функцию getop(), которая выбирает следующий операнд или операцию. Она пропускает пробелы, символы табуляции и перехода на новую строку. Если следующий символ не цифра или десятичная точка, то он не выдается. Иначе набирается строка цифр, которая может включать десятичную точку, и выдается NUMBER - сигнал о том, что введено число. Если приходит слишком длинное число, то выдается сигнал переполнения TOOBIG.</p>
<pre>
getop(char s[], int lim) {
  int i, c;
  while ((c = getch()) == ' ' || c == '\t' || c == '\n') ;

  if (c != '.' && (c &lt; '0' || c > '9')) {
    return c;
  }

  s[0] = c;
  for (i = 1; (c = getchar()) >= '0' && c &lt;= '9'; i++) {
    if (i &lt; lim) {
      s[i] = c;
    }
  }

  // дробная часть
  if (c == '.') {
    if (i &lt; lim) {
      s[i] = c;
    }
    for (i++; (c = getchar()) >= '0' && c &lt;= '9'; i++) {
      if (i &lt; lim) {
        s[i] = c;
      }
    }
  }

  // если число правильное
  if (i &lt; lim) {
    ungetch(c);
    s[i] = '\0';
    return(NUMBER);
  // если число слишком длинное
  } else {
    // пропустить все до конца строки
    while (c != '\n' && c != EOF) {
      c = getchar();
    }
    s[lim - 1] = '\0';
    return TOOBIG;
  }
}
</pre>

  <p>Функция getch() берет следующий символ из входного потока. Функция ungetch() возвращает символ обратно во входной поток так, что следующее обращение к getch() опять выдаст этот символ. Как это работает? Функция ungetch() сохраняет возвращаемые символы в некотором буфере - символьнгом массиве. Функция getch() сначала читает информацию из этого буфера, если она там есть. Если буфер пустой, то обращается к getchar() и забирает следующий символ из входного потока.</p>

<pre>
#define BUFSIZE 100

// буфер для возврата символов
char buf[BUFSIZE]

// следующая свободная позиция в буфере
int bufp = 0;

// выдача возвращенного символа
getch() {
  return (bufp > 0) ? buf[--bufp] : getchar();
}

// возврат символа в буфер
ungetch(int c) {
  if (bufp > BUFSIZE) {
    printf("ungetch: too many characters\n");
  } else {
    buf[bufp++] = c;
  }
}
</pre>

  <h4>5.6 Статические переменные (76)</h4>

  <p>Статическая переменная объявляется со словом static и может быть внутренней или внешней.</p>
  <p>Внутренние статические переменные локальны по отношению к отдельной функции, но они не возникают и не уничтожаются при каждом вызове функции, являясь постоянной памятью для функции.</p>
  <p>Внешние статические переменные видны только ниже их объявления в том файле где они объявлены и не видны в других файлах. Их имена не конфликтует с именами внешних переменных из других файлов.</p>
  <p>Функции являются внешними и их имена известны везде, однако можно объявить функцию как статическую и она будет видна только внутри файла, где она объявлена.</p>

  <h4>5.7 Регистровые переменные (77)</h4>

  <p>Если переменную объявить со словом register, то компилятор будет знать, что переменная будет часто использоваться и ее можно поместить в регистр машины. На практике в регистрах можно хранить только небольшое число переменных, поэтому компилятор сам решает хранить переменную в регистре или нет. Для регистровой переменной невозможна операция & взятия адреса.</p>
  <p>Со словом register можно объявить только автоматическую переменную или параметр функции.</p>

  <h4>5.8 Блочная структура (78)</h4>

  <p>Язык Си не относится к языкам с блочной структурой. Нельзя определять функцию внутри другой функции. Однако переменные можно определять как и в блочных языках. Если переменная объявлена внутри блока, ограниченного фигурными скобками, то в этом блоке она затеняет все другие переменные с таким же именем.</p>

  <h4>5.9 Инициация (78)</h4>

  <p>Если при объявлении переменной не происходит ее инициализация, то гарантируется, что внешние и статичкеские переменные будут иметь значение ноль, а автоматические и регистровые переменные будут содержать мусор (то что осталось в ячейках памяти от других программ).</p>
  <p>Простые переменные (не массивы или записи) можно инициировать при их определении, если постваить знак равенства и константное выражение</p>
  <code>int x = 1;</code>
  <code>char letter = 'a';</code>
  <p>Внешние и статические переменные инициируются только один раз по время компиляции.</p>
  <p>Автоматические и регистровые переменные инициируются при каждом входе в функцию или блок. Они могут инициироваться не только константами, можно использовать любые выражения, даже вызов функции.</p>
  <p>Автоматические массивы инициировать нельзя. Внешние и статические массивы можно инициировать, поместив в описании список значений через запятую в фигурных скобках.</p>
  <code>int digits[10] = {0,1,2,3,4,5,6,7,8,9};</code>
  <p>Если инициирующих значений меньше чем размер массива, то остальные элементы получают нулевые значения.</p>
  <p>Для символьных массивов существует специальный способ инициации</p>
  <code>char s[] = "the";</code>
  <code>char s[] = {'t', 'h', 'e', '\0'};</code>
  <p>Если не указать размер массива при инициации, то его длина равна числу инициирующих значений. В последнем случае длина равна 4.</p>

  <h4>5.10 Рекурсия (80)</h4>

  <p>Рекурсивная функция обращается сама к себе. Например напечатать числа как последовательность символов. Младшие разряды числа получаются раньше старших, а печататься должны в обратном порядке.</p>
  <p>Первый способ. Сохраним цифры в массиве и распечатаем массив в обратном порядке.</p>
<pre>
printd(int n) {
  char s[10];
  int i;
  if (n &lt; 0) {
    putchar('-';
    n = -n;)
  }
  i = 0;
  do {
    s[i++] = n % 10 + '0';
  } while ((n /= 10) > 0);

  while (--i >= 0) {
    putchar(s[i]);
  }
}
</pre>

  <p>Второй способ. Рекурсивный. При каждом обращении к функции printd() она сначала обращается к себе, чтобы напечатать начальные цифры, а затем печатает замыкающую цифру.</p>
<pre>
printd(int n) {
  int i;

  if (n &lt; 0) {
    putchar('0');
    n = -n;
  }
  if ((i = n / 10) != 0) {
    printd(i);
  }
  putchar(n % 10+ '0');
}
</pre>

  <p>Рекурсия не предусматривает защиту памяти, поэтому стек вызовов может переполняться. Однако рекурсивные программы более компактные и их легче писать и понимать.</p>

  <h4>5.11 Препроцессор для Си (81)</h4>

  <p>Конструкция</p>
  <code>#include "file"</code>
  <p>заменяется содержимым файла с указанным именем.</p>

  <p>Конструкция</p>
  <code>#define true 1</code>
  <p>Заменяет все имена true на 1.</p>
  <p>Если конструкция #define не умещается на одну строку, ее можно разбить на несколько строк, ставя в конце строки символ '\'.</p>

  <p>Можно определить макроподстановку с аргументами</p>
  <code>#define max(A, B) ((A) > (B) ? (A) : (B)</code>

  <p>После такого определения, везде в программе функция max будет заменена на ее тело.</p>
</article>


<!-- Глава 6. Ссылки и массивы -->
<article class="article">
  <div class="anchor" id="p7"></div>
  <h3>Глава 6. Ссылки и массивы (84)</h3>

  <p>Ссылка представляет собою переменную, содержащую адрес другой переменной. С помощью ссылок получаются более компактные и эффективные программы.</p>

  <h4>6.1 Ссылки и массивы (84)</h4>

  <p>Ссылка содержит адрес объекта, поэтому возможно косвенное обращение к объекту через ссылку.</p>
<pre>
int x, y;
int *px;
px = &x;
y = *px;
</pre>
  <p>В указателе px будет записан адрес переменной x.</p>
  <p>Операцию & взятия адреса можно применить только к переменным и элементам массива.</p>
  <p>В переменной y будет записано содержимое, по адресу px, то есть значение y будет равно значению x.</p>
  <p>Операция * разименования применяется к указателю и возвращает значение по адресу, на который указывает указатель.</p>
</article>


<!-- Глава 7. Записи -->
<article class="article">
  <div class="anchor" id="p8"></div>
  <h3>Глава 7. Записи (108)</h3>
</article>


<!-- Глава 8. Ввод и вывод -->
<article class="article">
  <div class="anchor" id="p9"></div>
  <h3>Глава 8. Ввод и вывод (129)</h3>
</article>


<!-- Глава 9. Взаимодействие с системой UNIX -->
<article class="article">
  <div class="anchor" id="p10"></div>
  <h3>Глава 9. Взаимодействие с системой UNIX (142)</h3>
</article>


<!-- Справочное руководство по языку Си -->
<article class="article">
  <div class="anchor" id="p11"></div>
  <h3>Справочное руководство по языку Си (157)</h3>
</article>


<!-- Задачи по языку Си -->
<article class="article">
  <div class="anchor" id="p12"></div>
  <h3>Задачи по языку Си (157)</h3>
</article>

