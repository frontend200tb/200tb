<article class="article">
  <h1>1985 Керниган, Ритчи - Язык программирования Си. Задачи по языку. 279c</h1>
  <p>Конспект книги</p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
    <a href="#p1">Предисловие (10)</a>
    <br><a href="#p2">Глава 1. Введение (11)</a>
    <br><a href="#p3">Глава 2. Обзор языка (15)</a>
    <br><a href="#p4">Глава 3. Типы, операции и выражения (38)</a>
    <br><a href="#p5">Глава 4. Управление (53)</a>
    <br><a href="#p6">Глава 5. Функции и структура программы (64)</a>
    <br><a href="#p7">Глава 6. Ссылки и массивы (84)</a>
    <br><a href="#p8">Глава 7. Записи (108)</a>
    <br><a href="#p9">Глава 8. Ввод и вывод (129)</a>
    <br><a href="#p10">Глава 9. Взаимодействие с системой UNIX (142)</a>
    <br><a href="#p11">Справочное руководство по языку Си (157)</a>
    <br><a href="#p12">Задачи по языку Си (157)</a>
  </p>
</article>


<!-- Предисловие -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Предисловие (10)</h3>

  <p>Язык Си позволяет максимально использовать ресурсы ЭВМ и практически полностью отказаться от ассемблера.</p>
  <p>Книга Кернигана и Ритчи - авторское введение в язык. Язык в нем описывается так как они желали. Они учат не самому языку, а тому как надо на нем программировать.</p>
  <p>Первоначально язык Си был создан Ритчи для UNIX на ЭВМ PDP-11 и реализован в этой системе.</p>
</article>


<!-- Глава 1. Введение -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>Глава 1. Введение (11)</h3>

  <p>Язык Си работает с теми же объектами, с которыми работает и большинство вычислительных машин, а именно с символами, числами и адресами. В языке си нет операций ввода-вывода и встроенных методов доступа к файлам. Эти механизмы обеспечиваются вызовом функций.</p>
  <p>Язык Си был написан на основе языков BCPL и B. Но он на них не похож. В языках BCPL и B нет типов данных, единственными данными в них были машинные слова, обращение к другим объектам идет через специальные операции и функции.В Си есть основные типы данных из которых можно построить много производных типов.</p>
</article>


<!-- Глава 2. Обзор языка -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>Глава 2. Обзор языка (15)</h3>

  <p>Как можно быстрее начнем сами писать программы.</p>

  <h4>2.1 Начнем, пожалуй (15)</h4>

  <p>Единственный способ обучиться новому языку программирования - начать писать на нем программы.</p>
  <p>Напишем первую программу, которая выводит на экран hello, world.</p>
  <p>Первое препятствие - сначала надо где-то написать текст программы, потом его скомпилировать, запустить готовую программу и разобраться что у нас получилось.</p>
  <p>Будем использовать операционную систему <strong>Windows 10</strong>  и редактор кода <strong>VSCode</strong>.</p>
  <p>Создадим текстовый файл с расширением <strong>.c</strong>, назовем его, например, <strong>hello.c.</strong> Напишем в нем текст программы</p>

  <h4>Программа 1 (16)</h4>
  <p>Выводим на экран hello, world и переводим курсор на новую строку</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  printf("hello, world\n");

  return 0;
}
</pre>
  <code>hello, world!</code>

  <p>Откроем терминал и скомпилируем этот файл командой</p>
  <code>gcc hello.c</code>
  <p>Если нет ошибок и компиляция закончится успешно, то будет создан файл</p>
  <code>a.exe</code>
  <p>Запустим файл a.exe командой</p>
  <code>./a</code>
  <p>В консоли должен быть результат выполнения программы, выводится строчка</p>
  <code>hello, world</code>

  <p>Любая программа ня языке Си состоит из одной или более функций. Функциям можно давать любые имена, согласно правилам именования переменных и функций. Функция main() это особая функция. Она должна быть в каждой программе. С нее начинается выполнение программы.</p>

  <h4>Программа 2 (17)</h4>
  <p>Выводим на экран hello, world и переводим курсор на новую строку три раза вызвав функцию printf()</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  printf("hello, ");
  printf("world!");
  printf("\n");

  return 0;
}
</pre>
  <code>hello, world!</code>

  <h4>Программа 3 (17)</h4>
  <p>Если в функцию printf() включить '\s', где s это не символ управляющей последовательности, то получим предупреждение. Программа скомпилируется и выполнится как будто символа '\' не было</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  printf("\shello, world!\n");

  return 0;
}
</pre>
  <code>warning: unknown escape sequence: '\s'</code>
  <code>shello, world!</code>

  <h4>2.2 Переменные и арифметика (17)</h4>

  <h4>Программа 4 (18)</h4>
  <p>Программа печатает таблицу температур по Фаренгейту и  по Цельсию. Для перевода используется формула</p>
  <code>C = (5/9)(F-32)</code>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int lower, upper, step;
  float fahr, celsius;

  lower = 0;
  upper = 300;
  step = 20;
  fahr = lower;

  while (fahr &lt;= upper) {
    celsius = (5.0 / 9.0) * (fahr - 32.0);
    printf("%4.0f %6.1f\n", fahr, celsius);
    fahr = fahr + step;
  }

  return 0;
}
</pre>
  <p>Спецификатор %4.0f означает что дробное число при печати должно занимать минимум 4 символа (если цифр меньше то перед ними ставятся пробелы) и без цифр после десятичной точки</p>
  <p>Спецификатор %6.1f означает что дробное число при печати должно занимать минимум 6 символов (включая точку и цифры после нее, если цифр меньше то перед ними ставятся пробелы) и после десятичной точки доолжна быть одна цифра</p>

  <h4>2.3 Цикл for (20)</h4>

  <h4>Программа 5 (21)</h4>
  <p>Программа печатает таблицу температур по Фаренгейту и  по Цельсию, используя цикл for</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int fahr;

  for (fahr = 0; fahr &lt;= 300; fahr += 20) {
    printf("%4d %6.1f\n", fahr, (5.0 / 9.0) * (fahr - 32));
  }

  return 0;
}
</pre>

  <h4>Программа 6 (21)</h4>
  <p>Напечатаем температуры в обратном порядке от 300 до 0 градусов</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int fahr;

  for (fahr = 300; fahr >= 0; fahr -= 20) {
    printf("%4d %6.1f\n", fahr, (5.0 / 9.0) * (fahr - 32));
  }

  return 0;
}
</pre>

  <h4>2.4 Символические константы (21)</h4>

  <p>Плохо когда в программе встречаются загадочные числа вроде 300 или 20. Хорошо использовать для них конструкцию со словом #define в начале программы. Тогда можно определить символические константы. Препроцессор до выполнения компиляции заменит все символические константы на их значения. Так что полученная программа будет точно такое же, а вот читаемость программы на языке Си будет лучше.</p>

  <h4>Программа 7 (22)</h4>
  <p>Заменим цифры в программе символическими константами</p>
<pre>
#include &lt;stdio.h&gt;
#define LOWER 0
#define UPPER 300
#define STEP 20

int main() {
  int fahr;

  for (fahr = LOWER; fahr &lt;= UPPER; fahr += STEP) {
    printf("%4d %6.1f\n", fahr, (5.0 / 9.0) * (fahr - 32));
  }

  return 0;
}
</pre>

  <h4>2.5 Некоторые простые программы (22)</h4>

  <p>Чтение одного символа (обычно из терминала)</p>
  <code>c = getchar();</code>
  <p>Запись одного символа (обысно в терминал)</p>
  <code>putchar(c);</code>

  <h4>Программа 8 (23)</h4>
  <p>Копируем по одному символу со входа на выход после нажатия на клавишу ENTER. Если нужно остановать программу, надо нажать Ctrl+Z это константа EOF которая приведет к выходу из цикла while</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int c;

  c = getchar();
  while (c != EOF) {
    putchar(c);
    c = getchar();
  }

  return 0;
}
</pre>

  <h4>Программа 9 (23)</h4>
  <p>Программа может стать компактнее, если записать getchar() прямо условии цикла while. Здесь считывается один символ, присваивается переменной, проверяется на равенство символу EOF</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int c;

  while ((c = getchar()) != EOF) {
    putchar(c);
  }

  return 0;
}
</pre>

  <h4>Программа 10 (24)</h4>
  <p>Подсчитаем количество введенных символов в переменной типа int (включая пробелы и ENTER) пока не введем EOF</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int nc = 0;
  while (getchar() != EOF) {
    ++nc;
  }
  printf("count=%d\n", nc);

  return 0;
}
</pre>

  <h4>Программа 11 (24)</h4>
  <p>Подсчитаем количество введенных символов в переменной типа long (включая пробелы и ENTER) пока не введем EOF</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  long nc = 0;
  while (getchar() != EOF) {
    ++nc;
  }
  printf("count=%ld\n", nc);

  return 0;
}
</pre>

  <h4>Программа 12 (24)</h4>
  <p>Подсчитаем количество введенных символов в переменной типа double (включая пробелы и ENTER) пока не введем EOF</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  double nc = 0;
  while (getchar() != EOF) {
    ++nc;
  }
  printf("count=%.0f\n", nc);

  return 0;
}
</pre>

  <h4>Программа 13 (25)</h4>
  <p>Вместо цикла while напишем цикл for и всю работу цикл будет делать при проверке и повторной инициализации. Вместо пустого тела цикла необходимо поставить точку с запятой</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  double nc;
  for (nc = 0; getchar() != EOF; ++nc) ;
  printf("count=%.0f\n", nc);

  return 0;
}
</pre>

  <h4>Программа 14 (25)</h4>
  <p>Подсчитаем строки входного текста. Каждая строка заканчивается символом '\n'.</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int c, nl = 0;
  while ((c = getchar()) != EOF) {
    if (c == '\n') {
      ++nl;
    }
  };
    printf("count line = %d\n", nl);

  return 0;
}
</pre>

  <h4>Программа 15 (26)</h4>
  <p>Подсчитаем пробелы, символы табуляции и новые строки</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int c,
  n_ws = 0,
  n_tab = 0,
  n_l = 0;

  while ((c = getchar()) != EOF) {
    if (c == ' ') {
      ++n_ws;
    } else if (c == '\t') {
      ++n_tab;
    } else if (c == '\n') {
      ++n_l;
    }
 };
    printf("count whitespace = %d\n", n_ws);
    printf("count tab = %d\n", n_tab);
    printf("count new line = %d\n", n_l);

  return 0;
}
</pre>

  <h4>Программа 16 (26)</h4>
  <p>Напишем программу копирования ввода на вывод с заменой одного или более пробелов на один пробел</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int c, w = ' ', flag = 0;

  while ((c = getchar()) != EOF) {
    if (c == ' ') {
      flag = 1;
    } else {
      if (flag == 1) {
        putchar(w);
        flag = 0;
      }
      putchar(c);
    }
  };

  return 0;
}
</pre>

  <h4>Программа 17 (26)</h4>
  <p>Напишем программу копирования ввода на вывод с заменой каждого символа табуляции на символы >>>, а каждого символа возврата на один шаг на символ &lt;</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char c;
  char t = '\t', tt = '>';
  char b = '\b', bb = '&lt;';

  while ((c = getchar()) != EOF) {
    if (c == t) {
      putchar(tt);
      putchar(tt);
      putchar(tt);
    } else if (c == b) {
      putchar(bb);
    } else {
      putchar(c);
    }
  };

  return 0;
}
</pre>

  <h4>Программа 18 (26)</h4>
  <p>Подсчитаем строки, слова и символы. Слово это последовательность символов, не содержащая пробелов, табуляции и символа перехода на новую строку. Как только программа встречает первый символ, она начинает считать</p>
<pre>
#include &lt;stdio.h&gt;

#define YES 1
#define NO  0

int main() {
  int c, n_line, n_word, n_char, inword;
  inword = NO;
  n_line = n_word = n_char = 0;

  while ((c = getchar()) != EOF) {
    ++n_char;
    if (c == '\n') {
      ++n_line;
    }
    if (c == ' ' || c == '\t' || c == '\n') {
      inword = NO;
    } else if (inword == NO) {
      inword = YES;
      ++n_word;
    }
  }
  printf("count line = %d\n", n_line);
  printf("count word = %d\n", n_word);
  printf("count char = %d\n", n_char);

  return 0;
}
</pre>

  <h4>Программа 19 (28)</h4>
  <p>Напечатаем вводимые слова по одному в строке</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int c, w = 0;

  while ((c = getchar()) != EOF) {
    if (c == ' ' || c == '\t' || c == '\n') {
      if (w == 0) {
        putchar('\n');
      }
      w++;
    } else {
      putchar(c);
      w = 0;
    }
  }

  return 0;
}
</pre>

  <h4>Программа 20 (28)</h4>
  <p>Напечатаем вводимые слова по одному в строке. Слова должны начинаться с буквы</p>
<pre>
#include &lt;stdio.h&gt;

#define YES 1
#define NO  0

int main() {
  int c;
  int n_word = 0;
  int inword = NO;

  while ((c = getchar()) != EOF) {
    if (c == ' ' || c == '\t' || c == '\n') {
      inword = NO;
    } else if (inword == NO && (
              (c > 64 && c &lt; 91) ||
              (c > 96 && c &lt; 123))) {
      inword = YES;
      ++n_word;
    } else {
      inword = YES;
    }
  }
  printf("count word = %d\n", n_word);

  return 0;
}
</pre>

  <h4>2.6 Массивы (28)</h4>

  <h4>Программа 21 (28)</h4>
  <p>Посчитаем вхождения каждой из цифр, невидимых (пустых) симовол (пробелов, табуляций, перехода на новую строку) и других символов</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int c, i;
  int nwhite = 0, nother = 0;
  int ndigit[10];

  for (i = 0; i &lt; 10; i++) {
    ndigit[i] = 0;
  }

  while ((c = getchar()) != EOF) {
    if (c >= '0' && c &lt;= '9') {
      ndigit[c - '0']++;
    } else if (c == ' ' || c == '\t' || c == '\n') {
      nwhite++;
    } else {
      nother++;
    }
  }
  for (i = 0; i &lt; 10; i++) {
    printf("%d %d\n", i, ndigit[i]);
  }
  printf("white space = %d\n", nwhite);
  printf("other = %d\n", nother);

  return 0;
}
</pre>

  <h4>Программа 22 (29)</h4>
  <p>Напечатаем гистограмму длин читаемых слов. Гистограмму расположим горизонтально</p>
<pre>
#include &lt;stdio.h&gt;

#define YES 1
#define NO  0

int main() {
  int c;
  int n_word = 0;
  int inword = NO;
  int inother = NO;
  int len[256] = {0};

  while ((c = getchar()) != EOF) {
    // если пробельный символ
    if (c == ' ' || c == '\t' || c == '\n') {
      inword = NO;
      inother = NO;
    // если это первая буква после пробельного символа
    } else if (inword == NO && inother == NO && (
              (c > 64 && c &lt; 91) ||
              (c > 96 && c &lt; 123))) {
      inword = YES;    // мы внутри слова
      ++n_word;        // увеличиваем число слов
      len[n_word] = 1; // в слове одна буква
    // если не пробельный символ и мы внутри слова
    } else if (inword == YES) {
        len[n_word]++;
    } else {
      inother = YES;
    }
  }

  for (int i = 1; i &lt;= n_word; i++) {
    for (int j = 1; j &lt;= len[i]; j++) {
      printf("#");
    }
    printf("\n");
  }

  return 0;
}
</pre>

  <h4>2.7 Функции (29)</h4>

  <h4>Программа 23 (30)</h4>
  <p>Напишем функцию power для возведения целого числа в целую положительную степень. В программе вычисли 2⁵ и 2¹⁰</p>
<pre>
#include &lt;stdio.h&gt;

int power(int, int);

int main() {
  printf("2**5=%d\n", power(2,5));
  printf("2**10=%d\n", power(2,10));

  return 0;
}

int power(int m, int n) {
  int i, p = 1;
  for (i = 0; i &lt; n; i++) {
    p *= m;
  }

  return p;
}
</pre>
  <code>2**5=32</code>
  <code>2**10=1024</code>

  <h4>Программа 24 (30)</h4>
  <p>Напишем программу, которая принимает два целых числа и возводит первое число в степень равную второму числу</p>
<pre>
#include &lt;stdio.h&gt;

int power(int, int);

int main() {
  int a, b;
  printf("Enter integer ");
  scanf("%d", &a);
  printf("Enter power ");
  scanf("%d", &b);
  printf("%d**%d = %d\n", a, b, power(a, b));

  return 0;
}

int power(int m, int n) {
  int i, p = 1;
  for (i = 0; i &lt; n; i++) {
    p *= m;
  }

  return p;
}
</pre>

  <h4>Программа 25 (31)</h4>
  <p>Напишем программу, которая принимает строку и преобразует буквы к нижнему регистру.</p>
<pre>
#include &lt;stdio.h&gt;

char lower(char);

int main() {
  int ch;
  while ((ch = getchar()) != '\n') {
    printf("%c", lower(ch));
  }

  return 0;
}

char lower(char c) {
  char res;
  if (c >= 65 && c &lt;= 91) {
    res = c + 32;
  } else {
    res = c;
  }

  return res;
}
</pre>

  <h4>2.8 Аргументы - вызов по значению (31)</h4>

  <p>Все аргументы функции передаются "по-значению". Внутри функции создаются новые переменные со значениями, переданными в параметрах. В основной программе передаваемые аргументы остаются неизменными, внутри функции меняется только их копия.</p>

  <h4>Программа 26 (31)</h4>
  <p>Функция power() работает с копиями переменных.</p>
<pre>
#include &lt;stdio.h&gt;

int power(int, int);

int main() {
  printf("2**5=%d\n", power(2,5));
  printf("2**10=%d\n", power(2,10));

  return 0;
}

int power(int m, int n) {
  int p;
  for (p = 1; n > 0; --n) {
    p *= m;
  }

  return p;
}
</pre>

  <p>Чтобы в программе поменялось значение переменной, надо в функцию передать ее адрес. и тогда адрес не изменится, так как внутри функции будет действовать копия адреса, а переменную по этому адресу можно поменять.</p>
  <p>Если в качестве аргумента берется имя массива, то передаваемое функции значение фактически есть адрес начала массива. Никакое копирование элементов массива не производится. Обращаясь по индексу, функция может выбирать или изменять любые элементы массива.</p>

  <h4>2.9 Массивы символов (32)</h4>

  <h4>Программа 27 (32)</h4>
  <p>Напишем программу, которая читает несколько строк и затем печатает самую длинную из них. Программа читает строки. В цикле, пока есть еще строки, сравнивает строку с самой длинной, выбирает самую длинную и запоминает строку и ее длину.</p>
<pre>
#include &lt;stdio.h&gt;
#define MAXLINE 1000

int getline(char [], int);
void copy(char [], char []);

int main() {
  int len;
  int max;
  char line[MAXLINE];
  char save[MAXLINE];
  max = 0;
  while((len = getline(line, MAXLINE)) > 0) {
    if (len > max) {
      max = len;
      copy(line, save);
    }
  }
  if (max > 0) {
    printf("%s", save);
  }

  return 0;
}

int getline(char s[], int lim) {
    int c, i;
    for (i=0; i &lt; lim - 1 && (c=getchar())!=EOF && c!='\n'; i++){
      s[i] = c;
    }
    if (c == '\n') {
      s[i] = c;
      i++;
    }
    s[i] = '\0';
    return i;
  }

void copy(char s1[], char s2[]) {
  int i = 0;
  while ((s2[i] = s1[i]) != '\0') {
    i++;
  }
}
</pre>

  <h4>Программа 28 (34)</h4>
  <p>Напишем программу, убирающую начальные пробелы и символы табуляции из каждой входно стрки и исключающую пустые строки.</p>

  <h4>Программа 29 (34)</h4>
  <p>Напишем программу, переставляющую символы строки в обратном порядке.</p>

  <h4>2.10 Области действия. Внешние переменные (34)</h4>

  <p>Внутренние переменные функции main() это локальные переменные, поскольку они объявлены и действуют внутри нее. Никакие другие функции не имеют к ним прямого доступа. Это же справедливо для переменных других функций. Любая локальная переменная начинает существовать при входе в функцию и уничтожается при выходе из функции. Такие переменные еще можно назвать автоматическими, потому что они сами независимо от нас создаются и уничтожаются автоматически.</p>
  <p>Внешние переменные, объявленные вне функций, это глобальные переменные. К ним можно обращаться из любой функции. Их можно использовать для связи между функциями. Эти переменные существуют всегда, а не возникают и исчезают при входе и выходе из функции.</p>
  <p>Чтобы в функции использовать глобальную переменную, ее нужно пометить как extern.</p>

  <h4>Программа 30 (35)</h4>
  <p>Перепишем программу для самой большой строки, сделав переменные line, save и max внешними.</p>
<pre>
#include &lt;stdio.h&gt;
#define MAXLINE 1000

char line[MAXLINE];
char save[MAXLINE];
int max;

int getline();
void copy();

int main() {
  int len;
  extern int max;
  extern char save[];
  max = 0;
  while((len = getline()) > 0) {
    if (len > max) {
      max = len;
      copy();
    }
  }
  if (max > 0) {
    printf("%s", save);
  }

  return 0;
}

int getline() {
    int c, i;
    extern char line[];
    for (i=0; i &lt; MAXLINE - 1 && (c=getchar())!=EOF && c!='\n'; i++){
      line[i] = c;
    }
    if (c == '\n') {
      line[i] = c;
      i++;
    }
    line[i] = '\0';
    return i;
  }

void copy() {
  int i = 0;
  extern char line[], save[];
  while ((save[i] = line[i]) != '\0') {
    i++;
  }
}
</pre>
  <p>Определение глобальных переменных приводит к выделению памяти, согласно их типу. Прежде чем функция сможет использовать глобальную переменную, нужно сделать имя этой переменной известным для функции. Один из спопобов сделать это - включить в функцию описание внешней переменной с помощью слова extern.</p>
  <p>При описании переменной с помощью слова extern, память для нее не выделяется.</p>

  <h4>2.11 Заключение (36)</h4>
</article>


<!-- Глава 3. Типы, операции и выражения -->
<article class="article">
  <div class="anchor" id="p4"></div>
  <h3>Глава 3. Типы, операции и выражения (38)</h3>

  <h4>3.1 Имена переменных (38)</h4>

  <p>Имена могут состоять из букв, цифр, символа подчеркивания. Первым символом в имени не может быть цифра.</p>

  <h4>3.2 Типы данных и размеры (38)</h4>

  <p>Основные типы данных в Си char, int, float, double. Несколько "уточнителей" для типа int: short, long, unsigned. Точность целых чисел зависит от конкретной машины.</p>

  <h4>3.3 Константы (39)</h4>

  <p>Символьная константа и строка из одного символа это не одно и то же. 'x' != "x". 'x' это символ для буквы x. "x" это строка, содержащая один символ и символ "\0".</p>

  <h4>3.4 Описания (40)</h4>

  <p>Перед использованием переменная должна быть объявлена. При объявлении можно задавать начальные значения.</p>

  <h4>3.5 Арифметические операции (41)</h4>

  <p>Операцию % остаток от деления нельзя использовать для типа float и double.</p>

  <h4>3.6 Отношения и логические операции (42)</h4>

  <h4>3.7 Преобразование типов (43)</h4>

  <p>Автоматическое преобразование типов происходит в трех случаях</p>
  <ol>
    <li>Если в одном выражении операнды разных типов, то они преобразуются к одному типу.</li>
    <li>При присваивании значение правой части преобразуется к типу левой части.</li>
    <li>При передачи аргументов в функцию их типы преобразуются к типам параметров функции</li>
  </ol>
  <p>Явное преобразование называется приведением</p>
  <code>(имя типа) выражение</code>

  <h4>3.8 Операции увеличения и уменьшения (45)</h4>

  <p>Операции инкремента и декремента можно применять только к переменным и нельзя применять к выражениям. Например (i + i)++ выполнить нельзя.</p>

  <h4>3.9 Поразрядные логическин операции (47)</h4>

  <p>Порязрядные операции нельзя применить к float и double.</p>

  <h4>3.10 Операции присваивания и выражения (48)</h4>

  <h4>3.11 Условные выражения (50)</h4>

  <p>Найдем максимум из двух чисел</p>
  <code>if (a>b) max=a; else max=b;</code>
  <code>max = (a>b) & a : b;</code>

  <h4>3.12 Приоритеты и порядок вычислений (50)</h4>

  <p>Обращение к функциям, вложенные операторы присваивания, операции инкремента, декремента обладают побочным эффектом, связанным с порядком обращения к переменным.</p>
</article>


<!-- Глава 4 Управление -->
<article class="article">
  <div class="anchor" id="p4"></div>
  <h3>Глава 4 Управление (53)</h3>

  <h4>4.1 Операторы и блоки (53)</h4>

  <p>Любое выражение становится оператором, если за ним идет точка с запятой. В языке Си точка с запятой заканчивает оператор. Если операторы группируются в блок, окруженный фигурными скобками, то после закрывающей фигурной скобки точка с запятой не ставится.</p>

  <h4>4.2 if - else (53)</h4>

  <p>Оператор if-else применяется для принятия решения. Часть else может присутствовать, а может и не присутствовать. Если часть с else пропускается во вложенных условных операторах, то возникает неясность в толковании. Компилятор сопоставляет else с ближайшим if, не имеющим своего else. Если это не то что вам нужно, то используйте фигурные скобки перед оператором else чтобы показать к какому if он относится.</p>

  <h4>4.3 else if (55)</h4>

  <p>Конструкция else if используется когда нужно выбирать из многих решений.</p>

  <h4>Программа 34 (55)</h4>
  <p>Функция двоичного поиска, определяющая встречается ли значение x  в упорядоченном массиве v.</p>
<pre>
binary(int x, int v[], int n) {
  int low, high, mid;
  low = 0;
  high = n-1;
  while (low &lt;= high) {
    mid = (low + high) / 2;
    if (x &lt; v[mid]) high = mid - 1;
    else if (x > v[mid]) low = mid + 1;
    else return (mid);
  }
  return (-1);
}
</pre>

  <h4>4.4 Переключатель (56)</h4>

  <p>Переключатель (оператор switch) предназначен для принятия одного из многих решений. В нем проверяется совпадение значения выражения с одной из нескольких констант и выполняется соответствующая ветвь.</p>

  <h4>4.5 Циклы while и for (57)</h4>

  <h4>4.6 Цмклы do-while (60)</h4>
</article>

