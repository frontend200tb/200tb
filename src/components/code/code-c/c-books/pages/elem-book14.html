<article class="article">
  <h1>2020 Прохоренок - Язык Си. Самое необходимое 480c</h1>
  <p>Конспект книги</p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
        <a href="#p1">1 Установка программ под Windows (11)</a>
    <br><a href="#p2">2 Первые шаги (44)</a>
    <br><a href="#p3">3 Переменные и типы данных (91)</a>
    <br><a href="#p4">4 Операторы и циклы (133)</a>
    <br><a href="#p5">5 Числа (156)</a>
    <br><a href="#p6">6 Массивы (181)</a>
    <br><a href="#p7">7 Символы и C-строки (206)</a>
    <br><a href="#p8">8 Широкие символы и L-строки (244)</a>
    <br><a href="#p9">9 Работа с датой и временем (300)</a>
    <br><a href="#p10">10 Пользовательские функции (312)</a>
    <br><a href="#p11">11 Обработка ошибок (336)</a>
    <br><a href="#p12">12 Чтение и запись файлов (351)</a>
    <br><a href="#p13">13 Низкоуровневые потоки ввода и вывода (374)</a>
    <br><a href="#p14">14 Работа с файловой системой (386)</a>
    <br><a href="#p15">15 Потоки и процессы (407)</a>
    <br><a href="#p16">16 Создание библиотек (430)</a>
    <br><a href="#p17">17 Прочее (448)</a>
  </p>
</article>


<!-- 1 Установка программ под Windows (11) -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>1 Установка программ под Windows (11)</h3>

  <p>Язык Си - это компилируемый язык высокого уровня. Это кроссплатформенный язык, позволяющий создавать программы, которые будут работать во всех операционных системах, но для каждой операционной системы компиляцию нужно проводить отдельно. В этой книге мы будем получать исполняемые exe-файлы с помощью компилятора gcc из состава популярной библиотеки MinGW-W64 для 64-битной операционной системы Windows.</p>
  <p>Существует несколько стандартов языка Си:</p>
  <code>C90, C99, C11.</code>
  <p>Чтобы использовать правила конкретного стандарта, при компиляции нужно указать флаги:</p>
  <code>-std=c90, -std=c99, -std=c11.</code>
  <p>Без этих флагов компилятор будет использовать последний стандарт. Узнать используемый стандарт языка Си внутри программы можно с помощью макроса __STDC_VERSION__</p>
  <code>printf("%ld\n", __STDC_VERSION__);</code>
  <p>Получить информацию о версии компилятора позволяет макрос __VERSION__</p>
  <code>printf("s\n", __VERSION__);</code>
  <p>Для комфортного программирования, имя компьютера, имена файлов и катлогов должны содержать только символы латинского алфавита, цифры, тире, подчеркивания. Это нужно чтобы не было проблем с компиляцией и запуском программ.</p>

  <h4>1.2 Добавление пути в переменную PATH (12)</h4>

  <p>Когда в командной строке мы вводим название программы, то вначале поиск программы выполняется в текущем каталоге, а затем в путях, указанных в системной переменной PATH. Пути в системной переменной PATH просматриваются слева направо до первого вхождения искомого названия. Если в путях прописано несколько объектов с одинаковым названием, то выдаваться всегда будет один - только первый найденный объект.</p>
  <p>Чтобы  добавить объект в системную переменную PATH, необходимо открыть</p>
  <code>Параметры - Панель управления - Система и безопасность - Система - Дополнительные параметры системы</code>
  <p>В открывшемся окне <strong>Свойства системы</strong> выбрать</p>
  <code>Дополнительно - Переменные среды</code>
  <p>В открывшемся окне <strong>Переменные среды</strong> в списке <strong>Системные переменные</strong> выделяем строку с переменной <strong>Path</strong> и нажимаем кнопку <strong>Изменить</strong></p>

  <h4>1.4 Установка MinGW и MSYS (14)</h4>

  <p>Для преобразования текста программы в файле с расширением .c в исполняемый файл с расширением .exe потребуется установить компилятор. Мы установим беспратный компилятор gcc, входящий в состав популярной библиотеки MinGW. Установим ее в каталог</p>
  <code>c:\gcc</code>
  <p>Путь к компилятору gcc.exe и g++.exe пропишем в систмную переменную PATH</p>
  <code>c:\gcc\bin</code>
  <p>Если компилятор успешно установился и путь к нему прописан, то мы получим версию компилятора, если введем в командной строке команду</p>
  <code>gcc --version</code>
  <code>g++ --version</code>
</article>


<!-- 2 Первые шаги (44) -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>2 Первые шаги (44)</h3>

  <h4>2.1 Первая программа (44)</h4>

  <p>Напишем первую программу, которая выводит в консоль надпись Hello, world!</p>

  <details>
    <summary>Программа 1 (45)</summary>
<pre>
#include &lt;stdio.h&gt;

int main () {
  printf("Hello, world!");
  return 0;
}
</pre>
  </details>

  <p>Чтобы скомпилировать программу, нужно запустить компилятор и передать ему в качестве аргумента название файла. Наберем в терминале следующую команду</p>

  <code>gcc helloworld.c</code>

  <p>После компиляции, если нет ошибок, компилятор создаст исполняемый файл a.exe, который можно запустить командой</p>
  <code>./a</code>

  <p>В терминале получится результат работы программы</p>
  <code>Hello, world!</code>

  <h4>2.4 Добавление в проект заголовочного файла (50)</h4>

  <p>В программе могут быть заголовочные файлы. В заголовочных файлах указывают прототипы функций и различные объявления. Заголовочный файл имеет расширение .h</p>
  <p>Создадим файл helloworld.h</p>
<pre>
#ifndef HELLOWORLD_H_
#define HELLOWORLD_H_

#endif /* HELLOWORLD_H_ */
</pre>
  <p>Для того чтобы избежать повторное объявление идентификаторов, все прототипы и прочие объявления нужно вкладывать в блок #ifndef #endif.</p>
  <p>Второй способ избежать повторного объявления идентификаторов это указать директиву #pragma со значением once</p>
  <code>#pragma once</code>

  <h4>2.6 Структура программы (57)</h4>

<pre>
Подключение заголовочных файлов
Объявление глобальных переменных
Объявление функций
int main() {
  код функции
  return 0;
}
Определение функций
</pre>
  <p>В самом начале программы подключаются заголовочные файлы, в которых содержатся объявления идентификаторов без их реализации.</p>
  <p>Объявление переменной</p>
  <code>int x;</code>
  <p>Присвоение значения переменной при объявлении называется инициализацией переменной</p>
  <code>int x = 10;</code>
  <p>Если глобальной переменной не присвоено значение при объявлении, то она будет иметь значение 0. Если локальной переменной не присвоено значение, то она будет содержать мусор - данные оставшиеся в памяти от других программ.</p>
  <p>Объявление функции без ее реализации называется прототипом функции.</p>
  <code>int sum(int x, int y);</code>
  <p>В прототипе указывается тип возвращаемого значения, имя, тип и порядок аргументов функции. Имена аргументов можно писать, а можно и не писать. После прототипа функции нужно написать ее реализацию. После прототипа ставится точка с запятой ;.</p>
  <p>Прототип функции обычно пишут перед функцией main, чтобы функция main знала и могла использовать объявленные функции, а реализацию функции пишут после функции main.</p>
  <p>Реализация функции sum</p>
<pre>
int sum(int x, int y) {
  return x + y;
}
</pre>
  <p>Первая строка в реализации функции совпадает с прототипом. Но вместо точки с запятой ставятся фигурные скобки {} внутри которых находится код функции.</p>
  <p>Функция main имеет три прототипа</p>
  <code>int main(void);</code>
  <code>int main(int argc, char *argv[]);</code>
  <code>int main(int argc, char *argv[], char **penv);</code>
  <p>В первом прототипе значение void означает что функция не принимает параметров.</p>
  <p>Во втором прототипе параметр argc это количество строковых значений, переданных из командной сроки. Причем первое значение это имя программы, а остальные значения передаются через параметр argv</p>
  <p>В третьем прототипе параметр penv позволяет получить значения переменных окружения.</p>
  <p>Функция main при успешном выполнении должна возвращать 0. Вместо этого можно написать EXIT_SUCCESS, а при завершении с ошибкой EXIT_FAILURE. Для этого нужно подключить библиотеку stdlib, в которой определены две переменные</p>
<pre>
#include &lt;stdlib.h&gt;
#define EXIT_SUCCESS 0
#define EXIT_FAILURE 1
</pre>
  <code>return EXIT_SUCCESS;</code>

  <p>Программа вычисления суммы двух чисел.</p>

  <details>
    <summary>Программа 2 (62)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int x = 21;
int y = 85;

int sum(int, int);
void print(int);

int main() {
  int z = sum(x, y);
  print(z);

  return EXIT_SUCCESS;
}

int sum(int x, int y) {
  return x + y;
}

void print(int) {
  printf("%d", x);
}
</pre>
  </details>

  <p>Вынесем объявления функций в отдельный заголовочный файл</p>

  <details>
    <summary>Программа 3 (63)</summary>
    <p>Заголовочный файл 3sum.h</p>
<pre>
#ifndef SUM_H_
#define SUM_H_

int sum(int, int);
void print(int);

#endif
</pre>

  <p>Файл 3.c</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include "3sum.h"

int x = 21;
int y = 85;

int main() {
  int z = sum(x, y);
  print(z);

  return EXIT_SUCCESS;
}

int sum(int x, int y) {
  return x + y;
}

void print(int x) {
  printf("%d", x);
}
</pre>
  </details>

  <h4>Комментарии в программе (63)</h4>

  <p>Компилятор полностью игнорирует комментарии. Комментарии синтаксически бывают однострочные и многострочные.</p>
  <p>Чтобы закомментировать одну строку, нужно поставить курсор на эту строку и нажать Ctrl + /. Строка будет закомментирована однострочным комментарием. Чтобы закомментировать более одной строки, их нужно выделить и нажать Ctrl + /. Выделенные строки будут закомментированы однострочными комментариями.</p>
  <p>Многострочные комментарии не могут быть вложенные. Однострочные комментарии могут быть вложены друг в друга и в многострочные комментарии.</p>

  <h4>Вывод данных (65)</h4>

  <p>Печать одного символа putchar()</p>
  <code>putchar('w'); // w</code>
  <code>putchar('119'); // w</code>

  <p>Печать одной строки puts()</p>
  <code>puts("string"); // string</code>

  <p>Форматированная печать printf()</p>
  <code>printf("string\n"); // string</code>
  <code>printf("%d", 10); // 10</code>
  <code>printf("%s %d", "number", 10); // number 10</code>

  <p>Напишем индикатор выполнения процесса</p>

  <details>
    <summary>Программа 4 (70)</summary>
    <p>Версия из книги</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;

int main() {
  printf("... 0%%");
  for (int i = 5; i &lt; 101; i += 5) {
    Sleep(1000);
    printf("\r... %d%%", i);
    fflush(stdout);
  }
  printf("\n");

  return 0;
}
</pre>
  <p>Моя версия</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;

int main() {
  for (int i = 5; i &lt; 100; i += 5) {
    Sleep(200);
    printf("\r.    %d%%", i);
    Sleep(200);
    printf("\r..   %d%%", i += 5);
    Sleep(200);
    printf("\r...  %d%%", i += 5);
    Sleep(200);
    printf("\r.... %d%%", i += 5);
    fflush(stdout); // сброс буфера вывода
  }

  // держим консоль открытой
  printf("\nPress any key for continue");
  fflush(stdin); // сброс буфера ввода
  getchar();

  return 0;
}
</pre>
  </details>

  <h4>2.9 Ввод данных (71)</h4>

  <h4>2.9.1 Ввод одного символа (71)</h4>

  <p>Для ввод одного символа предназначена функция getchar()</p>
  <code>char ch = getchar();</code>

  <p>Полученный символ будет в кодировке консоли. По умолчанию кодировка консоли <strong>windows-866</strong>. Чтобы принимать русские буквы в кодировке <strong>windows-1251</strong>, необходимо сменить кодировку.</p>

  <details>
    <summary>Программа 5 (72)</summary>
    <p>Сохраним файл программы в кодировке <strong>Windows-1251</strong></p>

<pre>
#include &lt;stdio.h&gt;

int main() {
  puts("Введите символ");
  char ch = getchar();
  printf("%c", ch);

  return 0;
}
</pre>

    <p>Если русские буквы не выводятся, то сменим кодировку в консоли</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;locale.h&gt;

int main() {
  // смена кодировки консоли
  system("chcp 1251");
  setlocale(LC_ALL,"Russian_Russia.1251");

  puts("Введите символ");
  char ch = getchar();
  printf("%c", ch);

  return 0;
}
</pre>
  </details>

  <h4>2.9.2 Функция scanf() (72)</h4>

  <p>Для получения и автоматического преобразования данных в корректный тип предназначена функция scanf(). Введем число</p>
  <code>int x;</code>
  <code>scanf("%d", &x);</code>

  <p>При вводе строки, функция scanf() не производит никакой проверки длины строки, что может привести к переполнению буфера. Обязательно используйте ширину при использовании спецификатора строки. Введем строку, не превышающую 255 символов</p>
  <code>char str[256] = "";</code>
  <code>scanf("%255s", str);</code>

  <details>
    <summary>Программа 6 (73)</summary>
    <p>Сохраним файл программы в кодировке <strong>Windows-1251</strong></p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;locale.h&gt;

int main() {
  // смена кодировки консоли
  system("chcp 1251");
  setlocale(LC_ALL,"Russian_Russia.1251");

  puts("Введите строку (max 255 symbols)");
  char str[256] = "";
  scanf("%255s", str);
  printf("%s", str);

  // держим консоль открытой
  printf("\nPress any key for continue");
  fflush(stdin); // сброс буфера ввода
  getchar();

  return 0;
}
</pre>
  </details>

  <p>Суммирование двух введенных чисел. Функция scanf() возвращает количество успешных операций присваивания. Мы можем проверить, что если мы ожидаем число и присвоилось число, то это успешная операция присваивания.</p>
  <details>
    <summary>Программа 7 (73)</summary>
    <p>Сохраним файл программы в кодировке <strong>Windows-1251</strong></p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;locale.h&gt;

int main() {
  // смена кодировки
  system("chcp 1251");
  setlocale(LC_ALL,"Russian_Russia.1251");

  int x = 0, y = 0;

  puts("Введите первое число");
  if (scanf("%d", &x) != 1) {
    puts("Вы ввели не число");
    return 1;
  }

  puts("Введите второе число");
  if (scanf("%d", &y) != 1) {
    puts("Вы ввели не число");
    return 1;
  }

  printf("Сумма равна %d", x + y);

  return 0;
}
</pre>
  </details>

  <h4>2.9.3 Ввод строки (77)</h4>

  <p>Для ввода строки предназначена функция gets(), но применять ее в программе не следует, т.к. функция не производит никакой проверки длины строки, что может привести к переполнению буфера. Лучше получать строку посимвольно с помощью функции getchar() или воспользоваться функцией fgets(). Функция fgets() имеет прототип</p>
  <code>char *fgets(char *buf, int maxCount, FILE *stream);</code>
  <p>Функция fgets() принимает три параметра. Первый имя переменной куда запишет строку. Второй максимальная длина строки. Третий указатель на поток, откуда брать строку. Считывание происходит до первого символа перевода строки или конца файла или пока не будет прочитано maxCount-1 символов. Символ конца строки тоже запишется в буфер.</p>

  <details>
    <summary>Программа 8 (78)</summary>
    <p>Сохраним файл программы в кодировке <strong>Windows-1251</strong></p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;locale.h&gt;
#include &lt;string.h&gt;

int main() {
  // смена кодировки консоли
  system("chcp 1251");
  setlocale(LC_ALL,"Russian_Russia.1251");

  char buf[256] = "";
  char *p = NULL;

  puts("Введите строку (max 255 symbols)");
  p = fgets(buf, 256, stdin);
  if (p) {
    // удаляем символ перевода строки
    size_t len = strlen(buf);
    if (len != 0 && buf[len - 1] == '\n') {
      buf[len - 1] = '\0';
    }
    printf("%s", buf);
  } else {
    puts("Возникла ошибка");
  }

  return 0;
}
</pre>
  </details>
</article>


<!-- 3 Переменные и типы данных (91) -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>3 Переменные и типы данных (91)</h3>

</article>


<!-- 4 Операторы и циклы (133) -->
<article class="article">
  <div class="anchor" id="p4"></div>
  <h3>4 Операторы и циклы (133)</h3>

</article>


<!-- 5 Числа (156) -->
<article class="article">
  <div class="anchor" id="p5"></div>
  <h3>5 Числа (156)</h3>

</article>


<!-- 6 Массивы (181) -->
<article class="article">
  <div class="anchor" id="p6"></div>
  <h3>6 Массивы (181)</h3>

</article>


<!-- 7 Символы и C-строки (206) -->
<article class="article">
  <div class="anchor" id="p7"></div>
  <h3>7 Символы и C-строки (206)</h3>

</article>


<!-- 8 Широкие символы и L-строки (244) -->
<article class="article">
  <div class="anchor" id="p8"></div>
  <h3>8 Широкие символы и L-строки (244)</h3>

</article>


<!-- 9 Работа с датой и временем (300) -->
<article class="article">
  <div class="anchor" id="p9"></div>
  <h3>9 Работа с датой и временем (300)</h3>

</article>


<!-- 10 Пользовательские функции (312) -->
<article class="article">
  <div class="anchor" id="p10"></div>
  <h3>10 Пользовательские функции (312)</h3>

</article>


<!-- 11 Обработка ошибок (336) -->
<article class="article">
  <div class="anchor" id="p11"></div>
  <h3>11 Обработка ошибок (336)</h3>

</article>


<!-- 12 Чтение и запись файлов (351) -->
<article class="article">
  <div class="anchor" id="p12"></div>
  <h3>12 Чтение и запись файлов (351)</h3>

</article>


<!-- 13 Низкоуровневые потоки ввода и вывода (374) -->
<article class="article">
  <div class="anchor" id="p13"></div>
  <h3>13 Низкоуровневые потоки ввода и вывода (374)</h3>

</article>


<!-- 14 Работа с файловой системой (386) -->
<article class="article">
  <div class="anchor" id="p14"></div>
  <h3>14 Работа с файловой системой (386)</h3>

</article>


<!-- 15 Потоки и процессы (407) -->
<article class="article">
  <div class="anchor" id="p15"></div>
  <h3>15 Потоки и процессы (407)</h3>

</article>


<!-- 16 Создание библиотек (430) -->
<article class="article">
  <div class="anchor" id="p16"></div>
  <h3>16 Создание библиотек (430)</h3>

</article>


<!-- 17 Прочее (448) -->
<article class="article">
  <div class="anchor" id="p17"></div>
  <h3>17 Прочее (448)</h3>

</article>

