<article class="article">
  <h1>2020 Прохоренок - Язык Си. Самое необходимое 480c</h1>
  <p>Конспект книги</p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
        <a href="#p1">1 Установка программ под Windows (11)</a>
    <br><a href="#p2">2 Первые шаги (44)</a>
    <br><a href="#p3">3 Переменные и типы данных (91)</a>
    <br><a href="#p4">4 Операторы и циклы (133)</a>
    <br><a href="#p5">5 Числа (156)</a>
    <br><a href="#p6">6 Массивы (181)</a>
    <br><a href="#p7">7 Символы и C-строки (206)</a>
    <br><a href="#p8">8 Широкие символы и L-строки (244)</a>
    <br><a href="#p9">9 Работа с датой и временем (300)</a>
    <br><a href="#p10">10 Пользовательские функции (312)</a>
    <br><a href="#p11">11 Обработка ошибок (336)</a>
    <br><a href="#p12">12 Чтение и запись файлов (351)</a>
    <br><a href="#p13">13 Низкоуровневые потоки ввода и вывода (374)</a>
    <br><a href="#p14">14 Работа с файловой системой (386)</a>
    <br><a href="#p15">15 Потоки и процессы (407)</a>
    <br><a href="#p16">16 Создание библиотек (430)</a>
    <br><a href="#p17">17 Прочее (448)</a>
  </p>
</article>


<!-- 1 Установка программ под Windows (11) -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>1 Установка программ под Windows (11)</h3>

  <p>Язык Си - это компилируемый язык высокого уровня. Это кроссплатформенный язык, позволяющий создавать программы, которые будут работать во всех операционных системах, но для каждой операционной системы компиляцию нужно проводить отдельно. В этой книге мы будем получать исполняемые exe-файлы с помощью компилятора gcc из состава популярной библиотеки MinGW-W64 для 64-битной операционной системы Windows.</p>
  <p>Существует несколько стандартов языка Си:</p>
  <code>C90, C99, C11.</code>
  <p>Чтобы использовать правила конкретного стандарта, при компиляции нужно указать флаги:</p>
  <code>-std=c90, -std=c99, -std=c11.</code>
  <p>Без этих флагов компилятор будет использовать последний стандарт. Узнать используемый стандарт языка Си внутри программы можно с помощью макроса __STDC_VERSION__</p>
  <code>printf("%ld\n", __STDC_VERSION__);</code>
  <p>Получить информацию о версии компилятора позволяет макрос __VERSION__</p>
  <code>printf("s\n", __VERSION__);</code>
  <p>Для комфортного программирования, имя компьютера, имена файлов и катлогов должны содержать только символы латинского алфавита, цифры, тире, подчеркивания. Это нужно чтобы не было проблем с компиляцией и запуском программ.</p>

  <h4>1.2 Добавление пути в переменную PATH (12)</h4>

  <p>Когда в командной строке мы вводим название программы, то вначале поиск программы выполняется в текущем каталоге, а затем в путях, указанных в системной переменной PATH. Пути в системной переменной PATH просматриваются слева направо до первого вхождения искомого названия. Если в путях прописано несколько объектов с одинаковым названием, то выдаваться всегда будет один - только первый найденный объект.</p>
  <p>Чтобы  добавить объект в системную переменную PATH, необходимо открыть</p>
  <code>Параметры - Панель управления - Система и безопасность - Система - Дополнительные параметры системы</code>
  <p>В открывшемся окне <strong>Свойства системы</strong> выбрать</p>
  <code>Дополнительно - Переменные среды</code>
  <p>В открывшемся окне <strong>Переменные среды</strong> в списке <strong>Системные переменные</strong> выделяем строку с переменной <strong>Path</strong> и нажимаем кнопку <strong>Изменить</strong></p>

  <h4>1.4 Установка MinGW и MSYS (14)</h4>

  <p>Для преобразования текста программы в файле с расширением .c в исполняемый файл с расширением .exe потребуется установить компилятор. Мы установим беспратный компилятор gcc, входящий в состав популярной библиотеки MinGW. Установим ее в каталог</p>
  <code>c:\gcc</code>
  <p>Путь к компилятору gcc.exe и g++.exe пропишем в систмную переменную PATH</p>
  <code>c:\gcc\bin</code>
  <p>Если компилятор успешно установился и путь к нему прописан, то мы получим версию компилятора, если введем в командной строке команду</p>
  <code>gcc --version</code>
  <code>g++ --version</code>
</article>


<!-- 2 Первые шаги (44) -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>2 Первые шаги (44)</h3>

  <h4>2.1 Первая программа (44)</h4>

  <p>Напишем первую программу, которая выводит в консоль надпись Hello, world!</p>

  <details>
    <summary>Программа 1 (45)</summary>
<pre>
#include &lt;stdio.h&gt;

int main () {
  printf("Hello, world!");
  return 0;
}
</pre>
  </details>

  <p>Чтобы скомпилировать программу, нужно запустить компилятор и передать ему в качестве аргумента название файла. Наберем в терминале следующую команду</p>

  <code>gcc helloworld.c</code>

  <p>После компиляции, если нет ошибок, компилятор создаст исполняемый файл a.exe, который можно запустить командой</p>
  <code>./a</code>

  <p>В терминале получится результат работы программы</p>
  <code>Hello, world!</code>

  <h4>2.4 Добавление в проект заголовочного файла (50)</h4>

  <p>В программе могут быть заголовочные файлы. В заголовочных файлах указывают прототипы функций и различные объявления. Заголовочный файл имеет расширение .h</p>
  <p>Создадим файл helloworld.h</p>
<pre>
#ifndef HELLOWORLD_H_
#define HELLOWORLD_H_

#endif /* HELLOWORLD_H_ */
</pre>
  <p>Для того чтобы избежать повторное объявление идентификаторов, все прототипы и прочие объявления нужно вкладывать в блок #ifndef #endif.</p>
  <p>Второй способ избежать повторного объявления идентификаторов это указать директиву #pragma со значением once</p>
  <code>#pragma once</code>

  <h4>2.6 Структура программы (57)</h4>

<pre>
Подключение заголовочных файлов
Объявление глобальных переменных
Объявление функций
int main() {
  код функции
  return 0;
}
Определение функций
</pre>
  <p>В самом начале программы подключаются заголовочные файлы, в которых содержатся объявления идентификаторов без их реализации.</p>
  <p>Объявление переменной</p>
  <code>int x;</code>
  <p>Присвоение значения переменной при объявлении называется инициализацией переменной</p>
  <code>int x = 10;</code>
  <p>Если глобальной переменной не присвоено значение при объявлении, то она будет иметь значение 0. Если локальной переменной не присвоено значение, то она будет содержать мусор - данные оставшиеся в памяти от других программ.</p>
  <p>Объявление функции без ее реализации называется прототипом функции.</p>
  <code>int sum(int x, int y);</code>
  <p>В прототипе указывается тип возвращаемого значения, имя, тип и порядок аргументов функции. Имена аргументов можно писать, а можно и не писать. После прототипа функции нужно написать ее реализацию. После прототипа ставится точка с запятой ;.</p>
  <p>Прототип функции обычно пишут перед функцией main, чтобы функция main знала и могла использовать объявленные функции, а реализацию функции пишут после функции main.</p>
  <p>Реализация функции sum</p>
<pre>
int sum(int x, int y) {
  return x + y;
}
</pre>
  <p>Первая строка в реализации функции совпадает с прототипом. Но вместо точки с запятой ставятся фигурные скобки {} внутри которых находится код функции.</p>
  <p>Функция main имеет три прототипа</p>
  <code>int main(void);</code>
  <code>int main(int argc, char *argv[]);</code>
  <code>int main(int argc, char *argv[], char **penv);</code>
  <p>В первом прототипе значение void означает что функция не принимает параметров.</p>
  <p>Во втором прототипе параметр argc это количество строковых значений, переданных из командной сроки. Причем первое значение это имя программы, а остальные значения передаются через параметр argv</p>
  <p>В третьем прототипе параметр penv позволяет получить значения переменных окружения.</p>
  <p>Функция main при успешном выполнении должна возвращать 0. Вместо этого можно написать EXIT_SUCCESS, а при завершении с ошибкой EXIT_FAILURE. Для этого нужно подключить библиотеку stdlib, в которой определены две переменные</p>
<pre>
#include &lt;stdlib.h&gt;
#define EXIT_SUCCESS 0
#define EXIT_FAILURE 1
</pre>
  <code>return EXIT_SUCCESS;</code>

  <p>Программа вычисления суммы двух чисел.</p>

  <details>
    <summary>Программа 2 (62)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int x = 21;
int y = 85;

int sum(int, int);
void print(int);

int main() {
  int z = sum(x, y);
  print(z);

  return EXIT_SUCCESS;
}

int sum(int x, int y) {
  return x + y;
}

void print(int) {
  printf("%d", x);
}
</pre>
  </details>

  <p>Вынесем объявления функций в отдельный заголовочный файл</p>

  <details>
    <summary>Программа 3 (63)</summary>
    <p>Заголовочный файл 3sum.h</p>
<pre>
#ifndef SUM_H_
#define SUM_H_

int sum(int, int);
void print(int);

#endif
</pre>

  <p>Файл 3.c</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include "3sum.h"

int x = 21;
int y = 85;

int main() {
  int z = sum(x, y);
  print(z);

  return EXIT_SUCCESS;
}

int sum(int x, int y) {
  return x + y;
}

void print(int x) {
  printf("%d", x);
}
</pre>
  </details>

  <h4>Комментарии в программе (63)</h4>

  <p>Компилятор полностью игнорирует комментарии. Комментарии синтаксически бывают однострочные и многострочные.</p>
  <p>Чтобы закомментировать одну строку, нужно поставить курсор на эту строку и нажать Ctrl + /. Строка будет закомментирована однострочным комментарием. Чтобы закомментировать более одной строки, их нужно выделить и нажать Ctrl + /. Выделенные строки будут закомментированы однострочными комментариями.</p>
  <p>Многострочные комментарии не могут быть вложенные. Однострочные комментарии могут быть вложены друг в друга и в многострочные комментарии.</p>

  <h4>Вывод данных (65)</h4>

  <p>Печать одного символа putchar()</p>
  <code>putchar('w'); // w</code>
  <code>putchar('119'); // w</code>

  <p>Печать одной строки puts()</p>
  <code>puts("string"); // string</code>

  <p>Форматированная печать printf()</p>
  <code>printf("string\n"); // string</code>
  <code>printf("%d", 10); // 10</code>
  <code>printf("%s %d", "number", 10); // number 10</code>

  <p>Напишем индикатор выполнения процесса</p>

  <details>
    <summary>Программа 4 (70)</summary>
    <p>Версия из книги</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;

int main() {
  printf("... 0%%");
  for (int i = 5; i &lt; 101; i += 5) {
    Sleep(1000);
    printf("\r... %d%%", i);
    fflush(stdout);
  }
  printf("\n");

  return 0;
}
</pre>
  <p>Моя версия</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;

int main() {
  for (int i = 5; i &lt; 100; i += 5) {
    Sleep(200);
    printf("\r.    %d%%", i);
    Sleep(200);
    printf("\r..   %d%%", i += 5);
    Sleep(200);
    printf("\r...  %d%%", i += 5);
    Sleep(200);
    printf("\r.... %d%%", i += 5);
    fflush(stdout); // сброс буфера вывода
  }

  // держим консоль открытой
  printf("\nPress any key for continue");
  fflush(stdin); // сброс буфера ввода
  getchar();

  return 0;
}
</pre>
  </details>

  <h4>2.9 Ввод данных (71)</h4>

  <h4>2.9.1 Ввод одного символа (71)</h4>

  <p>Для ввод одного символа предназначена функция getchar()</p>
  <code>char ch = getchar();</code>

  <p>Полученный символ будет в кодировке консоли. По умолчанию кодировка консоли <strong>windows-866</strong>. Чтобы принимать русские буквы в кодировке <strong>windows-1251</strong>, необходимо сменить кодировку.</p>

  <details>
    <summary>Программа 5 (72)</summary>
    <p>Сохраним файл программы в кодировке <strong>Windows-1251</strong></p>

<pre>
#include &lt;stdio.h&gt;

int main() {
  puts("Введите символ");
  char ch = getchar();
  printf("%c", ch);

  return 0;
}
</pre>

    <p>Если русские буквы не выводятся, то сменим кодировку в консоли</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;locale.h&gt;

int main() {
  // смена кодировки консоли
  system("chcp 1251");
  setlocale(LC_ALL,"Russian_Russia.1251");

  puts("Введите символ");
  char ch = getchar();
  printf("%c", ch);

  return 0;
}
</pre>
  </details>

  <h4>2.9.2 Функция scanf() (72)</h4>

  <p>Для получения и автоматического преобразования данных в корректный тип предназначена функция scanf(). Введем число</p>
  <code>int x;</code>
  <code>scanf("%d", &x);</code>

  <p>При вводе строки, функция scanf() не производит никакой проверки длины строки, что может привести к переполнению буфера. Обязательно используйте ширину при использовании спецификатора строки. Введем строку, не превышающую 255 символов</p>
  <code>char str[256] = "";</code>
  <code>scanf("%255s", str);</code>

  <details>
    <summary>Программа 6 (73)</summary>
    <p>Сохраним файл программы в кодировке <strong>Windows-1251</strong></p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;locale.h&gt;

int main() {
  // смена кодировки консоли
  system("chcp 1251");
  setlocale(LC_ALL,"Russian_Russia.1251");

  puts("Введите строку (max 255 symbols)");
  char str[256] = "";
  scanf("%255s", str);
  printf("%s", str);

  // держим консоль открытой
  printf("\nPress any key for continue");
  fflush(stdin); // сброс буфера ввода
  getchar();

  return 0;
}
</pre>
  </details>

  <p>Суммирование двух введенных чисел. Функция scanf() возвращает количество успешных операций присваивания. Мы можем проверить, что если мы ожидаем число и присвоилось число, то это успешная операция присваивания.</p>
  <details>
    <summary>Программа 7 (73)</summary>
    <p>Сохраним файл программы в кодировке <strong>Windows-1251</strong></p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;locale.h&gt;

int main() {
  // смена кодировки
  system("chcp 1251");
  setlocale(LC_ALL,"Russian_Russia.1251");

  int x = 0, y = 0;

  puts("Введите первое число");
  if (scanf("%d", &x) != 1) {
    puts("Вы ввели не число");
    return 1;
  }

  puts("Введите второе число");
  if (scanf("%d", &y) != 1) {
    puts("Вы ввели не число");
    return 1;
  }

  printf("Сумма равна %d", x + y);

  return 0;
}
</pre>
  </details>

  <h4>2.9.3 Ввод строки (77)</h4>

  <p>Для ввода строки предназначена функция gets(), но применять ее в программе не следует, т.к. функция не производит никакой проверки длины строки, что может привести к переполнению буфера. Лучше получать строку посимвольно с помощью функции getchar() или воспользоваться функцией fgets(). Функция fgets() имеет прототип</p>
  <code>char *fgets(char *buf, int maxCount, FILE *stream);</code>
  <p>Функция fgets() принимает три параметра. Первый имя переменной куда запишет строку. Второй максимальная длина строки. Третий указатель на поток, откуда брать строку. Считывание происходит до первого символа перевода строки или конца файла или пока не будет прочитано maxCount-1 символов. Символ конца строки тоже запишется в буфер.</p>

  <details>
    <summary>Программа 8 (78)</summary>
    <p>Сохраним файл программы в кодировке <strong>Windows-1251</strong></p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;locale.h&gt;
#include &lt;string.h&gt;

int main() {
  // смена кодировки консоли
  system("chcp 1251");
  setlocale(LC_ALL,"Russian_Russia.1251");

  char buf[256] = "";
  char *p = NULL;

  puts("Введите строку (max 255 symbols)");
  p = fgets(buf, 256, stdin);
  if (p) {
    // удаляем символ перевода строки
    size_t len = strlen(buf);
    if (len != 0 && buf[len - 1] == '\n') {
      buf[len - 1] = '\0';
    }
    printf("%s", buf);
  } else {
    puts("Возникла ошибка");
  }

  return 0;
}
</pre>
  </details>

  <h4>2.10 Интерактивный ввод символов (80)</h4>

  <p>Функция getchar() получает символ только после нажатия клавиши Enter.</p>
  <p>В библиотеке conio.h есть две функции _getche() и _getch().</p>
  <p>Функция _getche() возвращает код символа. Она получает символ сразу после нажатия на клавишу и выводит его на экран.</p>
  <code>char ch = _getche();</code>
  <p>Функция _getch() возвращает код символа, но не выводит его на экран.</p>
  <code>char ch2 = _getch();</code>

  <h4>2.11 Получение данных из командной строки (82)</h4>

  <p>При вызове программы, после ее имени можно передать ей данные через пробел. Эти данные функция main() примет как аргументы.</p>
  <code>int main(int argc, char* argv[]) {}</code>
  <p>Параметр argc это количество принятых аргументов. Первый аргумент это всегда название файла с программой. Поэтому argc не может быть меньше 1. Второй аргумент содержит все переданные данные в виде массива строк.</p>

  <details>
    <summary>Программа 9 (83)</summary>
<pre>
#include &lt;stdio.h&gt;

int main(int argc, char* argv[]) {
  printf("argc = %d\n", argc);
  for (int i = 0; i &lt; argc; i++) {
    printf("%s\n", argv[i]);
  }

  return 0;
}
</pre>
  </details>

  <h4>2.12 Предотвращение закрытия окна консоли (84)</h4>

  <p>Чтобы окно консоли не закрылось, надо вставить инструкцию, ожидающую нажатие клавиши. Есть несколько способов сделать это.</p>
  <p>Первый способ. Подключить библиотеку conio.h и использовать функцию _getch().</p>

  <details>
    <summary>Программа 10 (84)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;

int main(int argc, char* argv[]) {
  printf("argc = %d\n", argc);
  for (int i = 0; i &lt; argc; i++) {
    printf("%s\n", argv[i]);
  }

  _getch();  // задержка окна консоли

  return 0;
}
</pre>
  </details>

  <p>Второй способ. Подключить библиотеку stdlib.h и использовать функцию system("pause").</p>

  <details>
    <summary>Программа 11 (85)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char* argv[]) {
  printf("argc = %d\n", argc);
  for (int i = 0; i &lt; argc; i++) {
    printf("%s\n", argv[i]);
  }

  system("pause");  // задержка окна консоли

  return 0;
}
</pre>
  </details>

  <p>Третий способ. Сбросить буфер ввода fflush(stdin) и использовать функцию getchar(). Консоль закроется после нажатия клавиши Enter.</p>

  <details>
    <summary>Программа 12 (85)</summary>
<pre>
#include &lt;stdio.h&gt;

int main(int argc, char* argv[]) {
  printf("argc = %d\n", argc);
  for (int i = 0; i &lt; argc; i++) {
    printf("%s\n", argv[i]);
  }

  fflush(stdin); // сброс буфера ввода
  getchar();  // задержка окна консоли

  return 0;
}
</pre>
  </details>

  <h4>2.13 Настройка отображения русских букв в консоли (86)</h4>

  <p>Если сохранить файл с программой в кодировке windows-1251, то русские буквы отображаться в консоли не будут. Причина в том, что по умолчанию в консоли используется кодировка windows-866. Кодировку можно сменить системной командой прямо из консоли</p>
  <code>chcp 1251</code>
  <p>Кодировку консоли можно изменить и внутри программы</p>
  <code>system("chcp 1251");</code>
  <p>Чтобы в программе настроить локаль (локальные настройки компьютера), нужно подключить библиотеку locale.h и использовать функцию setlocale()</p>
  <code>#include &lt;locale.h&gt;</code>
  <code>setlocale(LC_ALL, "Russian_Russia.1251");</code>
  <p>В функции setlocale первый аргумент это число от 0 до 5, указывающее категорию. Вместо чисел можно использовать константы LC_ALL, LC_COLLATE, LC_CTYPE, LC_MONETARY, LC_NUMERIC, LC_TIME. Второй аргумент это строка, содержащая название локали, после которого через точку указывается кодировка файла с программой. Русские буквы будут правильно отображаться вне зависимости от текущей кодировки.</p>

  <details>
    <summary>Программа 13 (88)</summary>
    <p>Сохраним файл программы в кодировке <strong>Windows-1251</strong></p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;locale.h&gt;

int main() {
  setlocale(LC_ALL, "Russian_Russia.1251");
  printf("Привет, мир!\n");

  return 0;
}
</pre>
  </details>

  <h4>2.14 Преждевременное завершение выполнения программы (89)</h4>

  <p>Подключим библиотеку stdlib.h и вызовем функцию exit().</p>

  <code>#include &lt;stdlib.h&gt;</code>

  <p>Для успешного завершения можно передать значение 0 или EXIT_SUCCESS.</p>
  <code>exit(0);</code>
  <code>exit(EXIT_SUCCESS);</code>

  <p>Для аварийного завершения можно передать значение 1 или EXIT_FAILURE.</p>
  <code>exit(0);</code>
  <code>exit(EXIT_SUCCESS);</code>

  <p>Для аварийного завершения можно также использовать функцию abort. В этом случае завершение программы осуществляется операционной системой с выводом диалогового окна.</p>
  <code>abort();</code>

  <p>Внутри функции main() для завершения программы лучше использовать инструкцию return. Если завершить программу нужно вне функции main, то в этом случае инструкция return не поможет.</p>
</article>


<!-- 3 Переменные и типы данных (91) -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>3 Переменные и типы данных (91)</h3>

  <p>Переменная это участок памяти для хранения данных. Каждой переменной присваивается имя, чтобы можно было обратиться к памяти для записи или чтения данных. Каждой переменной указывается тип, чтобы была выделена память подходящего размера. В одной переменной можно хранить только одно значение.</p>

  <h4>3.1 Объявление переменной (91)</h4>

  <p>Глобальные переменные объявляются вне функций и видны во всех функциях в файле.</p>
  <p>Локальные переменные объявляются внутри функции и видны только в той функции, в которой объявлены.</p>
  <p>В одной инструкции может быть объявлена одна или несколько переменных</p>
  <code>int x;</code>
  <code>int x, y, z;</code>

  <h4>3.2 Именование переменных (92)</h4>

  <h4>3.3 Типы данных (93)</h4>

  <p>В языке Си доступны следующие элементарные типы данных</p>
  <p>char символьный тип данных.</p>
  <p>int целое число со знаком</p>
  <p>float вещественное число</p>
  <p>double вещественное число двойной точности</p>
  <p>bool логический тип данных. Если он не доступен, подключите файл</p>
  <code>#include &lt;stdbool.h&gt;</code>

  <p>Перед целым типом можно указывать модификаторы</p>
  <p>signed целое число со знаком</p>
  <p>unsugned целое число без знака</p>
  <p>short целое число, занимает 2 байта</p>
  <p>long целое число, занимает 4 байта</p>
  <p>long long целое число, занимает 8 байт</p>
  <p>При использовании модификаторов, ключевое слово int можно писать, а можно и не писать.</p>

  <p>Перед типом double можно использовать следующие модификаторы</p>
  <p>long вещественное число, занимает 12 байт в 32 разрядных системах, занимает 16 байт в 64 разрядных системах.</p>
  <code>long double x = 8e+245L;</code>

  <h4>3.4 Целочисленные типы фиксированного размера (97)</h4>

  <p>В заголовочном файле stdint.h объявлены знаковые и беззнаковые целочисленные типы фиксированного размера:</p>
  <code>int8_t, uint8_t</code>
  <code>int16_t, uint16_t</code>
  <code>int32_t, uint32_t</code>
  <code>int64_t uint64_t</code>
  <p>Минимальные и максимальные значения этих типов можно получить используя константы:</p>
  <code>INT8_MIN, INT8_MAX, UINT8_MAX</code>
  <code>INT16_MIN, INT16_MAX, UINT16_MAX</code>
  <code>INT32_MIN, INT32_MAX, UINT32_MAX</code>
  <code>INT64_MIN, INT64_MAX, UINT64_MAX</code>

  <h4>3.5 Оператор sizeof и тип size_t (99)</h4>

  <p>В зависимости от архитектуры процессора, компилятор может выделять разный размер памяти для целых типов. Точный размер типа и переменной можно узнать оператором sizeof. Имя переменной можно писать в скобках, а можно и без них. Тип данных пишется только в скобках. Оператор sizeof возвращает значение типа size_t</p>
  <code>size_t a = sizeof x;</code>
  <code>size_t b = sizeof(x);</code>
  <code>size_t c = sizeof (int);</code>

  <p>Поскольку размер типа может быть очень огромным, например большие структуры или массивы, то обычно тип size_t равен самому большому беззнаковому целому типу uint64_t</p>

  <h4>3.6 Инициализация переменных (100)</h4>

  <p>Инициализация это присвоение начального значения переменной. Инициализацию можно сделать в одной инструкции вместе с объявлением переменной, или после объявления.</p>
  <code>int x =10;</code>
  <code>int y;</code>
  <code>y = 20;</code>

  <p>Глобальные переменные инициализируются один раз и автоматически получают значение 0. Локальные переменные инициализируются каждый раз при входе в функцию и получают неопределенное значение "мусор". Статические локальные переменные инициализируются один раз и автоматически получают значени 0 и сохраняют свое значение между вызовами функции.</p>

  <h4>3.7 Оператор typedef (100)</h4>

  <p>Оператор typedef позволяет создать псевдоним для существующего типа данных.</p>
  <code>typedef long long ll;</code>
  <code>ll x = 5L;</code>

  <p>После создания псевдонима его имя можно использовать при создании другого псевдонима</p>
  <code>typedef ll lint;</code>
  <code>lint y = 10L;</code>

  <p>Псевдонимы используются для создания машинно-независимых программ и часто используются в стандартной библиотеке. Например, тип size_t это псевдоним, его размер зависит от компилятора.</p>

  <h4>3.8 Константы (101)</h4>

  <p>Константа это переменная, объявленная с ключевым словом const. Значение константы задается только один раз при ее обявлении и не меняется во время работы программы. В названии константы принято использовать большие буквы.</p>
  <code>const int CX = 10;</code>

  <p>Второй способ объявить переменную с постоянным значением это директива #define. Константа, созданная с помощью директивы #define называется макроопределением или макросом. Но такую константу, все же, можно изменить прямо в программе. Если разопределить ее директивой #undef, а затем ее снова определить с тем же именем, но другим значением.</p>
  <code>#define PI 3.14</code>
  <code>#undef PI</code>
  <code>#define PI 3.14159</code>

  <p>Посмотрим значения встроенных макросов:</p>
  <ul>
    <li>__FILE__ имя файла</li>
    <li>__LINE__ номер текущей строки</li>
    <li>__DATE__ дата компиляции файла</li>
    <li>__TIME__ время компиляции файла</li>
  </ul>

  <details>
    <summary>Программа 14 (103)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  printf("FILE %s\n", __FILE__);
  printf("LINE %d\n", __LINE__);
  printf("DATE %s\n", __DATE__);
  printf("TIME %s\n", __TIME__);

  return 0;
}
</pre>
  </details>

  <h4>3.9 Спецификаторы хранения (104)</h4>

  <p>Перед модификатором и типом могут быть указаны спецификаторы.</p>
  <ol>
    <li>auto - автоматическая локальная переменная. Она создается при входе в блок и удаляется при выходе из блока. Практически не используется, потому что локальная переменная по умолчанию является автоматической,
      <code>auto int x = 10;</code>
    </li>
    <li>register - регистровая переменная. Это подсказка компилятору, что переменная будет часто использоваться и ее надо поместить в регистр. Применяется к локальным переменным и параметрам функции. Современные компиляторы просто игнорируют этот спецификатор. Раньше использовали для счетчиков в цикле.
      <code>register int i = 0;</code>
    </li>
    <li>extern - внешняя переменная. Сообщает компилятору что переменная объявлена в другом месте, например, в другом файле. При этом компилятор память под нее повторно не выделяет.
      <code>extern int x;</code>
    </li>
    <li>static - статическая переменная. Инициализация локальной статической переменной производится только один раз. Она не уничтожается при выходе из функции, а ее значение сохраняется между вызовами функции. Глобальная статическая переменная будет видна только в пределах одного файла.</li>
  </ol>

  <h4>3.10 Области видимости переменных (105)</h4>

  <p>Глобальная переменная - это переменная объявленная вне функций и видна сразу после ее объявления и во всех функциях. Она инициализируется один раз при объявлении. По умолчанию инициализируется нулем.</p>
  <p>Локальная переменная - это переменная объявленная внутри функции или блока ограниченного фигурными скобками. Локальная переменная видна только внутри функции или блока, где она объявлена. По умолчанию инициализируется "мусором" (значением в памяти, оставшимся после других программ).</p>

  <h4>3.11 Массивы (107)</h4>

  <p>Определим массив из трех элементов</p>
  <code>int arr[3] = {10, 20, 30};</code>
  <code>int arr[] = {10, 20, 30};</code>
  <p>После определения массива выделяется необходимый размер памяти, а в переменную записывается адрес первого элемента массива</p>
  <p>Определим размер массива из 3 элементов</p>
  <code>size_t razm = sizeof(int) * 3;</code>
  <p>Обратиться к элементам массива можно с помощью квадратных скобок, в которых указывается индекс элемента. При указании индекса внутри квадратных скобок производится вычисление адреса элемента массива относительно адреса первого элемента, который записан в переменной с именем массива.</p>
  <p>Массивы могут быть много мерными. Создадим двумерный массив</p>
  <code>int arr[2][4];</code>
  <p>Элементы двумерного массива располагаются в памяти друг за другом. Сначала элементы первой строки, затем второй и т.д. При инициализации двумерного массива, элементы каждой строки можно указать в фигурных скобках.</p>
  <code>int arr[2][4] = { {1,2,3,4}, {5,6,7,8} };</code>

  <h4>3.12 Строки (110)</h4>

  <p>Строка это массив символов, последний элемент которого содержит символ конца строки '\0'.</p>
  <p>Объявление строки без инициализации</p>
  <code>char str[7];</code>
  <p>Объявление и инициализация строки. При инициализации по-символьно, последним нужно указывать символ конца строки '\0'.</p>
  <code>char str[7] = {'s','t','r','i','n','g','\0'};</code>
  <p>При инициализации строкой используют двойные кавычки и пишут на 1 символ меньше. Потому что послений символ - символ конца строки '\0' будет добавлен автоматически.</p>
  <code>char str[7] = "string";</code>

  <h4>3.13 Указатели (111)</h4>

  <p>Указатель это переменная, которая предназначена для хранения адреса. Если при объявлении указателя, он никуда не должен указывать, то его инициализируют значением NULL.</p>
  <code>int *p = NULL;</code>
  <p>Чтобы присвоить указателю адрес переменной, тип данных указателя и переменной должны совпадать. Адресная арифметика использует тип данных указателя для рассчета адресов следующих подряд переменных.</p>
  <code>int x = 10;</code>
  <code>int *p1 = &amp;x;</code>
  <p>Указателю можно присвоить значение другого указателя. Их типы данных должны совпадать.</p>
  <code>int *p2 = p1;</code>
  <p>Помимо копирования адреса из указателя в указатель, можно создать указатель на указатель. Для этого при объявлении указывают два оператора звездочка</p>
  <code>int **p3 = NULL;</code>
  <code>p3 = &amp;p2;</code>
  <p>Указатель можно использовать при обращении к строке или элементам массива.</p>
  <p>Указатели можно использовать при передачи параметров в функцию. По умолчанию переменная в функцию передается <strong>по значению</strong>. Это значит, что создается копия значения переменной, сама же переменная вне функции остается неизменной. При передачи в функцию указателя, переменная на которую он указывает передается <strong>по ссылке</strong>. Значение такой перенной можно изменить внутри функции. Тогда вне функции она тоже изменится.</p>

  <h3>3.14 Динамическое выделение памяти (118)</h3>

  <p>При объявлении переменной указывается тип данных. При объявлении массива указывается тип данных и количество элементов. По этой информации компилятор выделяет необходимый размер памяти, который автоматически освобождается при завершении программы. Память, размер которой определяется компилятор и известен до начала программы, называется статическая. Изменить ее во время выполнения программы невозможно.</p>
  <p>Если размер массива заранее неизвестен, то используют динамическую память. Выделение и освобождение памяти осуществляется во время выполнения программы и заботиться об этом должен программист. Если память не освободить, то она становится недоступной и происходит "утечка" памяти.</p>

  <h4>Функции malloc() и free() (118)</h4>

<pre>
#include &lt;stdlib.h&gt;

const int SIZE = 10;
int *p = malloc(SIZE * sizeof(int));
</pre>

  <p>Библиотека stdlib.h содержит функцию malloc, которая принимает один аргумент - размер памяти в байтах и возвращает указатель типа void*. Если память выделить не удалось, возвращается указатель на NULL. Все элементы выделенной памяти до инициализации содержат мусор.</p>
  <p>В языке Си указатель типа void* автоматически неявно приводится к другому типу, поэтому использовать явное приведение не нужно. В языке C++ нужно обязательно выполнять явное приведение.</p>
  <p>Для освобождения динамической памяти, выделенной функцией malloc(), используют функцию free().</p>

  <h4>3.14.2 Функция calloc*() (119)</h4>

<pre>
#include &lt;stdlib.h&gt;

const int SIZE = 10;
int *p = calloc(SIZE, sizeof(int));
</pre>
  <p>Функция calloc() принимает два параметра - количество элементов и размер одного элемента и возвращает указатель типа void*. Если память выделить не удалось, возвращается указатель на NULL. Все элементы выделенной памяти автоматически инициализируются значением 0.</p>

  <h4>3.14.3 Функция realloc() (122)</h4>

<pre>
#include &lt;stdlib.h&gt;

const int SIZE = 10;
int *p = calloc(SIZE, sizeof(int));
const int SIZE2 = 100;
int *p2 = realloc(p, SIZE2 * sizeof(int));
</pre>

  <p>Функция realloc() выполняет перераспределение памяти. Она принимает два параметра - указатель на выделенную ранее память и размер новой памяти в байтах. Функция выделит новую память, скопирует в нее элементы из старой памяти, освободит старую память и вернет указатель на новую память. Если размер новой памяти больше чем старой, то новые элементы памяти будут содержать мусор. Если размер новой памяти меньше чем старой, то лишние элементы будут удалены. Если память не может быть выделена, то функция вернет указатель на NULL, при этом прежняя память не изменится</p>

  <h4>3.15 Структуры (123)</h4>

<pre>
struct Student {
  string name;
  int age;
};
</pre>

  <p>Структура - это совокупность переменных, объединенных под одним именем. Объявление структуры только описывает новый тип данных, а не определяет переменную, поэтому память под нее не выделяется.</p> <p>Чтобы объявить переменную, ее название указывается после закрывающей фигурной скобки при объявлении структуры. Допустимо не задавать имя структуры, если сразу объявляется имя переменной.</p>
<pre>
struct Point {
  int x;
  int y;
} p1;

struct {
  string name;
  int age;
} Vova;
</pre>

  <p>Также переменную структуры можно объявить отдельно от нее как и другие переменные, указав тип данных. При объявлении можно выполнить инициализацию переменной. При инициализации можно в списке указывать точку и название поля структуры.</p>
  <code>struct Point p2, p3;</code>
  <code>struct Point p2 = {10, 20};</code>
  <code>struct Point p2 = {.x = 10, .y = 20};</code>

  <p>При объявлении переменной типа структуры выделяется необходимый размер памяти. Для вычисления этого размера используют оператор sizeof.</p>
  <code>sizeof(p1);</code>

  <p>Одну структуру можно присвоить другой структуре, при этом копируются значения всех полей структуры. Структуры можно вкладывать в другие структуры. Адрес структуры можно сохранить в указателе с типом этой структуры.</p>
  <code>struct Point *p = &amp;p1;</code>

  <h4>3.16 Битовые поля (126)</h4>

  <p>Битовые поля это поля структуры, позволяющие в одной переменной хранить несколько значений, используя доступ к отдельным битам. При этом никакой экономии памяти не происходит, потому что минимальный размер битового поля соответствует типу int. Битовые поля объявляются только с типом int.</p>

<pre>
struct Bit {
  int a : 2; // размер в 2 бита
  int b : 4; // размер в 4 бита
};
</pre>

  <p>В одной структуре можно использовать одновременно битовые поля и обычные поля. Название битового поля можно не указывать. Если размер поля составляет 1 бит, то необходимо указать ключевое слово unsigned.</p>

  <h4>3.17 Объединения (127)</h4>

  <p>Объединение - это одна область памяти, используемая для хранения данных разных типов. В один момент времени в этой области могут храниться данные только одного типа. Размер объединения равен размеру самого большого типа.</p>

<pre>
union Num {
  int x;
  float y;
  double z;
};

union Num num1;
union Num num2 = {10};
union Num num3 = {.z = 1.2};
</pre>

  <h4>3.18 Перечисления (129)</h4>

<pre>
enum Color {
  RED, GREEN, BLUE, BLACK
} color1;
</pre>

  <h4>3.19 Приведение типов (130)</h4>

  <p>Если в выражении используются переменные разных типов, то тип результата выражения будет соответствовать более сложному типу.</p>
</article>


<!-- 4 Операторы и циклы (133) -->
<article class="article">
  <div class="anchor" id="p4"></div>
  <h3>4 Операторы и циклы (133)</h3>

  <h4>4.1 Математические операторы (133)</h4>

  <p>Деление целого числа на 0 вызовет ошибку. Деление вещественного числа на 0 вернет +INFINITY или -INFINITY (бесконечность). Деление вещественного числа 0.0 на 0.0 вернет значение NAN (нет числа).</p>

  <h4>4.2 Побитовые операторы (135)</h4>

  <p>Побитовые операторы предназначены для манипуляции отдельными битами и применяются только к целым числам.</p>

  <h4>4.3 Операторы присваивания (138)</h4>

  <p>Операторы присваивания предназначены для сохранения значения в переменной.</p>

  <h4>4.4 Оператор запятая (138)</h4>

  <p>Оператор запятая позволяет разместить сразу несколько выражений внутри одной инструкции. Результат вычисления последнего выражения можно присвоить переменной.</p>
  <code>int x, y;</code>
  <code>x = (y = 10, z = 20, y + z);</code>

  <h4>4.5 Операторы сравнения (139)</h4>

  <p>Операторы сравнения возвращают логический тип данных.</p>

  <h4>4.6 Приоритет выполнения операторов (141)</h4>

  <p>Все операторы имеют приоритет. Если в выражении более одного оператора, то сначала будут вычисляться выражения, в котором оператор имеет более высокий приоритет.</p>

  <h4>4.7 Оператор ветвления if (142)</h4>

  <p>Оператор ветвления позволяет выполнить отдельный блок программы, если выполняется некоторое условие. Условие в операторе if всегда автоматически преобразовывается в логический тип.</p>

  <h4>4.8 Тернарный оператор &: (146)</h4>

  <p>Если в зависимости от условия должно обязательно выполниться одно или другое действие, то можно использовать тернарный оператор &:. Присвоим переменной x единицу, если переменная y содержит четное число, иначе присвоим ноль.</p>
  <code>int x = y % 2 == 0 ? 1 : 0;</code>

  <h4>4.9 Оператор выбора switch (147)</h4>
</article>


<!-- 5 Числа (156) -->
<article class="article">
  <div class="anchor" id="p5"></div>
  <h3>5 Числа (156)</h3>

</article>


<!-- 6 Массивы (181) -->
<article class="article">
  <div class="anchor" id="p6"></div>
  <h3>6 Массивы (181)</h3>

</article>


<!-- 7 Символы и C-строки (206) -->
<article class="article">
  <div class="anchor" id="p7"></div>
  <h3>7 Символы и C-строки (206)</h3>

</article>


<!-- 8 Широкие символы и L-строки (244) -->
<article class="article">
  <div class="anchor" id="p8"></div>
  <h3>8 Широкие символы и L-строки (244)</h3>

</article>


<!-- 9 Работа с датой и временем (300) -->
<article class="article">
  <div class="anchor" id="p9"></div>
  <h3>9 Работа с датой и временем (300)</h3>

</article>


<!-- 10 Пользовательские функции (312) -->
<article class="article">
  <div class="anchor" id="p10"></div>
  <h3>10 Пользовательские функции (312)</h3>

</article>


<!-- 11 Обработка ошибок (336) -->
<article class="article">
  <div class="anchor" id="p11"></div>
  <h3>11 Обработка ошибок (336)</h3>

</article>


<!-- 12 Чтение и запись файлов (351) -->
<article class="article">
  <div class="anchor" id="p12"></div>
  <h3>12 Чтение и запись файлов (351)</h3>

</article>


<!-- 13 Низкоуровневые потоки ввода и вывода (374) -->
<article class="article">
  <div class="anchor" id="p13"></div>
  <h3>13 Низкоуровневые потоки ввода и вывода (374)</h3>

</article>


<!-- 14 Работа с файловой системой (386) -->
<article class="article">
  <div class="anchor" id="p14"></div>
  <h3>14 Работа с файловой системой (386)</h3>

</article>


<!-- 15 Потоки и процессы (407) -->
<article class="article">
  <div class="anchor" id="p15"></div>
  <h3>15 Потоки и процессы (407)</h3>

</article>


<!-- 16 Создание библиотек (430) -->
<article class="article">
  <div class="anchor" id="p16"></div>
  <h3>16 Создание библиотек (430)</h3>

</article>


<!-- 17 Прочее (448) -->
<article class="article">
  <div class="anchor" id="p17"></div>
  <h3>17 Прочее (448)</h3>

</article>

