<article class="article">
  <h1>2020 Прохоренок - Язык Си. Самое необходимое 480c</h1>
  <p>Конспект книги</p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
        <a href="#p1">1 Установка программ под Windows (11)</a>
    <br><a href="#p2">2 Первые шаги (44)</a>
    <br><a href="#p3">3 Переменные и типы данных (91)</a>
    <br><a href="#p4">4 Операторы и циклы (133)</a>
    <br><a href="#p5">5 Числа (156)</a>
    <br><a href="#p6">6 Массивы (181)</a>
    <br><a href="#p7">7 Символы и C-строки (206)</a>
    <br><a href="#p8">8 Широкие символы и L-строки (244)</a>
    <br><a href="#p9">9 Работа с датой и временем (300)</a>
    <br><a href="#p10">10 Пользовательские функции (312)</a>
    <br><a href="#p11">11 Обработка ошибок (336)</a>
    <br><a href="#p12">12 Чтение и запись файлов (351)</a>
    <br><a href="#p13">13 Низкоуровневые потоки ввода и вывода (374)</a>
    <br><a href="#p14">14 Работа с файловой системой (386)</a>
    <br><a href="#p15">15 Потоки и процессы (407)</a>
    <br><a href="#p16">16 Создание библиотек (430)</a>
    <br><a href="#p17">17 Прочее (448)</a>
  </p>
</article>


<!-- 1 Установка программ под Windows (11) -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>1 Установка программ под Windows (11)</h3>

  <p>Язык Си - это компилируемый язык высокого уровня. Это кроссплатформенный язык, позволяющий создавать программы, которые будут работать во всех операционных системах, но для каждой операционной системы компиляцию нужно проводить отдельно. В этой книге мы будем получать исполняемые exe-файлы с помощью компилятора gcc из состава популярной библиотеки MinGW-W64 для 64-битной операционной системы Windows.</p>
  <p>Существует несколько стандартов языка Си:</p>
  <code>C90, C99, C11.</code>
  <p>Чтобы использовать правила конкретного стандарта, при компиляции нужно указать флаги:</p>
  <code>-std=c90, -std=c99, -std=c11.</code>
  <p>Без этих флагов компилятор будет использовать последний стандарт. Узнать используемый стандарт языка Си внутри программы можно с помощью макроса __STDC_VERSION__</p>
  <code>printf("%ld\n", __STDC_VERSION__);</code>
  <p>Получить информацию о версии компилятора позволяет макрос __VERSION__</p>
  <code>printf("s\n", __VERSION__);</code>
  <p>Для комфортного программирования, имя компьютера, имена файлов и катлогов должны содержать только символы латинского алфавита, цифры, тире, подчеркивания. Это нужно чтобы не было проблем с компиляцией и запуском программ.</p>

  <h4>1.2 Добавление пути в переменную PATH (12)</h4>

  <p>Когда в командной строке мы вводим название программы, то вначале поиск программы выполняется в текущем каталоге, а затем в путях, указанных в системной переменной PATH. Пути в системной переменной PATH просматриваются слева направо до первого вхождения искомого названия. Если в путях прописано несколько объектов с одинаковым названием, то выдаваться всегда будет один - только первый найденный объект.</p>
  <p>Чтобы  добавить объект в системную переменную PATH, необходимо открыть</p>
  <code>Параметры - Панель управления - Система и безопасность - Система - Дополнительные параметры системы</code>
  <p>В открывшемся окне <strong>Свойства системы</strong> выбрать</p>
  <code>Дополнительно - Переменные среды</code>
  <p>В открывшемся окне <strong>Переменные среды</strong> в списке <strong>Системные переменные</strong> выделяем строку с переменной <strong>Path</strong> и нажимаем кнопку <strong>Изменить</strong></p>

  <h4>1.4 Установка MinGW и MSYS (14)</h4>

  <p>Для преобразования текста программы в файле с расширением .c в исполняемый файл с расширением .exe потребуется установить компилятор. Мы установим беспратный компилятор gcc, входящий в состав популярной библиотеки MinGW. Установим ее в каталог</p>
  <code>c:\gcc</code>
  <p>Путь к компилятору gcc.exe и g++.exe пропишем в систмную переменную PATH</p>
  <code>c:\gcc\bin</code>
  <p>Если компилятор успешно установился и путь к нему прописан, то мы получим версию компилятора, если введем в командной строке команду</p>
  <code>gcc --version</code>
  <code>g++ --version</code>
</article>


<!-- 2 Первые шаги (44) -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>2 Первые шаги (44)</h3>

  <h4>2.1 Первая программа (44)</h4>

  <p>Напишем первую программу, которая выводит в консоль надпись Hello, world!</p>

  <details>
    <summary>Программа 1 (45)</summary>
<pre>
#include &lt;stdio.h&gt;

int main () {
  printf("Hello, world!");
  return 0;
}
</pre>
  </details>

  <p>Чтобы скомпилировать программу, нужно запустить компилятор и передать ему в качестве аргумента название файла</p>

  <code>gcc helloworld.c</code>

  <h4>2.4 Добавление в проект заголовочного файла (50)</h4>

  <p>В программе могут быть заголовочные файлы. В заголовочных файлах указывают прототипы функций и различные объявления. Заголовочный файл имеет расширение .h</p>
  <p>Создадим файл helloworld.h</p>
<pre>
#ifndef HELLOWORLD_H_
#define HELLOWORLD_H_

#endif /* HELLOWORLD_H_ */
</pre>
  <p>Для того чтобы избежать повторное объявление идентификаторов, все прототипы и прочие объявления нужно вкладывать в блок #ifndef #endif.</p>
  <p>Второй способ избежать повторного объявления идентификаторов это указать директиву #pragma со значением once</p>
  <code>#pragma once</code>

  <h4>2.6 Структура программы (57)</h4>

<pre>
Подключение заголовочных файлов
Объявление глобальных переменных
Объявление функций
int main() {
  код функции
  return 0;
}
Определение функций
</pre>
  <p>В самом начале программы подключаются заголовочные файлы, в которых содержатся объявления идентификаторов без их реализации.</p>
  <p>Объявление переменной</p>
  <code>int x;</code>
  <p>Присвоение значения переменной при объявлении называется инициализацией переменной</p>
  <code>int x = 10;</code>
  <p>Если глобальной переменной не присвоено значение при объявлении, то она будет иметь значение 0. Если локальной переменной не присвоено значение, то она будет содержать мусор - данные оставшиеся в памяти от других программ.</p>
  <p>Объявление функции без ее реализации называется прототипом функции.</p>
  <code>int sum(int x, int y);</code>
  <p>В прототипе указывается тип возвращаемого значения, имя, тип и порядок аргументов функции. Имена аргументов можно писать, а можно и не писать. После прототипа функции нужно написать ее реализацию. После прототипа ставится точка с запятой ;.</p>
  <p>Прототип функции обычно пишут перед функцией main, чтобы функция main знала и могла использовать объявленные функции, а реализацию функции пишут после функции main.</p>
  <p>Реализация функции sum</p>
<pre>
int sum(int x, int y) {
  return x + y;
}
</pre>
  <p>Первая строка в реализации функции совпадает с прототипом. Но вместо точки с запятой ставятся фигурные скобки {} внутри которых находится код функции.</p>
  <p>Функция main имеет три прототипа</p>
  <code>int main(void);</code>
  <code>int main(int argc, char *argv[]);</code>
  <code>int main(int argc, char *argv[], char **penv);</code>
  <p>В первом прототипе значение void означает что функция не принимает параметров.</p>
  <p>Во втором прототипе параметр argc это количество строковых значений, переданных из командной сроки. Причем первое значение это имя программы, а остальные значения передаются через параметр argv</p>
  <p>В третьем прототипе параметр penv позволяет получить значения переменных окружения.</p>
  <p>Функция main при успешном выполнении должна возвращать 0. Вместо этого можно написать EXIT_SUCCESS, а при завершении с ошибкой EXIT_FAILURE. Для этого нужно подключить библиотеку stdlib, в которой определены две переменные</p>
<pre>
#include &lt;stdlib.h&gt;
#define EXIT_SUCCESS 0
#define EXIT_FAILURE 1
</pre>
  <code>return EXIT_SUCCESS;</code>
</article>


<!-- 3 Переменные и типы данных (91) -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>3 Переменные и типы данных (91)</h3>

</article>


<!-- 4 Операторы и циклы (133) -->
<article class="article">
  <div class="anchor" id="p4"></div>
  <h3>4 Операторы и циклы (133)</h3>

</article>


<!-- 5 Числа (156) -->
<article class="article">
  <div class="anchor" id="p5"></div>
  <h3>5 Числа (156)</h3>

</article>


<!-- 6 Массивы (181) -->
<article class="article">
  <div class="anchor" id="p6"></div>
  <h3>6 Массивы (181)</h3>

</article>


<!-- 7 Символы и C-строки (206) -->
<article class="article">
  <div class="anchor" id="p7"></div>
  <h3>7 Символы и C-строки (206)</h3>

</article>


<!-- 8 Широкие символы и L-строки (244) -->
<article class="article">
  <div class="anchor" id="p8"></div>
  <h3>8 Широкие символы и L-строки (244)</h3>

</article>


<!-- 9 Работа с датой и временем (300) -->
<article class="article">
  <div class="anchor" id="p9"></div>
  <h3>9 Работа с датой и временем (300)</h3>

</article>


<!-- 10 Пользовательские функции (312) -->
<article class="article">
  <div class="anchor" id="p10"></div>
  <h3>10 Пользовательские функции (312)</h3>

</article>


<!-- 11 Обработка ошибок (336) -->
<article class="article">
  <div class="anchor" id="p11"></div>
  <h3>11 Обработка ошибок (336)</h3>

</article>


<!-- 12 Чтение и запись файлов (351) -->
<article class="article">
  <div class="anchor" id="p12"></div>
  <h3>12 Чтение и запись файлов (351)</h3>

</article>


<!-- 13 Низкоуровневые потоки ввода и вывода (374) -->
<article class="article">
  <div class="anchor" id="p13"></div>
  <h3>13 Низкоуровневые потоки ввода и вывода (374)</h3>

</article>


<!-- 14 Работа с файловой системой (386) -->
<article class="article">
  <div class="anchor" id="p14"></div>
  <h3>14 Работа с файловой системой (386)</h3>

</article>


<!-- 15 Потоки и процессы (407) -->
<article class="article">
  <div class="anchor" id="p15"></div>
  <h3>15 Потоки и процессы (407)</h3>

</article>


<!-- 16 Создание библиотек (430) -->
<article class="article">
  <div class="anchor" id="p16"></div>
  <h3>16 Создание библиотек (430)</h3>

</article>


<!-- 17 Прочее (448) -->
<article class="article">
  <div class="anchor" id="p17"></div>
  <h3>17 Прочее (448)</h3>

</article>

