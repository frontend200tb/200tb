<article class="article">
  <h1>2020 Дейтел - Как программировать на C (7е). 1000c</h1>
  <p>Конспект книги</p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
    <a href="#p1">1 Введение в компьютеры, Internet и World Wide Web (21)</a>
    <br><a href="#p2">2 Введение в программирование на C (43)</a>
    <br><a href="#p3">3 Структурная разработка программ на C (71)</a>
    <br><a href="#p4">4 Управление программой в C (113)</a>
    <br><a href="#p5">5 Функции в C (153)</a>
    <br><a href="#p6">6 Массивы в C (207)</a>
    <br><a href="#p7">7 Указатели в C (263)</a>
    <br><a href="#p8">8 Символы и строки в C (320)</a>
    <br><a href="#p9">9 Форматированный ввод/вывод в C (364)</a>
    <br><a href="#p10">10 Структуры, объединения, перечисления и операции с битами в C (392)</a>
    <br><a href="#p11">11 Работа с файлами в C (426)</a>
    <br><a href="#p12">12 Структуры данных в C (461)</a>
    <br><a href="#p13">13 Препроцессор C (513)</a>
    <br><a href="#p14">14 Специальные вопросы языка C (524)</a>
    <br><a href="#p15">15 C++ как улучшенный C (545)</a>
    <br><a href="#p16">16 Введение в классы и объекты (576)</a>
    <br><a href="#p17">17 Классы: часть 1 (618)</a>
    <br><a href="#p18">18 Классы: часть 2 (654)</a>
    <br><a href="#p19">19 Перегрузка операций. Объекты Array и String (690)</a>
    <br><a href="#p20">20 ООП. Наследование (758)</a>
    <br><a href="#p21">21 ООП. Полиморфизм (810)</a>
    <br><a href="#p22">22 Шаблоны (866)</a>
    <br><a href="#p23">23 Потоковый ввод/вывод (885)</a>
    <br><a href="#p24">24 Управление исключениями (925)</a>
  </p>
</article>


<!-- 1 Введение в компьютеры, Internet и World Wide Web -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>1 Введение в компьютеры, Internet и World Wide Web (21)</h3>

  <h4>1.1 Введение (22)</h4>
  <h4>1.2 Что такое компьютер (23)</h4>
  <h4>1.3 Внутренняя организация компьютера (24)</h4>
  <h4>1.4 Персональные вычисления, распределенные вычисления и вычисления в модели клиент/сервер (25)</h4>
  <h4>1.5 Интернет и всемирная паутина (25)</h4>

  <h4>1.6 Машинные языки, языки ассемблера и языки высокого уровня (26)</h4>

  <p>Все языки разбиты на три категории</p>
  <ol>
    <li>Машинные языки</li>
    <li>Ассемблерные языки</li>
    <li>Языки высокого уровня</li>
  </ol>
  <p>Каждый компьютер может понимать только свой машинный язык, связанный с его архитектурой и аппаратурой. Машинные языки состоят из последовательностей единиц и нулей, которые являются командами на выполнение элементарных операций. Программы на машинных языках не переносимы на компьютеры с разной архитектурой и неудобны для восприятия человеком.</p>
  <p>Программирование на машинных языках тормозило развитие компьютерной техники, очень медленное и непосильное занятие для большинства программистов.</p>
  <p>Вместо последовательности чисел стали применяться англоязычные аббревиатуры, которые стали применяться  в языке ассемблера.</p>
  <p>Программисты стали писать на языке ассемблера, а специальные программы-трансляторы преобразовывали программы на машинный язык.</p>
  <p>С появлением языков ассемблера использование компьютеров значительно расширилось, однако все еще писалось большое количество кода для решения простейших задач. Для ускорения программирования были разработаны языки высокого уровня, в которых выполнение сложных действий заменялось одним оператором. Программисты стали писать на языках высокого уровня, а программы-компиляторы переводили написанное на машинный язык.</p>
  <p>Языки высокого уровня предпочтительнее чем ассемблерные и машинные языки.</p>

  <h4>1.7 История языка Си (27)</h4>

  <p>Язык Си берет свое начало от двух языков BCPL и B. В 1967 году Мартин Ричардс разработал BCPL как язык для написания системного ПО и компиляторов. В 1970 году Кен Томпсон использовал B для создания ранних версий ОС UNIX на компьютере DEC PDP-7. В языках BCPL и B переменные не разделялись на типы. Каждое значение данных занимало одно слово в памяти. Ответственность за различие целых и действительных чисел целиком ложилась на плечи программиста.</p>
  <p>Язык Си был разработан Денисом Ричи и реализован в 1972 году на компьютере DEC PDP-11.</p>

  <h4>1.8 Стандартная библиотека Си (28)</h4>

  <p>Есть два аспекта изучения языка. Первый - изучение непосредственно Си. Второй - умение пользоваться стандартной библиотекой. Не следует изобретать велосипед. Повторное использование кода это ключевой момент. При написании программы на языке Си вы будете использовать</p>
  <ol>
    <li>функции стандартной библиотеки Си</li>
    <li>функции, которые вы создадите сами</li>
    <li>Функции, написанные другими программистами</li>
  </ol>
  <p>Преимущества создания своих собственных функций - вы отлично значете и понимаете как они работают. Недостаток - затраты времени на создание новых функций.</p>

  <h4>1.9 C++</h4>

  <p>Язык C++ является надмножеством языка Си. Язык C++ разработал Бьерн Страуструп. В языке реализованы средства для ООП. В программном мире происходит революция. Быстрое, надежное, экономичное создание программ остается труднодостижимой целью. Применение ООП позволяет повысить производительность программистов.</p>

  <p>Сегодня наилучшей стратегией обучения будет освоение языка Си, а затем изучение C++.</p>

  <h4>1.10 Java</h4>

  <p>Родственным C и C++ является язык Java. Корпорация Sun Microsystems в 1991 году на основе C/C++ стали разрабатывать новый язык, которому его создатель Джеймс Гослинг дал имя Oak в честь дуба, который рос за окном его кабинета в Sun. Однако, оказалось, что уже есть компьютерный язык под названием Oak, тогда в местной кофейне предложили назвать язык Java и это название прижилось. Sun формально объявила о языке Java на торговой выставке в мае 1995 года.</p>

  <h4>1.11 Fortran, Cobol, Pascal и Ada (30)</h4>

  <p>В 1950-х годах корпорация IBM разработала Fortran (FORmula TRANslation) в качестве языка для научных и технических приложений, в которых требуются сложные математические вычисления.</p>
  <p>Ы 1959 году разработали язык Cobol (COmmon Business OrientedLanguage) для коммерческих прикладных программ в которых требовалась высокая точность при обработке большого количества данных.</p>
  <p>В 1960-е годы большие программные проекты сталкивались с трудностями. Сроки разработки затягивались, расходы значительно превышали бюджет, а продукты получались ненадежны. Это привело к структурному прошграммированию - упорядоченному подходу к написанию более ясных программ, которые легче тестировать, отлаживать и модифицировать чем неструктурнированные.</p>
  <p>В резуьтате, в 1971 году профессором Никласом Виртом был разработан язык Pascal, который предназначался как язык для обучения структурному программированию. В нем отсутствуют многие элементы для коммерческих, промышленных и административных приложений, поэтому он не получил широкого распространения.</p>
  <p>В начале 1980-х под эгидой министерства обороны США был создан язык Ada. Для создания огромной массы программных систем управлени и контроля МО использовались сотни различных языков. Хотелось иметь единственный язык, который удовлетворял бы всем нуждам. Важная особенность языка Ada - многозадачность, позволяющая выполнять действия параллельно. Многие языки, в том числе C/C++ однозадачны.</p>

  <h4>1.12 Basic, Visual Basic, Visual C++, C# и .NET (30)</h4>

  <p>В середине 1960-х годов был написан язык Basic (Beginner's All-Purpose Symbolic Instruction Code) для написания простых программ. Основной целью было ознакомить новичков с программированием.</p>
  <p>В 1991 году корпорация Microsoft представила язык Visual Basic для упрощения разработки приложений Microsoft Windows.</p>
  <p>Visual Basic .NET, Visual C++ .NET и C# были разработаны для новой программной платформы .NET от Microsoft.</p>

  <h4>1.13 Ключевая тенденция в программировании: объектная технология (31)</h4>

  <p>Язык C++ унаследовал все возможности языка Си, дополнив их средствами манипулирования объектами, заимствованными у Simula. Ни Си, ни C++ не предназначались для широкого использования вне стен лабораторий AT&T. Но очень быстро оба стали доступны для рядовых программистов.</p>
  <p>Мы живем в мире объектов. Машины, самолеты, люди, животные, здания... Программные языки (Fortran, Pascal, Basic, C) концентрировали внимание на действиях (глаголах), а не вещах или объектах (существительных). Объектные языки (C++, Java) позволяют программистам живущим в мире объектов писать программы с помощью объектов, что делает труд гораздо производительнее. Это порождает более понятные, лучше организованные программы, которые проще сопровождать, модифицировать и отлаживать. Это важно, так как 80% стоимости программного продукта связано с его сопровождением на протяжении долгих лет.</p>

  <h4>1.4 Схема типичной среды разработки Си (32)</h4>

  <p>Система среды разработки на языке Си состоит из трех частей</p>
  <ol>
    <li>Среда программирования</li>
    <li>Язык Си</li>
    <li>Стандартная библиотека</li>
  </ol>
  <p>Создание программы проходит через 6 стадий</p>
  <ol>
    <li>Написание кода в редакторе кода и сохранение его в файле с расширением .c</li>
    <li>Препроцессорная обработка. Когда вводится команда на компиляцию программы, первой выполняется программа препроцессора. Она выполняет все директив препроцессора, написанные в программе.Например, добавление файлов к коду программы, замена символов в тексте программы</li>
    <li>Компиляция. Компилятор преобразует программу в машинный язык и в результате сохраняет объектный код в файле с расширением .o</li>
    <li>Компоновка. В программах на языке Си содержатся обращения к функциям, определенным в стандартной библиотеке. Поэтому объектный код после работы компилятора содержит "дыры", обусловленные отсутствием определенных функций, к которым происходит обращение. Компоновщик связывает объектный код с определениями отсутствующих функций и результат сохраняет в файл с расширением .exe в котором уже нет отсутствующих частей.</li>
    <li>Загрузка. Перед выполнением программа должна быть размещена в памяти. Загрузчик помещает в память исполняемый код, также могут загружаться библиотеки не входящие в исполняемый код.</li>
    <li>Исполнение. Компьютер выполняет программу, последовательно прочитывая инструкции одна за другой</li>
  </ol>

  <p>Программы получают и выводят данные. Конкретные функции получают входные данные от stdin стандартный входной поток. Обычно это клавиатура, но stdin может быть подключен и к другому устройству. Вывод данных осуществляется на stdout стандартный выходной поток. Обычно это экран, но stdout также может быть подключен к другому устройству. Имеется еще один поток stderr стандартный поток ошибок.</p>

  <h4>1.15 Тенденции в области аппаратных средств (35)</h4>

  <p>Сообщество программистов процветает на волне непрерывного прогресса в технологиях оборудования, программного обеспечения и коммуникации. Каждый год возможности компьютеров, объемы памяти, быстродействие процессоров увеличиваются.</p>

  <h4>1.16 Общие замечания о Си и этой книге (36)</h4>

  <p>Хороший стиль программирования. Пишите программы в простой, четкой манере придерживаясь принципа KISS Keep It Simple.</p>
  <p>Совет по переносимости. Существует много проблем совместимости между разными версиями Си и разными компьютерами, что затрудняет достижение переносимости. Само по себе написание программ на Си не обеспечивает их переносимости.</p>
</article>


<!-- 2 Введение в программирование на C -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>2 Введение в программирование на C (43)</h3>

  <h4>2.1 Введение (44)</h4>

  <p>Далее будет рассматриваться структурное программирование на языке Си.</p>

  <h4>2.2 Простая программа на Си. Печать строки текста (44)</h4>

  <details>
    <summary>Программа 1 (44)</summary>
    <p>Печать строки текста.</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  printf("Welcome to C!\n");

  return 0;
}
</pre>
    <code>Welcome to C!</code>
  </details>

  <details>
    <summary>Программа 2 (47)</summary>
    <p>Печать в одну строку несколькими операторами printf.</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  printf("Welcome ");
  printf("to C!\n");

  return 0;
}
</pre>
    <code>Welcome to C!</code>
  </details>

  <details>
    <summary>Программа 3 (47)</summary>
    <p>Печать несколько строк одним оператором printf.</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  printf("Welcome\nto\nC!\n");

  return 0;
}
</pre>
<pre>
Welcome
to
C!
</pre>
  </details>

  <h4>2.3 Еще одна простая программа на Си. Сложение двух целых чисел (48)</h4>

  <details>
    <summary>Программа 4 (48)</summary>
    <p>Считать два числа оператором scanf, сложить их и вывести результат.</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int a;
  int b;
  int sum;

  printf("Enter first integer\n");
  scanf("%d", &a);

  printf("Enter second integer\n");
  scanf("%d", &b);

  sum = a + b;

  printf("Sum is %d\n", sum);

  return 0;
}
</pre>
<pre>
Enter first integer
5
Enter second integer
3
Sum is 8
</pre>
  </details>

  <h4>2.4 Общие понятия о памяти компьютера (53)</h4>

  <p>Имена переменных в действительности соответствуют ячейкам памяти. Когда присваивается значение переменной, то это значение сохранается в соответствующей ячейке памяти. При этом старое значение в этой ячейке памяти уничтожается.</p>

  <h4>2.5 Арифметика в Си (54)</h4>

  <h4>2.6 Принятие решений. Операции равенства и отношения (58)</h4>

  <details>
    <summary>Программа 5 (59)</summary>
    <p>Программа вызывает scanf чтобы считать два числа. Шесть операторов if сравнивают два введенных числа.</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int num1;
  int num2;

  printf("Enter two integers by space \n");
  scanf("%d %d", &num1, &num2);

  if (num1 == num2) {
    printf("%d is equal to %d\n", num1, num2);
  }

  if (num1 != num2) {
    printf("%d is not equal to %d\n", num1, num2);
  }

  if (num1 &lt; num2) {
    printf("%d is less than %d\n", num1, num2);
  }

  if (num1 > num2) {
    printf("%d is greater than %d\n", num1, num2);
  }

  if (num1 &lt;= num2) {
    printf("%d is less than or equal to %d\n", num1, num2);
  }

  if (num1 >= num2) {
    printf("%d is greater than or equal to %d\n", num1, num2);
  }

  return 0;
}
</pre>
  </details>
</article>


<!-- 3 Структурная разработка программ на C -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>3 Структурная разработка программ на C (71)</h3>

  <h4>3.1 Введение (72)</h4>

  <h4>3.2 Алгоритмы (72)</h4>

  <h4>3.3 Псевдокод (73)</h4>

  <p>Программы на псевдокоде не выполняются на компьютерах. Они помогают программисту продумывать программу перед написанием ее на языке программирования.</p>

  <h4>3.4 Управляющие структуры (74)</h4>

  <p>В 60-е годы последовательное выполнение программ, при котором оператор GOTO передавал управление по одному из возможных путей, сильно затрудняло программирование. В 70-е годы структурное программирование, также известное как программирование без GOTO, стало эпохальным девизом профессиональных программистов. Уменьшилось время разработки, программы стали более понятные, их проще отлаживать, модифицировать и в них меньше ошибок.</p>
  <p>Всего в языке Си семь типов управляющих структур. Три типа структуры выбора if, if else, switch. Три типа структур повторение for, while, do while. И, наконец, последовательное выполнение команд.</p>

  <h4>3.5 Оператор выбора if (76)</h4>

  <h4>3.6 Оператор выбора if else (77)</h4>

  <h4>3.7 Оператор повторения while (81)</h4>

  <h4>3.8 Формулирование алгоритмов: пример 1 (повторение, управляемое счетчиком) (82)</h4>

  <details>
    <summary>Программа 6 (83)</summary>
    <p>Программа подсчета средней оценки за экзамен десяти студентов.</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int counter = 1;
  int total = 0;
  int grade;
  int average;

  while (counter &lt;= 10) {
    printf("%s", "Enter grade ");
    scanf("%d", &grade);
    total += grade;
    counter++;
  }

  average = total / 10;
  printf("Average = %d", average);

  return 0;
}
</pre>
  </details>

  <h4>3.9 Формулирование алгоритмов методом нисходящего последовательного уточнения: пример 2 (повторение, управляемое контрольным значением) (84)</h4>

  <details>
    <summary>Программа 7 (88)</summary>
    <p>Программа подсчета средней оценки за экзамен. Число студентов заранее неизвестно.</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int counter = 0;
  int total = 0;
  int grade;
  float average;

  printf("%s", "Enter grade, -1 to end ");
  scanf("%d", &grade);

  while (grade != -1) {
    total += grade;
    counter++;
    printf("%s", "Enter grade, -1 to end ");
    scanf("%d", &grade);
  }

  if (counter != 0) {
    average = (float)total / counter;
    printf("Average = %.2f", average);
  } else {
    puts("No grades were entered");
  }

  return 0;
}
</pre>
  </details>

  <p>При делении двух целых чисел total / counter получается целое число. Унарная операция приведения типа (float)total создает для своего операнда total временную копию с плавающей точкой. Значение, хранимое в переменной total, по-прежнему является целым числом. Компилятор Си вычисляет выражение только с одинаковым типом операндов, поэтому встретив операнд типа float, он автоматически делает временную копию второго операнда и выполняет неявное преобразове в тип float. Вычисленный результат деления двух переменных типа float будет типа float и запишется в переменную average типа float.</p>

  <h4>3.10 Формулирование алгоритмов методом нисходящего последовательного уточнения: пример 3 (вложенные управляющие структуры) (91)</h4>

  <details>
    <summary>Программа 8 (94)</summary>
    <p>Студент после экзамена имеет результат 1, если сдал экзамен, и 0 если не сдал. Из 10 студентов подсчитать число сдавших и не сдавших экзамен. Если экзамен сдали больше 8 студентов, то премировать преподавателя.</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int passes = 0;
  int failures = 0;
  int student = 1;
  int result;

  while (student &lt;= 10) {
    printf("Enter result %d (0 or 1) ", student);
    scanf("%d", &result);

    if (result == 1) {
      passes++;
    } else {
      failures++;
    }

    student++;
  }

  printf("Passed %d\n", passes);
  printf("Failed %d\n", failures);

  if (passes > 8) {
    puts("Bonus to teacher");
  }

  return 0;
}
</pre>
  </details>

  <h4>3.11 Операции присваивания (95)</h4>

  <p>+=, -=, *=, /=, %=</p>

  <h4>3.12 Операции инкремента и декремента (96)</h4>

  <details>
    <summary>Программа 9 (97)</summary>
    <p>Студент после экзамена имеет результат 1, если сдал экзамен, и 0 если не сдал. Из 10 студентов подсчитать число сдавших и не сдавших экзамен. Если экзамен сдали больше 8 студентов, то премировать преподавателя.</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int c = 5;

  printf("c = %d\n", c);
  printf("c++ = %d\n", c++);
  printf("c = %d\n", c);
  printf("++c = %d\n", ++c);
  printf("c = %d\n", c);

  return 0;
}
</pre>
  </details>
</article>


<!-- 4 Управление программой в C -->
<article class="article">
  <div class="anchor" id="p4"></div>
  <h3>4 Управление программой в C (113)</h3>

  <h4>4.1 Введение (114)</h4>

  <h4>4.2 Основы структур повторения (114)</h4>

  <h4>4.3 Повторение, управляемое счетчикм (115)</h4>

  <p>Выведем числа от 1 до 10.</p>

  <details>
    <summary>Программа 10 (115)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int counter = 1;

  while (counter &lt;=10) {
    printf("%d ", counter);
    counter++;
  }

  return 0;
}
</pre>
  </details>

  <h4>4.4 Оператор повторения for (117)</h4>

  <p>Выведем числа от 1 до 10.</p>

  <details>
    <summary>Программа 11 (117)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int counter;

  for (counter = 1; counter &lt;=10; counter++) {
    printf("%d ", counter);
  }

  return 0;
}
</pre>
  </details>

  <h4>4.5 Оператор for. Замечания и рекомендации (119)</h4>

  <p>Сначала выполняется инициализация управляющей переменной (int i = 0), затем проверка условия (i != 10), затем выполняется тела цикла. После этого изменяется управляющая переменная (i++). Управляющую переменную можно изменять и в теле цикла, но это не рекомендуется из-за трудно уловимых ошибок в коде. Управляющую переменную можно как увеличивать так и уменьшать (i--). Шаг переменной может быть любым (i += 10).</p>

  <h4>4.6 Примеры структур for (120)</h4>

  <p>Найдем сумму всех четных чисел от 2 до 100.</p>

  <details>
    <summary>Программа 12 (121)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int sum = 0;

  for (int i = 2; i &lt;=100; i += 2) {
    sum += i;
  }

  printf("sum = %d", sum);

  return 0;
}
</pre>
  </details>

  <p>Задача. Клиент открыл в банке 5%-ый счет на 1000$. Предполагая, что вся прибыль остается на депозите счета, расчитайте и выведите сумму денег на счете на конец каждого года за 10 лет по формуле</p>
  <code>a = p * (1 + r)ⁿ</code>
  <p>где p - первоначальная сумма, r - годовая процентная ставка, n - число лет, a - сумма на депозите  на конец n-го года.</p>

  <details>
    <summary>Программа 13 (122)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main() {
  double amount; // сумма на счете
  double principal = 1000.0; // начальная сумма
  double rate = .05; // процентная ставка
  int year; // счетчик лет

  // вывести заголовки колонок таблицы
  printf("%4s%21s\n", "Year", "Amount on deposit");

  // вычислить сумму на счете для каждого из 10 лет
  for (year = 1; year &lt;=10; year++) {
    amount = principal * pow(1.0 + rate, year);
    printf("%4d%21.2f\n", year, amount);
  }

  return 0;
}
</pre>
  </details>

  <h4>4.7 Оператор множественного выбора switch (124)</h4>

  <p>Подсчитаем количество различных буквенных оценок, полученных студентами на экзамене.</p>

  <details>
    <summary>Программа 14 (124)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int grade; // одна оценка
  int aCount = 0; // число оценок A
  int bCount = 0; // число оценок B
  int cCount = 0; // число оценок C
  int dCount = 0; // число оценок D
  int fCount = 0; // число оценок F

  puts("Enter the letter grades (a,b,c,d,f)");
  puts("Enter the EOF for end");

  while ((grade = getchar()) != EOF) {
    switch (grade) {
      case 'A':
      case 'a':
        ++aCount;
        break;
      case 'B':
      case 'b':
        ++bCount;
        break;
      case 'C':
      case 'c':
        ++cCount;
        break;
      case 'D':
      case 'd':
        ++dCount;
        break;
      case "F":
      case 'f':
        ++fCount;
        break;
      case '\n':
      case '\t':
      case ' ':
        break;
      default:
        printf("%s is incorrect letter grade", grade);
        puts("Enter new grade");
        break;
    }
  }

  puts("\nTotal:\n");
  printf("A %d\n", aCount);
  printf("B %d\n", bCount);
  printf("C %d\n", cCount);
  printf("D %d\n", dCount);
  printf("F %d\n", fCount);

  return 0;
}
</pre>
  </details>

  <p>Для Windows EOF можно ввести нажав CTRL+z.</p>
  <p>Оператор switch проверяет переданное ему выражение на равенство <strong>константному целочисленному значению</strong>. Это просто целые значения, символьная константа, заключенная в одиночные кавычки, также равна целому значению.</p>

  <h4>4.8 Оператор повторения do...while (129)</h4>

  <p>Оператор while проверяет условие до выполнения тела цикла. Оператор do while проверяет условие после выполнения тела цикла. После конструкции while не ставится точка с запятой. После конструкции do while ставится точка с запятой.</p>

  <details>
    <summary>Программа 15 (130)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int counter = 1;

  do {
    printf("%d ", counter;)
  } while (++counter &lt;= 10);

  return 0;
}
</pre>
  </details>

  <h4>4.9 Операторы break и continue (131)</h4>

  <p>Оператор break немедленно выходит из структур for, while, do while, switch. Оператор continue пропускает оставшиеся операторы в структурах for, while, do while и переходит к проверке условия продолжения цикла, в операторе for выполняется приращение а затем проверяется условие повторения цикла.</p>

  <p>Использование оператора break в цикле for</p>

  <details>
    <summary>Программа 16 (131)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int x;

  for (x = 1; x &lt;= 10; x++) {
    if (x == 5) {
      break;
    }
    printf("%d ", x);
  }
  printf("\nBroke out of loop at x = %d", x);

  return 0;
}
</pre>
  </details>

  <p>Использование оператора continue в цикле for</p>

  <details>
    <summary>Программа 17 (132)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int x;

  for (x = 1; x &lt;= 10; x++) {
    if (x == 5) {
      continue;
    }
    printf("%d ", x);
  }
  puts("\nUsed continue to skip value 5");

  return 0;
}
</pre>
  </details>

  <h4>4.10 Логические операции (133)</h4>

  <p>Логическое И &&, логическое ИЛИ ||, логическое отрицание !.</p>

  <h4>4.11 Смешивание операций равенства (==) и присваивания (=) (136)</h4>

  <p>Ошибка написания оператора присваивания = вместо оператора равенства == очень частая и опасная. Эта ошибка не вызывает синтаксических ошибок при компиляции потому что присваивание так же возвращает значение как и сравнение. Однако программа выдает неверные результаты при выполнении.</p>

  <h4>4.12 Резюме структурного программирования (137)</h4>
</article>


<!-- 5 Функции в C -->
<article class="article">
  <div class="anchor" id="p5"></div>
  <h3>5 Функции в C (153)</h3>

  <h4>5.1 Введение (154)</h4>

  <p>Наилучшим способом разработки и поддержки больших программ является конструирование программы из небольших частей, модулей, с каждым из которых обращаться проще, чем со всей программой целиком.</p>

  <h4>5.2 Программные модули в Си (154)</h4>

  <p>Модули в Си называются функциями. Функции поставляются в составе стандатной библиотеки, а новые функции пишутся программистами. Освойте функции из стандартной библитеки и по возможности используйте их, чтобы не создавать точно такие же новые функции.</p>

  <h4>5.3 Функции математической библиотеки (155)</h4>

  <p>Описание математических функций содержатся в заголовочном файле math.h</p>

  <h4>5.4 Функции (157)</h4>

  <p>Написание кода в виде простых функций позволяет избежать дублирования кода. Каждая функция должна выполнять одну задачу, а имя функции должно отражать смысл данной задачи.</p>

  <h4>5.5 Определения функций (157)</h4>

  <p>Напишем функцию square для вычисления квадрата целых чисел от 1 до 10.</p>

  <details>
    <summary>Программа 18 (158)</summary>
<pre>
#include &lt;stdio.h&gt;

int square(int y);

int main() {
  int x;

  for (x = 1; x &lt;= 10; x++) {
    printf("%d ", square(x));
  }
  puts("");

  return 0;
}

int square(int y) {
  return y * y;
}
</pre>
  </details>

  <p>Напишем функцию maximum для определения и возврата наибольшего из трех целых чисел.</p>

  <details>
    <summary>Программа 19 (160)</summary>
<pre>
#include &lt;stdio.h&gt;

int maximum(int x, int y, int z);

int main() {
  int num1;
  int num2;
  int num3;

  printf("s", "Enter three integers: ");
  scanf("%d%d%d", &num1, &num2, &num3);

  printf("Maximum is %d ", maximum(num1, num2, num3));

  puts("");

  return 0;
}

int maximum(int x, int y, int z) {
  int max = x;

  if (y > max) {
    max = y;
  }
  if (z > max) {
    max = z;
  }
  return max;
}
</pre>
  </details>

  <h4>5.6 Прототипы функций (162)</h4>

  <p>Прототипы функций в языке Си были позаимствованы у разработчиков C++. Прототипы сообщают компилятору тип данных, возвращаемых функцией, число, тип и порядок следования параметров, получаемых функцией. Компилятор использует прототипы для проверки корректности обращения к функции.</p>
  <p>Ранние версии Си не выполняли такие проверки, неправильные вызовы функций не обнаруживались при компиляции и приводили к труднообнаружимым ошибкам во время выполнения программы.</p>
  <p>Включайте в программу прототипы всех функций чтобы воспользоваться преимуществом проверки типов.</p>
  <p>В прототипе пишутся только типы параметров и их порядок следования. Если в прототипе написать имена параметров, то компилятор игнорирует эти имена. В конце прототипа обязательно ставить точку с запятой.</p>
  <code>int square(int);</code>
  <code>int maximum(int, int, int);</code>

  <p>Прототип функции можно разместить вне любой функции или внутри функции. Прототип, размещенный вне любой функции, применяется ко всем вызовам функции внутри файла. Прототип, размещенный внутри функции, применяется только к вызовам из этой функции.</p>

  <h4>5.7 Стек вызовов и активационные записи (164)</h4>

  <p>Каждый раз, когда функция вызывает другую функцию, в стек заталкивается блок информации. Этот блок называется кадром стека или активационной записью. Она содержит адрес возврата, чтобы вызванная функция могла возвратиться в вызывающую функцию. Когда функция выполняет возврат, кадро стека для ее вызова выталкивается и управление передается адресу возврата в вытолкнутом кадре.</p>
  <p>Все локальные переменные функции должны существовать только во время выполнения функции. Но когда функция выполнится и возвращает выполнение вызывающей функции, ее локальные переменные должны исчезнуть. Кадр стека также резервирует память для таких локальных переменных функции.</p>
  <p>Компьютер выделяет ограниченный объем памяти для стека вызовов, поэтому если вызывается слишком много функций, то стек может не вместить все их активационные записи и происходит ошибка переполнения стека.</p>

  <h4>5.8 Заголовочные файлы (165)</h4>

  <p>Каждая стандартная библиотека имеет свой заголовочный файл, содержащий прототипы всех функций и определение различных типов данных и константа данной библиотеки</p>
  <p>При написании собственных функций, их прототипы можно включать в свой заголовочный файл с расширением .h, который затем подключать в нужные файлы своей программы.</p>
  <code>#include "maximum.h"</code>

  <h4>5.9 Вызов функций. Вызов по значению и вызов по ссылке (166)</h4>

  <p>Если аргумент передается по значению, то создается копия значения аргумента, с которой работает функция. При этом оригинальное значение переданной переменной не может измениться.</p>
  <p>Если аргумент передается по ссылке, то функция получает адрес переданной переменной и в процессе работы может записать в этот адрес любое другое значение. При этом оригинальное значение переданной переменной тоже изменится.</p>

  <h4>5.10 Генерация случайных чисел (166)</h4>

  <p>Функция rand() генерирует и возвращает случайное целое значение в диапазоне от 0 до RAND_MAX. Сама функция rand() и константа RAND_MAX определены в заголовочном файле stdlib.h. Присвоим целочисленной переменной случайное число</p>
  <code>int i = rand();</code>
  <p>Если нужно случайное число в диапазоне от 1 до 6, то можно применить операцию взятия по модулю и прибавить 1</p>
  <code>rand() % 6 + 1</code>

  <p>Напишем программу, которая 20 раз подбросит кубик с 6 гранями и выведет результат выпавшей грани на экран.</p>

  <details>
    <summary>Программа 20 (167)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
  for (int i = 1; i &lt;= 20; i++) {
    printf("%10d", rand() % 6 + 1);
    if (i % 5 == 0) {
      puts("");
    }
  }

  return 0;
}
</pre>
  </details>

  <p>Чтобы показать, что эти числа появляются приблизительно с равной вероятностью, смоделируем 6000 бросков. Каждое целое число от 1 до 6 должно выпасть приблизительно 1000 раз.</p>

  <details>
    <summary>Программа 21 (168)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
  int f1 = 0, f2 = 0, f3 = 0;
  int f4 = 0, f5 = 0, f6 = 0;
  int roll, face;

  for (roll = 1; roll &lt;= 6000; roll++) {
    face = rand() % 6 + 1;

    switch(face) {
      case 1: f1++; break;
      case 2: f2++; break;
      case 3: f3++; break;
      case 4: f4++; break;
      case 5: f5++; break;
      case 6: f6++; break;
    }
  }

  printf("%s%13s\n", "Face", "Frequency");
  printf("  1%13d\n", f1);
  printf("  2%13d\n", f2);
  printf("  3%13d\n", f3);
  printf("  4%13d\n", f4);
  printf("  5%13d\n", f5);
  printf("  6%13d\n", f6);

  return 0;
}
</pre>
  </details>

  <p>При каждом запуске программы, функция rand() дает одинаковый результат. На самом деле функция rand() возвращает определенную последовательность чисел. Каждая такая последовательность определяется семенем. По умолчанию семя равно 0. Но его можно изменить при помощи функции srand(). Тогда функция rand() будет возвращать другую последовательность, по одному числу в каждом вызове. Функция srand() получает в качестве аргумента значение типа unsigned.</p>
  <p>Напишем программу, которая при каждом вызове выдает разные результаты.</p>

  <details>
    <summary>Программа 22 (170)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
  unsigned seed;

  printf("Enter seed: ");
  scanf("%u", &seed);
  srand(seed);

  for (int i = 1; i &lt;= 10; i++) {
    printf("%10d", rand() % 6 + 1);
  }

  return 0;
}
</pre>
  </details>

  <p>Хорошая рандомизация получится если в качестве семени ввести показания системных часов.</p>
  <code>srand( time(NULL) );</code>
  <p>Функция time возвращает число секунд, прошедшее с 1 января 1970 года.</p>
  <p>Значение, генерируемые функцией rand всегда находятся в диапазоне</p>
  <code>0 ≤ rand() ≤ RAND_MAX</code>
  <p>Можно получить значения от 1 до 6</p>
  <code>face = 1 + rand() % 6;</code>
  <p>Чтобы получить нужный диапазон значений надо применить формулу</p>
  <code>n = a + rand() % b;</code>
  <p>где a это значение сдвига, b это коэффициент масштабирования.</p>

  <h4>5.11 Пример: стохастическая игра (172)</h4>

  <p>Напишем игру "Крепс". Игрок бросает две кости. Каждая кость имеет 6 граней с точками от 1 до 6. Вычисляется сумма точек на двух гранях повернутых вверх. Если сумма при первом броске равна 7 или 11, то победил игрок. Если сумма при первом броске равна 2, 3 или 12 то победило казино. Если сумма при первом броске равна 4, 5, 6, 8, 9 или 10 то эта сумма становится очком игрока. Чтобы выиграть нужно бросать кости до тех пор, пока не наберете свое очко еще раз. Если при очередном броске выпадает 7, то игрок проигрывает.</p>

  <details>
    <summary>Программа 23 (172)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

enum Status { CONTINUE, WON, LOST };

int rollDice();

int main() {
  int sum;
  int myPoint;
  enum Status gameStatus;
  srand( time(NULL) );
  sum = rollDice();

  switch (sum) {
    case 7:
    case 11:
      gameStatus = WON;
      break;
    case 2:
    case 3:
    case 12:
      gameStatus = LOST;
      break;
    default:
      gameStatus = CONTINUE;
      myPoint = sum;
      printf("Point is %d\n", myPoint);
      break;
  }

  while (gameStatus == CONTINUE) {
    sum = rollDice();
    if (sum == myPoint) {
      gameStatus = WON;
    } else {
      if (sum == 7) {
        gameStatus = LOST;
      }
    }
  }

  if (gameStatus == WON) {
    puts("Player wins");
  } else {
    puts("Player loses");
  }

  return 0;
}

int rollDice() {
  int die1;
  int die2;
  int workSum;

  die1 = 1 + rand() % 6;
  die2 = 1 + rand() % 6;
  workSum = die1 + die2;

  printf("Player rolled %d + %d = %d\n", die1, die2, workSum);

  return workSum;
}
</pre>
  </details>

  <h4>5.12 Классы памяти (175)</h4>

  <p>Язык Си поддерживает четыре класса памяти, обозначаемые спецификаторами класса памяти: auto, regidter, extern, static. Класс памяти определяет период хранения, область дейтсвия и тип компоновки. Классы памяти имеют все переменные и функции.</p>
  <p>Есть два периода хранения: автоматический и статический.</p>
  <p>Автоматический период хранения могут иметь только переменные. Переменные с автоматическим периодом хранения (auto и register) создаются, когда начинает выполняться блок в котором они определены и уничтожаются, когда программа выходит из этого блока.</p>
  <p>Все локальные переменные имеют автоматический период хранения по умолчанию, поэтому ключевое слово auto можно не использоваеть при их объявлении.</p>
  <p>Данные в программе на машинном языке для вычислений загружаются из памяти в регистры. Если часто используемые переменные создавать сразу в регистрах, то можно исключить затраты на загрузку переменных из памяти в регистры. Например, счетчик в цикле. Ключевое слово register рекомендует компилятору создавать переменную сразу в регистре. Обычно компиляторы игнорируют данную рекомендацию и размещают переменную как им удобно.</p>
  <p>Статический период хранения могут иметь переменные и функции. Для переменых и функций со статическим периодом хранения (extern и static) память распределяется и инициализируется один раз, когда программа запускается. Но это не означает, что они доступны во всей программе. Период хранения и область действия это разные вещи.</p>
  <p>Глобальные переменные и функции имеют по умолчанию класс памяти extern. Они создаются вне функций и сохраняют свои значения в течении всего времени выполнения программы. Обращение к глобальнымм переменным и функциям возможно из любого места после их объявления. По этой причине в начале файла всегда пишут прототипы функций. Нужно избегать использования глобальных переменных.</p>
  <p>Локальные переменные с классом памяти static известны только той функции в которой они определены, но сохраняют свое значение при выходе из функции.</p>
  <p>Все числовые переменные со статическим периодом хранения инициализируются нулем, если они явно не инициализируются программистом.</p>

  <h4>5.13 Правила области действия (178)</h4>

  <p>Есть четыре области действия: область действия функции, область действия файла, область действия блока, область действия прототипа функции.</p>
  <p>Область действия функции имеют только метки с двоеточием. Метки используются только в операторах switch и goto. Метки это подробности реализации, которые функции скрывают друг от друга</p>
  <p>Область действия файла имеет идентификатор, объявленый вне любой функции. Он действует с момента объявления и до конца файла. Глобальные переменные, определения функций и прототипы функций, помещенные вне функций имеют облать действия файла.</p>
  <p>Область действия блока имеют идентификаторы, определенные внутри блока. Локальные переменные, параметры функции имеют область действия блока</p>
  <p>Локальные переменные, объявленные как static, имеют область действия блока, но существуют во все время выполнения программы. В этом случае период хранения не совпадает с областью действия.</p>
  <p>Область действия прототипа функции имеют только идентификаторы, которые используются в списке параметров прототипа. Прототипы функций не требуют, чтобы в списке параметров стояли имена идентификаторов, прототипы требуют только их тип. Если в списке параметров прототипа используется имя, то компилятор его игнорирует. Поэтому имена параметров в прототипе функций могут встречаться в любом месте программы и это не вызовет конфликта имен.</p>
  <p>Нужно избегать дублирования имен переменных в программе.</p>

  <h4>5.14 Рекурсия (181)</h4>

  <p>Рекурсию можно использовать для определения факториала n!</p>
  <code>n*(n-1)*(n-2)* ... *2*1</code>
  <p>Базовым случаем будет</p>
  <code>1! = 1</code>
  <p>Рекурсивным определением функции будет</p>
  <code>n! = n * (n-1)!</code>

  <details>
    <summary>Программа 24 (183)</summary>
<pre>
#include &lt;stdio.h&gt;

long factorial(int);

int main() {
  for (int i = 0; i &lt;= 10; i++) {
    printf("%2d! = %ld\n", i, factorial(i));
  }

  return 0;
}

long factorial(int num) {
  if (num &lt;= 1) {
    return 1;
  } else {
    return num * factorial(num-1);
  }
}
</pre>
  </details>

  <h4>5.15 Пример применения рекурсии: числа Фибоначчи (185)</h4>

  <p>Числа Фибоначчи начинаются с 0 и 1, каждое следующее число это сумма двух предыдущих чисел.</p>
  <code>0 1 1 2 3 5 8 13 21 ...</code>
  <p>Числа Фибоначчи встречаются в природе, например описывают форму спирали. Отношения последовательных чисел Фибоначчи сходятся к значению константы 1,618... и назывваются золотым сечением.</p>

  <details>
    <summary>Программа 25 (185)</summary>
<pre>
#include &lt;stdio.h&gt;

long fibonacci(int);

int main() {
  long result;
  long number;

  printf("%s", "Enter an integer");
  scanf("%ld", &number);
  result = fibonacci(number);

  return 0;
}

long fibonacci(int n) {
  if (n == 0 || n == 1) {
    return n;
  } else {
    return fibonacci(n-1) + fibonacci(n-2);
  }
}
</pre>
  </details>

  <h4>5.16 Рекурсия в сравнении с итерацией (188)</h4>

  <p>Итерация завершается когда перестает выполняться условие продолжения цикла. Рекурсия завершается, когда выполняется базовый случай.</p>
  <p>Рекурсия имеет много отрицательных сторон. Она многократно инициирует механизм вызова функции. Это дорого стоит в плане процессорного времени и в плане расхода памяти. Итерация происходит в пределах функции, поэтому дополнительных расходов на вызовы функции и выделение памяти нет.</p>
  <p>Любая проблема, которая может быть решена рекурсивно, может быть решена и итеративно (без рекурсии). Рекурсивное решение проще для понимания и отладки.</p>

  <p>Стандарт ANSI не определяет порядок, в котором должны вычисляться значения операндов большинства операций. Порядок определен только в четырех операциях: логическое И "&&"",  логическое ИЛИ ""||", запятая ",", тернарный оператор "?:". В этих операциях порядок слева направо.</p>
</article>


<!-- 6 Массивы в C -->
<article class="article">
  <div class="anchor" id="p6"></div>
  <h3>6 Массивы в C (207)</h3>

  <h4>6.1 Введение (208)</h4>

  <p>Массив это группа соседних ячеек памяти, которые содержат элементы одного типа данных. Массивы это статические объекты, потому что их размер не изменяется. Списки, очереди, стеки и деревья это динамические объекты, потому что их размер можно увеличивать и уменьшать.</p>

  <h4>6.2 Массивы (208)</h4>

  <p>Для обращения к элементу массива, мы указываем имя массива и номер позиции элемента относительно начала массива. Номера позиций (индексы) элементов массива начинаются с 0.</p>

  <h4>6.3 Определение массивов (210)</h4>

  <h4>6.4 Примеры действий над массивами (210)</h4>

  <p>Определение массива и использование цикла для инициализации его элементов.</p>

  <details>
    <summary>Программа 26 (211)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int n[10];
  int i;

  for (i = 0; i &lt; 10; i++) {
    n[i] = 0;
  }

  printf("%s%13s\n", "Element", "Value");

  for (i = 0; i &lt; 10; i++) {
    printf("%7d%13d\n", i, n[i]);
  }

  return 0;
}
</pre>
  </details>

  <p>Инициализация массива в определении с помощью списка инициализации.</p>

  <details>
    <summary>Программа 27 (212)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int n[10] = {32, 27, 64, 18, 95, 14, 90, 70, 60, 37};
  int i;

  printf("%s%13s\n", "Element", "Value");

  for (i = 0; i &lt; 10; i++) {
    printf("%7d%13d\n", i, n[i]);
  }

  return 0;
}
</pre>
  </details>

  <p>Если инициализирующих значений меньше, чем элементов массива, то оставшиеся элементы автоматически инициализируются нулями. Массивы не инициализируются нулями автоматически, нужно инициализировать хотя бы один элемент, чтобы оставшиеся элементы были заполнены нулями автоматически.</p>

  <p>Инициализируем элементы массива четными числами от 2 до 20</p>

  <details>
    <summary>Программа 28 (213)</summary>
<pre>
#include &lt;stdio.h&gt;
#define SIZE 10

int main() {
  int n[SIZE];
  int i;

  for (i = 0; i &lt; SIZE; i++) {
    n[i] = 2 + 2 * i;
  }

  printf("%s%13s\n", "Element", "Value");

  for (i = 0; i &lt; SIZE; i++) {
    printf("%7d%13d\n", i, n[i]);
  }

  return 0;
}
</pre>
  </details>

  <p>Вычисление суммы элементов массива (215)</p>

  <details>
    <summary>Программа 29 (215)</summary>
<pre>
#include &lt;stdio.h&gt;
#define SIZE 12

int main() {
  int n[SIZE] = {1,3,5,4,7,2,99,16,45,67,89,45};
  int i;
  int total = 0;

  for (i = 0; i &lt; SIZE; i++) {
    total += n[i];
  }

  printf("Total is %d\n", total);

  return 0;
}
</pre>
  </details>

  <p>Задача. Сорок студентов попросили оценить качество питания в студенческой столовой по шкале от 1 до 10. Поместите 40 ответов в целочисленный массив и определите результат опроса.</p>

  <details>
    <summary>Программа 30 (216)</summary>
<pre>
#include &lt;stdio.h&gt;
#define RESPONSE_SIZE 40
#define FREQUENCY_SIZE 11

int main() {
  int answer;
  int raiting;

  int frequency[FREQUENCY_SIZE] = {0};
  int responses[RESPONSE_SIZE] = {1,2,6,4,8,5,9,7,8,10,1,6,3,8,6,10,3,8,2,7,6,5,7,6,8,6,7,5,6,6,5,6,7,5,6,4,8,6,8,10};

  for (answer = 0; answer &lt; RESPONSE_SIZE; answer++) {
    ++frequency[responses[answer]];
  }

  printf("%s%17s\n", "Raiting", "Frequency");

  for (raiting = 1; raiting &lt; FREQUENCY_SIZE; raiting++) {
    printf("%6%17d\n", raiting, frequensy[raiting]);
  }

  return 0;
}
</pre>
  </details>

  <p>Вывести элементы массива в виде гистограммы.</p>

  <details>
    <summary>Программа 31 (218)</summary>
<pre>
#include &lt;stdio.h&gt;
#define SIZE 10

int main() {
  int n[SIZE] = {19,3,15,7,11,9,13,5,17,1};

  printf("%s%13s%17s\n", "Element", "Value", "Histogram");

  for (int i = 0; i &lt; SIZE; i++) {
    printf("%7d%13d     ", i, n[i]);

    for (int j = 1; j &lt;= n[i]; j++) {
      printf("%c", '*');
    }

    puts("");
  }

  return 0;
}
</pre>
  </details>

  <p>Бросание игральной кости 6000 раз</p>

  <details>
    <summary>Программа 32 (219)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#define SIZE 7

int main() {
  int face;
  int roll;
  int frequency[SIZE] = {0};

  srand(time(NULL));

  for (roll = 1; roll &lt;= 6000; roll++) {
    face = 1 + rand() % 6;
    ++frequency[face];
  }

  printf("%s%17s\n", "Face", "Frequency");

  for (face = 1; face &lt; SIZE; face++) {
    printf("%4d%17d\n", face, frequency[face]);
  }

  return 0;
}
</pre>
  </details>

  <h4>Использование символьных массивов для хранения строк и действий над ними</h4>

  <p>Символьный массив может быть инициализирован строковым литералом.</p>
  <code>char string1[] = "first";</code>

  <p>Компилятор определяет размер массива исходя из длины строки. Строка "first" содержит пять символов и специальный символ окончания строки - нулевой символ '\0'. Все строки языка Си заканчиваются нулевым символом '\0'.</p>
  <p>Символьный массив может быть также инициализирован списком символьных констант.</p>
  <code>char string1[] = {'f', 'i', 'r', 's', 't', '\0'};</code>

  <p>Символьный массив можно ввести с помощью функции scanf() и спецификатора %s.</p>
  <code>char string2[20];</code>
  <code>scanf("%s", string2)</code>
  <code>printf("%s\n", string2);</code>
  <p>Создаем символьный массив на 19 символов и завершающий нулевой символ. Имя массива является адресом его начала в памяти, поэтому символ & перед ним не ставится.</p>
  <p>Программист должен следить за размером массива сам. Если пользователь введет больше символов, чем содержит символьный массив, переданный в функцию scanf(), то функция scanf() запишет информацию за пределы массива это может привести к потере других данных и ошибкам в программе.</p>
  <p>Функция printf(), также как и функция scanf(), не следит за размером массива, она будет выводить символы до тех пор, пока не встетит завершающий символ '\0'.</p>

  <p>Инициализация символьного массива строковым литералом, чтение строки в символьный массив, вывод символьного массива в виде строки и доступ к отдельным символам строки.</p>

  <details>
    <summary>Программа 33 (221)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char string1[20];
  char string2[] = "string literal";

  printf("Enter a string (less than 20 chars) ");
  scanf("%s", string1);

  printf("%s", "string1 is %s\nstring2 is %s\n", "string1 with spaces between characters is\n", string1, string2);

  for (int i = 0; string1[i] != '\0'; i++) {
    printf("%c", string1[i]);
  }

  puts("");

  return 0;
}
</pre>
  </details>

  <h4>Статические и автоматические локальные массивы</h4>

  <p>Статическая локальная переменная (объявленная со словом static внутри функции) существует всегда, но видна только в теле функции. Если локальный массив объявить как статический, он будет создан и проинициализирован один раз. Каждый раз при вызове функции массив не будет создаваться и потом уничтожаться. Это уменьшит время выполнения программы.</p>

  <p>Напишем две функции. Функция staticArrayInit с локальным статическим массивом. В ней массив создается один раз и сразу инициализируется нулями. Вызовем эту функцию дважды. Каждый вызов значения в массиве сохраняются после предыдущего вызова функциии. Функция automaticArrayInit с локальным автоматическим массивом. В ней массив создается при каждом вызове функции и инициализируется значениями 1, 2, 3. Вызываем эту функцию тоже дважды.</p>

  <details>
    <summary>Программа 34 (222)</summary>
<pre>
#include &lt;stdio.h&gt;

void staticArrayInit();
void automaticArrayInit();

int main() {
  puts("First call to each function ");
  staticArrayInit();
  automaticArrayInit();

  puts("Second call to each function ");
  staticArrayInit();
  automaticArrayInit();

  return 0;
}

void staticArrayInit() {
  static init array[3]; // {0, 0, 0}
  puts("Values on entering of static array ");
  for (int i = 0; i &lt; 3; i++) {
    printf("array[%d] = %d ", i, array[i]);
  }
  puts("Values on exiting of static array ");
  for (int i = 0; i &lt; 3; i++) {
    printf("array[%d] = %d ", i, array[i] += 5);
  }
}

void automaticArrayInit() {
  static init array[3] = {1, 2, 3}
  puts("Values on entering of automatic array ");
  for (int i = 0; i &lt; 3; i++) {
    printf("array[%d] = %d ", i, array[i]);
  }
  puts("Values on exiting of automatic array ");
  for (int i = 0; i &lt; 3; i++) {
    printf("array[%d] = %d ", i, array[i] += 5);
  }
}
</pre>
  </details>

  <h4>6.5 Передача массивов функциям (224)</h4>

  <p>Для передачи функции массива, нужно указать его имя. Также необходимо передавать размер массива отдельным параметром. Имя массива является адресом его первого элемента. Поэтому такая передача массива в функцию является передачей по ссылке. Функция в этом случае работает не с копиями значений, а с оригинальными элементами массива, находящимися по переданному адресу.</p>

  <p>Покажем что имя массива array и адрес его первого элемента &array[0] это одно и то же.</p>

  <details>
    <summary>Программа 35 (225)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char array[5];

  printf("array = %p\n", array);
  printf("&array = %p\n", &array);
  printf("&array[0] = %p\n", &array[0]);

  return 0;
}
</pre>
  </details>

  <p>Покажем что массив передается по ссылке, а отдельные элементы массива передаются по значению.</p>

  <details>
    <summary>Программа 36 (226)</summary>
<pre>
#include &lt;stdio.h&gt;
#define SIZE 5

void modifyArray(int [], int);
void modifyElement(int);

int main() {
  int a[SIZE] = {1, 2, 3, 4, 5};
  puts("Values of original array ");
  for (int i = 0; i &lt; SIZE; i++) {
    printf("%3d", a[i]);
  }
  puts("");

  modifyArray(a, SIZE);
  puts("Values of modified array ");
  for (int i = 0; i &lt; SIZE; i++) {
    printf("%3d", a[i]);
  }
  puts("");

  puts("Value of array element [3] ");
  printf("%d", a[3]);

  modifyElement(a[3]);
  puts("Value of modified element [3] ");
  printf("%d", a[3]);

  return 0;
}

void modifyArray(int b[], int size) {
  for (int i = 0; i &lt; size; i++) {
    b[i] *= 2;
  }
}

void modifyElement(int e) {
  e *= 2;
  printf("Value in modifyElement is %d", e);
}
</pre>
  </details>

  <p>Чтобы уберечь элементы массива от изменений, при передаче массива в функцию по ссылке, нужно использовать слово const.</p>
  <code>void change(const int array[], int size);</code>
  <p>Теперь любая попытка изменить элемент приведет к ошибке компиляции.</p>

  <details>
    <summary>Программа 37 (228)</summary>
<pre>
#include &lt;stdio.h&gt;

void tryToModifyArray(const int []);

int main() {
  int a[] = {10, 20, 30};
  printf("%d %d %d", a[0], a[1], a[2]);

  tryToModifyArray(a);
  printf("%d %d %d", a[0], a[1], a[2]);

  return 0;
}

void tryToModifyArray(const int b[]) {
  for (int i = 0; i &lt; size; i++) {
    b[i] *= 2; // ошибка компиляции
  }
}
</pre>
  </details>

  <h4>6.6 Сортировка массивов (229)</h4>

  <p>Напишем сортировку пузырьком массива из 10 целых чисел.</p>

  <details>
    <summary>Программа 38 (229)</summary>
<pre>
#include &lt;stdio.h&gt;
#define SIZE 10

int main() {
  int a[SIZE] = {2,6,4,8,10,12,89,68,45,37};
  int tmp;

  puts("Original order ");
  for (int i = 0; i &lt; SIZE; i++) {
    printf("%4d ", a[i]);
  }
  puts("");

  for (int i = 1; i &lt; SIZE; i++) {
    for (int j = 0; j &lt; SIZE - 1; j++) {
      if (a[j] > a[j+1]) {
        tmp = a[j];
        a[j] = a[j+1];
        a[j+1] = tmp;
      }
    }
  }

  puts("Ascending order ");
  for (int i = 0; i &lt; SIZE; i++) {
    printf("%4d ", a[i]);
  }

  return 0;
}
</pre>
  </details>

  <h4>6.7 Пример: вычисление среднего, медианы и наиболее вероятного значения массива (231)</h4>

  <details>
    <summary>Программа 39 (231)</summary>
<pre>
#include &lt;stdio.h&gt;
#define SIZE 99

void mean(const int []);
void median(int []);
void mode(int [], const int []);
void bubbleSort(int []);
void printArray(const int []);

int main() {
  int frequency[10] = {0};
  int response[SIZE] = {
    6,7,8,9,8,7,8,9,8,9,
    7,8,9,5,9,8,7,8,7,8,
    6,7,8,9,3,9,8,7,8,7,
    7,8,9,8,9,8,9,7,8,9,
    6,7,8,7,8,7,9,8,9,2,
    7,8,9,8,9,8,9,7,5,3,
    5,6,7,2,5,3,9,4,6,4,
    7,8,9,6,8,7,8,9,7,8,
    7,4,4,2,5,3,8,7,5,6,
    4,5,6,1,6,5,7,8,7
  }

  mean(response);
  median(response);
  mode(frequency, response);

  return 0;
}

// вычислить среднее значение
void mean(const int answer[]) {
  int total = 0;
  printf("%s\n%s\n%s\n", "********", "  Mean", "********");
  for (int i = 0; i &lt; SIZE; i++) {
    total += answer[i];
  }
  printf("Average is %d\n", total);
}

// вычислить медианный элемент
void median(int answer[]) {
  printf("%s\n%s\n%s\n", "********", "  Median", "********");
  puts("Unsorted array\n");
  printArray(answer);
  bubbleSort(answer);
  puts("Sorted array\n");
  printArray(answer);
  printf("Median is %d\n", answer[SIZE / 2]);
}

// определить наиболее частый отклик
void mode(int freq[], const int answer[]) {
  int raiting;
  int h;
  int largest = 0;
  int modeValue = 0;
  printf("%s\n%s\n%s\n", "********", "  Mode", "********");
  for (raiting = 1; raiting &lt;= 9; raiting++) {
    freq[raiting] = 0;
  }
  for (int i = 0; i &lt; SIZE; i++) {
    freq[answer[i]]++;
  }
  printf("%s%11s%19s\n\n%54s\n%54s\n\n",
         "Response", "Frequency", "Histogram",
         "1   1   2   2", "5   0   5   0   5");
  for (raiting = 1; raiting &lt;= 9; raining++) {
    printf("%8d%11d       ", raiting, freq[raiting]);
    if (freq[raiting] > largest) {
      largest = freq[raiting];
      modeValue = raiting;
    }
    for (h = 1; h &lt;= freq[raiting]; h++) {
      printf("%s", "*");
    }
    puts("");
    printf("Mode is %d occurred %d times\n", modeValue, largest);
  }
}

// пузырьковая сортировка
void bubbleSort(int a[]){
  int pass;
  int hold;
  for (pass = 1; pass &lt; SIZE; pass++){
    for (int i = 0; i &lt; SIZE - 1; i++) {
      if (a[i] > a[i + 1]) {
        hold = a[i];
        a[i] = a[i + 1];
        a[i + 1] = hold;
      }
    }
  }
}

// печать массива
void printArray(const int a[]) {
  for (int i = 0; i &lt; SIZE; i++) {
    if (i % 20 == 0) {
      puts("");
    }
    printf("%2d", a[i]);
  }
}
</pre>
  </details>

  <h4>6.8 Поиск в массивах (236)</h4>

  <h4>Линейный поиск</h4>

  <p>При линейном поиске сравнивают значения каждого элемента с ключом поиска. Алгоритм проводится на несортированном массиве.</p>

  <details>
    <summary>Программа 40 (236)</summary>
<pre>
#include &lt;stdio.h&gt;
#define SIZE 100

int linearSearch(const int [], int, int);

int main() {
  int a[SIZE];
  int key;
  int element;
  for (int i = 0; i &lt; SIZE; i++) {
    a[i] = 2 * i;
  }
  puts("Enter integer key ");
  scanf("%d", &key);
  element = linearSearch(a, key, SIZE);
  if (element != -1) {
    printf("Fount in element %d\n", element);
  } else {
    puts("Element not found");
  }

  return 0;
}

// линейнй поиск
int linearSearch(const int array[], int key, int size) {
  for (int i = 0; i &lt; size; i++) {
    if (array[i] == key) {
      return i;
    }
  }
  return -1;
}
</pre>
  </details>

  <h4>Двоичный поиск</h4>

  <p>При двоичном поиске после каждого сравнения исключается половина массива. Алгоритм проводится на сортированном массиве.</p>

  <details>
    <summary>Программа 41 (238)</summary>
<pre>
#include &lt;stdio.h&gt;
#define SIZE 15

int binarySearch(const int [], int, int, int);
void printHeader();
void printRow(const int [], int, int, int);

int main() {
  int a[SIZE];
  int key;
  int element;
  for (int i = 0; i &lt; SIZE; i++) {
    a[i] = 2 * i;
  }
  puts("Enter number from 0 to 28 ");
  scanf("%d", &key);
  printHeader();
  element = binarySearch(a, key, 0, SIZE - 1);
  if (element != -1) {
    printf("%d found in element %d\n", key, element);
  } else {
    printf("Element %d not found", key);
  }

  return 0;
}

// двоичный поиск
int binarySearch(const int b[], int key, int low, int high) {
  int middle;
  while (low &lt;= high) {
    middle = (low + high) / 2;
    printRow(b, low, middle, high);
    if (key == b[middle]) {
      return middle;
    } else if (key &lt; b[middle]) {
      high = middle - 1;
    } else {
      low = middle + 1;
    }
  }

  return -1;
}

// печать заголовка
void printHeader() {
  puts("\nSubscripts:");
  for (int i = 0; i &lt; SIZE; i++) {
    printf("%3d", i)
  }
  puts("";)
  for (int i = 0; i &lt; 4 * SIZE; i++) {
    printf("%s", "-");
  }
  puts("";)
}

// напечатать ряд массива
void printRow(const int b[], int low, int mid, int high) {
  for (int i = 0; i &lt; SIZE; i++) {
    if (i &lt; low || i > high) {
      printf("%s", "   ");
    } else if (i == mid) {
      printf("%3d", b[i]);
    } else {
      printf("%3d", b[i]);
    }
  }
  puts("";)
}
</pre>
  </details>

  <h4>6.9 Многомерные массивы (241)</h4>

  <p>Для работы с таблицами используют двумерные массивы. Каждую ячейку таблицы можно указать с помощью двух индексов: первый индекс указывает строку таблицы, второй индекс - столбец.</p>
  <p>Определим и инициализируем массив 2 на 2.</p>
  <code>int b[2][2] = { {1,2}, {3,4} };</code>
  <p>Если указывать не все значения, то последние в каждой строке инициализируются нулями</p>
  <code>int b[2][2] = { {1}, {3} }; // { {1,0}, {3,0}}</code>

  <details>
    <summary>Программа 42 (242)</summary>
<pre>
#include &lt;stdio.h&gt;

void printArray(const int [][3]);

int main() {
  int array1[2][3] = { {1,2,3}, {4,5,6} };
  int array1[2][3] = { 1, 2, 3, 4, 5, 6 };
  int array1[2][3] = { {1,2}, {4} };

  puts("array1");
  printArray(array1);

  puts("array2");
  printArray(array2);

  puts("array3");
  printArray(array3);

  return 0;
}

void printArray(const int a[][3]) {
  for (int i = 0; i &lt;= 1; i++) {
    for (int j = 0; j &lt;= 2; j++) {
      printf("%d", a[i][j]);
    }
  }
  puts("");
}
</pre>
  </details>

  <p>Все элементы многомерного массива хранятся в памяти последовательно , независимо от количества индексов. В двумерных массивах каждая строка является одномерным массивом.</p>
  <p>В следующей программе есть массив studentGrages размером 3 на 4. Каждая строка массива это студент, а каждый столбец это оценка за экзамен. Функция minimum() определяет самую низкую оценку. Функция maximum() - самую высокую. Функция average() для каждого студента определяет среднюю оценку.</p>

  <details>
    <summary>Программа 43 (245)</summary>
<pre>
#include &lt;stdio.h&gt;
#define STUDENTS 3
#define EXAMS 4

int minimum(const int [][EXAMS], int, int);
int maximum(const int [][EXAMS], int, int);
double average(const int [][EXAMS], int);
void printArray(const int [][EXAMS], int, int);

int main() {
  int student;
  const int studentGrades[STUDENTS][EXAMS] = {
    {77, 68, 86, 73},
    {96, 87, 89, 78},
    {70, 90, 86, 81}
  }

  puts("Array is");
  printArray(studentGrades, STUDENTS, EXAMS);

  printf("Lowest grade %d\n Highest grade %d\n",
    minimum(studentGrades, STUDENTS, EXAMS),
    maximum(studentGrades, STUDENTS, EXAMS),)

  for (student = 0; student &lt; STUDENTS, student++) {
    printf("Average for student %d is %d\n",
    student,
    average(studentGrades[student], EXAMS));
  }

  return 0;
}

int minimum(const int grades[][EXAMS], int pupils, int tests){
  int lowGrade = 100;
  for (int i = 0; i &lt; pupils; i++) {
    for (int j = 0; j &lt; tests; j++) {
      if (grades[i][j] &lt; lowGrade) {
        lowGrade = grades[i][j];
      }
    }
  }
  return lowGrade;
}

int maximum(const int grades[][EXAMS], int pupils, int tests){
  int highGrade = 0;
  for (int i = 0; i &lt; pupils; i++) {
    for (int j = 0; j &lt; tests; j++) {
      if (grades[i][j] > highGrade) {
        highGrade = grades[i][j];
      }
    }
  }
  return highGrade;
}

double average(const int setOfGrades[][EXAMS], int tests) {
  int total = 0;
  for (int i = 0; i &lt; tests; i++) {
    total += setOgGrades[i];
  }

  return (double)total / tests;
}

void printArray(const int grades[][EXAMS], int pupils, int tests) {
  printf("%s", "            [0]  [1]  [2]  [3]");
  for (int i = 0; i &lt; pupils; i++) {
    printf("\nstudentGrades[%d] ", i);
    for (int j = 0; j &lt; tests; j++) {
      printf("%-5d", grades[i][j]);
    }
  }
}
</pre>
  </details>

  <p>Двумерный массив это одномерный массив одномерных массивов. Имя одномерного массива является адресом этого массива в памяти.</p>
</article>


<!-- 7 Указатели в C -->
<article class="article">
  <div class="anchor" id="p7"></div>
  <h3>7 Указатели в C (263)</h3>
</article>


<!-- 8 Символы и строки в C -->
<article class="article">
  <div class="anchor" id="p8"></div>
  <h3>8 Символы и строки в C (320)</h3>
</article>


<!-- 9 Форматированный ввод/вывод в C -->
<article class="article">
  <div class="anchor" id="p9"></div>
  <h3>9 Форматированный ввод/вывод в C (364)</h3>
</article>


<!-- 10 Структуры, объединения, перечисления и операции с битами в C -->
<article class="article">
  <div class="anchor" id="p10"></div>
  <h3>10 Структуры, объединения, перечисления и операции с битами в C (392)</h3>
</article>


<!-- 11 Работа с файлами в C -->
<article class="article">
  <div class="anchor" id="p11"></div>
  <h3>11 Работа с файлами в C (426)</h3>
</article>


<!-- 12 Структуры данных в C -->
<article class="article">
  <div class="anchor" id="p12"></div>
  <h3>12 Структуры данных в C (461)</h3>
</article>


<!-- 13 Препроцессор C -->
<article class="article">
  <div class="anchor" id="p13"></div>
  <h3>13 Препроцессор C (513)</h3>
</article>


<!-- 14 Специальные вопросы языка C -->
<article class="article">
  <div class="anchor" id="p14"></div>
  <h3>14 Специальные вопросы языка C (524)</h3>
</article>


<!-- 15 C++ как улучшенный C -->
<article class="article">
  <div class="anchor" id="p15"></div>
  <h3>15 C++ как улучшенный C (545)</h3>
</article>


<!-- 16 Введение в классы и объекты -->
<article class="article">
  <div class="anchor" id="p16"></div>
  <h3>16 Введение в классы и объекты (576)</h3>
</article>


<!-- 17 Классы: часть 1 -->
<article class="article">
  <div class="anchor" id="p17"></div>
  <h3>17 Классы: часть 1 (618)</h3>
</article>


<!-- 18 Классы: часть 2 -->
<article class="article">
  <div class="anchor" id="p18"></div>
  <h3>18 Классы: часть 2 (654)</h3>
</article>


<!-- 19 Перегрузка операций. Объекты Array и String -->
<article class="article">
  <div class="anchor" id="p19"></div>
  <h3>19 Перегрузка операций. Объекты Array и String (690)</h3>
</article>


<!-- 20 ООП. Наследование -->
<article class="article">
  <div class="anchor" id="p20"></div>
  <h3>20 ООП. Наследование (758)</h3>
</article>


<!-- 21 ООП. Полиморфизм -->
<article class="article">
  <div class="anchor" id="p21"></div>
  <h3>21 ООП. Полиморфизм (810)</h3>
</article>


<!-- 22 Шаблоны -->
<article class="article">
  <div class="anchor" id="p22"></div>
  <h3>22 Шаблоны (866)</h3>
</article>


<!-- 23 Потоковый ввод/вывод -->
<article class="article">
  <div class="anchor" id="p23"></div>
  <h3>23 Потоковый ввод/вывод (885)</h3>
</article>


<!-- 24 Управление исключениями -->
<article class="article">
  <div class="anchor" id="p24"></div>
  <h3>24 Управление исключениями (925)</h3>
</article>

