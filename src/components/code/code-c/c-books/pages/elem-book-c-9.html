<article class="article">
  <h1>2015 Кузин - Программирование на языке Си. 144c</h1>
  <p>Конспект книги</p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
        <a href="#p1">1 Введение в программирование (5)</a>
    <br><a href="#p2">2 Основные понятия языка Си (10)</a>
    <br><a href="#p3">3 Простые операторы и программы с линейной структурой (23)</a>
    <br><a href="#p4">4 Основные алгоритмические структуры (36)</a>
    <br><a href="#p5">5 Операторы организации условных и безусловных переходов (41)</a>
    <br><a href="#p6">6 Операторы организации циклов (45)</a>
    <br><a href="#p7">7 Структурные типы данных (50)</a>
    <br><a href="#p8">8 Динамическая память и указатели (58)</a>
    <br><a href="#p9">9 Функции (68)</a>
    <br><a href="#p10">10 Структурный тип - строка (84)</a>
    <br><a href="#p11">11 Структурный тип - структура (94)</a>
    <br><a href="#p12">12 Структурные типы: битовые поля, объединения, перечислимый тип (108)</a>
    <br><a href="#p13">13 Структурный тип - файл (111)</a>
    <br><a href="#p14">14 Библиотеки и их использование (128)</a>
    <br><a href="#p15">15 Препроцессор языка Си (136)</a>
    <br><a href="#p16">16 Литература (139)</a>
  </p>
</article>


<!-- 1 Введение в программирование -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>1 Введение в программирование (5)</h3>

  <p>Это учебное пособие представляет собой начальный курс по программированию на языке высокого уровня Си.</p>

  <h4>1.1 Принцип программного управления (5)</h4>

  <p>В 1946 году Джон фон Нейман сформулировал принцыпы работы компьютеров. Один из них - принцип программного управления:</p>
  <ol>
    <li>Программа размещается в последовательных ячейках оперативной памяти вместе с обрабатываемыми данными</li>
    <li>Программа состоит из последовательных команд, каждыя из которых может код операции, адреса операндов и результата операции</li>
    <li>Каждая команда это операция, входящая в набор команд процессора</li>
    <li>Система команд процессора обязательно содержит арифметические операции, копирования, перемещения, ввода, вывода и окончания программы.</li>
    <li>Процессор выполняет команды, начиная с первой команды программы по порядку. Для изменения порядка выполнения команд используют условные и безусловные переходы.</li>
  </ol>
  <p>Программы хранятся во внешней памяти (на жестком диске). При запуске программы загружаются в оперативную память. Процессор, обращаясь к оперативной памяти, считывает команды одну за другой.</p>

  <h4>1.2 Понятие о языках программирования (6)</h4>

  <p>Различают естественные языки и формальные.</p>
  <p><strong>Естественные языки</strong> - языки общения людей. Смысл слови или фразы зависит от окружения, соседних слов и фраз. Сформулировать семантические правила практически невозможно.</p>
  <p><strong>Формальные языки</strong> - искусственные языки. Синтаксис и семантика со строгими правилами. Компьютеры понимают только формальные языки.</p>
  <p>Система команд процессора это машинный язык, который является формальным языком. Процессор понимает только машинный язык. Первые программы создавались на машинном языке. Каждая команда представляет собой длинны набор цифр, кодирующих название операции, адреса операндов и результата операции. В таких программах очень тяжело искать и исправлять ошибки.</p>
  <p>В процессе развития, появились языки высокого уровня, которые также являются формальными. Программа написанная на языке высокого уровня сначала проходит трансляцию в машинный код, который затем пожет быть выполнен процессором. Компилятор - программа, которая переводит текст программы на языке высокого уровня в машинные коды.</p>

  <h4>1.3 Язык Си (7)</h4>

  <p>Язык Си создан в начале 1970-х Дэннисом Ритчи. Язык Си разрабатывался для программирования в Unix. Unix была написана на языке ассемблера для PDP-7 и в 1971 году была перенесена на PDP-11. В 1973 году Unix была переписана на языке Си и стала первой операционной системой, написанной на языке высокого уровня. В 1983 году ANSI начал работу над стандартом языка Си, который появился в конце 1988 года. В 1983 году Бьерн Страуструп разработал язык C++, добавив в язык Си поддержку объектно-ориентированного программирования. В середине 1990-х фирма Borland разработала систему визуального программирования C++ Builder. Язык C++, лежащий в основе C++ Builder, более мощный, чем Object Pascal на котором построена Delphi. Библиотеки функций C++ намного обширней библиотек Object Pascal. Язык C# создан специально для платформы .NET и объединяет в себе сильные стороны языков C++ и Java. Программы на языке C# не требуют компиляции и, написанные один раз, работают на всех платформах, на которых есть интерпретатор .NET. Язык Objective C, построенный на основе языка Си, используется фирмой Apple для своих приложений. На языке Си часто пишут компиляторы, драйверы, операционные системы.</p>
  <p>Для разработки программ на языке Си можно использовать свободные среды разработки Code Blocks или Dev C++, последняя позвляет работать с графической библиотекой graphics.h. Основным средством разработки является Microsoft Visual Studio.</p>
</article>


<!-- 2 Основные понятия языка Си -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>2 Основные понятия языка Си (10)</h3>

  <h4>2.1 Алфавит языка (10)</h4>

  <p><strong>Алфавит языка</strong>Алфавит языка - это символы или группы символов, допустипые в языке Си. Алфавит языка Си является подмножеством множеста символов ASCII.</p>
  <p><strong>Ключевые слова</strong> - это имена объектов, зарезервированных для специального использования. Например, операторы или имена типов данных и т.д.</p>
  <p>Ключевые 36 слов стандарта ANSI языка Си:</p>
  <p>auto, break, case, const, char, continue, default, delete, do, else, double, if, enum, extern, float, for, goto, int, long, main, new, operator, register, return, short, signed, sizeof, static, struct, switch, typedef, typeid, union, unsigned, volatile, while</p>
  <p>В стандарте C++ к ним добавляются еще 14 ключевых слов:</p>
  <p>asm, catch, class, friend, inline, new, private, protected, public, template, this, throw, try, virtual</p>
  <p><strong>Идентификатор</strong> - имя переменной, константы, функции или другого объекта.</p>
  <p><strong>Комментарии</strong> - символы, которые игнорируются компилятором. Комментарии остаются в исходном тексте программы на языке Си. После комплияции они не попадают в машинный код программы. Однострочный комментарий начинается после символов // и заканчивается концом строки. Многострочный комментарий пишут между символами /* и */.</p>
  <p>Символы, не входящие в алфавит языка, могут использоваться только в символьных строках и комментариях.</p>

  <h4>2.2 Структура программы на языке Си (13)</h4>

  <p><strong>Препроцессор</strong> - это программа, которая обрабатывает текст программы до компилятора.</p>
  <p>Работой препроцессора управляют директивы. Директива начинается со знака # решетки и заканчивается концом строки. Точка с запятой в конце директивы не ставится.</p>
  <p><strong>Директива #define</strong> позволяет задать идентификатор и выражение. Заданный идентификатор будет заменен далее во всей программе на заданое выражение.</p>
  <p>Если в директиве #define определение занимает больше одной строки, то в конце строки ставится \ обратный слеш, а оставшуюся часть пишут с новой строки.</p>
  <p><strong>Директива #include</strong> включает в программу текст из указанного файла. Файл можно указать двумя способами. &lt;&lt;имя файла&gt;&gt; ищет файл в стандартной директории программирования. Так задаются заголовочные файлы библиотек. "имя файла" ищет файл в текущей директории. Так задаются файлы, которые мы пишем сами.</p>
  <p>Глобальные объекты - это переменные, объявленные вне функций, и все функции. Функции нельзя определять внутри других функций, поэтому они все являются глобальными. Глобальные объекты доступны из любого места программы после их объявления.</p>
  <p>Локальные объекты - это переменные, объявленные внутри функций. Локальные объекты доступны только в функции, в которой они объявлены. Они создаются в памяти при входе в функцию и уничтожаются при выходе из нее.</p>

  <h4>2.3 Объявления и типы данных (15)</h4>

  <h4>2.4 Операции и выражения (18)</h4>

  <p>Если в одном выражении должны выполняться несколько операторов, то они выполняются в порядке их приоритета. Порядок выполнения можно изменить используя круглые скобки (), потому что они имеют наивысший приоритет.</p>

  <p>Унарные операции имеют один операнд, бинарные - два, тернарные - три.</p>
</article>


<!-- 3 Простые операторы и программы с линейной структурой -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>3 Простые операторы и программы с линейной структурой (23)</h3>

  <h4>3.1 Оператор присваивания (23)</h4>

  <code>переменная = выражение;</code>
  <p>Сначала вычисляется выражение справа от оператора присваивания, результат преобразуется в тип переменной слева и записывается в нее.</p>
  <p>При многократном присваивании, присваивание происходит справа налево.</p>
  <code>a = b = c = 2 + 2;</code>
  <p>Если в выражении есть операция присваивания, то значение выражения равно значению которое присвоилось.</p>
  <code>a = (b = 5 + 5) + (c = 2 + 2); // a = 10 + 4</code>
  <p>Если в выражении есть операция запятая, то значение выражения равно значению после последней запятой</p>
  <code>a = (b = 5) , (c = 2) , (d = 3); // a = 3</code>

  <h4>3.2 Операторы ввода данных (24)</h4>

  <p>Функция getchar() считывает символ из стандартного потока ввода. Результат можно записать в переменную типа char или int. Символ считывается после нажатия клавиши Enter.</p>
  <code>char x = getchar();</code>
  <code>int x = getchar();</code>
  <p>Функция getch() считывает символ сразу после нажатия на клавишу, не надо дополнительно нажимать еще и Enter. Ее прототип находится в файле conio.h.</p>
  <code>char x = getch();</code>
  <p>Функция scanf() выполняет форматный ввод. Можно вводить данные любого типа. Первым аргументом функция принимает управляющую строку, которая автоматически преобразовывает введенные данные в заданный формат. Следующие аргументы это адреса, по которым записываются введенные данные.</p>
  <code>int a; scanf("%d", &a);</code>
  <p>Набранная последовательность символов накапливается в буфере клавиатуры и становится доступной программе только после нажатия Enter.</p>
  <p>Функция gets() считывает строку.</p>

  <h4>3.3 Операторы вывода данных (27)</h4>

  <p>Функция putchar() выводит один символ в стандартный поток вывода.</p>
  <code>putchar('a');</code>
  <p>Функция printf() выполняет форматный вывод. Можно выводить данные любого типа. Первым аргументом функция принимает управляющую строку, которая автоматически преобразовывает данные для вывода. Сделующие аргументы это данные, которые нужно вывести.</p>
  <code>printf("%d", 100);</code>
  <p>В управляющей строке определяется сколько всего аргументов и каковы их типы. Если аргументов больше, то лишние аргументы игнорируются.</p>
  <p>Функция puts() выводит строку.</p>

  <h4>3.4 Математические функции (31)</h4>

  <p>Перечислим некоторые функции из библиотеки math.h.</p>
  <ul>
    <li>abs() модуль целого числа</li>
    <li>fabs() модуль вещественного числа</li>
    <li>labs() модуль числа типа long</li>
    <li>cos() косинус</li>
    <li>sin() синус</li>
    <li>tan() тангенс</li>
    <li>acos() арккосинус</li>
    <li>asin() арксинус</li>
    <li>atan() арктангенс</li>
    <li>exp() экспоненциальная функция e<sup>x</sup></li>
    <li>sqrt() корень квадратный</li>
    <li>log() натуральный логарифм ln(x)</li>
    <li>log10() десятичный логарифм lg(x)</li>
    <li>pow(a, b) возведение числа a в степень b</li>
  </ul>
  <p>Перечислим некоторые константы из библиотеки math.h</p>
  <ul>
    <li>M_PI число pi</li>
    <li>M_PI_2 число pi / 2</li>
    <li>M_PI_4 число pi / 4</li>
    <li>M_E число e</li>
  </ul>

  <h4>3.5 Примеры программ с линейной структурой (32)</h4>

  <p>Откроем программу <strong>Visual Studio</strong>. Выберем пункт меню</p>
  <code>Файл - Создать - Проект Ctrl+Shift+N</code>
  <p>В открывшемся окне <strong>Создать проект</strong> выберем</p>
  <code>Консольное приложение Win32</code>
  <p>Зададим имя проекта и его расположение и нажмем OK.</p>
  <p>В открывшемся окне Мастер приложений Win32 выбираем Тип приложения - Консольное приложение. Остальные галочки снимаем и нажимаем Готово.</p>
  <p>Откроется окно с кодом нового проекта.</p>
</article>


<!-- 4 Основные алгоритмические структуры -->
<article class="article">
  <div class="anchor" id="p4"></div>
  <h3>4 Основные алгоритмические структуры (36)</h3>

  <h4>4.1 Построение блок-схем (36)</h4>

  <p>Блок схема состоит из блоков с действиями, которые соединены между собой стрелками, которые порядок действий.</p>
  <p>Выполнение алгоритма всегда начинается с блока Начало и заканчивается на блоке Конец.</p>
  <p>Ветвление выполняется с помощью проверки условия в блоке принятия решений. В результате проверки выбирается одна из двух стрелок, определяющих следующее действие.</p>
  <p>В блоке ввода-вывода ожидается ввод данных или вывод.</p>
  <p>В блоке обработки данных вычисляются выражения, присваиваются новые значения переменным и т.д.</p>

  <h4>4.2 Основные виды алгоритмических структур (37)</h4>

  <p>Алгоритмы используют три конструкции: линейные, ветвления, циклы.</p>
  <p>В линейной конструкции все действия выполняются строко один за другим независимо от входных данных и результатов предыдущих действий.</p>
  <p>В разветвленной конструкции следующее действие выбирается в зависимости от результата проверки условия. Ветвление может состоять из двух и более ветвей. В результате проверки условия может быть выбрана только одна ветвь для следующего действия.</p>
  <p>Циклическая конструкция повзоляет многократно выполнять однотипные действия. Циклы могут быть вложены один в другой. Цикл может быть</p>
  <ol>
    <li>конечным и бесконечным</li>
    <li>с предусловием и с постусловием</li>
    <li>с заранее известным числом повторений и не известным.</li>
  </ol>
</article>


<!-- 5 Операторы организации условных и безусловных переходов -->
<article class="article">
  <div class="anchor" id="p5"></div>
  <h3>5 Операторы организации условных и безусловных переходов (41)</h3>

  <h4>5.1 Условный оператор (41)</h4>

  <p>if-else это условные оператор. Если условие верно, то программа выполняет блок после оператора if. Если условие ложно, то программа выполняет блок после оператора else. Ветвь else может не писаться если в ней не выполняется никаких действий.</p>
  <p>Пустой оператор не выполняет никаких действий и обозначается ; точкой с запятой.</p>
  <p>Условные операторы являются вложенными, если один if содержит другой if. В этом случае else относится к ближайшему к ней if.</p>
  <p>Условный оператор можно записать в виде тернарной операции ?:.</p>

  <h4>5.2 Операторы безусловных переходов (42)</h4>

  <p>goto это оператор безусловного перехода к любому месту внутри функции.</p>
  <code>goto m;</code>
  <p>Выполнение программы продолжится с метки m.</p>
  <p>break это оператор безусловного перехода для выхода из цикла.</p>
  <p>continue это оператор безусловного перехода для перехода в начало цикла</p>

  <h4>5.3 Оператор выбора (43)</h4>

  <p>switch-case оператор выбора из нескольких альтернатив.</p>

  <h4>5.4 Пример программы с ветвящейся структурой (44)</h4>

  <p>Проверка правильности ввода значения x. Если x больше 0 и меньше 20, то вычисляется функция, содержащая переменную x.</p>
</article>


<!-- 6 Операторы организации циклов -->
<article class="article">
  <div class="anchor" id="p6"></div>
  <h3>6 Операторы организации циклов (45)</h3>

  <h4>6.1 Цикл for (45)</h4>

  <p>for это цикл с параметром. Управляющая переменная является параметром цикла. В начале она получает инициализацию, а в конце каждой итерации она получает приращение. Перед каждой итерацией цикла проверяется условие. Если условие истинно, то выполняется итерация, если ложно то закл заканчивается и выполняются операции после цикла.</p>
  <p>Если внутри цикла выполняется другой цикл, то такие циклы называются вложенными.</p>

  <h4>6.2 Цикл while (46)</h4>

  <p>while это итерационный цикл с предусловием. Сначала проверяется условие. Если условие истинно, то выполняется одно повторение цикла и снова проверяется условие. Если условие ложно, то цикл сразу прекращается.</p>

  <h4>6.3 Цикл do-while (47)</h4>

  <p>do-while это итерационный цикл с постусловием. Сначала выполняется одно повторение цикла, потом проверяется условие. Если условие истинно, то выполняется следующее повторение цикла и снова проверяется условие. Если условие ложно, то цикл сразу прекращается.</p>

  <h4>6.4 Примеры программ с циклическим алгоритмом (47)</h4>

  <p>Цикл с постусловием можно использовать для вводна исходного значения в программу. Условие проверяет первый раз введенные данные, если они некорректны, то данные нужно ввести снова. И так до тех пор пока данные не будут корректными.</p>
  <p>Цикл с параметром можно использовать чтобы вывести результат вычислений в табличном виде.</p>
</article>


<!-- 7 Структурные типы данных -->
<article class="article">
  <div class="anchor" id="p7"></div>
  <h3>7 Структурные типы данных (50)</h3>

  <h4>7.1 Понятие структурных типов данных. Структурный тип - массив (50)</h4>

  <p>Структурные типы данных представляют собой контейнеры для других типов данных. К структурным типам относятся массивы, структуры, объединения, перечисления, битовые поля. Массив содержит элементы одного типа и представляет удобный способ для их обработки.</p>
  <p>В языке Си различаются статические и динамические массивы. В статических массивах число элементов определяется на этапе компиляции и остается постоянным во время работы программы. Динамические массивы могут изменять количество своих элементов. Для работы с динамическими массивами используются указатели.</p>
  <p>Рассмотрим статический массив. Размер массива не может быть представлен переменной, а только константой, так как в период компиляции под него статически выделяется память. Под элементы массива выделяется непрерывный фрагмент памяти, в котором они располагаются один за другим. Имя массива без индексов является указателем-константой, т.е. адресом его первого элемента (с нулевым индексом).</p>

  <h4>Описание массивов и доступ к элементам массива (51)</h4>

  <p>Одномерный массив</p>
  <code>int nums[3];</code>
  <p>Двумерный массив представляет собой одномерный массив, элементы которого тоже массивы. Элементы двумерного массива хранятся в памяти последовательно по строкам</p>
  <code>int nums[3][2];</code>
  <p>При объявлении массива можно сразу его инициализировать</p>
  <code>int nums[3] = {2,4,8};</code>
  <code>int nums[3][3] = {1,2,3,4,5,6,7,8,9};</code>
  <code>int nums[3][3] = { {1,2,3}, {4,5,6}, {7,8,9} };</code>
  <p>При инициализации массива можно не указывать его размер. Компилятор сам определит его размер</p>
  <code>int nums[] = {1,2,3};</code>
  <p>Символьный массив можно инициализировать двумя способами: как обычный массив</p>
  <code>char ch[] = {'n', 'a', 'm', 'e'};</code>
  <p>или как строка. В этом случае в конец символьного массива добавляется символ конца строки '\0'.</p>
  <code>char str[] = "name";</code>
  <p>Обращаются к элементам массива по их индексу. Компилятор не отслеживает выход индекса за пределы массива, это должен отслеживать программист. При обращении к элементу массива, для которого не выделена память, мы получим значение другой переменной или мусора, оставшегося от предыдущего использования памяти. Использование чужой памяти приводит к потере элементов и других переменных в программе.</p>

  <h4>Обработка массивов (53)</h4>

  <p>Массиву нельзя присвоить новое значение. Работать можно только с элементами массива через их индексы. Элементу массива можно присвоить значение только того же типа. Чаще всего элементы массива обрабатываются в цикле.</p>

  <h4>Примеры работы с массивом (54)</h4>

  <p>1. Ввод элементов массива с клавиатуры</p>
<pre>
int x[5];
for (int i = 0; i &lt; 5; i++) {
  printf("Enter x[%d]", i);
  scanf("%d", &x[i]);
}
</pre>

  <p>2. Ввод элементов матрицы с клавиатуры. Внешний цикл изменяет индекс строки матрицы, внутренний - индекс столбца. Заполняется матрица построчно.</p>
<pre>
int y[5][7];
for (int i = 0; i &lt; 5; i++) {
  for (int j = 0; j &lt; 7; j++) {
    printf("Enter y[%d][%d]", i, j);
    scanf("%d", &y[i][j]);
  }
}
</pre>

  <p>3. Вывод элементов массива на экран</p>
<pre>
for (int i = 0; i &lt; 5; i++) {
  printf("x[%d] = %d", i, x[i]);
}
</pre>

  <p>4. Вывод элементов матрицы на экран</p>
<pre>
int y[5][7];
for (int i = 0; i &lt; 5; i++) {
  for (int j = 0; j &lt; 7; j++) {
    printf("y[%d][%d] = %d", i, j, y[i][j]);
  }
}
</pre>

  <p>5. Нахождение максимального значения в массиве</p>
<pre>
int x[5] = {3,5,-2,9,4};
int max = x[0];
for (int i = 1; i &lt; 5; i++) {
  if (x[i] > max) {
    max = x[i];
  }
}
</pre>
</article>


<!-- 8 Динамическая память и указатели -->
<article class="article">
  <div class="anchor" id="p8"></div>
  <h3>8 Динамическая память и указатели (58)</h3>

  <h4>8.1 Статическая и динамическая память (58)</h4>

  <p>Под статические структуры память выделяется до выполнения программы, а размер выделяемой памяти определяется размерами типа данных. Размер статической памяти не может изменяться во время выполнения программы. Статическая память освобождается при завершении программы. Преодолеть недостатки статической памяти можно использованием динамической памяти.</p>
  <p>Динамическая память способна полностью использовать физический объем оперативной памяти компьютера. Она выделяется и освобождается в процессе выполнения программы. Работают с динамической памятью с помощью типа данных - указателя (адреса). Указатель - это целое число.</p>
  <p>Каждый байт оперативной памяти имеет свой адрес (от 0 до размера оперативной памяти в байтах). Адрес состоит из двух частей: сегмента и смещения. Сегмент - это непрерывный участок оперативной памяти размером 64кб, начинающийся с адреса, кратного 16. Смещение указывает относительный адрес внутри сегмента.</p>
  <p>Оперативная память выделяется программе сегментами по 64кб. Выделенный участок памяти делится на три зоны:</p>
  <ol>
    <li><strong>сегмент кода</strong> - содержит машинный код программы</li>
    <li><strong>сегмента данных</strong> - содержит данные. Делится на две части: <strong>сегмент статических данных</strong> (глобальные переменные и константы), которые не изменяются в процессе работы и <strong>сегмент динамических данных</strong> (динамические структуры данных), который может увеличиваться и уменьшаться когда программа запрашивает дополнительную память или освобождает ее.</li>
    <li><strong>сегмент стека</strong> - содержит локальные переменные, параметры функций, сохраняемые регистры.</li>
  </ol>
  <p>Дополнительно могут существовать вспомогательные сегменты.</p>
  <p>Размер выделяемой памяти и тип указателей(near, far, huge) зависит от используемой модели памяти:</p>
  <ol>
    <li>tiny - минимальная из моделей. Общий размер памяти 64кб для кода, данных и стека. Все указатели ближние (near - 16 бит)</li>
    <li>small. Общий размер памяти 128кб. 64кб памяти для кода и 64кб памяти для данных и стека. Все указатели ближние (near - 16 бит)</li>
    <li>medium. Общий размер памяти до 1мб. Для кода используются дальные указатели (far - 32 бита). Для данных и стека объем памяти ограничен 64кб, используются ближние указатели.</li>
    <li>compact. Общий размер памяти до 1мб. Для кода объем памяти ограничен 64кб, используются ближние указатели. Для данных и стека используются дальные указатели (far - 32 бита).</li>
    <li>large. Нет ограничения на размер памяти. Для кода и данных используются дальные указатели.</li>
    <li>huge. То же что и large, но отсутствует ограничение памяти под статические данные. В остальных моделях под статические данные ограничение памяти 64кб.</li>
  </ol>
  <p>Модель памяти устанавливается соответствующей опцией в среде программирования.</p>

  <h4>8.2 Тип данных - указатель (60)</h4>

  <p>Каждая объявленная переменная получает адрес ячейки в памяти, который является неотъемлемой частью переменной. Укзатель это переменная, имеющая свой адрес ячейки памяти, содержащая адрес другой ячейки памяти, в которой может быть любой уже объявленный объект. Если объект имеет длину более одного байта, то указатель указывает на начало, на первый байт в памяти. Через указатель можно обращаться к объекту.</p>
  <p>Указатели, как и другие переменные, могут объединяться в массивы.</p>
  <p>После объявления указателя, его надо инициализировать до первого обращения к нему, иначе это приведет к ошибке. Можно инициализировать значением NULL.</p>

  <h4>8.3 Операции с указателем (61)</h4>

  <ol>
    <li>Присваивание. Указателю можно присвоить значение указателя того же типа или значение NULL
      <p>int *p1, *p2;</p>
      <code>p1 = p2;</code>
      <code>p1 = NULL;</code>
    </li>
    <li>Разименование - взятие значения по адресу. По указателю можно обратиться к значению
      <code>int i, *pi;</code>
      <code>*pi = 7;</code>
      <code>i = *pi;</code>
    </li>
    <li>Взятие адреса. В указатель можно записать адрес переменной
      <code>pi = &i;</code>
    </li>
    <li>Сложение, вычитание. Можно прибавлять к указателю целое число (количество элементов того же типа что и указатель), вычитать из указателя целое число, вычитать из указателя указатель. Эти действия имеют смысл только для указателей на элементы одного массива.</li>
    <li>Инкремент, декремент. Операция * разименования и операции ++, -- имеют одинаковый приоритет и выполняются справа налево
<pre>
int i = 5;
int *pi = i;
*pi++;
</pre>
      <p>Сначала изменится значение указателя pi, он будет указывать на следующий элемент типа int. Знчение переменной i = 5 никак не изменится.</p>
<pre>
int i = 5;
int *pi = i;
(*pi)++;
</pre>
      <p>Сначала изменится значение переменной i = 6, потом изменится значение указателя pi, он будет указывать на следующий элемент типа int.</p>
    </li>
    <li>Сравнение. Сравнивать указатели допустимо только одного типа или со значением NULL.</li>
  </ol>

  <h4>8.4 Функции динамического распределения памяти (63)</h4>

  <p>В заголовочном файле stdlib.h определены функции для динамического выделения памяти malloc, calloc, realloc. Эти функции возвращают адрес начала выделенного участка памяти или NULL если память выделить нельзя. Тип возвращаемого значения указатель void*. Этот тип нужно явно преобразовать к указателю нужного типа с помощью операции приведения типов.</p>
  <p>Функция free освобождает память, выделенную ранее функциями malloc, calloc, realloc.</p>
  <code>void* malloc(unsigned n);</code>
  <p>Выделяет n байт памяти.</p>
  <code>void* calloc(unsigned m, unsigned n);</code>
  <p>Выделяет и обнуляет память для m элементов по n байт каждый.</p>
  <code>void* realloc(void* p, unsigned n);</code>
  <p>Изменяет размер блока ранее выделенной памяти до размера n байт. p - адрес начала изменяемого блока. Если p = NULL (память не выделялась), то работает как malloc.</p>
  <code>void* free(void* p);</code>
  <p>Освобождает (возвращает системе) ранее выделенный блок памяти, начиная с адреса равного p.</p>

  <h4>8.5 Динамические массивы (64)</h4>

  <p>Имя массива не является переменной типа указатель, а есть константа - адрес начала массива. Поэтому к имени массива нельзя применить операции ++, --  и присваивания.</p>
  <p>Если размер массива заранее неизвестен и не может быть постоянным, нужно чтобы память под массив выделялась в необходимых на текущий момент размерах.</p>
  <p>Выделим память для массива с 10 элементами типа int</p>
  <code>int n = 10, *m;</code>
  <code>m = (int*)malloc(n * sizeof(int));</code>
  <p>При sizeof(int) = 4 выделится 40 байт.</p>

  <h4>8.6 Примеры работы с динамическими массивами (65)</h4>

  <p>Дан массив из n элементов. Определить наибольшее число идущих подряд положительных элементов.</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
  int n;

  // ввод числа элементов в массиве
  do {
    puts("Enter number of elements");
    scanf("%d", &n);
    if (n &lt; 1) {
      puts("Error");
    }
  } while (n &lt; 1);

  // выделение памяти под массив
  int *A = (int*)malloc(n * sizeof(int));

  // обязательная проверка на NULL
  if (A != NULL) {

    // ввод элементов массива
    for (int i = 0; i &lt; n; i++) {
      printf("\n A[%d] = ", i);
      scanf("%d", &A[i]);
    }

    // поиск положительных элементов
    int m = 0, max = 0;
    for (int i = 0; i &lt; n; i++) {
      if (A[i] > 0) {
        m++;
        if (m > max) {
          max = m;
        }
      } else {
        m = 0;
      }
    }

    // вывод результата
    printf("max = %d", max);

    // освобождение памяти
    free(A);
  } else {
    puts("Error memory allocation");
    getch();
  }

  return 0;
}
</pre>
</article>


<!-- 9 Функции -->
<article class="article">
  <div class="anchor" id="p9"></div>
  <h3>9 Функции (68)</h3>

  <h4>9.1 Понятие подпрограммы (68)</h4>

  <p>Функции описываются один раз и могут вызываться многократно. Функция может иметь параметры или не имать. Параметры могут передаваться по значению и по адресу. При передаче параметра по значению функция получает свою копию параметра и не может изменить оригинальный переданный параметр. При передаче параметра по адресу функция получает копию адреса ячейки памяти, в которой хранится значение аргумента и функция может изменить значение оригинального аргумента, но не его адрес.</p>
  <p>Механизм вызова функции испльзует аргументы (фактические параметры) и параметры (формальные параметры). Формальные параметры пишут в описании функции. Фактические параметры передают в функцию при ее вызове.</p>
  <p>При вызове в функцию передают аргументы, а функция получает параметры. Аргументом может быть выражение соответствующего типа, значение которого должно быть вычислено и подставлено в момент вызова функции как параметр.</p>
  <p>Список аргументов и список параметров должны совпадать.</p>

  <h4>9.2 Прототип, описание и вызов функций (70)</h4>

  <p>Все функции являются глобальными, поэтому запрещено определять одну функцию внутри другой.</p>
  <p>Прототи функции сообщает компилятору тип возвращаемого значения, количество, тип и порядок следования параметров. При этом имена параметров компилятором игнорируются и их можно не писать. Прототипы должны быть описаны до первого вызова функции.</p>

  <h4>9.3 Оператор return (72)</h4>

  <p>Оператор return возвращает значение из функции и подставляет его вместо вызова функции. Если оператора return нет, то компилятор сам подставляет оператор return перед закрывающей скобкой.</p>

  <h4>9.4 Особенности использования параметров в функциях (72)</h4>

  <p>Массивы передаются в функцию только одним способом - по адресу. Адрес передается или через имя или через указатель на массив</p>
  <code>void func(int arr[]);</code>
  <code>void func(int *arr);</code>
  <p>Многомерный массив как параметр выглядит так</p>
  <code>void func(int arr[][]);</code>
  <code>void func(int *arr[]);</code>
  <code>void func(int **arr);</code>

  <p>Строки это обычные одномерные символьные массивы, которые завершаются символом '\0'. При передачи строки, в функцию передается указатель на начало этой строки.</p>
  <p>Можно передавать функцию в функцию. Это реализуется с помощью указателя на функцию. Указатель на функцию содержит адрес первого байта кода функции. Этот адрес является точкой входа. Над указателями на функцию запрещены арифметические действия.</p>

  <h4>9.5 Классы памяти (78)</h4>

  <p>Каждую переменную можно объявить с одним из четырех классов памяти: auto автоматический, extern внешний, static статический, register регистровый.</p>
  <p>Автоматические переменные размещаются в <strong>сегменте стека</strong> и имеют локальную область действия. Доступны только в той функции или в том блоке, где они объявлены. При входе в фунцию или блок, при объявлении переменной ей выделяется память в сегменте стека. При выходе из функции или блока, выделенная память освобождается для других переменных.</p>
  <p>Регистровые переменные размещаются в регистрах процессора и к ним нельзя обратиться по адресу. В остальном они такие же как автоматические. Доступ к регистрам быстрее чем к ячейкам оперативной памяти. В регистрах хранят часто используемые переменные. Переменные размещают в регистрах для ускорения работы программы. Поскольку число регистров невелико, то компилятор вместо того чтобы помещать переменные в регистры, просто делает их автоматическими.</p>
  <p>Внешние переменные относятся к глобальным переменным. Они могут быть объявлены в любом файле программы, вне или внутри функции и доступны везде после их объявления. Под них выделяется память в <strong>сегменте данных</strong>. По умолчанию они инициализируются нулем.</p>
  <p>Статические переменные могут быть локальные и глобальные. Статические локальные переменные объявляют внутри функций. Они имеют локальную область видимости, но не освобождают память (не теряют свое значение и не исчезают) при выходе из функции. Статические глобальные переменные объявляют вне функций. Их область видимости от момента объявления и до конца программы. По умолчанию статические переменные инициализируются нулем.</p>
  <p>По умолчанию переменная относится к классу auto.</p>

  <h4>9.6 Рекурсивные функции (79)</h4>

  <p>Если в своем теле функция вызывает саму себя то это рекурсивная функция.</p>
  <p>Например, факториал числа n</p>
<pre>
long factorial(long n) {
  if (n &lt; 0) {
    return 0;
  }
  return factorial(n - 1) * n;
  if (n == 0) {
    return 1
  }
}
</pre>
  <p>Повторный вызов рекурсивной функции не создает новую копию функции, а создает в памяти новые копии локальных переменных и параметров. Слишком большое число вызовов приведет к переполнению памяти.</p>

  <h4>9.7 Функции с переменным числом параметров (80)</h4>

  <p>Для поддержки функций с переменным числом параметров, в языке Си предусмотрены макросы в заголовочных файлах stdarg.h для стандарта ANSI. Или файл varargs.h для стандарта UNIX SYSTEM. Должен быть хотя бы один фиксированный параметр, за которым следует список необязательных параметров.</p>

  <h4>9.8 Аргументы функции main() (82)</h4>

  <p>В программы на языке Си можно передавать аргументы командной строки при вызове программы. Каждая программа на языке Си ожидает на вход два аргумента</p>
  <code>int main(int argc, char *argv[]) {}</code>
  <p>argc содержит количество аргументов командной строки. Имя программы это всегда первый аргумент, поэтому argc не может быть меньше 1. argv является указателем на массив строк. Размер массива argv равен argc. Первый элемент массива argv[0] это всегда указатель на полный путь к программе.</p>
</article>


<!-- 10 Структурный тип - строка -->
<article class="article">
  <div class="anchor" id="p10"></div>
  <h3>10 Структурный тип - строка (84)</h3>

  <h4>10.1 Преобразование символов (84)</h4>

  <p>В языке Си нет типа данных строка. Строку можно создать как одномерный массив символов</p>
  <code>char str[80];</code>
  <p>К строкам можно применять все что применимо к массивам. Обработка строк имеет широкое применение. В стандартной библиотеке есть функции для обработки символьной информации.</p>
  <p>Заголовочный файл <strong>ctype.h</strong> содержит определения следующих функций для проверки символа: isalnum, isalpha, iscntrl, isdigit, isgraph, islower, isupper, isprint, ispunct, isspace, isxdigit, isascii. Эти функции возвращают 0, если переданный в них символ не принадлежит к проверяемому классу символов.</p>
  <p>Две функции для преобразования символа: tolower, toupper.</p>

  <h4>10.2 Форматные преобразования (85)</h4>

  <p>Заголовочный файл <strong>stdlib.h</strong> содержит функции преобразования из одного формата в другой: itoa, ltoa, utoa, fcvt, atof, atoi, atol, strtod, strtol</p>
  <ol>
    <li>itoa, ltoa, utoa для преобразования целого числа в строку</li>
    <li>fcvt для преобразования вещественного числа в строку</li>
    <li>atof, atoi, atol, strtol для преобразования строки в целое число</li>
    <li>strtod для преобразования строки в вещественное число</li>
  </ol>

  <h4>10.3 Функции работы со строками (87)</h4>

  <p>Заголовочный файл <strong>string.h</strong> содержит функции для работы со строками, имеющих на конце символ '\0': strcat, strncat, strlen, strchr, strrchr, strstr, strspn, strcspn, strpbrk, strcmp, stricmp, strncmp, strnicmp, strcpy, strncpy, strtok</p>

  <h4>10.4 Примеры работы со строками (91)</h4>

  <h4>10.5 Работа с областями памяти (92)</h4>

  <p>Заголовочный файл <strong>string.h</strong> содержит функции для работы с областями памяти для строк: memcpy, memmove, memch, memcmp, memicmp, memset</p>
</article>


<!-- 11 Структурный тип - структура -->
<article class="article">
  <div class="anchor" id="p11"></div>
  <h3>11 Структурный тип - структура (94)</h3>

  <h4>11.1 Понятие структуры и ее объявление (94)</h4>

  <p>Структура содержит неоднородные данные (данные разных типов) поэтому мы не имеем доступ к полям посредством их индексации, как это было с массивами. Доступ к полям структуры осуществляется посредством составных имен. Именя полей уникальны в пределах своей структуры. Типом поля может быть любой тип. Если тип поля также является структурой, то это уже иерархическая структура.</p>
  <p>При объявлении типа структуры память под него не выделяется, поэтому не допускается инициализация объявленных полей типа структуры.</p>
  <p>В языке Си можно ввести свое обозначение для структурного типа с помощью слова typedef или директивы #define.</p>
  <p>При объявлении структуры нужно описать ее поля.</p>
<pre>
struct stud {
  int age;
  char name[16];
};
</pre>
  <p>Создать переменную типа структуры можно несколькими способами.</p>
  <ol>
    <li>Написать название переменной сразу после объявления структуры перед последней ; точкой с запятой
<pre>
struct stud {
  int age;
  char name[16];
} stud1, stud2;
</pre>
    </li>
    <li>Использовать имя структуры для объявления переменных
      <code>struct stud stud1, stud2;</code>
    </li>
    <li>Задать псевдоним структуре и использовать его для объявления переменных
      <code>typedef struct stud Stud;</code>
      <code>Stud stud1, stud2;</code>
    </li>
  </ol>
  <p>Можно объявить безымянную структуру</p>
<pre>
struct {
  int age;
  char name[16];
};
</pre>
  <p>Есть два способа создать переменные для безымянной структуры</p>
  <ol>
    <li>Написать название переменной сразу после объявления структуры перед последней ; точкой с запятой
<pre>
struct {
  int age;
  char name[16];
} stud1, stud2;
</pre>
    </li>
    <li>Задать псевдоним структуре сразу при ее объявлении и использовать его для объявления переменных
<pre>
typedef struct {
  int age;
  char name[16];
} Stud;

Stud stud1, stud2;
</pre>
    </li>
  </ol>

  <h4>11.2 Доступ к полям структуры (97)</h4>

  <p>Доступ к полям структуры осуществляется двумя способами</p>
  <ol>
    <li>С точкой для переменных
      <code>stud1.age = 15;</code>
    </li>
    <li>Со стрелкой для указателей
      <code>stud1Ptr->age = 10;</code>
      Если разыменовать указатель, то используется доступ с точкой
      <code>(*stud1Ptr).age = 5;</code>
    </li>
  </ol>

  <h4>11.3 Инициализация и обработка структур (97)</h4>

  <p>При объявлении структурной переменной можо инициализировать ее списком констант в {} фигурных скобках. Значения полям структуры присваивается в порядке их расположения в памяти.</p>
<pre>
struct stud {
  int age;
  char name[16];
} stud1 = {15, "Trump"};
</pre>
  <p>Если в фигурных скобках меньше значений, чем должно быть в структуре, то оставшиеся поля заполняются нулями.</p>
  <p>Структуры нельзя сравнивать на равенство или неравенство. Передавать структуру в функцию можно по значение и через указатель. При передаче структуры по значению, создается ее копия и помещается в стек, функция работает с копией структуры. Если структура слишком большая, то произойдет  переполнение стека и копия не создастся.</p>
  <p>Над полями структуры применимы те же операции, что и над обычными переменными.</p>

  <h4>11.4 Примеры программ обработки структур (98)</h4>

  <h4>11.5 Динамические структуры данных (99)</h4>

  <p>Динамические структуры данных с помощью указателей размещают элементы в оперативной памяти независимо друг от друга и не слошным массивом адресов, что придает гибкость относительно статических массивов. Добавление элемента или удаление не приводит к перемещению остальных элементов в памяти.</p>
  <p>Структура данных линейный список это линейная последовательность элементов, каждый элемент имеет значение и указатель на следующий элемент. Если у элементов есть указатель только на следующий элемент то это однонаправленный список. Если еще и на предыдущий элемент то это двунаправленный список.</p>
  <p>Первый элемент списка называется голова, последний - хвост. Доступ к элементам только последовательный, начиная с головы через указатели на следующий элемент.</p>
  <p>Списки используются для построения стека и очереди.</p>
  <p>Кольцевые списки это списки у которых последний элемент показывает на первый. При создании кольцевого списка сначала создают один элемент, который указывает на себя же как на следующий элемент. Остальные элементы включаются в этот список друг задругом. Доступ к элементам возможен не только через голову, но и через любой другой элемент. Кольцевые списки используются для поиска кратчайших путей между станциями кольцевого метро.</p>
  <p>Структура данных дерево это нелинейная структура с иерархическим представлением. Дерево состоит из вершин и соединений между ними. Корень это единственная вершина у которой нет родительской вершины. Любые другие узлы имеют родителя. Если у вершины нет потомков, то это лист дерева.</p>
  <p>Бинарное дерево - это дерево, вершины которого имеют указатели на двух потомков. Таким образом каждая вершина имеет левое и правое поддерево. Просматривают дерево рекурсивно с использованием трех операций: посмотреть на вершину, посмотреть на левое поддерево, посмотреть на правое поддерево. Существует три основных обхода деревьев:</p>
  <ol>
    <li>Смотрим сначала левое поддерево, потом корень, потом правое поддерево</li>
    <li>Смотрим сначала корень, потом левое поддерево, потом правое поддерево</li>
    <li>Смотрим сначала левое поддерево, потом правое поддерево, потом корень</li>
  </ol>
  <p>Двоичное дерево поиска сохраняет в определенном порядке данные, поступающие в случайном порядке. Используется для быстрого поиска данных.</p>
</article>


<!-- 12 Структурные типы: битовые поля, объединения, перечислимый тип -->
<article class="article">
  <div class="anchor" id="p12"></div>
  <h3>12 Структурные типы: битовые поля, объединения, перечислимый тип (108)</h3>

  <h4>12.1 Битовые поля (108)</h4>

  <p>В отличие от других языков, в Си есть доступ к битам байта. Битовые поля это специальные члены структуры, где определено из скольких бит состоит каждое поле.</p>
<pre>
struct Bits{
  int bit1: 1;
  int bit4: 4;
  int bit3: 3;
};
</pre>
  <p>Bits это структура данных размером 1 байт, в которой есть три переменных bit1, bit4, bit3 с размерами 1, 4, 3 бита. Нельзя использовать массив битовых полей, указатель на битовое поле и возвращать из функции битовые поля.</p>

  <h4>12.2 Объединения (108)</h4>

  <p>Объединение это набор элементов, возможно разных типов,занимающих одну и ту же область памяти. Размер объединения равен размеру самого элемента в нем. Объединение хранит значение только одного из своих элементов. Когда другому элементу объединения присваивается значение, то значения других элементов теряются.</p>
<pre>
union primer {
  int i;
  char s[5];
  float f;
};
</pre>
  <p>Максимальный размер памяти 5 байт у массива s[5], значит объединение занимает 5 байт. Все элементы объединения располагаются в памяти с одного и того же адреса. При инициализации объединения константным выражением, его значние присваивается первому в порядке перечисления элементу объединения.</p>
  <code>union primer sm = {16961};</code>
  <p>В результате элемент sm.i = 16961. К этой области памяти можно обращаться по именам других элементов. При этом все элементы получают значения, преобразованные к их типу</p>
  <code>sm.i = 16961; sm.s = "ABAB"; sm.f = 48.31;</code>
  <p>Объединения union подобны структурам struc, однако не используется казатель объединения на само себя и не допускаются элементы - битовые поля.</p>

  <h4>12.3 Перечислимый тип (110)</h4>

  <p>Перечисления - это подмножества целого типа. Перечислимый тип определяет все допустимые значения, которые могут иметь переменные этого типа.</p>
  <p>Перечисление состоит из списка именованных констант. Именя констант уникальны среди остальных имен программы. Переменные этого типа могут принимать значения только этих констант</p>
  <code>enum colors {white, green, black} p;</code>
  <code>enum colors p2;</code>
</article>


<!-- 13 Структурный тип - файл -->
<article class="article">
  <div class="anchor" id="p13"></div>
  <h3>13 Структурный тип - файл (111)</h3>

  <h4>13.1 Организация ввода-вывода (111)</h4>

  <p>В языке Си для обмена данными между оперативной памятью и внешними устройствами предусмотрен набор стандартных функций.</p>

  <h4>13.2 Потоковый ввод-вывод (111)</h4>

  <p>Все данные рассматриваются как поток отдельных байт. Под потоком понимается либо файл на внешнем устройстве, либо физическое устройство ввода-вывода. В программе необходимо определить указатель на структуру типа FILE, который будет связан с определенным потоком. Заголовочный файл stdio.h содержит все функции и константы для работы с потоком.</p>

  <h4>13.3 Открытие и закрытие потока (112)</h4>

  <p>Для начала работы с потоком, необходимо его открыть</p>
  <code>FILE* fPtr = fopen("text.txt", "w");</code>
  <p>Функция fopen первым параметром принимает имя файла, а вторым - режим, в котором его нужно открыть, возвращает указатель на структуру типа FILE.</p>
  <p>Любой поток можно перенаправить в другой поток</p>
  <code>freopen("text.txt", "w", stdout);</code>
  <p>Функция freopen перенаправит поток вывода на экран в файл с именем text.txt.</p>
  <p>После завершения работы с потоком, его необходимо закрыть. Все открытые потоки автоматически закрываются при выходе из программы. Однако число одновременно открытых потоков ограничено.</p>
  <code>fclose(fPtr);</code>
  <p>Функция fclose принимает указатель на поток, который нужно закрыть и возвращает 0, если поток закрыт успешно, и EOF в случае ошибки.</p>
  <p>Можно закрыть один поток или все сразу</p>
  <code>fcloseall();</code>
  <p>Функция fcloseall закрывает все открытые потоки и возвращает число закрытых потоков или EOF в случае ошибки.</p>

  <h4>13.4 Бесформатный ввод-вывод (113)</h4>

  <p>Библиотека Си поддерживает три типа бесформатного ввода-вывода</p>
  <ol>
    <li>Посимвольный. Чтение/запись одного символа</li>
    <li>Построчный. Чтение/запись строки из символов</li>
    <li>Блочный. Чтение/запись блоков фиксированной длины</li>
  </ol>
  <code>char c = fgetc(fPtr);</code>
  <p>Функция fgetc принимает указатель на поток и возвращает код одного символа из этого потока. При обнаружении конца файла возвращает значение EOF.</p>
  <code>fputc(c, fPtr);</code>
  <p>Функция fputc принимает один символ и указатель на поток и записывает полученный символ в этот поток.</p>

  <h4>13.5 Строчный ввод-вывод (115)</h4>

  <code>char* s = fgets(str, n, fPtr);</code>
  <p>Функция fgets принимает указатель на первый символ строки, число символов строки и указатель на поток, возвращает указатель на прочитанную строку.</p>
  <code>fputs(s, fPtr);</code>
  <p>Функция fputs принимает указатель на строку и указатель на поток. Записывает указанную строку в поток.</p>

  <h4>13.6 Блочный ввод-вывод (115)</h4>

  <code>fread(aPtr, m, n, fPtr);</code>
  <p>Функция fread принимает указатель на область памяти и читает n блоков размером по m байт каждый из указанного потока. Сохраняет прочитанные блоки в указанной области памяти.</p>
  <code>fwrite(aPtr, m, n, fPtr);</code>
  <p>Функция fwrite выводит в поток из указанной области памяти n блоков размером по m байт каждый.</p>

  <h4>13.7 Позиционирование (116)</h4>

  <p>Все операции ввода-вывода осуществляются относительно текущей позиции. Указатель на текущую позицию устанавливается автоматически в зависимости от режима открытия потока. Для режимов "r" и "w" позиция устанавливается в начало потока. Для режима "a" - в конец потока. После выполнения операции ввода-вывода позиция потока смещается на прочитанное/записанное число байт.</p>
  <code>ftell(fPtr);</code>
  <p>Функция ftell принимает указатель на поток и возвращает текущую позицию потока.</p>
  <code>rewind(fPtr);</code>
  <p>Функция rewind устанавливает текущую позицию на начало потока.</p>
  <code>fseek(fPtr, sm, ot);</code>
  <p>Функция fseek смещает текущую позицию на sm смещение в байтах относительно ot точки оствчета</p>
  <p>Использование позиционирования позволяет организовать прямой доступ к любому байту потока.</p>
  <p>Функции позиционирования нельзя применять к стандартным потокам.</p>
  <p>Напишем программу чтения из заданного файла каждой пятой буквы, начиная с последней</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int a;
  long L = 1;
  FILE *f;

  if ((f = fopen("c:\\alf.dat", "r")) == NULL) {
    return 1;
  }

  fseek(f, -L, SEEK_END);

  while ((a = getc(f)) != EOF) {
    fputc(a, stdout);
    L += 5;
    fseek(f, -L, SEEK_END);
  }

  fclose(f);
  getch();
  return 0;
}
</pre>

  <h4>Управление буферизацией (118)</h4>

  <p>Каждому открытому потоку ставится в соответствие системный буфер. Использование буфера позволяет ускорить ввод-вывод за счет сокращения обращений к внешнему устройству. Чем больше размер буфера, тем меньше обращений. Размер системного буфера определен символической константой BUFSIZ, значение которой равно 512 Кб.</p>
  <p>Функции записи записывают данные не в файл, а в буфер. Накопленные данные из буфера выгружаются в поток в следующих случаях:</p>
  <ol>
    <li>буфер полностью заполнен</li>
    <li>вызвана команда очистки буфера</li>
    <li>поток закрывается</li>
  </ol>
  <p>Функции чтения читают данные из буфера. Данные загружаются в буфер, если он полностью исчерпан. Очистить буфер можно с помощью функции fflush</p>
  <code>fflush(fPtr);</code>
  <p>Одновременно очистить все буферы можно с помощью функции flushall</p>
  <code>flushall();</code>
  <p>При работе с буфером можно:</p>
  <ol>
    <li>заменить системный буфер на свой такого же объема</li>
    <li>заменить системный буфер на свой произвольного размера, но не более 32767 байт</li>
    <li>отменить буферизацию</li>
  </ol>
  <code>setbuf(fPtr, *buf);</code>
  <p>Функция setbuf заменяет системный буфер для потока fPtr на свой, задаваемый указателем на начало буфера *buf. Размер устанавливаемого буфера должен быть равен BUFSIZE. Если вместо указателя на буфер использовать значение NULL, то буферизации не будет и ввод будет осуществляться сразу в поток.</p>
  <code>int setvbuf(FILE *stream, char *buf, int type, size_t size);</code>
  <p>Функция setbuf из заголовочного файла stdio.h устанавливает буфер заданного размера.</p>

  <h4>13.9 Двоичный и текстовый режимы открытия потоков (120)</h4>

  <p>Поток можно открыть в текстовом или в двоичном режиме. В обоих случаях поток рассматривается как последовательность байт. Отличие только в обработке управляющих символов. В двоичном режиме она отсутствует и управляющие символы воспринимаются как обычные байты. Управляющие символы это, например, конец строки, конец файла. Текстовый или двоичный режим задается во время открытия потока функцией fopen.</p>

  <h4>13.10 Форматный ввод-вывод (121)</h4>

  <p>Функция fprintf принимает поток для вывода, фомратную строку и список аргументов, возвращает число записанных байт или EOF в случае ошибки.</p>
  <p>Функция fscanf принимает поток для ввода, фомратную строку и список аргументов, возвращает число прочитанных полей или EOF если достигнут конец потока.</p>

  <h4>13.11 Ввод-вывод нижнего уровня (122)</h4>

  <p>Заголовочный файл io.h содержит прототипы функций ввода-вывода нижнего уровня. Эти функции для чтения или записи вызывают функции операционной системы. При этом ввод-вывод не буферизированный и неформатированный.</p>
  <p>При открытии, каждому файлу назначается дескриптор. Дескриптор это целое число. Каждому файлу можно назначить несколько дескрипторов.</p>
  <p>Функция open открывает файл в заданном режиме. Функция close закрывает файл. Функция dup назначает еще один дескриптор для файла. Функция read(fd, buf, n) читает n байт из файла с дескриптором fd из записывает их в область памяти buf. Функция write(fd, buf, n) записывает n байт из области памяти buf в файл с дескриптором fd.</p>
  <p>Чтение и запись проискходит относительно текущей позиции, которую можно установить с помощью функции lseek. Функция filelength возвращает длину файла.</p>
  <p>Функции ввода-вывода нижнего уровня и функции потокового ввода-вывода несовместимы, поэтому их нельзя применять к одному и тому же файлу в одной программе.</p>

  <h4>13.12 Примеры программ работы с файлами (124)</h4>
</article>


<!-- 14 Библиотеки и их использование -->
<article class="article">
  <div class="anchor" id="p14"></div>
  <h3>14 Библиотеки и их использование (128)</h3>

  <h4>14.1 Включаемые файлы (128)</h4>

  <p>Все функции и глобальные переменные выдны только в том файле, где они определены. Если программа пишется из нескольких файлов, нужно чтобы в разных файлах можно было пользоваться общими функциями и переменными. Для этого создается заголовочный файл с описаниями всех общих переменных и функций. Этот заголовочный файл с помощью директивы #include включается в начале каждого файла, использующего общие функции.</p>

  <h4>14.2 Примеры разработки модульных программ (128)</h4>

  <h4>14.3 Стандартные заголовочные файлы (132)</h4>

  <p>Каждая библиотечная функция стандарта языка Си имеет прототип в соответствующем заголовочном файле. В стандарте ANSI 15 заголовочных файлов: assert.h, ctype.h, errno.h, float.h, limits.h, locale.h, math.h, setjmp.h, signal.h, stdarg.h, stddef.h, stdio.h, stdlib.h, string.h, time.h</p>

  <h4>14.4 Введение в графику на языке Си (132)</h4>

  <p>Экран рассматривается как совокупность точек (пикселей), яркостью и цветом которых можно управлять. Для каждого пикселя отводится фиксированное число бит в видеопамяти видеоадаптера. Видеоадаптер может работать в двух режимах - текстовый или графический.</p>
  <p>В текстовом режиме экран имеет стандартный размер 25 строк по 80 смволов в каждой. У всех символов на экране есть свои координаты от верхнего левого символа (1,1) до правого нижнего (25, 80). Современные мониторы и среды программирования не поддерживают функций создания окон в консоли, поэтому текстовый режим рассматривать не будем.</p>
  <p>В графическом режиме на один пиксель выделяется от 1 до 8 бит памяти. В монохромном режиме используется 1 бит, который управляет яркостью пикселя. В цветном режиме управляют яркостью трех цветов красного, зеленого и синего. Это RGB схема.</p>
  <p>Заголовочный файл graphics.h содержит прототипы функций управления экраном. Чтобы функции графического режима работали, нужен специальный драйвер для каждого видеоадаптера. Фирмой Borland были разработаны графические драйверы практически для всех видов устройств, которые располагаются в отдельных файлах с расширением .bgi.</p>
  <p>Выбор адаптера и графического режима выполняет функция detectgraph(). Эта функция тестирует аппаратуру и выбирает подходящий драйвер и графический режим. Инициализацию графического режима выполняет функция initgraph(). По окончании работы в графическом режиме необходимо вернуться в текстовый режим, закрыв графический с помощью функции closegraph(). При закрытии графического режима функция освобождает выделенную под графику память и очищает буфер видеоадаптера.</p>
  <p>Microsoft Visual Studio не поддерживает работу с графической библиотекой graphics.h. Для работы с графикой можно использовать другие библиотеки, например OpenGL или DirectX.</p>
</article>


<!-- 15 Препроцессор языка Си -->
<article class="article">
  <div class="anchor" id="p15"></div>
  <h3>15 Препроцессор языка Си (136)</h3>

  <h4>15.1 Препроцессор языка Си (136)</h4>

  <p>Препроцессор является обязательной частью компилятора. Препроцессор включает в себя директивы и операции.</p>

  <h4>Директивы препроцессора</h4>

  <ul>
    <li>#define определение макроса</li>
    <li>#undef отмена определения макроса</li>
    <li>#include включение заголовка</li>
    <li>#if компиляция, если выражение истинно</li>
    <li>#ifdef компиляция, если макрос определен</li>
    <li>#ifndef компиляция, если макрос не определен</li>
    <li>#else компиляция, если выражение в if ложно</li>
    <li>#elif составная директива else if</li>
    <li>#endif окончание директивы #if</li>
    <li>#line замена новым значением номера строки или имени файла</li>
    <li>#error формирование ошибок трансляции</li>
    <li>#pragma действие определяется реализацией</li>
    <li># пустая директива</li>
  </ul>

  <h4>Операции препроцессора</h4>

  <ul>
    <li># придание операнду формы строки символов</li>
    <li>## склеивание лексем</li>
    <li>#defined представление #ifdef в форме выражения</li>
  </ul>

  <h4>15.2 Директивы условной компиляции (137)</h4>

  <p>Каждой директиве #if должна соответствовать завершающая ее директива #endif. Между ними может быть любой число директив #elif и не более одной директивы #else. Препроцессор вычислаят константное выражение в директиве #if и #elif. Константное выражение может содержать операцию defined(идентификатор). Эта операция возвращает истину, если идентификатор определен выше с помощью директивы #defined, иначе ложь.</p>
</article>


<!-- 16 Литература -->
<article class="article">
  <div class="anchor" id="p16"></div>
  <h3>16 Литература (139)</h3>

  <ol>
    <li>1992 Керниган, Ритчи - Язык программирования Си. (2е) 202с.</li>
    <li>1999 Подбельский, Фомин - Программирование на языке Си. (2е)</li>
    <li>1996 Березин - Начальный курс C и C++</li>
    <li>2010 Куликова, Чумакова - Разработка программ на языке Си</li>
  </ol>
</article>

