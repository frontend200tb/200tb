<article class="article">
  <h1>1988 Джехани - Программирование на языке Си. 274c</h1>
  <p>Конспект книги</p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
        <a href="#p1">1 Введение и основные понятия (8)</a>
    <br><a href="#p2">2 Типы и переменные (22)</a>
    <br><a href="#p3">3 Операторы и выражения (63)</a>
    <br><a href="#p4">4 Операторы управления (79)</a>
    <br><a href="#p5">5 Функции и завершенные программы (90)</a>
    <br><a href="#p6">6 Раздельная компиляция и абстрагирование данных (132)</a>
    <br><a href="#p7">7 Особые ситуации (152)</a>
    <br><a href="#p8">8 Параллельное программирование (168)</a>
    <br><a href="#p9">9 Препроцессор языка Си (183)</a>
    <br><a href="#p10">10 Последний пример (195)</a>
    <br><a href="#p11">Приложения (202)</a>
    <br><a href="#p12">Список литературы (257)</a>
  </p>
</article>


<!-- 1 Введение и основные понятия -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>1 Введение и основные понятия (8)</h3>

  <h4>1.1 Пример программы на языке Си (8)</h4>

  <details>
    <summary>Программа 1 (8)</summary>
<pre>
#include &lt;stdio.h&gt;

#define PROMPT ':'

int main() {
  float a, b;
  char opr;
  float res;

  while(putchar(PROMPT), scanf("%f%c%f", &a, &opr, &b) != EOF) {
    switch (opr) {
      case '+': res = a + b; break;
      case '-': res = a - b; break;
      case '*': res = a * b; break;
      case '/': res = a / b; break;
      default:
        puts("Error operator\n");
        exit(1)
    }
    printf("result is %g\n", res);
  }

  exit(0);
}
</pre>
  </details>

  <p>Внутри условия оператора while используется составное выражение, состоящее из двух выражений разделенных запятой: putchar и scanf. В этом случае выполнятся оба выражения, а значением составного выражения будет значение выражения после запятой, в данном случае scanf.</p>
  <p>Все аргументы в языке Си передаются по значению. Чтобы переменную передать по ссылке, нужно передавать адрес переменной.</p>
  <p>exit(1) завершает программу с кодом 1, что указывает операционной системе , что программа завершена с ошибкой.</p>
  <p>exit(0) завершает программу с кодом 0, что указывает операционной системе , что программа завершена успешно.</p>
  <p>Для завершения программы необязательно использовать функцию exit. Программа может закончится выполнением всех операторов функции main или оператором return функции main.</p>

  <h4>1.2 Основные понятия (16)</h4>

  <p><strong>Алфавит</strong> это набор знаков языка Си. Знаки пробела (blank), табуляции (tab) и перехода на новую строку (newline) обозначаются как интервал (white space).</p>
  <p><strong>Идентификаторы</strong> это имена переменных и функций. Идентификаторы могут быть любой длины, но компиляторы различают идентификаторы только по первым восьми знакам.</p>
  <p><strong>Ключевые слова</strong> это список зарезервированных слов, которые нельзя использовать в качестве идентификаторов.</p>
  <p><strong>Литералы</strong> это константные значения которые можно записать в переменную. Литералы могут быть различных типов - целые, символьные, строковые и т.д. Некоторые литералы не имеют графического представления и записываются с помощью escape последовательности, например \', \n и т.д. Также любой литерал можно записать с помощью escape последовательности, записав его код из таблицы ASCII после знака обратный слеш. Если строковый литерал не помещается на одной строке кода, то можно поставить обратный слеш и продолжить литерал на новой строке.</p>
  <p>Строки в языке Си всегда оканчиваются знаком '\0' обозначающим конец строки. Обработка строк основана на этом соглашении. Если строковой переменной присваивается строковый литерал, то знак конца строки компилятор добавляет автоматически. Если строковой переменной присваивается массив символов, то программист сам должен в конце строки добавить знак '\0'.</p>
  <p><strong>Комментарии</strong> игнорируются компилятором и не попадают в код исполняемого файла. Вложенные комментарии не допускаются.</p>
  <p><strong>Точка с запятой</strong> пишется в конце каждого оператора. Точка с запятой не пишется после правой фигурной скобки составного оператора</p>

  <h4>1.3 Константы (20)</h4>

  <code>#define PI 3.14</code>
  <p>Константы определяются на уровне препроцессора в макросе. Препроцессор сам заменет в программе все имена PI на значение 3.14.</p>
</article>


<!-- 2 Типы и переменные -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>2 Типы и переменные (22)</h3>

  <p>Если переменной присвоить новое значение, то ее старое значение будет потеряно.</p>
  <p>Объект (object) это область памяти. При описании (declaration) объекта перечисляются все его свойства, но память для него не выделяется. При определении (definition) объекта для выделяется область памяти.</p>

  <h4>2.1 Основные типы (23)</h4>

  <ol>
    <li>char. Символы это набор символов ASCII. Символы хранятся как целые числа.</li>
    <li>int. Целые обычно занимают память, равную машинному слову. Целые без знака используются при работе с отдельными битами в машинном слове.</li>
    <li>enum. Перечисляемые типы в качестве значений используют идентификаторы. Это позволяет внести ясность при использовании идентификаторов вместо непонятных цифр. Например, идентификаторы jan, feb. mar более понятны, чем целые числа 1, 2, 3 для обозначения месяцев. Идентификаторы перечислимых типов должны быть уникальны и не совпадать с другими переменными в программе.</li>
    <li>bool. В языке Си нет булевых значений. Вместо них используются целые значения.</li>
    <li>Числа с плавающей точкой. Есть два типа: float (обычная точность) и double(двойная точность). В языке Си все арифметические операции с плавающей точкой выполняются с двойной точностью.</li>
    <li>void. Пустой тип используется для функций, не возвращающих значений.</li>
  </ol>

  <h4>2.2 Производные типы (28)</h4>

  <ol>
    <li>
      <h4>2.2.1 Массивы (28)</h4>
      <p>Массив это объект из элементов одного типа. Элементы массива не могут быть функциями, но они могут быть указателями на функции. Массив может быть одномерный или многомерный.</p>
    </li>
    <li>
      <h4>2.2.2 Структуры (29)</h4>
      <p>Структура это объект из элементов разного типа. В структуре должен быть хотябы один элемент.</p>
      <h4>2.2.2.1 Доступ к компонентам структуры</h4>
      <p>Доступ к компонентам структуры осуществляется через точку</p>
      <code>s.c</code>
      <h4>2.2.2.2 Поля битов</h4>
      <p>Доступ к отдельным битам числа можно осуществить через структуру. В структуре объявляются компоненты - поля битов с указанием положения и числа битов, занимаемых каждым компонентом.</p>
    </li>
    <li>
      <h4>2.2.3 Объединения (34)</h4>
      <p>Это такая структура, где одновременно может использоваться только один элемент. Для всех элементов объединения выделяется одна и та же память. Доступ к этой памяти возможен по любому элементу объединения. Но чтобы это имело смысл, нужно использовать тот элемент, который был записан в эту память. Объединения применяются для уменьшения объема памяти.</p>
    </li>
    <li>
      <h4>2.2.4 Переменные структуры (35)</h4>
      <p>Это объекты, которые имеют набор одинаковых элементов плюс индивидуальные элементы для каждой структуры. Переменная структура реализуется комбинацией структуры и объединения.</p>
    </li>
    <li>
      <h4>2.2.5 Указатели (38)</h4>
      <p>Указатель это ссылка на ячейку памяти. В указатель записывается адрес ячейки памяти. </p>
      <h4>2.2.5.1 Динамические объекты</h4>
      <p>Указатели используются при создании и обработке динамических объектов. В отличие от статических объектов, число и размер которых предопределены заранее, динамические объекты могут создаваться и уничтожаться в процессе выполнения программы. Динамические объекты не имеют имен и ссылка на них выполняется с помощью указателей.</p>
      <h4>2.2.5.2 Создание динамических объектов</h4>
      <p>Функции malloc, calloc возвращают указатель на созданный динамический объект. Для определения необходимого размера памяти нужно пользоваться оператором sizeof. Возвращаемые указатели имеют тип указателя на char и должны быть явно преобразованы к подходящему типу. Выделим память для одного значения целого типа.</p>
      <code>int* pi = (int*)malloc(sizeof(int));</code>
      <h4>2.2.5.3 Доступ к динамическим объектам</h4>
      <p>Ссылаться на динамический объект можно с помощью более чем одного указателя.</p>
      <h4>2.2.5.4 Время жизни динамического объекта</h4>
      <p>Динамические объекты занимают память. Когда они становятся не нужны, память необходимо освободить. Если этого не сделать, то память будет утеряна навсегда и станет невозможно ею пользоваться. Функция free(ptr) принимает указатель на динамический объект и освобождает память. После освобождения памяти, нужно обнулить ссылку на нее ptr = null</p>
      <h4>2.2.5.5 Указание на заранее определенные объекты</h4>
      <code>int i, *pi; pi = &i;</code>
      <h4>2.2.5.6 Указание на произвольную ячейку памяти</h4>
      <p>Можно присвоить указателю адрес ячейки памяти, если привести этот адрес к типу указателя</p>
      <code>pi = (int*)0777000;</code>
      <p>Обращение к конкретным ячейкам памяти необходимо при написании драйверов устройств.</p>
      <h4>2.2.5.7 Связь между указателями и массивами</h4>
      <p>Имя массива рассматривается как указатель на первый элемент массива.</p>
      <h4>2.2.5.8 Строки - дополнительные сведения о тесной связи между указателями и массивами</h4>
      <p>Строки это массивы символов. Последним символом строки должен быть '\0'.</p>
      <h4>2.2.5.9 Указатели и структуры</h4>
      <p>Поскольку указатели часто используются для указания на структуры, для ссылок на компоненты таких структур введен оператор выбора стрелка вправо.</p>
    </li>
  </ol>

  <h4>2.3 Описания типа (45)</h4>

  <p>typedef это оператор описания типа. Новый тип не вводится, а вводится новый псевдоним для уже существующего типа.</p>

  <h4>2.4 Определения и описания (46)</h4>

  <h4>2.4.1 Классы памяти</h4>

  <p>Время жизни и область видимости объекта определяется классом памяти. Всего есть 4 класса памяти: auto автоматический, static статический, extern внешний, register регистровый.</p>

  <h4>2.4.2 Типы данных</h4>

  <h4>2.4.3 Описатели</h4>

  <h4>2.4.4 Примеры определений и описаний объектов</h4>

  <code>int i, *pi, f(), *fip(), (*pfi)()</code>
  <p>Здесь определены целая переменная i, указатель на целую переменную pi, функция f() возвращающая целое значение, функция fip() возвращающая указатель на целое значение, указатель pfi на функцию возвращающую целое значение.</p>

  <h4>2.4.4.1 Синтаксическое отличие описаний объекта от его определений</h4>

  <ol>
    <li>Наличие ключевого слова extern указывает на то, что объекты описываются, а не определяются</li>
    <li>Отсутствие параметров функции и соответствующего имени тела функции означает, что функция описывается, а не определяется</li>
    <li>Параметры функции описываются, но не определяются</li>
  </ol>

  <h4>2.4.5 Инициализаторы</h4>

  <p>Инициализаторы это начальные значения переменных при их определении. Статическим и внешним переменным по умолчанию присваиваются нулевые значения. Автоматическим переменным по умолчанию ничего не присваивается.</p>

  <h4>2.4.6 Комментарии к синтаксису описаний и определений</h4>

  <code>int *(*(*x)[6])();</code>
  <p>Переменная x определяется как указатель на массив из 6 элементов, каждый из которых является указателем на функцию, возвращающую указатель на целый объект.</p>
  <code>char (*(*(y())[]))();</code>
  <p>Переменная y описывается как функция, которая возвращает указатель на массив указателей на функции, возвращающие символьные значения</p>
  <code>int x; // целое</code>
  <code>int *x; // указатель на целое</code>
  <code>int x[]; // массив целых</code>
  <code>int x(); // функция, возвращающая целое</code>
  <p>Оператор косвенной ссылки (*) имеет приоритет меньше, чем операторы скобки () и []. Поэтому переменная a это массив указателей на символы, такой как char *(a[])</p>
  <code>char *a[]</code>
  <p>Переменная b это указатель на массив символов</p>
  <code>char(*b)[];</code>
  <p>Поэтому обязательно используйте скобки для указания приоритета и для ясности.</p>

  <h4>2.4.7 Примеры, иллюстрирующие использование эквивалентностей</h4>

  <code>int *(*(*x)[6])();</code>
  <p>Переменная x это указатель на массив из 6 указателей на функцию, возвращающую указатель на целое.</p>
  <code>char (*(*y())[]);</code>
  <p>Переменная y это функция, которая возвращает указатель на массив указателей на функции, возвращающие символьное значение.</p>

  <h4>2.4.8 Использование оператора typedef для упрощения понимания описаний и определений</h4>

  <p>Применение оператора typedef решает проблему описания сложных типов. Однако при этом не всегда получаются ясные и краткие описания.</p>
  <code>typedef int *pi;</code>
  <p>pi это теперь указатель на целое</p>
  <code>typedef pi fpi();</code>
  <p>fpi это теперь функция, возвращающая указатель на целое</p>
  <code>typedef fpi *pfpi();</code>
  <p>pfpi это теперь указатель на функцию, возвращающую указатель на целое</p>

  <h4>2.4.9  Заключительные замечания об описаниях и определениях</h4>

  <p>В языке Си допускается совместное описание и определение переменных разных типов.</p>
  <code>int a[6], *c;</code>

  <h4>2.4.10 Эквивалентность типов</h4>

  <p>Есть два способа определения являются ли типы двух объектов эквивалентными: структурная эквивалентность типов и именная эквивалентность типов. При структурной эквивалентности два объекта относятся к одному типу если их компоненты имеют одинаковые типы. При именной эквивалентности два объекта относятся к одному типу в случае их определения с использованием имени того же типа. Поэтому разные компиляторы могут давать разные результаты.</p>

  <h4>2.5 Преобразования типов (58)</h4>

  <p>Преобразование может быть явное и неявное.</p>

  <h4>2.5.1 Неявное преобразование типа</h4>

  <p>Неявные преобразования выполняются в основном для согласования аргументов оператора или функции.</p>

  <h4>2.5.2 Арифметические преобразования</h4>

  <p>Арифметические операторы преобразуют операнды к соответствующим типам автоматически.</p>

  <h4>2.5.3 Явные преобразования типов</h4>

  <p>Все типы могут быть явно преобразованы в тип void, однако тип void нельзя преобразовать в другой тип.</p>

  <h4>2.6 Задачи (61)</h4>

  <details>
    <summary>Программа 2 (62)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char *test[5];

  for (int i = 0; i &lt;= 4; i++) {
    test[i] = "0123456789";
  }

  test[1][3] = '*';

  for (int i = 0; i &lt;= 4; i++) {
    printf("%s\n", test[i]);
  }
}
</pre>
  </details>
</article>


<!-- 3 Операторы и выражения -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>3 Операторы и выражения (63)</h3>

  <h4>3.1 Операторы (63)</h4>

  <p>Рассмотрим операторы в порядке убывания приоритета.</p>

  <h4>3.1.1 Операторы вызова функции, индексирования и выбора</h4>

  <p>Вызов функции, а также группировка операторов в выражении () круглые скобки. Выбор элемента массива [] квадратные скобки. Выбор компонента структуры . точка. Выбор компонента структуры через указатель -> стрелка.</p>

  <h4>3.1.2 Унарные операторы</h4>

  <p>Косвенная ссылка * звездочка, получение адреса & амперсанд, отрицание - минус, логическое отрицание ! восклицательный знак, дополнение до 1 ~ тильда, инкремент ++, декремент --, вычисление размера памяти sizeof.</p>

  <h4>3.1.3 Мультипликативные операторы</h4>

  <p>Умножение *, деление /, остаток от деления %.</p>

  <h4>3.1.4 Аддитивные операторы</h4>

  <p>Сложение +, вычитание -</p>

  <h4>3.1.4.1 Арифметические действия с указателями</h4>

  <p>Сложение указателя с целым числом возвращает указатель на элемент, отстоящий от начального на целое число ячеек памяти данного типа. То же с вычитанием, инкрементом и декрементом. Поэтому арифметические действия имеют смысл только для указателей, указывающих на элементы массива.</p>
  <p>Вычитание двух указателей вернет число элементов между ними.</p>

  <h4>3.1.5 Операторы сдвига</h4>

  <p>Сдвиг влево &lt;&lt;, сдвиг вправо &gt;&gt;</p>

  <h4>3.1.6 Операторы отношения</h4>

  <p>Меньше &lt;, больше &gt;, меньше или равно &lt;=, больше или равно &gt;=</p>

  <h4>3.1.7 Операторы равенства и неравенства</h4>

  <p>Равенство ==, неравенство !=</p>

  <h4>3.1.8 Оператор порязрядное и &</h4>

  <h4>3.1.9 Оператор поразрядное исключающее или ^</h4>

  <h4>3.1.10 Оператор поразрядное или |</h4>

  <h4>3.1.11 Логический оператор и &&</h4>

  <h4>3.1.12 Логический оператор или ||</h4>

  <h4>3.1.13 Тернарный условный оператор ?:</h4>

  <h4>3.1.14 Операторы присваивания</h4>

  <p>=, +=, -=, *=, /=, %=, &gt;&gt;=, &lt;&lt;=, &=, ^=, |=.</p>

  <h4>3.1.15 Оператор запятая ,</h4>

  <p>Объединяет выражения в одно выражение. Тип совпадает с правым операндом. Вычисляются все выражения, возвращается результат выражения после запятой.</p>

  <h4>3.1.16 Таблица приоритетов и порядка выполнения операторов</h4>

  <h4>3.2 Выражения (77)</h4>

  <p>Выражения могут быть составлены с использованием операторов, переменных, литералов, констант, вызовов функций. Порядок вычисления выражений компилятор выбирает сам. Если значение выражения зависит от порядка вычисления , то такие вычисления называют с побочным эффектом. Даже если правильно расставить скобки, для определения приоритета операций, все равно это не поможет. Компилятор может произвольно переупорядочивать выражения даже при наличи скобок. В таком случае нужно использовать дополнительные присваивания с использованием временных переменных.</p>

  <h4>3.2.1 Постоянные выражения</h4>

  <h4>3.3 Задачи (78)</h4>
</article>


<!-- 4 Операторы управления -->
<article class="article">
  <div class="anchor" id="p4"></div>
  <h3>4 Операторы управления (79)</h3>

  <h4>4.1 Выражения и операторы (79)</h4>

  <p>Если к выражению добавить точку с запятой, то оно становится оператором.</p>

  <h4>4.2 Пустой оператор (79)</h4>

  <p>Пустой оператор обозначается точкой с запять ;. Его используют когда никаких действий не требуется, а по правилам синтаксиса языка должен присутствовать оператор. Наприме, всегда должен быть оператор тела цикла</p>
<pre>
while ((c = getchar()) == BLANK) {
  ;
}
</pre>

  <h4>4.3 Составной оператор (80)</h4>

  <p>Составной оператор записывается в фигурных скобках. Все переменные объявленные внутри составного оператора видны только до закрывающей фигурной скобки.</p>

  <h4>4.4 Оператор присваивания (80)</h4>

  <p>Используя несколько операторов присваивания в одном выражении, можно присвоить значение сразу нескольким переменным</p>
  <code>i = j = k = 0;</code>

  <h4>4.5 Оператор if (81)</h4>

  <h4>4.6 Оператор switch (83)</h4>

  <p>Если действия для разных случаев case совпадают, то они могут быть объединены.</p>

  <h4>4.7 Циклы (85)</h4>

  <p>Три вида циклов for, while, do-while</p>

  <h4>4.7.1 Цикл while</h4>

  <h4>4.7.2 Цикл for</h4>

  <p>Оператор continue имеет разное значение для циклов for и while. В цикле for происходит переход к приращению переменной цикла и проверке условия. В цикле while происходит переход к проверке условия, если переменная приращает свое значение в конце цикла while, то это приращение не происходит.</p>

  <h4>Цикл do</h4>

  <h4>4.8 Оператор break (87)</h4>

  <h4>4.9 Оператор continue (87)</h4>

  <h4>4.10 Оператор вызова функции (88)</h4>

  <h4>4.11 Оператор return (88)</h4>

  <h4>4.12 Оператор goto (88)</h4>

  <p>Производит переход к строке с указанной меткой</p>

  <h4>4.13 Метки операторов (89)</h4>

  <p>Метки нужны для того чтобы на них можно было делать ссылки в операторах goto</p>

  <h4>4.14 Задачи (89)</h4>
</article>


<!-- 5 Функции и завершенные программы -->
<article class="article">
  <div class="anchor" id="p5"></div>
  <h3>5 Функции и завершенные программы (90)</h3>

  <h4>5.1 Функции (90)</h4>
</article>


<!-- 6 Раздельная компиляция и абстрагирование данных -->
<article class="article">
  <div class="anchor" id="p6"></div>
  <h3>6 Раздельная компиляция и абстрагирование данных (132)</h3>

</article>


<!-- 7 Особые ситуации -->
<article class="article">
  <div class="anchor" id="p7"></div>
  <h3>7 Особые ситуации (152)</h3>

</article>


<!-- 8 Параллельное программирование -->
<article class="article">
  <div class="anchor" id="p8"></div>
  <h3>8 Параллельное программирование (168)</h3>

</article>


<!-- 9 Препроцессор языка Си -->
<article class="article">
  <div class="anchor" id="p9"></div>
  <h3>9 Препроцессор языка Си (183)</h3>

</article>


<!-- 10 Последний пример -->
<article class="article">
  <div class="anchor" id="p10"></div>
  <h3>10 Последний пример (195)</h3>

</article>


<!-- Приложения -->
<article class="article">
  <div class="anchor" id="p11"></div>
  <h3>Приложения (202)</h3>

</article>


<!-- Список литературы -->
<article class="article">
  <div class="anchor" id="p12"></div>
  <h3>Список литературы (257)</h3>

</article>

