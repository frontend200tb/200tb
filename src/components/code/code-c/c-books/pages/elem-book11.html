<article class="article">
  <h1>2019 Кольцов - Си на примерах. Практика, практика и только практика. 288c</h1>
  <p>Конспект книги</p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
        <a href="#pc1">Часть 1. Основные конструкции (22)</a>
    <br><a href="#p1">1 Выражения в Си (23)</a>
    <br><a href="#p2">2 Операторы в Си (55)</a>
    <br><a href="#p3">3 Массивы и строки в Си (75)</a>
    <br><a href="#p4">4 Указатели в Си (95)</a>
    <br><a href="#p5">5 Функции в Си (109)</a>
    <br><a href="#p6">6 Пользовательские типы в Си (128)</a>
    <br><a href="#p7">7 Ввод/вывод в Си (138)</a>
    <br><a href="#pc2">Часть 2. Алгоритмизация (172)</a>
    <br><a href="#p8">8 Очереди и стеки в Си (173)</a>
    <br><a href="#p9">9 Связанные списки и деревья в Си (180)</a>
    <br><a href="#p10">10 Алгоритмы поиска и сортировки в Си (201)</a>
    <br><a href="#p11">11 Многопоточность в Си (234)</a>
    <br><a href="#pc3">Часть 3. Практическое программирование (253)</a>
    <br><a href="#p12">12 Работа с сетью в Си (254)</a>
    <br><a href="#p13">13 Практический пример: компьютерная игра (271)</a>
  </p>
</article>


<!-- Часть 1. Основные конструкции -->
<article class="article">
  <div class="anchor" id="pc1"></div>
  <h3>Часть 1. Основные конструкции (22)</h3>

</article>


<!-- 1 Выражения в Си -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>1 Выражения в Си (23)</h3>

  <p>Стандарты языка Си: ANSI C, C89, C99, C11.</p>
  <p>Напишем программу, которая запрашивает число и выводит это число на экран.</p>

  <details>
    <summary>Программа 1 (18)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int k;
  printf("Enter number: ");
  scanf("%d", &k);
  printf("Number is: %d\n", k);

  return 0;
}
</pre>
  </details>

  <p>Выражения (expressions) это элементы языка Си состоящие из данных и операторов. Данные могут быть в виде переменных или в виде констант. Операторы выполняют операции над данными.</p>

  <h4>1.1 Основные типы данных (24)</h4>

  <p>В языке Си существует пять элементарных типов данных:</p>
  <ol>
    <li>char</li>
    <li>int</li>
    <li>float</li>
    <li>double</li>
    <li>void</li>
  </ol>
  <p>Остальные типы данных создаются на основе этих элементарных типов.</p>
  <p>Тип void используется для определения типа функции, не возвращающей значения или для создания обобщенного указателя.</p>
  <p>Типы данных char, int, double могут имеют модификаторы типа</p>
  <p>Тип char имеет два модификатора signed, unsigned. Тип int имеет четыре модификатора signed, unsigned, short, long. Тип double имеет один модификатор long.</p>
  <p>Для signed старший бит определяет знак числа: 0 для положительного, 1 для отрицательного.</p>

  <h4>1.2 Идентификаторы (26)</h4>

  <p>Имена идентификаторов чувствительны к регистру.</p>

  <h4>1.3 Переменные (27)</h4>

  <p>Переменная это область памяти, размером в соответсвии с ее типом, в которую записывается значение.</p>

  <h4>1.3.1 Локальные переменные</h4>

  <p>Локальные переменные объявляются внутри функции. Они используются только внутри функции, в которой объявлены, и не видны за ее пределами.</p>
  <p>Для объявления локальной переменной, используется ключевое слово auto. Но поскольку все локальные переменные по умолчанию являются auto, то это слово не используется.</p>
  <p>Переменную можно объявить в любом месте функции, но до первого ее использования.</p>
  <p>Если локальная переменная объявлена в блоке внутри фигурных скобок, то она уничтожается и ее значение теряется при выходе из блока. Локальная переменная также уничтожается и ее значение теряется при выходе из функции. Чтобы сохранить ее значение при следующих вызовах функции, надо ее объявить с ключевым словом static.</p>
  <p>Локальные переменные хранятся в стеке.</p>

  <h4>1.3.2 Формальные параметры</h4>

  <p>Аргументы передаются в функцию с помощью формальных параметров. Формальные параметры объявляются в круглых скобках после названия функции</p>
  <code>int sum(int a, int b);</code>
  <p>Внутри функции формальные параметры это локальные переменные, которые динамически создаются при вызове функции и разрушаются при выходе из нее.</p>

  <h4>1.3.3 Глобальные переменные</h4>

  <p>Глобальные переменные объявляются вне функций и доступны везде после их объявления.</p>

  <details>
    <summary>Программа 2 (31)</summary>
<pre>
#include &lt;stdio.h&gt;

int counter = 0;

void f1();
void f2();

int main() {
  counter = 100;
  f1();
  f2();

  return 0;
}

void f1() {
  int z = counter;
  printf("counter = %d\n", z);
}

void f2() {
  int z = counter;
  printf("counter = %d\n", z);
}
</pre>
  </details>

  <details>
    <summary>Программа 3 (32)</summary>
<pre>
#include &lt;stdio.h&gt;

int counter = 0;

void f1();
void f2();

int main() {
  counter = 100;
  f1();
  f2();

  return 0;
}

void f1() {
  int z = counter;
  printf("counter = %d\n", z);
}

void f2() {
  int counter = 200;
  printf("counter = %d\n", counter);
}
</pre>
  </details>

  <h4>1.3.4 Области видимости</h4>

  <p>В языке Си четыре области видимости:</p>
  <ol>
    <li>Файл. Глобальные переменные, объявленные вне функций.</li>
    <li>Блок. Локальные переменные, объявленные внутри блока из фигурных скобок. Область видимости с момента объявления до закрывающей фигурной скобки.</li>
    <li>Прототип функции. Переменные объявляются и видны только внутри прототипа функции.</li>
    <li>Функция. Локальные переменные, объявленные внутри функции, доступны только внутри функции.</li>
  </ol>

  <h4>1.3.5 Квалификаторы типа</h4>

  <p>Квалификаторы типа указывают на доступность и модифицируемость переменной. Есть три квалификатора</p>
  <ol>
    <li>
      <h4>const</h4>
      <p>Переменная не может быть изменена. Переменная должна быть инициализирована одновременно с объявлением.</p>
      <code>const port = 8080;</code>
      <p>Если в прототипе функции написать const перед указателем на переменную, то внутри функции ее изменить нельзя.</p>
      <code>size_t strlen(const char *str);</code>
    </li>
    <li>
      <h4>volatile</h4>
      <p>Переменная может изменяться неявно. Компиляторы оптимизируют выражения, считая что значения переменных не изменяются если они указаны справа от знака равенства и нет смысла перепроверять их значение при каждом обращении. Компиляторы меняют порядок вычисления выражений в ходе компиляции.</p>
    </li>
    <li>
      <h4>restrict</h4>
      <p>Появился в стандарте C99 и применяется только для указателей. К объекту на который ссылается такой указатель можно обратиться только с помощью этого указателя или с помощью выражений, вычисленных с помощью этого указателя.</p>
    </li>
  </ol>

  <h4>1.3.6 Спецификаторы хранения</h4>

  <p>Спецификатор хранения указывает где должна храниться переменная. Есть три спецификатора</p>
  <ol>
    <li>
      <h4>extern</h4>
      <p>Переменная объявлена в другом файле. В одном файле объявляются все глобальные переменные, а во всех остальных используется слово extern</p>
    </li>
    <li>
      <h4>static</h4>
      <p>Статические переменные не известны вне своей функции и файла, но сохраняет свое значение между вызовами функции. Статическая глобальная переменная не видна в других файлах. Статическая локальная переменная имеет постоянное место для хранения, как и глобальная.</p>
    </li>
    <li>
      <h4>register</h4>
      <p>Рекомендует компилятору размещать переменную не в области памяти, а в регистре центрального процессора. Операции над регистровыми переменными выполняются намного быстрее. Применяется только к локальным переменным.</p>
    </li>
  </ol>

  <h4>1.3.7 Инициализация переменных. Оператор присваивания</h4>

  <p>При объявлении переменной ее можно инициализировать константой или результатом выражения. После значение переменной можно менять с помощью оператора присваивания.</p>

  <h4>1.4 Константы (37)</h4>

  <p>Константы - это фиксированные значения, которые программа не может изменить. Константы могут быть целочисленные, символьные, строковые, с плавающей точкой.</p>

  <h4>1.5 Операторы (39)</h4>

  <h4>1.5.1 Оператор присваивания (39)</h4>

  <p>Слева от оператора присваивания должна стоять переменная, в которую будет записано значение справа от оператора присваивания. Справа может стоять константа или выражение. Если тип переменной слева и тип значения справа отличается, то происходит преобразование типов. Если типы невозможно преобразовать, то компилятор выдаст ошибку. Можно выполнить несколько присваиваний в одном выражении</p>
  <code>a = b = c = 0;</code>

  <h4>1.5.2 Арифметические операторы (41)</h4>

  <p>Напишем программу для нахождения частного и остатка при делении двух целых чисел.</p>

  <details>
    <summary>Программа 4 (42)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int dividend, divisor, quotient, reminder;

  printf("Enter divident: ");
  scanf("%d", &dividend);

  printf("Enter divisor: ");
  scanf("%d", &divisor);

  quotitent = dividend / divisor;
  reminder = dividend % divisor;

  printf("quotitent = %d\n", quotitent);
  printf("reminder = %d", reminder);

  return 0;
}
</pre>
  </details>

  <h4>1.5.3 Операторы сравнения и логические операторы (44)</h4>

  <p>В языке Си нет оператора XOR, но его можно реализовать самому.</p>
<pre>
int XOR(int x, int y) {
  return (x || y) && !(x && y);
}
</pre>

  <h4>1.5.4 Побитовые операторы (45)</h4>

  <p>Язык Си разрабатывался как замена языку ассемблера, поэтому в него вошли операции низкого уровня, такие как побитовые операции (bitwise operation) для проверки, установки и сдвига битов в байтах и машинных словах. Побитовые операции можно применить только к типам char и int. Они находят применения в написании драйверов устройств и в шифровальных программах.</p>

  <h4>1.5.5 Тернарный оператор (46)</h4>

  <p>Тернарный оператор это компактная форма записи оператора if-then-else</p>

  <h4>1.5.6 Оператор получения адреса (&) и разыменования ссылки (*) (47)</h4>

  <p>Указатель это переменная хранящая адрес объекта определенного типа. Адрес объекта можно получить, применив к нему операцию получения адреса &.</p>
  <code>int count = 1; int *addr = &count;</code>
  <p>Полученный адрес это адрес ячейки памяти, в которой находится переменная count. Адрес не связан со значением переменной. Изменяя значение переменной, ее адрес не изменится.</p>
  <p>Оператор разыменования указателя (*) возвращает значение объекта, расположенного по указанному адресу.</p>
  <code>int value = *addr; // 1</code>

  <h4>1.5.7 Статический оператор sizeof (48)</h4>

  <p>Оператор sizeof принимает тип или объект и возвращает размер в байтах. Тип нужно заключать в скобки, объект может быть в скобках, а может и без.</p>
<pre>
double v = 0;
printf("%d\n", sizeof v);       // 8
printf("%d\n", sizeof(double)); // 8
</pre>

  <h4>1.5.8 Оператор последовательного вычисления или запятая (49)</h4>

  <p>В одном выражении можно через запятую записать несколько выражений. Все эти выражения выполнятся последовательно. Результатом всего выражения станет значение после последней запятой</p>
  <code>z = (x = 2, x + 1);</code>

  <h4>1.5.9 Оператор доступа к члену структуры (50)</h4>

<pre>
struct car {
  float speed;
} priora;
</pre>
  <p>Для доступа к элементу speed структуры priora можно использовать оператор  . точка</p>
  <code>priora.speed = 55</code>
  <p>Если объявить указатель на структуру</p>
  <code>struct car *c = &priora;</code>
  <p>то доступ к элементу структуры через указатель происходит по оператору -> стрелка</p>
  <code>c->speed = 55;</code>

  <h4>1.5.10 Операторы [] и ()</h4>

  <p>Квадратные скобки нужны для доступа к элементам массива. Круглые скобки нужны для изменения приоритета операций.</p>

  <h4>1.5.11 Приоритеты операторов</h4>

  <p>Если в одном выражении встречается несколько операторов, то они выполняюстя в порядке их приоритета.</p>

  <h4>1.6 Практический пример: меняем местами два числа (52)</h4>

  <p>Введем два числа и поменяем их местами при помощи третьей переменной.</p>

  <details>
    <summary>Программа 5 (53)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  double a, b, temp;

  printf("Enter A: ");
  scanf("%lf", &a);
  printf("Enter B: ");
  scanf("%lf", &b);

  temp = a;
  a = b;
  b = temp;

  printf("A = %.2lf\n", a);
  printf("B = %.2lf\n", b);

  return 0;
}
</pre>
  </details>

  <p>Введем два числа и поменяем их местами без помощи третьей переменной.</p>

  <details>
    <summary>Программа 6 (54)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  double a, b;

  printf("Enter A: ");
  scanf("%lf", &a);
  printf("Enter B: ");
  scanf("%lf", &b);

  a = a - b;
  b = a + b;
  a = a - b;

  printf("A = %.2lf\n", a);
  printf("B = %.2lf\n", b);

  return 0;
}
</pre>
  </details>
</article>


<!-- 2 Операторы в Си -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>2 Операторы в Си (55)</h3>

  <p>Операторы друг от друга отделяются точкой с запятой.</p>

  <h4>2.1 Условные операторы (56)</h4>

  <p>Условный оператор проверяет выражение. Если выражение истинно, то выполняются какие-то действия.</p>

  <h4>2.1.1 Оператор if</h4>

  <p>Проверим является ли число четным.</p>

  <details>
    <summary>Программа 7 (57)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int num;

  printf("Enter integer: ");
  scanf("%d", &num);

  if (num % 2 == 0) {
    printf("%d - even", num);
  } else {
    printf("%d - odd", num);
  }

  return 0;
}
</pre>
  </details>

  <p>Проверим является ли год високосным.</p>

  <details>
    <summary>Программа 8 (58)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int year;

  printf("Enter year: ");
  scanf("%d", &year);

  if (year % 4 == 0) {
    if (year % 100 == 0) {
      if (year % 400 == 0) {
        printf("%d - visokosni", year);
      } else {
        printf("%d - ne visokosni", year);
      }
    } else {
      printf("%d - visokosni", year);
    }
  } else {
    printf("%d - ne visokosni", year);
  }

  return 0;
}
</pre>
  </details>

  <h4>2.1.2 Оператор switch</h4>

  <p>Оператор switch последовательно сравнивает значение выражения со списком целых чисел или символьных констант. При этом символьные константы автоматически преобразуются в целочисленные.</p>

  <details>
    <summary>Программа 9 (61)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char operator;
  double num1, num2;

  printf("Enter operator (+, -, *, /) ");
  scanf("%c", &operator);

  printf("Enter 2 numbers ");
  scanf("%lf %lf", &num1, &num2);

  switch(operator) {
    case '+':
      printf("%.11f + %.11f = %.11f", num1, num2, num1 + num2);
      break;
    case '-':
      printf("%.11f - %.11f = %.11f", num1, num2, num1 - num2);
      break;
    case '*':
      printf("%.11f * %.11f = %.11f", num1, num2, num1 * num2);
      break;
    case '/':
      if (num2 != 0) {
        printf("%.11f / %.11f = %.11f", num1, num2, num1 / num2);
      } else {
        printf("Division by zero prohibiten");
      }
      break;
    default:
      printf("Error operator");
  }

  return 0;
}
</pre>
  </details>

  <h4>2.2 Операторы цикла (63)</h4>

  <p>Циклы выполняют повторяющиеся инструкции пока истинно заданное условие.</p>

  <h4>2.2.1 Цикл for</h4>

  <p>Цикл for это цикл со счетчиком. Его применяют когда заранее известно число повторений.</p>

  <details>
    <summary>Программа 10 (63)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int n, sum = 0;
  printf("Enter positive integer ");
  scanf("%d", &n);

  for (int i = 1; i &lt;= n; i++) {
    sum += i;
  }

  printf("Sum = %d", sum);

  return 0;
}
</pre>
  </details>

  <p>Если условие выполнения цикла не указано, то оно считается истинным и цикл получится бесконечным.</p>

  <h4>2.2.2 Цикл while</h4>

  <p>Такой цикл удобно использовать когда заранее не известно количество повторений.</p>

  <details>
    <summary>Программа 11 (65)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
  int k = 0, i = 0;

  while (k &lt; 7) {
    k = 1 + rand() % 10;
    printf("%d ", k);
    i++;
  }

  printf("repeat %d times", i);

  return 0;
}
</pre>
  </details>

  <details>
    <summary>Программа 12 (66)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int n, i = 1, sum = 0;
  printf("Enter positive integer ");
  scanf("%d", &n);

  while (i &lt;= n) {
    sum += i;
    i++;
  }

  printf("Sum = %d", sum);

  return 0;
}
</pre>
  </details>

  <p>Бесконечные циклы часто используются на практике. Например, сервер в бесконечном цикле обрабатывает подключения клиентов. Для него даже не нужно условие выхода из цикла, так как сервер должен обрабатывать запросы постоянно. Впрочем, прервать цикл можно и в самой консоли. Для этого надо нажать Ctrl+C в терминале, где запущена программа с бесконечным циклом.</p>

  <h4>2.2.3 Цикл do-while</h4>

  <p>Сначала выполняется тело цикла, потом проверяется условие. Это нужно, чтобы цикл выполнился хотя бы один раз.</p>

  <details>
    <summary>Программа 13 (68)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int n, sum = 0;

  do {
    printf("Enter positive integer ");
    scanf("%d", &n);
  } while (n &lt; 0);

  for (int i = 1; i &lt;= n; i++) {
    sum += i;
  }

  printf("Sum = %d", sum);

  return 0;
}
</pre>
  </details>

  <h4>2.3 Операторы перехода (69)</h4>

  <p>В языке Си есть четыре оператора безусловного перехода: return, goto, break, continue.</p>

  <h4>2.3.1 Оператор return</h4>

  <p>Это оператор возврата из функции. Применяется только внутри функции и выполняет возврат в точку вызова функции. Если функция имеет тип void, то есть не возвращает значение, то оператор return можно не писать. В этом случае компилятор сам подставит оператор return перед закрывающей фигурной скобкой функции.</p>

  <h4>2.3.2 Оператор goto</h4>

  <p>Оператор производит безусловный переход к указанной метке. Оператор и метка должны находиться в одной функции. В современных программах этот оператор не используется.</p>

  <h4>2.3.3 Операторы break и continue</h4>

  <p>Оператор break используется в циклах и конструкции switch и выполняет выход из них.</p>
  <p>Оператор continue используется только в циклах и выполняет переход на проверку условия цикла и после этого к следующей итерации.</p>

  <h4>2.4 Операторы-выражения (72)</h4>

  <p>Оператор (инструкция) это выражение, которое завершается точкой с запятой. Например</p>
  <code>a = b + c; // присваивание</code>
  <code>sum(a, b); // вызов функции</code>
  <code>b + c; // значение оператора будет потеряно</code>
  <code>; // пустой оператор</code>

  <h4>2.5 Блоки</h4>

  <p>Блок это группа операторов, заключенная в фигурные скобки.</p>

  <h4>2.6 Функция exit()</h4>

  <p>Функция exit завершает программу и передает управление программе (операционной системе) вызвавшей ее. Функция exit возвращает целое значение в то место, где была вызвана программа.</p>
</article>


<!-- 3 Массивы и строки в Си -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>3 Массивы и строки в Си (75)</h3>

  <h4>3.1 Одномерные массивы</h4>

  <p>Одномерный массив представляет собой список переменных, имеющих одинаковый тип и хранящихся в соседних ячейках памяти в порядке возрастания индексов. Младший адрес занимает первый элемент массива, старший - последний. Массив занимает память равную размеру типа умноженному на число элементов.</p>

  <h4>3.2 Указатель на массив</h4>

  <p>Имя массива это адрес ячейки памяти, с которой начинается массив. По этому адресу также находится первый элемент массива. Если у нас есть массив nums, то выражения nums и &nums[0] эквивалентны и указывают на один и тот же элемент.</p>
  <p>В языке Си нельзя передать массив в функцию. Вместо этого передают указатель на массив. Есть три способа передачи в функцию указателя на массив:</p>
  <ol>
    <li>В качестве аргумента объявить указатель
      <code>int max(int *x) {}</code>
    </li>
    <li>Передать указатель на массив фиксированного размера
      <code>int max(int x[10]) {}</code>
    </li>
    <li>Использовать массив неопределенного размера
      <code>int max(int x[]) {}</code>
    </li>
  </ol>
  <p>Размер массива, передаваемого в функцию, не имеет никакого значения, поскольку проверка выхода индекса за пределы в языке Си не предусмотрена. В функцию передается не массив, а указатель на его первый элемент и тип элемента, который определяет размер элемента.</p>

  <h4>3.3 Работа со строками (81)</h4>

  <h4>3.3.1 Объявление строки</h4>

  <p>Константы символьных строк помещаются в класс статической памяти. Длину строки компилятор вычислит автоматически.</p>
  <p>Объявим массив символов</p>
  <code>char name[21];</code>
  <p>Объявим строку как массив символов</p>
  <code>char s[] = "string";</code>
  <p>Объявим строку как указатель на символ. В память запишется строка, но ps это указатель на символ.</p>
  <code>char *ps = "string";</code>

  <h4>3.3.2 Правильное выделение памяти под строку</h4>

  <p>Строка всегда должна заканчиваться символом '\0', который занимает еще один байт памяти.</p>

  <h4>3.3.3 Функции для работы со строками</h4>

  <p>Заголовочный файл string.h содержит прототипы функций для работы со строками.</p>

  <h4>3.3.4 Работа со строкой как с массивом символов</h4>

  <p>Напишем программу, которая удаляет из массива все символы, кроме цифр.</p>

  <details>
    <summary>Программа 14 (84)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char line[101];
  int i, j;
  gets(line);

  for (i = 0; line[i] != '\0'; i++) {
    while (!((line[i] >= '0' && line[i] &lt;= '9') || line[i] == '\0')) {
      for (j = i; line[j] != '\0'; j++) {
        line[j] = line[j+1];
      }
      line[j] = '\0';
    }
  }

  printf("%s", line);

  return 0;
}
</pre>
  </details>

  <p>Пользователь вводит строку в переменную line. Проверяем каждый символ. Если это не цифра, то все символы после него сдвигаем влево на один.</p>

  <h4>3.3.5 Пример использования библиотечных функций</h4>

  <h4>3.3.6 Многобайтовые строки. Работа с UTF-8</h4>

  <p>При работе с английским языком, который располагается в таблице ASCII, все символы занимают 1 байт. При работе в кодировке unicode символы национальных алфавитов занимают 2 байта, но символы таблицы ASCII по прежнему занимают 1 байт, потому что они расположены в первом байте символов unicode.</p>
  <p>Для работы с юникодом надо использовать широкие символы с типом wchar_t и функции для работы с ними из заголовочного файла wchar.h.</p>

  <details>
    <summary>Программа 15 (87)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;wchar.h&gt;
#include &lt;locale.h&gt;
#include &lt;stdlib.h&gt;

int main() {
  wchar_t buf[BUFSIZ];
  wchar_t *pch;
  size_t count;

  setlocale(LC_ALL, "");

  fputws(L"Введите свое имя: ", stdout);
  fflush(stdout);

  fgetws(buf, BUFSIZ, stdin);
  fputws(L"Ваше имя ", stdout);

  if ((pch = wcschr(buf, L'\n')) != NULL) {
    *pch = L'\0';
  }

  for (pch = buf, cout = 0; *pch != L'\0'; pch++, cout++) {
    putwchar(*pch);
  }

  putwchar(L'\n');

  wprintf(L"Введено букв %zd\n", count);

  return 0;
}
</pre>
  </details>

  <h4>3.4 Многомерные массивы (88)</h4>

  <p>Объявим двумерный массив из 100 строк и 200 столбцов</p>
  <code>int c[100][200];</code>
  <p>Если двумерный массив передается в функцию, то как и при одномерном массиве, в функцию передается указатель на его первый элемент.</p>
  <p>Напишем программу сложения двух матриц, используя многомерные массивы.</p>

  <details>
    <summary>Программа 16 (89)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int r, c, a[100][100], b[100][100], sum[100][100];
  printf("Enter number of rows");
  scanf("%d", &r);
  printf("Enter number of colons");
  scanf("%d", &c);

  printf("Enter elements of A matrix");
  for (int i = 0; i &lt; r; i++) {
    for (int j = 0; j &lt; c; j++) {
      printf("Enter element A[%d][%d] ", i+1, j+1);
      scanf("%d", &a[i][j]);
    }
  }

  printf("Enter elements of B matrix");
  for (int i = 0; i &lt; r; i++) {
    for (int j = 0; j &lt; c; j++) {
      printf("Enter element B[%d][%d] ", i+1, j+1);
      scanf("%d", &b[i][j]);
    }
  }

  // сложение двух матриц
  for (int i = 0; i &lt; r; i++) {
    for (int j = 0; j &lt; c; j++) {
      sum[i][j] = a[i][j] + b[i][j];
    }
  }

  // вывод результата
  printf("Sum of 2 matrix");
  for (int i = 0; i &lt; r; i++) {
    for (int j = 0; j &lt; c; j++) {
      printf("%d ", sum[i][j]);
    }
    printf("\n");
  }

  return 0;
}
</pre>
  </details>
  <p>Напишем программу умножения двух матриц, используя многомерные массивы. Чтобы умножить две матрицы, число колонок первой матрицы должно быть равно числу строк второй матрицы. Нужно каждую строку первой матрицы умножить на каждый столбец второй матрицы.</p>

  <details>
    <summary>Программа 17 (91)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int r1, c1, r2, c2, a[10][10], b[10][10], res[10][10];
  printf("Enter number rows and colons matrix1");
  scanf("%d %d", &r1, &c1);
  printf("Enter number rows and colons matrix2");
  scanf("%d %d", &r2, &c2);

  while (c1 != r2) {
    printf("Error %d != %d", r1, c2);
    printf("Enter number rows and colons matrix1");
    scanf("%d %d", &r1, &c1);
    printf("Enter number rows and colons matrix2");
    scanf("%d %d", &r2, &c2);
  }
  printf("Enter elements of matrix1");
  for (int i = 0; i &lt; r1; i++) {
    for (int j = 0; j &lt; c1; j++) {
      printf("Enter element A[%d][%d] ", i+1, j+1);
      scanf("%d", &a[i][j]);
    }
  }

  printf("Enter elements of matrix2");
  for (int i = 0; i &lt; r2; i++) {
    for (int j = 0; j &lt; c2; j++) {
      printf("Enter element B[%d][%d] ", i+1, j+1);
      scanf("%d", &b[i][j]);
    }
  }

  // создаем матрицу результата
  for (int i = 0; i &lt; r1; i++) {
    for (int j = 0; j &lt; c2; j++) {
      res[i][j] = 0;
    }
  }

  // умножение двух матриц
  for (int i = 0; i &lt; r1; i++) {
    for (int j = 0; j &lt; c2; j++) {
      for (int k = 0; k &lt; c1; k++) {
        res[i][j] += a[i][k] + b[k][j];
      }
    }
  }

  // вывод результата
  printf("Priduct of 2 matrix");
  for (int i = 0; i &lt; r1; i++) {
    for (int j = 0; j &lt; c2; j++) {
      printf("%d ", res[i][j]);
    }
    printf("\n");
  }

  return 0;
}
</pre>
  </details>

  <h4>3.5 Индексация указателей (93)</h4>

  <p>Обращение к элементам массива с помощью указателей используется довольно широко, поскольку операции адресной арифметики выполняются быстрее, чем индексация.</p>

  <h4>3.6 Инициализация массива (94)</h4>

  <code>int j[5] = {1,2,3,4,5};</code>
  <code>char s[20] = "Hello!";</code>
  <code>char s[20] = {'H','e','l','l','o','!','\0'};</code>
<pre>
int s[2][2] = {
  {1,1},
  {2,2}
}
</pre>
</article>


<!-- 4 Указатели в Си -->
<article class="article">
  <div class="anchor" id="p4"></div>
  <h3>4 Указатели в Си (95)</h3>

  <h4>4.1 Что такое указатели и для чего они нужны (95)</h4>

  <p>Укзатель это переменная, содержащая адрес другой переменной.Указатель нужен для обращения к другой переменной через ее адрес. Указатели позволяют функциям изменять свои аргументы. Указатели позволяют делать динамическое распределение памяти. Указатели повышают эффективность многих процедур.</p>

  <h4>4.2 Объявление указателей и операторы для работы с ними (96)</h4>

  <p>При объявлении указателя надо писать тип переменной, на которую он будет указывать. Указатель может содержать любой адрес с любым типоп переменной, но для правильной арифметики указателей, необходимо этот тип сразу объявлять. Указатель можно присвоить другому указателю.</p>

  <h4>4.3 Адресная арифметика (98)</h4>

  <code>int *p = num;</code>
  <p>Указатель p содержит адрес переменной num, которая занимает 4 байта памяти.</p>
  <p>p++;</p>
  <p>Указатель p  увеличится не на 1, а на 4. И будет указывать на следующий адрес с переменной типа int. Указатель увеличивается или уменьшается на размер типа данных на который он указывает.</p>
  <p>Указатели сравниваются между собой только когда они указывают на один и тот же объект или массив.</p>

  <h4>4.4 Массивы указателей (100)</h4>

  <p>Массив указателей можно передать в обычную функцию.</p>

  <h4>4.5 Инициализация указателей (101)</h4>

  <p>Глобальные и статические указатели автоматически инициализируются нулем. Если не инициализировать нестатический локальный указатель, то его значение неопределено. При обращении к нему программа завершится ошибкой. При объявлении указатель нужно инициализировать. Если нечем, то значением NULL.</p>
  <code>struct lnode *new = NULL;</code>

  <h4>4.6 Нулевой указатель (NULL) (102)</h4>

  <p>Указатель до инициализации хранит мусор. При определении указателя принято делать его равным NULL.</p>

  <details>
    <summary>Программа 18 (103)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;conio.h&gt;

int main() {
  int *a = NULL;
  unsigned length;
  printf("Enter size of array ");
  scanf("%d", length);

  if (length > 0) {
    if ((a = (int*)malloc(length * sizeof(int))) != NULL) {
      for (int i = 0; i &lt; length; i++) {
        a[i] = i * i;
      }
    } else {
      printf("cannot allocate memory");
    }
  }

  if (a != NULL) {
    free(a);
  }

  return 0;
}
</pre>
  </details>

  <h4>4.7 Указатели на функции (104)</h4>

  <p>Хотя функция и не является переменной, но она также располагается в памяти и ее адрес можно присвоить указателю. Этот адрес считается точкой входа в функцию и используется при ее вызове. Когда указатель ссылается на функцию, ее можно вызвать с помощью этого указателя.</p>
  <p>Адрес функции задается ее именем без скобок и аргументов.</p>

  <h4>4.8 Динамическое распределение памяти (105)</h4>

  <p>В ходе выполнения программы возникает необходимость выделить дополнительную память, размер которой заранее не известен. Например, связные списки или деревья, они могут увеличиваться или уменьшаться по мере необходимости.</p>
  <p>Функции распределения памяти - malloc() и calloc(), функция освобождения памяти - free().</p>
  <p>Динамическая память находится в куче (heap), которая представляет собой область свободной памяти, расположенную между кодом программы, сегментом данных и стеком.</p>
  <p>Выделим 2000 байт непрерывной памяти</p>
  <code>char *s; s = malloc(2000);</code>
  <p>Напишем программу вычисления максимума в массиве, размер которого мы не знаем</p>

  <details>
    <summary>Программа 19 (107)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int num;
  float *data;

  printf("enter numbers of elements ");
  scanf("%d", &num);

  data = (float*)calloc(num, sizeof(float));

  if (data == NULL) {
    printf("error allocation memory\n");
    exit(1);
  }

  printf ("\n");

  for (int i = 0; i &lt; num; i++) {
    printf("enter element %d ", i + 1);
    scanf("%f", data + i);
  }

  for (int i = 0; i &lt; num; i++) {
    if (*data &lt; *(data + i)) {
      *data = *(data + i);
    }
  }

  printf("maximum = %.2f\n", *data);

  return 0;
}
</pre>
  </details>
</article>


<!-- 5 Функции в Си -->
<article class="article">
  <div class="anchor" id="p5"></div>
  <h3>5 Функции в Си (109)</h3>

  <h4>5.1 Синтаксис объявления функции (109)</h4>

  <p>Функция может возвращать переменные любого типа кроме массива.</p>
  <p>Напишем функцию checkPrimeNumber(), которая возвращает 1, если число является простым или 0 в противном случае.</p>
<pre>
int checkPrimeNumber(int n) {
  int flag = 1;
  for (int i = 2; i &lt;= n / 2; i++) {
    if (n % i == 0) {
      flag = 0;
      break;
    }
  }

  return flag;
}
</pre>

  <h4>5.2 Область видимости функции (110)</h4>

  <p>Тело функции это отдельный блок операторов, заключенный в {} фигурные скобки. Код и данные одной функции никак не взаимодействуют с кодом и данными другой функции, поскольку имеют различные области видимости. Локальные переменные функции создаются при входе в функцию и уничтожаются при выходе из нее и не сохраняют свое значение между вызовами функции. Кроме статических локальных переменных. Они хранятся вместе с глобальными переменными, но их область видимости ограничена функцией.</p>

  <h4>5.3 Формальные параметры функции (111)</h4>

  <h4>5.3.1 Список параметров</h4>

  <p>Формальные параметры функции объявляются в заголовке в виде переменных и как и локальные переменные создаются при входе функции и уничтожаются при выходе из нее.</p>
  <p>Напишем функцию gcd, которая вычисляет НОД двух чисел.</p>
<pre>
int gcd(int n1, int n2) {
  if (n2 != 0) {
    return gcd(n2, n1 % n2);
  } else {
    return n1;
  }
}
</pre>

  <h4>5.3.2 Параметры по ссылке и по значению</h4>

  <p>Параметры в функцию можно передавать по ссылке (call by reference) и по значению (call by value).</p>
  <p>В случае передачи по значению, функция создает копию параметра и работает с ним. При этом не оказывая влияния на переданную переменную в основной программе.</p>
  <p>В случае передачи по ссылки, в функцию передается адрес аргумента. Функция создает копию адреса и работает с ним, изменяя значение переменной, записанной по этому адресу. При этом не оказывая влияния на сам адрес переданный в функцию из основной программы.</p>

  <h4>5.3.3 Передача массива в качестве параметра</h4>

  <p>Если функция должна принимать массив, то ей передается адрес массива. Функция при этом получает доступ ко всем элементам массива и может его модифицировать.</p>
  <p>Перепишем программу умножения двух матриц с использованием функций. Будет три функции:</p>
  <ol>
    <li>enterData() ввод данных от пользователя</li>
    <li>multiplyMatrices() умножение двух матриц</li>
    <li>display() отображение матрицы</li>
  </ol>

  <h4>5.3.4 Аргументы функции main() (119)</h4>

  <p>Функция main() может принять параметры argc и argv при вызове программы из командной строки.</p>
  <p>argc содержит количество аргументов, первым аргументом всегда передается имя программы, поэтому argc не может быть меньше 1. Все аргументы командной строки принимаются как строки, поэтому argv это указатель на массив символьных указателей.</p>

  <h4>5.4 Оператор return (121)</h4>

  <h4>5.5 Тип void (122)</h4>

  <h4>5.6 Рекурсия (123)</h4>

  <h4>5.7 Прототипы функций (125)</h4>
</article>


<!-- 6 Пользовательские типы в Си -->
<article class="article">
  <div class="anchor" id="p6"></div>
  <h3>6 Пользовательские типы в Си (128)</h3>

  <h4>6.1 Структуры (128)</h4>

  <p>В языке Си можно создавать пользовательские типы данных. Для этого служат структуры.</p>

  <h4>6.1.1 Объявление структуры</h4>

  <p>Объявление структуры еще не создает ни одной переменной, это просто описание пользовательского типа данных. Для того чтобы создать переменную данного типа, ее нужно объявить отдельно.</p>

  <h4>6.1.2 Доступ к членам структуры</h4>

  <p>Доступ к членам структуры осуществляется через точку.</p>

  <h4>6.1.3 Массивы структур и динамическое выделение памяти</h4>

  <p>Можно создать массив структур. Но как создать массив структур если не известно количество его элементов? Выделить память под большое число элементов это неправильно. А вдруг столько не понадобится, или понадобится еще больше? В этом случае нужно использовать динамическое выделение памяти. Мы можем выделить ровно столько памяти, сколько нам нужно с помощью функции malloc.</p>

  <h4>6.1.4 Передача структур функциям</h4>

  <p>Структуры можно передавать функциям. Передавать можно как члены структур, так и структуры целиком.</p>

  <h4>6.1.5 Указатели на структуры</h4>

  <p>Можно создать указатель на структуру. Тогда доступ к члену структуры через указатель выполняется не через точку, а через стрелочку ->.</p>
  <p>Если в функцию передавать структуру, то создается копия структуры и функция пользуется копией. При этом тратится лишнее память на копию структуры и лишнее время на ее создание. Этого можно избежать если в функцию передавать не саму структуру, а указатель на нее. При этом функции передается лишь адрес. При этом функция сможет модифицировать саму структуру.</p>

  <h4>6.2 Объединения (135)</h4>

  <p>Объединение содержит несколько типов данных, однако эти данные занимают одну и ту же область памяти.</p>

  <h4>6.3 Перечисления и typedef</h4>

  <p>С помощью оператора typedef можно создать псевдонимы к существующим типам данных.</p>
  <p>Перечисление enum определяет список целых чисел, каждое из которых имеет собственное имя. По умолчанию числа начинаются с 0 и идут последоветельно. Но можно назначить и свои числа для каждой из перечисленных констант. С такими константами можно производить арифметические действия.</p>
</article>


<!-- 7 Ввод/вывод в Си -->
<article class="article">
  <div class="anchor" id="p7"></div>
  <h3>7 Ввод/вывод в Си (138)</h3>

  <p>В языке Си ввод и вывод данных возможен только с помощью библиотечных функций. Ввод и вывод работает и с консолью и с файлами. Технически консоль и файлы ничем не отличаются друг от друга.</p>
  <p>Помимо того, что язык Си не содержит функций для работы с вводом и выводом, он еще и не содержит функций для работы с графическим интерфейсом. Невозможно создать функции специфические для работы с каждой платформой. Поэтому библиотеки содержать функции, которые обращаются к операционной системе для ввода-вывода или работы с графикой.</p>

  <h4>7.1 Консольный ввод-вывод (139)</h4>

  <h4>7.1.1 Чтение и запись символов</h4>

  <p>Функция getchar() считывает символ с клавиатуры. Она не принимает аргументы. Если все хорошо, то она возвращает целое однобайтовое значение - код символа. Если происходит ошибка, то она возвращает EOF (End Of File).</p>
  <p>Функция putchar() выводит символ на экран. В нее можно передать или символ, или целое однобайтовое число - код символа. Если все хорошо, то она возвращает целое однобайтовое значение - код символа. Если происходит ошибка, то она возвращает EOF (End Of File).</p>
  <p>Функция getchar помещает входные данные в буфер, пока не будет нажата клавиша ENTER. Это не удобно использовать в играх. Не будет же пользователь после нажатия на стрелку каждый раз нажимать ENTER.</p>
  <p>Функция getch() сразу же возвращает код нажатой клавиши как только клавиша нажата. При этом сам символ не отображается на экране. Если символ на экране должен отображатья то используют такую же функцию getche().</p>
  <p>getch это не стандартная функция и находится в заголовочном файле conio.h. Функцию getch можно реализовать самостоятельно</p>
<pre>
int getch() {
  return fgetc(stdin);
}
</pre>

  <h4>7.1.2 Чтение и вывод строк</h4>

  <p>Функция gets(char *buf) читает строку и записывает ее по адресу, указанному в аргументе. Строка читается до нажатия клавиши ENTER. В конец строки записывается нулевой байт '\0'. Функция gets не проверяет выход строки за границы массива символов, куда она записывается. Это может вызвать переполнение массива и ошибку. Поэтому вместо нее используют функцию gets_s().</p>
  <p>Функция gets_s(char *buf, size_t n) читает строку и записывает ее по адрезу, указанному в аргументе. Читается не более n-1 символов, а последним символом записывается '\0'.</p>
  <p>Функция puts() выводит строку на экран и переводит курсор на новую строку.</p>

  <h4>7.1.3 Форматированный вывод: функция printf()</h4>

  <p>Если нужно вывести переменные, числа, константы, то используют форматированный ввод printf().</p>

  <h4>7.1.3 Форматированный ввод: функция scanf()</h4>

  <p>scanf может считать данные всех встроенных типов и автоматически преобразовать их в соответствующий формат. Аргументами функции scanf могут быть только указатели, поэтому перед именем переменной нужно указывать &. Исключение составляют строки, которые считываются в символьные массивы, поскольку имя массива является также и указателем на адрес в памяти.</p>
  <p>Поскольку scanf считывает строки только до пробельного символа, в нее нельзя считать строку, содержащую пробел. Для этого нужно использовать функцию gets или gets_s.</p>

  <h4>7.2 Файловый ввод-вывод (154)</h4>

  <h4>7.2.1 Файлы и потоки</h4>

  <p>Программист работает с абстракцией - записывает в нее данные или читает из нее данные. Такая абстракция называется поток. Поток уже работает с физическим устройством (файл, или консоль, или принтер). Существует два вида потоков: текстовые и бинарные.</p>
  <p>Текстовый поток - это последовательность символов (однобайтовых кодов символов из таблицы ASCII). Можно организовать поток в виде строк, если каждую строку заканчивать символом перехода на новую строку '\n'. В зависимости от устройства вывода, символ '\n' может заменяться на два символа \r\n. Поэтому количество символов выводимых в поток и на внешнем устройстве может быть разным.</p>
  <p>Бинарный поток - это последовательность байтов. На внешнее устройство всегда выводится столько байтов, сколько передается в поток.</p>
  <p>Для языка Си все физические устройства считаются файлами: файл на диске, дисплей, принтер. Так же работает и операционная система UNIX. Но для пользователей Windows это уже новшество. Не все файлы ведут себя одинаково. Например, из файла на жестком диске можно прочитать данные, а из файла принтера нельзя.</p>
  <p>При закрытии файла курсор позиции устанавливается на его начало и связь с потоком разрывается. При переходе к очередному символу (чтение или запись) курсор смещается на одну позицию вперед.</p>

  <h4>7.2.2 Основные функции файлового ввода-вывода</h4>

  <p>Функций файлового ввода-вывода больше чем консольного, поскольку они содержать функции открытия-закрытия файла и перемещения курсора.</p>

  <h4>7.2.3 Открытие и закрытие файла</h4>

  <p>Функция fopen() открывает файл и возвращает указатель на него. Если произошла ошибка, то возвращается NULL. Эту ошибку всегда нужно проверять. Функция fclose() записывает все оставшиеся в буфере данные в файл и закрывает его.</p>
<pre>
FILE *fptr;
fptr = fopen("text.txt", "w");
if (fptr == NULL) {
  printf("Error!\n");
}
fclose(fptr);
</pre>

  <h4>7.2.4 Чтение и запись символов</h4>

  <p>Функция fputc() записывает символ.</p>
  <p>Функция fgetc() читает символ и переводит курсор на следующий символ. При достижении конца файла возвращает EOF.</p>
<pre>
FILE *fp;
char c;
fp = fopen("text.txt", "r");
do {
  c = fgetc(fp);
  putchar(c);
} while (c != EOF);
fclose(fp);
</pre>
  <p>Функция fgets() может вернуть EOF при достижении конца файла, при возникновении ошибки, при чтении константы EOF из бинарного файла. Поэтому для однозначного определения конца файла используют функцию feof().</p>
  <p>Функция feof() возвращает конец файла.</p>
<pre>
while (!feof(fp)) {
  c = fgetc(fp);
}
</pre>

  <h4>7.2.5 Чтение и запись строк</h4>

  <p>Функция fputs() записывает строку.</p>
  <p>Функция fgets() читает строку.</p>

  <h4>7.2.6 Функция ferror()</h4>

  <p>Функция ferror() возвращает истинное значение, если возникла ошибка, иначе ложное значение. Ее нужно вызывать сразу после выполнения операции с файлом, иначе ошибка будет упущена.</p>

  <h4>7.2.7 Сброс буфера - функция fflush()</h4>

  <p>Функция fflush() сбрасывает содержимое буфера в файл.</p>

  <h4>7.2.8 Удаление файла</h4>

  <p>Функция remove() принимает имя файла и удаляет его. В случае успеха возвращает 0, в случае ошибки - другое значение.</p>
<pre>
if (remove("file.txt")) {
  printf("Error");
} else {
  printf("file is remved");
}
</pre>

  <h4>7.2.9 Функции fread() и fwrite()</h4>

  <p>Функция fread() читает данные и возвращает количество считанных блоков. Если количество блоков меньше заданного то или обнаружен конец файла или возникла ошибка.</p>
  <p>Функция write() записывает данные и возвращает количество записанных блоков. Если количество блоков меньше заданного, то произошла ошибка, например закончилось место на диске.</p>

  <h4>7.2.10 Функция fprintf() и fscanf()</h4>

  <p>Аналогичны консольным printf и scanf, только первым параметром передается указатель на файл.</p>

  <h4>7.3 Работа с каталогами (166)</h4>

  <h4>7.3.1 Создание каталога</h4>

  <p>Для создания каталога используются системные вызовы.</p>
  <p>Создадим каталог в Linux с помощью функции mkdir, которая принимает имя каталога и режим доступа к нему.</p>
<pre>
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
mkdir("cat", S_IRUSR);
</pre>
  <p>Создадим каталог в Windows с помощью функции mkdir, которая принимает имя каталога.</p>
<pre>
#include &lt;dir&gt;
mkdir("cat");
</pre>
  <p>В случае успеха, функция mkdir вернет 0, иначе - отличное от нуля значение.</p>

  <h4>7.3.2 Чтение каталога</h4>

  <p>Сначала нужно открыть поток, потом произвести чтение из потока, потом закрыть поток.</p>

  <h4>7.3.3 Удаление каталога</h4>

  <p>Для удаления каталога используется системный вызов rmdir(). Она принимает имя каталога и удаляет его если он пуст и не является текущим каталогом. Поэтому перед удалением каталог надо очистить и установить другой рабочий каталог.</p>

  <h4>7.3.4 Получение рабочего каталога</h4>

  <p>В Linux системная функция getcwd() копирует абсолютный путь к текущемму рабочему каталогу.</p>

  <h4>7.3.5 Пример работы с каталогом</h4>
</article>


<!-- Часть 2. Алгоритмизация -->
<article class="article">
  <div class="anchor" id="pc2"></div>
  <h3>Часть 2. Алгоритмизация (172)</h3>

</article>


<!-- 8 Очереди и стеки в Си -->
<article class="article">
  <div class="anchor" id="p8"></div>
  <h3>8 Очереди и стеки в Си (173)</h3>

  <h4>8.1 Очередь (174)</h4>

  <p>Очередь это линейный список данных. Есть только один вариант работы с очередью: данные добавляются в конец очереди, а читаются и удаляются с начала очереди.</p>
  <p>Напишем код функций qin() для добавления строки в очередь и qout() для чтения и удаления строки из очереди.</p>
<pre>
#define MAX[10]

char *p[MAX];
int in_pos;
int out_pos;

void qin(char *q) {
  if (in_pos == MAX) {
    printf("Queue is full\n");
    return;
  }
  p[in_pos] = q;
  in_pos++;
}

char *qout() {
  if (in_pos == out_pos) {
    printf("Queue is empty\n");
    return '\0';
  }
  out_pos++;
  return p[out_pos - 1];
}
</pre>

  <h4>8.2 Стеки (177)</h4>

  <p>Стек это линейный список данных. Есть только один вариант работы со стеком: данные добавляются в конец стека и читаются и удаляются из конца стека.</p>

</article>


<!-- 9 Связанные списки и деревья в Си -->
<article class="article">
  <div class="anchor" id="p9"></div>
  <h3>9 Связанные списки и деревья в Си (180)</h3>

  <p>Связанный список это динамическая структура данных, состоящая из узлов, где каждый узел содержит данные и ссылку на следующий узел.</p>

  <h4>9.1 Односвзязные списки (181)</h4>

  <p>В односвязном списке каждый узел содержит данные и ссылку на следующий узел. Обход односвязного списка возможен только в одном направлении.</p>
<pre>
typedef struct list_node {
  struct list_node *next;
  void *data;
} list_node_t;
</pre>

  <h4>9.1.1 Инициализация списка</h4>

  <p>При инициализации списка выделяется необходимая память, устанавливается размер списка, указатели head и tail.</p>

  <h4>9.1.2 Добавление узла</h4>

  <p>Функция добавления узла в начало списка list_push() выделяет память под новый элемент списка, добавляет данные в элемент, создает указатель на следующий элемент - голову списка, изменяет размер списка.</p>
  <p>Функция добавления узла в конец списка list_push_back() выделяет память под новый элемент списка, добавляет данные в элемент, создает указатель на NULL, изменяет указатель предыдущего элемента, изменяет размер списка.</p>

  <h4>9.1.3 Извлечение узла</h4>

  <h4>9.1.4 Реализация стека и очереди</h4>

  <h4>9.1.5 Практический пример: реверс односвязного списка</h4>

<pre>
while (a != NULL) {
  c = b;
  b = a;
  a = a->next;
  b->next = c;
}
</pre>

  <h4>9.2 Двусвязный список (188)</h4>

  <p>В двусвязном списке каждый узел содержит данные и ссылку на следующий и предыдущий узел. Обход односвязного списка возможен в двух направлениях.</p>
<pre>
struct list {
  int data;
  struct list *next;
  struct list *prev;
};
</pre>

  <h4>9.2.1 Инициализация списка</h4>

  <p>При инициализации создается корневой узел, у которого указатели на предыдущий и следующий элементы указывают на NULL.</p>

  <h4>9.2.2 Добавление узла</h4>

  <p>Для добавления нужно передать указатель на узел, после которого будет добавлятся элемент и данные для нового элемента.</p>

  <h4>9.2.3 Удаление узла</h4>

  <p>При удалении нажно передать указатель на удаляемый узел.</p>

  <h4>9.2.4 Вывод списка</h4>

  <p>Функция вывода списка принимает корень списка и последовательно выводит все его элементы.</p>

  <h4>9.2.5 Замена местами двух элементов</h4>

  <p>Замена местами двух элементов происходит путем перестановки их указателей. Заменяемые элементы могут быть соседними или нет.</p>

  <h4>9.3 Деревья (195)</h4>

  <p>Дерево это динамическая структура данных, состоящая из узлов, связанных друг с другом. Бинарное дерево имеет корень - это узел, который может быть связан еще с двумя бинарными поддеревьями - левым и правым.</p>

  <h4>9.3.1 Способы обхода дерева</h4>

  <p>Пусть дерево состоит из корня A, левого поддерева B и правого поддерева C. Существует три способа обхода дерева:</p>
  <ol>
    <li>A->B->C префиксная форма или обход в прямом порядке (сверзу вниз)</li>
    <li>B->A->C инфиксная форма или обход в симметричном порядке (слева направо)</li>
    <li>B->C->A постфиксная форма или обход в обратном порядке (снизу вверх)</li>
  </ol>

  <h4>9.3.2 Реализация дерева</h4>

<pre>
struct tnode {
  int field;
  struct tnode *left;
  struct tnode *right;
}
</pre>

  <p>Обход сверху вниз (в прямом порядке)</p>
<pre>
void tree_print(tnode *tree) {
  if (tree !- NULL) {
    cout &lt;&lt; tree->field;
    tree_print(tree->left);
    tree_print(tree->right);
  }
}
</pre>

  <p>Обход в слева направо (инфиксный)</p>
<pre>
void tree_infix_print(tnode *tree) {
  if (tree !- NULL) {
    tree_print(tree->left);
    cout &lt;&lt; tree->field;
    tree_print(tree->right);
  }
}
</pre>

  <p>Обход снизу вверх (постфиксный)</p>
<pre>
void tree_postfix_print(tnode *tree) {
  if (tree !- NULL) {
    tree_print(tree->left);
    tree_print(tree->right);
    cout &lt;&lt; tree->field;
  }
}
</pre>

  <h4>9.3.3 Бинарное дерево поиска</h4>

  <p>В бинарном дереве поиска для любого узла все узлы левого поддерева меньше, а все узлы правого поддерева больше.</p>
</article>


<!-- 10 Алгоритмы поиска и сортировки в Си -->
<article class="article">
  <div class="anchor" id="p10"></div>
  <h3>10 Алгоритмы поиска и сортировки в Си (201)</h3>

  <h4>10.1 Сортировка вставкой связного списка (201)</h4>

  <p>При сортировке вставками (insertion sort) на каждом шаге алгоритма берется один элемент, находится позиция для его вставки и он вставляется на правильное место. Сортировку вставками можно реализовать на связном списке.</p>
<pre>
struct node {
  int number;
  struct node *next;
};
struct node *head = NULL;
</pre>
  <p>Первый узел называется head (голова списка). Он содержит указатель на второй узел. Последний узел называется tail (хвост). Он содержит указатель на NULL.</p>

  <h4>10.2 Пузырьковая сортировка (206)</h4>

  <p>При сортировке пузырьком (bubble sort) надо несколько раз пройтись по всем элементам. На каждой итерации соседние элементы сравниваются между собой ставятся в нужном порядке.В конце каждой итерации один элемент занимает свое правильное место.</p>

  <h4>10.3 Пузырьковая сортировка связного списка (209)</h4>

  <h4>10.4 Пузырьковая сортировка массива строк (214)</h4>

  <h4>10.5 Сортировка кучей или пирамидальная сортировка (216)</h4>

  <p>Это среднее между сортировкой выбором и сортировкой пузырьком.</p>
  <p>Ищем максимальный элемент в неотсортированной части массива и ставим его в конец этого подмассива. После сортировки, подмассив перестраивается в сортирующее дерево. После этого в оставшейся части массива снова осуществляется процедура перестройки в сортирующее дерево.</p>
  <p>Неубывающее сортирующее дерево - такое дерево, у которого любой родитель не меньше своих потомков. Невозрастающее сортирующее дерево - такое дерево, у которого любой родитель не больше своих потомков.</p>

  <h4>10.6 Сортировка слиянием связного списка (219)</h4>

  <p>Сортировка слиянием (merge sort) - это объединение последовательностей в одну упорядоченную при помощи циклического выбора элементов.</p>

  <h4>10.7 Быстрая сортировка массива (223)</h4>

  <p>Быстрая сортировка (сортировка Хоара) - это улучшенный вариант пузырьковой сортировки. Выбирается опорный элемент. Обычно это медиана - середина массива. Все элементы меньше опорного перемещаем слева от него, а все элементы больше опорного - справа от него. Далее рекурсивно сортируем полученные два подмассива. Выходим из рекурсии, когда в подмассиве остается один элемент.</p>

  <h4>10.8 Сортировка с помощью бинарного дерева (228)</h4>

  <p>При сортировке с помощью бинарного дерева (treesort) строится двоичное дерево по значениям элементов массива с последующей сборкой отсортированного массива путем обхода узлов дерева в необходимом порядке.</p>

  <h4>10.9 Бинарный поиск в целочисленном массиве (230)</h4>

  <p>Самый эффективный поиск в упорядоченной последовательности это бинарный поиск. На каждом шаге алгоритма находим средний элемент последовательности который разобъет ее на две подпоследовательностии - с элементами меньше среднего и с элементами больше среднего. Определяем в какой подпоследовательности искать дальше.</p>

  <h4>10.10 Бинарный поиск по массиву указателей строк (231)</h4>
</article>


<!-- 11 Многопоточность в Си -->
<article class="article">
  <div class="anchor" id="p11"></div>
  <h3>11 Многопоточность в Си (234)</h3>

  <p>Современные процессоры имеют несколько ядер, следовательно, одновременно может выполняться несколько потока. Современные приложения обычно пишут многопоточными.</p>
  <p>Например, многопоточный сервер может обслуживать несколько клиентов одновременно.</p>
  <p>Поддержка многопоточности в Си появилась со стандарта C11.</p>

  <h4>11.1 Введение в потоки (235)</h4>

  <p>Поток (thread) - это независимое выполнение последовательности инструкций. Поток это не процесс, поток работает внутри процесса и использует то же пространство в памяти, что и процесс.</p>
  <p>У каждого потока есть свое собственное пространство для хранения переменных.</p>
  <p>Даже на однопроцессорных машинах многопоточные приложения лучше используют процессорное время. Когда процесс ждет ресурсы (например читает данные из файла), он блокируется и контроль передается другому процессу. Поток тоже может ждать ресурсыы, но при этом другой поток в этом же процессе может делать что-то другое. При обработки асинхронных событий одним потоком, другие потоки могут делать другие вычисления.Обычно отдельный поток выделяют для взаимодействия с интерфейсом пользователя. Еще отдельный поток можно выделять для выполнения фоновой работы, например воспроизведения музыки.</p>
  <p>Преимущества потока над процессом. Создавать потоки проще чем процессы. Потоки проще обмениваются данными чем процессы.</p>
  <p>Преимущества процесса над потоком. Процессы независимы и не имеют таких требований к безопасности как потоки. Один поток с ошибкой может повредить все остальные.</p>

  <h4>11.2 Типы потоков (237)</h4>

  <p>Потоки делятся на два типа: пользовательские и сущности операционной системы.</p>

  <h4>11.3 Модели многопотоковых приложений (239)</h4>

  <p>Модели многопоточный приложений:</p>
  <ul>
    <li>Хозяин/рабочий (boss/worker) создается основной поток, контролирующий работу остальных потоков.</li>
    <li>Одноранговая модель (peer) - несколько потоков запускаются параллельно без выделенного потока управления.</li>
    <li>Конвейерная модель (pipeline) - задание передается от одного потока к другому.</li>
  </ul>

  <h4>11.3.1 Модель boss/worker</h4>

  <p>Основной поток получает запрос. Создает новый поток и передает для обслуживания полученного запроса или передает запрос уже созданному и простаивающему потоку.</p>

  <h4>11.3.2 Одноранговая модель</h4>

  <p>Первый поток создает остальные потоки, запускает их и затем ждут когда они завершатся.</p>

  <h4>11.3.3 Конвейерная модель</h4>

  <p>Программа принимает постоянный поток данныхсостоящий из блоков, который нужно обрабатывать последовательностью операций. Разные блоки могут обрабатываться разными потоками.</p>

  <h4>11.4 Механизмы синхронизации (244)</h4>

  <p>Взаимодействие между потоками осуществляется через память и глобальные переменные.</p>
  <p>Основными примитивами синхронизации являются мьютексы и условные переменные.</p>
  <p>Мьютекс (mutex - mutual exclusion - взаимное исключение) - одноместный семафор, служащий в программировании для синхронизации одновременно выполняющихся потоков. Мьютекс может это двоичный семафор, который может находиться в одном из двух состояний - отмеченном и неотмеченном (свободен - занят, открыт - закрыт).</p>
  <p>Когда поток становится владельцем объекта mutex, он переводится в неотмеченное состояние и защищен от попыток завладеть этим объектом со стороны другого потока. Когда поток освобождает объект mutex, он переводится в помеченное состояние и снова становится доступным для любого потока. Одновременно только один поток может быть владельцем объекта mutex.</p>
  <p>Условная переменная обеспечивает блокирование одного или нескольких потоков до момента поступления сигнала от другого потока о выполнении некоторого условия или до истечения максимального времени ожидания.</p>

  <h4>11.5 Параллелизм и функции (246)</h4>

  <p>Чтобы функция могла одновременно вызываться разными потоками, она должна быть пококо-безопасная (thread safe). Если функция не соответствует этим требованиям, то возможны взаимная блокировка или состояние гонки. Взаимная блокировка (deadlock) это ситуация в многопоточной среде, когда несколько потоков ждут ресурсы, занятые друг другом и ни один из потоков не может продолжить свое выполнение. Состояние гонки (конкуренция) - это зависимость работы системы от того, в каком порядке выполняются части кода.</p>

  <h4>11.6 POSIX-функция для организации многопоточности (246)</h4>

  <h4>11.6.1 Подключение библиотеки и основные типы данных</h4>

  <p>Библиотека POSIX для работы с потоками - это набор функций для поддержки многопоточности. Содержится библиотека в заголовочном файле pthread.h. При компиляции нужно указывать опцию -lpthread</p>
  <code>gcc program.c - lpthread</code>

  <h4>11.6.2 Запуск потока</h4>

  <p>Поток создается функцией pthread_create().</p>

  <h4>11.6.3 Завершение потока</h4>

  <p>Выполнение потока завершается в следующих случаях:</p>
  <ul>
    <li>В потоке выполняется оператор return</li>
    <li>Вызывается завершение исполнения потока pthread_exit()</li>
    <li>Вызов отмены потока pthread_cancel()</li>
    <li>Вызов exit()</li>
    <li>Основной поток в функции main() выполняет return и все потоки завершают свою работу</li>
  </ul>

  <h4>11.6.4 Ожидание потока</h4>

  <p>Функция pthread_join() ожидает завершения потока. Суть функции в том, чтобы синхронизировать потоки. Как только поток будет завершен, функция немедленно возвращает значение.При удачном завершении функция pthread_join() возвращает 0, ненулевое значение означает ошибку.</p>

  <h4>11.6.5 Досрочное завершение потока</h4>

  <p>Функция pthread_cancel посылает запрос на досрочное завершение потока. Если поток завершился, то возвращает 0, или ненулевое значение если произошла ошибка. Поток самостоятельно выбирает момент завершения в ответ на вызов pthread_cancel или может его вовсе игнорировать. Чтобы убедиться что поток был удален, нужно дождаться его завершения функцией pthread_join.</p>

  <h4>11.6.6 Отсоединение потока</h4>

  <p>К любому потоку можно присоединиться вызовом pthread_join и ждать его завершения. Если статус завершения нам не интересен, можно автоматически выгрузить ресурсы обратно в операционную систему вызовом pthread_detach. При удачном завершении ptread_detach возвращает 0, при ошибке возвращает ненулевое значение.</p>

  <h4>11.7 Потоки C11 (251)</h4>

  <p>Потоки C11 представляют собой оболочку для POSIX потоков.Создание потока осуществляется функцией thrd_create, для подсоединения к потоку используется функция thrd_join.</p>
</article>


<!-- Часть 3. Практическое программирование -->
<article class="article">
  <div class="anchor" id="pc3"></div>
  <h3>Часть 3. Практическое программирование (253)</h3>

</article>


<!-- 12 Работа с сетью в Си -->
<article class="article">
  <div class="anchor" id="p12"></div>
  <h3>12 Работа с сетью в Си (254)</h3>

  <h4>12.1 Разработка программы-сервера (254)</h4>

  <p>Программа-сервер посл запуска сразу перейдет в режим ожидания новых клиентов, максимальное количество клиентов - 3.</p>

  <h4>12.2 Программа-клиент (262)</h4>

  <p>Для подключению к серверу нам нужен номер узла сервера, номер порта сервера, номер порта клиента.</p>

  <h4>12.3 Многопоточный сервер (265)</h4>

  <p>Однопоточные серверы не встречаются на практике. Обычно, серверы запускают несколько потоков, чтобы обслужить сразу несколько клиентов.</p>
  <p>Сервер "слушает" соединения и для каждого нового соединения создает свой поток.</p>
</article>


<!-- 13 Практический пример: компьютерная игра -->
<article class="article">
  <div class="anchor" id="p13"></div>
  <h3>13 Практический пример: компьютерная игра (271)</h3>

  <p>В стандарте Си нет функций для работы с графикой, поэтому чтобы написать даже самую простую игру, программисту нужно выбрать и изучить сторонние библиотеки для работы с графикой.</p>
  <p>Современные игры написаны на C++/C#, а не на Си. Потому что в них есть поддержка объектно-ориентированного программирования. Тем не менее, на Си тоже можно написать игру.</p>

  <h4>13.1 Идея игры (272)</h4>

  <p>Создадим простенький космический шутер. Мы летим в космическом корабле и чтобы остаться в живых, нужно истребить все камни, летящие в нашу сторону.</p>

  <h4>13.2 Выбор библиотеки (13.2)</h4>

  <p>Для работы с графикой в Windows используют DirectX. Чтобы программа работала как в Windows так и в Linux, используют OpenGL. Мы будем использовать OpenGL.</p>
  <p>Для работы с этой библиотекой нужно установить пакеты freeglut3 и freeglut3-dev. freeglut это открытая альтернатива OpenGL, которая позволяет создавать окна, предоставляющие контекст OpenGL. Для нашей примитивной игры этого достаточно.</p>

  <h4>13.3 Основы glut (274)</h4>

  <p>На тему разработки игр можно написать отдельную книгу и даже не одну. Рассказать о разработке игры и рассмотреть все библиотеки - физически невозможно. Домашним заданием будет самостоятельно разобраться с библиотекой glut.</p>
  <p>Существует два типа проецирования: параллельная и перспективная. Ортогональная проекция - это частный случай параллельной проекции, при которой проецируемые лучи ортогональны картинной плоскости.</p>
  <p>Таким образом, видны все объекты, которые попали внутрь параллелепипеда видимости.</p>

  <h4>13.4 Основная функция display (280)</h4>

  <p>Функция display управляет отображением экранов игры. Экранов у нас будет четыре - игровой экран, экран меню, экран инструкций и экран Game over.</p>

  <h4>13.5 Обработка нажатий клавиш клавиатуры и мыши (281)</h4>

  <p>Функция keys() будет обрабатывать нажатия клавиатуры. При нажатии кнопки мыши вызывается обработчик mouseClick().</p>

  <h4>13.6 Отображение меню (282)</h4>

  <p>На экране меню можно выбрать несколько пунктов: запуск игры, отображение инструкций, выход.</p>

  <h4>13.7 Игровой экран (284)</h4>

  <p>Функция GameScreenDisplay() отвечает за отображение основного игрового экрана. Функция проверяет что мы еще живы. Если да, то прорисовывает космический корабль и запускает генератор камней, летящих в сторону космического корабля, а если нет, то выводит экран Game over.</p>
</article>

