<article class="article">
  <h1>1991 Шилдт - Язык Си для профессионалов. 384c</h1>
  <p>Конспект книги</p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

      <a href="#p1">1 Исчезающие и иерархические меню (7)</a>
  <br><a href="#p2">2 Всплывающие окна (48)</a>
  <br><a href="#p3">3 Программы, остающиеся резидентными (91)</a>
  <br><a href="#p4">4 Графика (129)</a>
  <br><a href="#p5">5 Видеоигры (176)</a>
  <br><a href="#p6">6 Использование последовательного порта (211)</a>
  <br><a href="#p7">7 Интерпретаторы языка (251)</a>
  <br><a href="#p8">8 О манипулировании экраном и герерация звука (293)</a>
  <br><a href="#p9">9 Интерфейс с мышью (314)</a>
  <br><a href="#p10">10 Создание коммерческих диаграмм (358)</a>
</article>


<!-- Исчезающие и иерархические меню (7) -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Исчезающие и иерархические меню (7)</h3>

  <p>Создание исчезающих и иерархических меню требует прямого управления экраном. Программы доступа к экрану зависят от операционной системы и оборудования и не используют обычные функции Си ввода/вывода на консоль. Иерархическое меню требует более сложной программы, чем исчезающее меню.</p>

  <h4>Работа видеоадаптеров</h4>

  <p>Три основных типа адаптеров - одноцветный, цветной CGA, усовершенствованный цветной EGA. CGA и EGA могут иметь несколько режимов работы. Наиболее общий это режим 80-символьного текста.</p>
  <p>Символы, выводимые на экран, содержатся в некоторой зарезервированной области памяти на адаптере дисплея. Адрес одноцветной информации B0000000H. И CGA и EGA хранят информацию, начиная с B80000000H.</p>
  <p>Каждый символ, выводимый на экран, требует два байта видео памяти. Первый байт содержит символ, второй содержит атрибуты экрана.</p>
  <p>Каждый адаптер имеет по крайней мере в 4 раза больше памяти, чем необходимо для вывода текста в 80-символьном режиме. Это позволяет держать в памяти несколько экранов и переключаться между ними. Каждая область памяти называется видеостраницей. По умолчанию при инициализации DOS используется страница 0.</p>
  <p>Имеется три способа доступа к видеоадаптеру. Первый это через прерывание DOS, которое достаточно медленное для исчезающего меню. Второй это через процедуры DOS, которые быстрее и подходят для небольших меню. Третий способ это чтение и запись прямо в видеопамять, что происходит очень быстро, но требует большой работы.</p>

  <h4>Доступ к экрану через BIOS</h4>

  <p>Исчезающие и иерархические меню должны сохранять информацию экрана перед тем как будут вызваны и восстановить ее после выбора пункта меню. Для этого будем вызывать встроенные в BIOS функции чтения и записи символов на экран.</p>
  <p>Вызовы BIOS могут быть очень медленными, но они гарантируют работу на любом компьютере с одинаковым BIOS даже если аппаратура экрана другая. Чтобы увеличить скорость выполнения используют прямой доступ к видеопамяти, однако это снижает переносимость программ, так как требует одинаковой аппаратной части экрана.</p>

  <h4>Использование int86()</h4>

  <p>Вызовы BIOS используют программные прерывания. BIOS имеет несколько различных прерываний для разных целей. Прерывание 16 (10H) используется для доступа к дисплею. Как и многие прерывания BIOS, прерывание 16 имеет несколько режимов, выбор которых выполняется по значению регистра AH. Если функция возвращает значение, то оно заносится в регистр AL. Иногда, для возвращения нескольких значений используются другие регистры. Для доступа к прерываниям BIOS используют функцию Си int86().</p>
  <code>int int86(int num, union REGS *inregs, unionREGS *outregs)</code>
  <p>Функция int86() возвращает значение регистра AX. Тип union REGS описывается в заголовке DOS.H.</p>
<pre>
struct WORDREGS {
  unsigned int ax, bx, cx, dx, si, di, cflag, flags;
};
struct BYTEREGS {
  unsigned char al, ah, bl, bh, cl, ch, dl, dh;
};
union REGS {
  struct WORDREGS x;
  struct BYTEREGS h;
};
</pre>
  <p>Видим, что union REGS это объединение двух структур. WORDREGS позволяет рассматривать регистры как 16-битные числа. BYTEREGS дает доступ к отдельным 8-битным регистрам. Для доступа к прерыванию 16, функции 5, будем использовать следующий код</p>
<pre>
union REGS in, out;
in.h.ah = 5; // функция доступа к памяти
int86(16, &in, &out);
</pre>

  <h4>Сохранение части экрана</h4>

  <p>Для сохранения содержимого экрана, должно быть прочитано и запомнено текущее значение каждой позиции экрана. Функция 8 прерывания 16 возвращает символ и связанный с ним атрибут в текущей позиции курсора. Для установки позиции курсора можно использовать функцию goto_xy(). Она использует функцию 2 прерывания 16 с координатой столбца в DL и координатой ряда в DH. Видеостраница задается в BH (используется страница 0 по умолчанию).</p>
  <p>Функция установки курсора goto_xy() в x, y описывается в заголовке DOS.H.</p>
<pre>
void goto_xy(int x, int y) {
  union REGS r;
  r.h.ah = 2; // функция установки курсора
  r.h.dl = y; // координата колонки
  r.h.dh = x; // координата строки
  r.h.bh = 0; // видео страница
  int86(0x10, &r, &r);
}
</pre>
  <p>Функция 8 прерывания 16 возвращает символ из текущей позиции курсора в AL и его атрибут в AH. Функция save_video() считывает часть экрана, сохраняет информацию в буфер и очищает эту часть экрана.</p>
<pre>
void save_video(int startx, int endx, int starty, int endy, unsigned int *buf_ptr) {
  union REGS r;

  for (int i = starty, i &lt; endy; i++) {
    for (int j = startx, j &lt; endx; j++) {
      r.h.ah = 8; // функция чтения символа
      r.h.bh = 0; // видео страница
      *buf_ptr++ = int86(0x10, &r, &r);
      putchar(' '); // очистка символа
    }
  }
}
</pre>
  <p>Указатель на область памяти *buf_ptr должен указывать на достаточно большую область, чтобы разместить информацию об экране в прямоукольнике от верхнего левого угла с координатами startx, starty до правого нижнего угла с координатами endx, endy.</p>

  <h4>Восстановление экрана</h4>

  <p>Восстановление экрана это запись информации из буфера обратно в видеопамять. Функция 9 прерывания 16 запишет символ из регистра AL, атрибут символа из регистра BL в видеостраницу из регистра BH. Функция restore_video() переносит информацию из буфера на экран</p>
<pre>
void restore_video(int startx, int endx, int starty, int endy, unsigned int *buf_ptr) {
  union REGS r;

  for (int i = starty; i &lt; endy; i++) {
    for (int j = startx; k &lt; endx; j++) {
      goto_xy(j, i);
      r.h.ah = 9; // функция записи символа
      r.h.bh = 0; // видео страница
      r.x.cx = 1; // число повторений символа
      r.h.al = *buf_ptr++; // символ
      r.h.bl = *buf_ptr++; // атрибут
      *buf_ptr++ = int 86(0x10, &r, &r);
    }
  }
}
</pre>

  <h4>Создание исчезающих меню</h4>

  <p>Для создания исчезающего меню будем писать функцию popup().</p>
  <code>int popup(char *menu[], char *keys, int count, int x, int y, int border)</code>
  <p>Функция popup() принимает:</p>
  <ul>
    <li>char *menu[] указатель на массив, в котором список строк меню.</li>
    <li>char *keys список горячих клавиш для меню, в том же порядке, что и строки меню.</li>
    <li>int count число режимов в меню</li>
    <li>int x координата x меню</li>
    <li>int y координата y меню</li>
    <li>int border если рамка не нужна, то border = 0.</li>
  </ul>
  <p>Функция popup() делает следующее:</p>
  <ul>
    <li>Сохраняет область экрана под меню. Это делается с помощью уже написанной функции save_video().</li>
    <li>Высвечивает рамку, если надо. Для этого напишем функцию draw_border().</li>
    <li>Высвечивает меню. Для этого напишем функцию display_menu()</li>
    <li>Получает ответ пользователя. Для этого напишем функцию get_resp().</li>
    <li>Восстанавливает экран в исходное состояние. Это делается с помощью уже написанной функции restore_video()</li>
  </ul>

  <h4>Высвечивание меню</h4>

  <p>Функция принимает массив указателей на строки. Каждая строка это соответствующий элемент меню.</p>
<pre>

</pre>
</article>

