<article class="article">
  <h1>1991 Шилдт - Язык Си для профессионалов. 384c</h1>
  <p>Конспект книги</p>
  <p>Прочитана 2025.09.09</p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

      <a href="#p1">1 Исчезающие и иерархические меню (7)</a>
  <br><a href="#p2">2 Всплывающие окна (48)</a>
  <br><a href="#p3">3 Программы, остающиеся резидентными (91)</a>
  <br><a href="#p4">4 Графика (129)</a>
  <br><a href="#p5">5 Видеоигры (176)</a>
  <br><a href="#p6">6 Использование последовательного порта (211)</a>
  <br><a href="#p7">7 Интерпретаторы языка (251)</a>
  <br><a href="#p8">8 О манипулировании экраном и герерация звука (293)</a>
  <br><a href="#p9">9 Интерфейс с мышью (314)</a>
  <br><a href="#p10">10 Создание коммерческих диаграмм (358)</a>
</article>


<!-- 1 Исчезающие и иерархические меню (7) -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>1 Исчезающие и иерархические меню (7)</h3>

  <p>Создание исчезающих и иерархических меню требует прямого управления экраном. Программы доступа к экрану зависят от операционной системы и оборудования и не используют обычные функции Си ввода/вывода на консоль. Иерархическое меню требует более сложной программы, чем исчезающее меню.</p>

  <h4>Работа видеоадаптеров</h4>

  <p>Три основных типа адаптеров - одноцветный, цветной CGA, усовершенствованный цветной EGA. CGA и EGA могут иметь несколько режимов работы. Наиболее общий это режим 80-символьного текста.</p>
  <p>Символы, выводимые на экран, содержатся в некоторой зарезервированной области памяти на адаптере дисплея. Адрес одноцветной информации B0000000H. И CGA и EGA хранят информацию, начиная с B80000000H.</p>
  <p>Каждый символ, выводимый на экран, требует два байта видео памяти. Первый байт содержит символ, второй содержит атрибуты экрана.</p>
  <p>Каждый адаптер имеет по крайней мере в 4 раза больше памяти, чем необходимо для вывода текста в 80-символьном режиме. Это позволяет держать в памяти несколько экранов и переключаться между ними. Каждая область памяти называется видеостраницей. По умолчанию при инициализации DOS используется страница 0.</p>
  <p>Имеется три способа доступа к видеоадаптеру. Первый это через прерывание DOS, которое достаточно медленное для исчезающего меню. Второй это через процедуры DOS, которые быстрее и подходят для небольших меню. Третий способ это чтение и запись прямо в видеопамять, что происходит очень быстро, но требует большой работы.</p>

  <h4>Доступ к экрану через BIOS</h4>

  <p>Исчезающие и иерархические меню должны сохранять информацию экрана перед тем как будут вызваны и восстановить ее после выбора пункта меню. Для этого будем вызывать встроенные в BIOS функции чтения и записи символов на экран.</p>
  <p>Вызовы BIOS могут быть очень медленными, но они гарантируют работу на любом компьютере с одинаковым BIOS даже если аппаратура экрана другая. Чтобы увеличить скорость выполнения используют прямой доступ к видеопамяти, однако это снижает переносимость программ, так как требует одинаковой аппаратной части экрана.</p>

  <h4>Использование int86()</h4>

  <p>Вызовы BIOS используют программные прерывания. BIOS имеет несколько различных прерываний для разных целей. Прерывание 16 (10H) используется для доступа к дисплею. Как и многие прерывания BIOS, прерывание 16 имеет несколько режимов, выбор которых выполняется по значению регистра AH. Если функция возвращает значение, то оно заносится в регистр AL. Иногда, для возвращения нескольких значений используются другие регистры. Для доступа к прерываниям BIOS используют функцию Си int86().</p>
  <code>int int86(int num, union REGS *inregs, unionREGS *outregs)</code>
  <p>Функция int86() возвращает значение регистра AX. Тип union REGS описывается в заголовке DOS.H.</p>
<pre>
struct WORDREGS {
  unsigned int ax, bx, cx, dx, si, di, cflag, flags;
};
struct BYTEREGS {
  unsigned char al, ah, bl, bh, cl, ch, dl, dh;
};
union REGS {
  struct WORDREGS x;
  struct BYTEREGS h;
};
</pre>
  <p>Видим, что union REGS это объединение двух структур. WORDREGS позволяет рассматривать регистры как 16-битные числа. BYTEREGS дает доступ к отдельным 8-битным регистрам. Для доступа к прерыванию 16, функции 5, будем использовать следующий код</p>
<pre>
union REGS in, out;
in.h.ah = 5; // функция доступа к памяти
int86(16, &in, &out);
</pre>

  <h4>Сохранение части экрана</h4>

  <p>Для сохранения содержимого экрана, должно быть прочитано и запомнено текущее значение каждой позиции экрана. Функция 8 прерывания 16 возвращает символ и связанный с ним атрибут в текущей позиции курсора. Для установки позиции курсора можно использовать функцию goto_xy(). Она использует функцию 2 прерывания 16 с координатой столбца в DL и координатой ряда в DH. Видеостраница задается в BH (используется страница 0 по умолчанию).</p>
  <p>Функция установки курсора goto_xy() в x, y описывается в заголовке DOS.H.</p>
<pre>
void goto_xy(int x, int y) {
  union REGS r;
  r.h.ah = 2; // функция установки курсора
  r.h.dl = y; // координата колонки
  r.h.dh = x; // координата строки
  r.h.bh = 0; // видео страница
  int86(0x10, &r, &r);
}
</pre>
  <p>Функция 8 прерывания 16 возвращает символ из текущей позиции курсора в AL и его атрибут в AH. Функция save_video() считывает часть экрана, сохраняет информацию в буфер и очищает эту часть экрана.</p>
<pre>
void save_video(int startx, int endx, int starty, int endy, unsigned int *buf_ptr) {
  union REGS r;

  for (int i = starty, i &lt; endy; i++) {
    for (int j = startx, j &lt; endx; j++) {
      r.h.ah = 8; // функция чтения символа
      r.h.bh = 0; // видео страница
      *buf_ptr++ = int86(0x10, &r, &r);
      putchar(' '); // очистка символа
    }
  }
}
</pre>
  <p>Указатель на область памяти *buf_ptr должен указывать на достаточно большую область, чтобы разместить информацию об экране в прямоукольнике от верхнего левого угла с координатами startx, starty до правого нижнего угла с координатами endx, endy.</p>

  <h4>Восстановление экрана</h4>

  <p>Восстановление экрана это запись информации из буфера обратно в видеопамять. Функция 9 прерывания 16 запишет символ из регистра AL, атрибут символа из регистра BL в видеостраницу из регистра BH. Функция restore_video() переносит информацию из буфера на экран</p>
<pre>
void restore_video(int startx, int endx, int starty, int endy, unsigned int *buf_ptr) {
  union REGS r;

  for (int i = starty; i &lt; endy; i++) {
    for (int j = startx; k &lt; endx; j++) {
      goto_xy(j, i);
      r.h.ah = 9; // функция записи символа
      r.h.bh = 0; // видео страница
      r.x.cx = 1; // число повторений символа
      r.h.al = *buf_ptr++; // символ
      r.h.bl = *buf_ptr++; // атрибут
      *buf_ptr++ = int 86(0x10, &r, &r);
    }
  }
}
</pre>

  <h4>Создание исчезающих меню</h4>

  <p>Для создания исчезающего меню будем писать функцию popup().</p>
  <code>int popup(char *menu[], char *keys, int count, int x, int y, int border)</code>
  <p>Функция popup() принимает:</p>
  <ul>
    <li>char *menu[] указатель на массив, в котором список строк меню.</li>
    <li>char *keys список горячих клавиш для меню, в том же порядке, что и строки меню.</li>
    <li>int count число режимов в меню</li>
    <li>int x координата x меню</li>
    <li>int y координата y меню</li>
    <li>int border если рамка не нужна, то border = 0.</li>
  </ul>
  <p>Функция popup() делает следующее:</p>
  <ul>
    <li>Сохраняет область экрана под меню. Это делается с помощью уже написанной функции save_video().</li>
    <li>Высвечивает рамку, если надо. Для этого напишем функцию draw_border().</li>
    <li>Высвечивает меню. Для этого напишем функцию display_menu()</li>
    <li>Получает ответ пользователя. Для этого напишем функцию get_resp().</li>
    <li>Восстанавливает экран в исходное состояние. Это делается с помощью уже написанной функции restore_video()</li>
  </ul>

  <h4>Высвечивание меню</h4>

  <p>Функция принимает массив указателей на строки. Каждая строка это соответствующий элемент меню.</p>
<pre>
void display_menu(char *menu[], int x, int y, int count) {
  for (int i = 0; i &lt; counr; i++, x++) {
    goto_xy(x, y);
    printf(menu[i]);
  }
}
</pre>

  <p>Массив строк с пунктами меню может выглядеть так:</p>
<pre>
char *fruit[] = {
  "Apple",
  "Apelsin",
  "Orange",
  "Malina"
}
</pre>

  <h4>Всвечивание рамки</h4>

  <p>Для рамки можно использовать символы из стандартного набора символов.</p>
<pre>
void draw_border(int startx, int starty, int endx, int endy) {

  for (int i = startx + 1; i &lt; endx; i++) {
    goto_xy(i, starty);
    putchar(179);
    goto_xy(i, endy);
    putchar(179);
  }

  for (int i = starty + 1; i &lt; endy; i++) {
    goto_xy(startx, i);
    putchar(196);
    goto_xy(endx, i);
    putchar(196);
  }

  goto_xy(startx, starty);
  putchar(218);
  goto_xy(startx, endy);
  putchar(191);
  goto_xy(endx, starty);
  putchar(192);
  goto_xy(endx, endy);
  putchar(217);
}
</pre>

  <h4>Ввод выбора пользователя</h4>

  <p>Пользователь может выбрать пункт меню одним из двух способов. Первый способ это перемещаясь по пунктам меню с помощью клавиш "стрелка вниз" и "стрелка вверх" или пробелом. При этом активный пункт меню будет выделяться в инверсном режиме. Второй способ это выбор с помощью нажатия на горячую клавишу.</p>
  <p>Функция get_resp() отвечает за выбор пользователя. Она использует функцию bioskey() вместо getchar() для ожидания и считывания нажатой клавиши. Функция getchar() возвращает только 8-битный код символа. Функция bioskey() считывает полный 16-битный код нажатой клавиши. Символы записываются в младшие 8-бит, при этом старшие 8-бит равны нулю. Специальные клавиши, такие как стрелка, записываются в старшие 8-бит, а младшие 8-бит равны нулю.</p>

  <h4>Функция popup()</h4>

  <p>Теперь можно написать функцию popup().</p>

  <h4>Общий обзор</h4>

  <p>Простая программа, показанная здесь, использует все программы, разработанные для исчезающих окон. Также используется функция cls() которая очищает экран.</p>

  <h4>Прямой доступ к видео памяти</h4>

  <p>При прямой записи и чтении из видео памяти, исчезающие меню будут появляться и исчезать без задержек. Обращение к видео памяти требует использования дальних указателей. Для этого есть два способа. Первый - использовать ключевое слово far, которое определяет указатель как дальний. Второй - использовать большую модель памяти, в которой все указатели дальние.</p>

  <h4>Определение расположения видео памяти</h4>

  <p>Одноцветный адаптер использует для видео паммяти адрес B0000000H, а все остальные - B8000000H. Программа должна знать какой адаптер имеет система. Функция 15 прерывания 16 возвращает текущий видео режим. Адаптеры CGA и EGA используют режимы 2 и 3. Одноцветный адаптер использует режим 7.</p>

  <h4>Создание иерархическийх окон</h4>

  <p>Иерархические окна могут иметь два и более исчезающих меню активными одновременно.</p>

  <h4>Фреймы меню</h4>

  <p>Каждое меню должно иметь свой фрейм ссылок. Каждое меню активизируется по номеру его фрейма и загружается по необходимости. Для этого нужен массив структур, содержащий всю информацию о меню.</p>

  <h4>Создание фрейма меню</h4>

  <p>Функция make_menu() создает фрейм меню. Функция make_menu вызывается с теми же параметрами что и popup() кроме номера меню, который передается первым параметром.</p>

  <h4>Функция pulldown()</h4>

  <p>Функция pulldown() принимает номер меню, которое нужно высветить.</p>

  <h4>Восстановление окна</h4>

  <p>Функция restore_video() передает номер окна, которое нужно восстановить.</p>
</article>


<!-- 2 Всплывающие окна (48) -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>2 Всплывающие окна (48)</h3>

  <p>Программа управления окнами использует функции прямого доступа к памяти. Поскольку окна часто имеют размер больше чем меню, использование функций BIOS невозможно из за их медлительности.</p>

  <h4>Теория всплывающих окон</h4>

  <p>Всплывающее окно представляет собой часть экрана. Перед появлением окна текущее содержимое экрана сохраняется и после этого отображается всплывающее окно. По завершению работы со всплывающим окном, оно удаляется а первоначальное содержимое экрана возвращается.</p>

  <h4>Оконные структуры</h4>

  <p>Границы окна могут меняться во время выполнения программы и должны быть доступны всем оконным функциям.</p>
</article>


<!-- 3 Программы, остающиеся резидентными (91) -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>3 Программы, остающиеся резидентными (91)</h3>

  <h4>Что такое TSR программа?</h4>

  <h4>Прерывания в семействе процессоров 8086</h4>
</article>


<!-- 4 Графика (129) -->
<article class="article">
  <div class="anchor" id="p4"></div>
  <h3>4 Графика (129)</h3>
</article>


<!-- 5 Видеоигры (176) -->
<article class="article">
  <div class="anchor" id="p5"></div>
  <h3>5 Видеоигры (176)</h3>
</article>


<!-- 6 Использование последовательного порта (211) -->
<article class="article">
  <div class="anchor" id="p6"></div>
  <h3>6 Использование последовательного порта (211)</h3>
</article>


<!-- 7 Интерпретаторы языка (251) -->
<article class="article">
  <div class="anchor" id="p7"></div>
  <h3>7 Интерпретаторы языка (251)</h3>
</article>


<!-- 8 О манипулировании экраном и герерация звука (293) -->
<article class="article">
  <div class="anchor" id="p8"></div>
  <h3>8 О манипулировании экраном и герерация звука (293)</h3>
</article>


<!-- 9 Интерфейс с мышью (314) -->
<article class="article">
  <div class="anchor" id="p9"></div>
  <h3>9 Интерфейс с мышью (314)</h3>
</article>


<!-- 10 Создание коммерческих диаграмм (358) -->
<article class="article">
  <div class="anchor" id="p10"></div>
  <h3>10 Создание коммерческих диаграмм (358)</h3>
</article>

