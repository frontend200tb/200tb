<article class="article">
  <h1>Руководство по языку программирования Си</h1>
  <p>Конспект курса</p>
  <p><a href="https://metanit.com/c/tutorial/" target="_blank">https://metanit.com/c/tutorial/</a></p>
  <p>Последнее обновление: 09.03.2025</p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
    <a href="#p1.1">1 Введение в C</a>
    <br><a href="#p1.1">1.1 Язык программирования C</a>
    <br><a href="#p1.2">1.2 Компилятор GCC. Первая программа на Windows</a>
    <br><a href="#p1.3">1.3 Компилятор Clang. Первая программа на Windows</a>
    <br><a href="#p1.4">1.4 GCC. Первая программа на Linux</a>
    <br><a href="#p1.5">1.5 Clang. Первая программа на MacOS</a>
    <br><a href="#p1.6">1.6 Настройка параметров компиляции</a>
    <br><a href="#p1.7">1.7 Локализация и кириллица в консоли</a>
  </p>

  <p>
    <a href="#p2.1">2 Основы языка Си</a>
    <br><a href="#p2.1">2.1 Структура программы на Си</a>
    <br><a href="#p2.2">2.2 Переменные</a>
    <br><a href="#p2.3">2.3 Типы данных</a>
    <br><a href="#p2.4">2.4 Консольный вывод. Функция printf</a>
    <br><a href="#p2.5">2.5 Константы</a>
    <br><a href="#p2.6">2.6 Арифметические операции</a>
    <br><a href="#p2.7">2.7 Условные операции</a>
    <br><a href="#p2.8">2.8 Поразрядные операции</a>
    <br><a href="#p2.9">2.9 Операции присваивания</a>
    <br><a href="#p2.10">2.10 Преобразование типов</a>
    <br><a href="#p2.11">2.11 Условные конструкции</a>
    <br><a href="#p2.12">2.12 Циклы</a>
    <br><a href="#p2.13">2.13 Введение в массивы и строки</a>
    <br><a href="#p2.14">2.14 Ввод в консоли. Функция scanf</a>
  </p>

  <p>
    <a href="#p3.1">3 Указатели</a>
    <br><a href="#p3.1">3.1 Что такое указатели</a>
    <br><a href="#p3.2">3.2 Операции с указателями</a>
    <br><a href="#p3.3">3.3 Арифметика указателей</a>
    <br><a href="#p3.4">3.4 Константы и указатели</a>
    <br><a href="#p3.5">3.5 Указатели и массивы</a>
    <br><a href="#p3.6">3.6 Указатели и строки</a>
    <br><a href="#p3.7">3.7 Массивы указателей и многоуровневая адресация</a>
  </p>

  <p>
    <a href="#p4.1">4 Функции</a>
    <br><a href="#p4.1">4.1 Определение и описание функций</a>
    <br><a href="#p4.2">4.2 Параметры функции</a>
    <br><a href="#p4.3">4.3 Результат функции</a>
    <br><a href="#p4.4">4.4 Рекурсивные функции</a>
    <br><a href="#p4.5">4.5 Область видимости переменных</a>
    <br><a href="#p4.6">4.6 Внешние объекты</a>
    <br><a href="#p4.7">4.7 Указатели в параметрах функции</a>
    <br><a href="#p4.8">4.8 Указатели на функции</a>
    <br><a href="#p4.9">4.9 Тип функции</a>
    <br><a href="#p4.10">4.10 Функции как параметры других функций</a>
    <br><a href="#p4.11">4.11 Функция как результат другой функции</a>
    <br><a href="#p4.12">4.12 Функции с переменным количеством параметров</a>
    <br><a href="#p4.13">4.13 Параметры командной строки</a>
  </p>

  <p>
    <a href="#p5.1">5 Препроцессор</a>
    <br><a href="#p5.1">5.1 Директива #include. Включение файлов</a>
    <br><a href="#p5.2">5.2 Директива #define</a>
    <br><a href="#p5.3">5.3 Макросы</a>
    <br><a href="#p5.4">5.4 Условная компиляция</a>
    <br><a href="#p5.5">5.5 Встроенные макросы</a>
  </p>

  <p>
    <a href="#p6.1">6 Структуры</a>
    <br><a href="#p6.1">6.1 Определение структур</a>
    <br><a href="#p6.2">6.2 Структуры как элементы структур</a>
    <br><a href="#p6.3">6.3 Указатели на структуры</a>
    <br><a href="#p6.4">6.4 Массивы структур</a>
    <br><a href="#p6.5">6.5 Структуры и функции</a>
    <br><a href="#p6.6">6.6 Размещение структур и их полей в памяти</a>
    <br><a href="#p6.7">6.7 Составные литералы</a>
    <br><a href="#p6.8">6.8 Перечисления</a>
    <br><a href="#p6.9">6.9 Объединения</a>
    <br><a href="#p6.10">6.10 Битовые поля</a>
  </p>

  <p>
    <a href="#p7.1">7 Динамическая память</a>
    <br><a href="#p7.1">7.1 Выделение и освобождение памяти</a>
    <br><a href="#p7.2">7.2 Выделение памяти для двухмерного массива произвольной длины</a>
    <br><a href="#p7.3">7.3 Управление динамической памятью</a>
    <br><a href="#p7.4">7.4 Указатель как результат функции</a>
  </p>

  <p>
    <a href="#p8.1">8 Ввод-вывод и работа с файлами</a>
    <br><a href="#p8.1">8.1 Открытие и закрытие потоков</a>
    <br><a href="#p8.2">8.2 Чтение и запись бинарных файлов</a>
    <br><a href="#p8.3">8.3 Чтение и запись структур в файл</a>
    <br><a href="#p8.4">8.4 Чтение и запись в файл и функции fwrite и fread</a>
    <br><a href="#p8.5">8.5 Чтение и запись текстовых файлов</a>
    <br><a href="#p8.6">8.6 Форматируемый ввод-вывод</a>
    <br><a href="#p8.7">8.7 Позиционирование в файле</a>
    <br><a href="#p8.8">8.8 Консольный ввод-вывод</a>
    <br><a href="#p8.9">8.9 Форматированный ввод и вывод в строки. Функции sscanf и sprintf</a>
  </p>

  <p>
    <a href="#p9.1">9 Стандартная библиотека С</a>
    <br><a href="#p9.1">9.1 Заголовочные файлы стандартной библиотеки С</a>
    <br><a href="#p9.2">9.2 Работа со строками</a>
    <br><a href="#p9.3">9.3 Работа с памятью</a>
    <br><a href="#p9.4">9.4 Работа с датами и временем</a>
    <br><a href="#p9.5">9.5 Математические функции</a>
    <br><a href="#p9.6">9.6 Преобразование строк в числа и чисел в строки</a>
    <br><a href="#p9.7">9.7 Обобщения и макрос _Generic</a>
    <br><a href="#p9.8">9.8 Поддержка Unicode и кодировки UTF-16 и UTF-32</a>
    <br><a href="#p9.9">9.9 Платформо-независимые числа</a>
    <br><a href="#p9.10">9.10 Проверка символов и ctype.h</a>
  </p>

  <p>
    <a href="#p10.1">10 Многопоточность</a>
    <br><a href="#p10.1">10.1 Создание и запуск потоков</a>
    <br><a href="#p10.2">10.2 Завершение потоков</a>
    <br><a href="#p10.3">10.3 Мьютексы</a>
    <br><a href="#p10.4">10.4 Сигналы и условные переменные синхронизации</a>
    <br><a href="#p10.5">10.5 Семафоры</a>
  </p>

  <p>
    <a href="#p11.1">11 Макросы</a>
    <br><a href="#p11.1">11.1 Примеры распространенных макросов</a>
    <br><a href="#p11.2">11.2 Макрос для вывода отладочной информации</a>
    <br><a href="#p11.3">11.3 Макрос для создания обобщенного списка</a>
  </p>

  <p>
    <a href="#p12.1">12 Среды разработки для С</a>
    <br><a href="#p12.1">12.1 Первая программа в Visual Studio</a>
    <br><a href="#p12.2">12.2 Первая программа в Qt Creator</a>
  </p>

  <p>
    <a href="#p13.1">13 Взаимодействие с кодом Python</a>
    <br><a href="#p13.1">13.1 Подключение Python</a>
  </p>

  <p>
    <a href="#p14.1">14 Дополнительные статьи</a>
    <br><a href="#p14.1">14.1 Разделяемые библиотеки на Linux</a>
    <br><a href="#p14.2">14.2 Функции setjmp и longjmp и обработка ошибок</a>
  </p>

  <p>
    <a href="#p15">Упражнения по языку С</a>
  </p>
</article>


<!-- 1 Введение в C -->
<!-- 1.1 Язык программирования C -->
<article class="article">
  <div class="anchor" id="p1.1"></div>
  <h3>1 Введение в C</h3>
  <h3>1.1 Язык программирования C</h3>

  <p>Язык программирования С (си) является одним из самых популярных и распространенных языков. Он представляет компилируемый язык программирования общего назначения со статической типизацией, разработанный в 1969—1973 годах в компании Bell Labs программистом Деннисом Ритчи (Dennis Ritchie).</p>

  <p>Язык С нередко называют языком программирования "среднего уровня" или даже "низкого уровня", так как он сочетает элементы языков высокого уровня с функциональностью и производительностью ассемблера и работает близко к аппаратной части компьютера. В итоге мы можем манипулировать данными на низком уровне и при этом использовать высокоуровневые конструкции для управления работы программы.</p>

  <p>Первоначально язык С предназначался для написания операционной системы Unix. Впоследствии Си стал одним из популярных языков, а его основной сферой применения стало системное программирование, в частности, создание операционных систем, драйверов, различных утилит, антивирусов и т.д. К слову сказать, Linux большей частью написан на Си. Однако только системным программированием применение данного языка не ограничивается. Данный язык можно использовать в программах любого уровня, где важны скорость работы и производительность. Так, мы можем писать с помощью Си и прикладные приложения, и даже веб-сайты (используя технологию CGI - Common Gateway Interface). Но, конечно, для создания графического интерфейса и веб-приложений, как правило, выбираются более подходящие инструменты и технологии, но тем не менее круг использования Си довольно широк. Это в немалой степени определило популярность языка. Например, в известном рейтинге языков программирования TIOBE язык С долгое время уверенно удерживает второе место.</p>

  <p>Несмотря на большие возможности язык Си одновременно довольно прост. Он не содержит много конструкций, библиотек, его легко осваивать и изучать. Поэтому нередко его выбирают в качестве языка для изучения в целом программированию.</p>

  <p>Си является компилируемым языком, а это значит, что компилятор транслирует исходный код на Си в исполняемый файл, который содержит набор машинных инструкций. Но разные платформы имеют свои особенности, поэтому скомпилированные программы нельзя просто перенести с одной платформы на другую и там уже запустить. Однако на уровне исходного кода программы на Си обладают переносимостью, а наличие компиляторов, библиотек и инструментов разработки почти под все распространенные платформы позволяет компилировать один и тот же исходный код на Си в приложения под эти платформы.</p>

  <p>Развитие Си оказало большое влияние в целом на развитие языков программирования. В частности, его синтаксис стал основой для таких языков как С++, С#, Java, PHP, JavaScript. Особо следует сказать про связь с C++. C++ напрямую произошёл от Си. Но впоследствии их развитие происходило отдельно друг от друга, и даже появилась несовместимость между ними. Стандарт C99 добавил в язык Си ряд конфликтующих с C++ особенностей. В итоге в настоящее время оба языка являются фактически самодостаточными и развиваются независимо.</p>

  <h4>Основные особенности Си</h4>
  <ul>
    <li>Универсальность - один и тот же код может быть скомпилирован на почти каждой платформе (при наличии для нее компилятора)</li>
    <li>Высокая скорость выполнения</li>
    <li>Компактность, небольшой размер выходных скомпилированных файлов</li>
  </ul>

  <h4>Основные этапы развития</h4>

  <p>В 1978 году Брайан Керниган и Деннис Ритчи опубликовали первое издание своего знаменитого труда "Язык программирования Си". Долгое время эта книга служила неформальной спецификацией языка Си. Однако быстрое распространение Си привело к необходимости выработки общих стандартов. И в 1983 году организация ANSI (Американский национальный институт стандартов) создала комитет для разработки спецификации Си. А в 1989 году спецификация была утверждена. Эту версию языка принято называть ANSI C или C89. В 1990 году спецификация ANSI C была немного дополнена Международной организацией по стандартизации (ISO). Новый стандарт стал называться ISO/IEC 9899:1990 или сокращенно С90.</p>

  <p>В конце 1990-х годов стандарт подвергся пересмотру, что привело к выходу нового стандарта в 1999 году, который принято называть C99 (официальное название ISO 9899:1999). В году 2018 вышел последний на момент написания текущей статьи стандарт C17 (официальное название ISO/IEC 9899:2018). В 2023 планируется выход стандарта C23. Список всех стандартов</p>
  <ul>
    <li>ANSI C Standard (ANSI C / C89)</li>
    <li>C90 (ISO/IEC 9899:1990)</li>
    <li>C99 (ISO/IEC 9899:1999)</li>
    <li>C11 (ISO/IEC 9899:2011)</li>
    <li>C17 (ISO/IEC 9899:2018)</li>
    <li>C23 (ожидает выхода в 2023 году)</li>
  </ul>

  <h4>Компиляторы и среды разработки</h4>

  <p>Для написания программ на языке С необходимы как минимум два компонента: текстовый редактор для написания исходного кода программы, и компилятор для компиляции кода в исполняемый файл. В качестве текстового редактора можно выбрать любой понравившийся. Я бы посоветовал кросcплатформенный редактор Visual Studio Code, который поддерживает плагины для разных языков, в том числе для C.</p>

  <p>Среди компиляторов под Си следует выделить следующие компиляторы</p>
  <ul>
    <li>GCC от проекта GNU</li>
    <li>Clang</li>
  </ul>

  <p>Так, если обратиться к опросу разработчиков, проведенному компанией JetBrains s 2022, то доли использования различных компиляторов среди разработчиков распределились следующим образом:</p>
  <ul>
    <li>80% GCC</li>
    <li>38% Clang</li>
    <li>18% Compiler for microcontrollers</li>
    <li>17% MSVC</li>
  </ul>

  <p>В дальнейшем на страницах этого руководства буду ориентироваться прежде всего на компилятор GCC, который на мой субъективный взгляд на сегодняшний день является наиболее распространенным.</p>

  <p>Один из вопросов, который может возникнуть при выборе компилятора, - это поддержка компилятором определенных стандартов, особенно если мы хотим использовать некоторые возможности, которые были введены в последних стандартах. В этом случае можно обратиться к странице <a href="https://en.cppreference.com/w/c/compiler_support">https://en.cppreference.com/w/c/compiler_support</a></p>
</article>


<!-- 1.2 Компилятор GCC. Первая программа на Windows -->
<article class="article">
  <div class="anchor" id="p1.2"></div>
  <h3>1.2 Компилятор GCC. Первая программа на Windows</h3>

  <h4>Установка компилятора</h4>

  <p>Рассмотрим создание первой простейшей программы на языке Си с помощью компилятора GCC, который на сегодняшний день является одим из наиболее популярных компиляторов для Cи и который доступен для разных платформ. Более подобному информацию о GCC можно получить на официальном сайте проекта <a href="https://gcc.gnu.org/">https://gcc.gnu.org/</a></p>

  <p>Набор компиляторов GCC распространяется в различных версиях. Для Windows одной из наиболее популярных версий является пакет средств для разработки от некоммерческого проекта MSYS2. Следует отметить, что для MSYS2 требуется 64-битная версия Windows 7 и выше (то есть Vista, XP и более ранние версии не подходят)</p>
  <ul>
    <li>Итак, загрузим программу установки MSYS2 с официального сайта MSYS2:</li>
    <li>После загрузки запустим программу установки:</li>
    <li>На первом шаге установки будет предложено установить каталог для установки. По умолчанию это каталог C:\msys64:</li>
    <li>Оставим каталог установки по умолчанию (при желании можно изменить). На следующем шаге устанавливаются настройки для ярлыка для меню Пуск, и затем собственно будет произведена установка.</li>
    <li>После завершения установки нам отобразить финальное окно, в котором нажмем на кнопку Завершить</li>
    <li>После завершения установки запустится консольное приложение MSYS2.exe. Если по каким-то причинам оно не запустилось, то в папке установки C:/msys64 надо найти файл usrt_64.exe:</li>
    <li>
      Теперь нам надо установить собственно набор компиляторов GCC. Для этого введем в этом приложении следующую команду:
      <code>pacman -S mingw-w64-ucrt-x86_64-gcc</code>
      <p>Для управления пакетами MSYS2 использует пакетный менеджер Packman. И данная команда говорит пакетному менелжеру packman установить пакет mingw-w64-ucrt-x86_64-gcc, который представляет набор компиляторов GCC (название устанавливаемого пакета указывается после параметра -S).</p>
    </li>
    <li>
      <p>и после завершения установки мы можем приступать к программированию на языке Си. Если мы откроем каталог установки и зайдем в нем в папку C:\msys64\ucrt64\bin, то найдем там все необходимые файлы компиляторов:</p>
      <p>В частности, файл gcc.exe как раз и будет представлять компилятор для языка Си.</p>
    </li>
    <li>Далее для упрощения запуска компилятора мы можем добавить путь к нему в Переменные среды. Для этого можно в окне поиска в Windows ввести "изменение переменных среды текущего пользователя":</li>
    <li>Нам откроется окно Переменные среды:</li>
    <li>И добавим путь к компилятору C:\msys64\ucrt64\bin:</li>
    <li>Чтобы убедиться, что набор компиляторов GCC успешно установлен, введем следующую команду:
      <code>gcc --version</code>
      <p>В этом случае нам должна отобразиться версия компиляторов</p>
    </li>
  </ul>

  <h4>Создание первой программы</h4>

  <p>Итак, компилятор установлен, и теперь мы можем написать первую программу. Для этого потребуется любой текстовый редактор для набора исходного кода. Можно взять распространенный редактор Visual Studio Code или даже обычный встроенный Блокнот.</p>
  <p>Итак, создадим на жестком диске папку для исходных файлов. А в этой папке создадим новый файл, который назовем hello.c.</p>
  <p>В моем случае файл hello.c находится в папке C:\c.</p>
  <p>Теперь определим в файле hello.c простейший код, который будет выводить строку на консоль:</p>
<pre>
#include &lt;stdio.h&gt;            // подключаем заголовочный файл stdio.h

int main(void)                      // определяем функцию main
{                                   // начало функции
  printf("Hello METANIT.COM!\n");   // выводим строку на консоль
  return 0;                         // выходим из функции
}                                   // конец функции
</pre>
  <p>Для вывода строки на консоль необходимо подключить нужный функционал. Для этого в начале файла идет строка</p>
  <code>#include &lt;stdio.h&gt;</code>

  <p>Директива include подключает заголовочный файл stdio.h, который содержит определение функции printf, которая нужна для вывода строки на консоль.</p>

  <p>Далее идет определение функции int main(void). Функция main должна присутствовать в любой программе на Си, с нее собственно и начинается выполнение приложения.</p>

  <p>Ключевое слово int в определении функции int main(void) говорит о том, что функция возвращает целое число. А слово void в скобках указывает, что функция не принимает параметров.</p>

  <p>Тело функции main заключено в фигурные скобки {}. В теле функции происходит вывод строки на консоль с помощью функции printf, в которую передается выводимая строка "Hello METANIT.COM!".</p>

  <p>В конце осуществляем выход из функции с помощью оператора return. Так как функция должна возвращать целое число, то после return указывается число 0. Ноль используется в качестве индикатора успешного завершения программы.</p>

  <p>После каждого действия в функции ставятся точка с запятой.</p>
  <p>Теперь скомпилируем этот файл. Для этого откроем командную строку Windows и вначале с помощью команды cd перейдем к папке с исходным файлом:</p>
  <code>cd C:\c</code>
  <p>Чтобы скомпилировать исходный код, необходимо компилятору gcc передать в качестве параметра файл hello.c:</p>
  <code>gcc hello.c</code>
  <p>После этого будет скомпилирован исполняемый файл, который в Windows по умолчанию называется a.exe. И мы можем обратиться к этому файлу</p>
  <code>a.exe</code>
  <p>и в этом случае консоль выведет строку "Hello METANIT.COM!", собственно как и прописано в коде.</p>
  <p>Стоит отметить, что мы можем переопределить имя компилируемого файла с помощью флага -o и передав ему имя файла, в который будет компилироваться программа. Например:</p>
  <code>gcc hello.c -o hello.exe</code>
  <p>В этом случае программа будет компилироваться в файл hello.exe, который мы также запустить.</p>
  <p>Чтобы не приходилось вводить две команды: одну для компиляции программы и другую для ее запуска, мы можем объединить команды:</p>
  <code>gcc hello.c -o hello.exe & hello</code>
  <p>Эта команда сначала компилирует код в файл hello.exe, а потом сразу запускает его.</p>
</article>


<!-- 1.3 Компилятор Clang. Первая программа на Windows -->
<article class="article">
  <div class="anchor" id="p1.3"></div>
  <h3>1.3 Компилятор Clang. Первая программа на Windows</h3>

  <h4>Установка Clang</h4>

  <p>Одним из наиболее распространенных компиляторов для языка C является компилятор Clang, который развивается в рамках проекта LLVM. Рассмотрим создание первой простейшей программы на C с помощью Clang под ОС Windows.</p>

  <p>Прежде всего нам надо установить непосредственно сам компилятор. Clang развивается в рамках проекта LLVM, репозиторий которого можно найти на github: <a href="https://github.com/llvm/llvm-project">https://github.com/llvm/llvm-project</a>. И данный проект предоставляет готовый установщик компилятора под Windows</p>

  <p>Для загрузки установщика под Windows перейдем на страницу релизов в данном репозитории по ссылке <a href="https://github.com/llvm/llvm-project/releases/">https://github.com/llvm/llvm-project/releases/</a></p>

  <p>По умолчанию в самом верху будут ссылки на самую последнюю версию. Но по умолчанию ссылка на установщик для Windows может быть скрыта. В этом случае под набором ссылок необходимо нажать на ссылку Show All assets. И среди появившихся ссылок найдем пункт LLVM-XX.X.X-win64.exe, где XX.X.X - это версия. Например, в моем случае это файл LLVM-18.1.0-win64.exe</p>

  <p>Это версия для 64-битной версии Windows. Если ОС 32-х битная, то необходимо загрузить файл LLVM-18.1.0-win32.exe</p>
  <ol>
    <li>После загрузки запустим файл.</li>
    <li>На стартовом экране программы нажмем на кнопку "Далее". Затем надо будет принять лицензионное соглашение</li>
    <li>Далее надо будет указать опции установки: Чтобы при компиляции не указывать полные пути к компилятору или вручную не добавлять путь к нему в переменные среды выберем на этом окне пункт Add LLVM to the system PATH for current user</li>
    <li>На следующем окне укажем папку для установки. Можно оставать путь по умолчанию - "C:/Program Files/LLVM":</li>
    <li>На следующих окнах оставим все опции по умолчанию и запустим процесс установки. После успешной установки мы можем приступать к использованию Clang</li>
  </ol>
  <p>Чтобы проверить установку Clang, в терминале/командной строке следует ввести команду</p>
  <code>clang --version</code>
  <p>В этом случае нам должна отобразиться базовая информация о компиляторе, типа версии и т.д.:</p>

  <h4>Первая программа</h4>

  <p>После завершения установки если мы откроем каталог C:\Program Files\LLVM\bin, то найдем там все необходимые файлы компиляторов:</p>
  <p>В частности, файл clang.exe предназначен для компиляции программы на языке Си.</p>

  <h4>Создание первой программы</h4>

  <p>Итак, компилятор установлен, и теперь мы можем написать первую программу. Для этого потребуется любой текстовый редактор для набора исходного кода. Можно взять распространенный редактор Visual Studio Code или даже обычный встроенный Блокнот.</p>
  <p>Итак, создадим на жестком диске папку для исходных файлов. А в этой папке создадим новый файл, который назовем hello.c.</p>
  <p>В моем случае файл hello.c находится в папке C:\c.</p>
  <p>Теперь определим в файле hello.c простейший код, который будет выводить строку на консоль:</p>
<pre>
#include &lt;stdio.h&gt;

int main(void) {
  printf("Hello METANIT.COM!\n");
  return 0;
}
</pre>
  <p>Для вывода строки на консоль необходимо подключить нужный функционал. Для этого в начале файла идет строка</p>
  <code>#include &lt;stdio.h&gt;</code>
  <p>Директива include подключает заголовочный файл stdio.h, который содержит определение функции printf, которая нужна для вывода строки на консоль.</p>

  <p>Далее идет определение функции int main(void). Функция main должна присутствовать в любой программе на Си, с нее собственно и начинается выполнение приложения.</p>

  <p>Ключевое слово int в определении функции int main(void) говорит о том, что функция возвращает целое число. А слово void в скобках указывает, что функция не принимает параметров.</p>

  <p>Тело функции main заключено в фигурные скобки {}. В теле функции происходит вывод строки на консоль с помощью функции printf, в которую передается выводимая строка "Hello METANIT.COM!".</p>

  <p>В конце осуществляем выход из функции с помощью оператора return. Так как функция должна возвращать целое число, то после return указывается число 0. Ноль используется в качестве индикатора успешного завершения программы.</p>

  <p>После каждого действия в функции ставятся точка с запятой.</p>
  <p>Теперь скомпилируем этот файл. Для этого откроем командную строку Windows и вначале с помощью команды cd перейдем к папке с исходным файлом:</p>
  <code>cd C:\c</code>
  <p>Чтобы скомпилировать исходный код, необходимо компилятору clang передать в качестве параметра файл hello.c:</p>
  <code>clang hello.c -o hello.exe</code>
  <p>Дополнительный необязательный параметр -o hello.exe указывает, что скомпилированный файл будет называться hello.exe. Если не указать этот параметр, то файл будет называться по умолчанию - a.exe.</p>
  <p>После выполнения этой команды будет скомпилирован исполняемый файл, который в Windows по умолчанию называется hello.exe. И мы можем обратиться к этому файлу, и в этом случае консоль выведет строку "Hello METANIT.COM!", собственно как и прописано в коде.</p>
  <p>Если вместо командной строки используется оболочка PowerShell, то для запуска файла надо прописать "./hello".</p>
</article>


<!-- 1.4 GCC. Первая программа на Linux -->
<article class="article">
  <div class="anchor" id="p1.4"></div>
  <h3>1.4 GCC. Первая программа на Linux</h3>

  <p>Рассмотрим создание первой программы на Linux, в частности, в среде Ubuntu. Как правило, многие дистрибутивы Linux, в том числе и Ubuntu, уже по умолчанию содержат установленный компилятор gcc, который мы сразу же можем использовать. Но даже если вдруг он не установлен, то его можно доустановить в терминале через команду:</p>
  <code>sudo apt-get install gcc</code>
  <p>В остальном, если мы будем использовать для компиляции компилятор GCC, все будет аналогично созданию программы на Windows.</p>
  <p>Определим в файловой системе каталог для исходных файлов с кодом на Си и создадим в нем новый файл hello.c со следующим кодом:</p>
<pre>
#include &lt;stdio.h&gt;

int main(void) {
  printf("Hello METANIT.COM!\n");
  return 0;
}
</pre>
  <p>И это тот же код, что был в случае с Windows, потому что программы на Си на уровне исходного кода в большей степени обладают переносимостью.</p>
  <p>Чтобы вывести строку на консоль, необходимо подключить подключает заголовочный файл stdio.h с помощью директивы include.</p>
  <code>#include &lt;stdio.h&gt;</code>
  <p>Этот заголовочный файл содержит определение функции printf, которая нужна для вывода строки на консоль.</p>
  <p>Далее идет определение функции int main(void) - главной функции, которая должна присутствовать в любой программе на Си. С нее собственно и начинается выполнение приложения.</p>
  <p>Ключевое слово int в определении функции int main(void) говорит о том, что функция возвращает целое число. А слово void в скобках указывает, что функция не принимает параметров. А все содержимое функции заключается в фигурные скобки.</p>
  <p>В самой функции происходит вывод строки на консоль с помощью функции printf, в которую передается выводимая строка "Hello world!".</p>
  <p>В конце осуществляем выход из функции с помощью оператора return. Так как функция должна возвращать целое число, то после return указывается число 0. Ноль используется в качестве индикатора успешного завершения программы.</p>
  <p>Перейдем к терминалу и вначале с помощью команды cd перейдем к каталогу, где расположен файл с исходным кодом.</p>
  <p>Далее для компиляции программы введем команду</p>
  <code>gcc hello.c</code>
  <p>В итоге в папке с файлом hello.c появился скомпилированный файл, который по умолчанию называется a.out. Запустим его с помощью следующей команды:</p>
  <code>./a.out</code>
  <p>И на консоль будет выведена сакральная строка "Hello World!".</p>
</article>


<!-- 1.5 Clang. Первая программа на MacOS -->
<article class="article">
  <div class="anchor" id="p1.5"></div>
  <h3>1.5 Clang. Первая программа на MacOS</h3>

  <p>Для компиляции программы на Си в MacOS одним из наиболее популярных компиляторов является Clang (стоит отметить, что clang может также применяться для компиляции программы на C++ и Objective-C). Считается, что clang работает быстрее и потребляет меньше памяти, чем GCC. Для работы с clang в MacOS необходимо установить утилиту Xcode Command Line Tools. Самой простой способ установить эту утилиту - установить сам XCode, с которым автоматически устанавливается и Xcode Command Line Tools.</p>
  <p>Для работы определим в файловой системе каталог для исходных файлов с кодом на Си и создадим в нем новый файл hello.c со следующим кодом:</p>
<pre>
#include &lt;stdio.h&gt;

int main(void) {
  printf("Hello METANIT.COM!\n");
  return 0;
}
</pre>
  <p>Этот код аналогичен тому, что применялся в случае с Windows и Linux.</p>
  <p>Чтобы вывести строку на консоль, необходимо подключить заголовочный файл stdio.h с помощью директивы include.</p>
  <code>#include &lt;stdio.h&gt;</code>
  <p>Этот заголовочный файл содержит определение функции printf, которая нужна для вывода строки на консоль.</p>
  <p>Далее идет определение функции int main(void) - главной функции, которая должна присутствовать в любой программе на Си. С нее собственно и начинается выполнение приложения.</p>
  <p>Ключевое слово int в определении функции int main(void) говорит о том, что функция возвращает целое число. А слово void в скобках указывает, что функция не принимает параметров. А все содержимое функции заключается в фигурные скобки.</p>
  <p>В самой функции происходит вывод строки на консоль с помощью функции printf, в которую передается выводимая строка "Hello METANIT.COM!".</p>
  <p>В конце осуществляем выход из функции с помощью оператора return. Так как функция должна возвращать целое число, то после return указывается число 0. Ноль используется в качестве индикатора успешного завершения программы.</p>
  <p>Перейдем к терминалу и вначале с помощью команды cd перейдем к каталогу, где расположен файл с исходным кодом.</p>
  <p>Далее для компиляции программы введем команду</p>
  <code>clang hello.c</code>
  <p>В итоге в папке с файлом hello.c появился скомпилированный файл, который по умолчанию называется a.out. Запустим его с помощью следующей команды:</p>
  <code>./a.out</code>
  <p>И на консоль будет выведена строка "Hello METANIT.COM!".</p>
  <p>При компиляции с помощью флага -o можно задать имя выходного файла:</p>
  <code>clang hello.c -o app</code>
  <p>В этом случае будет компилироваться файл app, который также будет находиться в папке с файлом hello.c. И в этом случае мы его можем запустить следующим образом:</p>
  <code>./app</code>
</article>


<!-- 1.6 Настройка параметров компиляции -->
<article class="article">
  <div class="anchor" id="p1.6"></div>
  <h3>1.6 Настройка параметров компиляции</h3>

  <h4>Параметры компилятора gcc</h4>

  <p>По умолчанию при компиляции не отображается никакх предупреждений. Тем не менее предупреждения компилятора могут подсказать о наличие определенных проблем в коде, даже если код успешно компилируется. Простейший пример: в программе определена переменная, но она нигде не используется. И при компиляции компилятор может подсказать о данной пробелеме, что поможет разработчику идентифицировать проблему и сразу отреагировать на нее.</p>
  <p>Для компиляции с предупреждениями применяется флаг -Wall:</p>
  <code>gcc -Wall source.c</code>
  <p>Есть разные версии стандарта языка Си, и каждый из них может добавлять дополнительный функционал, который мы, возможно, захотим использовать в программе. С помощью флага -std= можно указать конкретный стандарт, добавив c99, c11 или c17. Например, для компиляции в стандарт c99 нужно написать:</p>
  <code>gcc -std=c99 source.c</code>
  <p>Аналогично для компиляции в стандарт C11 используется команда:</p>
  <code>gcc -std=c11 source.c</code>
  <p>Чтобы гарантировать, что программа будет строго соответствовать определенному стандарту, можно указать флаг -pedantic</p>
<pre>
gcc -std=c99 -Wall -pedantic source.c
gcc -std=c11 -Wall -pedantic source.c
gcc -std=c17 -Wall -pedantic source.c
gcc -std=c23 -Wall -pedantic source.c
</pre>
  <p>В этом случае компилятор будет генерировать предупреждения, если код не соответствует правилам стандарта.</p>
  <p>Для того, чтобы автоматически запустить приложение после компиляции, можно использовать следующую команду:</p>
  <code>gcc source.c & ./a.out</code>
  <p>Можно налепить в одну команду различные опции:</p>
  <code>gcc -std=c17 -Wall -pedantic app.c -o app.exe & app</code>
  <p>Опция -S позволяет сгенерировать файл с ассемблерным кодом:</p>
  <code>gcc app.c -S</code>
  <p>В данном случае по содержимому app.c будет сгенерирован файл, который называется как и исходный файл, только имеет расширение .s, то есть в данном случае будет сгенерирован файл app.s. Этот файл будет содержать код на ассемблере, причем в качестве синтаксиса применяется синтаксис ассемблера GAS (ассемблера от GNU).</p>

  <h4>Параметры компилятора clang</h4>

  <p>Основные параметры компилятора Clang в ряде случаев повторяют параметры для gcc. Например, компиляция с помощью Clang под определенный стандарт с выводом ошибок:</p>
  <code>clang -std=c17 -Wall -pedantic app.c -o app.exe & app.exe</code>
</article>


<!-- 1.7 Локализация и кириллица в консоли -->
<article class="article">
  <div class="anchor" id="p1.7"></div>
  <h3>1.7 Локализация и кириллица в консоли</h3>

  <p>При использовании кириллических символов мы можем столкнуться с ситуацией, когда вместо кириллических символов отображаются непонятные знаки. Особенно это актуально для ОС Windows. И в этом случае необходимо явным образом задать текущую локаль (культуру) для вывода символов. В Си это делается с помощью функции setlocale(), определение которой имеется в заголовочном файле locale.h.</p>
  <p>Итак, изменим код, который использовался в прошлых темах следующим образом:</p>
<pre>
#include &lt;stdio.h&gt;

int main(void) {
  printf("Привет мир!\n");
  return 0;
}
</pre>
  <p>Компиляция и запуск в ОС Windows может выглядеть следующим образом:</p>
<pre>
c:\C>gcc hello.c -o hello & hello
╧ЁштхЄ ьшЁ!
</pre>
  <p>Вместо русских слов я получаю непонятные символы, и это не то, что ожидалось. Теперь изменим код, применив функцию setlocale:</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;locale.h&gt;

int main(void) {
  char *locale = setlocale(LC_ALL, "");

  printf("Привет мир!\n");
  return 0;
}
</pre>
  <p>Поскольку функция setlocale определена в файле locale.h, то он подключается с помощью директивы #include &lt;locale.h&gt;.</p>
  <p>Повторно компилируем и запустим приложение:</p>
<pre>
c:\C>gcc hello.c -o hello & hello
Привет мир!
</pre>
  <p>Стоит отметить, что в качестве кодировки текстового файла в этом случае должна использоваться кодировка ANSI или Windows-1251, но не UTF-8.</p>
  <p>На некоторых платформах, например, Ubuntu/MacOS, мы можем не столкнуться с подобной проблемой. И в этом случае вызов функции setlocale просто не окажет никакого влияния.</p>
</article>


<!-- 2 Основы языка Си -->
<!-- 2.1 Структура программы на Си -->
<article class="article">
  <div class="anchor" id="p2.1"></div>
  <h3>2 Основы языка Си</h3>
  <h3>2.1 Структура программы на Си</h3>

  <p>Программа на языке Си состоит из набора директив препроцессора, определений функций и глобальных объектов. Директивы препроцессора управляют преобразованием текста до его компиляции. Глобальные объекты определяют используемые данные или состояние программы. А функции определяют поведение или действия программы. Простейшая программа на Си, которая была определена в прошлых темах:</p>
<pre>
#include &lt;stdio.h&gt;

int main(void) {
  printf("Hello METANIT.COM!\n");
  return 0;
}
</pre>

  <h4>Инструкции</h4>
  <p>Простейшим строительным элементом программы на Си являются инструкции (statements). Каждая инструкция выполняет определенное действие. В конце инструкций в языке Си ставится точка с запятой (;). Данный знак указывает компилятору на завершение инструкции. Например:</p>
  <code>printf("Hello METANIT.COM!");</code>
  <p>Вызов функции printf, которая выводит на консоль строку "Hello METANIT.COM!" является инструкцией и завершается точкой с запятой.</p>
  <p>Набор инструкций может представлять блок кода. Блок кода оформляется фигурными скобками, инструкции, составляющие тело этого блока, помещаются между открывающей и закрывающей фигурными скобками:</p>
<pre>
{
  printf("Hello METANIT.COM!");
  printf("Bye world!");
}
</pre>
  <p>В этом блоке кода две инструкции. Обе инструкции представляют вызов функции printf() и выводят определенную строку на консоль.</p>

  <h4>Директивы препроцессора</h4>

  <p>Для вывода данных на консоль в примере выше используется функция printf(), но чтобы использовать эту функцию, чтобы она вообще стала нам доступна в программе на Си, необходимо в начале файла с исходным кодом подключать заголовочный файл stdio.h с помощью директивы include.</p>
  <p>Директива include является директивой препроцессора. Кроме данной include есть еще ряд директив препроцессора, например, define.</p>
  <p>Каждая директива препроцессора размещается на одной строке. И в отличие от обычных инструкций языка Си, которые завершаются точкой с запятой ; , признаком завершения препроцессорной директивы является перевод на новую строку. Кроме того, директива должна начинаться со знака решетки #.</p>
  <p>Непосредственно директива "include" определяет, какие файлы надо включить в данном месте в текст программы. По умолчанию мы можем подключать стандартные файлы из каталога так называемых "заголовочных файлов", которые обычно поставляются вместе со стандартными библиотеками компилятора. И файл "stdio.h" как раз является одним из таких заголовочных файлов.</p>
  <p>Вообще сам термин "заголовочный файл" (header file) предполагает включение текста файла именно в начало или заголовок программы. Поэтому заголовочные файлы подключаются, как правило, в начале исходного кода. Кроме того, заголовочный файл должен быть подключен до вызова тех функций, которые он определяет. То есть, к примеру, файл stdio.h хранит определение функции printf, поэтому этот файл необходимо подключить до вызова функции printf.</p>
  <p>Но в целом директивы препроцессора необязательно должны быть размещены в начале файла.</p>

  <p>При компиляции исходного кода вначале срабатывает препроцессор, который сканирует исходный код на наличие строк, которые начинаются с символа #. Эти строки расцениваются препроцессором как директивы. И на месте этих директив происходит преобразование текста. Например, на месте директивы #include &lt;stdio.h&gt; вставляется код из файла stdio.h.</p>

  <h4>Функция main</h4>

  <p>Стартовой точкой в любую программу на языке Си является функция main(). Именно с этой функции начинается выполнение приложения. Ее имя main фиксировано и для всех программ на Си всегда одинаково.</p>
  <p>Функция также является блоком кода, поэтому ее тело обрамляется фигурными скобками, между которыми идет набор инструкций.</p>
  <p>Стоит отметить, что в разной литературе и примерах можно встретить модификации этой функции. В частности, вместо определения выше мы могли бы написать по другому:</p>
<pre>
#include &lt;stdio.h&gt;

void main() {
  printf("Hello METANIT.COM!\n");
}
</pre>
<pre>
#include &lt;stdio.h&gt;

int main() {
  printf("Hello METANIT.COM!\n");
  return 0;
}
</pre>
  <p>Использование этих определений не было бы ошибкой, и программа также вывела бы строку "Hello METANIT.COM" на консоль. И для большинства компиляторов это было бы нормально.</p>

  <h4>Комментарии</h4>

  <p>Программа может сопровождаться комментариями. Комментарии содержат описание программы, характеристики кода. При компиляции комментарии не учитываются и не оказывают никакого влияние на работу программы. В то же время они дают программисту понимание того, как работает код.</p>
  <p>В Си можно использовать два типа комментариев: блочный и строчный. Блочный заключается между символами /* текст комментария */. Он может размещаться на нескольких строках. Например:</p>
<pre>
#include &lt;stdio.h&gt;

/* Функция main выводит
на консоль строку Hello World */
int main() {
  printf("Hello METANIT.COM! \n");
  return 0;
}
</pre>
  <p>Строчный комментарий помещается на одной строке после двойного слеша:</p>
<pre>
#include &lt;stdio.h&gt;

int main() { // Функция main
  printf("Hello METANIT.COM! \n");
  return 0;
}
</pre>
</article>


<!-- 2.2 Переменные -->
<article class="article">
  <div class="anchor" id="p2.2"></div>
  <h3>2.2 Переменные</h3>

  <p>Для хранения данных в языке программирования Си используются переменные. Переменная может иметь тип, имя и значение.</p>
  <p>Перед использованием любую переменную надо определить. Синтаксис определения переменной выглядит следующим образом:</p>
  <code>тип_переменной имя_переменной;</code>
  <p>Например, простейшее определение переменной:</p>
  <code>int number;</code>
  <p>Здесь определена переменная number, которая имеет тип int. Поскольку определение переменной представляет собой отдельное выражение, то после него ставится точка с запятой.</p>
  <p>Имя переменной может представлять последовательность символов латинского алфавита, чисел и знака подчеркивания. При этом имя должно начинаться либо с алфавитного символа, либо со знака подчеркивания.</p>
  <code>int _number33;</code>
  <p>Нередко компиляторы имеют ограничение на длину названий переменных, например, для некоторых компиляторов длина имени переменной не должна превышать 31 символа, для других компиляторов ограничение может быть более жестким.</p>
  <p>Также стоит учитывать, что C - регистрозависимый язык, а это значит, что регистр символов имеет большое значение. То есть следующем коде будут определяться две разные переменные:</p>
<pre>
int number;
int Number;
</pre>
  <p>Поэтому переменная Number не будет представлять то же самое, что и переменная number.</p>
  <p>Кроме того, в языке есть ряд зарезервированных слов, которые не могут использоваться в качестве имени переменной. Их не так много: auto, break, case, char, const, continue, default, do, double, else, enum, extern, float, for, goto, if, int, long, register, return, short, signed, sizeof, static, struct, switch, typedef, union, unsigned, void, volatile, while.</p>
  <p>Также нельзя объявить больше одной переменной с одним и тем же именем, например:</p>
<pre>
int number;
int number;
</pre>
  <p>Подобное определение вызовет ошибку на этапе компиляции.</p>
  <p>Можно определить сразу несколько переменных:</p>
  <code>int number1, number2, number3;</code>
  <p>Здесь определены три переменных: number1, number2 и number3.</p>

  <h4>Присвоение значения</h4>

  <p>При определении переменных каждой из них присваивается неопределенное значение. Но в дальнейшем мы можем присвоить ей конкретное значение:</p>
<pre>
int number;
number = 2;
</pre>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int number;
  number = 2;
  printf("number = %d \n", number);
  return 0;
}
</pre>
  <p>Для вывода числа на консоль используется спецификатор %d, вместо которого вставляется значение переменной number. Таким образом, мы получим следующий консольный вывод:</p>
  <code>number = 2</code>
  <p>Однако также можно сразу при определении переменной дать ей некоторое начальное значение. Данный прием называется инициализацией:</p>
<pre>
#include &lt;stdio.h&gt;

int main(void) {
  int number = 2;
  printf("number = %d \n", number);
  return 0;
}
</pre>
  <p>Также можно инициализовать сразу несколько переменных:</p>
<pre>
#include &lt;stdio.h&gt;

int main(void) {
  int number1 = 1, number2 = 2, number3 = 3;
  printf("number1 = %d \n", number1);
  printf("number2 = %d \n", number2);
  printf("number3 = %d \n", number3);
  return 0;
}
</pre>
</article>


<!-- 2.3 Типы данных -->
<article class="article">
  <div class="anchor" id="p2.3"></div>
  <h3>2.3 Типы данных</h3>

  <p>Переменная имеет определенный тип. И этот тип определяет, какие значения может иметь переменная и сколько байт в памяти она будет занимать. В Си определены следующие базовые типы данных:</p>
  <ul>
    <li>char: представляет один символ. Занимает в памяти 1 байт (8 бит)</li>
    <li>unsigned char: представляет один символ. Занимает в памяти 1 байт (8 бит). Может хранить любой значение из диапазона от 0 до 255</li>
    <li>signed char: представляет один символ. Занимает в памяти 1 байт (8 бит). Может хранить любое значение из диапазона от -128 до 127</li>
    <li>short: представляет целое число в диапазоне от –32768 до 32767. Занимает в памяти 2 байта (16 бит). Имеет псевдонимы short int, signed short и signed short int.</li>
    <li>unsigned short: представляет целое число в диапазоне от 0 до 65535. Занимает в памяти 2 байта (16 бит). Имеет псевдоним unsigned short int.</li>
    <li>int: представляет целое число. В зависимости от архитектуры процессора может занимать 2 байта (16 бит) или 4 байта (32 бита). Если брать основные платформы - 64-разрядные Windows, Linux (вместе с Android) и MacOS, то размер int составляет 4 байта. Диапазон предельных значений соответственно также может варьироваться от –32768 до 32767 (при 2 байтах) или от −2 147 483 648 до 2 147 483 647 (при 4 байтах) и выше. Имеет псевдонимы signed int и signed</li>
    <li>unsigned int: представляет положительное целое число. В зависимости от архитектуры процессора может занимать 2 байта (16 бит) или 4 байта (32 бита), и из-за этого диапазон предельных значений может меняться: от 0 до 65535 (для 2 байт), либо от 0 до 4 294 967 295 (для 4 байт). Имеет псевдоним unsigned: то же самое, что и unsigned int</li>
    <li>long: представляет целое число и занимает в памяти 4 байта (32 бита) или 8 байт (64 бита). В зависимости от размера может находиться в в диапазоне от -2 147 483 648 до 2 147 483 647 (4 байта), либо в диапазоне от -9223372036854775807 до +9 223 372 036 854 775 807 (8 байт). Если брать распростренные платформы, то на 64-разрядном Windows long занимает 4 байта, а на 64-разрядных Linux/MacOS - 8 байт. Имеет псевдонимы long int, signed long int и signed long.</li>
    <li>unsigned long: представляет целое число и занимает в памяти 4 байта (32 бита) или 8 байт (64 бита). В зависимости от размера может находиться в в диапазоне от 0 до 4 294 967 295 (4 байта) или в диапазоне от 0 до 18 446 744 073 709 551 615 (8 байт). Имеет псевдоним unsigned long int.</li>
    <li>long long: представляет целое число в диапазоне от -9223372036854775807 до +9 223 372 036 854 775 807. Занимает в памяти, как правило, 8 байт (64 бита). Имеет псевдонимы long long int, signed long long int и signed long long.</li>
    <li>unsigned long long: представляет целое число в диапазоне от 0 до 18 446 744 073 709 551 615. Занимает в памяти, как правило, 8 байт (64 бита). Имеет псевдоним unsigned long long int.</li>
    <li>float: представляет вещественное число одинарной точности с плавающей точкой в диапазоне +/- 3.4E-38 до 3.4E+38. В памяти занимает 4 байта (32 бита)</li>
    <li>double: представляет вещественное число двойной точности с плавающей точкой в диапазоне +/- 1.7E-308 до 1.7E+308. В памяти занимает 8 байт (64 бита)</li>
    <li>long double: представляет вещественное число двойной точности с плавающей точкой в диапазоне +/- 3.4E-4932 до 1.1E+4932. В памяти занимает 10 байт (80 бит). На некоторых системах может занимать 96 и 128 бит.</li>
    <li>void: тип без значения</li>
  </ul>

  <h4>Целочисленные типы</h4>

  <p>Наиболее распространенным целочисленным типом является int (имеет псевдонимы signed int и signed), представляет целое число со знаком и обычно занимает 4 байта. Переменной такого типа можно передать целое число:</p>
<pre>
int age = 38;
signed int number = 2;
signed temps = -3;
</pre>
  <p>Для определения переменной некоторого типа можно использовать все псевдонимы этого типа. Так, в примере выше определяются три переменных типа int, хотя в каждом случае используются разные псевдонимы типа: int, signed int и signed.</p>

  <h4>Суффиксы целочисленных типов</h4>

  <p>Стоит учитывать, что любое десятичное число рассматривается по умолчанию как значение типов int/long int/long long int (в зависимости от размера) и при присвоении переменным другим типов будет выполняться преобразование. Чтобы указать, что число явным образом представляет определенный тип, к числу добавляется определенный суффикс:</p>
  <ul>
    <li>u или U, unsigned int, unsigned long int и unsigned long long int</li>
    <li>ul или UL, unsigned long int и unsigned long long int</li>
    <li>ll или LL, long long int</li>
    <li>ull или ULL, unsigned long long int</li>
  </ul>
  <p>Как видно, не для всех типов есть отдельные суффиксы. И для некоторых типов можно применять несколько суффиксов. Применим суффикс. Например, если надо хранить только положительные числа, то можно взять тип unsigned int. Для определения чисел этого типа применяется суффикс u или U:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
    unsigned number1 = 4294967294u;
    unsigned int number2 = 22U;
    printf("number1 = %u\n", number1);
    printf("number2 = %u\n", number2);
    return 0;
}
</pre>
  <p>При выводе таких чисел на консоль применяется спецификатор %u.</p>
  <p>Стоит отметить, что мы могли бы присвоить переменной число и без суффикса и получили бы тот же самый результат:</p>
<pre>
unsigned number1 = 4294967294;  // без суффикса u
unsigned int number2 = 22;      // без суффикса u
printf("number1 = %u\n", number1);
printf("number2 = %u\n", number2);
</pre>
  <p>Зачем же нужен данный суффикс? Без этого суффикса десятичное число рассматривается как значение типов int/long int/long long int и при присвоении переменной типа unsigned int выполняется преобразование. Используя суффикс, мы можем избежать ненужного преобразования.</p>
  <p>Пример определения данных других типов:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  unsigned short number1 = 1u;
  unsigned short int number2 = 2u;
  short number3 = 3;
  short int number4 = -4;
  signed short number5 = 5;
  signed short int number6 = -6;

  long number7 = -2147483648l;
  long int number8 = -2147483648L;
  signed long number9 = 2147483647l;
  signed long int number10 = 2147483647L;

  unsigned long number11 = 4294967295ul;
  unsigned long int number12 = 4294967295UL;

  long long number13 = -9223372036854775807ll;
  long long int number14 = 9223372036854775807ll;
  signed long long number15 = -9223372036854775807LL;
  signed long long int number16 = 9223372036854775807LL;

  unsigned long long number17 = 18446744073709551615ull;
  unsigned long long int number18 = 18446744073709551615ULL;

  printf("number1 = %hu\n", number1);
  printf("number2 = %hu\n", number2);
  printf("number3 = %d\n", number3);
  printf("number4 = %d\n", number4);
  printf("number5 = %d\n", number5);
  printf("number6 = %d\n", number6);
  printf("number7 = %ld\n", number7);
  printf("number8 = %ld\n", number8);
  printf("number9 = %ld\n", number9);
  printf("number10 = %ld\n", number10);
  printf("number11 = %lu\n", number11);
  printf("number12 = %lu\n", number12);
  printf("number13 = %lld\n", number13);
  printf("number14 = %lld\n", number14);
  printf("number15 = %lld\n", number15);
  printf("number16 = %lld\n", number16);
  printf("number17 = %llu\n", number17);
  printf("number18 = %llu\n", number18);
  return 0;
}
</pre>
  <p>Обратите внимание на спецификатор, который используется для вывода числа на консоль в функции printf():</p>
  <ul>
    <li>hu, unsigned short</li>
    <li>ld, long</li>
    <li>lu, unsigned long</li>
    <li>lld, long long</li>
    <li>llu, unsigned long long</li>
  </ul>

  <h4>Определение чисел в различных системах</h4>

  <p>Си позволяет определять числа в разных числовых системых. Числа в двоичной системе начинаются с символов 0b, после которых идет набор 1 и 0, которые представляют число. Восьмеричные числа начинаются с числа 0, за которым могут идти цифры от 0 до 7. Щестнадцатеричные числа начинаются с 0x или 0X, за которыми следуют шестнадцатеричные цифры от 0 до 9 и от A до F. Например:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int code1 = 0b1011;     // двоичная система - число 11
  int code2 = 013;        // восьмеричная система - число 11
  int code3 = 11;        // десятичная система - число 11
  int code4 = 0xB;        // шестнадцатеричная система - число 11
  printf("code1 = %d\n", code1);    //  code1 = 11
  printf("code2 = %d\n", code2);    //  code2 = 11
  printf("code3 = %d\n", code3);    //  code3 = 11
  printf("code4 = %d\n", code4);    //  code4 = 11
  return 0;
}
</pre>
  <p>В данном случае определены четыре переменных, но каждая из них хранит одно и то же число - 11, записанное в разных системах исчисления.</p>
  <p>При этом при определении переменных важно понимать, что значение переменной не должно выходить за те пределы, которые очерчены для ее типа. Например:</p>
  <code>unsigned short int number = -65535;</code>
  <p>Компилятор GCC при компиляции программы с этой строкой выдаст ошибку о том, что значение -65535 не входит в диапазон допустимых значений для типа unsigned short int.</p>

  <h4>Числа с плавающей точкой</h4>

  <p>Числа с плавающей точкой представлены тремя типами: float, double, long double. В качестве разделителя между целой и дробной частями применяется точка. По умолчанию все дробные числа представляют тип double, который занимает 8 байт:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  double number = 3.14159;
  printf("number = %f\n", number);
  return 0;
}
</pre>
  <p>Для вывода значения double на консоль используется спецификаторы f и lf. Чтобы указать, что число представляет тип float, применяется суффикс f, а для long double - суффикс l:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  float number1 = 3.14f;
  long double number2 = 123456.789l;
  printf("number1 = %f\n", number1);
  printf("number2 = %Lf\n", number2);
  return 0;
}
</pre>
  <p>Стоит отметить, что для вывода данных типа long double на консоль применяется спецификатор Lf, однако на некоторых платформах он может работать некорректно, например, показывать 0.</p>

  <h4>Символы</h4>

  <p>В Си представлены тремя типами: char, signed char и unsigned char. В реальности для работы с символами применяется тип char. Сразу может возникнуть вопрос: этот тип знаковый или беззнаковый? Данный момент не определяется стандартом и оставлен на усмотрение разработчиков компиляторов и зависит от конкретной реализации. Однако, как правило, тип char определяется как тип со знаком и соответственно имеет диапазон значений от -128 до 127. (В частности, так определено в стандарте System V ABI, который определяет общие правила для Unix-систем (в том числе и Linux))</p>
  <p>В качестве значений для даного типа применяются символьные литералы - символы в одинарных кавычках. Например, мы можем присвоить переменной этого типа символ в одинарных кавычках:</p>
  <code>char letter = 'A';</code>
  <p>Здесь определяется переменная letter, которая хранит символ 'A'. Однако в реальности переменная типа char хранит число. И когда переменной присваивается символ, она получает числовой код этого символа из таблицы, которая сопоставляет числовые коды и символы. Наиболее распространена таблица ASCII. Она сопоставляет символы с числами от 0 до 127. Например, возьмем выше определенную переменную letter и выведем ее содержимое на консоль:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char letter = 'A';
  printf("letter: %d \n", letter);    // letter: 65
  printf("letter: %c \n", letter);    // letter: A
  return 0;
}
</pre>
  <p>Числовой код символа 'A' в таблице ASCII равен 65. Для наглядности в программе два раза выводим значение переменной letter. Но в первом случае используем спецификатор %d для вывода числового кода символа, а во втором случае применяется спецификатор %c, который позволяет вывести на консоль сам символ. То есть при выполнении программа выведет на консоль:</p>
<pre>
letter: 65
letter: A
</pre>
  <p>Вместо символа в одинарных кавычках мы могли бы присвоить напрямую числовой код:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char letter = 65;
  printf("letter: %d \n", letter);    // letter: 65
  printf("letter: %c \n", letter);    // letter: A
  return 0;
}
</pre>
  <p>И мы получили бы тот же самый результат.</p>
  <p>Стоит отметить, что символы в одинарных кавычках - это данные типа int.</p>

  <h4>typedef</h4>

  <p>Оператор typedef позволяет определить для определенного типа псевдоним. Это может потребоваться, например, когда название некоторого типа довольно большое, и мы хотим его сократить.</p>
  <p>Общая форма оператора</p>
  <code>typedef существующий_тип псевдоним</code>
  <p>Например, зададим для типа unsigned char псевдоним BYTE:</p>
  <code>typedef unsigned char BYTE;</code>
  <p>И мы сможем использовать этот тип как и любой другой:</p>
<pre>
#include &lt;stdio.h&gt;

typedef unsigned char BYTE;

int main() {
  BYTE byte = 22;
  printf("byte = %d", byte);
}
</pre>

  <h4>Размер типов данных</h4>

  <p>В выше приведенном списке для каждого типа указан размер, который он занимает в памяти. Однако стоит отметить, что предельные размеры для типов разработчики компиляторов могут выбирать самостоятельно, исходя из аппаратных возможностей компьютера. Стандарт устанавливает лишь минимальные значения, которые должны быть. Например, для типов int и short минимальное значение - 16 бит, для типа long - 32 бита. При этом размер типа long должен быть не меньше размера типа int, а размер типа int - не меньше размера типа short. Но в целом для типов используются те размеры, которые указаны выше при описании типов данных.</p>
  <p>Однако бывают ситуации, когда необходимо точно знать размер определенного типа. И для этого в C есть оператор sizeof, который возвращает размер памяти в байтах, которую занимает выражение или тип.</p>
  <p>Чтобы получить размер типа данных этот тип помещается в скобки после sizeof:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  printf("sizeof(int): %lu\n", sizeof(int));
  printf("sizeof(long): %lu\n", sizeof(long));
  printf("sizeof(unsigned long long): %lu\n", sizeof(unsigned long long));
  return 0;
}
</pre>
  <p>В данном случае мы получаем размер для 3 типов. Так, на 64-рязрядном Linux мы получим следующий консольный вывод:</p>
<pre>
sizeof(int): 4
sizeof(long): 8
sizeof(unsigned long long): 8
</pre>
  <p>Оператор sizeof возвращает размер типа в виде значения size_t. Тип size_t фактически не является самостоятельным типом, а представляет псевдоним. Так, на 64-битном Linux size_t является псевдонимом для unsigned long. На других системах для size_t может применяться другой тип. Поэтому для работы с размерами лучше использовать псевдоним size_t, а не конкретный тип(например, unsigned long). Соответственно для вывода этого значения на консоль в функции printf применяется спецификатор %lu (long unsigned). И мы могли бы даже присвоить результат оператора другой переменной:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  size_t int_size = sizeof(int);
  printf("sizeof(int): %lu\n", int_size);
  return 0;
}
</pre>
  <p>Также sizeof может вычислять размер какого-нибудь объекта, например, переменной. Вэтом случае название объекта передается в скобки, либо может идти после оператора без скобок:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int number = 2;
  printf("sizeof(number): %lu\n", sizeof(number));
  printf("sizeof number: %lu\n", sizeof number);
  return 0;
}
</pre>
  <p>Консольный вывод:</p>
<pre>
sizeof(number): 4
sizeof number: 4
</pre>
  <p>Консоль нам показывает, что размер переменной number - 4 байта. Ведь тип переменной number - int, соответственно переменная имеет такой же размер.</p>
  <p>Кроме того, оператор sizeof может возвращать размер результата выражения. Например:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  size_t size = sizeof printf("hello METANIT.COM");
  printf("sizeof printf('hello METANIT.COM'): %lu\n", size);
  return 0;
}
</pre>
  <p>Здесь переменной size присваивается результат выражения sizeof printf("hello METANIT.COM"). Может показаться, что здесь оператор sizeof вычисляет размер выражения printf("hello METANIT.COM"). В реальности же в данном сдучае sizeof вычисляет размер результата выражения printf("hello METANIT.COM") или, если быть точным, результата функции printf(). Результат данной функции представляет тип int. Поэтому переменная size здесь равна 4. При этом, обращаю внимание, само выражение printf("hello METANIT.COM") не выполняется.</p>
  <p>Другой пример:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  size_t size = sizeof sizeof(int);
  printf("sizeof sizeof(int): %lu\n", size);
  return 0;
}
</pre>
  <p>Здесь оператор sizeof возвращает размер результата другого оператора sizeof.</p>
  <code>sizeof sizeof(int): 8</code>
</article>


<!-- 2.4 Консольный вывод. Функция printf -->
<article class="article">
  <div class="anchor" id="p2.4"></div>
  <h3>2.4 Консольный вывод. Функция printf</h3>

  <p>Для вывода на консоль в языке программирования Си зачастую применяется функция printf(). Но если с выводом простой строки особых проблем не возникает, то при выводе данных других типов есть свои особенности.</p>
  <p>Формальное определение функции printf выглядит следующим образом:</p>
  <code>printf(строка_форматирования, список_аргументов)</code>
  <p>Первый параметр представляет строку, которая может содержать произвольный текст в двойных кавычках. Например:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
    printf("Hello world!");
    return 0;
}
</pre>
  <p>Кроме стандартного текста мы можем передавать в строку специальные группы символов, которые называются управляющими последовательностями. Например</p>
  <code>\n: перевод на новую строку</code>

  <h4>Спецификации преобразования</h4>

  <p>Спецификации преобразования позволяют задать формат вывода различных типов данных. Формальное определение спецификаций преобразования выглядит следующим образом:</p>
  <code>% флаги ширина_поля.точность модификатор спецификатор</code>
  <p>Из этих компонентов обязательными являются только два % и спецификатор.</p>
  <p>Какие спецификаторы мы можем использовать:</p>
  <ul>
    <li>%c: для вывода отдельных символов (тип char)</li>
    <li>%s: для вывода строк</li>
    <li>%d: для вывода целых чисел со знаком (тип int)</li>
    <li>%i: для вывода целых чисел со знаком (тип int)</li>
    <li>%u: для вывода целых положительных чисел (тип unsigned)</li>
    <li>%f: для вывода чисел с плавающей точкой (float, double)</li>
    <li>%F: для вывода чисел с плавающей точкой в верхнем регистре (float, double)</li>
    <li>%e: для вывода экспоненциального представления чисел с плавающей точкой (float, double)</li>
    <li>%E: для вывода экспоненциального представления чисел с плавающей точкой в верхнем регистре (float, double)</li>
    <li>%g: для вывода чисел используется более короткий из форматов %e или %f</li>
    <li>%G: для вывода чисел используется более короткий из форматов %E или %F</li>
    <li>%o: для вывода восьмеричных чисел без знака</li>
    <li>%x: для вывода шестнадцатеричных чисел</li>
    <li>%X: для вывода шестнадцатеричных чисел в верхнем регистре</li>
    <li>%%: для вывода знака процента</li>
  </ul>
  <p>Применим несколько спецификаторов:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  float r = 71.8986;
  printf("x = %f \n", r);
  printf("x = %e \n", r);

  char symbol = 'r';
  printf("symbol = %c \n", symbol);

  unsigned int number = 23;
  printf("number = %u \n", number);

  printf("%s \n", "Hello Word 2013");
  return 0;
}
</pre>
  <p>Значения для спецификаторов передаются через аргумент, который идет вторым параметром в функции printf.</p>
  <p>Консольный вывод:</p>
<pre>
x = 71.898598
x = 7.189860e+001
symbol = r
number = 23
Hello Word 2013
</pre>
  <p>Для вывода числовых значений с плавающей точкой мы можем использовать ширину поля и точность. Ширина поля представляет целое положительное число, которое определяет длину выводимого значения в символах. Точность - это также целое положительное число, которое определяет количество цифр в дробной части. Например:</p>
<pre>
float r = 71.8986;
printf("x = %4.2f \n", r);  // 71.90
</pre>
  <p>Здесь спецификация преобразования представляет строку "%4.2f", где "4" - ширина поля (для вывода числа будут использоваться 4 цифры), а "2" - точность (2 цифры в дробной части).</p>
  <p>Модификаторы позволяют конкретизировать выводимое значение. Используются следующие модификаторы:</p>
  <ul>
    <li>h: для вывода значений short int</li>
    <li>l: для вывода значений long int и unsigned long int</li>
    <li>ll: для вывода значений long long int и unsigned long long int</li>
    <li>L: для вывода значений long double</li>
  </ul>
<pre>
short r = 7100;
printf("x = %hd", r);
</pre>
  <p>Необязательно передавать по одному значению для вывода в функцию printf. Мы можем передавать множество значений:</p>
  <code>printf("Name=%s \t Age=%d \t Weight=%3.2f", "Tom", 23, 63.3456);</code>
  <p>Первый спецификатор в строке форматирования - "%s", и для него значение будет поставляться первым аргументом - строкой "Tom". Второй спецификатор - "%d", для него значение берется из второго аргумента - числа 23. И так далее.</p>
  <p>Дополнительно можно использовать флаги, которые дополнительно позволяют управлять форматированием вывода:</p>
  <ul>
    <li>-: указывает, что выравнивание будет идти от левого края (по умолчанию используется выравнивае справа).</li>
    <li>+: если выводимое значение имеет знак (+ или -), то оно выводится. Без данного флага знак выводится только в случае отрицательного значения.</li>
    <li>пробел: вставляет пробел на месте знака перед положительными числами</li>
    <li>#: при использовании со спецификаторами "o", "x", "X" значение числа выводится с предшествующими символами 0, 0x или 0X. При использовании со спецификаторами "f", "g", "G" десятичная точка будет выводиться, даже если в числе нет дробной части</li>
  </ul>
  <p>Пример использования флагов:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  printf("%d \n", 8);
  printf("% d \n", 8);
  printf("%+d \n", +8);
  printf("%#o \n", 8);
  printf("%#f \n", 8.);

  printf("%9s %d \n", "Tom", 38);
  printf("%-9s %d \n", "Tom", 38);

  return 0;
}
</pre>
  <p>Консольный вывод:</p>
<pre>
8
 8
+8
010
8.000000

      Tom 38
Tom       38
</pre>
</article>


<!-- 2.5 Константы -->
<article class="article">
  <div class="anchor" id="p2.5"></div>
  <h3>2.5 Константы</h3>

  <p>Отличительным признаком переменных является то, что мы многократно в течение работы программы можем изменять ее значение:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int number = 2;
  printf("number = %d \n", number);
  number = 55;
  printf("number = %d \n", number);
  number = -23;
  printf("number = %d \n", number);
  return 0;
}
</pre>
  <p>Здесь переменная number последовательно меняет свое значение</p>
  <p>В отличие от переменных значение констант устанавливается один раз при их объявлении. Для определения константы используется ключевое слово const:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  const int number = 2;
  printf("number = %d \n", number);
  // number = 55;  эта строка работать не будет, так как number - это константа
  return 0;
}
</pre>
  <p>Если в коде будет содержаться изменение константы, то компилятор не сможет скомпилировать подобную программу.</p>
  <p>Как правило, в виде констант определяются такие значение, которые должны оставаться постоянными в течение работы всей программы и не могут быть изменены. Например, если программы выполняет математические операции с использованием числа PI, то было бы оптимально определить данные значение как константу, так как оно все равно в принципе неизменно:</p>
  <code>const float PI = 3.14;</code>
</article>


<!-- 2.6 Арифметические операции -->
<article class="article">
  <div class="anchor" id="p2.6"></div>
  <h3>2.6 Арифметические операции</h3>

  <p>Язык программирования Си поддерживает все основные арифметические операции. Эти операции производятся над числами. Значения, которые участвуют в операции, называются операндами. Список имеющихся в Си операций:</p>
  <ol>
    <li>
      + Операция сложения возвращает сумму двух чисел:
<pre>
#include &lt;stdio.h&gt;

int main() {
  int a = 67;
  int b = 33;
  int c = a + b + 7;
  printf("a + b + 7 = %d \n", c);     // 107
  return 0;
}
</pre>
    </li>
    <li>
      - Операция вычитания возвращает разность двух чисел:
<pre>
#include &lt;stdio.h&gt;

int main() {
  int a = 67;
  int b = 33;
  int c = a - b;
  printf("a - b = %d \n", c);     // 34
  return 0;
}
</pre>
    </li>
    <li>
      * Операция умножения возвращает произведение двух чисел:
      <code>int c = 15 * 3;     // 45</code>
    </li>
    <li>
      / Операция деления двух чисел:
<pre>
#include &lt;stdio.h&gt;

int main() {
  int a = 15 / 3;         // 5
  float d = 34.0 / 3.0;   // 11.333333

  printf("a=%d \n", a);
  printf("d=%f \n", d);
  return 0;
}
</pre>
      <p>При делении стоит быть внимательным, так как если в операции участвуют два целых числа, то результат деления будет округляться до целого числа, даже если результат присваивается переменной float:</p>
<pre>
float f = 10 / 4;
printf("f = %f \n", f);     // 2.0
</pre>
      <p>Чтобы результат представлял вещественное число, один из операндов также должен представлять вещественное число:</p>
<pre>
float f = 10.0 / 4;
printf("f = %f \n", f);     // 2.5
</pre>
    </li>
    <li>
      % Возвращает результат деления двух чисел по модулю (получение остатка от деления):
      <code>int a = 35 % 3;         // 2 (35 - 33 = 2)</code>
    </li>
  </ol>
  <p>Операции *, /, % имеют больший приоритет, чем + и - :</p>
<pre>
int a = 8;
int b = 7;
int c = a + 5 * b;      // 43
printf("c = %d \n", c); // 43
</pre>
  <p>Здесь результатом будет число 43: 5 * b = 35, a + 35 = 43</p>
  <p>С помощью скобок мы можем переопределить порядок операций, сделав, чтобы операции с более низким приоритетом выполнялись до операций с более высоким приоритетом:</p>
<pre>
int a = 8;
int b = 7;
int c = (a + 5) * b;    // 91
</pre>
  <p>Здесь результатом будет число 91: a + 5 = 13, 13 * b = 91</p>
  <p>Также в Си есть специальные унарные операции над одним числом: ++ (инкремент) и -- (декремент). Каждая из операций имеет две разновидности: префиксная и постфиксная.</p>
  <ol>
    <li>
      Префиксный инкремент (++x). Увеличивает значение переменной на единицу и полученное значение используется как значение выражения ++x
<pre>
int a = 8;
int b = ++a;
printf("a = %d \n", a); // 9
printf("b = %d", b);    // 9
</pre>
    </li>
    <li>
      Постфиксный инкремент (x++). Увеличивает значение переменной на единицу, но значением выражения x++ будет то, которое было до увеличения на единицу:
<pre>
int a = 8;
int b = a++;
printf("a = %d \n", a); // 9
printf("b = %d", b);    // 8
</pre>
    </li>
    <li>
      Префиксный декремент (--x). Уменьшает значение переменной на единицу, и полученное значение используется как значение выражения --x
<pre>
int a = 8;
int b = --a;
printf("a = %d \n", a); // 7
printf("b = %d", b);    // 7
</pre>
    </li>
    <li>
      Постфиксный декремент (x--). Уменьшает значение переменной на единицу, но значением выражения x-- будет то, которое было до уменьшения на единицу:
<pre>
int a = 8;
int b = a--;
printf("a = %d \n", a); // 7
printf("b = %d", b);    // 8
</pre>
    </li>
  </ol>
  <p>Рассмотрим более сложную ситуацию:</p>
<pre>
int a = 8;
int b = 7;
int c = a+++b;
printf("a = %d \n", a); // 9
printf("b = %d \n", b); // 7
printf("c = %d \n", c); // 15
</pre>
  <p>Здесь операция трактуются таким образом, что вначале идет постфиксный инкремент, а потом сложение. То есть фактически так:</p>
  <code>int c = (a++) + b;</code>
  <p>Аналогично будет расцениваться выражения с постфиксным декрементом: </p>
  <code>int c = a---b;</code>
</article>


<!-- 2.7 Условные операции -->
<article class="article">
  <div class="anchor" id="p2.7"></div>
  <h3>2.7 Условные операции</h3>

  <h4>Логические операции и операции отношения</h4>

  <p>Условные операции позволяют проверить истинность некоторого условия и оперируют понятиями "истина"/"верно" и "ложь"/"неверно". Причем "истина" (условие верно) соответствует значению 1, а "ложь" (условие не верно) - значению 0. К условным операциям относят операции сравнения и логические операции. Оба этих вида операций применяются к арифметическим операндам, то есть числам.</p>

  <h4>Операции сравнения</h4>

  <p>Операции сравнения (еще называют операциями отношения) позволяют сравнить два значения и возвращают 1, если выражение истинно, и 0, если выражение ложно. В языке Си есть следующие операции сравнения:</p>
  <ol>
    <li>
      == Операция "равно". Возвращает 1, если оба операнда равны, и 0, если они не равны:
<pre>
#include &lt;stdio.h&gt;

int main() {
  int a = 10;
  int b = 4;
  int c = a == b;                 // 0 - числа НЕ равны
  printf("c = %d \n", c);         // c = 0

  int num = 5;
  int result = num == 2 + 3;      // 1 - числа равны
  printf("result = %d \n", result);     // result = 1
  return 0;
}
</pre>
      <p>В первом случае переменная c хранит результат выражения a == b. Так как a и b не равны, то это выражение возвратит 0. Поэтому переменная c будет равна 0.</p>
      <p>Во втором случае переменная result хранит результат выражения num == 2 + 3;, где в качестве второго операнда выступает результат операции 2 + 3. Так как переменная num равна 5, то это выражение возвратит 1. Поэтому переменная result будет равна 1.</p>
    </li>
    <li>
      != Операция "не равно". Возвращает 1, если первый операнд не равен второму, и 0, если оба операнда равны:
<pre>
int c = 10 != 4;    // 1
int d = 4 != 4;     // 0
</pre>
    </li>
    <li>
      &gt; Операция "больше чем". Возвращает 1, если первый операнд больше второго, и 0, если первый операнд меньше или равен второму:
<pre>
int a = 10;
int b = 4;
int c = a > b;   // 1
</pre>
    </li>
    <li>
      &lt; Операция "меньше чем". Возвращает 1, если первый операнд меньше второго, и 0, если первый операнд больше или равен второму:
      <code>int c = 10 &lt; 4;  // 0</code>
    </li>
    <li>
      &lt;= Операция "меньше или равно". Возвращает 1, если первый операнд меньше или равен второму, и 0, если первый операнд больше второго:
      <code>int c = 10 &lt;= 4; // 0</code>
    </li>
    <li>
      &gt;= Операция "больше или равно". Возвращает 1, если первый операнд больше или равен второму, и 0, если первый операнд меньше второго:
      <code>int c = 10 >= 4; // 1</code>
    </li>
  </ol>
  <p>Как правило, операции отношения применяются в условных конструкциях типа if...else, которые мы далее рассмотрим.</p>

  <h4>Логические операции</h4>

  <p>Логические операции, как правило, применяются к отношениям и объединяют несколько операций отношения. К логическим операциям относят следующие:</p>
  <ol>
    <li>
      ! (операция отрицания) Если операнд равен 0, то возвращает 1, иначе возвращает 0.
<pre>
int c = !2; // 0
int d = !0; // 1
</pre>
    </li>
    <li>
      && (конъюнкция, логическое умножение) Возвращает 1, если оба операнда не равны 0. Возвращает 0, если хотя бы один операнд равен 0.
<pre>
int c = -2 && 5;    // 1
int d = 0 && 7;     // 0
</pre>
    </li>
    <li>
      || (дизъюнкция, логическое сложение) Возвращает 1, если хотя бы один операнд не равен 0. Возвращает 0, если оба операнда равны 0.
<pre>
int c = -2 || 5;    // 1
int d = 0 || 7;     // 1
int e = 0 || 0;     // 0
</pre>
    </li>
  </ol>
  <p>Используем одновременно несколько логических операций и операций сравнения:</p>
<pre>
int a = -2 > 5;          // 0
int b = 0 &lt; 7;           // 1
int c = 0 == 0;          // 1
int d = a && b || c;        // 1

printf("a = %d \n", a);
printf("b = %d \n", b);
printf("c = %d \n", c);
printf("d = %d \n", d);
</pre>
  <p>Операции сравнения имеют больший приоритет, чем логические операции, поэтому мы могли бы напрямую подставить операции сравнения:</p>
  <code>int d = -2 > 5 && 0 &lt; 7 || 0 == 0; // 1</code>
</article>


<!-- 2.8 Поразрядные операции -->
<article class="article">
  <div class="anchor" id="p2.8"></div>
  <h3>2.8 Поразрядные операции</h3>

  <h4>Операции сдвига</h4>

  <p>Каждое целое число в памяти представлено в виде определенного количества разрядов. И операции сдвига позволяют сдвинуть битовое представление числа на несколько разрядов вправо или влево. Операции сдвига применяются только к целочисленным операндам. Есть две операции:</p>
  <ol>
    <li>&lt;&lt; Сдвигает битовое представление числа, представленного первым операндом, влево на определенное количество разрядов, которое задается вторым операндом.</li>
    <li>&gt;&gt; Сдвигает битовое представление числа вправо на определенное количество разрядов.</li>
  </ol>
  <p>Применение операций:</p>
  <code>int a = 2 &lt;&lt; 2; // 2 = 0010 -> 1000 = 8</code>
  <code>int b = 16 >> 3; // 16 = 10000 -> 10 = 2</code>
  <p>Число 2 в двоичном представлении 10. Если сдвинуть число 10 на два разряда влево, то получится 1000, что в десятичной системе равно число 8.</p>
  <p>Число 16 в двоичном представлении 10000. Если сдвинуть число 10 на три разряда вправо (три последних разряда отбрасываются), то получится 10, что в десятичной системе представляет число 2.</p>

  <h4>Поразрядные операции</h4>

  <p>Поразрядные операции также проводятся только над разрядами целочисленных операндов:</p>
  <ol>
    <li>&: поразрядная конъюнкция (операция И или поразрядное умножение). Возвращает 1, если оба из соответствующих разрядов обоих чисел равны 1</li>
    <li>|: поразрядная дизъюнкция (операция ИЛИ или поразрядное сложение). Возвращает 1, если хотя бы один из соответствующих разрядов обоих чисел равен 1</li>
    <li>^: поразрядное исключающее ИЛИ. Возвращает 1, если только один из соответствующих разрядов обоих чисел равен 1</li>
    <li>~: поразрядное отрицание. Инвертирует все разряды операнда. Если разряд равен 1, то он становится равен 0, а если он равен 0, то он получает значение 1.</li>
  </ol>
  <p>Применение операций:</p>
<pre>
int a = 5 | 2;          // 101 | 010 = 111  - 7
int b = 6 & 2;          // 110 & 010 = 10  - 2
int c = 5 ^ 2;          // 101 ^ 010 = 111 - 7

int f = 12;              // 00001100
int d = ~f;         // 11110011   или -13

printf("a = %d \n", a);
printf("b = %d \n", b);
printf("c = %d \n", c);
printf("d = %d \n", d);
</pre>
  <p>Например, выражение 5 | 2 равно 7. Число 5 в двоичной записи равно 101, а число 2 - 10 или 010. Сложим соответствующие разряды обоих чисел. При сложении если хотя бы один разряд равен 1, то сумма обоих разрядов равна 1. Поэтому получаем:</p>
<pre>
1	0	1
0	1	0
1	1	1
</pre>
  <p>В итоге получаем число 111, что в десятичной записи представляет число 7.</p>
  <p>Возьмем другое выражение 6 & 2. Число 6 в двоичной записи равно 110, а число 2 - 10 или 010. Умножим соответствующие разряды обоих чисел. Произведение обоих разрядов равно 1, если оба этих разряда равны 1. Иначе произведение равно 0. Поэтому получаем:</p>
<pre>
1	1	0
0	1	0
0	1	0
</pre>
  <p>Получаем число 010, что в десятичной системе равно 2.</p>
  <p>Теперь рассмотрим последний пример - инверсию числа.</p>

  <h4>Представление отрицательных чисел</h4>

  <p>Для записи чисел со знаком в Си применяется дополнительный код (two's complement), при котором старший разряд является знаковым. Если его значение равно 0, то число положительное, и его двоичное представление не отличается от представления беззнакового числа. Например, 0000 0001 в десятичной системе 1.</p>
  <p>Если старший разряд равен 1, то мы имеем дело с отрицательным числом. Например, 1111 1111 в десятичной системе представляет -1. Соответственно, 1111 0011 представляет -13.</p>
  <p>Чтобы получить из положительного числа отрицательное, его нужно инвертировать и прибавить единицу:</p>
<pre>
int x = 12;
int y = ~x;
y += 1;
printf("y = %d \n", y);   // y=-12
</pre>

  <h4>Примеры применения поразрядных операций</h4>

  <p>Поразрядные операции имеют довольно широкую сферу применения. Особенно это касается низкоуровнего программирования, криптографии и ряда других сфер. Рассмотрим простейшие примеры.</p>

  <h4>Проверка установки оперделенного бита</h4>

  <p>Например, нам надо проверить установлен ли определенный бит числа. В этом случае мы можем выполнить следующую программу:</p>
<pre>
#include &lt;stdio.h&gt;

int main(void)
{
  int num = 255; // 0b11111111;
  int bit = 5;
  int result = num & (1 &lt;&lt; bit);  // 0b00100000 или 32
  printf("result: %d\n", result);

  return 0;
}
</pre>
  <p>Переменная num представляет исходное число, где нам нало проверить установленный бит. Переменная bit указывает, какой имеено разрял надо проверить. В данном случае она равна 5, поэтому проверям, установлен ли 5-й бит (нумерация начинается с нуля) в числе num. Для этого применяется выражение:</p>
  <code>int result = num & (1 &lt;&lt; bit);</code>
  <p>Вначале мы сдвигаем 1 на определенное число разрядов: 1 &lt;&lt; bit. Так, если bit равно 5, то мы получим:</p>
  <code>1 &lt;&lt; bit = 1 >> 5 = 0b100000</code>
  <p>Нoвые разряды справа заполняются нулями, и таким образом мы получим число 0b100000 в двоичной или 32 в десятичной системе. Таким образом, мы получаем маску. Далее эту маску с помощью операции поразрядного умножения применяем к исходному числу:</p>
<pre>
int result = num & (1 &lt;&lt; bit) = num & 32 =
0b11111111
&
0b00100000
=
0b00100000
</pre>
  <p>Таким образом, если соответствующий разряд установлен, то в результате после выполнения выражения этот разряд будет имет 1. Если разряд в числе не установлен, то в результате он будет иметь 0, и сам результат будет равен 0.</p>
  <p>Другой пример:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int num2 = 128; // 0b10000000;
  int bit = 5;
  int result2 = num2 & (1 &lt;&lt; bit);  // 0b00000000 или 0
  printf("result2: %d\n", result2);

  return 0;
}
</pre>
  <p>Здесь также проверяем установку 5-го бита, но теперь в числе 128. В итоге получим:</p>
<pre>
int result2 = num2 & (1 &lt;&lt; bit) 128 & 32 =
0b10000000
&
0b00100000
=
0b00000000
</pre>
  <p>То есть результат будет равен 0, а значит, 5-1 бит не установлен.</p>

  <h4>Сброс бита</h4>

  <p>Для сброса бита применяем операцию поразрядного умножения & к маске, где все разряды кроме сбрасываемого бита равны 1:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int num = 255; // 0b11111111;
  int bit = 0; // сбрасываем 0-й бит
  int result = num & ~(1 &lt;&lt; bit);  // 0b11111110 или 254
  printf("result1: %d\n", result);

  return 0;
}
</pre>
  <p>Здесь сбрасываем начальный (условно нулевой бит) в числе num. Для этого применяется следующий код:</p>
  <code>int result = num & ~(1 &lt;&lt; bit);</code>
  <p>Фактически у нас здесь 3 операции:</p>
  <ol>
    <li>
      Сдвигаем число 1 на bit разрядов влево:
      <code>1 &lt;&lt; bit</code>
      <p>Поскольку bit равно 0, то фактически сдвига не происходит и мы получим число 1.</p>
    </li>
    <li>
      Затем инвертируем все разряды предыдущего результата:
      <code>~(1 &lt;&lt; bit)</code>
      <p>Поскольку результат предыдущей операции равен 1 или 0b000000001 (формально результат - число типа int и занимает 32 разряда, но для краткости я опустил старшие разряды, которые также равны 0), то после инверсии мы получим 0b11111110.</p>
    </li>
    <li>
      И последняя операция применяет полученную на предыдущем этапе маску:
      <code>num & ~(1 &lt;&lt; bit)</code>
      <p>То есть мы получаем следующее выражение:</p>
<pre>
num & ~(1 &lt;&lt; bit) = num & 0b11111110 =
0b11111111
&
0b11111110
=
0b11111110
</pre>
      <p>Итоговый результат - 0b11111110 или число 254 в десятичной системе.</p>
    </li>
  </ol>

  <h4>Установка бита</h4>

  <p>Для установки определенного бита применяется операция поразрядного сложения с маской, где установлен нужный разряд. Например:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int num = 128; // 0b10000000;
  int bit = 1; // устанавливаем 1-й бит
  int result = num | (1 &lt;&lt; bit);  // 0b10000010 или 130
  printf("result: %d\n", result);

  return 0;
}
</pre>
  <p>Здесь устанавливаем 1-й бит (второй с начала) в числе num. Для формирования маски применяем выражение (1 &lt;&lt; bit), которое равно 0b00000010 (2 в десятичной системе). Затем поразрядно складываем эту маску с числом num и получаем число 0b10000010 или 130 в десятичной системе.</p>
</article>


<!-- 2.9 Операции присваивания -->
<article class="article">
  <div class="anchor" id="p2.9"></div>
  <h3>2.9 Операции присваивания</h3>

  <p>Отдельную группу операций в языке программирования Си составляют операции присваивания. Она производится над двумя операндами. Причем левый операнд может представлять только модифицируемое именованное выражение, например, переменную.</p>
  <p>Существует базовая операция присваивания =, которая позволяет присвоить значение правого операнда левому операнду:</p>
  <code>int x = 2 + 5</code>
  <p>Выражение 2 + 5 представляет правый операнд, и его значение присваивается левому операнду.</p>
  <p>Стоит отметить, что тип значения правого операнда не всегда может совпадать с типом левого операнда. В этом случае компилятор пытается преобразовать значение правого операнда к типу левого операнда.</p>
  <p>Также можно выполнять множественное присваивание:</p>
<pre>
int a, b, c;
a = b = c = 34 +7;
</pre>
  <p>Здесь сначала вычисляется значение выражения c = 34 +7. Значение правого операнда - 34 +7 присваивается левому операнду с. То есть переменная c получает значение 41. Далее вычисляется выражение b = c: значение правого операнда c (41) присваивается левому операнду b. И в конце вычисляется выражение a = b: значение правого операнда b (41) присваивается левому операнду a.</p>
  <p>Все остальные операции присваивания являются сочетанием простой операции присваивания с другими операциями:</p>
  <ul>
    <li>+=: присваивание после сложения. Присваивает левому операнду сумму левого и правого операндов: A += B эквивалентно A = A + B</li>
    <li>-=: присваивание после вычитания. Присваивает левому операнду разность левого и правого операндов: A -= B эквивалентно A = A - B</li>
    <li>*=: присваивание после умножения. Присваивает левому операнду произведение левого и правого операндов: A *= B эквивалентно A = A * B</li>
    <li>/=: присваивание после деления. Присваивает левому операнду частное левого и правого операндов: A /= B эквивалентно A = A / B</li>
    <li>%=: присваивание после деления по модулю. Присваивает левому операнду остаток от целочисленного деления левого операнда на правый: A %= B эквивалентно A = A % B</li>
    <li>&lt;&lt;=: присваивание после сдвига разрядов влево. Присваивает левому операнду результат сдвига его битового представления влево на определенное количество разрядов, равное значению правого операнда: A &lt;&lt;= B эквивалентно A = A &lt;&lt; B</li>
    <li>>>=: присваивание после сдвига разрядов вправо. Присваивает левому операнду результат сдвига его битового представления вправо на определенное количество разрядов, равное значению правого операнда: A >>= B эквивалентно A = A >> B</li>
    <li>&=: присваивание после поразрядной конъюнкции. Присваивает левому операнду результат поразрядной конъюнкции его битового представления с битовым представлением правого операнда: A &= B эквивалентно A = A & B</li>
    <li>|=: присваивание после поразрядной дизъюнкции. Присваивает левому операнду результат поразрядной дизъюнкции его битового представления с битовым представлением правого операнда: A |= B эквивалентно A = A | B</li>
    <li>^=: присваивание после операции исключающего ИЛИ. Присваивает левому операнду результат операции исключающего ИЛИ его битового представления с битовым представлением правого операнда: A ^= B эквивалентно A = A ^ B</li>
  </ul>
  <p>Примеры операций:</p>
<pre>
int a = 5;
a += 10;        // 15
a -= 3;         // 12
a *= 2;         // 24
a /= 6;         // 4
a &lt;&lt;= 4;      // 64
a >>= 2;      // 16
</pre>
</article>


<!-- 2.10 Преобразование типов -->
<article class="article">
  <div class="anchor" id="p2.10"></div>
  <h3>2.10 Преобразование типов</h3>

  <p>Если в арифметических операциях участвуют значения разных типов, то компилятор неявно пытается привести их к одному типу. Кроме того, когда мы присваиваем переменной какое-либо значение, это значение всегда приводится к типу переменной. Например:</p>
<pre>
char c = 6;
int d = c;
</pre>
  <p>Переменной d, которая представляет тип int, присваивается значение типа char, поэтому компилятор выполняет приведение значения от типа char к типу int.</p>
  <p>В то же время не всегда преобразования могут быть безопасными, поскольку разные типы имеют разное внутреннее представление. И просто так перейти от одного представления к другому без потери точности данных не всегда возможно.</p>
  <p>Рассмотрим, какие преобразования применяет компилятор при арифметических операциях:</p>
  <ol>
    <li>Если один из операндов имеет тип long double, то второй операнд тоже будет преобразован в тип long double</li>
    <li>Если один из операндов имеет тип double, то второй операнд тоже будет преобразован к типу double</li>
    <li>Если один из операндов имеет тип float, то второй операнд тоже будет преобразован к типу float</li>
    <li>Если один из операндов имеет тип unsigned long int, то второй операнд тоже будет преобразован к типу unsigned long int</li>
    <li>Если один из операндов имеет тип long, то второй операнд тоже будет преобразован к типу long</li>
    <li>Если один из операндов имеет тип unsigned, то второй операнд тоже будет преобразован к типу unsigned</li>
    <li>Если предыдущий пункт не выполняется то оба операнда приводятся к типу int</li>
  </ol>
  <p>Например:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int number1 = 10;
  double number2 = 4;
  double result = number1 + number2;   // 14.000000
  printf("result = %f \n", result);     // result = 14.000000
  return 0;
}
</pre>
  <p>В выражении number1 + number2 число number2 представляет тип double, поэтому число number1 будет автоматически приводиться к числу double. И результат операции сложения также будет представлять тип double.</p>

  <h4>Операция преобразования</h4>

  <p>С помощью специальной операции преобразования мы можем явным образом привести данные к нужному типу. Например:</p>
<pre>
int a = 10;
int b = 4;
int c = a / b;                  // 2
double d = a / b;               // 2.00000
double e = (double)a / (double)b;   // 2.50000
printf("c = %d \n", c);
printf("d = %f \n", d);
printf("e = %f \n", e);
</pre>
  <p>В выражении int c = a / b; результат деления будет целочисленный - 2, при котором дробная часть будет отброшена, так как оба операнда операции представляют целые числа.</p>
  <p>В выражении double d = a / b; результат деления будет представлять вещественное число - 2.00000, но так как оба операнда являются целыми числами, то опять же результат операции будет представлять целое число 2, и только поле выполнения деления произойдет присвоение результата переменной d с приведением значения 2 от типа int к типу double.</p>
  <p>В выражении double e = (double)a / (double)b применяется явное преобразование данных к типу double, поэтому и результат деления будет представлять вещественное число - 2.50000.</p>
  <p>Для выполнения операции приведении в скобках указывается тот тип, к которому надо привести значение:</p>
<pre>
int number = 70;
char symbol = (char) number;
printf("symbol = %c \n", symbol);           //  F
printf("symbol (int code) = %d \n", symbol);    // 70
</pre>
  <p>В ряде случаев преобразования сопровождаются потерей информации, например, когда из числа большей разрядности (скажем размером 4 байт) получаем число меньшей разрядности (например, в 2 байта). Без потери информации проходят следующие цепочки преобразований:</p>
  <code>char -> short -> int -> long</code>
  <code>unsigned char -> unsigned short -> unsigned int -> unsigned long</code>
  <code>float -> double -> long double</code>
  <p>При всех остальных преобразованиях, которые не входят в эти цепочки, мы можем столкнуться с потерей точности данных. Так, в примере выше преобразование от int к char не является безопасным, поэтому к таким преобразованиям следует относиться с осторожностью. Например:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int number1 = 300;
  // потеря точности - число number1 усекается до 1 байта
  char code = number1;
  printf("code = %d \n", code);     // code = 44

  // потеря точности - число 100000 усекается до 2 байт
  short number2 = 100000;
  printf("number2 = %d \n", number2);     // number2 = -31072

  return 0;
}
</pre>
  <p>Здесь две ситуации небезопасных преобразований. В первом случае число типа int, которое равно 300, присваивается переменной типа char. В итоге переменная code будет равна 44. Почему? Число 300 в двоичной системе:</p>
  <code>0000000100101100</code>
  <p>Оставляем только первый младший байт:</p>
  <code>00101100</code>
  <p>И у нас получается число 44 в десятичной системе.</p>
  <p>Во втором случае число 100000 (которое по умолчанию представляет тип int), усекается до разрядности типа short - до двух байт.</p>
  <code>short number = 100000;</code>
  <p>В итоге число number в реальности будет равно -31072.</p>
</article>


<!-- 2.11 Условные конструкции -->
<article class="article">
  <div class="anchor" id="p2.11"></div>
  <h3>2.11 Условные конструкции</h3>

  <p>Условные конструкции позволяют направить ход программы по одному из возможных путей в зависимости от условия. В языке Си есть несколько операторов, которые позволяют это сделать.</p>

  <h4>Оператор if</h4>

  <p>Оператор if проверяет истинность условия, и если оно истинно, выполняет блок инструкций. Этот оператор имеет следующую сокращенную форму:</p>
  <code>if (условие) инструкция;</code>
  <p>В качестве условия может выступать любое выражение, которое возвращает число. Если это выражение возвращает ненулевое значение (то есть выражение истинно), то выполняется последующая инструкция:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  if(1) printf("Hello C \n");

  if(0) printf("Hello World \n");

  return 0;
}
</pre>
  <p>Здесь у нас две условных конструкции if. В качестве инструкции в обоих случаях выполняется функция printf. И в обоих случаях условие представляет просто число. В первом случае "условие" равно 1, то есть "истинно" (любое число, кроме 0, представляет истину). Поэтому на консоль будет выполняться функция printf, которая выведет на консоль строку "Hello C".</p>
  <p>А во втором случае "условие" равно 0, то есть "не верно/ложно". Поэтому инструкция printf("Hello World \n") НЕ будет выполняться.</p>
  <p>В приведенном выше примере в качестве условий выступали числа 1 или 0. Однако в реальности в качестве условий выступает результат некоторых выражений, обычно, операций сравнения или логических операций. Однако все они в конечном счете возвращают либо 0 (условие не верно) или ненулевое значение (условие верно). Используем операции сравнения:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int n = 10;

  if(n == 20) printf("n = 20 \n");
  if(n == 10) printf("n = 10 \n");

  return 0;
}
</pre>
  <p>Здесь также используются две условных конструкции if. В первом случае n == 20 условие не верно, оно возвращает 0, так как значение переменной n не равно 20, поэтому поэтому последующая инструкция printf("n = 20 \n") не будет выполняться.</p>
  <p>А во втором случае операция сравнения n == 10 возвратит 1, так как условие истинно, поэтому будет выполняться инструкция printf("n = 10 \n").</p>
  <p>Если в конструкции if необходимо выполнить не одну, а несколько инструкций, то эти инструкции оформляются в блок кода с помощью фигурных скобок:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int x = 60;

  if(x > 50)
  {
    printf("if statement \n");
    printf("x is greater than 50 \n");
  }
  return 0;
}
</pre>
  <p>Здесь проверяем, больше ли переменная х чем 50. И если это условие истинно, выполняем последующий блок из двух инструкций</p>
  <p>Условия могут более сложные:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int x = 50;
  int y = 60;
  if (x > 20 && y &lt; 100)
  {
    printf("the condition is true\n");
  }
  return 0;
}
</pre>
  <p>Здесь проверяем больше ли значение переменной х чем 20 и меньше ли значение переменной y чем 100. Поскольку здесь два условия соединяются операцией &&, то общее условие будет истинно, если одновременно верны оба условия.</p>

  <h4>Выражение else</h4>

  <p>Но что, если мы хотим определить две пары действий: одни выполняются, если условие истинно, а другие, если условие ложно? В этом случае можно использовать другую форму конструкции if - if..else:</p>
<pre>
if(условие)
  инструкция_1
else
  инструкция_2
</pre>
  <p>После оператора else мы можем определить набор инструкций, которые выполняются, если выражение_условия ложно, то есть возвращает 0. То есть если условие истинно, выполнится инструкция после оператора if, а если это выражение ложно, то выполняется инструкция после оператора else.</p>
<pre>
int x = 60;
if(x > 60)
  printf("x is greater than 60 \n");
else
  printf("x is less or equal 60 \n");
</pre>
  <p>Однако в данном случае у нас есть три условия: переменная x может быть больше 60, меньше 60 и равна 60. Для проверки альтернативных условий мы можем вводить выражения else if:</p>
<pre>
int x = 60;

if(x > 60)
  printf("x is greater than 60 \n");
else if (x &lt; 60)
  printf("x is less than 60 \n");
else
  printf("x is equal 60 \n");
</pre>
  <p>То есть в данном случае мы получаем три ветки развития событий в программе.</p>
  <p>И также если после операторов должен идти набор инструкций, то эти инструкции оформляются в блок кода:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int x = 60;

  if(x > 60)
  {
    printf("if statement \n");
    printf("x is greater than 60 \n");
  }
  else if (x &lt; 60)
  {
    printf("else if statement \n");
    printf("x is less than 60 \n");
  }
  else
  {
    printf("else statement \n");
    printf("x is equal 60 \n");
  }
  return 0;
}
</pre>

  <h4>Конструкция switch</h4>

  <p>Другую форму организации ветвления программ представляет конструкция switch...case. Она имеет следующую форму:</p>
<pre>
switch(выражение)
{
  case константа_1: инструкции_1;
  case константа_2: инструкции_2;

  default: инструкции;
}
</pre>
  <p>После ключевого слова switch в скобках идет сравниваемое выражение. Значение этого выражения последовательно сравнивается со значениями после оператора сase. И если совпадение будет найдено, то будет выполняться данный блок сase.</p>
  <p>В качестве констант после оператора case могут выступать значения типов char, int и unsigned. Например, проверим с помощью конструкции switch значение некоторого числа:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int x = 2;

  switch(x)
  {
    case 1:
      printf("x = 1 \n");
      break;
    case 2:
      printf("x = 2 \n");
      break;
    case 3:
      printf("x = 3 \n");
      break;
  }
  return 0;
}
</pre>
  <p>Здесь в качестве сравниваемого выражения выступает переменная x. Ее значение последовательно сравнивается со значениями после операторов case:</p>
  <ol>
    <li>сначала программа переходит к выражению case 1. Но переменная x не равна 1, поэтому выполнение переходит к следующему оператору case.</li>
    <li>программа переходит к выражению case 2. Поскольку переменная x равна 2, то выполняются инструкции данного оператора case:</li>
  </ol>
  <p>Чтобы избежать выполнения последующих блоков case, в конце каждого блока ставится оператор break. При его выполнение происходит выход из конструкции switch..case</p>
  <p>В итоге мы получим следующий консольный вывод:</p>
  <code>x = 2</code>
  <p>При определении блоков case следует не забывать про добавление операторов break. Так, перепигем предыдущий пример без операторов break:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int x = 2;

  switch(x)
  {
    case 1:
      printf("x = 1 \n");
    case 2:
      printf("x = 2 \n");
    case 3:
      printf("x = 3 \n");
  }
  return 0;
}
</pre>
  <p>Так как x=2, то будет выполняться блок инструкций после выражения case 2. Но поскольку этот блок не завершается оператором break, поэтому будут выполняться все последующие блоки case, пока не встретится оператор break или конец конструкции switch. Консольный вывод:</p>
<pre>
x = 2
x = 3
</pre>
  <p>В конце конструкции switch может стоять блок default. Он необязателен и выполняется в том случае, если ни одного совпадения в блоках case не было найдено. Например, сравним значение переменной с набором значений:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int x = 5;

  switch(x)
  {
    case 1:
      printf("x = 1 \n");
      break;
    case 2:
        printf("x = 2 \n");
        break;
    case 3:
      printf("x = 3 \n");
      break;
    default:
      printf("x is undefined \n");
      break;
  }
  return 0;
}
</pre>
  <p>Поскольку здесь значение x не соответствует ни одному из значений после операторов case, то будет выполняться блок default. Консольный вывод:</p>
  <code>x is undefined</code>

  <h4>Тернарный оператор</h4>

  <p>Тернарный оператор ?: позволяет сократить определение простейших условных конструкций if и имеет следующую форму:</p>
  <code>[первый операнд - условие] ? [второй операнд] : [третий операнд]</code>
  <p>Оператор использует сразу три операнда. В зависимости от условия тернарный оператор возвращает второй или третий операнд: если условие равно 1 (то есть истинно), то возвращается второй операнд; если условие равно 0 (то есть ложно), то третий. Например:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int x=5;
  int y=2;

  int z = x > y ? x-y : x+y;

  printf("z = %d", z);    // z = 3
  return 0;
}
</pre>
  <p>Здесь результатом тернарной операции является переменная z. Она имеет следующие операнды:</p>
  <ul>
    <li>Условие x > y</li>
    <li>Действия, выполняемые, если условие истинно x - y</li>
    <li>Действия, выполняемые, если условие ложно x + y</li>
  </ul>
  <p>Поскольку в данном случае условие x &lt; y истинно (то есть x больше чем y), то будет выполняться вычитание x - y, и переменная z получит его результат - число 3.</p>
</article>


<!-- 2.12 Циклы -->
<article class="article">
  <div class="anchor" id="p2.12"></div>
  <h3>2.12 Циклы</h3>

  <p>Циклы позволяет выполнить одно действие множество раз в зависимости от определенного условия. В языке Си есть следующие типы циклов: for, while, do...while</p>

  <h4>Цикл for</h4>

  <p>Цикл for имеет следующее формальное определение:</p>
<pre>
for (инициализация; условие; приращение;) {
  // тело цикла
}
</pre>
  <p>заголовок цикла состоит из трех частей. Первая часть - инициализация выполняется один раз при начале выполнения цикла и представляет установку начальных условий, как правило, это инициализация счетчиков - специальных переменных, которые используются для контроля за циклом.</p>
  <p>Вторая часть - условие, при соблюдении которого выполняется цикл. Зачастую в качестве условия используется операция сравнения, и если она возвращает ненулевое значение (то есть условие истинно), то выполняется тело цикла, а затем вычисляется выражение_3.</p>
  <p>Третья часть - приращение задает изменение параметров цикла. Обычно здесь происходит увеличение счетчиков цикла.</p>
  <p>Рассмотрим стандартный цикл for и для этого выведем числа с 0 до 5 на консоль:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  for (int i = 0; i &lt; 6; i++)
  {
    printf("%d", i);
  }
  return 0;
}
</pre>
  <p>Первая часть объявления цикла - int i = 0 - создает и инициализирует счетчик i. Счетчик необязательно должен представлять тип int. Это может быть и другой числовой тип, например, float. И перед выполнением цикла его значение будет равно 0. В данном случае это то же самое, что и объявление переменной.</p>
  <p>Вторая часть - условие, при котором будет выполняться цикл. В данном случае цикл будет выполняться, пока i не достигнет 6.</p>
  <p>И третья часть - приращение счетчика на единицу. Опять же нам необязательно увеличивать на единицу. Можно уменьшать: i--. Можно изменять на другое значение: i+=2.</p>
  <p>В итоге блок цикла сработает 6 раз, пока значение i не станет равным 6. И каждый раз это значение будет увеличиваться на 1.</p>
  <code>012345</code>
  <p>Каждый отдельный проход цикла называется итерацией. То есть в примере выше было 6 итераций.</p>
  <p>Усложним цикл и выведем квадраты чисел от 0 до 8:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  for (int i = 0; i &lt; 9; i++)
  {
    printf("%d * %d = %d \n", i, i,  i * i);
  }
  return 0;
}
</pre>
  <p>Здесь блок цикла сработает 9 раз, пока значение i не станет равным 9. И каждый раз это значение будет увеличиваться на 1.</p>
<pre>
0 * 0 = 0
1 * 1 = 1
2 * 2 = 4
3 * 3 = 9
4 * 4 = 16
5 * 5 = 25
6 * 6 = 36
7 * 7 = 49
8 * 8 = 64
</pre>
  <p>Необязательно указывать все три выражения в определении цикла, мы можем одно или даже все их них опустить:</p>
<pre>
int i = 1;
for ( ; i &lt; 9 ; ) {
  printf("%d * %d = %d \n", i, i,  i * i);
  i++;
}
</pre>
  <p>Формально определение цикла осталось тем же, только теперь первое и третье выражения в определении цикла отсутствуют: for (; i &lt; 9;). Переменная-счетчик определена и инициализирована вне цикла, а ее приращение происходит в самом цикле.</p>
  <p>Можно определять вложенные циклы. Например, выведем таблицу умножения:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  for (int i=1; i &lt; 10; i++) {
    for(int j = 1; j &lt; 10; j++) {
      printf("%d \t", i * j);
    }
    printf("\n");
  }
  return 0;
}
</pre>

  <h4>Цикл do..while</h4>

  <p>В цикле do..while сначала выполняется код цикла, а потом происходит проверка условия в инструкции while. И пока это условие истинно, то есть не равно 0, то цикл повторяется.</p>
<pre>
do
{
  // действия цикла
}
while (условие);
</pre>
  <p>Например:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int i = 6;
  do {
    printf("%d", i);
    i--;
  }
  while (i > 0);
  return 0;
}
</pre>
  <p>Здесь код цикла сработает 6 раз, пока i не станет равным нулю. Но важно отметить, что цикл do гарантирует хотя бы единократное выполнение действий, даже если перед первым выполнением условие в инструкции while не будет истинно. То есть мы можем написать:</p>
<pre>
int i = -1;
do {
  printf("%d", i);
  i--;
}
while (i > 0);
</pre>
  <p>Хотя у нас переменная i меньше 0, цикл все равно один раз выполнится.</p>

  <h4>Цикл while</h4>

  <p>В отличие от цикла do цикл while сразу проверяет истинность некоторого условия, и если условие истинно, то есть не равно 0, то код цикла выполняется:</p>
<pre>
while(условие){
  // выполняемые инструкции, если условие истинно
}
</pre>
  <p>Например, выведем на консоль все числа от 6 до 1:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int i = 6;
  while (i > 0) {
    printf("%d \n", i);
    i--;
  }
  return 0;
}
</pre>
  <p>Здесь, пока истинно условие i > 0, будут выполняться действия цикла - printf("%d \n", i) и i--</p>

  <h4>Операторы continue и break</h4>

  <p>Иногда возникает необходимость выйти из цикла до его завершения. В этом случае можно воспользоваться оператором break. Например:</p>
<pre>
int i = 1;
for ( ; ; ) {
  printf("%d * %d = %d \n", i, i,  i * i);
  i++;
  if (i > 5) break;
}
</pre>
  <p>Здесь когда значение переменной i достигнет 5, осуществляется выход из цикла с помощью оператора break.</p>
  <p>В отличие от оператора break, оператор continue производит переход к следующей итерации. Например, нам надо посчитать сумму только нечетных чисел из некоторого диапазона:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int result = 0;
  for (int i = 0; i &lt; 10; i++) {
    if (i % 2 == 0) continue;
    result +=i;
  }
  printf("result = %d", result);  // 25
  return 0;
}
</pre>
  <p>Чтобы узнать, четное ли число, мы получаем остаток от целочисленного деления на 2, и если он равен 0, то с помощью оператора continue переходим к следующей итерации цикла. А если число нечетное, то складываем его с остальными нечетными числами.</p>
</article>


<!-- 2.13 Введение в массивы и строки -->
<article class="article">
  <div class="anchor" id="p2.13"></div>
  <h3>2.13 Введение в массивы и строки</h3>

  <p>Нередко возникает необходимость работы не с одиночными данными, а с наборами данных. И для этого в языке Си применяются массивы. Массив представляет набор однотипных значений. Объявление массива выглядит следующим образом:</p>
  <code>тип_переменной название_массива [длина_массива]</code>
  <p>После типа переменной идет название массива, а затем в квадратных скобках его размер. Например, определим массив из 4 чисел:</p>
<pre>
int main() {
  int numbers[4];
  return 0;
}
</pre>
  <p>Используя номера элементов массиве, которые называются индексами, мы можем обратиться к отдельным элементам. Например:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int numbers[4];
  numbers[0] = 1;
  numbers[1] = 2;
  numbers[2] = 3;
  numbers[3] = 4;

  printf("numbers[0] = %d \n", numbers[0]);   // 1 - первый элемент
  printf("numbers[2] = %d \n", numbers[2]);   // 3 - третий элемент
  return 0;
}
</pre>
  <p>Индексы указываются в квадратных скобках после названия массива и начинаются с нуля, поэтому для обращения к первому элементу необходимо использовать выражение numbers[0].</p>
  <p>Также мы можем сразу объявить и инициализировать массив значениями. Для этого применяется инициализатор - набор значений в фигурных скобках:</p>
<pre>
// инициализация массива
int numbers[4] = { 1, 2, 3, 5 };
printf("numbers[2] = %d", numbers[2]);  // 3
</pre>
  <p>Внутри инициализатора через запятую перечисляются значения, которые последовательно присваиваются элементам массива. То есть в данном случае у нас будет следующее соответствие между значениями элементов и их индексами:</p>
<pre>
Значение	1	2	3	5
Индекс	  0	1	2	3
</pre>
  <p>При инициализации массива можно явно не указывать его длину, в этом случае длина массива будет вычисляться исходя из количества его элементов в инициализаторе:</p>
  <code>int numbers[] = { 1, 2, 3, 5 };</code>
  <p>При этом необязательно инициализировать массив значениями для всех его элементов:</p>
  <code>int numbers[5] = { 10, 12}; // 10, 12, 0, 0, 0</code>
  <p>В данном случае в рамках инициализации предоставляются значения для двух первых элементов, остальные элементы по умолчанию получают значение 0.</p>
  <p>Также Си позволяет частично инициализировать элементы массива не по порядку:</p>
  <code>int numbers[5] = { [1]=11, [3] = 13 };</code>
  <p>В данном случае инициализируются только два элемента - с индексами 1 и 3. Остальные получают значение по умолчанию - 0. То есть в итоге подобный массив будет анологичен следующему:</p>
  <code>int numbers[5] = { 0, 11, 0, 13, 0 };</code>

  <h4>Размер и количество элементов массива</h4>

  <p>Не всегда в программе может быть известен размер массива. В этом случае можно использовать оператор sizeof, который возвращает размер массива в байтах в виде значения типа size_t:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int numbers[] = { 5, 6, 7};
  size_t size = sizeof(numbers);
  printf("numbers size: %zu \n", size);     // numbers size: 12
  return 0;
}
</pre>
  <p>В этом примере оператор sizeof() для массива { 5, 6, 7} возвращает 12 байт (так как массив содержит 3 значения типа int, которое обычно занимает 4 байта). Тип результата оператора sizeof - size_t фактически является псевдонимом для типа unsigned long long, то есть 64-разрядное положительное число. Для его вывода на консоль применяется спецификатор %zu.</p>
  <p>Используя размер типа, мы можем получить количество элементов в массиве:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int numbers[] = { 5, 6, 7};
  size_t size = sizeof(numbers);
  size_t count = sizeof(numbers) / sizeof(int);
  printf("numbers size: %zu \n", size);    // numbers size: 12
  printf("numbers count: %zu \n", count);  // numbers count: 3
  return 0;
}
</pre>
  <p>Также можно получить количество элементов в массиве, разделив его размер на размер первого элемента:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int numbers[] = { 5, 6, 7};
  size_t size = sizeof(numbers);
  size_t count = sizeof(numbers) / sizeof(numbers[0]);
  printf("numbers size: %zu \n", size);    // numbers size: 12
  printf("numbers count: %zu \n", count);  // numbers count: 3
  return 0;
}
</pre>

  <h4>Динамическое вычисление значений массива</h4>

  <p>Также можно отметить, что элементы массива могут динамически вычисляться. Например:</p>
<pre>
// numbers = {4, 4 (Windows) или 8 (Linux/MacOS), 8}
int sizes[] = {sizeof(int), sizeof(long), sizeof(long long)};
sizes[1] = sizeof(char);  // sizes[1] = 1
</pre>
  <p>В данном случае каждый элемент массива вычисляется динамически с помощью выше рассмотренной функции sizeof(), которая возвращает размер.</p>

  <h4>Перебор элементов массива</h4>

  <p>Используя циклические конструкции, можно перебрать массив:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int numbers[] = { 10, 12, 13, 54, 43 };
  size_t count = sizeof(numbers) / sizeof(numbers[0]);
  for(size_t i =0; i &lt; count; i++)
  {
    printf("numbers[%zu] = %d \n", i, numbers[i]);
  }
  return 0;
}
</pre>
  <p>Стоит отметить, что в качестве индекса используется значение типа size_t. В реальности часто встречается и мы могли бы использовать тип int или unsigned int:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int numbers[] = { 10, 12, 13, 54, 43 };
  size_t count = sizeof(numbers) / sizeof(numbers[0]);
  // int в качестве индекса
  for(int i =0; i &lt; count; i++)
  {
    printf("numbers[%d] = %d \n", i, numbers[i]);
  }
  return 0;
}
</pre>
  <p>В целом мы получим тот же результат. Но в общем рекомендуемым способом все таки является использование size_t, поскольку этот тип допускает количество, которое может не вписаться в допустимый диапазон чисел типов int или unsigned int.</p>

  <h4>Динамическая установка размера массива</h4>

  <p>Размер массива можно установить динамически с помощью переменной/константы:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int maxSize = 3;
  int array[maxSize];
  array[0] = 1;
  array[1] = 2;
  array[2] = 3;
  for (int i = 0; i &lt; maxSize; i++)
  {
    printf("%d", array[i]);
  }
  return 0;
}
</pre>
  <p>Стоит отметить, что при динамической установке нельзя при определении инициализировать массив:</p>
<pre>
int maxSize = 3;
int array[maxSize] = {1, 2, 3}; // ! Ошибка, так нельзя
</pre>

  <h4>Константные массивы</h4>

  <p>При необходимости после инициализации мы можем многократно изменять значения элементов массива:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int numbers[3] = {11, 12, 13};
  numbers[1] = 22;        // изменяем второй элемент
  printf("numbers[1] = %d", numbers[1]);  // numbers[1] = 22
  return 0;
}
</pre>
  <p>Однако иногда, наоборот, не требуется или даже нежелательно изменять элементы массива. В этом случае мы можем определить массив как константный:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  const int numbers[3] = {11, 12, 13};
  // numbers[1] = 22; // Нельзя изменить - массив константный
  printf("numbers[1] = %d", numbers[1]);  // numbers[1] = 22
  return 0;
}
</pre>
  <p>При попытке изменить элемент константного массива мы уже на этапе компиляции столкнемся с ошибкой.</p>

  <h4>Многомерные массивы</h4>

  <p>Массивы могут быть многомерными. Элементы таких массивов сами в свою очередь являются массивами, в которых также элементы могут быть массивами. В большинстве случаев многмерные массивы представляют двухмерные массивы, которые можно представить в виде таблицы. Например, определим двухмерный массив чисел:</p>
  <code>int numbers[3][2] = { {1, 2}, {4, 5}, {7, 8} };</code>
  <p>Здесь массив numbers имеет три элемента (3 строки), но каждый из этих элементов сам представляет массив из двух элементов (2 столбцов). Такой массив еще можно представить в виде таблицы:</p>
<pre>
1	2
4	5
7	8
</pre>
  <p>И чтобы обратиться к элементам вложенного массива, потребуется два индекса:</p>
<pre>
int numbers[3][2] = { {1, 2}, {4, 5}, {7, 8} };
printf("numbers[1][0] = %d \n", numbers[1][0]);     // 4
</pre>
  <p>другой пример, двухмерный массив с двумя строками и тремя столбцами:</p>
  <code>int numbers[2][3] = { {1, 2, 4}, {5, 7, 8} };</code>
  <p>Такой массив графически можно представить следующим образом:</p>
<pre>
1	2	4
5	7	8
</pre>
  <p>Для перебора двухмерного массива применются вложенные циклы:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int numbers[3][2] = { {1, 2}, {4, 5}, {7, 8} };
  // проходим по 3 строкам таблицы
  for(int i =0; i &lt; 3; i++) {
    // проходим по 2 столбцам каждой строки
    for(int j = 0; j &lt; 2; j++) {
      printf("numbers[%d][%d] = %d \n", i, j, numbers[i][j]);
    }
  }
  return 0;
}
</pre>
  <p>Как и в одномерных массивах, мы можем применить оператор sizeof для поиска длины массива и даже его подмассивов:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int numbers[3][2] = { {1, 2}, {4, 5}, {7, 8} };
  size_t rows_count = sizeof(numbers) / sizeof(numbers[0]);   // 3
  size_t columns_count = sizeof(numbers[0]) / sizeof(numbers[0][0]);  // 2
  printf("rows count = %zu \n", rows_count);
  printf("columns count = %zu \n", columns_count);
  // проходим по 3 строкам таблицы
  for(size_t i =0; i &lt; rows_count; i++) {
    // проходим по 2 столбцам каждой строки
    for(size_t j =0; j &lt; columns_count; j++) {
      printf("numbers[%zu][%zu] = %d \n", i, j, numbers[i][j]);
    }
  }
  return 0;
}
</pre>
  <p>Консольный вывод:</p>
<pre>
rows count = 3
columns count = 2
numbers[0][0] = 1
numbers[0][1] = 2
numbers[1][0] = 4
numbers[1][1] = 5
numbers[2][0] = 7
numbers[2][1] = 8
</pre>
  <p>Стоит отметить, что двухмерные и прочие многомерные массивы - это фактически абстракция, которая в реальности не существует. В реальности все массивы являются одномерными и представляют сплошной блок памяти. Возможно, гораздо удобнее работать, скажем, с табличными данными как с двухмерных массивом. Однако мы могли бы инициализировать многомерные массивы как одномерные:</p>
  <code>int numbers[3][2] = { 1, 2, 4, 5, 7, 8 };</code>

  <h4>Строки</h4>

  <p>Выше рассматривались массивы чисел, но с массивами остальных типов данных все будет аналогично. Но отдельно стоит остановиться на массивах символов. В различных языках программирования есть специальные типы данных для представления строк. В языке программирования Си для представления строк используются массивы символов, ведь по сути строка - это и есть набор символов. Например, определим строку:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char message[] = "Hello";
  printf("message: %s \n", message);     // message: Hello
  return 0;
}
</pre>
  <p>Строки определяются в двойных кавычках. И если нам в программе нужны строки, то как раз можно использовать массивы символов.</p>
  <p>Но стоит отметить, что кроме самих символов, которые заключены двойные кавычки, каждая строка в качестве завершающего символа содержит символ \0или нулевой символ (нулевой байт). Он же самый первый символ из таблицы ASCII. В Си нулевой байт служит признаком окончания строки. Поэтому в строке "Hello" на самом деле будет не 5 символов, а 6.</p>
  <code>H	e	l	l	o	\0</code>
  <p>К примеру, переберем все символы строки и выведем их десятичный код ASCII:</p>
<pre>
char message[] = "Hello";
size_t length = sizeof(message)/sizeof(char);   // 6 символов
for(size_t i=0; i &lt; length; i++) {
  printf("%d ", message[i]);
}
</pre>
  <p>На консоли при запуске программы мы сможем увидеть в конце нулевой символ:</p>
  <code>72 101 108 108 111 0</code>
  <p>Если бы мы определяли массив message не как строку, а именно как массив символов, то последним элементом должен был бы идти нулевой символ:</p>
  <code>char message[] = {'H', 'e', 'l', 'l', 'o', '\0'};</code>

  <h4>Задачи с массивами</h4>

  <p>Рассмотрим работу с массивами на примере умножения матриц:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  const int r1 = 3, c1r2 = 2, c2 = 1;
  int matrix1[3][2] = {{1, 2},{3, 4},{5, 6}};
  int matrix2[2][1] = {{10},{20}};
  int matmult[r1][c2];

  // инициализируем результирующую матрицу
  for (int i = 0; i &lt; r1; i++) {
    for (int j = 0; j &lt; c2; j++) {
      matmult[i][j]=0;
    }
  }

  for (int i = 0; i &lt; r1; i++) {
    for (int j = 0; j &lt; c2; j++) {
      for (int k = 0; k &lt; c1r2; k++) {
        matmult[i][j] = matmult[i][j] + matrix1[i][k] * matrix2[k][j];
      }
    }
  }

  printf("Result \n");
  for (int i = 0; i &lt; r1; i++) {
    for (int j = 0; j &lt; c2; j++) {
      printf("%d ",matmult[i][j]);
    }
    printf("\n");
  }
}
</pre>
  <p>Здесь у нас определены две матрицы. Матрица matrix1[3][2] имеет три строки и два столбца:</p>
<pre>
1	2
3	4
5	6
</pre>
  <p>Вторая матрица фактически состоит из одного столбца:</p>
<pre>
10
20
</pre>
  <p>Для хранения размера столбцов и строк определены переменные</p>
<pre>
r1 = 3  // число строк в 1-й матрице
c1r2=2  // число столбцов в 1-й и число строк во 2-й матрице
c2=1    // число столбцов во 2-й матрице
</pre>
  <p>Также определяем результирующую матрицу - результат произведения - matmul:</p>
  <code>int matmult[r1][c2];</code>
  <p>И инициализируем ее нулями.</p>
  <p>При произведении матриц мы получаем матрицу, где количество строк равно количеству строк первой матрицы, а количество столбцов - количеству столбцов второй матрицы. А элемент результирующей матрицы на i-й строке j-м столбце равен сумме произведений элементов на i-й строке первой матрицы на соответствующие элементы j-го столбца второй матрицы.</p>
  <code>c2,1 = a2,1 * b1,1 + a2,2 * b2,1</code>
  <p>Соответственно при вычислении произведения в цикле по i проходим по всем строкам первой матрицы:</p>
  <code>for (int i = 0; i &lt; r1; i++)</code>
  <p>Далее в цикле по j проходим по всем столбцам второй матрицы:</p>
  <code>for (int j = 0; j &lt; c2; j++)</code>
  <p>В цикле по k умножаем значения из k-столбца первой матрицы на значения k-строки второй матрицы и прибавляем к результату:</p>
<pre>
for (int k = 0; k &lt; c1r2; k++) {
  matmult[i][j] = matmult[i][j] + matrix1[i][k] * matrix2[k][j];
}
</pre>
  <p>В результате мы получим матрицу из трех строк и одного столбца:</p>
<pre>
Result
50
110
170
</pre>
</article>


<!-- 2.14 Ввод в консоли. Функция scanf -->
<article class="article">
  <div class="anchor" id="p2.14"></div>
  <h3>2.14 Ввод в консоли. Функция scanf</h3>

  <p>Для ввода данных в консоли может использоваться функция scanf(). Эта функция определена в заголовочном файле stdio.h (там же, где и функция printf) и имеет следующее формальное определение:</p>
  <code>scanf(форматная_строка, аргументы)</code>
  <p>И форматная_строка, и аргументы для функции scanf обязательны.</p>
  <p>Форматная_строка содержит спецификации преобразования, которые определяют вводимые данные. Общий вид спецификаций преобразования:</p>
  <code>% * ширина_поля модификатор спецификатор</code>
  <p>Из этих элементов обязательны только два: знак процента % и спецификатор.</p>
  <p>Спецификатор определяет тип вводимых данных:</p>
  <ul>
    <li>%c: считывает один символ</li>
    <li>%d: считывает десятичное целое число</li>
    <li>%i: считывает целое число в любой системе (десятичной, шестнадцатеричной, восьмеричной)</li>
    <li>%u: считывает положительное целое число</li>
    <li>%e: считывает число с плавающей точкой в экспоненциальной форме</li>
    <li>%E: считывает число с плавающей точкой в экспоненциальной форме с заглавным символом экспоненты</li>
    <li>%f: считывает число с плавающей точкой</li>
    <li>%F: считывает число с плавающей точкой</li>
    <li>%g: считывает число с плавающей точкой</li>
    <li>%G: считывает число с плавающей точкой</li>
    <li>%o: считывает восьмеричное число</li>
    <li>%x: считывает шестнадцатеричное число</li>
    <li>%X: считывает шестнадцатеричное число</li>
    <li>%s: считывает строку</li>
    <li>%%: считывает символ процента</li>
  </ul>
  <p>Символ звездочки * в спецификации преобразования позволяет пропустить при вводе водимые символы для типа, указанного через спецификатор.</p>
  <p>Ширина_поля представляет целое положительное число, которое позволяет определить, какое количество байтов будет учитываться при вводе.</p>
  <p>Модификаторы позволяют конкретизировать тип данных. В частности, есть следующие модификаторы:</p>
  <ul>
    <li>h: для ввода значений типа short int (%hd)</li>
    <li>l: для ввода значений типа long int (%ld) или double (%lf, %le)</li>
    <li>L: для ввода значений типа long double (%Lf, %Le)</li>
  </ul>
  <p>В качестве аргументов в функцию scanf() передаются адреса переменной, которая будет получать введенное значение. Для получения адреса переменной перед ее именем ставится знак амперсанда &. Например, если переменная называется age, то ее адрес мы можем получить с помощью выражения &age.</p>
  <p>Например, введем с консоли числовое значение:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int age;
  printf("Input your age:");
  scanf("%d", &age);

  printf("age = %d", age);
  return 0;
}
</pre>
  <p>Здесь вводится значение для переменной age, которая представляет тип int, поэтому в форматную строку в функции scanf передается спецификатор %d. Здесь не используется ни символ звездочки, ни ширина поля, ни модификаторы. Вторым параметром идет адрес переменной age - &age.</p>
  <p>После ввода значения мы можем его использовать, например, вывести на консоль:</p>
<pre>
Input your age:44
age = 44
</pre>
  <p>Аналогичен будет ввод данных других типов:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  double price;
  long code;
  printf("Enter the product code: ");
  scanf("%ld", &code);
  printf("Enter the price: ");
  scanf("%lf", &price);
  printf("Product code: %ld \t price: %.2lf \n", code, price);
  return 0;
}
</pre>
  <p>После ввода значения мы можем его использовать, например, вывести на консоль:</p>
<pre>
Enter the product code: 1234
Enter the price: 234.567
Product code: 1234       price: 234.57
</pre>
  <p>Можно сразу вводить несколько значений. В этом случае в качестве разделителя используется пробел:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int count;
  double price;
  long code;
  printf("Enter product data: ");
  scanf("%ld %d %lf", &code, &count, &price);
  printf("Product code: %ld \tcount: %d \tprice: %.2lf\n", code, count, price);
  return 0;
}
</pre>
  <p>При вводе данных в консоли функция scanf может использовать пробелы в качестве разделителей, чтобы выдернуть из ввода значения для определенных переменных. Консольный ввод-вывод:</p>
<pre>
Enter product data: 1234 3 234.56
Product code: 1234      count: 3        price: 234.56
</pre>

  <h4>Ввод строк</h4>

  <p>Функция scanf() также позволяет вводить строки. Например:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char name[10];
  // вводим имя
  printf("Enter your name: ");
  scanf("%10s", name);

  printf("Name: %s \n",name);
  return 0;
}
</pre>
  <p>Здесь для имени выделяется 10 символов. Теоретически мы можем ввести и большее количество символов, но чтобы только 10 из них учитывались, в строку форматирования передается ширина поля, которая представляет 10 символов - %10s. Когда функция считает достаточное количетсво символов, она прекратит считывание.</p>
  <p>Обратите внимание, что для ввода строки перед названием переменной не указывается символ адреса.</p>
  <code>scanf("%10s", name);</code>
  <p>Потому что название массива уже само по себе представляет адрес на первый элемент массива.</p>
  <p>Возможный консольный вывод:</p>
<pre>
Enter your name: Tom
Name: Tom
</pre>
  <p>Однако при использовании этой функции мы можем столкнуться с рядом проблем. Прежде всего попробуйте ввести в предыдущем примере составное имя, в которм подстроки разделены пробелами, например, "Tom Smith".</p>
<pre>
Enter your name: Tom Smith
Name: Tom
</pre>
  <p>Для решения этой проблемы можно использовать один хак:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char name[10];
  printf("Enter your name: ");
  scanf("%10[^\n]", name);

  printf("Name: %s \n",name);
  return 0;
}
</pre>
  <p>Спецификатор %10[^\n] указавает, что мы по прежнему считываем не более 10 символов. Квадратные скобки [] представляют позволяют определить набор символов, которые будут извлекаться из ввода или, наоборот, игнорироваться. Так, выражение [^\n] говорит, что надо считать ввод до тех пор пока не встретиться символ перевода строки '\n', то есть пока пользователь не нажмет на клавишу Enter.</p>
</article>


<!-- 3 Указатели -->
<!-- 3.1 Что такое указатели -->
<article class="article">
  <div class="anchor" id="p3.1"></div>
  <h3>3 Указатели</h3>
  <h3>3.1 Что такое указатели</h3>

  <p>Все определенные в программе данные, например, переменные, хранятся в памяти по определенному адресу. И указатели позволяют напрямую обращаться к этим адресам и благодаря этому манипулировать данными. Указатели представляют собой объекты, значением которых служат адреса других объектов (переменных, констант, указателей) или функций. Указатели - это неотъемлемый компонент для управления памятью в языке Си.</p>

  <h4>Определение указателя</h4>

  <p>Для определения указателя надо указать тип объекта, на который указывает указатель, и символ звездочки *.</p>
  <code>тип_данных* название_указателя;</code>
  <p>Сначала идет тип данных, на который указывает указатель, и символ звездочки *. Затем имя указателя.</p>
  <p>Например, определим указатель на объект типа int:</p>
  <code>int *p;</code>
  <p>Пока указатель не ссылается ни на какой объект. Теперь присвоим ему адрес переменной:</p>
<pre>
int main() {
  int x = 10;   // определяем переменную
  int *p;       // определяем указатель
  p = &amp;x;       // указатель получает адрес переменной
  return 0;
}
</pre>

  <h4>Получение адреса данных</h4>

  <p>Указатель хранит адрес объекта в памяти компьютера. И для получения адреса к переменной применяется операция &. Эта операция применяется только к таким объектам, которые хранятся в памяти компьютера, то есть к переменным и элементам массива.</p>
  <p>Что важно, переменная x имеет тип int, и указатель, который указывает на ее адрес тоже имеет тип int. То есть должно быть соответствие по типу.</p>
  <p>Какой именно адрес имеет переменная x? Для вывода значения указателя можно использовать специальный спецификатор %p:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int x = 10;
  int *p;
  p = &amp;x;
  printf("%p \n", p);   // 0060FEA8
  return 0;
}
</pre>
  <p>В моем случае машинный адрес переменной x - 0x0060FEA8. (Для адресов в памяти применяется шестнадцатеричная система.) Но в каждом отдельном случае адрес может быть иным. Фактически адрес представляет целочисленное значение, выраженное в шестнадцатеричном формате.</p>
  <p>То есть в памяти компьютера есть адрес 0x0060FEA8, по которому располагается переменная x.</p>
  <p>Так как переменная x представляет тип int, то на большинстве архитектур она будет занимать следующие 4 байта (на конкретных архитектурах размер памяти для типа int может отличаться). Таким образом, переменная типа int последовательно займет ячейки памяти с адресами 0x0060FEA8, 0x0060FEA9, 0x0060FEAA, 0x0060FEAB.</p>
  <p>И указатель p будет ссылаться на адрес, по которому располагается переменная x, то есть на адрес 0x0060FEA8.</p>
  <p>Стоит отметить, что при выводе адреса указателя функция printf() ожидает, что указатель будет представлять void*, то есть указатель на значение типа void. Поэтому некоторые компиляторы при некоторых настройках могут при компиляции отображать предупреждения. И чтобы было все канонически правильно, то переданный указатель нужно преобразовать в указатель типа void *:</p>
  <code>printf("%p \n", (void *)p);</code>

  <h4>Получение значения по адресу</h4>

  <p>Но так как указатель хранит адрес, то мы можем по этому адресу получить хранящееся там значение, то есть значение переменной x. Для этого применяется операция * или операция разыменования (dereference operator). Результатом этой операции всегда является объект, на который указывает указатель. Применим данную операцию и получим значение переменной x:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int x = 10;
  int *p;
  p = &amp;x;
  printf("Address = %p \n", (void*) p);
  printf("x = %d \n", *p);
  return 0;
}
</pre>
  <p>Консольный вывод:</p>
<pre>
Address = 0060FEA8
x = 10
</pre>
  <p>Используя полученное значение в результате операции разыменования мы можем присвоить его другой переменной:</p>
<pre>
int x = 10;
int *p  = &amp;x;
// присваиваем переменной y значение по адресу из указателя p
int y = *p;
printf("x = %d \n", y); // 10
</pre>
  <p>Здесь присваиваем переменной y значение по адресу из указателя p, то есть значение переменной x.</p>
  <p>И также используя указатель, мы можем менять значение по адресу, который хранится в указателе:</p>
<pre>
int x = 10;
int *p = &amp;x;
*p = 45;
printf("x = %d \n", x);  // 45
</pre>
  <p>Так как по адресу, на который указывает указатель, располагается переменная x, то соответственно ее значение изменится.</p>
  <p>Создадим еще несколько указателей:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char c = 'N';
  int d = 10;
  short s = 2;

  char *pc = &amp;c;      // получаем адрес переменной с типа char
  int *pd = &amp;d;       // получаем адрес переменной d типа int
  short *ps = &amp;s;     // получаем адрес переменной s типа short

  printf("Variable c: address=%p \t value=%c \n", (void*) pc, *pc);
  printf("Variable d: address=%p \t value=%d \n", (void*) pd, *pd);
  printf("Variable s: address=%p \t value=%hd \n", (void*) ps, *ps);
  return 0;
}
</pre>
  <p>В моем случае я получу следующий консольный вывод:</p>
<pre>
Variable c: address=0060FEA3	value=N
Variable d: address=0060FE9C	value=10
Variable s: address=0060FE9A	value=2
</pre>
  <p>По адресам можно увидеть, что переменные часто расположены в памяти рядом, но не обязательно в том порядке, в котором они определены в тексте программы.</p>
</article>


<!-- 3.2 Операции с указателями -->
<article class="article">
  <div class="anchor" id="p3.2"></div>
  <h3>3.2 Операции с указателями</h3>

  <p>Указатели в языке Си поддерживают ряд операций: присваивание, получение адреса указателя, получение значения по указателю, некоторые арифметические операции и операции сравнения.</p>

  <h4>Присваивание</h4>

  <p>Указателю можно присвоить либо адрес объекта того же типа, либо значение другого указателя или константу NULL.</p>
  <p>Присвоение указателю адреса уже рассматривалось в прошлой теме. Для получения адреса объекта используется операция &:</p>
<pre>
int a = 10;
int *pa = &mp;a;   // указатель pa хранит адрес переменной a
</pre>
  <p>Причем указатель и переменная должны иметь тот же тип, в данном случае int.</p>
  <p>Присвоение указателю другого указателя:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int a = 10;
  int b = 2;

  int *pa = &amp;a;
  int *pb = &amp;b;

  printf("Variable a: address=%p \t value=%d \n", (void*)pa, *pa);
  printf("Variable b: address=%p \t value=%d \n", (void*)pb, *pb);

  pa = pb;    // теперь указатель pa хранит адрес переменной b
  printf("Variable b: address=%p \t value=%d \n", (void*)pa, *pa);

  return 0;
}
</pre>
  <p>Когда указателю присваивается другой указатель, то фактически первый указатель начинает также указывать на тот же адрес, на который указывает второй указатель.</p>
  <p>Если мы не хотим, чтобы указатель указывал на какой-то конкретный адрес, то можно присвоить ему условное нулевое значение с помощью константы NULL, которая определена в заголовочном файле stdio.h:</p>
  <code>int *pa = NULL;</code>

  <h4>Разыменование указателя</h4>

  <p>Операция разыменования указателя в виде *имя_указателя, позволяет получить объект по адресу, который хранится в указателе.</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int a = 10;

  int *pa = &amp;a;
  int *pb = pa;

  *pa = 25;

  printf("Value on pointer pa: %d \n", *pa);  // 25
  printf("Value on pointer pb: %d \n", *pb);  // 25
  printf("Value of variable a: %d \n", a);    // 25

  return 0;
}
</pre>
  <p>Через выражение *pa мы можем получить значение по адресу, который хранится в указателе pa, а через выражение типа *pa = значение вложить по этому адресу новое значение.</p>
  <p>И так как в данном случае указатель pa указывает на переменную a, то при изменении значения по адресу, на который указывает указатель, также изменится и значение переменной a.</p>

  <h4>Указатель на void</h4>

  <p>Указатели указывают на данные определенных типов. Например, указатель типа int* указывает на значение типа int, но не может указывать на данные других типов, скажем, на объект типа float. Однако можно также определять указатели типа void*, которые могут указывать на данные любого типа. И неявно указатели любых типов можно преобразовать в указатель типа void*:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int x = 123;
  // указатель хранит адрес объекта int
  int *ip = &x;

  void *vp;
  // void-указатель получает адрес из указателя ip
  vp = ip;

  printf("Value: %d\n", *((int *)vp));    // Value: 123

  return 0;
}
</pre>
  <p>Следует учитывать, что к void-указателю мы НЕ можем применить операцию разыменования и тем самым получить значение под адресу, который хранится в этом указателе. Поэтому для получения значения надо приводить к указателю соответствующего типа:</p>
  <code>printf("Value: %d\n", *((int *)vp));</code>
  <p>Одно из распространенных применений void-указателя - это вывод адреса на консоль:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int x = 123;

  // указатель хранит адрес объекта int
  int *ip = &x;

  // void-указатель получает адрес из указателя ip
  void *vp = ip;

  // получаем адрес, который хранится в указателе vp
  printf("vp: %p\n", vp);

  // преобразование к типу void* - получаем адрес из указателя ip
  printf("ip: %p\n", (void*)ip);

  return 0;
}
</pre>
  <p>Если мы хотим получить адрес из указателя другого типа, то, в соответствии со стандартами, его сначала надо преобразовать к типу void*.</p>

  <h4>Адрес указателя</h4>

  <p>Указатель хранит адрес переменной, и по этому адресу мы можем получить значение этой переменной. Но кроме того, указатель, как и любая переменная, сам имеет адрес, по которому он располагается в памяти. Этот адрес можно получить также через операцию &:</p>
<pre>
int a = 10;
int *pa = &a;

// адрес указателя
printf("address of pointer=%p \n",  (void*)&pa);

// адрес, который хранится в указателе - адрес переменной a
printf("address in pointer=%p \n",  (void*)pa);

// значение по адресу в указателе - значение переменной a
printf("value on pointer=%d \n", *pa);
</pre>

  <h4>Операции сравнения</h4>

  <p>К указателям могут применяться операции сравнения >, >=, &lt;, &lt;=, ==, !=. Операции сравнения применяются только к указателям одного типа и константе NULL. Для сравнения используются номера адресов:</p>
<pre>
int a = 10;
int b = 20;
int *pa = &a;
int *pb = &b;

if(pa > pb) {
  printf("pa (%p) is greater than pb (%p) \n",  (void*)pa,  (void*)pb);
} else {
  printf("pa (%p) is less or equal pb (%p) \n",  (void*)pa,  (void*)pb);
}
</pre>
  <p>Консольный вывод в моем случае:</p>
  <code>pa (0060FEA4) is greater than pb (0060FEA0)</code>

  <h4>Приведение типов</h4>

  <p>Иногда требуется присвоить указателю одного типа значение указателя другого типа. В этом случае следует выполнить операцию приведения типов:</p>
<pre>
char c = 'N';
char *pc = &c;
int *pd = (int *)pc;
printf("pc=%p \n",  (void*)pc);
printf("pd=%p \n",  (void*)pd);
</pre>
</article>


<!-- 3.3 Арифметика указателей -->
<article class="article">
  <div class="anchor" id="p3.3"></div>
  <h3>3.3 Арифметика указателей</h3>

  <p>К указателям могут применять некоторые арифметические операции (сложение, вычитание, инкремент, декремент). Однако сами операции производятся немного иначе, чем с числами. И многое здесь зависит от типа указателя. К указателю можно прибавлять целое число, и также можно вычитать из указателя целое число. Кроме того, можно вычитать из одного указателя другой указатель.</p>
  <p>Рассмотрим вначале операции инкремента и декремента и для этого возьмем указатель на объект типа int:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int n = 10;

  int *ptr = &n;
  printf("address=%p \t value=%d \n", (void*)ptr, *ptr);

  ptr++;
  printf("address=%p \t value=%d \n", (void*)ptr, *ptr);

  ptr--;
  printf("address=%p \t value=%d \n", (void*)ptr, *ptr);

  return 0;
}
</pre>
  <p>Операция инкремента ++ увеличивает значение на единицу. В случае с указателем увеличение на единицу будет означать увеличение адреса, который хранится в указателе, на размер типа указателя. То есть в данном случае указатель на тип int, а размер объектов int в большинстве архитектур равен 4 байтам. Поэтому увеличение указателя типа int на единицу означает увеличение значение указателя на 4.</p>
  <p>И в моем случае консольный вывод выглядит следующим образом:</p>
<pre>
address=0060FEA8	value=10
address=0060FEAC	value=6356652
address=0060FEA8	value=10
</pre>
  <p>Здесь видно, что после инкремента значение указателя увеличилось на 4: с 0060FEA8 до 0060FEAC. А после декремента, то есть уменьшения на единицу, указатель получил предыдущий адрес в памяти.</p>
  <p>Фактически увеличение на единицу означает, что мы хотим перейти к следующему объекту в памяти, который находится за текущим и на который указывает указатель. А уменьшение на единицу означает переход назад к предыдущему объекту в памяти.</p>
  <p>После изменения адреса мы можем получить значение, которое находится по новому адресу, однако это значение может быть неопределенным, как показано на консольном выводе программы выше.</p>
  <p>В случае с указателем типа int увеличение/уменьшение на единицу означает изменение адреса на 4. Аналогично, для указателя типа short эти операции изменяли бы адрес на 2, а для указателя типа char на 1.</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  double d = 10.6;
  double *pd = &d;
  printf("Pointer pd: address=%p \n", (void*)pd);
  pd++;
  printf("Pointer pd: address=%p \n", (void*)pd);

  char c = 'N';
  char *pc = &c;
  printf("Pointer pc: address=%p \n", (void*)pc);
  pc++;
  printf("Pointer pc: address=%p \n", (void*)pc);

  return 0;
}
</pre>
  <p>В моем случае консольный вывод будет выглядеть следующим образом:</p>
<pre>
Pointer pd: address=0060FEA0
Pointer pd: address=0060FEA8
Pointer pc: address=0060FE9F
Pointer pc: address=0060FEA0
</pre>
  <p>Как видно из консольного вывода, увеличение на единицу указателя типа double дало увеличения хранимого в нем адреса на 8 единиц (размер объекта double - 8 байт), а увеличение на единицу указателя типа char дало увеличение хранимого в нем адреса на 1 (размер типа char - 1 байт).</p>
  <p>Аналогично указатель будет изменяться при прибавлении/вычитании не единицы, а какого-то другого числа.</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  double d = 10.6;
  double *pd = &d;

  printf("Pointer pd: address=%p \n", (void*)pd);
  // перемещаем указатель вперед на 2 значения double (2 * 8 = 16 байт)
  pd = pd + 2;
  printf("Pointer pd: address=%p \n", (void*)pd);

  char c = 'N';
  char *pc = &c;

  printf("Pointer pc: address=%p \n", (void*)pc);
  // перемещаем указатель назад на 3 значения char (3 * 1 = 3 байта)
  pc = pc - 3;
  printf("Pointer pc: address=%p \n", (void*)pc);

  return 0;
}
</pre>
  <p>Добавление к указателю типа double числа 2</p>
  <code>pd = pd + 2;</code>
  <p>означает, что мы хотим перейти на два объекта double вперед, что подразумевает изменение адреса на 2 * 8 = 16 байт.</p>
  <p>Вычитание из указателя типа char числа 3</p>
  <code>pc = pc - 3;</code>
  <p>означает, что мы хотим перейти на три объекта char назад, что подразумевает изменение адреса на 3 * 1 = 3 байта.</p>
  <p>И в моем случае я получу следующий консольный вывод:</p>
<pre>
Pointer pd: address=0060FEA0
Pointer pd: address=0060FEB0
Pointer pc: address=0060FE9F
Pointer pc: address=0060FE9C
</pre>
  <p>В отличие от сложения операция вычитание может применяться не только к указателю и целому числу, но и к двум указателям одного типа:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int a = 10;
  int b = 23;
  int *pa = &a;
  int *pb = &b;
  ptrdiff_t c = pa - pb;  // разница между адресами

  printf("pa=%p \n", (void*)pa);
  printf("pb=%p \n", (void*)pb);
  printf("c=%lld \n", c);

  return 0;
}
</pre>
  <p>Консольный вывод в моем случае:</p>
<pre>
pa=0060FEA0
pb=0060FE9C
c=1
</pre>
  <p>Результатом разности двух указателей является "расстояние" между ними, которое соответствует количеству значений типа указателя (в примере выше типа int), которые могут поместиться между этими двуся указателями. Например, в случае выше адрес из первого указателя на 4 больше, чем адрес из второго указателя (0x0060FE9C + 4 = 0x0060FEA0). Так как размер одного объекта int равен 4 байтам, то расстояние между указателями будет равно (0x0060FEA0 - 0x0060FE9C)/4 = 1.</p>
  <p>Расстояние между указателями представляет тип ptrdif_t - на 64-разрядной архитектуре этот тип является псевдонимом для базового типа long long и занимает 8 байт.</p>
  <p>Или другой пример:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int arr[64];
  int* ptr1 = &arr[10];
  int* ptr2 = &arr[40];
  ptrdiff_t dist = ptr2 - ptr1; // 30

  printf("dist=%lld \n", dist);

  return 0;
}
</pre>
  <p>В данном случае находим разницу между указателями на 10-й и 40-й элементы массива. В итоге расстояние будет равно 30 - 30 элементам int. Чтобы получить расстояние в байтах, соответственно надо умножить расстояние на размер типа указателя.</p>

  <h4>Некоторые особенности операций</h4>

  <p>При работе с указателями надо отличать операции с самим указателем и операции со значением по адресу, на который указывает указатель.</p>
<pre>
int a = 10;
int *pa = &a;
// операция со значением, на который указывает указатель
int b = *pa + 20;
// операция с самим указателем
pa++;

printf("b=%d \n", b);   // 30
</pre>
  <p>То есть в данном случае через операцию разыменования *pa получаем значение, на которое указывает указатель pa, то есть число 10, и выполняем операцию сложения. То есть в данном случае обычная операция сложения между двумя числами, так как выражение *pa представляет число.</p>
  <p>Но в то же время есть особенности, в частности, с операциями инкремента и декремента. Дело в том, что операции *, ++ и -- имеют одинаковый приоритет и при размещении рядом выполняются справа налево.</p>
  <p>Например, выполним постфиксный инкремент:</p>
<pre>
int a = 10;
int *pa = &a;
printf("pa: address=%p \t value=%d \n", (void*)pa, *pa);
int b = *pa++;      // инкремент адреса указателя

printf("b: value=%d \n", b);
printf("pa: address=%p \t value=%d \n", (void*)pa, *pa);
</pre>
  <p>В выражении b = *pa++; сначала к указателю прибавляется единица (то есть к адресу добавляется 4, так как указатель типа int). Затем так как инкремент постфиксный, с помощью операции разыменования возвращается значение, которое было до инкремента - то есть число 10. И это число 10 присваивается переменной b. И в моем случае результат работы будет следующий:</p>
<pre>
pa: address=0060FEA4	value=10
b: value=10
pa: address=0060FEA8	value=6356648
</pre>
  <p>Изменим выражение:</p>
  <code>b = (*pa)++;</code>
  <p>Скобки изменяют порядок операций. Здесь сначала выполняется операция разыменования и получение значения, затем это значение увеличивается на 1. Теперь по адресу в указателе находится число 11. И затем так как инкремент постфиксный, переменная b получает значение, которое было до инкремента, то есть опять число 10. Таким образом, в отличие от предыдущего случая все операции производятся над значением по адресу, который хранит указатель, но не над самим указателем. И, следовательно, изменится результат работы:</p>
<pre>
pa: address=0060FEA4	value=10
b: value=10
pa: address=0060FEA4	value=11
</pre>
  <p>Аналогично будет с префиксным инкрементом:</p>
  <code>b = ++*pa;</code>
  <p>В данном случае сначала с помощью операции разыменования получаем значение по адресу из указателя pa, к этому значению прибавляется единица. То есть теперь значение по адресу, который хранится в указателе, равно 11. Затем результат операции присваивается переменной b:</p>
<pre>
pa: address=0060FEA4	value=10
b: value=11
pa: address=0060FEA4	value=11
</pre>
  <p>Изменим выражение:</p>
  <code>b = *++pa;</code>
  <p>Теперь сначала изменяет адрес в указателе, затем мы получаем по этому адресу значение и присваиваем его переменной b. Полученное значение в этом случае может быть неопределенным:</p>
<pre>
pa: address=0060FEA4	value=10
b: value=6356648
pa: address=0060FEA8	value=6356648
</pre>

  <h4>Указатели на void</h4>

  <p>Особо следует отметить работу с указателями на тип void. Потому что void - это неполный тип (incomplete type), что значит, что компилятор не может узнать его размер. За указателем на void может скрываться все что угодно. Посмотрим на примере:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int num1 = 11;
  int num2 = 12;
  int num3 = 13;
  int num4 = 14;
  void* p_num = &num1;
  printf("*p_num: %d\n", *(int*)(p_num+8));

  return 0;
}
</pre>
  <p>Здесь опеределено 4 числа типа int. Поскольку значения помещаются в стек, то в памяти они будут располагаться последовательно, наподобие следующего:</p>
</article>

