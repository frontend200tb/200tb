<article class="article">
  <h1>Руководство по языку программирования Си</h1>
  <p>Конспект курса</p>
  <p><a href="https://metanit.com/c/tutorial/" target="_blank">https://metanit.com/c/tutorial/</a></p>
  <p>Последнее обновление: 09.03.2025</p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
    <a href="#p1.1">1 Введение в C</a>
    <br><a href="#p1.1">1.1 Язык программирования C</a>
    <br><a href="#p1.2">1.2 Компилятор GCC. Первая программа на Windows</a>
    <br><a href="#p1.3">1.3 Компилятор Clang. Первая программа на Windows</a>
    <br><a href="#p1.4">1.4 GCC. Первая программа на Linux</a>
    <br><a href="#p1.5">1.5 Clang. Первая программа на MacOS</a>
    <br><a href="#p1.6">1.6 Настройка параметров компиляции</a>
    <br><a href="#p1.7">1.7 Локализация и кириллица в консоли</a>
  </p>

  <p>
    <a href="#p2">2 Основы языка Си</a>
    <br><a href="#p2.1">2.1 Структура программы на Си</a>
    <br><a href="#p2.2">2.2 Переменные</a>
    <br><a href="#p2.3">2.3 Типы данных</a>
    <br><a href="#p2.4">2.4 Консольный вывод. Функция printf</a>
    <br><a href="#p2.5">2.5 Константы</a>
    <br><a href="#p2.6">2.6 Арифметические операции</a>
    <br><a href="#p2.7">2.7 Условные операции</a>
    <br><a href="#p2.8">2.8 Поразрядные операции</a>
    <br><a href="#p2.9">2.9 Операции присваивания</a>
    <br><a href="#p2.10">2.10 Преобразование типов</a>
    <br><a href="#p2.11">2.11 Условные конструкции</a>
    <br><a href="#p2.12">2.12 Циклы</a>
    <br><a href="#p2.13">2.13 Введение в массивы и строки</a>
    <br><a href="#p2.14">2.14 Ввод в консоли. Функция scanf</a>
  </p>

  <p>
    <a href="#p3">3 Указатели</a>
    <br><a href="#p3.1">3.1 Что такое указатели</a>
    <br><a href="#p3.2">3.2 Операции с указателями</a>
    <br><a href="#p3.3">3.3 Арифметика указателей</a>
    <br><a href="#p3.4">3.4 Константы и указатели</a>
    <br><a href="#p3.5">3.5 Указатели и массивы</a>
    <br><a href="#p3.6">3.6 Указатели и строки</a>
    <br><a href="#p3.7">3.7 Массивы указателей и многоуровневая адресация</a>
  </p>

  <p>
    <a href="#p4">4 Функции</a>
    <br><a href="#p4.1">4.1 Определение и описание функций</a>
    <br><a href="#p4.2">4.2 Параметры функции</a>
    <br><a href="#p4.3">4.3 Результат функции</a>
    <br><a href="#p4.4">4.4 Рекурсивные функции</a>
    <br><a href="#p4.5">4.5 Область видимости переменных</a>
    <br><a href="#p4.6">4.6 Внешние объекты</a>
    <br><a href="#p4.7">4.7 Указатели в параметрах функции</a>
    <br><a href="#p4.8">4.8 Указатели на функции</a>
    <br><a href="#p4.9">4.9 Тип функции</a>
    <br><a href="#p4.10">4.10 Функции как параметры других функций</a>
    <br><a href="#p4.11">4.11 Функция как результат другой функции</a>
    <br><a href="#p4.12">4.12 Функции с переменным количеством параметров</a>
    <br><a href="#p4.13">4.13 Параметры командной строки</a>
  </p>

  <p>
    <a href="#p5">5 Препроцессор</a>
    <br><a href="#p5.1">5.1 Директива #include. Включение файлов</a>
    <br><a href="#p5.2">5.2 Директива #define</a>
    <br><a href="#p5.3">5.3 Макросы</a>
    <br><a href="#p5.4">5.4 Условная компиляция</a>
    <br><a href="#p5.5">5.5 Встроенные макросы</a>
  </p>

  <p>
    <a href="#p6">6 Структуры</a>
    <br><a href="#p6.1">6.1 Определение структур</a>
    <br><a href="#p6.2">6.2 Структуры как элементы структур</a>
    <br><a href="#p6.3">6.3 Указатели на структуры</a>
    <br><a href="#p6.4">6.4 Массивы структур</a>
    <br><a href="#p6.5">6.5 Структуры и функции</a>
    <br><a href="#p6.6">6.6 Размещение структур и их полей в памяти</a>
    <br><a href="#p6.7">6.7 Составные литералы</a>
    <br><a href="#p6.8">6.8 Перечисления</a>
    <br><a href="#p6.9">6.9 Объединения</a>
    <br><a href="#p6.10">6.10 Битовые поля</a>
  </p>

  <p>
    <a href="#p7">7 Динамическая память</a>
    <br><a href="#p7.1">7.1 Выделение и освобождение памяти</a>
    <br><a href="#p7.2">7.2 Выделение памяти для двухмерного массива произвольной длины</a>
    <br><a href="#p7.3">7.3 Управление динамической памятью</a>
    <br><a href="#p7.4">7.4 Указатель как результат функции</a>
  </p>

  <p>
    <a href="#p8">8 Ввод-вывод и работа с файлами</a>
    <br><a href="#p8.1">8.1 Открытие и закрытие потоков</a>
    <br><a href="#p8.2">8.2 Чтение и запись бинарных файлов</a>
    <br><a href="#p8.3">8.3 Чтение и запись структур в файл</a>
    <br><a href="#p8.4">8.4 Чтение и запись в файл и функции fwrite и fread</a>
    <br><a href="#p8.5">8.5 Чтение и запись текстовых файлов</a>
    <br><a href="#p8.6">8.6 Форматируемый ввод-вывод</a>
    <br><a href="#p8.7">8.7 Позиционирование в файле</a>
    <br><a href="#p8.8">8.8 Консольный ввод-вывод</a>
    <br><a href="#p8.9">8.9 Форматированный ввод и вывод в строки. Функции sscanf и sprintf</a>
  </p>

  <p>
    <a href="#p9">9 Стандартная библиотека С</a>
    <br><a href="#p9.1">9.1 Заголовочные файлы стандартной библиотеки С</a>
    <br><a href="#p9.2">9.2 Работа со строками</a>
    <br><a href="#p9.3">9.3 Работа с памятью</a>
    <br><a href="#p9.4">9.4 Работа с датами и временем</a>
    <br><a href="#p9.5">9.5 Математические функции</a>
    <br><a href="#p9.6">9.6 Преобразование строк в числа и чисел в строки</a>
    <br><a href="#p9.7">9.7 Обобщения и макрос _Generic</a>
    <br><a href="#p9.8">9.8 Поддержка Unicode и кодировки UTF-16 и UTF-32</a>
    <br><a href="#p9.9">9.9 Платформо-независимые числа</a>
    <br><a href="#p9.10">9.10 Проверка символов и ctype.h</a>
  </p>

  <p>
    <a href="#p10">10 Многопоточность</a>
    <br><a href="#p10.1">10.1 Создание и запуск потоков</a>
    <br><a href="#p10.2">10.2 Завершение потоков</a>
    <br><a href="#p10.3">10.3 Мьютексы</a>
    <br><a href="#p10.4">10.4 Сигналы и условные переменные синхронизации</a>
    <br><a href="#p10.5">10.5 Семафоры</a>
  </p>

  <p>
    <a href="#p11">11 Макросы</a>
    <br><a href="#p11.1">11.1 Примеры распространенных макросов</a>
    <br><a href="#p11.2">11.2 Макрос для вывода отладочной информации</a>
    <br><a href="#p11.3">11.3 Макрос для создания обобщенного списка</a>
  </p>

  <p>
    <a href="#p12">12 Среды разработки для С</a>
    <br><a href="#p12.1">12.1 Первая программа в Visual Studio</a>
    <br><a href="#p12.2">12.2 Первая программа в Qt Creator</a>
  </p>

  <p>
    <a href="#p13">13 Взаимодействие с кодом Python</a>
    <br><a href="#p13.1">13.1 Подключение Python</a>
  </p>

  <p>
    <a href="#p14">14 Дополнительные статьи</a>
    <br><a href="#p14.1">14.1 Разделяемые библиотеки на Linux</a>
    <br><a href="#p14.2">14.2 Функции setjmp и longjmp и обработка ошибок</a>
  </p>

  <p>
    <a href="#p15">Упражнения по языку С</a>
  </p>
</article>


<!-- 1 Введение в C -->
<!-- 1.1 Язык программирования C -->
<article class="article">
  <div class="anchor" id="p1.1"></div>
  <h3>1 Введение в C</h3>
  <h3>1.1 Язык программирования C</h3>

  <p>Язык программирования С (си) является одним из самых популярных и распространенных языков. Он представляет компилируемый язык программирования общего назначения со статической типизацией, разработанный в 1969—1973 годах в компании Bell Labs программистом Деннисом Ритчи (Dennis Ritchie).</p>

  <p>Язык С нередко называют языком программирования "среднего уровня" или даже "низкого уровня", так как он сочетает элементы языков высокого уровня с функциональностью и производительностью ассемблера и работает близко к аппаратной части компьютера. В итоге мы можем манипулировать данными на низком уровне и при этом использовать высокоуровневые конструкции для управления работы программы.</p>

  <p>Первоначально язык С предназначался для написания операционной системы Unix. Впоследствии Си стал одним из популярных языков, а его основной сферой применения стало системное программирование, в частности, создание операционных систем, драйверов, различных утилит, антивирусов и т.д. К слову сказать, Linux большей частью написан на Си. Однако только системным программированием применение данного языка не ограничивается. Данный язык можно использовать в программах любого уровня, где важны скорость работы и производительность. Так, мы можем писать с помощью Си и прикладные приложения, и даже веб-сайты (используя технологию CGI - Common Gateway Interface). Но, конечно, для создания графического интерфейса и веб-приложений, как правило, выбираются более подходящие инструменты и технологии, но тем не менее круг использования Си довольно широк. Это в немалой степени определило популярность языка. Например, в известном рейтинге языков программирования TIOBE язык С долгое время уверенно удерживает второе место.</p>

  <p>Несмотря на большие возможности язык Си одновременно довольно прост. Он не содержит много конструкций, библиотек, его легко осваивать и изучать. Поэтому нередко его выбирают в качестве языка для изучения в целом программированию.</p>

  <p>Си является компилируемым языком, а это значит, что компилятор транслирует исходный код на Си в исполняемый файл, который содержит набор машинных инструкций. Но разные платформы имеют свои особенности, поэтому скомпилированные программы нельзя просто перенести с одной платформы на другую и там уже запустить. Однако на уровне исходного кода программы на Си обладают переносимостью, а наличие компиляторов, библиотек и инструментов разработки почти под все распространенные платформы позволяет компилировать один и тот же исходный код на Си в приложения под эти платформы.</p>

  <p>Развитие Си оказало большое влияние в целом на развитие языков программирования. В частности, его синтаксис стал основой для таких языков как С++, С#, Java, PHP, JavaScript. Особо следует сказать про связь с C++. C++ напрямую произошёл от Си. Но впоследствии их развитие происходило отдельно друг от друга, и даже появилась несовместимость между ними. Стандарт C99 добавил в язык Си ряд конфликтующих с C++ особенностей. В итоге в настоящее время оба языка являются фактически самодостаточными и развиваются независимо.</p>

  <h4>Основные особенности Си</h4>
  <ul>
    <li>Универсальность - один и тот же код может быть скомпилирован на почти каждой платформе (при наличии для нее компилятора)</li>
    <li>Высокая скорость выполнения</li>
    <li>Компактность, небольшой размер выходных скомпилированных файлов</li>
  </ul>

  <h4>Основные этапы развития</h4>

  <p>В 1978 году Брайан Керниган и Деннис Ритчи опубликовали первое издание своего знаменитого труда "Язык программирования Си". Долгое время эта книга служила неформальной спецификацией языка Си. Однако быстрое распространение Си привело к необходимости выработки общих стандартов. И в 1983 году организация ANSI (Американский национальный институт стандартов) создала комитет для разработки спецификации Си. А в 1989 году спецификация была утверждена. Эту версию языка принято называть ANSI C или C89. В 1990 году спецификация ANSI C была немного дополнена Международной организацией по стандартизации (ISO). Новый стандарт стал называться ISO/IEC 9899:1990 или сокращенно С90.</p>

  <p>В конце 1990-х годов стандарт подвергся пересмотру, что привело к выходу нового стандарта в 1999 году, который принято называть C99 (официальное название ISO 9899:1999). В году 2018 вышел последний на момент написания текущей статьи стандарт C17 (официальное название ISO/IEC 9899:2018). В 2023 планируется выход стандарта C23. Список всех стандартов</p>
  <ul>
    <li>ANSI C Standard (ANSI C / C89)</li>
    <li>C90 (ISO/IEC 9899:1990)</li>
    <li>C99 (ISO/IEC 9899:1999)</li>
    <li>C11 (ISO/IEC 9899:2011)</li>
    <li>C17 (ISO/IEC 9899:2018)</li>
    <li>C23 (ожидает выхода в 2023 году)</li>
  </ul>

  <h4>Компиляторы и среды разработки</h4>

  <p>Для написания программ на языке С необходимы как минимум два компонента: текстовый редактор для написания исходного кода программы, и компилятор для компиляции кода в исполняемый файл. В качестве текстового редактора можно выбрать любой понравившийся. Я бы посоветовал кросcплатформенный редактор Visual Studio Code, который поддерживает плагины для разных языков, в том числе для C.</p>

  <p>Среди компиляторов под Си следует выделить следующие компиляторы</p>
  <ul>
    <li>GCC от проекта GNU</li>
    <li>Clang</li>
  </ul>

  <p>Так, если обратиться к опросу разработчиков, проведенному компанией JetBrains s 2022, то доли использования различных компиляторов среди разработчиков распределились следующим образом:</p>
  <ul>
    <li>80% GCC</li>
    <li>38% Clang</li>
    <li>18% Compiler for microcontrollers</li>
    <li>17% MSVC</li>
  </ul>

  <p>В дальнейшем на страницах этого руководства буду ориентироваться прежде всего на компилятор GCC, который на мой субъективный взгляд на сегодняшний день является наиболее распространенным.</p>

  <p>Один из вопросов, который может возникнуть при выборе компилятора, - это поддержка компилятором определенных стандартов, особенно если мы хотим использовать некоторые возможности, которые были введены в последних стандартах. В этом случае можно обратиться к странице <a href="https://en.cppreference.com/w/c/compiler_support">https://en.cppreference.com/w/c/compiler_support</a></p>
</article>


<!-- 1.2 Компилятор GCC. Первая программа на Windows -->
<article class="article">
  <div class="anchor" id="p1.2"></div>
  <h3>1.2 Компилятор GCC. Первая программа на Windows</h3>

  <h4>Установка компилятора</h4>

  <p>Рассмотрим создание первой простейшей программы на языке Си с помощью компилятора GCC, который на сегодняшний день является одим из наиболее популярных компиляторов для Cи и который доступен для разных платформ. Более подобному информацию о GCC можно получить на официальном сайте проекта <a href="https://gcc.gnu.org/">https://gcc.gnu.org/</a></p>

  <p>Набор компиляторов GCC распространяется в различных версиях. Для Windows одной из наиболее популярных версий является пакет средств для разработки от некоммерческого проекта MSYS2. Следует отметить, что для MSYS2 требуется 64-битная версия Windows 7 и выше (то есть Vista, XP и более ранние версии не подходят)</p>
  <ul>
    <li>Итак, загрузим программу установки MSYS2 с официального сайта MSYS2:</li>
    <li>После загрузки запустим программу установки:</li>
    <li>На первом шаге установки будет предложено установить каталог для установки. По умолчанию это каталог C:\msys64:</li>
    <li>Оставим каталог установки по умолчанию (при желании можно изменить). На следующем шаге устанавливаются настройки для ярлыка для меню Пуск, и затем собственно будет произведена установка.</li>
    <li>После завершения установки нам отобразить финальное окно, в котором нажмем на кнопку Завершить</li>
    <li>После завершения установки запустится консольное приложение MSYS2.exe. Если по каким-то причинам оно не запустилось, то в папке установки C:/msys64 надо найти файл usrt_64.exe:</li>
    <li>
      Теперь нам надо установить собственно набор компиляторов GCC. Для этого введем в этом приложении следующую команду:
      <code>pacman -S mingw-w64-ucrt-x86_64-gcc</code>
      <p>Для управления пакетами MSYS2 использует пакетный менеджер Packman. И данная команда говорит пакетному менелжеру packman установить пакет mingw-w64-ucrt-x86_64-gcc, который представляет набор компиляторов GCC (название устанавливаемого пакета указывается после параметра -S).</p>
    </li>
    <li>
      <p>и после завершения установки мы можем приступать к программированию на языке Си. Если мы откроем каталог установки и зайдем в нем в папку C:\msys64\ucrt64\bin, то найдем там все необходимые файлы компиляторов:</p>
      <p>В частности, файл gcc.exe как раз и будет представлять компилятор для языка Си.</p>
    </li>
    <li>Далее для упрощения запуска компилятора мы можем добавить путь к нему в Переменные среды. Для этого можно в окне поиска в Windows ввести "изменение переменных среды текущего пользователя":</li>
    <li>Нам откроется окно Переменные среды:</li>
    <li>И добавим путь к компилятору C:\msys64\ucrt64\bin:</li>
    <li>Чтобы убедиться, что набор компиляторов GCC успешно установлен, введем следующую команду:
      <code>gcc --version</code>
      <p>В этом случае нам должна отобразиться версия компиляторов</p>
    </li>
  </ul>

  <h4>Создание первой программы</h4>

  <p>Итак, компилятор установлен, и теперь мы можем написать первую программу. Для этого потребуется любой текстовый редактор для набора исходного кода. Можно взять распространенный редактор Visual Studio Code или даже обычный встроенный Блокнот.</p>
  <p>Итак, создадим на жестком диске папку для исходных файлов. А в этой папке создадим новый файл, который назовем hello.c.</p>
  <p>В моем случае файл hello.c находится в папке C:\c.</p>
  <p>Теперь определим в файле hello.c простейший код, который будет выводить строку на консоль:</p>
<pre>
#include &lt;stdio.h&gt;            // подключаем заголовочный файл stdio.h

int main(void)                      // определяем функцию main
{                                   // начало функции
  printf("Hello METANIT.COM!\n");   // выводим строку на консоль
  return 0;                         // выходим из функции
}                                   // конец функции
</pre>
  <p>Для вывода строки на консоль необходимо подключить нужный функционал. Для этого в начале файла идет строка</p>
  <code>#include &lt;stdio.h&gt;</code>

  <p>Директива include подключает заголовочный файл stdio.h, который содержит определение функции printf, которая нужна для вывода строки на консоль.</p>

  <p>Далее идет определение функции int main(void). Функция main должна присутствовать в любой программе на Си, с нее собственно и начинается выполнение приложения.</p>

  <p>Ключевое слово int в определении функции int main(void) говорит о том, что функция возвращает целое число. А слово void в скобках указывает, что функция не принимает параметров.</p>

  <p>Тело функции main заключено в фигурные скобки {}. В теле функции происходит вывод строки на консоль с помощью функции printf, в которую передается выводимая строка "Hello METANIT.COM!".</p>

  <p>В конце осуществляем выход из функции с помощью оператора return. Так как функция должна возвращать целое число, то после return указывается число 0. Ноль используется в качестве индикатора успешного завершения программы.</p>

  <p>После каждого действия в функции ставятся точка с запятой.</p>
  <p>Теперь скомпилируем этот файл. Для этого откроем командную строку Windows и вначале с помощью команды cd перейдем к папке с исходным файлом:</p>
  <code>cd C:\c</code>
  <p>Чтобы скомпилировать исходный код, необходимо компилятору gcc передать в качестве параметра файл hello.c:</p>
  <code>gcc hello.c</code>
  <p>После этого будет скомпилирован исполняемый файл, который в Windows по умолчанию называется a.exe. И мы можем обратиться к этому файлу</p>
  <code>a.exe</code>
  <p>и в этом случае консоль выведет строку "Hello METANIT.COM!", собственно как и прописано в коде.</p>
  <p>Стоит отметить, что мы можем переопределить имя компилируемого файла с помощью флага -o и передав ему имя файла, в который будет компилироваться программа. Например:</p>
  <code>gcc hello.c -o hello.exe</code>
  <p>В этом случае программа будет компилироваться в файл hello.exe, который мы также запустить.</p>
  <p>Чтобы не приходилось вводить две команды: одну для компиляции программы и другую для ее запуска, мы можем объединить команды:</p>
  <code>gcc hello.c -o hello.exe & hello</code>
  <p>Эта команда сначала компилирует код в файл hello.exe, а потом сразу запускает его.</p>
</article>


<!-- 1.3 Компилятор Clang. Первая программа на Windows -->
<article class="article">
  <div class="anchor" id="p1.3"></div>
  <h3>1.3 Компилятор Clang. Первая программа на Windows</h3>

  <h4>Установка Clang</h4>

  <p>Одним из наиболее распространенных компиляторов для языка C является компилятор Clang, который развивается в рамках проекта LLVM. Рассмотрим создание первой простейшей программы на C с помощью Clang под ОС Windows.</p>

  <p>Прежде всего нам надо установить непосредственно сам компилятор. Clang развивается в рамках проекта LLVM, репозиторий которого можно найти на github: <a href="https://github.com/llvm/llvm-project">https://github.com/llvm/llvm-project</a>. И данный проект предоставляет готовый установщик компилятора под Windows</p>

  <p>Для загрузки установщика под Windows перейдем на страницу релизов в данном репозитории по ссылке <a href="https://github.com/llvm/llvm-project/releases/">https://github.com/llvm/llvm-project/releases/</a></p>

  <p>По умолчанию в самом верху будут ссылки на самую последнюю версию. Но по умолчанию ссылка на установщик для Windows может быть скрыта. В этом случае под набором ссылок необходимо нажать на ссылку Show All assets. И среди появившихся ссылок найдем пункт LLVM-XX.X.X-win64.exe, где XX.X.X - это версия. Например, в моем случае это файл LLVM-18.1.0-win64.exe</p>

  <p>Это версия для 64-битной версии Windows. Если ОС 32-х битная, то необходимо загрузить файл LLVM-18.1.0-win32.exe</p>
  <ol>
    <li>После загрузки запустим файл.</li>
    <li>На стартовом экране программы нажмем на кнопку "Далее". Затем надо будет принять лицензионное соглашение</li>
    <li>Далее надо будет указать опции установки: Чтобы при компиляции не указывать полные пути к компилятору или вручную не добавлять путь к нему в переменные среды выберем на этом окне пункт Add LLVM to the system PATH for current user</li>
    <li>На следующем окне укажем папку для установки. Можно оставать путь по умолчанию - "C:/Program Files/LLVM":</li>
    <li>На следующих окнах оставим все опции по умолчанию и запустим процесс установки. После успешной установки мы можем приступать к использованию Clang</li>
  </ol>
  <p>Чтобы проверить установку Clang, в терминале/командной строке следует ввести команду</p>
  <code>clang --version</code>
  <p>В этом случае нам должна отобразиться базовая информация о компиляторе, типа версии и т.д.:</p>

  <h4>Первая программа</h4>

  <p>После завершения установки если мы откроем каталог C:\Program Files\LLVM\bin, то найдем там все необходимые файлы компиляторов:</p>
  <p>В частности, файл clang.exe предназначен для компиляции программы на языке Си.</p>

  <h4>Создание первой программы</h4>

  <p>Итак, компилятор установлен, и теперь мы можем написать первую программу. Для этого потребуется любой текстовый редактор для набора исходного кода. Можно взять распространенный редактор Visual Studio Code или даже обычный встроенный Блокнот.</p>
  <p>Итак, создадим на жестком диске папку для исходных файлов. А в этой папке создадим новый файл, который назовем hello.c.</p>
  <p>В моем случае файл hello.c находится в папке C:\c.</p>
  <p>Теперь определим в файле hello.c простейший код, который будет выводить строку на консоль:</p>
<pre>
#include &lt;stdio.h&gt;

int main(void) {
  printf("Hello METANIT.COM!\n");
  return 0;
}
</pre>
  <p>Для вывода строки на консоль необходимо подключить нужный функционал. Для этого в начале файла идет строка</p>
  <code>#include &lt;stdio.h&gt;</code>
  <p>Директива include подключает заголовочный файл stdio.h, который содержит определение функции printf, которая нужна для вывода строки на консоль.</p>

  <p>Далее идет определение функции int main(void). Функция main должна присутствовать в любой программе на Си, с нее собственно и начинается выполнение приложения.</p>

  <p>Ключевое слово int в определении функции int main(void) говорит о том, что функция возвращает целое число. А слово void в скобках указывает, что функция не принимает параметров.</p>

  <p>Тело функции main заключено в фигурные скобки {}. В теле функции происходит вывод строки на консоль с помощью функции printf, в которую передается выводимая строка "Hello METANIT.COM!".</p>

  <p>В конце осуществляем выход из функции с помощью оператора return. Так как функция должна возвращать целое число, то после return указывается число 0. Ноль используется в качестве индикатора успешного завершения программы.</p>

  <p>После каждого действия в функции ставятся точка с запятой.</p>
  <p>Теперь скомпилируем этот файл. Для этого откроем командную строку Windows и вначале с помощью команды cd перейдем к папке с исходным файлом:</p>
  <code>cd C:\c</code>
  <p>Чтобы скомпилировать исходный код, необходимо компилятору clang передать в качестве параметра файл hello.c:</p>
  <code>clang hello.c -o hello.exe</code>
  <p>Дополнительный необязательный параметр -o hello.exe указывает, что скомпилированный файл будет называться hello.exe. Если не указать этот параметр, то файл будет называться по умолчанию - a.exe.</p>
  <p>После выполнения этой команды будет скомпилирован исполняемый файл, который в Windows по умолчанию называется hello.exe. И мы можем обратиться к этому файлу, и в этом случае консоль выведет строку "Hello METANIT.COM!", собственно как и прописано в коде.</p>
  <p>Если вместо командной строки используется оболочка PowerShell, то для запуска файла надо прописать "./hello".</p>
</article>


<!-- 1.4 GCC. Первая программа на Linux -->
<article class="article">
  <div class="anchor" id="p1.4"></div>
  <h3>1.4 GCC. Первая программа на Linux</h3>

  <p>Рассмотрим создание первой программы на Linux, в частности, в среде Ubuntu. Как правило, многие дистрибутивы Linux, в том числе и Ubuntu, уже по умолчанию содержат установленный компилятор gcc, который мы сразу же можем использовать. Но даже если вдруг он не установлен, то его можно доустановить в терминале через команду:</p>
  <code>sudo apt-get install gcc</code>
  <p>В остальном, если мы будем использовать для компиляции компилятор GCC, все будет аналогично созданию программы на Windows.</p>
  <p>Определим в файловой системе каталог для исходных файлов с кодом на Си и создадим в нем новый файл hello.c со следующим кодом:</p>
<pre>
#include &lt;stdio.h&gt;

int main(void) {
  printf("Hello METANIT.COM!\n");
  return 0;
}
</pre>
  <p>И это тот же код, что был в случае с Windows, потому что программы на Си на уровне исходного кода в большей степени обладают переносимостью.</p>
  <p>Чтобы вывести строку на консоль, необходимо подключить подключает заголовочный файл stdio.h с помощью директивы include.</p>
  <code>#include &lt;stdio.h&gt;</code>
  <p>Этот заголовочный файл содержит определение функции printf, которая нужна для вывода строки на консоль.</p>
  <p>Далее идет определение функции int main(void) - главной функции, которая должна присутствовать в любой программе на Си. С нее собственно и начинается выполнение приложения.</p>
  <p>Ключевое слово int в определении функции int main(void) говорит о том, что функция возвращает целое число. А слово void в скобках указывает, что функция не принимает параметров. А все содержимое функции заключается в фигурные скобки.</p>
  <p>В самой функции происходит вывод строки на консоль с помощью функции printf, в которую передается выводимая строка "Hello world!".</p>
  <p>В конце осуществляем выход из функции с помощью оператора return. Так как функция должна возвращать целое число, то после return указывается число 0. Ноль используется в качестве индикатора успешного завершения программы.</p>
  <p>Перейдем к терминалу и вначале с помощью команды cd перейдем к каталогу, где расположен файл с исходным кодом.</p>
  <p>Далее для компиляции программы введем команду</p>
  <code>gcc hello.c</code>
  <p>В итоге в папке с файлом hello.c появился скомпилированный файл, который по умолчанию называется a.out. Запустим его с помощью следующей команды:</p>
  <code>./a.out</code>
  <p>И на консоль будет выведена сакральная строка "Hello World!".</p>
</article>


<!-- 1.5 Clang. Первая программа на MacOS -->
<article class="article">
  <div class="anchor" id="p1.5"></div>
  <h3>1.5 Clang. Первая программа на MacOS</h3>

  <p>Для компиляции программы на Си в MacOS одним из наиболее популярных компиляторов является Clang (стоит отметить, что clang может также применяться для компиляции программы на C++ и Objective-C). Считается, что clang работает быстрее и потребляет меньше памяти, чем GCC. Для работы с clang в MacOS необходимо установить утилиту Xcode Command Line Tools. Самой простой способ установить эту утилиту - установить сам XCode, с которым автоматически устанавливается и Xcode Command Line Tools.</p>
  <p>Для работы определим в файловой системе каталог для исходных файлов с кодом на Си и создадим в нем новый файл hello.c со следующим кодом:</p>
<pre>
#include &lt;stdio.h&gt;

int main(void) {
  printf("Hello METANIT.COM!\n");
  return 0;
}
</pre>
  <p>Этот код аналогичен тому, что применялся в случае с Windows и Linux.</p>
  <p>Чтобы вывести строку на консоль, необходимо подключить заголовочный файл stdio.h с помощью директивы include.</p>
  <code>#include &lt;stdio.h&gt;</code>
  <p>Этот заголовочный файл содержит определение функции printf, которая нужна для вывода строки на консоль.</p>
  <p>Далее идет определение функции int main(void) - главной функции, которая должна присутствовать в любой программе на Си. С нее собственно и начинается выполнение приложения.</p>
  <p>Ключевое слово int в определении функции int main(void) говорит о том, что функция возвращает целое число. А слово void в скобках указывает, что функция не принимает параметров. А все содержимое функции заключается в фигурные скобки.</p>
  <p>В самой функции происходит вывод строки на консоль с помощью функции printf, в которую передается выводимая строка "Hello METANIT.COM!".</p>
  <p>В конце осуществляем выход из функции с помощью оператора return. Так как функция должна возвращать целое число, то после return указывается число 0. Ноль используется в качестве индикатора успешного завершения программы.</p>
  <p>Перейдем к терминалу и вначале с помощью команды cd перейдем к каталогу, где расположен файл с исходным кодом.</p>
  <p>Далее для компиляции программы введем команду</p>
  <code>clang hello.c</code>
  <p>В итоге в папке с файлом hello.c появился скомпилированный файл, который по умолчанию называется a.out. Запустим его с помощью следующей команды:</p>
  <code>./a.out</code>
  <p>И на консоль будет выведена строка "Hello METANIT.COM!".</p>
  <p>При компиляции с помощью флага -o можно задать имя выходного файла:</p>
  <code>clang hello.c -o app</code>
  <p>В этом случае будет компилироваться файл app, который также будет находиться в папке с файлом hello.c. И в этом случае мы его можем запустить следующим образом:</p>
  <code>./app</code>
</article>


<!-- 1.6 Настройка параметров компиляции -->
<article class="article">
  <div class="anchor" id="p1.6"></div>
  <h3>1.6 Настройка параметров компиляции</h3>

  <h4>Параметры компилятора gcc</h4>

  <p>По умолчанию при компиляции не отображается никакх предупреждений. Тем не менее предупреждения компилятора могут подсказать о наличие определенных проблем в коде, даже если код успешно компилируется. Простейший пример: в программе определена переменная, но она нигде не используется. И при компиляции компилятор может подсказать о данной пробелеме, что поможет разработчику идентифицировать проблему и сразу отреагировать на нее.</p>
  <p>Для компиляции с предупреждениями применяется флаг -Wall:</p>
  <code>gcc -Wall source.c</code>
  <p>Есть разные версии стандарта языка Си, и каждый из них может добавлять дополнительный функционал, который мы, возможно, захотим использовать в программе. С помощью флага -std= можно указать конкретный стандарт, добавив c99, c11 или c17. Например, для компиляции в стандарт c99 нужно написать:</p>
  <code>gcc -std=c99 source.c</code>
  <p>Аналогично для компиляции в стандарт C11 используется команда:</p>
  <code>gcc -std=c11 source.c</code>
  <p>Чтобы гарантировать, что программа будет строго соответствовать определенному стандарту, можно указать флаг -pedantic</p>
<pre>
gcc -std=c99 -Wall -pedantic source.c
gcc -std=c11 -Wall -pedantic source.c
gcc -std=c17 -Wall -pedantic source.c
gcc -std=c23 -Wall -pedantic source.c
</pre>
  <p>В этом случае компилятор будет генерировать предупреждения, если код не соответствует правилам стандарта.</p>
  <p>Для того, чтобы автоматически запустить приложение после компиляции, можно использовать следующую команду:</p>
  <code>gcc source.c & ./a.out</code>
  <p>Можно налепить в одну команду различные опции:</p>
  <code>gcc -std=c17 -Wall -pedantic app.c -o app.exe & app</code>
  <p>Опция -S позволяет сгенерировать файл с ассемблерным кодом:</p>
  <code>gcc app.c -S</code>
  <p>В данном случае по содержимому app.c будет сгенерирован файл, который называется как и исходный файл, только имеет расширение .s, то есть в данном случае будет сгенерирован файл app.s. Этот файл будет содержать код на ассемблере, причем в качестве синтаксиса применяется синтаксис ассемблера GAS (ассемблера от GNU).</p>

  <h4>Параметры компилятора clang</h4>

  <p>Основные параметры компилятора Clang в ряде случаев повторяют параметры для gcc. Например, компиляция с помощью Clang под определенный стандарт с выводом ошибок:</p>
  <code>clang -std=c17 -Wall -pedantic app.c -o app.exe & app.exe</code>
</article>


<!-- 1.7 Локализация и кириллица в консоли -->
<article class="article">
  <div class="anchor" id="p1.7"></div>
  <h3>1.7 Локализация и кириллица в консоли</h3>

  <p>При использовании кириллических символов мы можем столкнуться с ситуацией, когда вместо кириллических символов отображаются непонятные знаки. Особенно это актуально для ОС Windows. И в этом случае необходимо явным образом задать текущую локаль (культуру) для вывода символов. В Си это делается с помощью функции setlocale(), определение которой имеется в заголовочном файле locale.h.</p>
  <p>Итак, изменим код, который использовался в прошлых темах следующим образом:</p>
<pre>
#include &lt;stdio.h&gt;

int main(void) {
  printf("Привет мир!\n");
  return 0;
}
</pre>
  <p>Компиляция и запуск в ОС Windows может выглядеть следующим образом:</p>
<pre>
c:\C>gcc hello.c -o hello & hello
╧ЁштхЄ ьшЁ!
</pre>
  <p>Вместо русских слов я получаю непонятные символы, и это не то, что ожидалось. Теперь изменим код, применив функцию setlocale:</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;locale.h&gt;

int main(void) {
  char *locale = setlocale(LC_ALL, "");

  printf("Привет мир!\n");
  return 0;
}
</pre>
  <p>Поскольку функция setlocale определена в файле locale.h, то он подключается с помощью директивы #include &lt;locale.h&gt;.</p>
  <p>Повторно компилируем и запустим приложение:</p>
<pre>
c:\C>gcc hello.c -o hello & hello
Привет мир!
</pre>
  <p>Стоит отметить, что в качестве кодировки текстового файла в этом случае должна использоваться кодировка ANSI или Windows-1251, но не UTF-8.</p>
  <p>На некоторых платформах, например, Ubuntu/MacOS, мы можем не столкнуться с подобной проблемой. И в этом случае вызов функции setlocale просто не окажет никакого влияния.</p>
</article>


<!-- 2 Основы языка Си -->
<!-- 2.1 Структура программы на Си -->
<article class="article">
  <div class="anchor" id="p2.1"></div>
  <h3>2 Основы языка Си</h3>
  <h3>2.1 Структура программы на Си</h3>

  <p>Программа на языке Си состоит из набора директив препроцессора, определений функций и глобальных объектов. Директивы препроцессора управляют преобразованием текста до его компиляции. Глобальные объекты определяют используемые данные или состояние программы. А функции определяют поведение или действия программы. Простейшая программа на Си, которая была определена в прошлых темах:</p>
<pre>
#include &lt;stdio.h&gt;

int main(void) {
  printf("Hello METANIT.COM!\n");
  return 0;
}
</pre>

  <h4>Инструкции</h4>
  <p>Простейшим строительным элементом программы на Си являются инструкции (statements). Каждая инструкция выполняет определенное действие. В конце инструкций в языке Си ставится точка с запятой (;). Данный знак указывает компилятору на завершение инструкции. Например:</p>
  <code>printf("Hello METANIT.COM!");</code>
  <p>Вызов функции printf, которая выводит на консоль строку "Hello METANIT.COM!" является инструкцией и завершается точкой с запятой.</p>
  <p>Набор инструкций может представлять блок кода. Блок кода оформляется фигурными скобками, инструкции, составляющие тело этого блока, помещаются между открывающей и закрывающей фигурными скобками:</p>
<pre>
{
  printf("Hello METANIT.COM!");
  printf("Bye world!");
}
</pre>
  <p>В этом блоке кода две инструкции. Обе инструкции представляют вызов функции printf() и выводят определенную строку на консоль.</p>

  <h4>Директивы препроцессора</h4>

  <p>Для вывода данных на консоль в примере выше используется функция printf(), но чтобы использовать эту функцию, чтобы она вообще стала нам доступна в программе на Си, необходимо в начале файла с исходным кодом подключать заголовочный файл stdio.h с помощью директивы include.</p>
  <p>Директива include является директивой препроцессора. Кроме данной include есть еще ряд директив препроцессора, например, define.</p>
  <p>Каждая директива препроцессора размещается на одной строке. И в отличие от обычных инструкций языка Си, которые завершаются точкой с запятой ; , признаком завершения препроцессорной директивы является перевод на новую строку. Кроме того, директива должна начинаться со знака решетки #.</p>
  <p>Непосредственно директива "include" определяет, какие файлы надо включить в данном месте в текст программы. По умолчанию мы можем подключать стандартные файлы из каталога так называемых "заголовочных файлов", которые обычно поставляются вместе со стандартными библиотеками компилятора. И файл "stdio.h" как раз является одним из таких заголовочных файлов.</p>
  <p>Вообще сам термин "заголовочный файл" (header file) предполагает включение текста файла именно в начало или заголовок программы. Поэтому заголовочные файлы подключаются, как правило, в начале исходного кода. Кроме того, заголовочный файл должен быть подключен до вызова тех функций, которые он определяет. То есть, к примеру, файл stdio.h хранит определение функции printf, поэтому этот файл необходимо подключить до вызова функции printf.</p>
  <p>Но в целом директивы препроцессора необязательно должны быть размещены в начале файла.</p>

  <p>При компиляции исходного кода вначале срабатывает препроцессор, который сканирует исходный код на наличие строк, которые начинаются с символа #. Эти строки расцениваются препроцессором как директивы. И на месте этих директив происходит преобразование текста. Например, на месте директивы #include &lt;stdio.h&gt; вставляется код из файла stdio.h.</p>

  <h4>Функция main</h4>

  <p>Стартовой точкой в любую программу на языке Си является функция main(). Именно с этой функции начинается выполнение приложения. Ее имя main фиксировано и для всех программ на Си всегда одинаково.</p>
  <p>Функция также является блоком кода, поэтому ее тело обрамляется фигурными скобками, между которыми идет набор инструкций.</p>
  <p>Стоит отметить, что в разной литературе и примерах можно встретить модификации этой функции. В частности, вместо определения выше мы могли бы написать по другому:</p>
<pre>
#include &lt;stdio.h&gt;

void main() {
  printf("Hello METANIT.COM!\n");
}
</pre>
<pre>
#include &lt;stdio.h&gt;

int main() {
  printf("Hello METANIT.COM!\n");
  return 0;
}
</pre>
  <p>Использование этих определений не было бы ошибкой, и программа также вывела бы строку "Hello METANIT.COM" на консоль. И для большинства компиляторов это было бы нормально.</p>

  <h4>Комментарии</h4>

  <p>Программа может сопровождаться комментариями. Комментарии содержат описание программы, характеристики кода. При компиляции комментарии не учитываются и не оказывают никакого влияние на работу программы. В то же время они дают программисту понимание того, как работает код.</p>
  <p>В Си можно использовать два типа комментариев: блочный и строчный. Блочный заключается между символами /* текст комментария */. Он может размещаться на нескольких строках. Например:</p>
<pre>
#include &lt;stdio.h&gt;

/* Функция main выводит
на консоль строку Hello World */
int main() {
  printf("Hello METANIT.COM! \n");
  return 0;
}
</pre>
  <p>Строчный комментарий помещается на одной строке после двойного слеша:</p>
<pre>
#include &lt;stdio.h&gt;

int main() { // Функция main
  printf("Hello METANIT.COM! \n");
  return 0;
}
</pre>
</article>


<!-- 2.2 Переменные -->
<article class="article">
  <div class="anchor" id="p2.2"></div>
  <h3>2.2 Переменные</h3>

  <p>Для хранения данных в языке программирования Си используются переменные. Переменная может иметь тип, имя и значение.</p>
  <p>Перед использованием любую переменную надо определить. Синтаксис определения переменной выглядит следующим образом:</p>
  <code>тип_переменной имя_переменной;</code>
  <p>Например, простейшее определение переменной:</p>
  <code>int number;</code>
  <p>Здесь определена переменная number, которая имеет тип int. Поскольку определение переменной представляет собой отдельное выражение, то после него ставится точка с запятой.</p>
  <p>Имя переменной может представлять последовательность символов латинского алфавита, чисел и знака подчеркивания. При этом имя должно начинаться либо с алфавитного символа, либо со знака подчеркивания.</p>
  <code>int _number33;</code>
  <p>Нередко компиляторы имеют ограничение на длину названий переменных, например, для некоторых компиляторов длина имени переменной не должна превышать 31 символа, для других компиляторов ограничение может быть более жестким.</p>
  <p>Также стоит учитывать, что C - регистрозависимый язык, а это значит, что регистр символов имеет большое значение. То есть следующем коде будут определяться две разные переменные:</p>
<pre>
int number;
int Number;
</pre>
  <p>Поэтому переменная Number не будет представлять то же самое, что и переменная number.</p>
  <p>Кроме того, в языке есть ряд зарезервированных слов, которые не могут использоваться в качестве имени переменной. Их не так много: auto, break, case, char, const, continue, default, do, double, else, enum, extern, float, for, goto, if, int, long, register, return, short, signed, sizeof, static, struct, switch, typedef, union, unsigned, void, volatile, while.</p>
  <p>Также нельзя объявить больше одной переменной с одним и тем же именем, например:</p>
<pre>
int number;
int number;
</pre>
  <p>Подобное определение вызовет ошибку на этапе компиляции.</p>
  <p>Можно определить сразу несколько переменных:</p>
  <code>int number1, number2, number3;</code>
  <p>Здесь определены три переменных: number1, number2 и number3.</p>

  <h4>Присвоение значения</h4>

  <p>При определении переменных каждой из них присваивается неопределенное значение. Но в дальнейшем мы можем присвоить ей конкретное значение:</p>
<pre>
int number;
number = 2;
</pre>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int number;
  number = 2;
  printf("number = %d \n", number);
  return 0;
}
</pre>
  <p>Для вывода числа на консоль используется спецификатор %d, вместо которого вставляется значение переменной number. Таким образом, мы получим следующий консольный вывод:</p>
  <code>number = 2</code>
  <p>Однако также можно сразу при определении переменной дать ей некоторое начальное значение. Данный прием называется инициализацией:</p>
<pre>
#include &lt;stdio.h&gt;

int main(void) {
  int number = 2;
  printf("number = %d \n", number);
  return 0;
}
</pre>
  <p>Также можно инициализовать сразу несколько переменных:</p>
<pre>
#include &lt;stdio.h&gt;

int main(void) {
  int number1 = 1, number2 = 2, number3 = 3;
  printf("number1 = %d \n", number1);
  printf("number2 = %d \n", number2);
  printf("number3 = %d \n", number3);
  return 0;
}
</pre>
</article>


<!-- 2.3 Типы данных -->
<article class="article">
  <div class="anchor" id="p2.3"></div>
  <h3>2.3 Типы данных</h3>

  <p>Переменная имеет определенный тип. И этот тип определяет, какие значения может иметь переменная и сколько байт в памяти она будет занимать. В Си определены следующие базовые типы данных:</p>
  <ul>
    <li>char: представляет один символ. Занимает в памяти 1 байт (8 бит)</li>
    <li>unsigned char: представляет один символ. Занимает в памяти 1 байт (8 бит). Может хранить любой значение из диапазона от 0 до 255</li>
    <li>signed char: представляет один символ. Занимает в памяти 1 байт (8 бит). Может хранить любое значение из диапазона от -128 до 127</li>
    <li>short: представляет целое число в диапазоне от –32768 до 32767. Занимает в памяти 2 байта (16 бит). Имеет псевдонимы short int, signed short и signed short int.</li>
    <li>unsigned short: представляет целое число в диапазоне от 0 до 65535. Занимает в памяти 2 байта (16 бит). Имеет псевдоним unsigned short int.</li>
    <li>int: представляет целое число. В зависимости от архитектуры процессора может занимать 2 байта (16 бит) или 4 байта (32 бита). Если брать основные платформы - 64-разрядные Windows, Linux (вместе с Android) и MacOS, то размер int составляет 4 байта. Диапазон предельных значений соответственно также может варьироваться от –32768 до 32767 (при 2 байтах) или от −2 147 483 648 до 2 147 483 647 (при 4 байтах) и выше. Имеет псевдонимы signed int и signed</li>
    <li>unsigned int: представляет положительное целое число. В зависимости от архитектуры процессора может занимать 2 байта (16 бит) или 4 байта (32 бита), и из-за этого диапазон предельных значений может меняться: от 0 до 65535 (для 2 байт), либо от 0 до 4 294 967 295 (для 4 байт). Имеет псевдоним unsigned: то же самое, что и unsigned int</li>
    <li>long: представляет целое число и занимает в памяти 4 байта (32 бита) или 8 байт (64 бита). В зависимости от размера может находиться в в диапазоне от -2 147 483 648 до 2 147 483 647 (4 байта), либо в диапазоне от -9223372036854775807 до +9 223 372 036 854 775 807 (8 байт). Если брать распростренные платформы, то на 64-разрядном Windows long занимает 4 байта, а на 64-разрядных Linux/MacOS - 8 байт. Имеет псевдонимы long int, signed long int и signed long.</li>
    <li>unsigned long: представляет целое число и занимает в памяти 4 байта (32 бита) или 8 байт (64 бита). В зависимости от размера может находиться в в диапазоне от 0 до 4 294 967 295 (4 байта) или в диапазоне от 0 до 18 446 744 073 709 551 615 (8 байт). Имеет псевдоним unsigned long int.</li>
    <li>long long: представляет целое число в диапазоне от -9223372036854775807 до +9 223 372 036 854 775 807. Занимает в памяти, как правило, 8 байт (64 бита). Имеет псевдонимы long long int, signed long long int и signed long long.</li>
    <li>unsigned long long: представляет целое число в диапазоне от 0 до 18 446 744 073 709 551 615. Занимает в памяти, как правило, 8 байт (64 бита). Имеет псевдоним unsigned long long int.</li>
    <li>float: представляет вещественное число одинарной точности с плавающей точкой в диапазоне +/- 3.4E-38 до 3.4E+38. В памяти занимает 4 байта (32 бита)</li>
    <li>double: представляет вещественное число двойной точности с плавающей точкой в диапазоне +/- 1.7E-308 до 1.7E+308. В памяти занимает 8 байт (64 бита)</li>
    <li>long double: представляет вещественное число двойной точности с плавающей точкой в диапазоне +/- 3.4E-4932 до 1.1E+4932. В памяти занимает 10 байт (80 бит). На некоторых системах может занимать 96 и 128 бит.</li>
    <li>void: тип без значения</li>
  </ul>

  <h4>Целочисленные типы</h4>

  <p>Наиболее распространенным целочисленным типом является int (имеет псевдонимы signed int и signed), представляет целое число со знаком и обычно занимает 4 байта. Переменной такого типа можно передать целое число:</p>
<pre>
int age = 38;
signed int number = 2;
signed temps = -3;
</pre>
  <p>Для определения переменной некоторого типа можно использовать все псевдонимы этого типа. Так, в примере выше определяются три переменных типа int, хотя в каждом случае используются разные псевдонимы типа: int, signed int и signed.</p>

  <h4>Суффиксы целочисленных типов</h4>

  <p>Стоит учитывать, что любое десятичное число рассматривается по умолчанию как значение типов int/long int/long long int (в зависимости от размера) и при присвоении переменным другим типов будет выполняться преобразование. Чтобы указать, что число явным образом представляет определенный тип, к числу добавляется определенный суффикс:</p>
  <ul>
    <li>u или U, unsigned int, unsigned long int и unsigned long long int</li>
    <li>ul или UL, unsigned long int и unsigned long long int</li>
    <li>ll или LL, long long int</li>
    <li>ull или ULL, unsigned long long int</li>
  </ul>
  <p>Как видно, не для всех типов есть отдельные суффиксы. И для некоторых типов можно применять несколько суффиксов. Применим суффикс. Например, если надо хранить только положительные числа, то можно взять тип unsigned int. Для определения чисел этого типа применяется суффикс u или U:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
    unsigned number1 = 4294967294u;
    unsigned int number2 = 22U;
    printf("number1 = %u\n", number1);
    printf("number2 = %u\n", number2);
    return 0;
}
</pre>
  <p>При выводе таких чисел на консоль применяется спецификатор %u.</p>
  <p>Стоит отметить, что мы могли бы присвоить переменной число и без суффикса и получили бы тот же самый результат:</p>
<pre>
unsigned number1 = 4294967294;  // без суффикса u
unsigned int number2 = 22;      // без суффикса u
printf("number1 = %u\n", number1);
printf("number2 = %u\n", number2);
</pre>
  <p>Зачем же нужен данный суффикс? Без этого суффикса десятичное число рассматривается как значение типов int/long int/long long int и при присвоении переменной типа unsigned int выполняется преобразование. Используя суффикс, мы можем избежать ненужного преобразования.</p>
  <p>Пример определения данных других типов:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  unsigned short number1 = 1u;
  unsigned short int number2 = 2u;
  short number3 = 3;
  short int number4 = -4;
  signed short number5 = 5;
  signed short int number6 = -6;

  long number7 = -2147483648l;
  long int number8 = -2147483648L;
  signed long number9 = 2147483647l;
  signed long int number10 = 2147483647L;

  unsigned long number11 = 4294967295ul;
  unsigned long int number12 = 4294967295UL;

  long long number13 = -9223372036854775807ll;
  long long int number14 = 9223372036854775807ll;
  signed long long number15 = -9223372036854775807LL;
  signed long long int number16 = 9223372036854775807LL;

  unsigned long long number17 = 18446744073709551615ull;
  unsigned long long int number18 = 18446744073709551615ULL;

  printf("number1 = %hu\n", number1);
  printf("number2 = %hu\n", number2);
  printf("number3 = %d\n", number3);
  printf("number4 = %d\n", number4);
  printf("number5 = %d\n", number5);
  printf("number6 = %d\n", number6);
  printf("number7 = %ld\n", number7);
  printf("number8 = %ld\n", number8);
  printf("number9 = %ld\n", number9);
  printf("number10 = %ld\n", number10);
  printf("number11 = %lu\n", number11);
  printf("number12 = %lu\n", number12);
  printf("number13 = %lld\n", number13);
  printf("number14 = %lld\n", number14);
  printf("number15 = %lld\n", number15);
  printf("number16 = %lld\n", number16);
  printf("number17 = %llu\n", number17);
  printf("number18 = %llu\n", number18);
  return 0;
}
</pre>
  <p>Обратите внимание на спецификатор, который используется для вывода числа на консоль в функции printf():</p>
  <ul>
    <li>hu, unsigned short</li>
    <li>ld, long</li>
    <li>lu, unsigned long</li>
    <li>lld, long long</li>
    <li>llu, unsigned long long</li>
  </ul>

  <h4>Определение чисел в различных системах</h4>

  <p>Си позволяет определять числа в разных числовых системых. Числа в двоичной системе начинаются с символов 0b, после которых идет набор 1 и 0, которые представляют число. Восьмеричные числа начинаются с числа 0, за которым могут идти цифры от 0 до 7. Щестнадцатеричные числа начинаются с 0x или 0X, за которыми следуют шестнадцатеричные цифры от 0 до 9 и от A до F. Например:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int code1 = 0b1011;     // двоичная система - число 11
  int code2 = 013;        // восьмеричная система - число 11
  int code3 = 11;        // десятичная система - число 11
  int code4 = 0xB;        // шестнадцатеричная система - число 11
  printf("code1 = %d\n", code1);    //  code1 = 11
  printf("code2 = %d\n", code2);    //  code2 = 11
  printf("code3 = %d\n", code3);    //  code3 = 11
  printf("code4 = %d\n", code4);    //  code4 = 11
  return 0;
}
</pre>
  <p>В данном случае определены четыре переменных, но каждая из них хранит одно и то же число - 11, записанное в разных системах исчисления.</p>
  <p>При этом при определении переменных важно понимать, что значение переменной не должно выходить за те пределы, которые очерчены для ее типа. Например:</p>
  <code>unsigned short int number = -65535;</code>
  <p>Компилятор GCC при компиляции программы с этой строкой выдаст ошибку о том, что значение -65535 не входит в диапазон допустимых значений для типа unsigned short int.</p>

  <h4>Числа с плавающей точкой</h4>

  <p>Числа с плавающей точкой представлены тремя типами: float, double, long double. В качестве разделителя между целой и дробной частями применяется точка. По умолчанию все дробные числа представляют тип double, который занимает 8 байт:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  double number = 3.14159;
  printf("number = %f\n", number);
  return 0;
}
</pre>
  <p>Для вывода значения double на консоль используется спецификаторы f и lf. Чтобы указать, что число представляет тип float, применяется суффикс f, а для long double - суффикс l:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  float number1 = 3.14f;
  long double number2 = 123456.789l;
  printf("number1 = %f\n", number1);
  printf("number2 = %Lf\n", number2);
  return 0;
}
</pre>
  <p>Стоит отметить, что для вывода данных типа long double на консоль применяется спецификатор Lf, однако на некоторых платформах он может работать некорректно, например, показывать 0.</p>

  <h4>Символы</h4>

  <p>В Си представлены тремя типами: char, signed char и unsigned char. В реальности для работы с символами применяется тип char. Сразу может возникнуть вопрос: этот тип знаковый или беззнаковый? Данный момент не определяется стандартом и оставлен на усмотрение разработчиков компиляторов и зависит от конкретной реализации. Однако, как правило, тип char определяется как тип со знаком и соответственно имеет диапазон значений от -128 до 127. (В частности, так определено в стандарте System V ABI, который определяет общие правила для Unix-систем (в том числе и Linux))</p>
  <p>В качестве значений для даного типа применяются символьные литералы - символы в одинарных кавычках. Например, мы можем присвоить переменной этого типа символ в одинарных кавычках:</p>
  <code>char letter = 'A';</code>
  <p>Здесь определяется переменная letter, которая хранит символ 'A'. Однако в реальности переменная типа char хранит число. И когда переменной присваивается символ, она получает числовой код этого символа из таблицы, которая сопоставляет числовые коды и символы. Наиболее распространена таблица ASCII. Она сопоставляет символы с числами от 0 до 127. Например, возьмем выше определенную переменную letter и выведем ее содержимое на консоль:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char letter = 'A';
  printf("letter: %d \n", letter);    // letter: 65
  printf("letter: %c \n", letter);    // letter: A
  return 0;
}
</pre>
  <p>Числовой код символа 'A' в таблице ASCII равен 65. Для наглядности в программе два раза выводим значение переменной letter. Но в первом случае используем спецификатор %d для вывода числового кода символа, а во втором случае применяется спецификатор %c, который позволяет вывести на консоль сам символ. То есть при выполнении программа выведет на консоль:</p>
<pre>
letter: 65
letter: A
</pre>
  <p>Вместо символа в одинарных кавычках мы могли бы присвоить напрямую числовой код:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char letter = 65;
  printf("letter: %d \n", letter);    // letter: 65
  printf("letter: %c \n", letter);    // letter: A
  return 0;
}
</pre>
  <p>И мы получили бы тот же самый результат.</p>
  <p>Стоит отметить, что символы в одинарных кавычках - это данные типа int.</p>

  <h4>typedef</h4>

  <p>Оператор typedef позволяет определить для определенного типа псевдоним. Это может потребоваться, например, когда название некоторого типа довольно большое, и мы хотим его сократить.</p>
  <p>Общая форма оператора</p>
  <code>typedef существующий_тип псевдоним</code>
  <p>Например, зададим для типа unsigned char псевдоним BYTE:</p>
  <code>typedef unsigned char BYTE;</code>
  <p>И мы сможем использовать этот тип как и любой другой:</p>
<pre>
#include &lt;stdio.h&gt;

typedef unsigned char BYTE;

int main() {
  BYTE byte = 22;
  printf("byte = %d", byte);
}
</pre>

  <h4>Размер типов данных</h4>

  <p>В выше приведенном списке для каждого типа указан размер, который он занимает в памяти. Однако стоит отметить, что предельные размеры для типов разработчики компиляторов могут выбирать самостоятельно, исходя из аппаратных возможностей компьютера. Стандарт устанавливает лишь минимальные значения, которые должны быть. Например, для типов int и short минимальное значение - 16 бит, для типа long - 32 бита. При этом размер типа long должен быть не меньше размера типа int, а размер типа int - не меньше размера типа short. Но в целом для типов используются те размеры, которые указаны выше при описании типов данных.</p>
  <p>Однако бывают ситуации, когда необходимо точно знать размер определенного типа. И для этого в C есть оператор sizeof, который возвращает размер памяти в байтах, которую занимает выражение или тип.</p>
  <p>Чтобы получить размер типа данных этот тип помещается в скобки после sizeof:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  printf("sizeof(int): %lu\n", sizeof(int));
  printf("sizeof(long): %lu\n", sizeof(long));
  printf("sizeof(unsigned long long): %lu\n", sizeof(unsigned long long));
  return 0;
}
</pre>
  <p>В данном случае мы получаем размер для 3 типов. Так, на 64-рязрядном Linux мы получим следующий консольный вывод:</p>
<pre>
sizeof(int): 4
sizeof(long): 8
sizeof(unsigned long long): 8
</pre>
  <p>Оператор sizeof возвращает размер типа в виде значения size_t. Тип size_t фактически не является самостоятельным типом, а представляет псевдоним. Так, на 64-битном Linux size_t является псевдонимом для unsigned long. На других системах для size_t может применяться другой тип. Поэтому для работы с размерами лучше использовать псевдоним size_t, а не конкретный тип(например, unsigned long). Соответственно для вывода этого значения на консоль в функции printf применяется спецификатор %lu (long unsigned). И мы могли бы даже присвоить результат оператора другой переменной:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  size_t int_size = sizeof(int);
  printf("sizeof(int): %lu\n", int_size);
  return 0;
}
</pre>
  <p>Также sizeof может вычислять размер какого-нибудь объекта, например, переменной. Вэтом случае название объекта передается в скобки, либо может идти после оператора без скобок:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int number = 2;
  printf("sizeof(number): %lu\n", sizeof(number));
  printf("sizeof number: %lu\n", sizeof number);
  return 0;
}
</pre>
  <p>Консольный вывод:</p>
<pre>
sizeof(number): 4
sizeof number: 4
</pre>
  <p>Консоль нам показывает, что размер переменной number - 4 байта. Ведь тип переменной number - int, соответственно переменная имеет такой же размер.</p>
  <p>Кроме того, оператор sizeof может возвращать размер результата выражения. Например:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  size_t size = sizeof printf("hello METANIT.COM");
  printf("sizeof printf('hello METANIT.COM'): %lu\n", size);
  return 0;
}
</pre>
  <p>Здесь переменной size присваивается результат выражения sizeof printf("hello METANIT.COM"). Может показаться, что здесь оператор sizeof вычисляет размер выражения printf("hello METANIT.COM"). В реальности же в данном сдучае sizeof вычисляет размер результата выражения printf("hello METANIT.COM") или, если быть точным, результата функции printf(). Результат данной функции представляет тип int. Поэтому переменная size здесь равна 4. При этом, обращаю внимание, само выражение printf("hello METANIT.COM") не выполняется.</p>
  <p>Другой пример:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  size_t size = sizeof sizeof(int);
  printf("sizeof sizeof(int): %lu\n", size);
  return 0;
}
</pre>
  <p>Здесь оператор sizeof возвращает размер результата другого оператора sizeof.</p>
  <code>sizeof sizeof(int): 8</code>
</article>


<!-- 2.4 Консольный вывод. Функция printf -->
<article class="article">
  <div class="anchor" id="p2.4"></div>
  <h3>2.4 Консольный вывод. Функция printf</h3>

  <p>Для вывода на консоль в языке программирования Си зачастую применяется функция printf(). Но если с выводом простой строки особых проблем не возникает, то при выводе данных других типов есть свои особенности.</p>
  <p>Формальное определение функции printf выглядит следующим образом:</p>
  <code>printf(строка_форматирования, список_аргументов)</code>
  <p>Первый параметр представляет строку, которая может содержать произвольный текст в двойных кавычках. Например:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
    printf("Hello world!");
    return 0;
}
</pre>
  <p>Кроме стандартного текста мы можем передавать в строку специальные группы символов, которые называются управляющими последовательностями. Например</p>
  <code>\n: перевод на новую строку</code>

  <h4>Спецификации преобразования</h4>

  <p>Спецификации преобразования позволяют задать формат вывода различных типов данных. Формальное определение спецификаций преобразования выглядит следующим образом:</p>
  <code>% флаги ширина_поля.точность модификатор спецификатор</code>
  <p>Из этих компонентов обязательными являются только два % и спецификатор.</p>
  <p>Какие спецификаторы мы можем использовать:</p>
  <ul>
    <li>%c: для вывода отдельных символов (тип char)</li>
    <li>%s: для вывода строк</li>
    <li>%d: для вывода целых чисел со знаком (тип int)</li>
    <li>%i: для вывода целых чисел со знаком (тип int)</li>
    <li>%u: для вывода целых положительных чисел (тип unsigned)</li>
    <li>%f: для вывода чисел с плавающей точкой (float, double)</li>
    <li>%F: для вывода чисел с плавающей точкой в верхнем регистре (float, double)</li>
    <li>%e: для вывода экспоненциального представления чисел с плавающей точкой (float, double)</li>
    <li>%E: для вывода экспоненциального представления чисел с плавающей точкой в верхнем регистре (float, double)</li>
    <li>%g: для вывода чисел используется более короткий из форматов %e или %f</li>
    <li>%G: для вывода чисел используется более короткий из форматов %E или %F</li>
    <li>%o: для вывода восьмеричных чисел без знака</li>
    <li>%x: для вывода шестнадцатеричных чисел</li>
    <li>%X: для вывода шестнадцатеричных чисел в верхнем регистре</li>
    <li>%%: для вывода знака процента</li>
  </ul>
  <p>Применим несколько спецификаторов:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  float r = 71.8986;
  printf("x = %f \n", r);
  printf("x = %e \n", r);

  char symbol = 'r';
  printf("symbol = %c \n", symbol);

  unsigned int number = 23;
  printf("number = %u \n", number);

  printf("%s \n", "Hello Word 2013");
  return 0;
}
</pre>
  <p>Значения для спецификаторов передаются через аргумент, который идет вторым параметром в функции printf.</p>
  <p>Консольный вывод:</p>
<pre>
x = 71.898598
x = 7.189860e+001
symbol = r
number = 23
Hello Word 2013
</pre>
  <p>Для вывода числовых значений с плавающей точкой мы можем использовать ширину поля и точность. Ширина поля представляет целое положительное число, которое определяет длину выводимого значения в символах. Точность - это также целое положительное число, которое определяет количество цифр в дробной части. Например:</p>
<pre>
float r = 71.8986;
printf("x = %4.2f \n", r);  // 71.90
</pre>
  <p>Здесь спецификация преобразования представляет строку "%4.2f", где "4" - ширина поля (для вывода числа будут использоваться 4 цифры), а "2" - точность (2 цифры в дробной части).</p>
  <p>Модификаторы позволяют конкретизировать выводимое значение. Используются следующие модификаторы:</p>
  <ul>
    <li>h: для вывода значений short int</li>
    <li>l: для вывода значений long int и unsigned long int</li>
    <li>ll: для вывода значений long long int и unsigned long long int</li>
    <li>L: для вывода значений long double</li>
  </ul>
<pre>
short r = 7100;
printf("x = %hd", r);
</pre>
  <p>Необязательно передавать по одному значению для вывода в функцию printf. Мы можем передавать множество значений:</p>
  <code>printf("Name=%s \t Age=%d \t Weight=%3.2f", "Tom", 23, 63.3456);</code>
  <p>Первый спецификатор в строке форматирования - "%s", и для него значение будет поставляться первым аргументом - строкой "Tom". Второй спецификатор - "%d", для него значение берется из второго аргумента - числа 23. И так далее.</p>
  <p>Дополнительно можно использовать флаги, которые дополнительно позволяют управлять форматированием вывода:</p>
  <ul>
    <li>-: указывает, что выравнивание будет идти от левого края (по умолчанию используется выравнивае справа).</li>
    <li>+: если выводимое значение имеет знак (+ или -), то оно выводится. Без данного флага знак выводится только в случае отрицательного значения.</li>
    <li>пробел: вставляет пробел на месте знака перед положительными числами</li>
    <li>#: при использовании со спецификаторами "o", "x", "X" значение числа выводится с предшествующими символами 0, 0x или 0X. При использовании со спецификаторами "f", "g", "G" десятичная точка будет выводиться, даже если в числе нет дробной части</li>
  </ul>
  <p>Пример использования флагов:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  printf("%d \n", 8);
  printf("% d \n", 8);
  printf("%+d \n", +8);
  printf("%#o \n", 8);
  printf("%#f \n", 8.);

  printf("%9s %d \n", "Tom", 38);
  printf("%-9s %d \n", "Tom", 38);

  return 0;
}
</pre>
  <p>Консольный вывод:</p>
<pre>
8
 8
+8
010
8.000000

      Tom 38
Tom       38
</pre>
</article>


<!-- 2.5 Константы -->
<article class="article">
  <div class="anchor" id="p2.5"></div>
  <h3>2.5 Константы</h3>

  <p>Отличительным признаком переменных является то, что мы многократно в течение работы программы можем изменять ее значение:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int number = 2;
  printf("number = %d \n", number);
  number = 55;
  printf("number = %d \n", number);
  number = -23;
  printf("number = %d \n", number);
  return 0;
}
</pre>
  <p>Здесь переменная number последовательно меняет свое значение</p>
  <p>В отличие от переменных значение констант устанавливается один раз при их объявлении. Для определения константы используется ключевое слово const:</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  const int number = 2;
  printf("number = %d \n", number);
  // number = 55;  эта строка работать не будет, так как number - это константа
  return 0;
}
</pre>
  <p>Если в коде будет содержаться изменение константы, то компилятор не сможет скомпилировать подобную программу.</p>
  <p>Как правило, в виде констант определяются такие значение, которые должны оставаться постоянными в течение работы всей программы и не могут быть изменены. Например, если программы выполняет математические операции с использованием числа PI, то было бы оптимально определить данные значение как константу, так как оно все равно в принципе неизменно:</p>
  <code>const float PI = 3.14;</code>
</article>


<!-- 2.6 Арифметические операции -->
<article class="article">
  <div class="anchor" id="p2.6"></div>
  <h3>2.6 Арифметические операции</h3>

  <p>Язык программирования Си поддерживает все основные арифметические операции. Эти операции производятся над числами. Значения, которые участвуют в операции, называются операндами. Список имеющихся в Си операций:</p>
  <ol>
    <li>
      + Операция сложения возвращает сумму двух чисел:
<pre>
#include &lt;stdio.h&gt;

int main() {
  int a = 67;
  int b = 33;
  int c = a + b + 7;
  printf("a + b + 7 = %d \n", c);     // 107
  return 0;
}
</pre>
    </li>
    <li>
      - Операция вычитания возвращает разность двух чисел:
<pre>
#include &lt;stdio.h&gt;

int main() {
  int a = 67;
  int b = 33;
  int c = a - b;
  printf("a - b = %d \n", c);     // 34
  return 0;
}
</pre>
    </li>
    <li>
      * Операция умножения возвращает произведение двух чисел:
      <code>int c = 15 * 3;     // 45</code>
    </li>
    <li>
      / Операция деления двух чисел:
<pre>
#include &lt;stdio.h&gt;

int main() {
  int a = 15 / 3;         // 5
  float d = 34.0 / 3.0;   // 11.333333

  printf("a=%d \n", a);
  printf("d=%f \n", d);
  return 0;
}
</pre>
      <p>При делении стоит быть внимательным, так как если в операции участвуют два целых числа, то результат деления будет округляться до целого числа, даже если результат присваивается переменной float:</p>
<pre>
float f = 10 / 4;
printf("f = %f \n", f);     // 2.0
</pre>
      <p>Чтобы результат представлял вещественное число, один из операндов также должен представлять вещественное число:</p>
<pre>
float f = 10.0 / 4;
printf("f = %f \n", f);     // 2.5
</pre>
    </li>
    <li>
      % Возвращает результат деления двух чисел по модулю (получение остатка от деления):
      <code>int a = 35 % 3;         // 2 (35 - 33 = 2)</code>
    </li>
  </ol>
  <p>Операции *, /, % имеют больший приоритет, чем + и - :</p>
<pre>
int a = 8;
int b = 7;
int c = a + 5 * b;      // 43
printf("c = %d \n", c); // 43
</pre>
  <p>Здесь результатом будет число 43: 5 * b = 35, a + 35 = 43</p>
  <p>С помощью скобок мы можем переопределить порядок операций, сделав, чтобы операции с более низким приоритетом выполнялись до операций с более высоким приоритетом:</p>
<pre>
int a = 8;
int b = 7;
int c = (a + 5) * b;    // 91
</pre>
  <p>Здесь результатом будет число 91: a + 5 = 13, 13 * b = 91</p>
  <p>Также в Си есть специальные унарные операции над одним числом: ++ (инкремент) и -- (декремент). Каждая из операций имеет две разновидности: префиксная и постфиксная.</p>
  <ol>
    <li>
      Префиксный инкремент (++x). Увеличивает значение переменной на единицу и полученное значение используется как значение выражения ++x
<pre>
int a = 8;
int b = ++a;
printf("a = %d \n", a); // 9
printf("b = %d", b);    // 9
</pre>
    </li>
    <li>
      Постфиксный инкремент (x++). Увеличивает значение переменной на единицу, но значением выражения x++ будет то, которое было до увеличения на единицу:
<pre>
int a = 8;
int b = a++;
printf("a = %d \n", a); // 9
printf("b = %d", b);    // 8
</pre>
    </li>
    <li>
      Префиксный декремент (--x). Уменьшает значение переменной на единицу, и полученное значение используется как значение выражения --x
<pre>
int a = 8;
int b = --a;
printf("a = %d \n", a); // 7
printf("b = %d", b);    // 7
</pre>
    </li>
    <li>
      Постфиксный декремент (x--). Уменьшает значение переменной на единицу, но значением выражения x-- будет то, которое было до уменьшения на единицу:
<pre>
int a = 8;
int b = a--;
printf("a = %d \n", a); // 7
printf("b = %d", b);    // 8
</pre>
    </li>
  </ol>
  <p>Рассмотрим более сложную ситуацию:</p>
<pre>
int a = 8;
int b = 7;
int c = a+++b;
printf("a = %d \n", a); // 9
printf("b = %d \n", b); // 7
printf("c = %d \n", c); // 15
</pre>
  <p>Здесь операция трактуются таким образом, что вначале идет постфиксный инкремент, а потом сложение. То есть фактически так:</p>
  <code>int c = (a++) + b;</code>
  <p>Аналогично будет расцениваться выражения с постфиксным декрементом: </p>
  <code>int c = a---b;</code>
</article>


<!-- 2.7 Условные операции -->
<article class="article">
  <div class="anchor" id="p2.7"></div>
  <h3>2.7 Условные операции</h3>

  <h4>Логические операции и операции отношения</h4>

  <p>Условные операции позволяют проверить истинность некоторого условия и оперируют понятиями "истина"/"верно" и "ложь"/"неверно". Причем "истина" (условие верно) соответствует значению 1, а "ложь" (условие не верно) - значению 0. К условным операциям относят операции сравнения и логические операции. Оба этих вида операций применяются к арифметическим операндам, то есть числам.</p>

  <h4>Операции сравнения</h4>

  <p>Операции сравнения (еще называют операциями отношения) позволяют сравнить два значения и возвращают 1, если выражение истинно, и 0, если выражение ложно. В языке Си есть следующие операции сравнения:</p>
  <ol>
    <li>
      == Операция "равно". Возвращает 1, если оба операнда равны, и 0, если они не равны:
<pre>
#include &lt;stdio.h&gt;

int main() {
  int a = 10;
  int b = 4;
  int c = a == b;                 // 0 - числа НЕ равны
  printf("c = %d \n", c);         // c = 0

  int num = 5;
  int result = num == 2 + 3;      // 1 - числа равны
  printf("result = %d \n", result);     // result = 1
  return 0;
}
</pre>
      <p>В первом случае переменная c хранит результат выражения a == b. Так как a и b не равны, то это выражение возвратит 0. Поэтому переменная c будет равна 0.</p>
      <p>Во втором случае переменная result хранит результат выражения num == 2 + 3;, где в качестве второго операнда выступает результат операции 2 + 3. Так как переменная num равна 5, то это выражение возвратит 1. Поэтому переменная result будет равна 1.</p>
    </li>
    <li>
      != Операция "не равно". Возвращает 1, если первый операнд не равен второму, и 0, если оба операнда равны:
<pre>
int c = 10 != 4;    // 1
int d = 4 != 4;     // 0
</pre>
    </li>
    <li>
      &gt; Операция "больше чем". Возвращает 1, если первый операнд больше второго, и 0, если первый операнд меньше или равен второму:
<pre>
int a = 10;
int b = 4;
int c = a > b;   // 1
</pre>
    </li>
    <li>
      &lt; Операция "меньше чем". Возвращает 1, если первый операнд меньше второго, и 0, если первый операнд больше или равен второму:
      <code>int c = 10 &lt; 4;  // 0</code>
    </li>
    <li>
      &lt;= Операция "меньше или равно". Возвращает 1, если первый операнд меньше или равен второму, и 0, если первый операнд больше второго:
      <code>int c = 10 &lt;= 4; // 0</code>
    </li>
    <li>
      &gt;= Операция "больше или равно". Возвращает 1, если первый операнд больше или равен второму, и 0, если первый операнд меньше второго:
      <code>int c = 10 >= 4; // 1</code>
    </li>
  </ol>
  <p>Как правило, операции отношения применяются в условных конструкциях типа if...else, которые мы далее рассмотрим.</p>

  <h4>Логические операции</h4>

  <p>Логические операции, как правило, применяются к отношениям и объединяют несколько операций отношения. К логическим операциям относят следующие:</p>
  <ol>
    <li>
      ! (операция отрицания) Если операнд равен 0, то возвращает 1, иначе возвращает 0.
<pre>
int c = !2; // 0
int d = !0; // 1
</pre>
    </li>
    <li>
      && (конъюнкция, логическое умножение) Возвращает 1, если оба операнда не равны 0. Возвращает 0, если хотя бы один операнд равен 0.
<pre>
int c = -2 && 5;    // 1
int d = 0 && 7;     // 0
</pre>
    </li>
    <li>
      || (дизъюнкция, логическое сложение) Возвращает 1, если хотя бы один операнд не равен 0. Возвращает 0, если оба операнда равны 0.
<pre>
int c = -2 || 5;    // 1
int d = 0 || 7;     // 1
int e = 0 || 0;     // 0
</pre>
    </li>
  </ol>
  <p>Используем одновременно несколько логических операций и операций сравнения:</p>
<pre>
int a = -2 > 5;          // 0
int b = 0 &lt; 7;           // 1
int c = 0 == 0;          // 1
int d = a && b || c;        // 1

printf("a = %d \n", a);
printf("b = %d \n", b);
printf("c = %d \n", c);
printf("d = %d \n", d);
</pre>
  <p>Операции сравнения имеют больший приоритет, чем логические операции, поэтому мы могли бы напрямую подставить операции сравнения:</p>
  <code>int d = -2 > 5 && 0 &lt; 7 || 0 == 0; // 1</code>
</article>


<!-- 2.8 Поразрядные операции -->
<article class="article">
  <div class="anchor" id="p2.8"></div>
  <h3>2.8 Поразрядные операции</h3>

  <h4>Операции сдвига</h4>

  <p>Каждое целое число в памяти представлено в виде определенного количества разрядов. И операции сдвига позволяют сдвинуть битовое представление числа на несколько разрядов вправо или влево. Операции сдвига применяются только к целочисленным операндам. Есть две операции:</p>
  <ol>
    <li>&lt;&lt; Сдвигает битовое представление числа, представленного первым операндом, влево на определенное количество разрядов, которое задается вторым операндом.</li>
    <li>&gt;&gt; Сдвигает битовое представление числа вправо на определенное количество разрядов.</li>
  </ol>
  <p>Применение операций:</p>
  <code>int a = 2 &lt;&lt; 2; // 2 = 0010 -> 1000 = 8</code>
  <code>int b = 16 >> 3; // 16 = 10000 -> 10 = 2</code>
  <p>Число 2 в двоичном представлении 10. Если сдвинуть число 10 на два разряда влево, то получится 1000, что в десятичной системе равно число 8.</p>
  <p>Число 16 в двоичном представлении 10000. Если сдвинуть число 10 на три разряда вправо (три последних разряда отбрасываются), то получится 10, что в десятичной системе представляет число 2.</p>

  <h4>Поразрядные операции</h4>

  <p>Поразрядные операции также проводятся только над разрядами целочисленных операндов:</p>
  <ol>
    <li>&: поразрядная конъюнкция (операция И или поразрядное умножение). Возвращает 1, если оба из соответствующих разрядов обоих чисел равны 1</li>
    <li>|: поразрядная дизъюнкция (операция ИЛИ или поразрядное сложение). Возвращает 1, если хотя бы один из соответствующих разрядов обоих чисел равен 1</li>
    <li>^: поразрядное исключающее ИЛИ. Возвращает 1, если только один из соответствующих разрядов обоих чисел равен 1</li>
    <li>~: поразрядное отрицание. Инвертирует все разряды операнда. Если разряд равен 1, то он становится равен 0, а если он равен 0, то он получает значение 1.</li>
  </ol>
  <p>Применение операций:</p>
<pre>
int a = 5 | 2;          // 101 | 010 = 111  - 7
int b = 6 & 2;          // 110 & 010 = 10  - 2
int c = 5 ^ 2;          // 101 ^ 010 = 111 - 7

int f = 12;              // 00001100
int d = ~f;         // 11110011   или -13

printf("a = %d \n", a);
printf("b = %d \n", b);
printf("c = %d \n", c);
printf("d = %d \n", d);
</pre>
  <p>Например, выражение 5 | 2 равно 7. Число 5 в двоичной записи равно 101, а число 2 - 10 или 010. Сложим соответствующие разряды обоих чисел. При сложении если хотя бы один разряд равен 1, то сумма обоих разрядов равна 1. Поэтому получаем:</p>
<pre>
1	0	1
0	1	0
1	1	1
</pre>
  <p>В итоге получаем число 111, что в десятичной записи представляет число 7.</p>
  <p>Возьмем другое выражение 6 & 2. Число 6 в двоичной записи равно 110, а число 2 - 10 или 010. Умножим соответствующие разряды обоих чисел. Произведение обоих разрядов равно 1, если оба этих разряда равны 1. Иначе произведение равно 0. Поэтому получаем:</p>
<pre>
1	1	0
0	1	0
0	1	0
</pre>
  <p>Получаем число 010, что в десятичной системе равно 2.</p>
  <p>Теперь рассмотрим последний пример - инверсию числа.</p>

  <h4>Представление отрицательных чисел</h4>

  <p>Для записи чисел со знаком в Си применяется дополнительный код (two's complement), при котором старший разряд является знаковым. Если его значение равно 0, то число положительное, и его двоичное представление не отличается от представления беззнакового числа. Например, 0000 0001 в десятичной системе 1.</p>
  <p>Если старший разряд равен 1, то мы имеем дело с отрицательным числом. Например, 1111 1111 в десятичной системе представляет -1. Соответственно, 1111 0011 представляет -13.</p>
  <p>Чтобы получить из положительного числа отрицательное, его нужно инвертировать и прибавить единицу:</p>
<pre>
int x = 12;
int y = ~x;
y += 1;
printf("y = %d \n", y);   // y=-12
</pre>

  <h4>Примеры применения поразрядных операций</h4>
</article>
