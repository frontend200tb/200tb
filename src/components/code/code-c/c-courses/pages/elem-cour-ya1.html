<article class="article">
  <h1>Яндекс Образования. Хендбук. Основы С++</h1>
  <p>Конспект курса</p>
  <p><a href="https://education.yandex.ru/handbook/cpp" target="_blank">https://education.yandex.ru/handbook/cpp</a></p>
  <p>Авторы: Алексей Зобнин (Яндекс), Владимир Кузнецов (Яндекс), Артём Брустовецкий (Clever Inc. (Kahoot)).</p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
    <a href="#p1.1">1 Введение</a>
    <br><a href="#p1.1">1.1 Введение</a>
  </p>

  <p>
    <a href="#p2.1">2 Базовые конструкции C++</a>
    <br><a href="#p2.1">2.1 Первые шаги</a>
    <br><a href="#p2.2">2.2 Типы данных</a>
    <br><a href="#p2.3">2.3 Ветвления и циклы</a>
    <br><a href="#p2.4">2.4 Векторы и строки</a>
    <br><a href="#p2.5">2.5 Составные типы данных</a>
    <br><a href="#p2.6">2.6 Ссылки, указатели, константность</a>
    <br><a href="#p2.7">2.7 Функции</a>
    <br><a href="#p2.8">2.8 Шаблоны</a>
    <br><a href="#p2.9">2.9 Разбор задач к главе «Базовые конструкции C++»</a>
  </p>

  <p>
    <a href="#p3.1">3 Стандартная библиотека C++</a>
    <br><a href="#p3.1">3.1 Последовательные контейнеры</a>
    <br><a href="#p3.2">3.2 Ассоциативные контейнеры</a>
    <br><a href="#p3.3">3.3 Алгоритмы</a>
    <br><a href="#p3.4">3.4 Адаптеры и представления</a>
    <br><a href="#p3.5">3.5 Разбор задач к главе «Стандартная библиотека C++»</a>
  </p>

  <p>
    <a href="#p4.1">4 Идиомы C++</a>
    <br><a href="#p4.1">4.1 Классы</a>
    <br><a href="#p4.2">4.2 Шаблонные классы</a>
    <br><a href="#p4.3">4.3 Жизненный цикл объекта</a>
    <br><a href="#p4.5">4.4 Наследование и полиморфизм</a>
    <br><a href="#p4.4">4.5 Обработка исключений</a>
    <br><a href="#p4.6">4.6 Идиома RAII и умные указатели</a>
    <br><a href="#p4.7">4.7 Разбор задач к главе «Идиомы C++»</a>
  </p>

  <p>
    <a href="#p5.1">5 Приложение</a>
    <br><a href="#p5.1">5.1 Как работать с системой проверки заданий</a>
    <br><a href="#p5.2">5.2 Как пользоваться хендбуком</a>
  </p>

</article>


<!-- 1.1 Введение -->
<article class="article">
  <div class="anchor" id="p1.1"></div>
  <h2>1 Введение</h2>
  <h3>1.1 Введение</h3>

  <p>Перед вами учебник по основам языка C++. При его создании мы вдохновлялись специализацией «Искусство разработки на современном C++» на «Курсере», созданной при поддержке Яндекса, и курсом «Основы и методология программирования», который читался в 2014–2021 годах на факультете компьютерных наук ВШЭ.</p>

  <p>Языку C++ почти 40 лет, но он по-прежнему очень актуален и востребован. Он оказал огромное влияние на индустрию и на другие языки. C++ был разработан Бьярне Страуструпом в начале 1980-х годов как расширение языка C (и даже изначально назывался «Си с классами»).</p>

  <p>Однако для изучения C++ совсем не обязательно знать C. Тем не менее мы предполагаем, что вы знакомы с основами информатики и владеете каким-либо языком программирования на уровне школьной программы — например, языком Python.</p>

  <p>Впрочем, C++ во многом полностью противоположен Python:</p>
  <ul>
    <li>это компилируемый, а не интерпретируемый язык;</li>
    <li>С++ — язык со статической, а не динамической типизацией;</li>
    <li>в C++ возможно ручное управление памятью (в отличие от автоматической сборки мусора).</li>
  </ul>

  <p>Чтобы исходный код программы на C++ превратился в исполняемый файл для конкретной архитектуры процессора, программу нужно скомпилировать. Существует несколько популярных компиляторов C++:</p>
  <ul>
    <li>GNU Compiler Collection (GCC);</li>
    <li>Clang — построен поверх инфраструктуры LLVM;</li>
    <li>Microsoft Visual C++ (MSVC) — входит в состав Microsoft Visual Studio;</li>
    <li>Intel C++ Compiler.</li>
  </ul>

  <p>Мы будем использовать в примерах и при проверке задач компилятор Clang 16-й версии.</p>

  <p>С 1998 года международный комитет по стандартизации C++ выпускает стандарты — версии языка, в которых описываются его возможности. В первую очередь это руководства для создателей компиляторов, но при возникновении спорных моментов всегда полезно обратиться к стандарту. Мы будем ориентироваться на стандарт C++20, а по ссылке можно ознакомиться с черновиком будущего стандарта. Важно понимать, что стандарт определяет лишь общие требования и не фиксирует детали реализации, которые в разных компиляторах могут отличаться.</p>

  <p>Чтобы проверить, поддерживает ли ваша версия компилятора ту или иную особенность C++, советуем пользоваться специальной таблицей.</p>

  <p>При изучении вам будут полезны следующие англоязычные ресурсы:</p>
  <ul>
    <li>cppreference.com — онлайн-документация по C++;</li>
    <li>isocpp.org — сайт Standard C++ Foundation;</li>
    <li>C++ Core Guidelines — гайдлайны по C++ от Бьярне Страуструпа и Герба Саттера;</li>
    <li>godbolt.org — Compiler Explorer, онлайн-компилятор;</li>
    <li>learncpp.com — современный учебник по C++;</li>
    <li>hacking C++ — наглядный справочник по C++ с картинками и инфографикой.</li>
  </ul>

  <p>В тексте мы будем часто ссылаться на англоязычную версию cppreference.com и на английскую «Википедию».</p>

  <p>Написать программу для C++ можно в любом текстовом редакторе, но удобнее пользоваться средой разработки (IDE). IDE включают редактор кода с подсветкой синтаксиса, а также позволяют компилировать, запускать и отлаживать программы.</p>

  <p>Примеры IDE:</p>
  <ul>
    <li>Microsoft Visual Studio Community</li>
    <li>Eclipse CDT</li>
    <li>Code::Blocks</li>
    <li>Qt Creator</li>
    <li>Xcode</li>
  </ul>

  <p>Мы рассчитываем, что вы сможете самостоятельно разобраться с настройкой и использованием среды разработки, и не будем заострять на этом внимание. В наших примерах мы будем запускать компилятор из консоли.</p>

  <p>К нашему учебнику прилагается набор задач по соответствующим темам. Вы можете сдавать их в автоматическую проверяющую систему. В одних задачах требуется написать полноценную программу, а в других — сдать только код функции или класса. Обратите внимание, что ко всем задачам имеются разборы с авторскими решениями. Найти разборы вы можете в конце глав.</p>

  <p>Ho прежде чем мы двинемся дальше — небольшое объявление: для этого хендбука у нас есть коммьюнити студентов. В нём можно найти единомышленников, обсудить материалы и задания. Вступить в него можно по <a href="https://t.me/handbook_cpp">ссылке</a>. А чтобы быть в курсе обновлений хендбука — советуем подписаться на рассылку.</p>
</article>


<!-- 2.1 Первые шаги -->
<article class="article">
  <div class="anchor" id="p2.1"></div>
  <h2>2 Базовые конструкции C++</h2>
  <h3>2.1 Первые шаги</h3>

  <p>В этом параграфе мы напишем первую программу на C++ и научимся печатать и считывать с клавиатуры строки и числа.</p>

  <h4>Функция main</h4>
  <p>Пожалуй, самая простая и короткая программа на C++ — это программа, которая ничего не делает. Она выглядит так:</p>
<pre>
int main() {
  return 0;
}
</pre>
  <p>Здесь определяется функция с именем main, которая не принимает никаких аргументов (внутри круглых скобок ничего нет) и не выполняет никаких содержательных команд. В каждой программе на C++ должна быть ровно одна функция main — с неё начинается выполнение программы.</p>

  <p>У функции указан тип возвращаемого значения int (целое число), и она возвращает 0 — в данном случае это сообщение для операционной системы, что программа выполнилась успешно. И наоборот, ненулевой код возврата означает, что при выполнении возникла ошибка (например, программа получила некорректные входные данные).</p>

  <p>Для функции main разрешается не писать завершающий return 0, чем мы и будем пользоваться далее для краткости. Поэтому самую короткую программу можно было бы написать вот так:</p>
<pre>
int main() {
}
</pre>

  <h4>Hello, world!</h4>
  <p>Соблюдая традиции, напишем простейшую программу на C++ — она выведет приветствие в консоль:</p>
<pre>
#include <iostream>

int main() {
  std::cout &lt;&lt; "Hello, world!\n";
}
</pre>
  <p>Разберём её подробнее.</p>

  <p>Директива #include &lt;iostream&gt; подключает стандартный библиотечный заголовочный файл для работы с потоками ввода-вывода (input-output streams). Для печати мы используем поток вывода std::cout, где cout расшифровывается как character output, то есть «символьный вывод».</p>

  <p>В теле функции main мы передаём в std::cout строку Hello, world! с завершающим переводом строки \n. В зависимости от операционной системы \n будет преобразован в один или в два управляющих байта с кодами 0A или 0D 0A соответственно.</p>

  <p>Инструкции внутри тела функции завершаются точками с запятой.</p>

  <h4>Компиляция из командной строки</h4>
  <p>Вы можете запустить эту программу из какой-нибудь IDE. Мы же покажем, как собрать её в консоли Linux с помощью компилятора clang++.</p>

  <p>Пусть файл с программой называется hello.cpp. Запустим компилятор:</p>
  <code>$ clang++ hello.cpp -o hello</code>
  <p>В результате мы получим исполняемый файл с именем hello, который теперь можно просто запустить. Он напечатает на экране ожидаемую фразу:</p>
<pre>
$ ./hello
Hello, world!
</pre>
  <p>Если опцию -o не указать, то сгенерированный исполняемый файл будет по умолчанию назван a.out. В дальнейшем для простых примеров мы будем использовать краткую форму записи команды:</p>
<pre>
$ clang++ hello.cpp && ./a.out
Hello, world!
</pre>
  <p>С её помощью мы компилируем программу и в случае успеха компиляции сразу же запускаем.</p>

  <h4>Комментарии</h4>
  <p>Комментарии — это фрагменты программы, которые игнорируются компилятором и предназначены для программиста. В C++ есть два вида комментариев — однострочные и многострочные:</p>
<pre>
int main() {  // однострочный комментарий продолжается до конца строки

/* Пример
   многострочного
   комментария */
}
</pre>
  <p>Мы будем использовать комментарии в примерах кода для пояснений, а в реальных программах ими лучше не злоупотреблять.</p>

  <p>Хорошо: комментировать, что делает библиотека, функция или класс или почему этот код написан именно так.</p>

  <p>Плохо: комментировать, что происходит на отдельных строчках. Это признак того, что код можно написать лучше.</p>

  <h4>Библиотеки и заголовочные файлы</h4>
  <p>Библиотека — это код, который можно переиспользовать в разных программах. В стандарт языка C++ входит спецификация так называемой стандартной библиотеки, которая поставляется вместе с компилятором. Она содержит различные структуры данных (контейнеры), типовые алгоритмы, средства ввода-вывода и т. д. Конструкции из этой библиотеки предваряются префиксом std::, который обозначает пространство имён.</p>

  <p>Чтобы воспользоваться теми или иными библиотечными конструкциями, в начале программы надо подключить нужные заголовочные файлы. Так, в программе, которая печатала Hello, world!, нам уже встречался заголовочный файл iostream и конструкция std::cout из стандартной библиотеки.</p>

  <p>Для C++ существует также множество сторонних библиотек. Наиболее известной коллекцией сторонних библиотек для C++ является Boost.</p>

  <h4>Ошибки компиляции</h4>
  <p>Перед запуском программу необходимо скомпилировать. Компилятор проверяет корректность программы и генерирует исполняемый файл. Во время компиляции компилятор может обнаружить синтаксические ошибки.</p>

  <p>Рассмотрим пример такой программы:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  cout &lt;&lt; "Hello, world\n"
</pre>
  <p>Первая ошибка — вместо std::cout мы написали cout. Вторая ошибка — не поставили точку запятой после "Hello, world!\n". Наконец, третья – не закрыли фигурную скобку с телом функции.</p>

  <p>Ошибки компиляции (compile errors) следует отличать от возможных ошибок времени выполнения (runtime errors), которые происходят после запуска программы и, как правило, зависят от входных данных, неизвестных во время компиляции.</p>

  <h4>Отступы и оформление кода</h4>
  <p>Фрагменты программы на C++ могут быть иерархически вложены друг в друга. На верхнем уровне находятся функции, внутри них написаны их тела, в теле могут быть составные операторы, и так далее.</p>

  <p>Среди программистов есть соглашение — писать внутренние блоки кода с отступами вправо: компилятор полностью игнорирует эти отступы, а код читать удобнее. Мы будем использовать отступы в четыре пробела. Также мы будем придерживаться стиля оформления кода, принятого в Яндексе. Имена переменных мы будем писать с маленькой буквы, имена функций и классов — с большой (если речь не идёт о конструкциях стандартной библиотеки, где действуют другие соглашения).</p>

  <h4>Переменные</h4>
  <p>Любая содержательная программа так или иначе обрабатывает данные в памяти. Переменная — это именованный блок данных определённого типа. Чтобы определить переменную, нужно указать её тип и имя. В общем виде это выглядит так:</p>
  <code>Type name;</code>
  <p>где Type — конкретный тип данных (например, строка или число), а name — имя переменной. Имена переменных должны состоять из латинских букв, цифр и знаков подчёркивания и не должны начинаться с цифры. Также можно в одной строке определить несколько переменных одного типа:</p>
  <code>Type name1, name2, name3;</code>
  <p>Например:</p>
<pre>
// библиотека, в которой
// определён тип std::string
#include &lt;string&gt;

int main() {
  // Определяем переменную value
  // целочисленного типа int
  int value;

  // Определяем переменные name и surname
  // типа std::string (текстовая строка)
  std::string name, surname;
}
</pre>
  <p>В этом примере мы используем встроенный в язык тип int (от слова integer — целое число) и поставляемый со стандартной библиотекой тип std::string. (Можно было бы использовать для строк встроенный тип с массивом символов, но это неудобно.)</p>

  <p>Тип переменной должен быть известен компилятору во время компиляции.</p>

  <p>От типа зависит:</p>
  <ul>
    <li>сколько байтов памяти потребуется для хранения данных;</li>
    <li>как интерпретировать эти байты;</li>
    <li>какие операции с этой переменной возможны.</li>
  </ul>

  <p>Например, переменной типа int можно присваивать значения и с ней можно производить арифметические операции. Подробнее про разные типы данных и их размер в памяти мы поговорим ниже.</p>
  <p>Важно понимать, что тип остаётся с переменной навсегда. Например, присвоить целочисленной переменной строку не получится — это вызовет ошибку компиляции:</p>
<pre>
int main() {
  int value;
  value = 42;  // OK
  value = "Hello!";  // ошибка компиляции!
}
</pre>
  <p>Переменные можно сразу проинициализировать значением. В С++ есть много разных способов инициализации. Нам пока будет достаточно способа, который называется copy initialization:</p>
<pre>
#include &lt;string&gt;

int main() {
  int value = 42;
  std::string title = "Bjarne Stroustrup";
}
</pre>
  <p>Если переменная была объявлена, но нигде дальше не использовалась, то компилятор выдаёт об этом предупреждение. При проверке решений мы используем опцию -Werror, которая считает предупреждения компилятора ошибками компиляции.</p>

  <h4>Потоковый ввод и вывод</h4>
  <p>Поток — это абстракция для чтения и записи последовательности данных в форматированном виде.</p>

  <p>Записывать данные можно на экран консоли, в файл, буфер в памяти или в строку. Считывать их можно с клавиатуры, из файла, из памяти. Причём с каждым таким «устройством» можно связать свой поток.</p>

  <p>Важно, что потоки не просто пересылают байты памяти, а применяют форматированный человекочитаемый ввод-вывод. Например, числа печатаются и считываются в десятичной нотации, хотя в памяти компьютера они хранятся в двоичном виде.</p>

  <p>В программе Hello, world! нам уже встречался поток вывода std::cout, по умолчанию связанный с экраном консоли. Познакомимся с потоком ввода std::cin, связанным с клавиатурой. Для его использования нужен тот же заголовочный файл iostream.</p>

  <p>Рассмотрим программу, которая спрашивает имя пользователя и печатает персональное приветствие:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string name;  // объявляем переменную name
  std::cout &lt;&lt; "What is your name?\n";
  std::cin >> name;  // считываем её значение с клавиатуры
  std::cout &lt;&lt; "Hello, " &lt;&lt; name &lt;&lt; "!\n";
}
</pre>
  <p>Обратите внимание на направление угловых скобок в этом примере — они условно показывают направление потока данных. При печати данные выводятся на экран, и стрелки направлены от текста к cout. При вводе данные поступают с клавиатуры, и стрелки направлены от cin к переменной.</p>

  <p>В нашем примере в переменную name считается одно слово, которое будет выведено в ответном сообщении. Пример работы программы:</p>
<pre>
What is your name?
Alice
Hello, Alice!
</pre>
  <p>Однако если ввести строку из нескольких слов с пробелами, то в name запишется только первое слово:</p>
<pre>
$ ./a.out
What is your name?
Alice Liddell
Hello, Alice!
</pre>
  <p>Дело в том, что cin читает поток данных до ближайшего пробельного разделителя (пробела, табуляции, перевода строки или просто конца файла). Чтобы считать в строковую переменную всю строчку целиком (не включая завершающий символ перевода строки), нужно использовать функцию std::getline из заголовочного файла string:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string name;
  std::getline(std::cin, name);
  std::cout &lt;&lt; "Hello, " &lt;&lt; name &lt;&lt; "!\n";
}
</pre>
  <p>В этом примере мы печатаем в одном выражении друг за другом несколько строк ("Hello, ", name и "!\n"), разделённых угловыми скобками &lt;&lt;. Таким образом, cin и cout позволяют кратко считывать и печатать несколько объектов одной командой.</p>

  <p>Например, считывание нескольких чисел целого типа, набранных через пробельные разделители, может выглядеть так:</p>
<pre>
int main() {
  int a;
  int b;
  int c;
  std::cin >> a >> b >> c;
}
</pre>
  <p>Напечатать их значения можно следующим образом:</p>
  <code>std::cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; " " &lt;&lt; c &lt;&lt; "\n";</code>
  <p>Обратите внимание, что мы дополнительно вставляем между ними пробелы, чтобы в выводе числа не слиплись вместе. В конце вывода мы вставляем символ перевода строки \n, чтобы отделить этот результат от последующего вывода или от сообщений командной строки.</p>

  <p>Итак, параграф позади! Впереди вас ждут первые задачи. Но прежде чем приступить к ним, советуем сперва взглянуть на небольшое руководство о том, как пользоваться системой проверки заданий.</p>
</article>


<!-- 2.2 Типы данных -->
<article class="article">
  <div class="anchor" id="p2.2"></div>
  <h3>2.2 Типы данных</h3>
  <p>C++ — язык со статической типизацией. У каждой переменной на этапе компиляции должен быть чётко определённый тип данных. Про каждый тип данных заранее известно, сколько места в памяти занимает переменная такого типа.</p>

  <p>В этом параграфе мы познакомимся с некоторыми базовыми типами данных и с понятием области видимости переменных.</p>

  <h4>Области видимости</h4>
  <p>В С++ существует понятие области видимости (scope) переменной. Эта область ограничивается блоком кода, в котором переменная определена. Рассмотрим пример:</p>
<pre>
#include &lt;iostream&gt;

int a = 1;  // глобальная переменная

int main() {
  int b = 2;  // локальная переменная
  {
    int c = 3;  // локальная переменная внутри блока
    std::cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b
    &lt;&lt; " " &lt;&lt; c &lt;&lt; "\n";  // корректно
  }

  // Эта строчка не скомпилируется,
  // так как переменная c не определена в данной области:
  std::cout &lt;&lt; c &lt;&lt; "\n";
}
</pre>
  <p>В этом примере есть три области:</p>
  <ul>
    <li>глобальная, в которой определена переменная a;</li>
    <li>тело функции main, в которой определена переменная b;</li>
    <li>внутренний блок, в котором определена переменная c.</li>
  </ul>
  <p>В последней строке примера переменная c недоступна, так как её область видимости уже закончилась. В случае коллизии имён компилятор всегда выбирает самую вложенную область видимости.</p>

  <p>Рассмотрим пример:</p>
<pre>
#include <iostream>

int main() {
  int x = 1;
  // напечатает 1
  std::cout &lt;&lt; x &lt;&lt; "\n";
  {
    // новая переменная, к предыдущему x не имеет отношения
    int x = 2;
    // напечатает 2
    std::cout &lt;&lt; x &lt;&lt; "\n";
  }
  // снова напечатает 1
  std::cout &lt;&lt; x &lt;&lt; "\n";
}
</pre>

  <h4>Инициализация локальных переменных</h4>
  <p>Локальные переменные простых типов, таких как int, не инициализируются по умолчанию нулём. Компилятор просто выделяет для них байты в стековой памяти, но при этом он не обязан как-либо их заполнять. Это один из принципов C++: мы не должны платить за то, что не используем.</p>

  <p>Следующий фрагмент кода может напечатать всё что угодно:</p>
<pre>
#include <iostream>

int main() {
  int x;
  // неопределённое поведение!
  std::cout &lt;&lt; x &lt;&lt; "\n";
  int y;
  // а это допустимый сценарий
  std::cin >> y;
}
</pre>
  <p>Компиляторы g++ и clang++ обычно дают предупреждения о чтении неинициализированных переменных при использовании опции -Wall или -Wuninitialized:</p>
  <p>Заметим, что std::string является сложным типом и переменные такого типа всегда по умолчанию инициализируются пустой строкой. Поэтому нет необходимости писать std::string s = "";. Пишите просто std::string s;.</p>

  <h4>Простые типы данных</h4>
  <p>С типом int мы уже знакомы. Рассмотрим другие фундаментальные типы данных в С++. Это так называемые интегральные типы и типы для вещественных чисел.</p>
<pre>
int main() {
  char c = '1';    // символ
  bool b = true;   // логическая переменная, принимает значения false и true
  int i = 42;      // целое число (занимает, как правило, 4 байта)
  short int si = 17;           // короткое целое (занимает 2 байта)
  long li = 12321321312;       // длинное целое (как правило, 8 байт)
  long long lli = 12321321312; // длинное целое (как правило, 8 байт)
  float f = 2.71828;           // дробное число с плавающей запятой (4 байта)
  double d = 3.141592;         // дробное число двойной точности (8 байт)
  long double ld = 1e15;       // длинное дробное (как правило, 16 байт)
}
</pre>
  <p>Обратите внимание, что символы, в отличие от строк (то есть массивов символов), записываются в апострофах, а не в кавычках. В примере выше мы записываем в переменную c символ единицы. Фактически в памяти хранится ASCII-код этого символа, который равен 49.</p>

  <p>Напомним, что каждый тип данных занимает заранее известное количество байтов памяти. Стандарт языка С++ не накладывает жёстких ограничений на размеры типов, они могут отличаться для разных платформ и компиляторов.</p>

  <p>О том, что делать с этой особенностью, мы расскажем ниже. А пока отметим, что узнать размер переменной или типа на этапе компиляции можно с помощью оператора sizeof.</p>

  <p>Например, на 64-битной Linux-системе компилятор clang++ использует такие размеры для типов:</p>
<pre>
int main() {
  std::cout &lt;&lt; "char: " &lt;&lt; sizeof(char) &lt;&lt; "\n";                 //  1
  std::cout &lt;&lt; "bool: " &lt;&lt; sizeof(bool) &lt;&lt; "\n";                 //  1
  std::cout &lt;&lt; "short int: " &lt;&lt; sizeof(short int) &lt;&lt; "\n";       //  2 (по стандарту >= 2)
  std::cout &lt;&lt; "int: " &lt;&lt; sizeof(int) &lt;&lt; "\n";                   //  4 (по стандарту >= 2)
  std::cout &lt;&lt; "long int: " &lt;&lt; sizeof(long int) &lt;&lt; "\n";         //  8 (по стандарту >= 4)
  std::cout &lt;&lt; "long long int: " &lt;&lt; sizeof(long long) &lt;&lt; "\n";   //  8 (по стандарту >= 8)
  std::cout &lt;&lt; "float: " &lt;&lt;sizeof(float) &lt;&lt; "\n";               //  4
  std::cout &lt;&lt; "double: " &lt;&lt; sizeof(double) &lt;&lt; "\n";             //  8
  std::cout &lt;&lt; "long double: " &lt;&lt; sizeof(long double) &lt;&lt; "\n";   // 16
}
</pre>

  <h4>Размеры стандартных типов</h4>
  <p>По умолчанию числовые типы – знаковые. Они имеют диапазон значений от -2<sup>n-1</sup> до 2<sup>n-1</sup> - 1, где n – количество битов, занимаемых типом. Приставка unsigned перед типом делает его беззнаковым. В этом случае диапазон допустимых значений будет от 0 до 2<sup>n</sup> - 1:</p>
<pre>
int main() {
  unsigned int ui = 4294967295;  // 2^32 - 1
}
</pre>
  <p>Минимальное и максимальное значение, помещающееся в данный числовой тип, можно получить так:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;limits&gt;  // необходимо для numeric_limits

int main() {
  // посчитаем для типа int:
  std::cout &lt;&lt; "minimum value: "
            &lt;&lt; std::numeric_limits<int>::min()
            &lt;&lt; "\n"
            &lt;&lt; "maximum value: "
            &lt;&lt; std::numeric_limits<int>::max()
            &lt;&lt; "\n";
}
</pre>
  <p>Данный пример на 64-битной Linux-системе напечатает:</p>
<pre>
minimum value: -2147483648
maximum value: 2147483647
</pre>
  <p>Приведённые выше примеры вывода оператора sizeof верны для 64-битных архитектур, которые на сегодняшний день распространены повсеместно. Однако если бы мы скомпилировали и запустили такую программу на компьютере с 32-битной архитектурой, то получили бы другие результаты. Например, sizeof(long int) стал бы равен 4, в то время как на современных компьютерах мы получили бы 8. Также бывают встраиваемые системы, под которые тоже можно писать на С++. Там битность архитектуры может быть ещё меньше, чем 32.</p>
  <p>В заголовочном файле cstdint стандартной библиотеки имеются целочисленные типы с фиксированным размером:</p>
  <ul>
    <li>int8_t / uint8_t</li>
    <li>int16_t / uint16_t</li>
    <li>int32_t / uint32_t</li>
    <li>int64_t / uint64_t</li>
  </ul>
  <p>Число в имени типа означает количество бит, используемых для хранения в памяти. Например, int32_t содержит 32 бита (4 байта) и часто соответствует типу int. Если система не поддерживает какой-то тип, то программа с ним просто не скомпилируется.</p>

  <h4>Переполнение целочисленных типов</h4>

  <p>Стандартные числовые типы имеют ограниченный размер и ограниченное множество допустимых значений. При арифметических операциях над числами таких типов может возникнуть переполнение — ситуация, когда результат операции не помещается в тип:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  // на 64-битной платформе sizeof(a) == 4
  unsigned int a = 123456;

  // Произведение a * a не помещается в 4 байта,
  // так как оно больше 2^32
  std::cout &lt;&lt; a * a &lt;&lt; "\n";
}
</pre>

  <p>В этом примере выражение a * a будет иметь тот же тип, что и аргументы. То, что на самом деле будет вычислено, зависит от знаковости типа.</p>
  <p>Беззнаковые типы можно спокойно переполнять: вычисления будут производиться по модулю соответствующей степени двойки. Другими словами, будут учтены только младшие биты результата:</p>
<pre>
int main() {
  // на 64-битной платформе sizeof(x) == 4
  unsigned int x = 0;
  // 4294967295, то есть 2**32 - 1
  unsigned int y = x - 1;
  unsigned int z = y + 1;  // 0
}
</pre>
  <p>Наоборот, для знаковых типов переполнение приводит к так называемому неопределённому поведению (UB, undefined behavior).</p>
  <p>Такая ситуация не считается ошибкой компиляции (в самом деле, на стадии компиляции значения переменных могут быть ещё неизвестны). Но в этом случае стандарт С++ перестаёт что-либо гарантировать по поводу поведения программы. Компиляторы могут использовать такие случаи для оптимизации программ, полагаясь на то, что разработчики пишут код корректно и никогда не допускают неопределённого поведения. Далее нам встретятся и другие случаи неопределённого поведения.</p>
  <p>Беззнаковые типы следует использовать, когда вы имеете дело с битовыми наборами. В остальных случаях предпочтительнее использовать знаковые типы.</p>

  <h4>Арифметические операции</h4>
  <p>Бинарные операции +, - и * работают для чисел стандартным образом. Результат операции деления /, применённой к целым числам, всегда округляется в сторону нуля. Таким образом, для положительных чисел операция / возвращает неполное частное. Остаток от деления целых чисел можно получить с помощью операции %.</p>
<pre>
int main() {
  int a = 7, b = 3;
  int q = a / b;  // 2
  int r = a % b;  // 1
}
</pre>
  <p>Если при делении нужно получить обычное частное, то один из аргументов нужно привести к вещественному типу (например, double) с помощью оператора static_cast:</p>
<pre>
int main() {
  int a = 6, b = 4;
  double q = static_cast&lt;double&gt;(a) / b;  // 1.5
}
</pre>
  <p>Можно было бы написать чуть более кратко: double q = a * 1.0 / b;. Тогда преобразование аргументов произошло бы неявно.</p>
  <p>Арифметические операции над символами, а также сравнение символов друг с другом — это фактически операции над их ASCII-кодами:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  char c = 'A';
  c += 25;  // увеличиваем ASCII-код символа на 25
  std::cout &lt;&lt; c &lt;&lt; "\n";  // Z
}
</pre>
  <p>Операция + применительно к строкам означает конкатенирование (то есть склейку). Это пример перегрузки операции: изначальному оператору сложения чисел в стандартной библиотеке для строки придали новый смысл.</p>
<pre>
#include &lt;string&gt;

int main() {
  std::string a = "Hello, ";
  std::string b = "world!";
  std::string c = a + b;  // Hello, world!
}
</pre>
  <p>Для каждой бинарной операции (например, +) есть версия со знаком равенства (+=) для случая, когда левый аргумент совпадает с переменной, которой присваивается результат:</p>
<pre>
int main() {
  int x = 5;
  x += 3;  // x = x + 3
  x *= x;  // x = x * x
}
</pre>
  <p>Наконец, имеются операторы ++ и -- для увеличения или уменьшения переменной на единицу. Они бывают префиксные (++x) и постфиксные (x++). Отличие состоит в значении выражения, которое будет вычисляться при применении такого оператора. Мы рассмотрим это позже, а пока привыкнем по умолчанию использовать префиксный оператор для обычных чисел:</p>
<pre>
int main() {
  int x = 5;
  ++x;  // 6
  --x;  // снова 5
}
</pre>

  <h4>Числа с плавающей точкой</h4>

  <p>В языке C++ существуют три встроенных типа для записи дробных чисел: float (4 байта), double (8 байт) и long double (16 или 8 байт, в зависимости от платформы). В большинстве случаев рекомендуется использовать тип double.Тип float разумно использовать там, где обрабатываются огромные массивы чисел, и возникает необходимость экономить память.</p>
  <p>Как правило, хранение дробных чисел в С++ основано на стандарте IEEE 754. Число представляется в виде двоичной дроби в экспоненциальной записи: отдельно хранятся бит знака, порядок и мантисса. Мантисса 23 бита (0-22), порядок 8 бит (23-30), знак 1 бит (31).</p>
  <p>Такое представление выгодно отличается от чисел с фиксированной точкой, где хранится фиксированное количество разрядов. Оно позволяет, хотя и с разной степенью точности, представлять числа, отличающиеся на порядки.</p>
  <p>При работе с рациональными числами, знаменатель которых не является степенью двойки, неизбежно возникают погрешности представления. В следующем параграфе мы разберём как следует сравнивать такие числа.</p>

  <h4>Автоматический вывод типа</h4>

  <p>Компилятор C++ умеет автоматически выводить тип переменной по значению, которое ей присваивается. Для этого вместо типа надо написать ключевое слово auto:</p>
<pre>
int main() {
  auto x = 42;  // int
  auto pi = 3.14159;  // double
}
</pre>
  <p>Ключевое слово auto позволяет сократить код и не выписывать сложные типы (нам встретятся дальше монстры вроде std::unordered_multimap&lt;Key, Value&gt;::const_iterator). Важно подчеркнуть, что точный тип переменной всё равно становится известен в момент компиляции.</p>
  <p>При использовании auto со строками нужно быть осторожным. Важно знать, что конструкция auto s = "hello" выведет низкоуровневый тип const char * (указатель на неизменяемый набор символов в памяти), а не тип-обёртку std::string.</p>
  <p>Точные правила вывода типов похожи на правила вывода шаблонных параметров, с которыми мы познакомимся в параграфе про шаблоны.</p>
  <p>В следующем параграфе мы подробнее поговорим о ветвлении и циклах.</p>
</article>


<!-- 2.3 Ветвления и циклы -->
<article class="article">
  <div class="anchor" id="p2.3"></div>
  <h3>2.3 Ветвления и циклы</h3>

  <p>В этом параграфе мы познакомимся с операторами ветвления if и switch, циклами while, do-while и for, а также с оператором goto.</p>

  <h4>Оператор if</h4>
  <p>Условный оператор if записывается так:</p>
<pre>
if (condition) {
  // код, который исполнится в случае,
  // когда условие condition истинно
}
</pre>
  <p>Дополнительно можно добавить ветку кода для случая, когда условие ложно:</p>
<pre>
if (condition) {
  // код, который исполнится,
  // если condition истинно
} else {
  // код, который исполнится,
  // если condition ложно
}
</pre>
  <p>Также можно выстроить цепочку условных операторов:</p>
<pre>
if (condition1) {
  // случай, когда condition1 истинно
} else if (condition2) {
  // случай, когда condition1 ложно,
  // а condition2 истинно
} else if (condition3) {
  // случай, когда condition1 и condition2 ложны,
  // а condition3 истинно
} else {
  // случай, когда condition1,
  // condition2 и condition3 ложны
}
</pre>
  <p>Если код внутри фигурных скобок состоит из одной инструкции, то фигурные скобки можно не писать. Однако рекомендуется ставить фигурные скобки всегда во избежание ошибок.</p>
  <p>На месте condition может стоять любое выражение логического типа. Простейшие примеры таких выражений — это проверка на равенство (==) и неравенство (!=), а также сравнения на меньше / больше (&lt;, &lt;=, > и >=):</p>
<pre>
#include <iostream>

int main() {
  int x;
  std::cin >> x;
  if (x &lt;= 0) {
    std::cout &lt;&lt; "zero or negative\n";
  } else if (x == 1) {
    std::cout &lt;&lt; "one\n";
  } else if (x == 2) {
    std::cout &lt;&lt; "two\n";
  } else {
    std::cout &lt;&lt; "many\n";
  }
}
</pre>

  <h4>Сложные условия</h4>
  <p>Условия можно комбинировать с помощью логических операторов && (и), || (или) и ! (не). Рассмотрим пример, где проверяется принадлежность точки разным интервалам на прямой.</p>
<pre>
int main() {
  int a, b, x;
  /* Тут должна быть логика заполнения объявленных переменных,
  но мы её опустили, чтобы не отвлекаться */

  if (a &lt;= x && x &lt;= b) {
    // точка x лежит на отрезке [a; b]
  } else {
    // точка x лежит вне отрезка [a; b]
  }

  // то же самое можно было бы проверить так:
  if (!(x &lt; a || x > b)) {  // отрицание
    // точка x лежит на отрезке [a; b]
  } else {
    // точка x лежит вне отрезка [a; b]
  }
}
</pre>
  <p>Обратите внимание, что двойное неравенство некорректно проверять через a &lt;= x &lt;= b. Так можно написать, но смысл будет совсем другим: результат сравнения a &lt;= x будет приведён к нулю или единице, и полученное число будет сравниваться с b.</p>
  <p>Операторы сравнения имеют больший приоритет, чем логические операторы, поэтому скобки вокруг элементарных сравнений в сложных условиях не обязательны. А вот оператор отрицания имеет высокий приоритет, поэтому в последнем примере он применяется к условию в скобках. Таблицу приоритета операторов C++ можно посмотреть здесь.</p>
  <p>Операторы && и || ведут себя лениво: если первого аргумента уже достаточно для ответа, то второй аргумент вычисляться не будет. Например, в выражении condition1 && condition2 второе условие не вычисляется, если первое ложно. Это часто используют для проверок корректности:</p>
<pre>
int a, b;
// ...
if (a != 0 && b % a == 0) {
  // b делится на a
}
</pre>

  <h4>Сравнение чисел с плавающей точкой</h4>

  <p>Рассмотрим программу, которая проверяет равенство 0.1 + 0.2 == 0.3:</p>
<pre>
#include <iostream>

int main() {
  double x = 0.1, y = 0.2;
  if (x + y == 0.3) {
    std::cout &lt;&lt; "EQUAL ";
  } else {
    std::cout &lt;&lt; "NOT EQUAL ";
  }

  std::cout &lt;&lt; x + y &lt;&lt; "\n";
}
</pre>
  <p>Логично было бы предположить, что программа выведет EQUAL 0.3, потому что 0.1 + 0.2 = 0.3. Однако программа напечатает NOT EQUAL 0.3. Данная «ошибка вычисления» встречается в большинстве современных языков программирования и обусловлена погрешностью представления этих чисел. Если повысить число знаков дробной части в выводе, мы увидим, что 0.1 + 0.2 == 0.30000000000000004. Подробнее об этом можно прочитать здесь и в этой статье.</p>
  <p>Поскольку операции над числами с плавающей точкой могут содержать погрешность, обычное сравнение через == некорректно. Поэтому правильнее сравнивать модуль разности величин с некой допустимой для нас погрешностью. Модуль дробного числа можно получить с помощью функции std::abs из заголовочного файла cmath. Исходную программу можно было бы переписать так:</p>
<pre>
#include &lt;cmath&gt;
#include &lt;iostream&gt;

int main() {
  double delta = 0.000001;

  double x = 0.1, y = 0.2;
  double sum = x + y;

  if (std::abs(sum - 0.3) &lt; delta) {
    std::cout &lt;&lt; "EQUAL ";
  } else {
    std::cout &lt;&lt; "NOT EQUAL ";
  }

  std::cout &lt;&lt; sum &lt;&lt; "\n";
}
</pre>
  <p>Теперь программа выведет EQUAL 0.3.</p>

  <h4>Оператор switch</h4>

  <p>Рассмотрим простейший калькулятор, считывающий число, затем знак арифметической операции, а затем другое число и печатающий результат. Напишем сначала программу с помощью if и else.</p>
<pre>
#include &lt;cstdint&gt;
#include &lt;iostream&gt;

int main() {
  int64_t a, b;
  char operation;
  std::cin >> a >> operation >> b;

  int64_t result = 0;
  if (operation == '+') {
    result = a + b;
  } else if (operation == '-') {
    result = a - b;
  } else if (operation == '*') {
    result = a * b;
  } else if (operation == '/' || operation == ':') {
    result = a / b;
  } else if (operation == '%') {  // остаток от деления
    result = a % b;
  }

  std::cout &lt;&lt; result &lt;&lt; "\n";
}
</pre>
  <p>Перепишем эту программу через оператор switch. Этот оператор следует рассматривать как условный прыжок на соответствующую метку в зависимости от значения выражения.</p>
<pre>
#include &lt;cstdint&gt;
#include &lt;iostream&gt;

int main() {
  int64_t a, b;
  char operation;
  std::cin >> a >> operation >> b;

  int64_t result;
  switch (operation) {
    case '+':
        result = a + b;
        break;  // если не написать этот break,
                // программа просто пойдёт дальше
                // в код следующего блока case
    case '-':
        result = a - b;
        break;
    case '*':
        result = a * b;
        break;
    case '/':
    case ':':
        result = a / b;
        break;
    case '%':
        result = a % b;
        break;
    default:  // здесь обрабатывается случай,
              // когда ни один case не сработал.
        result = 0;
  }

  std::cout &lt;&lt; result &lt;&lt; "\n";
}
</pre>
  <p>Выражения внутри скобок оператора switch и в блоках case должны быть простого целочисленного или символьного типа. В приведённой выше программе значение + относится к типу char. Использование сложных типов (например, строк) приведёт к ошибке компиляции:</p>
<pre>
int main() {
  std::string name;
  std::cin >> name;
  switch (name) {  // ошибка компиляции
    case "Alice":
        std::cout &lt;&lt; "Hello, Alice!\n";
        break;
  }
}
</pre>

  <h4>Оператор goto</h4>

  <p>Есть шутка, что оператор безусловного перехода goto — это ругательное слово из четырёх букв. Безусловные переходы ломают иерархичность программы, затрудняют чтение и отладку. Доказано, что любую программу можно переписать без оператора goto. Поэтому во многих современных языках goto отсутствует.</p>
  <p>Однако в C++ этот оператор есть по следующим причинам:</p>
  <ul>
    <li>обратная совместимость с языком С;</li>
    <li>удобный выход из вложенных циклов;</li>
    <li>применение в автосгенерированном коде (например, коде конечного автомата), не предназначенном для чтения человеком.</li>
  </ul>
  <p>Мы познакомимся с его синтаксисом, но дальше использовать нигде не будем — и вам не советуем.</p>
<pre>
int main() {
  again:  // метка — это произвольное имя с двоеточием

  std::cout &lt;&lt; "How old are you?\n";
  int age;
  std::cin >> age;

  if (age &lt; 0 || age >= 128) {
    std::cout &lt;&lt; "Wrong age...\n";
    goto again;  // безусловный прыжок в место, помеченное меткой
  }

  std::cout &lt;&lt; "Your age is " &lt;&lt; age &lt;&lt; ".\n";

  // ...
}
</pre>
  <p>Здесь вводится метка again, на которую осуществляется переход, если возраст введён некорректно. Ниже мы покажем, как можно избавиться от оператора goto.</p>
  <p>С помощью оператора goto нельзя выйти из функции или зайти в неё, а также нельзя перепрыгнуть через объявления переменных (кроме тривиальных случаев):</p>
<pre>
#include <iostream>

int main() {
  goto label;
  int x = 42;
  label:  // ошибка компиляции!
  std::cout &lt;&lt; x &lt;&lt; "\n";
}
</pre>

  <h4>Цикл while</h4>

  <p>В C++ существует несколько видов циклов. Цикл while — это цикл с предусловием. Перед очередной итерацией проверяется условие, и если оно истинно, то цикл продолжается. Рассмотрим пример печати таблицы квадратов чисел от 1 до 10:</p>
<pre>
#include <iostream>

int main() {
  int n = 1;
  while (n &lt;= 10) {
    // выводим число и его квадрат через табуляцию
    std::cout &lt;&lt; n &lt;&lt; "\t" &lt;&lt; n * n &lt;&lt; "\n";
    ++n;
  }
}
</pre>
  <p>Здесь мы намеренно разделяем числа и их квадраты не пробелом, а знаком табуляции \t. В консоли такой вывод будет выглядеть выровненным по колонкам с фиксированной шириной:</p>
<pre>
1	  1
2	  4
3	  9
4	  16
5	  25
6	  36
7	  49
8	  64
9	  81
10	100
</pre>

  <h4>Цикл do-while</h4>

  <p>Это цикл с постусловием. Отличие от цикла while заключается в том, что первая итерация всегда выполняется безусловно. Только после её завершения проверяется условие цикла. Если оно истинно, то цикл продолжается.</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int n = 1;
  do {
    std::cout &lt;&lt; n &lt;&lt; "\t" &lt;&lt; n * n &lt;&lt; "\n";
    ++n;
  } while (n &lt;= 10);
}
</pre>
  <p>Без особых причин пользоваться этим видом циклов не стоит, старайтесь использовать циклы while или for.</p>

  <h4>Цикл for</h4>

  <p>Цикл for — самый гибкий. Он записывается так:</p>
<pre>
for (initialization; condition; action) {
  // тело цикла
}
</pre>
  <p>Как правило, с циклом ассоциируется некоторый параметр, который меняется от итерации к итерации, а цикл выполняется до тех пор, пока некоторое условие на этот параметр истинно.</p>

  <p>Начальное значение такого параметра можно задать в разделе initialization, условие — в condition, а действие над параметром, выполняющееся после каждой итерации, — в action.</p>

  <p>Напечатаем таблицу квадратов через цикл for:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  for (int i = 1; i &lt;= 10; ++i) {
    std::cout &lt;&lt; i &lt;&lt; "\t" &lt;&lt; i * i &lt;&lt; "\n";
  }
}
</pre>
  <p>Напомним, что ++i — традиционная краткая форма записи для выражения i = i + 1.</p>
  <p>Цикл for эквивалентен такому циклу while:</p>
<pre>
{
  initialization;
  while (condition) {
    // тело цикла
    action;
  }
}
</pre>

  <h4>Цикл range-based for</h4>

  <p>Этот цикл применим к контейнерам разной природы (массивам, векторам, спискам и т. д.), с которыми мы познакомимся позже. Пока рассмотрим его на примере строк. Цикл позволяет удобно проитерироваться по символам строки, не используя индексов. В этом примере мы считываем строку и печатаем отдельно все символы строки и их ASCII-коды:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string line;
  std::getline(std::cin, line);
  for (char symbol : line) {
    std::cout &lt;&lt; symbol &lt;&lt; "\t"
    &lt;&lt; static_cast&lt;int&gt;(symbol) &lt;&lt; "\n";
  }
}
</pre>
  <p>Здесь оператор static_cast преобразует символ к числовому типу int, чтобы получить его код. Результат для строки Hello, world! выглядит так:</p>
<pre>
H	72
e	101
l	108
l	108
o	111
,	44
 	32
w	119
o	111
r	114
l	108
d	100
!	33
</pre>
  <p>Обратите внимание, что std::string хранит внутри байты. Если вы вводите символы русского алфавита и у вас используется кодировка UTF-8, ставшая де-факто стандартом, то эти символы будут кодироваться парами байтов. И при такой итерации вы увидите отдельные байты, а не символы.</p>

  <h4>Вложенные циклы</h4>

  <p>Циклы могут быть вложенными. Напечатаем таблицу умножения:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  for (int i = 1; i &lt;= 10; ++i) {
    for (int j = 1; j &lt;= 10; ++j) {
      std::cout &lt;&lt; i * j &lt;&lt; "\t";
    }
    std::cout &lt;&lt; "\n";
  }
}
</pre>
  <p>Результат:</p>
<pre>
  1	   2	 3	 4	 5	 6	 7	 8	 9	10
  2	   4	 6	 8	10	12	14	16	18	20
  3	   6	 9	12	15	18	21	24	27	30
  4	   8	12	16	20	24	28	32	36	40
  5	  10	15	20	25	30	35	40	45	50
  6  	12	18	24	30	36	42	48	54	60
  7	  14	21	28	35	42	49	56	63	70
  8	  16	24	32	40	48	56	64	72	80
  9	  18	27	36	45	54	63	72	81	90
  10	20	30	40	50	60	70	80	90	100
</pre>

  <h4>Операторы break и continue</h4>

  <p>Оператор break досрочно заканчивает текущий цикл. Оператор continue прыгает в самый конец тела цикла и, если условие цикла позволяет, переходит на следующую итерацию.</p>
  <p>Типичный пример использования оператора break — выход из формально бесконечного цикла:</p>
<pre>
while (true) {
  // ...
  if (condition) {
    break;
  }
  // ...
}
</pre>
  <p>Кстати, рассмотрим другие способы записать бесконечный цикл.</p>
  <p>Через цикл do-while:</p>
<pre>
do {
  // ...
} while (true);
</pre>
  <p>Через цикл for:</p>
<pre>
for (;;) {
  // ...
}
</pre>
  <p>Напишем программу, которая считывает числа с клавиатуры до тех пор, пока пользователь не введёт ноль, а затем печатает их сумму:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int sum = 0;
  while (true) {
    int x;
    std::cin >> x;
    if (x == 0) {
      break;
    }
    sum += x;
  }
  std::cout &lt;&lt; sum &lt;&lt; "\n";
}
</pre>
  <p>(Здесь, конечно, неявно предполагается, что и сами числа, и результат суммирования помещаются в тип int, и в ходе вычислений не происходит переполнений.)</p>

  <h4>Считывание до конца ввода</h4>

  <p>В предыдущем примере мы считывали числа до тех пор, пока на вход не поступит ноль. Это не очень удобно. Предположим, что вместо ввода с клавиатуры мы читали бы эти числа из файла. Это легко сделать, перенаправив файл на стандартный ввод при запуске программы из консоли:</p>
  <code>./a.out &lt; input.txt</code>
  <p>Следующий цикл считывает числа до тех пор, пока поступающие данные не закончатся:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int sum = 0;
  int x;
  while (std::cin >> x) {
    sum += x;
  }
  std::cout &lt;&lt; sum &lt;&lt; "\n";
}
</pre>
  <p>Здесь вместо условия цикла подставлено выражение std::cin >> x. Кроме считывания x это выражение преобразуется к логическому типу, показывающему, есть ли ещё данные в потоке ввода.</p>
  <p>При вводе данных не из файла, а с клавиатуры можно сымитировать конец ввода комбинацией клавиш Ctrl+D в Linux и macOS или Ctrl+Z в Windows.</p>
  <p>Аналогично можно прочитать строки до конца ввода с помощью std::getline:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string name;
  while (std::getline(std::cin, name)) {
    std::cout &lt;&lt; "Hello, " &lt;&lt; name &lt;&lt; "!\n";
  }
}
</pre>
</article>


<!-- 2.4 Векторы и строки -->
<article class="article">
  <div class="anchor" id="p2.4"></div>
  <h3>2.4 Векторы и строки</h3>

  <p>Вектор (std::vector) и строка (std::string) — это важные базовые контейнеры стандартной библиотеки C++. Они хранят свои элементы в непрерывном фрагменте памяти. Оба этих контейнера предоставляют доступ к элементам по индексу и позволяют эффективно добавлять новые элементы в конец.</p>

  <h4>Контейнер std::vector</h4>

  <p>В стандартной библиотеке C++ вектором (std::vector) называется динамический массив, обеспечивающий быстрое добавление новых элементов в конец и меняющий свой размер при необходимости. Вектор гарантирует отсутствие утечек памяти (об этом мы поговорим в других параграфах, сейчас просто считайте, что это хорошо).</p>

  <p>Для работы с вектором нужно подключить заголовочный файл vector.</p>

  <p>Элементы вектора должны быть одинакового типа, и этот тип должен быть известен при компиляции программы. Он задаётся в угловых скобках после std::vector: например, std::vector&lt;int&gt; — это вектор целых чисел типа int, а std::vector&lt;std::string&gt; — вектор строк.</p>

  <p>Само имя std::vector не является типом данных: это шаблон, в который требуется подставить нужные параметры (тип элемента), чтобы получился конкретный тип данных. Подробнее о том, что такое шаблоны и как их применять, мы расскажем в параграфе «Шаблоны».</p>

  <p>Рассмотрим пример программы, которая заполняет вектор элементами и печатает их через пробел:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; data = {1, 2, 3, 4, 5};
  for (int elem : data) {
    std::cout &lt;&lt; elem &lt;&lt; " ";
  }
  std::cout &lt;&lt; "\n";
}
</pre>
  <p>Здесь мы инициализируем вектор через список инициализации, в котором элементы перечислены через запятую. Другой способ инициализации вектора — указать число элементов и (при необходимости) образец элемента:</p>
<pre>
#include &lt;string&gt;
#include &lt;vector&gt;

int main() {
  // пустой вектор строк
  std::vector&lt;std::string&gt; v1;
  // вектор из пяти пустых строк
  std::vector&lt;std::string&gt; v2(5);
  // вектор из пяти строк "hello"
  std::vector&lt;std::string&gt; v3(5, "hello");
}
</pre>

  <h4>Обращение к элементам</h4>

  <p>Выше мы использовали для печати элементов вектора цикл range-for. Но иногда удобнее работать с индексами. Вектор хранит элементы в памяти последовательно, поэтому по индексу элемента можно быстро найти его положение в памяти. Индексация начинается с нуля:</p>
<pre>
std::vector&lt;int&gt; data = {1, 2, 3, 4, 5};
// начальный элемент вектора
int a = data[0];
// последний элемент вектора (в нём пять элементов)
int b = data[4];
// меняем элемент 3 на -3
data[2] = -3;
</pre>
  <p>Чтобы узнать общее количество элементов в векторе, можно воспользоваться функцией size:</p>
  <code>std::cout &lt;&lt; data.size() &lt;&lt; "\n";</code>
  <p>Отрицательные индексы, как в некоторых других языках программирования, не допускаются.</p>
  <p>Обратите внимание: когда мы обращаемся по индексу через квадратные скобки, проверки его корректности не происходит.Это ещё одно проявление принципа «мы не должны платить за то, что не используем».</p>
  <p>Встроенные валидаторы замедляют программу: предполагается, что программист пишет правильный код и уверен, что индекс i в выражении data[i] неотрицателен и удовлетворяет условию i &lt; data.size(). В этом случае они ему не нужны.</p>
  <p>Если всё же обратиться к вектору по некорректному индексу, то программа во время выполнения попадёт в неопределённое поведение: фактически она попробует прочитать память, не принадлежащую вектору.</p>
  <p>Если вам не хочется делать много лишних проверок, а в корректности индекса вы не уверены, то можно использовать функцию at:</p>
<pre>
std::vector&lt;int&gt; data = {1, 2, 3, 4, 5};
// неопределённое поведение: может произойти всё что угодно
std::cout &lt;&lt; data[42] &lt;&lt; "\n";
// напечатается 1
std::cout &lt;&lt; data.at(0) &lt;&lt; "\n";
// произойдёт исключение std::out_of_range
// его можно будет перехватить и обработать
std::cout &lt;&lt; data.at(42) &lt;&lt; "\n";
</pre>
  <p>Про работу с исключениями мы поговорим отдельно в параграфе «Обработка исключений».</p>
  <p>Рассмотрим функции вектора front и back, которые возвращают его первый и последний элемент без использования индексов:</p>
<pre>
std::vector&lt;int&gt; data = {1, 2, 3, 4, 5};
// то же, что data[0]
std::cout &lt;&lt; data.front() &lt;&lt; "\n";
то же, что data[data.size() - 1]
std::cout &lt;&lt; data.back() &lt;&lt; "\n";  //
</pre>
  <p>Важно учитывать, что вызов этих функций на пустом векторе приведёт к неопределённому поведению.</p>
  <p>Для проверки вектора на пустоту вместо сравнения data.size() == 0 принято использовать функцию empty, которая возвращает логическое значение:</p>
<pre>
if (!data.empty()) {
  // вектор не пуст, с ним можно работать
}
</pre>

  <h4>Итерация по индексам</h4>

  <p>Так сложилось, что в стандартной библиотеке индексы и размеры контейнеров имеют беззнаковый тип. Вместо unsigned int или unsigned long int для него используется традиционный псевдоним size_t (а точнее, std::vector&lt;T&gt;::size_type). Тип size_t на самом деле совпадает с uint32_t или uint64_t в зависимости от битности платформы. Его использование в программе дополнительно подчёркивает, что мы имеем дело с индексами или с размером.</p>

  <p>Итерацию по элементам data с помощью индексов можно записать так:</p>
<pre>
for (size_t i = 0; i != data.size(); ++i) {
  std::cout &lt;&lt; data[i] &lt;&lt; " ";
}
</pre>
  <p>Это каноническая форма записи такого цикла: в ней принято использовать сравнение != и префиксный ++i. Для целых чисел не будет разницы, если написать это как-то иначе (например, через &lt; и постфиксный i++), но потом, когда вы будете писать аналогичные циклы для итераторов других контейнеров, разница появится. Давайте привыкнем всегда оформлять цикл по индексам так.</p>
  <p>Беззнаковость типа возвращаемого значения функции size порождает следующую проблему. По правилам, унаследованным ещё от языка C, результат арифметических действий над беззнаковым и знаковым типами приводится к беззнаковому типу. Поэтому выражение data.size() - 1, например, тоже будет беззнаковым. Если data.size() окажется нулём, то такое выражение будет вовсе не минус единицей, а самым большим беззнаковым целым (для 64-битной платформы это 2<sup>64</sup>-1).</p>
  <p>Рассмотрим следующий ошибочный код, который проверяет, есть ли в векторе дубликаты, идущие подряд:</p>
<pre>
// итерация по всем элементам, кроме последнего:
for (size_t i = 0; i &lt; data.size() - 1; ++i) {
  if (data[i] == data[i + 1]) {
    std::cout &lt;&lt; "Duplicate value: " &lt;&lt; data[i] &lt;&lt; "\n";
  }
}
</pre>
  <p>Эта программа будет некорректно работать на пустом векторе. Условие i &lt; data.size() - 1 на первой итерации окажется истинным, и произойдёт обращение к элементам пустого вектора. Правильнее было бы переписать это условие через i + 1 &lt; data.size() или воспользоваться внешней функцией std::ssize, которая появилась в C++20. Она возвращает знаковый размер вектора:</p>
<pre>
for (std::int64_t i = 0; i &lt; std::ssize(data) - 1; ++i) {
  if (data[i] == data[i + 1]) {
    std::cout &lt;&lt; "Duplicate value: " &lt;&lt; data[i] &lt;&lt; "\n";
  }
}
</pre>

  <h4>Добавление и удаление элементов</h4>
</article>


<!-- 2.5 Составные типы данных -->
<article class="article">
  <div class="anchor" id="p2.5"></div>
  <h3>2.5 Составные типы данных</h3>
</article>


<!-- 2.6 Ссылки, указатели, константность -->
<article class="article">
  <div class="anchor" id="p2.6"></div>
  <h3>2.6 Ссылки, указатели, константность</h3>
</article>


<!-- 2.7 Функции -->
<article class="article">
  <div class="anchor" id="p2.7"></div>
  <h3>2.7 Функции</h3>
</article>


<!-- 2.8 Шаблоны -->
<article class="article">
  <div class="anchor" id="p2.8"></div>
  <h3>2.8 Шаблоны</h3>
</article>


<!-- 2.9 Разбор задач к главе «Базовые конструкции C++» -->
<article class="article">
  <div class="anchor" id="p2.9"></div>
  <h3>2.9 Разбор задач к главе «Базовые конструкции C++»</h3>
</article>


<!-- 3.1 Последовательные контейнеры -->
<article class="article">
  <div class="anchor" id="p3.1"></div>
  <h2>3 Стандартная библиотека C++</h2>
  <h3>3.1 Последовательные контейнеры</h3>
</article>


<!-- 3.2 Ассоциативные контейнеры -->
<article class="article">
  <div class="anchor" id="p3.2"></div>
  <h3>3.2 Ассоциативные контейнеры</h3>
</article>


<!-- 3.3 Алгоритмы -->
<article class="article">
  <div class="anchor" id="p3.3"></div>
  <h3>3.3 Алгоритмы</h3>
</article>


<!-- 3.4 Адаптеры и представления -->
<article class="article">
  <div class="anchor" id="p3.4"></div>
  <h3>3.4 Адаптеры и представления</h3>
</article>


<!-- 3.5 Разбор задач к главе «Стандартная библиотека C++» -->
<article class="article">
  <div class="anchor" id="p3.5"></div>
  <h3>3.5 Разбор задач к главе «Стандартная библиотека C++»</h3>
</article>


<!-- 4.1 Классы -->
<article class="article">
  <div class="anchor" id="p4.1"></div>
  <h2>4 Идиомы C++</h2>
  <h3>4.1 Классы</h3>
</article>


<!-- 4.2 Шаблонные классы -->
<article class="article">
  <div class="anchor" id="p4.2"></div>
  <h3>4.2 Шаблонные классы</h3>
</article>


<!-- 4.3 Жизненный цикл объекта -->
<article class="article">
  <div class="anchor" id="p4.3"></div>
  <h3>4.3 Жизненный цикл объекта</h3>
</article>


<!-- 4.4 Наследование и полиморфизм -->
<article class="article">
  <div class="anchor" id="p4.4"></div>
  <h3>4.4 Наследование и полиморфизм</h3>
</article>


<!-- 4.5 Обработка исключений -->
<article class="article">
  <div class="anchor" id="p4.5"></div>
  <h3>4.5 Обработка исключений</h3>
</article>


<!-- 4.6 Идиома RAII и умные указатели -->
<article class="article">
  <div class="anchor" id="p4.6"></div>
  <h3>4.6 Идиома RAII и умные указатели</h3>
</article>


<!-- 4.7 Разбор задач к главе «Идиомы C++» -->
<article class="article">
  <div class="anchor" id="p4.7"></div>
  <h3>4.7 Разбор задач к главе «Идиомы C++»</h3>
</article>



<!-- 5.1 Как работать с системой проверки заданий -->
<article class="article">
  <div class="anchor" id="p5.1"></div>
  <h2>5 Приложение</h2>
  <h3>5.1 Как работать с системой проверки заданий</h3>
</article>


<!-- 5.2 Как пользоваться хендбуком -->
<article class="article">
  <div class="anchor" id="p5.2"></div>
  <h3>5.2 Как пользоваться хендбуком</h3>
</article>


