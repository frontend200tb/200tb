<article class="article">
  <h1>Яндекс Образования. Хендбук. Основы С++</h1>
  <p>Конспект курса</p>
  <p><a href="https://education.yandex.ru/handbook/cpp" taget="_blank">https://education.yandex.ru/handbook/cpp</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
    <a href="#p1">1 Введение</a>
    <br><a href="#p1.1">1.1 Введение</a>
  </p>

  <p>
    <a href="#p2">2 Базовые конструкции C++</a>
    <br><a href="#p2.1">2.1 Первые шаги</a>
    <br><a href="#p2.2">2.2 Типы данных</a>
    <br><a href="#p2.3">2.3 Ветвления и циклы</a>
    <br><a href="#p2.4">2.4 Векторы и строки</a>
    <br><a href="#p2.5">2.5 Составные типы данных</a>
    <br><a href="#p2.6">2.6 Ссылки, указатели, константность</a>
    <br><a href="#p2.7">2.7 Функции</a>
    <br><a href="#p2.8">2.8 Шаблоны</a>
    <br><a href="#p2.9">2.9 Разбор задач к главе «Базовые конструкции C++»</a>
  </p>

  <p>
    <a href="#p3">3 Стандартная библиотека C++</a>
    <br><a href="#p3.1">3.1 Последовательные контейнеры</a>
    <br><a href="#p3.2">3.2 Ассоциативные контейнеры</a>
    <br><a href="#p3.3">3.3 Алгоритмы</a>
    <br><a href="#p3.4">3.4 Адаптеры и представления</a>
    <br><a href="#p3.5">3.5 Разбор задач к главе «Стандартная библиотека C++»</a>
  </p>

  <p>
    <a href="#p4">4 Идиомы C++</a>
    <br><a href="#p4.1">4.1 Классы</a>
    <br><a href="#p4.2">4.2 Шаблонные классы</a>
    <br><a href="#p4.3">4.3 Жизненный цикл объекта</a>
    <br><a href="#p4.5">4.4 Наследование и полиморфизм</a>
    <br><a href="#p4.4">4.5 Обработка исключений</a>
    <br><a href="#p4.6">4.6 Идиома RAII и умные указатели</a>
    <br><a href="#p4.7">4.7 Разбор задач к главе «Идиомы C++»</a>
  </p>

  <p>
    <a href="#p5">5 Приложение</a>
    <br><a href="#p5.1">5.1 Как работать с системой проверки заданий</a>
    <br><a href="#p5.2">5.2 Как пользоваться хендбуком</a>
  </p>

</article>


<!-- 1 Введение -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h2>1 Введение</h2>
</article>


<!-- 1.1 Введение -->
<article class="article">
  <div class="anchor" id="p1.1"></div>
  <h3>1.1 Введение</h3>

  <p>Перед вами учебник по основам языка C++. При его создании мы вдохновлялись специализацией «Искусство разработки на современном C++» на «Курсере», созданной при поддержке Яндекса, и курсом «Основы и методология программирования», который читался в 2014–2021 годах на факультете компьютерных наук ВШЭ.</p>

  <p>Языку C++ почти 40 лет, но он по-прежнему очень актуален и востребован. Он оказал огромное влияние на индустрию и на другие языки. C++ был разработан Бьярне Страуструпом в начале 1980-х годов как расширение языка C (и даже изначально назывался «Си с классами»).</p>

  <p>Однако для изучения C++ совсем не обязательно знать C. Тем не менее мы предполагаем, что вы знакомы с основами информатики и владеете каким-либо языком программирования на уровне школьной программы — например, языком Python.</p>

  <p>Впрочем, C++ во многом полностью противоположен Python:</p>
  <ul>
    <li>это компилируемый, а не интерпретируемый язык;</li>
    <li>С++ — язык со статической, а не динамической типизацией;</li>
    <li>в C++ возможно ручное управление памятью (в отличие от автоматической сборки мусора).</li>
  </ul>

  <p>Чтобы исходный код программы на C++ превратился в исполняемый файл для конкретной архитектуры процессора, программу нужно скомпилировать. Существует несколько популярных компиляторов C++:</p>
  <ul>
    <li>GNU Compiler Collection (GCC);</li>
    <li>Clang — построен поверх инфраструктуры LLVM;</li>
    <li>Microsoft Visual C++ (MSVC) — входит в состав Microsoft Visual Studio;</li>
    <li>Intel C++ Compiler.</li>
  </ul>

  <p>Мы будем использовать в примерах и при проверке задач компилятор Clang 16-й версии.</p>

  <p>С 1998 года международный комитет по стандартизации C++ выпускает стандарты — версии языка, в которых описываются его возможности. В первую очередь это руководства для создателей компиляторов, но при возникновении спорных моментов всегда полезно обратиться к стандарту. Мы будем ориентироваться на стандарт C++20, а по ссылке можно ознакомиться с черновиком будущего стандарта. Важно понимать, что стандарт определяет лишь общие требования и не фиксирует детали реализации, которые в разных компиляторах могут отличаться.</p>

  <p>Чтобы проверить, поддерживает ли ваша версия компилятора ту или иную особенность C++, советуем пользоваться специальной таблицей.</p>

  <p>При изучении вам будут полезны следующие англоязычные ресурсы:</p>
  <ul>
    <li>cppreference.com — онлайн-документация по C++;</li>
    <li>isocpp.org — сайт Standard C++ Foundation;</li>
    <li>C++ Core Guidelines — гайдлайны по C++ от Бьярне Страуструпа и Герба Саттера;</li>
    <li>godbolt.org — Compiler Explorer, онлайн-компилятор;</li>
    <li>learncpp.com — современный учебник по C++;</li>
    <li>hacking C++ — наглядный справочник по C++ с картинками и инфографикой.</li>
  </ul>

  <p>В тексте мы будем часто ссылаться на англоязычную версию cppreference.com и на английскую «Википедию».</p>

  <p>Написать программу для C++ можно в любом текстовом редакторе, но удобнее пользоваться средой разработки (IDE). IDE включают редактор кода с подсветкой синтаксиса, а также позволяют компилировать, запускать и отлаживать программы.</p>

  <p>Примеры IDE:</p>
  <ul>
    <li>Microsoft Visual Studio Community</li>
    <li>Eclipse CDT</li>
    <li>Code::Blocks</li>
    <li>Qt Creator</li>
    <li>Xcode</li>
  </ul>

  <p>Мы рассчитываем, что вы сможете самостоятельно разобраться с настройкой и использованием среды разработки, и не будем заострять на этом внимание. В наших примерах мы будем запускать компилятор из консоли.</p>

  <p>К нашему учебнику прилагается набор задач по соответствующим темам. Вы можете сдавать их в автоматическую проверяющую систему. В одних задачах требуется написать полноценную программу, а в других — сдать только код функции или класса. Обратите внимание, что ко всем задачам имеются разборы с авторскими решениями. Найти разборы вы можете в конце глав.</p>

  <p>Ho прежде чем мы двинемся дальше — небольшое объявление: для этого хендбука у нас есть коммьюнити студентов. В нём можно найти единомышленников, обсудить материалы и задания. Вступить в него можно по <a href="https://t.me/handbook_cpp">ссылке</a>. А чтобы быть в курсе обновлений хендбука — советуем подписаться на рассылку.</p>
</article>


<!-- 2 Базовые конструкции C++ -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h2>2 Базовые конструкции C++</h2>
</article>


<!-- 2.1 Первые шаги -->
<article class="article">
  <div class="anchor" id="p2.1"></div>
  <h2>2 Базовые конструкции C++</h2>
  <h3>2.1 Первые шаги</h3>

  <p>В этом параграфе мы напишем первую программу на C++ и научимся печатать и считывать с клавиатуры строки и числа.</p>

  <h4>Функция main</h4>
  <p>Пожалуй, самая простая и короткая программа на C++ — это программа, которая ничего не делает. Она выглядит так:</p>
<pre>
int main() {
  return 0;
}
</pre>
  <p>Здесь определяется функция с именем main, которая не принимает никаких аргументов (внутри круглых скобок ничего нет) и не выполняет никаких содержательных команд. В каждой программе на C++ должна быть ровно одна функция main — с неё начинается выполнение программы.</p>

  <p>У функции указан тип возвращаемого значения int (целое число), и она возвращает 0 — в данном случае это сообщение для операционной системы, что программа выполнилась успешно. И наоборот, ненулевой код возврата означает, что при выполнении возникла ошибка (например, программа получила некорректные входные данные).</p>

  <p>Для функции main разрешается не писать завершающий return 0, чем мы и будем пользоваться далее для краткости. Поэтому самую короткую программу можно было бы написать вот так:</p>
<pre>
int main() {
}
</pre>

  <h4>Hello, world!</h4>
  <p>Соблюдая традиции, напишем простейшую программу на C++ — она выведет приветствие в консоль:</p>
<pre>
#include <iostream>

int main() {
  std::cout &lt;&lt; "Hello, world!\n";
}
</pre>
  <p>Разберём её подробнее.</p>

  <p>Директива #include &lt;iostream&gt; подключает стандартный библиотечный заголовочный файл для работы с потоками ввода-вывода (input-output streams). Для печати мы используем поток вывода std::cout, где cout расшифровывается как character output, то есть «символьный вывод».</p>

  <p>В теле функции main мы передаём в std::cout строку Hello, world! с завершающим переводом строки \n. В зависимости от операционной системы \n будет преобразован в один или в два управляющих байта с кодами 0A или 0D 0A соответственно.</p>

  <p>Инструкции внутри тела функции завершаются точками с запятой.</p>

  <h4>Компиляция из командной строки</h4>
  <p>Вы можете запустить эту программу из какой-нибудь IDE. Мы же покажем, как собрать её в консоли Linux с помощью компилятора clang++.</p>

  <p>Пусть файл с программой называется hello.cpp. Запустим компилятор:</p>
  <code>$ clang++ hello.cpp -o hello</code>
  <p>В результате мы получим исполняемый файл с именем hello, который теперь можно просто запустить. Он напечатает на экране ожидаемую фразу:</p>
<pre>
$ ./hello
Hello, world!
</pre>
  <p>Если опцию -o не указать, то сгенерированный исполняемый файл будет по умолчанию назван a.out. В дальнейшем для простых примеров мы будем использовать краткую форму записи команды:</p>
<pre>
$ clang++ hello.cpp && ./a.out
Hello, world!
</pre>
  <p>С её помощью мы компилируем программу и в случае успеха компиляции сразу же запускаем.</p>

  <h4>Комментарии</h4>
  <p>Комментарии — это фрагменты программы, которые игнорируются компилятором и предназначены для программиста. В C++ есть два вида комментариев — однострочные и многострочные:</p>
<pre>
int main() {  // однострочный комментарий продолжается до конца строки

/* Пример
   многострочного
   комментария */
}
</pre>
  <p>Мы будем использовать комментарии в примерах кода для пояснений, а в реальных программах ими лучше не злоупотреблять.</p>

  <p>Хорошо: комментировать, что делает библиотека, функция или класс или почему этот код написан именно так.</p>

  <p>Плохо: комментировать, что происходит на отдельных строчках. Это признак того, что код можно написать лучше.</p>

  <h4>Библиотеки и заголовочные файлы</h4>
  <p>Библиотека — это код, который можно переиспользовать в разных программах. В стандарт языка C++ входит спецификация так называемой стандартной библиотеки, которая поставляется вместе с компилятором. Она содержит различные структуры данных (контейнеры), типовые алгоритмы, средства ввода-вывода и т. д. Конструкции из этой библиотеки предваряются префиксом std::, который обозначает пространство имён.</p>

  <p>Чтобы воспользоваться теми или иными библиотечными конструкциями, в начале программы надо подключить нужные заголовочные файлы. Так, в программе, которая печатала Hello, world!, нам уже встречался заголовочный файл iostream и конструкция std::cout из стандартной библиотеки.</p>

  <p>Для C++ существует также множество сторонних библиотек. Наиболее известной коллекцией сторонних библиотек для C++ является Boost.</p>

  <h4>Ошибки компиляции</h4>
  <p>Перед запуском программу необходимо скомпилировать. Компилятор проверяет корректность программы и генерирует исполняемый файл. Во время компиляции компилятор может обнаружить синтаксические ошибки.</p>

  <p>Рассмотрим пример такой программы:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  cout &lt;&lt; "Hello, world\n"
</pre>
  <p>Первая ошибка — вместо std::cout мы написали cout. Вторая ошибка — не поставили точку запятой после "Hello, world!\n". Наконец, третья – не закрыли фигурную скобку с телом функции.</p>

  <p>Ошибки компиляции (compile errors) следует отличать от возможных ошибок времени выполнения (runtime errors), которые происходят после запуска программы и, как правило, зависят от входных данных, неизвестных во время компиляции.</p>

  <h4>Отступы и оформление кода</h4>
  <p>Фрагменты программы на C++ могут быть иерархически вложены друг в друга. На верхнем уровне находятся функции, внутри них написаны их тела, в теле могут быть составные операторы, и так далее.</p>

  <p>Среди программистов есть соглашение — писать внутренние блоки кода с отступами вправо: компилятор полностью игнорирует эти отступы, а код читать удобнее. Мы будем использовать отступы в четыре пробела. Также мы будем придерживаться стиля оформления кода, принятого в Яндексе. Имена переменных мы будем писать с маленькой буквы, имена функций и классов — с большой (если речь не идёт о конструкциях стандартной библиотеки, где действуют другие соглашения).</p>

  <h4>Переменные</h4>
  <p>Любая содержательная программа так или иначе обрабатывает данные в памяти. Переменная — это именованный блок данных определённого типа. Чтобы определить переменную, нужно указать её тип и имя. В общем виде это выглядит так:</p>
  <code>Type name;</code>
  <p>где Type — конкретный тип данных (например, строка или число), а name — имя переменной. Имена переменных должны состоять из латинских букв, цифр и знаков подчёркивания и не должны начинаться с цифры. Также можно в одной строке определить несколько переменных одного типа:</p>
  <code>Type name1, name2, name3;</code>
  <p>Например:</p>
<pre>
// библиотека, в которой
// определён тип std::string
#include &lt;string&gt;

int main() {
  // Определяем переменную value
  // целочисленного типа int
  int value;

  // Определяем переменные name и surname
  // типа std::string (текстовая строка)
  std::string name, surname;
}
</pre>
  <p>В этом примере мы используем встроенный в язык тип int (от слова integer — целое число) и поставляемый со стандартной библиотекой тип std::string. (Можно было бы использовать для строк встроенный тип с массивом символов, но это неудобно.)</p>

  <p>Тип переменной должен быть известен компилятору во время компиляции.</p>

  <p>От типа зависит:</p>
  <ul>
    <li>сколько байтов памяти потребуется для хранения данных;</li>
    <li>как интерпретировать эти байты;</li>
    <li>какие операции с этой переменной возможны.</li>
  </ul>

  <p>Например, переменной типа int можно присваивать значения и с ней можно производить арифметические операции. Подробнее про разные типы данных и их размер в памяти мы поговорим ниже.</p>
  <p>Важно понимать, что тип остаётся с переменной навсегда. Например, присвоить целочисленной переменной строку не получится — это вызовет ошибку компиляции:</p>
<pre>
int main() {
  int value;
  value = 42;  // OK
  value = "Hello!";  // ошибка компиляции!
}
</pre>
  <p>Переменные можно сразу проинициализировать значением. В С++ есть много разных способов инициализации. Нам пока будет достаточно способа, который называется copy initialization:</p>
<pre>
#include &lt;string&gt;

int main() {
  int value = 42;
  std::string title = "Bjarne Stroustrup";
}
</pre>
  <p>Если переменная была объявлена, но нигде дальше не использовалась, то компилятор выдаёт об этом предупреждение. При проверке решений мы используем опцию -Werror, которая считает предупреждения компилятора ошибками компиляции.</p>

  <h4>Потоковый ввод и вывод</h4>
  <p>Поток — это абстракция для чтения и записи последовательности данных в форматированном виде.</p>

  <p>Записывать данные можно на экран консоли, в файл, буфер в памяти или в строку. Считывать их можно с клавиатуры, из файла, из памяти. Причём с каждым таким «устройством» можно связать свой поток.</p>

  <p>Важно, что потоки не просто пересылают байты памяти, а применяют форматированный человекочитаемый ввод-вывод. Например, числа печатаются и считываются в десятичной нотации, хотя в памяти компьютера они хранятся в двоичном виде.</p>

  <p>В программе Hello, world! нам уже встречался поток вывода std::cout, по умолчанию связанный с экраном консоли. Познакомимся с потоком ввода std::cin, связанным с клавиатурой. Для его использования нужен тот же заголовочный файл iostream.</p>

  <p>Рассмотрим программу, которая спрашивает имя пользователя и печатает персональное приветствие:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string name;  // объявляем переменную name
  std::cout &lt;&lt; "What is your name?\n";
  std::cin >> name;  // считываем её значение с клавиатуры
  std::cout &lt;&lt; "Hello, " &lt;&lt; name &lt;&lt; "!\n";
}
</pre>
  <p>Обратите внимание на направление угловых скобок в этом примере — они условно показывают направление потока данных. При печати данные выводятся на экран, и стрелки направлены от текста к cout. При вводе данные поступают с клавиатуры, и стрелки направлены от cin к переменной.</p>

  <p>В нашем примере в переменную name считается одно слово, которое будет выведено в ответном сообщении. Пример работы программы:</p>
<pre>
What is your name?
Alice
Hello, Alice!
</pre>
  <p>Однако если ввести строку из нескольких слов с пробелами, то в name запишется только первое слово:</p>
<pre>
$ ./a.out
What is your name?
Alice Liddell
Hello, Alice!
</pre>
  <p>Дело в том, что cin читает поток данных до ближайшего пробельного разделителя (пробела, табуляции, перевода строки или просто конца файла). Чтобы считать в строковую переменную всю строчку целиком (не включая завершающий символ перевода строки), нужно использовать функцию std::getline из заголовочного файла string:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string name;
  std::getline(std::cin, name);
  std::cout &lt;&lt; "Hello, " &lt;&lt; name &lt;&lt; "!\n";
}
</pre>
  <p>В этом примере мы печатаем в одном выражении друг за другом несколько строк ("Hello, ", name и "!\n"), разделённых угловыми скобками &lt;&lt;. Таким образом, cin и cout позволяют кратко считывать и печатать несколько объектов одной командой.</p>

  <p>Например, считывание нескольких чисел целого типа, набранных через пробельные разделители, может выглядеть так:</p>
<pre>
int main() {
  int a;
  int b;
  int c;
  std::cin >> a >> b >> c;
}
</pre>
  <p>Напечатать их значения можно следующим образом:</p>
  <code>std::cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; " " &lt;&lt; c &lt;&lt; "\n";</code>
  <p>Обратите внимание, что мы дополнительно вставляем между ними пробелы, чтобы в выводе числа не слиплись вместе. В конце вывода мы вставляем символ перевода строки \n, чтобы отделить этот результат от последующего вывода или от сообщений командной строки.</p>

  <p>Итак, параграф позади! Впереди вас ждут первые задачи. Но прежде чем приступить к ним, советуем сперва взглянуть на небольшое руководство о том, как пользоваться системой проверки заданий.</p>
</article>


<!-- 2.2 Типы данных -->
<article class="article">
  <div class="anchor" id="p2.2"></div>
  <h3>2.2 Типы данных</h3>
  <p>C++ — язык со статической типизацией. У каждой переменной на этапе компиляции должен быть чётко определённый тип данных. Про каждый тип данных заранее известно, сколько места в памяти занимает переменная такого типа.</p>

  <p>В этом параграфе мы познакомимся с некоторыми базовыми типами данных и с понятием области видимости переменных.</p>

  <h4>Области видимости</h4>
  <p>В С++ существует понятие области видимости (scope) переменной. Эта область ограничивается блоком кода, в котором переменная определена. Рассмотрим пример:</p>
<pre>
#include &lt;iostream&gt;

int a = 1;  // глобальная переменная

int main() {
  int b = 2;  // локальная переменная
  {
    int c = 3;  // локальная переменная внутри блока
    std::cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b
    &lt;&lt; " " &lt;&lt; c &lt;&lt; "\n";  // корректно
  }

  // Эта строчка не скомпилируется,
  // так как переменная c не определена в данной области:
  std::cout &lt;&lt; c &lt;&lt; "\n";
}
</pre>
  <p>В этом примере есть три области:</p>
  <ul>
    <li>глобальная, в которой определена переменная a;</li>
    <li>тело функции main, в которой определена переменная b;</li>
    <li>внутренний блок, в котором определена переменная c.</li>
  </ul>
  <p>В последней строке примера переменная c недоступна, так как её область видимости уже закончилась. В случае коллизии имён компилятор всегда выбирает самую вложенную область видимости.</p>

  <p>Рассмотрим пример:</p>
<pre>
#include <iostream>

int main() {
  int x = 1;
  // напечатает 1
  std::cout &lt;&lt; x &lt;&lt; "\n";
  {
    // новая переменная, к предыдущему x не имеет отношения
    int x = 2;
    // напечатает 2
    std::cout &lt;&lt; x &lt;&lt; "\n";
  }
  // снова напечатает 1
  std::cout &lt;&lt; x &lt;&lt; "\n";
}
</pre>

  <h4>Инициализация локальных переменных</h4>
  <p>Локальные переменные простых типов, таких как int, не инициализируются по умолчанию нулём. Компилятор просто выделяет для них байты в стековой памяти, но при этом он не обязан как-либо их заполнять. Это один из принципов C++: мы не должны платить за то, что не используем.</p>

  <p>Следующий фрагмент кода может напечатать всё что угодно:</p>
<pre>
#include <iostream>

int main() {
  int x;
  // неопределённое поведение!
  std::cout &lt;&lt; x &lt;&lt; "\n";
  int y;
  // а это допустимый сценарий
  std::cin >> y;
}
</pre>
  <p>Компиляторы g++ и clang++ обычно дают предупреждения о чтении неинициализированных переменных при использовании опции -Wall или -Wuninitialized:</p>
  <p>Заметим, что std::string является сложным типом и переменные такого типа всегда по умолчанию инициализируются пустой строкой. Поэтому нет необходимости писать std::string s = "";. Пишите просто std::string s;.</p>

  <h4>Простые типы данных</h4>
  <p>С типом int мы уже знакомы. Рассмотрим другие фундаментальные типы данных в С++. Это так называемые интегральные типы и типы для вещественных чисел.</p>
<pre>
int main() {
  char c = '1';    // символ
  bool b = true;   // логическая переменная, принимает значения false и true
  int i = 42;      // целое число (занимает, как правило, 4 байта)
  short int si = 17;           // короткое целое (занимает 2 байта)
  long li = 12321321312;       // длинное целое (как правило, 8 байт)
  long long lli = 12321321312; // длинное целое (как правило, 8 байт)
  float f = 2.71828;           // дробное число с плавающей запятой (4 байта)
  double d = 3.141592;         // дробное число двойной точности (8 байт)
  long double ld = 1e15;       // длинное дробное (как правило, 16 байт)
}
</pre>
  <p>Обратите внимание, что символы, в отличие от строк (то есть массивов символов), записываются в апострофах, а не в кавычках. В примере выше мы записываем в переменную c символ единицы. Фактически в памяти хранится ASCII-код этого символа, который равен 49.</p>

  <p>Напомним, что каждый тип данных занимает заранее известное количество байтов памяти. Стандарт языка С++ не накладывает жёстких ограничений на размеры типов, они могут отличаться для разных платформ и компиляторов.</p>

  <p>О том, что делать с этой особенностью, мы расскажем ниже. А пока отметим, что узнать размер переменной или типа на этапе компиляции можно с помощью оператора sizeof.</p>

  <p>Например, на 64-битной Linux-системе компилятор clang++ использует такие размеры для типов:</p>
<pre>
int main() {
  std::cout &lt;&lt; "char: " &lt;&lt; sizeof(char) &lt;&lt; "\n";                 //  1
  std::cout &lt;&lt; "bool: " &lt;&lt; sizeof(bool) &lt;&lt; "\n";                 //  1
  std::cout &lt;&lt; "short int: " &lt;&lt; sizeof(short int) &lt;&lt; "\n";       //  2 (по стандарту >= 2)
  std::cout &lt;&lt; "int: " &lt;&lt; sizeof(int) &lt;&lt; "\n";                   //  4 (по стандарту >= 2)
  std::cout &lt;&lt; "long int: " &lt;&lt; sizeof(long int) &lt;&lt; "\n";         //  8 (по стандарту >= 4)
  std::cout &lt;&lt; "long long int: " &lt;&lt; sizeof(long long) &lt;&lt; "\n";   //  8 (по стандарту >= 8)
  std::cout &lt;&lt; "float: " &lt;&lt;sizeof(float) &lt;&lt; "\n";               //  4
  std::cout &lt;&lt; "double: " &lt;&lt; sizeof(double) &lt;&lt; "\n";             //  8
  std::cout &lt;&lt; "long double: " &lt;&lt; sizeof(long double) &lt;&lt; "\n";   // 16
}
</pre>

  <h4>Размеры стандартных типов</h4>
  <p></p>По умолчанию числовые типы – знаковые. Они имеют диапазон значений от -2<sup>n-1</sup> до 2<sup>n-1</sup> - 1, где n – количество битов, занимаемых типом. Приставка unsigned перед типом делает его беззнаковым. В этом случае диапазон допустимых значений будет от 0 до 2<sup>n</sup> - 1:
</article>


<!-- 2.3 Ветвления и циклы -->
<article class="article">
  <div class="anchor" id="p2.3"></div>
  <h3>2.3 Ветвления и циклы</h3>
</article>


<!-- 2.4 Векторы и строки -->
<article class="article">
  <div class="anchor" id="p2.4"></div>
  <h3>2.4 Векторы и строки</h3>
</article>


<!-- 2.5 Составные типы данных -->
<article class="article">
  <div class="anchor" id="p2.5"></div>
  <h3>2.5 Составные типы данных</h3>
</article>


<!-- 2.6 Ссылки, указатели, константность -->
<article class="article">
  <div class="anchor" id="p2.6"></div>
  <h3>2.6 Ссылки, указатели, константность</h3>
</article>


<!-- 2.7 Функции -->
<article class="article">
  <div class="anchor" id="p2.7"></div>
  <h3>2.7 Функции</h3>
</article>


<!-- 2.8 Шаблоны -->
<article class="article">
  <div class="anchor" id="p2.8"></div>
  <h3>2.8 Шаблоны</h3>
</article>


<!-- 2.9 Разбор задач к главе «Базовые конструкции C++» -->
<article class="article">
  <div class="anchor" id="p2.9"></div>
  <h3>2.9 Разбор задач к главе «Базовые конструкции C++»</h3>
</article>


<!-- 3 Стандартная библиотека C++ -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h2>3 Стандартная библиотека C++</h2>
</article>


<!-- 3.1 Последовательные контейнеры -->
<article class="article">
  <div class="anchor" id="p3.1"></div>
  <h3>3.1 Последовательные контейнеры</h3>
</article>


<!-- 3.2 Ассоциативные контейнеры -->
<article class="article">
  <div class="anchor" id="p3.2"></div>
  <h3>3.2 Ассоциативные контейнеры</h3>
</article>


<!-- 3.3 Алгоритмы -->
<article class="article">
  <div class="anchor" id="p3.3"></div>
  <h3>3.3 Алгоритмы</h3>
</article>


<!-- 3.4 Адаптеры и представления -->
<article class="article">
  <div class="anchor" id="p3.4"></div>
  <h3>3.4 Адаптеры и представления</h3>
</article>


<!-- 3.5 Разбор задач к главе «Стандартная библиотека C++» -->
<article class="article">
  <div class="anchor" id="p3.5"></div>
  <h3>3.5 Разбор задач к главе «Стандартная библиотека C++»</h3>
</article>


<!-- 4 Идиомы C++ -->
<article class="article">
  <div class="anchor" id="p4"></div>
  <h2>4 Идиомы C++</h2>
</article>


<!-- 4.1 Классы -->
<article class="article">
  <div class="anchor" id="p4.1"></div>
  <h3>4.1 Классы</h3>
</article>


<!-- 4.2 Шаблонные классы -->
<article class="article">
  <div class="anchor" id="p4.2"></div>
  <h3>4.2 Шаблонные классы</h3>
</article>


<!-- 4.3 Жизненный цикл объекта -->
<article class="article">
  <div class="anchor" id="p4.3"></div>
  <h3>4.3 Жизненный цикл объекта</h3>
</article>


<!-- 4.4 Наследование и полиморфизм -->
<article class="article">
  <div class="anchor" id="p4.4"></div>
  <h3>4.4 Наследование и полиморфизм</h3>
</article>


<!-- 4.5 Обработка исключений -->
<article class="article">
  <div class="anchor" id="p4.5"></div>
  <h3>4.5 Обработка исключений</h3>
</article>


<!-- 4.6 Идиома RAII и умные указатели -->
<article class="article">
  <div class="anchor" id="p4.6"></div>
  <h3>4.6 Идиома RAII и умные указатели</h3>
</article>


<!-- 4.7 Разбор задач к главе «Идиомы C++» -->
<article class="article">
  <div class="anchor" id="p4.7"></div>
  <h3>4.7 Разбор задач к главе «Идиомы C++»</h3>
</article>


<!-- 5 Приложение -->
<article class="article">
  <div class="anchor" id="p5"></div>
  <h2>5 Приложение</h2>
</article>


<!-- 5.1 Как работать с системой проверки заданий -->
<article class="article">
  <div class="anchor" id="p5.1"></div>
  <h3>5.1 Как работать с системой проверки заданий</h3>
</article>


<!-- 5.2 Как пользоваться хендбуком -->
<article class="article">
  <div class="anchor" id="p5.2"></div>
  <h3>5.2 Как пользоваться хендбуком</h3>
</article>


