<article class="article">
  <h1>Яндекс Образования. Хендбук. Основы С++</h1>
  <p>Конспект курса</p>
  <p><a href="https://education.yandex.ru/handbook/cpp" target="_blank">https://education.yandex.ru/handbook/cpp</a></p>
  <p>Авторы: Алексей Зобнин (Яндекс), Владимир Кузнецов (Яндекс), Артём Брустовецкий (Clever Inc. (Kahoot)).</p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
    <a href="#p1.1">1 Введение</a>
    <br><a href="#p1.1">1.1 Введение</a>
  </p>

  <p>
    <a href="#p2.1">2 Базовые конструкции C++</a>
    <br><a href="#p2.1">2.1 Первые шаги</a>
    <br><a href="#p2.2">2.2 Типы данных</a>
    <br><a href="#p2.3">2.3 Ветвления и циклы</a>
    <br><a href="#p2.4">2.4 Векторы и строки</a>
    <br><a href="#p2.5">2.5 Составные типы данных</a>
    <br><a href="#p2.6">2.6 Ссылки, указатели, константность</a>
    <br><a href="#p2.7">2.7 Функции</a>
    <br><a href="#p2.8">2.8 Шаблоны</a>
    <br><a href="#p2.9">2.9 Разбор задач к главе «Базовые конструкции C++»</a>
  </p>

  <p>
    <a href="#p3.1">3 Стандартная библиотека C++</a>
    <br><a href="#p3.1">3.1 Последовательные контейнеры</a>
    <br><a href="#p3.2">3.2 Ассоциативные контейнеры</a>
    <br><a href="#p3.3">3.3 Алгоритмы</a>
    <br><a href="#p3.4">3.4 Адаптеры и представления</a>
    <br><a href="#p3.5">3.5 Разбор задач к главе «Стандартная библиотека C++»</a>
  </p>

  <p>
    <a href="#p4.1">4 Идиомы C++</a>
    <br><a href="#p4.1">4.1 Классы</a>
    <br><a href="#p4.2">4.2 Шаблонные классы</a>
    <br><a href="#p4.3">4.3 Жизненный цикл объекта</a>
    <br><a href="#p4.5">4.4 Наследование и полиморфизм</a>
    <br><a href="#p4.4">4.5 Обработка исключений</a>
    <br><a href="#p4.6">4.6 Идиома RAII и умные указатели</a>
    <br><a href="#p4.7">4.7 Разбор задач к главе «Идиомы C++»</a>
  </p>

  <p>
    <a href="#p5.1">5 Приложение</a>
    <br><a href="#p5.1">5.1 Как работать с системой проверки заданий</a>
    <br><a href="#p5.2">5.2 Как пользоваться хендбуком</a>
  </p>

</article>


<!-- 1.1 Введение -->
<article class="article">
  <div class="anchor" id="p1.1"></div>
  <h2>1 Введение</h2>
  <h3>1.1 Введение</h3>

  <p>Перед вами учебник по основам языка C++. При его создании мы вдохновлялись специализацией «Искусство разработки на современном C++» на «Курсере», созданной при поддержке Яндекса, и курсом «Основы и методология программирования», который читался в 2014–2021 годах на факультете компьютерных наук ВШЭ.</p>

  <p>Языку C++ почти 40 лет, но он по-прежнему очень актуален и востребован. Он оказал огромное влияние на индустрию и на другие языки. C++ был разработан Бьярне Страуструпом в начале 1980-х годов как расширение языка C (и даже изначально назывался «Си с классами»).</p>

  <p>Однако для изучения C++ совсем не обязательно знать C. Тем не менее мы предполагаем, что вы знакомы с основами информатики и владеете каким-либо языком программирования на уровне школьной программы — например, языком Python.</p>

  <p>Впрочем, C++ во многом полностью противоположен Python:</p>
  <ul>
    <li>это компилируемый, а не интерпретируемый язык;</li>
    <li>С++ — язык со статической, а не динамической типизацией;</li>
    <li>в C++ возможно ручное управление памятью (в отличие от автоматической сборки мусора).</li>
  </ul>

  <p>Чтобы исходный код программы на C++ превратился в исполняемый файл для конкретной архитектуры процессора, программу нужно скомпилировать. Существует несколько популярных компиляторов C++:</p>
  <ul>
    <li>GNU Compiler Collection (GCC);</li>
    <li>Clang — построен поверх инфраструктуры LLVM;</li>
    <li>Microsoft Visual C++ (MSVC) — входит в состав Microsoft Visual Studio;</li>
    <li>Intel C++ Compiler.</li>
  </ul>

  <p>Мы будем использовать в примерах и при проверке задач компилятор Clang 16-й версии.</p>

  <p>С 1998 года международный комитет по стандартизации C++ выпускает стандарты — версии языка, в которых описываются его возможности. В первую очередь это руководства для создателей компиляторов, но при возникновении спорных моментов всегда полезно обратиться к стандарту. Мы будем ориентироваться на стандарт C++20, а по ссылке можно ознакомиться с черновиком будущего стандарта. Важно понимать, что стандарт определяет лишь общие требования и не фиксирует детали реализации, которые в разных компиляторах могут отличаться.</p>

  <p>Чтобы проверить, поддерживает ли ваша версия компилятора ту или иную особенность C++, советуем пользоваться специальной таблицей.</p>

  <p>При изучении вам будут полезны следующие англоязычные ресурсы:</p>
  <ul>
    <li>cppreference.com — онлайн-документация по C++;</li>
    <li>isocpp.org — сайт Standard C++ Foundation;</li>
    <li>C++ Core Guidelines — гайдлайны по C++ от Бьярне Страуструпа и Герба Саттера;</li>
    <li>godbolt.org — Compiler Explorer, онлайн-компилятор;</li>
    <li>learncpp.com — современный учебник по C++;</li>
    <li>hacking C++ — наглядный справочник по C++ с картинками и инфографикой.</li>
  </ul>

  <p>В тексте мы будем часто ссылаться на англоязычную версию cppreference.com и на английскую «Википедию».</p>

  <p>Написать программу для C++ можно в любом текстовом редакторе, но удобнее пользоваться средой разработки (IDE). IDE включают редактор кода с подсветкой синтаксиса, а также позволяют компилировать, запускать и отлаживать программы.</p>

  <p>Примеры IDE:</p>
  <ul>
    <li>Microsoft Visual Studio Community</li>
    <li>Eclipse CDT</li>
    <li>Code::Blocks</li>
    <li>Qt Creator</li>
    <li>Xcode</li>
  </ul>

  <p>Мы рассчитываем, что вы сможете самостоятельно разобраться с настройкой и использованием среды разработки, и не будем заострять на этом внимание. В наших примерах мы будем запускать компилятор из консоли.</p>

  <p>К нашему учебнику прилагается набор задач по соответствующим темам. Вы можете сдавать их в автоматическую проверяющую систему. В одних задачах требуется написать полноценную программу, а в других — сдать только код функции или класса. Обратите внимание, что ко всем задачам имеются разборы с авторскими решениями. Найти разборы вы можете в конце глав.</p>

  <p>Ho прежде чем мы двинемся дальше — небольшое объявление: для этого хендбука у нас есть коммьюнити студентов. В нём можно найти единомышленников, обсудить материалы и задания. Вступить в него можно по <a href="https://t.me/handbook_cpp">ссылке</a>. А чтобы быть в курсе обновлений хендбука — советуем подписаться на рассылку.</p>
</article>


<!-- 2.1 Первые шаги -->
<article class="article">
  <div class="anchor" id="p2.1"></div>
  <h2>2 Базовые конструкции C++</h2>
  <h3>2.1 Первые шаги</h3>

  <p>В этом параграфе мы напишем первую программу на C++ и научимся печатать и считывать с клавиатуры строки и числа.</p>

  <h4>Функция main</h4>
  <p>Пожалуй, самая простая и короткая программа на C++ — это программа, которая ничего не делает. Она выглядит так:</p>
<pre>
int main() {
  return 0;
}
</pre>
  <p>Здесь определяется функция с именем main, которая не принимает никаких аргументов (внутри круглых скобок ничего нет) и не выполняет никаких содержательных команд. В каждой программе на C++ должна быть ровно одна функция main — с неё начинается выполнение программы.</p>

  <p>У функции указан тип возвращаемого значения int (целое число), и она возвращает 0 — в данном случае это сообщение для операционной системы, что программа выполнилась успешно. И наоборот, ненулевой код возврата означает, что при выполнении возникла ошибка (например, программа получила некорректные входные данные).</p>

  <p>Для функции main разрешается не писать завершающий return 0, чем мы и будем пользоваться далее для краткости. Поэтому самую короткую программу можно было бы написать вот так:</p>
  <code>int main() {}</code>

  <h4>Hello, world!</h4>
  <p>Соблюдая традиции, напишем простейшую программу на C++ — она выведет приветствие в консоль:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  std::cout &lt;&lt; "Hello, world!\n";
}
</pre>
  <p>Разберём её подробнее.</p>

  <p>Директива #include &lt;iostream&gt; подключает стандартный библиотечный заголовочный файл для работы с потоками ввода-вывода (input-output streams). Для печати мы используем поток вывода std::cout, где cout расшифровывается как character output, то есть «символьный вывод».</p>

  <p>В теле функции main мы передаём в std::cout строку Hello, world! с завершающим переводом строки \n. В зависимости от операционной системы \n будет преобразован в один или в два управляющих байта с кодами 0A или 0D 0A соответственно.</p>

  <p>Инструкции внутри тела функции завершаются точками с запятой.</p>

  <h4>Компиляция из командной строки</h4>
  <p>Вы можете запустить эту программу из какой-нибудь IDE. Мы же покажем, как собрать её в консоли Linux с помощью компилятора clang++.</p>

  <p>Пусть файл с программой называется hello.cpp. Запустим компилятор:</p>
  <code>$ clang++ hello.cpp -o hello</code>
  <p>В результате мы получим исполняемый файл с именем hello, который теперь можно просто запустить. Он напечатает на экране ожидаемую фразу:</p>
<pre>
$ ./hello
Hello, world!
</pre>
  <p>Если опцию -o не указать, то сгенерированный исполняемый файл будет по умолчанию назван a.out. В дальнейшем для простых примеров мы будем использовать краткую форму записи команды:</p>
<pre>
$ clang++ hello.cpp && ./a.out
Hello, world!
</pre>
  <p>С её помощью мы компилируем программу и в случае успеха компиляции сразу же запускаем.</p>

  <h4>Комментарии</h4>
  <p>Комментарии — это фрагменты программы, которые игнорируются компилятором и предназначены для программиста. В C++ есть два вида комментариев — однострочные и многострочные:</p>
<pre>
int main() {  // однострочный комментарий продолжается до конца строки

/* Пример
   многострочного
   комментария */
}
</pre>
  <p>Мы будем использовать комментарии в примерах кода для пояснений, а в реальных программах ими лучше не злоупотреблять.</p>

  <p>Хорошо: комментировать, что делает библиотека, функция или класс или почему этот код написан именно так.</p>

  <p>Плохо: комментировать, что происходит на отдельных строчках. Это признак того, что код можно написать лучше.</p>

  <h4>Библиотеки и заголовочные файлы</h4>
  <p>Библиотека — это код, который можно переиспользовать в разных программах. В стандарт языка C++ входит спецификация так называемой стандартной библиотеки, которая поставляется вместе с компилятором. Она содержит различные структуры данных (контейнеры), типовые алгоритмы, средства ввода-вывода и т. д. Конструкции из этой библиотеки предваряются префиксом std::, который обозначает пространство имён.</p>

  <p>Чтобы воспользоваться теми или иными библиотечными конструкциями, в начале программы надо подключить нужные заголовочные файлы. Так, в программе, которая печатала Hello, world!, нам уже встречался заголовочный файл iostream и конструкция std::cout из стандартной библиотеки.</p>

  <p>Для C++ существует также множество сторонних библиотек. Наиболее известной коллекцией сторонних библиотек для C++ является Boost.</p>

  <h4>Ошибки компиляции</h4>
  <p>Перед запуском программу необходимо скомпилировать. Компилятор проверяет корректность программы и генерирует исполняемый файл. Во время компиляции компилятор может обнаружить синтаксические ошибки.</p>

  <p>Рассмотрим пример такой программы:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  cout &lt;&lt; "Hello, world\n"
</pre>
  <p>Первая ошибка — вместо std::cout мы написали cout. Вторая ошибка — не поставили точку запятой после "Hello, world!\n". Наконец, третья – не закрыли фигурную скобку с телом функции.</p>

  <p>Ошибки компиляции (compile errors) следует отличать от возможных ошибок времени выполнения (runtime errors), которые происходят после запуска программы и, как правило, зависят от входных данных, неизвестных во время компиляции.</p>

  <h4>Отступы и оформление кода</h4>
  <p>Фрагменты программы на C++ могут быть иерархически вложены друг в друга. На верхнем уровне находятся функции, внутри них написаны их тела, в теле могут быть составные операторы, и так далее.</p>

  <p>Среди программистов есть соглашение — писать внутренние блоки кода с отступами вправо: компилятор полностью игнорирует эти отступы, а код читать удобнее. Мы будем использовать отступы в четыре пробела. Также мы будем придерживаться стиля оформления кода, принятого в Яндексе. Имена переменных мы будем писать с маленькой буквы, имена функций и классов — с большой (если речь не идёт о конструкциях стандартной библиотеки, где действуют другие соглашения).</p>

  <h4>Переменные</h4>
  <p>Любая содержательная программа так или иначе обрабатывает данные в памяти. Переменная — это именованный блок данных определённого типа. Чтобы определить переменную, нужно указать её тип и имя. В общем виде это выглядит так:</p>
  <code>Type name;</code>
  <p>где Type — конкретный тип данных (например, строка или число), а name — имя переменной. Имена переменных должны состоять из латинских букв, цифр и знаков подчёркивания и не должны начинаться с цифры. Также можно в одной строке определить несколько переменных одного типа:</p>
  <code>Type name1, name2, name3;</code>
  <p>Например:</p>
<pre>
// библиотека, в которой
// определён тип std::string
#include &lt;string&gt;

int main() {
  // Определяем переменную value
  // целочисленного типа int
  int value;

  // Определяем переменные name и surname
  // типа std::string (текстовая строка)
  std::string name, surname;
}
</pre>
  <p>В этом примере мы используем встроенный в язык тип int (от слова integer — целое число) и поставляемый со стандартной библиотекой тип std::string. (Можно было бы использовать для строк встроенный тип с массивом символов, но это неудобно.)</p>

  <p>Тип переменной должен быть известен компилятору во время компиляции.</p>

  <p>От типа зависит:</p>
  <ul>
    <li>сколько байтов памяти потребуется для хранения данных;</li>
    <li>как интерпретировать эти байты;</li>
    <li>какие операции с этой переменной возможны.</li>
  </ul>

  <p>Например, переменной типа int можно присваивать значения и с ней можно производить арифметические операции. Подробнее про разные типы данных и их размер в памяти мы поговорим ниже.</p>
  <p>Важно понимать, что тип остаётся с переменной навсегда. Например, присвоить целочисленной переменной строку не получится — это вызовет ошибку компиляции:</p>
<pre>
int main() {
  int value;
  value = 42;  // OK
  value = "Hello!";  // ошибка компиляции!
}
</pre>
  <p>Переменные можно сразу проинициализировать значением. В С++ есть много разных способов инициализации. Нам пока будет достаточно способа, который называется copy initialization:</p>
<pre>
#include &lt;string&gt;

int main() {
  int value = 42;
  std::string title = "Bjarne Stroustrup";
}
</pre>
  <p>Если переменная была объявлена, но нигде дальше не использовалась, то компилятор выдаёт об этом предупреждение. При проверке решений мы используем опцию -Werror, которая считает предупреждения компилятора ошибками компиляции.</p>

  <h4>Потоковый ввод и вывод</h4>
  <p>Поток — это абстракция для чтения и записи последовательности данных в форматированном виде.</p>

  <p>Записывать данные можно на экран консоли, в файл, буфер в памяти или в строку. Считывать их можно с клавиатуры, из файла, из памяти. Причём с каждым таким «устройством» можно связать свой поток.</p>

  <p>Важно, что потоки не просто пересылают байты памяти, а применяют форматированный человекочитаемый ввод-вывод. Например, числа печатаются и считываются в десятичной нотации, хотя в памяти компьютера они хранятся в двоичном виде.</p>

  <p>В программе Hello, world! нам уже встречался поток вывода std::cout, по умолчанию связанный с экраном консоли. Познакомимся с потоком ввода std::cin, связанным с клавиатурой. Для его использования нужен тот же заголовочный файл iostream.</p>

  <p>Рассмотрим программу, которая спрашивает имя пользователя и печатает персональное приветствие:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string name;  // объявляем переменную name
  std::cout &lt;&lt; "What is your name?\n";
  std::cin >> name;  // считываем её значение с клавиатуры
  std::cout &lt;&lt; "Hello, " &lt;&lt; name &lt;&lt; "!\n";
}
</pre>
  <p>Обратите внимание на направление угловых скобок в этом примере — они условно показывают направление потока данных. При печати данные выводятся на экран, и стрелки направлены от текста к cout. При вводе данные поступают с клавиатуры, и стрелки направлены от cin к переменной.</p>

  <p>В нашем примере в переменную name считается одно слово, которое будет выведено в ответном сообщении. Пример работы программы:</p>
<pre>
What is your name?
Alice
Hello, Alice!
</pre>
  <p>Однако если ввести строку из нескольких слов с пробелами, то в name запишется только первое слово:</p>
<pre>
$ ./a.out
What is your name?
Alice Liddell
Hello, Alice!
</pre>
  <p>Дело в том, что cin читает поток данных до ближайшего пробельного разделителя (пробела, табуляции, перевода строки или просто конца файла). Чтобы считать в строковую переменную всю строчку целиком (не включая завершающий символ перевода строки), нужно использовать функцию std::getline из заголовочного файла string:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string name;
  std::getline(std::cin, name);
  std::cout &lt;&lt; "Hello, " &lt;&lt; name &lt;&lt; "!\n";
}
</pre>
  <p>В этом примере мы печатаем в одном выражении друг за другом несколько строк ("Hello, ", name и "!\n"), разделённых угловыми скобками &lt;&lt;. Таким образом, cin и cout позволяют кратко считывать и печатать несколько объектов одной командой.</p>

  <p>Например, считывание нескольких чисел целого типа, набранных через пробельные разделители, может выглядеть так:</p>
<pre>
int main() {
  int a;
  int b;
  int c;
  std::cin >> a >> b >> c;
}
</pre>
  <p>Напечатать их значения можно следующим образом:</p>
  <code>std::cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; " " &lt;&lt; c &lt;&lt; "\n";</code>
  <p>Обратите внимание, что мы дополнительно вставляем между ними пробелы, чтобы в выводе числа не слиплись вместе. В конце вывода мы вставляем символ перевода строки \n, чтобы отделить этот результат от последующего вывода или от сообщений командной строки.</p>

  <p>Итак, параграф позади! Впереди вас ждут первые задачи. Но прежде чем приступить к ним, советуем сперва взглянуть на небольшое руководство о том, как пользоваться системой проверки заданий.</p>
</article>


<!-- 2.2 Типы данных -->
<article class="article">
  <div class="anchor" id="p2.2"></div>
  <h3>2.2 Типы данных</h3>
  <p>C++ — язык со статической типизацией. У каждой переменной на этапе компиляции должен быть чётко определённый тип данных. Про каждый тип данных заранее известно, сколько места в памяти занимает переменная такого типа.</p>

  <p>В этом параграфе мы познакомимся с некоторыми базовыми типами данных и с понятием области видимости переменных.</p>

  <h4>Области видимости</h4>

  <p>В С++ существует понятие области видимости (scope) переменной. Эта область ограничивается блоком кода, в котором переменная определена. Рассмотрим пример:</p>
<pre>
#include &lt;iostream&gt;

int a = 1;  // глобальная переменная

int main() {
  int b = 2;  // локальная переменная
  {
    int c = 3;  // локальная переменная внутри блока
    std::cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b
    &lt;&lt; " " &lt;&lt; c &lt;&lt; "\n";  // корректно
  }

  // Эта строчка не скомпилируется,
  // так как переменная c не определена в данной области:
  std::cout &lt;&lt; c &lt;&lt; "\n";
}
</pre>
  <p>В этом примере есть три области:</p>
  <ul>
    <li>глобальная, в которой определена переменная a;</li>
    <li>тело функции main, в которой определена переменная b;</li>
    <li>внутренний блок, в котором определена переменная c.</li>
  </ul>
  <p>В последней строке примера переменная c недоступна, так как её область видимости уже закончилась. В случае коллизии имён компилятор всегда выбирает самую вложенную область видимости.</p>

  <p>Рассмотрим пример:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int x = 1;
  // напечатает 1
  std::cout &lt;&lt; x &lt;&lt; "\n";
  {
    // новая переменная, к предыдущему x не имеет отношения
    int x = 2;
    // напечатает 2
    std::cout &lt;&lt; x &lt;&lt; "\n";
  }
  // снова напечатает 1
  std::cout &lt;&lt; x &lt;&lt; "\n";
}
</pre>

  <h4>Инициализация локальных переменных</h4>
  <p>Локальные переменные простых типов, таких как int, не инициализируются по умолчанию нулём. Компилятор просто выделяет для них байты в стековой памяти, но при этом он не обязан как-либо их заполнять. Это один из принципов C++: мы не должны платить за то, что не используем.</p>

  <p>Следующий фрагмент кода может напечатать всё что угодно:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int x;
  // неопределённое поведение!
  std::cout &lt;&lt; x &lt;&lt; "\n";
  int y;
  // а это допустимый сценарий
  std::cin >> y;
}
</pre>
  <p>Компиляторы g++ и clang++ обычно дают предупреждения о чтении неинициализированных переменных при использовании опции -Wall или -Wuninitialized:</p>
  <p>Заметим, что std::string является сложным типом и переменные такого типа всегда по умолчанию инициализируются пустой строкой. Поэтому нет необходимости писать std::string s = "";. Пишите просто std::string s;.</p>

  <h4>Простые типы данных</h4>
  <p>С типом int мы уже знакомы. Рассмотрим другие фундаментальные типы данных в С++. Это так называемые интегральные типы и типы для вещественных чисел.</p>
<pre>
int main() {
  char c = '1';           // символ
  bool b = true;          // логическая переменная, принимает значения false и true
  int i = 42;             // целое число (занимает, как правило, 4 байта)
  short int si = 17;      // короткое целое (занимает 2 байта)
  long li = 12321321312;  // длинное целое (как правило, 8 байт)
  long long lli = 12321321312; // длинное целое (как правило, 8 байт)
  float f = 2.71828;      // дробное число с плавающей запятой (4 байта)
  double d = 3.141592;    // дробное число двойной точности (8 байт)
  long double ld = 1e15;  // длинное дробное (как правило, 16 байт)
}
</pre>
  <p>Обратите внимание, что символы, в отличие от строк (то есть массивов символов), записываются в апострофах, а не в кавычках. В примере выше мы записываем в переменную c символ единицы. Фактически в памяти хранится ASCII-код этого символа, который равен 49.</p>

  <p>Напомним, что каждый тип данных занимает заранее известное количество байтов памяти. Стандарт языка С++ не накладывает жёстких ограничений на размеры типов, они могут отличаться для разных платформ и компиляторов.</p>

  <p>О том, что делать с этой особенностью, мы расскажем ниже. А пока отметим, что узнать размер переменной или типа на этапе компиляции можно с помощью оператора sizeof.</p>

  <p>Например, на 64-битной Linux-системе компилятор clang++ использует такие размеры для типов:</p>
<pre>
int main() {
  std::cout &lt;&lt; "char: "      &lt;&lt; sizeof(char) &lt;&lt; "\n";                 //  1
  std::cout &lt;&lt; "bool: "      &lt;&lt; sizeof(bool) &lt;&lt; "\n";                 //  1
  std::cout &lt;&lt; "short int: " &lt;&lt; sizeof(short int) &lt;&lt; "\n";       //  2 (по стандарту >= 2)
  std::cout &lt;&lt; "int: "       &lt;&lt; sizeof(int) &lt;&lt; "\n";                   //  4 (по стандарту >= 2)
  std::cout &lt;&lt; "long int: "  &lt;&lt; sizeof(long int) &lt;&lt; "\n";         //  8 (по стандарту >= 4)
  std::cout &lt;&lt; "long long int: " &lt;&lt; sizeof(long long) &lt;&lt; "\n";   //  8 (по стандарту >= 8)
  std::cout &lt;&lt; "float: "     &lt;&lt;sizeof(float) &lt;&lt; "\n";               //  4
  std::cout &lt;&lt; "double: "    &lt;&lt; sizeof(double) &lt;&lt; "\n";             //  8
  std::cout &lt;&lt; "long double: " &lt;&lt; sizeof(long double) &lt;&lt; "\n";   // 16
}
</pre>

  <h4>Размеры стандартных типов</h4>
  <p>По умолчанию числовые типы – знаковые. Они имеют диапазон значений от -2<sup>n-1</sup> до 2<sup>n-1</sup> - 1, где n – количество битов, занимаемых типом. Приставка unsigned перед типом делает его беззнаковым. В этом случае диапазон допустимых значений будет от 0 до 2<sup>n</sup> - 1:</p>
<pre>
int main() {
  unsigned int ui = 4294967295;  // 2^32 - 1
}
</pre>
  <p>Минимальное и максимальное значение, помещающееся в данный числовой тип, можно получить так:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;limits&gt;  // необходимо для numeric_limits

int main() {
  // посчитаем для типа int:
  std::cout &lt;&lt; "minimum value: "
            &lt;&lt; std::numeric_limits&lt;int&gt;::min()
            &lt;&lt; "\n"
            &lt;&lt; "maximum value: "
            &lt;&lt; std::numeric_limits&lt;int&gt;::max()
            &lt;&lt; "\n";
}
</pre>
  <p>Данный пример на 64-битной Linux-системе напечатает:</p>
<pre>
minimum value: -2147483648
maximum value: 2147483647
</pre>
  <p>Приведённые выше примеры вывода оператора sizeof верны для 64-битных архитектур, которые на сегодняшний день распространены повсеместно. Однако если бы мы скомпилировали и запустили такую программу на компьютере с 32-битной архитектурой, то получили бы другие результаты. Например, sizeof(long int) стал бы равен 4, в то время как на современных компьютерах мы получили бы 8. Также бывают встраиваемые системы, под которые тоже можно писать на С++. Там битность архитектуры может быть ещё меньше, чем 32.</p>
  <p>В заголовочном файле cstdint стандартной библиотеки имеются целочисленные типы с фиксированным размером:</p>
  <ul>
    <li>int8_t / uint8_t</li>
    <li>int16_t / uint16_t</li>
    <li>int32_t / uint32_t</li>
    <li>int64_t / uint64_t</li>
  </ul>
  <p>Число в имени типа означает количество бит, используемых для хранения в памяти. Например, int32_t содержит 32 бита (4 байта) и часто соответствует типу int. Если система не поддерживает какой-то тип, то программа с ним просто не скомпилируется.</p>

  <h4>Переполнение целочисленных типов</h4>

  <p>Стандартные числовые типы имеют ограниченный размер и ограниченное множество допустимых значений. При арифметических операциях над числами таких типов может возникнуть переполнение — ситуация, когда результат операции не помещается в тип:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  // на 64-битной платформе sizeof(a) == 4
  unsigned int a = 123456;

  // Произведение a * a не помещается в 4 байта,
  // так как оно больше 2^32
  std::cout &lt;&lt; a * a &lt;&lt; "\n";
}
</pre>

  <p>В этом примере выражение a * a будет иметь тот же тип, что и аргументы. То, что на самом деле будет вычислено, зависит от знаковости типа.</p>
  <p>Беззнаковые типы можно спокойно переполнять: вычисления будут производиться по модулю соответствующей степени двойки. Другими словами, будут учтены только младшие биты результата:</p>
<pre>
int main() {
  // на 64-битной платформе sizeof(x) == 4
  unsigned int x = 0;
  // 4294967295, то есть 2**32 - 1
  unsigned int y = x - 1;
  unsigned int z = y + 1;  // 0
}
</pre>
  <p>Наоборот, для знаковых типов переполнение приводит к так называемому неопределённому поведению (UB, undefined behavior).</p>
  <p>Такая ситуация не считается ошибкой компиляции (в самом деле, на стадии компиляции значения переменных могут быть ещё неизвестны). Но в этом случае стандарт С++ перестаёт что-либо гарантировать по поводу поведения программы. Компиляторы могут использовать такие случаи для оптимизации программ, полагаясь на то, что разработчики пишут код корректно и никогда не допускают неопределённого поведения. Далее нам встретятся и другие случаи неопределённого поведения.</p>
  <p>Беззнаковые типы следует использовать, когда вы имеете дело с битовыми наборами. В остальных случаях предпочтительнее использовать знаковые типы.</p>

  <h4>Арифметические операции</h4>
  <p>Бинарные операции +, - и * работают для чисел стандартным образом. Результат операции деления /, применённой к целым числам, всегда округляется в сторону нуля. Таким образом, для положительных чисел операция / возвращает неполное частное. Остаток от деления целых чисел можно получить с помощью операции %.</p>
<pre>
int main() {
  int a = 7, b = 3;
  int q = a / b;  // 2
  int r = a % b;  // 1
}
</pre>
  <p>Если при делении нужно получить обычное частное, то один из аргументов нужно привести к вещественному типу (например, double) с помощью оператора static_cast:</p>
<pre>
int main() {
  int a = 6, b = 4;
  double q = static_cast&lt;double&gt;(a) / b;  // 1.5
}
</pre>
  <p>Можно было бы написать чуть более кратко: double q = a * 1.0 / b;. Тогда преобразование аргументов произошло бы неявно.</p>
  <p>Арифметические операции над символами, а также сравнение символов друг с другом — это фактически операции над их ASCII-кодами:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  char c = 'A';
  c += 25;  // увеличиваем ASCII-код символа на 25
  std::cout &lt;&lt; c &lt;&lt; "\n";  // Z
}
</pre>
  <p>Операция + применительно к строкам означает конкатенирование (то есть склейку). Это пример перегрузки операции: изначальному оператору сложения чисел в стандартной библиотеке для строки придали новый смысл.</p>
<pre>
#include &lt;string&gt;

int main() {
  std::string a = "Hello, ";
  std::string b = "world!";
  std::string c = a + b;  // Hello, world!
}
</pre>
  <p>Для каждой бинарной операции (например, +) есть версия со знаком равенства (+=) для случая, когда левый аргумент совпадает с переменной, которой присваивается результат:</p>
<pre>
int main() {
  int x = 5;
  x += 3;  // x = x + 3
  x *= x;  // x = x * x
}
</pre>
  <p>Наконец, имеются операторы ++ и -- для увеличения или уменьшения переменной на единицу. Они бывают префиксные (++x) и постфиксные (x++). Отличие состоит в значении выражения, которое будет вычисляться при применении такого оператора. Мы рассмотрим это позже, а пока привыкнем по умолчанию использовать префиксный оператор для обычных чисел:</p>
<pre>
int main() {
  int x = 5;
  ++x;  // 6
  --x;  // снова 5
}
</pre>

  <h4>Числа с плавающей точкой</h4>

  <p>В языке C++ существуют три встроенных типа для записи дробных чисел: float (4 байта), double (8 байт) и long double (16 или 8 байт, в зависимости от платформы). В большинстве случаев рекомендуется использовать тип double.Тип float разумно использовать там, где обрабатываются огромные массивы чисел, и возникает необходимость экономить память.</p>
  <p>Как правило, хранение дробных чисел в С++ основано на стандарте IEEE 754. Число представляется в виде двоичной дроби в экспоненциальной записи: отдельно хранятся бит знака, порядок и мантисса. Мантисса 23 бита (0-22), порядок 8 бит (23-30), знак 1 бит (31).</p>
  <p>Такое представление выгодно отличается от чисел с фиксированной точкой, где хранится фиксированное количество разрядов. Оно позволяет, хотя и с разной степенью точности, представлять числа, отличающиеся на порядки.</p>
  <p>При работе с рациональными числами, знаменатель которых не является степенью двойки, неизбежно возникают погрешности представления. В следующем параграфе мы разберём как следует сравнивать такие числа.</p>

  <h4>Автоматический вывод типа</h4>

  <p>Компилятор C++ умеет автоматически выводить тип переменной по значению, которое ей присваивается. Для этого вместо типа надо написать ключевое слово auto:</p>
<pre>
int main() {
  auto x = 42;  // int
  auto pi = 3.14159;  // double
}
</pre>
  <p>Ключевое слово auto позволяет сократить код и не выписывать сложные типы (нам встретятся дальше монстры вроде std::unordered_multimap&lt;Key, Value&gt;::const_iterator). Важно подчеркнуть, что точный тип переменной всё равно становится известен в момент компиляции.</p>
  <p>При использовании auto со строками нужно быть осторожным. Важно знать, что конструкция auto s = "hello" выведет низкоуровневый тип const char * (указатель на неизменяемый набор символов в памяти), а не тип-обёртку std::string.</p>
  <p>Точные правила вывода типов похожи на правила вывода шаблонных параметров, с которыми мы познакомимся в параграфе про шаблоны.</p>
  <p>В следующем параграфе мы подробнее поговорим о ветвлении и циклах.</p>
</article>


<!-- 2.3 Ветвления и циклы -->
<article class="article">
  <div class="anchor" id="p2.3"></div>
  <h3>2.3 Ветвления и циклы</h3>

  <p>В этом параграфе мы познакомимся с операторами ветвления if и switch, циклами while, do-while и for, а также с оператором goto.</p>

  <h4>Оператор if</h4>
  <p>Условный оператор if записывается так:</p>
<pre>
if (condition) {
  // код, который исполнится в случае,
  // когда условие condition истинно
}
</pre>
  <p>Дополнительно можно добавить ветку кода для случая, когда условие ложно:</p>
<pre>
if (condition) {
  // код, который исполнится,
  // если condition истинно
} else {
  // код, который исполнится,
  // если condition ложно
}
</pre>
  <p>Также можно выстроить цепочку условных операторов:</p>
<pre>
if (condition1) {
  // случай, когда condition1 истинно
} else if (condition2) {
  // случай, когда condition1 ложно,
  // а condition2 истинно
} else if (condition3) {
  // случай, когда condition1 и condition2 ложны,
  // а condition3 истинно
} else {
  // случай, когда condition1,
  // condition2 и condition3 ложны
}
</pre>
  <p>Если код внутри фигурных скобок состоит из одной инструкции, то фигурные скобки можно не писать. Однако рекомендуется ставить фигурные скобки всегда во избежание ошибок.</p>
  <p>На месте condition может стоять любое выражение логического типа. Простейшие примеры таких выражений — это проверка на равенство (==) и неравенство (!=), а также сравнения на меньше / больше (&lt;, &lt;=, > и >=):</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int x;
  std::cin >> x;
  if (x &lt;= 0) {
    std::cout &lt;&lt; "zero or negative\n";
  } else if (x == 1) {
    std::cout &lt;&lt; "one\n";
  } else if (x == 2) {
    std::cout &lt;&lt; "two\n";
  } else {
    std::cout &lt;&lt; "many\n";
  }
}
</pre>

  <h4>Сложные условия</h4>
  <p>Условия можно комбинировать с помощью логических операторов && (и), || (или) и ! (не). Рассмотрим пример, где проверяется принадлежность точки разным интервалам на прямой.</p>
<pre>
int main() {
  int a, b, x;
  /* Тут должна быть логика заполнения объявленных переменных,
  но мы её опустили, чтобы не отвлекаться */

  if (a &lt;= x && x &lt;= b) {
    // точка x лежит на отрезке [a; b]
  } else {
    // точка x лежит вне отрезка [a; b]
  }

  // то же самое можно было бы проверить так:
  if (!(x &lt; a || x > b)) {  // отрицание
    // точка x лежит на отрезке [a; b]
  } else {
    // точка x лежит вне отрезка [a; b]
  }
}
</pre>
  <p>Обратите внимание, что двойное неравенство некорректно проверять через a &lt;= x &lt;= b. Так можно написать, но смысл будет совсем другим: результат сравнения a &lt;= x будет приведён к нулю или единице, и полученное число будет сравниваться с b.</p>
  <p>Операторы сравнения имеют больший приоритет, чем логические операторы, поэтому скобки вокруг элементарных сравнений в сложных условиях не обязательны. А вот оператор отрицания имеет высокий приоритет, поэтому в последнем примере он применяется к условию в скобках. Таблицу приоритета операторов C++ можно посмотреть здесь.</p>
  <p>Операторы && и || ведут себя лениво: если первого аргумента уже достаточно для ответа, то второй аргумент вычисляться не будет. Например, в выражении condition1 && condition2 второе условие не вычисляется, если первое ложно. Это часто используют для проверок корректности:</p>
<pre>
int a, b;
// ...
if (a != 0 && b % a == 0) {
  // b делится на a
}
</pre>

  <h4>Сравнение чисел с плавающей точкой</h4>

  <p>Рассмотрим программу, которая проверяет равенство 0.1 + 0.2 == 0.3:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  double x = 0.1, y = 0.2;
  if (x + y == 0.3) {
    std::cout &lt;&lt; "EQUAL ";
  } else {
    std::cout &lt;&lt; "NOT EQUAL ";
  }

  std::cout &lt;&lt; x + y &lt;&lt; "\n";
}
</pre>
  <p>Логично было бы предположить, что программа выведет EQUAL 0.3, потому что 0.1 + 0.2 = 0.3. Однако программа напечатает NOT EQUAL 0.3. Данная «ошибка вычисления» встречается в большинстве современных языков программирования и обусловлена погрешностью представления этих чисел. Если повысить число знаков дробной части в выводе, мы увидим, что 0.1 + 0.2 == 0.30000000000000004. Подробнее об этом можно прочитать здесь и в этой статье.</p>
  <p>Поскольку операции над числами с плавающей точкой могут содержать погрешность, обычное сравнение через == некорректно. Поэтому правильнее сравнивать модуль разности величин с некой допустимой для нас погрешностью. Модуль дробного числа можно получить с помощью функции std::abs из заголовочного файла cmath. Исходную программу можно было бы переписать так:</p>
<pre>
#include &lt;cmath&gt;
#include &lt;iostream&gt;

int main() {
  double delta = 0.000001;

  double x = 0.1, y = 0.2;
  double sum = x + y;

  if (std::abs(sum - 0.3) &lt; delta) {
    std::cout &lt;&lt; "EQUAL ";
  } else {
    std::cout &lt;&lt; "NOT EQUAL ";
  }

  std::cout &lt;&lt; sum &lt;&lt; "\n";
}
</pre>
  <p>Теперь программа выведет EQUAL 0.3.</p>

  <h4>Оператор switch</h4>

  <p>Рассмотрим простейший калькулятор, считывающий число, затем знак арифметической операции, а затем другое число и печатающий результат. Напишем сначала программу с помощью if и else.</p>
<pre>
#include &lt;cstdint&gt;
#include &lt;iostream&gt;

int main() {
  int64_t a, b;
  char operation;
  std::cin >> a >> operation >> b;

  int64_t result = 0;
  if (operation == '+') {
    result = a + b;
  } else if (operation == '-') {
    result = a - b;
  } else if (operation == '*') {
    result = a * b;
  } else if (operation == '/' || operation == ':') {
    result = a / b;
  } else if (operation == '%') {  // остаток от деления
    result = a % b;
  }

  std::cout &lt;&lt; result &lt;&lt; "\n";
}
</pre>
  <p>Перепишем эту программу через оператор switch. Этот оператор следует рассматривать как условный прыжок на соответствующую метку в зависимости от значения выражения.</p>
<pre>
#include &lt;cstdint&gt;
#include &lt;iostream&gt;

int main() {
  int64_t a, b;
  char operation;
  std::cin >> a >> operation >> b;

  int64_t result;
  switch (operation) {
    case '+':
        result = a + b;
        break;  // если не написать этот break,
                // программа просто пойдёт дальше
                // в код следующего блока case
    case '-':
        result = a - b;
        break;
    case '*':
        result = a * b;
        break;
    case '/':
    case ':':
        result = a / b;
        break;
    case '%':
        result = a % b;
        break;
    default:  // здесь обрабатывается случай,
              // когда ни один case не сработал.
        result = 0;
  }

  std::cout &lt;&lt; result &lt;&lt; "\n";
}
</pre>
  <p>Выражения внутри скобок оператора switch и в блоках case должны быть простого целочисленного или символьного типа. В приведённой выше программе значение + относится к типу char. Использование сложных типов (например, строк) приведёт к ошибке компиляции:</p>
<pre>
int main() {
  std::string name;
  std::cin >> name;
  switch (name) {  // ошибка компиляции
    case "Alice":
        std::cout &lt;&lt; "Hello, Alice!\n";
        break;
  }
}
</pre>

  <h4>Оператор goto</h4>

  <p>Есть шутка, что оператор безусловного перехода goto — это ругательное слово из четырёх букв. Безусловные переходы ломают иерархичность программы, затрудняют чтение и отладку. Доказано, что любую программу можно переписать без оператора goto. Поэтому во многих современных языках goto отсутствует.</p>
  <p>Однако в C++ этот оператор есть по следующим причинам:</p>
  <ul>
    <li>обратная совместимость с языком С;</li>
    <li>удобный выход из вложенных циклов;</li>
    <li>применение в автосгенерированном коде (например, коде конечного автомата), не предназначенном для чтения человеком.</li>
  </ul>
  <p>Мы познакомимся с его синтаксисом, но дальше использовать нигде не будем — и вам не советуем.</p>
<pre>
int main() {
  again:  // метка — это произвольное имя с двоеточием

  std::cout &lt;&lt; "How old are you?\n";
  int age;
  std::cin >> age;

  if (age &lt; 0 || age >= 128) {
    std::cout &lt;&lt; "Wrong age...\n";
    // безусловный прыжок в место, помеченное меткой
    goto again;
  }

  std::cout &lt;&lt; "Your age is " &lt;&lt; age &lt;&lt; ".\n";

  // ...
}
</pre>
  <p>Здесь вводится метка again, на которую осуществляется переход, если возраст введён некорректно. Ниже мы покажем, как можно избавиться от оператора goto.</p>
  <p>С помощью оператора goto нельзя выйти из функции или зайти в неё, а также нельзя перепрыгнуть через объявления переменных (кроме тривиальных случаев):</p>
<pre>
#include &lt;iostream&gt;

int main() {
  goto label;
  int x = 42;
  label:  // ошибка компиляции!
  std::cout &lt;&lt; x &lt;&lt; "\n";
}
</pre>

  <h4>Цикл while</h4>

  <p>В C++ существует несколько видов циклов. Цикл while — это цикл с предусловием. Перед очередной итерацией проверяется условие, и если оно истинно, то цикл продолжается. Рассмотрим пример печати таблицы квадратов чисел от 1 до 10:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int n = 1;
  while (n &lt;= 10) {
    // выводим число и его квадрат через табуляцию
    std::cout &lt;&lt; n &lt;&lt; "\t" &lt;&lt; n * n &lt;&lt; "\n";
    ++n;
  }
}
</pre>
  <p>Здесь мы намеренно разделяем числа и их квадраты не пробелом, а знаком табуляции \t. В консоли такой вывод будет выглядеть выровненным по колонкам с фиксированной шириной:</p>
<pre>
1&#x9;1
2&#x9;4
3&#x9;9
4&#x9;16
5&#x9;25
6&#x9;36
7&#x9;49
8&#x9;64
9&#x9;81
10&#x9;100
</pre>

  <h4>Цикл do-while</h4>

  <p>Это цикл с постусловием. Отличие от цикла while заключается в том, что первая итерация всегда выполняется безусловно. Только после её завершения проверяется условие цикла. Если оно истинно, то цикл продолжается.</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int n = 1;
  do {
    std::cout &lt;&lt; n &lt;&lt; "\t" &lt;&lt; n * n &lt;&lt; "\n";
    ++n;
  } while (n &lt;= 10);
}
</pre>
  <p>Без особых причин пользоваться этим видом циклов не стоит, старайтесь использовать циклы while или for.</p>

  <h4>Цикл for</h4>

  <p>Цикл for — самый гибкий. Он записывается так:</p>
<pre>
for (initialization; condition; action) {
  // тело цикла
}
</pre>
  <p>Как правило, с циклом ассоциируется некоторый параметр, который меняется от итерации к итерации, а цикл выполняется до тех пор, пока некоторое условие на этот параметр истинно.</p>

  <p>Начальное значение такого параметра можно задать в разделе initialization, условие — в condition, а действие над параметром, выполняющееся после каждой итерации, — в action.</p>

  <p>Напечатаем таблицу квадратов через цикл for:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  for (int i = 1; i &lt;= 10; ++i) {
    std::cout &lt;&lt; i &lt;&lt; "\t" &lt;&lt; i * i &lt;&lt; "\n";
  }
}
</pre>
  <p>Напомним, что ++i — традиционная краткая форма записи для выражения i = i + 1.</p>
  <p>Цикл for эквивалентен такому циклу while:</p>
<pre>
{
  initialization;
  while (condition) {
    // тело цикла
    action;
  }
}
</pre>

  <h4>Цикл range-based for</h4>

  <p>Этот цикл применим к контейнерам разной природы (массивам, векторам, спискам и т. д.), с которыми мы познакомимся позже. Пока рассмотрим его на примере строк. Цикл позволяет удобно проитерироваться по символам строки, не используя индексов. В этом примере мы считываем строку и печатаем отдельно все символы строки и их ASCII-коды:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string line;
  std::getline(std::cin, line);
  for (char symbol : line) {
    std::cout &lt;&lt; symbol &lt;&lt; "\t"
    &lt;&lt; static_cast&lt;int&gt;(symbol) &lt;&lt; "\n";
  }
}
</pre>
  <p>Здесь оператор static_cast преобразует символ к числовому типу int, чтобы получить его код. Результат для строки Hello, world! выглядит так:</p>
<pre>
H	72
e	101
l	108
l	108
o	111
,	44
 	32
w	119
o	111
r	114
l	108
d	100
!	33
</pre>
  <p>Обратите внимание, что std::string хранит внутри байты. Если вы вводите символы русского алфавита и у вас используется кодировка UTF-8, ставшая де-факто стандартом, то эти символы будут кодироваться парами байтов. И при такой итерации вы увидите отдельные байты, а не символы.</p>

  <h4>Вложенные циклы</h4>

  <p>Циклы могут быть вложенными. Напечатаем таблицу умножения:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  for (int i = 1; i &lt;= 10; ++i) {
    for (int j = 1; j &lt;= 10; ++j) {
      std::cout &lt;&lt; i * j &lt;&lt; "\t";
    }
    std::cout &lt;&lt; "\n";
  }
}
</pre>
  <p>Результат:</p>
<pre>
  1	   2	 3	 4	 5	 6	 7	 8	 9	10
  2	   4	 6	 8	10	12	14	16	18	20
  3	   6	 9	12	15	18	21	24	27	30
  4	   8	12	16	20	24	28	32	36	40
  5	  10	15	20	25	30	35	40	45	50
  6   12	18	24	30	36	42	48	54	60
  7	  14	21	28	35	42	49	56	63	70
  8	  16	24	32	40	48	56	64	72	80
  9	  18	27	36	45	54	63	72	81	90
  10  20	30	40	50	60	70	80	90	100
</pre>

  <h4>Операторы break и continue</h4>

  <p>Оператор break досрочно заканчивает текущий цикл. Оператор continue прыгает в самый конец тела цикла и, если условие цикла позволяет, переходит на следующую итерацию.</p>
  <p>Типичный пример использования оператора break — выход из формально бесконечного цикла:</p>
<pre>
while (true) {
  // ...
  if (condition) {
    break;
  }
  // ...
}
</pre>
  <p>Кстати, рассмотрим другие способы записать бесконечный цикл.</p>
  <p>Через цикл do-while:</p>
<pre>
do {
  // ...
} while (true);
</pre>
  <p>Через цикл for:</p>
<pre>
for (;;) {
  // ...
}
</pre>
  <p>Напишем программу, которая считывает числа с клавиатуры до тех пор, пока пользователь не введёт ноль, а затем печатает их сумму:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int sum = 0;
  while (true) {
    int x;
    std::cin >> x;
    if (x == 0) {
      break;
    }
    sum += x;
  }
  std::cout &lt;&lt; sum &lt;&lt; "\n";
}
</pre>
  <p>(Здесь, конечно, неявно предполагается, что и сами числа, и результат суммирования помещаются в тип int, и в ходе вычислений не происходит переполнений.)</p>

  <h4>Считывание до конца ввода</h4>

  <p>В предыдущем примере мы считывали числа до тех пор, пока на вход не поступит ноль. Это не очень удобно. Предположим, что вместо ввода с клавиатуры мы читали бы эти числа из файла. Это легко сделать, перенаправив файл на стандартный ввод при запуске программы из консоли:</p>
  <code>./a.out &lt; input.txt</code>
  <p>Следующий цикл считывает числа до тех пор, пока поступающие данные не закончатся:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int sum = 0;
  int x;
  while (std::cin >> x) {
    sum += x;
  }
  std::cout &lt;&lt; sum &lt;&lt; "\n";
}
</pre>
  <p>Здесь вместо условия цикла подставлено выражение std::cin >> x. Кроме считывания x это выражение преобразуется к логическому типу, показывающему, есть ли ещё данные в потоке ввода.</p>
  <p>При вводе данных не из файла, а с клавиатуры можно сымитировать конец ввода комбинацией клавиш Ctrl+D в Linux и macOS или Ctrl+Z в Windows.</p>
  <p>Аналогично можно прочитать строки до конца ввода с помощью std::getline:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string name;
  while (std::getline(std::cin, name)) {
    std::cout &lt;&lt; "Hello, " &lt;&lt; name &lt;&lt; "!\n";
  }
}
</pre>
</article>


<!-- 2.4 Векторы и строки -->
<article class="article">
  <div class="anchor" id="p2.4"></div>
  <h3>2.4 Векторы и строки</h3>

  <p>Вектор (std::vector) и строка (std::string) — это важные базовые контейнеры стандартной библиотеки C++. Они хранят свои элементы в непрерывном фрагменте памяти. Оба этих контейнера предоставляют доступ к элементам по индексу и позволяют эффективно добавлять новые элементы в конец.</p>

  <h4>Контейнер std::vector</h4>

  <p>В стандартной библиотеке C++ вектором (std::vector) называется динамический массив, обеспечивающий быстрое добавление новых элементов в конец и меняющий свой размер при необходимости. Вектор гарантирует отсутствие утечек памяти (об этом мы поговорим в других параграфах, сейчас просто считайте, что это хорошо).</p>

  <p>Для работы с вектором нужно подключить заголовочный файл vector.</p>

  <p>Элементы вектора должны быть одинакового типа, и этот тип должен быть известен при компиляции программы. Он задаётся в угловых скобках после std::vector: например, std::vector&lt;int&gt; — это вектор целых чисел типа int, а std::vector&lt;std::string&gt; — вектор строк.</p>

  <p>Само имя std::vector не является типом данных: это шаблон, в который требуется подставить нужные параметры (тип элемента), чтобы получился конкретный тип данных. Подробнее о том, что такое шаблоны и как их применять, мы расскажем в параграфе «Шаблоны».</p>

  <p>Рассмотрим пример программы, которая заполняет вектор элементами и печатает их через пробел:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; data = {1, 2, 3, 4, 5};
  for (int elem : data) {
    std::cout &lt;&lt; elem &lt;&lt; " ";
  }
  std::cout &lt;&lt; "\n";
}
</pre>
  <p>Здесь мы инициализируем вектор через список инициализации, в котором элементы перечислены через запятую. Другой способ инициализации вектора — указать число элементов и (при необходимости) образец элемента:</p>
<pre>
#include &lt;string&gt;
#include &lt;vector&gt;

int main() {
  // пустой вектор строк
  std::vector&lt;std::string&gt; v1;
  // вектор из пяти пустых строк
  std::vector&lt;std::string&gt; v2(5);
  // вектор из пяти строк "hello"
  std::vector&lt;std::string&gt; v3(5, "hello");
}
</pre>

  <h4>Обращение к элементам</h4>

  <p>Выше мы использовали для печати элементов вектора цикл range-for. Но иногда удобнее работать с индексами. Вектор хранит элементы в памяти последовательно, поэтому по индексу элемента можно быстро найти его положение в памяти. Индексация начинается с нуля:</p>
<pre>
std::vector&lt;int&gt; data = {1, 2, 3, 4, 5};
// начальный элемент вектора
int a = data[0];
// последний элемент вектора (в нём пять элементов)
int b = data[4];
// меняем элемент 3 на -3
data[2] = -3;
</pre>
  <p>Чтобы узнать общее количество элементов в векторе, можно воспользоваться функцией size:</p>
  <code>std::cout &lt;&lt; data.size() &lt;&lt; "\n";</code>
  <p>Отрицательные индексы, как в некоторых других языках программирования, не допускаются.</p>
  <p>Обратите внимание: когда мы обращаемся по индексу через квадратные скобки, проверки его корректности не происходит. Это ещё одно проявление принципа «мы не должны платить за то, что не используем».</p>
  <p>Встроенные валидаторы замедляют программу: предполагается, что программист пишет правильный код и уверен, что индекс i в выражении data[i] неотрицателен и удовлетворяет условию i &lt; data.size(). В этом случае они ему не нужны.</p>
  <p>Если всё же обратиться к вектору по некорректному индексу, то программа во время выполнения попадёт в неопределённое поведение: фактически она попробует прочитать память, не принадлежащую вектору.</p>
  <p>Если вам не хочется делать много лишних проверок, а в корректности индекса вы не уверены, то можно использовать функцию at:</p>
<pre>
std::vector&lt;int&gt; data = {1, 2, 3, 4, 5};
// неопределённое поведение: может произойти всё что угодно
std::cout &lt;&lt; data[42] &lt;&lt; "\n";
// напечатается 1
std::cout &lt;&lt; data.at(0) &lt;&lt; "\n";
// произойдёт исключение std::out_of_range
// его можно будет перехватить и обработать
std::cout &lt;&lt; data.at(42) &lt;&lt; "\n";
</pre>
  <p>Про работу с исключениями мы поговорим отдельно в параграфе «Обработка исключений».</p>
  <p>Рассмотрим функции вектора front и back, которые возвращают его первый и последний элемент без использования индексов:</p>
<pre>
std::vector&lt;int&gt; data = {1, 2, 3, 4, 5};
// то же, что data[0]
std::cout &lt;&lt; data.front() &lt;&lt; "\n";
// то же, что data[data.size() - 1]
std::cout &lt;&lt; data.back() &lt;&lt; "\n";
</pre>
  <p>Важно учитывать, что вызов этих функций на пустом векторе приведёт к неопределённому поведению.</p>
  <p>Для проверки вектора на пустоту вместо сравнения data.size() == 0 принято использовать функцию empty, которая возвращает логическое значение:</p>
<pre>
if (!data.empty()) {
  // вектор не пуст, с ним можно работать
}
</pre>

  <h4>Итерация по индексам</h4>

  <p>Так сложилось, что в стандартной библиотеке индексы и размеры контейнеров имеют беззнаковый тип. Вместо unsigned int или unsigned long int для него используется традиционный псевдоним size_t (а точнее, std::vector&lt;T&gt;::size_type). Тип size_t на самом деле совпадает с uint32_t или uint64_t в зависимости от битности платформы. Его использование в программе дополнительно подчёркивает, что мы имеем дело с индексами или с размером.</p>

  <p>Итерацию по элементам data с помощью индексов можно записать так:</p>
<pre>
for (size_t i = 0; i != data.size(); ++i) {
  std::cout &lt;&lt; data[i] &lt;&lt; " ";
}
</pre>
  <p>Это каноническая форма записи такого цикла: в ней принято использовать сравнение != и префиксный ++i. Для целых чисел не будет разницы, если написать это как-то иначе (например, через &lt; и постфиксный i++), но потом, когда вы будете писать аналогичные циклы для итераторов других контейнеров, разница появится. Давайте привыкнем всегда оформлять цикл по индексам так.</p>
  <p>Беззнаковость типа возвращаемого значения функции size порождает следующую проблему. По правилам, унаследованным ещё от языка C, результат арифметических действий над беззнаковым и знаковым типами приводится к беззнаковому типу. Поэтому выражение data.size() - 1, например, тоже будет беззнаковым. Если data.size() окажется нулём, то такое выражение будет вовсе не минус единицей, а самым большим беззнаковым целым (для 64-битной платформы это 2<sup>64</sup>-1).</p>
  <p>Рассмотрим следующий ошибочный код, который проверяет, есть ли в векторе дубликаты, идущие подряд:</p>
<pre>
// итерация по всем элементам, кроме последнего:
for (size_t i = 0; i &lt; data.size() - 1; ++i) {
  if (data[i] == data[i + 1]) {
    std::cout &lt;&lt; "Duplicate value: " &lt;&lt; data[i] &lt;&lt; "\n";
  }
}
</pre>
  <p>Эта программа будет некорректно работать на пустом векторе. Условие i &lt; data.size() - 1 на первой итерации окажется истинным, и произойдёт обращение к элементам пустого вектора. Правильнее было бы переписать это условие через i + 1 &lt; data.size() или воспользоваться внешней функцией std::ssize, которая появилась в C++20. Она возвращает знаковый размер вектора:</p>
<pre>
for (std::int64_t i = 0; i &lt; std::ssize(data) - 1; ++i) {
  if (data[i] == data[i + 1]) {
    std::cout &lt;&lt; "Duplicate value: " &lt;&lt; data[i] &lt;&lt; "\n";
  }
}
</pre>

  <h4>Добавление и удаление элементов</h4>

  <p>В вектор можно эффективно добавлять элементы в конец и удалять их с конца. Для этого существуют функции push_back и pop_back. Рассмотрим программу, считывающую числа с клавиатуры в вектор и затем удаляющую все нули в конце:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  int x;
  std::vector&lt;int> data;

  // читаем числа, пока не закончится ввод
  while (std::cin >> x) {
    // добавляем очередное число в вектор
    data.push_back(x);
  }

  // Пока вектор не пуст и последний элемент равен нулю
  while (!data.empty() && data.back() == 0) {
    // удаляем этот нулевой элемент
    data.pop_back();
  }
}
</pre>
  <p>Добавление элементов в другие части вектора или их удаление неэффективно, так как требует сдвига соседних элементов. Поэтому отдельных функций, например, для добавления или удаления элементов из начала у вектора нет. Это можно сделать с помощью общих функций insert/erase и итераторов. Мы рассмотрим такие примеры позже.</p>
  <p>Удалить все элементы из вектора можно с помощью функции clear.</p>

  <h4>Резерв памяти</h4>
  <p>Вектор хранит элементы в памяти в виде непрерывной последовательности, друг за другом. При этом в конце последовательности резервируется дополнительное место для быстрого добавления новых элементов. Когда этот резерв заканчивается, при вставке очередного элемента происходит реаллокация: элементы вектора копируются в новый, более просторный блок памяти.</p>
  <p>Реаллокация — довольно дорогая процедура, но если она происходит достаточно редко, то её влияние незначительно. Можно доказать, что если размер нового блока выбирать в два раза больше предыдущего размера, то амортизационная сложность добавления элемента будет константной.</p>
  <p>Текущий резерв вектора можно узнать с помощью функции capacity (не путайте её с функцией size).</p>
  <p>Рассмотрим программу, в которой в вектор последовательно добавляются элементы и после каждого шага печатается размер и резерв:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; data = {1, 2};
  std::cout &lt;&lt; data.size() &lt;&lt; "\t" &lt;&lt; data.capacity() &lt;&lt; "\n";

  data.push_back(3);
  std::cout &lt;&lt; data.size() &lt;&lt; "\t" &lt;&lt; data.capacity() &lt;&lt; "\n";

  data.push_back(4);
  std::cout &lt;&lt; data.size() &lt;&lt; "\t" &lt;&lt; data.capacity() &lt;&lt; "\n";

  data.push_back(5);
  std::cout &lt;&lt; data.size() &lt;&lt; "\t" &lt;&lt; data.capacity() &lt;&lt; "\n";
}
</pre>
  <p>Вот вывод этой программы:</p>
<pre>
2	2
3	4
4	4
5	8
</pre>
  <p>Видно, что размер вектора увеличивается на единицу, а резерв удваивается после исчерпания. Так, при добавлении четвёрки используется имеющаяся в резерве память, а при добавлении тройки и пятёрки происходит реаллокация.</p>
<pre>
vector&lt;int&gt; data = {1, 2, 3, 4};
data.push_back(5);
</pre>
  <p>Иногда требуется заполнить вектор элементами, причём число элементов известно заранее. В таком случае можно сразу зарезервировать нужный размер памяти с помощью функции reserve, чтобы при добавлении элементов не происходили реаллокации. Пусть, например, нам сначала задаётся число слов, а потом сами эти слова, и нам требуется сложить их в вектор:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;std::string&gt; words;

  size_t words_count;
  std::cin >> words_count;

  // Размер вектора остаётся нулевым, меняется только резерв:
  words.reserve(words_count);

  for (size_t i = 0; i != words_count; ++i) {
    std::string word;
    std::cin >> word;
    // Все добавления будут дешёвыми, без реаллокаций:
    words.push_back(word);
  }
}
</pre>
  <p>Если передать в reserve величину меньше текущего резерва, то ничего не поменяется — резерв останется прежним.</p>
  <p>Функцию reserve не следует путать с функцией resize, которая меняет количество элементов в векторе. Если аргумент функции resize меньше текущего размера, то лишние элементы в конце вектора удаляются. Если же он больше текущего размера, то при необходимости происходит реаллокация и в вектор добавляются новые элементы с дефолтным значением данного типа.</p>
<pre>
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; data = {1, 2, 3, 4, 5};

  // поменяли резерв, но размер вектора остался равным пяти
  data.reserve(10);

  data.resize(3);  // удалили последние элементы 4 и 5
  data.resize(6);  // получили вектор 1, 2, 3, 0, 0, 0
}
</pre>

  <h4>Многомерные векторы</h4>

  <p>Воспользуемся вектором векторов, чтобы сохранить матрицу (таблицу) целых чисел. Пусть на вход программы сначала поступают число строк и число столбцов матрицы, а потом — сами элементы построчно:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  size_t m, n;
  std::cin >> m >> n;  // число строк и столбцов

  // создаём матрицу matrix из m строк, каждая из которых — вектор из n нулей
  std::vector&lt;std::vector&lt;int&gt; &gt; matrix(m, std::vector&lt;int&gt;(n));

  for (size_t i = 0; i != m; ++i) {
    for (size_t j = 0; j != n; ++j) {
      std::cin >> matrix[i][j];
    }
  }

  // напечатаем матрицу, выводя элементы через табуляцию
  for (size_t i = 0; i != m; ++i) {
    for (size_t j = 0; j != n; ++j) {
      std::cout &lt;&lt; matrix[i][j] &lt;&lt; "\t";
    }
    std::cout &lt;&lt; "\n";
  }
}
</pre>
  <p>В этом примере мы заранее создали матрицу из нулей, а потом просто меняли её элементы.</p>

  <h4>Сортировка вектора</h4>

  <p>Рассмотрим типичную задачу — отсортировать вектор по возрастанию. Для этого в стандартной библиотеке в заголовочном файле algorithm есть готовая функция sort. Гарантируется, что сложность её работы в худшем случае составляет O(nlogn), где n — число элементов в векторе. Типичные реализации используют алгоритм сортировки Introsort.</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; data = {3, 1, 4, 1, 5, 9, 2, 6};

  // Сортировка диапазона вектора от начала до конца
  std::sort(data.begin(), data.end());

  // получим вектор 1, 1, 2, 3, 4, 5, 6, 9
}
</pre>
  <p>В функцию sort передаются так называемые итераторы, ограничивающие рассматриваемый диапазон. В нашем случае мы передаём диапазон, совпадающий со всем вектором, от начала до конца. Соответствующие итераторы возвращают функции begin и end (не путать с front и back!). Итераторы можно считать обобщёнными индексами (но они могут быть и у контейнеров, не допускающих обычную индексацию). Подробнее про итераторы мы поговорим в отдельном параграфе.</p>
  <p>Для сортировки по убыванию можно передать на вход обратные итераторы rbegin() и rend(), представляющие элементы вектора в перевёрнутом порядке:</p>
<pre>
std::sort(data.rbegin(), data.rend());
// 9, 6, 5, 4, 3, 2, 1, 1
</pre>
  <p>В C++20 доступен более элегантный способ сортировки через std::ranges::sort:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; data = {3, 1, 4, 1, 5, 9, 2, 6};
  // можно передать сам вектор, а не его диапазоны
  std::ranges::sort(data);
}
</pre>
  <p>Для сортировки по умолчанию используется сравнение элементов с помощью оператора &lt;. Этот оператор работает и для самих векторов: они сравниваются лексикографически. Поэтому можно без проблем отсортировать, например, строки в матрице (векторе векторов целых чисел).</p>

  <h4>Строки</h4>

  <p>Контейнер std::string можно рассматривать как особый случай вектора символов std::vector&lt;char&gt;, имеющий набор дополнительных функций. В частности, у строки есть все те же рассмотренные нами функции, что и у вектора (например, pop_back или resize). Рассмотрим некоторые специфические функции строки:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string s = "Some string";

  // приписывание символов и строк
  // добавляем отдельный символ в конец, это аналог push_back
  s += ' ';
  s += "functions";  // добавляем строку в конец
  std::cout &lt;&lt; s &lt;&lt; "\n";  // Some string functions

  // выделение подстроки
  // подстрока "string" из 6 символов начиная с 5-й позиции
  std::string sub1 = s.substr(5, 6);
  // подстрока "functions" с 12-й позиции и до конца
  std::string sub2 = s.substr(12);

  // поиск символа или подстроки
  // позиция первого пробела, в данном случае 4
  size_t pos1 = s.find(' ');
  // позиция следующего пробела (11)
  size_t pos2 = s.find(' ', pos1 + 1);
  // вернётся 5
  size_t pos3 = s.find("str");
  вернётся std::string::npos
  size_t pos4 = s.find("#");  //
}
</pre>

  <p>Вставку, замену и удаление подстрок можно сделать через указание индекса начала и длины подстроки:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string s = "Some string functions";

  // вставка подстроки
  s.insert(5, "std::");
  std::cout &lt;&lt; s &lt;&lt; "\n";  // Some std::string functions

  // замена указанного диапазона на новую подстроку
  s.replace(0, 4, "Special");
  std::cout &lt;&lt; s &lt;&lt; "\n";  // Special std::string functions

  // удаление подстроки
  s.erase(8, 5);  // Special string functions
}
</pre>
  <p>Аналогичные действия для других контейнеров (например, для того же вектора) можно сделать через итераторы. Мы рассмотрим такие примеры в одном из следующих параграфов.</p>
  <p>В C++20 появились удобные функции starts_with и ends_with для проверки префикса или суффикса строк:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string phrase;
  std::getline(std::cin, phrase);

  if (phrase.starts_with("hello")) {
    std::cout &lt;&lt; "Greeting\n";
  }

  if (phrase.ends_with("bye")) {
    std::cout &lt;&lt; "Farewell\n";
  }
}
</pre>
</article>


<!-- 2.5 Составные типы данных -->
<article class="article">
  <div class="anchor" id="p2.5"></div>
  <h3>2.5 Составные типы данных</h3>

  <p>C++ позволяет конструировать новые типы данных на основе базовых типов. В этом параграфе мы познакомимся с перечислениями и структурами, а также рассмотрим конструкции std::pair и std::tuple из стандартной библиотеки.</p>

  <h4>Перечисления</h4>

  <p>Предположим, что мы пишем программу для обработки изображений и хотим работать с цветами. Для каждого цвета заводить отдельную константу не очень удобно. Воспользуемся перечислением — специальным типом данных, который состоит из конечного набора именованных констант:</p>
<pre>
enum class Color {
  White,
  Red,
  Orange,
  Blue,
};
</pre>
  <p>Мы описали новый тип данных Color с четырьмя допустимыми значениями. Теперь к каждому цвету можно обращаться через префикс Color:::</p>
<pre>
int main() {
  Color color1 = Color::Red;
  Color color2 = Color::Blue;
}
</pre>
  <p>Фактически перечисления — это удобный способ описывать однотипные именованные константы. По умолчанию перечисления хранятся как тип int, а их значения последовательно нумеруются с нуля. И тип, и конкретное значение можно поменять.</p>
  <p>Преобразовать перечисление в число и обратно можно с помощью оператора static_cast:</p>
<pre>
int value = static_cast&lt;int&gt;(color2);  // 3
Color color3 = static_cast&lt;Color&gt;(2);  // Color::Orange
</pre>
  <p>Раньше в C++ перечисления объявлялись вот так, без слова class:</p>
<pre>
enum Color {
  White,
  Red,
  Orange,
  Blue,
};

// можно даже без названия
enum {
  Apple,
  Orange,
  Banana
};
</pre>
  <p>Этот способ остался в языке. Но в таком случае все имена внутри перечислений являются глобальными, и могут происходить конфликты имён (Orange в примере). Такая программа просто не скомпилируется.</p>

  <h4>Структуры</h4>

  <p>Часто хочется собрать «под одной крышей» несколько переменных. В таких случаях можно использовать структуры. Например, давайте опишем структуру точек из трёхмерного пространства:</p>
<pre>
struct Point {
  double x = 0.0;
  double y = 0.0;
  double z = 0.0;
  Color color;  // пусть у нас будет цветная точка
};
</pre>
  <p>В данном случае мы описали новый тип данных — Point, который содержит в себе четыре переменные.</p>
  <p>Давайте поработаем с этой структурой:</p>
<pre>
int main() {
  // по умолчанию координаты будут нулевыми,
  // а color никак не будет проинициализирован
  Point point1;
  point1.color = Color::Blue;

  Point point2 = {1.4, -2.2, -3.98, Color::Red};
  // x = 1.4, y = -2.2, z = -3.98, color = Color::Red

  // обращаться к полям можно через точку
  point2.z = 32;
  // и вообще работать с ними как с обычными переменными
  point2.x += 2;
}
</pre>
  <p>В С++20 появилась новая форма инициализации структур — designated initializers:</p>
<pre>
int main() {
  Point point3 = {.x = 1.4, .y = -2.2, .z = -3.98};
  Point point4 = {.color = Color::Orange};
}
</pre>
  <p>Такой способ записи понятнее: сразу видно, какое поле структуры каким значением инициализируется. Важно, что поля должны быть перечислены в том же порядке, в каком они указываются при описании структуры (причину этого мы узнаем в параграфе про конструкторы и жизненный цикл объекта). Пропущенные поля будут инициализироваться значением по умолчанию. Так, point3.color будет равно Color::White — нулевому значению перечисления Color.</p>

  <h4>Выравнивание</h4>

  <p>Теперь давайте поговорим про размеры перечислений и структур:</p>
<pre>
int main() {
  std::cout &lt;&lt; sizeof(double) &lt;&lt; "\n";  // 8
  std::cout &lt;&lt; sizeof(Color) &lt;&lt; "\n";   // 4 (фактически это int)
  std::cout &lt;&lt; sizeof(Point) &lt;&lt; "\n";   // 32
}
</pre>
  <p>Получается, что размер структуры Point (32 байта) не равен сумме размеров её частей (8 + 8 + 8 + 4 = 28). Всё дело в выравнивании: компилятору не очень удобно работать со структурой в 28 байт при условии, что внутри этой структуры есть переменные, размер которых — 8 байт (так как 28 не кратно 8). Поэтому компилятор резервирует за структурой несколько лишних байтов (в нашем случае — 4).</p>
  <p>Можно явно попросить компилятор не выделять мнимых байтов, но в таком случае пострадает скорость — потому что если данные в памяти выровнены, то их легче достать и проще обрабатывать.</p>

  <h4>Кортежи и пары</h4>

  <p>В заголовочном файле utility есть шаблонная структура std::pair с полями first и second. Из названия просто догадаться, что она хранит два объекта:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;utility&gt;

int main() {
  // в угловых скобках нужно указывать два типа:
  std::pair&lt;int, double&gt; p = {42, 3.14};

  // обращаться к полям можно через .first и .second:
  std::cout &lt;&lt; p.first &lt;&lt; "\n";  // 42
  std::cout &lt;&lt; p.second &lt;&lt; "\n"; // 3.14
}
</pre>
  <p>Однако у std::pair есть проблема — её поля обезличены, и не очень ясно, какую смысловую нагрузку несёт first, а какую — second. Из-за этого мы советуем не злоупотреблять данной структурой, кроме случаев, когда она используется в функциях стандартной библиотеки.</p>
  <p>Обобщением пары на несколько переменных является кортеж — std::tuple, объявленный в заголовочном файле tuple:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;tuple&gt;

struct Point;  // определена выше

int main() {
  std::tuple&lt;int, double, Point&gt; t = {42, 3.14, {.color = Color::Orange}};

  // тут уже нет полей .first и .second,
  // но есть стандартная функция std::get&lt;&gt;,
  // которая принимает в угловых скобках
  // индекс элемента (индексация с нуля):
  std::cout &lt;&lt; std::get&lt;0&gt;(t) &lt;&lt; "\n";   // 42
  std::cout &lt;&lt; std::get&lt;1&gt;(t) &lt;&lt; "\n";   // 3.14
  std::cout &lt;&lt; std::get&lt;2&gt;(t).x &lt;&lt; "\n"; // 0.0

  // вызов std::get может появляться и слева от присваивания:
  std::get&lt;2&gt;(t).color = Color::Red;
}
</pre>
  <p>Важно понимать, что типы элементов пары или кортежа, а также размер кортежа фиксируются на этапе компиляции.</p>
  <p>Пару, кортеж или структуру можно «распаковать» с помощью structured binding.</p>
<pre>
#include &lt;string&gt;
#include &lt;utility&gt;

int main() {
  std::pair&lt;std::string, int&gt; p = {"hello", 42};
  auto [word, freq] = p;  // word = "hello"; freq = 42;
}
</pre>
  <p>Здесь конструкция auto [word, freq] = p вводит две новые переменные word и freq соответствующих типов и присваивает им значения из пары.</p>
</article>


<!-- 2.6 Ссылки, указатели, константность -->
<article class="article">
  <div class="anchor" id="p2.6"></div>
  <h3>2.6 Ссылки, указатели, константность</h3>

  <p>Ссылки позволяют вводить псевдонимы для переменных. Указатели — это самостоятельные типы данных, которые могут хранить адреса других переменных в памяти. Ключевое слово const позволяет подчеркнуть, что переменная используется только для чтения. Часто оно используется совместно с объявлением ссылок и указателей.</p>

  <h4>Копии переменных</h4>

  <p>Для начала давайте рассмотрим такой фрагмент кода:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string s1 = "Elementary, my dear Watson!";
  std::string s2 = s1;

  s1.clear();  // s2 никак не изменится

  std::cout &lt;&lt; s1 &lt;&lt; "\n";  // пустая строка
  std::cout &lt;&lt; s2 &lt;&lt; "\n";  // Elementary, my dear Watson!
}
</pre>
  <p>Важно понимать, что здесь s2 будет совершенно новой строкой, которая проинициализирована значением s1, но более никак с s1 не связана. Это отличает С++ от некоторых других языков программирования — например, языка Python. В них после аналогичного присваивания строка осталась бы той же самой.</p>
  <p>Создание новой строки s2 требует ресурсов: нужно выделить новый блок памяти и скопировать туда старую строку.</p>

  <h4>Ссылки</h4>
  <p>Впрочем, в C++ есть возможность обращаться к уже существующему в памяти объекту под другим именем. Рассмотрим это на примере целых чисел:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int x = 42;
  int& ref = x;  // ссылка на x

  ++x;
  std::cout &lt;&lt; ref &lt;&lt; "\n";  // 43
}
</pre>
  <p>Здесь ref — псевдоним для x. Это не самостоятельная переменная, а просто ссылка на объект, уже живущий в памяти. Формально типом ref является int& — ссылка на int.</p>
  <p>Аналогично для строк:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string s1 = "Elementary, my dear Watson!";
  std::string& s2 = s1;  // тут ссылка!

  s1.clear();

  std::cout &lt;&lt; s2.size() &lt;&lt; "\n";  // напечатает 0
}
</pre>
  <p>Ссылка должна быть проинициализирована сразу в момент объявления. Например, так написать нельзя:</p>
<pre>
int main() {
  int my_variable = 42;
  int& ref;  // ошибка!
  // ...
  ref = my_variable;
}
</pre>
  <p>Ссылка привязана к одному и тому же объекту со своего рождения. Переназначить её нельзя:</p>
<pre>
int main() {
  int x = 42, y = 13;
  int& ref = x;  // OK
  ref = y;
  // ссылка останется привязанной к x,
  // значение x поменяется
}
</pre>
  <p>Ссылки удобны там, где исходное имя слишком громоздко (например, является вложенным полем какой-либо структуры).</p>

  <h4>Указатели</h4>
  <p>Другой (более базовый) способ сослаться на что-то уже существующее в памяти — указатели. Это специальные типы данных, которые могут хранить адрес какой-либо другой переменной в памяти. Здесь мы можем представлять себе память как длинную ленту с пронумерованными ячейками (байтами). Сам адрес переменной можно получить с помощью унарного оператора &:</p>
<pre>
int main() {
  int x = 42;
  // сохраняем адрес в памяти переменной x в указатель ptr
  int* ptr = &x;

  ++x;  // увеличим x на единицу
  std::cout &lt;&lt; *ptr &lt;&lt; "\n";  // 43
}
</pre>
  <p>Формально указатель — это не номер ячейки памяти, а отдельный тип. Но обычно он может быть преобразован к целому числу. Вот такой код напечатает адреса переменных в шестнадцатеричном виде:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int x = 1, y = 2, z = 3;
  std::cout &lt;&lt; &x &lt;&lt; "\n";
  std::cout &lt;&lt; &y &lt;&lt; "\n";
  std::cout &lt;&lt; &z &lt;&lt; "\n";
}
</pre>
  <p>Пример вывода:</p>
<pre>
0x7ffdfee3188c
0x7ffdfee31888
0x7ffdfee31884
</pre>
  <p>Можно заметить, что адреса будут идти «рядом» с шагом sizeof(int) по возрастанию или убыванию — это зависит от платформы и компилятора. Но при повторном запуске программы они могут отличаться, так как программе может быть назначен совсем другой сегмент памяти.</p>
  <p>Кроме адреса ячейки памяти переменная-указатель обладает ещё и типом данных, значение которого в этой ячейке лежит. Это позволяет компилятору правильно интерпретировать обращение к памяти по этому адресу. Поэтому мы используем не какой-либо абстрактный тип «указатель», а именно «указатель на int».</p>
  <p>Оператор разыменования (унарная звёздочка) противоположен оператору взятия адреса (унарному амперсанду). Сравните: &x — это адрес x в памяти, а *ptr — это значение, живущее по адресу, записанному в ptr.</p>
  <p>Указатели, в отличие от ссылок, можно переназначать. Кроме того, есть выделенное значение никуда не ссылающегося указателя — nullptr («нулевой» указатель):</p>
<pre>
#include <iostream>

int main() {
  int x = 42, y = 13;
  // по умолчанию не инициализируется, тут лежит «случайный» адрес
  int* ptr;
  ptr = nullptr;  // «нулевой» указатель
  ptr = &x;  // теперь в ptr лежит адрес переменной x
  std::cout &lt;&lt; *ptr &lt;&lt; "\n";  // 42
  ptr = &y;  // можно поменять адрес, записанный в ptr
  std::cout &lt;&lt; *ptr &lt;&lt; "\n";  // 13
}
</pre>
  <p>Указатель nullptr нельзя разыменовывать: это приведёт к неопределённому поведению.</p>
  <p>Часто указатели используются вместе с динамическим выделением памяти (malloc/new). Мы познакомимся с динамической памятью в параграфе «Жизненный цикл объекта». А сейчас лишь стоит заметить, что указатель сам по себе совершенно не означает, что память, на которую он ссылается, была выделена динамически. Например, во всех примерах выше указатель ссылался на обычную переменную на стеке.</p>
  <p>Отдельно рассмотрим <strong>указатели на структуру</strong>. Для обращения к полям структуры через указатель есть отдельный оператор ->:</p>
<pre>
#include &lt;iostream&gt;

struct Point {
  double x, y, z;
};

int main() {
  Point p = {3.0, 4.0, 5.0};

  Point* ptr = &p;

  // обращение через * и . требует скобок
  std::cout &lt;&lt; (*ptr).x &lt;&lt; "\n";
  // то же самое, но чуть короче
  std::cout &lt;&lt; ptr->x &lt;&lt; "\n";
}
</pre>

  <h4>Константность</h4>

  <p>Константа — это переменная, предназначенная только для чтения. Её значение должно быть зафиксировано в момент присваивания. При этом оно не обязательно должно быть известно в момент компиляции:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  // эта константа известна в compile time
  const int c1 = 42;

  int x;
  std::cin >> x;
  // значение становится известным только в runtime
  const int c2 = 2 * x;

  // ошибка компиляции: константе нельзя присвоить новое значение
  с2 = 0;
}
</pre>
  <p>У константного вектора или строки нельзя будет вызвать функции, которые их будут изменять:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  const std::vector&lt;int&gt; v = {1, 3, 5};

  // OK, напечатает 3
  std::cout &lt;&lt; v.size() &lt;&lt; "\n";

  // ошибка компиляции: константный вектор нельзя изменять
  v.clear();

  // тоже ошибка компиляции
  v[0] = 0;
}
</pre>
  <p>Ссылки и указатели можно комбинировать с константностью:</p>
<pre>
int main() {
  int x = 42;

  // обычная ссылка
  int& ref = x;

  // константная ссылка
  const int& cref = x;
  ++x;  // OK
  ++ref;  // OK

  // ошибка компиляции: псевдоним cref предназначен только для чтения
  ++cref;

  // обычный указатель
  int* ptr = &x;

  // указатель на константу
  const int* cptr = &x;
  ++*ptr;  // OK

  // ошибка компиляции: разыменованный cptr — константа!
  ++*cptr;
}
</pre>
  <p>Если исходная переменная уже была константной, то взять обычную ссылку или указатель на неё не получится. Другими словами, константность нельзя просто так отменить, её можно только добавить:</p>
<pre>
int main() {
  const int cx = 42;

  // ошибка компиляции: константность нельзя убрать
  int& ref = cx;
  const int& cref = cx;  // OK

  // тоже ошибка компиляции
  int* ptr = &cx;
  const int* cptr = &cx;  // OK
}
</pre>
  <p>Базовый тип и слово const можно менять местами. Так что const T и T const — это одно и то же. Но следует различать указатель на константу (const T*) и константу типа «указатель» (T* const):</p>
<pre>
int main() {
  int x = 42;
  const int cx = 13;

  // обычный указатель
  int* ptr = &x;
  // ошибка компиляции
  ptr = &cx;

  // OK: через *cptr нельзя будет изменить x
  const int* cptr = &x;
  cptr = &cx;  // OK

  // OK: *ptrc можно менять, но сам ptrc менять нельзя
  int* const ptrc = &x;
  ptrc = nullptr;  // ошибка компиляции

  // OK, для &cx тоже бы сработало
  const int* const cptrc = &x;
}
</pre>
  <p>Пример в последней строке похож на константную ссылку: указатель cptrc не позволяет менять содержимое ячейки &x (первый const) и в него нельзя записать адрес другой переменной (второй const).</p>

  <h4>Ссылки в цикле range-for</h4>

  <p>Рассмотрим итерацию по элементам вектора строк. Намеренно положим в вектор много длинных строк и в цикле попробуем подсчитать их длину (которую, конечно, можно было бы сразу вычислить):</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  // создаём вектор из m строк длины n
  // и искусственно заполняем его:
  const size_t m = 1000000;
  const size_t n = 10000;
  std::vector&lt;std::string&gt; v(m);
  for (size_t i = 0; i != m; ++i) {
    v[i].resize(n, '@');  // кладём в вектор строку из n символов @
  }

  // нам интересен этот цикл:
  size_t sum = 0;
  for (auto row : v) {
    sum += row.size();
  }
  std::cout &lt;&lt; sum &lt;&lt; "\n";
}
</pre>
  <p>Скомпилируем программу с умеренным уровнем оптимизаций (ключ -O2) и измерим время её работы с помощью консольной утилиты time:</p>
<pre>
$ clang++ -O2 -o runnable test.cpp
$ time ./runnable

real   0m4,255s
user   0m1,948s
sys    0m2,307s
</pre>
  <p>Программа работала 4,255 секунды. Давайте её ускорим. Заметим, что в цикле мы пишем</p>
<pre>
for (auto row : v) {
  // ...
}
</pre>
  <p>На самом деле это эквивалентно такому:</p>
<pre>
for (size_t i = 0; i != v.size(); ++i) {
  std::string row = v[i];  // здесь создаётся копия!
  // ...
}
</pre>
  <p>Понятно, что вместо копирования очередной строки можно воспользоваться константной ссылкой:</p>
<pre>
for (const auto& row : v) {
  // ...
}
</pre>
  <p>Время работы такой программы уже будет меньше:</p>
<pre>
$ time ./runnable

real   0m3,462s
user   0m1,157s
sys    0m2,305s
</pre>
  <p>Давайте запомним: чтобы избегать лишнего копирования, в range-for используйте константную ссылку при итерации по набору «тяжёлых» объектов — строк, векторов, структур. Если вы хотите в цикле менять элементы контейнера — используйте обычную ссылку. Нашу программу можно было бы переписать так:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  const size_t m = 1000000;
  const size_t n = 10000;
  std::vector&lt;std::string&gt; v(m);
  for (auto& row : v) {  // обычная ссылка
    row.resize(n, '@');
  }

  size_t sum = 0;
  for (const auto& row : v) {  // константная ссылка
    sum += row.size();
  }
  std::cout &lt;&lt; sum &lt;&lt; "\n";
}
</pre>

  <h4>«Висячие» ссылки и указатели</h4>

  <p>Может так оказаться, что переменная, на адрес которой ссылается указатель, уже вышла из своей области видимости. Похожая ситуация может произойти и со ссылками. В таком случае обращаться к памяти через ссылку или указатель нельзя — это приведёт к неопределённому поведению.</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int* ptr = nullptr;

  {
    int x = 42;
    ptr = &x;
  }

  // обращаться к памяти, в которой жила переменная x, уже нельзя:
  // неопределённое поведение!
  std::cout &lt;&lt; *ptr &lt;&lt; "\n";
}
</pre>
  <p>Аналогичная ситуация произойдёт при обращении к уже не существующему элементу вектора:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;std::string&gt; words = {"one", "two", "three"};

  std::string& ref = words[0];  // псевдоним для начального элемента вектора

  words.clear();

  // обращаться к ссылке ref уже нельзя!
  std::cout &lt;&lt; ref &lt;&lt; "\n";  // неопределённое поведение!
}
</pre>
  <p>Важно не допускать в программах таких ситуаций.</p>
</article>


<!-- 2.7 Функции -->
<article class="article">
  <div class="anchor" id="p2.7"></div>
  <h3>2.7 Функции</h3>

  <p>Функции позволяют отделить часто используемый код и переиспользовать его с разными значениями аргументов. С примером функции мы уже знакомы: в каждой программе вы пишете функцию main, которая не принимает аргументов и возвращает int.</p>

  <h4>Примеры функций</h4>

  <p>Напишем простейшую функцию, вычисляющую сумму двух целых чисел:</p>
<pre>
// в заголовке функции указывается
// тип возвращаемого значения
// и типы аргументов
int Sum(int a, int b) {
  return a + b;
}
</pre>
  <p>Если функция ничего не должна возвращать, её можно объявить как void:</p>
<pre>
void DoSomething(double d, char c) {
  // ...
  // писать return в конце такой функции не обязательно,
  // но если требуется завершить функцию, можно написать просто return;
}

int main() {
  int x = 17, y = 42;
  int z = Sum(x, y);
   DoSomething(3.14, '@');
}
</pre>
  <p>Вот пример рекурсивной функции, вычисляющей факториал:</p>
<pre>
#include &lt;cstdint&gt;
#include &lt;iostream&gt;

std::uint64_t Factorial(std::uint64_t n) {
  if (n == 0) {
    return 1;
  }
  return n * Factorial(n - 1);  // рекурсивный вызов
}

int main() {
  std::cout &lt;&lt; Factorial(5) &lt;&lt; "\n";  // 120
}
</pre>
  <p>Помните, что если делать очень много рекурсивных вызовов, то рано или поздно переполнится стек — область памяти, в которой хранятся аргументы и локальные переменные текущей функции.</p>

  <h4>Аргументы функций</h4>

  <p>Параметры в функции по умолчанию передаются «по значению». Другими словами, функция работает с копиями аргументов. Чтобы лучше представить это, давайте посмотрим, что бы получилось, если бы компилятор заменил вызов функции на непосредственное исполнение кода.</p>
  <p>Возьмём такой фрагмент кода:</p>
<pre>
void f(int x, int y) {
  // работаем с аргументами x и y
}

int main() {
  int a, b;
  // какая-то инициализация a и b

  f(a, b);
}
</pre>
  <p>Заменим его на такой код:</p>
<pre>
int main() {
  int a, b;
  // какая-то инициализация a и b

  {
    // этот блок просто ограничивает время жизни
    // находящихся внутри переменных
    int x = a;
    int y = b;
    // работаем с аргументами x и y
  }
}
</pre>
  <p>Теперь видно, что любое изменение x или y внутри функции никак не затронет a и b.</p>
  <p>Можем ли мы изменить переданный аргумент внутри функции, чтобы это повлияло на аргументы в месте вызова? Да, для этого надо передать аргументы через ссылку или указатель. Вот классический пример функции, меняющей два аргумента местами:</p>
<pre>
void Swap(int& x, int& y) {  // передаём аргументы по ссылке
  int z = x;
  x = y;
  y = z;
}

int main() {
  int a = 1, b = 2;
  Swap(a, b);
  std::cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; "\n";  // 2 1
}
</pre>
  <p>Чтобы понять, как это работает, раскроем снова код функции в месте вызова:</p>
<pre>
int main() {
  int a = 1, b = 2;

  {
    int& x = a;
    int& y = b;
    int z = x;
    x = y;
    y = z;
  }

  std::cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; "\n";  // 2 1
}
</pre>
  <p>Видно, что x и y — это просто псевдонимы для a и b.</p>
  <p>Заметьте, что вызов Swap(1, 2), в отличие от Swap(a, b), не скомпилируется, потому что обычная ссылка должна быть привязана к изменяемому объекту.</p>
  <p>Примером функции из стандартной библиотеки, которая принимает аргумент по ссылке и изменяет его, является std::getline:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string line;

  // Второй аргумент передаётся по ссылке и изменяется внутри функции:
  std::getline(std::cin, line);
}
</pre>
  <p>Иногда копирование объекта может быть очень дорогим (и ненужным). Например, копирование вектора приведёт к копированию всех его элементов. Поэтому вот так передавать вектор в функцию неэффективно:</p>
<pre>
void f(std::vector&lt;int&gt; v) {
  // плохо: при вызове функции создаётся копия вектора
}
</pre>
  <p>Копии можно было бы избежать, если бы вектор передавался по ссылке:</p>
<pre>
void f(std::vector&lt;int&gt;& v) {
  // Но теперь есть другие недостатки:
  // 1. В такую функцию нельзя передать константный вектор.
  // 2. Функция не защищена от случайного изменения вектора:
  v.clear();  // тут компилятор нас не схватит за руку
}
</pre>
  <p>Поэтому самое правильное — передавать такой параметр по константной ссылке:</p>
<pre>
void f(const std::vector&lt;int&gt;& v) {
  // Такой аргумент не требует дорогого копирования,
  // его нельзя случайно изменить внутри,
  // и такую функцию можно вызывать от констант!
}
</pre>
  <p>Давайте запомним: аргументы сложных типов (векторы, строки, любые контейнеры, большие структуры) всегда лучше передавать в функцию по константной ссылке, если функция использует их только для чтения. Из этого правила бывают исключения, но о них мы поговорим отдельно.</p>
  <p>Впрочем, это правило не стоит распространять на обычные встроенные типы:</p>
<pre>
void g(const int& a, const char& c) {
  // так делать не надо, это уже перебор!
  // передавайте такие параметры просто
  // по значению, как int или char
}
</pre>

  <h4>Возвращаемые значения функций</h4>

  <p>В отличие от аргументов, значения сложных типов можно без проблем возвращать из функций. Здесь от ненужного копирования (по крайней мере, для стандартных контейнеров) спасает copy elision.</p>
  <p>Рассмотрим, например, функцию, которая возвращает конкатенацию всех строк из вектора:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

std::string Concatenate(const std::vector&lt;std::string&gt;& parts) {
  std::string result;
  for (const auto& part : parts) {
    result += part;
  }
  return result;
}

int main() {
  std::vector&lt;std::string&gt; parts = {"abra", "ca", "dabra"};
  std::cout &lt;&lt; Concatenate(parts) &lt;&lt; "\n";  // abracadabra
}
</pre>
  <p>Опасно возвращать из функции ссылку на локальную переменную, так как эта ссылка сразу же станет «висячей»:</p>
<pre>
#include &lt;iostream&gt;

int& Sum(int a, int b) {  // ошибка!
  int result = a + b;
  return result;
}

int main() {
  // неопределённое поведение!
  std::cout &lt;&lt; Sum(2, 3) &lt;&lt; "\n";
}
</pre>
  <p>Компиляторы в таких случаях генерируют предупреждения.</p>
  <p>Возвращать значение по ссылке можно только в случае, если оно заведомо будет доступно после завершения функции. Например, так можно вернуть глобальную переменную или аргумент, также переданный по ссылке.</p>

  <h4>Функции-компараторы</h4>

  <p>Пусть имеется структура Date, описывающая день, месяц и год какой-то даты. Создадим вектор дат:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

struct Date {
  int year = 1970;
  int month = 1;
  int day = 1;
};

int main() {
  std::vector&lt;Date&gt; dates = {
    {2020, 3, 15},
    {2019, 1, 21},
    {2021, 1, 30}
  };

  // напечатаем содержимое:
  for (const auto& [year, month, day] : dates) {
    std::cout &lt;&lt; year &lt;&lt; "." &lt;&lt; month
    &lt;&lt; "." &lt;&lt; day &lt;&lt; "\n";
  }
}
</pre>
  <p>Предположим, нам требуется отсортировать даты. Для сортировки нам поможет уже знакомая функция std::sort, но есть нюанс: вызов std::sort(dates.begin(), dates.end()) не скомпилируется, так как компилятор не умеет сравнивать даты между собой. Функция std::sort пытается найти оператор &lt; для сравнения дат, но, увы, для нашей даты такого нет. Мы можем его определить. Он выглядит как функция с особым именем operator &lt;, возвращающая true, если первый аргумент меньше второго:</p>
<pre>
bool operator &lt; (const Date& lhs, const Date& rhs) {
  if (lhs.year != rhs.year) {
    return lhs.year &lt; rhs.year;
  }
  if (lhs.month != rhs.month) {
    return lhs.month &lt; rhs.month;
  }
  return lhs.day &lt; rhs.day;
}
</pre>
  <p>Здесь lhs и rhs — сокращения от left-hand side и right-hand side. Это левый и правый аргументы оператора &lt;. Этот громоздкий код можно записать лаконичнее с использованием функции std::tie, возвращающей кортеж из ссылок, для которого уже определено лексикографическое (покомпонентное) сравнение:</p>
<pre>
bool operator &lt; (const Date& lhs, const Date& rhs) {
  return std::tie(lhs.year, lhs.month, lhs.day) &lt; std::tie(rhs.year, rhs.month, rhs.day);
}
</pre>
  <p>После определения operator &lt; сортировка заработает. Но что, если нам в разных случаях нужно по-разному сортировать даты — например, где-то в хронологическом порядке, а где-то — без учёта года? Можно передать в std::sort третьим аргументом свою функцию сравнения, которая будет использована вместо operator &lt;:</p>
<pre>
bool CompareWithoutYear(const Date& lhs, const Date& rhs) {
  return std::tie(lhs.month, lhs.day) &lt; std::tie(rhs.month, rhs.day);
}

int main() {
  // ...
  std::sort(dates.begin(), dates.end(), CompareWithoutYear);
}
</pre>
  <p>Обратите внимание, что третьим аргументом в std::sort мы передаём саму функцию (без круглых скобок), а не результат её вызова от каких-то аргументов.</p>

  <h4>Лямбда-функции</h4>

  <p>Иногда бывает неудобно определять отдельную именованную функцию для сравнения. Тогда можно определить анонимную лямбда-функцию прямо в месте её использования:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;vector&gt;

struct Date {
  int year, month, day;
};

int main() {
  std::vector&lt;Date&gt; dates;
  std::sort(dates.begin(), dates.end(), [](const Date& lhs, const Date& rhs) {
    return std::tie(lhs.month, lhs.day) &lt; std::tie(rhs.month, rhs.day);
  });
}
</pre>
  <p>Тип возвращаемого значения тут не указывается, компилятор умеет его угадывать по return (его можно указать после круглых скобок на «питоновский» манер через ->, но не обязательно).</p>
  <p>Разберём синтаксис лямбда-функций. Тут видны три блока.</p>
  <ol>
    <li>Квадратные скобки отвечают за контекст. В них мы можем передать переменные, которые объявлены вне лямбда-функции через запятую, и они будут доступны в самой лямбда-функции.</li>
    <li>Круглые скобки отвечают за аргументы функции.</li>
    <li>Фигурные скобки отвечают за тело лямбда-функции.</li>
  </ol>
  <p>Когда лямбды добавлялись в стандарт C++11, разработчики очень не хотели вводить для них новое ключевое слово (как lambda в Python) и обошлись комбинацией скобок. Есть шутка про то, что вот такая программа является вполне корректной:</p>
  <code>int main() {[](){}();}</code>
  <p>Попробуйте разобраться, что тут происходит.</p>
</article>


<!-- 2.8 Шаблоны -->
<article class="article">
  <div class="anchor" id="p2.8"></div>
  <h3>2.8 Шаблоны</h3>

  <p>Шаблоны — это фрагменты обобщённого кода, в котором некоторые типы или константы вынесены в параметры. Шаблонными могут быть функции, структуры (классы) и даже переменные. Компилятор превращает использование шаблона в конкретный код, подставляя в него нужные параметры на этапе компиляции. Шаблоны позволяют писать общий код, пригодный для использования с разными типами данных.</p>
  <p>Стандартная библиотека C++ построена на шаблонах. Раньше её даже называли Standard Template Library (STL, стандартная библиотека шаблонов). Её контейнеры и итераторы являются шаблонными классами, а алгоритмы — шаблонными функциями. Примеры шаблонных конструкций из стандартной библиотеки нам уже встречались: это, например, контейнер std::vector и функция std::sort. В следующем параграфе мы рассмотрим контейнер std::array, размер которого задаётся шаблонной константой времени компиляции. В этом параграфе мы рассмотрим шаблоны функций и структур, параметры которых являются типами. Но прежде чем говорить про шаблоны, рассмотрим перегрузку функций.</p>

  <h4>Перегрузка функций</h4>

  <p>Количество и типы аргументов функции должны быть известны заранее, на этапе компиляции. Но в языке C++ можно создавать функции с одним и тем же именем, но разным набором или типами аргументов и с разными телами. Такие функции называются перегруженными. Рассмотрим, например, семейство перегруженных функций для печати переменной на экран:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

void Print(int value) {
  std::cout &lt;&lt; value &lt;&lt; "\n";
}

void Print(const std::string& name, int value) {
  // печатаем название и саму величину
  std::cout &lt;&lt; name &lt;&lt; ": " &lt;&lt; value &lt;&lt; "\n";
}

void Print(const std::string& str) {
  std::cout &lt;&lt; str &lt;&lt; "\n";
}

int main() {
  Print(42);  // версия 1
  Print("x", 42);  // версия 2
  Print("good bye");  // версия 3
}
</pre>
  <p>Компилятор, сравнивая разные версии функции друг с другом, смотрит на их имена и набор типов аргументов. При этом имена аргументов ни на что не влияют. Также нельзя перегружать функции по типу возвращаемого значения. Действительно, возвращаемое значение может просто игнорироваться в месте вызова, и компилятор не сможет определить, какая версия функции имеется в виду.</p>
<pre>
int f(int x) {
  return x;
}

// ошибка компиляции: функция с таким
// именем и типом параметра уже была
int f(int y) {
  return 2 * y;
}

// ошибка компиляции: перегружать
// по возвращаемому значению нельзя
double f(int x) {
  return 3 * x;
}
</pre>

  <h4>Шаблонные функции</h4>

  <p>Рассмотрим классический пример. Предположим, у нас есть функция, вычисляющая максимум целых чисел:</p>
<pre>
int Max(int x, int y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}
</pre>
  <p>Она определена для аргументов типа int. Однако, если применить её к аргументам типа double, результат получится неожиданным. А её применение к строкам или векторам вообще не скомпилируется:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::cout &lt;&lt; Max(1, 2) &lt;&lt; "\n";  // 2
  std::cout &lt;&lt; Max(3.14159, 2.71828) &lt;&lt; "\n";  // внезапно 3

  std::string word1 = "hello", word2 = "world";
  std::cout &lt;&lt; Max(word1, word2);  // ошибка компиляции
}
</pre>
  <p>В вызове Max(3.14159, 2.71828) аргументы будут преобразованы к типу int, то есть получится Max(3, 2). Вызов Max(word1, word2) не скомпилируется, так как строки нельзя привести к типу int. Чтобы эти вызовы корректно заработали, надо определить перегруженные версии функции Max:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int Max(int x, int y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}

double Max(double x, double y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}

std::string Max(const std::string& x, const std::string& y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}

int main() {
  std::cout &lt;&lt; Max(1, 2) &lt;&lt; "\n";  // 2
  std::cout &lt;&lt; Max(3.14159, 2.71828) &lt;&lt; "\n";  // 3.14159

  std::string word1 = "hello", word2 = "world";
  std::cout &lt;&lt; Max(word1, word2);  // world
}
</pre>
  <p>Выписывать похожие друг на друга версии функций утомительно. Кроме того, такие функции не смогут работать с новыми, неизвестными нам заранее типами. Шаблоны позволяют описать такую функцию один раз, вынеся тип в параметры:</p>
<pre>
template &lt;typename T&gt;
T Max(const T& x, const T& y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}
</pre>
  <p>Шаблон начинается с шапки template. Далее в угловых скобках перечисляются формальные имена параметров. В нашем случае параметр один — это тип T (от слова type). Вместо ключевого слова typename в этом месте допускается использовать слово class (вы можете встретить такие описания шаблонов на cppreference.com). А вместо имени T можно было бы использовать любой другой идентификатор.</p>
  <p>Так как мы не знаем, будет ли тип T встроенным или сложным, то на всякий случай передаём аргументы в функцию по константной ссылке, чтобы избежать лишнего копирования.</p>
  <p>В нашей шаблонной функции Max используется оператор >. Он определён для обычных чисел, строк и векторов (если, конечно, для элементов вектора тоже определён этот оператор). Но если попробовать применить наш шаблон к типу, не поддерживающему оператор >, то произойдёт ошибка компиляции:</p>
<pre>
struct Point {
  double x = 0.0;
  double y = 0.0;
  double z = 0.0;
};

int main() {
  Point p1, p2;
  Point p = Max(p1, p2);  // ошибка компиляции
}
</pre>

  <h4>Вывод шаблонных параметров</h4>

  <p>Конкретные версии шаблонной функции Max для нужных типов получаются подстановкой шаблонных аргументов в угловые скобки. Так, Max&lt;int&gt; — это версия нашей функции для типа int, а Max&lt;std::string&gt; — версия для строк. Важно понимать, что, несмотря на общий шаблон, это разные функции, которые просто порождаются компилятором по образцу.</p>
  <p>Вызвать шаблонную функцию можно было бы так:</p>
<pre>
Max&lt;double&gt;(3.14159, 2.71828);  // 3.14159
Max&lt;int&gt;(3.14159, 2.71828);  // вызывается int-версия, вернётся 3
</pre>
  <p>Однако параметры шаблона в угловых скобках можно не писать: компилятор попытается сам угадать эти параметры по типу аргументов:</p>
<pre>
int main() {
  // 2, вызывается Max&lt;int&gt;
  std::cout &lt;&lt; Max(1, 2) &lt;&lt; "\n";
   // 3.14159, вызывается Max&lt;double&gt;
  std::cout &lt;&lt; Max(3.14159, 2.71828) &lt;&lt; "\n";

  std::string word1 = "hello", word2 = "world";
  // world, вызывается Max&lt;std::string&gt;
  std::cout &lt;&lt; Max(word1, word2);
}
</pre>
  <p>В случае неоднозначностей, например в вызове Max(3.14159, 2), компилятор не сможет автоматически вывести параметр, и ему придётся подсказать тип: Max&lt;double&gt;(3.14159, 2).</p>

  <h4>Перегрузка шаблонных функций</h4>

  <p>Шаблонные функции тоже можно перегружать. Пусть, например, мы хотим вычислять максимум двух векторов, но при этом сравнивать векторы сначала по размеру, а затем уже лексикографически. Стандартное сравнение векторов через оператор > не будет учитывать размер. Поэтому напишем отдельную перегрузку для векторов:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

// общая версия
template &lt;typename T&gt;
T Max(const T& x, const T& y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}

// перегрузка для векторов
template &lt;typename T&gt;
const std::vector&lt;T&gt;& Max(const std::vector&lt;T&gt;& v1, const std::vector&lt;T&gt;& v2) {
  if (v1.size() > v2.size()) {
    return v1;
  } else if (v1.size() &lt; v2.size()) {
    return v2;
  } else if (v1 > v2) {
    return v1;
  } else {
    return v2;
  }
}

int main() {
  std::cout &lt;&lt; Max(1, 2) &lt;&lt; "\n";  // вызов общей версии

  std::vector&lt;int&gt; v1 = {1, 2, 3};
  std::vector&lt;int&gt; v2 = {4, 5};
  for (int x : Max(v1, v2)) {  // вызов перегруженной версии
    std::cout &lt;&lt; x &lt;&lt; " ";  // 1 2 3
  }
  std::cout &lt;&lt; "\n";
}
</pre>

  <h4>Разрешение неоднозначностей</h4>

  <p>Когда компилятор видит вызов функции, ему нужно правильно определить, в каком пространстве имён её искать, какую из перегруженных версий выбрать, а в случае шаблонной функции — как вывести параметры шаблона. Для шаблонных функций после выбора перегруженной версии возможен ещё выбор из вариантов полной специализации шаблона. Общие правила поиска нужной функции достаточно сложны, и мы не будем их здесь приводить полностью. Однако в случаях, которые мы будем рассматривать в этом учебнике, выбор нужной функции будет интуитивно понятен.</p>

  <h4>Шаблонные структуры</h4>

  <p>Структуры и классы также могут быть описаны в общем виде и параметризованы типами или константами времени компиляции. Типичный пример шаблонной структуры — std::pair. Определим по аналогии свою структуру Triple с тремя шаблонными типами:</p>
<pre>
#include &lt;string&gt;

template &lt;typename T1, typename T2, typename T3&gt;
struct Triple {
  T1 first;
  T2 second;
  T3 third;
};

int main() {
  Triple&lt;int, int, int&gt; point = {-1, 3, 2};
  Triple&lt;std::string, std::string, int&gt; wordPairsFreq = {"hello", "world", 42};
}
</pre>
  <p>Здесь так же, как и в случае функций, компилятор генерирует по образцу две никак не связанные друг с другом структуры Triple&lt;int, int, int&gt; и Triple&lt;std::string, std::string, int&gt;.</p>
  <p>В следующих параграфах мы будем подробно рассматривать шаблонные классы, в которых могут быть шаблонные функции-члены.</p>
</article>


<!-- 2.9 Разбор задач к главе «Базовые конструкции C++» -->
<article class="article">
  <div class="anchor" id="p2.9"></div>
  <h3>2.9 Разбор задач к главе «Базовые конструкции C++»</h3>

  <h3>Параграф «Первые шаги»</h3>

  <h4>Задача «Печать текста»</h4>

  <details>
    <summary>Условие</summary>
    <p>Напишите программу, печатающую на экране первые строчки со страницы Бьярне Страуструпа про C++:</p>
<pre>
C++ is a general-purpose programming language with a bias towards systems programming that
  - is a better C
  - supports data abstraction
  - supports object-oriented programming
  - supports generic programming.
</pre>
    <p>Не потеряйте парные пробелы в начале строк и переносы в конце строк.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Задача очень похожа на программу Hello world. Отличие в том, что здесь надо напечатать несколько строк текста. Сам символ перевода строки не может содержаться в обычных строковых литералах, поэтому в программе его придётся заменить на \n. Можно просто вывести каждую строчку отдельно:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  std::cout &lt;&lt; "C++ is a general-purpose programming language with a bias towards systems programming that\n";
  std::cout &lt;&lt; "  - is a better C\n";
  std::cout &lt;&lt; "  - supports data abstraction\n";
  std::cout &lt;&lt; "  - supports object-oriented programming\n";
  std::cout &lt;&lt; "  - supports generic programming.\n";
}
</pre>
    <p>Однако писать каждый раз std::cout утомительно. В конструкции std::cout поддерживается вывод нескольких величин сразу. Можно оставить только самый первый std::cout, а остальные строки вывести через &lt;&lt;:</p>
<pre>
#include <iostream>

int main() {
  std::cout &lt;&lt; "C++ is a general-purpose programming language with a bias towards systems programming that\n"
            &lt;&lt; "  - is a better C\n"
            &lt;&lt; "  - supports data abstraction\n"
            &lt;&lt; "  - supports object-oriented programming\n"
            &lt;&lt; "  - supports generic programming.\n";
}
</pre>
    <p>Здесь мы нарочно для лучшей читаемости отформатировали программу так, чтобы символы &lt;&lt; стояли друг под другом.</p>
    <p>Рассмотрим ещё два способа решить задачу. Строковые константы, расположенные просто друг за другом, автоматически конкатенируются при компиляции программы. Так "Hello," " world!" даст "Hello, world!. Поэтому можно написать так:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  std::cout &lt;&lt; "C++ is a general-purpose programming language with a bias towards systems programming that\n"
               "  - is a better C\n"
               "  - supports data abstraction\n"
               "  - supports object-oriented programming\n"
               "  - supports generic programming.\n";
}
</pre>
    <p>Можно ли избавиться от необходимости писать \n в конце каждой строки? Да, для этого можно воспользоваться raw-литералами. Они могут содержать внутри без экранирования любые символы, в том числе перевод строки, лишь бы они были отличны от выбранных ограничителей. Такие литералы предваряются символом R, а в начале и в конце должна стоять произвольно выбранная одинаковая последовательность символов и круглые скобки. Например, raw(...)raw, или ~~~(...)~~~:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  std::cout &lt;&lt;
R"~~~(C++ is a general-purpose programming language with a bias towards systems programming that
  - is a better C
  - supports data abstraction
  - supports object-oriented programming
  - supports generic programming.
)~~~";
}
</pre>
  </details>

  <h4>Задача «Сумма чисел»</h4>

  <details>
    <summary>Условие</summary>
    <p>Вам даны два целых числа. Напечатайте их сумму.</p>

    <h4>Формат ввода</h4>
    <p>Вводятся два числа, по модулю не превосходящие миллиарда.</p>

    <h4>Формат вывода</h4>
    <p>Напечатайте сумму этих чисел. В конце поставьте перевод строки.</p>

    <h4>Пример</h4>
    <code>1 2</code>
    <code>3</code>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;

int main() {
  int a, b;
  std::cin >> a >> b;
  std::cout &lt;&lt; a + b &lt;&lt; "\n";
}
</pre>
    <p>Проверять корректность условия (то, что числа по модулю не превосходят миллиарда) в программе не нужно.</p>
    <p>Из условия следует, что сумма этих чисел по модулю не будет превосходить двух миллиардов. Забегая немного вперёд, скажем, что это гарантирует, что сумма поместится в тип int. Такие условия позволяют выбрать правильный тип данных для решения задачи.</p>
  </details>

  <h3>Параграф «Типы данных»</h3>

  <h4>Задача «Дюймы»</h4>

  <details>
    <summary>Условие</summary>
    <p>Напишите программу для перевода сантиметров в дюймы. В одном дюйме 2.54 сантиметра.</p>

    <h4>Формат ввода</h4>
    <p>На вход поступает длина в сантиметрах. Значение может быть дробным. Используйте тип double для его хранения.</p>

    <h4>Формат вывода</h4>
    <p>Напечатайте эту длину в дюймах. Округление не требуется. Достаточно использовать стандартную точность вывода до 6 знаков после запятой, которая установлена по умолчанию.</p>

    <h4>Пример</h4>
    <code>1.1</code>
    <code>0.433071</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Если в одном дюйме 2.54 сантиметра, то в одном сантиметре 1/2.54 дюйма:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  double centimeters;
  std::cin >> centimeters;

  double inches = centimeters / 2.54;

  std::cout &lt;&lt; inches &lt;&lt; "\n";
}
</pre>
  </details>

  <h4>Задача «Арифметическая прогрессия»</h4>

  <details>
    <summary>Условие</summary>
    <p>Перед вами программа, которая считает сумму первых n натуральных чисел по формуле суммы арифметической прогрессии:</p>
<pre>
#include <iostream>

int main() {
  int n;
  std::cin >> n;
  std::cout &lt;&lt; n * (n + 1) / 2 &lt;&lt; "\n";
}
</pre>
    <p>Программа должна работать для всех n≤4000000000, но оказывается, что для некоторых n она работает неправильно. Найдите причину проблемы и исправьте программу.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Никакой ошибки в формуле нет. Всё дело в используемом типе данных. При n=46341 происходит переполнение типа int32_t, а при n = 3037000500 происходит переполнение типа int64_t. При выборе беззнакового типа uint64_t переполнения на n=4000000000 не случится. Поэтому просто заменим тип данных на uint64_t.</p>
<pre>
#include &lt;cstdint&gt;
#include &lt;iostream&gt;

int main() {
  std::uint64_t n = 0;
  std::cin >> n;
  std::cout &lt;&lt; n * (n + 1) / 2 &lt;&lt; "\n";
}
</pre>
    <p>Можно было бы сначала выяснить, является ли n чётным, чтобы сначала произвести деление, а потом умножить:</p>
<pre>
#include &lt;cstdint&gt;
#include &lt;iostream&gt;

int main() {
  std::uint64_t number = 0;
  std::cin >> number;

  if (number % 2 == 0) {
    std::cout &lt;&lt; (number / 2) * (number + 1);
  } else {
    std::cout &lt;&lt; ((number + 1) / 2) * number;
  }
  std::cout &lt;&lt; "\n";
}
</pre>
    <p>Тогда лимиты выросли бы ещё больше. Но в решении этого не потребовалось.</p>
  </details>

  <h3>Параграф «Ветвления и циклы»</h3>

  <h4>Задача «Ход ферзя»</h4>

  <details>
    <summary>Условие</summary>
    <p>Шахматный ферзь ходит на любое количество клеток по диагонали, горизонтали или вертикали. Даны две различные клетки на шахматной доске без фигур. Определите, может ли ферзь попасть с первой клетки на вторую одним ходом.</p>

    <h4>Формат ввода</h4>
    <p>Программа получает на вход четыре целых числа от 1 до 8. Первая пара чисел задаёт номер столбца и номер строки для первой клетки. Вторая пара чисел аналогично задаёт вторую клетку.</p>

    <h4>Формат вывода</h4>
    <p>Программа должна вывести YES, если из первой клетки ходом ферзя можно попасть во вторую, или NO в противном случае.</p>

    <h4>Пример 1</h4>
    <code>1 1 2 2</code>
    <code>YES</code>

    <h4>Пример 2</h4>
    <code>1 1 2 3</code>
    <code>NO</code>

    <h4>Пример 3</h4>
    <code>5 6 3 3</code>
    <code>NO</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Ферзь может ходить по вертикали, горизонтали и диагонали. Для того чтобы проверить, является ли ход вертикальным или горизонтальным, достаточно сравнить координаты x1 x2 или y1 y2. Для проверки является ли ход диагональным достаточно сравнить модуль разности координат |x1-x2| и |y1-y2| . Если ни одно из условий не выполняется — ход не может быть совершён ферзём. Для нахождения модуля удобно использовать стандартную функцию std::abs.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;cmath&gt;

int main() {
  int x1, y1, x2, y2;
  std::cin >> x1 >> y1;
  std::cin >> x2 >> y2;

  if (x1 == x2 || y1 == y2 || std::abs(x1 - x2) == std::abs(y1 - y2)) {
    std::cout &lt;&lt; "YES\n";
  } else {
    std::cout &lt;&lt; "NO\n";
  }
}
</pre>
  </details>

  <h4>Задача «Прямоугольный треугольник»</h4>

  <details>
    <summary>Условие</summary>
    <p>Напишите программу, которая проверяет является ли треугольник прямоугольным.</p>

    <h4>Формат ввода</h4>
    <p>На стандартный поток ввода подаётся три целых положительных числа — стороны треугольника. Числа не превосходят 30000.</p>

    <h4>Формат вывода</h4>
    <p>Если полученный треугольник является прямоугольным, напечатайте YES. Если треугольник не является прямоугольным, напечатайте NO. Если с заданными сторонами невозможно построить треугольник, напечатайте UNDEFINED.</p>

    <h4>Пример 1</h4>
    <code>3 2 5</code>
    <code>YES</code>

    <h4>Пример 2</h4>
    <code>3 2 10</code>
    <code>UNDEFINED</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Во-первых, нам необходимо проверить существует ли такой треугольник. Для этого достаточно воспользоваться неравенством треугольника: a+b>c, a+c>b, c+b>a. Если хотя бы одно из этих условий не выполняется, программа должна выводить UNDEFINED.</p>
    <p>Далее необходимо проверить является ли треугольник прямоугольным. Есть несколько способов это сделать. Самый простой — воспользоваться теоремой Пифагора. Если одно из равенств a²+b²=c², a²+c²=b², b²+c²=a² выполняется, программа должна вывести YES. В противном случае надо вывести NO.</p>
    <p>По условию задачи стороны треугольника не превосходят 2¹⁵, а значит выражение a²+b² не будет превосходить 2³⁰+2³⁰=2³¹ и поместится в тип int.</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int a, b, c;
  std::cin >> a >> b >> c;

  if (a + b &lt;= c || a + c &lt;= b || b + c &lt;= a) {
    std::cout &lt;&lt; "UNDEFINED\n";
  } else if (a * a + b * b == c * c || a * a + c * c == b * b || b * b + c * c == a * a) {
    std::cout &lt;&lt; "YES\n";
  } else {
    std::cout &lt;&lt; "NO\n";
  }
}
</pre>
  </details>

  <h4>Задача «Високосный год»</h4>

  <details>
    <summary>Условие</summary>
    <p>Определите, является ли год високосным по григорианскому календарю.</p>
    <p>Напоминание:</p>
    <ol>
      <li>год, номер которого кратен 400, — високосный;</li>
      <li>остальные годы, номер которых кратен 100, — невисокосные (например, годы 1700, 1800, 1900, 2100, 2200, 2300);</li>
      <li>остальные годы, номер которых кратен 4, — високосные.</li>
      <li>все остальные годы — невисокосные.</li>
    </ol>

    <h4>Формат ввода</h4>
    <p>Вводится целое положительное четырёхзначное число — номер года.</p>

    <h4>Формат вывода</h4>
    <p>Программа выводит YES если год високосный и NO в противном случае.</p>

    <h4>Пример 1</h4>
    <code>2003</code>
    <code>NO</code>

    <h4>Пример 2</h4>
    <code>2004</code>
    <code>YES</code>

    <h4>Пример 3</h4>
    <code>3000</code>
    <code>NO</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Грамотно перепишем определения из условия через if/else и проверку остатка от деления:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int year;
  std::cin >> year;

  if (year % 400 == 0) {
    std::cout &lt;&lt; "YES\n";
  } else if (year % 100 == 0) {
    std::cout &lt;&lt; "NO\n";
  } else if (year % 4 == 0) {
    std::cout &lt;&lt; "YES\n";
  } else {
    std::cout &lt;&lt; "NO\n";
  }
}
</pre>
    <p>Заметим, что в получившимся коде дублируются ветви условий. Попробуем его упростить. Для этого достаточно заметить, что високосным является любой год, который делится на 400 или делится на 4, но не делится на 100. После этого упрощения получим следующий код:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int year;
  std::cin >> year;

  if ((year % 400 == 0 || year % 100 != 0) && year % 4 == 0) {
    std::cout &lt;&lt; "YES\n";
  } else {
    std::cout &lt;&lt; "NO\n";
  }
}
</pre>
  </details>

  <h4>Задача «Количество дней в месяце»</h4>

  <details>
    <summary>Условие</summary>
    <p>Напишите программу, выводящую количество дней в месяце по заданному номеру месяца и году.</p>

    <h4>Формат ввода</h4>
    <p>На вход программе подается два целых положительных числа: номер месяца (от 1 до 12) и четырёхзначный год.</p>

    <h4>Формат вывода</h4>
    <p>Необходимо вывести одно число — количество дней в заданном месяце.</p>

    <h4>Пример 1</h4>
    <code>1 2001</code>
    <code>31</code>

    <h4>Пример 2</h4>
    <code>6 3000</code>
    <code>30</code>

    <h4>Пример 3</h4>
    <code>2 2012</code>
    <code>29</code>

    <p>Рекомендуется сначала решить задачу «Високосный год» и использовать её решение для вывода количества дней в феврале.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Эту задачу можно решать либо через if/else, либо через switch/case. Мы воспользуемся вторым вариантом, потому что в таком случае удобно описывать ветви, у которых много разных возможных условий.</p>
    <p>Перечислим все возможные месяцы, для которых ответ будет 31: это январь (1), март (3), май (5), июль (7), август (8), октябрь (10), декабрь (12). Для февраля (2) ответ будет зависеть от года. Воспользуемся кодом из задачи «Високосный год», заменив вывод с YES/NO на 29/28. Для остальных месяцев воспользуемся инструкцией default и выведем 30.</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int month, year;
  std::cin >> month >> year;

  switch (month) {
    case 1:
    case 3:
    case 5:
    case 7:
    case 8:
    case 10:
    case 12:
      std::cout &lt;&lt; "31\n";
      break;
    case 2:
      if ((year % 400 == 0 || year % 100 != 0) && year % 4 == 0) {
        std::cout &lt;&lt; "29\n";
      } else {
        std::cout &lt;&lt; "28\n";
      }
      break;
    default:
      std::cout &lt;&lt; "30\n";
  }
}
</pre>
  </details>

  <h4>Задача «Печать календаря»</h4>

  <details>
    <summary>Условие</summary>
    <p>Напечатайте месяц из календаря по заданному начальному дню и количеству дней. Ваш ответ должен выглядеть примерно так:</p>
<pre>
                   1
 2  3  4  5  6  7  8
 9 10 11 12 13 14 15
16 17 18 19 20 21 22
23 24 25 26 27 28 29
30 31
</pre>
    <h4>Формат ввода</h4>
    <p>Вводится два числа: n — номер дня недели первого числа месяца (целое число от 1 до 7) и k — количество дней в этом месяце (целое число от 1 до 99). n ≤ k. Обратите внимание, что число дней в месяце не обязательно должно быть таким же, как в привычном календаре.</p>
    <h4>Формат вывода</h4>
    <p>Необходимо напечатать календарь как в примере. Пустые позиции в первой строке заполняйте пробелами. Соседние числа также разделяйте пробелами. Под одно число всегда выделяется два символа. В конце строчек до перевода строки пробелов быть не должно. Вывод должен завершаться ровно одним подряд идущим переводом строки.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Для начала выведем отступ перед первым днём. Номер одного дня записывается в два символа, все дни разделены пробелом. Соответственно, необходимо вывести n - 1 раз строку из трёх пробелов.</p>
    <p>Далее введём счётчик dayOfWeek и выставим ему начальное значение, равное n. Будем использовать его для отсчета текущего столбца. Воспользуемся циклом for от 1 до k включительно. Будем выводить текущее число и прибавлять к счётчику 1. Каждый раз, когда счётчик достигает семи, сбрасываем его в единицу и печатаем символ переноса строки \n. Также нужно не забыть, что числа от 1 до 9 занимают всего один символ в нашем календаре. Чтобы это исправить добавим дополнительный if, который ставит пробел перед числом.</p>
    <p>В самом конце проверим, в какой день недели закончился месяц. Если он закончился не в воскресенье, то необходимо допечатать перевод строки.</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int n, k;
  std::cin >> n >> k;

  int dayOfWeek = n;

  for (int i = 1; i &lt; n; ++i) {
    std::cout &lt;&lt; "   ";
  }

  for (int day = 1; day &lt;= k; ++day) {
    if (day &lt; 10) {
      std::cout &lt;&lt; " ";
    }

    std::cout &lt;&lt; day;

    if (dayOfWeek == 7) {
      std::cout &lt;&lt; "\n";
      dayOfWeek = 1;
    } else {
      std::cout &lt;&lt; " ";
      dayOfWeek += 1;
    }
  }

  if (dayOfWeek != 1) {
    std::cout &lt;&lt; "\n";
  }
}
</pre>
  </details>

  <h4>Задача «Сумма цифр»</h4>

  <details>
    <summary>Условие</summary>
    <p>Вычислите сумму цифр неотрицательного целого числа.</p>
    <h4>Формат ввода</h4>
    <p>На вход подаётся одно неотрицательное целое число, не превосходящее 10⁹</p>
    <h4>Формат вывода</h4>
    <p>Выведите сумму цифр этого числа.</p>
    <h4>Пример</h4>
    <code>59</code>
    <code>14</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>По условию задачи число помещается в тип int. Поэтому можно написать цикл, который будет прибавлять к ответу последнюю цифру этого числа (остаток при делении на 10) и делить число на 10 без учёта остатка.</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int x;
  std::cin >> x;

  int s = 0;
  while (x != 0) {
    s += x % 10;
    x /= 10;
  }

  std::cout &lt;&lt; s &lt;&lt; "\n";
}
</pre>

    <p>Есть более общее решение, которое подойдёт для чисел любого размера, не обязательно влезающих в int. Можно считать цифры числа в строку и обработать их посимвольно. Правда, для очень больших строк уже сама сумма цифр может не поместиться в int.</p>
    <p>Чтобы превратить очередной символ в цифру, воспользуемся тем, что символы цифр в таблице ASCII идут подряд. Поэтому разность кодов символов c - '0' будет как раз давать числовое представление очередной цифры.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string digits;
  std::cin >> digits;

  int s = 0;
  for (char digit : digits) {
    s += digit - '0';
  }

  std::cout &lt;&lt; s &lt;&lt; "\n";
}
</pre>
  </details>

  <h4>Задача «ln 2»</h4>

  <details>
    <summary>Условие</summary>
    <p>Значение натурального логарифма ln2 представляется в виде суммы 1 - 1/2 + 1/3 - 1/4 + ... + n(-1)n+1 с точностью до O(n). Напишите программу, выводящую сумму первых n членов этого ряда. Попробуйте также обойтись без использования инструкции if. Указание: используйте тип double для работы с числами с плавающей точкой. Используйте стандартную точность вывода.</p>
    <h4>Формат ввода</h4>
    <p>Вводится целое положительное число n, помещающееся в тип int.</p>
    <h4>Формат вывода</h4>
    <p>Программа выводит ответ на задачу.</p>

    <h4>Пример 1</h4>
    <code>3</code>
    <code>0.833333</code>

    <h4>Пример 2</h4>
    <code>2</code>
    <code>0.5</code>

    <h4>Пример 3</h4>
    <code>1</code>
    <code>1</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Объявим две переменные sign и result. В result будем складывать итоговое значение, а в sign будем хранить 1 или -1. Знак переменной sign будет каждый раз меняться.</p>
    <p>Важно привести один из аргументов дроби sign / i к типу double, чтобы не получилось целочисленного деления.Проще всего это сделать, выбрав для переменной sign тип double.</p>
<pre>
#include <iostream>

int main() {
  int n;
  std::cin >> n;

  double sign = 1;
  double result = 0.0;

  for (int i = 1; i &lt;= n; ++i) {
    result += sign / i;
    sign = -sign;
  }
  std::cout &lt;&lt; result &lt;&lt; "\n";
}
</pre>
  </details>

  <h3>Параграф «Векторы и строки»</h3>

  <h4>Задача «Пароли»</h4>

  <details>
    <summary>Условие</summary>

    <p>Пароль от некоторого сервиса должен удовлетворять таким ограничениям:</p>
    <ul>
      <li>состоять из символов таблицы ASCII с кодами от 33 до 126;</li>
      <li>быть не короче 8 символов и не длиннее 14;</li>
      <li>из 4 классов символов — большие буквы, маленькие буквы, цифры, прочие символы — в пароле должны присутствовать не менее трёх любых.</li>
    </ul>

    <p>Напишите программу, которая проверит, что введённый пароль подходит под эти ограничения.</p>

    <h4>Формат ввода</h4>
    <p>На входе дана одна строка с паролем.</p>

    <h4>Формат вывода</h4>
    <p>Выведите YES, если пароль удовлетворяет требованиям, и NO в противном случае.</p>

    <h4>Пример</h4>
    <code>Vasya123</code>
    <code>YES</code>

    <p>Вы можете воспользоваться функциями из заголовочного файла cctype или реализовать самостоятельно их аналоги.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Решение можно целиком записать внутри функции main, но нам будет удобнее оформить проверку пароля в виде отдельной функции IsGood, которая возвращает логическое значение. Из такой функции всегда можно удобно выйти с помощью return, если ответ уже известен.</p>
<pre>
#include &lt;iostream>
#include &lt;string>

bool IsGood(const std::string& password) {
  if (password.size() &lt; 8 || password.size() > 14) {
    return false;
  }
  int upper = 0;
  int lower = 0;
  int digit = 0;
  int other = 0;

  for (char c : password) {
    if (c &lt; 33 || c > 126) {
      return false;
    }
    if ('A' &lt;= c && c &lt;= 'Z') {
      upper = 1;
    } else if ('a' &lt;= c && c &lt;= 'z') {
      lower = 1;
    } else if ('0' &lt;= c && c &lt;= '9') {
      digit = 1;
    } else {
      other = 1;
    }
  }

  return upper + lower + digit + other >= 3;
}

int main() {
  std::string password;
  std::getline(std::cin, password);
  if (IsGood(password)) {
    std::cout &lt;&lt; "YES\n";
  } else {
    std::cout &lt;&lt; "NO\n";
  }
}
</pre>
    <p>Здесь мы используем явные сравнения с другими символами вида '0' &lt;= c && c &lt;= '9'. Можно было бы использовать функции std::isupper, std::islower и std::isdigit из заголовочного файла cctype.</p>
  </details>

  <h4>Задача «Soundex»</h4>

  <details>
    <summary>Условие</summary>
    <p>Известный алгоритм Soundex определяет, похожи ли два английских слова по звучанию. На вход он принимает слово и заменяет его на некоторый четырёхсимвольный код. Если коды двух слов совпадают, то слова, как правило, звучат похоже.</p>

    <p>Вам требуется реализовать этот алгоритм. Он работает так:</p>
    <ol>
      <li>Первая буква слова сохраняется.</li>
      <li>В остальной части слова буквы a, e, h, i, o, u, w и y удаляются;</li>
      <li>Оставшиеся буквы заменяются на цифры от 1 до 6, причём похожим по звучанию буквам соответствуют одинаковые цифры:
        <ul>
          <li>b, f, p, v: 1</li>
          <li>c, g, j, k, q, s, x, z: 2</li>
          <li>d, t: 3</li>
          <li>l: 4</li>
          <li>m, n: 5</li>
          <li>r: 6</li>
        </ul>
      </li>
      <li>Любая последовательность идущих подряд одинаковых цифр сокращается до одной такой цифры.</li>
      <li>Итоговая строка обрезается до первых четырёх символов.</li>
      <li>Если длина строки получилась меньше четырёх символов, в конце добавляются нули.</li>
    </ol>

    <p>Примеры:</p>
    <code>аmmonium → ammnm → a5555 → a5 → a500.</code>
    <code>implementation → implmnttn → i51455335 → i514535 → i514.</code>

    <h4>Формат ввода</h4>
    <p>На вход подаётся одно непустое слово из строчных латинских букв. Длина слова не превосходит 20 символов.</p>

    <h4>Формат вывода</h4>
    <p>Напечатайте четырёхбуквенный код, соответствующий слову.</p>

    <h4>Пример 1</h4>
    <code>ammonium</code>
    <code>a500</code>

    <h4>Пример 2</h4>
    <code>implementation</code>
    <code>i514</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Хотя задачу можно решить и без функций, нам будет удобно оформить её решение в виде отдельной функции Soundex. Шаги 3 и 4 можно оформить в виде оператора switch.</p>

    <p>Напишем также вспомогательную функцию Append, добавляющую символ к ответу в случае, если он не дублируется. В эту функцию удобно передать параметр res по ссылке, чтобы его можно было изменять.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

void Append(std::string& res, char c) {
  if (res.back() != c) {
    res.push_back(c);
  }
}

std::string Soundex(const std::string& word) {
  std::string res;
  res.push_back(word[0]);
  for (size_t i = 1; i != word.size(); ++i) {
    char c = word[i];
    switch (c) {
      case 'b':
      case 'f':
      case 'p':
      case 'v':
        Append(res, '1');
        break;
      case 'c':
      case 'g':
      case 'j':
      case 'k':
      case 'q':
      case 's':
      case 'x':
      case 'z':
        Append(res, '2');
        break;
      case 'd':
      case 't':
        Append(res, '3');
        break;
      case 'l':
        Append(res, '4');
        break;
      case 'm':
      case 'n':
        Append(res, '5');
        break;
      case 'r':
        Append(res, '6');
        break;
    }
  }
  while (res.size() &lt; 4) {
    res.push_back('0');
  }
  res.resize(4);
  return res;
}

int main() {
  std::string word;
  std::cin >> word;
  std::cout &lt;&lt; Soundex(word) &lt;&lt; "\n";
}
</pre>
  </details>

  <h4>Задача «Обратная перестановка»</h4>

  <details>
    <summary>Условие</summary>

    <p>На мероприятие приглашены n гостей. Им предлагают занять места с номерами от 1 до n в зале. Гости занимают эти места в произвольном порядке. Известно, на каком месте сел очередной гость.</p>

    <p>Выпишите для каждого очередного места номер гостя, который на него сел.</p>

    <h4>Формат ввода</h4>
    <p>Дано число n, а затем n различных чисел a1, a2, ... , an от 1 до n. Число ak — это номер места, на которое сел k-й гость.</p>

    <p>Число n не превосходит 20000.</p>

    <h4>Формат вывода</h4>
    <p>Выведите n чисел b1, b2, ... , bn от 1 до n. Число bk должно обозначать номер гостя, который сел на k-е место.</p>

    <h4>Пример 1</h4>
<pre>
4
3 1 2 4
</pre>
  <code>2 3 1 4</code>

    <h4>Пример 2</h4>
<pre>
11
11 6 8 2 10 9 4 7 3 1 5
</pre>
  <code>10 4 9 7 11 2 8 3 6 5 1</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Будем заполнять вектор seats, в котором для каждого номера места будет указан номер гостя. Не забудьте: элементы вектора индексируются с нуля, а номера мест и гостей в задаче начинаются с единицы.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  int n;
  std::cin >> n;

  std::vector&lt;int&gt; seats(n);
  for (int guest = 1; guest &lt;= n; ++guest) {
    int seat;
    std::cin >> seat;
    seats[seat - 1] = guest;
  }

  for (int guest : seats) {
    std::cout &lt;&lt; guest &lt;&lt; " ";
  }
  std::cout &lt;&lt; "\n";
}
</pre>
  </details>

  <h4>Задача «Сортировка по убыванию»</h4>

  <details>
    <summary>Условие</summary>
    <p>Вам даны строки текстового файла. Отсортируйте набор этих строк по убыванию.</p>

    <h4>Формат ввода</h4>
    <p>Количество строк не превосходит 1000. Каждая строка состоит из символов ASCII с кодами от 32 до 126, длина строки не превосходит 100.</p>

    <h4>Формат вывода</h4>
    <p>Напечатайте строки в отсортированном по убыванию порядке. Для сравнения строк друг с другом достаточно использовать стандартные операторы сравнения, определённые для std::string.</p>

    <h4>Пример</h4>
<pre>
one
two
three
</pre>
<pre>
two
three
one
</pre>
    <p>Примечания</p>
    <p>Компилятор не поддерживает std::ranges.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Строки необходимо прочитать и сложить в вектор, а затем отсортировать и вывести. По умолчанию они будут сортироваться по возрастанию. Есть несколько способов сделать сортировку и вывод в нужном порядке:</p>
    <ol>
      <li>строки можно напечатать в обратном порядке;</li>
      <li>можно передать в std::sort обратные итераторы;</li>
      <li>можно передать в std::sort свою функцию сравнения;</li>
      <li>можно передать в std::sort уже готовый компаратор std::greater&lt;std::string&gt;().</li>
    </ol>
    <p>Воспользуемся, например, вторым способом:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;std::string&gt; lines;

  std::string line;
  while (std::getline(std::cin, line)) {
    lines.push_back(line);
  }

  std::sort(lines.rbegin(), lines.rend());

  for (size_t i = 0; i != lines.size(); ++i) {
    std::cout &lt;&lt; lines[i] &lt;&lt; "\n";
  }
}
</pre>
    <p>Типичная ошибка в решении этой задачи — считывать строки через std::cin >> line вместо std::getline. Такой код прочитает строку не целиком, а до ближайшего пробельного разделителя.</p>
  </details>

  <h4>Задача «Палиндромы»</h4>

  <details>
    <summary>Условие</summary>
    <p>Дана строка из строчных латинских букв и пробелов. Проверьте, является ли она палиндромом без учета пробелов.</p>

    <h4>Формат ввода</h4>
    <p>На вход подается одна строка. В строке могут быть пробелы. Подряд может идти произвольное число пробелов. Длина строки не превосходит 100.</p>

    <h4>Формат вывода</h4>
    <p>Представьте, что из строки удалили все пробелы. Необходимо вывести YES, если полученная строка — палиндром, и NO в противном случае.</p>

    <h4>Пример 1</h4>
    <code>hello world</code>
    <code>NO</code>

    <h4>Пример 2</h4>
    <code>never odd or even</code>
    <code>YES</code>

    <p>Примечание</p>
    <p>Пустая строка считается палиндромом.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Будем поддерживать два индекса i и j, которые будут идти с разных сторон строки навстречу друг другу. Будем повторять цикл до тех пор, пока первый индекс меньше второго. В цикле будем игнорировать пробелы. Если будет найдено несоответствие символов, цикл можно досрочно закончить.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

int main() {
  std::string s;
  std::getline(std::cin, s);

  int i = 0;
  int j = static_cast&lt;int&gt;(s.size()) - 1;
  bool isPalindrome = true;

  while (i &lt; j) {
    if (s[i] == ' ') {
      ++i;
    } else if (s[j] == ' ') {
      --j;
    } else if (s[i] != s[j]) {
      isPalindrome = false;
      break;
    } else {
      ++i;
      --j;
    }
  }

  if (isPalindrome) {
    std::cout &lt;&lt; "YES\n";
  } else {
    std::cout &lt;&lt; "NO\n";
  }
}
</pre>
    <p>Вот изящное решение этой задачи для тех, кто прочитал параграф про алгоритмы стандартной библиотеки:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string s;
  std::getline(std::cin, s);

  std::erase(s, ' ');  // С++20

  // В С++17 пришлось бы написать
  // s.erase(std::remove(s.begin(), s.end(), ' '), s.end());

  if (std::equal(s.begin(), s.begin() + s.size() / 2, s.rbegin())) {
    std::cout &lt;&lt; "YES\n";
  } else {
    std::cout &lt;&lt; "NO\n";
  }
}
</pre>
  </details>

  <h4>Задача «Сапёр»</h4>

  <details>
    <summary>Условие</summary>
    <p>Вам необходимо построить поле для игры «Сапёр» по его конфигурации — высоте, ширине и координатам расставленных на нем мин.</p>
    <p>Вкратце напомним правила построения поля для игры «Сапёр»:</p>
    <ul>
      <li>поле состоит из клеток с минами и пустых клеток;</li>
      <li>клетки с миной обозначаются символом *;</li>
      <li>пустые клетки содержат число от 0 до 8 — количество мин на соседних клетках.</li>
    </ul>

    <h4>Формат ввода</h4>
    <p>В первой строке содержатся три числа:</p>
    <ul>
      <li>число m от 1 до 100 — количество строк на поле;</li>
      <li>число n от 1 до 100 — количество столбцов на поле;</li>
      <li>число k от 0 до mn — количество мин на поле.</li>
    </ul>
    <p>В следующих k строках содержатся пары чисел с координатами мин (номерами строки и столбца). Нумерация ведётся с единицы.</p>

    <h4>Формат вывода</h4>
    <p>Выведите построенное поле, разделяя строки поля символом \n, а столбцы — пробелом.</p>

    <h4>Пример</h4>
<pre>
3 2 2
1 1
2 2
</pre>
<pre>
* 2
2 *
1 1
</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Заведём двумерный вектор и будем записывать в него мины и количество мин в соседних клетках. Мины будет удобно обозначать минус единицей.</p>

    <p>Будем по очереди добавлять мины на игровое поле и для каждой мины сразу обновлять числа в соседних клетках.</p>

    <p>Чтобы не выписывать восемь однотипных проверок на соседние клетки, удобно будет создать вектор «сдвигов» и перебирать эти сдвиги в цикле.</p>

    <p>Можно также добавить к нашему игровому полю дополнительные клетки по краям, чтобы не делать проверки на корректность при обращении к соседней клетке. Поэтому размер поля в нашей программе на 2 больше указанного.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

struct Shift {
  int x = 0;
  int y = 0;
};

const std::vector&lt;Shift&gt; SHIFTS = {
  {-1, -1},
  {-1,  0},
  {-1,  1},
  { 0,  1},
  { 1,  1},
  { 1,  0},
  { 1, -1},
  { 0, -1},
};

int main() {
  size_t rows;
  size_t columns;
  size_t mines;
  std::cin >> rows >> columns >> mines;

  const int mineLabel = -1;

  std::vector&lt;std::vector&lt;int&gt; &gt; field(rows + 2, std::vector&lt;int&gt;(columns + 2));

  for (size_t index = 0; index != mines; ++index) {
    int row, column;
    std::cin >> row >> column;

    field[row][column] = mineLabel;

    for (auto shift : SHIFTS) {
      auto& cell = field[row + shift.x][column + shift.y];
      if (cell != mineLabel) {
        ++cell;
      }
    }
  }

  for (size_t row = 1; row &lt;= rows; ++row) {
    for (size_t column = 1; column &lt;= columns; ++column) {
      if (column > 1) {
        std::cout &lt;&lt; " ";
      }
      if (field[row][column] == mineLabel) {
        std::cout &lt;&lt; "*";
      } else {
        std::cout &lt;&lt; field[row][column];
      }
    }
    std::cout &lt;&lt; "\n";
  }
}
</pre>
    <p>Обратите внимание на инициализацию ссылки cell. Мы специально объявили cell как ссылку, чтобы по этому краткому имени можно было изменить значение.</p>
  </details>

  <h3>Параграф «Функции»</h3>

  <h4>Задача «ArgMax в матрице»</h4>

  <details>
    <summary>Условие</summary>
    <p>Вам требуется написать на C++ функцию со следующим заголовком:</p>
    <code>std::pair&lt;size_t, size_t&gt; MatrixArgMax(const std::vector&lt;std::vector&lt;int&gt; &gt;& matrix);</code>
    <p>Функция должна вернуть пару из индексов максимального элемента в матрице. Если максимальных элементов несколько, то нужно вернуть наименьшую такую пару.</p>

    <p>Примечания</p>
    <p>Считайте, что матрица задана корректно: все строки одинаковой длины, пустых строк нет. В матрице всегда есть хотя бы один элемент.</p>
    <p>Подключите необходимые заголовочные файлы и напишите только код функции MatrixArgMax. Мы скомпилируем решение с нашей функцией main.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Сохраним в переменной argMax позицию начального элемента матрицы, а в переменной max — значение этого элемента. Обойдём все элементы матрицы с помощью вложенного цикла. Если обнаружим новый максиммум, то обновим эти переменные.</p>
<pre>
#include &lt;utility&gt;
#include &lt;vector&gt;

std::pair&lt;size_t, size_t&gt; MatrixArgMax(const std::vector&lt;std::vector&lt;int&gt; &gt;& matrix) {
  std::pair&lt;size_t, size_t&gt; argMax = {0, 0};
  int max = matrix[0][0];
  for (size_t i = 0; i != matrix.size(); ++i) {
    for (size_t j = 0; j != matrix[i].size(); ++j) {
      if (matrix[i][j] > max) {
        max = matrix[i][j];
        argMax = {i, j};
      }
    }
  }
  return argMax;
}
</pre>
  </details>

  <h4>Задача «Общий префикс»</h4>

  <details>
    <summary>Условие</summary>
    <p>Напишите функцию для вычисления наибольшего общего префикса строк, переданных в векторе words:</p>
    <code>std::string CommonPrefix(const std::vector&lt;std::string&gt;& words);</code>
    <p>Например, для пустого вектора функция должна вернуть пустую строку, а для вектора из строк "apple", "apricot" и "application" — строку "ap".</p>

    <p>Примечание</p>
    <p>В решении не должно быть функции main: она будет в нашей тестирующей программе. Подключите необходимые библиотеки и напишите код функции CommonPrefix.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Давайте напишем вспомогательную функцию для вычисления общего префикса двух строк. Для этого будем идти по символам строк и проверять, равны ли они. Важно не выйти за пределы строки.</p>
<pre>
#include &lt;string&gt;
#include &lt;vector&gt;

std::string CommonPrefix(const std::string& a, const std::string& b) {
  size_t i = 0;
  while (i != a.size() && i != b.size() && a[i] == b[i]) {
    ++i;
  }
  return a.substr(0, i);
}
</pre>
    <p>Теперь можно просто перебрать поданные на вход строки и вычислять на каждом шаге общий префикс у текущей строки и старого префикса:</p>
<pre>
std::string CommonPrefix(const std::vector&lt;std::string&gt;& words) {
  if (words.empty()) {
    return {};
  }
  std::string prefix = words[0];
  for (size_t i = 1; i != words.size() && !prefix.empty(); ++i) {
    prefix = CommonPrefix(prefix, words[i]);
  }
  return prefix;
}
</pre>
    <p>Здесь мы вызываем в цикле первую функцию CommonPrefix. Компилятор понимает какую из функций надо вызвать по типам аргументов (здесь передаётся не вектор строк, а две строки).</p>

    <p>Недостаток этого решения в том, что мы много раз создаём новые строки (префиксы), хотя на самом деле все они являются подстроками первой строки. Поэтому давайте перепишем первую функцию, чтобы она использовала std::string_view — конструкцию, о которой мы поговорим в параграфе «Адаптеры и представления». Во второй функции объявим prefix с явным типом std::string_view, а в конце вернём std::string(prefix): преобразование из string_view обратно в string надо описывать явно.</p>
<pre>
#include &lt;string&gt;
#include &lt;string_view&gt;
#include &lt;vector&gt;

std::string_view CommonPrefix(const std::string_view a, const std::string_view b) {
  size_t i = 0;
  while (i != a.size() && i != b.size() && a[i] == b[i]) {
    ++i;
  }
  return a.substr(0, i);
}

std::string CommonPrefix(const std::vector&lt;std::string&gt;& words) {
  if (words.empty()) {
    return {};
  }
  std::string_view prefix = words[0];
  for (size_t i = 1; i != words.size() && !prefix.empty(); ++i) {
    prefix = CommonPrefix(prefix, words[i]);
  }
  return std::string(prefix);
}
</pre>
    <p>Рассмотрим альтернативное решение с синхронным проходом. Будем одновременно идти по всем словам. Для этого удобно сначала вычислить их минимальную длину, чтобы было проще проверять, когда пора остановиться.</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

std::string CommonPrefix(const std::vector&lt;std::string&gt;& words) {
  if (words.empty()) {
    return {};
  }

  size_t minLen = words[0].size();
  for (const auto& word : words) {
    minLen = std::min(minLen, word.size());
  }

  for (size_t i = 0; i &lt; minLen; ++i) {
    const char c = words[0][i];
    for (const auto& word : words) {
      if (word[i] != c) {
        return word.substr(0, i);
      }
    }
  }

  return words[0].substr(0, minLen);
}
</pre>
  </details>

  <h4>Задача «Функция Split»</h4>

  <details>
    <summary>Условие</summary>
    <p>Вам требуется написать функцию со следующим заголовком:</p>
    <code>std::vector<std::string> Split(const std::string& str, char delimiter);</code>
    <p>Функция должна вернуть вектор строк, полученный разбиением строки str на части по указанному символу-разделителю delimiter. Если разделитель встретился в начале или в конце строки str, то в начале (соответственно, в конце) вектора с результатом должна быть пустая строка. Если два разделителя встретились рядом, то пустая строка между ними тоже должна попасть в ответ. Для пустой строки надо вернуть вектор, содержащий одну пустую строку.</p>
    <p>Например, Split("What_is_your_name?", '_') должна вернуть вектор из строк What, is, your иname?.</p>

    <p>Примечание</p>
    <p>Подключите необходимые заголовочные файлы и напишите только код функции Split. Мы скомпилируем решение с нашей функцией main.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Заметим, что количество элементов в ответе должно оказаться на единицу больше количества символов-разделителей в строке.</p>
    <p>Будем поддерживать два индекса: начало и конец очередного фрагмента строки. Будем сдвигать конец вправо. Если нам встретится разделитель, добавим этот фрагмент к ответу и переназначим начало будущего фрагмента на следующий индекс.</p>
    <p>В конце надо будет отдельно добавить к ответу последний фрагмент.</p>
<pre>
#include &lt;string&gt;
#include &lt;vector&gt;

std::vector&lt;std::string&gt; Split(const std::string& str, char delimiter) {
  std::vector&lt;std::string&gt; result;
  size_t i = 0;
  for (size_t j = 0; j != str.size(); ++j) {
    if (str[j] == delimiter) {
      result.push_back(str.substr(i, j - i));
      i = j + 1;
    }
  }
  result.push_back(str.substr(i));
  return result;
}
</pre>
    <p>Заметим, что если исходная строка будет существовать после вызова функции, то может оказаться эффективнее разбивать строку на std::string_view (мы поговорим об этой конструкции в параграфе «Адаптеры и представления»).</p>
<pre>
#include &lt;string&gt;
#include &lt;string_view&gt;
#include &lt;vector&gt;

std::vector&lt;std::string_view&gt; Split(const std::string& s, char delimiter) {
  std::string_view str = s;
  std::vector&lt;std::string_view&gt; result;
  size_t i = 0;
  for (size_t j = 0; j != str.size(); ++j) {
    if (str[j] == delimiter) {
      result.push_back(str.substr(i, j - i));
      i = j + 1;
    }
  }
  result.push_back(str.substr(i));
  return result;
}
</pre>
  </details>

  <h4>Задача «Функция Join»</h4>

  <details>
    <summary>Условие</summary>
    <p>Вам требуется написать функцию Join со следующим заголовком:</p>
    <code>std::string Join(const std::vector&lt;std::string&gt;& tokens, char delimiter);</code>
    <p>Функция должна вернуть строку, полученную склейкой элементов вектора через указанный разделитель. Например, Join({"What", "is", "your", "name?"}, '_') должна вернуть строку "What_is_your_name?".</p>

    <p>Примечание</p>
    <p>Если вектор tokens пустой, то функция должна вернуть пустую строку. Если в векторе tokens ровно один элемент, то он и должен вернуться в ответе.</p>
    <p>Подключите необходимые заголовочные файлы и напишите только код функции Join. Мы скомпилируем решение с нашей функцией main.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Будем идти по вектору и добавлять в ответ разделитель и очередной токен. Важно, чтобы разделители не оказались по краям — они должны быть только между токенами.</p>
<pre>
#include &lt;string&gt;
#include &lt;vector&gt;

std::string Join(std::vector&lt;std::string&gt;& tokens, char delim) {
  std::string result;
  for (size_t i = 0; i != tokens.size(); ++i) {
    if (i > 0) {
      result += delim;
    }
    result += tokens[i];
  }
  return result;
}
</pre>
  </details>

  <h4>Задача «Транспонировать матрицу»</h4>

  <details>
    <summary>Условие</summary>
    <p>Дана прямоугольная матрица A из m строк и n столбцов. Транспонированной матрицей AT называется матрица из n строк и m столбцов, в которой строки и столбцы поменялись ролями: элемент  Aij равен элементу Aji.</p>
    <p>Напишите функцию, которая возвращает транспонированную матрицу:</p>
    <code>std::vector&lt;std::vector&lt;int&gt; &gt; Transpose(const std::vector&lt;std::vector&lt;int&gt; &gt;& matrix);</code>

    <p>Примечание</p>
    <p>Гарантируется, что вектор matrix непуст и все его элементы имеют равную ненулевую длину.</p>
    <p>Подключите необходимые заголовочные файлы и напишите только код функции Transpose. Мы скомпилируем решение с нашей функцией main.</p>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;vector&gt;

std::vector&lt;std::vector&lt;int&gt; &gt; Transpose(const std::vector&lt;std::vector&lt;int&gt; &gt;& matrix) {
  const size_t m = matrix.size();
  const size_t n = matrix[0].size();

  std::vector&lt;std::vector&lt;int&gt; &gt; result(n);
  for (size_t j = 0; j != n; ++j) {
    result[j].resize(m);
    for (size_t i = 0; i != m; ++i) {
      result[j][i] = matrix[i][j];
    }
  }
  return result;
}
</pre>
  </details>

  <h4>Задача «Сортировка точек»</h4>

  <details>
    <summary>Условие</summary>
    <p>Вам даны координаты точек на плоскости. Выведите эти точки в порядке возрастания расстояний до начала координат.</p>

    <h4>Формат ввода</h4>
    <p>Сначала задано количество точек n. Затем идет последовательность из n строк, каждая из которых содержит два целых числа — координаты точки. Величина n не превосходит 100. Координаты точек по модулю не превосходят 1000.</p>

    <h4>Формат вывода</h4>
    <p>Выведите через пробел кординаты точек в порядке возрастания расстояний до начала координат. После каждой пары координат печатайте перевод строки.</p>

    <h4>Пример</h4>
<pre>
2
2 3
1 2
</pre>
<pre>
1 2
2 3
</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Создадим структуру Point для хранения точки. Заполним вектор этих структур. Напишем лямбда-функцию для сравнения двух точек. Заметим, что вычислять квадратный корень не обязательно: достаточно сравнить целочисленную сумму квадратов.</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

struct Point {
  int x;
  int y;
};

int main() {
  size_t n;
  std::cin >> n;

  std::vector&lt;Point&gt; points(n);

  for (size_t i = 0; i != n; ++i) {
    std::cin >> points[i].x >> points[i].y;
  }

  std::sort(
    points.begin(),
    points.end(),
    [](const Point& p1, const Point& p2) {
      return p1.x * p1.x + p1.y * p1.y &lt; p2.x * p2.x + p2.y * p2.y;
    }
  );

  for (const auto& point : points) {
    std::cout &lt;&lt; point.x &lt;&lt; " "
              &lt;&lt; point.y &lt;&lt; "\n";
  }
}
</pre>
    <p>Недостаток этого решения в том, что для каждого сравнения пары точек приходится вычислять сумму квадратов заново. Можно было бы предрассчитать расстояния от каждой точки до начала координат отдельно и отсортировать уже по готовым значениям.</p>
  </details>
</article>


<!-- 3.1 Последовательные контейнеры -->
<article class="article">
  <div class="anchor" id="p3.1"></div>
  <h2>3 Стандартная библиотека C++</h2>
  <h3>3.1 Последовательные контейнеры</h3>

  <p>Стандартная библиотека C++ содержит набор шаблонных контейнеров. С некоторыми из них мы уже знакомы: это std::vector и std::string. Эти два контейнера гарантируют, что элементы (в случае string — символы строки) будут храниться в непрерывном фрагменте памяти. Эти контейнеры умеют эффективно добавлять элементы в конец, делая реаллокацию при необходимости, но не могут обеспечить эффективную вставку или удаление элементов в других позициях.</p>
  <p>В этом параграфе мы рассмотрим другие последовательные контейнеры. Они не обязательно хранят элементы в непрерывном куске памяти, но позволяют обойти элементы в последовательном порядке.</p>
  <p>Как правило, контейнеры определены в одноимённом заголовочном файле стандартной библиотеки.</p>

  <h4>Контейнер std::array</h4>

  <p>Если вам нужен массив фиксированного, известного в момент компиляции размера, то используйте std::array. Вот так можно объявить array из трёх элементов:</p>
<pre>
#include &lt;array&gt;

int main() {
  std::array&lt;int, 3&gt; point = {1, 2, -3};
}
</pre>
  <p>Внутри array&lt;T, N&gt; является обёрткой над низкоуровневым массивом T[N], но предоставляет интерфейс стандартного контейнера: знает свой размер, умеет присваиваться, предоставляет итераторы и т. д. Как и у вектора, элементы array располагаются в памяти непрерывно, но хранятся не в динамической памяти, а на стеке (мы разберём подробности в параграфе «Жизненный цикл объекта»).</p>
  <p>Важно подчеркнуть, что размер array должен быть задан в момент компиляции и не может изменяться во время работы программы.</p>

  <h4>Контейнер std::deque</h4>

  <p>Deque расшифровывается как double-ended queue (двусторонняя очередь).</p>
  <p>Если вектор располагает элементы в памяти непрерывно, то std::deque располагает их кусочно-непрерывно, в отдельных страницах (непрерывных блоках) памяти фиксированного размера. Но даже для хранения одного элемента в деке будет выделена целая страница. Сами страницы не обязательно расположены в памяти подряд. Отдельно поддерживается перечень указателей на начала страниц. Размеры страниц зависят от sizeof(T) и от конкретной реализации дека. Например, для std::deque&lt;int&gt; они могут занимать 4 килобайта.</p>
  <p>Дек умеет эффективно добавлять и удалять элементы в начале и в конце: это приводит к выделению новой страницы при необходимости. Вставка по краям в деке эффективнее, чем в векторе, так как реаллокаций нет и старые элементы никогда не приходится копировать. В отличие от вектора, дек гарантирует, что при вставке или удалении по краям элементы останутся в тех же самых ячейках памяти, что и были. Вставка в середину дека и удаление из неё уже требуют сдвига элементов.</p>
  <p>Как и вектор, дек поддерживает обращение к элементу по индексу за O(1): так как размер страниц фиксирован и начальная позиция в первой странице известна, то можно легко вычислить нужную страницу и позицию в ней. Однако для обращения к элементу деку приходится делать два разыменования указателей, а вектору — только одно.</p>
<pre>
#include &lt;deque&gt;
#include &lt;iostream&gt;

int main() {
  std::deque&lt;int&gt; d = {1, 2, 3, 4};

  d.push_back(5);  // добавление в конец, как у вектора
  d.push_back(6);
  d.pop_back();  // удаление из конца, как у вектора

  d.push_front(0);  // добавление в начало
  d.push_front(-1);
  d.pop_front();  // удаление из начала

  // элементы дека: 0, 1, 2, 3, 4, 5

  // обращение по индексам:
  for (size_t i = 0; i != d.size(); ++i) {
    std::cout &lt;&lt; d[i] &lt;&lt; "\n";
  }

  // range-based for:
  for (int x : d) {
    std::cout &lt;&lt; x &lt;&lt; "\n";
  }
}
</pre>

  <h4>Контейнер std::list</h4>

  <p>Двусвязный список std::list хранит элементы в отдельных узлах. Узлы могут располагаться в разных местах памяти, никакого требования непрерывности нет. В узле рядом с самим элементом хранится указатель на предыдущий и следующий узлы. Можно представить себе отдельный узел двусвязного списка для элементов типа T примерно так:</p>
<pre>
template &lt;typename T&gt;
struct Node {
  T value;
  Node* prev;
  Node* next;
};
</pre>
  <p>Сам список хранит указатели на начальный и конечный узлы. К узлу нельзя эффективно обратиться по номеру (для этого пришлось бы идти в цикле по списку начиная от головы). Поэтому пройтись по списку можно только с помощью range-based for или итераторов:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;list&gt;

int main() {
  std::list&lt;int&gt; l = {10, 15, 20};
  l.push_front(5);
  l.push_front(0);

  l.push_back(25);
  l.push_back(30);

  l.pop_front();
  l.pop_back();

  for (int x : l) {
    std::cout &lt;&lt; x &lt;&lt; "\n";  // 5 10 15 20 25
  }
}
</pre>

  <h4>Итераторы списка</h4>

  <p>Итераторы — это специальные объекты, предназначенные для навигации по контейнеру. Итераторы позволяют обращаться к текущему элементу контейнера и сдвигаться к соседним элементам. Итератор, указывающий на начальный элемент контейнера, возвращает функция begin.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;list&gt;

int main() {
  std::list&lt;int&gt; l = {10, 15, 20};

  // Используем auto, чтобы не писать громоздкий тип std::list&lt;int>::iterator
  auto iter = l.begin();
  // печатаем начальный элемент
  std::cout &lt;&lt; *iter &lt;&lt; "\n";
  ++iter;  // сдвигаемся к следующему элементу
  --iter;  // возвращаемся назад
}
</pre>
  <p>Итераторы в C++ создавались по подобию указателей: их можно разыменовывать (*) и сдвигать (++ и --). Однако операторы ++ и -- для обычных указателей сдвигаются на соседние ячейки памяти, а двусвязный список хранит свои элементы разрозненно. Поэтому указатели могут подойти на роль итераторов лишь для контейнеров с непрерывным хранением (array, vector и string).</p>
  <p>Функция end у контейнера возвращает особый итератор, который указывает за последний элемент контейнера. Этот итератор нельзя разыменовывать. С ним можно только сравниваться:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;list&gt;

int main() {
  std::list&lt;int&gt; l = {10, 15, 20};
  for (auto iter = l.begin(); iter != l.end(); ++iter) {
    // печатаем элементы списка через итератор
    std::cout &lt;&lt; *iter &lt;&lt; "\n";
  }

  for (auto iter = l.rbegin(); iter != l.rend(); ++iter) {
    // проход по списку в обратном порядке
    std::cout &lt;&lt; *iter &lt;&lt; "\n";
  }
}
</pre>
  <p>С помощью итераторов можно вставлять (insert) или удалять (erase) элементы или целые цепочки элементов в любом месте списка:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;list&gt;

int main() {
  std::list&lt;int&gt; l = {0, 10, 15, 20};

  auto iter = l.begin();
  ++iter;
  l.insert(iter, 5);  // вставляем на эту позицию элемент

  // Удаляем из списка чётные числа
  for (auto iter = l.begin(); iter != l.end(); ) {
    if (*iter % 2 == 0) {
      // возвращается итератор на элемент, следующий за удалённым
      iter = l.erase(iter);
    } else {
      ++iter;
    }
  }

}
</pre>
  <p>С итераторами стандартных контейнеров мы познакомимся подробнее в других параграфах. Заметим пока, что к итераторам списка (в отличие от итераторов вектора) нельзя прибавлять произвольные целые числа, чтобы сдвинуть их на несколько позиций вперёд: эта операция не может быть реализована эффективно за константное время. Стандартная функция std::advance из заголовочного файла iterator умеет делать это за константное время для итераторов контейнеров с индексацией и за линейное время для итераторов списка. А функции std::next и std::prev возвращают следующее и предыдущее значения итератора соответственно.</p>
<pre>
#include &lt;iterator&gt;
#include &lt;list&gt;

int main() {
  std::list&lt;int&gt; l = {0, 10, 15, 20};

  // вместо этого удобнее воспользоваться функцией std::next:
  // auto iter = l.begin();
  // ++iter;

  // итератор указывает на второй элемент списка
  auto iter = std::next(l.begin());

  // итератор указывает на последний элемент
  std::advance(iter, 2);
}
</pre>

  <h4>Контейнер std::forward_list</h4>

  <p>Односвязный список std::forward_list нужен там, где требуется сэкономить память на хранении ссылок на предыдущий узел. По такому контейнеру можно пройтись только вперёд, а вставка разрешена только в начало (или после указанного итератора). Этот контейнер встречается в некоторых реализациях хеш-таблицы unordered_map для хранения элементов с одинаковыми хешами.</p>
<pre>
#include &lt;forward_list&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;

int main() {
  std::forward_list&lt;int&gt; fl = {3, 42, 5};
  fl.push_front(2);
  // fl.push_back(10);  // ошибка компиляции!

  auto iter = std::next(fl.begin());
  iter = fl.erase_after(iter);
  fl.insert_after(iter, 4);

  for (int x : fl) {
    std::cout &lt;&lt; x &lt;&lt; "\n";  // 2 3 5 4
  }
}
</pre>
  <p>Функции insert_after и erase_after своими названиями подчёркивают своё отличие от insert и erase у других контейнеров, работающих с текущей позицией. В односвязном списке не получится вставить элемент на текущую позицию, как это делает insert в std::list, поскольку к предыдущему элементу невозможно обратиться, а его ссылку на следующий элемент надо поправить</p>
  <p>Упражнение: сравните интерфейсы (набор функций) контейнеров list и forward_list и объясните различия.</p>

  <h4>Инвалидация итераторов и ссылок</h4>

  <p>Если контейнер изменяется, то в некоторых случаях итераторы и ссылки (указатели) на элементы могут стать невалидными. Рассмотрим пример:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; v = {1, 2, 3, 4};

  auto iter = v.begin();  // итератор
  int* ptr = &v.front();  // указатель
  int& ref = v.front();  // ссылка

  std::cout &lt;&lt; *iter &lt;&lt; " " &lt;&lt; *ptr
  &lt;&lt; " " &lt;&lt; ref &lt;&lt; "\n";  // 1 1 1

  v.push_back(5);  // происходит реаллокация

  // обращаться к старым итераторам, указателям и ссылкам больше нельзя:
  std::cout &lt;&lt; *iter &lt;&lt; " " &lt;&lt; *ptr
  &lt;&lt; " " &lt;&lt; ref &lt;&lt; "\n";  // неопределённое поведение!
}
</pre>
  <p>В этом примере показано, что итераторы, указатели или ссылки могут оказаться невалидными, если у вектора произошла реаллокация. Рассмотрим, как ведут себя итераторы других последовательных контейнеров при добавлении элементов в конец. Указатели и ссылки тут либо вместе инвалидируются, либо вместе остаются валидными, так как они в конечном итоге смотрят на память, которую занимал элемент.</p>
  <ol>
    <li>Строка std::string ведёт себя так же, как и вектор: все итераторы и ссылки инвалидируются.</li>
    <li>В std::array ничего вставить нельзя, его размер фиксирован.</li>
    <li>В std::deque инвалидируются итераторы, но не инвалидируются ссылки и указатели! Сами элементы дека остаются в тех же местах памяти, но во внутреннем векторе страниц, про который должен знать итератор дека, вообще говоря, может произойти реаллокация.</li>
    <li>В std::list и std::forward_list ни итераторы, ни ссылки не инвалидируются. Так что если в приведённом примере заменить vector на list, то он будет корректно работать.</li>
  </ol>
  <p>Валидность итераторов и ссылок после вызова той или иной функции контейнера описывается в документации</p>
</article>


<!-- 3.2 Ассоциативные контейнеры -->
<article class="article">
  <div class="anchor" id="p3.2"></div>
  <h3>3.2 Ассоциативные контейнеры</h3>

  <p>Ассоциативные контейнеры сопоставляют ключам некоторые значения.</p>
  <p>В стандартной библиотеке есть ассоциативные контейнеры, основанные на сбалансированных деревьях поиска (map, set) и контейнеры, основанные на хеш-таблицах (unordered_map, unordered_set). В этих контейнерах ключи уникальны, то есть, не могут повторяться. Также существуют и multi-версии этих контейнеров, в которых допускаются повторы ключей.</p>
  <p>Так как C++ — статически типизированный язык, типы ключей и значений должны быть строго зафиксированы на этапе компиляции.</p>

  <h4>Контейнер std::map</h4>

  <p>Начнём с контейнера std::map. Он определен в заголовочном файле map. Аналогично вектору, std::map является шаблонным: в угловых скобках нужно указать типы ключей и значений. Рассмотрим пример:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;string&gt;

int main() {
  // инициализируем map набором пар {ключ, значение}
  std::map&lt;std::string, int&gt; years = {
    {"Moscow", 1147},
    {"Rome", -753},
    {"London", 47},
  };

  for (const auto& [city, year] : years) {
    std::cout &lt;&lt; city &lt;&lt; ": " &lt;&lt; year &lt;&lt; "\n";
  }
}
</pre>
  <p>Вывод программы:</p>
<pre>
London: 47
Moscow: 1147
Rome: -753
</pre>
  <p>При итерации с помощью ranged-based for возвращаются пары std::pair из константного ключа и значения. Для итерации по элементам мы использовали structured binding, прикрепив ссылки city и year к элементам возвращаемой пары, а также auto для автоматического вывода типа. Согласитесь, это удобнее, чем такая форма записи:</p>
<pre>
for (const std::pair&lt;const std::string, int&gt;& item : years) {
  std::cout &lt;&lt; item.first &lt;&lt; ": " &lt;&lt; item.second &lt;&lt; "\n";
}
</pre>
  <p>Контейнер map реализован как красно-чёрное дерево — сбалансированное дерево поиска с особыми свойствами. Поэтому его элементы при итерации обходятся в порядке возрастания ключей, а на самих ключах должен быть определён оператор &lt; для сравнения.</p>
  <p>Внутренне устройство красно-чёрных деревьев мы оставим за рамками этого учебника: для нас важнее научиться пользоваться таким контейнером и знать, что три основных операции — поиск, вставка и удаление элемента — выполняются за логарифмическое время O(logn) от числа элементов в контейнере. Покажем, как воспользоваться этими операциями.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;string&gt;

int main() {
  std::map&lt;std::string, int&gt; data;
  std::string key;
  int value;

  while (std::cin >> key >> value) {
    data[key] = value;  // вставка
  }

  data.erase("hello");  // удаление

  // поиск
  if (auto iter = data.find("test"); iter != data.end()) {
    std::cout &lt;&lt; "Found the key " &lt;&lt; iter->first
    &lt;&lt; " with the value " &lt;&lt; iter->second &lt;&lt; "\n";
  } else {
    std::cout &lt;&lt; "Not found\n";
  }
}
</pre>
  <p>Рассмотрим эту программу подробнее.</p>
  <p>Для вставки мы использовали обращение по ключу в квадратных скобках: data[key] = value. В отличие от вектора или дека, ключ теперь не обязательно является индексом: в нашем случае это строка. Альтернативные способы вставки — data.insert({key, value}) или data.insert_or_assign(key, value).</p>
  <p>Эти функции принимают пару из ключа и значения, поэтому нам пришлось обрамить в фигурные скобки key и value, чтобы экземпляр std::pair сконструировался на лету. Если ключ key уже существует в контейнере, то data[key] = value и функция insert_or_assign его перезапишут, а insert — нет (но вернет информацию о старом значении).</p>
  <p>Удаляя элемент по ключу, можно не заботиться о его наличии в контейнере: если ключа нет, то функция erase просто ничего не поменяет.</p>
  <p>Для поиска элемента мы вызываем функцию find, которая возвращает итератор. Мы пользуемся версией if с инициализатором, чтобы сразу сохранить этот итератор в переменную iter и потом проверить его значение. Такая переменная будет видна только внутри условного оператора: таким образом мы подчеркнём, что iter нам нужен только здесь. Итератор будет либо указывать на пару из найденного ключа и его значения, либо окажется равен значению data.end(), если ключ не найден. Обратиться к найденной паре можно через унарную звёздочку или стрелочку (iter->first означает (*iter).first). Это похоже на указатели, но важно понимать, что итератор ассоциативного контейнера — это не указатель, а самостоятельный объект.</p>
  <p>Вернёмся ещё раз к конструкции data[key]. Она возвращает ссылку на значение, которому можно что-то присвоить. Сначала она проверяет, есть ли уже такой ключ в контейнере. Если ключа нет, он тут же вставляется в контейнер со значением по умолчанию (0 для int). Затем возвращается ссылка на значение в контейнере.</p>
  <p>Такое поведение оператора [] требует, чтобы контейнер data был изменяемым. Поэтому выражение data[key] не скомпилируется, если data — константа:</p>
<pre>
void Check(const std::map&lt;std::string, int&gt;& data) {
  if (data["total"] > 0) {  // ошибка компиляции!
    // ...
  }
}
</pre>
  <p>Если мы уверены, что ключ в контейнере есть, то можно воспользоваться функцией at:</p>
<pre>
void Check(const std::map&lt;std::string, int&gt;& data) {
  if (data.at("total") > 0) {  // OK, это скомпилируется
    // ...
  }
}
</pre>
  <p>Если же ключа всё же не окажется, то at во время работы программы сгенерирует исключение — «цивилизованную» ошибку, которую можно перехватить и обработать. Исключения мы обсудим в параграфе «Обработка исключений».</p>

  <h4>Задача о подсчёте частот слов</h4>

  <p>Рассмотрим классическую задачу: построить частотный словарь из текстового файла. Возьмём для тестирования файл text8 с сайта mattmahoney.net. Это архив со словами статей из английской «Википедии» общим объёмом 100 мегабайт. Его часто используют для оценки эффективности алгоритмов сжатия и для машинного обучения систем обработки текстов.</p>
  <p>Напишем программу, которая подсчитывает количество повторов для каждого слова. Слова будем читать со стандартного ввода просто до ближайшего пробельного разделителя.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;string&gt;

int main() {
  std::map&lt;std::string, int&gt; freqs;
  std::string word;
  while (std::cin >> word) {
    ++freqs[word];
  }
  for (const auto& [word, freq] : freqs) {
    std::cout &lt;&lt; word &lt;&lt; "\t"
     &lt;&lt; freq &lt;&lt; "\n";
  }
}
</pre>
  <p>Посмотрите, как мы элегантно добавляем очередное слово в ассоциативный массив через ++freqs[word]! Если слово уже встречалось, то мы просто увеличиваем его частоту. Если такого слова не было, то во freqs автоматически вставится такой ключ со значением 0, и мы тут же увеличим это значение на 1.</p>
  <p>Запустим программу, передав ей на вход файл text8, и посмотрим на первые 10 строк её вывода:</p>
<pre>
$ clang++ --std=c++20 -o count_freqs count_freqs.cpp
$ ./count_freqs &lt; text8 | head
a	325873
aa	276
aaa	57
aaaa	7
aaaaaacceglllnorst	1
aaaaaaccegllnorrst	1
aaaaaah	1
aaaaaalmrsstt	1
aaaaaannrstyy	1
aaaaabbcdrr	1
</pre>
  <p>Мы уже знаем, что итерация по контейнеру map обходит узлы в порядке возрастания ключей. Поэтому мы увидели первые «слова» по алфавиту. Позже мы попробуем сделать так, чтобы слова были отсортированы по убыванию частоты. А сейчас давайте попробуем замерить время работы нашей программы. Скомпилируем её с максимальным уровнем оптимизаций (ключ -O3) и направим её вывод в /dev/null (он нам не нужен). Замеряем время с помощью консольной утилиты time.</p>
<pre>
$ clang++ --std=c++20 -O3 -o count_freqs count_freqs.cpp
$ time ./count_freqs &lt; text8 > /dev/null
real    0m5,541s
user    0m5,500s
sys     0m0,040s
</pre>
  <p>Конечно, реальное время работы зависит от процессора и других факторов. Но нельзя ли обработать файл быстрее, чем за пять с половиной секунд? В этом нам поможет контейнер std::unordered_map.</p>

  <h4>Контейнер std::unordered_map</h4>

  <p>Воспользуемся другой реализацией ассоциативного массива из стандартной библиотеки C++ — хеш-таблицей unordered_map. Само название этого класса подчёркивает, что данные будут храниться не упорядоченными по ключу. Предполагается, что для каждого ключа определена хеш-функция (по умолчанию std::hash&lt;Key&gt;()), а по ней вычисляется номер корзины (bucket), в которую должен попасть ключ.</p>
  <p>Случай, когда два разных ключа оказываются в одной корзине, называется коллизией. В С++ для разрешения коллизий используется метод цепочек, то есть, внутри одной корзины все элементы выстраиваются в односвязный список.</p>
  <p>Если хеш-функция достаточно равномерна и корзин достаточно много, то в среднем время поиска, добавления и удаления элементов для unordered_map будет константным O(1).</p>
  <p>Интерфейс unordered_map специально сделан похожим на интерфейс map. Нам будет достаточно заменить только заголовочный файл и имя контейнера:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;

int main() {
  std::unordered_map&lt;std::string, int&gt; freqs;
  std::string word;
  while (std::cin >> word) {
    ++freqs[word];
  }
  for (const auto& [word, freq] : freqs) {
    std::cout &lt;&lt; word &lt;&lt; "\t" &lt;&lt; freq &lt;&lt; "\n";
  }
}
</pre>
  <p>Порядок обхода теперь выглядит произвольным (но на самом деле он диктуется хеш-функцией):</p>
<pre>
$ clang++ --std=c++20 -o count_freqs count_freqs.cpp
$ ./count_freqs &lt; text8 | head
storerooms	2
fretensis	1
metzada	1
workmans	1
mikhailgorbachev	1
naevus	3
buildups	1
clandenstine	1
democratised	1
wilgoren	2
</pre>
  <p>Время работы сократилось с 5,5 до 3,1 секунды:</p>
<pre>
$ clang++ --std=c++20 -O3 -o count_freqs count_freqs.cpp
$ time ./count_freqs &lt; text8 > /dev/null
real    0m3,117s
user    0m3,080s
sys     0m0,036s
</pre>
  <p>У контейнера unordered_map есть функция max_load_factor, которая задаёт максимально допустимое соотношение между числом элементов и количеством корзин. По умолчанию эта величина равна единице, так что unordered_map пытается в среднем вообще избежать коллизий. Но это не означает отсутствия коллизий в отдельных корзинах.</p>
  <p>Если при вставке очередного элемента среднее число элементов в корзинах превышает этот порог, число корзин автоматически увеличивается и происходит рехеширование. Чем-то это напоминает реаллокацию у вектора.</p>
  <p>Если нам заранее известно финальное количество ключей, то можно вызвать заранее функцию reserve и избежать лишних рехеширований при вставках. Тем самым можно отыграть дополнительное время:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;

int main() {
  std::unordered_map&lt;std::string, int&gt; freqs;
  freqs.reserve(300'000);  // можно использовать апостроф для выделения разрядов
  std::string word;
  while (std::cin >> word) {
    ++freqs[word];
  }
  for (const auto& [word, freq] : freqs) {
    std::cout &lt;&lt; word &lt;&lt; "\t" &lt;&lt; freq &lt;&lt; "\n";
  }
}
</pre>
<pre>
$ clang++ --std=c++20 -O3 -o count_freqs count_freqs.cpp
$ time ./count_freqs &lt; text8 > /dev/null
real   0m3,067s
user   0m3,035s
sys    0m0,032s
</pre>

  <h4>Из контейнера в контейнер</h4>

  <p>Вернёмся к сортировке слов по убыванию частоты. Для этого проще всего будет переложить слова с частотами в вектор пар и отсортировать его, используя свою функцию сравнения:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;tuple&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;

int main() {
  std::unordered_map&lt;std::string, int&gt; freqs;
  std::string word;
  while (std::cin >> word) {
    ++freqs[word];
  }

  // копируем пары в вектор, используя шаблонный конструктор от двух итераторов:
  std::vector&lt;std::pair&lt;std::string, int&gt; &gt; sortedByFreq(
    freqs.begin(),
    freqs.end()
  );

  // сортируем с помощью своей лямбда-функции:
  std::sort(
    sortedByFreq.begin(),
    sortedByFreq.end(),
    [](const auto& p1, const auto& p2) {
      // сначала сравниваем частоты по убыванию, потом — слова по возрастанию
      return std::tie(p2.second, p1.first) &lt; std::tie(p1.second, p2.first);
    }
  );

  for (const auto& [word, freq] : sortedByFreq) {
    std::cout &lt;&lt; word &lt;&lt; "\t" &lt;&lt; freq &lt;&lt; "\n";
  }
}
</pre>
  <p>Здесь мы элегантно копируем данные из unordered_map в вектор, указывая при инициализации переменной sortedByFreq пару итераторов другого контейнера. Цикл, копирующий элементы из этого диапазона, скрыт в конструкторе вектора.</p>
  <p>Посмотрим на первые 10 результатов с помощью консольной утилиты head. Теперь мы в самом деле получили наиболее частотные слова из файла:</p>
<pre>
$ clang++ --std=c++20 -o count_freqs count_freqs.cpp
$ ./count_freqs &lt; text8 | head
the	1061396
of	593677
and	416629
one	411764
in	372201
a	325873
to	316376
zero	264975
nine	250430
two	192644
</pre>

  <h4>Контейнеры std::set и std::unordered_set</h4>

  <p>Контейнеры std::set и std::unordered_set похожи на map и unordered_map по внутреннему устройству, но они хранят только ключи, без ассоциированных значений. Вот как можно выписать повторяющиеся слова текста в алфавитном порядке (по одному разу каждое):</p>
<pre>
#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;string&gt;
#include &lt;unordered_set&gt;

int main() {
  // здесь будем хранить все слова (каждое по одному разу)
  std::unordered_set&lt;std::string&gt; words;

  // здесь будем хранить повторяющиеся слова
  // используем set, а не unordered_set, чтобы потом напечатать их по алфавиту
  std::set&lt;std::string&gt; duplicate_words;

  std::string word;
  while (std::cin >> word) {
    if (words.contains(word)) {
      duplicate_words.insert(word);
    } else {
    words.insert(word);
    }
  }

  for (const auto& word : duplicate_words) {
    std::cout &lt;&lt; word &lt;&lt; "\n";
  }
}
</pre>
  <p>Здесь мы применили функцию contains, которая появилась только в C++20. При использовании более старого стандарта нужно написать if (words.find(word) != words.end()).</p>
  <p>Заметим, что при попадании в else мы ищем слово в words дважды: один раз для проверки в contains, а другой раз — в insert. Можно было бы обойтись только одним поиском, воспользовавшись тем, что insert возвращает пару из итератора на элемент и флажка с результатом поиска:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;string&gt;
#include &lt;unordered_set&gt;

int main() {
  std::unordered_set&lt;std::string&gt; words;
  std::set&lt;std::string&gt; duplicate_words;
  std::string word;
  while (std::cin >> word) {
    auto [iter, has_been_inserted] = words.insert(word);
    if (!has_been_inserted) {
      duplicate_words.insert(word);
    }
  }
  for (const auto& word : duplicate_words) {
    std::cout &lt;&lt; word &lt;&lt; "\n";
  }
}
</pre>
  <p>Название set происходит от математического понятия множества, где элементы хранятся только по одному разу. Однако никаких теоретико-множественных операций (объединения, пересечения, разности) у set и unordered_set не предусмотрено. В параграфе «Алгоритмы» мы рассмотрим алгоритмы для выполнения таких операций над отсортированными последовательностями.</p>

  <h4>Мультиконтейнеры</h4>

  <p>В стандартной библиотеке C++ есть четыре мультиконтейнера:</p>
  <ul>
    <li>std::multimap (в заголовочном файле map);</li>
    <li>std::multiset (в заголовочном файле set);</li>
    <li>std::unordered_multimap (в заголовочном файле unordered_map);</li>
    <li>std::unordered_multiset (в заголовочном файле unordered_set).</li>
  </ul>
  <p>Они аналогичны обычным ассоциативным контейнерам, которые мы рассматривали выше, но в мультиконтейнерах один и тот же ключ может встретиться несколько раз.</p>
  <p>Пусть, например, мы хотим сохранять для каждого слова в текстовом файле его порядковый номер. Слова в тексте могут повторяться, поэтому воспользуемся контейнером multimap:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;map&gt;

int main() {
  std::multimap&lt;std::string, int&gt; positions;

  std::string word;
  int position = 0;
  while (std::cin >> word) {
    positions.insert({word, position});
    ++position;
  }
}
</pre>
  <p>В этом случае мы могли бы применить вместо std::multimap&lt;std::string, int&gt; контейнер std::map&lt;std::string, std::vector&lt;int&lt; &lt;. Разница будет в использовании и в накладных расходах.</p>
  <p>Для обхода multimap потребуется один цикл, а для map с вектором — два вложенных цикла (по ключам и по элементам вектора для данного ключа). Вектор имеет накладные расходы на хранение метаинформации и резерва, а в multimap все данные будут храниться в одном сбалансированном дереве.</p>
  <p>Наконец, итераторы multimap стабильны, а у вектора могут инвалидироваться. Применять multimap имеет смысл там, где повторы ключей сравнительно редки.</p>

  <h4>Итераторы ассоциативных контейнеров</h4>

  <p>Контейнеры map, set и их мультиверсии предоставляют двусторонние итераторы, которые можно сдвигать на соседние позиции вперёд и назад. Как и в случае последовательных контейнеров, запрещено выходить за пределы диапазона, ограниченного begin() и end(), и разыменовывать итератор, равный end(). Итераторы таких контейнеров и ссылки (указатели) на элементы никогда не инвалидируются.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;map&gt;
#include &lt;string&gt;

int main() {
  std::map&lt;int, std::string&gt; numbers = {
    {100, "hundred"},
    {3, "three"},
    {42, "forty two"},
    {11, "eleven"},
  };

  auto iter = numbers.find(11);

  if (iter != numbers.end()) {
    // печатаем найденный элемент
    const auto& [key, value] = *iter;
    std::cout &lt;&lt; "Found: " &lt;&lt; key
    &lt;&lt; ": " &lt;&lt; value &lt;&lt; "\n";  // Found: 11: eleven

    // печатаем предыдущий элемент
    if (iter != numbers.begin()) {
      const auto& [key, value] = *std::prev(iter);
      std::cout &lt;&lt; "Previous: " &lt;&lt; key
      &lt;&lt; ": " &lt;&lt; value &lt;&lt; "\n";  // Previous: 3: three
    } else {
      std::cout &lt;&lt; "No previous element\n";
    }

    // печатаем следующий элемент
    if (auto nextIter = std::next(iter); nextIter != numbers.end()) {
      const auto& [key, value] = *nextIter;
      std::cout &lt;&lt; "Next: " &lt;&lt; key
      &lt;&lt; ": " &lt;&lt; value &lt;&lt; "\n";  // Next: 42: forty two
    } else {
      std::cout &lt;&lt; "No next element\n";
    }
  } else {
    std::cout &lt;&lt; "Not found\n";
  }
}
</pre>
  <p>Может показаться, что в строке const auto& [key, value] = *std::prev(iter) мы строим висячие ссылки, так как возвращаемое значение функции prev после вычисления всего выражения сразу станет невалидным. Однако константные ссылки продлевают жизнь объекта до конца текущего блока.</p>
  <p>Итераторы unordered-контейнеров однонаправленные: их можно сдвигать только вперёд. Это связано с тем, что коллизии в хеш-таблице обычно разрешаются с помощью односвязного списка элементов, а по односвязному списку нельзя двигаться назад. Итераторы unordered-контейнеров могут инвалидироваться только если произошло рехеширование при вставке. Ссылки и указатели никогда не инвалидируются.</p>
  <p>Отдельно отметим функцию erase у ассоциативных контейнеров. У неё есть несколько перегруженных версий. Одна версия принимает ключ, другая — итератор удаляемого элемента, третья — диапазон итераторов. Разница будет для мультиконтейнеров: если какой-то ключ повторяется, то первая версия erase удалит все вхождения таких ключей, а вторая — только конкретные:</p>
<pre>
#include &lt;unordered_map&gt;

int main() {
  std::unordered_multimap&lt;std::string, int&gt; data = {
    {"a", 1},
    {"a", 2},
    {"a", 3},
    {"b", 4},
  };

  auto iter = data.find("a");
  if (iter != data.end()) {
    // удаляем первое найденное вхождение с ключом "a"
    data.erase(iter);
  }

  // удаляем все остальные вхождения с ключом "a"
  data.erase("a");
}
</pre>
</article>


<!-- 3.3 Алгоритмы -->
<article class="article">
  <div class="anchor" id="p3.3"></div>
  <h3>3.3 Алгоритмы</h3>

  <p>В этом параграфе мы обсудим алгоритмы стандартной библиотеки. Они представляют из себя шаблонные функции для обработки последовательностей: подсчёта, поиска, сортировки и т. д. Такие функции, как правило, принимают на вход два итератора, которые ограничивают рассматриваемый диапазон.</p>
  <p>Мы уже знакомы с одной из таких функций: это std::sort. В этом параграфе мы познакомимся с некоторыми другими важными примерами алгоритмов, а полный их перечень можно найти на cppreference.com.</p>

  <h4>Пары итераторов</h4>

  <p>В функции стандартной библиотеки часто требуется передать два итератора, которые ограничивают диапазон элементов. К ним предъявляются такие требования:</p>
  <ul>
    <li>это должны быть итераторы одного и того же контейнера;</li>
    <li>от первого итератора ко второму можно перейти, применяя оператор ++.</li>
  </ul>
  <p>Предполагается, что второй итератор при этом ссылается за последний элемент диапазона. Его нельзя разыменовывать оператором *, даже если он ссылается на валидный элемент.</p>
  <p>Можно рассматривать пару итераторов как математический полуинтервал, где левый конец включается в диапазон, а правый — нет.</p>
  <p>Все контейнеры имеют функции begin и end. Они возвращают итераторы, указывающие на начальный и за последний элемент всей последовательности элементов контейнера.</p>
  <p>Контейнеры, которые допускают обход в обратном порядке (все кроме forward_list и unordered-контейнеров), имеют также функции rbegin и rend. Они возвращают обратные итераторы. С их помощью можно проходить по элементам из конца в начало.</p>
  <p>Однако можно строить и другие диапазоны. Например, вот так можно отсортировать по возрастанию «середину» вектора кроме первого и последнего элемента:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; data = {100, 42, 17, 80, 20, 0};
  std::sort(data.begin() + 1, data.end() - 1);  // 100, 17, 20, 42, 80, 0
}
</pre>
  <p>Впрочем, так можно делать только если мы уверены, что в векторе есть хотя бы два элемента. В противном случае диапазон получится некорректным и поведение программы будет неопределённым.</p>
  <p>Заметим, что с помощью итераторов реализован цикл range-based for. В самом деле, конструкция</p>
<pre>
for (const auto& element : container) {
  // делаем что-то с element
}
</pre>
  <p>просто превращается компилятором в примерно такой код:</p>
<pre>
for (auto iter = container.begin(); iter != container.end(); ++iter) {
  const auto& element = *iter;
  // делаем что-то с element
}
</pre>
  <p>В C++20 для каждого алгоритма были добавлены так называемые constrained-версии. Эти версии вместо пары итераторов принимают диапазон (range), оформленный в виде отдельного объекта. В частности, в роли такого объекта может выступать сам контейнер. Это позволяет вызывать сортировку, например, так:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; data = {100, 42, 17, 80, 20, 0};
  std::ranges::sort(data);  // 0, 17, 20, 42, 80, 100
}
</pre>
  <p>Мы пока ограничимся классическими версиями алгоритмов.</p>

  <h4>Подсчёт</h4>

  <p>Рассмотрим, пожалуй, самый простой пример — алгоритм std::count. Эта функция подсчитывает, сколько элементов последовательности равны заданному. Конечно, такую задачу можно решить с помощью банального цикла:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; v = {2, 7, 1, 8, 2, 8};

  // сколько в последовательности восьмёрок?
  int counter = 0;
  for (int elem : v) {
    if (elem == 8) {
      ++counter;
    }
  }
  std::cout &lt;&lt; counter &lt;&lt; "\n";  // 2
}
</pre>
  <p>Однако использование готового стандартного алгоритма всегда предпочтительнее:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; v = {2, 7, 1, 8, 2, 8};
  std::cout &lt;&lt; std::count(v.begin(), v.end(), 8)
   &lt;&lt; "\n";  // 2
}
</pre>
  <p>Функцию std::count можно применять к итераторам любого последовательного контейнера. Применим её, например, к списку:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;list&gt;

int main() {
  std::list&lt;int&gt; v = {2, 7, 1, 8, 2, 8};
  std::cout &lt;&lt; std::count(v.begin(), v.end(), 8) &lt;&lt; "\n";
}
</pre>
  <p>Такие функции как std::count позволяют упростить код и сделать его более лаконичным и выразительным. Важно понимать, что это самые обыкновенные шаблонные функции, написанные на C++. Вы даже можете посмотреть их реализацию, если откроете заголовочный файл algorithm. Давайте попробуем в качестве упражнения написать такую функцию самостоятельно.</p>
<pre>
template &lt;typename Iter, typename Value&gt;  // два шаблонных параметра: тип итератора и тип эталонного элемента
int count(Iter first, Iter last, const Value& value) {
  int counter = 0;
  for (Iter iter = first; iter != last; ++iter) {
    if (*iter == value) {
      ++counter;
    }
  }
  return counter;
}
</pre>
  <p>На самом деле тип возвращаемого значения этой функции не в точности int, а typename iterator_traits&lt;Iter&gt;::difference_type, построенный по типу итератора.</p>

  <h4>Поиск</h4>

  <p>Алгоритм std::find ищет последовательным перебором первое вхождение элемента, равного заданному. Результатом является итератор, который указывает на найденный элемент. Если же ничего не найдено, то возвращается правый конец переданного полуинтервала.</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;deque&gt;
#include &lt;iostream&gt;

int main() {
  std::deque&lt;int&gt; d = {3, 14, 15, 92, 6};

  // Такой элемент есть, мы его точно найдём
  auto iter1 = std::find(d.begin(), d.end(), 15);
  // Итераторы дека можно вычитать, напечатается индекс найденного элемента
  std::cout &lt;&lt; (iter1 - d.begin()) &lt;&lt; "\n";

  auto start = d.begin();
  // К итераторам дека и вектора можно прибавлять целые числа
  auto end = start + 3;
  // Полуинтервал [start; end&#x29; теперь ограничивает подпоследовательность 3, 14, 15

  auto iter2 = std::find(start, end, 19);
  if (iter2 == end) {
    std::cout &lt;&lt; "No such element!\n";
  } else {
    std::cout &lt;&lt; *iter2 &lt;&lt; "\n";
  }
  // Напечатает No such element
}
</pre>
  <p>Вот его возможная реализация:</p>
<pre>
template &lt;typename Iter, typename Value&gt;
Iter find(Iter first, Iter last, const Value& value) {
  while (first != last) {
    if (*first == value) {
      return first;
    }
    ++first;
  }
  return last;
}
</pre>
  <p>Имеется также алгоритм std::search, который ищет не отдельный элемент, а подпоследовательность элементов.</p>

  <h4>Алгоритмы и встроенные функции</h4>

  <p>У ассоциативных контейнеров есть встроенная функция find, которая возвращает похожий по смыслу итератор. Разберёмся, в чём различие между общим алгоритмом find и встроенной функцией. Алгоритм std::find написан в общем виде. Он работает только с итераторами и ничего не знает о физическом устройстве контейнера. Поэтому он ищет элемент последовательным перебором с линейной сложностью O(n). Но в ассоциативных контейнерах можно найти элемент быстрее: за O(logn) в set и map и в среднем за O(1) в unordered_set и unordered_map.</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;set&gt;

int main() {
  std::set&lt;int&gt; numbers = {2, 3, 5, 7, 11, 13, 17, 19};

  // Предпочтительный способ:
  auto iter1 = numbers.find(15);

  // Допустимо, но неэффективно!
  auto iter2 = std::find(numbers.begin(), numbers.end(), 15);
}
</pre>
  <p>Тут мы встречаемся с общей идеей, заложенной в дизайн стандартной библиотеки C++: если некоторый алгоритм имеет более эффективную реализацию для конкретного контейнера, то он будет реализован у этого контейнера в виде встроенной функции. Наоборот, если возможна лишь общая реализация, то специальной встроенной функции не будет. Поэтому, например, у вектора и дека нет своей встроенной функции find.</p>
  <p>Заметим, что найти элемент по ключу в контейнерах map и unordered_map с помощью алгоритма std::find вообще не получится. Дело в том, что итераторы таких контейнеров ссылаются на пару из константного ключа и значения, а не просто на ключ. А значение как правило нам заранее неизвестно: его как раз обычно и требуется получить по ключу.</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;utility&gt;

int main() {
  std::map&lt;int, int&gt; m = {
    {1, 30},
    {2, 28},
    {3, 31},
    // ...
  };

  // правильный способ поиска по ключу
  auto it1 = m.find(12);
  // не скомпилируется!
  auto it2 = std::find(m.begin(), m.end(), 12);

  std::pair&lt;const int, int&gt; value = {12, 31};
  // Скомпилируется, но неэффективно и бессмысленно:
  auto it3 = std::find(m.begin(), m.end(), value);
}
</pre>

  <h4>Алгоритмы, принимающие предикат</h4>

  <p>В алгоритмах count и find мы передавали третьим аргументом конкретное значение, которое требовалось найти в последовательности. Но иногда бывает нужно найти любое значение, удовлетворяющее некоторому условию. Такое условие можно оформить в виде функции, получающей на вход элемент последовательности и возвращающей логический ответ (true, если элемент подходит и false, если не подходит). Такие функции называют предикатами. Для работы с ними имеются алгоритмы, в названии которых добавляется суффикс _if.</p>
  <p>Например, подсчитаем, сколько заглавных латинских букв в строке. Передадим в функцию count_if предикат, оформленный в виде лямбда-функции:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string s = "iPhone SE";

  std::cout &lt;&lt; std::count_if(
    s.begin(),
    s.end(),
    [](char c) {
      return 'A' &lt;= c && c &lt;= 'Z';
    }
  ) &lt;&lt; "\n";  // 3
}
</pre>
  <p>Можно было бы внутри лямбда-функции вместо двойного неравенства воспользоваться функцией std::isupper. К сожалению, просто передать std::isupper в std::count_if не получится: компилятор не сможет без конкретных аргументов отличить эту функцию от другой перегруженной версии.</p>
  <p>Напишем для примера собственную реализацию алгоритма find_if. Тип предиката сделаем просто шаблонным параметром.</p>
<pre>
template &lt;typename Iter, typename Predicate&gt;
Iter find_if(Iter first, Iter last, Predicate p) {
  while (first != last) {
    if (p(*first)) {  // применяем предикат
      return first;
    }
    ++first;
  }
  return last;
}
</pre>
  <p>Отметим семейство алгоритмов std::all_of, std::any_of и std::none_of, также принимающих предикаты. Их смысл понятен из названия. Например, any_of проверяет, что какой-то элемент последовательности удовлетворяет предикату. Типичная реализация any_of сводится к вызову find_if и сравнению результата с итератором last.</p>

  <h4>Алгоритмы, модифицирующие последовательность</h4>

  <p>Рассмотрим алгоритм std::reverse. Он переставляет элементы последовательности в обратном порядке:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string s = "No lemon, no melon!";
  std::reverse(s.begin(), s.end());
  std::cout &lt;&lt; s &lt;&lt; "\n";  // !nolem on ,nomel oN
}
</pre>
  <p>Его возможная реализация выглядит так:</p>
<pre>
template &lt;typename Iter&gt;
void reverse(Iter first, Iter last) {
  while (first != last) {
    --last;
    if (first == last) {
      break;
    }
    std::swap(*first, *last);
    ++first;
  }
}
</pre>
  <p>Сложность тут в том, что last указывает за последний элемент, и этот итератор надо аккуратно подвинуть назад, прежде чем переставлять элементы. Здесь вызывается функция std::swap, реализацию которой мы уже писали в параграфе «Функции».</p>
  <p>Важно понимать, что алгоритмы работают с итераторами, и поэтому они ничего не знают о физическом способе хранения элементов в контейнерах. Алгоритмы знают лишь о логическом порядке перебора элементов. Поэтому алгоритмы не могут физически что-либо удалить из контейнера или добавить в него. Лучшее, что они могут сделать, — это переупорядочить элементы в последовательности.</p>
  <p>Рассмотрим алгоритм std::unique. Этот алгоритм переставляет элементы так, чтобы в последовательности не было подряд идущих дубликатов. Уменьшить размер последовательности алгоритм не может. Поэтому в конце последовательности остаётся некоторый набор ненужных элементов. Их можно потом явно удалить, вызвав функцию erase у контейнера:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; v = {5, 5, 3, 2, 2, 5, 9, 1};
  auto iter = std::unique(v.begin(), v.end());
  // В векторе окажется 5, 3, 2, 5, 9, 1, 9, 1
  //                                      ^ iter будет указывать сюда
  v.erase(iter, v.end());  // удаляем хвост из ненужных элементов
}
</pre>
  <p>Обратите внимание, что третья пятёрка не удалилась, потому что она не расположена рядом с другими пятёрками. Обычно std::unique применяют вместе с std::sort, чтобы одинаковые элементы оказались рядом:</p>
<pre>
std::sort(v.begin(), v.end());
v.erase(std::unique(v.begin(), v.end()), v.end());
</pre>
  <p>Среди других алгоритмов, модифицирующих последовательность, имеются</p>
  <ul>
    <li>std::fill и std::generate (заполнение заданными значениями),</li>
    <li>std::rotate (циклический сдвиг),</li>
    <li>std::replace (замена элементов),</li>
    <li>std::remove (переупорядочивание элементов, чтобы указанный элемент не встречался в начале),</li>
    <li>std::shuffle (случайная перестановка элементов).</li>
  </ul>

  <h4>Запись в другую последовательность</h4>

  <p>Алгоритм std::copy копирует содержимое одной последовательности в другую последовательность. Он принимает три аргумента: обычную пару итераторов, задающих входной диапазон, и итератор, обозначающий начало выходного диапазона. Четвёртый аргумент не нужен: никаких проверок корректности всё равно не делается.</p>
  <p>В этом примере мы копируем диапазон элементов в обратном порядке из вектора в список:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; v = {3, 14, 15, 92, 6};
  std::list&lt;int&gt; l;
  l.resize(v.size());  // теперь в списке l 5 нулей

  std::copy(v.rbegin(), v.rend(), l.begin());

  for (int x : l) {
    std::cout &lt;&lt; x &lt;&lt; " ";
  }
  std::cout &lt;&lt; "\n";  // 6 92 15 14 3
}
</pre>
  <p>В контейнере, в который мы копируем элементы, должно быть достаточно места, чтобы они поместились. Если бы мы не вызвали resize для списка l, то программа попала бы в неопределенное поведение!</p>
<pre>
Вот возможная реализация алгоритма copy:
template &lt;typename InputIter, typename OutputIter&gt;
OutputIter copy(InputIter first, InputIter last, OutputIter out) {
  while (first != last) {
    *out = *first;
    ++first;
    ++out;
  }
  return out;
}
</pre>
  <p>Обратите внимание, что шаблонные типы входных и выходных итераторов, вообще говоря, разные. Функция возвращает выходной итератор, указывающий за последний записанный элемент. Этот итератор позволяет потом физически удалить лишние элементы выходной последовательности, которые больше не нужны:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;list&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; v = {3, 14, 15, 92, 6};
  std::list&lt;int&gt; l(10);  // 10 нулей

  auto iter = std::copy(v.begin(), v.end(), l.begin());
  // 3 14 15 92 6 0 0 0 0 0, iter указывает на первый ноль

  l.erase(iter, l.end());  // 3 14 15 92 6
}
</pre>
  <p>В стандартной библиотеке для модифицирующих алгоритмов есть версии с суффиксом _copy в имени, которые ведут себя похожим образом. Вместо модификации исходной последовательности они записывают результат в отдельную выходную последовательность. В ней должно быть достаточно места, чтобы результат поместился. Вот пример использования функции std::replace_copy:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;std::string&gt; words1 = {"a", "cat", "and", "a", "dog"};
  std::vector&lt;std::string&gt; words2(words1.size());  // 5 пустых строк

  const std::string from = "a";
  const std::string to = "the";
  std::replace_copy(words1.begin(), words1.end(), words2.begin(), from, to);

  for (const auto& word : words1) {
    std::cout &lt;&lt; word &lt;&lt; " ";  // a cat and a dog
  }
  std::cout &lt;&lt; "\n";

  for (const auto& word : words2) {
    std::cout &lt;&lt; word &lt;&lt; " ";  // the cat and the dog
  }
  std::cout &lt;&lt; "\n";
}
</pre>

  <h4>Адаптеры для вставки</h4>

  <p>В стандартной библиотеке есть конструкции, которые притворяются обычными итераторами, но на самом деле не являются таковыми. Например, шаблонная функция std::back_inserter принимает последовательный контейнер и возвращает адаптер, который ведёт себя как итератор, но при попытке записи в него добавляет элемент в контейнер через push_back. Такие адаптеры удобно использовать с модифицирующими алгоритмами.</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;list&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; v = {3, 14, 15, 92, 6};
  std::list&lt;int&gt; l;  // список пустой!
  std::copy(v.begin(), v.end(), std::back_inserter(l));  // 3 14 15 92 6
}
</pre>
  <p>Также есть функции std::front_inserter и std::inserter. Последняя кроме контейнера принимает ещё и итератор, перед которым должна производиться вставка. Разумеется, этот итератор не должен инвалидироваться в процессе работы алгоритма.</p>

  <h4>Сортировка</h4>

  <p>Мы уже знакомы с std::sort. Заметим, что этот алгоритм нестабильный: после сортировки порядок одинаковых элементов может измениться. Это может быть заметно, например, во время сортировки вектора структур при сравнении по какому-то ключевому полю. В стандартной библиотеке имеется чуть менее эффективная функция stable_sort с асимптотической сложностью O(n(logn)²), сохраняющая порядок эквивалентных элементов.</p>
  <p>Важно заметить, что алгоритмы сортировки требуют, чтобы на входе были итераторы произвольного доступа. Такие итераторы предоставляют контейнеры с индексами — vector, string, array, deque. К итераторам этих контейнеров можно прибавлять целые числа и их можно вычитать друг из друга. В сортировке это используется для быстрого обращения к элементу в середине последовательности.</p>
  <p>Вызов общего алгоритма сортировки с итераторами списка просто не скомпилируется. Однако, как и с функцией find у ассоциативных контейнеров, у списков есть встроенная функция sort. Она использует сортировку слиянием, которая чуть менее эффективна на практике, но имеет ту же асимптотическую сложность O(nlogn), что и std::sort.</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;list&gt;

int main() {
  std::list&lt;int&gt; data = {3, 14, 15, 92, 6};
  std::sort(data.begin(), data.end());  // не скомпилируется!
  data.sort();  // OK, встроенная функция сортировки списка
}
</pre>
  <p>Проверить, отсортирована ли последовательность, можно с помощью функции std::is_sorted. А с помощью функции std::partial_sort можно построить только начало отсортированного массива, не сортируя хвост:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; data = {3, 14, 15, 92, 6};
  std::partial_sort(data.begin(), data.begin() + 3, data.end());
  // первыми тремя элементами в векторе будут 3, 6, 14
}
</pre>

  <h4>Алгоритмы бинарного поиска</h4>

  <p>К отсортированным последовательностям в контейнерах можно применять особый набор алгоритмов. Рассмотрим алгоритмы для бинарного поиска:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  // Отсортирован по возрастанию:
  std::vector&lt;int&gt; data = {1, 4, 5, 9, 9, 13, 47};

  // Элемент будет найден:
  if (std::binary_search(data.begin(), data.end(), 5)) {
    std::cout &lt;&lt; "Found\n";
  } else {
    std::cout &lt;&lt; "Not found\n";
  }
}
</pre>
  <p>Если <strong>binary_search</strong> возвращает true или false, то алгоритмы <strong>lower_bound</strong> и <strong>upper_bound</strong> возвращают итераторы. Алгоритм <strong>lower_bound</strong> возвращает итератор на первый элемент, не меньший заданного. Алгоритм <strong>upper_bound</strong> возвращает итератор на первый элемент, больший заданного:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  // Числа идут по возрастанию:
  std::vector&lt;int&gt; data = {1, 4, 5, 9, 9, 13, 47};

  auto iter1 = std::lower_bound(
    data.begin(), data.end(),
    8
  );  // *iter1 == 9

  auto iter2 = std::upper_bound(
    data.begin(), data.end(),
    47
  );  // iter2 == data.end()

  // все элементы исходной последовательности,
  // такие, что 8 &lt;= x &lt;= 47,
  // попадут в полуинтервал [iter1, iter2)
  for (auto iter = iter1; iter != iter2; ++iter) {
    std::cout &lt;&lt; *iter &lt;&lt; " ";  // 9 9 13 47
  }
  std::cout &lt;&lt; "\n";
}
</pre>
  <p>В частности, пара std::lower_bound(first, last, x) и std::upper_bound(first, last, x) ограничивает диапазон элементов, эквивалентных x. Пару таких итераторов можно получить за один вызов из функции <strong>std::equal_range</strong>.</p>
  <p>Как и в случае с find, у ассоциативных контейнеров есть собственные встроенные реализации функций lower_bound, upper_bound и equal_range.</p>
  <p>Если последовательность не будет упорядочена, то результат работы всех этих функций может быть некорректным.</p>
  <p>Формально эти функции можно применять и к итераторам списка, не имеющим произвольного доступа. В этом случае время работы будет не логарифмическим, а линейным.</p>

  <h4>Теоретико-множественные алгоритмы</h4>

  <p>Над отсортированными последовательностями можно выполнять операции</p>
  <ul>
    <li>слияния (std::merge),</li>
    <li>объединения (std::set_union)</li>
    <li>пересечения (std::set_intersection),</li>
    <li>разности (std::set_difference),</li>
    <li>симметрической разности (std::set_symmetric_difference).</li>
  </ul>
  <p>Также можно проверять вложения (std::includes).</p>
  <p>Эти алгоритмы работают за линейное время от суммарной длины последовательностей. Перечисленные операции соответствуют математическим мультимножествам, а не множествам, потому что элементы в последовательностях могут повторяться. Каждый элемент учитывается со своей кратностью.</p>
  <p>Все эти операции (кроме includes) принимают пять аргументов:</p>
  <ul>
    <li>два итератора первого диапазона,</li>
    <li>два итератора второго диапазона,</li>
    <li>итератор выходной последовательности для записи ответа.</li>
  </ul>
  <p>Элементы выходной последовательности также будут отсортированы.</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;deque&gt;
#include &lt;iterator&gt;
#include &lt;list&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; in1 = {1, 3, 5, 5, 7};
  std::list&lt;int&gt; in2 = {1, 1, 2, 3};
  std::deque&lt;int&gt; out;

  std::merge(
    in1.begin(), in1.end(),
    in2.begin(), in2.end(),
    std::back_inserter(out)
  );  // 1, 1, 1, 2, 3, 3, 5, 5, 7

  out.clear();
  std::set_union(
    in1.begin(), in1.end(),
    in2.begin(), in2.end(),
    std::back_inserter(out)
  );  // 1, 1, 2, 3, 5, 5, 7

  out.clear();
  std::set_intersection(
    in1.begin(), in1.end(),
    in2.begin(), in2.end(),
    std::back_inserter(out)
  );  // 1, 3

  out.clear();
  std::set_difference(
    in1.begin(), in1.end(),
    in2.begin(), in2.end(),
    std::back_inserter(out)
  );  // 5, 5, 7

  out.clear();
  std::set_symmetric_difference(
    in1.begin(), in1.end(),
    in2.begin(), in2.end(),
    std::back_inserter(out)
  );  // 1, 2, 5, 5, 7

  std::includes(
    in2.begin(), in2.end(),
    in1.begin(), in1.end()
  );  // false
}
</pre>
</article>


<!-- 3.4 Адаптеры и представления -->
<article class="article">
  <div class="anchor" id="p3.4"></div>
  <h3>3.4 Адаптеры и представления</h3>

  <p>Адаптеры над стандартными контейнерами — это не самостоятельные контейнеры. Они используют какой-нибудь другой контейнер (например, дек или вектор) для хранения своих элементов, но при этом предоставляют свой набор функций для работы с ними. В стандартной библиотеке есть адаптеры std::stack, std::queue и std::priority_queue.</p>
  <p>Представления (views) не владеют памятью, а лишь ссылаются на диапазон значений другого контейнера. Представлением можно считать пару итераторов. В С++20 появилась обширная библиотека ranges для работы с представлениями. В этом параграфе мы рассмотрим конструкцию string_view, представляющую фрагмент строки.</p>

  <h4>Адаптер std::stack</h4>

  <p>Стек — это последовательность элементов, в которую разрешается добавлять и извлекать элементы только с одной стороны. Обращение к промежуточным элементам не допускается. Говорят, что структура данных «стек» реализует идею LIFO (last in — first out).</p>
  <p>Понятно, что эти действия можно сделать с помощью вектора или дека и операций push_back и pop_back. Адаптер std::stack является обёрткой над такими контейнерами с особым интерфейсом — функциями push, pop и top. Это позволяет более выразительно подчеркнуть, что используется не просто какой-то контейнер, а именно стек как структура данных.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;stack&gt;

int main() {
  std::stack&lt;int&gt; s;
  s.push(1);
  s.push(13);
  // удалить элемент с вершины стека (в стеке останется 1)
  s.pop();

  // получить элемент на вершине стека, не удаляя его
  std::cout &lt;&lt; s.top() &lt;&lt; "\n";

  if (s.empty()) {  // проверка на пустоту
    std::cout &lt;&lt; "Stack is empty\n";
  }
}
</pre>
  <p>Функция pop ничего не возвращает. Напротив, функция top возвращает элемент, но никак не меняет состояние стека. Так было сделано для гарантий безопасности исключений. Мы поговорим об этом в параграфе «Обработка исключений».</p>
  <p>По умолчанию стек использует контейнер std::deque для хранения элементов. При желании мы можем указать другой тип этого контейнера. Всё, что требуется от этого контейнера, — это поддержка операций push_back, pop_back, back и empty:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;stack&gt;

int main() {
  // используем std::list для хранения элементов в стеке
  std::stack&lt;int, std::list&lt;int&gt; &gt; s;
  // ...
}
</pre>
  <p>В C++ есть ещё понятие стека как области памяти для локальных переменных и аргументов функций. Оно так называется потому, что переменные автоматически помещаются туда при создании и автоматически удаляются при выходе из области видимости. То есть, последняя созданная переменная удалится первой, как в обычном стеке. Не следует путать это понятие с адаптером std::stack. Подробнее про жизненный цикл объектов мы поговорим в параграфе «Жизненный цикл объекта».</p>

  <h4>Адаптер std::queue</h4>

  <p>Другой похожий адаптер — очередь (std::queue). Очередь реализует идею FIFO (first in — first out). Можно считать, что элементы встают в очередь с одного конца, а извлекаются с другого. Очередь предоставляет функции push, pop, front и back.</p>
  <p>Не следует путать адаптер queue с контейнером deque.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;queue&gt;

int main() {
  std::queue&lt;int&gt; s;
  s.push(1);
  s.push(13);

  std::cout &lt;&lt; s.front() &lt;&lt; "\n";  // 1
  std::cout &lt;&lt; s.back() &lt;&lt; "\n";  // 13

  s.pop();  // в очереди останется 13

  if (s.empty()) {
    std::cout &lt;&lt; "Queue is empty\n";
  }
}
</pre>
  <p>Так же как и в std::stack, в очереди по умолчанию используется std::deque для хранения элементов. Этот контейнер точно так же можно заменить. Для этого нужно указать тип нового контейнера во втором шаблонном параметре. Однако в отличие от стека здесь не получится использовать std::vector, так как у него нет функций push_front и pop_front.</p>

  <h4>Адаптер std::priority_queue</h4>

  <p>Рассмотрим адаптер std::priority_queue — очередь с приоритетами. Эта структура данных позволяет за логарифмическое время добавлять и удалять элементы и за константное время получать максимальный элемент. Типичная реализация очереди с приоритетами основана на структуре данных «куча». Для хранения элементов используется контейнер с индексами и с возможностью добавления в конец. На эту роль подходят std::vector и std::deque, но не подходит std::list. По умолчанию используется std::vector.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;queue&gt;  // именно queue, а не priority_queue

int main() {
  std::priority_queue&lt;int&gt; pq;
  for (int x : {3, 14, 15, 92, 6, 0, 1, 10}) {
    pq.push(x);
  }
  while (!pq.empty()) {
    std::cout &lt;&lt; pq.top() &lt;&lt; "\n";
    pq.pop();
  }
  // Будет напечатано 92, 15, 14, 10, 6, 3, 1, 0
}
</pre>
  <p>Для сравнения элементов по умолчанию используется оператор &lt;. Чтобы воспользоваться оператором &gt; и, соответственно, извлекать из очереди минимальные элементы вместо максимальных, можно передать в третьем шаблонном параметре специальную обёртку std::greater&lt;int&gt;.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;functional&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;

int main() {
  std::priority_queue&lt;
    int,
    // тип внутреннего контейнера;
    // его приходится указывать,
    // если нам нужен третий параметр
    std::vector&lt;int&gt;,
    // вспомогательная обёртка над оператором &gt; (а не &lt;)
    std::greater&lt;int&gt;
  > pq;

  for (int x : {3, 14, 15, 92, 6}) {
    pq.push(x);
  }

  while (!pq.empty()) {
    std::cout &lt;&lt; pq.top() &lt;&lt; "\n";
    pq.pop();
  }
  // Будет напечатано 3 6 14 15 92
}
</pre>

  <h4>Представление std::string_view</h4>

  <p>Конструкция std::string_view не является адаптером. Это не самостоятельная строка, а отсылка к подстроке какой-то другой строки. Объекты такого класса не выделяют память для размещения символов строки и не копируют подстроки. Упрощённо их можно представлять себе просто как такие структуры:</p>
<pre>
struct string_view {
  // указатель на начало подстроки в чужой памяти
  const char* start;
  size_t len;   // длина этой подстроки
};
</pre>
  <p>Давайте взглянем на следующий код:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string s = "Hello, world! How do you do?";
  auto sub = s.substr(7, 5);  // тип sub — std::string
  sub[0] = 'W';
  std::cout &lt;&lt; sub &lt;&lt; "\n";  // World
  // В исходной строке всё осталось по-прежнему:
  std::cout &lt;&lt; s &lt;&lt; "\n";  // Hello, world! How do you do?
}
</pre>
  <p>Здесь имеется исходная строка s, у которой мы выделяем подстрочку sub. Эта подстрока является самостоятельной копией фрагмента исходной строки. С одной стороны, это позволяет её независимо изменять. С другой стороны, если такие изменения не требуются, на такое копирование тратится время и память.</p>
  <p>Перепишем теперь это через string_view:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;string_view&gt;

int main() {
  std::string s = "Hello, world! How do you do?";
  std::string_view sv = s;  // смотрим через string_view на строку s
  auto sub = sv.substr(7, 5);  // теперь тип sub — std::string_view
  // sub[0] = 'W';  // изменять через string_view символы строки нельзя
  std::cout &lt;&lt; sub &lt;&lt; "\n";  // world
  std::cout &lt;&lt; s &lt;&lt; "\n";  // Hello, world! How do you do?
}
</pre>
  <p>Обёртка string_view рассматривает исходную строчку как константную: она не позволяет её изменять. В то же время через string_view можно читать символы фрагмента исходной строки, а также можно брать новые подстроки и сужать длину подстроки:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;string_view&gt;

int main() {
  std::string s = "Hello, world! How do you do?";
  std::string_view sv = s;
  sv.remove_prefix(7);  // убрали из sv первые 7 символов
  sv.remove_suffix(16);  // убрали последние 16 символов
  std::cout &lt;&lt; sv &lt;&lt; "\n";  // world
  std::cout &lt;&lt; s &lt;&lt; "\n";  // строка s при этом никак не изменилась
}
</pre>
  <p>Обёртка string_view позволяет избежать ненужных копирований и ускорить программу там, где ведётся работа с подстроками одной большой строки. Например, это могут быть фрагменты JSON- или XML-файлов. Однако важно помнить, что string_view валиден только при условии, что объемлющая строка жива. Например, следующая программа некорректна и приведёт к неопределённому поведению:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;string_view&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;std::string_view&gt; lines;
  for (int i = 0; i &lt; 5; ++i) {
    std::string line;
    std::getline(std::cin, line);
    // string_view в векторе ссылается на память строки line
    lines.push_back(line);
  }
  for (auto item : lines) {
    // Ошибка! Все эти строки уже невалидны!
    std::cout &lt;&lt; item &lt;&lt; "\n";
  }
}
</pre>
  <p>Программа компилируется, но при запуске попадает в неопределённое поведение, так как исходные строки line выходят из своей области видимости после каждой итерации цикла, и обращаться к их памяти больше нельзя.</p>
  <p>По аналогии со string_view, std::span является оберткой над произвольной непрерывной последовательностью элементов в памяти. Можно сказать, что span — это аналог string_view для массивов или векторов.</p>
</article>


<!-- 3.5 Разбор задач к главе «Стандартная библиотека C++» -->
<article class="article">
  <div class="anchor" id="p3.5"></div>
  <h3>3.5 Разбор задач к главе «Стандартная библиотека C++»</h3>

  <h3>Параграф «Последовательные контейнеры»</h3>

  <h4>Задача «Шаблонный Print»</h4>

  <details>
    <summary>Условие</summary>
    <p>Вам надо написать функцию Print, которая умеет печатать в поток std::cout элементы переданного контейнера через указанную строку-разделитель. Первый аргумент функции — контейнер. Гарантируется, что по этому контейнеру можно проитерироваться с помощью стандартного цикла range-based for, и что элементы контейнера можно напечатать в поток std::cout с помощью стандартного оператора &lt;&lt;. Второй аргумент функции — строка-разделитель, которую надо печатать между элементами. В конце необходимо напечатать перевод строки \n.</p>
    <p>Пример вызова:</p>
<pre>
int main() {
  std::vector&lt;int&gt; data = {1, 2, 3};
  Print(data, ", ");  // 1, 2, 3
}
</pre>
    <p>Примечание</p>
    <p>В вашем решении должен быть только код функции Print без функции main. Подключите все необходимые для реализации библиотеки. Используйте константные ссылки для получения параметров и при итерации в цикле, чтобы избежать лишних копирований: если этого не сделать, то программа не скомпилируется.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Прежде всего определимся с заголовком функции Print. Она должна работать с любым контейнером. Проще всего будет сделать тип контейнера шаблонным параметров функции (да и название задачи на это намекает):</p>
<pre>
template &lt;typename Container&gt;
void Print(const Container& data, const std::string& delimiter);
</pre>
    <p>Сам контейнер и строку-разделитель мы будем принимать по константной ссылке, чтобы избежать лишних и ненужных копирований. Про необходимость передачи по константной ссылке даже написано в примечании к условию (это специально проверяется в тестах).</p>
    <p>Постараемся решить задачу, не предполагая ничего дополнительного о контейнере, кроме того, что сказано в условии. Гарантируется, что по контейнеру можно пройтись с помощью range-based for:</p>
<pre>
for (const auto& elem : data) {
  // ...
}
</pre>
    <p>Строку-разделитель следует печатать только между элементами. Для этого нам нужно понимать, последний ли элемент сейчас печатается. Но гораздо проще проверять, первый ли это элемент. Заведём для этого логическую переменную, изначально установленную в true, и сбросим её на первой итерации цикла.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

template &lt;typename Container&gt;
void Print(const Container& data, const std::string& delimiter) {
  bool first = true;

  for (const auto& elem : data) {
    if (!first) {
      std::cout &lt;&lt; delimiter;
    } else {
      first = false;
    }

    std::cout &lt;&lt; elem;
  }

  std::cout &lt;&lt; "\n";
}
</pre>
    <p>Решения, использующие итераторы, тоже допустимы, так как range-based for на самом деле под капотом обращается к функциям begin и end:</p>
<pre>
for (auto iter = std::begin(data); iter != std::end(data); ++it) {
  // ...
}
</pre>
    <p>Однако не следуют проверять, является ли элемент последним, с помощью такого сравнения:</p>
<pre>
if (iter == std::prev(std::end(data))) {
  // ...
}
</pre>
    <p>У однонаправленных итераторов (например, у односвязного списка forward_list) взятие prev приведёт к неопределенному поведению. По аналогичной причине это не будет работать с некоторыми реализациями unordered_set.</p>
    <p>Вместо этого можно либо написать next(iter) == end(data), либо, как в решении выше, проверять не на конец, а на начало (сравнивать iter с begin(data)):</p>
<pre>
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;string&gt;

template &lt;typename Container&gt;
void Print(const Container& data, const std::string& delimiter) {
  for (auto iter = std::begin(data); iter != std::end(data); ++iter) {
    std::cout &lt;&lt; *iter;
    if (std::next(iter) != std::end(data)) {
      std::cout &lt;&lt; delimiter;
    }
  }
  std::cout &lt;&lt; "\n";
}
</pre>
    <p>Отметим также, что первое решение скорее всего покажет большую производительность, так как компилятору будет проще оптимизировать инструкцию if над логической переменной, а процессору будет проще предугадать правильную ветку исполнения. Однако реальная разность в производительности на такой примитивной задаче вряд ли будет заметна на уровне погрешности.</p>
  </details>

  <h4>Задача «Проверка работ»</h4>

  <details>
    <summary>Условие</summary>
    <p>В университете проводится письменная контрольная работа. N студентов сдают свои работы в общую стопку, причем некоторые кладут свою работу сверху, а другие (считая, что чем позже их работу проверят, тем лучше) — снизу. Проверяются работы в том порядке, в котором лежат, начиная с верхней. Определите, чья работа будет проверена k-й по счёту.</p>

    <h4>Формат ввода</h4>
    <p>Первая строка содержит одно натуральное число N, не превосходящее 10000, — число студентов.</p>
    <p>Каждая из последующих N строк содержит фамилию студента — строку из латинских букв длиной от 2 до 10 символов, и через пробел слово top или bottom — положил этот студент свою работу сверху или снизу.</p>
    <p>Следующая строка содержит одно целое число M от 0 до 10000 — для какого числа работ нужно определить их автора.</p>
    <p>Следующие M строк содержат по одному числу xi от 1 до N — номер в стопке очередной интересующей нас работы.</p>

    <h4>Формат вывода</h4>
    <p>Выведите M строк. В i-й строке выведите фамилию студента, чья работа будет проверена xi-й по счёту.</p>

    <h4>Пример 1</h4>
<pre>
3
Ivanov top
Petrov top
Sidorov bottom
2
1
3
</pre>
<pre>
Petrov
Sidorov
</pre>

    <h4>Пример 2</h4>
<pre>
3
Ivanov top
Ivanov bottom
Ivanov top
4
1
2
3
1
</pre>
<pre>
Ivanov
Ivanov
Ivanov
Ivanov
</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Самая подходящая для нашей задачи структура данных — std::deque. В этот контейнер можно эффективно вставлять новые элементы по краям и обращаться к элементам по индексам. Будем хранить в деке имена студентов в том порядке, в котором их работы попадают в стопку. Для этого при считывании позиции top будем использовать функцию push_front, а в случае позиции bottom — функцию push_back. Обе функции в среднем работают за константное время.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;deque&gt;
#include &lt;string&gt;

int main() {
  std::deque&lt;std::string&gt; works;

  int n = 0;
  std::cin >> n;

  for (int i = 0; i &lt; n; ++i) {
    std::string name, position;
    std::cin >> name >> position;

    if (position == "top") {
      works.push_front(name);
    } else {
      works.push_back(name);
    }
  }

  int k = 0;
  std::cin >> k;
  for (int i = 0; i &lt; k; ++i) {
    int x = 0;
    std::cin >> x;
    std::cout &lt;&lt; works[x - 1] &lt;&lt; "\n";
  }
}
</pre>
  </details>
  <h4>Задача «Вагоны»</h4>

  <details>
    <summary>Условие</summary>
    <p>Вы — машинист. Вам поручено реализовать функцию void MakeTrain(), чтобы сформировать поезд из набора вагонов.</p>
    <p>У каждого вагона есть номер (помещается в int). Номера вагонов внутри состава могут повторяться. Изначально путь, на котором формируется состав, пустой. Вы должны уметь выполнять следующие команды, которые поступают в отдельных строках на входе:</p>
    <ul>
      <li>+left W — добавить вагон с номером W слева</li>
      <li>+right W — добавить вагон с номером W справа</li>
      <li>-left N — отцепить и убрать N вагонов слева</li>
      <li>-right N — отцепить и убрать N вагонов справа</li>
    </ul>
    <p>В последних двух командах N может быть больше текущей длины состава — в этом случае надо убрать весь состав целиком. Отцеплять вагоны по одному может быть долго: постарайтесь сразу отцеплять по N штук. Напечатайте через пробел номера вагонов получившегося состава, если смотреть на них слева направо. В самом конце напечатайте перевод строки.</p>
    <p>На вход подаются строки с командами в указанном формате. Всего будет не более 1 млн команд. Оформите ваше решение в функции void MakeTrain(). Эта функция должна читать данные со стандартного потока ввода и печатать их в стандартный поток вывода. Подключите все необходимые библиотеки. В вашем решении не должно быть функции main.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Для хранения последовательности вагонов нам нужен контейнер, позволяющий эффективно добавлять и удалять элементы с обоих концов. Мы знаем два таких контейнера в стандартной библиотеке - std::list и std::deque.</p>
    <p>В условии есть совет отцеплять вагоны сразу по N штук. Это намекает на то, что deque будет более подходящим контейнером: его итераторы являются итераторами произвольного доступа, а значит, можно будет быстро найти место расцепки.</p>
    <p>К тому же в задании есть нестандартные ограничения по времени. Контейнер std::list может оказаться медленнее дека, потому что он аллоцирует отдельные ячейки памяти под каждый элемент. Напротив, std::deque аллоцирует сразу большие страницы памяти.</p>
    <p>Итак, выбираем std::deque&lt;int&gt;:</p>
<pre>
#include &lt;deque&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

void MakeTrain() {
  using Wagon = int;
  std::deque&lt;Wagon&gt; train;

  std::string command;
  Wagon wagon;
  size_t k;
  while (std::cin >> command) {
    if (command == "+left") {
      std::cin >> wagon;
      train.push_front(wagon);
    } else if (command == "+right") {
      std::cin >> wagon;
      train.push_back(wagon);
    } else if (command == "-left") {
      std::cin >> k;
      k = std::min(k, train.size());
      train.erase(train.begin(), train.begin() + k);
    } else if (command == "-right") {
      std::cin >> k;
      k = std::min(k, train.size());
      train.erase(train.end() - k, train.end());
    }
  }

  for (const auto& wagon : train) {
    std::cout &lt;&lt; wagon &lt;&lt; " ";
  }
  std::cout &lt;&lt; "\n";
}
</pre>
    <p>Здесь мы используем псевдоним Wagon вместо int, чтобы в будущем можно было легко поменять тип. (В конце при выводе вагонов по-хорошему не надо было бы печатать последний пробел, но в тестах ответ проверяется с точность до пробельных символов в конце, и такое решение проходит.)</p>
    <p>Мы специально просим в этой задаче написать код в отдельной функции, чтобы в своей функции main позвать std::ios_base::sync_with_stdio(false) и ускорить ввод-вывод, так что накладные расходы на ввод-вывод данных будут минимальными.</p>
    <p>Можно сгенерировать искусственный тест, где будут случайные добавления вагонов с разных сторон, а потом — серия мелких удалений (и так несколько раз). Попробуем сравнить скорость работы этой программы для deque и для list на таком тесте с опцией компилятора -O3 (то есть, с полностью включенными оптимизациями). Оказывается, что list медленнее на 20%.</p>
    <p>Заметим, что в решении с deque отцепка вагонов по одному через pop_back или pop_front на самом деле оказывается не медленнее вызова erase с парой итераторов.</p>

    <h4>Неверные решения</h4>
    <p>Разберём два неправильных решения этой задачи. Первое — пытаться считывать данные через getline в строку, а потом отдельно разбирать её через stringstream:</p>
<pre>
std::string line;
std::string command;
Wagon wagon;
while (std::getline(std::cin, line)) {
  std::istringstream ss(line);
  ss >> command >> wagon;
  // ...
}
</pre>
    <p>Это удобно, но в данном случае сильно замедляет программу. Поток istringstream внутри хранит копию исходной строки, а на это требуются накладные расходы.</p>
    <p>Второе ошибочное решение — такое:</p>
<pre>
if (command == "+left") {
  std::cin >> wagon;
  train.push_front(wagon);
} else if (command == "+right") {
  std::cin >> wagon;
  train.push_back(wagon);
} else if (command == "-left") {
  std::cin >> k;
  for (size_t i = 0; i &lt; std::min(k, train.size()); ++i) {
    train.pop_front();
  }
} else if (command == "-right") {
  std::cin >> k;
  for (size_t i = 0; i &lt; std::min(k, train.size()); ++i) {
    train.pop_back();
  }
}
</pre>
    <p>Тут просто будет неверный ответ. Найдите ошибку самостоятельно.</p>
  </details>

  <h4>Задача «Ctrl+X, Ctrl+V»</h4>

  <details>
    <summary>Условие</summary>
    <p>Петя решил написать свой собственный текстовый редактор и просит вас помочь протестировать его прототип. На текущей стадии разработки в редакторе есть только возможность загрузить файл и выполнять с ним такие действия:</p>
    <ul>
      <li>переместить курсор на строчку вниз (Down)</li>
      <li>переместить курсор на строчку вверх (Up)</li>
      <li>вырезать текущую строку в буфер обмена (Ctrl+X)</li>
      <li>вставить строку из буфера перед текущей строкой (Ctrl+V)</li>
    </ul>
    <p>Изначально курсор находится на первой (начальной) строке.</p>
    <p>Операции Down с курсором на последней строке и Up с курсором на первой строке должны игнорироваться.</p>
    <p>Любой текстовый файл в системе заканчивается переводом строки. Поэтому последняя строка любого файла является пустой. Операция Ctrl+X на пустой строке ничего не делает.</p>
    <p>Изначально буфер редактора пустой. Операция Ctrl+X перезаписывает буфер, если в нём уже было какое-то значение. Операция Ctrl+V не очищает буфер и может быть использована несколько раз подряд. Операция Ctrl+V при пустом буфере ничего не делает.</p>
    <p>Помогите Пете протестировать его текстовый редактор. Напишите программу, которая по заданному файлу и набору команд выводит получившийся файл.</p>

    <h4>Формат ввода</h4>
    <p>Программе на вход подаётся набор строк, разделённых переносом строки. Длина каждой строки не превышает 3000 символов. Последняя строка в файле является пустой. Она означает завершение ввода файла. Других пустых строк в файле быть не может.</p>
    <p>После этого и до окончания ввода программе подаются команды Down, Up, Ctrl+X, Ctrl+V.</p>

    <h4>Формат вывода</h4>
    <p>Выведите получившийся файл построчно.</p>

    <h4>Пример 1</h4>
<pre>
program
is awesome
My
is awful

Down
Down
Down
Ctrl+X
Up
Ctrl+X
Up
Up
Ctrl+V
</pre>
<pre>
My
program
is awesome
</pre>

    <h4>Пример 2</h4>
<pre>
copy
paste

Ctrl+X
Ctrl+V
Ctrl+V
Ctrl+V
Ctrl+X
Ctrl+V
Ctrl+V
Ctrl+V
</pre>
<pre>
copy
copy
copy
paste
paste
paste
</pre>
    <p>Примечание</p>
    <p>Если условие кажется вам запутанным, попробуйте воспользоваться настоящим текстовым редактором, например Sublime. Создайте пустой файл, вставьте любой пример из условия и исполняйте заданные команды. В итоге вы должны получить точно такой же файл, как в ответе. Таким образом описанное в условии поведение в точности соответствует поведению множества настоящих текстовых редакторов.</p>
    <p>Используйте std::getline для считывания строчек файла.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Для работы со строками нам нужен контейнер для хранения данных, в котором вставка в середину возможна за константное время. При этом нам не нужно иметь произвольный доступ по индексу, так как курсор в файле перемещается последовательно. Подходящим контейнером является двусвязный список std::list.</p>
    <p>Запишем все строки (кроме последней пустой) в список. В роли курсора будет выступать итератор списка. Вспомним, что операции над списком не инвалидируют существующие итераторы.</p>
    <p>Далее будем последовательно обрабатывать команды.</p>
    <ol>
      <li>
        <h4>Команда Up.</h4>
        <p>Необходимо передвинуть итератор на одну позицию назад. Для этого можно воспользоваться конструкцией --cursor. Необходимо не забыть про случай, когда курсор уже находится на первой строке.</p>
      </li>
      <li>
        <h4>Команда Down.</h4>
        <p>Необходимо передвинуть итератор на одну позицию вперёд, воспользовавшись конструкцией ++cursor. Перед этим надо проверить, не находится ли курсор на последний строке.</p>
      </li>
      <li>
        <h4>Команда Ctrl+X.</h4>
        <p>Копируем текущее значение итератора в буфер. После этого перезаписываем курсор с помощью cursor = file.erase(cursor). Напомним, что erase возвращает итератор на следующий элемент в списке, что соответствует требуемому поведению.</p>
      </li>
      <li>
        <h4>Команда Ctrl+V.</h4>
        <p>Проверяем, что буфер не пуст, и используем функцию insert.</p>
      </li>
    </ol>
<pre>
#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;string&gt;
#include &lt;utility&gt;

int main() {
  std::list&lt;std::string&gt; file;

  while (true) {
    std::string line;
    std::getline(std::cin, line);

    if (line.empty()) {
      break;
    }

    file.push_back(line);
  }

  auto cursor = file.begin();
  std::string buffer;

  std::string command;
  while (std::cin >> command) {
    if (command == "Up") {
      if (cursor == file.begin()) {
        continue;
      }
      --cursor;
    } else if (command == "Down") {
      if (cursor == file.end()) {
        continue;
      }
      ++cursor;
    } else if (command == "Ctrl+X") {
      if (cursor == file.end()) {
        continue;
      }
      buffer = std::move(*cursor);
      cursor = file.erase(cursor);
    } else if (command == "Ctrl+V") {
      if (buffer.empty()) {
        continue;
      }
      file.insert(cursor, buffer);
    }
  }

  for (const auto &x: file) {
    std::cout &lt;&lt; x &lt;&lt; "\n";
  }
}
</pre>
    <p>Обратите внимание, что при вырезании строки в буфер мы используем функцию std::move. Она позволяет забрать владение строкой, которая вот-вот будет удалена из списка, и сэкономить на её копировании. Подробнее про move-семантику рассказано в параграфе «Жизненный цикл объекта».</p>
  </details>

  <h4>Задача «Ctrl+X, Ctrl+V - 2»</h4>

  <details>
    <summary>Условие</summary>
    <p>Эта задача — продолжение предыдущей задачи Ctrl+X, Ctrl+V. В качестве основы вы можете взять код оттуда.</p>
    <p>Петя продолжает разработку своего текстового редактора. На этот раз добавилось еще одна операция — зажать клавишу Shift (Shift).</p>
    <p>Операции Up и Down при зажатой клавише Shift выделяют строки в текстовом редакторе. Если курсор находится на строке n, то после операций Shift, Down, Down выделенными окажутся строки n и n+1.</p>
    <p>Операция Ctrl+X вырезает выделенные строки из файла в буфер. Операция Ctrl+V копирует строки из буфера, заменяя выделенные строки в файле.</p>
    <p>Операции Ctrl+X и Ctrl+V сбрасывают выделение после исполнения и отпускают клавишу Shift. Если при исполнении этих операций в файле не выделена ни одна строка, поведение должно соответствовать предыдущей задаче Ctrl+X, Ctrl+V.</p>

    <h4>Формат ввода</h4>
    <p>Программе на вход подаётся набор строк, разделённых переносом строки. Длина каждой строки не превышает 3000 символов. Последняя строка в файле является пустой. Она означает завершение ввода файла. Других пустых строк в файле быть не может.</p>
    <p>После этого и до окончания ввода программе подаются команды Down, Up, Ctrl+X, Ctrl+V, Shift.</p>

    <h4>Формат вывода</h4>
    <p>Выведите получившийся файл построчно.</p>

    <h4>Пример</h4>
<pre>
My
program
is
awful
bad
poor
wrong
awesome

Down
Down
Down
Shift
Down
Down
Down
Down
Ctrl+X
</pre>
<pre>
My
program
is
awesome
</pre>
    <p>Примечание</p>
    <p>Для вырезания строк из файла в буфер удобно использовать функцию splice. Разберитесь самостоятельно по документации, как она устроена.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Как и рекомендуется в условии, возьмём за основу код из предыдущей задачи. Однако теперь в качестве буфера у нас будет не одна строка, а лист строк.</p>
    <p>Также нам понадобятся дополнительные переменные для обработки нажатия клавиши Shift:</p>
    <ul>
      <li>В логической переменной shiftPressed будем поддерживать текущее состояние клавиши: true если клавиша нажата и false если нет.</li>
      <li>В переменной shift будем хранить указатель на строчку, на которой произошло нажатие клавиши Shift.</li>
      <li>В переменной shiftOffset будем поддерживать разность номера строки где сейчас находится курсор и номера
        строки на которой была нажата клавиша Shift.</li>
    </ul>
    <p>Далее будем последовательно обрабатывать команды.</p>
    <ol>
      <li>
        <h4>Команда Up.</h4>
        <p>Добавим проверку нажата ли сейчас клавиша Shift. Если нажата – уменьшим shiftOffset на единицу. Иначе передвинем указатель shift вместе с курсором.</p>
      </li>
      <li>
        <h4>Команда Down.</h4>
        <p>Аналогично команде Up, только здесь мы будем увеличивать shiftOffset на единицу.</p>
      </li>
      <li>
        <h4>Команда Shift.</h4>
        <p>Единственное, что мы должны сделать при вызове этой команды – поставить переменной shiftPressed значение true.</p>
      </li>
      <li>
        <h4>Команда Ctrl+X.</h4>
        <p>Воспользуемся функцией .splice, которая позволит нам эффективно и без копирования «вырезать» элементы из одного листа и вставить их в другой. Достаточно лишь передать этой функции два итератора cursor и shift. Воспользуемся переменной shiftOffset чтобы понять, какой из этих двух итераторов должен идти первым. Также нужно корректно обработать операцию Ctrl+X без зажатой клавиши Shift (cursor == shift). В таком случае необходимо заранее сделать копию курсора, иначе после операции .splice старый курсор будет ссылаться на элемент в буфере, а не в файле. В конце не забудем «обнулить» все переменные, связанные с клавишей Shift.</p>
      </li>
      <li>
        <h4>Команда Ctrl+V.</h4>
        <p>Сначала сделаем операцию .erase, аналогично определяя порядок итераторов с помощью shiftOffset. После сделаем .insert, передав ему итераторы на наш буфер. В конце также не забудем обнулить Shift переменные.</p>
      </li>
    </ol>
    <p>Итоговое решение:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;string&gt;

int main() {
  std::list&lt;std::string&gt; file;

  while (true) {
    std::string line;
    std::getline(std::cin, line);

    if (line.empty()) {
      break;
    }

    file.push_back(line);
  }

  auto cursor = file.begin();

  std::list&lt;std::string&gt; buffer;

  bool shiftPressed = false;
  int shiftOffset = 0;
  auto shift = file.begin();

  std::string command;
  while (std::cin >> command) {
    if (command == "Up") {
      if (cursor == file.begin()) {
        continue;
      }

      --cursor;
      if (!shiftPressed) {
        shift = cursor;
      } else {
        --shiftOffset;
      }
    } else if (command == "Down") {
      if (cursor == file.end()) {
        continue;
      }

      ++cursor;
      if (!shiftPressed) {
        shift = cursor;
      } else {
      ++shiftOffset;
      }
    } else if (command == "Ctrl+X") {
      if (shift == cursor && cursor == file.end()) {
        continue;
      }

      buffer.clear();

      if (shift == cursor) {
        auto toSplice = cursor;
        cursor = std::next(cursor);
        buffer.splice(buffer.begin(), file, toSplice);
      } else if (shiftOffset &lt; 0) {
        buffer.splice(buffer.begin(), file, cursor, shift);
        cursor = shift;
      } else {
        buffer.splice(buffer.begin(), file, shift, cursor);
      }

      shiftPressed = false;
      shift = cursor;
      shiftOffset = 0;
    } else if (command == "Ctrl+V") {
      if (buffer.empty()) {
        continue;
      }

      if (shiftOffset &lt; 0) {
        cursor = file.erase(cursor, shift);
      } else if (shiftOffset > 0) {
        cursor = file.erase(shift, cursor);
      }

      file.insert(cursor, buffer.begin(), buffer.end());

      shiftPressed = false;
      shift = cursor;
      shiftOffset = 0;
    } else if (command == "Shift") {
      shiftPressed = true;
    }
  }

  for (const auto &x: file) {
    std::cout &lt;&lt; x &lt;&lt; "\n";
  }
}
</pre>
  </details>

  <h3>Параграф «Ассоциативные контейнеры»</h3>

  <h4>Задача «Встречалось ли число раньше?»</h4>

  <details>
    <summary>Условие</summary>
    <p>На вход подаётся последовательность целых чисел. Для каждого числа выведите в отдельной строке слово YES, если это число ранее встречалось в последовательности, и NO, если не встречалось.</p>

    <h4>Формат ввода</h4>
    <p>Вводится список чисел. Все числа списка находятся на одной строке и разделены пробелом. Каждое число представимо типом int.</p>

    <h4>Формат вывода</h4>
    <p>Выведите ответ на задачу.</p>

    <h4>Пример</h4>
    <code>1 2 1 2 2 1 6</code>
<pre>
NO
NO
YES
YES
YES
YES
NO
</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Эту задачу удобно решить через std::set, но так как нам не важен порядок элементов, то лучше будет использовать std::unordered_set. Будем сохранять прочитанные числа и выводить каждый раз YES, если это число уже есть в нашем множестве, и NO в противном случае. Не забудем сохранить само число во множестве.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;unordered_set&gt;

int main() {
  std::unordered_set&lt;int&gt; numbers;
  int number;
  while (std::cin >> number) {
    if (numbers.contains(number)) {
      std::cout &lt;&lt; "YES\n";
    } else {
      std::cout &lt;&lt; "NO\n";
      numbers.insert(number);
    }
  }
}
</pre>
    <p>Можно было бы вместо вызова contains воспользоваться тем, что функция insert возвращает пару из итератора и успешности вставки:</p>
<pre>
if (numbers.insert(number).second) {
  std::cout &lt;&lt; "NO\n";
} else {
  std::cout &lt;&lt; "YES\n";
}
</pre>
  </details>

  <h4>Задача «Общие буквы»</h4>

  <details>
    <summary>Условие</summary>
    <p>Вам даны слова. Выведите в алфавитном порядке список общих букв всех слов.</p>

    <h4>Формат ввода</h4>
    <p>На вход поступают слова (по одному в строке), состоящие из маленьких латинских букв алфавита. Длина слов не превосходит 100 символов, а количество слов не превосходит 1000.</p>

    <h4>Формат вывода</h4>
    <p>Выведите в алфавитном порядке без пробелов список букв, которые присутствуют в каждом слове.</p>

    <h4>Пример 1</h4>
<pre>
apple
peach
</pre>
    <code>aep</code>

    <h4>Пример 2</h4>
<pre>
alpha
beta
gamma
delta
epsilon
</pre>
    <code></code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Воспользуемся контейнером std::map&lt;char, int&gt;. Будем для каждой буквы подсчитывать число слов, в которых эта буква встретилась. Затем напечатаем все буквы, которые встретились во всех словах.</p>
    <p>Если какая-то буква повторяется в слове, то важно не посчитать её дважды. Для этого сначала буквы всех слов сложим в set или unordered_set.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;string&gt;

int main() {
  std::map&lt;char, int&gt; counter;
  std::string word;
  int wordsCount = 0;
  while (std::cin >> word) {
    ++wordsCount;
    std::set&lt;char&gt; letters(word.begin(), word.end());
    for (char c : letters) {
      ++counter[c];
    }
  }
  for (auto [c, freq] : counter) {
    if (freq == wordsCount) {
      std::cout &lt;&lt; c;
    }
  }
  std::cout &lt;&lt; "\n";
}
</pre>
  </details>

  <h4>Задача «Файловая система»</h4>

  <details>
    <summary>Условие</summary>
    <p>Дан список всех файлов в некоторой файловой системе. Необходимо вывести все непустые директории этой файловой системы в лексикографическом порядке.</p>
    <p>Гарантируется, что все пути начинаются от корня файловой системы. Все пути состоят из слешей (/), латинских символов, цифр и точек. Два слеша никогда не стоят подряд.</p>

    <h4>Формат ввода</h4>
    <p>На вход подаются строки, описывающие пути ко всем файлам в системе. Каждый путь содержится в отдельной строке. Число строк не превосходит 10000.</p>

    <h4>Формат вывода</h4>
    <p>Выведите все непустые директории в этой файловой системе в лексикографическом порядке. Каждый путь должен начинаться со слеша и заканчиваться слешом.</p>

    <h4>Пример 1</h4>
<pre>
/docs/README.txt
/docs/LICENSE.txt
/boot/grub
/init
</pre>
<pre>
/
/boot/
/docs/
</pre>

    <h4>Пример 2</h4>
<pre>
/root/test.cpp
/root/tests/01
/root/tests/01.a
/bin/bash
</pre>
<pre>
/
/bin/
/root/
/root/tests/
</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Воспользуемся контейнером set. Если нам дан путь к некоторому файлу, то все его родительские директории заведомо непустые. Надо будет аккуратно вырезать из этого пути все подстроки, которые заканчиваются на /, и сложить их в set.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;string&gt;

int main() {
  std::set&lt;std::string&gt; dirs;
  std::string path;
  while (std::getline(std::cin, path)) {
    for (size_t i = 0; i != path.size(); ++i) {
      if (path[i] == '/') {
        dirs.insert(path.substr(0, i + 1));
      }
    }
  }
  for (const auto& dir : dirs) {
    std::cout &lt;&lt; dir &lt;&lt; "\n";
  }
}
</pre>
  </details>

  <h4>Задача «Предметный указатель»</h4>

  <details>
    <summary>Условие</summary>
    <p>Профессор написал научную книгу и составил для неё предметный указатель. Это список ключевых слов, для каждого из которых указана страница, на которой это слово встречается. Теперь профессор хочет для каждой страницы выписать в алфавитном порядке все ключевые слова, которые на эту страницу попали (если такие вообще есть). Помогите профессору решить эту задачу.</p>

    <h4>Формат ввода</h4>
    <p>Сначала задано натуральное число n, не превосходящее 1000 — количество слов, которое требуется обработать. Далее идут n строк. В каждой строке сначала записано ключевое слово. Затем идёт натуральное число, также не превосходящее 1000, — номер страницы. Ключевые слова состоят из латинских букв, не бывают пустыми и по длине не превосходят 16 символов. Слова в списке, конечно, могут повторяться.</p>

    <h4>Формат вывода</h4>
    <p>Выпишите в порядке возрастания все страницы, на которых присутствуют ключевые слова. После каждого номера страницы через пробел выпишите в алфавитном порядке сами эти слова. Если на какой-то странице слово встретилось несколько раз, то повторять его не нужно. Завершающего пробела в конце строк быть не должно.</p>

    <h4>Пример</h4>
<pre>
5
derivative 10
function 2
function 10
function 10
limit 7
</pre>
<pre>
2 function
7 limit
10 derivative function
</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Воспользуемся ассоциативным контейнером, который будет номерам страниц сопоставлять множества слов на этой странице. Так как в ответе надо вывести страницы по возрастанию, а слова — по алфавиту, то нам подойдут упорядоченные контейнеры std::map и std::set.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;string&gt;

int main() {
  std::map&lt;int, std::set&lt;std::string&gt; &gt; index;

  int n;
  std::cin >> n;
  for (int i = 0; i &lt; n; ++i) {
    std::string word;
    int page;
    std::cin >> word >> page;
    index[page].insert(word);
  }

  for (const auto& [page, words] : index) {
    std::cout &lt;&lt; page;
    for (const auto& word : words) {
      std::cout &lt;&lt; " " &lt;&lt; word;
    }
    std::cout &lt;&lt; "\n";
  }
}
</pre>
  </details>

  <h4>Задача «Символьные n-граммы»</h4>

  <details>
    <summary>Условие</summary>
    <p>Будем называть символьной n-граммой последовательность из n последовательно идущих символов в одном слове в тексте. Для данного числа n подсчитайте суммарное количество каждой  n-граммы в тексте.</p>

    <h4>Формат ввода</h4>
    <p>В первой строке заданы два числа: m — число слов в тексте (от 1 до 100000) и n — длина n-граммы (от 1 до 5). Далее идет m слов. Можно считать, что слова отделены пробелами или переносами строк. Обработку пунктуации и регистра реализовывать не нужно. Читайте слова просто через std::cin >> word.</p>

    <h4>Формат вывода</h4>
    <p>Выведите все n-граммы, отсортированные по убыванию частоты, а в случае равных частот — лексикографически (по алфавиту). Для каждой n-граммы напечатайте также её частоту (смотрите формат в примере).</p>

    <h4>Пример</h4>
<pre>
6 2
to be or not to be
</pre>
<pre>
be - 2
to - 2
no - 1
or - 1
ot - 1
</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Задача похожа на классическую задачу про подсчёт частоты слов в тексте, только вместо слов надо будет подсчитывать подстроки слов длины N.</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;tuple&gt;
#include &lt;unordered_map&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

int main() {
  size_t m, n;
  std::cin >> m >> n;

  std::unordered_map&lt;std::string, int&gt; freqs;

  for (size_t i = 0; i != m; ++i) {
    std::string word;
    std::cin >> word;
    for (size_t j = n; j &lt;= word.size(); ++j) {
      ++freqs[word.substr(j - n, n)];
    }
  }

  std::vector&lt;std::pair&lt;std::string, int&gt; &gt; sorted(freqs.begin(), freqs.end());
  std::sort(
    sorted.begin(),
    sorted.end(),
    [](const auto& p1, const auto& p2) {
      return std::tie(p2.second, p1.first) &lt; std::tie(p1.second, p2.first);
    }
  );

  for (const auto& [word, freq] : sorted) {
    std::cout &lt;&lt; word &lt;&lt; " - "
    &lt;&lt; freq &lt;&lt; "\n";
  }
}
</pre>
    <p>Пожалуй, самый нетривиальный фрагмент здесь — выделение подстрок:</p>
<pre>
for (size_t j = n; j &lt;= word.size(); ++j) {
  ++freqs[word.substr(j - n, n)];
}
</pre>
    <p>Здесь j пробегает все позиции за последним символом подстроки. Соотвественно, j - n — всевозможные начальные позиции подстрок длины n. Так организованный цикл защищён от случайных переполнений и вычитаний большего числа из меньшего в беззнаковом типе size_t. В таких конструкциях всегда полезно проверять себя на "крайних" случаях (например, когда n совпадает с word.size()).</p>
    <p>Если известно, что n мало по сравнению со средним размером слова, то более выгодным по скорости может оказаться другое решение: сначала сохраняем в std::unordered_map все слова, а сами n-граммы строим как std::unordered_map&lt;std::string_view, int&gt;:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;string_view&gt;
#include &lt;tuple&gt;
#include &lt;unordered_map&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

int main() {
  size_t m, n;
  std::cin >> m >> n;

  std::unordered_map&lt;std::string, int&gt; words;
  words.reserve(m);
  for (size_t i = 0; i != m; ++i) {
    std::string word;
    std::cin >> word;
    ++words[word];
  }

  std::unordered_map&lt;std::string_view, int&gt; freqs;

  for (const auto& [word, freq] : words) {
    std::string_view sv = word;
    for (size_t j = n; j &lt;= sv.size(); ++j) {
      freqs[sv.substr(j - n, n)] += freq;
    }
  }

  std::vector&lt;std::pair&lt;std::string_view, int>> sorted(freqs.begin(), freqs.end());
  std::sort(
    sorted.begin(),
    sorted.end(),
    [](const auto& p1, const auto& p2) {
      return std::tie(p2.second, p1.first) &lt; std::tie(p1.second, p2.first);
    }
  );

  for (const auto& [word, freq] : sorted) {
    std::cout &lt;&lt; word &lt;&lt; " - "
    &lt;&lt; freq &lt;&lt; "\n";
  }
}
</pre>
  </details>

  <h3>Параграф «Алгоритмы»</h3>

  <h4>Задача «Удвоить вектор»</h4>

  <details>
    <summary>Условие</summary>
    <p>Требуется написать шаблонную функцию Dublicate, которая получает на вход вектор и дублирует все его элементы в конце вектора. Например, из вектора с элементами 1, 2, 3 должен получиться вектор с элементами 1, 2, 3, 1, 2, 3. Вася написал вот такую реализацию, которая почему-то не работает:</p>
<pre>
#include &lt;vector&gt;

template &lt;typename T&gt;
void Dublicate(std::vector&lt;T&gt;& v) {
  for (auto it = v.begin(); it != v.end(); ++it) {
    v.push_back(*it);
  }
}
</pre>
    <p>Вам надо исправить код Васи.</p>
    <p>Примечания</p>
    <p>Сдайте в систему только исправленный код функции Dublicate без функции main. Подключите все необходимые для вашей реализации библиотеки. Заголовок функции Вася написал правильно, в этом можете не сомневаться.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Решение Васи не работает, так как в процессе вставки итераторы вектора инвалидируются и программа попадает в неопределённое поведение. Самый простой способ исправить проблему — переписать цикл через индексы. При этом исходный размер вектора надо запомнить в начале цикла. Это можно сделать прямо в секции инициализации цикла for:</p>
<pre>
#include &lt;vector&gt;

template &lt;typename T&gt;
void Dublicate(std::vector&lt;T&gt;& v) {
  for (size_t n = v.size(), i = 0; i &lt; n; ++i) {
    v.push_back(v[i]);
  }
}
</pre>
    <p>Другой способ — зарезервировать в векторе заранее удвоенное число элементов. Тогда при вставке не будет происходить реаллокаций, и итераторы не будут инвалидироваться. Исходное решение заработает. Но его всё же удобнее переписать через алгоритм copy:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;vector&gt;

template &lt;typename T&gt;
void Dublicate(std::vector&lt;T&gt;& v) {
  v.reserve(v.size() * 2);
  std::copy(v.begin(), v.end(), std::back_inserter(v));
}
</pre>
  </details>

  <h3>Задача «Алгоритм unique»</h3>
</article>


<!-- 4.1 Классы -->
<article class="article">
  <div class="anchor" id="p4.1"></div>
  <h2>4 Идиомы C++</h2>
  <h3>4.1 Классы</h3>
</article>


<!-- 4.2 Шаблонные классы -->
<article class="article">
  <div class="anchor" id="p4.2"></div>
  <h3>4.2 Шаблонные классы</h3>
</article>


<!-- 4.3 Жизненный цикл объекта -->
<article class="article">
  <div class="anchor" id="p4.3"></div>
  <h3>4.3 Жизненный цикл объекта</h3>
</article>


<!-- 4.4 Наследование и полиморфизм -->
<article class="article">
  <div class="anchor" id="p4.4"></div>
  <h3>4.4 Наследование и полиморфизм</h3>
</article>


<!-- 4.5 Обработка исключений -->
<article class="article">
  <div class="anchor" id="p4.5"></div>
  <h3>4.5 Обработка исключений</h3>
</article>


<!-- 4.6 Идиома RAII и умные указатели -->
<article class="article">
  <div class="anchor" id="p4.6"></div>
  <h3>4.6 Идиома RAII и умные указатели</h3>
</article>


<!-- 4.7 Разбор задач к главе «Идиомы C++» -->
<article class="article">
  <div class="anchor" id="p4.7"></div>
  <h3>4.7 Разбор задач к главе «Идиомы C++»</h3>
</article>



<!-- 5.1 Как работать с системой проверки заданий -->
<article class="article">
  <div class="anchor" id="p5.1"></div>
  <h2>5 Приложение</h2>
  <h3>5.1 Как работать с системой проверки заданий</h3>
</article>


<!-- 5.2 Как пользоваться хендбуком -->
<article class="article">
  <div class="anchor" id="p5.2"></div>
  <h3>5.2 Как пользоваться хендбуком</h3>
</article>



