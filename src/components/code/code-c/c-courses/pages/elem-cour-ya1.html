<article class="article">
  <h1>Яндекс Образования. Хендбук. Основы С++</h1>
  <p>Конспект курса</p>
  <p><a href="https://education.yandex.ru/handbook/cpp" target="_blank">https://education.yandex.ru/handbook/cpp</a></p>
  <p>Авторы: Алексей Зобнин (Яндекс), Владимир Кузнецов (Яндекс), Артём Брустовецкий (Clever Inc. (Kahoot)).</p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
    <a href="#p1.1">1 Введение</a>
    <br><a href="#p1.1">1.1 Введение</a>
  </p>

  <p>
    <a href="#p2.1">2 Базовые конструкции C++</a>
    <br><a href="#p2.1">2.1 Первые шаги</a>
    <br><a href="#p2.2">2.2 Типы данных</a>
    <br><a href="#p2.3">2.3 Ветвления и циклы</a>
    <br><a href="#p2.4">2.4 Векторы и строки</a>
    <br><a href="#p2.5">2.5 Составные типы данных</a>
    <br><a href="#p2.6">2.6 Ссылки, указатели, константность</a>
    <br><a href="#p2.7">2.7 Функции</a>
    <br><a href="#p2.8">2.8 Шаблоны</a>
    <br><a href="#p2.9">2.9 Разбор задач к главе «Базовые конструкции C++»</a>
  </p>

  <p>
    <a href="#p3.1">3 Стандартная библиотека C++</a>
    <br><a href="#p3.1">3.1 Последовательные контейнеры</a>
    <br><a href="#p3.2">3.2 Ассоциативные контейнеры</a>
    <br><a href="#p3.3">3.3 Алгоритмы</a>
    <br><a href="#p3.4">3.4 Адаптеры и представления</a>
    <br><a href="#p3.5">3.5 Разбор задач к главе «Стандартная библиотека C++»</a>
  </p>

  <p>
    <a href="#p4.1">4 Идиомы C++</a>
    <br><a href="#p4.1">4.1 Классы</a>
    <br><a href="#p4.2">4.2 Шаблонные классы</a>
    <br><a href="#p4.3">4.3 Жизненный цикл объекта</a>
    <br><a href="#p4.5">4.4 Наследование и полиморфизм</a>
    <br><a href="#p4.4">4.5 Обработка исключений</a>
    <br><a href="#p4.6">4.6 Идиома RAII и умные указатели</a>
    <br><a href="#p4.7">4.7 Разбор задач к главе «Идиомы C++»</a>
  </p>

  <p>
    <a href="#p5.1">5 Приложение</a>
    <br><a href="#p5.1">5.1 Как работать с системой проверки заданий</a>
    <br><a href="#p5.2">5.2 Как пользоваться хендбуком</a>
  </p>

</article>


<!-- 1.1 Введение -->
<article class="article">
  <div class="anchor" id="p1.1"></div>
  <h2>1 Введение</h2>
  <h3>1.1 Введение</h3>

  <p>Перед вами учебник по основам языка C++. При его создании мы вдохновлялись специализацией «Искусство разработки на современном C++» на «Курсере», созданной при поддержке Яндекса, и курсом «Основы и методология программирования», который читался в 2014–2021 годах на факультете компьютерных наук ВШЭ.</p>

  <p>Языку C++ почти 40 лет, но он по-прежнему очень актуален и востребован. Он оказал огромное влияние на индустрию и на другие языки. C++ был разработан Бьярне Страуструпом в начале 1980-х годов как расширение языка C (и даже изначально назывался «Си с классами»).</p>

  <p>Однако для изучения C++ совсем не обязательно знать C. Тем не менее мы предполагаем, что вы знакомы с основами информатики и владеете каким-либо языком программирования на уровне школьной программы — например, языком Python.</p>

  <p>Впрочем, C++ во многом полностью противоположен Python:</p>
  <ul>
    <li>это компилируемый, а не интерпретируемый язык;</li>
    <li>С++ — язык со статической, а не динамической типизацией;</li>
    <li>в C++ возможно ручное управление памятью (в отличие от автоматической сборки мусора).</li>
  </ul>

  <p>Чтобы исходный код программы на C++ превратился в исполняемый файл для конкретной архитектуры процессора, программу нужно скомпилировать. Существует несколько популярных компиляторов C++:</p>
  <ul>
    <li>GNU Compiler Collection (GCC);</li>
    <li>Clang — построен поверх инфраструктуры LLVM;</li>
    <li>Microsoft Visual C++ (MSVC) — входит в состав Microsoft Visual Studio;</li>
    <li>Intel C++ Compiler.</li>
  </ul>

  <p>Мы будем использовать в примерах и при проверке задач компилятор Clang 16-й версии.</p>

  <p>С 1998 года международный комитет по стандартизации C++ выпускает стандарты — версии языка, в которых описываются его возможности. В первую очередь это руководства для создателей компиляторов, но при возникновении спорных моментов всегда полезно обратиться к стандарту. Мы будем ориентироваться на стандарт C++20, а по ссылке можно ознакомиться с черновиком будущего стандарта. Важно понимать, что стандарт определяет лишь общие требования и не фиксирует детали реализации, которые в разных компиляторах могут отличаться.</p>

  <p>Чтобы проверить, поддерживает ли ваша версия компилятора ту или иную особенность C++, советуем пользоваться специальной таблицей.</p>

  <p>При изучении вам будут полезны следующие англоязычные ресурсы:</p>
  <ul>
    <li>cppreference.com — онлайн-документация по C++;</li>
    <li>isocpp.org — сайт Standard C++ Foundation;</li>
    <li>C++ Core Guidelines — гайдлайны по C++ от Бьярне Страуструпа и Герба Саттера;</li>
    <li>godbolt.org — Compiler Explorer, онлайн-компилятор;</li>
    <li>learncpp.com — современный учебник по C++;</li>
    <li>hacking C++ — наглядный справочник по C++ с картинками и инфографикой.</li>
  </ul>

  <p>В тексте мы будем часто ссылаться на англоязычную версию cppreference.com и на английскую «Википедию».</p>

  <p>Написать программу для C++ можно в любом текстовом редакторе, но удобнее пользоваться средой разработки (IDE). IDE включают редактор кода с подсветкой синтаксиса, а также позволяют компилировать, запускать и отлаживать программы.</p>

  <p>Примеры IDE:</p>
  <ul>
    <li>Microsoft Visual Studio Community</li>
    <li>Eclipse CDT</li>
    <li>Code::Blocks</li>
    <li>Qt Creator</li>
    <li>Xcode</li>
  </ul>

  <p>Мы рассчитываем, что вы сможете самостоятельно разобраться с настройкой и использованием среды разработки, и не будем заострять на этом внимание. В наших примерах мы будем запускать компилятор из консоли.</p>

  <p>К нашему учебнику прилагается набор задач по соответствующим темам. Вы можете сдавать их в автоматическую проверяющую систему. В одних задачах требуется написать полноценную программу, а в других — сдать только код функции или класса. Обратите внимание, что ко всем задачам имеются разборы с авторскими решениями. Найти разборы вы можете в конце глав.</p>

  <p>Ho прежде чем мы двинемся дальше — небольшое объявление: для этого хендбука у нас есть коммьюнити студентов. В нём можно найти единомышленников, обсудить материалы и задания. Вступить в него можно по <a href="https://t.me/handbook_cpp">ссылке</a>. А чтобы быть в курсе обновлений хендбука — советуем подписаться на рассылку.</p>
</article>


<!-- 2.1 Первые шаги -->
<article class="article">
  <div class="anchor" id="p2.1"></div>
  <h2>2 Базовые конструкции C++</h2>
  <h3>2.1 Первые шаги</h3>

  <p>В этом параграфе мы напишем первую программу на C++ и научимся печатать и считывать с клавиатуры строки и числа.</p>

  <h4>Функция main</h4>
  <p>Пожалуй, самая простая и короткая программа на C++ — это программа, которая ничего не делает. Она выглядит так:</p>
<pre>
int main() {
  return 0;
}
</pre>
  <p>Здесь определяется функция с именем main, которая не принимает никаких аргументов (внутри круглых скобок ничего нет) и не выполняет никаких содержательных команд. В каждой программе на C++ должна быть ровно одна функция main — с неё начинается выполнение программы.</p>

  <p>У функции указан тип возвращаемого значения int (целое число), и она возвращает 0 — в данном случае это сообщение для операционной системы, что программа выполнилась успешно. И наоборот, ненулевой код возврата означает, что при выполнении возникла ошибка (например, программа получила некорректные входные данные).</p>

  <p>Для функции main разрешается не писать завершающий return 0, чем мы и будем пользоваться далее для краткости. Поэтому самую короткую программу можно было бы написать вот так:</p>
  <code>int main() {}</code>

  <h4>Hello, world!</h4>
  <p>Соблюдая традиции, напишем простейшую программу на C++ — она выведет приветствие в консоль:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  std::cout &lt;&lt; "Hello, world!\n";
}
</pre>
  <p>Разберём её подробнее.</p>

  <p>Директива #include &lt;iostream&gt; подключает стандартный библиотечный заголовочный файл для работы с потоками ввода-вывода (input-output streams). Для печати мы используем поток вывода std::cout, где cout расшифровывается как character output, то есть «символьный вывод».</p>

  <p>В теле функции main мы передаём в std::cout строку Hello, world! с завершающим переводом строки \n. В зависимости от операционной системы \n будет преобразован в один или в два управляющих байта с кодами 0A или 0D 0A соответственно.</p>

  <p>Инструкции внутри тела функции завершаются точками с запятой.</p>

  <h4>Компиляция из командной строки</h4>
  <p>Вы можете запустить эту программу из какой-нибудь IDE. Мы же покажем, как собрать её в консоли Linux с помощью компилятора clang++.</p>

  <p>Пусть файл с программой называется hello.cpp. Запустим компилятор:</p>
  <code>$ clang++ hello.cpp -o hello</code>
  <p>В результате мы получим исполняемый файл с именем hello, который теперь можно просто запустить. Он напечатает на экране ожидаемую фразу:</p>
<pre>
$ ./hello
Hello, world!
</pre>
  <p>Если опцию -o не указать, то сгенерированный исполняемый файл будет по умолчанию назван a.out. В дальнейшем для простых примеров мы будем использовать краткую форму записи команды:</p>
<pre>
$ clang++ hello.cpp && ./a.out
Hello, world!
</pre>
  <p>С её помощью мы компилируем программу и в случае успеха компиляции сразу же запускаем.</p>

  <h4>Комментарии</h4>
  <p>Комментарии — это фрагменты программы, которые игнорируются компилятором и предназначены для программиста. В C++ есть два вида комментариев — однострочные и многострочные:</p>
<pre>
int main() {  // однострочный комментарий продолжается до конца строки

/* Пример
   многострочного
   комментария */
}
</pre>
  <p>Мы будем использовать комментарии в примерах кода для пояснений, а в реальных программах ими лучше не злоупотреблять.</p>

  <p>Хорошо: комментировать, что делает библиотека, функция или класс или почему этот код написан именно так.</p>

  <p>Плохо: комментировать, что происходит на отдельных строчках. Это признак того, что код можно написать лучше.</p>

  <h4>Библиотеки и заголовочные файлы</h4>
  <p>Библиотека — это код, который можно переиспользовать в разных программах. В стандарт языка C++ входит спецификация так называемой стандартной библиотеки, которая поставляется вместе с компилятором. Она содержит различные структуры данных (контейнеры), типовые алгоритмы, средства ввода-вывода и т. д. Конструкции из этой библиотеки предваряются префиксом std::, который обозначает пространство имён.</p>

  <p>Чтобы воспользоваться теми или иными библиотечными конструкциями, в начале программы надо подключить нужные заголовочные файлы. Так, в программе, которая печатала Hello, world!, нам уже встречался заголовочный файл iostream и конструкция std::cout из стандартной библиотеки.</p>

  <p>Для C++ существует также множество сторонних библиотек. Наиболее известной коллекцией сторонних библиотек для C++ является Boost.</p>

  <h4>Ошибки компиляции</h4>
  <p>Перед запуском программу необходимо скомпилировать. Компилятор проверяет корректность программы и генерирует исполняемый файл. Во время компиляции компилятор может обнаружить синтаксические ошибки.</p>

  <p>Рассмотрим пример такой программы:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  cout &lt;&lt; "Hello, world\n"
</pre>
  <p>Первая ошибка — вместо std::cout мы написали cout. Вторая ошибка — не поставили точку запятой после "Hello, world!\n". Наконец, третья – не закрыли фигурную скобку с телом функции.</p>

  <p>Ошибки компиляции (compile errors) следует отличать от возможных ошибок времени выполнения (runtime errors), которые происходят после запуска программы и, как правило, зависят от входных данных, неизвестных во время компиляции.</p>

  <h4>Отступы и оформление кода</h4>
  <p>Фрагменты программы на C++ могут быть иерархически вложены друг в друга. На верхнем уровне находятся функции, внутри них написаны их тела, в теле могут быть составные операторы, и так далее.</p>

  <p>Среди программистов есть соглашение — писать внутренние блоки кода с отступами вправо: компилятор полностью игнорирует эти отступы, а код читать удобнее. Мы будем использовать отступы в четыре пробела. Также мы будем придерживаться стиля оформления кода, принятого в Яндексе. Имена переменных мы будем писать с маленькой буквы, имена функций и классов — с большой (если речь не идёт о конструкциях стандартной библиотеки, где действуют другие соглашения).</p>

  <h4>Переменные</h4>
  <p>Любая содержательная программа так или иначе обрабатывает данные в памяти. Переменная — это именованный блок данных определённого типа. Чтобы определить переменную, нужно указать её тип и имя. В общем виде это выглядит так:</p>
  <code>Type name;</code>
  <p>где Type — конкретный тип данных (например, строка или число), а name — имя переменной. Имена переменных должны состоять из латинских букв, цифр и знаков подчёркивания и не должны начинаться с цифры. Также можно в одной строке определить несколько переменных одного типа:</p>
  <code>Type name1, name2, name3;</code>
  <p>Например:</p>
<pre>
// библиотека, в которой
// определён тип std::string
#include &lt;string&gt;

int main() {
  // Определяем переменную value
  // целочисленного типа int
  int value;

  // Определяем переменные name и surname
  // типа std::string (текстовая строка)
  std::string name, surname;
}
</pre>
  <p>В этом примере мы используем встроенный в язык тип int (от слова integer — целое число) и поставляемый со стандартной библиотекой тип std::string. (Можно было бы использовать для строк встроенный тип с массивом символов, но это неудобно.)</p>

  <p>Тип переменной должен быть известен компилятору во время компиляции.</p>

  <p>От типа зависит:</p>
  <ul>
    <li>сколько байтов памяти потребуется для хранения данных;</li>
    <li>как интерпретировать эти байты;</li>
    <li>какие операции с этой переменной возможны.</li>
  </ul>

  <p>Например, переменной типа int можно присваивать значения и с ней можно производить арифметические операции. Подробнее про разные типы данных и их размер в памяти мы поговорим ниже.</p>
  <p>Важно понимать, что тип остаётся с переменной навсегда. Например, присвоить целочисленной переменной строку не получится — это вызовет ошибку компиляции:</p>
<pre>
int main() {
  int value;
  value = 42;  // OK
  value = "Hello!";  // ошибка компиляции!
}
</pre>
  <p>Переменные можно сразу проинициализировать значением. В С++ есть много разных способов инициализации. Нам пока будет достаточно способа, который называется copy initialization:</p>
<pre>
#include &lt;string&gt;

int main() {
  int value = 42;
  std::string title = "Bjarne Stroustrup";
}
</pre>
  <p>Если переменная была объявлена, но нигде дальше не использовалась, то компилятор выдаёт об этом предупреждение. При проверке решений мы используем опцию -Werror, которая считает предупреждения компилятора ошибками компиляции.</p>

  <h4>Потоковый ввод и вывод</h4>
  <p>Поток — это абстракция для чтения и записи последовательности данных в форматированном виде.</p>

  <p>Записывать данные можно на экран консоли, в файл, буфер в памяти или в строку. Считывать их можно с клавиатуры, из файла, из памяти. Причём с каждым таким «устройством» можно связать свой поток.</p>

  <p>Важно, что потоки не просто пересылают байты памяти, а применяют форматированный человекочитаемый ввод-вывод. Например, числа печатаются и считываются в десятичной нотации, хотя в памяти компьютера они хранятся в двоичном виде.</p>

  <p>В программе Hello, world! нам уже встречался поток вывода std::cout, по умолчанию связанный с экраном консоли. Познакомимся с потоком ввода std::cin, связанным с клавиатурой. Для его использования нужен тот же заголовочный файл iostream.</p>

  <p>Рассмотрим программу, которая спрашивает имя пользователя и печатает персональное приветствие:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string name;  // объявляем переменную name
  std::cout &lt;&lt; "What is your name?\n";
  std::cin >> name;  // считываем её значение с клавиатуры
  std::cout &lt;&lt; "Hello, " &lt;&lt; name &lt;&lt; "!\n";
}
</pre>
  <p>Обратите внимание на направление угловых скобок в этом примере — они условно показывают направление потока данных. При печати данные выводятся на экран, и стрелки направлены от текста к cout. При вводе данные поступают с клавиатуры, и стрелки направлены от cin к переменной.</p>

  <p>В нашем примере в переменную name считается одно слово, которое будет выведено в ответном сообщении. Пример работы программы:</p>
<pre>
What is your name?
Alice
Hello, Alice!
</pre>
  <p>Однако если ввести строку из нескольких слов с пробелами, то в name запишется только первое слово:</p>
<pre>
$ ./a.out
What is your name?
Alice Liddell
Hello, Alice!
</pre>
  <p>Дело в том, что cin читает поток данных до ближайшего пробельного разделителя (пробела, табуляции, перевода строки или просто конца файла). Чтобы считать в строковую переменную всю строчку целиком (не включая завершающий символ перевода строки), нужно использовать функцию std::getline из заголовочного файла string:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string name;
  std::getline(std::cin, name);
  std::cout &lt;&lt; "Hello, " &lt;&lt; name &lt;&lt; "!\n";
}
</pre>
  <p>В этом примере мы печатаем в одном выражении друг за другом несколько строк ("Hello, ", name и "!\n"), разделённых угловыми скобками &lt;&lt;. Таким образом, cin и cout позволяют кратко считывать и печатать несколько объектов одной командой.</p>

  <p>Например, считывание нескольких чисел целого типа, набранных через пробельные разделители, может выглядеть так:</p>
<pre>
int main() {
  int a;
  int b;
  int c;
  std::cin >> a >> b >> c;
}
</pre>
  <p>Напечатать их значения можно следующим образом:</p>
  <code>std::cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; " " &lt;&lt; c &lt;&lt; "\n";</code>
  <p>Обратите внимание, что мы дополнительно вставляем между ними пробелы, чтобы в выводе числа не слиплись вместе. В конце вывода мы вставляем символ перевода строки \n, чтобы отделить этот результат от последующего вывода или от сообщений командной строки.</p>

  <p>Итак, параграф позади! Впереди вас ждут первые задачи. Но прежде чем приступить к ним, советуем сперва взглянуть на небольшое руководство о том, как пользоваться системой проверки заданий.</p>
</article>


<!-- 2.2 Типы данных -->
<article class="article">
  <div class="anchor" id="p2.2"></div>
  <h3>2.2 Типы данных</h3>
  <p>C++ — язык со статической типизацией. У каждой переменной на этапе компиляции должен быть чётко определённый тип данных. Про каждый тип данных заранее известно, сколько места в памяти занимает переменная такого типа.</p>

  <p>В этом параграфе мы познакомимся с некоторыми базовыми типами данных и с понятием области видимости переменных.</p>

  <h4>Области видимости</h4>

  <p>В С++ существует понятие области видимости (scope) переменной. Эта область ограничивается блоком кода, в котором переменная определена. Рассмотрим пример:</p>
<pre>
#include &lt;iostream&gt;

int a = 1;  // глобальная переменная

int main() {
  int b = 2;  // локальная переменная
  {
    int c = 3;  // локальная переменная внутри блока
    std::cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b
    &lt;&lt; " " &lt;&lt; c &lt;&lt; "\n";  // корректно
  }

  // Эта строчка не скомпилируется,
  // так как переменная c не определена в данной области:
  std::cout &lt;&lt; c &lt;&lt; "\n";
}
</pre>
  <p>В этом примере есть три области:</p>
  <ul>
    <li>глобальная, в которой определена переменная a;</li>
    <li>тело функции main, в которой определена переменная b;</li>
    <li>внутренний блок, в котором определена переменная c.</li>
  </ul>
  <p>В последней строке примера переменная c недоступна, так как её область видимости уже закончилась. В случае коллизии имён компилятор всегда выбирает самую вложенную область видимости.</p>

  <p>Рассмотрим пример:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int x = 1;
  // напечатает 1
  std::cout &lt;&lt; x &lt;&lt; "\n";
  {
    // новая переменная, к предыдущему x не имеет отношения
    int x = 2;
    // напечатает 2
    std::cout &lt;&lt; x &lt;&lt; "\n";
  }
  // снова напечатает 1
  std::cout &lt;&lt; x &lt;&lt; "\n";
}
</pre>

  <h4>Инициализация локальных переменных</h4>
  <p>Локальные переменные простых типов, таких как int, не инициализируются по умолчанию нулём. Компилятор просто выделяет для них байты в стековой памяти, но при этом он не обязан как-либо их заполнять. Это один из принципов C++: мы не должны платить за то, что не используем.</p>

  <p>Следующий фрагмент кода может напечатать всё что угодно:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int x;
  // неопределённое поведение!
  std::cout &lt;&lt; x &lt;&lt; "\n";
  int y;
  // а это допустимый сценарий
  std::cin >> y;
}
</pre>
  <p>Компиляторы g++ и clang++ обычно дают предупреждения о чтении неинициализированных переменных при использовании опции -Wall или -Wuninitialized:</p>
  <p>Заметим, что std::string является сложным типом и переменные такого типа всегда по умолчанию инициализируются пустой строкой. Поэтому нет необходимости писать std::string s = "";. Пишите просто std::string s;.</p>

  <h4>Простые типы данных</h4>
  <p>С типом int мы уже знакомы. Рассмотрим другие фундаментальные типы данных в С++. Это так называемые интегральные типы и типы для вещественных чисел.</p>
<pre>
int main() {
  char c = '1';           // символ
  bool b = true;          // логическая переменная, принимает значения false и true
  int i = 42;             // целое число (занимает, как правило, 4 байта)
  short int si = 17;      // короткое целое (занимает 2 байта)
  long li = 12321321312;  // длинное целое (как правило, 8 байт)
  long long lli = 12321321312; // длинное целое (как правило, 8 байт)
  float f = 2.71828;      // дробное число с плавающей запятой (4 байта)
  double d = 3.141592;    // дробное число двойной точности (8 байт)
  long double ld = 1e15;  // длинное дробное (как правило, 16 байт)
}
</pre>
  <p>Обратите внимание, что символы, в отличие от строк (то есть массивов символов), записываются в апострофах, а не в кавычках. В примере выше мы записываем в переменную c символ единицы. Фактически в памяти хранится ASCII-код этого символа, который равен 49.</p>

  <p>Напомним, что каждый тип данных занимает заранее известное количество байтов памяти. Стандарт языка С++ не накладывает жёстких ограничений на размеры типов, они могут отличаться для разных платформ и компиляторов.</p>

  <p>О том, что делать с этой особенностью, мы расскажем ниже. А пока отметим, что узнать размер переменной или типа на этапе компиляции можно с помощью оператора sizeof.</p>

  <p>Например, на 64-битной Linux-системе компилятор clang++ использует такие размеры для типов:</p>
<pre>
int main() {
  std::cout &lt;&lt; "char: "      &lt;&lt; sizeof(char) &lt;&lt; "\n";                 //  1
  std::cout &lt;&lt; "bool: "      &lt;&lt; sizeof(bool) &lt;&lt; "\n";                 //  1
  std::cout &lt;&lt; "short int: " &lt;&lt; sizeof(short int) &lt;&lt; "\n";       //  2 (по стандарту >= 2)
  std::cout &lt;&lt; "int: "       &lt;&lt; sizeof(int) &lt;&lt; "\n";                   //  4 (по стандарту >= 2)
  std::cout &lt;&lt; "long int: "  &lt;&lt; sizeof(long int) &lt;&lt; "\n";         //  8 (по стандарту >= 4)
  std::cout &lt;&lt; "long long int: " &lt;&lt; sizeof(long long) &lt;&lt; "\n";   //  8 (по стандарту >= 8)
  std::cout &lt;&lt; "float: "     &lt;&lt;sizeof(float) &lt;&lt; "\n";               //  4
  std::cout &lt;&lt; "double: "    &lt;&lt; sizeof(double) &lt;&lt; "\n";             //  8
  std::cout &lt;&lt; "long double: " &lt;&lt; sizeof(long double) &lt;&lt; "\n";   // 16
}
</pre>

  <h4>Размеры стандартных типов</h4>
  <p>По умолчанию числовые типы – знаковые. Они имеют диапазон значений от -2<sup>n-1</sup> до 2<sup>n-1</sup> - 1, где n – количество битов, занимаемых типом. Приставка unsigned перед типом делает его беззнаковым. В этом случае диапазон допустимых значений будет от 0 до 2<sup>n</sup> - 1:</p>
<pre>
int main() {
  unsigned int ui = 4294967295;  // 2^32 - 1
}
</pre>
  <p>Минимальное и максимальное значение, помещающееся в данный числовой тип, можно получить так:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;limits&gt;  // необходимо для numeric_limits

int main() {
  // посчитаем для типа int:
  std::cout &lt;&lt; "minimum value: "
            &lt;&lt; std::numeric_limits&lt;int&gt;::min()
            &lt;&lt; "\n"
            &lt;&lt; "maximum value: "
            &lt;&lt; std::numeric_limits&lt;int&gt;::max()
            &lt;&lt; "\n";
}
</pre>
  <p>Данный пример на 64-битной Linux-системе напечатает:</p>
<pre>
minimum value: -2147483648
maximum value: 2147483647
</pre>
  <p>Приведённые выше примеры вывода оператора sizeof верны для 64-битных архитектур, которые на сегодняшний день распространены повсеместно. Однако если бы мы скомпилировали и запустили такую программу на компьютере с 32-битной архитектурой, то получили бы другие результаты. Например, sizeof(long int) стал бы равен 4, в то время как на современных компьютерах мы получили бы 8. Также бывают встраиваемые системы, под которые тоже можно писать на С++. Там битность архитектуры может быть ещё меньше, чем 32.</p>
  <p>В заголовочном файле cstdint стандартной библиотеки имеются целочисленные типы с фиксированным размером:</p>
  <ul>
    <li>int8_t / uint8_t</li>
    <li>int16_t / uint16_t</li>
    <li>int32_t / uint32_t</li>
    <li>int64_t / uint64_t</li>
  </ul>
  <p>Число в имени типа означает количество бит, используемых для хранения в памяти. Например, int32_t содержит 32 бита (4 байта) и часто соответствует типу int. Если система не поддерживает какой-то тип, то программа с ним просто не скомпилируется.</p>

  <h4>Переполнение целочисленных типов</h4>

  <p>Стандартные числовые типы имеют ограниченный размер и ограниченное множество допустимых значений. При арифметических операциях над числами таких типов может возникнуть переполнение — ситуация, когда результат операции не помещается в тип:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  // на 64-битной платформе sizeof(a) == 4
  unsigned int a = 123456;

  // Произведение a * a не помещается в 4 байта,
  // так как оно больше 2^32
  std::cout &lt;&lt; a * a &lt;&lt; "\n";
}
</pre>

  <p>В этом примере выражение a * a будет иметь тот же тип, что и аргументы. То, что на самом деле будет вычислено, зависит от знаковости типа.</p>
  <p>Беззнаковые типы можно спокойно переполнять: вычисления будут производиться по модулю соответствующей степени двойки. Другими словами, будут учтены только младшие биты результата:</p>
<pre>
int main() {
  // на 64-битной платформе sizeof(x) == 4
  unsigned int x = 0;
  // 4294967295, то есть 2**32 - 1
  unsigned int y = x - 1;
  unsigned int z = y + 1;  // 0
}
</pre>
  <p>Наоборот, для знаковых типов переполнение приводит к так называемому неопределённому поведению (UB, undefined behavior).</p>
  <p>Такая ситуация не считается ошибкой компиляции (в самом деле, на стадии компиляции значения переменных могут быть ещё неизвестны). Но в этом случае стандарт С++ перестаёт что-либо гарантировать по поводу поведения программы. Компиляторы могут использовать такие случаи для оптимизации программ, полагаясь на то, что разработчики пишут код корректно и никогда не допускают неопределённого поведения. Далее нам встретятся и другие случаи неопределённого поведения.</p>
  <p>Беззнаковые типы следует использовать, когда вы имеете дело с битовыми наборами. В остальных случаях предпочтительнее использовать знаковые типы.</p>

  <h4>Арифметические операции</h4>
  <p>Бинарные операции +, - и * работают для чисел стандартным образом. Результат операции деления /, применённой к целым числам, всегда округляется в сторону нуля. Таким образом, для положительных чисел операция / возвращает неполное частное. Остаток от деления целых чисел можно получить с помощью операции %.</p>
<pre>
int main() {
  int a = 7, b = 3;
  int q = a / b;  // 2
  int r = a % b;  // 1
}
</pre>
  <p>Если при делении нужно получить обычное частное, то один из аргументов нужно привести к вещественному типу (например, double) с помощью оператора static_cast:</p>
<pre>
int main() {
  int a = 6, b = 4;
  double q = static_cast&lt;double&gt;(a) / b;  // 1.5
}
</pre>
  <p>Можно было бы написать чуть более кратко: double q = a * 1.0 / b;. Тогда преобразование аргументов произошло бы неявно.</p>
  <p>Арифметические операции над символами, а также сравнение символов друг с другом — это фактически операции над их ASCII-кодами:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  char c = 'A';
  c += 25;  // увеличиваем ASCII-код символа на 25
  std::cout &lt;&lt; c &lt;&lt; "\n";  // Z
}
</pre>
  <p>Операция + применительно к строкам означает конкатенирование (то есть склейку). Это пример перегрузки операции: изначальному оператору сложения чисел в стандартной библиотеке для строки придали новый смысл.</p>
<pre>
#include &lt;string&gt;

int main() {
  std::string a = "Hello, ";
  std::string b = "world!";
  std::string c = a + b;  // Hello, world!
}
</pre>
  <p>Для каждой бинарной операции (например, +) есть версия со знаком равенства (+=) для случая, когда левый аргумент совпадает с переменной, которой присваивается результат:</p>
<pre>
int main() {
  int x = 5;
  x += 3;  // x = x + 3
  x *= x;  // x = x * x
}
</pre>
  <p>Наконец, имеются операторы ++ и -- для увеличения или уменьшения переменной на единицу. Они бывают префиксные (++x) и постфиксные (x++). Отличие состоит в значении выражения, которое будет вычисляться при применении такого оператора. Мы рассмотрим это позже, а пока привыкнем по умолчанию использовать префиксный оператор для обычных чисел:</p>
<pre>
int main() {
  int x = 5;
  ++x;  // 6
  --x;  // снова 5
}
</pre>

  <h4>Числа с плавающей точкой</h4>

  <p>В языке C++ существуют три встроенных типа для записи дробных чисел: float (4 байта), double (8 байт) и long double (16 или 8 байт, в зависимости от платформы). В большинстве случаев рекомендуется использовать тип double.Тип float разумно использовать там, где обрабатываются огромные массивы чисел, и возникает необходимость экономить память.</p>
  <p>Как правило, хранение дробных чисел в С++ основано на стандарте IEEE 754. Число представляется в виде двоичной дроби в экспоненциальной записи: отдельно хранятся бит знака, порядок и мантисса. Мантисса 23 бита (0-22), порядок 8 бит (23-30), знак 1 бит (31).</p>
  <p>Такое представление выгодно отличается от чисел с фиксированной точкой, где хранится фиксированное количество разрядов. Оно позволяет, хотя и с разной степенью точности, представлять числа, отличающиеся на порядки.</p>
  <p>При работе с рациональными числами, знаменатель которых не является степенью двойки, неизбежно возникают погрешности представления. В следующем параграфе мы разберём как следует сравнивать такие числа.</p>

  <h4>Автоматический вывод типа</h4>

  <p>Компилятор C++ умеет автоматически выводить тип переменной по значению, которое ей присваивается. Для этого вместо типа надо написать ключевое слово auto:</p>
<pre>
int main() {
  auto x = 42;  // int
  auto pi = 3.14159;  // double
}
</pre>
  <p>Ключевое слово auto позволяет сократить код и не выписывать сложные типы (нам встретятся дальше монстры вроде std::unordered_multimap&lt;Key, Value&gt;::const_iterator). Важно подчеркнуть, что точный тип переменной всё равно становится известен в момент компиляции.</p>
  <p>При использовании auto со строками нужно быть осторожным. Важно знать, что конструкция auto s = "hello" выведет низкоуровневый тип const char * (указатель на неизменяемый набор символов в памяти), а не тип-обёртку std::string.</p>
  <p>Точные правила вывода типов похожи на правила вывода шаблонных параметров, с которыми мы познакомимся в параграфе про шаблоны.</p>
  <p>В следующем параграфе мы подробнее поговорим о ветвлении и циклах.</p>
</article>


<!-- 2.3 Ветвления и циклы -->
<article class="article">
  <div class="anchor" id="p2.3"></div>
  <h3>2.3 Ветвления и циклы</h3>

  <p>В этом параграфе мы познакомимся с операторами ветвления if и switch, циклами while, do-while и for, а также с оператором goto.</p>

  <h4>Оператор if</h4>
  <p>Условный оператор if записывается так:</p>
<pre>
if (condition) {
  // код, который исполнится в случае,
  // когда условие condition истинно
}
</pre>
  <p>Дополнительно можно добавить ветку кода для случая, когда условие ложно:</p>
<pre>
if (condition) {
  // код, который исполнится,
  // если condition истинно
} else {
  // код, который исполнится,
  // если condition ложно
}
</pre>
  <p>Также можно выстроить цепочку условных операторов:</p>
<pre>
if (condition1) {
  // случай, когда condition1 истинно
} else if (condition2) {
  // случай, когда condition1 ложно,
  // а condition2 истинно
} else if (condition3) {
  // случай, когда condition1 и condition2 ложны,
  // а condition3 истинно
} else {
  // случай, когда condition1,
  // condition2 и condition3 ложны
}
</pre>
  <p>Если код внутри фигурных скобок состоит из одной инструкции, то фигурные скобки можно не писать. Однако рекомендуется ставить фигурные скобки всегда во избежание ошибок.</p>
  <p>На месте condition может стоять любое выражение логического типа. Простейшие примеры таких выражений — это проверка на равенство (==) и неравенство (!=), а также сравнения на меньше / больше (&lt;, &lt;=, > и >=):</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int x;
  std::cin >> x;
  if (x &lt;= 0) {
    std::cout &lt;&lt; "zero or negative\n";
  } else if (x == 1) {
    std::cout &lt;&lt; "one\n";
  } else if (x == 2) {
    std::cout &lt;&lt; "two\n";
  } else {
    std::cout &lt;&lt; "many\n";
  }
}
</pre>

  <h4>Сложные условия</h4>
  <p>Условия можно комбинировать с помощью логических операторов && (и), || (или) и ! (не). Рассмотрим пример, где проверяется принадлежность точки разным интервалам на прямой.</p>
<pre>
int main() {
  int a, b, x;
  /* Тут должна быть логика заполнения объявленных переменных,
  но мы её опустили, чтобы не отвлекаться */

  if (a &lt;= x && x &lt;= b) {
    // точка x лежит на отрезке [a; b]
  } else {
    // точка x лежит вне отрезка [a; b]
  }

  // то же самое можно было бы проверить так:
  if (!(x &lt; a || x > b)) {  // отрицание
    // точка x лежит на отрезке [a; b]
  } else {
    // точка x лежит вне отрезка [a; b]
  }
}
</pre>
  <p>Обратите внимание, что двойное неравенство некорректно проверять через a &lt;= x &lt;= b. Так можно написать, но смысл будет совсем другим: результат сравнения a &lt;= x будет приведён к нулю или единице, и полученное число будет сравниваться с b.</p>
  <p>Операторы сравнения имеют больший приоритет, чем логические операторы, поэтому скобки вокруг элементарных сравнений в сложных условиях не обязательны. А вот оператор отрицания имеет высокий приоритет, поэтому в последнем примере он применяется к условию в скобках. Таблицу приоритета операторов C++ можно посмотреть здесь.</p>
  <p>Операторы && и || ведут себя лениво: если первого аргумента уже достаточно для ответа, то второй аргумент вычисляться не будет. Например, в выражении condition1 && condition2 второе условие не вычисляется, если первое ложно. Это часто используют для проверок корректности:</p>
<pre>
int a, b;
// ...
if (a != 0 && b % a == 0) {
  // b делится на a
}
</pre>

  <h4>Сравнение чисел с плавающей точкой</h4>

  <p>Рассмотрим программу, которая проверяет равенство 0.1 + 0.2 == 0.3:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  double x = 0.1, y = 0.2;
  if (x + y == 0.3) {
    std::cout &lt;&lt; "EQUAL ";
  } else {
    std::cout &lt;&lt; "NOT EQUAL ";
  }

  std::cout &lt;&lt; x + y &lt;&lt; "\n";
}
</pre>
  <p>Логично было бы предположить, что программа выведет EQUAL 0.3, потому что 0.1 + 0.2 = 0.3. Однако программа напечатает NOT EQUAL 0.3. Данная «ошибка вычисления» встречается в большинстве современных языков программирования и обусловлена погрешностью представления этих чисел. Если повысить число знаков дробной части в выводе, мы увидим, что 0.1 + 0.2 == 0.30000000000000004. Подробнее об этом можно прочитать здесь и в этой статье.</p>
  <p>Поскольку операции над числами с плавающей точкой могут содержать погрешность, обычное сравнение через == некорректно. Поэтому правильнее сравнивать модуль разности величин с некой допустимой для нас погрешностью. Модуль дробного числа можно получить с помощью функции std::abs из заголовочного файла cmath. Исходную программу можно было бы переписать так:</p>
<pre>
#include &lt;cmath&gt;
#include &lt;iostream&gt;

int main() {
  double delta = 0.000001;

  double x = 0.1, y = 0.2;
  double sum = x + y;

  if (std::abs(sum - 0.3) &lt; delta) {
    std::cout &lt;&lt; "EQUAL ";
  } else {
    std::cout &lt;&lt; "NOT EQUAL ";
  }

  std::cout &lt;&lt; sum &lt;&lt; "\n";
}
</pre>
  <p>Теперь программа выведет EQUAL 0.3.</p>

  <h4>Оператор switch</h4>

  <p>Рассмотрим простейший калькулятор, считывающий число, затем знак арифметической операции, а затем другое число и печатающий результат. Напишем сначала программу с помощью if и else.</p>
<pre>
#include &lt;cstdint&gt;
#include &lt;iostream&gt;

int main() {
  int64_t a, b;
  char operation;
  std::cin >> a >> operation >> b;

  int64_t result = 0;
  if (operation == '+') {
    result = a + b;
  } else if (operation == '-') {
    result = a - b;
  } else if (operation == '*') {
    result = a * b;
  } else if (operation == '/' || operation == ':') {
    result = a / b;
  } else if (operation == '%') {  // остаток от деления
    result = a % b;
  }

  std::cout &lt;&lt; result &lt;&lt; "\n";
}
</pre>
  <p>Перепишем эту программу через оператор switch. Этот оператор следует рассматривать как условный прыжок на соответствующую метку в зависимости от значения выражения.</p>
<pre>
#include &lt;cstdint&gt;
#include &lt;iostream&gt;

int main() {
  int64_t a, b;
  char operation;
  std::cin >> a >> operation >> b;

  int64_t result;
  switch (operation) {
    case '+':
        result = a + b;
        break;  // если не написать этот break,
                // программа просто пойдёт дальше
                // в код следующего блока case
    case '-':
        result = a - b;
        break;
    case '*':
        result = a * b;
        break;
    case '/':
    case ':':
        result = a / b;
        break;
    case '%':
        result = a % b;
        break;
    default:  // здесь обрабатывается случай,
              // когда ни один case не сработал.
        result = 0;
  }

  std::cout &lt;&lt; result &lt;&lt; "\n";
}
</pre>
  <p>Выражения внутри скобок оператора switch и в блоках case должны быть простого целочисленного или символьного типа. В приведённой выше программе значение + относится к типу char. Использование сложных типов (например, строк) приведёт к ошибке компиляции:</p>
<pre>
int main() {
  std::string name;
  std::cin >> name;
  switch (name) {  // ошибка компиляции
    case "Alice":
        std::cout &lt;&lt; "Hello, Alice!\n";
        break;
  }
}
</pre>

  <h4>Оператор goto</h4>

  <p>Есть шутка, что оператор безусловного перехода goto — это ругательное слово из четырёх букв. Безусловные переходы ломают иерархичность программы, затрудняют чтение и отладку. Доказано, что любую программу можно переписать без оператора goto. Поэтому во многих современных языках goto отсутствует.</p>
  <p>Однако в C++ этот оператор есть по следующим причинам:</p>
  <ul>
    <li>обратная совместимость с языком С;</li>
    <li>удобный выход из вложенных циклов;</li>
    <li>применение в автосгенерированном коде (например, коде конечного автомата), не предназначенном для чтения человеком.</li>
  </ul>
  <p>Мы познакомимся с его синтаксисом, но дальше использовать нигде не будем — и вам не советуем.</p>
<pre>
int main() {
  again:  // метка — это произвольное имя с двоеточием

  std::cout &lt;&lt; "How old are you?\n";
  int age;
  std::cin >> age;

  if (age &lt; 0 || age >= 128) {
    std::cout &lt;&lt; "Wrong age...\n";
    // безусловный прыжок в место, помеченное меткой
    goto again;
  }

  std::cout &lt;&lt; "Your age is " &lt;&lt; age &lt;&lt; ".\n";

  // ...
}
</pre>
  <p>Здесь вводится метка again, на которую осуществляется переход, если возраст введён некорректно. Ниже мы покажем, как можно избавиться от оператора goto.</p>
  <p>С помощью оператора goto нельзя выйти из функции или зайти в неё, а также нельзя перепрыгнуть через объявления переменных (кроме тривиальных случаев):</p>
<pre>
#include &lt;iostream&gt;

int main() {
  goto label;
  int x = 42;
  label:  // ошибка компиляции!
  std::cout &lt;&lt; x &lt;&lt; "\n";
}
</pre>

  <h4>Цикл while</h4>

  <p>В C++ существует несколько видов циклов. Цикл while — это цикл с предусловием. Перед очередной итерацией проверяется условие, и если оно истинно, то цикл продолжается. Рассмотрим пример печати таблицы квадратов чисел от 1 до 10:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int n = 1;
  while (n &lt;= 10) {
    // выводим число и его квадрат через табуляцию
    std::cout &lt;&lt; n &lt;&lt; "\t" &lt;&lt; n * n &lt;&lt; "\n";
    ++n;
  }
}
</pre>
  <p>Здесь мы намеренно разделяем числа и их квадраты не пробелом, а знаком табуляции \t. В консоли такой вывод будет выглядеть выровненным по колонкам с фиксированной шириной:</p>
<pre>
1&#x9;1
2&#x9;4
3&#x9;9
4&#x9;16
5&#x9;25
6&#x9;36
7&#x9;49
8&#x9;64
9&#x9;81
10&#x9;100
</pre>

  <h4>Цикл do-while</h4>

  <p>Это цикл с постусловием. Отличие от цикла while заключается в том, что первая итерация всегда выполняется безусловно. Только после её завершения проверяется условие цикла. Если оно истинно, то цикл продолжается.</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int n = 1;
  do {
    std::cout &lt;&lt; n &lt;&lt; "\t" &lt;&lt; n * n &lt;&lt; "\n";
    ++n;
  } while (n &lt;= 10);
}
</pre>
  <p>Без особых причин пользоваться этим видом циклов не стоит, старайтесь использовать циклы while или for.</p>

  <h4>Цикл for</h4>

  <p>Цикл for — самый гибкий. Он записывается так:</p>
<pre>
for (initialization; condition; action) {
  // тело цикла
}
</pre>
  <p>Как правило, с циклом ассоциируется некоторый параметр, который меняется от итерации к итерации, а цикл выполняется до тех пор, пока некоторое условие на этот параметр истинно.</p>

  <p>Начальное значение такого параметра можно задать в разделе initialization, условие — в condition, а действие над параметром, выполняющееся после каждой итерации, — в action.</p>

  <p>Напечатаем таблицу квадратов через цикл for:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  for (int i = 1; i &lt;= 10; ++i) {
    std::cout &lt;&lt; i &lt;&lt; "\t" &lt;&lt; i * i &lt;&lt; "\n";
  }
}
</pre>
  <p>Напомним, что ++i — традиционная краткая форма записи для выражения i = i + 1.</p>
  <p>Цикл for эквивалентен такому циклу while:</p>
<pre>
{
  initialization;
  while (condition) {
    // тело цикла
    action;
  }
}
</pre>

  <h4>Цикл range-based for</h4>

  <p>Этот цикл применим к контейнерам разной природы (массивам, векторам, спискам и т. д.), с которыми мы познакомимся позже. Пока рассмотрим его на примере строк. Цикл позволяет удобно проитерироваться по символам строки, не используя индексов. В этом примере мы считываем строку и печатаем отдельно все символы строки и их ASCII-коды:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string line;
  std::getline(std::cin, line);
  for (char symbol : line) {
    std::cout &lt;&lt; symbol &lt;&lt; "\t"
    &lt;&lt; static_cast&lt;int&gt;(symbol) &lt;&lt; "\n";
  }
}
</pre>
  <p>Здесь оператор static_cast преобразует символ к числовому типу int, чтобы получить его код. Результат для строки Hello, world! выглядит так:</p>
<pre>
H	72
e	101
l	108
l	108
o	111
,	44
 	32
w	119
o	111
r	114
l	108
d	100
!	33
</pre>
  <p>Обратите внимание, что std::string хранит внутри байты. Если вы вводите символы русского алфавита и у вас используется кодировка UTF-8, ставшая де-факто стандартом, то эти символы будут кодироваться парами байтов. И при такой итерации вы увидите отдельные байты, а не символы.</p>

  <h4>Вложенные циклы</h4>

  <p>Циклы могут быть вложенными. Напечатаем таблицу умножения:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  for (int i = 1; i &lt;= 10; ++i) {
    for (int j = 1; j &lt;= 10; ++j) {
      std::cout &lt;&lt; i * j &lt;&lt; "\t";
    }
    std::cout &lt;&lt; "\n";
  }
}
</pre>
  <p>Результат:</p>
<pre>
  1	   2	 3	 4	 5	 6	 7	 8	 9	10
  2	   4	 6	 8	10	12	14	16	18	20
  3	   6	 9	12	15	18	21	24	27	30
  4	   8	12	16	20	24	28	32	36	40
  5	  10	15	20	25	30	35	40	45	50
  6   12	18	24	30	36	42	48	54	60
  7	  14	21	28	35	42	49	56	63	70
  8	  16	24	32	40	48	56	64	72	80
  9	  18	27	36	45	54	63	72	81	90
  10  20	30	40	50	60	70	80	90	100
</pre>

  <h4>Операторы break и continue</h4>

  <p>Оператор break досрочно заканчивает текущий цикл. Оператор continue прыгает в самый конец тела цикла и, если условие цикла позволяет, переходит на следующую итерацию.</p>
  <p>Типичный пример использования оператора break — выход из формально бесконечного цикла:</p>
<pre>
while (true) {
  // ...
  if (condition) {
    break;
  }
  // ...
}
</pre>
  <p>Кстати, рассмотрим другие способы записать бесконечный цикл.</p>
  <p>Через цикл do-while:</p>
<pre>
do {
  // ...
} while (true);
</pre>
  <p>Через цикл for:</p>
<pre>
for (;;) {
  // ...
}
</pre>
  <p>Напишем программу, которая считывает числа с клавиатуры до тех пор, пока пользователь не введёт ноль, а затем печатает их сумму:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int sum = 0;
  while (true) {
    int x;
    std::cin >> x;
    if (x == 0) {
      break;
    }
    sum += x;
  }
  std::cout &lt;&lt; sum &lt;&lt; "\n";
}
</pre>
  <p>(Здесь, конечно, неявно предполагается, что и сами числа, и результат суммирования помещаются в тип int, и в ходе вычислений не происходит переполнений.)</p>

  <h4>Считывание до конца ввода</h4>

  <p>В предыдущем примере мы считывали числа до тех пор, пока на вход не поступит ноль. Это не очень удобно. Предположим, что вместо ввода с клавиатуры мы читали бы эти числа из файла. Это легко сделать, перенаправив файл на стандартный ввод при запуске программы из консоли:</p>
  <code>./a.out &lt; input.txt</code>
  <p>Следующий цикл считывает числа до тех пор, пока поступающие данные не закончатся:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int sum = 0;
  int x;
  while (std::cin >> x) {
    sum += x;
  }
  std::cout &lt;&lt; sum &lt;&lt; "\n";
}
</pre>
  <p>Здесь вместо условия цикла подставлено выражение std::cin >> x. Кроме считывания x это выражение преобразуется к логическому типу, показывающему, есть ли ещё данные в потоке ввода.</p>
  <p>При вводе данных не из файла, а с клавиатуры можно сымитировать конец ввода комбинацией клавиш Ctrl+D в Linux и macOS или Ctrl+Z в Windows.</p>
  <p>Аналогично можно прочитать строки до конца ввода с помощью std::getline:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string name;
  while (std::getline(std::cin, name)) {
    std::cout &lt;&lt; "Hello, " &lt;&lt; name &lt;&lt; "!\n";
  }
}
</pre>
</article>


<!-- 2.4 Векторы и строки -->
<article class="article">
  <div class="anchor" id="p2.4"></div>
  <h3>2.4 Векторы и строки</h3>

  <p>Вектор (std::vector) и строка (std::string) — это важные базовые контейнеры стандартной библиотеки C++. Они хранят свои элементы в непрерывном фрагменте памяти. Оба этих контейнера предоставляют доступ к элементам по индексу и позволяют эффективно добавлять новые элементы в конец.</p>

  <h4>Контейнер std::vector</h4>

  <p>В стандартной библиотеке C++ вектором (std::vector) называется динамический массив, обеспечивающий быстрое добавление новых элементов в конец и меняющий свой размер при необходимости. Вектор гарантирует отсутствие утечек памяти (об этом мы поговорим в других параграфах, сейчас просто считайте, что это хорошо).</p>

  <p>Для работы с вектором нужно подключить заголовочный файл vector.</p>

  <p>Элементы вектора должны быть одинакового типа, и этот тип должен быть известен при компиляции программы. Он задаётся в угловых скобках после std::vector: например, std::vector&lt;int&gt; — это вектор целых чисел типа int, а std::vector&lt;std::string&gt; — вектор строк.</p>

  <p>Само имя std::vector не является типом данных: это шаблон, в который требуется подставить нужные параметры (тип элемента), чтобы получился конкретный тип данных. Подробнее о том, что такое шаблоны и как их применять, мы расскажем в параграфе «Шаблоны».</p>

  <p>Рассмотрим пример программы, которая заполняет вектор элементами и печатает их через пробел:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; data = {1, 2, 3, 4, 5};
  for (int elem : data) {
    std::cout &lt;&lt; elem &lt;&lt; " ";
  }
  std::cout &lt;&lt; "\n";
}
</pre>
  <p>Здесь мы инициализируем вектор через список инициализации, в котором элементы перечислены через запятую. Другой способ инициализации вектора — указать число элементов и (при необходимости) образец элемента:</p>
<pre>
#include &lt;string&gt;
#include &lt;vector&gt;

int main() {
  // пустой вектор строк
  std::vector&lt;std::string&gt; v1;
  // вектор из пяти пустых строк
  std::vector&lt;std::string&gt; v2(5);
  // вектор из пяти строк "hello"
  std::vector&lt;std::string&gt; v3(5, "hello");
}
</pre>

  <h4>Обращение к элементам</h4>

  <p>Выше мы использовали для печати элементов вектора цикл range-for. Но иногда удобнее работать с индексами. Вектор хранит элементы в памяти последовательно, поэтому по индексу элемента можно быстро найти его положение в памяти. Индексация начинается с нуля:</p>
<pre>
std::vector&lt;int&gt; data = {1, 2, 3, 4, 5};
// начальный элемент вектора
int a = data[0];
// последний элемент вектора (в нём пять элементов)
int b = data[4];
// меняем элемент 3 на -3
data[2] = -3;
</pre>
  <p>Чтобы узнать общее количество элементов в векторе, можно воспользоваться функцией size:</p>
  <code>std::cout &lt;&lt; data.size() &lt;&lt; "\n";</code>
  <p>Отрицательные индексы, как в некоторых других языках программирования, не допускаются.</p>
  <p>Обратите внимание: когда мы обращаемся по индексу через квадратные скобки, проверки его корректности не происходит. Это ещё одно проявление принципа «мы не должны платить за то, что не используем».</p>
  <p>Встроенные валидаторы замедляют программу: предполагается, что программист пишет правильный код и уверен, что индекс i в выражении data[i] неотрицателен и удовлетворяет условию i &lt; data.size(). В этом случае они ему не нужны.</p>
  <p>Если всё же обратиться к вектору по некорректному индексу, то программа во время выполнения попадёт в неопределённое поведение: фактически она попробует прочитать память, не принадлежащую вектору.</p>
  <p>Если вам не хочется делать много лишних проверок, а в корректности индекса вы не уверены, то можно использовать функцию at:</p>
<pre>
std::vector&lt;int&gt; data = {1, 2, 3, 4, 5};
// неопределённое поведение: может произойти всё что угодно
std::cout &lt;&lt; data[42] &lt;&lt; "\n";
// напечатается 1
std::cout &lt;&lt; data.at(0) &lt;&lt; "\n";
// произойдёт исключение std::out_of_range
// его можно будет перехватить и обработать
std::cout &lt;&lt; data.at(42) &lt;&lt; "\n";
</pre>
  <p>Про работу с исключениями мы поговорим отдельно в параграфе «Обработка исключений».</p>
  <p>Рассмотрим функции вектора front и back, которые возвращают его первый и последний элемент без использования индексов:</p>
<pre>
std::vector&lt;int&gt; data = {1, 2, 3, 4, 5};
// то же, что data[0]
std::cout &lt;&lt; data.front() &lt;&lt; "\n";
// то же, что data[data.size() - 1]
std::cout &lt;&lt; data.back() &lt;&lt; "\n";
</pre>
  <p>Важно учитывать, что вызов этих функций на пустом векторе приведёт к неопределённому поведению.</p>
  <p>Для проверки вектора на пустоту вместо сравнения data.size() == 0 принято использовать функцию empty, которая возвращает логическое значение:</p>
<pre>
if (!data.empty()) {
  // вектор не пуст, с ним можно работать
}
</pre>

  <h4>Итерация по индексам</h4>

  <p>Так сложилось, что в стандартной библиотеке индексы и размеры контейнеров имеют беззнаковый тип. Вместо unsigned int или unsigned long int для него используется традиционный псевдоним size_t (а точнее, std::vector&lt;T&gt;::size_type). Тип size_t на самом деле совпадает с uint32_t или uint64_t в зависимости от битности платформы. Его использование в программе дополнительно подчёркивает, что мы имеем дело с индексами или с размером.</p>

  <p>Итерацию по элементам data с помощью индексов можно записать так:</p>
<pre>
for (size_t i = 0; i != data.size(); ++i) {
  std::cout &lt;&lt; data[i] &lt;&lt; " ";
}
</pre>
  <p>Это каноническая форма записи такого цикла: в ней принято использовать сравнение != и префиксный ++i. Для целых чисел не будет разницы, если написать это как-то иначе (например, через &lt; и постфиксный i++), но потом, когда вы будете писать аналогичные циклы для итераторов других контейнеров, разница появится. Давайте привыкнем всегда оформлять цикл по индексам так.</p>
  <p>Беззнаковость типа возвращаемого значения функции size порождает следующую проблему. По правилам, унаследованным ещё от языка C, результат арифметических действий над беззнаковым и знаковым типами приводится к беззнаковому типу. Поэтому выражение data.size() - 1, например, тоже будет беззнаковым. Если data.size() окажется нулём, то такое выражение будет вовсе не минус единицей, а самым большим беззнаковым целым (для 64-битной платформы это 2<sup>64</sup>-1).</p>
  <p>Рассмотрим следующий ошибочный код, который проверяет, есть ли в векторе дубликаты, идущие подряд:</p>
<pre>
// итерация по всем элементам, кроме последнего:
for (size_t i = 0; i &lt; data.size() - 1; ++i) {
  if (data[i] == data[i + 1]) {
    std::cout &lt;&lt; "Duplicate value: " &lt;&lt; data[i] &lt;&lt; "\n";
  }
}
</pre>
  <p>Эта программа будет некорректно работать на пустом векторе. Условие i &lt; data.size() - 1 на первой итерации окажется истинным, и произойдёт обращение к элементам пустого вектора. Правильнее было бы переписать это условие через i + 1 &lt; data.size() или воспользоваться внешней функцией std::ssize, которая появилась в C++20. Она возвращает знаковый размер вектора:</p>
<pre>
for (std::int64_t i = 0; i &lt; std::ssize(data) - 1; ++i) {
  if (data[i] == data[i + 1]) {
    std::cout &lt;&lt; "Duplicate value: " &lt;&lt; data[i] &lt;&lt; "\n";
  }
}
</pre>

  <h4>Добавление и удаление элементов</h4>

  <p>В вектор можно эффективно добавлять элементы в конец и удалять их с конца. Для этого существуют функции push_back и pop_back. Рассмотрим программу, считывающую числа с клавиатуры в вектор и затем удаляющую все нули в конце:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  int x;
  std::vector&lt;int> data;

  // читаем числа, пока не закончится ввод
  while (std::cin >> x) {
    // добавляем очередное число в вектор
    data.push_back(x);
  }

  // Пока вектор не пуст и последний элемент равен нулю
  while (!data.empty() && data.back() == 0) {
    // удаляем этот нулевой элемент
    data.pop_back();
  }
}
</pre>
  <p>Добавление элементов в другие части вектора или их удаление неэффективно, так как требует сдвига соседних элементов. Поэтому отдельных функций, например, для добавления или удаления элементов из начала у вектора нет. Это можно сделать с помощью общих функций insert/erase и итераторов. Мы рассмотрим такие примеры позже.</p>
  <p>Удалить все элементы из вектора можно с помощью функции clear.</p>

  <h4>Резерв памяти</h4>
  <p>Вектор хранит элементы в памяти в виде непрерывной последовательности, друг за другом. При этом в конце последовательности резервируется дополнительное место для быстрого добавления новых элементов. Когда этот резерв заканчивается, при вставке очередного элемента происходит реаллокация: элементы вектора копируются в новый, более просторный блок памяти.</p>
  <p>Реаллокация — довольно дорогая процедура, но если она происходит достаточно редко, то её влияние незначительно. Можно доказать, что если размер нового блока выбирать в два раза больше предыдущего размера, то амортизационная сложность добавления элемента будет константной.</p>
  <p>Текущий резерв вектора можно узнать с помощью функции capacity (не путайте её с функцией size).</p>
  <p>Рассмотрим программу, в которой в вектор последовательно добавляются элементы и после каждого шага печатается размер и резерв:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; data = {1, 2};
  std::cout &lt;&lt; data.size() &lt;&lt; "\t" &lt;&lt; data.capacity() &lt;&lt; "\n";

  data.push_back(3);
  std::cout &lt;&lt; data.size() &lt;&lt; "\t" &lt;&lt; data.capacity() &lt;&lt; "\n";

  data.push_back(4);
  std::cout &lt;&lt; data.size() &lt;&lt; "\t" &lt;&lt; data.capacity() &lt;&lt; "\n";

  data.push_back(5);
  std::cout &lt;&lt; data.size() &lt;&lt; "\t" &lt;&lt; data.capacity() &lt;&lt; "\n";
}
</pre>
  <p>Вот вывод этой программы:</p>
<pre>
2	2
3	4
4	4
5	8
</pre>
  <p>Видно, что размер вектора увеличивается на единицу, а резерв удваивается после исчерпания. Так, при добавлении четвёрки используется имеющаяся в резерве память, а при добавлении тройки и пятёрки происходит реаллокация.</p>
<pre>
vector&lt;int&gt; data = {1, 2, 3, 4};
data.push_back(5);
</pre>
  <p>Иногда требуется заполнить вектор элементами, причём число элементов известно заранее. В таком случае можно сразу зарезервировать нужный размер памяти с помощью функции reserve, чтобы при добавлении элементов не происходили реаллокации. Пусть, например, нам сначала задаётся число слов, а потом сами эти слова, и нам требуется сложить их в вектор:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;std::string&gt; words;

  size_t words_count;
  std::cin >> words_count;

  // Размер вектора остаётся нулевым, меняется только резерв:
  words.reserve(words_count);

  for (size_t i = 0; i != words_count; ++i) {
    std::string word;
    std::cin >> word;
    // Все добавления будут дешёвыми, без реаллокаций:
    words.push_back(word);
  }
}
</pre>
  <p>Если передать в reserve величину меньше текущего резерва, то ничего не поменяется — резерв останется прежним.</p>
  <p>Функцию reserve не следует путать с функцией resize, которая меняет количество элементов в векторе. Если аргумент функции resize меньше текущего размера, то лишние элементы в конце вектора удаляются. Если же он больше текущего размера, то при необходимости происходит реаллокация и в вектор добавляются новые элементы с дефолтным значением данного типа.</p>
<pre>
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; data = {1, 2, 3, 4, 5};

  // поменяли резерв, но размер вектора остался равным пяти
  data.reserve(10);

  data.resize(3);  // удалили последние элементы 4 и 5
  data.resize(6);  // получили вектор 1, 2, 3, 0, 0, 0
}
</pre>

  <h4>Многомерные векторы</h4>

  <p>Воспользуемся вектором векторов, чтобы сохранить матрицу (таблицу) целых чисел. Пусть на вход программы сначала поступают число строк и число столбцов матрицы, а потом — сами элементы построчно:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  size_t m, n;
  std::cin >> m >> n;  // число строк и столбцов

  // создаём матрицу matrix из m строк, каждая из которых — вектор из n нулей
  std::vector&lt;std::vector&lt;int&gt; &gt; matrix(m, std::vector&lt;int&gt;(n));

  for (size_t i = 0; i != m; ++i) {
    for (size_t j = 0; j != n; ++j) {
      std::cin >> matrix[i][j];
    }
  }

  // напечатаем матрицу, выводя элементы через табуляцию
  for (size_t i = 0; i != m; ++i) {
    for (size_t j = 0; j != n; ++j) {
      std::cout &lt;&lt; matrix[i][j] &lt;&lt; "\t";
    }
    std::cout &lt;&lt; "\n";
  }
}
</pre>
  <p>В этом примере мы заранее создали матрицу из нулей, а потом просто меняли её элементы.</p>

  <h4>Сортировка вектора</h4>

  <p>Рассмотрим типичную задачу — отсортировать вектор по возрастанию. Для этого в стандартной библиотеке в заголовочном файле algorithm есть готовая функция sort. Гарантируется, что сложность её работы в худшем случае составляет O(nlogn), где n — число элементов в векторе. Типичные реализации используют алгоритм сортировки Introsort.</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; data = {3, 1, 4, 1, 5, 9, 2, 6};

  // Сортировка диапазона вектора от начала до конца
  std::sort(data.begin(), data.end());

  // получим вектор 1, 1, 2, 3, 4, 5, 6, 9
}
</pre>
  <p>В функцию sort передаются так называемые итераторы, ограничивающие рассматриваемый диапазон. В нашем случае мы передаём диапазон, совпадающий со всем вектором, от начала до конца. Соответствующие итераторы возвращают функции begin и end (не путать с front и back!). Итераторы можно считать обобщёнными индексами (но они могут быть и у контейнеров, не допускающих обычную индексацию). Подробнее про итераторы мы поговорим в отдельном параграфе.</p>
  <p>Для сортировки по убыванию можно передать на вход обратные итераторы rbegin() и rend(), представляющие элементы вектора в перевёрнутом порядке:</p>
<pre>
std::sort(data.rbegin(), data.rend());
// 9, 6, 5, 4, 3, 2, 1, 1
</pre>
  <p>В C++20 доступен более элегантный способ сортировки через std::ranges::sort:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; data = {3, 1, 4, 1, 5, 9, 2, 6};
  // можно передать сам вектор, а не его диапазоны
  std::ranges::sort(data);
}
</pre>
  <p>Для сортировки по умолчанию используется сравнение элементов с помощью оператора &lt;. Этот оператор работает и для самих векторов: они сравниваются лексикографически. Поэтому можно без проблем отсортировать, например, строки в матрице (векторе векторов целых чисел).</p>

  <h4>Строки</h4>

  <p>Контейнер std::string можно рассматривать как особый случай вектора символов std::vector&lt;char&gt;, имеющий набор дополнительных функций. В частности, у строки есть все те же рассмотренные нами функции, что и у вектора (например, pop_back или resize). Рассмотрим некоторые специфические функции строки:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string s = "Some string";

  // приписывание символов и строк
  // добавляем отдельный символ в конец, это аналог push_back
  s += ' ';
  s += "functions";  // добавляем строку в конец
  std::cout &lt;&lt; s &lt;&lt; "\n";  // Some string functions

  // выделение подстроки
  // подстрока "string" из 6 символов начиная с 5-й позиции
  std::string sub1 = s.substr(5, 6);
  // подстрока "functions" с 12-й позиции и до конца
  std::string sub2 = s.substr(12);

  // поиск символа или подстроки
  // позиция первого пробела, в данном случае 4
  size_t pos1 = s.find(' ');
  // позиция следующего пробела (11)
  size_t pos2 = s.find(' ', pos1 + 1);
  // вернётся 5
  size_t pos3 = s.find("str");
  вернётся std::string::npos
  size_t pos4 = s.find("#");  //
}
</pre>

  <p>Вставку, замену и удаление подстрок можно сделать через указание индекса начала и длины подстроки:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string s = "Some string functions";

  // вставка подстроки
  s.insert(5, "std::");
  std::cout &lt;&lt; s &lt;&lt; "\n";  // Some std::string functions

  // замена указанного диапазона на новую подстроку
  s.replace(0, 4, "Special");
  std::cout &lt;&lt; s &lt;&lt; "\n";  // Special std::string functions

  // удаление подстроки
  s.erase(8, 5);  // Special string functions
}
</pre>
  <p>Аналогичные действия для других контейнеров (например, для того же вектора) можно сделать через итераторы. Мы рассмотрим такие примеры в одном из следующих параграфов.</p>
  <p>В C++20 появились удобные функции starts_with и ends_with для проверки префикса или суффикса строк:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string phrase;
  std::getline(std::cin, phrase);

  if (phrase.starts_with("hello")) {
    std::cout &lt;&lt; "Greeting\n";
  }

  if (phrase.ends_with("bye")) {
    std::cout &lt;&lt; "Farewell\n";
  }
}
</pre>
</article>


<!-- 2.5 Составные типы данных -->
<article class="article">
  <div class="anchor" id="p2.5"></div>
  <h3>2.5 Составные типы данных</h3>

  <p>C++ позволяет конструировать новые типы данных на основе базовых типов. В этом параграфе мы познакомимся с перечислениями и структурами, а также рассмотрим конструкции std::pair и std::tuple из стандартной библиотеки.</p>

  <h4>Перечисления</h4>

  <p>Предположим, что мы пишем программу для обработки изображений и хотим работать с цветами. Для каждого цвета заводить отдельную константу не очень удобно. Воспользуемся перечислением — специальным типом данных, который состоит из конечного набора именованных констант:</p>
<pre>
enum class Color {
  White,
  Red,
  Orange,
  Blue,
};
</pre>
  <p>Мы описали новый тип данных Color с четырьмя допустимыми значениями. Теперь к каждому цвету можно обращаться через префикс Color:::</p>
<pre>
int main() {
  Color color1 = Color::Red;
  Color color2 = Color::Blue;
}
</pre>
  <p>Фактически перечисления — это удобный способ описывать однотипные именованные константы. По умолчанию перечисления хранятся как тип int, а их значения последовательно нумеруются с нуля. И тип, и конкретное значение можно поменять.</p>
  <p>Преобразовать перечисление в число и обратно можно с помощью оператора static_cast:</p>
<pre>
int value = static_cast&lt;int&gt;(color2);  // 3
Color color3 = static_cast&lt;Color&gt;(2);  // Color::Orange
</pre>
  <p>Раньше в C++ перечисления объявлялись вот так, без слова class:</p>
<pre>
enum Color {
  White,
  Red,
  Orange,
  Blue,
};

// можно даже без названия
enum {
  Apple,
  Orange,
  Banana
};
</pre>
  <p>Этот способ остался в языке. Но в таком случае все имена внутри перечислений являются глобальными, и могут происходить конфликты имён (Orange в примере). Такая программа просто не скомпилируется.</p>

  <h4>Структуры</h4>

  <p>Часто хочется собрать «под одной крышей» несколько переменных. В таких случаях можно использовать структуры. Например, давайте опишем структуру точек из трёхмерного пространства:</p>
<pre>
struct Point {
  double x = 0.0;
  double y = 0.0;
  double z = 0.0;
  Color color;  // пусть у нас будет цветная точка
};
</pre>
  <p>В данном случае мы описали новый тип данных — Point, который содержит в себе четыре переменные.</p>
  <p>Давайте поработаем с этой структурой:</p>
<pre>
int main() {
  // по умолчанию координаты будут нулевыми,
  // а color никак не будет проинициализирован
  Point point1;
  point1.color = Color::Blue;

  Point point2 = {1.4, -2.2, -3.98, Color::Red};
  // x = 1.4, y = -2.2, z = -3.98, color = Color::Red

  // обращаться к полям можно через точку
  point2.z = 32;
  // и вообще работать с ними как с обычными переменными
  point2.x += 2;
}
</pre>
  <p>В С++20 появилась новая форма инициализации структур — designated initializers:</p>
<pre>
int main() {
  Point point3 = {.x = 1.4, .y = -2.2, .z = -3.98};
  Point point4 = {.color = Color::Orange};
}
</pre>
  <p>Такой способ записи понятнее: сразу видно, какое поле структуры каким значением инициализируется. Важно, что поля должны быть перечислены в том же порядке, в каком они указываются при описании структуры (причину этого мы узнаем в параграфе про конструкторы и жизненный цикл объекта). Пропущенные поля будут инициализироваться значением по умолчанию. Так, point3.color будет равно Color::White — нулевому значению перечисления Color.</p>

  <h4>Выравнивание</h4>

  <p>Теперь давайте поговорим про размеры перечислений и структур:</p>
<pre>
int main() {
  std::cout &lt;&lt; sizeof(double) &lt;&lt; "\n";  // 8
  std::cout &lt;&lt; sizeof(Color) &lt;&lt; "\n";   // 4 (фактически это int)
  std::cout &lt;&lt; sizeof(Point) &lt;&lt; "\n";   // 32
}
</pre>
  <p>Получается, что размер структуры Point (32 байта) не равен сумме размеров её частей (8 + 8 + 8 + 4 = 28). Всё дело в выравнивании: компилятору не очень удобно работать со структурой в 28 байт при условии, что внутри этой структуры есть переменные, размер которых — 8 байт (так как 28 не кратно 8). Поэтому компилятор резервирует за структурой несколько лишних байтов (в нашем случае — 4).</p>
  <p>Можно явно попросить компилятор не выделять мнимых байтов, но в таком случае пострадает скорость — потому что если данные в памяти выровнены, то их легче достать и проще обрабатывать.</p>

  <h4>Кортежи и пары</h4>

  <p>В заголовочном файле utility есть шаблонная структура std::pair с полями first и second. Из названия просто догадаться, что она хранит два объекта:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;utility&gt;

int main() {
  // в угловых скобках нужно указывать два типа:
  std::pair&lt;int, double&gt; p = {42, 3.14};

  // обращаться к полям можно через .first и .second:
  std::cout &lt;&lt; p.first &lt;&lt; "\n";  // 42
  std::cout &lt;&lt; p.second &lt;&lt; "\n"; // 3.14
}
</pre>
  <p>Однако у std::pair есть проблема — её поля обезличены, и не очень ясно, какую смысловую нагрузку несёт first, а какую — second. Из-за этого мы советуем не злоупотреблять данной структурой, кроме случаев, когда она используется в функциях стандартной библиотеки.</p>
  <p>Обобщением пары на несколько переменных является кортеж — std::tuple, объявленный в заголовочном файле tuple:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;tuple&gt;

struct Point;  // определена выше

int main() {
  std::tuple&lt;int, double, Point&gt; t = {42, 3.14, {.color = Color::Orange}};

  // тут уже нет полей .first и .second,
  // но есть стандартная функция std::get&lt;&gt;,
  // которая принимает в угловых скобках
  // индекс элемента (индексация с нуля):
  std::cout &lt;&lt; std::get&lt;0&gt;(t) &lt;&lt; "\n";   // 42
  std::cout &lt;&lt; std::get&lt;1&gt;(t) &lt;&lt; "\n";   // 3.14
  std::cout &lt;&lt; std::get&lt;2&gt;(t).x &lt;&lt; "\n"; // 0.0

  // вызов std::get может появляться и слева от присваивания:
  std::get&lt;2&gt;(t).color = Color::Red;
}
</pre>
  <p>Важно понимать, что типы элементов пары или кортежа, а также размер кортежа фиксируются на этапе компиляции.</p>
  <p>Пару, кортеж или структуру можно «распаковать» с помощью structured binding.</p>
<pre>
#include &lt;string&gt;
#include &lt;utility&gt;

int main() {
  std::pair&lt;std::string, int&gt; p = {"hello", 42};
  auto [word, freq] = p;  // word = "hello"; freq = 42;
}
</pre>
  <p>Здесь конструкция auto [word, freq] = p вводит две новые переменные word и freq соответствующих типов и присваивает им значения из пары.</p>
</article>


<!-- 2.6 Ссылки, указатели, константность -->
<article class="article">
  <div class="anchor" id="p2.6"></div>
  <h3>2.6 Ссылки, указатели, константность</h3>

  <p>Ссылки позволяют вводить псевдонимы для переменных. Указатели — это самостоятельные типы данных, которые могут хранить адреса других переменных в памяти. Ключевое слово const позволяет подчеркнуть, что переменная используется только для чтения. Часто оно используется совместно с объявлением ссылок и указателей.</p>

  <h4>Копии переменных</h4>

  <p>Для начала давайте рассмотрим такой фрагмент кода:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string s1 = "Elementary, my dear Watson!";
  std::string s2 = s1;

  s1.clear();  // s2 никак не изменится

  std::cout &lt;&lt; s1 &lt;&lt; "\n";  // пустая строка
  std::cout &lt;&lt; s2 &lt;&lt; "\n";  // Elementary, my dear Watson!
}
</pre>
  <p>Важно понимать, что здесь s2 будет совершенно новой строкой, которая проинициализирована значением s1, но более никак с s1 не связана. Это отличает С++ от некоторых других языков программирования — например, языка Python. В них после аналогичного присваивания строка осталась бы той же самой.</p>
  <p>Создание новой строки s2 требует ресурсов: нужно выделить новый блок памяти и скопировать туда старую строку.</p>

  <h4>Ссылки</h4>
  <p>Впрочем, в C++ есть возможность обращаться к уже существующему в памяти объекту под другим именем. Рассмотрим это на примере целых чисел:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int x = 42;
  int& ref = x;  // ссылка на x

  ++x;
  std::cout &lt;&lt; ref &lt;&lt; "\n";  // 43
}
</pre>
  <p>Здесь ref — псевдоним для x. Это не самостоятельная переменная, а просто ссылка на объект, уже живущий в памяти. Формально типом ref является int& — ссылка на int.</p>
  <p>Аналогично для строк:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string s1 = "Elementary, my dear Watson!";
  std::string& s2 = s1;  // тут ссылка!

  s1.clear();

  std::cout &lt;&lt; s2.size() &lt;&lt; "\n";  // напечатает 0
}
</pre>
  <p>Ссылка должна быть проинициализирована сразу в момент объявления. Например, так написать нельзя:</p>
<pre>
int main() {
  int my_variable = 42;
  int& ref;  // ошибка!
  // ...
  ref = my_variable;
}
</pre>
  <p>Ссылка привязана к одному и тому же объекту со своего рождения. Переназначить её нельзя:</p>
<pre>
int main() {
  int x = 42, y = 13;
  int& ref = x;  // OK
  ref = y;
  // ссылка останется привязанной к x,
  // значение x поменяется
}
</pre>
  <p>Ссылки удобны там, где исходное имя слишком громоздко (например, является вложенным полем какой-либо структуры).</p>

  <h4>Указатели</h4>
  <p>Другой (более базовый) способ сослаться на что-то уже существующее в памяти — указатели. Это специальные типы данных, которые могут хранить адрес какой-либо другой переменной в памяти. Здесь мы можем представлять себе память как длинную ленту с пронумерованными ячейками (байтами). Сам адрес переменной можно получить с помощью унарного оператора &:</p>
<pre>
int main() {
  int x = 42;
  // сохраняем адрес в памяти переменной x в указатель ptr
  int* ptr = &x;

  ++x;  // увеличим x на единицу
  std::cout &lt;&lt; *ptr &lt;&lt; "\n";  // 43
}
</pre>
  <p>Формально указатель — это не номер ячейки памяти, а отдельный тип. Но обычно он может быть преобразован к целому числу. Вот такой код напечатает адреса переменных в шестнадцатеричном виде:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int x = 1, y = 2, z = 3;
  std::cout &lt;&lt; &x &lt;&lt; "\n";
  std::cout &lt;&lt; &y &lt;&lt; "\n";
  std::cout &lt;&lt; &z &lt;&lt; "\n";
}
</pre>
  <p>Пример вывода:</p>
<pre>
0x7ffdfee3188c
0x7ffdfee31888
0x7ffdfee31884
</pre>
  <p>Можно заметить, что адреса будут идти «рядом» с шагом sizeof(int) по возрастанию или убыванию — это зависит от платформы и компилятора. Но при повторном запуске программы они могут отличаться, так как программе может быть назначен совсем другой сегмент памяти.</p>
  <p>Кроме адреса ячейки памяти переменная-указатель обладает ещё и типом данных, значение которого в этой ячейке лежит. Это позволяет компилятору правильно интерпретировать обращение к памяти по этому адресу. Поэтому мы используем не какой-либо абстрактный тип «указатель», а именно «указатель на int».</p>
  <p>Оператор разыменования (унарная звёздочка) противоположен оператору взятия адреса (унарному амперсанду). Сравните: &x — это адрес x в памяти, а *ptr — это значение, живущее по адресу, записанному в ptr.</p>
  <p>Указатели, в отличие от ссылок, можно переназначать. Кроме того, есть выделенное значение никуда не ссылающегося указателя — nullptr («нулевой» указатель):</p>
<pre>
#include <iostream>

int main() {
  int x = 42, y = 13;
  // по умолчанию не инициализируется, тут лежит «случайный» адрес
  int* ptr;
  ptr = nullptr;  // «нулевой» указатель
  ptr = &x;  // теперь в ptr лежит адрес переменной x
  std::cout &lt;&lt; *ptr &lt;&lt; "\n";  // 42
  ptr = &y;  // можно поменять адрес, записанный в ptr
  std::cout &lt;&lt; *ptr &lt;&lt; "\n";  // 13
}
</pre>
  <p>Указатель nullptr нельзя разыменовывать: это приведёт к неопределённому поведению.</p>
  <p>Часто указатели используются вместе с динамическим выделением памяти (malloc/new). Мы познакомимся с динамической памятью в параграфе «Жизненный цикл объекта». А сейчас лишь стоит заметить, что указатель сам по себе совершенно не означает, что память, на которую он ссылается, была выделена динамически. Например, во всех примерах выше указатель ссылался на обычную переменную на стеке.</p>
  <p>Отдельно рассмотрим <strong>указатели на структуру</strong>. Для обращения к полям структуры через указатель есть отдельный оператор ->:</p>
<pre>
#include &lt;iostream&gt;

struct Point {
  double x, y, z;
};

int main() {
  Point p = {3.0, 4.0, 5.0};

  Point* ptr = &p;

  // обращение через * и . требует скобок
  std::cout &lt;&lt; (*ptr).x &lt;&lt; "\n";
  // то же самое, но чуть короче
  std::cout &lt;&lt; ptr->x &lt;&lt; "\n";
}
</pre>

  <h4>Константность</h4>

  <p>Константа — это переменная, предназначенная только для чтения. Её значение должно быть зафиксировано в момент присваивания. При этом оно не обязательно должно быть известно в момент компиляции:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  // эта константа известна в compile time
  const int c1 = 42;

  int x;
  std::cin >> x;
  // значение становится известным только в runtime
  const int c2 = 2 * x;

  // ошибка компиляции: константе нельзя присвоить новое значение
  с2 = 0;
}
</pre>
  <p>У константного вектора или строки нельзя будет вызвать функции, которые их будут изменять:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  const std::vector&lt;int&gt; v = {1, 3, 5};

  // OK, напечатает 3
  std::cout &lt;&lt; v.size() &lt;&lt; "\n";

  // ошибка компиляции: константный вектор нельзя изменять
  v.clear();

  // тоже ошибка компиляции
  v[0] = 0;
}
</pre>
  <p>Ссылки и указатели можно комбинировать с константностью:</p>
<pre>
int main() {
  int x = 42;

  // обычная ссылка
  int& ref = x;

  // константная ссылка
  const int& cref = x;
  ++x;  // OK
  ++ref;  // OK

  // ошибка компиляции: псевдоним cref предназначен только для чтения
  ++cref;

  // обычный указатель
  int* ptr = &x;

  // указатель на константу
  const int* cptr = &x;
  ++*ptr;  // OK

  // ошибка компиляции: разыменованный cptr — константа!
  ++*cptr;
}
</pre>
  <p>Если исходная переменная уже была константной, то взять обычную ссылку или указатель на неё не получится. Другими словами, константность нельзя просто так отменить, её можно только добавить:</p>
<pre>
int main() {
  const int cx = 42;

  // ошибка компиляции: константность нельзя убрать
  int& ref = cx;
  const int& cref = cx;  // OK

  // тоже ошибка компиляции
  int* ptr = &cx;
  const int* cptr = &cx;  // OK
}
</pre>
  <p>Базовый тип и слово const можно менять местами. Так что const T и T const — это одно и то же. Но следует различать указатель на константу (const T*) и константу типа «указатель» (T* const):</p>
<pre>
int main() {
  int x = 42;
  const int cx = 13;

  // обычный указатель
  int* ptr = &x;
  // ошибка компиляции
  ptr = &cx;

  // OK: через *cptr нельзя будет изменить x
  const int* cptr = &x;
  cptr = &cx;  // OK

  // OK: *ptrc можно менять, но сам ptrc менять нельзя
  int* const ptrc = &x;
  ptrc = nullptr;  // ошибка компиляции

  // OK, для &cx тоже бы сработало
  const int* const cptrc = &x;
}
</pre>
  <p>Пример в последней строке похож на константную ссылку: указатель cptrc не позволяет менять содержимое ячейки &x (первый const) и в него нельзя записать адрес другой переменной (второй const).</p>

  <h4>Ссылки в цикле range-for</h4>

  <p>Рассмотрим итерацию по элементам вектора строк. Намеренно положим в вектор много длинных строк и в цикле попробуем подсчитать их длину (которую, конечно, можно было бы сразу вычислить):</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  // создаём вектор из m строк длины n
  // и искусственно заполняем его:
  const size_t m = 1000000;
  const size_t n = 10000;
  std::vector&lt;std::string&gt; v(m);
  for (size_t i = 0; i != m; ++i) {
    v[i].resize(n, '@');  // кладём в вектор строку из n символов @
  }

  // нам интересен этот цикл:
  size_t sum = 0;
  for (auto row : v) {
    sum += row.size();
  }
  std::cout &lt;&lt; sum &lt;&lt; "\n";
}
</pre>
  <p>Скомпилируем программу с умеренным уровнем оптимизаций (ключ -O2) и измерим время её работы с помощью консольной утилиты time:</p>
<pre>
$ clang++ -O2 -o runnable test.cpp
$ time ./runnable

real   0m4,255s
user   0m1,948s
sys    0m2,307s
</pre>
  <p>Программа работала 4,255 секунды. Давайте её ускорим. Заметим, что в цикле мы пишем</p>
<pre>
for (auto row : v) {
  // ...
}
</pre>
  <p>На самом деле это эквивалентно такому:</p>
<pre>
for (size_t i = 0; i != v.size(); ++i) {
  std::string row = v[i];  // здесь создаётся копия!
  // ...
}
</pre>
  <p>Понятно, что вместо копирования очередной строки можно воспользоваться константной ссылкой:</p>
<pre>
for (const auto& row : v) {
  // ...
}
</pre>
  <p>Время работы такой программы уже будет меньше:</p>
<pre>
$ time ./runnable

real   0m3,462s
user   0m1,157s
sys    0m2,305s
</pre>
  <p>Давайте запомним: чтобы избегать лишнего копирования, в range-for используйте константную ссылку при итерации по набору «тяжёлых» объектов — строк, векторов, структур. Если вы хотите в цикле менять элементы контейнера — используйте обычную ссылку. Нашу программу можно было бы переписать так:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  const size_t m = 1000000;
  const size_t n = 10000;
  std::vector&lt;std::string&gt; v(m);
  for (auto& row : v) {  // обычная ссылка
    row.resize(n, '@');
  }

  size_t sum = 0;
  for (const auto& row : v) {  // константная ссылка
    sum += row.size();
  }
  std::cout &lt;&lt; sum &lt;&lt; "\n";
}
</pre>

  <h4>«Висячие» ссылки и указатели</h4>

  <p>Может так оказаться, что переменная, на адрес которой ссылается указатель, уже вышла из своей области видимости. Похожая ситуация может произойти и со ссылками. В таком случае обращаться к памяти через ссылку или указатель нельзя — это приведёт к неопределённому поведению.</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int* ptr = nullptr;

  {
    int x = 42;
    ptr = &x;
  }

  // обращаться к памяти, в которой жила переменная x, уже нельзя:
  // неопределённое поведение!
  std::cout &lt;&lt; *ptr &lt;&lt; "\n";
}
</pre>
  <p>Аналогичная ситуация произойдёт при обращении к уже не существующему элементу вектора:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;std::string&gt; words = {"one", "two", "three"};

  std::string& ref = words[0];  // псевдоним для начального элемента вектора

  words.clear();

  // обращаться к ссылке ref уже нельзя!
  std::cout &lt;&lt; ref &lt;&lt; "\n";  // неопределённое поведение!
}
</pre>
  <p>Важно не допускать в программах таких ситуаций.</p>
</article>


<!-- 2.7 Функции -->
<article class="article">
  <div class="anchor" id="p2.7"></div>
  <h3>2.7 Функции</h3>

  <p>Функции позволяют отделить часто используемый код и переиспользовать его с разными значениями аргументов. С примером функции мы уже знакомы: в каждой программе вы пишете функцию main, которая не принимает аргументов и возвращает int.</p>

  <h4>Примеры функций</h4>

  <p>Напишем простейшую функцию, вычисляющую сумму двух целых чисел:</p>
<pre>
// в заголовке функции указывается
// тип возвращаемого значения
// и типы аргументов
int Sum(int a, int b) {
  return a + b;
}
</pre>
  <p>Если функция ничего не должна возвращать, её можно объявить как void:</p>
<pre>
void DoSomething(double d, char c) {
  // ...
  // писать return в конце такой функции не обязательно,
  // но если требуется завершить функцию, можно написать просто return;
}

int main() {
  int x = 17, y = 42;
  int z = Sum(x, y);
   DoSomething(3.14, '@');
}
</pre>
  <p>Вот пример рекурсивной функции, вычисляющей факториал:</p>
<pre>
#include &lt;cstdint&gt;
#include &lt;iostream&gt;

std::uint64_t Factorial(std::uint64_t n) {
  if (n == 0) {
    return 1;
  }
  return n * Factorial(n - 1);  // рекурсивный вызов
}

int main() {
  std::cout &lt;&lt; Factorial(5) &lt;&lt; "\n";  // 120
}
</pre>
  <p>Помните, что если делать очень много рекурсивных вызовов, то рано или поздно переполнится стек — область памяти, в которой хранятся аргументы и локальные переменные текущей функции.</p>

  <h4>Аргументы функций</h4>

  <p>Параметры в функции по умолчанию передаются «по значению». Другими словами, функция работает с копиями аргументов. Чтобы лучше представить это, давайте посмотрим, что бы получилось, если бы компилятор заменил вызов функции на непосредственное исполнение кода.</p>
  <p>Возьмём такой фрагмент кода:</p>
<pre>
void f(int x, int y) {
  // работаем с аргументами x и y
}

int main() {
  int a, b;
  // какая-то инициализация a и b

  f(a, b);
}
</pre>
  <p>Заменим его на такой код:</p>
<pre>
int main() {
  int a, b;
  // какая-то инициализация a и b

  {
    // этот блок просто ограничивает время жизни
    // находящихся внутри переменных
    int x = a;
    int y = b;
    // работаем с аргументами x и y
  }
}
</pre>
  <p>Теперь видно, что любое изменение x или y внутри функции никак не затронет a и b.</p>
  <p>Можем ли мы изменить переданный аргумент внутри функции, чтобы это повлияло на аргументы в месте вызова? Да, для этого надо передать аргументы через ссылку или указатель. Вот классический пример функции, меняющей два аргумента местами:</p>
<pre>
void Swap(int& x, int& y) {  // передаём аргументы по ссылке
  int z = x;
  x = y;
  y = z;
}

int main() {
  int a = 1, b = 2;
  Swap(a, b);
  std::cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; "\n";  // 2 1
}
</pre>
  <p>Чтобы понять, как это работает, раскроем снова код функции в месте вызова:</p>
<pre>
int main() {
  int a = 1, b = 2;

  {
    int& x = a;
    int& y = b;
    int z = x;
    x = y;
    y = z;
  }

  std::cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; "\n";  // 2 1
}
</pre>
  <p>Видно, что x и y — это просто псевдонимы для a и b.</p>
  <p>Заметьте, что вызов Swap(1, 2), в отличие от Swap(a, b), не скомпилируется, потому что обычная ссылка должна быть привязана к изменяемому объекту.</p>
  <p>Примером функции из стандартной библиотеки, которая принимает аргумент по ссылке и изменяет его, является std::getline:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string line;

  // Второй аргумент передаётся по ссылке и изменяется внутри функции:
  std::getline(std::cin, line);
}
</pre>
  <p>Иногда копирование объекта может быть очень дорогим (и ненужным). Например, копирование вектора приведёт к копированию всех его элементов. Поэтому вот так передавать вектор в функцию неэффективно:</p>
<pre>
void f(std::vector&lt;int&gt; v) {
  // плохо: при вызове функции создаётся копия вектора
}
</pre>
  <p>Копии можно было бы избежать, если бы вектор передавался по ссылке:</p>
<pre>
void f(std::vector&lt;int&gt;& v) {
  // Но теперь есть другие недостатки:
  // 1. В такую функцию нельзя передать константный вектор.
  // 2. Функция не защищена от случайного изменения вектора:
  v.clear();  // тут компилятор нас не схватит за руку
}
</pre>
  <p>Поэтому самое правильное — передавать такой параметр по константной ссылке:</p>
<pre>
void f(const std::vector&lt;int&gt;& v) {
  // Такой аргумент не требует дорогого копирования,
  // его нельзя случайно изменить внутри,
  // и такую функцию можно вызывать от констант!
}
</pre>
  <p>Давайте запомним: аргументы сложных типов (векторы, строки, любые контейнеры, большие структуры) всегда лучше передавать в функцию по константной ссылке, если функция использует их только для чтения. Из этого правила бывают исключения, но о них мы поговорим отдельно.</p>
  <p>Впрочем, это правило не стоит распространять на обычные встроенные типы:</p>
<pre>
void g(const int& a, const char& c) {
  // так делать не надо, это уже перебор!
  // передавайте такие параметры просто
  // по значению, как int или char
}
</pre>

  <h4>Возвращаемые значения функций</h4>

  <p>В отличие от аргументов, значения сложных типов можно без проблем возвращать из функций. Здесь от ненужного копирования (по крайней мере, для стандартных контейнеров) спасает copy elision.</p>
  <p>Рассмотрим, например, функцию, которая возвращает конкатенацию всех строк из вектора:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

std::string Concatenate(const std::vector&lt;std::string&gt;& parts) {
  std::string result;
  for (const auto& part : parts) {
    result += part;
  }
  return result;
}

int main() {
  std::vector&lt;std::string&gt; parts = {"abra", "ca", "dabra"};
  std::cout &lt;&lt; Concatenate(parts) &lt;&lt; "\n";  // abracadabra
}
</pre>
  <p>Опасно возвращать из функции ссылку на локальную переменную, так как эта ссылка сразу же станет «висячей»:</p>
<pre>
#include &lt;iostream&gt;

int& Sum(int a, int b) {  // ошибка!
  int result = a + b;
  return result;
}

int main() {
  // неопределённое поведение!
  std::cout &lt;&lt; Sum(2, 3) &lt;&lt; "\n";
}
</pre>
  <p>Компиляторы в таких случаях генерируют предупреждения.</p>
  <p>Возвращать значение по ссылке можно только в случае, если оно заведомо будет доступно после завершения функции. Например, так можно вернуть глобальную переменную или аргумент, также переданный по ссылке.</p>

  <h4>Функции-компараторы</h4>

  <p>Пусть имеется структура Date, описывающая день, месяц и год какой-то даты. Создадим вектор дат:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

struct Date {
  int year = 1970;
  int month = 1;
  int day = 1;
};

int main() {
  std::vector&lt;Date&gt; dates = {
    {2020, 3, 15},
    {2019, 1, 21},
    {2021, 1, 30}
  };

  // напечатаем содержимое:
  for (const auto& [year, month, day] : dates) {
    std::cout &lt;&lt; year &lt;&lt; "." &lt;&lt; month
    &lt;&lt; "." &lt;&lt; day &lt;&lt; "\n";
  }
}
</pre>
  <p>Предположим, нам требуется отсортировать даты. Для сортировки нам поможет уже знакомая функция std::sort, но есть нюанс: вызов std::sort(dates.begin(), dates.end()) не скомпилируется, так как компилятор не умеет сравнивать даты между собой. Функция std::sort пытается найти оператор &lt; для сравнения дат, но, увы, для нашей даты такого нет. Мы можем его определить. Он выглядит как функция с особым именем operator &lt;, возвращающая true, если первый аргумент меньше второго:</p>
<pre>
bool operator &lt; (const Date& lhs, const Date& rhs) {
  if (lhs.year != rhs.year) {
    return lhs.year &lt; rhs.year;
  }
  if (lhs.month != rhs.month) {
    return lhs.month &lt; rhs.month;
  }
  return lhs.day &lt; rhs.day;
}
</pre>
  <p>Здесь lhs и rhs — сокращения от left-hand side и right-hand side. Это левый и правый аргументы оператора &lt;. Этот громоздкий код можно записать лаконичнее с использованием функции std::tie, возвращающей кортеж из ссылок, для которого уже определено лексикографическое (покомпонентное) сравнение:</p>
<pre>
bool operator &lt; (const Date& lhs, const Date& rhs) {
  return std::tie(lhs.year, lhs.month, lhs.day) &lt; std::tie(rhs.year, rhs.month, rhs.day);
}
</pre>
  <p>После определения operator &lt; сортировка заработает. Но что, если нам в разных случаях нужно по-разному сортировать даты — например, где-то в хронологическом порядке, а где-то — без учёта года? Можно передать в std::sort третьим аргументом свою функцию сравнения, которая будет использована вместо operator &lt;:</p>
<pre>
bool CompareWithoutYear(const Date& lhs, const Date& rhs) {
  return std::tie(lhs.month, lhs.day) &lt; std::tie(rhs.month, rhs.day);
}

int main() {
  // ...
  std::sort(dates.begin(), dates.end(), CompareWithoutYear);
}
</pre>
  <p>Обратите внимание, что третьим аргументом в std::sort мы передаём саму функцию (без круглых скобок), а не результат её вызова от каких-то аргументов.</p>

  <h4>Лямбда-функции</h4>

  <p>Иногда бывает неудобно определять отдельную именованную функцию для сравнения. Тогда можно определить анонимную лямбда-функцию прямо в месте её использования:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;vector&gt;

struct Date {
  int year, month, day;
};

int main() {
  std::vector&lt;Date&gt; dates;
  std::sort(dates.begin(), dates.end(), [](const Date& lhs, const Date& rhs) {
    return std::tie(lhs.month, lhs.day) &lt; std::tie(rhs.month, rhs.day);
  });
}
</pre>
  <p>Тип возвращаемого значения тут не указывается, компилятор умеет его угадывать по return (его можно указать после круглых скобок на «питоновский» манер через ->, но не обязательно).</p>
  <p>Разберём синтаксис лямбда-функций. Тут видны три блока.</p>
  <ol>
    <li>Квадратные скобки отвечают за контекст. В них мы можем передать переменные, которые объявлены вне лямбда-функции через запятую, и они будут доступны в самой лямбда-функции.</li>
    <li>Круглые скобки отвечают за аргументы функции.</li>
    <li>Фигурные скобки отвечают за тело лямбда-функции.</li>
  </ol>
  <p>Когда лямбды добавлялись в стандарт C++11, разработчики очень не хотели вводить для них новое ключевое слово (как lambda в Python) и обошлись комбинацией скобок. Есть шутка про то, что вот такая программа является вполне корректной:</p>
  <code>int main() {[](){}();}</code>
  <p>Попробуйте разобраться, что тут происходит.</p>
</article>


<!-- 2.8 Шаблоны -->
<article class="article">
  <div class="anchor" id="p2.8"></div>
  <h3>2.8 Шаблоны</h3>

  <p>Шаблоны — это фрагменты обобщённого кода, в котором некоторые типы или константы вынесены в параметры. Шаблонными могут быть функции, структуры (классы) и даже переменные. Компилятор превращает использование шаблона в конкретный код, подставляя в него нужные параметры на этапе компиляции. Шаблоны позволяют писать общий код, пригодный для использования с разными типами данных.</p>
  <p>Стандартная библиотека C++ построена на шаблонах. Раньше её даже называли Standard Template Library (STL, стандартная библиотека шаблонов). Её контейнеры и итераторы являются шаблонными классами, а алгоритмы — шаблонными функциями. Примеры шаблонных конструкций из стандартной библиотеки нам уже встречались: это, например, контейнер std::vector и функция std::sort. В следующем параграфе мы рассмотрим контейнер std::array, размер которого задаётся шаблонной константой времени компиляции. В этом параграфе мы рассмотрим шаблоны функций и структур, параметры которых являются типами. Но прежде чем говорить про шаблоны, рассмотрим перегрузку функций.</p>

  <h4>Перегрузка функций</h4>

  <p>Количество и типы аргументов функции должны быть известны заранее, на этапе компиляции. Но в языке C++ можно создавать функции с одним и тем же именем, но разным набором или типами аргументов и с разными телами. Такие функции называются перегруженными. Рассмотрим, например, семейство перегруженных функций для печати переменной на экран:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

void Print(int value) {
  std::cout &lt;&lt; value &lt;&lt; "\n";
}

void Print(const std::string& name, int value) {
  // печатаем название и саму величину
  std::cout &lt;&lt; name &lt;&lt; ": " &lt;&lt; value &lt;&lt; "\n";
}

void Print(const std::string& str) {
  std::cout &lt;&lt; str &lt;&lt; "\n";
}

int main() {
  Print(42);  // версия 1
  Print("x", 42);  // версия 2
  Print("good bye");  // версия 3
}
</pre>
  <p>Компилятор, сравнивая разные версии функции друг с другом, смотрит на их имена и набор типов аргументов. При этом имена аргументов ни на что не влияют. Также нельзя перегружать функции по типу возвращаемого значения. Действительно, возвращаемое значение может просто игнорироваться в месте вызова, и компилятор не сможет определить, какая версия функции имеется в виду.</p>
<pre>
int f(int x) {
  return x;
}

// ошибка компиляции: функция с таким
// именем и типом параметра уже была
int f(int y) {
  return 2 * y;
}

// ошибка компиляции: перегружать
// по возвращаемому значению нельзя
double f(int x) {
  return 3 * x;
}
</pre>

  <h4>Шаблонные функции</h4>

  <p>Рассмотрим классический пример. Предположим, у нас есть функция, вычисляющая максимум целых чисел:</p>
<pre>
int Max(int x, int y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}
</pre>
  <p>Она определена для аргументов типа int. Однако, если применить её к аргументам типа double, результат получится неожиданным. А её применение к строкам или векторам вообще не скомпилируется:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::cout &lt;&lt; Max(1, 2) &lt;&lt; "\n";  // 2
  std::cout &lt;&lt; Max(3.14159, 2.71828) &lt;&lt; "\n";  // внезапно 3

  std::string word1 = "hello", word2 = "world";
  std::cout &lt;&lt; Max(word1, word2);  // ошибка компиляции
}
</pre>
  <p>В вызове Max(3.14159, 2.71828) аргументы будут преобразованы к типу int, то есть получится Max(3, 2). Вызов Max(word1, word2) не скомпилируется, так как строки нельзя привести к типу int. Чтобы эти вызовы корректно заработали, надо определить перегруженные версии функции Max:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int Max(int x, int y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}

double Max(double x, double y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}

std::string Max(const std::string& x, const std::string& y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}

int main() {
  std::cout &lt;&lt; Max(1, 2) &lt;&lt; "\n";  // 2
  std::cout &lt;&lt; Max(3.14159, 2.71828) &lt;&lt; "\n";  // 3.14159

  std::string word1 = "hello", word2 = "world";
  std::cout &lt;&lt; Max(word1, word2);  // world
}
</pre>
  <p>Выписывать похожие друг на друга версии функций утомительно. Кроме того, такие функции не смогут работать с новыми, неизвестными нам заранее типами. Шаблоны позволяют описать такую функцию один раз, вынеся тип в параметры:</p>
<pre>
template &lt;typename T&gt;
T Max(const T& x, const T& y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}
</pre>
  <p>Шаблон начинается с шапки template. Далее в угловых скобках перечисляются формальные имена параметров. В нашем случае параметр один — это тип T (от слова type). Вместо ключевого слова typename в этом месте допускается использовать слово class (вы можете встретить такие описания шаблонов на cppreference.com). А вместо имени T можно было бы использовать любой другой идентификатор.</p>
  <p>Так как мы не знаем, будет ли тип T встроенным или сложным, то на всякий случай передаём аргументы в функцию по константной ссылке, чтобы избежать лишнего копирования.</p>
  <p>В нашей шаблонной функции Max используется оператор >. Он определён для обычных чисел, строк и векторов (если, конечно, для элементов вектора тоже определён этот оператор). Но если попробовать применить наш шаблон к типу, не поддерживающему оператор >, то произойдёт ошибка компиляции:</p>
<pre>
struct Point {
  double x = 0.0;
  double y = 0.0;
  double z = 0.0;
};

int main() {
  Point p1, p2;
  Point p = Max(p1, p2);  // ошибка компиляции
}
</pre>

  <h4>Вывод шаблонных параметров</h4>
</article>


<!-- 2.9 Разбор задач к главе «Базовые конструкции C++» -->
<article class="article">
  <div class="anchor" id="p2.9"></div>
  <h3>2.9 Разбор задач к главе «Базовые конструкции C++»</h3>
</article>


<!-- 3.1 Последовательные контейнеры -->
<article class="article">
  <div class="anchor" id="p3.1"></div>
  <h2>3 Стандартная библиотека C++</h2>
  <h3>3.1 Последовательные контейнеры</h3>
</article>


<!-- 3.2 Ассоциативные контейнеры -->
<article class="article">
  <div class="anchor" id="p3.2"></div>
  <h3>3.2 Ассоциативные контейнеры</h3>
</article>


<!-- 3.3 Алгоритмы -->
<article class="article">
  <div class="anchor" id="p3.3"></div>
  <h3>3.3 Алгоритмы</h3>
</article>


<!-- 3.4 Адаптеры и представления -->
<article class="article">
  <div class="anchor" id="p3.4"></div>
  <h3>3.4 Адаптеры и представления</h3>
</article>


<!-- 3.5 Разбор задач к главе «Стандартная библиотека C++» -->
<article class="article">
  <div class="anchor" id="p3.5"></div>
  <h3>3.5 Разбор задач к главе «Стандартная библиотека C++»</h3>
</article>


<!-- 4.1 Классы -->
<article class="article">
  <div class="anchor" id="p4.1"></div>
  <h2>4 Идиомы C++</h2>
  <h3>4.1 Классы</h3>
</article>


<!-- 4.2 Шаблонные классы -->
<article class="article">
  <div class="anchor" id="p4.2"></div>
  <h3>4.2 Шаблонные классы</h3>
</article>


<!-- 4.3 Жизненный цикл объекта -->
<article class="article">
  <div class="anchor" id="p4.3"></div>
  <h3>4.3 Жизненный цикл объекта</h3>
</article>


<!-- 4.4 Наследование и полиморфизм -->
<article class="article">
  <div class="anchor" id="p4.4"></div>
  <h3>4.4 Наследование и полиморфизм</h3>
</article>


<!-- 4.5 Обработка исключений -->
<article class="article">
  <div class="anchor" id="p4.5"></div>
  <h3>4.5 Обработка исключений</h3>
</article>


<!-- 4.6 Идиома RAII и умные указатели -->
<article class="article">
  <div class="anchor" id="p4.6"></div>
  <h3>4.6 Идиома RAII и умные указатели</h3>
</article>


<!-- 4.7 Разбор задач к главе «Идиомы C++» -->
<article class="article">
  <div class="anchor" id="p4.7"></div>
  <h3>4.7 Разбор задач к главе «Идиомы C++»</h3>
</article>



<!-- 5.1 Как работать с системой проверки заданий -->
<article class="article">
  <div class="anchor" id="p5.1"></div>
  <h2>5 Приложение</h2>
  <h3>5.1 Как работать с системой проверки заданий</h3>
</article>


<!-- 5.2 Как пользоваться хендбуком -->
<article class="article">
  <div class="anchor" id="p5.2"></div>
  <h3>5.2 Как пользоваться хендбуком</h3>
</article>


