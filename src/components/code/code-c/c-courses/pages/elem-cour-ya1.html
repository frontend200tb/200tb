<article class="article">
  <h1>Яндекс Образования. Хендбук. Основы С++</h1>
  <p>Конспект курса</p>
  <p><a href="https://education.yandex.ru/handbook/cpp" target="_blank">https://education.yandex.ru/handbook/cpp</a></p>
  <p>Авторы: Алексей Зобнин (Яндекс), Владимир Кузнецов (Яндекс), Артём Брустовецкий (Clever Inc. (Kahoot)).</p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
    <a href="#p1.1">1 Введение</a>
    <br><a href="#p1.1">1.1 Введение</a>
  </p>

  <p>
    <a href="#p2.1">2 Базовые конструкции C++</a>
    <br><a href="#p2.1">2.1 Первые шаги</a>
    <br><a href="#p2.2">2.2 Типы данных</a>
    <br><a href="#p2.3">2.3 Ветвления и циклы</a>
    <br><a href="#p2.4">2.4 Векторы и строки</a>
    <br><a href="#p2.5">2.5 Составные типы данных</a>
    <br><a href="#p2.6">2.6 Ссылки, указатели, константность</a>
    <br><a href="#p2.7">2.7 Функции</a>
    <br><a href="#p2.8">2.8 Шаблоны</a>
    <br><a href="#p2.9">2.9 Разбор задач к главе «Базовые конструкции C++»</a>
  </p>

  <p>
    <a href="#p3.1">3 Стандартная библиотека C++</a>
    <br><a href="#p3.1">3.1 Последовательные контейнеры</a>
    <br><a href="#p3.2">3.2 Ассоциативные контейнеры</a>
    <br><a href="#p3.3">3.3 Алгоритмы</a>
    <br><a href="#p3.4">3.4 Адаптеры и представления</a>
    <br><a href="#p3.5">3.5 Разбор задач к главе «Стандартная библиотека C++»</a>
  </p>

  <p>
    <a href="#p4.1">4 Идиомы C++</a>
    <br><a href="#p4.1">4.1 Классы</a>
    <br><a href="#p4.2">4.2 Шаблонные классы</a>
    <br><a href="#p4.3">4.3 Жизненный цикл объекта</a>
    <br><a href="#p4.5">4.4 Наследование и полиморфизм</a>
    <br><a href="#p4.4">4.5 Обработка исключений</a>
    <br><a href="#p4.6">4.6 Идиома RAII и умные указатели</a>
    <br><a href="#p4.7">4.7 Разбор задач к главе «Идиомы C++»</a>
  </p>

  <p>
    <a href="#p5.1">5 Приложение</a>
    <br><a href="#p5.1">5.1 Как работать с системой проверки заданий</a>
    <br><a href="#p5.2">5.2 Как пользоваться хендбуком</a>
  </p>

</article>


<!-- 1.1 Введение -->
<article class="article">
  <div class="anchor" id="p1.1"></div>
  <h2>1 Введение</h2>
  <h3>1.1 Введение</h3>

  <p>Перед вами учебник по основам языка C++. При его создании мы вдохновлялись специализацией «Искусство разработки на современном C++» на «Курсере», созданной при поддержке Яндекса, и курсом «Основы и методология программирования», который читался в 2014–2021 годах на факультете компьютерных наук ВШЭ.</p>

  <p>Языку C++ почти 40 лет, но он по-прежнему очень актуален и востребован. Он оказал огромное влияние на индустрию и на другие языки. C++ был разработан Бьярне Страуструпом в начале 1980-х годов как расширение языка C (и даже изначально назывался «Си с классами»).</p>

  <p>Однако для изучения C++ совсем не обязательно знать C. Тем не менее мы предполагаем, что вы знакомы с основами информатики и владеете каким-либо языком программирования на уровне школьной программы — например, языком Python.</p>

  <p>Впрочем, C++ во многом полностью противоположен Python:</p>
  <ul>
    <li>это компилируемый, а не интерпретируемый язык;</li>
    <li>С++ — язык со статической, а не динамической типизацией;</li>
    <li>в C++ возможно ручное управление памятью (в отличие от автоматической сборки мусора).</li>
  </ul>

  <p>Чтобы исходный код программы на C++ превратился в исполняемый файл для конкретной архитектуры процессора, программу нужно скомпилировать. Существует несколько популярных компиляторов C++:</p>
  <ul>
    <li>GNU Compiler Collection (GCC);</li>
    <li>Clang — построен поверх инфраструктуры LLVM;</li>
    <li>Microsoft Visual C++ (MSVC) — входит в состав Microsoft Visual Studio;</li>
    <li>Intel C++ Compiler.</li>
  </ul>

  <p>Мы будем использовать в примерах и при проверке задач компилятор Clang 16-й версии.</p>

  <p>С 1998 года международный комитет по стандартизации C++ выпускает стандарты — версии языка, в которых описываются его возможности. В первую очередь это руководства для создателей компиляторов, но при возникновении спорных моментов всегда полезно обратиться к стандарту. Мы будем ориентироваться на стандарт C++20, а по ссылке можно ознакомиться с черновиком будущего стандарта. Важно понимать, что стандарт определяет лишь общие требования и не фиксирует детали реализации, которые в разных компиляторах могут отличаться.</p>

  <p>Чтобы проверить, поддерживает ли ваша версия компилятора ту или иную особенность C++, советуем пользоваться специальной таблицей.</p>

  <p>При изучении вам будут полезны следующие англоязычные ресурсы:</p>
  <ul>
    <li>cppreference.com — онлайн-документация по C++;</li>
    <li>isocpp.org — сайт Standard C++ Foundation;</li>
    <li>C++ Core Guidelines — гайдлайны по C++ от Бьярне Страуструпа и Герба Саттера;</li>
    <li>godbolt.org — Compiler Explorer, онлайн-компилятор;</li>
    <li>learncpp.com — современный учебник по C++;</li>
    <li>hacking C++ — наглядный справочник по C++ с картинками и инфографикой.</li>
  </ul>

  <p>В тексте мы будем часто ссылаться на англоязычную версию cppreference.com и на английскую «Википедию».</p>

  <p>Написать программу для C++ можно в любом текстовом редакторе, но удобнее пользоваться средой разработки (IDE). IDE включают редактор кода с подсветкой синтаксиса, а также позволяют компилировать, запускать и отлаживать программы.</p>

  <p>Примеры IDE:</p>
  <ul>
    <li>Microsoft Visual Studio Community</li>
    <li>Eclipse CDT</li>
    <li>Code::Blocks</li>
    <li>Qt Creator</li>
    <li>Xcode</li>
  </ul>

  <p>Мы рассчитываем, что вы сможете самостоятельно разобраться с настройкой и использованием среды разработки, и не будем заострять на этом внимание. В наших примерах мы будем запускать компилятор из консоли.</p>

  <p>К нашему учебнику прилагается набор задач по соответствующим темам. Вы можете сдавать их в автоматическую проверяющую систему. В одних задачах требуется написать полноценную программу, а в других — сдать только код функции или класса. Обратите внимание, что ко всем задачам имеются разборы с авторскими решениями. Найти разборы вы можете в конце глав.</p>

  <p>Ho прежде чем мы двинемся дальше — небольшое объявление: для этого хендбука у нас есть коммьюнити студентов. В нём можно найти единомышленников, обсудить материалы и задания. Вступить в него можно по <a href="https://t.me/handbook_cpp">ссылке</a>. А чтобы быть в курсе обновлений хендбука — советуем подписаться на рассылку.</p>
</article>


<!-- 2.1 Первые шаги -->
<article class="article">
  <div class="anchor" id="p2.1"></div>
  <h2>2 Базовые конструкции C++</h2>
  <h3>2.1 Первые шаги</h3>

  <p>В этом параграфе мы напишем первую программу на C++ и научимся печатать и считывать с клавиатуры строки и числа.</p>

  <h4>Функция main</h4>
  <p>Пожалуй, самая простая и короткая программа на C++ — это программа, которая ничего не делает. Она выглядит так:</p>
<pre>
int main() {
  return 0;
}
</pre>
  <p>Здесь определяется функция с именем main, которая не принимает никаких аргументов (внутри круглых скобок ничего нет) и не выполняет никаких содержательных команд. В каждой программе на C++ должна быть ровно одна функция main — с неё начинается выполнение программы.</p>

  <p>У функции указан тип возвращаемого значения int (целое число), и она возвращает 0 — в данном случае это сообщение для операционной системы, что программа выполнилась успешно. И наоборот, ненулевой код возврата означает, что при выполнении возникла ошибка (например, программа получила некорректные входные данные).</p>

  <p>Для функции main разрешается не писать завершающий return 0, чем мы и будем пользоваться далее для краткости. Поэтому самую короткую программу можно было бы написать вот так:</p>
  <code>int main() {}</code>

  <h4>Hello, world!</h4>
  <p>Соблюдая традиции, напишем простейшую программу на C++ — она выведет приветствие в консоль:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  std::cout &lt;&lt; "Hello, world!\n";
}
</pre>
  <p>Разберём её подробнее.</p>

  <p>Директива #include &lt;iostream&gt; подключает стандартный библиотечный заголовочный файл для работы с потоками ввода-вывода (input-output streams). Для печати мы используем поток вывода std::cout, где cout расшифровывается как character output, то есть «символьный вывод».</p>

  <p>В теле функции main мы передаём в std::cout строку Hello, world! с завершающим переводом строки \n. В зависимости от операционной системы \n будет преобразован в один или в два управляющих байта с кодами 0A или 0D 0A соответственно.</p>

  <p>Инструкции внутри тела функции завершаются точками с запятой.</p>

  <h4>Компиляция из командной строки</h4>
  <p>Вы можете запустить эту программу из какой-нибудь IDE. Мы же покажем, как собрать её в консоли Linux с помощью компилятора clang++.</p>

  <p>Пусть файл с программой называется hello.cpp. Запустим компилятор:</p>
  <code>$ clang++ hello.cpp -o hello</code>
  <p>В результате мы получим исполняемый файл с именем hello, который теперь можно просто запустить. Он напечатает на экране ожидаемую фразу:</p>
<pre>
$ ./hello
Hello, world!
</pre>
  <p>Если опцию -o не указать, то сгенерированный исполняемый файл будет по умолчанию назван a.out. В дальнейшем для простых примеров мы будем использовать краткую форму записи команды:</p>
<pre>
$ clang++ hello.cpp && ./a.out
Hello, world!
</pre>
  <p>С её помощью мы компилируем программу и в случае успеха компиляции сразу же запускаем.</p>

  <h4>Комментарии</h4>
  <p>Комментарии — это фрагменты программы, которые игнорируются компилятором и предназначены для программиста. В C++ есть два вида комментариев — однострочные и многострочные:</p>
<pre>
int main() {  // однострочный комментарий продолжается до конца строки

/* Пример
   многострочного
   комментария */
}
</pre>
  <p>Мы будем использовать комментарии в примерах кода для пояснений, а в реальных программах ими лучше не злоупотреблять.</p>

  <p>Хорошо: комментировать, что делает библиотека, функция или класс или почему этот код написан именно так.</p>

  <p>Плохо: комментировать, что происходит на отдельных строчках. Это признак того, что код можно написать лучше.</p>

  <h4>Библиотеки и заголовочные файлы</h4>
  <p>Библиотека — это код, который можно переиспользовать в разных программах. В стандарт языка C++ входит спецификация так называемой стандартной библиотеки, которая поставляется вместе с компилятором. Она содержит различные структуры данных (контейнеры), типовые алгоритмы, средства ввода-вывода и т. д. Конструкции из этой библиотеки предваряются префиксом std::, который обозначает пространство имён.</p>

  <p>Чтобы воспользоваться теми или иными библиотечными конструкциями, в начале программы надо подключить нужные заголовочные файлы. Так, в программе, которая печатала Hello, world!, нам уже встречался заголовочный файл iostream и конструкция std::cout из стандартной библиотеки.</p>

  <p>Для C++ существует также множество сторонних библиотек. Наиболее известной коллекцией сторонних библиотек для C++ является Boost.</p>

  <h4>Ошибки компиляции</h4>
  <p>Перед запуском программу необходимо скомпилировать. Компилятор проверяет корректность программы и генерирует исполняемый файл. Во время компиляции компилятор может обнаружить синтаксические ошибки.</p>

  <p>Рассмотрим пример такой программы:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  cout &lt;&lt; "Hello, world\n"
</pre>
  <p>Первая ошибка — вместо std::cout мы написали cout. Вторая ошибка — не поставили точку запятой после "Hello, world!\n". Наконец, третья – не закрыли фигурную скобку с телом функции.</p>

  <p>Ошибки компиляции (compile errors) следует отличать от возможных ошибок времени выполнения (runtime errors), которые происходят после запуска программы и, как правило, зависят от входных данных, неизвестных во время компиляции.</p>

  <h4>Отступы и оформление кода</h4>
  <p>Фрагменты программы на C++ могут быть иерархически вложены друг в друга. На верхнем уровне находятся функции, внутри них написаны их тела, в теле могут быть составные операторы, и так далее.</p>

  <p>Среди программистов есть соглашение — писать внутренние блоки кода с отступами вправо: компилятор полностью игнорирует эти отступы, а код читать удобнее. Мы будем использовать отступы в четыре пробела. Также мы будем придерживаться стиля оформления кода, принятого в Яндексе. Имена переменных мы будем писать с маленькой буквы, имена функций и классов — с большой (если речь не идёт о конструкциях стандартной библиотеки, где действуют другие соглашения).</p>

  <h4>Переменные</h4>
  <p>Любая содержательная программа так или иначе обрабатывает данные в памяти. Переменная — это именованный блок данных определённого типа. Чтобы определить переменную, нужно указать её тип и имя. В общем виде это выглядит так:</p>
  <code>Type name;</code>
  <p>где Type — конкретный тип данных (например, строка или число), а name — имя переменной. Имена переменных должны состоять из латинских букв, цифр и знаков подчёркивания и не должны начинаться с цифры. Также можно в одной строке определить несколько переменных одного типа:</p>
  <code>Type name1, name2, name3;</code>
  <p>Например:</p>
<pre>
// библиотека, в которой
// определён тип std::string
#include &lt;string&gt;

int main() {
  // Определяем переменную value
  // целочисленного типа int
  int value;

  // Определяем переменные name и surname
  // типа std::string (текстовая строка)
  std::string name, surname;
}
</pre>
  <p>В этом примере мы используем встроенный в язык тип int (от слова integer — целое число) и поставляемый со стандартной библиотекой тип std::string. (Можно было бы использовать для строк встроенный тип с массивом символов, но это неудобно.)</p>

  <p>Тип переменной должен быть известен компилятору во время компиляции.</p>

  <p>От типа зависит:</p>
  <ul>
    <li>сколько байтов памяти потребуется для хранения данных;</li>
    <li>как интерпретировать эти байты;</li>
    <li>какие операции с этой переменной возможны.</li>
  </ul>

  <p>Например, переменной типа int можно присваивать значения и с ней можно производить арифметические операции. Подробнее про разные типы данных и их размер в памяти мы поговорим ниже.</p>
  <p>Важно понимать, что тип остаётся с переменной навсегда. Например, присвоить целочисленной переменной строку не получится — это вызовет ошибку компиляции:</p>
<pre>
int main() {
  int value;
  value = 42;  // OK
  value = "Hello!";  // ошибка компиляции!
}
</pre>
  <p>Переменные можно сразу проинициализировать значением. В С++ есть много разных способов инициализации. Нам пока будет достаточно способа, который называется copy initialization:</p>
<pre>
#include &lt;string&gt;

int main() {
  int value = 42;
  std::string title = "Bjarne Stroustrup";
}
</pre>
  <p>Если переменная была объявлена, но нигде дальше не использовалась, то компилятор выдаёт об этом предупреждение. При проверке решений мы используем опцию -Werror, которая считает предупреждения компилятора ошибками компиляции.</p>

  <h4>Потоковый ввод и вывод</h4>
  <p>Поток — это абстракция для чтения и записи последовательности данных в форматированном виде.</p>

  <p>Записывать данные можно на экран консоли, в файл, буфер в памяти или в строку. Считывать их можно с клавиатуры, из файла, из памяти. Причём с каждым таким «устройством» можно связать свой поток.</p>

  <p>Важно, что потоки не просто пересылают байты памяти, а применяют форматированный человекочитаемый ввод-вывод. Например, числа печатаются и считываются в десятичной нотации, хотя в памяти компьютера они хранятся в двоичном виде.</p>

  <p>В программе Hello, world! нам уже встречался поток вывода std::cout, по умолчанию связанный с экраном консоли. Познакомимся с потоком ввода std::cin, связанным с клавиатурой. Для его использования нужен тот же заголовочный файл iostream.</p>

  <p>Рассмотрим программу, которая спрашивает имя пользователя и печатает персональное приветствие:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string name;  // объявляем переменную name
  std::cout &lt;&lt; "What is your name?\n";
  std::cin >> name;  // считываем её значение с клавиатуры
  std::cout &lt;&lt; "Hello, " &lt;&lt; name &lt;&lt; "!\n";
}
</pre>
  <p>Обратите внимание на направление угловых скобок в этом примере — они условно показывают направление потока данных. При печати данные выводятся на экран, и стрелки направлены от текста к cout. При вводе данные поступают с клавиатуры, и стрелки направлены от cin к переменной.</p>

  <p>В нашем примере в переменную name считается одно слово, которое будет выведено в ответном сообщении. Пример работы программы:</p>
<pre>
What is your name?
Alice
Hello, Alice!
</pre>
  <p>Однако если ввести строку из нескольких слов с пробелами, то в name запишется только первое слово:</p>
<pre>
$ ./a.out
What is your name?
Alice Liddell
Hello, Alice!
</pre>
  <p>Дело в том, что cin читает поток данных до ближайшего пробельного разделителя (пробела, табуляции, перевода строки или просто конца файла). Чтобы считать в строковую переменную всю строчку целиком (не включая завершающий символ перевода строки), нужно использовать функцию std::getline из заголовочного файла string:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string name;
  std::getline(std::cin, name);
  std::cout &lt;&lt; "Hello, " &lt;&lt; name &lt;&lt; "!\n";
}
</pre>
  <p>В этом примере мы печатаем в одном выражении друг за другом несколько строк ("Hello, ", name и "!\n"), разделённых угловыми скобками &lt;&lt;. Таким образом, cin и cout позволяют кратко считывать и печатать несколько объектов одной командой.</p>

  <p>Например, считывание нескольких чисел целого типа, набранных через пробельные разделители, может выглядеть так:</p>
<pre>
int main() {
  int a;
  int b;
  int c;
  std::cin >> a >> b >> c;
}
</pre>
  <p>Напечатать их значения можно следующим образом:</p>
  <code>std::cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; " " &lt;&lt; c &lt;&lt; "\n";</code>
  <p>Обратите внимание, что мы дополнительно вставляем между ними пробелы, чтобы в выводе числа не слиплись вместе. В конце вывода мы вставляем символ перевода строки \n, чтобы отделить этот результат от последующего вывода или от сообщений командной строки.</p>

  <p>Итак, параграф позади! Впереди вас ждут первые задачи. Но прежде чем приступить к ним, советуем сперва взглянуть на небольшое руководство о том, как пользоваться системой проверки заданий.</p>
</article>


<!-- 2.2 Типы данных -->
<article class="article">
  <div class="anchor" id="p2.2"></div>
  <h3>2.2 Типы данных</h3>
  <p>C++ — язык со статической типизацией. У каждой переменной на этапе компиляции должен быть чётко определённый тип данных. Про каждый тип данных заранее известно, сколько места в памяти занимает переменная такого типа.</p>

  <p>В этом параграфе мы познакомимся с некоторыми базовыми типами данных и с понятием области видимости переменных.</p>

  <h4>Области видимости</h4>

  <p>В С++ существует понятие области видимости (scope) переменной. Эта область ограничивается блоком кода, в котором переменная определена. Рассмотрим пример:</p>
<pre>
#include &lt;iostream&gt;

int a = 1;  // глобальная переменная

int main() {
  int b = 2;  // локальная переменная
  {
    int c = 3;  // локальная переменная внутри блока
    std::cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b
    &lt;&lt; " " &lt;&lt; c &lt;&lt; "\n";  // корректно
  }

  // Эта строчка не скомпилируется,
  // так как переменная c не определена в данной области:
  std::cout &lt;&lt; c &lt;&lt; "\n";
}
</pre>
  <p>В этом примере есть три области:</p>
  <ul>
    <li>глобальная, в которой определена переменная a;</li>
    <li>тело функции main, в которой определена переменная b;</li>
    <li>внутренний блок, в котором определена переменная c.</li>
  </ul>
  <p>В последней строке примера переменная c недоступна, так как её область видимости уже закончилась. В случае коллизии имён компилятор всегда выбирает самую вложенную область видимости.</p>

  <p>Рассмотрим пример:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int x = 1;
  // напечатает 1
  std::cout &lt;&lt; x &lt;&lt; "\n";
  {
    // новая переменная, к предыдущему x не имеет отношения
    int x = 2;
    // напечатает 2
    std::cout &lt;&lt; x &lt;&lt; "\n";
  }
  // снова напечатает 1
  std::cout &lt;&lt; x &lt;&lt; "\n";
}
</pre>

  <h4>Инициализация локальных переменных</h4>
  <p>Локальные переменные простых типов, таких как int, не инициализируются по умолчанию нулём. Компилятор просто выделяет для них байты в стековой памяти, но при этом он не обязан как-либо их заполнять. Это один из принципов C++: мы не должны платить за то, что не используем.</p>

  <p>Следующий фрагмент кода может напечатать всё что угодно:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int x;
  // неопределённое поведение!
  std::cout &lt;&lt; x &lt;&lt; "\n";
  int y;
  // а это допустимый сценарий
  std::cin >> y;
}
</pre>
  <p>Компиляторы g++ и clang++ обычно дают предупреждения о чтении неинициализированных переменных при использовании опции -Wall или -Wuninitialized:</p>
  <p>Заметим, что std::string является сложным типом и переменные такого типа всегда по умолчанию инициализируются пустой строкой. Поэтому нет необходимости писать std::string s = "";. Пишите просто std::string s;.</p>

  <h4>Простые типы данных</h4>
  <p>С типом int мы уже знакомы. Рассмотрим другие фундаментальные типы данных в С++. Это так называемые интегральные типы и типы для вещественных чисел.</p>
<pre>
int main() {
  char c = '1';           // символ
  bool b = true;          // логическая переменная, принимает значения false и true
  int i = 42;             // целое число (занимает, как правило, 4 байта)
  short int si = 17;      // короткое целое (занимает 2 байта)
  long li = 12321321312;  // длинное целое (как правило, 8 байт)
  long long lli = 12321321312; // длинное целое (как правило, 8 байт)
  float f = 2.71828;      // дробное число с плавающей запятой (4 байта)
  double d = 3.141592;    // дробное число двойной точности (8 байт)
  long double ld = 1e15;  // длинное дробное (как правило, 16 байт)
}
</pre>
  <p>Обратите внимание, что символы, в отличие от строк (то есть массивов символов), записываются в апострофах, а не в кавычках. В примере выше мы записываем в переменную c символ единицы. Фактически в памяти хранится ASCII-код этого символа, который равен 49.</p>

  <p>Напомним, что каждый тип данных занимает заранее известное количество байтов памяти. Стандарт языка С++ не накладывает жёстких ограничений на размеры типов, они могут отличаться для разных платформ и компиляторов.</p>

  <p>О том, что делать с этой особенностью, мы расскажем ниже. А пока отметим, что узнать размер переменной или типа на этапе компиляции можно с помощью оператора sizeof.</p>

  <p>Например, на 64-битной Linux-системе компилятор clang++ использует такие размеры для типов:</p>
<pre>
int main() {
  std::cout &lt;&lt; "char: "      &lt;&lt; sizeof(char) &lt;&lt; "\n";                 //  1
  std::cout &lt;&lt; "bool: "      &lt;&lt; sizeof(bool) &lt;&lt; "\n";                 //  1
  std::cout &lt;&lt; "short int: " &lt;&lt; sizeof(short int) &lt;&lt; "\n";       //  2 (по стандарту >= 2)
  std::cout &lt;&lt; "int: "       &lt;&lt; sizeof(int) &lt;&lt; "\n";                   //  4 (по стандарту >= 2)
  std::cout &lt;&lt; "long int: "  &lt;&lt; sizeof(long int) &lt;&lt; "\n";         //  8 (по стандарту >= 4)
  std::cout &lt;&lt; "long long int: " &lt;&lt; sizeof(long long) &lt;&lt; "\n";   //  8 (по стандарту >= 8)
  std::cout &lt;&lt; "float: "     &lt;&lt;sizeof(float) &lt;&lt; "\n";               //  4
  std::cout &lt;&lt; "double: "    &lt;&lt; sizeof(double) &lt;&lt; "\n";             //  8
  std::cout &lt;&lt; "long double: " &lt;&lt; sizeof(long double) &lt;&lt; "\n";   // 16
}
</pre>

  <h4>Размеры стандартных типов</h4>
  <p>По умолчанию числовые типы – знаковые. Они имеют диапазон значений от -2<sup>n-1</sup> до 2<sup>n-1</sup> - 1, где n – количество битов, занимаемых типом. Приставка unsigned перед типом делает его беззнаковым. В этом случае диапазон допустимых значений будет от 0 до 2<sup>n</sup> - 1:</p>
<pre>
int main() {
  unsigned int ui = 4294967295;  // 2^32 - 1
}
</pre>
  <p>Минимальное и максимальное значение, помещающееся в данный числовой тип, можно получить так:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;limits&gt;  // необходимо для numeric_limits

int main() {
  // посчитаем для типа int:
  std::cout &lt;&lt; "minimum value: "
            &lt;&lt; std::numeric_limits&lt;int&gt;::min()
            &lt;&lt; "\n"
            &lt;&lt; "maximum value: "
            &lt;&lt; std::numeric_limits&lt;int&gt;::max()
            &lt;&lt; "\n";
}
</pre>
  <p>Данный пример на 64-битной Linux-системе напечатает:</p>
<pre>
minimum value: -2147483648
maximum value: 2147483647
</pre>
  <p>Приведённые выше примеры вывода оператора sizeof верны для 64-битных архитектур, которые на сегодняшний день распространены повсеместно. Однако если бы мы скомпилировали и запустили такую программу на компьютере с 32-битной архитектурой, то получили бы другие результаты. Например, sizeof(long int) стал бы равен 4, в то время как на современных компьютерах мы получили бы 8. Также бывают встраиваемые системы, под которые тоже можно писать на С++. Там битность архитектуры может быть ещё меньше, чем 32.</p>
  <p>В заголовочном файле cstdint стандартной библиотеки имеются целочисленные типы с фиксированным размером:</p>
  <ul>
    <li>int8_t / uint8_t</li>
    <li>int16_t / uint16_t</li>
    <li>int32_t / uint32_t</li>
    <li>int64_t / uint64_t</li>
  </ul>
  <p>Число в имени типа означает количество бит, используемых для хранения в памяти. Например, int32_t содержит 32 бита (4 байта) и часто соответствует типу int. Если система не поддерживает какой-то тип, то программа с ним просто не скомпилируется.</p>

  <h4>Переполнение целочисленных типов</h4>

  <p>Стандартные числовые типы имеют ограниченный размер и ограниченное множество допустимых значений. При арифметических операциях над числами таких типов может возникнуть переполнение — ситуация, когда результат операции не помещается в тип:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  // на 64-битной платформе sizeof(a) == 4
  unsigned int a = 123456;

  // Произведение a * a не помещается в 4 байта,
  // так как оно больше 2^32
  std::cout &lt;&lt; a * a &lt;&lt; "\n";
}
</pre>

  <p>В этом примере выражение a * a будет иметь тот же тип, что и аргументы. То, что на самом деле будет вычислено, зависит от знаковости типа.</p>
  <p>Беззнаковые типы можно спокойно переполнять: вычисления будут производиться по модулю соответствующей степени двойки. Другими словами, будут учтены только младшие биты результата:</p>
<pre>
int main() {
  // на 64-битной платформе sizeof(x) == 4
  unsigned int x = 0;
  // 4294967295, то есть 2**32 - 1
  unsigned int y = x - 1;
  unsigned int z = y + 1;  // 0
}
</pre>
  <p>Наоборот, для знаковых типов переполнение приводит к так называемому неопределённому поведению (UB, undefined behavior).</p>
  <p>Такая ситуация не считается ошибкой компиляции (в самом деле, на стадии компиляции значения переменных могут быть ещё неизвестны). Но в этом случае стандарт С++ перестаёт что-либо гарантировать по поводу поведения программы. Компиляторы могут использовать такие случаи для оптимизации программ, полагаясь на то, что разработчики пишут код корректно и никогда не допускают неопределённого поведения. Далее нам встретятся и другие случаи неопределённого поведения.</p>
  <p>Беззнаковые типы следует использовать, когда вы имеете дело с битовыми наборами. В остальных случаях предпочтительнее использовать знаковые типы.</p>

  <h4>Арифметические операции</h4>
  <p>Бинарные операции +, - и * работают для чисел стандартным образом. Результат операции деления /, применённой к целым числам, всегда округляется в сторону нуля. Таким образом, для положительных чисел операция / возвращает неполное частное. Остаток от деления целых чисел можно получить с помощью операции %.</p>
<pre>
int main() {
  int a = 7, b = 3;
  int q = a / b;  // 2
  int r = a % b;  // 1
}
</pre>
  <p>Если при делении нужно получить обычное частное, то один из аргументов нужно привести к вещественному типу (например, double) с помощью оператора static_cast:</p>
<pre>
int main() {
  int a = 6, b = 4;
  double q = static_cast&lt;double&gt;(a) / b;  // 1.5
}
</pre>
  <p>Можно было бы написать чуть более кратко: double q = a * 1.0 / b;. Тогда преобразование аргументов произошло бы неявно.</p>
  <p>Арифметические операции над символами, а также сравнение символов друг с другом — это фактически операции над их ASCII-кодами:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  char c = 'A';
  c += 25;  // увеличиваем ASCII-код символа на 25
  std::cout &lt;&lt; c &lt;&lt; "\n";  // Z
}
</pre>
  <p>Операция + применительно к строкам означает конкатенирование (то есть склейку). Это пример перегрузки операции: изначальному оператору сложения чисел в стандартной библиотеке для строки придали новый смысл.</p>
<pre>
#include &lt;string&gt;

int main() {
  std::string a = "Hello, ";
  std::string b = "world!";
  std::string c = a + b;  // Hello, world!
}
</pre>
  <p>Для каждой бинарной операции (например, +) есть версия со знаком равенства (+=) для случая, когда левый аргумент совпадает с переменной, которой присваивается результат:</p>
<pre>
int main() {
  int x = 5;
  x += 3;  // x = x + 3
  x *= x;  // x = x * x
}
</pre>
  <p>Наконец, имеются операторы ++ и -- для увеличения или уменьшения переменной на единицу. Они бывают префиксные (++x) и постфиксные (x++). Отличие состоит в значении выражения, которое будет вычисляться при применении такого оператора. Мы рассмотрим это позже, а пока привыкнем по умолчанию использовать префиксный оператор для обычных чисел:</p>
<pre>
int main() {
  int x = 5;
  ++x;  // 6
  --x;  // снова 5
}
</pre>

  <h4>Числа с плавающей точкой</h4>

  <p>В языке C++ существуют три встроенных типа для записи дробных чисел: float (4 байта), double (8 байт) и long double (16 или 8 байт, в зависимости от платформы). В большинстве случаев рекомендуется использовать тип double.Тип float разумно использовать там, где обрабатываются огромные массивы чисел, и возникает необходимость экономить память.</p>
  <p>Как правило, хранение дробных чисел в С++ основано на стандарте IEEE 754. Число представляется в виде двоичной дроби в экспоненциальной записи: отдельно хранятся бит знака, порядок и мантисса. Мантисса 23 бита (0-22), порядок 8 бит (23-30), знак 1 бит (31).</p>
  <p>Такое представление выгодно отличается от чисел с фиксированной точкой, где хранится фиксированное количество разрядов. Оно позволяет, хотя и с разной степенью точности, представлять числа, отличающиеся на порядки.</p>
  <p>При работе с рациональными числами, знаменатель которых не является степенью двойки, неизбежно возникают погрешности представления. В следующем параграфе мы разберём как следует сравнивать такие числа.</p>

  <h4>Автоматический вывод типа</h4>

  <p>Компилятор C++ умеет автоматически выводить тип переменной по значению, которое ей присваивается. Для этого вместо типа надо написать ключевое слово auto:</p>
<pre>
int main() {
  auto x = 42;  // int
  auto pi = 3.14159;  // double
}
</pre>
  <p>Ключевое слово auto позволяет сократить код и не выписывать сложные типы (нам встретятся дальше монстры вроде std::unordered_multimap&lt;Key, Value&gt;::const_iterator). Важно подчеркнуть, что точный тип переменной всё равно становится известен в момент компиляции.</p>
  <p>При использовании auto со строками нужно быть осторожным. Важно знать, что конструкция auto s = "hello" выведет низкоуровневый тип const char * (указатель на неизменяемый набор символов в памяти), а не тип-обёртку std::string.</p>
  <p>Точные правила вывода типов похожи на правила вывода шаблонных параметров, с которыми мы познакомимся в параграфе про шаблоны.</p>
  <p>В следующем параграфе мы подробнее поговорим о ветвлении и циклах.</p>
</article>


<!-- 2.3 Ветвления и циклы -->
<article class="article">
  <div class="anchor" id="p2.3"></div>
  <h3>2.3 Ветвления и циклы</h3>

  <p>В этом параграфе мы познакомимся с операторами ветвления if и switch, циклами while, do-while и for, а также с оператором goto.</p>

  <h4>Оператор if</h4>
  <p>Условный оператор if записывается так:</p>
<pre>
if (condition) {
  // код, который исполнится в случае,
  // когда условие condition истинно
}
</pre>
  <p>Дополнительно можно добавить ветку кода для случая, когда условие ложно:</p>
<pre>
if (condition) {
  // код, который исполнится,
  // если condition истинно
} else {
  // код, который исполнится,
  // если condition ложно
}
</pre>
  <p>Также можно выстроить цепочку условных операторов:</p>
<pre>
if (condition1) {
  // случай, когда condition1 истинно
} else if (condition2) {
  // случай, когда condition1 ложно,
  // а condition2 истинно
} else if (condition3) {
  // случай, когда condition1 и condition2 ложны,
  // а condition3 истинно
} else {
  // случай, когда condition1,
  // condition2 и condition3 ложны
}
</pre>
  <p>Если код внутри фигурных скобок состоит из одной инструкции, то фигурные скобки можно не писать. Однако рекомендуется ставить фигурные скобки всегда во избежание ошибок.</p>
  <p>На месте condition может стоять любое выражение логического типа. Простейшие примеры таких выражений — это проверка на равенство (==) и неравенство (!=), а также сравнения на меньше / больше (&lt;, &lt;=, > и >=):</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int x;
  std::cin >> x;
  if (x &lt;= 0) {
    std::cout &lt;&lt; "zero or negative\n";
  } else if (x == 1) {
    std::cout &lt;&lt; "one\n";
  } else if (x == 2) {
    std::cout &lt;&lt; "two\n";
  } else {
    std::cout &lt;&lt; "many\n";
  }
}
</pre>

  <h4>Сложные условия</h4>
  <p>Условия можно комбинировать с помощью логических операторов && (и), || (или) и ! (не). Рассмотрим пример, где проверяется принадлежность точки разным интервалам на прямой.</p>
<pre>
int main() {
  int a, b, x;
  /* Тут должна быть логика заполнения объявленных переменных,
  но мы её опустили, чтобы не отвлекаться */

  if (a &lt;= x && x &lt;= b) {
    // точка x лежит на отрезке [a; b]
  } else {
    // точка x лежит вне отрезка [a; b]
  }

  // то же самое можно было бы проверить так:
  if (!(x &lt; a || x > b)) {  // отрицание
    // точка x лежит на отрезке [a; b]
  } else {
    // точка x лежит вне отрезка [a; b]
  }
}
</pre>
  <p>Обратите внимание, что двойное неравенство некорректно проверять через a &lt;= x &lt;= b. Так можно написать, но смысл будет совсем другим: результат сравнения a &lt;= x будет приведён к нулю или единице, и полученное число будет сравниваться с b.</p>
  <p>Операторы сравнения имеют больший приоритет, чем логические операторы, поэтому скобки вокруг элементарных сравнений в сложных условиях не обязательны. А вот оператор отрицания имеет высокий приоритет, поэтому в последнем примере он применяется к условию в скобках. Таблицу приоритета операторов C++ можно посмотреть здесь.</p>
  <p>Операторы && и || ведут себя лениво: если первого аргумента уже достаточно для ответа, то второй аргумент вычисляться не будет. Например, в выражении condition1 && condition2 второе условие не вычисляется, если первое ложно. Это часто используют для проверок корректности:</p>
<pre>
int a, b;
// ...
if (a != 0 && b % a == 0) {
  // b делится на a
}
</pre>

  <h4>Сравнение чисел с плавающей точкой</h4>

  <p>Рассмотрим программу, которая проверяет равенство 0.1 + 0.2 == 0.3:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  double x = 0.1, y = 0.2;
  if (x + y == 0.3) {
    std::cout &lt;&lt; "EQUAL ";
  } else {
    std::cout &lt;&lt; "NOT EQUAL ";
  }

  std::cout &lt;&lt; x + y &lt;&lt; "\n";
}
</pre>
  <p>Логично было бы предположить, что программа выведет EQUAL 0.3, потому что 0.1 + 0.2 = 0.3. Однако программа напечатает NOT EQUAL 0.3. Данная «ошибка вычисления» встречается в большинстве современных языков программирования и обусловлена погрешностью представления этих чисел. Если повысить число знаков дробной части в выводе, мы увидим, что 0.1 + 0.2 == 0.30000000000000004. Подробнее об этом можно прочитать здесь и в этой статье.</p>
  <p>Поскольку операции над числами с плавающей точкой могут содержать погрешность, обычное сравнение через == некорректно. Поэтому правильнее сравнивать модуль разности величин с некой допустимой для нас погрешностью. Модуль дробного числа можно получить с помощью функции std::abs из заголовочного файла cmath. Исходную программу можно было бы переписать так:</p>
<pre>
#include &lt;cmath&gt;
#include &lt;iostream&gt;

int main() {
  double delta = 0.000001;

  double x = 0.1, y = 0.2;
  double sum = x + y;

  if (std::abs(sum - 0.3) &lt; delta) {
    std::cout &lt;&lt; "EQUAL ";
  } else {
    std::cout &lt;&lt; "NOT EQUAL ";
  }

  std::cout &lt;&lt; sum &lt;&lt; "\n";
}
</pre>
  <p>Теперь программа выведет EQUAL 0.3.</p>

  <h4>Оператор switch</h4>

  <p>Рассмотрим простейший калькулятор, считывающий число, затем знак арифметической операции, а затем другое число и печатающий результат. Напишем сначала программу с помощью if и else.</p>
<pre>
#include &lt;cstdint&gt;
#include &lt;iostream&gt;

int main() {
  int64_t a, b;
  char operation;
  std::cin >> a >> operation >> b;

  int64_t result = 0;
  if (operation == '+') {
    result = a + b;
  } else if (operation == '-') {
    result = a - b;
  } else if (operation == '*') {
    result = a * b;
  } else if (operation == '/' || operation == ':') {
    result = a / b;
  } else if (operation == '%') {  // остаток от деления
    result = a % b;
  }

  std::cout &lt;&lt; result &lt;&lt; "\n";
}
</pre>
  <p>Перепишем эту программу через оператор switch. Этот оператор следует рассматривать как условный прыжок на соответствующую метку в зависимости от значения выражения.</p>
<pre>
#include &lt;cstdint&gt;
#include &lt;iostream&gt;

int main() {
  int64_t a, b;
  char operation;
  std::cin >> a >> operation >> b;

  int64_t result;
  switch (operation) {
    case '+':
        result = a + b;
        break;  // если не написать этот break,
                // программа просто пойдёт дальше
                // в код следующего блока case
    case '-':
        result = a - b;
        break;
    case '*':
        result = a * b;
        break;
    case '/':
    case ':':
        result = a / b;
        break;
    case '%':
        result = a % b;
        break;
    default:  // здесь обрабатывается случай,
              // когда ни один case не сработал.
        result = 0;
  }

  std::cout &lt;&lt; result &lt;&lt; "\n";
}
</pre>
  <p>Выражения внутри скобок оператора switch и в блоках case должны быть простого целочисленного или символьного типа. В приведённой выше программе значение + относится к типу char. Использование сложных типов (например, строк) приведёт к ошибке компиляции:</p>
<pre>
int main() {
  std::string name;
  std::cin >> name;
  switch (name) {  // ошибка компиляции
    case "Alice":
        std::cout &lt;&lt; "Hello, Alice!\n";
        break;
  }
}
</pre>

  <h4>Оператор goto</h4>

  <p>Есть шутка, что оператор безусловного перехода goto — это ругательное слово из четырёх букв. Безусловные переходы ломают иерархичность программы, затрудняют чтение и отладку. Доказано, что любую программу можно переписать без оператора goto. Поэтому во многих современных языках goto отсутствует.</p>
  <p>Однако в C++ этот оператор есть по следующим причинам:</p>
  <ul>
    <li>обратная совместимость с языком С;</li>
    <li>удобный выход из вложенных циклов;</li>
    <li>применение в автосгенерированном коде (например, коде конечного автомата), не предназначенном для чтения человеком.</li>
  </ul>
  <p>Мы познакомимся с его синтаксисом, но дальше использовать нигде не будем — и вам не советуем.</p>
<pre>
int main() {
  again:  // метка — это произвольное имя с двоеточием

  std::cout &lt;&lt; "How old are you?\n";
  int age;
  std::cin >> age;

  if (age &lt; 0 || age >= 128) {
    std::cout &lt;&lt; "Wrong age...\n";
    // безусловный прыжок в место, помеченное меткой
    goto again;
  }

  std::cout &lt;&lt; "Your age is " &lt;&lt; age &lt;&lt; ".\n";

  // ...
}
</pre>
  <p>Здесь вводится метка again, на которую осуществляется переход, если возраст введён некорректно. Ниже мы покажем, как можно избавиться от оператора goto.</p>
  <p>С помощью оператора goto нельзя выйти из функции или зайти в неё, а также нельзя перепрыгнуть через объявления переменных (кроме тривиальных случаев):</p>
<pre>
#include &lt;iostream&gt;

int main() {
  goto label;
  int x = 42;
  label:  // ошибка компиляции!
  std::cout &lt;&lt; x &lt;&lt; "\n";
}
</pre>

  <h4>Цикл while</h4>

  <p>В C++ существует несколько видов циклов. Цикл while — это цикл с предусловием. Перед очередной итерацией проверяется условие, и если оно истинно, то цикл продолжается. Рассмотрим пример печати таблицы квадратов чисел от 1 до 10:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int n = 1;
  while (n &lt;= 10) {
    // выводим число и его квадрат через табуляцию
    std::cout &lt;&lt; n &lt;&lt; "\t" &lt;&lt; n * n &lt;&lt; "\n";
    ++n;
  }
}
</pre>
  <p>Здесь мы намеренно разделяем числа и их квадраты не пробелом, а знаком табуляции \t. В консоли такой вывод будет выглядеть выровненным по колонкам с фиксированной шириной:</p>
<pre>
1&#x9;1
2&#x9;4
3&#x9;9
4&#x9;16
5&#x9;25
6&#x9;36
7&#x9;49
8&#x9;64
9&#x9;81
10&#x9;100
</pre>

  <h4>Цикл do-while</h4>

  <p>Это цикл с постусловием. Отличие от цикла while заключается в том, что первая итерация всегда выполняется безусловно. Только после её завершения проверяется условие цикла. Если оно истинно, то цикл продолжается.</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int n = 1;
  do {
    std::cout &lt;&lt; n &lt;&lt; "\t" &lt;&lt; n * n &lt;&lt; "\n";
    ++n;
  } while (n &lt;= 10);
}
</pre>
  <p>Без особых причин пользоваться этим видом циклов не стоит, старайтесь использовать циклы while или for.</p>

  <h4>Цикл for</h4>

  <p>Цикл for — самый гибкий. Он записывается так:</p>
<pre>
for (initialization; condition; action) {
  // тело цикла
}
</pre>
  <p>Как правило, с циклом ассоциируется некоторый параметр, который меняется от итерации к итерации, а цикл выполняется до тех пор, пока некоторое условие на этот параметр истинно.</p>

  <p>Начальное значение такого параметра можно задать в разделе initialization, условие — в condition, а действие над параметром, выполняющееся после каждой итерации, — в action.</p>

  <p>Напечатаем таблицу квадратов через цикл for:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  for (int i = 1; i &lt;= 10; ++i) {
    std::cout &lt;&lt; i &lt;&lt; "\t" &lt;&lt; i * i &lt;&lt; "\n";
  }
}
</pre>
  <p>Напомним, что ++i — традиционная краткая форма записи для выражения i = i + 1.</p>
  <p>Цикл for эквивалентен такому циклу while:</p>
<pre>
{
  initialization;
  while (condition) {
    // тело цикла
    action;
  }
}
</pre>

  <h4>Цикл range-based for</h4>

  <p>Этот цикл применим к контейнерам разной природы (массивам, векторам, спискам и т. д.), с которыми мы познакомимся позже. Пока рассмотрим его на примере строк. Цикл позволяет удобно проитерироваться по символам строки, не используя индексов. В этом примере мы считываем строку и печатаем отдельно все символы строки и их ASCII-коды:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string line;
  std::getline(std::cin, line);
  for (char symbol : line) {
    std::cout &lt;&lt; symbol &lt;&lt; "\t"
    &lt;&lt; static_cast&lt;int&gt;(symbol) &lt;&lt; "\n";
  }
}
</pre>
  <p>Здесь оператор static_cast преобразует символ к числовому типу int, чтобы получить его код. Результат для строки Hello, world! выглядит так:</p>
<pre>
H	72
e	101
l	108
l	108
o	111
,	44
 	32
w	119
o	111
r	114
l	108
d	100
!	33
</pre>
  <p>Обратите внимание, что std::string хранит внутри байты. Если вы вводите символы русского алфавита и у вас используется кодировка UTF-8, ставшая де-факто стандартом, то эти символы будут кодироваться парами байтов. И при такой итерации вы увидите отдельные байты, а не символы.</p>

  <h4>Вложенные циклы</h4>

  <p>Циклы могут быть вложенными. Напечатаем таблицу умножения:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  for (int i = 1; i &lt;= 10; ++i) {
    for (int j = 1; j &lt;= 10; ++j) {
      std::cout &lt;&lt; i * j &lt;&lt; "\t";
    }
    std::cout &lt;&lt; "\n";
  }
}
</pre>
  <p>Результат:</p>
<pre>
  1	   2	 3	 4	 5	 6	 7	 8	 9	10
  2	   4	 6	 8	10	12	14	16	18	20
  3	   6	 9	12	15	18	21	24	27	30
  4	   8	12	16	20	24	28	32	36	40
  5	  10	15	20	25	30	35	40	45	50
  6   12	18	24	30	36	42	48	54	60
  7	  14	21	28	35	42	49	56	63	70
  8	  16	24	32	40	48	56	64	72	80
  9	  18	27	36	45	54	63	72	81	90
  10  20	30	40	50	60	70	80	90	100
</pre>

  <h4>Операторы break и continue</h4>

  <p>Оператор break досрочно заканчивает текущий цикл. Оператор continue прыгает в самый конец тела цикла и, если условие цикла позволяет, переходит на следующую итерацию.</p>
  <p>Типичный пример использования оператора break — выход из формально бесконечного цикла:</p>
<pre>
while (true) {
  // ...
  if (condition) {
    break;
  }
  // ...
}
</pre>
  <p>Кстати, рассмотрим другие способы записать бесконечный цикл.</p>
  <p>Через цикл do-while:</p>
<pre>
do {
  // ...
} while (true);
</pre>
  <p>Через цикл for:</p>
<pre>
for (;;) {
  // ...
}
</pre>
  <p>Напишем программу, которая считывает числа с клавиатуры до тех пор, пока пользователь не введёт ноль, а затем печатает их сумму:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int sum = 0;
  while (true) {
    int x;
    std::cin >> x;
    if (x == 0) {
      break;
    }
    sum += x;
  }
  std::cout &lt;&lt; sum &lt;&lt; "\n";
}
</pre>
  <p>(Здесь, конечно, неявно предполагается, что и сами числа, и результат суммирования помещаются в тип int, и в ходе вычислений не происходит переполнений.)</p>

  <h4>Считывание до конца ввода</h4>

  <p>В предыдущем примере мы считывали числа до тех пор, пока на вход не поступит ноль. Это не очень удобно. Предположим, что вместо ввода с клавиатуры мы читали бы эти числа из файла. Это легко сделать, перенаправив файл на стандартный ввод при запуске программы из консоли:</p>
  <code>./a.out &lt; input.txt</code>
  <p>Следующий цикл считывает числа до тех пор, пока поступающие данные не закончатся:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int sum = 0;
  int x;
  while (std::cin >> x) {
    sum += x;
  }
  std::cout &lt;&lt; sum &lt;&lt; "\n";
}
</pre>
  <p>Здесь вместо условия цикла подставлено выражение std::cin >> x. Кроме считывания x это выражение преобразуется к логическому типу, показывающему, есть ли ещё данные в потоке ввода.</p>
  <p>При вводе данных не из файла, а с клавиатуры можно сымитировать конец ввода комбинацией клавиш Ctrl+D в Linux и macOS или Ctrl+Z в Windows.</p>
  <p>Аналогично можно прочитать строки до конца ввода с помощью std::getline:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string name;
  while (std::getline(std::cin, name)) {
    std::cout &lt;&lt; "Hello, " &lt;&lt; name &lt;&lt; "!\n";
  }
}
</pre>
</article>


<!-- 2.4 Векторы и строки -->
<article class="article">
  <div class="anchor" id="p2.4"></div>
  <h3>2.4 Векторы и строки</h3>

  <p>Вектор (std::vector) и строка (std::string) — это важные базовые контейнеры стандартной библиотеки C++. Они хранят свои элементы в непрерывном фрагменте памяти. Оба этих контейнера предоставляют доступ к элементам по индексу и позволяют эффективно добавлять новые элементы в конец.</p>

  <h4>Контейнер std::vector</h4>

  <p>В стандартной библиотеке C++ вектором (std::vector) называется динамический массив, обеспечивающий быстрое добавление новых элементов в конец и меняющий свой размер при необходимости. Вектор гарантирует отсутствие утечек памяти (об этом мы поговорим в других параграфах, сейчас просто считайте, что это хорошо).</p>

  <p>Для работы с вектором нужно подключить заголовочный файл vector.</p>

  <p>Элементы вектора должны быть одинакового типа, и этот тип должен быть известен при компиляции программы. Он задаётся в угловых скобках после std::vector: например, std::vector&lt;int&gt; — это вектор целых чисел типа int, а std::vector&lt;std::string&gt; — вектор строк.</p>

  <p>Само имя std::vector не является типом данных: это шаблон, в который требуется подставить нужные параметры (тип элемента), чтобы получился конкретный тип данных. Подробнее о том, что такое шаблоны и как их применять, мы расскажем в параграфе «Шаблоны».</p>

  <p>Рассмотрим пример программы, которая заполняет вектор элементами и печатает их через пробел:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; data = {1, 2, 3, 4, 5};
  for (int elem : data) {
    std::cout &lt;&lt; elem &lt;&lt; " ";
  }
  std::cout &lt;&lt; "\n";
}
</pre>
  <p>Здесь мы инициализируем вектор через список инициализации, в котором элементы перечислены через запятую. Другой способ инициализации вектора — указать число элементов и (при необходимости) образец элемента:</p>
<pre>
#include &lt;string&gt;
#include &lt;vector&gt;

int main() {
  // пустой вектор строк
  std::vector&lt;std::string&gt; v1;
  // вектор из пяти пустых строк
  std::vector&lt;std::string&gt; v2(5);
  // вектор из пяти строк "hello"
  std::vector&lt;std::string&gt; v3(5, "hello");
}
</pre>

  <h4>Обращение к элементам</h4>

  <p>Выше мы использовали для печати элементов вектора цикл range-for. Но иногда удобнее работать с индексами. Вектор хранит элементы в памяти последовательно, поэтому по индексу элемента можно быстро найти его положение в памяти. Индексация начинается с нуля:</p>
<pre>
std::vector&lt;int&gt; data = {1, 2, 3, 4, 5};
// начальный элемент вектора
int a = data[0];
// последний элемент вектора (в нём пять элементов)
int b = data[4];
// меняем элемент 3 на -3
data[2] = -3;
</pre>
  <p>Чтобы узнать общее количество элементов в векторе, можно воспользоваться функцией size:</p>
  <code>std::cout &lt;&lt; data.size() &lt;&lt; "\n";</code>
  <p>Отрицательные индексы, как в некоторых других языках программирования, не допускаются.</p>
  <p>Обратите внимание: когда мы обращаемся по индексу через квадратные скобки, проверки его корректности не происходит. Это ещё одно проявление принципа «мы не должны платить за то, что не используем».</p>
  <p>Встроенные валидаторы замедляют программу: предполагается, что программист пишет правильный код и уверен, что индекс i в выражении data[i] неотрицателен и удовлетворяет условию i &lt; data.size(). В этом случае они ему не нужны.</p>
  <p>Если всё же обратиться к вектору по некорректному индексу, то программа во время выполнения попадёт в неопределённое поведение: фактически она попробует прочитать память, не принадлежащую вектору.</p>
  <p>Если вам не хочется делать много лишних проверок, а в корректности индекса вы не уверены, то можно использовать функцию at:</p>
<pre>
std::vector&lt;int&gt; data = {1, 2, 3, 4, 5};
// неопределённое поведение: может произойти всё что угодно
std::cout &lt;&lt; data[42] &lt;&lt; "\n";
// напечатается 1
std::cout &lt;&lt; data.at(0) &lt;&lt; "\n";
// произойдёт исключение std::out_of_range
// его можно будет перехватить и обработать
std::cout &lt;&lt; data.at(42) &lt;&lt; "\n";
</pre>
  <p>Про работу с исключениями мы поговорим отдельно в параграфе «Обработка исключений».</p>
  <p>Рассмотрим функции вектора front и back, которые возвращают его первый и последний элемент без использования индексов:</p>
<pre>
std::vector&lt;int&gt; data = {1, 2, 3, 4, 5};
// то же, что data[0]
std::cout &lt;&lt; data.front() &lt;&lt; "\n";
// то же, что data[data.size() - 1]
std::cout &lt;&lt; data.back() &lt;&lt; "\n";
</pre>
  <p>Важно учитывать, что вызов этих функций на пустом векторе приведёт к неопределённому поведению.</p>
  <p>Для проверки вектора на пустоту вместо сравнения data.size() == 0 принято использовать функцию empty, которая возвращает логическое значение:</p>
<pre>
if (!data.empty()) {
  // вектор не пуст, с ним можно работать
}
</pre>

  <h4>Итерация по индексам</h4>

  <p>Так сложилось, что в стандартной библиотеке индексы и размеры контейнеров имеют беззнаковый тип. Вместо unsigned int или unsigned long int для него используется традиционный псевдоним size_t (а точнее, std::vector&lt;T&gt;::size_type). Тип size_t на самом деле совпадает с uint32_t или uint64_t в зависимости от битности платформы. Его использование в программе дополнительно подчёркивает, что мы имеем дело с индексами или с размером.</p>

  <p>Итерацию по элементам data с помощью индексов можно записать так:</p>
<pre>
for (size_t i = 0; i != data.size(); ++i) {
  std::cout &lt;&lt; data[i] &lt;&lt; " ";
}
</pre>
  <p>Это каноническая форма записи такого цикла: в ней принято использовать сравнение != и префиксный ++i. Для целых чисел не будет разницы, если написать это как-то иначе (например, через &lt; и постфиксный i++), но потом, когда вы будете писать аналогичные циклы для итераторов других контейнеров, разница появится. Давайте привыкнем всегда оформлять цикл по индексам так.</p>
  <p>Беззнаковость типа возвращаемого значения функции size порождает следующую проблему. По правилам, унаследованным ещё от языка C, результат арифметических действий над беззнаковым и знаковым типами приводится к беззнаковому типу. Поэтому выражение data.size() - 1, например, тоже будет беззнаковым. Если data.size() окажется нулём, то такое выражение будет вовсе не минус единицей, а самым большим беззнаковым целым (для 64-битной платформы это 2<sup>64</sup>-1).</p>
  <p>Рассмотрим следующий ошибочный код, который проверяет, есть ли в векторе дубликаты, идущие подряд:</p>
<pre>
// итерация по всем элементам, кроме последнего:
for (size_t i = 0; i &lt; data.size() - 1; ++i) {
  if (data[i] == data[i + 1]) {
    std::cout &lt;&lt; "Duplicate value: " &lt;&lt; data[i] &lt;&lt; "\n";
  }
}
</pre>
  <p>Эта программа будет некорректно работать на пустом векторе. Условие i &lt; data.size() - 1 на первой итерации окажется истинным, и произойдёт обращение к элементам пустого вектора. Правильнее было бы переписать это условие через i + 1 &lt; data.size() или воспользоваться внешней функцией std::ssize, которая появилась в C++20. Она возвращает знаковый размер вектора:</p>
<pre>
for (std::int64_t i = 0; i &lt; std::ssize(data) - 1; ++i) {
  if (data[i] == data[i + 1]) {
    std::cout &lt;&lt; "Duplicate value: " &lt;&lt; data[i] &lt;&lt; "\n";
  }
}
</pre>

  <h4>Добавление и удаление элементов</h4>

  <p>В вектор можно эффективно добавлять элементы в конец и удалять их с конца. Для этого существуют функции push_back и pop_back. Рассмотрим программу, считывающую числа с клавиатуры в вектор и затем удаляющую все нули в конце:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  int x;
  std::vector&lt;int> data;

  // читаем числа, пока не закончится ввод
  while (std::cin >> x) {
    // добавляем очередное число в вектор
    data.push_back(x);
  }

  // Пока вектор не пуст и последний элемент равен нулю
  while (!data.empty() && data.back() == 0) {
    // удаляем этот нулевой элемент
    data.pop_back();
  }
}
</pre>
  <p>Добавление элементов в другие части вектора или их удаление неэффективно, так как требует сдвига соседних элементов. Поэтому отдельных функций, например, для добавления или удаления элементов из начала у вектора нет. Это можно сделать с помощью общих функций insert/erase и итераторов. Мы рассмотрим такие примеры позже.</p>
  <p>Удалить все элементы из вектора можно с помощью функции clear.</p>

  <h4>Резерв памяти</h4>
  <p>Вектор хранит элементы в памяти в виде непрерывной последовательности, друг за другом. При этом в конце последовательности резервируется дополнительное место для быстрого добавления новых элементов. Когда этот резерв заканчивается, при вставке очередного элемента происходит реаллокация: элементы вектора копируются в новый, более просторный блок памяти.</p>
  <p>Реаллокация — довольно дорогая процедура, но если она происходит достаточно редко, то её влияние незначительно. Можно доказать, что если размер нового блока выбирать в два раза больше предыдущего размера, то амортизационная сложность добавления элемента будет константной.</p>
  <p>Текущий резерв вектора можно узнать с помощью функции capacity (не путайте её с функцией size).</p>
  <p>Рассмотрим программу, в которой в вектор последовательно добавляются элементы и после каждого шага печатается размер и резерв:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; data = {1, 2};
  std::cout &lt;&lt; data.size() &lt;&lt; "\t" &lt;&lt; data.capacity() &lt;&lt; "\n";

  data.push_back(3);
  std::cout &lt;&lt; data.size() &lt;&lt; "\t" &lt;&lt; data.capacity() &lt;&lt; "\n";

  data.push_back(4);
  std::cout &lt;&lt; data.size() &lt;&lt; "\t" &lt;&lt; data.capacity() &lt;&lt; "\n";

  data.push_back(5);
  std::cout &lt;&lt; data.size() &lt;&lt; "\t" &lt;&lt; data.capacity() &lt;&lt; "\n";
}
</pre>
  <p>Вот вывод этой программы:</p>
<pre>
2	2
3	4
4	4
5	8
</pre>
  <p>Видно, что размер вектора увеличивается на единицу, а резерв удваивается после исчерпания. Так, при добавлении четвёрки используется имеющаяся в резерве память, а при добавлении тройки и пятёрки происходит реаллокация.</p>
<pre>
vector&lt;int&gt; data = {1, 2, 3, 4};
data.push_back(5);
</pre>
  <p>Иногда требуется заполнить вектор элементами, причём число элементов известно заранее. В таком случае можно сразу зарезервировать нужный размер памяти с помощью функции reserve, чтобы при добавлении элементов не происходили реаллокации. Пусть, например, нам сначала задаётся число слов, а потом сами эти слова, и нам требуется сложить их в вектор:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;std::string&gt; words;

  size_t words_count;
  std::cin >> words_count;

  // Размер вектора остаётся нулевым, меняется только резерв:
  words.reserve(words_count);

  for (size_t i = 0; i != words_count; ++i) {
    std::string word;
    std::cin >> word;
    // Все добавления будут дешёвыми, без реаллокаций:
    words.push_back(word);
  }
}
</pre>
  <p>Если передать в reserve величину меньше текущего резерва, то ничего не поменяется — резерв останется прежним.</p>
  <p>Функцию reserve не следует путать с функцией resize, которая меняет количество элементов в векторе. Если аргумент функции resize меньше текущего размера, то лишние элементы в конце вектора удаляются. Если же он больше текущего размера, то при необходимости происходит реаллокация и в вектор добавляются новые элементы с дефолтным значением данного типа.</p>
<pre>
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; data = {1, 2, 3, 4, 5};

  // поменяли резерв, но размер вектора остался равным пяти
  data.reserve(10);

  data.resize(3);  // удалили последние элементы 4 и 5
  data.resize(6);  // получили вектор 1, 2, 3, 0, 0, 0
}
</pre>

  <h4>Многомерные векторы</h4>

  <p>Воспользуемся вектором векторов, чтобы сохранить матрицу (таблицу) целых чисел. Пусть на вход программы сначала поступают число строк и число столбцов матрицы, а потом — сами элементы построчно:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  size_t m, n;
  std::cin >> m >> n;  // число строк и столбцов

  // создаём матрицу matrix из m строк, каждая из которых — вектор из n нулей
  std::vector&lt;std::vector&lt;int&gt; &gt; matrix(m, std::vector&lt;int&gt;(n));

  for (size_t i = 0; i != m; ++i) {
    for (size_t j = 0; j != n; ++j) {
      std::cin >> matrix[i][j];
    }
  }

  // напечатаем матрицу, выводя элементы через табуляцию
  for (size_t i = 0; i != m; ++i) {
    for (size_t j = 0; j != n; ++j) {
      std::cout &lt;&lt; matrix[i][j] &lt;&lt; "\t";
    }
    std::cout &lt;&lt; "\n";
  }
}
</pre>
  <p>В этом примере мы заранее создали матрицу из нулей, а потом просто меняли её элементы.</p>

  <h4>Сортировка вектора</h4>

  <p>Рассмотрим типичную задачу — отсортировать вектор по возрастанию. Для этого в стандартной библиотеке в заголовочном файле algorithm есть готовая функция sort. Гарантируется, что сложность её работы в худшем случае составляет O(nlogn), где n — число элементов в векторе. Типичные реализации используют алгоритм сортировки Introsort.</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; data = {3, 1, 4, 1, 5, 9, 2, 6};

  // Сортировка диапазона вектора от начала до конца
  std::sort(data.begin(), data.end());

  // получим вектор 1, 1, 2, 3, 4, 5, 6, 9
}
</pre>
  <p>В функцию sort передаются так называемые итераторы, ограничивающие рассматриваемый диапазон. В нашем случае мы передаём диапазон, совпадающий со всем вектором, от начала до конца. Соответствующие итераторы возвращают функции begin и end (не путать с front и back!). Итераторы можно считать обобщёнными индексами (но они могут быть и у контейнеров, не допускающих обычную индексацию). Подробнее про итераторы мы поговорим в отдельном параграфе.</p>
  <p>Для сортировки по убыванию можно передать на вход обратные итераторы rbegin() и rend(), представляющие элементы вектора в перевёрнутом порядке:</p>
<pre>
std::sort(data.rbegin(), data.rend());
// 9, 6, 5, 4, 3, 2, 1, 1
</pre>
  <p>В C++20 доступен более элегантный способ сортировки через std::ranges::sort:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; data = {3, 1, 4, 1, 5, 9, 2, 6};
  // можно передать сам вектор, а не его диапазоны
  std::ranges::sort(data);
}
</pre>
  <p>Для сортировки по умолчанию используется сравнение элементов с помощью оператора &lt;. Этот оператор работает и для самих векторов: они сравниваются лексикографически. Поэтому можно без проблем отсортировать, например, строки в матрице (векторе векторов целых чисел).</p>

  <h4>Строки</h4>

  <p>Контейнер std::string можно рассматривать как особый случай вектора символов std::vector&lt;char&gt;, имеющий набор дополнительных функций. В частности, у строки есть все те же рассмотренные нами функции, что и у вектора (например, pop_back или resize). Рассмотрим некоторые специфические функции строки:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string s = "Some string";

  // приписывание символов и строк
  // добавляем отдельный символ в конец, это аналог push_back
  s += ' ';
  s += "functions";  // добавляем строку в конец
  std::cout &lt;&lt; s &lt;&lt; "\n";  // Some string functions

  // выделение подстроки
  // подстрока "string" из 6 символов начиная с 5-й позиции
  std::string sub1 = s.substr(5, 6);
  // подстрока "functions" с 12-й позиции и до конца
  std::string sub2 = s.substr(12);

  // поиск символа или подстроки
  // позиция первого пробела, в данном случае 4
  size_t pos1 = s.find(' ');
  // позиция следующего пробела (11)
  size_t pos2 = s.find(' ', pos1 + 1);
  // вернётся 5
  size_t pos3 = s.find("str");
  вернётся std::string::npos
  size_t pos4 = s.find("#");  //
}
</pre>

  <p>Вставку, замену и удаление подстрок можно сделать через указание индекса начала и длины подстроки:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string s = "Some string functions";

  // вставка подстроки
  s.insert(5, "std::");
  std::cout &lt;&lt; s &lt;&lt; "\n";  // Some std::string functions

  // замена указанного диапазона на новую подстроку
  s.replace(0, 4, "Special");
  std::cout &lt;&lt; s &lt;&lt; "\n";  // Special std::string functions

  // удаление подстроки
  s.erase(8, 5);  // Special string functions
}
</pre>
  <p>Аналогичные действия для других контейнеров (например, для того же вектора) можно сделать через итераторы. Мы рассмотрим такие примеры в одном из следующих параграфов.</p>
  <p>В C++20 появились удобные функции starts_with и ends_with для проверки префикса или суффикса строк:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string phrase;
  std::getline(std::cin, phrase);

  if (phrase.starts_with("hello")) {
    std::cout &lt;&lt; "Greeting\n";
  }

  if (phrase.ends_with("bye")) {
    std::cout &lt;&lt; "Farewell\n";
  }
}
</pre>
</article>


<!-- 2.5 Составные типы данных -->
<article class="article">
  <div class="anchor" id="p2.5"></div>
  <h3>2.5 Составные типы данных</h3>

  <p>C++ позволяет конструировать новые типы данных на основе базовых типов. В этом параграфе мы познакомимся с перечислениями и структурами, а также рассмотрим конструкции std::pair и std::tuple из стандартной библиотеки.</p>

  <h4>Перечисления</h4>

  <p>Предположим, что мы пишем программу для обработки изображений и хотим работать с цветами. Для каждого цвета заводить отдельную константу не очень удобно. Воспользуемся перечислением — специальным типом данных, который состоит из конечного набора именованных констант:</p>
<pre>
enum class Color {
  White,
  Red,
  Orange,
  Blue,
};
</pre>
  <p>Мы описали новый тип данных Color с четырьмя допустимыми значениями. Теперь к каждому цвету можно обращаться через префикс Color:::</p>
<pre>
int main() {
  Color color1 = Color::Red;
  Color color2 = Color::Blue;
}
</pre>
  <p>Фактически перечисления — это удобный способ описывать однотипные именованные константы. По умолчанию перечисления хранятся как тип int, а их значения последовательно нумеруются с нуля. И тип, и конкретное значение можно поменять.</p>
  <p>Преобразовать перечисление в число и обратно можно с помощью оператора static_cast:</p>
<pre>
int value = static_cast&lt;int&gt;(color2);  // 3
Color color3 = static_cast&lt;Color&gt;(2);  // Color::Orange
</pre>
  <p>Раньше в C++ перечисления объявлялись вот так, без слова class:</p>
<pre>
enum Color {
  White,
  Red,
  Orange,
  Blue,
};

// можно даже без названия
enum {
  Apple,
  Orange,
  Banana
};
</pre>
  <p>Этот способ остался в языке. Но в таком случае все имена внутри перечислений являются глобальными, и могут происходить конфликты имён (Orange в примере). Такая программа просто не скомпилируется.</p>

  <h4>Структуры</h4>

  <p>Часто хочется собрать «под одной крышей» несколько переменных. В таких случаях можно использовать структуры. Например, давайте опишем структуру точек из трёхмерного пространства:</p>
<pre>
struct Point {
  double x = 0.0;
  double y = 0.0;
  double z = 0.0;
  Color color;  // пусть у нас будет цветная точка
};
</pre>
  <p>В данном случае мы описали новый тип данных — Point, который содержит в себе четыре переменные.</p>
  <p>Давайте поработаем с этой структурой:</p>
<pre>
int main() {
  // по умолчанию координаты будут нулевыми,
  // а color никак не будет проинициализирован
  Point point1;
  point1.color = Color::Blue;

  Point point2 = {1.4, -2.2, -3.98, Color::Red};
  // x = 1.4, y = -2.2, z = -3.98, color = Color::Red

  // обращаться к полям можно через точку
  point2.z = 32;
  // и вообще работать с ними как с обычными переменными
  point2.x += 2;
}
</pre>
  <p>В С++20 появилась новая форма инициализации структур — designated initializers:</p>
<pre>
int main() {
  Point point3 = {.x = 1.4, .y = -2.2, .z = -3.98};
  Point point4 = {.color = Color::Orange};
}
</pre>
  <p>Такой способ записи понятнее: сразу видно, какое поле структуры каким значением инициализируется. Важно, что поля должны быть перечислены в том же порядке, в каком они указываются при описании структуры (причину этого мы узнаем в параграфе про конструкторы и жизненный цикл объекта). Пропущенные поля будут инициализироваться значением по умолчанию. Так, point3.color будет равно Color::White — нулевому значению перечисления Color.</p>

  <h4>Выравнивание</h4>

  <p>Теперь давайте поговорим про размеры перечислений и структур:</p>
<pre>
int main() {
  std::cout &lt;&lt; sizeof(double) &lt;&lt; "\n";  // 8
  std::cout &lt;&lt; sizeof(Color) &lt;&lt; "\n";   // 4 (фактически это int)
  std::cout &lt;&lt; sizeof(Point) &lt;&lt; "\n";   // 32
}
</pre>
  <p>Получается, что размер структуры Point (32 байта) не равен сумме размеров её частей (8 + 8 + 8 + 4 = 28). Всё дело в выравнивании: компилятору не очень удобно работать со структурой в 28 байт при условии, что внутри этой структуры есть переменные, размер которых — 8 байт (так как 28 не кратно 8). Поэтому компилятор резервирует за структурой несколько лишних байтов (в нашем случае — 4).</p>
  <p>Можно явно попросить компилятор не выделять мнимых байтов, но в таком случае пострадает скорость — потому что если данные в памяти выровнены, то их легче достать и проще обрабатывать.</p>

  <h4>Кортежи и пары</h4>

  <p>В заголовочном файле utility есть шаблонная структура std::pair с полями first и second. Из названия просто догадаться, что она хранит два объекта:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;utility&gt;

int main() {
  // в угловых скобках нужно указывать два типа:
  std::pair&lt;int, double&gt; p = {42, 3.14};

  // обращаться к полям можно через .first и .second:
  std::cout &lt;&lt; p.first &lt;&lt; "\n";  // 42
  std::cout &lt;&lt; p.second &lt;&lt; "\n"; // 3.14
}
</pre>
  <p>Однако у std::pair есть проблема — её поля обезличены, и не очень ясно, какую смысловую нагрузку несёт first, а какую — second. Из-за этого мы советуем не злоупотреблять данной структурой, кроме случаев, когда она используется в функциях стандартной библиотеки.</p>
  <p>Обобщением пары на несколько переменных является кортеж — std::tuple, объявленный в заголовочном файле tuple:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;tuple&gt;

struct Point;  // определена выше

int main() {
  std::tuple&lt;int, double, Point&gt; t = {42, 3.14, {.color = Color::Orange}};

  // тут уже нет полей .first и .second,
  // но есть стандартная функция std::get&lt;&gt;,
  // которая принимает в угловых скобках
  // индекс элемента (индексация с нуля):
  std::cout &lt;&lt; std::get&lt;0&gt;(t) &lt;&lt; "\n";   // 42
  std::cout &lt;&lt; std::get&lt;1&gt;(t) &lt;&lt; "\n";   // 3.14
  std::cout &lt;&lt; std::get&lt;2&gt;(t).x &lt;&lt; "\n"; // 0.0

  // вызов std::get может появляться и слева от присваивания:
  std::get&lt;2&gt;(t).color = Color::Red;
}
</pre>
  <p>Важно понимать, что типы элементов пары или кортежа, а также размер кортежа фиксируются на этапе компиляции.</p>
  <p>Пару, кортеж или структуру можно «распаковать» с помощью structured binding.</p>
<pre>
#include &lt;string&gt;
#include &lt;utility&gt;

int main() {
  std::pair&lt;std::string, int&gt; p = {"hello", 42};
  auto [word, freq] = p;  // word = "hello"; freq = 42;
}
</pre>
  <p>Здесь конструкция auto [word, freq] = p вводит две новые переменные word и freq соответствующих типов и присваивает им значения из пары.</p>
</article>


<!-- 2.6 Ссылки, указатели, константность -->
<article class="article">
  <div class="anchor" id="p2.6"></div>
  <h3>2.6 Ссылки, указатели, константность</h3>

  <p>Ссылки позволяют вводить псевдонимы для переменных. Указатели — это самостоятельные типы данных, которые могут хранить адреса других переменных в памяти. Ключевое слово const позволяет подчеркнуть, что переменная используется только для чтения. Часто оно используется совместно с объявлением ссылок и указателей.</p>

  <h4>Копии переменных</h4>

  <p>Для начала давайте рассмотрим такой фрагмент кода:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string s1 = "Elementary, my dear Watson!";
  std::string s2 = s1;

  s1.clear();  // s2 никак не изменится

  std::cout &lt;&lt; s1 &lt;&lt; "\n";  // пустая строка
  std::cout &lt;&lt; s2 &lt;&lt; "\n";  // Elementary, my dear Watson!
}
</pre>
  <p>Важно понимать, что здесь s2 будет совершенно новой строкой, которая проинициализирована значением s1, но более никак с s1 не связана. Это отличает С++ от некоторых других языков программирования — например, языка Python. В них после аналогичного присваивания строка осталась бы той же самой.</p>
  <p>Создание новой строки s2 требует ресурсов: нужно выделить новый блок памяти и скопировать туда старую строку.</p>

  <h4>Ссылки</h4>
  <p>Впрочем, в C++ есть возможность обращаться к уже существующему в памяти объекту под другим именем. Рассмотрим это на примере целых чисел:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int x = 42;
  int& ref = x;  // ссылка на x

  ++x;
  std::cout &lt;&lt; ref &lt;&lt; "\n";  // 43
}
</pre>
  <p>Здесь ref — псевдоним для x. Это не самостоятельная переменная, а просто ссылка на объект, уже живущий в памяти. Формально типом ref является int& — ссылка на int.</p>
  <p>Аналогично для строк:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string s1 = "Elementary, my dear Watson!";
  std::string& s2 = s1;  // тут ссылка!

  s1.clear();

  std::cout &lt;&lt; s2.size() &lt;&lt; "\n";  // напечатает 0
}
</pre>
  <p>Ссылка должна быть проинициализирована сразу в момент объявления. Например, так написать нельзя:</p>
<pre>
int main() {
  int my_variable = 42;
  int& ref;  // ошибка!
  // ...
  ref = my_variable;
}
</pre>
  <p>Ссылка привязана к одному и тому же объекту со своего рождения. Переназначить её нельзя:</p>
<pre>
int main() {
  int x = 42, y = 13;
  int& ref = x;  // OK
  ref = y;
  // ссылка останется привязанной к x,
  // значение x поменяется
}
</pre>
  <p>Ссылки удобны там, где исходное имя слишком громоздко (например, является вложенным полем какой-либо структуры).</p>

  <h4>Указатели</h4>
  <p>Другой (более базовый) способ сослаться на что-то уже существующее в памяти — указатели. Это специальные типы данных, которые могут хранить адрес какой-либо другой переменной в памяти. Здесь мы можем представлять себе память как длинную ленту с пронумерованными ячейками (байтами). Сам адрес переменной можно получить с помощью унарного оператора &:</p>
<pre>
int main() {
  int x = 42;
  // сохраняем адрес в памяти переменной x в указатель ptr
  int* ptr = &x;

  ++x;  // увеличим x на единицу
  std::cout &lt;&lt; *ptr &lt;&lt; "\n";  // 43
}
</pre>
  <p>Формально указатель — это не номер ячейки памяти, а отдельный тип. Но обычно он может быть преобразован к целому числу. Вот такой код напечатает адреса переменных в шестнадцатеричном виде:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int x = 1, y = 2, z = 3;
  std::cout &lt;&lt; &x &lt;&lt; "\n";
  std::cout &lt;&lt; &y &lt;&lt; "\n";
  std::cout &lt;&lt; &z &lt;&lt; "\n";
}
</pre>
  <p>Пример вывода:</p>
<pre>
0x7ffdfee3188c
0x7ffdfee31888
0x7ffdfee31884
</pre>
  <p>Можно заметить, что адреса будут идти «рядом» с шагом sizeof(int) по возрастанию или убыванию — это зависит от платформы и компилятора. Но при повторном запуске программы они могут отличаться, так как программе может быть назначен совсем другой сегмент памяти.</p>
  <p>Кроме адреса ячейки памяти переменная-указатель обладает ещё и типом данных, значение которого в этой ячейке лежит. Это позволяет компилятору правильно интерпретировать обращение к памяти по этому адресу. Поэтому мы используем не какой-либо абстрактный тип «указатель», а именно «указатель на int».</p>
  <p>Оператор разыменования (унарная звёздочка) противоположен оператору взятия адреса (унарному амперсанду). Сравните: &x — это адрес x в памяти, а *ptr — это значение, живущее по адресу, записанному в ptr.</p>
  <p>Указатели, в отличие от ссылок, можно переназначать. Кроме того, есть выделенное значение никуда не ссылающегося указателя — nullptr («нулевой» указатель):</p>
<pre>
#include <iostream>

int main() {
  int x = 42, y = 13;
  // по умолчанию не инициализируется, тут лежит «случайный» адрес
  int* ptr;
  ptr = nullptr;  // «нулевой» указатель
  ptr = &x;  // теперь в ptr лежит адрес переменной x
  std::cout &lt;&lt; *ptr &lt;&lt; "\n";  // 42
  ptr = &y;  // можно поменять адрес, записанный в ptr
  std::cout &lt;&lt; *ptr &lt;&lt; "\n";  // 13
}
</pre>
  <p>Указатель nullptr нельзя разыменовывать: это приведёт к неопределённому поведению.</p>
  <p>Часто указатели используются вместе с динамическим выделением памяти (malloc/new). Мы познакомимся с динамической памятью в параграфе «Жизненный цикл объекта». А сейчас лишь стоит заметить, что указатель сам по себе совершенно не означает, что память, на которую он ссылается, была выделена динамически. Например, во всех примерах выше указатель ссылался на обычную переменную на стеке.</p>
  <p>Отдельно рассмотрим <strong>указатели на структуру</strong>. Для обращения к полям структуры через указатель есть отдельный оператор ->:</p>
<pre>
#include &lt;iostream&gt;

struct Point {
  double x, y, z;
};

int main() {
  Point p = {3.0, 4.0, 5.0};

  Point* ptr = &p;

  // обращение через * и . требует скобок
  std::cout &lt;&lt; (*ptr).x &lt;&lt; "\n";
  // то же самое, но чуть короче
  std::cout &lt;&lt; ptr->x &lt;&lt; "\n";
}
</pre>

  <h4>Константность</h4>

  <p>Константа — это переменная, предназначенная только для чтения. Её значение должно быть зафиксировано в момент присваивания. При этом оно не обязательно должно быть известно в момент компиляции:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  // эта константа известна в compile time
  const int c1 = 42;

  int x;
  std::cin >> x;
  // значение становится известным только в runtime
  const int c2 = 2 * x;

  // ошибка компиляции: константе нельзя присвоить новое значение
  с2 = 0;
}
</pre>
  <p>У константного вектора или строки нельзя будет вызвать функции, которые их будут изменять:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  const std::vector&lt;int&gt; v = {1, 3, 5};

  // OK, напечатает 3
  std::cout &lt;&lt; v.size() &lt;&lt; "\n";

  // ошибка компиляции: константный вектор нельзя изменять
  v.clear();

  // тоже ошибка компиляции
  v[0] = 0;
}
</pre>
  <p>Ссылки и указатели можно комбинировать с константностью:</p>
<pre>
int main() {
  int x = 42;

  // обычная ссылка
  int& ref = x;

  // константная ссылка
  const int& cref = x;
  ++x;  // OK
  ++ref;  // OK

  // ошибка компиляции: псевдоним cref предназначен только для чтения
  ++cref;

  // обычный указатель
  int* ptr = &x;

  // указатель на константу
  const int* cptr = &x;
  ++*ptr;  // OK

  // ошибка компиляции: разыменованный cptr — константа!
  ++*cptr;
}
</pre>
  <p>Если исходная переменная уже была константной, то взять обычную ссылку или указатель на неё не получится. Другими словами, константность нельзя просто так отменить, её можно только добавить:</p>
<pre>
int main() {
  const int cx = 42;

  // ошибка компиляции: константность нельзя убрать
  int& ref = cx;
  const int& cref = cx;  // OK

  // тоже ошибка компиляции
  int* ptr = &cx;
  const int* cptr = &cx;  // OK
}
</pre>
  <p>Базовый тип и слово const можно менять местами. Так что const T и T const — это одно и то же. Но следует различать указатель на константу (const T*) и константу типа «указатель» (T* const):</p>
<pre>
int main() {
  int x = 42;
  const int cx = 13;

  // обычный указатель
  int* ptr = &x;
  // ошибка компиляции
  ptr = &cx;

  // OK: через *cptr нельзя будет изменить x
  const int* cptr = &x;
  cptr = &cx;  // OK

  // OK: *ptrc можно менять, но сам ptrc менять нельзя
  int* const ptrc = &x;
  ptrc = nullptr;  // ошибка компиляции

  // OK, для &cx тоже бы сработало
  const int* const cptrc = &x;
}
</pre>
  <p>Пример в последней строке похож на константную ссылку: указатель cptrc не позволяет менять содержимое ячейки &x (первый const) и в него нельзя записать адрес другой переменной (второй const).</p>

  <h4>Ссылки в цикле range-for</h4>

  <p>Рассмотрим итерацию по элементам вектора строк. Намеренно положим в вектор много длинных строк и в цикле попробуем подсчитать их длину (которую, конечно, можно было бы сразу вычислить):</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  // создаём вектор из m строк длины n
  // и искусственно заполняем его:
  const size_t m = 1000000;
  const size_t n = 10000;
  std::vector&lt;std::string&gt; v(m);
  for (size_t i = 0; i != m; ++i) {
    v[i].resize(n, '@');  // кладём в вектор строку из n символов @
  }

  // нам интересен этот цикл:
  size_t sum = 0;
  for (auto row : v) {
    sum += row.size();
  }
  std::cout &lt;&lt; sum &lt;&lt; "\n";
}
</pre>
  <p>Скомпилируем программу с умеренным уровнем оптимизаций (ключ -O2) и измерим время её работы с помощью консольной утилиты time:</p>
<pre>
$ clang++ -O2 -o runnable test.cpp
$ time ./runnable

real   0m4,255s
user   0m1,948s
sys    0m2,307s
</pre>
  <p>Программа работала 4,255 секунды. Давайте её ускорим. Заметим, что в цикле мы пишем</p>
<pre>
for (auto row : v) {
  // ...
}
</pre>
  <p>На самом деле это эквивалентно такому:</p>
<pre>
for (size_t i = 0; i != v.size(); ++i) {
  std::string row = v[i];  // здесь создаётся копия!
  // ...
}
</pre>
  <p>Понятно, что вместо копирования очередной строки можно воспользоваться константной ссылкой:</p>
<pre>
for (const auto& row : v) {
  // ...
}
</pre>
  <p>Время работы такой программы уже будет меньше:</p>
<pre>
$ time ./runnable

real   0m3,462s
user   0m1,157s
sys    0m2,305s
</pre>
  <p>Давайте запомним: чтобы избегать лишнего копирования, в range-for используйте константную ссылку при итерации по набору «тяжёлых» объектов — строк, векторов, структур. Если вы хотите в цикле менять элементы контейнера — используйте обычную ссылку. Нашу программу можно было бы переписать так:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  const size_t m = 1000000;
  const size_t n = 10000;
  std::vector&lt;std::string&gt; v(m);
  for (auto& row : v) {  // обычная ссылка
    row.resize(n, '@');
  }

  size_t sum = 0;
  for (const auto& row : v) {  // константная ссылка
    sum += row.size();
  }
  std::cout &lt;&lt; sum &lt;&lt; "\n";
}
</pre>

  <h4>«Висячие» ссылки и указатели</h4>

  <p>Может так оказаться, что переменная, на адрес которой ссылается указатель, уже вышла из своей области видимости. Похожая ситуация может произойти и со ссылками. В таком случае обращаться к памяти через ссылку или указатель нельзя — это приведёт к неопределённому поведению.</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int* ptr = nullptr;

  {
    int x = 42;
    ptr = &x;
  }

  // обращаться к памяти, в которой жила переменная x, уже нельзя:
  // неопределённое поведение!
  std::cout &lt;&lt; *ptr &lt;&lt; "\n";
}
</pre>
  <p>Аналогичная ситуация произойдёт при обращении к уже не существующему элементу вектора:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;std::string&gt; words = {"one", "two", "three"};

  std::string& ref = words[0];  // псевдоним для начального элемента вектора

  words.clear();

  // обращаться к ссылке ref уже нельзя!
  std::cout &lt;&lt; ref &lt;&lt; "\n";  // неопределённое поведение!
}
</pre>
  <p>Важно не допускать в программах таких ситуаций.</p>
</article>


<!-- 2.7 Функции -->
<article class="article">
  <div class="anchor" id="p2.7"></div>
  <h3>2.7 Функции</h3>

  <p>Функции позволяют отделить часто используемый код и переиспользовать его с разными значениями аргументов. С примером функции мы уже знакомы: в каждой программе вы пишете функцию main, которая не принимает аргументов и возвращает int.</p>

  <h4>Примеры функций</h4>

  <p>Напишем простейшую функцию, вычисляющую сумму двух целых чисел:</p>
<pre>
// в заголовке функции указывается
// тип возвращаемого значения
// и типы аргументов
int Sum(int a, int b) {
  return a + b;
}
</pre>
  <p>Если функция ничего не должна возвращать, её можно объявить как void:</p>
<pre>
void DoSomething(double d, char c) {
  // ...
  // писать return в конце такой функции не обязательно,
  // но если требуется завершить функцию, можно написать просто return;
}

int main() {
  int x = 17, y = 42;
  int z = Sum(x, y);
   DoSomething(3.14, '@');
}
</pre>
  <p>Вот пример рекурсивной функции, вычисляющей факториал:</p>
<pre>
#include &lt;cstdint&gt;
#include &lt;iostream&gt;

std::uint64_t Factorial(std::uint64_t n) {
  if (n == 0) {
    return 1;
  }
  return n * Factorial(n - 1);  // рекурсивный вызов
}

int main() {
  std::cout &lt;&lt; Factorial(5) &lt;&lt; "\n";  // 120
}
</pre>
  <p>Помните, что если делать очень много рекурсивных вызовов, то рано или поздно переполнится стек — область памяти, в которой хранятся аргументы и локальные переменные текущей функции.</p>

  <h4>Аргументы функций</h4>

  <p>Параметры в функции по умолчанию передаются «по значению». Другими словами, функция работает с копиями аргументов. Чтобы лучше представить это, давайте посмотрим, что бы получилось, если бы компилятор заменил вызов функции на непосредственное исполнение кода.</p>
  <p>Возьмём такой фрагмент кода:</p>
<pre>
void f(int x, int y) {
  // работаем с аргументами x и y
}

int main() {
  int a, b;
  // какая-то инициализация a и b

  f(a, b);
}
</pre>
  <p>Заменим его на такой код:</p>
<pre>
int main() {
  int a, b;
  // какая-то инициализация a и b

  {
    // этот блок просто ограничивает время жизни
    // находящихся внутри переменных
    int x = a;
    int y = b;
    // работаем с аргументами x и y
  }
}
</pre>
  <p>Теперь видно, что любое изменение x или y внутри функции никак не затронет a и b.</p>
  <p>Можем ли мы изменить переданный аргумент внутри функции, чтобы это повлияло на аргументы в месте вызова? Да, для этого надо передать аргументы через ссылку или указатель. Вот классический пример функции, меняющей два аргумента местами:</p>
<pre>
void Swap(int& x, int& y) {  // передаём аргументы по ссылке
  int z = x;
  x = y;
  y = z;
}

int main() {
  int a = 1, b = 2;
  Swap(a, b);
  std::cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; "\n";  // 2 1
}
</pre>
  <p>Чтобы понять, как это работает, раскроем снова код функции в месте вызова:</p>
<pre>
int main() {
  int a = 1, b = 2;

  {
    int& x = a;
    int& y = b;
    int z = x;
    x = y;
    y = z;
  }

  std::cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; "\n";  // 2 1
}
</pre>
  <p>Видно, что x и y — это просто псевдонимы для a и b.</p>
  <p>Заметьте, что вызов Swap(1, 2), в отличие от Swap(a, b), не скомпилируется, потому что обычная ссылка должна быть привязана к изменяемому объекту.</p>
  <p>Примером функции из стандартной библиотеки, которая принимает аргумент по ссылке и изменяет его, является std::getline:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string line;

  // Второй аргумент передаётся по ссылке и изменяется внутри функции:
  std::getline(std::cin, line);
}
</pre>
  <p>Иногда копирование объекта может быть очень дорогим (и ненужным). Например, копирование вектора приведёт к копированию всех его элементов. Поэтому вот так передавать вектор в функцию неэффективно:</p>
<pre>
void f(std::vector&lt;int&gt; v) {
  // плохо: при вызове функции создаётся копия вектора
}
</pre>
  <p>Копии можно было бы избежать, если бы вектор передавался по ссылке:</p>
<pre>
void f(std::vector&lt;int&gt;& v) {
  // Но теперь есть другие недостатки:
  // 1. В такую функцию нельзя передать константный вектор.
  // 2. Функция не защищена от случайного изменения вектора:
  v.clear();  // тут компилятор нас не схватит за руку
}
</pre>
  <p>Поэтому самое правильное — передавать такой параметр по константной ссылке:</p>
<pre>
void f(const std::vector&lt;int&gt;& v) {
  // Такой аргумент не требует дорогого копирования,
  // его нельзя случайно изменить внутри,
  // и такую функцию можно вызывать от констант!
}
</pre>
  <p>Давайте запомним: аргументы сложных типов (векторы, строки, любые контейнеры, большие структуры) всегда лучше передавать в функцию по константной ссылке, если функция использует их только для чтения. Из этого правила бывают исключения, но о них мы поговорим отдельно.</p>
  <p>Впрочем, это правило не стоит распространять на обычные встроенные типы:</p>
<pre>
void g(const int& a, const char& c) {
  // так делать не надо, это уже перебор!
  // передавайте такие параметры просто
  // по значению, как int или char
}
</pre>

  <h4>Возвращаемые значения функций</h4>

  <p>В отличие от аргументов, значения сложных типов можно без проблем возвращать из функций. Здесь от ненужного копирования (по крайней мере, для стандартных контейнеров) спасает copy elision.</p>
  <p>Рассмотрим, например, функцию, которая возвращает конкатенацию всех строк из вектора:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

std::string Concatenate(const std::vector&lt;std::string&gt;& parts) {
  std::string result;
  for (const auto& part : parts) {
    result += part;
  }
  return result;
}

int main() {
  std::vector&lt;std::string&gt; parts = {"abra", "ca", "dabra"};
  std::cout &lt;&lt; Concatenate(parts) &lt;&lt; "\n";  // abracadabra
}
</pre>
  <p>Опасно возвращать из функции ссылку на локальную переменную, так как эта ссылка сразу же станет «висячей»:</p>
<pre>
#include &lt;iostream&gt;

int& Sum(int a, int b) {  // ошибка!
  int result = a + b;
  return result;
}

int main() {
  // неопределённое поведение!
  std::cout &lt;&lt; Sum(2, 3) &lt;&lt; "\n";
}
</pre>
  <p>Компиляторы в таких случаях генерируют предупреждения.</p>
  <p>Возвращать значение по ссылке можно только в случае, если оно заведомо будет доступно после завершения функции. Например, так можно вернуть глобальную переменную или аргумент, также переданный по ссылке.</p>

  <h4>Функции-компараторы</h4>

  <p>Пусть имеется структура Date, описывающая день, месяц и год какой-то даты. Создадим вектор дат:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

struct Date {
  int year = 1970;
  int month = 1;
  int day = 1;
};

int main() {
  std::vector&lt;Date&gt; dates = {
    {2020, 3, 15},
    {2019, 1, 21},
    {2021, 1, 30}
  };

  // напечатаем содержимое:
  for (const auto& [year, month, day] : dates) {
    std::cout &lt;&lt; year &lt;&lt; "." &lt;&lt; month
    &lt;&lt; "." &lt;&lt; day &lt;&lt; "\n";
  }
}
</pre>
  <p>Предположим, нам требуется отсортировать даты. Для сортировки нам поможет уже знакомая функция std::sort, но есть нюанс: вызов std::sort(dates.begin(), dates.end()) не скомпилируется, так как компилятор не умеет сравнивать даты между собой. Функция std::sort пытается найти оператор &lt; для сравнения дат, но, увы, для нашей даты такого нет. Мы можем его определить. Он выглядит как функция с особым именем operator &lt;, возвращающая true, если первый аргумент меньше второго:</p>
<pre>
bool operator &lt; (const Date& lhs, const Date& rhs) {
  if (lhs.year != rhs.year) {
    return lhs.year &lt; rhs.year;
  }
  if (lhs.month != rhs.month) {
    return lhs.month &lt; rhs.month;
  }
  return lhs.day &lt; rhs.day;
}
</pre>
  <p>Здесь lhs и rhs — сокращения от left-hand side и right-hand side. Это левый и правый аргументы оператора &lt;. Этот громоздкий код можно записать лаконичнее с использованием функции std::tie, возвращающей кортеж из ссылок, для которого уже определено лексикографическое (покомпонентное) сравнение:</p>
<pre>
bool operator &lt; (const Date& lhs, const Date& rhs) {
  return std::tie(lhs.year, lhs.month, lhs.day) &lt; std::tie(rhs.year, rhs.month, rhs.day);
}
</pre>
  <p>После определения operator &lt; сортировка заработает. Но что, если нам в разных случаях нужно по-разному сортировать даты — например, где-то в хронологическом порядке, а где-то — без учёта года? Можно передать в std::sort третьим аргументом свою функцию сравнения, которая будет использована вместо operator &lt;:</p>
<pre>
bool CompareWithoutYear(const Date& lhs, const Date& rhs) {
  return std::tie(lhs.month, lhs.day) &lt; std::tie(rhs.month, rhs.day);
}

int main() {
  // ...
  std::sort(dates.begin(), dates.end(), CompareWithoutYear);
}
</pre>
  <p>Обратите внимание, что третьим аргументом в std::sort мы передаём саму функцию (без круглых скобок), а не результат её вызова от каких-то аргументов.</p>

  <h4>Лямбда-функции</h4>

  <p>Иногда бывает неудобно определять отдельную именованную функцию для сравнения. Тогда можно определить анонимную лямбда-функцию прямо в месте её использования:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;vector&gt;

struct Date {
  int year, month, day;
};

int main() {
  std::vector&lt;Date&gt; dates;
  std::sort(dates.begin(), dates.end(), [](const Date& lhs, const Date& rhs) {
    return std::tie(lhs.month, lhs.day) &lt; std::tie(rhs.month, rhs.day);
  });
}
</pre>
  <p>Тип возвращаемого значения тут не указывается, компилятор умеет его угадывать по return (его можно указать после круглых скобок на «питоновский» манер через ->, но не обязательно).</p>
  <p>Разберём синтаксис лямбда-функций. Тут видны три блока.</p>
  <ol>
    <li>Квадратные скобки отвечают за контекст. В них мы можем передать переменные, которые объявлены вне лямбда-функции через запятую, и они будут доступны в самой лямбда-функции.</li>
    <li>Круглые скобки отвечают за аргументы функции.</li>
    <li>Фигурные скобки отвечают за тело лямбда-функции.</li>
  </ol>
  <p>Когда лямбды добавлялись в стандарт C++11, разработчики очень не хотели вводить для них новое ключевое слово (как lambda в Python) и обошлись комбинацией скобок. Есть шутка про то, что вот такая программа является вполне корректной:</p>
  <code>int main() {[](){}();}</code>
  <p>Попробуйте разобраться, что тут происходит.</p>
</article>


<!-- 2.8 Шаблоны -->
<article class="article">
  <div class="anchor" id="p2.8"></div>
  <h3>2.8 Шаблоны</h3>

  <p>Шаблоны — это фрагменты обобщённого кода, в котором некоторые типы или константы вынесены в параметры. Шаблонными могут быть функции, структуры (классы) и даже переменные. Компилятор превращает использование шаблона в конкретный код, подставляя в него нужные параметры на этапе компиляции. Шаблоны позволяют писать общий код, пригодный для использования с разными типами данных.</p>
  <p>Стандартная библиотека C++ построена на шаблонах. Раньше её даже называли Standard Template Library (STL, стандартная библиотека шаблонов). Её контейнеры и итераторы являются шаблонными классами, а алгоритмы — шаблонными функциями. Примеры шаблонных конструкций из стандартной библиотеки нам уже встречались: это, например, контейнер std::vector и функция std::sort. В следующем параграфе мы рассмотрим контейнер std::array, размер которого задаётся шаблонной константой времени компиляции. В этом параграфе мы рассмотрим шаблоны функций и структур, параметры которых являются типами. Но прежде чем говорить про шаблоны, рассмотрим перегрузку функций.</p>

  <h4>Перегрузка функций</h4>

  <p>Количество и типы аргументов функции должны быть известны заранее, на этапе компиляции. Но в языке C++ можно создавать функции с одним и тем же именем, но разным набором или типами аргументов и с разными телами. Такие функции называются перегруженными. Рассмотрим, например, семейство перегруженных функций для печати переменной на экран:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

void Print(int value) {
  std::cout &lt;&lt; value &lt;&lt; "\n";
}

void Print(const std::string& name, int value) {
  // печатаем название и саму величину
  std::cout &lt;&lt; name &lt;&lt; ": " &lt;&lt; value &lt;&lt; "\n";
}

void Print(const std::string& str) {
  std::cout &lt;&lt; str &lt;&lt; "\n";
}

int main() {
  Print(42);  // версия 1
  Print("x", 42);  // версия 2
  Print("good bye");  // версия 3
}
</pre>
  <p>Компилятор, сравнивая разные версии функции друг с другом, смотрит на их имена и набор типов аргументов. При этом имена аргументов ни на что не влияют. Также нельзя перегружать функции по типу возвращаемого значения. Действительно, возвращаемое значение может просто игнорироваться в месте вызова, и компилятор не сможет определить, какая версия функции имеется в виду.</p>
<pre>
int f(int x) {
  return x;
}

// ошибка компиляции: функция с таким
// именем и типом параметра уже была
int f(int y) {
  return 2 * y;
}

// ошибка компиляции: перегружать
// по возвращаемому значению нельзя
double f(int x) {
  return 3 * x;
}
</pre>

  <h4>Шаблонные функции</h4>

  <p>Рассмотрим классический пример. Предположим, у нас есть функция, вычисляющая максимум целых чисел:</p>
<pre>
int Max(int x, int y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}
</pre>
  <p>Она определена для аргументов типа int. Однако, если применить её к аргументам типа double, результат получится неожиданным. А её применение к строкам или векторам вообще не скомпилируется:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::cout &lt;&lt; Max(1, 2) &lt;&lt; "\n";  // 2
  std::cout &lt;&lt; Max(3.14159, 2.71828) &lt;&lt; "\n";  // внезапно 3

  std::string word1 = "hello", word2 = "world";
  std::cout &lt;&lt; Max(word1, word2);  // ошибка компиляции
}
</pre>
  <p>В вызове Max(3.14159, 2.71828) аргументы будут преобразованы к типу int, то есть получится Max(3, 2). Вызов Max(word1, word2) не скомпилируется, так как строки нельзя привести к типу int. Чтобы эти вызовы корректно заработали, надо определить перегруженные версии функции Max:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int Max(int x, int y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}

double Max(double x, double y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}

std::string Max(const std::string& x, const std::string& y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}

int main() {
  std::cout &lt;&lt; Max(1, 2) &lt;&lt; "\n";  // 2
  std::cout &lt;&lt; Max(3.14159, 2.71828) &lt;&lt; "\n";  // 3.14159

  std::string word1 = "hello", word2 = "world";
  std::cout &lt;&lt; Max(word1, word2);  // world
}
</pre>
  <p>Выписывать похожие друг на друга версии функций утомительно. Кроме того, такие функции не смогут работать с новыми, неизвестными нам заранее типами. Шаблоны позволяют описать такую функцию один раз, вынеся тип в параметры:</p>
<pre>
template &lt;typename T&gt;
T Max(const T& x, const T& y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}
</pre>
  <p>Шаблон начинается с шапки template. Далее в угловых скобках перечисляются формальные имена параметров. В нашем случае параметр один — это тип T (от слова type). Вместо ключевого слова typename в этом месте допускается использовать слово class (вы можете встретить такие описания шаблонов на cppreference.com). А вместо имени T можно было бы использовать любой другой идентификатор.</p>
  <p>Так как мы не знаем, будет ли тип T встроенным или сложным, то на всякий случай передаём аргументы в функцию по константной ссылке, чтобы избежать лишнего копирования.</p>
  <p>В нашей шаблонной функции Max используется оператор >. Он определён для обычных чисел, строк и векторов (если, конечно, для элементов вектора тоже определён этот оператор). Но если попробовать применить наш шаблон к типу, не поддерживающему оператор >, то произойдёт ошибка компиляции:</p>
<pre>
struct Point {
  double x = 0.0;
  double y = 0.0;
  double z = 0.0;
};

int main() {
  Point p1, p2;
  Point p = Max(p1, p2);  // ошибка компиляции
}
</pre>

  <h4>Вывод шаблонных параметров</h4>

  <p>Конкретные версии шаблонной функции Max для нужных типов получаются подстановкой шаблонных аргументов в угловые скобки. Так, Max&lt;int&gt; — это версия нашей функции для типа int, а Max&lt;std::string&gt; — версия для строк. Важно понимать, что, несмотря на общий шаблон, это разные функции, которые просто порождаются компилятором по образцу.</p>
  <p>Вызвать шаблонную функцию можно было бы так:</p>
<pre>
Max&lt;double&gt;(3.14159, 2.71828);  // 3.14159
Max&lt;int&gt;(3.14159, 2.71828);  // вызывается int-версия, вернётся 3
</pre>
  <p>Однако параметры шаблона в угловых скобках можно не писать: компилятор попытается сам угадать эти параметры по типу аргументов:</p>
<pre>
int main() {
  // 2, вызывается Max&lt;int&gt;
  std::cout &lt;&lt; Max(1, 2) &lt;&lt; "\n";
   // 3.14159, вызывается Max&lt;double&gt;
  std::cout &lt;&lt; Max(3.14159, 2.71828) &lt;&lt; "\n";

  std::string word1 = "hello", word2 = "world";
  // world, вызывается Max&lt;std::string&gt;
  std::cout &lt;&lt; Max(word1, word2);
}
</pre>
  <p>В случае неоднозначностей, например в вызове Max(3.14159, 2), компилятор не сможет автоматически вывести параметр, и ему придётся подсказать тип: Max&lt;double&gt;(3.14159, 2).</p>

  <h4>Перегрузка шаблонных функций</h4>

  <p>Шаблонные функции тоже можно перегружать. Пусть, например, мы хотим вычислять максимум двух векторов, но при этом сравнивать векторы сначала по размеру, а затем уже лексикографически. Стандартное сравнение векторов через оператор > не будет учитывать размер. Поэтому напишем отдельную перегрузку для векторов:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

// общая версия
template &lt;typename T&gt;
T Max(const T& x, const T& y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}

// перегрузка для векторов
template &lt;typename T&gt;
const std::vector&lt;T&gt;& Max(const std::vector&lt;T&gt;& v1, const std::vector&lt;T&gt;& v2) {
  if (v1.size() > v2.size()) {
    return v1;
  } else if (v1.size() &lt; v2.size()) {
    return v2;
  } else if (v1 > v2) {
    return v1;
  } else {
    return v2;
  }
}

int main() {
  std::cout &lt;&lt; Max(1, 2) &lt;&lt; "\n";  // вызов общей версии

  std::vector&lt;int&gt; v1 = {1, 2, 3};
  std::vector&lt;int&gt; v2 = {4, 5};
  for (int x : Max(v1, v2)) {  // вызов перегруженной версии
    std::cout &lt;&lt; x &lt;&lt; " ";  // 1 2 3
  }
  std::cout &lt;&lt; "\n";
}
</pre>

  <h4>Разрешение неоднозначностей</h4>

  <p>Когда компилятор видит вызов функции, ему нужно правильно определить, в каком пространстве имён её искать, какую из перегруженных версий выбрать, а в случае шаблонной функции — как вывести параметры шаблона. Для шаблонных функций после выбора перегруженной версии возможен ещё выбор из вариантов полной специализации шаблона. Общие правила поиска нужной функции достаточно сложны, и мы не будем их здесь приводить полностью. Однако в случаях, которые мы будем рассматривать в этом учебнике, выбор нужной функции будет интуитивно понятен.</p>

  <h4>Шаблонные структуры</h4>

  <p>Структуры и классы также могут быть описаны в общем виде и параметризованы типами или константами времени компиляции. Типичный пример шаблонной структуры — std::pair. Определим по аналогии свою структуру Triple с тремя шаблонными типами:</p>
<pre>
#include &lt;string&gt;

template &lt;typename T1, typename T2, typename T3&gt;
struct Triple {
  T1 first;
  T2 second;
  T3 third;
};

int main() {
  Triple&lt;int, int, int&gt; point = {-1, 3, 2};
  Triple&lt;std::string, std::string, int&gt; wordPairsFreq = {"hello", "world", 42};
}
</pre>
  <p>Здесь так же, как и в случае функций, компилятор генерирует по образцу две никак не связанные друг с другом структуры Triple&lt;int, int, int&gt; и Triple&lt;std::string, std::string, int&gt;.</p>
  <p>В следующих параграфах мы будем подробно рассматривать шаблонные классы, в которых могут быть шаблонные функции-члены.</p>
</article>


<!-- 2.9 Разбор задач к главе «Базовые конструкции C++» -->
<article class="article">
  <div class="anchor" id="p2.9"></div>
  <h3>2.9 Разбор задач к главе «Базовые конструкции C++»</h3>

  <h3>Параграф «Первые шаги»</h3>

  <h4>Задача «Печать текста»</h4>

  <details>
    <summary>Условие</summary>
    <p>Напишите программу, печатающую на экране первые строчки со страницы Бьярне Страуструпа про C++:</p>
<pre>
C++ is a general-purpose programming language with a bias towards systems programming that
  - is a better C
  - supports data abstraction
  - supports object-oriented programming
  - supports generic programming.
</pre>
    <p>Не потеряйте парные пробелы в начале строк и переносы в конце строк.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Задача очень похожа на программу Hello world. Отличие в том, что здесь надо напечатать несколько строк текста. Сам символ перевода строки не может содержаться в обычных строковых литералах, поэтому в программе его придётся заменить на \n. Можно просто вывести каждую строчку отдельно:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  std::cout &lt;&lt; "C++ is a general-purpose programming language with a bias towards systems programming that\n";
  std::cout &lt;&lt; "  - is a better C\n";
  std::cout &lt;&lt; "  - supports data abstraction\n";
  std::cout &lt;&lt; "  - supports object-oriented programming\n";
  std::cout &lt;&lt; "  - supports generic programming.\n";
}
</pre>
    <p>Однако писать каждый раз std::cout утомительно. В конструкции std::cout поддерживается вывод нескольких величин сразу. Можно оставить только самый первый std::cout, а остальные строки вывести через &lt;&lt;:</p>
<pre>
#include <iostream>

int main() {
  std::cout &lt;&lt; "C++ is a general-purpose programming language with a bias towards systems programming that\n"
            &lt;&lt; "  - is a better C\n"
            &lt;&lt; "  - supports data abstraction\n"
            &lt;&lt; "  - supports object-oriented programming\n"
            &lt;&lt; "  - supports generic programming.\n";
}
</pre>
    <p>Здесь мы нарочно для лучшей читаемости отформатировали программу так, чтобы символы &lt;&lt; стояли друг под другом.</p>
    <p>Рассмотрим ещё два способа решить задачу. Строковые константы, расположенные просто друг за другом, автоматически конкатенируются при компиляции программы. Так "Hello," " world!" даст "Hello, world!. Поэтому можно написать так:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  std::cout &lt;&lt; "C++ is a general-purpose programming language with a bias towards systems programming that\n"
               "  - is a better C\n"
               "  - supports data abstraction\n"
               "  - supports object-oriented programming\n"
               "  - supports generic programming.\n";
}
</pre>
    <p>Можно ли избавиться от необходимости писать \n в конце каждой строки? Да, для этого можно воспользоваться raw-литералами. Они могут содержать внутри без экранирования любые символы, в том числе перевод строки, лишь бы они были отличны от выбранных ограничителей. Такие литералы предваряются символом R, а в начале и в конце должна стоять произвольно выбранная одинаковая последовательность символов и круглые скобки. Например, raw(...)raw, или ~~~(...)~~~:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  std::cout &lt;&lt;
R"~~~(C++ is a general-purpose programming language with a bias towards systems programming that
  - is a better C
  - supports data abstraction
  - supports object-oriented programming
  - supports generic programming.
)~~~";
}
</pre>
  </details>

  <h4>Задача «Сумма чисел»</h4>

  <details>
    <summary>Условие</summary>
    <p>Вам даны два целых числа. Напечатайте их сумму.</p>

    <h4>Формат ввода</h4>
    <p>Вводятся два числа, по модулю не превосходящие миллиарда.</p>

    <h4>Формат вывода</h4>
    <p>Напечатайте сумму этих чисел. В конце поставьте перевод строки.</p>

    <h4>Пример</h4>
    <code>1 2</code>
    <code>3</code>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;

int main() {
  int a, b;
  std::cin >> a >> b;
  std::cout &lt;&lt; a + b &lt;&lt; "\n";
}
</pre>
    <p>Проверять корректность условия (то, что числа по модулю не превосходят миллиарда) в программе не нужно.</p>
    <p>Из условия следует, что сумма этих чисел по модулю не будет превосходить двух миллиардов. Забегая немного вперёд, скажем, что это гарантирует, что сумма поместится в тип int. Такие условия позволяют выбрать правильный тип данных для решения задачи.</p>
  </details>

  <h3>Параграф «Типы данных»</h3>

  <h4>Задача «Дюймы»</h4>

  <details>
    <summary>Условие</summary>
    <p>Напишите программу для перевода сантиметров в дюймы. В одном дюйме 2.54 сантиметра.</p>

    <h4>Формат ввода</h4>
    <p>На вход поступает длина в сантиметрах. Значение может быть дробным. Используйте тип double для его хранения.</p>

    <h4>Формат вывода</h4>
    <p>Напечатайте эту длину в дюймах. Округление не требуется. Достаточно использовать стандартную точность вывода до 6 знаков после запятой, которая установлена по умолчанию.</p>

    <h4>Пример</h4>
    <code>1.1</code>
    <code>0.433071</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Если в одном дюйме 2.54 сантиметра, то в одном сантиметре 1/2.54 дюйма:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  double centimeters;
  std::cin >> centimeters;

  double inches = centimeters / 2.54;

  std::cout &lt;&lt; inches &lt;&lt; "\n";
}
</pre>
  </details>

  <h4>Задача «Арифметическая прогрессия»</h4>

  <details>
    <summary>Условие</summary>
    <p>Перед вами программа, которая считает сумму первых n натуральных чисел по формуле суммы арифметической прогрессии:</p>
<pre>
#include <iostream>

int main() {
  int n;
  std::cin >> n;
  std::cout &lt;&lt; n * (n + 1) / 2 &lt;&lt; "\n";
}
</pre>
    <p>Программа должна работать для всех n≤4000000000, но оказывается, что для некоторых n она работает неправильно. Найдите причину проблемы и исправьте программу.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Никакой ошибки в формуле нет. Всё дело в используемом типе данных. При n=46341 происходит переполнение типа int32_t, а при n = 3037000500 происходит переполнение типа int64_t. При выборе беззнакового типа uint64_t переполнения на n=4000000000 не случится. Поэтому просто заменим тип данных на uint64_t.</p>
<pre>
#include &lt;cstdint&gt;
#include &lt;iostream&gt;

int main() {
  std::uint64_t n = 0;
  std::cin >> n;
  std::cout &lt;&lt; n * (n + 1) / 2 &lt;&lt; "\n";
}
</pre>
    <p>Можно было бы сначала выяснить, является ли n чётным, чтобы сначала произвести деление, а потом умножить:</p>
<pre>
#include &lt;cstdint&gt;
#include &lt;iostream&gt;

int main() {
  std::uint64_t number = 0;
  std::cin >> number;

  if (number % 2 == 0) {
    std::cout &lt;&lt; (number / 2) * (number + 1);
  } else {
    std::cout &lt;&lt; ((number + 1) / 2) * number;
  }
  std::cout &lt;&lt; "\n";
}
</pre>
    <p>Тогда лимиты выросли бы ещё больше. Но в решении этого не потребовалось.</p>
  </details>

  <h3>Параграф «Ветвления и циклы»</h3>

  <h4>Задача «Ход ферзя»</h4>

  <details>
    <summary>Условие</summary>
    <p>Шахматный ферзь ходит на любое количество клеток по диагонали, горизонтали или вертикали. Даны две различные клетки на шахматной доске без фигур. Определите, может ли ферзь попасть с первой клетки на вторую одним ходом.</p>

    <h4>Формат ввода</h4>
    <p>Программа получает на вход четыре целых числа от 1 до 8. Первая пара чисел задаёт номер столбца и номер строки для первой клетки. Вторая пара чисел аналогично задаёт вторую клетку.</p>

    <h4>Формат вывода</h4>
    <p>Программа должна вывести YES, если из первой клетки ходом ферзя можно попасть во вторую, или NO в противном случае.</p>

    <h4>Пример 1</h4>
    <code>1 1 2 2</code>
    <code>YES</code>

    <h4>Пример 2</h4>
    <code>1 1 2 3</code>
    <code>NO</code>

    <h4>Пример 3</h4>
    <code>5 6 3 3</code>
    <code>NO</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Ферзь может ходить по вертикали, горизонтали и диагонали. Для того чтобы проверить, является ли ход вертикальным или горизонтальным, достаточно сравнить координаты x1 x2 или y1 y2. Для проверки является ли ход диагональным достаточно сравнить модуль разности координат |x1-x2| и |y1-y2| . Если ни одно из условий не выполняется — ход не может быть совершён ферзём. Для нахождения модуля удобно использовать стандартную функцию std::abs.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;cmath&gt;

int main() {
  int x1, y1, x2, y2;
  std::cin >> x1 >> y1;
  std::cin >> x2 >> y2;

  if (x1 == x2 || y1 == y2 || std::abs(x1 - x2) == std::abs(y1 - y2)) {
    std::cout &lt;&lt; "YES\n";
  } else {
    std::cout &lt;&lt; "NO\n";
  }
}
</pre>
  </details>

  <h4>Задача «Прямоугольный треугольник»</h4>

  <details>
    <summary>Условие</summary>
    <p>Напишите программу, которая проверяет является ли треугольник прямоугольным.</p>

    <h4>Формат ввода</h4>
    <p>На стандартный поток ввода подаётся три целых положительных числа — стороны треугольника. Числа не превосходят 30000.</p>

    <h4>Формат вывода</h4>
    <p>Если полученный треугольник является прямоугольным, напечатайте YES. Если треугольник не является прямоугольным, напечатайте NO. Если с заданными сторонами невозможно построить треугольник, напечатайте UNDEFINED.</p>

    <h4>Пример 1</h4>
    <code>3 2 5</code>
    <code>YES</code>

    <h4>Пример 2</h4>
    <code>3 2 10</code>
    <code>UNDEFINED</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Во-первых, нам необходимо проверить существует ли такой треугольник. Для этого достаточно воспользоваться неравенством треугольника: a+b>c, a+c>b, c+b>a. Если хотя бы одно из этих условий не выполняется, программа должна выводить UNDEFINED.</p>
    <p>Далее необходимо проверить является ли треугольник прямоугольным. Есть несколько способов это сделать. Самый простой — воспользоваться теоремой Пифагора. Если одно из равенств a²+b²=c², a²+c²=b², b²+c²=a² выполняется, программа должна вывести YES. В противном случае надо вывести NO.</p>
    <p>По условию задачи стороны треугольника не превосходят 2¹⁵, а значит выражение a²+b² не будет превосходить 2³⁰+2³⁰=2³¹ и поместится в тип int.</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int a, b, c;
  std::cin >> a >> b >> c;

  if (a + b &lt;= c || a + c &lt;= b || b + c &lt;= a) {
    std::cout &lt;&lt; "UNDEFINED\n";
  } else if (a * a + b * b == c * c || a * a + c * c == b * b || b * b + c * c == a * a) {
    std::cout &lt;&lt; "YES\n";
  } else {
    std::cout &lt;&lt; "NO\n";
  }
}
</pre>
  </details>

  <h4>Задача «Високосный год»</h4>

  <details>
    <summary>Условие</summary>
    <p>Определите, является ли год високосным по григорианскому календарю.</p>
    <p>Напоминание:</p>
    <ol>
      <li>год, номер которого кратен 400, — високосный;</li>
      <li>остальные годы, номер которых кратен 100, — невисокосные (например, годы 1700, 1800, 1900, 2100, 2200, 2300);</li>
      <li>остальные годы, номер которых кратен 4, — високосные.</li>
      <li>все остальные годы — невисокосные.</li>
    </ol>

    <h4>Формат ввода</h4>
    <p>Вводится целое положительное четырёхзначное число — номер года.</p>

    <h4>Формат вывода</h4>
    <p>Программа выводит YES если год високосный и NO в противном случае.</p>

    <h4>Пример 1</h4>
    <code>2003</code>
    <code>NO</code>

    <h4>Пример 2</h4>
    <code>2004</code>
    <code>YES</code>

    <h4>Пример 3</h4>
    <code>3000</code>
    <code>NO</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Грамотно перепишем определения из условия через if/else и проверку остатка от деления:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int year;
  std::cin >> year;

  if (year % 400 == 0) {
    std::cout &lt;&lt; "YES\n";
  } else if (year % 100 == 0) {
    std::cout &lt;&lt; "NO\n";
  } else if (year % 4 == 0) {
    std::cout &lt;&lt; "YES\n";
  } else {
    std::cout &lt;&lt; "NO\n";
  }
}
</pre>
    <p>Заметим, что в получившимся коде дублируются ветви условий. Попробуем его упростить. Для этого достаточно заметить, что високосным является любой год, который делится на 400 или делится на 4, но не делится на 100. После этого упрощения получим следующий код:</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int year;
  std::cin >> year;

  if ((year % 400 == 0 || year % 100 != 0) && year % 4 == 0) {
    std::cout &lt;&lt; "YES\n";
  } else {
    std::cout &lt;&lt; "NO\n";
  }
}
</pre>
  </details>

  <h4>Задача «Количество дней в месяце»</h4>

  <details>
    <summary>Условие</summary>
    <p>Напишите программу, выводящую количество дней в месяце по заданному номеру месяца и году.</p>

    <h4>Формат ввода</h4>
    <p>На вход программе подается два целых положительных числа: номер месяца (от 1 до 12) и четырёхзначный год.</p>

    <h4>Формат вывода</h4>
    <p>Необходимо вывести одно число — количество дней в заданном месяце.</p>

    <h4>Пример 1</h4>
    <code>1 2001</code>
    <code>31</code>

    <h4>Пример 2</h4>
    <code>6 3000</code>
    <code>30</code>

    <h4>Пример 3</h4>
    <code>2 2012</code>
    <code>29</code>

    <p>Рекомендуется сначала решить задачу «Високосный год» и использовать её решение для вывода количества дней в феврале.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Эту задачу можно решать либо через if/else, либо через switch/case. Мы воспользуемся вторым вариантом, потому что в таком случае удобно описывать ветви, у которых много разных возможных условий.</p>
    <p>Перечислим все возможные месяцы, для которых ответ будет 31: это январь (1), март (3), май (5), июль (7), август (8), октябрь (10), декабрь (12). Для февраля (2) ответ будет зависеть от года. Воспользуемся кодом из задачи «Високосный год», заменив вывод с YES/NO на 29/28. Для остальных месяцев воспользуемся инструкцией default и выведем 30.</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int month, year;
  std::cin >> month >> year;

  switch (month) {
    case 1:
    case 3:
    case 5:
    case 7:
    case 8:
    case 10:
    case 12:
      std::cout &lt;&lt; "31\n";
      break;
    case 2:
      if ((year % 400 == 0 || year % 100 != 0) && year % 4 == 0) {
        std::cout &lt;&lt; "29\n";
      } else {
        std::cout &lt;&lt; "28\n";
      }
      break;
    default:
      std::cout &lt;&lt; "30\n";
  }
}
</pre>
  </details>

  <h4>Задача «Печать календаря»</h4>

  <details>
    <summary>Условие</summary>
    <p>Напечатайте месяц из календаря по заданному начальному дню и количеству дней. Ваш ответ должен выглядеть примерно так:</p>
<pre>
                   1
 2  3  4  5  6  7  8
 9 10 11 12 13 14 15
16 17 18 19 20 21 22
23 24 25 26 27 28 29
30 31
</pre>
    <h4>Формат ввода</h4>
    <p>Вводится два числа: n — номер дня недели первого числа месяца (целое число от 1 до 7) и k — количество дней в этом месяце (целое число от 1 до 99). n ≤ k. Обратите внимание, что число дней в месяце не обязательно должно быть таким же, как в привычном календаре.</p>
    <h4>Формат вывода</h4>
    <p>Необходимо напечатать календарь как в примере. Пустые позиции в первой строке заполняйте пробелами. Соседние числа также разделяйте пробелами. Под одно число всегда выделяется два символа. В конце строчек до перевода строки пробелов быть не должно. Вывод должен завершаться ровно одним подряд идущим переводом строки.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Для начала выведем отступ перед первым днём. Номер одного дня записывается в два символа, все дни разделены пробелом. Соответственно, необходимо вывести n - 1 раз строку из трёх пробелов.</p>
    <p>Далее введём счётчик dayOfWeek и выставим ему начальное значение, равное n. Будем использовать его для отсчета текущего столбца. Воспользуемся циклом for от 1 до k включительно. Будем выводить текущее число и прибавлять к счётчику 1. Каждый раз, когда счётчик достигает семи, сбрасываем его в единицу и печатаем символ переноса строки \n. Также нужно не забыть, что числа от 1 до 9 занимают всего один символ в нашем календаре. Чтобы это исправить добавим дополнительный if, который ставит пробел перед числом.</p>
    <p>В самом конце проверим, в какой день недели закончился месяц. Если он закончился не в воскресенье, то необходимо допечатать перевод строки.</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int n, k;
  std::cin >> n >> k;

  int dayOfWeek = n;

  for (int i = 1; i &lt; n; ++i) {
    std::cout &lt;&lt; "   ";
  }

  for (int day = 1; day &lt;= k; ++day) {
    if (day &lt; 10) {
      std::cout &lt;&lt; " ";
    }

    std::cout &lt;&lt; day;

    if (dayOfWeek == 7) {
      std::cout &lt;&lt; "\n";
      dayOfWeek = 1;
    } else {
      std::cout &lt;&lt; " ";
      dayOfWeek += 1;
    }
  }

  if (dayOfWeek != 1) {
    std::cout &lt;&lt; "\n";
  }
}
</pre>
  </details>

  <h4>Задача «Сумма цифр»</h4>

  <details>
    <summary>Условие</summary>
    <p>Вычислите сумму цифр неотрицательного целого числа.</p>
    <h4>Формат ввода</h4>
    <p>На вход подаётся одно неотрицательное целое число, не превосходящее 10⁹</p>
    <h4>Формат вывода</h4>
    <p>Выведите сумму цифр этого числа.</p>
    <h4>Пример</h4>
    <code>59</code>
    <code>14</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>По условию задачи число помещается в тип int. Поэтому можно написать цикл, который будет прибавлять к ответу последнюю цифру этого числа (остаток при делении на 10) и делить число на 10 без учёта остатка.</p>
<pre>
#include &lt;iostream&gt;

int main() {
  int x;
  std::cin >> x;

  int s = 0;
  while (x != 0) {
    s += x % 10;
    x /= 10;
  }

  std::cout &lt;&lt; s &lt;&lt; "\n";
}
</pre>

    <p>Есть более общее решение, которое подойдёт для чисел любого размера, не обязательно влезающих в int. Можно считать цифры числа в строку и обработать их посимвольно. Правда, для очень больших строк уже сама сумма цифр может не поместиться в int.</p>
    <p>Чтобы превратить очередной символ в цифру, воспользуемся тем, что символы цифр в таблице ASCII идут подряд. Поэтому разность кодов символов c - '0' будет как раз давать числовое представление очередной цифры.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string digits;
  std::cin >> digits;

  int s = 0;
  for (char digit : digits) {
    s += digit - '0';
  }

  std::cout &lt;&lt; s &lt;&lt; "\n";
}
</pre>
  </details>

  <h4>Задача «ln 2»</h4>

  <details>
    <summary>Условие</summary>
    <p>Значение натурального логарифма ln2 представляется в виде суммы 1 - 1/2 + 1/3 - 1/4 + ... + n(-1)n+1 с точностью до O(n). Напишите программу, выводящую сумму первых n членов этого ряда. Попробуйте также обойтись без использования инструкции if. Указание: используйте тип double для работы с числами с плавающей точкой. Используйте стандартную точность вывода.</p>
    <h4>Формат ввода</h4>
    <p>Вводится целое положительное число n, помещающееся в тип int.</p>
    <h4>Формат вывода</h4>
    <p>Программа выводит ответ на задачу.</p>

    <h4>Пример 1</h4>
    <code>3</code>
    <code>0.833333</code>

    <h4>Пример 2</h4>
    <code>2</code>
    <code>0.5</code>

    <h4>Пример 3</h4>
    <code>1</code>
    <code>1</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Объявим две переменные sign и result. В result будем складывать итоговое значение, а в sign будем хранить 1 или -1. Знак переменной sign будет каждый раз меняться.</p>
    <p>Важно привести один из аргументов дроби sign / i к типу double, чтобы не получилось целочисленного деления.Проще всего это сделать, выбрав для переменной sign тип double.</p>
<pre>
#include <iostream>

int main() {
  int n;
  std::cin >> n;

  double sign = 1;
  double result = 0.0;

  for (int i = 1; i &lt;= n; ++i) {
    result += sign / i;
    sign = -sign;
  }
  std::cout &lt;&lt; result &lt;&lt; "\n";
}
</pre>
  </details>

  <h3>Параграф «Векторы и строки»</h3>

  <h4>Задача «Пароли»</h4>

  <details>
    <summary>Условие</summary>

    <p>Пароль от некоторого сервиса должен удовлетворять таким ограничениям:</p>
    <ul>
      <li>состоять из символов таблицы ASCII с кодами от 33 до 126;</li>
      <li>быть не короче 8 символов и не длиннее 14;</li>
      <li>из 4 классов символов — большие буквы, маленькие буквы, цифры, прочие символы — в пароле должны присутствовать не менее трёх любых.</li>
    </ul>

    <p>Напишите программу, которая проверит, что введённый пароль подходит под эти ограничения.</p>

    <h4>Формат ввода</h4>
    <p>На входе дана одна строка с паролем.</p>

    <h4>Формат вывода</h4>
    <p>Выведите YES, если пароль удовлетворяет требованиям, и NO в противном случае.</p>

    <h4>Пример</h4>
    <code>Vasya123</code>
    <code>YES</code>

    <p>Вы можете воспользоваться функциями из заголовочного файла cctype или реализовать самостоятельно их аналоги.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Решение можно целиком записать внутри функции main, но нам будет удобнее оформить проверку пароля в виде отдельной функции IsGood, которая возвращает логическое значение. Из такой функции всегда можно удобно выйти с помощью return, если ответ уже известен.</p>
<pre>
#include &lt;iostream>
#include &lt;string>

bool IsGood(const std::string& password) {
  if (password.size() &lt; 8 || password.size() > 14) {
    return false;
  }
  int upper = 0;
  int lower = 0;
  int digit = 0;
  int other = 0;

  for (char c : password) {
    if (c &lt; 33 || c > 126) {
      return false;
    }
    if ('A' &lt;= c && c &lt;= 'Z') {
      upper = 1;
    } else if ('a' &lt;= c && c &lt;= 'z') {
      lower = 1;
    } else if ('0' &lt;= c && c &lt;= '9') {
      digit = 1;
    } else {
      other = 1;
    }
  }

  return upper + lower + digit + other >= 3;
}

int main() {
  std::string password;
  std::getline(std::cin, password);
  if (IsGood(password)) {
    std::cout &lt;&lt; "YES\n";
  } else {
    std::cout &lt;&lt; "NO\n";
  }
}
</pre>
    <p>Здесь мы используем явные сравнения с другими символами вида '0' &lt;= c && c &lt;= '9'. Можно было бы использовать функции std::isupper, std::islower и std::isdigit из заголовочного файла cctype.</p>
  </details>

  <h4>Задача «Soundex»</h4>

  <details>
    <summary>Условие</summary>
    <p>Известный алгоритм Soundex определяет, похожи ли два английских слова по звучанию. На вход он принимает слово и заменяет его на некоторый четырёхсимвольный код. Если коды двух слов совпадают, то слова, как правило, звучат похоже.</p>

    <p>Вам требуется реализовать этот алгоритм. Он работает так:</p>
    <ol>
      <li>Первая буква слова сохраняется.</li>
      <li>В остальной части слова буквы a, e, h, i, o, u, w и y удаляются;</li>
      <li>Оставшиеся буквы заменяются на цифры от 1 до 6, причём похожим по звучанию буквам соответствуют одинаковые цифры:
        <ul>
          <li>b, f, p, v: 1</li>
          <li>c, g, j, k, q, s, x, z: 2</li>
          <li>d, t: 3</li>
          <li>l: 4</li>
          <li>m, n: 5</li>
          <li>r: 6</li>
        </ul>
      </li>
      <li>Любая последовательность идущих подряд одинаковых цифр сокращается до одной такой цифры.</li>
      <li>Итоговая строка обрезается до первых четырёх символов.</li>
      <li>Если длина строки получилась меньше четырёх символов, в конце добавляются нули.</li>
    </ol>

    <p>Примеры:</p>
    <code>аmmonium → ammnm → a5555 → a5 → a500.</code>
    <code>implementation → implmnttn → i51455335 → i514535 → i514.</code>

    <h4>Формат ввода</h4>
    <p>На вход подаётся одно непустое слово из строчных латинских букв. Длина слова не превосходит 20 символов.</p>

    <h4>Формат вывода</h4>
    <p>Напечатайте четырёхбуквенный код, соответствующий слову.</p>

    <h4>Пример 1</h4>
    <code>ammonium</code>
    <code>a500</code>

    <h4>Пример 2</h4>
    <code>implementation</code>
    <code>i514</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Хотя задачу можно решить и без функций, нам будет удобно оформить её решение в виде отдельной функции Soundex. Шаги 3 и 4 можно оформить в виде оператора switch.</p>

    <p>Напишем также вспомогательную функцию Append, добавляющую символ к ответу в случае, если он не дублируется. В эту функцию удобно передать параметр res по ссылке, чтобы его можно было изменять.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

void Append(std::string& res, char c) {
  if (res.back() != c) {
    res.push_back(c);
  }
}

std::string Soundex(const std::string& word) {
  std::string res;
  res.push_back(word[0]);
  for (size_t i = 1; i != word.size(); ++i) {
    char c = word[i];
    switch (c) {
      case 'b':
      case 'f':
      case 'p':
      case 'v':
        Append(res, '1');
        break;
      case 'c':
      case 'g':
      case 'j':
      case 'k':
      case 'q':
      case 's':
      case 'x':
      case 'z':
        Append(res, '2');
        break;
      case 'd':
      case 't':
        Append(res, '3');
        break;
      case 'l':
        Append(res, '4');
        break;
      case 'm':
      case 'n':
        Append(res, '5');
        break;
      case 'r':
        Append(res, '6');
        break;
    }
  }
  while (res.size() &lt; 4) {
    res.push_back('0');
  }
  res.resize(4);
  return res;
}

int main() {
  std::string word;
  std::cin >> word;
  std::cout &lt;&lt; Soundex(word) &lt;&lt; "\n";
}
</pre>
  </details>

  <h4>Задача «Обратная перестановка»</h4>

  <details>
    <summary>Условие</summary>

    <p>На мероприятие приглашены n гостей. Им предлагают занять места с номерами от 1 до n в зале. Гости занимают эти места в произвольном порядке. Известно, на каком месте сел очередной гость.</p>

    <p>Выпишите для каждого очередного места номер гостя, который на него сел.</p>

    <h4>Формат ввода</h4>
    <p>Дано число n, а затем n различных чисел a1, a2, ... , an от 1 до n. Число ak — это номер места, на которое сел k-й гость.</p>

    <p>Число n не превосходит 20000.</p>

    <h4>Формат вывода</h4>
    <p>Выведите n чисел b1, b2, ... , bn от 1 до n. Число bk должно обозначать номер гостя, который сел на k-е место.</p>

    <h4>Пример 1</h4>
<pre>
4
3 1 2 4
</pre>
  <code>2 3 1 4</code>

    <h4>Пример 2</h4>
<pre>
11
11 6 8 2 10 9 4 7 3 1 5
</pre>
  <code>10 4 9 7 11 2 8 3 6 5 1</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Будем заполнять вектор seats, в котором для каждого номера места будет указан номер гостя. Не забудьте: элементы вектора индексируются с нуля, а номера мест и гостей в задаче начинаются с единицы.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  int n;
  std::cin >> n;

  std::vector&lt;int&gt; seats(n);
  for (int guest = 1; guest &lt;= n; ++guest) {
    int seat;
    std::cin >> seat;
    seats[seat - 1] = guest;
  }

  for (int guest : seats) {
    std::cout &lt;&lt; guest &lt;&lt; " ";
  }
  std::cout &lt;&lt; "\n";
}
</pre>
  </details>

  <h4>Задача «Сортировка по убыванию»</h4>

  <details>
    <summary>Условие</summary>
    <p>Вам даны строки текстового файла. Отсортируйте набор этих строк по убыванию.</p>

    <h4>Формат ввода</h4>
    <p>Количество строк не превосходит 1000. Каждая строка состоит из символов ASCII с кодами от 32 до 126, длина строки не превосходит 100.</p>

    <h4>Формат вывода</h4>
    <p>Напечатайте строки в отсортированном по убыванию порядке. Для сравнения строк друг с другом достаточно использовать стандартные операторы сравнения, определённые для std::string.</p>

    <h4>Пример</h4>
<pre>
one
two
three
</pre>
<pre>
two
three
one
</pre>
    <p>Примечания</p>
    <p>Компилятор не поддерживает std::ranges.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Строки необходимо прочитать и сложить в вектор, а затем отсортировать и вывести. По умолчанию они будут сортироваться по возрастанию. Есть несколько способов сделать сортировку и вывод в нужном порядке:</p>
    <ol>
      <li>строки можно напечатать в обратном порядке;</li>
      <li>можно передать в std::sort обратные итераторы;</li>
      <li>можно передать в std::sort свою функцию сравнения;</li>
      <li>можно передать в std::sort уже готовый компаратор std::greater&lt;std::string&gt;().</li>
    </ol>
    <p>Воспользуемся, например, вторым способом:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;std::string&gt; lines;

  std::string line;
  while (std::getline(std::cin, line)) {
    lines.push_back(line);
  }

  std::sort(lines.rbegin(), lines.rend());

  for (size_t i = 0; i != lines.size(); ++i) {
    std::cout &lt;&lt; lines[i] &lt;&lt; "\n";
  }
}
</pre>
    <p>Типичная ошибка в решении этой задачи — считывать строки через std::cin >> line вместо std::getline. Такой код прочитает строку не целиком, а до ближайшего пробельного разделителя.</p>
  </details>

  <h4>Задача «Палиндромы»</h4>

  <details>
    <summary>Условие</summary>
    <p>Дана строка из строчных латинских букв и пробелов. Проверьте, является ли она палиндромом без учета пробелов.</p>

    <h4>Формат ввода</h4>
    <p>На вход подается одна строка. В строке могут быть пробелы. Подряд может идти произвольное число пробелов. Длина строки не превосходит 100.</p>

    <h4>Формат вывода</h4>
    <p>Представьте, что из строки удалили все пробелы. Необходимо вывести YES, если полученная строка — палиндром, и NO в противном случае.</p>

    <h4>Пример 1</h4>
    <code>hello world</code>
    <code>NO</code>

    <h4>Пример 2</h4>
    <code>never odd or even</code>
    <code>YES</code>

    <p>Примечание</p>
    <p>Пустая строка считается палиндромом.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Будем поддерживать два индекса i и j, которые будут идти с разных сторон строки навстречу друг другу. Будем повторять цикл до тех пор, пока первый индекс меньше второго. В цикле будем игнорировать пробелы. Если будет найдено несоответствие символов, цикл можно досрочно закончить.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

int main() {
  std::string s;
  std::getline(std::cin, s);

  int i = 0;
  int j = static_cast&lt;int&gt;(s.size()) - 1;
  bool isPalindrome = true;

  while (i &lt; j) {
    if (s[i] == ' ') {
      ++i;
    } else if (s[j] == ' ') {
      --j;
    } else if (s[i] != s[j]) {
      isPalindrome = false;
      break;
    } else {
      ++i;
      --j;
    }
  }

  if (isPalindrome) {
    std::cout &lt;&lt; "YES\n";
  } else {
    std::cout &lt;&lt; "NO\n";
  }
}
</pre>
    <p>Вот изящное решение этой задачи для тех, кто прочитал параграф про алгоритмы стандартной библиотеки:</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string s;
  std::getline(std::cin, s);

  std::erase(s, ' ');  // С++20

  // В С++17 пришлось бы написать
  // s.erase(std::remove(s.begin(), s.end(), ' '), s.end());

  if (std::equal(s.begin(), s.begin() + s.size() / 2, s.rbegin())) {
    std::cout &lt;&lt; "YES\n";
  } else {
    std::cout &lt;&lt; "NO\n";
  }
}
</pre>
  </details>

  <h4>Задача «Сапёр»</h4>

  <details>
    <summary>Условие</summary>
    <p>Вам необходимо построить поле для игры «Сапёр» по его конфигурации — высоте, ширине и координатам расставленных на нем мин.</p>
    <p>Вкратце напомним правила построения поля для игры «Сапёр»:</p>
    <ul>
      <li>поле состоит из клеток с минами и пустых клеток;</li>
      <li>клетки с миной обозначаются символом *;</li>
      <li>пустые клетки содержат число от 0 до 8 — количество мин на соседних клетках.</li>
    </ul>

    <h4>Формат ввода</h4>
    <p>В первой строке содержатся три числа:</p>
    <ul>
      <li>число m от 1 до 100 — количество строк на поле;</li>
      <li>число n от 1 до 100 — количество столбцов на поле;</li>
      <li>число k от 0 до mn — количество мин на поле.</li>
    </ul>
    <p>В следующих k строках содержатся пары чисел с координатами мин (номерами строки и столбца). Нумерация ведётся с единицы.</p>

    <h4>Формат вывода</h4>
    <p>Выведите построенное поле, разделяя строки поля символом \n, а столбцы — пробелом.</p>

    <h4>Пример</h4>
<pre>
3 2 2
1 1
2 2
</pre>
<pre>
* 2
2 *
1 1
</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Заведём двумерный вектор и будем записывать в него мины и количество мин в соседних клетках. Мины будет удобно обозначать минус единицей.</p>

    <p>Будем по очереди добавлять мины на игровое поле и для каждой мины сразу обновлять числа в соседних клетках.</p>

    <p>Чтобы не выписывать восемь однотипных проверок на соседние клетки, удобно будет создать вектор «сдвигов» и перебирать эти сдвиги в цикле.</p>

    <p>Можно также добавить к нашему игровому полю дополнительные клетки по краям, чтобы не делать проверки на корректность при обращении к соседней клетке. Поэтому размер поля в нашей программе на 2 больше указанного.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

struct Shift {
  int x = 0;
  int y = 0;
};

const std::vector&lt;Shift&gt; SHIFTS = {
  {-1, -1},
  {-1,  0},
  {-1,  1},
  { 0,  1},
  { 1,  1},
  { 1,  0},
  { 1, -1},
  { 0, -1},
};

int main() {
  size_t rows;
  size_t columns;
  size_t mines;
  std::cin >> rows >> columns >> mines;

  const int mineLabel = -1;

  std::vector&lt;std::vector&lt;int&gt; &gt; field(rows + 2, std::vector&lt;int&gt;(columns + 2));

  for (size_t index = 0; index != mines; ++index) {
    int row, column;
    std::cin >> row >> column;

    field[row][column] = mineLabel;

    for (auto shift : SHIFTS) {
      auto& cell = field[row + shift.x][column + shift.y];
      if (cell != mineLabel) {
        ++cell;
      }
    }
  }

  for (size_t row = 1; row &lt;= rows; ++row) {
    for (size_t column = 1; column &lt;= columns; ++column) {
      if (column > 1) {
        std::cout &lt;&lt; " ";
      }
      if (field[row][column] == mineLabel) {
        std::cout &lt;&lt; "*";
      } else {
        std::cout &lt;&lt; field[row][column];
      }
    }
    std::cout &lt;&lt; "\n";
  }
}
</pre>
    <p>Обратите внимание на инициализацию ссылки cell. Мы специально объявили cell как ссылку, чтобы по этому краткому имени можно было изменить значение.</p>
  </details>

  <h3>Параграф «Функции»</h3>

  <h4>Задача «ArgMax в матрице»</h4>

  <details>
    <summary>Условие</summary>
    <p>Вам требуется написать на C++ функцию со следующим заголовком:</p>
    <code>std::pair&lt;size_t, size_t&gt; MatrixArgMax(const std::vector&lt;std::vector&lt;int&gt; &gt;& matrix);</code>
    <p>Функция должна вернуть пару из индексов максимального элемента в матрице. Если максимальных элементов несколько, то нужно вернуть наименьшую такую пару.</p>

    <p>Примечания</p>
    <p>Считайте, что матрица задана корректно: все строки одинаковой длины, пустых строк нет. В матрице всегда есть хотя бы один элемент.</p>
    <p>Подключите необходимые заголовочные файлы и напишите только код функции MatrixArgMax. Мы скомпилируем решение с нашей функцией main.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Сохраним в переменной argMax позицию начального элемента матрицы, а в переменной max — значение этого элемента. Обойдём все элементы матрицы с помощью вложенного цикла. Если обнаружим новый максиммум, то обновим эти переменные.</p>
<pre>
#include &lt;utility&gt;
#include &lt;vector&gt;

std::pair&lt;size_t, size_t&gt; MatrixArgMax(const std::vector&lt;std::vector&lt;int&gt; &gt;& matrix) {
  std::pair&lt;size_t, size_t&gt; argMax = {0, 0};
  int max = matrix[0][0];
  for (size_t i = 0; i != matrix.size(); ++i) {
    for (size_t j = 0; j != matrix[i].size(); ++j) {
      if (matrix[i][j] > max) {
        max = matrix[i][j];
        argMax = {i, j};
      }
    }
  }
  return argMax;
}
</pre>
  </details>

  <h4>Задача «Общий префикс»</h4>

  <details>
    <summary>Условие</summary>
    <p>Напишите функцию для вычисления наибольшего общего префикса строк, переданных в векторе words:</p>
    <code>std::string CommonPrefix(const std::vector&lt;std::string&gt;& words);</code>
    <p>Например, для пустого вектора функция должна вернуть пустую строку, а для вектора из строк "apple", "apricot" и "application" — строку "ap".</p>

    <p>Примечание</p>
    <p>В решении не должно быть функции main: она будет в нашей тестирующей программе. Подключите необходимые библиотеки и напишите код функции CommonPrefix.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Давайте напишем вспомогательную функцию для вычисления общего префикса двух строк. Для этого будем идти по символам строк и проверять, равны ли они. Важно не выйти за пределы строки.</p>
<pre>
#include &lt;string&gt;
#include &lt;vector&gt;

std::string CommonPrefix(const std::string& a, const std::string& b) {
  size_t i = 0;
  while (i != a.size() && i != b.size() && a[i] == b[i]) {
    ++i;
  }
  return a.substr(0, i);
}
</pre>
    <p>Теперь можно просто перебрать поданные на вход строки и вычислять на каждом шаге общий префикс у текущей строки и старого префикса:</p>
<pre>
std::string CommonPrefix(const std::vector&lt;std::string&gt;& words) {
  if (words.empty()) {
    return {};
  }
  std::string prefix = words[0];
  for (size_t i = 1; i != words.size() && !prefix.empty(); ++i) {
    prefix = CommonPrefix(prefix, words[i]);
  }
  return prefix;
}
</pre>
    <p>Здесь мы вызываем в цикле первую функцию CommonPrefix. Компилятор понимает какую из функций надо вызвать по типам аргументов (здесь передаётся не вектор строк, а две строки).</p>

    <p>Недостаток этого решения в том, что мы много раз создаём новые строки (префиксы), хотя на самом деле все они являются подстроками первой строки. Поэтому давайте перепишем первую функцию, чтобы она использовала std::string_view — конструкцию, о которой мы поговорим в параграфе «Адаптеры и представления». Во второй функции объявим prefix с явным типом std::string_view, а в конце вернём std::string(prefix): преобразование из string_view обратно в string надо описывать явно.</p>
<pre>
#include &lt;string&gt;
#include &lt;string_view&gt;
#include &lt;vector&gt;

std::string_view CommonPrefix(const std::string_view a, const std::string_view b) {
  size_t i = 0;
  while (i != a.size() && i != b.size() && a[i] == b[i]) {
    ++i;
  }
  return a.substr(0, i);
}

std::string CommonPrefix(const std::vector&lt;std::string&gt;& words) {
  if (words.empty()) {
    return {};
  }
  std::string_view prefix = words[0];
  for (size_t i = 1; i != words.size() && !prefix.empty(); ++i) {
    prefix = CommonPrefix(prefix, words[i]);
  }
  return std::string(prefix);
}
</pre>
    <p>Рассмотрим альтернативное решение с синхронным проходом. Будем одновременно идти по всем словам. Для этого удобно сначала вычислить их минимальную длину, чтобы было проще проверять, когда пора остановиться.</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

std::string CommonPrefix(const std::vector&lt;std::string&gt;& words) {
  if (words.empty()) {
    return {};
  }

  size_t minLen = words[0].size();
  for (const auto& word : words) {
    minLen = std::min(minLen, word.size());
  }

  for (size_t i = 0; i &lt; minLen; ++i) {
    const char c = words[0][i];
    for (const auto& word : words) {
      if (word[i] != c) {
        return word.substr(0, i);
      }
    }
  }

  return words[0].substr(0, minLen);
}
</pre>
  </details>

  <h4>Задача «Функция Split»</h4>

  <details>
    <summary>Условие</summary>
    <p>Вам требуется написать функцию со следующим заголовком:</p>
    <code>std::vector<std::string> Split(const std::string& str, char delimiter);</code>
    <p>Функция должна вернуть вектор строк, полученный разбиением строки str на части по указанному символу-разделителю delimiter. Если разделитель встретился в начале или в конце строки str, то в начале (соответственно, в конце) вектора с результатом должна быть пустая строка. Если два разделителя встретились рядом, то пустая строка между ними тоже должна попасть в ответ. Для пустой строки надо вернуть вектор, содержащий одну пустую строку.</p>
    <p>Например, Split("What_is_your_name?", '_') должна вернуть вектор из строк What, is, your иname?.</p>

    <p>Примечание</p>
    <p>Подключите необходимые заголовочные файлы и напишите только код функции Split. Мы скомпилируем решение с нашей функцией main.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Заметим, что количество элементов в ответе должно оказаться на единицу больше количества символов-разделителей в строке.</p>
    <p>Будем поддерживать два индекса: начало и конец очередного фрагмента строки. Будем сдвигать конец вправо. Если нам встретится разделитель, добавим этот фрагмент к ответу и переназначим начало будущего фрагмента на следующий индекс.</p>
    <p>В конце надо будет отдельно добавить к ответу последний фрагмент.</p>
<pre>
#include &lt;string&gt;
#include &lt;vector&gt;

std::vector&lt;std::string&gt; Split(const std::string& str, char delimiter) {
  std::vector&lt;std::string&gt; result;
  size_t i = 0;
  for (size_t j = 0; j != str.size(); ++j) {
    if (str[j] == delimiter) {
      result.push_back(str.substr(i, j - i));
      i = j + 1;
    }
  }
  result.push_back(str.substr(i));
  return result;
}
</pre>
    <p>Заметим, что если исходная строка будет существовать после вызова функции, то может оказаться эффективнее разбивать строку на std::string_view (мы поговорим об этой конструкции в параграфе «Адаптеры и представления»).</p>
<pre>
#include &lt;string&gt;
#include &lt;string_view&gt;
#include &lt;vector&gt;

std::vector&lt;std::string_view&gt; Split(const std::string& s, char delimiter) {
  std::string_view str = s;
  std::vector&lt;std::string_view&gt; result;
  size_t i = 0;
  for (size_t j = 0; j != str.size(); ++j) {
    if (str[j] == delimiter) {
      result.push_back(str.substr(i, j - i));
      i = j + 1;
    }
  }
  result.push_back(str.substr(i));
  return result;
}
</pre>
  </details>

  <h4>Задача «Функция Join»</h4>

  <details>
    <summary>Условие</summary>
    <p>Вам требуется написать функцию Join со следующим заголовком:</p>
    <code>std::string Join(const std::vector&lt;std::string&gt;& tokens, char delimiter);</code>
    <p>Функция должна вернуть строку, полученную склейкой элементов вектора через указанный разделитель. Например, Join({"What", "is", "your", "name?"}, '_') должна вернуть строку "What_is_your_name?".</p>

    <p>Примечание</p>
    <p>Если вектор tokens пустой, то функция должна вернуть пустую строку. Если в векторе tokens ровно один элемент, то он и должен вернуться в ответе.</p>
    <p>Подключите необходимые заголовочные файлы и напишите только код функции Join. Мы скомпилируем решение с нашей функцией main.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Будем идти по вектору и добавлять в ответ разделитель и очередной токен. Важно, чтобы разделители не оказались по краям — они должны быть только между токенами.</p>
<pre>
#include &lt;string&gt;
#include &lt;vector&gt;

std::string Join(std::vector&lt;std::string&gt;& tokens, char delim) {
  std::string result;
  for (size_t i = 0; i != tokens.size(); ++i) {
    if (i > 0) {
      result += delim;
    }
    result += tokens[i];
  }
  return result;
}
</pre>
  </details>

  <h4>Задача «Транспонировать матрицу»</h4>

  <details>
    <summary>Условие</summary>
    <p>Дана прямоугольная матрица A из m строк и n столбцов. Транспонированной матрицей AT называется матрица из n строк и m столбцов, в которой строки и столбцы поменялись ролями: элемент  Aij равен элементу Aji.</p>
    <p>Напишите функцию, которая возвращает транспонированную матрицу:</p>
    <code>std::vector&lt;std::vector&lt;int&gt; &gt; Transpose(const std::vector&lt;std::vector&lt;int&gt; &gt;& matrix);</code>

    <p>Примечание</p>
    <p>Гарантируется, что вектор matrix непуст и все его элементы имеют равную ненулевую длину.</p>
    <p>Подключите необходимые заголовочные файлы и напишите только код функции Transpose. Мы скомпилируем решение с нашей функцией main.</p>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;vector&gt;

std::vector&lt;std::vector&lt;int&gt; &gt; Transpose(const std::vector&lt;std::vector&lt;int&gt; &gt;& matrix) {
  const size_t m = matrix.size();
  const size_t n = matrix[0].size();

  std::vector&lt;std::vector&lt;int&gt; &gt; result(n);
  for (size_t j = 0; j != n; ++j) {
    result[j].resize(m);
    for (size_t i = 0; i != m; ++i) {
      result[j][i] = matrix[i][j];
    }
  }
  return result;
}
</pre>
  </details>

  <h4>Задача «Сортировка точек»</h4>

  <details>
    <summary>Условие</summary>
    <p>Вам даны координаты точек на плоскости. Выведите эти точки в порядке возрастания расстояний до начала координат.</p>

    <h4>Формат ввода</h4>
    <p>Сначала задано количество точек n. Затем идет последовательность из n строк, каждая из которых содержит два целых числа — координаты точки. Величина n не превосходит 100. Координаты точек по модулю не превосходят 1000.</p>

    <h4>Формат вывода</h4>
    <p>Выведите через пробел кординаты точек в порядке возрастания расстояний до начала координат. После каждой пары координат печатайте перевод строки.</p>

    <h4>Пример</h4>
<pre>
2
2 3
1 2
</pre>
<pre>
1 2
2 3
</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Создадим структуру Point для хранения точки. Заполним вектор этих структур. Напишем лямбда-функцию для сравнения двух точек. Заметим, что вычислять квадратный корень не обязательно: достаточно сравнить целочисленную сумму квадратов.</p>
<pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

struct Point {
  int x;
  int y;
};

int main() {
  size_t n;
  std::cin >> n;

  std::vector&lt;Point&gt; points(n);

  for (size_t i = 0; i != n; ++i) {
    std::cin >> points[i].x >> points[i].y;
  }

  std::sort(
    points.begin(),
    points.end(),
    [](const Point& p1, const Point& p2) {
      return p1.x * p1.x + p1.y * p1.y &lt; p2.x * p2.x + p2.y * p2.y;
    }
  );

  for (const auto& point : points) {
    std::cout &lt;&lt; point.x &lt;&lt; " "
              &lt;&lt; point.y &lt;&lt; "\n";
  }
}
</pre>
    <p>Недостаток этого решения в том, что для каждого сравнения пары точек приходится вычислять сумму квадратов заново. Можно было бы предрассчитать расстояния от каждой точки до начала координат отдельно и отсортировать уже по готовым значениям.</p>
  </details>
</article>


<!-- 3.1 Последовательные контейнеры -->
<article class="article">
  <div class="anchor" id="p3.1"></div>
  <h2>3 Стандартная библиотека C++</h2>
  <h3>3.1 Последовательные контейнеры</h3>

  <p>Стандартная библиотека C++ содержит набор шаблонных контейнеров. С некоторыми из них мы уже знакомы: это std::vector и std::string. Эти два контейнера гарантируют, что элементы (в случае string — символы строки) будут храниться в непрерывном фрагменте памяти. Эти контейнеры умеют эффективно добавлять элементы в конец, делая реаллокацию при необходимости, но не могут обеспечить эффективную вставку или удаление элементов в других позициях.</p>
  <p>В этом параграфе мы рассмотрим другие последовательные контейнеры. Они не обязательно хранят элементы в непрерывном куске памяти, но позволяют обойти элементы в последовательном порядке.</p>
  <p>Как правило, контейнеры определены в одноимённом заголовочном файле стандартной библиотеки.</p>
</article>


<!-- 3.2 Ассоциативные контейнеры -->
<article class="article">
  <div class="anchor" id="p3.2"></div>
  <h3>3.2 Ассоциативные контейнеры</h3>
</article>


<!-- 3.3 Алгоритмы -->
<article class="article">
  <div class="anchor" id="p3.3"></div>
  <h3>3.3 Алгоритмы</h3>
</article>


<!-- 3.4 Адаптеры и представления -->
<article class="article">
  <div class="anchor" id="p3.4"></div>
  <h3>3.4 Адаптеры и представления</h3>
</article>


<!-- 3.5 Разбор задач к главе «Стандартная библиотека C++» -->
<article class="article">
  <div class="anchor" id="p3.5"></div>
  <h3>3.5 Разбор задач к главе «Стандартная библиотека C++»</h3>
</article>


<!-- 4.1 Классы -->
<article class="article">
  <div class="anchor" id="p4.1"></div>
  <h2>4 Идиомы C++</h2>
  <h3>4.1 Классы</h3>
</article>


<!-- 4.2 Шаблонные классы -->
<article class="article">
  <div class="anchor" id="p4.2"></div>
  <h3>4.2 Шаблонные классы</h3>
</article>


<!-- 4.3 Жизненный цикл объекта -->
<article class="article">
  <div class="anchor" id="p4.3"></div>
  <h3>4.3 Жизненный цикл объекта</h3>
</article>


<!-- 4.4 Наследование и полиморфизм -->
<article class="article">
  <div class="anchor" id="p4.4"></div>
  <h3>4.4 Наследование и полиморфизм</h3>
</article>


<!-- 4.5 Обработка исключений -->
<article class="article">
  <div class="anchor" id="p4.5"></div>
  <h3>4.5 Обработка исключений</h3>
</article>


<!-- 4.6 Идиома RAII и умные указатели -->
<article class="article">
  <div class="anchor" id="p4.6"></div>
  <h3>4.6 Идиома RAII и умные указатели</h3>
</article>


<!-- 4.7 Разбор задач к главе «Идиомы C++» -->
<article class="article">
  <div class="anchor" id="p4.7"></div>
  <h3>4.7 Разбор задач к главе «Идиомы C++»</h3>
</article>



<!-- 5.1 Как работать с системой проверки заданий -->
<article class="article">
  <div class="anchor" id="p5.1"></div>
  <h2>5 Приложение</h2>
  <h3>5.1 Как работать с системой проверки заданий</h3>
</article>


<!-- 5.2 Как пользоваться хендбуком -->
<article class="article">
  <div class="anchor" id="p5.2"></div>
  <h3>5.2 Как пользоваться хендбуком</h3>
</article>


