<article class="article">
  <h1>2018 Тимофей Хирьянов. Язык Си. Курс молодого бойца МФТИ.</h1>
  <p>Конспект видео курса</p>
  <p>37 уроков. Длительность 9ч 18м.</p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

      <a href="#p1">1 Разбор  Hello, World! на Си</a>
  <br><a href="#p2">2 Ошибки и предупреждения при компиляции на Си</a>
  <br><a href="#p3">3 Этапы компиляции на Си предобработка, трансляция, компоновка</a>
  <br><a href="#p4">4 Переполнение и ошибки при работе с целыми типами в Си</a>
  <br><a href="#p5">5 Циклы for и while в Си сходство и различие</a>
  <br><a href="#p6">6 Генерация арифметических и геометрических прогрессий на Си</a>
  <br><a href="#p7">7 Операции присваивания и сравнения чисел в Си</a>
  <br><a href="#p8">8 Деление нацело и взятие остатка</a>
  <br><a href="#p9">9 Оператор if и организация ветвления в Си</a>
  <br><a href="#p10">10 Метки, оператор goto и оператор switch в Си</a>
  <br><a href="#p11">11 Управление циклом в Си break, continue</a>
  <br><a href="#p12">12 Разложение числа на множители на Си</a>
  <br><a href="#p13">13 Фильтрация потока чисел на Си</a>
  <br><a href="#p14">14 Индуктивные функции на Си подсчёт, сумма, произведение</a>
  <br><a href="#p15">15 Индуктивные функции на Си any of, all of</a>
  <br><a href="#p16">16 Индуктивные функции на Си поиск максимума</a>
  <br><a href="#p17">17 Хранение массива в памяти в Си</a>
  <br><a href="#p18">18 Создание и заполение массива на Си</a>
  <br><a href="#p19">19 Решето Эратосфена на Си</a>
  <br><a href="#p20">20 Копирование массива, реверс циклический сдвиг на Си</a>
  <br><a href="#p21">21 Задачи №25 ЕГЭ по информатике на Си</a>
  <br><a href="#p22">22 Задача №27 ЕГЭ по информатике на Си</a>
  <br><a href="#p23">23 Добавление и удаление элемента в конец массива на Си</a>
  <br><a href="#p24">24 Сортировка массива вставками на Си</a>
  <br><a href="#p25">25 Асимптотика сортировок. Сортировка подсчётом на Си</a>
  <br><a href="#p26">26 Функции в языке Си</a>
  <br><a href="#p27">27 Рекурсия. Репка и матрёшка</a>
  <br><a href="#p28">28 Примеры рекурсивных алгоритмов</a>
  <br><a href="#p29">29 Ханойские башни на Си</a>
  <br><a href="#p30">30 Динамическое программирование сверху и снизу</a>
  <br><a href="#p31">31 Динамическое программирование траектории кузнечика</a>
  <br><a href="#p32">32 Адреса и указатели в Си. Адресная арифметика</a>
  <br><a href="#p33">33 Тип void и интерпретация данных</a>
  <br><a href="#p34">34 Передача адреса переменной в функцию в Си</a>
  <br><a href="#p35">35 Выделение и освобождение динамической памяти в Си</a>
  <br><a href="#p36">36 Двумерные массивы в Си обычные и динамические</a>
  <br><a href="#p37">37 Техника безопасности при работе с памятью в Си</a>
</article>


<!-- 1 Разбор  Hello, World! на Си -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>1 Разбор  Hello, World! на Си</h3>

  <p>Я, Тимофей Хирьянов, проведу вас от школьной информатики до уровня информатики в МФТИ. Это мини курс, в нем 5 уроков. Каждый урок разбит на несколько видео. Я познакомлю вас с языком программирования Си и изложу школьные алгоритмы, которые вы бы знали если бы готовились к ЕГЭ по информатике хорошо. Разберем для начала программу hello world</p>
<pre>
#include &lt;stdio.h&gt;

int main(int argc, char* argv[]) {
  printf("Hello, World!\n");

  return 0;
}
</pre>

  <p>В первой строке идет инструкция препроцессора #include, которая подключает стандартную библиотеку ввода-вывода к нашей программе. Это строка не на языке Си. Инструкция в этой строке выполняется перед компиляцией на этаме обработки команд препроцессора. stdio.h это заголовочный файл, который описывает интерфейс библиотеки и он написан на языке Си. Сама библиотека разбивается на две части - это ее исходный код, он часто преобразован сразу в объектный файл с расширением .o, и заголовочный файл на языке Си с расширением .h.</p>
  <p>Вся программа на языке Си состоит из функций, которые вызывают друг друга. Всегда есть одна главная функция, которая вызывается первой. Это функция main(). Каждая программа должна содержать функцию main. При запуске программы эту функцию запускает командная оболочка (bash или cmd). И эта функция должна вернуть результат в командную оболочку после завершения своей работы. Поэтому главная функция оформляется точно также как все остальные функции в языке Си.</p>
  <p>Она имеет заголовок и тело. В заголовке сначала пишется возвращаемый тип, имя функции и список параметров. Параметры в главной функции необязательны, но лучше их знать.</p>
  <p>Язык программирования Си создавался в то время, когда никакого графического интерфейса еще не было и все программы запускались из командной строки. При запуске в программу передавались аргументы командной строки. argc это количество аргументов конмандной строки. argv это массив строк со значениями аргументов командной строки.</p>
  <p>Функция main всегда должна возвращать целое число. Во время выполнения программы может возникнуть ошибка, при которой дальнейшее выполнение невозможно. Программа должна вернуть код ошибки. Число 0 означает что программа выполнилась без ошибок. Коды ошибок для каждой программы пишутся в документации к этой программе. Из командной строки можно узнать какой код вернула программа, после своего выполнения.</p>
  <p>Единственная содержательная строчка нашей программы это та где вызывается функция printf(). Это print format - форматированная печать. Функция принимает первый аргумент в виде строки формата, в который вместе с текстом можно передавать значения переменных и способ их отображения.</p>
  <p>Добавим внутрь форматной строки спецификатор формата %s для вставки другой строки</p>
  <code>printf("Hello, %s!\n", "John");</code>
</article>


<!-- 2 Ошибки и предупреждения при компиляции на Си -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>2 Ошибки и предупреждения при компиляции на Си</h3>

  <p>Си это язык программирования высокого уровня. Процессор компьютера не знает языка Си. Чтобы процессор мог выполнить программу нужны <strong>компилятор</strong> и <strong>операционная система</strong>. Компилятор преобразует исходный текст на языке Си в исполняемый файл. При запуске исполняемого файла операционная система загружает его в оперативную память и контроллирует весь процесс.</p>
  <p>Компилятор, встретив ошибку, прекращает компиляцию и возвращает эту ошибку на экран разработчику.</p>
  <p>Напишем программу</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  printf("I'm a Bot. What's your name?\n");
  char name;
  scanf("%s", name);
  printf("Hello, %s! How old are you?\n");
  int age;
  scanf("%s", age);
  printf("Yuo are looking younger! "
         "I thought you are %d!\n", age - 3);

  return 0;
}
</pre>
  <p>Программа содержит ошибки. Но она скомпилируется без ошибок. Запустим программу. При вводе имени операционная система завершит программу с ошибкой. По умолчанию компилятор выдает только ошибки. Можно его настроить так, чтобы он выдавал еще и предупреждения.</p>
  <p>Если мы работаем в программе Code::Blocks, то нужно зайти в настройки компилятора</p>
  <code>Settings - Compiler</code>
  <p>В открывшемся окне Compiler settings выберем раздел Global compiler settings. На вкладке Compiler settings выберем вкладку Compiler Flags и найдем раздел Warnings. Поставим галочку рядом с флагом [-Wall]</p>
  <code>Enable all common compiler warnings (override many other settings) [Wall]</code>
  <p>Если теперь запустить компиляцию, то мы получим предупреждения об ошибках и программа не будет скомпилирована. Исправим ошибки в программе.</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  printf("I'm a Bot. What's your name?\n");
  char name[20];
  scanf("%s", name);
  printf("Hello, %s! How old are you?\n", name);
  int age;
  scanf("%d", &age);
  printf("Yuo are looking younger! "
         "I thought you are %d!\n", age - 3);

  return 0;
}
</pre>
</article>


<!-- 3 Этапы компиляции на Си предобработка, трансляция, компоновка -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>3 Этапы компиляции на Си предобработка, трансляция, компоновка</h3>
  <ol>
    <li>Этап preprocessing выполняется препроцессором. Удаляются комментарии, выполняются текстовые замены, условные включения кода, включение файлов, включение кода библиотек. В результате файл не создается.</li>
    <li>Этап compilation (компиляция, трансляция). Трансляция - перевод в машинные коды. Создается объектный файл с расширением .o, который состоит из машинных кодов.</li>
    <li>Этап linking (линковка, компоновка, сборка). Несколько объектных файлов собираются в один исполняемый файл. Создается исполняемый файл с расширением .exe.</li>
  </ol>
  <p>В программе Code::Blicks внизу на вкладке Build log можно посмотреть что происходит при сборке.</p>
  <p>Выполним пошагово все этапы компиляции на программе hello.c.</p> <p>Первый этап - препроцессинг. В качестве исходного файла для этапа препроцессинга передадим исходный текст программы, написанный нами на языке Си.</p>
  <code>gcc -E hello.c</code>
  <p>В результате создастся код, после обработки препроцессором, и выведется на экран, но никакой файл не создастся. Мы можем перенаправить вывод с экрана в файл</p>
  <code>gcc -E hello.c > hello_prep.c</code>
  <p>Препроцессор удаляет все коментарии, сделанные программистом, но вставляет свои коментарии для компилятора на строках, начинающихся с решетки #.</p>
  <p>Второй этап - трансляция. В качестве исходного файла для этапа трансляции передадим файл, полученный на предыдущем этапе препроцессинга.</p>
  <code>gcc -c hello_prep.c</code>
  <p>В результате трансляции создастся объектный файл с расширением .o с машинным кодом.</p>
  <p>Третий этап - сборка. Нужно собрать вместе полученный объектный код нашей программы и объектные коды включенных в программу библиотек. Компилятор сам знает где в операционной системе находятся файлы библиотек. Нам достаточно передать ему только наш объектный файл</p>
  <code>gcc hello_prep.o</code>
  <p>В результате линковки создастся исполняемый файл с именем a.exe. Если мы хотим получить другое имя, нужно его задать.</p>
  <code>gcc hello_prep.o -o hello.exe</code>
</article>


<!-- 4 Переполнение и ошибки при работе с целыми типами в Си -->
<article class="article">
  <div class="anchor" id="p4"></div>
  <h3>4 Переполнение и ошибки при работе с целыми типами в Си</h3>

  <p>Пусть у нас есть три бита для хранения переменной целого типа. Диапазон возможных значений переменной будет от 0 (000) до 7 (111). Кодовая таблица трех-битового числа без знака:</p>
<pre>
000 = 0
001 = 1
010 = 2
011 = 3
100 = 4
101 = 5
110 = 6
111 = 7
</pre>
  <p>Это также называется кольцо вычетов по модулю 8. Если прибавить единицу к семерке, то в переменной получим число 0. Это назвается overflow (переполнение). Если вычесть единицу из нуля, то получим 7. Это называется underflow.</p>
  <p>Теперь мы хотим хранить еще и отрицательные числа. Сохраним идею кольца вычетов. Называется это дополнительный двоичный код. Кодовая таблица 3-битового числа со знаком.</p>
<pre>
000 = 0
001 = 1
010 = 2
011 = 3
100 = -4
101 = -3
110 = -2
111 = -1
</pre>
  <p>Диапазон допустимых значений от -4 до 3.</p>
</article>


<!-- 5 Циклы for и while в Си сходство и различие -->
<article class="article">
  <div class="anchor" id="p5"></div>
  <h3>5 Циклы for и while в Си сходство и различие</h3>

  <p>Цикл for является полным аналогом цикла while. Оба цикла могут быть бесконечными.</p>
<pre>
int i = 0;
while (i &lt; 10) {
  printf("%d", i);
  ++i;
}
</pre>
<pre>
for (int i = 0; i &lt; 10; ++i) {
  printf("%d", i);
}
</pre>
</article>


<!-- 6 Генерация арифметических и геометрических прогрессий на Си -->
<article class="article">
  <div class="anchor" id="p6"></div>
  <h3>6 Генерация арифметических и геометрических прогрессий на Си</h3>

  <p>Генерация арифметической прогрессии с помощью цикла while</p>
<pre>
int start = 1, step = 1, stop = 10;
int x = start;
while (x &lt; stop) {
  printf("x = %d\n", x);
  x += step;  // арифметическая прогрессия
}
</pre>

  <p>Генерация геомеметической прогрессии с помощью цикла while</p>
<pre>
int start = 1, step = 2, stop = 1050;
int x = start;
while (x &lt; stop) {
  printf("x = %d\n", x);
  x *= step;  // геометрическая прогрессия
}
</pre>

  <p>Генерация убывающей арифметической прогрессии с помощью цикла while</p>
<pre>
int start = 10, step = -1, stop = 1;
int x = start;
while (x > stop) {
  printf("x = %d\n", x);
  x += step;  // арифметическая прогрессия
}
</pre>

  <p>Генерация возрастающей и убывающей арифметической прогрессии в зависимости от знака шага step</p>
<pre>
int start = 10, step = -1, stop = 1;
int sign = (step > 0) ? 1 : -1;
int x = start;
while (sign * x &lt; sign * stop) {
  printf("x = %d\n", x);
  x += step;  // арифметическая прогрессия
}
</pre>
</article>


<!-- 7 Операции присваивания и сравнения чисел в Си -->
<article class="article">
  <div class="anchor" id="p7"></div>
  <h3>7 Операции присваивания и сравнения чисел в Си</h3>

  <p>Операция со знаком присваивания = сначала вычисляет выражение справа, затем вычисляет выражение слева и присваивает ему вычисленное выражение справа. Слева от знака присваивания может стоять только l-value выражение. l-value это реальная оперативная память, куда можно записать значение.</p>
  <code>int x, y, z;</code>
  <code>x = y = z = 5;</code>
  <p>Нельзя в одном выражении несколько раз делать присваивание в одну переменную. Потому что компилятор может закешировать разельтат и произвести запись в переменную только один раз. При этом записано может быть не то что вам нужно</p>
  <code>x = (x = 2) + (x = 5); // так нельзя</code>
  <code>x = (x++) + (++x); // так нельзя</code>
  <p>Операции со знаками сравнения тоже возвращают результат. И этот результат - целое число</p>
  <code>int x = (5 > 2); // x = 1</code>
  <code>int x = (5 > 2) + (4 >= -1) + (10 == 9 + 1); // x = 3</code>
  <code>int y = (2 >= 5); // y = 0</code>
  <p>Избегайте сравнения знаковых и беззнаковых целых типов. Здесь -1 будет приведена к беззнаковому типу и равна 2<sup>31</sup> - 1.</p>
  <code>int z = (5u > -1); // z = 0</code>
</article>


<!-- 8 Деление нацело и взятие остатка -->
<article class="article">
  <div class="anchor" id="p8"></div>
  <h3>8 Деление нацело и взятие остатка</h3>

  <p>Деление целых чисел происходит нацело, с отбрасыванием остатка.</p>
  <code>int x = 12345 / 1000; // x = 12</code>
  <p>Остаток от деления вычисляется правильно только при положительных числах.</p>
  <code>int y = 12345 % 1000; // y = 345</code>
  <p>У отрицательных чисел остаток от деления отрицательный, что противоречит математике. В своих программах это надо учитывать и исправлять.</p>
  <code>int z = -19 % 10; // z = -9</code>
  <p>Для получения вещественного числа недостаточно разделить два целых числа. Сначала вычислится выражение справа, а это деление двух целых чисел. Потом полученное целое число при записи в вещественную переменную будет приведено к вещественному типу.</p>
  <code>double x = 1 / 2; // x = 0</code>
  <p>Мы сами должны сделать операнды для операции деления дробными</p>
  <code>double x = 1. / 2. ; // x = 0.5</code>
  <code>double x = (double)y / (double)z;</code>
</article>


<!-- 9 Оператор if и организация ветвления в Си -->
<article class="article">
  <div class="anchor" id="p9"></div>
  <h3>9 Оператор if и организация ветвления в Си</h3>

  <p>Определим положение точки с координатами x, y на координатной плоскости</p>
<pre>
if (y > 0) {
  if (x > 0) {
    printf("1-st quarter\n");
  } else {
    printf("2-nd quarter\n");
  }
} else {
  if (x > 0) {
    printf("4-th quarter\n");
  } else {
    printf("3-rd quarter\n");
  }
}
if (x == 0 || y == 0) {
  printf("Point is on axis\n");
}
</pre>
<pre>
if (y > 0 && x > 0) {
  printf("1-st quarter\n");
} else if (y > 0 && x &lt; 0) {
  printf("2-nd quarter\n");
} else if (y &lt; 0 && x &lt; 0) {
  printf("3-rd quarter\n");
} else if (y &lt; 0 && x > 0){
  printf("4-th quarter\n");
} else {
  printf("Point is on axis\n");
}
</pre>
</article>


<!-- 10 Метки, оператор goto и оператор switch в Си -->
<article class="article">
  <div class="anchor" id="p10"></div>
  <h3>10 Метки, оператор goto и оператор switch в Си</h3>

  <p>Оператор goto нужно избегать в своих программах.</p>
  <p>Оператор switch это множественный выбор только для целых чисел.</p>
</article>


<!-- 11 Управление циклом в Си break, continue -->
<article class="article">
  <div class="anchor" id="p11"></div>
  <h3>11 Управление циклом в Си break, continue</h3>

  <p>break и continue используются внутри цикла. break это goto за пределы цикла к следующей инструкции. continue это goto на проверку условия цикла и в начало следующей итерации.</p>
  <p>Переведем десятичное число в шестнадцатеричное в цикле , пока на вход не придет 0.</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int x;
  while (1) {
    scanf("%d", &x);
    if (x == 0) break;
    printf("Number %d in hex is %X\n", x, x);
  }
}
</pre>
  <p>Проверим является ли число простым. Циклом будем перебирать все числа от 2 пока не найдем делитель. Цикл до конца может и не дойти.</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int x;
  printf("Enter number ");
  scanf("%d", &x);

  for (int i = 2; i * i &lt;= x; i++) {
    if (x % i == 0) break;
  }

  if (i * i > x) {
    printf ("number %d is prime\n", x);
  } else {
    printf("Number %d is not prime\n", x);
  }
}
</pre>
  <p>Второй вариант с использованием булевской переменной. Цикл всегда будет работать от начала до конца. Поэтому по скорости работы этот вариант хуже первого.</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

int main() {
  int x;
  printf("Enter number ");
  scanf("%d", &x);
  bool is_prime = true;

  for (int i = 2; i * i &lt;= x; i++) {
    if (x % i == 0) is_prime = false;
  }

  if (is_prime) {
    printf ("number %d is prime\n", x);
  } else {
    printf("Number %d is not prime\n", x);
  }
}
</pre>
  <p>Третий вариант с использованием функции проверки числа на простоту.</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

bool is_prime(int n) {
  for (int i = 2; i * i &lt;= n; i++) {
    if (n % i == 0) return false;
  }
  return true;
}

int main() {
  int x;
  printf("Enter number ");
  scanf("%d", &x);

  if (is_prime(x)) {
    printf ("number %d is prime\n", x);
  } else {
    printf("Number %d is not prime\n", x);
  }
}
</pre>
</article>


<!-- 12 Разложение числа на множители на Си -->
<article class="article">
  <div class="anchor" id="p12"></div>
  <h3>12 Разложение числа на множители на Си</h3>

  <p>Любое целое число можно представить в виде произведения простых чисел единственным способом.</p>
  <code>n = p1 * p2 * ... * pn</code>
  <p>Такое разложение числа на простые множители лежит в основе шифрования RSA. Потому что эта задача асимптотически сложна. Существуют экспоненциальные алгоритмы в которых требуется полный перебор. Пока что нет ни одного не квантового простого способа разложить число на множители.</p>
  <p>Например, разложим число 90 на множители. Начнем с наименьшего простого числа</p>
  <code>90 / 2 = 45</code>
  <p>45 на 2 уже не делится, берем следующее простое число 3</p>
  <code>45 / 3 = 15, 15 / 3 = 5</code>
  <p>45 на 3 делится два раза. В итоге получили простое число 5. В итоге число 90 раскладывается на произведение простых чисел</p>
  <code>90 = 2 * 3 * 3 * 5</code>
<pre>
#include &lt;stdio.h&gt;

void print(int n) {
  printf("Number factors ");
  int i = 2;
  while (n != 1) {
    while (x % i == 0) {
      printf("%d", i);
      n /= i;
    }
    i++;
  }
  printf("\n");
}

int main() {
  int x;
  printf("Enter number ");
  scanf("%d", &x);
  print(x);
}
</pre>
</article>


<!-- 13 Фильтрация потока чисел на Си -->
<article class="article">
  <div class="anchor" id="p13"></div>
  <h3>13 Фильтрация потока чисел на Си</h3>

  <p>Можно представить алгоритм как функцию y = f(x), где одно число подается на вход и одно число возвращается на выход.</p>
  <p>Можно представить алгоритм как генератор чисел y = gen(x), где одно число подается на вход и возвращается последовательность чисел. </p>
  <p>Можно представить алгоритм как обработку последовательности, где на вход подается последовательность чисел и на выходе возвращается последовательность.</p>
  <p>Фильтрующий алгоритм принимает последовательность, а возвращает последовательность только тех чисел которые прошли фильтрацию.</p>
  <p>Достанем из числа цифры начиная с младшего разряда. Выведем на экран все цифры.</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int x;
  printf("Enter number");
  scanf("%d", &x);
  while (x) {
    int digit = x % 10;
    printf("%d", digit);
    x /= 10;
  }
}
</pre>
<p>Достанем из числа цифры начиная с младшего разряда. Выведем на экран только нечетные.</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int x;
  printf("Enter number");
  scanf("%d", &x);
  while (x) {
    int digit = x % 10;
    ша (вшпше % 2 == 1) {
      printf("%d", digit);
    }
    x /= 10;
  }
}
</pre>
</article>


<!-- 14 Индуктивные функции на Си подсчёт, сумма, произведение -->
<article class="article">
  <div class="anchor" id="p14"></div>
  <h3>14 Индуктивные функции на Си подсчёт, сумма, произведение</h3>

  <p>Функция f индуктивная на пространстве последовательностей, если найдется функция перевычисления от двух аргументов. Если известно значение функции на подпоследовательности, то добавив еще один элемент, можно вычислить новое значение на новой подпоследовательности.</p>
  <p>Индуктивная сумма последовательности. Для 0 элементов равна 0. Для 1 элемента равна сумме 0 и этого элемента. Для остальных случаев равна сумме элементов.</p>
  <p>Индуктивное произведение последовательности. Для 0 элеметов равна 1, для 1 элемента равна произведению этого элемента на 1. Для остальных случаев равна произведению элементов.</p>
</article>


<!-- 15 Индуктивные функции на Си any of, all of -->
<article class="article">
  <div class="anchor" id="p15"></div>
  <h3>15 Индуктивные функции на Си any of, all of</h3>

  <p>Будет два алгоритма</p>
  <ol>
    <li>any of. это какое-то из чисел соответствует критерию (поисковый алгоритм). Начальное состояние false. Функция перечисления основана на логическом ИЛИ. Совпадает с индуктивной функцией сложения.</li>
    <li>all of. это все числа соответствуют критерию. Начальное состояние true. Функция перечисления основана на логическом И. Совпадает с индуктивной функцией умножения.</li>
  </ol>
</article>


<!-- 16 Индуктивные функции на Си поиск максимума -->
<article class="article">
  <div class="anchor" id="p16"></div>
  <h3>16 Индуктивные функции на Си поиск максимума</h3>

<pre>
#include &lt;stdio.h&gt;

int main() {
  int x;
  scanf("%d", &x);
  int m = x;

  while (x != 0) {
    m = x > m ? x : m;
    scanf("%d", &x);
  }

  printf("max = %d\n", m);
  return 0;
}
</pre>
</article>


<!-- 17 Хранение массива в памяти в Си -->
<article class="article">
  <div class="anchor" id="p17"></div>
  <h3>17 Хранение массива в памяти в Си</h3>

  <p>Массив это структура данных, в которой хранятся однотипные элементы, располагаясь в памяти последовательно друг за другом в порядке возрастания индексов.</p>
</article>


<!-- 18 Создание и заполение массива на Си -->
<article class="article">
  <div class="anchor" id="p18"></div>
  <h3>18 Создание и заполение массива на Си</h3>

  <code>int A[6];</code>
  <code>int A[6] = {1, 2, 3, 4, 5, 6};</code>
  <code>int A[6] = {0}; // заполнили нулями</code>
</article>


<!-- 19 Решето Эратосфена на Си -->
<article class="article">
  <div class="anchor" id="p19"></div>
  <h3>19 Решето Эратосфена на Си</h3>

  <p>Для реализации решета Эратосфена от 2 до n, возьмем первый массив из n + 1 элементов и инициализируем его нулями. Пусть, если элемент содержит 0, то его индекс это простое число, а если 1, то его индекс это составное число. В элементы с индексами 0 и 1 записываем единицы, что означает не простое число. Первое простое число 2 записываем во второй массив, который будет содержать простые числа. В первом массиве будем прибавлять 2 к индексу 2 и записывать в эти элементы 1, что означает составное число, в составе которого есть число 2.</p>

<pre>
int main() {
  int N = 20;
  int A[N] = {0};
  A[0] = 1;
  A[1] = 1;

  for (int i = 2; i * i &lt; N; i++) {
    if (A[i] == 0) {
      for (int j = i * i; j &lt; n; j += i) {
        A[j] = 1;
      }
    }
  }

  for (int i = 0; i &lt; N; i++) {
    if (A[i] == 0) {
      printf("%3d", i);
    }
  }
}
</pre>
</article>


<!-- 20 Копирование массива, реверс циклический сдвиг на Си -->
<article class="article">
  <div class="anchor" id="p20"></div>
  <h3>20 Копирование массива, реверс циклический сдвиг на Си</h3>

<pre>
int A[n] = {10, 20, 30, 40, 50, 60, 70, 80, 90};

// переворот массива
for (int i = 0; i &lt; n / 2; i++) {
  int tmp = A[i];
  A[i] = A[n - 1 - i];
  A[n - 1 - i] = tmp;
}

// сдвиг массива на 1 влево
int tmp = A[0];
for (int i = 0; i &lt; n - 1; i++) {
  A[i] = A[i + 1];
}
A[n - 1] = tmp;

// сдвиг массива на 1 вправо
int tmp = A[n - 1];
for (int i = n - 1; i > 0; i--) {
  A[i] = A[i - 1];
}
A[0] = tmp;
</pre>
</article>


<!-- 21 Задачи №25 ЕГЭ по информатике на Си -->
<article class="article">
  <div class="anchor" id="p21"></div>
  <h3>21 Задачи №25 ЕГЭ по информатике на Си</h3>

  <p>Дан целочисленный массив из 30 элементов. Элементы массива могут принимать целые значения от 0  до 10000 включительно. Опишите на одном из языков программирования алгоритм, который находи количество элементов массива, больших 100 и при этом кратных 5, а затем заменяет каждый такой элемент на число, равное найденному количеству. Гарантируется, что хотя бы один такой элемент в массиве ессть. В качестве результата необходимо вывести измененный массив.</p>
  <p>Например, для массива из 6 элементов: 4 115 7 195 25 106 программа должна вывести числа 4 2 7 2 25 106.</p>

<pre>
#include &lt;stdio.h&gt;
#define N 30

int main() {
  int a[N];
  int i, j, k;

  for (i = 0; i &lt; N; i++) {
    scanf("%d", &a[i]);
  }

  k = 0;

  for (i = 0; i &lt; N; i++) {
    if (a[i] > 100 && a[i] % 5 == 0) {
      k++;
    }
  }

  for (i = 0; i &lt; N; i++) {
    if (a[i] > 100 && a[i] % 5 == 0) {
      a[i] = k;
    }
  }

  for (i = 0; i &lt; N; i++) {
    printf("%d ", a[i]);
  }

  return 0;
}
</pre>
</article>


<!-- 22 Задача №27 ЕГЭ по информатике на Си -->
<article class="article">
  <div class="anchor" id="p22"></div>
  <h3>22 Задача №27 ЕГЭ по информатике на Си</h3>

  <p>На вход программы поступает последовательность из N целых положительных чисел, все числа в последовательности различны. Расматриваются все пары различных элементов последовательности (элементы и пары не обязаны стоять в последовательности рядом, порядок элементов в паре не важен). Необходимо определить количество пар, для которых произведение элементов делится на 26.</p>
  <p>Например для входной строки 4 2 6 13 39, ответ будет 4. Потому что на 26 делятся четыре пары 2*13, 2*39, 6*13, 6*39.</p>

<pre>
#include &lt;stdio.h&gt;

int main() {
  int N;
  scanf("%d", &N);
  int k26 = 0, k13 = 0, k2 = 0;;

  for (int i = 0; i &lt; N; i++) {
    int x;
    scanf("%d", &x);

    if (x % 26 == 0) {
      k26++;
    } else (if x % 13 == 0) {
      k13++;
    } else if (x % 2 == 0) {
      k2++;
    } else {
      k1++;
    }

  }

  int m = k26*(k26 - 1)/2 + k26*(k1+k2+k13) + k2*k13;
  printf("%d\n", m);

  return 0;
}
</pre>
</article>


<!-- 23 Добавление и удаление элемента в конец массива на Си -->
<article class="article">
  <div class="anchor" id="p23"></div>
  <h3>23 Добавление и удаление элемента в конец массива на Си</h3>

<pre>
int get_number_factors(int x, intA[]) {
  int top = 0;
  int divisor = 2;
  while (x != 1) {
    while (x % divisor == 0) {
      A[top] = divisor;
      top += 1;
      x /= divisor;
    }
    divisor += 1;
  }
  return top;
}

int main() {
  int x;
  printf("Enter number to factorize:");
  scanf("%d", &x);
  int A[100];
  int N;
  N = get_number_factors(x, A);
  for (int i = 0; i &lt; N; i++) {
    printf("%d ", A[i]);
  }
  return 0;
}
</pre>
</article>


<!-- 24 Сортировка массива вставками на Си -->
<article class="article">
  <div class="anchor" id="p24"></div>
  <h3>24 Сортировка массива вставками на Си</h3>

  <p>Для сортировки вставками принимаем последовательность элементов по очереди. Первый элемент уже отсортирован и стоит на своем месте. Следующий элемент ставим на свое место.</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

#define ALLOCATE_SIZE 1000

int input_array(int A[], int max_size) {
  int top = 0;
  while (true) {
    int x;
    scanf("%d", &x);
    if (x == 0 || top == max_size) break;
    A[top] = x;
    top++;
  }
  return top;
}

void print_array(int A[], int N) {
  for (int i = 0; i &lt; N; i++) {
    printf("%3d ", A[i]);
  }
  printf("\n");
}

void insert_sort(int A[], int N) {
  for (int i = 1; i &lt; N; i++) {
    int k = i;
    while (k > 0 && A[k-1] > A[k]) {
      int tmp = A[k - 1];
      A[k - 1] = A[k];
      A[k] = tmp;
      k -= 1;
    }
  }
}

int main() {
  printf("Enter numbers:");
  int A[ALLOCATE_SIZE];
  int N;

  N = input_array(A, ALLOCATE_SIZE);
  insert_sort(A, N);
  print_array(A, N);

  return 0;
}
</pre>
</article>


<!-- 25 Асимптотика сортировок. Сортировка подсчётом на Си -->
<article class="article">
  <div class="anchor" id="p25"></div>
  <h3>25 Асимптотика сортировок. Сортировка подсчётом на Си</h3>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

int main() {
  int counters[10] = {0};
  int x;

  while (true) {
    scanf("%d", &x);
    if (x == 10) break;
    if (x &lt; 0 || x > 9) continue;
    counters[x] += 1;
  }

  for (x = 0; x &lt; 10; x++) {
    for (int i = 0; i &lt; counters[x]; i++) {
      printf("%3d ", x);
    }
  }
  return 0;
}
</pre>
</article>


<!-- 26 Функции в языке Си -->
<article class="article">
  <div class="anchor" id="p26"></div>
  <h3>26 Функции в языке Си</h3>

<pre>
#include &lt;stdio.h&gt;

void A();
void B();
void C();

int main() {
  printf("main() called.\n");
  A();
  printf("main() returns.\n");

  return 0;
}

void A() {
  printf("  A() called.\n");
  B();
  printf("  A() returns.\n");
}

void B() {
  printf("    B() called.\n");
  C();
  printf("    B() returns.\n");
}

void C() {
  printf("      C() called.\n");
  printf("      C() returns.\n");
}
</pre>
</article>


<!-- 27 Рекурсия. Репка и матрёшка -->
<article class="article">
  <div class="anchor" id="p27"></div>
  <h3>27 Рекурсия. Репка и матрёшка</h3>

<pre>
#include &lt;stdio.h&gt;

void matryoshka(int n);

int main() {
  matryoshka(7);

  return 0;
}

void matryoshka (int n) {
  if (n == 1) {
    printf("Last matryoshka %d\n", n);
  } else {
    printf("Top side matryoshka %d\n", n);
    matryoshka(n - 1);
    printf("Bottom side matryoshka %d\n", n);
  }
}
</pre>
</article>


<!-- 28 Примеры рекурсивных алгоритмов -->
<article class="article">
  <div class="anchor" id="p28"></div>
  <h3>28 Примеры рекурсивных алгоритмов</h3>

  <h4>Факториал</h4>

  <code>n! = (n - 1)! * n, n ≥ 1</code>
  <code>0! = 1, n = 0</code>

  <h4>Алгоритм Евклида</h4>

  <code>gcd(a, b) = gcd(b, a % b), b != 0</code>
  <code>gcd(a, b) = a, b = 0</code>

  <h4>Возведение в степень</h4>

  <code>aⁿ = a * aⁿ⁻¹, n > 0</code>
  <code>a⁰ = 1, n = 0</code>

  <p>Быстрое возведение в степень это когда четные степени вычислаяются как</p>
  <code>a<sup>n</sup> = a<sup>2</sup> * a<sup>n/2</sup></code>

  <h4>Числа Фибоначчи</h4>

  <code>F(n) = F(n-1) + F(n-2)</code>
  <code>F(0) = 0, F(1) = 1</code>

<pre>
int factorial(int n) {
  if (n == 0) {
    return 1;
  }
  return factorial(n-1) * n;
}
</pre>

<pre>
int gcd(int a, int b) {
  if (b == 0) {
    return a;
  }
  return gcd(b, a % b);
}
</pre>

<pre>
double fast_power(double a, int n) {
  if (n == 0) {
    return 1;
  }
  if (n % 2 == 0) {
    return fast_power(a * a, n / 2);
  } else {
    return a * fast_power(a, n - 1);
  }
}
</pre>

<pre>
int fib(int n) {
  if (n &lt;= 1) {
    return n;
  }
  return fib(n-1) + fib(n-2);
}
</pre>
</article>


<!-- 29 Ханойские башни на Си -->
<article class="article">
  <div class="anchor" id="p29"></div>
  <h3>29 Ханойские башни на Си</h3>

  <p>Есть три штырька. На первый штырек надето n дисков разного диаметра по порядку от самого большого снизу до самого маленького сверху. Диски можно перекладывать на другой штырек только по одному, меньший на больший. Необходимо пирамидку из дисков с первого штырька переместить на второй.</p>
  <p>Разобъем эту задачу на две подзадачи: перекладывание нижнего диска на второй штырек, перекладывание пирамидки из n-1 диска на третий штырек. Штырьки имеют номера 1, 2 и 3, что в сумме дает 6</p>
  <code>1 + 2 + 3 = 6</code>
  <p>Пусть нужно перекладывать пирамиду со штырька i на штырек k, используя штырек tmp как временный, тогда</p>
  <code>i + k + tmp = 6</code>
  <p>Отсюда найдем временный штырек</p>
  <code>tmp = 6 - i - k</code>
  <p>Получаем рекурсию. Крайний случай это переложить нижний блин.</p>

<pre>
#include &lt;stdio.h&gt;

void hanoi(int n, int i, int k);

int main() {
  hanoi(3, 1, 2);

  return 0;
}

void hanoi(int n, int i, int k) {
  if (n == 1) {
    printf("Move disk 1 from pin %d to %d.\n", n, i, k);
  } else {
    int tmp = 6 - i - k;
    hanoi(n-1, i, tmp);
    printf("Move disk %d from pin %d to %d.\n", n, i, k);
    hanoi(n-1, tmp, k);
  }
}
</pre>
</article>


<!-- 30 Динамическое программирование сверху и снизу -->
<article class="article">
  <div class="anchor" id="p30"></div>
  <h3>30 Динамическое программирование сверху и снизу</h3>

  <h4>Числа Фибоначчи с кешированием</h4>
  <p>При подсчете чисел Фибоначчи, приходится делать много повторяющейся работы. Это увеличивает время работы алгоритма. Чтобы это решить, закешируем результаты работы и будем их использовать, когда нужно повторно их подсчитывать. Это экономит время, но памяти для хранения результата нам требуется столько же, сколько и чисел Фибоначчи мы будем получать.</p>

<pre>
static int cache[100] = {0};

int fib(int n) {
  if (n &lt;= 1) {
    return n;
  }
  if (cache[n] == 0) {
    cache[n] = fib(n-1) + fib(n-2);
  }
  return cache[n];
}
</pre>

<p>Заметим, что уже число fib(47) не помещается в тип данных int.</p>

<h4>Числа Фибоначчи с динамическим программированием</h4>
<pre>
int fib_dynamic(int n) {
  int Fib[n + 1];
  Fib[0] = 0;
  Fib[1] = 1;
  for (int i = 2; i &lt;= n; i++) {
    Fib[i] = Fib[i-1] + Fib[i-2];
  }

  return Fib[n];
}
</pre>
</article>


<!-- 31 Динамическое программирование траектории кузнечика -->
<article class="article">
  <div class="anchor" id="p31"></div>
  <h3>31 Динамическое программирование траектории кузнечика</h3>

  <h4>Задача про города на карте</h4>

  <p>Даны города от A до Z с односторонними дорогами между ними. Найти количество траекторий из города A в город Z. Схема городов с односторонними дорогами представляет из собой ориентированный граф у которого нет циклов.</p>
  <p>Решение с помощью рекурсии. Для начала найдем число дорог которые ведут в город Z. Пусть в Z ведут две дороги X -> Z и Y -> Z. Тогда число траекторий из A в Z равно числу траекторий из A в X плюс число траекторий из A в Y.</p>
  <code>K<sub>AZ</sub> = K<sub>AX</sub> + K<sub>AY</sub></code>

  <p>Решение с помощью динамического программирования. Найдем для каждого города, сколько есть способов в него попасть. Начинаем с города A. Это первый город и есть только один способ в него попасть это уже находиться в нем.</p>

  <h4>Задача про кузнечика</h4>

  <p>На числовой прямой в точке 1 сидит кузнечик. Он может сделать один из двух ходов: прыгнуть на один шаг вперед, прыгнуть на два шага вперед. Сколько способов есть чтобы попасть в точку n?</p>
  <p>В точку n можно попасть только из двух точек : n-1 и n-2. Поэтому число траекторий в точку n равно числу траекторий в точку n-1 плюс число траекторий в точку n-2</p>
  <code>K<sub>N</sub> = K<sub>N-1</sub> + K<sub>n-2</sub></code>

  <p>Число траекторий в точку 1 равно 1, в точку 0 равно 0</p>
  <code>K[1] = 1, K[0] = 0</code>

<pre>
int numbers(int n) {
  int K[n+1];
  K[0] = 0;
  K[1] = 1;
  for (int i = 2; i &lt;= n; i++) {
    K[i] = K[i-1] + K[i-2];
  }
  return K[n];
}
</pre>
</article>


<!-- 32 Адреса и указатели в Си. Адресная арифметика -->
<article class="article">
  <div class="anchor" id="p32"></div>
  <h3>32 Адреса и указатели в Си. Адресная арифметика</h3>

  <p>Каждая переменная хранится в ячейках памяти. Каждая ячейка памяти имеет размер 8 бит. Каждая ячейка памяти имеет свой адрес, который выражается шестнадцатеричным числом. Если в переменную i мы запишем число 4 i = 4;, то в ячейку памяти по адресу переменной i запишется значение 4. Компилятор Си связывает имя переменной и адрес. В машинных кодах имен переменных не существует. Чтобы узнать адрес переменной, нужно выполнить операцию взятия адреса у переменной. Поскольку адрес это число, то его можно записать в переменную адресного типа - указатель.</p>
  <code>int* pi = &amp;i;</code>
  <p>Поскольку указатель это переменная, записанная в памяти и имеющая адрес, то мы можем взять адрес у указателя и записать его в переменную.</p>
  <code>int** ppi = &amp;pi;</code>
  <p>Операция разыменования применяется к указателю и возвращает значение, хранящееся по адресу, на который указывает указатель.</p>
<pre>
int i = 10;  // i = 10
int *pi = &amp;i;
int **ppi = &amp;pi;
int ***pppi = &amp;ppi;
*pi = 20; // i = 20
**ppi = 30; // i = 30
***pppi = 40; // i = 40
</pre>
</article>


<!-- 33 Тип void и интерпретация данных -->
<article class="article">
  <div class="anchor" id="p33"></div>
  <h3>33 Тип void и интерпретация данных</h3>

  <p>Невозможно создать переменную типа void. Например, void x; компилятор не пропустит. Но можно создать указатель на тип void. Например, void* p; теперь в переменную p мы можем положить адрес на любой тип данных.</p>

<pre>
char c;
int i;
double d;

void *p;
p = &amp;c;
printf("%c\n", *(char*)p);
p = &amp;i;
printf("%d\n", *(int*)p);
p = &amp;d;
printf("%lf\n", *(double*)p);
</pre>
</article>


<!-- 34 Передача адреса переменной в функцию в Си -->
<article class="article">
  <div class="anchor" id="p34"></div>
  <h3>34 Передача адреса переменной в функцию в Си</h3>

  <p>Переменная в функцию передается по значению. То есть при вызове функции значение переменной копируется во внутренний параметр функции. При этом, если типы несовпадают, то происходит неявное преобразование типа. Функция работает с копией переменной и не может никак изменить внешнюю переменную, переданную в функцию.</p>

  <p>Если внутри функции нужно изменить переменную, которую ей передали, то нужно использовать передачу по ссылке. Для этого в функцию передается не сама переменная, а указатель на нее. При этом функция принимает копию указателя, который указывает на переменную, которую можно менять внутри функции и она изменится за пределами функции тоже.</p>
</article>


<!-- 35 Выделение и освобождение динамической памяти в Си -->
<article class="article">
  <div class="anchor" id="p35"></div>
  <h3>35 Выделение и освобождение динамической памяти в Си</h3>

  <p>Программа использует системные вызовы для получения доступа к ресурсам: памяти, файлам, экрану, клавиатуре и т.д. Эти системные вызовы содержатся в API операционной системы.</p>
  <p>Пусть нам нужно создать массив из N байт. Его можно создать статически на стеке или динамически в оперативной памяти. Если массив очень большой, N > 1000000, то создать на стеке не получится, не хватит памяти в стеке.</p>
  <p>Выделим память на стеке для N символов</p>
<pre>
char A[N];
</pre>

  <p>Выделим память на стеке для N чисел</p>
<pre>
int A[N];
</pre>

  <p>Запросим N байт в оперативной памяти</p>
<pre>
char *A = (char*)malloc(N);
if (A == NULL) {
  puts("Memory not allocated!");
  exit(1);
}
free(A);
</pre>

  <p>Запросим память для N чисел в оперативной памяти</p>
<pre>
int *A = (int*)malloc(N * sizeof(int));
if (A == NULL) {
  puts("Memory not allocated!");
  exit(1);
}
free(A);
</pre>

  <p>Функция malloc() выделяет память вместе со всем мусором, который в этой памяти был. Функция calloc() выделяет память и сразу инициализирует ее нулями. Она принимает два параметра - количество элементов и размер одного элемента и сама перемножает их, чтобы узнать сколько памяти выделять.</p>
  <code>int *A = (int*)calloc(N, sizeof(int));</code>
</article>


<!-- 36 Двумерные массивы в Си обычные и динамические -->
<article class="article">
  <div class="anchor" id="p36"></div>
  <h3>36 Двумерные массивы в Си обычные и динамические</h3>

  <p>Одномерные массивы ведут себя одинаково, как статические так и динамические. Двумерные массивы расположены в памяти последовательно построчно.</p>

  <p>Создадим статический двумерный массив из 4 строк по 5 элементов в каждой строке. Число строк и элементов должны быть известны во время компиляции. Адрес любого элемента можно получить как</p>
  <code>int A[4][5];</code>
  <code>A[i][j] = *((int*)A + i * 5 + j);</code>

  <p>Создадим динамический двумерный массив из 4 указателей, которые указывают на одномерные массивы из 5 элементов.</p>
  <code>int **A;</code>
  <code>A = (int**)malloc(N * sizeof(int*));</code>
  <p>A представляет собой указатель на указатель на int. По указателям, хранящимся в A лежит не по одному значению, а по одномерному динамическому массиву таких значений. Адрес любого элемента можно получить как</p>
  <code>A[i][j] = *(*(A+i)+j);</code>

<pre>
int **A;
A = (int**)malloc(N * sizeof(int*));
for (int i = 0; i &lt; N; i++) {
  A[i] = (int*)malloc(M * sizeof(int));
}
for (int i = 0; i &lt; N; i++) {
  free(A[i]);
}
free(A);
</pre>

<pre>
int **A = (int**)malloc(N * sizeof(int*) + N * M * sizeof(int));
int *start = (int*)((char*)A + N * sizeof(int*));
for (int i = 0; i &lt; N; i++) {
  A[i] = start + i * M;
}
free(A);
</pre>
</article>


<!-- 37 Техника безопасности при работе с памятью в Си -->
<article class="article">
  <div class="anchor" id="p37"></div>
  <h3>37 Техника безопасности при работе с памятью в Си</h3>

  <p><strong>Segmentation fault</strong> это ошибка, когда во время выполнения программы происходит обращение к недоступному сегменту памяти.</p>
  <p><strong>Memory leak</strong> это ошибка, когда память выделяется, но не освобождается.</p>
  <p>При объявлении указателя его сразу нужно инициализировать</p>
  <code>int *p = NULL;</code>
  <p>Функция scanf() должна принимать адрес</p>
  <code>scanf("%d", &x);</code>
  <p>Есть два механизма против утечки памяти: smart pointers и garbage collector.</p>
</article>
