<article class="article">
  <h1>2018 Тимофей Хирьянов. Язык Си. Курс молодого бойца МФТИ.</h1>
  <p>Конспект видео курса</p>
  <p>37 уроков. Длительность 9ч 18м.</p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

      <a href="#p1">1 Разбор  Hello, World! на Си</a>
  <br><a href="#p2">2 Ошибки и предупреждения при компиляции на Си</a>
  <br><a href="#p3">3 Этапы компиляции на Си предобработка, трансляция, компоновка</a>
  <br><a href="#p4">4 Переполнение и ошибки при работе с целыми типами в Си</a>
  <br><a href="#p5">5 Циклы for и while в Си сходство и различие</a>
  <br><a href="#p6">6 Генерация арифметических и геометрических прогрессий на Си</a>
  <br><a href="#p7">7 Операции присваивания и сравнения чисел в Си</a>
  <br><a href="#p8">8 Деление нацело и взятие остатка</a>
  <br><a href="#p9">9 Оператор if и организация ветвления в Си</a>
  <br><a href="#p10">10 Метки, оператор goto и оператор switch в Си</a>
  <br><a href="#p11">11 Управление циклом в Си break, continue</a>
  <br><a href="#p12">12 Разложение числа на множители на Си</a>
  <br><a href="#p13">13 Фильтрация потока чисел на Си</a>
  <br><a href="#p14">14 Индуктивные функции на Си подсчёт, сумма, произведение</a>
  <br><a href="#p15">15 Индуктивные функции на Си any of, all of</a>
  <br><a href="#p16">16 Индуктивные функции на Си поиск максимума</a>
  <br><a href="#p17">17 Хранение массива в памяти в Си</a>
  <br><a href="#p18">18 Создание и заполение массива на Си</a>
  <br><a href="#p19">19 Решето Эратосфена на Си</a>
  <br><a href="#p20">20 Копирование массива, реверс циклический сдвиг на Си</a>
  <br><a href="#p21">21 Задачи №25 ЕГЭ по информатике на Си</a>
  <br><a href="#p22">22 Задача №27 ЕГЭ по информатике на Си</a>
  <br><a href="#p23">23 Добавление и удаление элемента в конец массива на Си</a>
  <br><a href="#p24">24 Сортировка массива вставками на Си</a>
  <br><a href="#p25">25 Асимптотика сортировок. Сортировка подсчётом на Си</a>
  <br><a href="#p26">26 Функции в языке Си</a>
  <br><a href="#p27">27 Рекурсия. Репка и матрёшка</a>
  <br><a href="#p28">28 Примеры рекурсивных алгоритмов</a>
  <br><a href="#p29">29 Ханойские башни на Си</a>
  <br><a href="#p30">30 Динамическое программирование сверху и снизу</a>
  <br><a href="#p31">31 Динамическое программирование траектории кузнечика</a>
  <br><a href="#p32">32 Адреса и указатели в Си. Адресная арифметика</a>
  <br><a href="#p33">33 Тип void  и интерпретация данных</a>
  <br><a href="#p34">34 Передача адреса переменной в функцию в Си</a>
  <br><a href="#p35">35 Выделение и освобождение динамической памяти в Си</a>
  <br><a href="#p36">36 Двумерные массивы в Си обычные и динамические</a>
  <br><a href="#p37">37 Техника безопасности при работе с памятью в Си</a>
</article>


<!-- 1 Разбор  Hello, World! на Си -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>1 Разбор  Hello, World! на Си</h3>

  <p>Я, Тимофей Хирьянов, проведу вас от школьной информатики до уровня информатики в МФТИ. Это мини курс, в нем 5 уроков. Каждый урок разбит на несколько видео. Я познакомлю вас с языком программирования Си и изложу школьные алгоритмы, которые вы бы знали если бы готовились к ЕГЭ по информатике хорошо. Разберем для начала программу hello world</p>
<pre>
#include &lt;stdio.h&gt;

int main(int argc, char* argv[]) {
  printf("Hello, World!\n");

  return 0;
}
</pre>

  <p>В первой строке идет инструкция препроцессора #include, которая подключает стандартную библиотеку ввода-вывода к нашей программе. Это строка не на языке Си. Инструкция в этой строке выполняется перед компиляцией на этаме обработки команд препроцессора. stdio.h это заголовочный файл, который описывает интерфейс библиотеки и он написан на языке Си. Сама библиотека разбивается на две части - это ее исходный код, он часто преобразован сразу в объектный файл с расширением .o, и заголовочный файл на языке Си с расширением .h.</p>
  <p>Вся программа на языке Си состоит из функций, которые вызывают друг друга. Всегда есть одна главная функция, которая вызывается первой. Это функция main(). Каждая программа должна содержать функцию main. При запуске программы эту функцию запускает командная оболочка (bash или cmd). И эта функция должна вернуть результат в командную оболочку после завершения своей работы. Поэтому главная функция оформляется точно также как все остальные функции в языке Си.</p>
  <p>Она имеет заголовок и тело. В заголовке сначала пишется возвращаемый тип, имя функции и список параметров. Параметры в главной функции необязательны, но лучше их знать.</p>
  <p>Язык программирования Си создавался в то время, когда никакого графического интерфейса еще не было и все программы запускались из командной строки. При запуске в программу передавались аргументы командной строки. argc это количество аргументов конмандной строки. argv это массив строк со значениями аргументов командной строки.</p>
  <p>Функция main всегда должна возвращать целое число. Во время выполнения программы может возникнуть ошибка, при которой дальнейшее выполнение невозможно. Программа должна вернуть код ошибки. Число 0 означает что программа выполнилась без ошибок. Коды ошибок для каждой программы пишутся в документации к этой программе. Из командной строки можно узнать какой код вернула программа, после своего выполнения.</p>
  <p>Единственная содержательная строчка нашей программы это та где вызывается функция printf(). Это print format - форматированная печать. Функция принимает первый аргумент в виде строки формата, в который вместе с текстом можно передавать значения переменных и способ их отображения.</p>
  <p>Добавим внутрь форматной строки спецификатор формата %s для вставки другой строки</p>
  <code>printf("Hello, %s!\n", "John");</code>
</article>


<!-- 2 Ошибки и предупреждения при компиляции на Си -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>2 Ошибки и предупреждения при компиляции на Си</h3>

  <p>Си это язык программирования высокого уровня. Процессор компьютера не знает языка Си. Чтобы процессор мог выполнить программу нужны <strong>компилятор</strong> и <strong>операционная система</strong>. Компилятор преобразует исходный текст на языке Си в исполняемый файл. При запуске исполняемого файла операционная система загружает его в оперативную память и контроллирует весь процесс.</p>
  <p>Компилятор, встретив ошибку, прекращает компиляцию и возвращает эту ошибку на экран разработчику.</p>
  <p>Напишем программу</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  printf("I'm a Bot. What's your name?\n");
  char name;
  scanf("%s", name);
  printf("Hello, %s! How old are you?\n");
  int age;
  scanf("%s", age);
  printf("Yuo are looking younger! "
         "I thought you are %d!\n", age - 3);

  return 0;
}
</pre>
  <p>Программа содержит ошибки. Но она скомпилируется без ошибок. Запустим программу. При вводе имени операционная система завершит программу с ошибкой. По умолчанию компилятор выдает только ошибки. Можно его настроить так, чтобы он выдавал еще и предупреждения.</p>
  <p>Если мы работаем в программе Code::Blocks, то нужно зайти в настройки компилятора</p>
  <code>Settings - Compiler</code>
  <p>В открывшемся окне Compiler settings выберем раздел Global compiler settings. На вкладке Compiler settings выберем вкладку Compiler Flags и найдем раздел Warnings. Поставим галочку рядом с флагом [-Wall]</p>
  <code>Enable all common compiler warnings (override many other settings) [Wall]</code>
  <p>Если теперь запустить компиляцию, то мы получим предупреждения об ошибках и программа не будет скомпилирована. Исправим ошибки в программе.</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  printf("I'm a Bot. What's your name?\n");
  char name[20];
  scanf("%s", name);
  printf("Hello, %s! How old are you?\n", name);
  int age;
  scanf("%d", &age);
  printf("Yuo are looking younger! "
         "I thought you are %d!\n", age - 3);

  return 0;
}
</pre>
</article>


<!-- 3 Этапы компиляции на Си предобработка, трансляция, компоновка -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>3 Этапы компиляции на Си предобработка, трансляция, компоновка</h3>
  <ol>
    <li>Этап preprocessing выполняется препроцессором. Удаляются комментарии, выполняются текстовые замены, условные включения кода, включение файлов, включение кода библиотек. В результате файл не создается.</li>
    <li>Этап compilation (компиляция, трансляция). Трансляция - перевод в машинные коды. Создается объектный файл с расширением .o, который состоит из машинных кодов.</li>
    <li>Этап linking (линковка, компоновка, сборка). Несколько объектных файлов собираются в один исполняемый файл. Создается исполняемый файл с расширением .exe.</li>
  </ol>
  <p>В программе Code::Blicks внизу на вкладке Build log можно посмотреть что происходит при сборке.</p>
  <p>Выполним пошагово все этапы компиляции на программе hello.c.</p> <p>Первый этап - препроцессинг. В качестве исходного файла для этапа препроцессинга передадим исходный текст программы, написанный нами на языке Си.</p>
  <code>gcc -E hello.c</code>
  <p>В результате создастся код, после обработки препроцессором, и выведется на экран, но никакой файл не создастся. Мы можем перенаправить вывод с экрана в файл</p>
  <code>gcc -E hello.c > hello_prep.c</code>
  <p>Препроцессор удаляет все коментарии, сделанные программистом, но вставляет свои коментарии для компилятора на строках, начинающихся с решетки #.</p>
  <p>Второй этап - трансляция. В качестве исходного файла для этапа трансляции передадим файл, полученный на предыдущем этапе препроцессинга.</p>
  <code>gcc -c hello_prep.c</code>
  <p>В результате трансляции создастся объектный файл с расширением .o с машинным кодом.</p>
  <p>Третий этап - сборка. Нужно собрать вместе полученный объектный код нашей программы и объектные коды включенных в программу библиотек. Компилятор сам знает где в операционной системе находятся файлы библиотек. Нам достаточно передать ему только наш объектный файл</p>
  <code>gcc hello_prep.o</code>
  <p>В результате линковки создастся исполняемый файл с именем a.exe. Если мы хотим получить другое имя, нужно его задать.</p>
  <code>gcc hello_prep.o -o hello.exe</code>
</article>


<!-- 4 Переполнение и ошибки при работе с целыми типами в Си -->
<article class="article">
  <div class="anchor" id="p4"></div>
  <h3>4 Переполнение и ошибки при работе с целыми типами в Си</h3>

  <p>Пусть у нас есть три бита для хранения переменной целого типа. Диапазон возможных значений переменной будет от 0 (000) до 7 (111). Кодовая таблица трех-битового числа без знака:</p>
<pre>
000 = 0
001 = 1
010 = 2
011 = 3
100 = 4
101 = 5
110 = 6
111 = 7
</pre>
  <p>Это также называется кольцо вычетов по модулю 8. Если прибавить единицу к семерке, то в переменной получим число 0. Это назвается overflow (переполнение). Если вычесть единицу из нуля, то получим 7. Это называется underflow.</p>
  <p>Теперь мы хотим хранить еще и отрицательные числа. Сохраним идею кольца вычетов. Называется это дополнительный двоичный код. Кодовая таблица 3-битового числа со знаком.</p>
<pre>
000 = 0
001 = 1
010 = 2
011 = 3
100 = -4
101 = -3
110 = -2
111 = -1
</pre>
  <p>Диапазон допустимых значений от -4 до 3.</p>
</article>


<!-- 5 Циклы for и while в Си сходство и различие -->
<article class="article">
  <div class="anchor" id="p5"></div>
  <h3>5 Циклы for и while в Си сходство и различие</h3>

  <p>Цикл for является полным аналогом цикла while. Оба цикла могут быть бесконечными.</p>
<pre>
int i = 0;
while (i &lt; 10) {
  printf("%d", i);
  ++i;
}
</pre>
<pre>
for (int i = 0; i &lt; 10; ++i) {
  printf("%d", i);
}
</pre>
</article>


<!-- 6 Генерация арифметических и геометрических прогрессий на Си -->
<article class="article">
  <div class="anchor" id="p6"></div>
  <h3>6 Генерация арифметических и геометрических прогрессий на Си</h3>

  <p>Генерация арифметической прогрессии с помощью цикла while</p>
<pre>
int start = 1, step = 1, stop = 10;
int x = start;
while (x &lt; stop) {
  printf("x = %d\n", x);
  x += step;  // арифметическая прогрессия
}
</pre>

  <p>Генерация геомеметической прогрессии с помощью цикла while</p>
<pre>
int start = 1, step = 2, stop = 1050;
int x = start;
while (x &lt; stop) {
  printf("x = %d\n", x);
  x *= step;  // геометрическая прогрессия
}
</pre>

  <p>Генерация убывающей арифметической прогрессии с помощью цикла while</p>
<pre>
int start = 10, step = -1, stop = 1;
int x = start;
while (x > stop) {
  printf("x = %d\n", x);
  x += step;  // арифметическая прогрессия
}
</pre>

  <p>Генерация возрастающей и убывающей арифметической прогрессии в зависимости от знака шага step</p>
<pre>
int start = 10, step = -1, stop = 1;
int sign = (step > 0) ? 1 : -1;
int x = start;
while (sign * x &lt; sign * stop) {
  printf("x = %d\n", x);
  x += step;  // арифметическая прогрессия
}
</pre>
</article>


<!-- 7 Операции присваивания и сравнения чисел в Си -->
<article class="article">
  <div class="anchor" id="p7"></div>
  <h3>7 Операции присваивания и сравнения чисел в Си</h3>

  <p>Операция со знаком присваивания = сначала вычисляет выражение справа, затем вычисляет выражение слева и присваивает ему вычисленное выражение справа. Слева от знака присваивания может стоять только l-value выражение. l-value это реальная оперативная память, куда можно записать значение.</p>
  <code>int x, y, z;</code>
  <code>x = y = z = 5;</code>
  <p>Нельзя в одном выражении несколько раз делать присваивание в одну переменную. Потому что компилятор может закешировать разельтат и произвести запись в переменную только один раз. При этом записано может быть не то что вам нужно</p>
  <code>x = (x = 2) + (x = 5); // так нельзя</code>
  <code>x = (x++) + (++x); // так нельзя</code>
  <p>Операции со знаками сравнения тоже возвращают результат. И этот результат - целое число</p>
  <code>int x = (5 > 2); // x = 1</code>
  <code>int x = (5 > 2) + (4 >= -1) + (10 == 9 + 1); // x = 3</code>
  <code>int y = (2 >= 5); // y = 0</code>
  <p>Избегайте сравнения знаковых и беззнаковых целых типов. Здесь -1 будет приведена к беззнаковому типу и равна 2<sup>31</sup> - 1.</p>
  <code>int z = (5u > -1); // z = 0</code>
</article>


<!-- 8 Деление нацело и взятие остатка -->
<article class="article">
  <div class="anchor" id="p8"></div>
  <h3>8 Деление нацело и взятие остатка</h3>

  <p>Деление целых чисел происходит нацело, с отбрасыванием остатка.</p>
  <code>int x = 12345 / 1000; // x = 12</code>
  <p>Остаток от деления вычисляется правильно только при положительных числах.</p>
  <code>int y = 12345 % 1000; // y = 345</code>
  <p>У отрицательных чисел остаток от деления отрицательный, что противоречит математике. В своих программах это надо учитывать и исправлять.</p>
  <code>int z = -19 % 10; // z = -9</code>
  <p>Для получения вещественного числа недостаточно разделить два целых числа. Сначала вычислится выражение справа, а это деление двух целых чисел. Потом полученное целое число при записи в вещественную переменную будет приведено к вещественному типу.</p>
  <code>double x = 1 / 2; // x = 0</code>
  <p>Мы сами должны сделать операнды для операции деления дробными</p>
  <code>double x = 1. / 2. ; // x = 0.5</code>
  <code>double x = (double)y / (double)z;</code>
</article>


<!-- 9 Оператор if и организация ветвления в Си -->
<article class="article">
  <div class="anchor" id="p9"></div>
  <h3>9 Оператор if и организация ветвления в Си</h3>

  <p>Определим положение точки с координатами x, y на координатной плоскости</p>
<pre>
if (y > 0) {
  if (x > 0) {
    printf("1-st quarter\n");
  } else {
    printf("2-nd quarter\n");
  }
} else {
  if (x > 0) {
    printf("4-th quarter\n");
  } else {
    printf("3-rd quarter\n");
  }
}
if (x == 0 || y == 0) {
  printf("Point is on axis\n");
}
</pre>
<pre>
if (y > 0 && x > 0) {
  printf("1-st quarter\n");
} else if (y > 0 && x &lt; 0) {
  printf("2-nd quarter\n");
} else if (y &lt; 0 && x &lt; 0) {
  printf("3-rd quarter\n");
} else if (y &lt; 0 && x > 0){
  printf("4-th quarter\n");
} else {
  printf("Point is on axis\n");
}
</pre>
</article>


<!-- 10 Метки, оператор goto и оператор switch в Си -->
<article class="article">
  <div class="anchor" id="p10"></div>
  <h3>10 Метки, оператор goto и оператор switch в Си</h3>
</article>


<!-- 11 Управление циклом в Си break, continue -->
<article class="article">
  <div class="anchor" id="p11"></div>
  <h3>11 Управление циклом в Си break, continue</h3>
</article>


<!-- 12 Разложение числа на множители на Си -->
<article class="article">
  <div class="anchor" id="p12"></div>
  <h3>12 Разложение числа на множители на Си</h3>
</article>


<!-- 13 Фильтрация потока чисел на Си -->
<article class="article">
  <div class="anchor" id="p13"></div>
  <h3>13 Фильтрация потока чисел на Си</h3>
</article>


<!-- 14 Индуктивные функции на Си подсчёт, сумма, произведение -->
<article class="article">
  <div class="anchor" id="p14"></div>
  <h3>14 Индуктивные функции на Си подсчёт, сумма, произведение</h3>
</article>


<!-- 15 Индуктивные функции на Си any of, all of -->
<article class="article">
  <div class="anchor" id="p15"></div>
  <h3>15 Индуктивные функции на Си any of, all of</h3>
</article>


<!-- 16 Индуктивные функции на Си поиск максимума -->
<article class="article">
  <div class="anchor" id="p16"></div>
  <h3>16 Индуктивные функции на Си поиск максимума</h3>
</article>


<!-- 17 Хранение массива в памяти в Си -->
<article class="article">
  <div class="anchor" id="p17"></div>
  <h3>17 Хранение массива в памяти в Си</h3>
</article>


<!-- 18 Создание и заполение массива на Си -->
<article class="article">
  <div class="anchor" id="p18"></div>
  <h3>18 Создание и заполение массива на Си</h3>
</article>


<!-- 19 Решето Эратосфена на Си -->
<article class="article">
  <div class="anchor" id="p19"></div>
  <h3>19 Решето Эратосфена на Си</h3>
</article>


<!-- 20 Копирование массива, реверс циклический сдвиг на Си -->
<article class="article">
  <div class="anchor" id="p20"></div>
  <h3>20 Копирование массива, реверс циклический сдвиг на Си</h3>
</article>


<!-- 21 Задачи №25 ЕГЭ по информатике на Си -->
<article class="article">
  <div class="anchor" id="p21"></div>
  <h3>21 Задачи №25 ЕГЭ по информатике на Си</h3>
</article>


<!-- 22 Задача №27 ЕГЭ по информатике на Си -->
<article class="article">
  <div class="anchor" id="p22"></div>
  <h3>22 Задача №27 ЕГЭ по информатике на Си</h3>
</article>


<!-- 23 Добавление и удаление элемента в конец массива на Си -->
<article class="article">
  <div class="anchor" id="p23"></div>
  <h3>23 Добавление и удаление элемента в конец массива на Си</h3>
</article>


<!-- 24 Сортировка массива вставками на Си -->
<article class="article">
  <div class="anchor" id="p24"></div>
  <h3>24 Сортировка массива вставками на Си</h3>
</article>


<!-- 25 Асимптотика сортировок. Сортировка подсчётом на Си -->
<article class="article">
  <div class="anchor" id="p25"></div>
  <h3>25 Асимптотика сортировок. Сортировка подсчётом на Си</h3>
</article>


<!-- 26 Функции в языке Си -->
<article class="article">
  <div class="anchor" id="p26"></div>
  <h3>26 Функции в языке Си</h3>
</article>


<!-- 27 Рекурсия. Репка и матрёшка -->
<article class="article">
  <div class="anchor" id="p27"></div>
  <h3>27 Рекурсия. Репка и матрёшка</h3>
</article>


<!-- 28 Примеры рекурсивных алгоритмов -->
<article class="article">
  <div class="anchor" id="p28"></div>
  <h3>28 Примеры рекурсивных алгоритмов</h3>
</article>


<!-- 29 Ханойские башни на Си -->
<article class="article">
  <div class="anchor" id="p29"></div>
  <h3>29 Ханойские башни на Си</h3>
</article>


<!-- 30 Динамическое программирование сверху и снизу -->
<article class="article">
  <div class="anchor" id="p30"></div>
  <h3>30 Динамическое программирование сверху и снизу</h3>
</article>


<!-- 31 Динамическое программирование траектории кузнечика -->
<article class="article">
  <div class="anchor" id="p31"></div>
  <h3>31 Динамическое программирование траектории кузнечика</h3>
</article>


<!-- 32 Адреса и указатели в Си. Адресная арифметика -->
<article class="article">
  <div class="anchor" id="p32"></div>
  <h3>32 Адреса и указатели в Си. Адресная арифметика</h3>
</article>


<!-- 33 Тип void  и интерпретация данных -->
<article class="article">
  <div class="anchor" id="p33"></div>
  <h3>33 Тип void  и интерпретация данных</h3>
</article>


<!-- 34 Передача адреса переменной в функцию в Си -->
<article class="article">
  <div class="anchor" id="p34"></div>
  <h3>34 Передача адреса переменной в функцию в Си</h3>
</article>


<!-- 35 Выделение и освобождение динамической памяти в Си -->
<article class="article">
  <div class="anchor" id="p35"></div>
  <h3>35 Выделение и освобождение динамической памяти в Си</h3>
</article>


<!-- 36 Двумерные массивы в Си обычные и динамические -->
<article class="article">
  <div class="anchor" id="p36"></div>
  <h3>36 Двумерные массивы в Си обычные и динамические</h3>
</article>


<!-- 37 Техника безопасности при работе с памятью в Си -->
<article class="article">
  <div class="anchor" id="p37"></div>
  <h3>37 Техника безопасности при работе с памятью в Си</h3>
</article>
