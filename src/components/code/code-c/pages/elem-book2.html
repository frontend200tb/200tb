<article class="article">
  <h1>2001 Крупник - Изучаем Си. 233c</h1>
  <p>Конспект книги</p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
    <a href="#p1">1 Введение в программирование (1)</a>
    <br><a href="#p1.1">1.1 Программы (1)</a>
    <br><a href="#p1.2">1.2 Ячейки и типы (4)</a>
    <br><a href="#p1.3">1.3 Программирование и трансляторы (6)</a>
    <br><a href="#p1.4">1.4 Первая программа на Си (9)</a>
  </p>

  <p>
    <a href="#p2">2 Первые шаги (12)</a>
    <br><a href="#p2.1">2.1 Турбо Си - среда программирования (12)</a>
    <br><a href="#p2.2">2.2 Связь с внешним миром (16)</a>
    <br><a href="#p2.3">2.3 Простые вычисления (20)</a>
    <br><a href="#p2.4">2.4 В чем преимущество программ (22)</a>
    <br><a href="#p2.5">2.5 Массивы (26)</a>
    <br><a href="#p2.6">2.6 Как это делается (34)</a>
  </p>

  <p>
    <a href="#p3">3 Странные типы (42)</a>
    <br><a href="#p3.1">3.1 Странные типы-1 (42)</a>
    <br><a href="#p3.2">3.2 Странные типы-2 (45)</a>
    <br><a href="#p3.3">3.3 Анатомия типов (47)</a>
    <br><a href="#p3.4">3.4 Подбирайте выражения (53)</a>
    <br><a href="#p3.5">3.5 Строки и символы (57)</a>
    <br><a href="#p3.6">3.6 Указатели (62)</a>
  </p>

  <p>
    <a href="#p4">4 Действия (65)</a>
    <br><a href="#p4.1">4.1 Очередность (65)</a>
    <br><a href="#p4.2">4.2 Условность (68)</a>
    <br><a href="#p4.3">4.3 Работа с указателями (72)</a>
    <br><a href="#p4.4">4.4 Битовые операции (74)</a>
    <br><a href="#p4.5">4.5 Функции (80)</a>
    <br><a href="#p4.6">4.6 Функции с длинными руками (84)</a>
    <br><a href="#p4.7">4.7 Рекурсия или раз, два, три (87)</a>
  </p>

  <p>
    <a href="#p5">5 Функции, указатели, массивы (96)</a>
    <br><a href="#p5.1">5.1 Функции и массивы (96)</a>
    <br><a href="#p5.2">5.2 Массивы и указатели (98)</a>
    <br><a href="#p5.3">5.3 Указатели и массивы (100)</a>
    <br><a href="#p5.4">5.4 Динамические массивы (102)</a>
    <br><a href="#p5.5">5.5 Копирование строк (105)</a>
  </p>

  <p>
    <a href="#p6">6 Файлы (109)</a>
    <br><a href="#p6.1">6.1 Падение железного занавеса (109)</a>
    <br><a href="#p6.2">6.2 Массивы указателей (114)</a>
    <br><a href="#p6.3">6.3 Указатели на указатели (120)</a>
    <br><a href="#p6.4">6.4 Файлы - не массивы (123)</a>
    <br><a href="#p6.5">6.5 Открытие файла (126)</a>
  </p>

  <p>
    <a href="#p7">7 Строки (131)</a>
    <br><a href="#p7.1">7.1 Считалочка (131)</a>
    <br><a href="#p7.2">7.2 Сортировка строк (136)</a>
    <br><a href="#p7.3">7.3 Указатель на функцию (138)</a>
    <br><a href="#p7.4">7.4 Имена функций и указатели (144)</a>
    <br><a href="#p7.5">7.5 Функция Qsort (146)</a>
    <br><a href="#p7.6">7.6 Иголка, сено и лыко в строку (151)</a>
  </p>

  <p>
    <a href="#p8">8 Основные типы на сборочном конвейере (157)</a>
    <br><a href="#p8.1">8.1 Перечисления (157)</a>
    <br><a href="#p8.2">8.2 Двухмерные массивы и указатели на... (163)</a>
    <br><a href="#p8.3">8.3 Хранение и переработка двухмерных массивов (170)</a>
    <br><a href="#p8.4">8.4 Записи (174)</a>
    <br><a href="#p8.5">8.5 Записи и функции (178)</a>
    <br><a href="#p8.6">8.6 Указатель на запись (182)</a>
    <br><a href="#p8.7">8.7 Связанные записи (186)</a>
    <br><a href="#p8.8">8.8 Typedef (191)</a>
  </p>

  <p>
    <a href="#p9">9 Большие программы (195)</a>
    <br><a href="#p9.1">9.1 Разделяй и вляствуй (195)</a>
    <br><a href="#p9.2">9.2 Extern или Три поросенка (199)</a>
    <br><a href="#p9.3">9.3 Static (202)</a>
  </p>

  <p>
    <a href="#p10">10 Макросы и переходы (210)</a>
    <br><a href="#p10.1">10.1 Макросы (210)</a>
    <br><a href="#p10.2">10.2 Управление текстом (215)</a>
    <br><a href="#p10.3">10.3 Напутствие или GOTO (218)</a>
  </p>
</article>


<!-- 1. Введение в программирование -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h2>1. Введение в программирование (1)</h2>
</article>


<!-- 1.1 Программы -->
<article class="article">
  <div class="anchor" id="p1.1"></div>
  <h3>1.1 Программы (1)</h3>

  <p>Ячейки памяти в компьютере пронумерованы и располагаются последовательно друг за другом. В ячейках могут храниться команды, данные и указатели на другие ячейки. Процессор выполняет команды в последовательно расположенных ячейках. Первая команда программы всегда расположена в одной и той же ячейке. Процессор выполняет каждую команду программы пока не дойдет до команды стоп, расположенной в последней ячейке с программой.</p>
  <p>Команды, данные и указатели хранятся в одной и той же памяти. Программист должен знать где находятся команды, а где данные. Нельзя записать данные в ячейки, в которых находятся команды потому что это испортит программу.</p>
</article>


<!-- 1.2 Ячейки и типы -->
<article class="article">
  <div class="anchor" id="p1.2"></div>
  <h3>1.2 Ячейки и типы (4)</h3>

  <p>Ячейки памяти не безразмерны. Ячейка памяти это набор из нескольких переключателей, каждый из которых находится в одном из двух состояний: верхнем (его обозначают единицей) и нижнем (его обозначают нулем). В 8-разрядных процессорах таких переключателей 8. Каждый переключатель называют битом и говорят, что в ячейке 8 бит или 1 байт.</p>
  <p>В ячейке с одним переключателем с двумя состояниями 0 и 1 можно хранить два числа. В ячейке с двумя переключателями можно хранить четыре числа. Минимальное число, которое можно хранить в ячейке из 8 бит состоит из всех нулей и равно 0. Максимальное число состоит из всех единиц и равно 255.</p>
  <p>Чтобы определить какое число записано в двоичном виде, нужно воспользоваться позиционным представлением чисел.</p>
  <p>Крайний правый бит, самый младший, это 1 (2⁰)</p>
  <p>Второй справа бит это 2 (2¹)</p>
  <p>Третий справа бит это 4 (2²)</p>
  <p>Четвертый справа бит это 8 (2³)</p>
  <p>Пятый справа бит это 16 (2⁴)</p>
  <p>Шестой справа бит это 32 (2⁵)</p>
  <p>Седьмой справа бит это 64 (2⁶)</p>
  <p>Восьмой справа бит, самый старший, это 128 (2⁷)</p>
  <p>Число 00000000 равно</p>
  <code>0∙2⁷+0∙2⁶+0∙2⁵+0∙2⁴+0∙2³+0∙2²+0∙2¹+0∙2⁰ = 0</code>
  <p>Число 11111111 равно</p>
  <code>1∙2⁷+1∙2⁶+1∙2⁵+1∙2⁴+1∙2³+1∙2²+1∙2¹+1∙2⁰ = 127</code>
  <p>Внутренности ячейки памяти выглядят всегда как последовательность нулей и единиц независимо от того что в них находится: числа, буквы, адреса других ячеек, команды. Процессор должен знать какого типа данные хранятся в ячейке, чтобы правильно с ними работать.</p>
  <p>В ячейках памяти есть только двоичные цифры.</p>
</article>


<!-- 1.3 Программирование и трансляторы -->
<article class="article">
  <div class="anchor" id="p1.3"></div>
  <h3>1.3 Программирование и трансляторы (6)</h3>

  <p>Процессор сначала читает команду, потом обращается к ячейкам с данными, потом снова переходит к командам. И все это без перерыва пока не закончится программа. Программисту приходится выделять ячейки, где будут храниться данные и программа. Нужно помнить в какой ячейке что записано. Если данных становится много, нужно заботиться о том чтобы данные не налезли на программу. Придется не только перемещать программу в другую область памяти, но и менять в ней команды, которые работают с адресами, потому что адреса тоже поменяются. Работа непосредственно с ячейками памяти и командами процессора требует от программиста огромного труда и чудовищного внимания. Изменение программы в одном месте неизбежно потребует изменений во многих других местах, поэтому очень трудно избежать ошибок</p>
  <p>Первые программисты не только распределяли память вручную, но и писали каждую команду в двоичном коде - нулями и единицами. Программа в машинном коде могла работать на компьютере только одного типа, который понимал этот машинный код. На компьютере с другим типом команд выполнить такую программу невозможно.</p>
  <p>Поэтому очень скоро сами программисты стали писать программы иначе. Вместо номеров ячеек они вводили обычные имена, сами команды процессора записывали обычными буквами. Программы из нулей и единиц превратились в тексты, которые можно создавать в текстовом редакторе. Такую программу легче понять и исправить, но ее уже не понимал процессор. Поэтому текст программы пропускали через служебную програму ассемблер, который переводил программу в последовательность из нулей и единиц понятных процессору. Ассемблерная программа могла работать на компьютере только одного типа.</p>
  <p>Поэтому били изобретены языки высокого уровня (BASIC, PASCAL, ...). Программа написанная на языке высокого уровня не может быть непосредственно выполнена ни на одном компьютере, который понимает только команды своего процессора. Программа на языке высокого уровня сначала проходит через компилятор, который переводит ее в ассемблерный код, а затем уже ассемблер переводит ее в машинный код.</p>
  <p>Для каждой разновидности процессора, со своим набором команд, пишут свой ассемблер и свой компилятор, а затем пишут для него программы на языке высокого уровня. Это ускоряет процесс программирования, такие программы более надежны и понятны, их легко выполнить на других компьютерах с другими командами процессора, для которых также написаны ассемблер и компилятор.</p>
  <p>Язык Си был написан в начале 70-х годов опытными программистами Денисом Ритчи и Кеном Томпсоном и стал очень популярным. Язык Си - язык профессиональных программистов.</p>
</article>


<!-- 1.4 Первая программа на Си -->
<article class="article">
  <div class="anchor" id="p1.4"></div>
  <h3>1.4 Первая программа на Си (9)</h3>

  <p>Напишем программу, которая скалдывает два числа</p>

  <details>
    <summary>Программа 1 (10)</summary>
<pre>
int main() {
  int first, second, sum;
  first = 2;
  second = 3;
  sum = first + second;
}
</pre>
  </details>
</article>


<!-- 2 Первые шаги -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>2 Первые шаги (12)</h3>
</article>


<!-- 2.1 Турбо Си - среда программирования -->
<article class="article">
  <div class="anchor" id="p2.1"></div>
  <h3>2.1 Турбо Си - среда программирования (12)</h3>

  <p>Мы выберем компилятор Turbo C 2.01 фирмы Borland для компьютера IBM PC. Компилятор Turbo C 2.01 распространяется бесплатно.</p>

  <h4>Установка компилятора Turbo C 2.01</h4>
  <ol>
    <li>
      Скачать файл
      <code><a href="http://community.borland.com/article/images/20841/tc201.zip">http://community.borland.com/article/images/20841/tc201.zip</a></code>
    </li>
    <li>Распаковать архив tc201.zip в папку <strong>tc</strong>. Появятся три новых папки DISC1, DISC2, DISC3. Переписать содержимое из трех папок DISC1, DISC2, DISC3 в одну папку tc</li>
    <li>Запустить программу install.exe</li>
  </ol>

  <p>Запустим установленную программу</p>
  <code>c:\tc\tc</code>
<p>Появится черное окно редактора, в котором можно писать программу на языке Си. Напишем в редакторе нашу Программу 1.</p>
<p>Программу можно выполнять по шагам и при этом следить за состоянием переменных. Чтобы следить за переменной first, подведем к ней курсор, нажмем CTRL+F7 (или ALT+B чтобы попасть в меню BREAK/WATCH и выбрать там пункт Add watch Ctrl-F7). На экране появится окно Add Watch с именем переменной. При нажатии Enter переменная окажется в нижней части окна под заголовком Watch.</p>
<p>Теперь программу можно выполнить по шагам. Каждому нажатию клавиши F8 соответствует один шаг.</p>
</article>


<!-- 2.2 Связь с внешним миром -->
<article class="article">
  <div class="anchor" id="p2.2"></div>
  <h3>2.2 Связь с внешним миром (16)</h3>

  <p>Дополним программу 1 функцией printf() и строкой #include &lt;stdio.h&gt;</p>

  <details>
    <summary>Программа 2 (17)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int first, second, sum;
  first = 2;
  second = 3;
  sum = first + second;
  printf("sum = %d\n", sum);
  printf("first = %d second = %d sum = %d\n", first, second, sum);
}
</pre>
  </details>
</article>


<!-- 2.3 Простые вычисления -->
<article class="article">
  <div class="anchor" id="p2.3"></div>
  <h3>2.3 Простые вычисления (20)</h3>

  <p>Напишем программу, выполняющую арифметические действия</p>

  <details>
    <summary>Программа 3 (20)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int fst = 2, scnd = 3;
  int df, prd, qt, rm;
  df = fst - scnd;
  prd = fst * scnd;
  qt = fst / scnd;
  fst = 123;
  scnd = 17;
  rm = fst % scnd;
  printf("%d %d %d %d\n", df, prd, qt, rm);
}
</pre>
  </details>
</article>


<!-- 2.4 В чем преимущество программ -->
<article class="article">
  <div class="anchor" id="p2.4"></div>
  <h3>2.4 В чем преимущество программ (22)</h3>

  <p>Напишем программу считающую сумму всех чисел от 1 до 100</p>

  <details>
    <summary>Программа 4 (25)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int sum, i;
  sum = 0;
  i = 1;
  while (i &lt;= 100) {
    sum += i;
    i++;
  }
  printf("sum = %d\n", sum);
}
</pre>
  </details>
</article>


<!-- 2.5 Массивы -->
<article class="article">
  <div class="anchor" id="p2.5"></div>
  <h3>2.5 Массивы (26)</h3>

  <p>Массив это ряд переменных, у каждой из которых есть специальным номер или индекс. Номера переменных в массиве идут по порядку и начинаются с нуля. Массивы позволяют перейти к следующему числу за счет увеличения индекса на 1. Произвольные 10 чисел в массиве так же легко сложить, как идущие подряд числа от 1 до 10.</p>

  <details>
    <summary>Программма 5 (27)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int nums[10] = {5,3,2,4,6,7,11,17,0,13};
  int sum, i;
  sum = 0;
  i = 0;
  while (i &lt; 10) {
    sum += nums[i];
    i++;
  }
  printf("sum = %d\n", sum);
}
</pre>
  </details>

  <p>Числа в массиве можно не только складывать. Напишем программу, которая находит максимальное число в массиве.</p>

  <details>
    <summary>Программа 6 (28)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int nums[10] = {5,3,2,4,6,7,11,17,0,13};
  int max, i;
  max = nums[0];
  i = 1;
  while (i &lt; 10) {
    if (nums[i] > max) {
      max = nums[i];
    }
    i++;
  }
  printf("max = %d\n", max);
}
</pre>
  </details>

  <p>Если заранее известно число итераций цикла, удобнее использовать цикл for. Найдем минимальное число в массиве</p>

  <details>
    <summary>Программа 7 (29)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int nums[10] = {5,3,2,4,6,7,11,17,0,13};
  int min;
  min = nums[0];
  for (int i = 1; i &lt; 10; i++) {
    if (nums[i] &lt; min) {
      min = nums[i];
    }
  }
  printf("min = %d\n", min);
}
</pre>
  </details>

  <p>Расставим элементы в массиве в порядке возрастания. Эта задача называется сортировкой. Сначала найдем максимальный элемент и поставим его в конец массива. Потом найдем максимальный из оставшихлся элементов и т.д.</p>

  <details>
    <summary>Программа 8 (31)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int n = 10;
  int nums[] = {5,3,2,4,6,7,11,17,0,13};
  int i, j;
  for (i = n - 1; i > 0; i--) {
    int max = 0;
    for (j = 1; j &lt;= i; j++) {
      if (nums[j] > nums[max]) {
        max = j;
      }
    }
    int temp = nums[i];
    nums[i] = nums[max];
    nums[max] = temp;
  }

  for (i = 0; i &lt; n; i++) {
    printf("%d ", nums[i]);
  }
}
</pre>
  </details>

  <p>Поменяем местами две переменные a и b, не используя временную переменную temp</p>

  <details>
    <summary>Программа 9 (33)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int a = 8, b = 11;
  a = a + b;
  b = a - b;
  a = a - b;

  printf("a = %d\nb = %d\n", a, b);
}
</pre>
  </details>
</article>


<!-- 2.6 Как это делается -->
<article class="article">
  <div class="anchor" id="p2.6"></div>
  <h3>2.6 Как это делается (34)</h3>

  <p>Как написать программу сортировки массива. Сначала приходит идея найти максимальный элемент, затем найти следующий максимальный элемент и так далее пока все элементы на встанут на свои места. Но куда девать найденные максимумы? Как не использовать дополнительный массив, а сортировать на месте? Для этого будем помещать найденный максимум в конец массива, а элемент из конца массива помещать туда где нашли максимум.</p>
  <p>Такая программа должна состоять из двух вложенных циклов. В первом цикле идем от конца массива и каждый раз в текущий элемент будем записывать найденный максимум. Во внутреннем цикле идем от начала и до элемента в который будем класть максимум. Во внутреннем цикле ищется максимальный элемент.</p>
</article>


<!-- 3 Странные типы -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>3 Странные типы (42)</h3>
</article>


<!-- 3.1 Странные типы-1 -->
<article class="article">
  <div class="anchor" id="p3.1"></div>
  <h3>3.1 Странные типы-1 (42)</h3>
</article>


<br><a href="#p3.2">3.2 Странные типы-2 (45)</a>
<br><a href="#p3.3">3.3 Анатомия типов (47)</a>
<br><a href="#p3.4">3.4 Подбирайте выражения (53)</a>
<br><a href="#p3.5">3.5 Строки и символы (57)</a>
<br><a href="#p3.6">3.6 Указатели (62)</a>