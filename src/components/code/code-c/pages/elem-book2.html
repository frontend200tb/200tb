<article class="article">
  <h1>2001 Крупник - Изучаем Си. 233c</h1>
  <p>Конспект книги</p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
    <a href="#p1">1 Введение в программирование (1)</a>
    <br><a href="#p1.1">1.1 Программы (1)</a>
    <br><a href="#p1.2">1.2 Ячейки и типы (4)</a>
    <br><a href="#p1.3">1.3 Программирование и трансляторы (6)</a>
    <br><a href="#p1.4">1.4 Первая программа на Си (9)</a>
  </p>

  <p>
    <a href="#p2">2 Первые шаги (12)</a>
    <br><a href="#p2.1">2.1 Турбо Си - среда программирования (12)</a>
    <br><a href="#p2.2">2.2 Связь с внешним миром (16)</a>
    <br><a href="#p2.3">2.3 Простые вычисления (20)</a>
    <br><a href="#p2.4">2.4 В чем преимущество программ (22)</a>
    <br><a href="#p2.5">2.5 Массивы (26)</a>
    <br><a href="#p2.6">2.6 Как это делается (34)</a>
  </p>

  <p>
    <a href="#p3">3 Странные типы (42)</a>
    <br><a href="#p3.1">3.1 Странные типы-1 (42)</a>
    <br><a href="#p3.2">3.2 Странные типы-2 (45)</a>
    <br><a href="#p3.3">3.3 Анатомия типов (47)</a>
    <br><a href="#p3.4">3.4 Подбирайте выражения (53)</a>
    <br><a href="#p3.5">3.5 Строки и символы (57)</a>
    <br><a href="#p3.6">3.6 Указатели (62)</a>
  </p>

  <p>
    <a href="#p4">4 Действия (65)</a>
    <br><a href="#p4.1">4.1 Очередность (65)</a>
    <br><a href="#p4.2">4.2 Условность (68)</a>
    <br><a href="#p4.3">4.3 Работа с указателями (72)</a>
    <br><a href="#p4.4">4.4 Битовые операции (74)</a>
    <br><a href="#p4.5">4.5 Функции (80)</a>
    <br><a href="#p4.6">4.6 Функции с длинными руками (84)</a>
    <br><a href="#p4.7">4.7 Рекурсия или раз, два, три (87)</a>
  </p>

  <p>
    <a href="#p5">5 Функции, указатели, массивы (96)</a>
    <br><a href="#p5.1">5.1 Функции и массивы (96)</a>
    <br><a href="#p5.2">5.2 Массивы и указатели (98)</a>
    <br><a href="#p5.3">5.3 Указатели и массивы (100)</a>
    <br><a href="#p5.4">5.4 Динамические массивы (102)</a>
    <br><a href="#p5.5">5.5 Копирование строк (105)</a>
  </p>

  <p>
    <a href="#p6">6 Файлы (109)</a>
    <br><a href="#p6.1">6.1 Падение железного занавеса (109)</a>
    <br><a href="#p6.2">6.2 Массивы указателей (114)</a>
    <br><a href="#p6.3">6.3 Указатели на указатели (120)</a>
    <br><a href="#p6.4">6.4 Файлы - не массивы (123)</a>
    <br><a href="#p6.5">6.5 Открытие файла (126)</a>
  </p>

  <p>
    <a href="#p7">7 Строки (131)</a>
    <br><a href="#p7.1">7.1 Считалочка (131)</a>
    <br><a href="#p7.2">7.2 Сортировка строк (136)</a>
    <br><a href="#p7.3">7.3 Указатель на функцию (138)</a>
    <br><a href="#p7.4">7.4 Имена функций и указатели (144)</a>
    <br><a href="#p7.5">7.5 Функция Qsort (146)</a>
    <br><a href="#p7.6">7.6 Иголка, сено и лыко в строку (151)</a>
  </p>

  <p>
    <a href="#p8">8 Основные типы на сборочном конвейере (157)</a>
    <br><a href="#p8.1">8.1 Перечисления (157)</a>
    <br><a href="#p8.2">8.2 Двухмерные массивы и указатели на... (163)</a>
    <br><a href="#p8.3">8.3 Хранение и переработка двухмерных массивов (170)</a>
    <br><a href="#p8.4">8.4 Записи (174)</a>
    <br><a href="#p8.5">8.5 Записи и функции (178)</a>
    <br><a href="#p8.6">8.6 Указатель на запись (182)</a>
    <br><a href="#p8.7">8.7 Связанные записи (186)</a>
    <br><a href="#p8.8">8.8 Typedef (191)</a>
  </p>

  <p>
    <a href="#p9">9 Большие программы (195)</a>
    <br><a href="#p9.1">9.1 Разделяй и вляствуй (195)</a>
    <br><a href="#p9.2">9.2 Extern или Три поросенка (199)</a>
    <br><a href="#p9.3">9.3 Static (202)</a>
  </p>

  <p>
    <a href="#p10">10 Макросы и переходы (210)</a>
    <br><a href="#p10.1">10.1 Макросы (210)</a>
    <br><a href="#p10.2">10.2 Управление текстом (215)</a>
    <br><a href="#p10.3">10.3 Напутствие или GOTO (218)</a>
  </p>
</article>


<!-- 1. Введение в программирование -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h2>1. Введение в программирование (1)</h2>
</article>


<!-- 1.1 Программы -->
<article class="article">
  <div class="anchor" id="p1.1"></div>
  <h3>1.1 Программы (1)</h3>

  <p>Ячейки памяти в компьютере пронумерованы и располагаются последовательно друг за другом. В ячейках могут храниться команды, данные и указатели на другие ячейки. Процессор выполняет команды в последовательно расположенных ячейках. Первая команда программы всегда расположена в одной и той же ячейке. Процессор выполняет каждую команду программы пока не дойдет до команды стоп, расположенной в последней ячейке с программой.</p>
  <p>Команды, данные и указатели хранятся в одной и той же памяти. Программист должен знать где находятся команды, а где данные. Нельзя записать данные в ячейки, в которых находятся команды потому что это испортит программу.</p>
</article>


<!-- 1.2 Ячейки и типы -->
<article class="article">
  <div class="anchor" id="p1.2"></div>
  <h3>1.2 Ячейки и типы (4)</h3>

  <p>Ячейки памяти не безразмерны. Ячейка памяти это набор из нескольких переключателей, каждый из которых находится в одном из двух состояний: верхнем (его обозначают единицей) и нижнем (его обозначают нулем). В 8-разрядных процессорах таких переключателей 8. Каждый переключатель называют битом и говорят, что в ячейке 8 бит или 1 байт.</p>
  <p>В ячейке с одним переключателем с двумя состояниями 0 и 1 можно хранить два числа. В ячейке с двумя переключателями можно хранить четыре числа. Минимальное число, которое можно хранить в ячейке из 8 бит состоит из всех нулей и равно 0. Максимальное число состоит из всех единиц и равно 255.</p>
  <p>Чтобы определить какое число записано в двоичном виде, нужно воспользоваться позиционным представлением чисел.</p>
  <p>Крайний правый бит, самый младший, это 1 (2⁰)</p>
  <p>Второй справа бит это 2 (2¹)</p>
  <p>Третий справа бит это 4 (2²)</p>
  <p>Четвертый справа бит это 8 (2³)</p>
  <p>Пятый справа бит это 16 (2⁴)</p>
  <p>Шестой справа бит это 32 (2⁵)</p>
  <p>Седьмой справа бит это 64 (2⁶)</p>
  <p>Восьмой справа бит, самый старший, это 128 (2⁷)</p>
  <p>Число 00000000 равно</p>
  <code>0∙2⁷+0∙2⁶+0∙2⁵+0∙2⁴+0∙2³+0∙2²+0∙2¹+0∙2⁰ = 0</code>
  <p>Число 11111111 равно</p>
  <code>1∙2⁷+1∙2⁶+1∙2⁵+1∙2⁴+1∙2³+1∙2²+1∙2¹+1∙2⁰ = 127</code>
  <p>Внутренности ячейки памяти выглядят всегда как последовательность нулей и единиц независимо от того что в них находится: числа, буквы, адреса других ячеек, команды. Процессор должен знать какого типа данные хранятся в ячейке, чтобы правильно с ними работать.</p>
  <p>В ячейках памяти есть только двоичные цифры.</p>
</article>


<!-- 1.3 Программирование и трансляторы -->
<article class="article">
  <div class="anchor" id="p1.3"></div>
  <h3>1.3 Программирование и трансляторы (6)</h3>

  <p>Процессор сначала читает команду, потом обращается к ячейкам с данными, потом снова переходит к командам. И все это без перерыва пока не закончится программа. Программисту приходится выделять ячейки, где будут храниться данные и программа. Нужно помнить в какой ячейке что записано. Если данных становится много, нужно заботиться о том чтобы данные не налезли на программу. Придется не только перемещать программу в другую область памяти, но и менять в ней команды, которые работают с адресами, потому что адреса тоже поменяются. Работа непосредственно с ячейками памяти и командами процессора требует от программиста огромного труда и чудовищного внимания. Изменение программы в одном месте неизбежно потребует изменений во многих других местах, поэтому очень трудно избежать ошибок</p>
  <p>Первые программисты не только распределяли память вручную, но и писали каждую команду в двоичном коде - нулями и единицами. Программа в машинном коде могла работать на компьютере только одного типа, который понимал этот машинный код. На компьютере с другим типом команд выполнить такую программу невозможно.</p>
  <p>Поэтому очень скоро сами программисты стали писать программы иначе. Вместо номеров ячеек они вводили обычные имена, сами команды процессора записывали обычными буквами. Программы из нулей и единиц превратились в тексты, которые можно создавать в текстовом редакторе. Такую программу легче понять и исправить, но ее уже не понимал процессор. Поэтому текст программы пропускали через служебную програму ассемблер, который переводил программу в последовательность из нулей и единиц понятных процессору. Ассемблерная программа могла работать на компьютере только одного типа.</p>
  <p>Поэтому били изобретены языки высокого уровня (BASIC, PASCAL, ...). Программа написанная на языке высокого уровня не может быть непосредственно выполнена ни на одном компьютере, который понимает только команды своего процессора. Программа на языке высокого уровня сначала проходит через компилятор, который переводит ее в ассемблерный код, а затем уже ассемблер переводит ее в машинный код.</p>
  <p>Для каждой разновидности процессора, со своим набором команд, пишут свой ассемблер и свой компилятор, а затем пишут для него программы на языке высокого уровня. Это ускоряет процесс программирования, такие программы более надежны и понятны, их легко выполнить на других компьютерах с другими командами процессора, для которых также написаны ассемблер и компилятор.</p>
  <p>Язык Си был написан в начале 70-х годов опытными программистами Денисом Ритчи и Кеном Томпсоном и стал очень популярным. Язык Си - язык профессиональных программистов.</p>
</article>


<!-- 1.4 Первая программа на Си -->
<article class="article">
  <div class="anchor" id="p1.4"></div>
  <h3>1.4 Первая программа на Си (9)</h3>

  <p>Напишем программу, которая скалдывает два числа</p>

  <details>
    <summary>Программа 1 (10)</summary>
<pre>
int main() {
  int first, second, sum;
  first = 2;
  second = 3;
  sum = first + second;
}
</pre>
  </details>
</article>


<!-- 2 Первые шаги -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>2 Первые шаги (12)</h3>
</article>


<!-- 2.1 Турбо Си - среда программирования -->
<article class="article">
  <div class="anchor" id="p2.1"></div>
  <h3>2.1 Турбо Си - среда программирования (12)</h3>

  <p>Мы выберем компилятор Turbo C 2.01 фирмы Borland для компьютера IBM PC. Компилятор Turbo C 2.01 распространяется бесплатно.</p>

  <h4>Установка компилятора Turbo C 2.01</h4>
  <ol>
    <li>
      Скачать файл
      <code><a href="http://community.borland.com/article/images/20841/tc201.zip">http://community.borland.com/article/images/20841/tc201.zip</a></code>
    </li>
    <li>Распаковать архив tc201.zip в папку <strong>tc</strong>. Появятся три новых папки DISC1, DISC2, DISC3. Переписать содержимое из трех папок DISC1, DISC2, DISC3 в одну папку tc</li>
    <li>Запустить программу install.exe</li>
  </ol>

  <p>Запустим установленную программу</p>
  <code>c:\tc\tc</code>
<p>Появится черное окно редактора, в котором можно писать программу на языке Си. Напишем в редакторе нашу Программу 1.</p>
<p>Программу можно выполнять по шагам и при этом следить за состоянием переменных. Чтобы следить за переменной first, подведем к ней курсор, нажмем CTRL+F7 (или ALT+B чтобы попасть в меню BREAK/WATCH и выбрать там пункт Add watch Ctrl-F7). На экране появится окно Add Watch с именем переменной. При нажатии Enter переменная окажется в нижней части окна под заголовком Watch.</p>
<p>Теперь программу можно выполнить по шагам. Каждому нажатию клавиши F8 соответствует один шаг.</p>
</article>


<!-- 2.2 Связь с внешним миром -->
<article class="article">
  <div class="anchor" id="p2.2"></div>
  <h3>2.2 Связь с внешним миром (16)</h3>

  <p>Дополним программу 1 функцией printf() и строкой #include &lt;stdio.h&gt;</p>

  <details>
    <summary>Программа 2 (17)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int first, second, sum;
  first = 2;
  second = 3;
  sum = first + second;
  printf("sum = %d\n", sum);
  printf("first = %d second = %d sum = %d\n", first, second, sum);
}
</pre>
  </details>
</article>


<!-- 2.3 Простые вычисления -->
<article class="article">
  <div class="anchor" id="p2.3"></div>
  <h3>2.3 Простые вычисления (20)</h3>

  <p>Напишем программу, выполняющую арифметические действия</p>

  <details>
    <summary>Программа 3 (20)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int fst = 2, scnd = 3;
  int df, prd, qt, rm;
  df = fst - scnd;
  prd = fst * scnd;
  qt = fst / scnd;
  fst = 123;
  scnd = 17;
  rm = fst % scnd;
  printf("%d %d %d %d\n", df, prd, qt, rm);
}
</pre>
  </details>
</article>


<!-- 2.4 В чем преимущество программ -->
<article class="article">
  <div class="anchor" id="p2.4"></div>
  <h3>2.4 В чем преимущество программ (22)</h3>

  <p>Напишем программу считающую сумму всех чисел от 1 до 100</p>

  <details>
    <summary>Программа 4 (25)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int sum, i;
  sum = 0;
  i = 1;
  while (i &lt;= 100) {
    sum += i;
    i++;
  }
  printf("sum = %d\n", sum);
}
</pre>
  </details>
</article>


<!-- 2.5 Массивы -->
<article class="article">
  <div class="anchor" id="p2.5"></div>
  <h3>2.5 Массивы (26)</h3>

  <p>Массив это ряд переменных, у каждой из которых есть специальным номер или индекс. Номера переменных в массиве идут по порядку и начинаются с нуля. Массивы позволяют перейти к следующему числу за счет увеличения индекса на 1. Произвольные 10 чисел в массиве так же легко сложить, как идущие подряд числа от 1 до 10.</p>

  <details>
    <summary>Программма 5 (27)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int nums[10] = {5,3,2,4,6,7,11,17,0,13};
  int sum, i;
  sum = 0;
  i = 0;
  while (i &lt; 10) {
    sum += nums[i];
    i++;
  }
  printf("sum = %d\n", sum);
}
</pre>
  </details>

  <p>Числа в массиве можно не только складывать. Напишем программу, которая находит максимальное число в массиве.</p>

  <details>
    <summary>Программа 6 (28)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int nums[10] = {5,3,2,4,6,7,11,17,0,13};
  int max, i;
  max = nums[0];
  i = 1;
  while (i &lt; 10) {
    if (nums[i] > max) {
      max = nums[i];
    }
    i++;
  }
  printf("max = %d\n", max);
}
</pre>
  </details>

  <p>Если заранее известно число итераций цикла, удобнее использовать цикл for. Найдем минимальное число в массиве</p>

  <details>
    <summary>Программа 7 (29)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int nums[10] = {5,3,2,4,6,7,11,17,0,13};
  int min;
  min = nums[0];
  for (int i = 1; i &lt; 10; i++) {
    if (nums[i] &lt; min) {
      min = nums[i];
    }
  }
  printf("min = %d\n", min);
}
</pre>
  </details>

  <p>Расставим элементы в массиве в порядке возрастания. Эта задача называется сортировкой. Сначала найдем максимальный элемент и поставим его в конец массива. Потом найдем максимальный из оставшихлся элементов и т.д.</p>

  <details>
    <summary>Программа 8 (31)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int n = 10;
  int nums[] = {5,3,2,4,6,7,11,17,0,13};
  int i, j;
  for (i = n - 1; i > 0; i--) {
    int max = 0;
    for (j = 1; j &lt;= i; j++) {
      if (nums[j] > nums[max]) {
        max = j;
      }
    }
    int temp = nums[i];
    nums[i] = nums[max];
    nums[max] = temp;
  }

  for (i = 0; i &lt; n; i++) {
    printf("%d ", nums[i]);
  }
}
</pre>
  </details>

  <p>Поменяем местами две переменные a и b, не используя временную переменную temp</p>

  <details>
    <summary>Программа 9 (33)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int a = 8, b = 11;
  a = a + b;
  b = a - b;
  a = a - b;

  printf("a = %d\nb = %d\n", a, b);
}
</pre>
  </details>
</article>


<!-- 2.6 Как это делается -->
<article class="article">
  <div class="anchor" id="p2.6"></div>
  <h3>2.6 Как это делается (34)</h3>

  <p>Как написать программу сортировки массива. Сначала приходит идея найти максимальный элемент, затем найти следующий максимальный элемент и так далее пока все элементы на встанут на свои места. Но куда девать найденные максимумы? Как не использовать дополнительный массив, а сортировать на месте? Для этого будем помещать найденный максимум в конец массива, а элемент из конца массива помещать туда где нашли максимум.</p>
  <p>Такая программа должна состоять из двух вложенных циклов. В первом цикле идем от конца массива и каждый раз в текущий элемент будем записывать найденный максимум. Во внутреннем цикле идем от начала и до элемента в который будем класть максимум. Во внутреннем цикле ищется максимальный элемент.</p>
</article>


<!-- 3 Странные типы -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>3 Странные типы (42)</h3>
</article>


<!-- 3.1 Странные типы-1 -->
<article class="article">
  <div class="anchor" id="p3.1"></div>
  <h3>3.1 Странные типы-1 (42)</h3>

  <p>int - целое число. float - дробное число, округленное с некоторой точностью. Округление возникает из-за ограниченной памяти на хранение одной переменной. В памяти компьютера дробные числа хранятся в двух целых числах - мантиса занимает 6 знаков, а порядок - число от -37 до +37</p>
  <code>0.00001 = 1E-5</code>

  <details>
    <summary>Программа 10 (42)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  float a, b = 2.0;
  int c = 3;
  a = b / c;

  printf("a = %f\n", a);
}
</pre>
  </details>

  <p>Оператор sizeof() возвращает число байт в указанной переменной</p>
  <p>Целые числа по умолчанию имеют тип int. Тип long помечается буквой l в конце числа</p>
  <p>Дробные числа по умолчанию имеют тип double. Тип float помечается буквой f в конце числа</p>

  <details>
    <summary>Программа 11 (44)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char a;
  int b;
  long c;
  float d;
  double e;

  a = sizeof(char);
  printf("Size char = %d\n", a);
  a = sizeof(int);
  printf("Size int = %d\n", a);
  a = sizeof(long);
  printf("Size long = %d\n", a);
  a = sizeof(float);
  printf("Size float = %d\n", a);
  a = sizeof(double);
  printf("Size double = %d\n", a);
}
</pre>
  </details>
</article>


<!-- 3.2 Странные типы-2 -->
<article class="article">
  <div class="anchor" id="p3.2"></div>
  <h3>3.2 Странные типы-2 (45)</h3>

  <p>Компьютер, на котором создавался язык Си, имел всего 24 килобайта оперативной памяти. Поэтому для экономии памяти существуют различные типы данных. Если нужно указать что число беззнаковое, то в конце него ставится буква u.</p>
</article>


<!-- 3.3 Анатомия типов -->
<article class="article">
  <div class="anchor" id="p3.3"></div>
  <h3>3.3 Анатомия типов (47)</h3>

  <p>Все целые числа хранятся в памяти одинаково. Рассмотрим как они хранятся на примере типа char размером 1 байт.</p>
  <p>Сначала посмотрим на беззнаковый тип. Значения переменной unsigned char могут быть от 0 до 255. В двоичном виде от 00000000 до 11111111. В шестнадцатеричном от 00 до FF. Если к 255 прибавить 1, то значение будет равно 0.</p>
  <p>Шестнадцатеричные числа записываются константами, которые начинаются с 0x. Используются когда важно не значение числа, а расположение его бит.</p>

  <details>
    <summary>Программа 12 (50)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int i;
  i = 0xFF;
  printf("%d\n", i);
}
</pre>
  </details>

  <p>Теперь посмотрим на числа со знаком. Знак числа хранится в старшем разряде. Если там 0 то число положительное, если 1 - отрицательное. Сумма положительного и отрицательного числа, равных по величине, равня 0.</p>
  <p>Программа 13 будет работать вечно потому что переменная unsigned char никогда не примет значение больше чем 255.</p>

  <details>
    <summary>Программа 13 (52)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  unsigned char i;
  // бесконечный цикл
  for (i = 0; i &lt;= 255; i++) {
    printf("%d\n", i);
  }
}
</pre>
  </details>

  <p>Компилятор не может и не хочет обнаруживать такие ошибки. Язык Си создавался для программистов, которым не нужно мешать надоедливыми проверками и предупреждениями. Компилятор считает что программист хорошо знает что делает.</p>
</article>


<!-- 3.4 Подбирайте выражения -->
<article class="article">
  <div class="anchor" id="p3.4"></div>
  <h3>3.4 Подбирайте выражения (53)</h3>

  <p>Использование переменных разных типов экономит память и ускоряет выполнение программ. Но нужно хорошо понимать как переменные взаимодействуют друг с другом.</p>
  <p>При делении одного целого числа на другое, результат будет целое число (дробная часть просто отбрасывается) даже если результат присваивается в переменную типа double.</p>
  <p>Чтобы в переменной оказалось дробное число, нужно чтобы одно из чисел было дробное. Когда производится операция над переменными разного типа, то более узкий тип приводится к более широкому.</p>

  <details>
    <summary>Программа 14 (54)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int a = 2;
  int b = 3;
  float c;
  c = a / b;
  printf("%f\n", c);
  c = 2.0 / b;
  printf("%f\n", c);
  c = a / (float)b;
  printf("%f\n", c);
}
</pre>
  </details>

  <p>В операции c = 2.0 / b; компилятор создаст временную переменную (копию переменной b), преобразует ее в тип float, выполнит операцию деления и результат запишется в переменную c. Сама переменная b останется неизменной.</p>
  <p>Используя явное приведение типов, можно самому приводить переменную к нужному типу. Операция (float)b приведет переменную b к типу float</p>
  <p>При операциях с целыми числами, если результат не помещается в переменнойт того же типа, то происходит переполнение. в результате приведения или переполнения могут быть потери. Бывает что переменную одного типа нельзя привести к другому типу без потерь.</p>

  <details>
    <summary>Программа 15 (56)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  unsigned char ch1 = 0xFF;
  signed char ch2 = 0xFF;
  int i;
  i = ch1;
  printf("%d\n", i); // 255
  i = ch2;
  printf("%d\n", i); // -1
  printf("%u\n", i); // 4294967295
}
</pre>
  </details>
</article>


<!-- 3.5 Строки и символы -->
<article class="article">
  <div class="anchor" id="p3.5"></div>
  <h3>3.5 Строки и символы (57)</h3>

  <p>Строки состоят из символов. Один символ кодируется восемью битами и может храниться в переменной типа char. Строки пишутся в двойных кавычках, символы - в одинарных. Для компьютера символ это просто двоичное число, занимающее 1 байт. Есть и невидимые символы, которые можно записать используюя обратный слеш, например '\n'.</p>
  <code>char ch1 = 'a';</code>
  <code>char ch2 = '\n';</code>
  <p>Поскольку строка состоит из символов, то ее кодируют используя массив типа char.</p>
  <code>char s1[4] = {'m','a','m','a'};</code>
  <p>В цикле, зная длину массива, можно вывести строку, записанную в массиве символов</p>

  <details>
    <summary>Программа 16 (58)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char s[4] = {'m','a','m','a'};
  for (int i = 0; i &lt; 4; i++) {
    printf("%c", s[i]);
  }
}
</pre>
  </details>

  <p>Если последним символом в массив записать символ-терминатор, то можно вывести строку не зная ее длины.</p>
  <code>char s2[5] = {'m','a','m','a','\0'};</code>

  <details>
    <summary>Программа 17 (59)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char s[5] = {'m','a','m','a','\0'};
  int i = 0;
  while (s[i] != '\0') {
    printf("%c", s[i]);
    i++;
  }
}
</pre>
  </details>

  <p>Строка состоит из символов, заключенных в двойные кавычки и завершается символом '\0'. Чтобы записать строку в массив, надо присвоить строку массиву символов.</p>
  <code>char s3[] = "mama";</code>
  <p>Компилятор здесь создаст массив из пяти символов, последним символом он допишет '\0'.</p>

  <details>
    <summary>Программа 18 (60)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char s[] = "mama";
  int i = 0;
  while (s[i]) {
    printf("%c", s[i]);
    i++;
  }
}
</pre>
  </details>

  <p>Есть спецификатор для печати строк %s. Поэтому улучшенный вид программы примет короткий вид.</p>

  <details>
    <summary>Программа 19 (61)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char s[] = "mama";
  printf("%s", s);
}
</pre>
  </details>
</article>


<!-- 3.6 Указатели -->
<article class="article">
  <div class="anchor" id="p3.6"></div>
  <h3>3.6 Указатели (62)</h3>

  <p>Имя массива указывает на ячейку памяти, где начинается массив. Адрес ячейки памяти можно передать и другим способом, через <strong>указатель</strong>. Перед тем как использовать указатель, его надо объявить. Чтобы объявить указатель, перед его именем ставится звездочка *.</p>
  <code>char *ps = "mama";</code>
  <p>Выведем слово mama используя указатель</p>

  <details>
    <summary>Программа 20 (62)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char *ps = "mama";
  printf("%s", ps);
}
</pre>
  </details>

  <p>Можно объявить указатель не только на строку, но и на другую переменную. Объявим указатель на адрес где хранится целое число. Сам адрес можно записать позже, используя оператор &.</p>
  <code>int *pa;</code>
  <p>Объявим переменную a целого типа и указатель pa на переменную целого типа. Запишем в указатель pa адрес переменной a. Изменим значение на которое указывает указатель pa и выведем значение переменной a.</p>

  <details>
    <summary>Программа 21 (63)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int a;
  int *pa;
  a = 2;
  pa = &a;
  *pa = 3;
  printf("%d\n", a);
}
</pre>
  </details>
</article>


<!-- 4 Действия -->
<article class="article">
  <div class="anchor" id="p4"></div>
  <h3>4 Действия (65)</h3>
</article>


<!-- 4.1 Очередность -->
<article class="article">
  <div class="anchor" id="p4.1"></div>
  <h3>4.1 Очередность (65)</h3>
</article>


<br><a href="#p4.2">4.2 Условность (68)</a>
<br><a href="#p4.3">4.3 Работа с указателями (72)</a>
<br><a href="#p4.4">4.4 Битовые операции (74)</a>
<br><a href="#p4.5">4.5 Функции (80)</a>
<br><a href="#p4.6">4.6 Функции с длинными руками (84)</a>
<br><a href="#p4.7">4.7 Рекурсия или раз, два, три (87)</a>