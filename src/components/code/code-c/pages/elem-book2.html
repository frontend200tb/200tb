<article class="article">
  <h1>2001 Крупник - Изучаем Си. 233c</h1>
  <p>Конспект книги</p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
    <a href="#p1">1 Введение в программирование (1)</a>
    <br><a href="#p1.1">1.1 Программы (1)</a>
    <br><a href="#p1.2">1.2 Ячейки и типы (4)</a>
    <br><a href="#p1.3">1.3 Программирование и трансляторы (6)</a>
    <br><a href="#p1.4">1.4 Первая программа на Си (9)</a>
  </p>

  <p>
    <a href="#p2">2 Первые шаги (12)</a>
    <br><a href="#p2.1">2.1 Турбо Си - среда программирования (12)</a>
    <br><a href="#p2.2">2.2 Связь с внешним миром (16)</a>
    <br><a href="#p2.3">2.3 Простые вычисления (20)</a>
    <br><a href="#p2.4">2.4 В чем преимущество программ (22)</a>
    <br><a href="#p2.5">2.5 Массивы (26)</a>
    <br><a href="#p2.6">2.6 Как это делается (34)</a>
  </p>

  <p>
    <a href="#p3">3 Странные типы (42)</a>
    <br><a href="#p3.1">3.1 Странные типы-1 (42)</a>
    <br><a href="#p3.2">3.2 Странные типы-2 (45)</a>
    <br><a href="#p3.3">3.3 Анатомия типов (47)</a>
    <br><a href="#p3.4">3.4 Подбирайте выражения (53)</a>
    <br><a href="#p3.5">3.5 Строки и символы (57)</a>
    <br><a href="#p3.6">3.6 Указатели (62)</a>
  </p>

  <p>
    <a href="#p4">4 Действия (65)</a>
    <br><a href="#p4.1">4.1 Очередность (65)</a>
    <br><a href="#p4.2">4.2 Условность (68)</a>
    <br><a href="#p4.3">4.3 Работа с указателями (72)</a>
    <br><a href="#p4.4">4.4 Битовые операции (74)</a>
    <br><a href="#p4.5">4.5 Функции (80)</a>
    <br><a href="#p4.6">4.6 Функции с длинными руками (84)</a>
    <br><a href="#p4.7">4.7 Рекурсия или раз, два, три (87)</a>
  </p>

  <p>
    <a href="#p5">5 Функции, указатели, массивы (96)</a>
    <br><a href="#p5.1">5.1 Функции и массивы (96)</a>
    <br><a href="#p5.2">5.2 Массивы и указатели (98)</a>
    <br><a href="#p5.3">5.3 Указатели и массивы (100)</a>
    <br><a href="#p5.4">5.4 Динамические массивы (102)</a>
    <br><a href="#p5.5">5.5 Копирование строк (105)</a>
  </p>

  <p>
    <a href="#p6">6 Файлы (109)</a>
    <br><a href="#p6.1">6.1 Падение железного занавеса (109)</a>
    <br><a href="#p6.2">6.2 Массивы указателей (114)</a>
    <br><a href="#p6.3">6.3 Указатели на указатели (120)</a>
    <br><a href="#p6.4">6.4 Файлы - не массивы (123)</a>
    <br><a href="#p6.5">6.5 Открытие файла (126)</a>
  </p>

  <p>
    <a href="#p7">7 Строки (131)</a>
    <br><a href="#p7.1">7.1 Считалочка (131)</a>
    <br><a href="#p7.2">7.2 Сортировка строк (136)</a>
    <br><a href="#p7.3">7.3 Указатель на функцию (138)</a>
    <br><a href="#p7.4">7.4 Имена функций и указатели (144)</a>
    <br><a href="#p7.5">7.5 Функция Qsort (146)</a>
    <br><a href="#p7.6">7.6 Иголка, сено и лыко в строку (151)</a>
  </p>

  <p>
    <a href="#p8">8 Основные типы на сборочном конвейере (157)</a>
    <br><a href="#p8.1">8.1 Перечисления (157)</a>
    <br><a href="#p8.2">8.2 Двухмерные массивы и указатели на... (163)</a>
    <br><a href="#p8.3">8.3 Хранение и переработка двухмерных массивов (170)</a>
    <br><a href="#p8.4">8.4 Записи (174)</a>
    <br><a href="#p8.5">8.5 Записи и функции (178)</a>
    <br><a href="#p8.6">8.6 Указатель на запись (182)</a>
    <br><a href="#p8.7">8.7 Связанные записи (186)</a>
    <br><a href="#p8.8">8.8 Typedef (191)</a>
  </p>

  <p>
    <a href="#p9">9 Большие программы (195)</a>
    <br><a href="#p9.1">9.1 Разделяй и вляствуй (195)</a>
    <br><a href="#p9.2">9.2 Extern или Три поросенка (199)</a>
    <br><a href="#p9.3">9.3 Static (202)</a>
  </p>

  <p>
    <a href="#p10">10 Макросы и переходы (210)</a>
    <br><a href="#p10.1">10.1 Макросы (210)</a>
    <br><a href="#p10.2">10.2 Управление текстом (215)</a>
    <br><a href="#p10.3">10.3 Напутствие или GOTO (218)</a>
  </p>
</article>


<!-- 1. Введение в программирование -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h2>1. Введение в программирование (1)</h2>
</article>


<!-- 1.1 Программы -->
<article class="article">
  <div class="anchor" id="p1.1"></div>
  <h3>1.1 Программы (1)</h3>

  <p>Ячейки памяти в компьютере пронумерованы и располагаются последовательно друг за другом. В ячейках могут храниться команды, данные и указатели на другие ячейки. Процессор выполняет команды в последовательно расположенных ячейках. Первая команда программы всегда расположена в одной и той же ячейке. Процессор выполняет каждую команду программы пока не дойдет до команды стоп, расположенной в последней ячейке с программой.</p>
  <p>Команды, данные и указатели хранятся в одной и той же памяти. Программист должен знать где находятся команды, а где данные. Нельзя записать данные в ячейки, в которых находятся команды потому что это испортит программу.</p>
</article>


<!-- 1.2 Ячейки и типы -->
<article class="article">
  <div class="anchor" id="p1.2"></div>
  <h3>1.2 Ячейки и типы (4)</h3>

  <p>Ячейки памяти не безразмерны. Ячейка памяти это набор из нескольких переключателей, каждый из которых находится в одном из двух состояний: верхнем (его обозначают единицей) и нижнем (его обозначают нулем). В 8-разрядных процессорах таких переключателей 8. Каждый переключатель называют битом и говорят, что в ячейке 8 бит или 1 байт.</p>
  <p>В ячейке с одним переключателем с двумя состояниями 0 и 1 можно хранить два числа. В ячейке с двумя переключателями можно хранить четыре числа. Минимальное число, которое можно хранить в ячейке из 8 бит состоит из всех нулей и равно 0. Максимальное число состоит из всех единиц и равно 255.</p>
  <p>Чтобы определить какое число записано в двоичном виде, нужно воспользоваться позиционным представлением чисел.</p>
  <p>Крайний правый бит, самый младший, это 1 (2⁰)</p>
  <p>Второй справа бит это 2 (2¹)</p>
  <p>Третий справа бит это 4 (2²)</p>
  <p>Четвертый справа бит это 8 (2³)</p>
  <p>Пятый справа бит это 16 (2⁴)</p>
  <p>Шестой справа бит это 32 (2⁵)</p>
  <p>Седьмой справа бит это 64 (2⁶)</p>
  <p>Восьмой справа бит, самый старший, это 128 (2⁷)</p>
  <p>Число 00000000 равно</p>
  <code>0∙2⁷+0∙2⁶+0∙2⁵+0∙2⁴+0∙2³+0∙2²+0∙2¹+0∙2⁰ = 0</code>
  <p>Число 11111111 равно</p>
  <code>1∙2⁷+1∙2⁶+1∙2⁵+1∙2⁴+1∙2³+1∙2²+1∙2¹+1∙2⁰ = 127</code>
  <p>Внутренности ячейки памяти выглядят всегда как последовательность нулей и единиц независимо от того что в них находится: числа, буквы, адреса других ячеек, команды. Процессор должен знать какого типа данные хранятся в ячейке, чтобы правильно с ними работать.</p>
  <p>В ячейках памяти есть только двоичные цифры.</p>
</article>


<!-- 1.3 Программирование и трансляторы -->
<article class="article">
  <div class="anchor" id="p1.3"></div>
  <h3>1.3 Программирование и трансляторы (6)</h3>

  <p>Процессор сначала читает команду, потом обращается к ячейкам с данными, потом снова переходит к командам. И все это без перерыва пока не закончится программа. Программисту приходится выделять ячейки, где будут храниться данные и программа. Нужно помнить в какой ячейке что записано. Если данных становится много, нужно заботиться о том чтобы данные не налезли на программу. Придется не только перемещать программу в другую область памяти, но и менять в ней команды, которые работают с адресами, потому что адреса тоже поменяются. Работа непосредственно с ячейками памяти и командами процессора требует от программиста огромного труда и чудовищного внимания. Изменение программы в одном месте неизбежно потребует изменений во многих других местах, поэтому очень трудно избежать ошибок</p>
  <p>Первые программисты не только распределяли память вручную, но и писали каждую команду в двоичном коде - нулями и единицами. Программа в машинном коде могла работать на компьютере только одного типа, который понимал этот машинный код. На компьютере с другим типом команд выполнить такую программу невозможно.</p>
  <p>Поэтому очень скоро сами программисты стали писать программы иначе. Вместо номеров ячеек они вводили обычные имена, сами команды процессора записывали обычными буквами. Программы из нулей и единиц превратились в тексты, которые можно создавать в текстовом редакторе. Такую программу легче понять и исправить, но ее уже не понимал процессор. Поэтому текст программы пропускали через служебную програму ассемблер, который переводил программу в последовательность из нулей и единиц понятных процессору. Ассемблерная программа могла работать на компьютере только одного типа.</p>
  <p>Поэтому били изобретены языки высокого уровня (BASIC, PASCAL, ...). Программа написанная на языке высокого уровня не может быть непосредственно выполнена ни на одном компьютере, который понимает только команды своего процессора. Программа на языке высокого уровня сначала проходит через компилятор, который переводит ее в ассемблерный код, а затем уже ассемблер переводит ее в машинный код.</p>
  <p>Для каждой разновидности процессора, со своим набором команд, пишут свой ассемблер и свой компилятор, а затем пишут для него программы на языке высокого уровня. Это ускоряет процесс программирования, такие программы более надежны и понятны, их легко выполнить на других компьютерах с другими командами процессора, для которых также написаны ассемблер и компилятор.</p>
  <p>Язык Си был написан в начале 70-х годов опытными программистами Денисом Ритчи и Кеном Томпсоном и стал очень популярным. Язык Си - язык профессиональных программистов.</p>
</article>


<!-- 1.4 Первая программа на Си -->
<article class="article">
  <div class="anchor" id="p1.4"></div>
  <h3>1.4 Первая программа на Си (9)</h3>

  <p>Напишем программу, которая скалдывает два числа</p>

  <details>
    <summary>Программа 1 (10)</summary>
<pre>
int main() {
  int first, second, sum;
  first = 2;
  second = 3;
  sum = first + second;
}
</pre>
  </details>
</article>


<!-- 2 Первые шаги -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>2 Первые шаги (12)</h3>
</article>


<!-- 2.1 Турбо Си - среда программирования -->
<article class="article">
  <div class="anchor" id="p2.1"></div>
  <h3>2.1 Турбо Си - среда программирования (12)</h3>

  <p>Мы выберем компилятор Turbo C 2.01 фирмы Borland для компьютера IBM PC. Компилятор Turbo C 2.01 распространяется бесплатно.</p>

  <h4>Установка компилятора Turbo C 2.01</h4>
  <ol>
    <li>
      Скачать файл
      <code><a href="http://community.borland.com/article/images/20841/tc201.zip">http://community.borland.com/article/images/20841/tc201.zip</a></code>
    </li>
    <li>Распаковать архив tc201.zip в папку <strong>tc</strong>. Появятся три новых папки DISC1, DISC2, DISC3. Переписать содержимое из трех папок DISC1, DISC2, DISC3 в одну папку tc</li>
    <li>Запустить программу install.exe</li>
  </ol>

  <p>Запустим установленную программу</p>
  <code>c:\tc\tc</code>
<p>Появится черное окно редактора, в котором можно писать программу на языке Си. Напишем в редакторе нашу Программу 1.</p>
<p>Программу можно выполнять по шагам и при этом следить за состоянием переменных. Чтобы следить за переменной first, подведем к ней курсор, нажмем CTRL+F7 (или ALT+B чтобы попасть в меню BREAK/WATCH и выбрать там пункт Add watch Ctrl-F7). На экране появится окно Add Watch с именем переменной. При нажатии Enter переменная окажется в нижней части окна под заголовком Watch.</p>
<p>Теперь программу можно выполнить по шагам. Каждому нажатию клавиши F8 соответствует один шаг.</p>
</article>


<!-- 2.2 Связь с внешним миром -->
<article class="article">
  <div class="anchor" id="p2.2"></div>
  <h3>2.2 Связь с внешним миром (16)</h3>

  <p>Дополним программу 1 функцией printf() и строкой #include &lt;stdio.h&gt;</p>

  <details>
    <summary>Программа 2 (17)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int first, second, sum;
  first = 2;
  second = 3;
  sum = first + second;
  printf("sum = %d\n", sum);
  printf("first = %d second = %d sum = %d\n", first, second, sum);
}
</pre>
  </details>
</article>


<!-- 2.3 Простые вычисления -->
<article class="article">
  <div class="anchor" id="p2.3"></div>
  <h3>2.3 Простые вычисления (20)</h3>

  <p>Напишем программу, выполняющую арифметические действия</p>

  <details>
    <summary>Программа 3 (20)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int fst = 2, scnd = 3;
  int df, prd, qt, rm;
  df = fst - scnd;
  prd = fst * scnd;
  qt = fst / scnd;
  fst = 123;
  scnd = 17;
  rm = fst % scnd;
  printf("%d %d %d %d\n", df, prd, qt, rm);
}
</pre>
  </details>
</article>


<!-- 2.4 В чем преимущество программ -->
<article class="article">
  <div class="anchor" id="p2.4"></div>
  <h3>2.4 В чем преимущество программ (22)</h3>

  <p>Напишем программу считающую сумму всех чисел от 1 до 100</p>

  <details>
    <summary>Программа 4 (25)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int sum, i;
  sum = 0;
  i = 1;
  while (i &lt;= 100) {
    sum += i;
    i++;
  }
  printf("sum = %d\n", sum);
}
</pre>
  </details>
</article>


<!-- 2.5 Массивы -->
<article class="article">
  <div class="anchor" id="p2.5"></div>
  <h3>2.5 Массивы (26)</h3>

  <p>Массив это ряд переменных, у каждой из которых есть специальным номер или индекс. Номера переменных в массиве идут по порядку и начинаются с нуля. Массивы позволяют перейти к следующему числу за счет увеличения индекса на 1. Произвольные 10 чисел в массиве так же легко сложить, как идущие подряд числа от 1 до 10.</p>

  <details>
    <summary>Программма 5 (27)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int nums[10] = {5,3,2,4,6,7,11,17,0,13};
  int sum, i;
  sum = 0;
  i = 0;
  while (i &lt; 10) {
    sum += nums[i];
    i++;
  }
  printf("sum = %d\n", sum);
}
</pre>
  </details>

  <p>Числа в массиве можно не только складывать. Напишем программу, которая находит максимальное число в массиве.</p>

  <details>
    <summary>Программа 6 (28)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int nums[10] = {5,3,2,4,6,7,11,17,0,13};
  int max, i;
  max = nums[0];
  i = 1;
  while (i &lt; 10) {
    if (nums[i] > max) {
      max = nums[i];
    }
    i++;
  }
  printf("max = %d\n", max);
}
</pre>
  </details>

  <p>Если заранее известно число итераций цикла, удобнее использовать цикл for. Найдем минимальное число в массиве</p>

  <details>
    <summary>Программа 7 (29)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int nums[10] = {5,3,2,4,6,7,11,17,0,13};
  int min;
  min = nums[0];
  for (int i = 1; i &lt; 10; i++) {
    if (nums[i] &lt; min) {
      min = nums[i];
    }
  }
  printf("min = %d\n", min);
}
</pre>
  </details>

  <p>Расставим элементы в массиве в порядке возрастания. Эта задача называется сортировкой. Сначала найдем максимальный элемент и поставим его в конец массива. Потом найдем максимальный из оставшихлся элементов и т.д.</p>

  <details>
    <summary>Программа 8 (31)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int n = 10;
  int nums[] = {5,3,2,4,6,7,11,17,0,13};
  int i, j;
  for (i = n - 1; i > 0; i--) {
    int max = 0;
    for (j = 1; j &lt;= i; j++) {
      if (nums[j] > nums[max]) {
        max = j;
      }
    }
    int temp = nums[i];
    nums[i] = nums[max];
    nums[max] = temp;
  }

  for (i = 0; i &lt; n; i++) {
    printf("%d ", nums[i]);
  }
}
</pre>
  </details>

  <p>Поменяем местами две переменные a и b, не используя временную переменную temp</p>

  <details>
    <summary>Программа 9 (33)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int a = 8, b = 11;
  a = a + b;
  b = a - b;
  a = a - b;

  printf("a = %d\nb = %d\n", a, b);
}
</pre>
  </details>
</article>


<!-- 2.6 Как это делается -->
<article class="article">
  <div class="anchor" id="p2.6"></div>
  <h3>2.6 Как это делается (34)</h3>

  <p>Как написать программу сортировки массива. Сначала приходит идея найти максимальный элемент, затем найти следующий максимальный элемент и так далее пока все элементы на встанут на свои места. Но куда девать найденные максимумы? Как не использовать дополнительный массив, а сортировать на месте? Для этого будем помещать найденный максимум в конец массива, а элемент из конца массива помещать туда где нашли максимум.</p>
  <p>Такая программа должна состоять из двух вложенных циклов. В первом цикле идем от конца массива и каждый раз в текущий элемент будем записывать найденный максимум. Во внутреннем цикле идем от начала и до элемента в который будем класть максимум. Во внутреннем цикле ищется максимальный элемент.</p>
</article>


<!-- 3 Странные типы -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>3 Странные типы (42)</h3>
</article>


<!-- 3.1 Странные типы-1 -->
<article class="article">
  <div class="anchor" id="p3.1"></div>
  <h3>3.1 Странные типы-1 (42)</h3>

  <p>int - целое число. float - дробное число, округленное с некоторой точностью. Округление возникает из-за ограниченной памяти на хранение одной переменной. В памяти компьютера дробные числа хранятся в двух целых числах - мантиса занимает 6 знаков, а порядок - число от -37 до +37</p>
  <code>0.00001 = 1E-5</code>

  <details>
    <summary>Программа 10 (42)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  float a, b = 2.0;
  int c = 3;
  a = b / c;

  printf("a = %f\n", a);
}
</pre>
  </details>

  <p>Оператор sizeof() возвращает число байт в указанной переменной</p>
  <p>Целые числа по умолчанию имеют тип int. Тип long помечается буквой l в конце числа</p>
  <p>Дробные числа по умолчанию имеют тип double. Тип float помечается буквой f в конце числа</p>

  <details>
    <summary>Программа 11 (44)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char a;
  int b;
  long c;
  float d;
  double e;

  a = sizeof(char);
  printf("Size char = %d\n", a);
  a = sizeof(int);
  printf("Size int = %d\n", a);
  a = sizeof(long);
  printf("Size long = %d\n", a);
  a = sizeof(float);
  printf("Size float = %d\n", a);
  a = sizeof(double);
  printf("Size double = %d\n", a);
}
</pre>
  </details>
</article>


<!-- 3.2 Странные типы-2 -->
<article class="article">
  <div class="anchor" id="p3.2"></div>
  <h3>3.2 Странные типы-2 (45)</h3>

  <p>Компьютер, на котором создавался язык Си, имел всего 24 килобайта оперативной памяти. Поэтому для экономии памяти существуют различные типы данных. Если нужно указать что число беззнаковое, то в конце него ставится буква u.</p>
</article>


<!-- 3.3 Анатомия типов -->
<article class="article">
  <div class="anchor" id="p3.3"></div>
  <h3>3.3 Анатомия типов (47)</h3>

  <p>Все целые числа хранятся в памяти одинаково. Рассмотрим как они хранятся на примере типа char размером 1 байт.</p>
  <p>Сначала посмотрим на беззнаковый тип. Значения переменной unsigned char могут быть от 0 до 255. В двоичном виде от 00000000 до 11111111. В шестнадцатеричном от 00 до FF. Если к 255 прибавить 1, то значение будет равно 0.</p>
  <p>Шестнадцатеричные числа записываются константами, которые начинаются с 0x. Используются когда важно не значение числа, а расположение его бит.</p>

  <details>
    <summary>Программа 12 (50)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int i;
  i = 0xFF;
  printf("%d\n", i);
}
</pre>
  </details>

  <p>Теперь посмотрим на числа со знаком. Знак числа хранится в старшем разряде. Если там 0 то число положительное, если 1 - отрицательное. Сумма положительного и отрицательного числа, равных по величине, равня 0.</p>
  <p>Программа 13 будет работать вечно потому что переменная unsigned char никогда не примет значение больше чем 255.</p>

  <details>
    <summary>Программа 13 (52)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  unsigned char i;
  // бесконечный цикл
  for (i = 0; i &lt;= 255; i++) {
    printf("%d\n", i);
  }
}
</pre>
  </details>

  <p>Компилятор не может и не хочет обнаруживать такие ошибки. Язык Си создавался для программистов, которым не нужно мешать надоедливыми проверками и предупреждениями. Компилятор считает что программист хорошо знает что делает.</p>
</article>


<!-- 3.4 Подбирайте выражения -->
<article class="article">
  <div class="anchor" id="p3.4"></div>
  <h3>3.4 Подбирайте выражения (53)</h3>

  <p>Использование переменных разных типов экономит память и ускоряет выполнение программ. Но нужно хорошо понимать как переменные взаимодействуют друг с другом.</p>
  <p>При делении одного целого числа на другое, результат будет целое число (дробная часть просто отбрасывается) даже если результат присваивается в переменную типа double.</p>
  <p>Чтобы в переменной оказалось дробное число, нужно чтобы одно из чисел было дробное. Когда производится операция над переменными разного типа, то более узкий тип приводится к более широкому.</p>

  <details>
    <summary>Программа 14 (54)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int a = 2;
  int b = 3;
  float c;
  c = a / b;
  printf("%f\n", c);
  c = 2.0 / b;
  printf("%f\n", c);
  c = a / (float)b;
  printf("%f\n", c);
}
</pre>
  </details>

  <p>В операции c = 2.0 / b; компилятор создаст временную переменную (копию переменной b), преобразует ее в тип float, выполнит операцию деления и результат запишется в переменную c. Сама переменная b останется неизменной.</p>
  <p>Используя явное приведение типов, можно самому приводить переменную к нужному типу. Операция (float)b приведет переменную b к типу float</p>
  <p>При операциях с целыми числами, если результат не помещается в переменнойт того же типа, то происходит переполнение. в результате приведения или переполнения могут быть потери. Бывает что переменную одного типа нельзя привести к другому типу без потерь.</p>

  <details>
    <summary>Программа 15 (56)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  unsigned char ch1 = 0xFF;
  signed char ch2 = 0xFF;
  int i;
  i = ch1;
  printf("%d\n", i); // 255
  i = ch2;
  printf("%d\n", i); // -1
  printf("%u\n", i); // 4294967295
}
</pre>
  </details>
</article>


<!-- 3.5 Строки и символы -->
<article class="article">
  <div class="anchor" id="p3.5"></div>
  <h3>3.5 Строки и символы (57)</h3>

  <p>Строки состоят из символов. Один символ кодируется восемью битами и может храниться в переменной типа char. Строки пишутся в двойных кавычках, символы - в одинарных. Для компьютера символ это просто двоичное число, занимающее 1 байт. Есть и невидимые символы, которые можно записать используюя обратный слеш, например '\n'.</p>
  <code>char ch1 = 'a';</code>
  <code>char ch2 = '\n';</code>
  <p>Поскольку строка состоит из символов, то ее кодируют используя массив типа char.</p>
  <code>char s1[4] = {'m','a','m','a'};</code>
  <p>В цикле, зная длину массива, можно вывести строку, записанную в массиве символов</p>

  <details>
    <summary>Программа 16 (58)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char s[4] = {'m','a','m','a'};
  for (int i = 0; i &lt; 4; i++) {
    printf("%c", s[i]);
  }
}
</pre>
  </details>

  <p>Если последним символом в массив записать символ-терминатор, то можно вывести строку не зная ее длины.</p>
  <code>char s2[5] = {'m','a','m','a','\0'};</code>

  <details>
    <summary>Программа 17 (59)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char s[5] = {'m','a','m','a','\0'};
  int i = 0;
  while (s[i] != '\0') {
    printf("%c", s[i]);
    i++;
  }
}
</pre>
  </details>

  <p>Строка состоит из символов, заключенных в двойные кавычки и завершается символом '\0'. Чтобы записать строку в массив, надо присвоить строку массиву символов.</p>
  <code>char s3[] = "mama";</code>
  <p>Компилятор здесь создаст массив из пяти символов, последним символом он допишет '\0'.</p>

  <details>
    <summary>Программа 18 (60)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char s[] = "mama";
  int i = 0;
  while (s[i]) {
    printf("%c", s[i]);
    i++;
  }
}
</pre>
  </details>

  <p>Есть спецификатор для печати строк %s. Поэтому улучшенный вид программы примет короткий вид.</p>

  <details>
    <summary>Программа 19 (61)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char s[] = "mama";
  printf("%s", s);
}
</pre>
  </details>
</article>


<!-- 3.6 Указатели -->
<article class="article">
  <div class="anchor" id="p3.6"></div>
  <h3>3.6 Указатели (62)</h3>

  <p>Имя массива указывает на ячейку памяти, где начинается массив. Адрес ячейки памяти можно передать и другим способом, через <strong>указатель</strong>. Перед тем как использовать указатель, его надо объявить. Чтобы объявить указатель, перед его именем ставится звездочка *.</p>
  <code>char *ps = "mama";</code>
  <p>Выведем слово mama используя указатель</p>

  <details>
    <summary>Программа 20 (62)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char *ps = "mama";
  printf("%s", ps);
}
</pre>
  </details>

  <p>Можно объявить указатель не только на строку, но и на другую переменную. Объявим указатель на адрес где хранится целое число. Сам адрес можно записать позже, используя оператор &.</p>
  <code>int *pa;</code>
  <p>Оператор взятия адреса & пишется перед переменной и возвращает адрес переменной</p>
  <p>Оператор разименования * пишется перед указателем и возвращает значение переменной</p>
  <p>Объявим переменную a целого типа и указатель pa на переменную целого типа. Запишем в указатель pa адрес переменной a. Изменим значение на которое указывает указатель pa и выведем значение переменной a.</p>

  <details>
    <summary>Программа 21 (63)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int a;
  int *pa;
  a = 2;
  pa = &a;
  *pa = 3;
  printf("%d\n", a);
}
</pre>
  </details>
</article>


<!-- 4 Действия -->
<article class="article">
  <div class="anchor" id="p4"></div>
  <h3>4 Действия (65)</h3>
</article>


<!-- 4.1 Очередность -->
<article class="article">
  <div class="anchor" id="p4.1"></div>
  <h3>4.1 Очередность (65)</h3>

  <p>Оператор инкремента ++ увеличивает на 1 значение переменной. Оператор декремента -- уменьшает на 1 значение переменной. Префиксная и постфиксная формы действуют одинаково на одиноко стоящую переменную. Но если переменная участвует в выражении, то результат окажется разным. В префиксной форме переменная сначала увеличит свое значение на 1, потом будет использована в выражении. В постфиксной форме переменная сначала будет использована в выражении, потом будет увеличина на 1.</p>

  <details>
    <summary>Программа 22 (67)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int i, j, x, y;
  i = 1;
  j = 1;
  x = ++i;
  y = j++;
  printf("x=%d y=%d\n", x, y);
  printf("i=%d j=%d\n", i, j);
}
</pre>
  </details>

  <p>В стандарте языка Си не определено какое слагаемое вычисляется первым. Один компилятор вычислит сначала a потом b, другой сначала b потом a</p>
  <code>x = a + b;</code>
  <p>Поэтому результат выражения может быть непредсказуемым</p>
  <code>x = ++i + i;</code>
  <p>Поэтому если в выражении используется префиксный оператор инкремента или декремента перед переменной, то эта переменная должна встречаться в этом выражении ровно один раз.</p>
</article>


<!-- 4.2 Условность -->
<article class="article">
  <div class="anchor" id="p4.2"></div>
  <h3>4.2 Условность (65)</h3>

  <p>Результат логической операции это число 1 (истина) или 0 (ложь). Поэтому логические и арифметические операции можно смешивать</p>
  <code>i = 10 > 5; // i = 1</code>
  <code>j = 5 > 6; // j = 0</code>

  <p>Следующая программа покажет как работают логические операторы && и ||.</p>

  <details>
    <summary>Программа 23 (70)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int i, j;
  for (i = 0; i &lt; 2; i++) {
    for (j = 0; j &lt; 2; j++) {
      printf("%d && %d = %d ", i, j, i && j);
      printf("%d || %d = %d\n", i, j, i || j);
    }
  }
}
</pre>
<pre>
0 && 0 = 0 0 || 0 = 0
0 && 1 = 0 0 || 1 = 1
1 && 0 = 0 1 || 0 = 1
1 && 1 = 1 1 || 1 = 1
</pre>
  </details>
</article>


<!-- 4.3 Работа с указателями -->
<article class="article">
  <div class="anchor" id="p4.3"></div>
  <h3>4.3 Работа с указателями (72)</h3>

  <p>Напишем программу суммирования всех элементов массива.</p>

  <details>
    <summary>Программа 24 (72)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int nums[10] = {5,3,2,4,6,7,11,17,0,13};
  int sum;
  int *p;
  p = &nums[0];
  for (int i = 0; i &lt; 10; i++) {
    sum += *p;
    p++;
  }
  printf("sum = %d\n", sum);
}
</pre>
  </details>
  <p>Операция ++ применяется к указателям не так как к переменным.</p>
  <p>Операция ++ для переменной увеличит ее значение на 1. Прибавляя целове число к переменно мы увеличиваем ее значение.</p>
  <p>Операция ++ для указателя увеличивает адрес, на который он указывает, до адреса следующего элемента. К указателям можно прибавлять целые числа. Прибавляя целое число N к указателю мы переместим адрес на N элементов вперед. В зависимости от типа указателя, от размера типа это может быть один, два, четыре и т.д. байта. Обычно такие операции используют для указателя на элементы массива, которые расположены в памяти друг за другом и имеют одинаковый тип.</p>
  <p>Если указатель выходит за пределы массива то он будет показывать неизвестно куда.</p>
  <p>Указатели, ссылающиеся на элементы одного и того же массива, можно сравнивать. Равные указатели ссылаются на один и тот же элемент. Меньший указатель ссылается на элемент, стоящий левее.</p>
</article>


<!-- 4.4 Битовые операциии -->
<article class="article">
  <div class="anchor" id="p4.4"></div>
  <h3>4.4 Битовые операции (74)</h3>

  <p>В программах есть значения всего с двумя состояниями. Для их хранения достаточно переменной размеров в 1 бит. Но минимальный размер ячейки памяти к которой может обратиться компьютер составляет 1 байт (8 бит). Если их много, то жалко тратить на каждую из них 1 байт.</p>
  <p>Чтобы решить эту проблему можно упаковать в один байт несколько таких переменных и использовать битовые операции для доступа к отдельным битам таких переменных. Если переменных не больше 8 то используют тип unsigned char</p>
  <p>Пусть у нас есть однобайтовая переменная со значением 00010001. Узнаем чему равен ее пятый бит. Биты нумеруются справа налево, от младшего к старшему. Изготовим специальную маску - переменную в которой все биты кроме пятого равны нулю 00010000. В программах такие переменные и их маски записываются в шестнадцатеричном виде.</p>

  <details>
    <summary>Программа 25 (75)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  unsigned char x, mask;
  x = 17;       // 00010001
  mask = 0x10;  // 00010000
  if (x & mask) {
    printf("=1");
  } else {
    printf("=0");
  }
}
</pre>
  </details>

  <code>x = 17; mask = 0x10; // x = 00010001, mask = 00010000</code>
  <p>Побитовое И</p>
  <code>x & mask; // 00010000</code>
  <p>Побитовое ИЛИ</p>
  <code>x | mask; // 00010001</code>
  <p>Побитовое исключающее ИЛИ</p>
  <code>x ^ mask; // 00000001</code>
  <p>Побитовый сдвиг вправо</p>
  <code>x >> 2; // 000000100</code>
  <p>Побитовый сдвиг влево</p>
  <code>x &lt;&lt; 1; // 000100010</code>
  <p>Побитовое отрицание</p>
  <code>~x; // 11101110</code>

  <p>Посмотрим как побитовые операторы работают в программе</p>
  <details>
    <summary>Программа 26 (77)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  unsigned char x, y;
  x = 17;  // 00010001
  y = 16;  // 00010000
  printf("x=%d y=%d\n", x, y);
  printf("x&y=%d\n", x&y);
  printf("x|y=%d\n", x|y);
  printf("x^y=%d\n", x^y);
  printf("x>>2=%d\n", x>>2);
  printf("x&lt;&lt;1=%d\n", x&lt;&lt;1);
  printf("~x=%u\n", ~x);
}
</pre>
  </details>

  <p>Посмотрим что делают инструкции</p>
  <code>a ^= b; b ^= a; a ^= b;</code>
  <details>
    <summary>Программа 27 (77)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  unsigned char a, b;
  a = 8;   // 00001000
  b = 15;  // 00001111
  printf("a=%d b=%d\n", a, b);
  a ^= b;
  b ^= a;
  a ^= b;
  printf("a=%d b=%d\n", a, b);
}
</pre>
<pre>
a=8 b=15
a=15 b=8
</pre>
  </details>
</article>


<!-- 4.5 Функции -->
<article class="article">
  <div class="anchor" id="p4.5"></div>
  <h3>4.5 Функции (80)</h3>

  <p>Напишкм функцию, скалдывающую два целых числа</p>
  <details>
    <summary>Программа 28 (81)</summary>
<pre>
#include &lt;stdio.h&gt;

int add(int, int);

int main() {
  int i, j, sum;
  i = 2;
  j = 3;
  sum = add(i, j);
  printf("%d\n", sum);
}

int add(int x, int y) {
  return x + y;
}
</pre>
  </details>

  <p>Сначала пишется <strong>заголовок</strong> функции. В заголовке указан тип возвращаемого значения функции, количество и тип ее аргументов. После пишется <strong>тело</strong> функции в фигурных скобках.</p>
  <p>Аргументы функции это переменные которые передаются в функцию при ее вызове (в программе выше это i и j). При каждом вызове могут быть переданы разные аргументы</p>
  <p>Параметры функции это то что записано в заголовке функции (в программе выше это x и y). Это переменные которые создаются каждый раз при вызове функции, в них копируется значение аргументов, с которыми была вызвана функция. Когда функция возвращает результат, она заканчивает свою работу и параметры уничтожаются.</p>
  <p>Функция не может изменить аргументы, она работает только с параметрами. Проверим это в следующей программе.</p>
  <details>
    <summary>Программа 29 (82)</summary>
<pre>
#include &lt;stdio.h&gt;

void change(int);

int main() {
  int i;
  i = 2;
  printf("i=%d\n", i);
  change(i);
  printf("after function i=%d\n", i);
}

void change(int i) {
  i += 3;
  printf("in function i=%d\n", i);
}
</pre>
  </details>

  <p>Функции пишут, чтобы она выполняла определенную часть работы. Написанные функции можно использовать в других программах. Например, стандартные функции языка Си.</p>
  <p>Функция main() главная в программе. Она возвращает значение тому,кто главнее, то есть запустившей ее процедуре операционной системы.</p>
</article>


<!-- 4.6 Функции с длинными руками -->
<article class="article">
  <div class="anchor" id="p4.6"></div>
  <h3>4.6 Функции с длинными руками (84)</h3>

  <p>При передаче переменной (аргумента) в функцию, ее <strong>значение</strong> копируется в переменную (параметр) того же типа и дальше функция работает со <strong>значением</strong> которое было во внешней переменной. Саму внешнюю переменную функция изменить никак не может.</p>
  <p>При передаче указателя в функцию, его значение (адрес который в нем записан) копируется в другой указатель (созданный во время вызова функции как ее параметр). Сам адрес, записанный в указателе (аргументе) функция изменить никак не может. Но она может менять значение переменной, записанной по этому адресу.</p>

  <details>
    <summary>Программа 30 (85)</summary>
<pre>
#include &lt;stdio.h&gt;

void change(int*);

int main() {
  int i;
  i = 2;
  printf("i=%d\n", i);
  change(&i);
  printf("after function i=%d\n", i);
}

void change(int *a) {
  *a += 3;
  printf("in function a=%d\n", *a);
}
</pre>
  </details>
  <p>Если внутри функции увеличить значение указателя на 1, то можно изменить соседнюю переменную. Но функция ничего не знает о внешних переменных и не известно на что будет указывать измененный указатель.</p>
  <p>Функция scanf() принимает указатели, поэтому мы передаем в нее адреса переменных. А функция scanf() записывает по этим адресам числа, введенные с клавиатуры. Если бы функция scanf() принимала переменные, то она не могла бы в них ничего записать, потому что никакая функция не может менять внешние переменные</p>

  <p>Напишем программу которая принимает от пользователя два целых числа разделенных пробелом и выводит их сумму</p>

  <details>
    <summary>Программа 31 (86)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int a, b;
  scanf("%d %d", &a, &b);
  printf("%d\n", a+b);
}
</pre>
  </details>

  <p>Функция не может менять внешние переменные. У нее для этого "руки коротки". С помощью указателя функция может дотянуться до чего угодно. Указатели дают функциям "длинные руки". Но при помощи ключевого слова <strong>const</strong> это руки можно "укортить". Например, если указатель передается в функцию как константа, то менять его значение не позволит компилятор.</p>
  <code>void change(const int *a) { a += 3; }</code>
  <p>Компилятор выдаст сообщение об ошибке - объект на который ссылается указатель постоянный и не может быть изменен</p>
  <p>Не следует использовать const если назначение функции - изменить переменную переданную через указатель. Слово const используют если нужно только читать переменную, зная указатель на нее. В этом случае слово const делает программу надежней и безопасней.</p>
</article>


<!-- 4.7 Рекурсия или раз, два, три  -->
<article class="article">
  <div class="anchor" id="p4.7"></div>
  <h3>4.7 Рекурсия или раз, два, три  (87)</h3>

  <p>Задача вывести на экран три числа</p>

  <details>
    <summary>Программа 32 (88)</summary>
<pre>
#include &lt;stdio.h&gt;

void CountTo3(int);
void CountTo2(int);
void CountTo1(int);

int main() {
  CountTo3(3);
}

void CountTo3(int p) {
  CountTo2(p-1);
  printf("%d\n", p);
}

void CountTo2(int p) {
  CountTo1(p-1);
  printf("%d\n", p);
}

void CountTo1(int p) {
  printf("%d\n", p);
}
</pre>
<pre>
1
2
3
</pre>
  </details>

  <p>Функции, которые вызывают сами себя, называюся рекурсивными.</p>

  <details>
    <summary>Программа 33 (91)</summary>
<pre>
#include &lt;stdio.h&gt;

void CountTo(int);

int main() {
  CountTo(3);
}

void CountTo(int p) {
  if (p > 0) {
  CountTo(p-1);
  printf("%d\n", p);
  }
}
</pre>
<pre>
1
2
3
</pre>
  </details>
  <p>Несколько раз вызывается функция, которая называется так же как вызывающая. На самом деле она другая. У нее создаются свои переменные, независимо от переменных вызвавшей функциии. Эти переменные никак не связаны.</p>
  <p>При рекурсии сначала функции будут по очереди вызываться, будут создаваться переменные для каждой функции. Закончив свою работу, функции будут по очереди завершаться, удаляя свои переменные.</p>
  <p>В каждой рекурсивной функции обязательно должно быть условие для ее завершения. Вызов каждой копии функции требует памяти для хранения переменных. Для этого выделяется память в стеке вызова. Когда память в стеке вызова заканчивается, то программма завершится аварийно.</p>
  <p>Напишем программу с рекурсивной функцией, которая складывает все числа от 1 до 100.</p>

  <details>
    <summary>Программа 34 (94)</summary>
<pre>
#include &lt;stdio.h&gt;

int sum(int);

int main() {
  int s = sum(100);
  printf("%d\n", s);
}

int sum(int n) {
  if (n == 1) {
    return 1;
  } else {
    return sum(n-1) + n;
  }
}
</pre>
<pre>
5050
</pre>
  </details>
</article>


<!-- 5 Функции, указатели, массивы -->
<article class="article">
  <div class="anchor" id="p5"></div>
  <h3>5 Функции, указатели, массивы (96)</h3>
</article>


<!-- 5.1 Функции и массивы -->
<article class="article">
  <div class="anchor" id="p5.1"></div>
  <h3>5.1 Функции и массивы (96)</h3>

  <p>Мы передаем в функции переменные когда необходимо только читать их значения. Мы передаем в функции указатели когда необходимо менять переменные, на которые они указывают. Чтобы передать фунции массив, достаточно передать указатель на нулевой элемент массива и число элементов в нем. Тогда функция сможет менять указатель в безопасных пределах и получит полный доступ к любому элементу массива.</p>
  <p>Напишем функцию, которая принимает массив, а возвращает максимальный элемент из него.</p>

  <details>
    <summary>Программа 35 (97)</summary>
<pre>
#include &lt;stdio.h&gt;

int maxi(int*, int);

int main() {
  int nums[10] = {5,3,2,4,6,7,11,17,0,13};
  int m = maxi(&nums[0], 10);
  printf("%d\n", m);
}

int maxi(int *a, int n) {
  int max = *a;
  for (int i = 1 ; i &lt; n ; i++) {
    if(*(a + i) > max) {
      max = *(a + i);
    }
  }

  return max;
}
</pre>
  </details>
</article>


<!-- 5.2 Массивы и указатели -->
<article class="article">
  <div class="anchor" id="p5.2"></div>
  <h3>5.2 Массивы и указатели (98)</h3>

  <p>В функцию вместо указателя на начало строки можно передать имя строки, а вместо указателя на первый элемент массива, можно передать имя массива. Это одно и то же.</p>
  <p>Компилятор рассматривает имя массива как адрес его нулевого элемента, а имя строки как указатель на ее нее. Для компилятора имя массива это указатель. Встретив элемент массива arr[i], компилятор преобразует его по правилам работы с указателями *(arr + i). Сумма arr + i указывает на i-й элемент массива, а оператор * возвращает значение этого элемента.</p>
  <p>Массив и возможные действия с его элементами:</p>
  <code>x[3] = {13,28,5};</code>
  <code>x[0]; // 13</code>
  <code>x[1]; // 28</code>
  <code>x[2]; // 5</code>
  <code>x; // адрес нулевого элемента</code>
  <code>*x; // 13</code>
  <code>x+1; // адрес первого элемента</code>
  <code>*(x+1); // 28</code>
  <code>x+2; // адрес ыторого элемента</code>
  <code>*(x+2); // 5</code>
  <code>&(x[0]); // x, адрес нулевого элемента</code>
  <code>*&(x[0]); // 13</code>
  <p>Адрес нулевого элемента равен имени массива. Но это не одно и то же. Указатель можно изменить, а имя массива не может быть изменено. Например, указатель можно увеличить на 1, а изменить имя массива, чтобы оно указывало на следующий элемент нельзя. Имя массива всегда указывает в одно и то же место - на свой нулевой элемент.</p>
  <p>Посмотрим на два объявления строки, чтобы понять различие между указателями и массивами</p>
  <code>char a[] = "mama";</code>
  <p>В массиве a хранится 5 элементов: 4 буквы и символ-терминатор '\0'. Адрес нулевого элемента определяется во время компиляции, и в программе нет такой переменной, где бы он хранился. Везде вместо имени массива компилятор подставляет адрес нулевого элемента массива.</p>
  <code>char *p = "mama";</code>
  <p>В указателе p хранится адрес начала строки. Но в указатель p , как и в любую переменную , можно записать новое значение и тогда он будет указывать на что-то другое</p>
</article>


<!-- 5.3 Указатели и массивы -->
<article class="article">
  <div class="anchor" id="p5.3"></div>
  <h3>5.3 Указатели и массивы (100)</h3>

  <p>Адрес нулевого элемента массива можно передать настоящему указателю p.</p>
  <code>int *p = a[0];</code>
  <p>Этот указатель p, в отличие от имени массива, можно менять так, чтобы он указывал последовательно на все элементы массива</p>
  <p>Напишем программу, суммирующую все элементы массива.</p>

  <details>
    <summary>Программа 36 (101)</summary>
<pre>
#include &lt;stdio.h&gt;

int sum(int*, int);

int main() {
  int nums[10] = {5,3,2,4,6,7,11,17,0,13};
  int s = sum(&nums[0], 10);
  printf("%d\n", s);
}

int sum(int *a, int n) {
  int s = 0;
  for (int i = 0 ; i &lt; n ; i++) {
    s += *a++;
  }

  return s;
}
</pre>
  </details>
</article>


<!-- 5.4 Динамические массивы -->
<article class="article">
  <div class="anchor" id="p5.4"></div>
  <h3>5.4 Динамические массивы (102)</h3>

  <p>Функция malloc() выделяет непрерывный кусок памяти под массив для k идущих подряд переменных одного типа. Функция malloc() принимает число байт, занимаемых массивом и возвращает указатель на его нулевой элемент. Укзатель p указывает на нулевой элемент, p+1 на первый, p+2 на второй и т.д.*p хранит значение нулевого элемента, *(p+1) - значение первого элемента и т.д. p[i] это значение i-го элемента.</p>
  <p>Выделим память под массив int из 10 элементов</p>

  <details>
    <summary>Программа 37 (103)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
  int *p;
  p = malloc(10 * sizeof(int));
  if (p == NULL) {
    printf("not enough memory");
    return 1;
  }
  for (int i = 0; i &lt; 10; i++) {
    printf("%d\n", p[i]);
  }
  free(p);
}
</pre>
  </details>
  <p>Память выделенная с помощью malloc() после завершения работы с ней должна быть освобождена функцией free(). После этого указатель указывает на несуществующую область в памяти и попытка обратиться к ней приведет к краху программы.</p>
</article>


<!-- 5.5 Копирование строк -->
<article class="article">
  <div class="anchor" id="p5.5"></div>
  <h3>5.5 Копирование строк (105)</h3>

  <p>Память занятую обычным массивом int p[100] уже нельзя освободить. Размер такого массива еще нельзя и изменить. Это статический массив. А если заранее неизвестно число элементов в массиве, то память выделяют с запасом. А это некрасиво и расточительно.</p>
  <p>В отличие от статического массива, функция malloc() создает динамический массив, при этом выделяется ровно столько памяти сколько нужно. Функция free() освободит память, когда она станет не нужна.</p>

  <details>
    <summary>Программа 38 (106)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main() {
  char *p1 = "use malloc()";
  char *p2;
  if(NULL == (p2 = malloc(strlen(p1) + 1))) {
    printf("not enough memory\n");
    return 1;
  }
  for (int i = 0; i &lt;= strlen(p1); i++) {
    p2[i] = p1[i];
  }

  printf("%s\n", p2);
  free(p2);
}
</pre>
  </details>
</article>


<!-- 6 Файлы -->
<article class="article">
  <div class="anchor" id="p6"></div>
  <h3>6 Файлы (109)</h3>
</article>


<!-- 6.1 Падение железного занавеса -->
<article class="article">
  <div class="anchor" id="p6.1"></div>
  <h3>6.1 Падение железного занавеса (109)</h3>

  <p>Научимся работать с файлами. Создадим указатель на тип FILE</p>
  <code>FILE *in;</code>
  <p>Чтобы начать работать с файлом нужно его открыть</p>
  <code>in = fopen("name", "mode");</code>
  <p>где name это имя файла, а mode это режим в котором нужно его открыть.</p>
  <p>Если файл удалось открыть то переменную in можно передавать как параметр различным функциям, работающим с файлами. Если файл открыть не удалось то функция fopen() возвращает NULL.</p>
  <p>Каждый открытый файл нужно закрыть функцией fclose() после завершения работы с ним.</p>
  <p>Познакомимся с двумя функциями. Функция чтения строки из файла fgets() и функция записи строки в файл fputs()</p>
  <code>fgets(char * buf, int n, FILE *f)</code>
  <p>Функция fgets() использует внешнюю память, на которую указывает первый параметр buf. Эта память задается массивом или выделяется функцией malloc(). Второй параметр n ограничивает длину читаемой строки.  Функция fgets() прочитает n-1 символов, поставит в конце нулевой символ '\0' и перейдет к следующей строке. После успешного чтения каждой строки возвращает указатель на буфер, где эта строка хранится buf. Если достигнут конец файла или возникла ошибка, возвращает NULL.</p>
  <code>fputs(char *buf, FILE *f)</code>
  <p>Функция fputs() записывает строку из буфера buf в файл f. Перед записью символ '\0' удаляется.</p>
  <p>Напишем программу, которая берет файл с текстом программы на языке Си, читает его построчно в буфер. Добавляет в начале каждой строки символ табуляции. И записывает в новый файл программу на языке Си с символом табуляции вначале каждой строки</p>

  <details>
    <summary>Программа 39 (112)</summary>
<pre>
#include &lt;stdio.h&gt;
#define BSIZE 200

int main() {
  char buf[BSIZE];
  FILE *in, *out;
  in = fopen("39a.c", "rb");
  out = fopen("39b.c", "wb");
  buf[0] = '\t';
  while (fgets(buf+1, BSIZE-1, in) != NULL) {
    fputs(buf,out);
  }
  fclose(in);
  fclose(out);
}
</pre>
  </details>
</article>


<!-- 6.2 Массивы указателей -->
<article class="article">
  <div class="anchor" id="p6.2"></div>
  <h3>6.2 Массивы указателей (114)</h3>

  <p>Функция main() умеет читать командную строку, то есть параметры, введенные при вызове программы. В прошлом уроке мы написали программу, которая брала файл с текстом программы на языке Си, добавляла вначале каждой строки символ табуляции и записывала в другой файл. Пусть нам нужно, чтобы эта програма как параметры при вызове принимала имя исходного файла и файла результата.</p>
  <code>tabshift.exe src.c dst.c</code>
  <p>src.c и dst.c это два аргумента, которые передаются нашей программе tabshift.exe при ее вызове.</p>
  <code>int main(int argc, char *argv[])</code>
  <p>argc это число аргументов пришедших в программу. Всегда первый аргумент это имя файла программы. Поэтому в любой программе на языке Си есть хотя бы один аргумент. Остальные argc-1 аргументов это то что передали программе при ее вызове.</p>
  <p>*argv[] это массив указателей. Первый указатель argv[0] указывает на имя программы. Остальные указатели argv[1], argv[2] ... указывают на параметры командной строки.</p>
  <p>Напишем программу, которая выводит на экран все аргументы командной строки, число которых равно argc.</p>

  <details>
    <summary>Программа 40 (116)</summary>
<pre>
#include &lt;stdio.h&gt;

int main(int argc, char *argv[]) {
  for (int i = 0; i &lt; argc; i++) {
    printf("%s\n", argv[i]);
  }
}
</pre>
  </details>

  <p>Теперь напишем программу, которая принимает два имени файлов. Читает первый файл, добавляет в начало каждой строки символ табуляции и записывает результат во второй файл</p>

  <details>
    <summary>Программа 41 (117)</summary>
<pre>
#include &lt;stdio.h&gt;
#define BSIZE 200

int main(int argc, char *argv[]) {
  char buf[BSIZE];
  FILE *in, *out;
  if (argc &lt; 3) {
    printf("too small parameters\n");
    return 1;
  }
  in = fopen(argv[1], "rb");
  if (in == NULL) {
    printf("cannot open file %s\n", argv[1]);
    return 1;
  }
  out = fopen(argv[2], "wb");
  buf[0] = '\t';
  while (fgets(buf+1, BSIZE-1, in) != NULL) {
    fputs(buf,out);
  }
  fclose(in);
  fclose(out);
}
</pre>
  </details>

  <p>Программа сама проверит что количество аргументов не меньше трех и что первый файл существует и его можно открыть. Если второго файла нет, то программа создаст его. Если второй файл нет, то программа его уничтожит и создаст новый с тем же именем.</p>
  <p>Чтобы не был уничтожен нужный файл, напишем программу, которая будет проверять есть ли уже файл с таким именем и спрашивать удалить ли его.</p>

  <details>
    <summary>Программа 42 (118)</summary>
<pre>
#include &lt;stdio.h&gt;
#define BSIZE 200

int main(int argc, char *argv[]) {
  char buf[BSIZE];
  FILE *in, *out;
  if (argc &lt; 3) {
    printf("too small parameters\n");
    return 1;
  }
  in = fopen(argv[1], "rb");
  if (in == NULL) {
    printf("cannot open file %s\n", argv[1]);
    return 1;
  }

  int notexist, ans;
  notexist = 0;
  if ((out = fopen(argv[2], "rb")) == NULL) {
    notexist = 1;
    fclose(out);
  }
  if (notexist) {
    out = fopen(argv[2], "wb");
  } else {
    printf("delete file %s ? Y/N\n", argv[2]);
    ans = getchar();
    if (ans == 'Y' || ans == 'y') {
      out = fopen(argv[2], "wb");
    } else {
      return 1;
    }
  }

  buf[0] = '\t';
  while (fgets(buf+1, BSIZE-1, in) != NULL) {
    fputs(buf,out);
  }
  fclose(in);
  fclose(out);
}
</pre>
  </details>

  <p>Напишем программу, которая считывает символы введенные с клавиатуры и выводит их на экран, пока не встретится символ EOF (Ctrl+z)</p>

  <details>
    <summary>Программа 43 (120)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int c;
  while ((c = getchar()) != EOF) {
    putchar(c);
  }
}
</pre>
  </details>
</article>


<!-- 6.3 Указатели на указатели -->
<article class="article">
  <div class="anchor" id="p6.3"></div>
  <h3>6.3 Указатели на указатели (120)</h3>

  <p>Напишем немножко по-другому программу, которая выводит на экран все аргументы командной строки.</p>

  <details>
    <summary>Программа 44 (121)</summary>
<pre>
#include &lt;stdio.h&gt;

int main(int argc, char *argv[]) {
  char *p;
  while ((p=*argv++) != NULL) {
    printf("%s\n", p);
  }
}
</pre>
  </details>

  <p>В программе, char *argv[] это массив указателей на char, а argv это указатель на указатель. Если разименовать такой указатель, то *argv равен нулевому элементу массива, т.е. *argv = argv[0]</p>
  <code>char *argv[] это массив указателей на char</code>
  <code>argv это указатель на указатель</code>
  <code>*argv = argv[0] это нулевой элемент массива</code>
  <code>*(argv+1) = argv[1] это первый элемент массива</code>
  <code>*(argv+argc) = argv[argc] = NULL</code>
  <p>Указатель на указатель в языке Си объявляется с помощью двух звездочек **p. Поэтому параметры для функции main() можно переписать так</p>
  <code>int main (int argc, char **argv)</code>
  <p>argv указывает на нулевой элемент. К нему можно применить оператор * разименования. *argv это и есть нулевой элемент, то есть argv[0]. Но argv[0] это указатель на первый параметр командной строки.И к нему можно применить оператор * разименования. *(argv[0]) это и есть **argv.</p>
  <p>Нельзя путать указатель с массивом. Объявление указателя int **a выделяет память только для одного указателя. А массив *argv[] содержит несколько указателей на строки, да и сами строки.</p>
</article>


<!-- 6.4 Файлы - не массивы -->
<article class="article">
  <div class="anchor" id="p6.4"></div>
  <h3>6.4 Файлы - не массивы (123)</h3>

  <p>Перепишем программу, добавляющую табуляцую в начале строки. Будем брать входной файл, добавлять табуляцию в начало каждой строки и записывать во временный файл, потом временный файл запишем в исходный файл.</p>
  <p>Функция tmpfile() создает никому не мешающий временный файл с уникальным именем.</p>

  <details>
    <summary>Программа 45 (124)</summary>
<pre>
#include &lt;stdio.h&gt;
#define BSIZE 200

int main(int argc, char *argv[]) {
  char buf[BSIZE];
  int ch;
  FILE *in, *tmp;
  if (argc &lt; 2) {
    printf("too small parameters\n");
    return 1;
  }
  in = fopen(argv[1], "rb");
  if (in == NULL) {
    printf("cannot open file %s\n", argv[1]);
    return 1;
  }

  tmp = tmpfile();

  buf[0] = '\t';
  while (fgets(buf+1, BSIZE-1, in) != NULL) {
    fputs(buf, tmp);
  }
  fclose(in);

  in = fopen(argv[1], "wb");
  fseek(tmp, 0L, SEEK_SET);
  while ((ch = fgetc(tmp)) != EOF) {
    fputc(ch, in);
  }

  fclose(in);
  fclose(tmp);
}
</pre>
  </details>

  <p>Файлы - не массивы. Массив это структура данных с произвольным доступом. Мы можем запросто обратиться к любому его элементу nums[0], nums[10]. Чтобы прочитать десятую строку текста из файла, необходимо перед этим прочитать предыдущие девять строк. Файлы похожи на кассету. Чтобы прослушать десятую песню необходимо прослушать предыдущие девять или перемотать пленку.</p>
  <p>Функция fseek() предоставляет такую услугу - перематывает пленку до нужного места. При открытии файла, специальный флажок, указывающий на текущее место чтения или записи, указывает на самое начало файла. Прочитали одну строку - и флажок переместился к началу следующей строки. Когда прочитали все строки - флажок оказывается в конце файла и при чтении из конца файла, функция fgets() выдает NULL.</p>
  <p>То же самое при записи строк в файл. Строка записывается туда где стоит флажок. Записали строчку - и флажок переместился в ее конец.</p>
  <p>Перед тем как копировать временный файл в исходный, необходимо переместить флажок в начало.</p>
</article>


<!-- 6.5 Открытие файла -->
<article class="article">
  <div class="anchor" id="p6.5"></div>
  <h3>6.5 Открытие файла (126)</h3>

  <p>Если в режиме открытия файла дописать букву b, то файлы воспринимаются такими какие они есть. Без буквы b файлы считаются текстовыми. Это значит что при чтении и записи будут меняться служебные символы в конце каждой строки.</p>
  <p>Чтобы открыть файл сразу для чтения и записи, надо использовать режим "r+b". Тогда не нужно будет закрывать файл после его прочтения, чтобы записать в него строки из временного файла.</p>
  <p>Перепишем нашу прогламму добавления символа табуляции, используя режим октрытия файла "r+b"</p>

  <details>
    <summary>Программа 46 (128)</summary>
<pre>
#include &lt;stdio.h&gt;
#define BSIZE 200

int main(int argc, char *argv[]) {
  char buf[BSIZE];
  int act_read;
  FILE *in, *tmp;
  if (argc &lt; 2) {
    printf("too small parameters\n");
    return 1;
  }
  in = fopen(argv[1], "r+b");
  if (in == NULL) {
    printf("cannot open file %s\n", argv[1]);
    return 1;
  }

  tmp = tmpfile();

  buf[0] = '\t';
  while (fgets(buf+1, BSIZE-1, in) != NULL) {
    fputs(buf, tmp);
  }

  rewind(in);
  rewind(tmp);
  do {
    act_read = fread(buf, 1, BSIZE, tmp);
    fwrite(buf, 1, act_read, in);
  } while (act_read == BSIZE);

  fclose(in);
  fclose(tmp);
}
</pre>
  </details>

  <p>Отличие этой программы от предыдущей версии. Во-первых, входной файл открывается для чтения и записи. Во-вторых, для перемотки используется функция rewind(). В-третьих, используется цикл do-while, который копирует временный файл в исходный.</p>
  <p>Функция fread() читает BSIZE байт из временного файла и записывает их в буферный массив buf.</p>
  <p>В конце файла может оказаться меньше байт, чем BSIZE, поэтому функция fread() прочитает оставшиеся байты и вернет число реально прочитанных байт, которое запомнится в переменной act_read.</p>
  <p>Функция fwrite() пишет из буфера buf во входной файл in ровно столько байт, сколько сумела прочитать функция fread().</p>
  <p>Размер символа равен один байт, поэтому при чтении мы указывает в параметрах функции fread() вторым параметром 1, а третим параметром число символов BSIZE.</p>
  <code>fread(buf, 1, BSIZE, tmp)</code>
  <p>Переменная типа int занимает 4 байта, поэтому при чтении 200 переменных типа int мы укажем в параметрах функции fread() вторым параметром sizeof(int), а третим параметром 200</p>
  <code>fread(buf, sizeof(int), 200, tmp)</code>
</article>


<!-- 7 Строки -->
<article class="article">
  <div class="anchor" id="p7"></div>
  <h3>7 Строки (131)</h3>
</article>


<!-- 7.1 Считалочка -->
<article class="article">
  <div class="anchor" id="p7.1"></div>
  <h3>7.1 Считалочка (131)</h3>

  <p>Хранит строки в файл очень удобно: файл легко редактируется и вмещает сколько угодно слов. Начнем с задачи сортировки слов. Прежде чем писать программу сортировки целиком, создадим сначала программу чтения и хранения слов из файла. Как будем хранить слова? Переписывание с места на место длинных слов сильно загружает процессор и программа будет медленно.</p>
  <p>Размер указателя постоянен и не зависит от длины строки, на который он указывает.Можно менять местами указатели, а слова пусть остаются на месте. Заводим массив указателей на char (их число равно числу слов)</p>
  <p>Напишем программу которая прочитает слова из файла и по одному выведет их на экран</p>

  <details>
    <summary>Программа 47 (134)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#define BSIZE 200

int main(int argc, char *argv[]) {
  char buf[BSIZE];
  char *strgs[100];
  FILE *in;

  if (argc &lt; 2) {
    printf("too small parameters\n");
    return 1;
  }

  in = fopen(argv[1], "r+b");
  if (in == NULL) {
    printf("cannot open file %s\n", argv[1]);
    return 1;
  }

  int i = 0;
  while (fgets(buf, BSIZE-1, in) != NULL) {
    strgs[i] = malloc(strlen(buf) + 1);
    strcpy(strgs[i], buf);
    i++;
  }

  int nofl = i;
  // здесь будет Сортировка

  // вывод на экран
  for (int i = 0; i &lt; nofl; i++) {
    printf("%s", strgs[i]);
  }
}
</pre>
  </details>
</article>


<!-- 7.2 Сортировка строк -->
<article class="article">
  <div class="anchor" id="p7.2"></div>
  <h3>7.2 Сортировка строк (136)</h3>

  <p>Для сортировки строк используется их сравнение. Большей из двух строк будем считать строку, у которой первая отличающаяся буква стоит позже в алфавитном списке. Этому определению соответствует библиотечная функция strcmp(char *str1, char *str2), принимающая указатели на начала строк и возвращающая 0 если строки равны, положительную величину, если str1 > str2 и отрицательную если str1 &lt; str2.</p>

  <details>
    <summary>Программа 48 (137)</summary>
    <p>Почему то не сортирует</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#define BSIZE 200

int main(int argc, char *argv[]) {
  char buf[BSIZE];
  char *strgs[100];
  FILE *in;

  if (argc &lt; 2) {
    printf("too small parameters\n");
    return 1;
  }

  in = fopen(argv[1], "r+b");
  if (in == NULL) {
    printf("cannot open file %s\n", argv[1]);
    return 1;
  }

  int i = 0;
  while (fgets(buf, BSIZE-1, in) != NULL) {
    strgs[i] = malloc(strlen(buf) + 1);
    strcpy(strgs[i], buf);
    i++;
  }

  int nofl = i;
  // сортировка
  char *tmp;
  int mm;
  for (int i = nofl - 1; i >= 1; i--) {
    mm = 0;
    for (int j = 1; j &lt;= i; j++) {
      if (strcmp(strgs[j], strgs[mm]) > 0) {
        mm = j;
      }
    }
    tmp = strgs[i];
    strgs[i] = strgs[mm];
    strgs[mm] = tmp;
  }

  // вывод на экран
  for (int i = 0; i &lt; nofl; i++) {
    printf("%s", strgs[i]);
  }
}
</pre>
  </details>
</article>


<!-- 7.3 Указатель на функцию -->
<article class="article">
  <div class="anchor" id="p7.3"></div>
  <h3>7.3 Указатель на функцию (138)</h3>

  <p>Сортировку вынесем в отдельную функцию. Она будет принимать массив указателей и их число (число слов). Возвращать она ничего не будет. После ее выполнения массив указателей будет отсортирован.</p>

  <details>
    <summary>Программа 49 (139)</summary>
    <p>Почему то не сортирует</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#define BSIZE 200

void strsort(char *[], int);

int main(int argc, char *argv[]) {
  char buf[BSIZE];
  char *strgs[100];
  FILE *in;

  if (argc &lt; 2) {
    printf("too small parameters\n");
    return 1;
  }

  in = fopen(argv[1], "r+b");
  if (in == NULL) {
    printf("cannot open file %s\n", argv[1]);
    return 1;
  }

  int i = 0;
  while (fgets(buf, BSIZE-1, in) != NULL) {
    strgs[i] = malloc(strlen(buf) + 1);
    strcpy(strgs[i], buf);
    i++;
  }

  int nofl = i;
  // сортировка
  strsort(strgs, nofl);

  // вывод на экран
  for (int i = 0; i &lt; nofl; i++) {
    printf("%s", strgs[i]);
  }
}

void strsort(char *s[], int N) {
  char *tmp;
  int mm;
  for (int i = N - 1; i >= 1; i--) {
    mm = 0;
    for (int j = 1; j &lt;= i; j++) {
      if (strcmp(s[j], s[mm]) > 0) {
        mm = j;
      }
    }
    tmp = s[i];
    s[i] = s[mm];
    s[mm] = tmp;
  }
}
</pre>
  </details>

  <p>Функции для процессора - те же двоичные коды, и с виду они мало отличаются от строк или массивов. Они так же занимают последовательные ячейки памяти, где хранятся двоичные числа. Эту память процессор воспринимает как последовательность команд.</p>
  <p>Функции в качестве параметра можно передать другую функцию. Надо понимать что передается не сама функция, а адрес ее начала. Это указатель на нее. Чтобы задать указатель на функцию надо записать</p>
  <code>int (*f)(); // указатель на функцию возвращающую int</code>

  <p>Напишем программу, где используется указатель на функцию, возвращающую сумму двух целых чисел.</p>

  <details>
    <summary>Программа 50 (142)</summary>
<pre>
#include &lt;stdio.h&gt;
int sum(int, int);

int main() {
  int i = 2, j = 3, k;
  int (*f)(int, int);
  printf("%d\n", sum(i, j));
  f = &sum;
  printf("%d\n", (*f)(i, j));
}

int sum(int f, int s) {
  return f + s;
}
</pre>
  </details>

  <p>Объявление указателя на функцию</p>
  <code>int (*f)(int, int)</code>
  <p>только выделяет участок памяти для него. Разумное значение указателю на функцию придает оператор &. После присваивания</p>
  <code>f = &sum</code>
  <p>указатель f равен адресу с которого начинается функция sum().</p>
  <p>Теперь мы можем написать функцию сортировки, принимающую функцию сравнения строк в качестве параметра.</p>

  <details>
    <summary>Программа 51 (143)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int cmplen(char *s1, char *s2) {
  return (strlen(s1) - strlen(s2));
}

void strsort(char *s[], int N,
int (*cmp)(char *, char*)) {
  char *tmp;
  int mm;
  for (int i = N - 1; i >= 1; i--) {
    mm = 0;
    for (int j = 1; j &lt;= i; j++) {
      if ((*cmp)(s[j], s[mm]) > 0) {
        mm = j;
      }
    }
    tmp = s[i];
    s[i] = s[mm];
    s[mm] = tmp;
  }
}

int main() {
  char *strgs[] = {"333", "22", "4444", "1"};
  strsort(strgs, 4, &cmplen);

  // вывод на экран
  for (int i = 0; i &lt; 4; i++) {
    printf("%s ", strgs[i]);
  }
}
</pre>
  </details>

  <p>Напишем программу, которая читает строки из файла и выводит их на экран в порядке возрастания длины</p>

  <details>
    <summary>Программа 52 (144)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#define BSIZE 200

int cmplen(char *, char *);
void strsort(char *[], int, int (*cmp)(char *, char*));

int main(int argc, char *argv[]) {
  char buf[BSIZE];
  char *strgs[100];
  FILE *in;

  if (argc &lt; 2) {
    printf("too small parameters\n");
    return 1;
  }

  in = fopen(argv[1], "r+b");
  if (in == NULL) {
    printf("cannot open file %s\n", argv[1]);
    return 1;
  }

  int i = 0;
  while (fgets(buf, BSIZE-1, in) != NULL) {
    strgs[i] = malloc(strlen(buf) + 1);
    strcpy(strgs[i], buf);
    i++;
  }

  int nofl = i;
  // сортировка
  strsort(strgs, nofl, &cmplen);

  // вывод на экран
  for (int i = 0; i &lt; nofl; i++) {
    printf("%s", strgs[i]);
  }
}

int cmplen(char *s1, char *s2) {
  return (strlen(s1) - strlen(s2));
}

void strsort(char *s[], int N,
int (*cmp)(char *, char*)) {
  char *tmp;
  int mm;
  for (int i = N - 1; i >= 1; i--) {
    mm = 0;
    for (int j = 1; j &lt;= i; j++) {
      if ((*cmp)(s[j], s[mm]) > 0) {
        mm = j;
      }
    }
    tmp = s[i];
    s[i] = s[mm];
    s[mm] = tmp;
  }
}
</pre>
  </details>
</article>


<!-- 7.4 Имена функций и указатели -->
<article class="article">
  <div class="anchor" id="p7.3"></div>
  <h3>7.4 Имена функций и указатели (144)</h3>
</article>


<br><a href="#p7.5">7.5 Функция Qsort (146)</a>
<br><a href="#p7.6">7.6 Иголка, сено и лыко в строку (151)</a>