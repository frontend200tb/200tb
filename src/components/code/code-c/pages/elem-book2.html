<article class="article">
  <h1>2001 Крупник - Изучаем Си. 233c</h1>
  <p>Конспект книги</p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
    <a href="#p1">1 Введение в программирование (1)</a>
    <br><a href="#p1.1">1.1 Программы (1)</a>
    <br><a href="#p1.2">1.2 Ячейки и типы (4)</a>
    <br><a href="#p1.3">1.3 Программирование и трансляторы (6)</a>
    <br><a href="#p1.4">1.4 Первая программа на Си (9)</a>
  </p>

  <p>
    <a href="#p2">2 Первые шаги (12)</a>
    <br><a href="#p2.1">2.1 Турбо Си - среда программирования (12)</a>
    <br><a href="#p2.2">2.2 Связь с внешним миром (16)</a>
    <br><a href="#p2.3">2.3 Простые вычисления (20)</a>
    <br><a href="#p2.4">2.4 В чем преимущество программ (22)</a>
    <br><a href="#p2.5">2.5 Массивы (26)</a>
    <br><a href="#p2.6">2.6 Как это делается (34)</a>
  </p>

  <p>
    <a href="#p3">3 Странные типы (42)</a>
    <br><a href="#p3.1">3.1 Странные типы-1 (42)</a>
    <br><a href="#p3.2">3.2 Странные типы-2 (45)</a>
    <br><a href="#p3.3">3.3 Анатомия типов (47)</a>
    <br><a href="#p3.4">3.4 Подбирайте выражения (53)</a>
    <br><a href="#p3.5">3.5 Строки и символы (57)</a>
    <br><a href="#p3.6">3.6 Указатели (62)</a>
  </p>

  <p>
    <a href="#p4">4 Действия (65)</a>
    <br><a href="#p4.1">4.1 Очередность (65)</a>
    <br><a href="#p4.2">4.2 Условность (68)</a>
    <br><a href="#p4.3">4.3 Работа с указателями (72)</a>
    <br><a href="#p4.4">4.4 Битовые операции (74)</a>
    <br><a href="#p4.5">4.5 Функции (80)</a>
    <br><a href="#p4.6">4.6 Функции с длинными руками (84)</a>
    <br><a href="#p4.7">4.7 Рекурсия или раз, два, три (87)</a>
  </p>

  <p>
    <a href="#p5">5 Функции, указатели, массивы (96)</a>
    <br><a href="#p5.1">5.1 Функции и массивы (96)</a>
    <br><a href="#p5.2">5.2 Массивы и указатели (98)</a>
    <br><a href="#p5.3">5.3 Указатели и массивы (100)</a>
    <br><a href="#p5.4">5.4 Динамические массивы (102)</a>
    <br><a href="#p5.5">5.5 Копирование строк (105)</a>
  </p>

  <p>
    <a href="#p6">6 Файлы (109)</a>
    <br><a href="#p6.1">6.1 Падение железного занавеса (109)</a>
    <br><a href="#p6.2">6.2 Массивы указателей (114)</a>
    <br><a href="#p6.3">6.3 Указатели на указатели (120)</a>
    <br><a href="#p6.4">6.4 Файлы - не массивы (123)</a>
    <br><a href="#p6.5">6.5 Открытие файла (126)</a>
  </p>

  <p>
    <a href="#p7">7 Строки (131)</a>
    <br><a href="#p7.1">7.1 Считалочка (131)</a>
    <br><a href="#p7.2">7.2 Сортировка строк (136)</a>
    <br><a href="#p7.3">7.3 Указатель на функцию (138)</a>
    <br><a href="#p7.4">7.4 Имена функций и указатели (144)</a>
    <br><a href="#p7.5">7.5 Функция Qsort (146)</a>
    <br><a href="#p7.6">7.6 Иголка, сено и лыко в строку (151)</a>
  </p>

  <p>
    <a href="#p8">8 Основные типы на сборочном конвейере (157)</a>
    <br><a href="#p8.1">8.1 Перечисления (157)</a>
    <br><a href="#p8.2">8.2 Двухмерные массивы и указатели на... (163)</a>
    <br><a href="#p8.3">8.3 Хранение и переработка двухмерных массивов (170)</a>
    <br><a href="#p8.4">8.4 Записи (174)</a>
    <br><a href="#p8.5">8.5 Записи и функции (178)</a>
    <br><a href="#p8.6">8.6 Указатель на запись (182)</a>
    <br><a href="#p8.7">8.7 Связанные записи (186)</a>
    <br><a href="#p8.8">8.8 Typedef (191)</a>
  </p>

  <p>
    <a href="#p9">9 Большие программы (195)</a>
    <br><a href="#p9.1">9.1 Разделяй и вляствуй (195)</a>
    <br><a href="#p9.2">9.2 Extern или Три поросенка (199)</a>
    <br><a href="#p9.3">9.3 Static (202)</a>
  </p>

  <p>
    <a href="#p10">10 Макросы и переходы (210)</a>
    <br><a href="#p10.1">10.1 Макросы (210)</a>
    <br><a href="#p10.2">10.2 Управление текстом (215)</a>
    <br><a href="#p10.3">10.3 Напутствие или GOTO (218)</a>
  </p>

  <p>
    <a href="#p11">Список литературы (225)</a>
  </p>
</article>


<!-- 1. Введение в программирование -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h2>1. Введение в программирование (1)</h2>
</article>


<!-- 1.1 Программы -->
<article class="article">
  <div class="anchor" id="p1.1"></div>
  <h3>1.1 Программы (1)</h3>

  <p>Ячейки памяти в компьютере пронумерованы и располагаются последовательно друг за другом. В ячейках могут храниться команды, данные и указатели на другие ячейки. Процессор выполняет команды в последовательно расположенных ячейках. Первая команда программы всегда расположена в одной и той же ячейке. Процессор выполняет каждую команду программы пока не дойдет до команды стоп, расположенной в последней ячейке с программой.</p>
  <p>Команды, данные и указатели хранятся в одной и той же памяти. Программист должен знать где находятся команды, а где данные. Нельзя записать данные в ячейки, в которых находятся команды потому что это испортит программу.</p>
</article>


<!-- 1.2 Ячейки и типы -->
<article class="article">
  <div class="anchor" id="p1.2"></div>
  <h3>1.2 Ячейки и типы (4)</h3>

  <p>Ячейки памяти не безразмерны. Ячейка памяти это набор из нескольких переключателей, каждый из которых находится в одном из двух состояний: верхнем (его обозначают единицей) и нижнем (его обозначают нулем). В 8-разрядных процессорах таких переключателей 8. Каждый переключатель называют битом и говорят, что в ячейке 8 бит или 1 байт.</p>
  <p>В ячейке с одним переключателем с двумя состояниями 0 и 1 можно хранить два числа. В ячейке с двумя переключателями можно хранить четыре числа. Минимальное число, которое можно хранить в ячейке из 8 бит состоит из всех нулей и равно 0. Максимальное число состоит из всех единиц и равно 255.</p>
  <p>Чтобы определить какое число записано в двоичном виде, нужно воспользоваться позиционным представлением чисел.</p>
  <p>Крайний правый бит, самый младший, это 1 (2⁰)</p>
  <p>Второй справа бит это 2 (2¹)</p>
  <p>Третий справа бит это 4 (2²)</p>
  <p>Четвертый справа бит это 8 (2³)</p>
  <p>Пятый справа бит это 16 (2⁴)</p>
  <p>Шестой справа бит это 32 (2⁵)</p>
  <p>Седьмой справа бит это 64 (2⁶)</p>
  <p>Восьмой справа бит, самый старший, это 128 (2⁷)</p>
  <p>Число 00000000 равно</p>
  <code>0∙2⁷+0∙2⁶+0∙2⁵+0∙2⁴+0∙2³+0∙2²+0∙2¹+0∙2⁰ = 0</code>
  <p>Число 11111111 равно</p>
  <code>1∙2⁷+1∙2⁶+1∙2⁵+1∙2⁴+1∙2³+1∙2²+1∙2¹+1∙2⁰ = 127</code>
  <p>Внутренности ячейки памяти выглядят всегда как последовательность нулей и единиц независимо от того что в них находится: числа, буквы, адреса других ячеек, команды. Процессор должен знать какого типа данные хранятся в ячейке, чтобы правильно с ними работать.</p>
  <p>В ячейках памяти есть только двоичные цифры.</p>
</article>


<!-- 1.3 Программирование и трансляторы -->
<article class="article">
  <div class="anchor" id="p1.3"></div>
  <h3>1.3 Программирование и трансляторы (6)</h3>

  <p>Процессор сначала читает команду, потом обращается к ячейкам с данными, потом снова переходит к командам. И все это без перерыва пока не закончится программа. Программисту приходится выделять ячейки, где будут храниться данные и программа. Нужно помнить в какой ячейке что записано. Если данных становится много, нужно заботиться о том чтобы данные не налезли на программу. Придется не только перемещать программу в другую область памяти, но и менять в ней команды, которые работают с адресами, потому что адреса тоже поменяются. Работа непосредственно с ячейками памяти и командами процессора требует от программиста огромного труда и чудовищного внимания. Изменение программы в одном месте неизбежно потребует изменений во многих других местах, поэтому очень трудно избежать ошибок</p>
  <p>Первые программисты не только распределяли память вручную, но и писали каждую команду в двоичном коде - нулями и единицами. Программа в машинном коде могла работать на компьютере только одного типа, который понимал этот машинный код. На компьютере с другим типом команд выполнить такую программу невозможно.</p>
  <p>Поэтому очень скоро сами программисты стали писать программы иначе. Вместо номеров ячеек они вводили обычные имена, сами команды процессора записывали обычными буквами. Программы из нулей и единиц превратились в тексты, которые можно создавать в текстовом редакторе. Такую программу легче понять и исправить, но ее уже не понимал процессор. Поэтому текст программы пропускали через служебную програму ассемблер, который переводил программу в последовательность из нулей и единиц понятных процессору. Ассемблерная программа могла работать на компьютере только одного типа.</p>
  <p>Поэтому били изобретены языки высокого уровня (BASIC, PASCAL, ...). Программа написанная на языке высокого уровня не может быть непосредственно выполнена ни на одном компьютере, который понимает только команды своего процессора. Программа на языке высокого уровня сначала проходит через компилятор, который переводит ее в ассемблерный код, а затем уже ассемблер переводит ее в машинный код.</p>
  <p>Для каждой разновидности процессора, со своим набором команд, пишут свой ассемблер и свой компилятор, а затем пишут для него программы на языке высокого уровня. Это ускоряет процесс программирования, такие программы более надежны и понятны, их легко выполнить на других компьютерах с другими командами процессора, для которых также написаны ассемблер и компилятор.</p>
  <p>Язык Си был написан в начале 70-х годов опытными программистами Денисом Ритчи и Кеном Томпсоном и стал очень популярным. Язык Си - язык профессиональных программистов.</p>
</article>


<!-- 1.4 Первая программа на Си -->
<article class="article">
  <div class="anchor" id="p1.4"></div>
  <h3>1.4 Первая программа на Си (9)</h3>

  <p>Напишем программу, которая скалдывает два числа</p>

  <details>
    <summary>Программа 1 (10)</summary>
<pre>
int main() {
  int first, second, sum;
  first = 2;
  second = 3;
  sum = first + second;
}
</pre>
  </details>
</article>


<!-- 2 Первые шаги -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>2 Первые шаги (12)</h3>
</article>


<!-- 2.1 Турбо Си - среда программирования -->
<article class="article">
  <div class="anchor" id="p2.1"></div>
  <h3>2.1 Турбо Си - среда программирования (12)</h3>

  <p>Мы выберем компилятор Turbo C 2.01 фирмы Borland для компьютера IBM PC. Компилятор Turbo C 2.01 распространяется бесплатно.</p>

  <h4>Установка компилятора Turbo C 2.01</h4>
  <ol>
    <li>
      Скачать файл
      <code><a href="http://community.borland.com/article/images/20841/tc201.zip">http://community.borland.com/article/images/20841/tc201.zip</a></code>
    </li>
    <li>Распаковать архив tc201.zip в папку <strong>tc</strong>. Появятся три новых папки DISC1, DISC2, DISC3. Переписать содержимое из трех папок DISC1, DISC2, DISC3 в одну папку tc</li>
    <li>Запустить программу install.exe</li>
  </ol>

  <p>Запустим установленную программу</p>
  <code>c:\tc\tc</code>
<p>Появится черное окно редактора, в котором можно писать программу на языке Си. Напишем в редакторе нашу Программу 1.</p>
<p>Программу можно выполнять по шагам и при этом следить за состоянием переменных. Чтобы следить за переменной first, подведем к ней курсор, нажмем CTRL+F7 (или ALT+B чтобы попасть в меню BREAK/WATCH и выбрать там пункт Add watch Ctrl-F7). На экране появится окно Add Watch с именем переменной. При нажатии Enter переменная окажется в нижней части окна под заголовком Watch.</p>
<p>Теперь программу можно выполнить по шагам. Каждому нажатию клавиши F8 соответствует один шаг.</p>
</article>


<!-- 2.2 Связь с внешним миром -->
<article class="article">
  <div class="anchor" id="p2.2"></div>
  <h3>2.2 Связь с внешним миром (16)</h3>

  <p>Дополним программу 1 функцией printf() и строкой #include &lt;stdio.h&gt;</p>

  <details>
    <summary>Программа 2 (17)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int first, second, sum;
  first = 2;
  second = 3;
  sum = first + second;
  printf("sum = %d\n", sum);
  printf("first = %d second = %d sum = %d\n", first, second, sum);
}
</pre>
  </details>
</article>


<!-- 2.3 Простые вычисления -->
<article class="article">
  <div class="anchor" id="p2.3"></div>
  <h3>2.3 Простые вычисления (20)</h3>

  <p>Напишем программу, выполняющую арифметические действия</p>

  <details>
    <summary>Программа 3 (20)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int fst = 2, scnd = 3;
  int df, prd, qt, rm;
  df = fst - scnd;
  prd = fst * scnd;
  qt = fst / scnd;
  fst = 123;
  scnd = 17;
  rm = fst % scnd;
  printf("%d %d %d %d\n", df, prd, qt, rm);
}
</pre>
  </details>
</article>


<!-- 2.4 В чем преимущество программ -->
<article class="article">
  <div class="anchor" id="p2.4"></div>
  <h3>2.4 В чем преимущество программ (22)</h3>

  <p>Напишем программу считающую сумму всех чисел от 1 до 100</p>

  <details>
    <summary>Программа 4 (25)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int sum, i;
  sum = 0;
  i = 1;
  while (i &lt;= 100) {
    sum += i;
    i++;
  }
  printf("sum = %d\n", sum);
}
</pre>
  </details>
</article>


<!-- 2.5 Массивы -->
<article class="article">
  <div class="anchor" id="p2.5"></div>
  <h3>2.5 Массивы (26)</h3>

  <p>Массив это ряд переменных, у каждой из которых есть специальным номер или индекс. Номера переменных в массиве идут по порядку и начинаются с нуля. Массивы позволяют перейти к следующему числу за счет увеличения индекса на 1. Произвольные 10 чисел в массиве так же легко сложить, как идущие подряд числа от 1 до 10.</p>

  <details>
    <summary>Программма 5 (27)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int nums[10] = {5,3,2,4,6,7,11,17,0,13};
  int sum, i;
  sum = 0;
  i = 0;
  while (i &lt; 10) {
    sum += nums[i];
    i++;
  }
  printf("sum = %d\n", sum);
}
</pre>
  </details>

  <p>Числа в массиве можно не только складывать. Напишем программу, которая находит максимальное число в массиве.</p>

  <details>
    <summary>Программа 6 (28)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int nums[10] = {5,3,2,4,6,7,11,17,0,13};
  int max, i;
  max = nums[0];
  i = 1;
  while (i &lt; 10) {
    if (nums[i] > max) {
      max = nums[i];
    }
    i++;
  }
  printf("max = %d\n", max);
}
</pre>
  </details>

  <p>Если заранее известно число итераций цикла, удобнее использовать цикл for. Найдем минимальное число в массиве</p>

  <details>
    <summary>Программа 7 (29)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int nums[10] = {5,3,2,4,6,7,11,17,0,13};
  int min;
  min = nums[0];
  for (int i = 1; i &lt; 10; i++) {
    if (nums[i] &lt; min) {
      min = nums[i];
    }
  }
  printf("min = %d\n", min);
}
</pre>
  </details>

  <p>Расставим элементы в массиве в порядке возрастания. Эта задача называется сортировкой. Сначала найдем максимальный элемент и поставим его в конец массива. Потом найдем максимальный из оставшихлся элементов и т.д.</p>

  <details>
    <summary>Программа 8 (31)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int n = 10;
  int nums[] = {5,3,2,4,6,7,11,17,0,13};
  int i, j;
  for (i = n - 1; i > 0; i--) {
    int max = 0;
    for (j = 1; j &lt;= i; j++) {
      if (nums[j] > nums[max]) {
        max = j;
      }
    }
    int temp = nums[i];
    nums[i] = nums[max];
    nums[max] = temp;
  }

  for (i = 0; i &lt; n; i++) {
    printf("%d ", nums[i]);
  }
}
</pre>
  </details>

  <p>Поменяем местами две переменные a и b, не используя временную переменную temp</p>

  <details>
    <summary>Программа 9 (33)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int a = 8, b = 11;
  a = a + b;
  b = a - b;
  a = a - b;

  printf("a = %d\nb = %d\n", a, b);
}
</pre>
  </details>
</article>


<!-- 2.6 Как это делается -->
<article class="article">
  <div class="anchor" id="p2.6"></div>
  <h3>2.6 Как это делается (34)</h3>

  <p>Как написать программу сортировки массива. Сначала приходит идея найти максимальный элемент, затем найти следующий максимальный элемент и так далее пока все элементы на встанут на свои места. Но куда девать найденные максимумы? Как не использовать дополнительный массив, а сортировать на месте? Для этого будем помещать найденный максимум в конец массива, а элемент из конца массива помещать туда где нашли максимум.</p>
  <p>Такая программа должна состоять из двух вложенных циклов. В первом цикле идем от конца массива и каждый раз в текущий элемент будем записывать найденный максимум. Во внутреннем цикле идем от начала и до элемента в который будем класть максимум. Во внутреннем цикле ищется максимальный элемент.</p>
</article>


<!-- 3 Странные типы -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>3 Странные типы (42)</h3>
</article>


<!-- 3.1 Странные типы-1 -->
<article class="article">
  <div class="anchor" id="p3.1"></div>
  <h3>3.1 Странные типы-1 (42)</h3>

  <p>int - целое число. float - дробное число, округленное с некоторой точностью. Округление возникает из-за ограниченной памяти на хранение одной переменной. В памяти компьютера дробные числа хранятся в двух целых числах - мантиса занимает 6 знаков, а порядок - число от -37 до +37</p>
  <code>0.00001 = 1E-5</code>

  <details>
    <summary>Программа 10 (42)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  float a, b = 2.0;
  int c = 3;
  a = b / c;

  printf("a = %f\n", a);
}
</pre>
  </details>

  <p>Оператор sizeof() возвращает число байт в указанной переменной</p>
  <p>Целые числа по умолчанию имеют тип int. Тип long помечается буквой l в конце числа</p>
  <p>Дробные числа по умолчанию имеют тип double. Тип float помечается буквой f в конце числа</p>

  <details>
    <summary>Программа 11 (44)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char a;
  int b;
  long c;
  float d;
  double e;

  a = sizeof(char);
  printf("Size char = %d\n", a);
  a = sizeof(int);
  printf("Size int = %d\n", a);
  a = sizeof(long);
  printf("Size long = %d\n", a);
  a = sizeof(float);
  printf("Size float = %d\n", a);
  a = sizeof(double);
  printf("Size double = %d\n", a);
}
</pre>
  </details>
</article>


<!-- 3.2 Странные типы-2 -->
<article class="article">
  <div class="anchor" id="p3.2"></div>
  <h3>3.2 Странные типы-2 (45)</h3>

  <p>Компьютер, на котором создавался язык Си, имел всего 24 килобайта оперативной памяти. Поэтому для экономии памяти существуют различные типы данных. Если нужно указать что число беззнаковое, то в конце него ставится буква u.</p>
</article>


<!-- 3.3 Анатомия типов -->
<article class="article">
  <div class="anchor" id="p3.3"></div>
  <h3>3.3 Анатомия типов (47)</h3>

  <p>Все целые числа хранятся в памяти одинаково. Рассмотрим как они хранятся на примере типа char размером 1 байт.</p>
  <p>Сначала посмотрим на беззнаковый тип. Значения переменной unsigned char могут быть от 0 до 255. В двоичном виде от 00000000 до 11111111. В шестнадцатеричном от 00 до FF. Если к 255 прибавить 1, то значение будет равно 0.</p>
  <p>Шестнадцатеричные числа записываются константами, которые начинаются с 0x. Используются когда важно не значение числа, а расположение его бит.</p>

  <details>
    <summary>Программа 12 (50)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int i;
  i = 0xFF;
  printf("%d\n", i);
}
</pre>
  </details>

  <p>Теперь посмотрим на числа со знаком. Знак числа хранится в старшем разряде. Если там 0 то число положительное, если 1 - отрицательное. Сумма положительного и отрицательного числа, равных по величине, равня 0.</p>
  <p>Программа 13 будет работать вечно потому что переменная unsigned char никогда не примет значение больше чем 255.</p>

  <details>
    <summary>Программа 13 (52)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  unsigned char i;
  // бесконечный цикл
  for (i = 0; i &lt;= 255; i++) {
    printf("%d\n", i);
  }
}
</pre>
  </details>

  <p>Компилятор не может и не хочет обнаруживать такие ошибки. Язык Си создавался для программистов, которым не нужно мешать надоедливыми проверками и предупреждениями. Компилятор считает что программист хорошо знает что делает.</p>
</article>


<!-- 3.4 Подбирайте выражения -->
<article class="article">
  <div class="anchor" id="p3.4"></div>
  <h3>3.4 Подбирайте выражения (53)</h3>

  <p>Использование переменных разных типов экономит память и ускоряет выполнение программ. Но нужно хорошо понимать как переменные взаимодействуют друг с другом.</p>
  <p>При делении одного целого числа на другое, результат будет целое число (дробная часть просто отбрасывается) даже если результат присваивается в переменную типа double.</p>
  <p>Чтобы в переменной оказалось дробное число, нужно чтобы одно из чисел было дробное. Когда производится операция над переменными разного типа, то более узкий тип приводится к более широкому.</p>

  <details>
    <summary>Программа 14 (54)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int a = 2;
  int b = 3;
  float c;
  c = a / b;
  printf("%f\n", c);
  c = 2.0 / b;
  printf("%f\n", c);
  c = a / (float)b;
  printf("%f\n", c);
}
</pre>
  </details>

  <p>В операции c = 2.0 / b; компилятор создаст временную переменную (копию переменной b), преобразует ее в тип float, выполнит операцию деления и результат запишется в переменную c. Сама переменная b останется неизменной.</p>
  <p>Используя явное приведение типов, можно самому приводить переменную к нужному типу. Операция (float)b приведет переменную b к типу float</p>
  <p>При операциях с целыми числами, если результат не помещается в переменнойт того же типа, то происходит переполнение. в результате приведения или переполнения могут быть потери. Бывает что переменную одного типа нельзя привести к другому типу без потерь.</p>

  <details>
    <summary>Программа 15 (56)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  unsigned char ch1 = 0xFF;
  signed char ch2 = 0xFF;
  int i;
  i = ch1;
  printf("%d\n", i); // 255
  i = ch2;
  printf("%d\n", i); // -1
  printf("%u\n", i); // 4294967295
}
</pre>
  </details>
</article>


<!-- 3.5 Строки и символы -->
<article class="article">
  <div class="anchor" id="p3.5"></div>
  <h3>3.5 Строки и символы (57)</h3>

  <p>Строки состоят из символов. Один символ кодируется восемью битами и может храниться в переменной типа char. Строки пишутся в двойных кавычках, символы - в одинарных. Для компьютера символ это просто двоичное число, занимающее 1 байт. Есть и невидимые символы, которые можно записать используюя обратный слеш, например '\n'.</p>
  <code>char ch1 = 'a';</code>
  <code>char ch2 = '\n';</code>
  <p>Поскольку строка состоит из символов, то ее кодируют используя массив типа char.</p>
  <code>char s1[4] = {'m','a','m','a'};</code>
  <p>В цикле, зная длину массива, можно вывести строку, записанную в массиве символов</p>

  <details>
    <summary>Программа 16 (58)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char s[4] = {'m','a','m','a'};
  for (int i = 0; i &lt; 4; i++) {
    printf("%c", s[i]);
  }
}
</pre>
  </details>

  <p>Если последним символом в массив записать символ-терминатор, то можно вывести строку не зная ее длины.</p>
  <code>char s2[5] = {'m','a','m','a','\0'};</code>

  <details>
    <summary>Программа 17 (59)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char s[5] = {'m','a','m','a','\0'};
  int i = 0;
  while (s[i] != '\0') {
    printf("%c", s[i]);
    i++;
  }
}
</pre>
  </details>

  <p>Строка состоит из символов, заключенных в двойные кавычки и завершается символом '\0'. Чтобы записать строку в массив, надо присвоить строку массиву символов.</p>
  <code>char s3[] = "mama";</code>
  <p>Компилятор здесь создаст массив из пяти символов, последним символом он допишет '\0'.</p>

  <details>
    <summary>Программа 18 (60)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char s[] = "mama";
  int i = 0;
  while (s[i]) {
    printf("%c", s[i]);
    i++;
  }
}
</pre>
  </details>

  <p>Есть спецификатор для печати строк %s. Поэтому улучшенный вид программы примет короткий вид.</p>

  <details>
    <summary>Программа 19 (61)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char s[] = "mama";
  printf("%s", s);
}
</pre>
  </details>
</article>


<!-- 3.6 Указатели -->
<article class="article">
  <div class="anchor" id="p3.6"></div>
  <h3>3.6 Указатели (62)</h3>

  <p>Имя массива указывает на ячейку памяти, где начинается массив. Адрес ячейки памяти можно передать и другим способом, через <strong>указатель</strong>. Перед тем как использовать указатель, его надо объявить. Чтобы объявить указатель, перед его именем ставится звездочка *.</p>
  <code>char *ps = "mama";</code>
  <p>Выведем слово mama используя указатель</p>

  <details>
    <summary>Программа 20 (62)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char *ps = "mama";
  printf("%s", ps);
}
</pre>
  </details>

  <p>Можно объявить указатель не только на строку, но и на другую переменную. Объявим указатель на адрес где хранится целое число. Сам адрес можно записать позже, используя оператор &.</p>
  <code>int *pa;</code>
  <p>Оператор взятия адреса & пишется перед переменной и возвращает адрес переменной</p>
  <p>Оператор разименования * пишется перед указателем и возвращает значение переменной</p>
  <p>Объявим переменную a целого типа и указатель pa на переменную целого типа. Запишем в указатель pa адрес переменной a. Изменим значение на которое указывает указатель pa и выведем значение переменной a.</p>

  <details>
    <summary>Программа 21 (63)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int a;
  int *pa;
  a = 2;
  pa = &a;
  *pa = 3;
  printf("%d\n", a);
}
</pre>
  </details>
</article>


<!-- 4 Действия -->
<article class="article">
  <div class="anchor" id="p4"></div>
  <h3>4 Действия (65)</h3>
</article>


<!-- 4.1 Очередность -->
<article class="article">
  <div class="anchor" id="p4.1"></div>
  <h3>4.1 Очередность (65)</h3>

  <p>Оператор инкремента ++ увеличивает на 1 значение переменной. Оператор декремента -- уменьшает на 1 значение переменной. Префиксная и постфиксная формы действуют одинаково на одиноко стоящую переменную. Но если переменная участвует в выражении, то результат окажется разным. В префиксной форме переменная сначала увеличит свое значение на 1, потом будет использована в выражении. В постфиксной форме переменная сначала будет использована в выражении, потом будет увеличина на 1.</p>

  <details>
    <summary>Программа 22 (67)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int i, j, x, y;
  i = 1;
  j = 1;
  x = ++i;
  y = j++;
  printf("x=%d y=%d\n", x, y);
  printf("i=%d j=%d\n", i, j);
}
</pre>
  </details>

  <p>В стандарте языка Си не определено какое слагаемое вычисляется первым. Один компилятор вычислит сначала a потом b, другой сначала b потом a</p>
  <code>x = a + b;</code>
  <p>Поэтому результат выражения может быть непредсказуемым</p>
  <code>x = ++i + i;</code>
  <p>Поэтому если в выражении используется префиксный оператор инкремента или декремента перед переменной, то эта переменная должна встречаться в этом выражении ровно один раз.</p>
</article>


<!-- 4.2 Условность -->
<article class="article">
  <div class="anchor" id="p4.2"></div>
  <h3>4.2 Условность (65)</h3>

  <p>Результат логической операции это число 1 (истина) или 0 (ложь). Поэтому логические и арифметические операции можно смешивать</p>
  <code>i = 10 > 5; // i = 1</code>
  <code>j = 5 > 6; // j = 0</code>

  <p>Следующая программа покажет как работают логические операторы && и ||.</p>

  <details>
    <summary>Программа 23 (70)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int i, j;
  for (i = 0; i &lt; 2; i++) {
    for (j = 0; j &lt; 2; j++) {
      printf("%d && %d = %d ", i, j, i && j);
      printf("%d || %d = %d\n", i, j, i || j);
    }
  }
}
</pre>
<pre>
0 && 0 = 0 0 || 0 = 0
0 && 1 = 0 0 || 1 = 1
1 && 0 = 0 1 || 0 = 1
1 && 1 = 1 1 || 1 = 1
</pre>
  </details>
</article>


<!-- 4.3 Работа с указателями -->
<article class="article">
  <div class="anchor" id="p4.3"></div>
  <h3>4.3 Работа с указателями (72)</h3>

  <p>Напишем программу суммирования всех элементов массива.</p>

  <details>
    <summary>Программа 24 (72)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int nums[10] = {5,3,2,4,6,7,11,17,0,13};
  int sum;
  int *p;
  p = &nums[0];
  for (int i = 0; i &lt; 10; i++) {
    sum += *p;
    p++;
  }
  printf("sum = %d\n", sum);
}
</pre>
  </details>
  <p>Операция ++ применяется к указателям не так как к переменным.</p>
  <p>Операция ++ для переменной увеличит ее значение на 1. Прибавляя целове число к переменно мы увеличиваем ее значение.</p>
  <p>Операция ++ для указателя увеличивает адрес, на который он указывает, до адреса следующего элемента. К указателям можно прибавлять целые числа. Прибавляя целое число N к указателю мы переместим адрес на N элементов вперед. В зависимости от типа указателя, от размера типа это может быть один, два, четыре и т.д. байта. Обычно такие операции используют для указателя на элементы массива, которые расположены в памяти друг за другом и имеют одинаковый тип.</p>
  <p>Если указатель выходит за пределы массива то он будет показывать неизвестно куда.</p>
  <p>Указатели, ссылающиеся на элементы одного и того же массива, можно сравнивать. Равные указатели ссылаются на один и тот же элемент. Меньший указатель ссылается на элемент, стоящий левее.</p>
</article>


<!-- 4.4 Битовые операциии -->
<article class="article">
  <div class="anchor" id="p4.4"></div>
  <h3>4.4 Битовые операции (74)</h3>

  <p>В программах есть значения всего с двумя состояниями. Для их хранения достаточно переменной размеров в 1 бит. Но минимальный размер ячейки памяти к которой может обратиться компьютер составляет 1 байт (8 бит). Если их много, то жалко тратить на каждую из них 1 байт.</p>
  <p>Чтобы решить эту проблему можно упаковать в один байт несколько таких переменных и использовать битовые операции для доступа к отдельным битам таких переменных. Если переменных не больше 8 то используют тип unsigned char</p>
  <p>Пусть у нас есть однобайтовая переменная со значением 00010001. Узнаем чему равен ее пятый бит. Биты нумеруются справа налево, от младшего к старшему. Изготовим специальную маску - переменную в которой все биты кроме пятого равны нулю 00010000. В программах такие переменные и их маски записываются в шестнадцатеричном виде.</p>

  <details>
    <summary>Программа 25 (75)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  unsigned char x, mask;
  x = 17;       // 00010001
  mask = 0x10;  // 00010000
  if (x & mask) {
    printf("=1");
  } else {
    printf("=0");
  }
}
</pre>
  </details>

  <code>x = 17; mask = 0x10; // x = 00010001, mask = 00010000</code>
  <p>Побитовое И</p>
  <code>x & mask; // 00010000</code>
  <p>Побитовое ИЛИ</p>
  <code>x | mask; // 00010001</code>
  <p>Побитовое исключающее ИЛИ</p>
  <code>x ^ mask; // 00000001</code>
  <p>Побитовый сдвиг вправо</p>
  <code>x >> 2; // 000000100</code>
  <p>Побитовый сдвиг влево</p>
  <code>x &lt;&lt; 1; // 000100010</code>
  <p>Побитовое отрицание</p>
  <code>~x; // 11101110</code>

  <p>Посмотрим как побитовые операторы работают в программе</p>
  <details>
    <summary>Программа 26 (77)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  unsigned char x, y;
  x = 17;  // 00010001
  y = 16;  // 00010000
  printf("x=%d y=%d\n", x, y);
  printf("x&y=%d\n", x&y);
  printf("x|y=%d\n", x|y);
  printf("x^y=%d\n", x^y);
  printf("x>>2=%d\n", x>>2);
  printf("x&lt;&lt;1=%d\n", x&lt;&lt;1);
  printf("~x=%u\n", ~x);
}
</pre>
  </details>

  <p>Посмотрим что делают инструкции</p>
  <code>a ^= b; b ^= a; a ^= b;</code>
  <details>
    <summary>Программа 27 (77)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  unsigned char a, b;
  a = 8;   // 00001000
  b = 15;  // 00001111
  printf("a=%d b=%d\n", a, b);
  a ^= b;
  b ^= a;
  a ^= b;
  printf("a=%d b=%d\n", a, b);
}
</pre>
<pre>
a=8 b=15
a=15 b=8
</pre>
  </details>
</article>


<!-- 4.5 Функции -->
<article class="article">
  <div class="anchor" id="p4.5"></div>
  <h3>4.5 Функции (80)</h3>

  <p>Напишкм функцию, скалдывающую два целых числа</p>
  <details>
    <summary>Программа 28 (81)</summary>
<pre>
#include &lt;stdio.h&gt;

int add(int, int);

int main() {
  int i, j, sum;
  i = 2;
  j = 3;
  sum = add(i, j);
  printf("%d\n", sum);
}

int add(int x, int y) {
  return x + y;
}
</pre>
  </details>

  <p>Сначала пишется <strong>заголовок</strong> функции. В заголовке указан тип возвращаемого значения функции, количество и тип ее аргументов. После пишется <strong>тело</strong> функции в фигурных скобках.</p>
  <p>Аргументы функции это переменные которые передаются в функцию при ее вызове (в программе выше это i и j). При каждом вызове могут быть переданы разные аргументы</p>
  <p>Параметры функции это то что записано в заголовке функции (в программе выше это x и y). Это переменные которые создаются каждый раз при вызове функции, в них копируется значение аргументов, с которыми была вызвана функция. Когда функция возвращает результат, она заканчивает свою работу и параметры уничтожаются.</p>
  <p>Функция не может изменить аргументы, она работает только с параметрами. Проверим это в следующей программе.</p>
  <details>
    <summary>Программа 29 (82)</summary>
<pre>
#include &lt;stdio.h&gt;

void change(int);

int main() {
  int i;
  i = 2;
  printf("i=%d\n", i);
  change(i);
  printf("after function i=%d\n", i);
}

void change(int i) {
  i += 3;
  printf("in function i=%d\n", i);
}
</pre>
  </details>

  <p>Функции пишут, чтобы она выполняла определенную часть работы. Написанные функции можно использовать в других программах. Например, стандартные функции языка Си.</p>
  <p>Функция main() главная в программе. Она возвращает значение тому,кто главнее, то есть запустившей ее процедуре операционной системы.</p>
</article>


<!-- 4.6 Функции с длинными руками -->
<article class="article">
  <div class="anchor" id="p4.6"></div>
  <h3>4.6 Функции с длинными руками (84)</h3>

  <p>При передаче переменной (аргумента) в функцию, ее <strong>значение</strong> копируется в переменную (параметр) того же типа и дальше функция работает со <strong>значением</strong> которое было во внешней переменной. Саму внешнюю переменную функция изменить никак не может.</p>
  <p>При передаче указателя в функцию, его значение (адрес который в нем записан) копируется в другой указатель (созданный во время вызова функции как ее параметр). Сам адрес, записанный в указателе (аргументе) функция изменить никак не может. Но она может менять значение переменной, записанной по этому адресу.</p>

  <details>
    <summary>Программа 30 (85)</summary>
<pre>
#include &lt;stdio.h&gt;

void change(int*);

int main() {
  int i;
  i = 2;
  printf("i=%d\n", i);
  change(&i);
  printf("after function i=%d\n", i);
}

void change(int *a) {
  *a += 3;
  printf("in function a=%d\n", *a);
}
</pre>
  </details>
  <p>Если внутри функции увеличить значение указателя на 1, то можно изменить соседнюю переменную. Но функция ничего не знает о внешних переменных и не известно на что будет указывать измененный указатель.</p>
  <p>Функция scanf() принимает указатели, поэтому мы передаем в нее адреса переменных. А функция scanf() записывает по этим адресам числа, введенные с клавиатуры. Если бы функция scanf() принимала переменные, то она не могла бы в них ничего записать, потому что никакая функция не может менять внешние переменные</p>

  <p>Напишем программу которая принимает от пользователя два целых числа разделенных пробелом и выводит их сумму</p>

  <details>
    <summary>Программа 31 (86)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int a, b;
  scanf("%d %d", &a, &b);
  printf("%d\n", a+b);
}
</pre>
  </details>

  <p>Функция не может менять внешние переменные. У нее для этого "руки коротки". С помощью указателя функция может дотянуться до чего угодно. Указатели дают функциям "длинные руки". Но при помощи ключевого слова <strong>const</strong> это руки можно "укортить". Например, если указатель передается в функцию как константа, то менять его значение не позволит компилятор.</p>
  <code>void change(const int *a) { a += 3; }</code>
  <p>Компилятор выдаст сообщение об ошибке - объект на который ссылается указатель постоянный и не может быть изменен</p>
  <p>Не следует использовать const если назначение функции - изменить переменную переданную через указатель. Слово const используют если нужно только читать переменную, зная указатель на нее. В этом случае слово const делает программу надежней и безопасней.</p>
</article>


<!-- 4.7 Рекурсия или раз, два, три  -->
<article class="article">
  <div class="anchor" id="p4.7"></div>
  <h3>4.7 Рекурсия или раз, два, три  (87)</h3>

  <p>Задача вывести на экран три числа</p>

  <details>
    <summary>Программа 32 (88)</summary>
<pre>
#include &lt;stdio.h&gt;

void CountTo3(int);
void CountTo2(int);
void CountTo1(int);

int main() {
  CountTo3(3);
}

void CountTo3(int p) {
  CountTo2(p-1);
  printf("%d\n", p);
}

void CountTo2(int p) {
  CountTo1(p-1);
  printf("%d\n", p);
}

void CountTo1(int p) {
  printf("%d\n", p);
}
</pre>
<pre>
1
2
3
</pre>
  </details>

  <p>Функции, которые вызывают сами себя, называюся рекурсивными.</p>

  <details>
    <summary>Программа 33 (91)</summary>
<pre>
#include &lt;stdio.h&gt;

void CountTo(int);

int main() {
  CountTo(3);
}

void CountTo(int p) {
  if (p > 0) {
  CountTo(p-1);
  printf("%d\n", p);
  }
}
</pre>
<pre>
1
2
3
</pre>
  </details>
  <p>Несколько раз вызывается функция, которая называется так же как вызывающая. На самом деле она другая. У нее создаются свои переменные, независимо от переменных вызвавшей функциии. Эти переменные никак не связаны.</p>
  <p>При рекурсии сначала функции будут по очереди вызываться, будут создаваться переменные для каждой функции. Закончив свою работу, функции будут по очереди завершаться, удаляя свои переменные.</p>
  <p>В каждой рекурсивной функции обязательно должно быть условие для ее завершения. Вызов каждой копии функции требует памяти для хранения переменных. Для этого выделяется память в стеке вызова. Когда память в стеке вызова заканчивается, то программма завершится аварийно.</p>
  <p>Напишем программу с рекурсивной функцией, которая складывает все числа от 1 до 100.</p>

  <details>
    <summary>Программа 34 (94)</summary>
<pre>
#include &lt;stdio.h&gt;

int sum(int);

int main() {
  int s = sum(100);
  printf("%d\n", s);
}

int sum(int n) {
  if (n == 1) {
    return 1;
  } else {
    return sum(n-1) + n;
  }
}
</pre>
<pre>
5050
</pre>
  </details>
</article>


<!-- 5 Функции, указатели, массивы -->
<article class="article">
  <div class="anchor" id="p5"></div>
  <h3>5 Функции, указатели, массивы (96)</h3>
</article>


<!-- 5.1 Функции и массивы -->
<article class="article">
  <div class="anchor" id="p5.1"></div>
  <h3>5.1 Функции и массивы (96)</h3>

  <p>Мы передаем в функции переменные когда необходимо только читать их значения. Мы передаем в функции указатели когда необходимо менять переменные, на которые они указывают. Чтобы передать фунции массив, достаточно передать указатель на нулевой элемент массива и число элементов в нем. Тогда функция сможет менять указатель в безопасных пределах и получит полный доступ к любому элементу массива.</p>
  <p>Напишем функцию, которая принимает массив, а возвращает максимальный элемент из него.</p>

  <details>
    <summary>Программа 35 (97)</summary>
<pre>
#include &lt;stdio.h&gt;

int maxi(int*, int);

int main() {
  int nums[10] = {5,3,2,4,6,7,11,17,0,13};
  int m = maxi(&nums[0], 10);
  printf("%d\n", m);
}

int maxi(int *a, int n) {
  int max = *a;
  for (int i = 1 ; i &lt; n ; i++) {
    if(*(a + i) > max) {
      max = *(a + i);
    }
  }

  return max;
}
</pre>
  </details>
</article>


<!-- 5.2 Массивы и указатели -->
<article class="article">
  <div class="anchor" id="p5.2"></div>
  <h3>5.2 Массивы и указатели (98)</h3>

  <p>В функцию вместо указателя на начало строки можно передать имя строки, а вместо указателя на первый элемент массива, можно передать имя массива. Это одно и то же.</p>
  <p>Компилятор рассматривает имя массива как адрес его нулевого элемента, а имя строки как указатель на ее нее. Для компилятора имя массива это указатель. Встретив элемент массива arr[i], компилятор преобразует его по правилам работы с указателями *(arr + i). Сумма arr + i указывает на i-й элемент массива, а оператор * возвращает значение этого элемента.</p>
  <p>Массив и возможные действия с его элементами:</p>
  <code>x[3] = {13,28,5};</code>
  <code>x[0]; // 13</code>
  <code>x[1]; // 28</code>
  <code>x[2]; // 5</code>
  <code>x; // адрес нулевого элемента</code>
  <code>*x; // 13</code>
  <code>x+1; // адрес первого элемента</code>
  <code>*(x+1); // 28</code>
  <code>x+2; // адрес ыторого элемента</code>
  <code>*(x+2); // 5</code>
  <code>&(x[0]); // x, адрес нулевого элемента</code>
  <code>*&(x[0]); // 13</code>
  <p>Адрес нулевого элемента равен имени массива. Но это не одно и то же. Указатель можно изменить, а имя массива не может быть изменено. Например, указатель можно увеличить на 1, а изменить имя массива, чтобы оно указывало на следующий элемент нельзя. Имя массива всегда указывает в одно и то же место - на свой нулевой элемент.</p>
  <p>Посмотрим на два объявления строки, чтобы понять различие между указателями и массивами</p>
  <code>char a[] = "mama";</code>
  <p>В массиве a хранится 5 элементов: 4 буквы и символ-терминатор '\0'. Адрес нулевого элемента определяется во время компиляции, и в программе нет такой переменной, где бы он хранился. Везде вместо имени массива компилятор подставляет адрес нулевого элемента массива.</p>
  <code>char *p = "mama";</code>
  <p>В указателе p хранится адрес начала строки. Но в указатель p , как и в любую переменную , можно записать новое значение и тогда он будет указывать на что-то другое</p>
</article>


<!-- 5.3 Указатели и массивы -->
<article class="article">
  <div class="anchor" id="p5.3"></div>
  <h3>5.3 Указатели и массивы (100)</h3>

  <p>Адрес нулевого элемента массива можно передать настоящему указателю p.</p>
  <code>int *p = a[0];</code>
  <p>Этот указатель p, в отличие от имени массива, можно менять так, чтобы он указывал последовательно на все элементы массива</p>
  <p>Напишем программу, суммирующую все элементы массива.</p>

  <details>
    <summary>Программа 36 (101)</summary>
<pre>
#include &lt;stdio.h&gt;

int sum(int*, int);

int main() {
  int nums[10] = {5,3,2,4,6,7,11,17,0,13};
  int s = sum(&nums[0], 10);
  printf("%d\n", s);
}

int sum(int *a, int n) {
  int s = 0;
  for (int i = 0 ; i &lt; n ; i++) {
    s += *a++;
  }

  return s;
}
</pre>
  </details>
</article>


<!-- 5.4 Динамические массивы -->
<article class="article">
  <div class="anchor" id="p5.4"></div>
  <h3>5.4 Динамические массивы (102)</h3>

  <p>Функция malloc() выделяет непрерывный кусок памяти под массив для k идущих подряд переменных одного типа. Функция malloc() принимает число байт, занимаемых массивом и возвращает указатель на его нулевой элемент. Укзатель p указывает на нулевой элемент, p+1 на первый, p+2 на второй и т.д.*p хранит значение нулевого элемента, *(p+1) - значение первого элемента и т.д. p[i] это значение i-го элемента.</p>
  <p>Выделим память под массив int из 10 элементов</p>

  <details>
    <summary>Программа 37 (103)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
  int *p;
  p = malloc(10 * sizeof(int));
  if (p == NULL) {
    printf("not enough memory");
    return 1;
  }
  for (int i = 0; i &lt; 10; i++) {
    printf("%d\n", p[i]);
  }
  free(p);
}
</pre>
  </details>
  <p>Память выделенная с помощью malloc() после завершения работы с ней должна быть освобождена функцией free(). После этого указатель указывает на несуществующую область в памяти и попытка обратиться к ней приведет к краху программы.</p>
</article>


<!-- 5.5 Копирование строк -->
<article class="article">
  <div class="anchor" id="p5.5"></div>
  <h3>5.5 Копирование строк (105)</h3>

  <p>Память занятую обычным массивом int p[100] уже нельзя освободить. Размер такого массива еще нельзя и изменить. Это статический массив. А если заранее неизвестно число элементов в массиве, то память выделяют с запасом. А это некрасиво и расточительно.</p>
  <p>В отличие от статического массива, функция malloc() создает динамический массив, при этом выделяется ровно столько памяти сколько нужно. Функция free() освободит память, когда она станет не нужна.</p>

  <details>
    <summary>Программа 38 (106)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main() {
  char *p1 = "use malloc()";
  char *p2;
  if(NULL == (p2 = malloc(strlen(p1) + 1))) {
    printf("not enough memory\n");
    return 1;
  }
  for (int i = 0; i &lt;= strlen(p1); i++) {
    p2[i] = p1[i];
  }

  printf("%s\n", p2);
  free(p2);
}
</pre>
  </details>
</article>


<!-- 6 Файлы -->
<article class="article">
  <div class="anchor" id="p6"></div>
  <h3>6 Файлы (109)</h3>
</article>


<!-- 6.1 Падение железного занавеса -->
<article class="article">
  <div class="anchor" id="p6.1"></div>
  <h3>6.1 Падение железного занавеса (109)</h3>

  <p>Научимся работать с файлами. Создадим указатель на тип FILE</p>
  <code>FILE *in;</code>
  <p>Чтобы начать работать с файлом нужно его открыть</p>
  <code>in = fopen("name", "mode");</code>
  <p>где name это имя файла, а mode это режим в котором нужно его открыть.</p>
  <p>Если файл удалось открыть то переменную in можно передавать как параметр различным функциям, работающим с файлами. Если файл открыть не удалось то функция fopen() возвращает NULL.</p>
  <p>Каждый открытый файл нужно закрыть функцией fclose() после завершения работы с ним.</p>
  <p>Познакомимся с двумя функциями. Функция чтения строки из файла fgets() и функция записи строки в файл fputs()</p>
  <code>fgets(char * buf, int n, FILE *f)</code>
  <p>Функция fgets() использует внешнюю память, на которую указывает первый параметр buf. Эта память задается массивом или выделяется функцией malloc(). Второй параметр n ограничивает длину читаемой строки.  Функция fgets() прочитает n-1 символов, поставит в конце нулевой символ '\0' и перейдет к следующей строке. После успешного чтения каждой строки возвращает указатель на буфер, где эта строка хранится buf. Если достигнут конец файла или возникла ошибка, возвращает NULL.</p>
  <code>fputs(char *buf, FILE *f)</code>
  <p>Функция fputs() записывает строку из буфера buf в файл f. Перед записью символ '\0' удаляется.</p>
  <p>Напишем программу, которая берет файл с текстом программы на языке Си, читает его построчно в буфер. Добавляет в начале каждой строки символ табуляции. И записывает в новый файл программу на языке Си с символом табуляции вначале каждой строки</p>

  <details>
    <summary>Программа 39 (112)</summary>
<pre>
#include &lt;stdio.h&gt;
#define BSIZE 200

int main() {
  char buf[BSIZE];
  FILE *in, *out;
  in = fopen("39a.c", "rb");
  out = fopen("39b.c", "wb");
  buf[0] = '\t';
  while (fgets(buf+1, BSIZE-1, in) != NULL) {
    fputs(buf,out);
  }
  fclose(in);
  fclose(out);
}
</pre>
  </details>
</article>


<!-- 6.2 Массивы указателей -->
<article class="article">
  <div class="anchor" id="p6.2"></div>
  <h3>6.2 Массивы указателей (114)</h3>

  <p>Функция main() умеет читать командную строку, то есть параметры, введенные при вызове программы. В прошлом уроке мы написали программу, которая брала файл с текстом программы на языке Си, добавляла вначале каждой строки символ табуляции и записывала в другой файл. Пусть нам нужно, чтобы эта програма как параметры при вызове принимала имя исходного файла и файла результата.</p>
  <code>tabshift.exe src.c dst.c</code>
  <p>src.c и dst.c это два аргумента, которые передаются нашей программе tabshift.exe при ее вызове.</p>
  <code>int main(int argc, char *argv[])</code>
  <p>argc это число аргументов пришедших в программу. Всегда первый аргумент это имя файла программы. Поэтому в любой программе на языке Си есть хотя бы один аргумент. Остальные argc-1 аргументов это то что передали программе при ее вызове.</p>
  <p>*argv[] это массив указателей. Первый указатель argv[0] указывает на имя программы. Остальные указатели argv[1], argv[2] ... указывают на параметры командной строки.</p>
  <p>Напишем программу, которая выводит на экран все аргументы командной строки, число которых равно argc.</p>

  <details>
    <summary>Программа 40 (116)</summary>
<pre>
#include &lt;stdio.h&gt;

int main(int argc, char *argv[]) {
  for (int i = 0; i &lt; argc; i++) {
    printf("%s\n", argv[i]);
  }
}
</pre>
  </details>

  <p>Теперь напишем программу, которая принимает два имени файлов. Читает первый файл, добавляет в начало каждой строки символ табуляции и записывает результат во второй файл</p>

  <details>
    <summary>Программа 41 (117)</summary>
<pre>
#include &lt;stdio.h&gt;
#define BSIZE 200

int main(int argc, char *argv[]) {
  char buf[BSIZE];
  FILE *in, *out;
  if (argc &lt; 3) {
    printf("too small parameters\n");
    return 1;
  }
  in = fopen(argv[1], "rb");
  if (in == NULL) {
    printf("cannot open file %s\n", argv[1]);
    return 1;
  }
  out = fopen(argv[2], "wb");
  buf[0] = '\t';
  while (fgets(buf+1, BSIZE-1, in) != NULL) {
    fputs(buf,out);
  }
  fclose(in);
  fclose(out);
}
</pre>
  </details>

  <p>Программа сама проверит что количество аргументов не меньше трех и что первый файл существует и его можно открыть. Если второго файла нет, то программа создаст его. Если второй файл нет, то программа его уничтожит и создаст новый с тем же именем.</p>
  <p>Чтобы не был уничтожен нужный файл, напишем программу, которая будет проверять есть ли уже файл с таким именем и спрашивать удалить ли его.</p>

  <details>
    <summary>Программа 42 (118)</summary>
<pre>
#include &lt;stdio.h&gt;
#define BSIZE 200

int main(int argc, char *argv[]) {
  char buf[BSIZE];
  FILE *in, *out;
  if (argc &lt; 3) {
    printf("too small parameters\n");
    return 1;
  }
  in = fopen(argv[1], "rb");
  if (in == NULL) {
    printf("cannot open file %s\n", argv[1]);
    return 1;
  }

  int notexist, ans;
  notexist = 0;
  if ((out = fopen(argv[2], "rb")) == NULL) {
    notexist = 1;
    fclose(out);
  }
  if (notexist) {
    out = fopen(argv[2], "wb");
  } else {
    printf("delete file %s ? Y/N\n", argv[2]);
    ans = getchar();
    if (ans == 'Y' || ans == 'y') {
      out = fopen(argv[2], "wb");
    } else {
      return 1;
    }
  }

  buf[0] = '\t';
  while (fgets(buf+1, BSIZE-1, in) != NULL) {
    fputs(buf,out);
  }
  fclose(in);
  fclose(out);
}
</pre>
  </details>

  <p>Напишем программу, которая считывает символы введенные с клавиатуры и выводит их на экран, пока не встретится символ EOF (Ctrl+z)</p>

  <details>
    <summary>Программа 43 (120)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int c;
  while ((c = getchar()) != EOF) {
    putchar(c);
  }
}
</pre>
  </details>
</article>


<!-- 6.3 Указатели на указатели -->
<article class="article">
  <div class="anchor" id="p6.3"></div>
  <h3>6.3 Указатели на указатели (120)</h3>

  <p>Напишем немножко по-другому программу, которая выводит на экран все аргументы командной строки.</p>

  <details>
    <summary>Программа 44 (121)</summary>
<pre>
#include &lt;stdio.h&gt;

int main(int argc, char *argv[]) {
  char *p;
  while ((p=*argv++) != NULL) {
    printf("%s\n", p);
  }
}
</pre>
  </details>

  <p>В программе, char *argv[] это массив указателей на char, а argv это указатель на указатель. Если разименовать такой указатель, то *argv равен нулевому элементу массива, т.е. *argv = argv[0]</p>
  <code>char *argv[] это массив указателей на char</code>
  <code>argv это указатель на указатель</code>
  <code>*argv = argv[0] это нулевой элемент массива</code>
  <code>*(argv+1) = argv[1] это первый элемент массива</code>
  <code>*(argv+argc) = argv[argc] = NULL</code>
  <p>Указатель на указатель в языке Си объявляется с помощью двух звездочек **p. Поэтому параметры для функции main() можно переписать так</p>
  <code>int main (int argc, char **argv)</code>
  <p>argv указывает на нулевой элемент. К нему можно применить оператор * разименования. *argv это и есть нулевой элемент, то есть argv[0]. Но argv[0] это указатель на первый параметр командной строки.И к нему можно применить оператор * разименования. *(argv[0]) это и есть **argv.</p>
  <p>Нельзя путать указатель с массивом. Объявление указателя int **a выделяет память только для одного указателя. А массив *argv[] содержит несколько указателей на строки, да и сами строки.</p>
</article>


<!-- 6.4 Файлы - не массивы -->
<article class="article">
  <div class="anchor" id="p6.4"></div>
  <h3>6.4 Файлы - не массивы (123)</h3>

  <p>Перепишем программу, добавляющую табуляцую в начале строки. Будем брать входной файл, добавлять табуляцию в начало каждой строки и записывать во временный файл, потом временный файл запишем в исходный файл.</p>
  <p>Функция tmpfile() создает никому не мешающий временный файл с уникальным именем.</p>

  <details>
    <summary>Программа 45 (124)</summary>
<pre>
#include &lt;stdio.h&gt;
#define BSIZE 200

int main(int argc, char *argv[]) {
  char buf[BSIZE];
  int ch;
  FILE *in, *tmp;
  if (argc &lt; 2) {
    printf("too small parameters\n");
    return 1;
  }
  in = fopen(argv[1], "rb");
  if (in == NULL) {
    printf("cannot open file %s\n", argv[1]);
    return 1;
  }

  tmp = tmpfile();

  buf[0] = '\t';
  while (fgets(buf+1, BSIZE-1, in) != NULL) {
    fputs(buf, tmp);
  }
  fclose(in);

  in = fopen(argv[1], "wb");
  fseek(tmp, 0L, SEEK_SET);
  while ((ch = fgetc(tmp)) != EOF) {
    fputc(ch, in);
  }

  fclose(in);
  fclose(tmp);
}
</pre>
  </details>

  <p>Файлы - не массивы. Массив это структура данных с произвольным доступом. Мы можем запросто обратиться к любому его элементу nums[0], nums[10]. Чтобы прочитать десятую строку текста из файла, необходимо перед этим прочитать предыдущие девять строк. Файлы похожи на кассету. Чтобы прослушать десятую песню необходимо прослушать предыдущие девять или перемотать пленку.</p>
  <p>Функция fseek() предоставляет такую услугу - перематывает пленку до нужного места. При открытии файла, специальный флажок, указывающий на текущее место чтения или записи, указывает на самое начало файла. Прочитали одну строку - и флажок переместился к началу следующей строки. Когда прочитали все строки - флажок оказывается в конце файла и при чтении из конца файла, функция fgets() выдает NULL.</p>
  <p>То же самое при записи строк в файл. Строка записывается туда где стоит флажок. Записали строчку - и флажок переместился в ее конец.</p>
  <p>Перед тем как копировать временный файл в исходный, необходимо переместить флажок в начало.</p>
</article>


<!-- 6.5 Открытие файла -->
<article class="article">
  <div class="anchor" id="p6.5"></div>
  <h3>6.5 Открытие файла (126)</h3>

  <p>Если в режиме открытия файла дописать букву b, то файлы воспринимаются такими какие они есть. Без буквы b файлы считаются текстовыми. Это значит что при чтении и записи будут меняться служебные символы в конце каждой строки.</p>
  <p>Чтобы открыть файл сразу для чтения и записи, надо использовать режим "r+b". Тогда не нужно будет закрывать файл после его прочтения, чтобы записать в него строки из временного файла.</p>
  <p>Перепишем нашу прогламму добавления символа табуляции, используя режим октрытия файла "r+b"</p>

  <details>
    <summary>Программа 46 (128)</summary>
<pre>
#include &lt;stdio.h&gt;
#define BSIZE 200

int main(int argc, char *argv[]) {
  char buf[BSIZE];
  int act_read;
  FILE *in, *tmp;
  if (argc &lt; 2) {
    printf("too small parameters\n");
    return 1;
  }
  in = fopen(argv[1], "r+b");
  if (in == NULL) {
    printf("cannot open file %s\n", argv[1]);
    return 1;
  }

  tmp = tmpfile();

  buf[0] = '\t';
  while (fgets(buf+1, BSIZE-1, in) != NULL) {
    fputs(buf, tmp);
  }

  rewind(in);
  rewind(tmp);
  do {
    act_read = fread(buf, 1, BSIZE, tmp);
    fwrite(buf, 1, act_read, in);
  } while (act_read == BSIZE);

  fclose(in);
  fclose(tmp);
}
</pre>
  </details>

  <p>Отличие этой программы от предыдущей версии. Во-первых, входной файл открывается для чтения и записи. Во-вторых, для перемотки используется функция rewind(). В-третьих, используется цикл do-while, который копирует временный файл в исходный.</p>
  <p>Функция fread() читает BSIZE байт из временного файла и записывает их в буферный массив buf.</p>
  <p>В конце файла может оказаться меньше байт, чем BSIZE, поэтому функция fread() прочитает оставшиеся байты и вернет число реально прочитанных байт, которое запомнится в переменной act_read.</p>
  <p>Функция fwrite() пишет из буфера buf во входной файл in ровно столько байт, сколько сумела прочитать функция fread().</p>
  <p>Размер символа равен один байт, поэтому при чтении мы указывает в параметрах функции fread() вторым параметром 1, а третим параметром число символов BSIZE.</p>
  <code>fread(buf, 1, BSIZE, tmp)</code>
  <p>Переменная типа int занимает 4 байта, поэтому при чтении 200 переменных типа int мы укажем в параметрах функции fread() вторым параметром sizeof(int), а третим параметром 200</p>
  <code>fread(buf, sizeof(int), 200, tmp)</code>
</article>


<!-- 7 Строки -->
<article class="article">
  <div class="anchor" id="p7"></div>
  <h3>7 Строки (131)</h3>
</article>


<!-- 7.1 Считалочка -->
<article class="article">
  <div class="anchor" id="p7.1"></div>
  <h3>7.1 Считалочка (131)</h3>

  <p>Хранит строки в файл очень удобно: файл легко редактируется и вмещает сколько угодно слов. Начнем с задачи сортировки слов. Прежде чем писать программу сортировки целиком, создадим сначала программу чтения и хранения слов из файла. Как будем хранить слова? Переписывание с места на место длинных слов сильно загружает процессор и программа будет медленно.</p>
  <p>Размер указателя постоянен и не зависит от длины строки, на который он указывает.Можно менять местами указатели, а слова пусть остаются на месте. Заводим массив указателей на char (их число равно числу слов)</p>
  <p>Напишем программу которая прочитает слова из файла и по одному выведет их на экран</p>

  <details>
    <summary>Программа 47 (134)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#define BSIZE 200

int main(int argc, char *argv[]) {
  char buf[BSIZE];
  char *strgs[100];
  FILE *in;

  if (argc &lt; 2) {
    printf("too small parameters\n");
    return 1;
  }

  in = fopen(argv[1], "r+b");
  if (in == NULL) {
    printf("cannot open file %s\n", argv[1]);
    return 1;
  }

  int i = 0;
  while (fgets(buf, BSIZE-1, in) != NULL) {
    strgs[i] = malloc(strlen(buf) + 1);
    strcpy(strgs[i], buf);
    i++;
  }

  int nofl = i;
  // здесь будет Сортировка

  // вывод на экран
  for (int i = 0; i &lt; nofl; i++) {
    printf("%s", strgs[i]);
  }
}
</pre>
  </details>
</article>


<!-- 7.2 Сортировка строк -->
<article class="article">
  <div class="anchor" id="p7.2"></div>
  <h3>7.2 Сортировка строк (136)</h3>

  <p>Для сортировки строк используется их сравнение. Большей из двух строк будем считать строку, у которой первая отличающаяся буква стоит позже в алфавитном списке. Этому определению соответствует библиотечная функция strcmp(char *str1, char *str2), принимающая указатели на начала строк и возвращающая 0 если строки равны, положительную величину, если str1 > str2 и отрицательную если str1 &lt; str2.</p>

  <details>
    <summary>Программа 48 (137)</summary>
    <p>Почему то не сортирует</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#define BSIZE 200

int main(int argc, char *argv[]) {
  char buf[BSIZE];
  char *strgs[100];
  FILE *in;

  if (argc &lt; 2) {
    printf("too small parameters\n");
    return 1;
  }

  in = fopen(argv[1], "r+b");
  if (in == NULL) {
    printf("cannot open file %s\n", argv[1]);
    return 1;
  }

  int i = 0;
  while (fgets(buf, BSIZE-1, in) != NULL) {
    strgs[i] = malloc(strlen(buf) + 1);
    strcpy(strgs[i], buf);
    i++;
  }

  int nofl = i;
  // сортировка
  char *tmp;
  int mm;
  for (int i = nofl - 1; i >= 1; i--) {
    mm = 0;
    for (int j = 1; j &lt;= i; j++) {
      if (strcmp(strgs[j], strgs[mm]) > 0) {
        mm = j;
      }
    }
    tmp = strgs[i];
    strgs[i] = strgs[mm];
    strgs[mm] = tmp;
  }

  // вывод на экран
  for (int i = 0; i &lt; nofl; i++) {
    printf("%s", strgs[i]);
  }
}
</pre>
  </details>
</article>


<!-- 7.3 Указатель на функцию -->
<article class="article">
  <div class="anchor" id="p7.3"></div>
  <h3>7.3 Указатель на функцию (138)</h3>

  <p>Сортировку вынесем в отдельную функцию. Она будет принимать массив указателей и их число (число слов). Возвращать она ничего не будет. После ее выполнения массив указателей будет отсортирован.</p>

  <details>
    <summary>Программа 49 (139)</summary>
    <p>Почему то не сортирует</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#define BSIZE 200

void strsort(char *[], int);

int main(int argc, char *argv[]) {
  char buf[BSIZE];
  char *strgs[100];
  FILE *in;

  if (argc &lt; 2) {
    printf("too small parameters\n");
    return 1;
  }

  in = fopen(argv[1], "r+b");
  if (in == NULL) {
    printf("cannot open file %s\n", argv[1]);
    return 1;
  }

  int i = 0;
  while (fgets(buf, BSIZE-1, in) != NULL) {
    strgs[i] = malloc(strlen(buf) + 1);
    strcpy(strgs[i], buf);
    i++;
  }

  int nofl = i;
  // сортировка
  strsort(strgs, nofl);

  // вывод на экран
  for (int i = 0; i &lt; nofl; i++) {
    printf("%s", strgs[i]);
  }
}

void strsort(char *s[], int N) {
  char *tmp;
  int mm;
  for (int i = N - 1; i >= 1; i--) {
    mm = 0;
    for (int j = 1; j &lt;= i; j++) {
      if (strcmp(s[j], s[mm]) > 0) {
        mm = j;
      }
    }
    tmp = s[i];
    s[i] = s[mm];
    s[mm] = tmp;
  }
}
</pre>
  </details>

  <p>Функции для процессора - те же двоичные коды, и с виду они мало отличаются от строк или массивов. Они так же занимают последовательные ячейки памяти, где хранятся двоичные числа. Эту память процессор воспринимает как последовательность команд.</p>
  <p>Функции в качестве параметра можно передать другую функцию. Надо понимать что передается не сама функция, а адрес ее начала. Это указатель на нее. Чтобы задать указатель на функцию надо записать</p>
  <code>int (*f)(); // указатель на функцию возвращающую int</code>

  <p>Напишем программу, где используется указатель на функцию, возвращающую сумму двух целых чисел.</p>

  <details>
    <summary>Программа 50 (142)</summary>
<pre>
#include &lt;stdio.h&gt;

int sum(int, int);

int main() {
  int i = 2, j = 3, k;
  int (*f)(int, int);
  printf("%d\n", sum(i, j));
  f = &sum;
  printf("%d\n", (*f)(i, j));
}

int sum(int f, int s) {
  return f + s;
}
</pre>
  </details>

  <p>Объявление указателя на функцию</p>
  <code>int (*f)(int, int)</code>
  <p>только выделяет участок памяти для него. Разумное значение указателю на функцию придает оператор &. После присваивания</p>
  <code>f = &sum</code>
  <p>указатель f равен адресу с которого начинается функция sum().</p>
  <p>Теперь мы можем написать функцию сортировки, принимающую функцию сравнения строк в качестве параметра.</p>

  <details>
    <summary>Программа 51 (143)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int cmplen(char *s1, char *s2) {
  return (strlen(s1) - strlen(s2));
}

void strsort(char *s[], int N,
int (*cmp)(char *, char*)) {
  char *tmp;
  int mm;
  for (int i = N - 1; i >= 1; i--) {
    mm = 0;
    for (int j = 1; j &lt;= i; j++) {
      if ((*cmp)(s[j], s[mm]) > 0) {
        mm = j;
      }
    }
    tmp = s[i];
    s[i] = s[mm];
    s[mm] = tmp;
  }
}

int main() {
  char *strgs[] = {"333", "22", "4444", "1"};
  strsort(strgs, 4, &cmplen);

  // вывод на экран
  for (int i = 0; i &lt; 4; i++) {
    printf("%s ", strgs[i]);
  }
}
</pre>
  </details>

  <p>Напишем программу, которая читает строки из файла и выводит их на экран в порядке возрастания длины</p>

  <details>
    <summary>Программа 52 (144)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#define BSIZE 200

int cmplen(char *, char *);
void strsort(char *[], int, int (*cmp)(char *, char*));

int main(int argc, char *argv[]) {
  char buf[BSIZE];
  char *strgs[100];
  FILE *in;

  if (argc &lt; 2) {
    printf("too small parameters\n");
    return 1;
  }

  in = fopen(argv[1], "r+b");
  if (in == NULL) {
    printf("cannot open file %s\n", argv[1]);
    return 1;
  }

  int i = 0;
  while (fgets(buf, BSIZE-1, in) != NULL) {
    strgs[i] = malloc(strlen(buf) + 1);
    strcpy(strgs[i], buf);
    i++;
  }

  int nofl = i;
  // сортировка
  strsort(strgs, nofl, &cmplen);

  // вывод на экран
  for (int i = 0; i &lt; nofl; i++) {
    printf("%s", strgs[i]);
  }
}

int cmplen(char *s1, char *s2) {
  return (strlen(s1) - strlen(s2));
}

void strsort(char *s[], int N,
int (*cmp)(char *, char*)) {
  char *tmp;
  int mm;
  for (int i = N - 1; i >= 1; i--) {
    mm = 0;
    for (int j = 1; j &lt;= i; j++) {
      if ((*cmp)(s[j], s[mm]) > 0) {
        mm = j;
      }
    }
    tmp = s[i];
    s[i] = s[mm];
    s[mm] = tmp;
  }
}
</pre>
  </details>
</article>


<!-- 7.4 Имена функций и указатели -->
<article class="article">
  <div class="anchor" id="p7.4"></div>
  <h3>7.4 Имена функций и указатели (144)</h3>

  <p>Объявляя указатель на int - int *p, мы выделяем для него память, в которой первоначально содержится мусор. Перед использованием указатель должен содержать адрес существующей переменной или свободной области памяти. С помощью оператора & - p = &a в указатель p записывается адрес переменной a.</p>
  <p>Объявленяя указатель на функцию int (*f)() мы выделяем всего лишь участок памяти, содержащий мусор. С помощью оператора & - f = &fun указателю присваивается разумное значение.</p>
  <p>Имя массива это адрес его нулевого элемента p = &arr[0]. Указатель p  равен адресу нулевого элемента массива. p = arr. Указатель p равен имени массива и равен адресу его нулевого элемента. Это стало возможно потому что с именем массива не связано какое-то значение как в обычной переменной.</p>
  <p>Массивы и функции похожи тем, что имя функции равно адресу ее начала. Поэтому если f это указатель на функцию, то можно писать f = fun и можно вызывать функцию через укзатель f() так же как и через ее имя fun().</p>

  <details>
    <summary>Программа 53 (146)</summary>
<pre>
#include &lt;stdio.h&gt;

int sum(int, int);

int main() {
  int i = 2, j = 3, k;
  int (*f)(int, int);
  printf("%d\n", sum(i, j));
  f = sum;
  printf("%d\n", f(i, j));
}

int sum(int f, int s) {
  return f + s;
}
</pre>
  </details>

  <p>Имя функции и указатель на нее практически равноправны. Разница между ними только в том, что имя функции нельзя отделить от нее самой, оно всегда связано с постоянным адресом. Указатель же свободен и ему можно присвоить любой адрес.</p>
</article>


<!-- 7.5 Функция Qsort -->
<article class="article">
  <div class="anchor" id="p7.5"></div>
  <h3>7.5 Функция Qsort (146)</h3>

  <p>Библиотека stdlib.h содержит функцию сортировки qsort()</p>
  <code>void qsort(void* base, unsigned n, unsigned size, int (*cmp)(const void*, const void*));</code>
  <p>base это указатель на начало сортируемого массива</p>
  <p>n это число сортируемых элементов</p>
  <p>size это размер элемента</p>
  <p>cmp это указатель на функуию сравнения, которая показывает какой из двух элементов больше</p>

  <p>Что такое void* base. Указатель на void это обобщенный указатель, нельзя сказать на что он указывает пока его не приведут к конкретному типу. К такому указателю нельзя прибавить число, потому что не известен размер переменной на которую он ссылается. Таким образом функция qsort() может сортировать массивы с любым типом данных.</p>
  <p>Что такое int (*cmp)(const void*, void*). Функция cmp сравнивает два элемента. Ее нужно писать самостоятельно, потому что сравнивать можно по разному (по алфавиту, по длине и т.д.). Функция qsort() будет вызывать функцию cmp() и передавать ей указатели на сравниваемые элементы. Функция cmp() должна вернуть положительное значение если первый аргумент больше второго, нуль если они равны и отрицательное значение если второй аргумент больше первого. Слово void говорит о том что функция cmp() принимает указатель на элементы любого размера. Слово const говорит что нельзя изменить сам элемент.</p>
  <p>Отсортируем целые числа в массиве x[]</p>

  <details>
    <summary>Программа 54 (149)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int cmp(const void*, const void*);

int main() {
  int x[10] = {5,3,2,4,6,7,11,17,0,13};
  qsort(x, 10, sizeof(int), cmp);
  for (int i = 0; i &lt; 10; i++) {
    printf("%d ", x[i]);
  }
}

int cmp(const void* a, const void* b) {
  int n1, n2;
  n1 = *(int *)a;
  n2 = *(int *)b;
  if (n1 &lt; n2) {
    return -1;
  } else if (n1 == n2) {
    return 0;
  } else {
    return 1;
  }
}
</pre>
  </details>
  <p>В функуию приходит параметр void* a. Сначала приводим указатель на void  к указателю на int (int *). Потом получаем значение переменной операцией разименования *(int *)a</p>
  <p>Функция сравнения вычисленная через разность параметров не надежна и опасна из-за возможного переполнения</p>
<pre>
int cmp(const void* a, const void* b) {
  return *(int *)a - *(int *)b;
}
</pre>
  <p>Строки могут быть как угодно разбросаны в памяти компьютера. Если указатели на строки собрать в одном массиве, то можно сортировать строки сортируя указатели на них.</p>
  <code>qsort(strings, n, sizeof(char*), pstrcmp)</code>
  <p>strgs это массив указателей на char. n это число строк. sizeof(char*) это размер указателя на char. pstrcmp это функция сравнения строк.</p>
  <p>Вместо того чтобы самому писать функцию сравнения pstrcmp, можно использовать стандартную функцию strcmp(). Но функция strcmp() принимает два указателя на char, а функция qsort() передает ей два указателя на указатели на char. Нужно между собой эти указатели подружить. Функция pstrcmp() должна принимать два указателя на void.</p>
  <code>int pstrcmp(const void* p1, const void* p2) {}</code>
  <p>Эти указатели нужно преобразовать внутри функции к тому типу, которые передаются ей на самом деле - "указатель на указатель на char" (char**)p1 и после этого разименовать ссылку чтобы получить ссылку на строку.</p>
<pre>
int pstrcmp(const void* p1, const void* p2) {
  return strcmp(*(char **)p1, *(char **)p2;
}
</pre>
</article>


<!-- 7.6 Иголка, сено и лыко в строку -->
<article class="article">
  <div class="anchor" id="p7.6"></div>
  <h3>7.6 Иголка, сено и лыко в строку (151)</h3>

  <p>Образование - это не сумма знаний, а умение учиться дальше. Не надо заучивать наизусть названия стандартных функций их принимаемые параметры. printf(), scanf() и другие стандартные функции описаны в справочниках по языку и все программисты значительную часть времени пользуются этими справочниками чтобы найти нужную функцию и узнать как она работает.</p>
  <p>Заголовочный файл string.h содержит функцию strstr() которая ищет одну строку в другой.</p>
  <p>Напишем программу, которая ищет строку str2 в строке str1.</p>

  <details>
    <summary>Программа 55 (152)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

char *str1 = "senosenosenoigolkasenosenoseno";
char *str2 = "igolka";
char *substr;

int main() {
  substr = strstr(str1, str2);
  if (substr != NULL) {
    printf("%s", substr);
  }
}
</pre>
  </details>
  <p>Результат поиска - указатель на место в str1, откуда начинается str2. Программа выводит на экран строку str1 с того места, где начинается строка str2.</p>
  <p>Напишем программу которая вставляет строку в строку.</p>

  <details>
    <summary>Программа 56 (153)</summary>
    <p>Программа не работает</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

int main() {
  char *s1 = "every in string";
  char *s2 = "thing";
  char *s3, *cptr;
  s3 = calloc(strlen(s1) + strlen(s2) + 3, 1);
  cptr = strtok(s1, " ");  // Segmentation fault
  strcpy(s3, cptr); // s3 = "every"
  strcat(s3, " ");  // s3 = "every "
  strcat(s3, s2);   // s3 = "every thing"
  strcat(s3, " ");  // s3 = "every thing "
  while (cptr = strtok(NULL, " ")) {
    strcat(s3, cptr);
    strcat(s3, " ");
  }
  printf("%s\n", s3);
}
</pre>
  </details>
</article>


<!-- 8 Основные типы на сборочном конвейере -->
<article class="article">
  <div class="anchor" id="p8"></div>
  <h3>8 Основные типы на сборочном конвейере (157)</h3>
</article>


<!-- 8.1 Перечисления -->
<article class="article">
  <div class="anchor" id="p8.1"></div>
  <h3>8.1 Перечисления (157)</h3>

  <p>В языке Си можно создавать новые типы данных на основе базовых. Базовые типы это как детали на конвейере, из которых можно собрать очень сложные переменные нового типа.</p>
  <p>Конструкция enum создает новый тип с определенными целыми значениями</p>
  <code>enum day {sun, mon, tues, weds, thur, fri, sat} d1, d2;</code>
  <p>В одной строке создается новый тип day и сразу объявляются две переменные d1 и d2 нового типа day. Эти две переменные d1 и d2 могут принимать только целые значения от 0 до 6 и у каждого значения есть свое имя.</p>
  <p>Напишем программу, которая определяет время года по номеру месяца.</p>

  <details>
    <summary>Программа 57 (158)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  enum months {jan = 1, feb, mar, apr, may,
        jun, jul, aug, sep, oct, nov, dec};
  enum months m2;
  scanf("%d", &m2);
  switch (m2) {
    case dec: case jan: case feb:
      printf("winter\n");
      break;
    case mar: case apr: case may:
      printf("spring\n");
      break;
    case jun: case jul: case aug:
      printf("summer\n");
      break;
    case sep: case oct: case nov:
      printf("autom\n");
      break;
    default:
      printf("enter error\n");
      break;
  }
}
</pre>
  </details>
  <p>Первой строчкой в функции main() создается новый тип данных и задаются имена и значения, которые могут принимать переменные нового типа данных. После создания нового типа данных, в программе объявляется переменная m2 перед которой пишется сам новый тип данных enum months m2. m2 это обычная целочисленная переменная, значения от 1 до 12 которой имеют имена от "jan" до "dec". Инструкция default нужна для того чтобы выделить случаи когда m2 не равна ни одному числу от 1 до 12.</p>
  <p>Напишем программу с оператором break в цикле, которая определяет длину строки.</p>

  <details>
    <summary>Программа 58 (161)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  int i = 0, len = 0;
  char x[] = "mama";
  while (1) {
    if (!x[i++]) break;
    len++;
  }
  printf("%d\n", len);
}
</pre>
  </details>
  <p>Когда в конце строки встретится символ '\0' он будет определен как 0 и сработает оператор break.</p>
  <p>Напишем прошрамму с оператором continue в цикле, которая определяет количество цифр в строке.</p>

  <details>
    <summary>Программа 59 (162)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
  int cnt = 0;
  char x[] = "123abcd4";
  for (int i = 0; i &lt; strlen(x); i++) {
    if(x[i] > '9' || x[i] &lt; '0') {
      continue;
    }
    cnt++;
  }
  printf("%d\n", cnt);
}
</pre>
  </details>
</article>


<!-- 8.2 Двухмерные массивы и указатели на... -->
<article class="article">
  <div class="anchor" id="p8.2"></div>
  <h3>8.2 Двухмерные массивы и указатели на... (163)</h3>

  <p>Для доступа к элементу одномерного массива нужен один индекс, начиная с 0. Для доступа к элементу двумерного массива нужно два индекса, первый указывает на строку, второй на столбец.</p>
  <p>Объявим двумерный массив символов из 3 строк и 5 столбцов.</p>
  <code>char a[3][5]</code>
  <p>Память компьютера одномерна, в ней ячейки памяти идут подряд одна за другой. Поэтому компилятор "вытягивает" двумерный массив в одну линию. Сначала в память пишется первая строка, потом вторая и так далее. Двумерный массив это не более чем удобная форма записи. Его можно заменить одномерным массивом. Каждый элемент одномерного массива тогда будет соответствовать определенному элементу двумерного массива. Чтобы работать с одномерным массивом как с двумерным, необходимо знать номер строки и столбца, а также число строк и столбцов двумерного массива. Если работать с двумерным массивом, то достаточно знать только номер строки и столбца.</p>Напишем программу, которая создает таблицу из трех строк и трех столбцов, в которой диагональные элементы (это те у которых номер строки равен номеру столбца) равны 1, а остальные элементы равны 0. Такая таблица называется единичной матрицей. Матрицу можно хранить в двумерном массиве a[3][3] или в одномерном a[9].</p>

  <details>
    <summary>Программа 60 (166)</summary>
<pre>
#include &lt;stdio.h&gt;
#define NCOLS 3

int main() {
  char a[3][3];
  char s[9];

  for (int i = 0; i &lt; 3; i++) {
    for (int j = 0; j &lt; 3; j++) {
      a[i][j] = (i == j) ? 1 : 0;
      s[i * NCOLS + j] = (i == j) ? 1 : 0;
    }
  }

  for (int i = 0; i &lt; 3; i++) {
    for (int j = 0; j &lt; 3; j++) {
      printf("%6d%c", a[i][j], (j == 2) ? '\n': ' ');
    }
  }
  printf("\n");

  for (int i = 0; i &lt; 3; i++) {
    for (int j = 0; j &lt; 3; j++) {
      printf("%6d%c", s[i * NCOLS + j], (j == 2) ? '\n': ' ');
    }
  }
}
</pre>
  </details>
  <p>Передавая одномерный массив в функцию, мы должны передать 2 параметра - ссылку на нулевой элемент массива и число элементов. Передавая двумерный массив в функцию мы должны передать 3 параметра - ссылку на нулевой элемент массива, число строк и число столбцов.</p>
  <p>Напишем программу которая для создания единичной матрицы испоьлзует функцию set1().</p>

  <details>
    <summary>Программа 61 (167)</summary>
<pre>
#include &lt;stdio.h&gt;

void set1(char [][3], int);

int main() {
  char a[3][3];
  set1(a, 3);
  for (int i = 0; i &lt; 3; i++) {
    for (int j = 0; j &lt; 3; j++) {
      printf("%6d%c", a[i][j], (j == 2) ? '\n' : ' ');
    }
  }

  return 0;
}

void set1(char matr[3][3], int dim) {
  for (int i = 0; i &lt; dim; i++) {
    for (int j = 0; j &lt; dim; j++) {
      matr[i][j] = (i == j) ? 1 : 0;
    }
  }
}
</pre>
  </details>
  <p>Функция принимает двумерный массив char matr[3][3]. Но что же на самом деле передается функции вместо двумерного массива? Вместо одномерного массива char matr[3] функции передается указатель на его первый элемент. Вместо двумерного массива char matr[3][3] функции передается указатель на массив из трех элементов типа char.</p>
  <p>Указатель на массив работает не так как указатель на переменную. Разименование указателя на переменную возвращает само значение переменной. А разименование указателя на массив возвращает указатель на его первый элемент. Если теперь разименовать указатель на первый элемент массива, то теперь мы уже получим значение этого элемента.</p>
  <p>Двумерный массив расположен строчка за строчкой в памяти компьютера. Если ia это указатель на первую строку двумерного массива, то через этот указатель мы можем получить доступ к любому элементу массива. Если ip указывает на нулевую строку, то *(ip + 2) указывает на начало второй строки, а еще одно раскрытие ссылки *(*(ip +2) + 3) вернет значение третьего элемента второй строки. Получаем три равноправные записи</p>
  <code>*(*(ip + 2) + 3) == *(ip[2] + 3) == ip[2][3]</code>
  <p>То есть, указателем на массив можно пользоваться как именем двумерного массива, и наоборот - имя двумерного массива есть указатель на его нулевую строку.</p>
  <p>Напишем программу, где элементу массива a[0][2] сначала присваивается значение 'P', а затем на экран выводится элемент массива с тем же значением, но с другим именем.</p>

  <details>
    <summary>Программа 62 (169)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char a[3][5];
  char (*ap)[5];
  ap = a;
  a[0][2] = 'P';
  printf("%c\n", ap[0][2]);

  return 0;
}
</pre>
  </details>
  <p>То что имя двумерного массива оказалось указателем на массив говорит о том что двумерный массив это массив массивов.</p>
</article>


<!-- 8.3 Хранение и переработка двухмерных массивов -->
<article class="article">
  <div class="anchor" id="p8.3"></div>
  <h3>8.3 Хранение и переработка двухмерных массивов (170)</h3>

  <p>Недостатки двумерных массивов: невозможность поменять их размеры и неудобства при передаче их функциям. Для передачи массива с тремя столбцами нужно писать одну функцию, а для массива с пятью - другую. К счастью мы можем передать массив указателей, чтобы явно не писать сколько у массива столбцов.</p>
  <p>Напишем программу в которой создается двумерный массив из массива указателей, которым память выделяется функцией malloc(). Такой массив не будет непрерывным, а будет разбросан по памяти, потому что при каждом обращении к функции malloc() она может выделять не соседние участки памяти.</p>

  <details>
    <summary>Программа 63 (171)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define NROW 3
#define NCOL 5

void set(int **);

int main() {
  int *arr[NROW];
  for (int i = 0; i &lt; NROW; i++) {
    arr[i] = malloc(NCOL * sizeof(int));
  }
  set(arr);
  printf("%c\n", arr[2][3]);
  for (int i = 0; i &lt; NROW; i++) {
    free(arr[i]);
  }

  return 0;
}

void set(int **a) {
  a[2][3] = 'P';
}
</pre>
  </details>
  <p>Несмотря на другое внутреннее устройство, созданной структурой можно пользоваться как двумерным массивом. Если arr[] это массив указателей, каждый из которых направлен на свободный участок памяти длиной NCOL, то arr[0] указывает на начало строки под номером 0. Чтобы получить значение третьего элемента второй строки, нужно взять указатель на начало второй строки, то есть arr[2] и прибавить к нему 3 и раскрыть ссылку оператором *</p>
  <code>*(arr[2] + 3) == arr[2][3]</code>
  <p>Таким образом, arr[][] выглядит двумерным массивом, хотя само имя arr уже не указатель на массив, а указатель на указатель. Поэтому функция set() из программы принмает указатель на указатель, что позволяет ей работать с двумерными массивами любых размеров.</p>
</article>


<!-- 8.4 Записи -->
<article class="article">
  <div class="anchor" id="p8.4"></div>
  <h3>8.4 Записи (174)</h3>

  <p>Записи создаются с помощью слова struct и могут содержать переменные разных типов. При этом сама созданная запись будет представлять новый тип, который можно использовать в программе. Запись хранит разнородные элементы, поэтому нельзя присвоить значение записи целиком. Значение можно присвоить только отдельнопу полю записи, обратившись к ней через точку.</p>
  <p>Массив записей выглядит еще сложнее. К отдельной записи массива можно обратиться через индекс, а потом уже через точку обратиться к полю записи.</p>
  <p>Напишем программу, в которой объявим запись об обеде и присвоим ее полям начальные значения.</p>

  <details>
    <summary>Программа 64 (176)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  struct dinner {
    float pepper;
    float cabbage;
    float peas;
    float ham;
  } d = {0.005, 3.0, 0.5, 1.0};
  printf("peas = %f\n", d.peas);

  return 0;
}
</pre>
  </details>
  <p>Можно совместить создание нового типа с объявлением переменной этого типа и с присваиванием значений ее полям. Записывать начальные значения полей внутри фигурных скобок можно только при объявлении записи.</p>
  <p>Напишем программу, в которой создадим новый тип данный через слово struct. Создадим две переменных нового типа. Запишем значение в одно поле первой переменной и скопируем первую переменную во вторую целиком. Дальше выведем на экран то же поле второй переменной.</p>

  <details>
    <summary>Программа 65 (177)</summary>
<pre>
#include &lt;stdio.h&gt;

int main() {
  struct dinner {
    float pepper;
    float cabbage;
    float peas;
    float ham;
  };
  struct dinner d1, d2;
  d1.ham = 1.0;
  d2 = d1;
  printf("ham = %f\n", d2.ham);

  return 0;
}
</pre>
  </details>
</article>


<!-- 8.5 Записи и функции -->
<article class="article">
  <div class="anchor" id="p8.5"></div>
  <h3>8.5 Записи и функции (178)</h3>

  <p>Функция cook() будет готовить обед из случайного количества продуктов. Она принимает массив записей типа struct dinner[]. Внутри перебираются 365 элементов массива. Каждый элемент - отдельная запись. В каждый элемент записывается количество продуктов приготовленных на обед в этот день.</p>
  <p>Функция sum() будет считать суммарное количество продуктов из которых был приготовлен обед за год. Она принимает тот же массив записей. Суммирует все продукты и возвращает запись того же типа.</p>
  <p>В функции main() создадим переменную типа struct dinner. Сначала вызовем функцию cook() чтобы заполнить ее значениями. Потом вызовем функцию sum() чтобы посчитать сумму продуктов за год. Выведем результат на экран.</p>

  <details>
    <summary>Программа 66 (181)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct dinner {
  float pepper;
  float cabbage;
  float peas;
  float ham;
};

void cook(struct dinner d[]);
struct dinner sum(struct dinner d[]);

int main() {
  struct dinner d[365], total;
  cook(d);
  total = sum(d);
  printf("total pepper = %f\n", total.pepper);
  printf("total cabbage = %f\n", total.cabbage);
  printf("total peas = %f\n", total.peas);
  printf("total ham = %f\n", total.ham);

  return 0;
}

void cook(struct dinner d[]) {
  for (int i = 0; i &lt; 365; i++) {
    d[i].pepper  = 0.1 * ((double) rand()) / RAND_MAX;
    d[i].cabbage = 2.0 * ((double) rand()) / RAND_MAX;
    d[i].peas    = 1.0 * ((double) rand()) / RAND_MAX;
    d[i].ham     = 0.5 * ((double) rand()) / RAND_MAX;
  }
}

struct dinner sum(struct dinner d[])
{
  struct dinner s = {0,0,0,0};
  for (int i = 0; i &lt; 365; i++) {
    s.pepper  += d[i].pepper;
    s.cabbage += d[i].cabbage;
    s.peas    += d[i].peas;
    s.ham     += d[i].ham;
  }
  return s;
}
</pre>
  </details>
</article>


<!-- 8.6 Указатель на запись -->
<article class="article">
  <div class="anchor" id="p8.6"></div>
  <h3>8.6 Указатель на запись (182)</h3>

  <p>Поскольку массив записей это указатель на запись то заголовок функции</p>
  <code>struct dinner sum(struct dinner d[])</code>
  <p>можно переписать так</p>
  <code>struct dinner sum(struct dinner *d)</code>
  <p>Раз d это указатель на запись, к нему можно применить оператор раскрытия ссылки *. Тогда и обращение к записи будет эквивалентно</p>
  <code>d[i].pepper == (*(d + i)).pepper</code>
  <p>Двойные скобки (*(d + i)) здесь необходимы, потому что точка '.' сильнее оператора звездочка '*'. Чтобы не писать лишние скобки, создатели языка Си придумали новый оператор стрелка '->', который применяется только к записям.</p>
  <p>Если d это указатель на запись, то d->pepper это значение его поля. Тогда и обращение к полю записи будет эквивалентно</p>
  <code>(*(d + i)).pepper == (d + i)->pepper</code>
  <p>Скобки (d + i) здесь необходимы, потому что слева от оператора -> должен стоять указатель на запись, а не целое число. Чтобы избавиться от скобок можно передвигать указатель на запись, увеличивая его на 1 в конце цикла for.</p>
  <p>Конечно правила не запрещают переходить к следующей записи уже на самом последнем присваивании. Тогда удастся записать последнюю строчку цикла так</p>
  <code>s.ham+=d++->ham;</code>
  <p>На самом деле, профессионалы стараются писать программы как можно проще. Потому что слишком изощренно написанная программа через пару недель перестанет быть понятной им самим.</p>
</article>


<!-- 8.7 Связанные записи -->
<article class="article">
  <div class="anchor" id="p8.7"></div>
  <h3>8.7 Связанные записи (186)</h3>

  <p>Записи позволяют связать между собой различные данные так, чтобы получилась структура. Связав записи друг за другом можно получить связный список. Пусть у нас есть персонаж</p>
<pre>
struct personage {
  char *hero;
  struct personage *next;
};
</pre>
  <p>У структуры данных struct personage всего два поля. Первое char *hero это указатель на имя героя. Второе содержит указатель на запись того же типа, в нем хранится адрес следующего персонажа.</p>

  <details>
    <summary>Программа 67 (188)</summary>
<pre>
#include &lt;stdio.h&gt;

struct personage {
  char *hero;
  struct personage *next;
};

int main() {
  struct personage repka, dedka;
  dedka.hero = "dedka";
  dedka.next = NULL;
  repka.hero = "repka";
  repka.next = &dedka;
  printf("%s\n", repka.next->hero);
}
</pre>
  </details>

  <p>Связный список это рад записей, последовательно ссылающихся друх на друга. Каждой записи изсевтен лишь адрес следующего элемента. Последняя запись в списке вместо указателя на следующую запись содержит NULL.</p>

  <details>
    <summary>Программа 68 (189)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct personage {
  char *hero;
  struct personage *next;
};

void display(struct personage *);

int main() {
  struct personage *repka, *root;
  char *heroes[] = {
    "repka",
    "dedka",
    "babka",
    "vnuchka",
    "zhuchka",
    "koshka",
    "mishka",
    NULL
  };
  repka = malloc(sizeof(struct personage *));
  root = repka;
  root->hero=heroes[0];
  int i = 1;
  while(heroes[i]) {
    repka = repka->next = malloc(sizeof(struct personage *));
    repka->hero = heroes[i++];
  }
  repka->next = NULL;
  display(root);
  return 0;
}

void display(struct personage *p) {
  do {
    printf("%s\n", p->hero);
  } while (p = p->next);
}
</pre>
  </details>
  <p>Отличие звазного списка от массива. В массиве можно прямо обратиться к любому элементу. В связном списке чтобы добраться до нужного элемента, нужно сначала пройти все предыдущие. В массив трудно вставить новый элемент, чтобы освободить место в массиве под новый элемент, нужно его раздвинуть, для чего придется переписат на новое место весь его хвост. В связный списко легко вставить новый элемент, достаточно поменять пару указателей.</p>
</article>


<!-- 8.8 Typedef -->
<article class="article">
  <div class="anchor" id="p8.8"></div>
  <h3>8.8 Typedef (191)</h3>

  <p>Ключевое слово <strong>typedef</strong> не создает новые типы (как enum или struct). Зато typedef позволяет дать короткие имена уже существующим типам.</p>
  <p>Для типа struct personage определим короткое имя person</p>
<pre>
typedef struct personage {
  char *hero;
  struct personage *next;
} person;
person *repka, *root;
</pre>
  <p>Если при создании типа использовалось слово typedef, то сама запись не создается. Запись может быть создана только в новой строке</p>
  <p>Дадим имена некоторым другим типам. Посмотрим что произойдет с обычной переменной</p>
  <code>typedef int s32</code>
  <p>Здесь не создается переменная s32. Здесь s32 превращается в имя типа и можно объявлять переменные этого типа</p>
  <code>s32 a = 0, i, j;</code>
  <p>Посмотрим что произойдет с массивом на 100 элементов</p>
  <code>typedef int arr100[100]</code>
  <p>здесь создается новый тип arr100 - массив из ста элементов типа int и можно объявлять переменные этого типа</p>
  <code>arr100 a;</code>
  <p>Посмотрим что произойдет с функцией</p>
  <code>typedef int (*f)(int, int);</code>
  <p>Здесь создается новый тип f - укзатель на функцию и можно объявлять переменные этого типа</p>
  <code>f f1ptr, f2ptr;</code>
  <p>Теперь f1ptr, f2ptr это указатели на функцию, принимающую два целочисленных аргумента и возвращающую целое число.</p>
</article>


<!-- 9 Большие программы -->
<article class="article">
  <div class="anchor" id="p9"></div>
  <h3>9 Большие программы (195)</h3>
</article>


<!-- 9.1 Разделяй и вляствуй -->
<article class="article">
  <div class="anchor" id="p9.1"></div>
  <h3>9.1 Разделяй и вляствуй (195)</h3>

  <p>Напишем программу, которая сортирует 10 чисел, находящихся в массиве nums[10]. И поместим эту программу в два файла. Первый содержит функцию main(), которая создает массив нужного размера, заполняет его случайными числами, вызывает функцию сортировки и выводит отсортированный массив на экран. Вторая содержит функцию сортировки.</p>

  <details>
    <summary>Программа 69 (197) первый файл 69.c</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#define N 50

void sort(int *, int);

int main() {
  long t1, t2;
  int nums[N];
  t1 = time(NULL);
  srand((unsigned int) t1);
  for (int i = 0; i &lt; N; i++){
    nums[i] = rand();
  }
  sort(nums, N);
  t2 = time(NULL);
  printf("%d second\n", t2 - t1);
  for(int i = 0; i &lt; N; i++) {
    printf("%d ", nums[i]);
  }
  return 0;
}
</pre>
  </details>

  <details>
    <summary>Программа 69 (197) второй файл 69sort.c</summary>
<pre>
void sort(int *nums, int n) {
  int mm, tmp;
  for (int i = n-1; i >= 1; i--) {
    mm = 0;
    for (int j = 1; j &lt;= i; j++) {
      if (nums[j] > nums[mm]) {
        mm = j;
      }
    }
    tmp = nums[i];
    nums[i] = nums[mm];
    nums[mm] = tmp;
  }
}
</pre>
  </details>
  <p>Скомпилируем программу состоящую из двух файлов компилятором gcc из командной строки</p>
  <code>gcc 69.c 69sort.c</code>
  <p>Заголовочный файл time.h содержит функции time(), rand(), srand().</p>
  <p>Функция rand() возвращает псевдослучайное число. При каждом новом запуске программы числа, выдаваемые функцией rand() повторяются, если используется одно и то же зерно. Поэтому чтобы числа были разными нужно задавать новое зерно.</p>
  <p>Функция srand() задает зерно для функции rand(). Для того чтобы выдавались разные числа их нужно привязывать к временной метке, так как время всегда разное при разном запуске программы.</p>
  <p>Функция time() возвращает время в секундах, прошедшее с 1 января 1970 года. Функцию time() можно использовать для вычисления времени работы частей программы.</p>
</article>


<!-- 9.2 Extern или Три поросенка -->
<article class="article">
  <div class="anchor" id="p9.2"></div>
  <h3>9.2 Extern или Три поросенка (199)</h3>

  <p>Напишем программу, в которой три поросенка закрывают дверь когда волк приближается и открывают дверь когда волк удаляется. Разобьем эту программу на три файла</p>

  <details>
    <summary>Программа 70 (200) первый файл 70.c</summary>
<pre>
#include &lt;stdio.h&gt;
#include "70pigs.h"

int wolf = OUT;

int main() {
  int door(void);
  if (door() == OPEN) {
    printf("door is open\n");
  }
  if (door() == CLOSED) {
    printf("door is closed\n");
  }
  return 0;
}
</pre>
  </details>

  <details>
    <summary>Программа 70 (200) второй файл 70door.c</summary>
<pre>
#include "70pigs.h"

extern int wolf;

int door() {
  if (wolf == IN) {
    return CLOSED;
  }
  if (wolf == OUT) {
    return OPEN;
  }
}
</pre>
  </details>

  <details>
    <summary>Программа 70 (200) третий файл 70pigs.h</summary>
<pre>
#define IN 1
#define OUT 0
#define OPEN 1
#define CLOSED 0
</pre>
  </details>
  <p>Если файлы содержат одинаковый фрагмент кода, определяющий имена, то можно создать заголовочный файл с расширением .h, куда надо поместить общие для этих файлов определения. Заголовочный файл располагается в папке с исходными текстами. Теперь его можно включить в каждый файл строчкой</p>
  <code>#include "70pigs.h"</code>
  <p>Имя файла здесь взято в кавычки а не в скобки. Увидев двойные кавычки компилятор поймет что перед ним нестандартный заголовочный файл и будет искать его там же где файлы с исходными текстами.</p>
  <p>Скомпилируем программу состоящую из трех файлов компилятором gcc из командной строки, третий заголовочный файл передавать компилятору не нужно</p>
  <code>gcc 70.c 70door.c</code>
  <p>Переменная wolf объявлена в файле 70.c. В файле 70door.c с помощью слова extern указывается что переменная wolf существует и определена в другом файле. Увидев слово extern, компилятор успокаивается и создает объектный файл, в котором сказано что переменная wolf внешняя и определена в другом файле. Поисками этой переменной в другом файле уже займется редактор связей linker.</p>
  <p>Нужно понимать, что объявить переменную в программе можно только один раз. При объявлении компилятор выделяет участок памяти равный размеру переменной и при ее инициализации засылает в него начальное значение. Слово extern лишь успокаивает компилятор, сообщая что уже есть такая переменная. Слово extern ничего не создает в и никакой памяти не выделяет.</p>
  <p>Словом extern необходимо помечат только переменные. Для функций это излишне, компилятор и так считает все функции внешними. Но чтобы подчеркнуть (для других программистов, не для компилятора), что функция определена в другом файле, ее прототип можно написать со словом extern</p>
  <code>extern int door(void);</code>
</article>


<!-- 9.3 Static -->
<article class="article">
  <div class="anchor" id="p9.3"></div>
  <h3>9.3 Static (202)</h3>

  <p>Объявлять переменную нужно до ее использования. Если переменная объявлена внутри функции, то за ее пределами она не будет видна. Переменная объявленная внутри фигурных скобок за их пределами не будет видна. Если переменная объявлена внутри функции, то она создается и существует внутри этой функции. Когда функция заканчивает свою работу переменная удаляется. Чтобы переменная помнила о себе и по выходе из функции, необходимо объявить ее со словом static. При первом вызове функцию переменная проинициализируется и может иметь какое-то значение при завершении функции. При повторном вызове функции переменная уже имеет значение, которое было при предыдущем выходе из функции.</p>
  <p>Напишем программу с одной функцией и двумя статичными переменными в этой функции. Переменная counter считает число вызовов функции и если оно меньше трех то выводит на экран этот номер. После четвертого вызова функция ничего не отвечает.</p>

  <details>
    <summary>Программа 71 (208)</summary>
<pre>
#include &lt;stdio.h&gt;

void bang(void);

int main() {
  for (int i = 0; i &lt; 100; i++) {
    bang();
  }
  return 0;
}

void bang() {
  static int impatience;
  static int counter = 1;
  if (impatience) {
    return;
  }
  printf("menya bespokoyat %d raz\n", counter);
  counter++;
  if (counter > 3) {
    impatience = 1;
    printf("terpenie lopnulo\n");
  }
}
</pre>
  </details>
  <p>Если переменная со словом static объявлена вне функций, то она становится видима только в своем файле. За пределами файла она становится невидимой. Если нужно функцию сделать доступной только в своем файле, нужно написать перед ней слово static.</p>
  <code>static int door() {}</code>
  <p>Прототипы функций видны только в одном файле. Поэтому их вместе со значениями констант нужно хранить в специальном заголовочном файле, который должен подключаться всюду, где эти прототипы и константы импользуются.</p>
</article>


<!-- 10 Макросы и переходы -->
<article class="article">
  <div class="anchor" id="p10"></div>
  <h3>10 Макросы и переходы (210)</h3>
</article>


<!-- 10.1 Макросы -->
<article class="article">
  <div class="anchor" id="p10.1"></div>
  <h3>10.1 Макросы (210)</h3>

  <p>Каждую программу перед компиляцией обрабатывает препроцессор. Команды препроцессора в программе начинаюстя с символа '#'. Определение имени с помощью команды #define называется <strong>макросом</strong>. Макросы позволяют присваивать имена константам и создавать подобия функций.</p>
  <p>Напишем макрос возводящий число в квадрат</p>
  <code>#define SQR(x) x * x</code>
  <p>То что в макросе есть скобки означает что это не определение константы, а определение функции, которая принимает один параметр.</p>
  <p>Напишем программу, использующую макрос возведения в квадрат, чтобы посчитать дважды два.</p>

  <details>
    <summary>Программа 72 (211)</summary>
<pre>
#include &lt;stdio.h&gt;
#define SQR(x) x*x

int main() {
  int i = 2, s;
  s = SQR(i);
  printf("%d\n", s);
  return 0;
}
</pre>
  </details>
  <p>Отличие макроса от функции в том, что функция подставляет параметры, вычисляет, и возвращает результат. Макрос просто подставляет параметры и возвращает выражение, которое вычисляется в коде программы, а не в макросе</p>
  <p>Посмотрим это на примере, где надо разделить 1 на квадрат числа. Компилятор заменит каждую переменную на переданный параметр и вставит выражение в код. Вместо квадрата числа получится деление на число и умножение на число.</p>

  <details>
    <summary>Программа 73 (212)</summary>
<pre>
#include &lt;stdio.h&gt;
#define SQR(x) x*x

int main() {
  float i = 2.0, s;
  s = 1 / SQR(i);
  printf("%g\n", s);
  return 0;
}
</pre>
  </details>
  <p>Чтобы получить правильный результат, достаточно взять выражение в макросе в скобки</p>
  <code>#define SQR(x) (x*x)</code>
  <p>Но и этот вариант тоже может работать неправильно. Если нам нужно возвести в квадрат сумму чисел</p>
  <code>s = SQR(2+2)</code>
  <p>Препроцессор выполнит подстановку из макроса и мы получим неверный результат</p>
  <code>s = (2+2*2+2); // 8</code>
  <p>Чтобы получить правильный результат, достаточно взять в скобки каждый параметр</p>
  <code>#define SQR(x) ((x) * (x))</code>
  <p>Препроцессор выполнит подстановку и мы получим правильный результат</p>
  <code>s = ((2+2) * (2+2)); // 16</code>
  <p>Но теперь передадим в выражение инкремент</p>
  <code>i = 2; s = SQR(i++);</code>
  <p>Если SQR() это функция, то все будет хорошо. После ее вызова s = 4, а i = 3. Но если SQR() это макрос, то s и i могут быть какими угодно, потому что после подстановки мы получим выражение</p>
  <code>s = ((i++) * (i++));</code>
  <p>Поведение компилятора не определено стандартом в таком случае. Единственный правильный выход - не использовать операторы ++ и -- в таких случаях.</p>
  <p>Таким образом, макрос с параметрами - это муляж функции, но недостатки иногда могут обернуться достоинствами. Функции требуют от процессора дополнительных затрат на передачу параметров, вызов, возврат. Если функция вызывается часто, полезно заменить ее макросом.</p>
  <p>Следующий недостаток макроса - отсутствие проверки типа аргументов. Это превращается в достоинство, потому что не надо писать отдельные макросы для разных типов данных, его можно использовать для любых переменных. Хотя мы обязаны писать столько разных функций, сколько разных типов данных мы хотим возвести в квадрат.</p>
  <p>Напишем макрос, меняющий значения двух переменных</p>
  <code>#define SWAP(a,b) a=a+b; b=a-b; a=a-b;</code>
  <p>Чтобы написать макрос в несколько строк, надо в конце строки ставить обратный слеш, сообщающий что макрос еще не кончился</p>
<pre>
#define SWAP(a,b) \
        a=a+b;    \
        b=a-b;    \
        a=a-b;
</pre>
  <p>Макрос можно создавать командой #define, а уничтожать командой #undef</p>
  <code>#define OUT 0</code>
  <code>#undef OUT</code>
  <p>Макрос живет только в пределах одного файла - с момента создания и до момента уничтотжения.</p>
</article>


<!-- 10.2 Управление текстом -->
<article class="article">
  <div class="anchor" id="p10.2"></div>
  <h3>10.2 Управление текстом (215)</h3>

  <p>Часто макросы используются программистами для отладки программы. Когда в режиме отладки нужно выполнить определенные команды, например printf() чтобы вывести промежуточные переменные на экран, то эти команды окружают условными директивами препроцессора</p>
<pre>
#define DEGUG
#if defined (DEBUG)
printf("%d\n", i);
#endif
</pre>
  <p>Теперь вызов printf() будет только если определен макрос DEBUG</p>
  <p>Когда отладка закончится, чтобы не удалять по все программе отладочный код, после определения макроса #define DEBUG, его нужно уничтожить. Для этого нужно прописать одну строчку</p>
  <code>#undef DEBUG</code>
  <p>Макрос #ifndef укажет препроцессору что делать если константа не определена.</p>
</article>


<!-- 10.3 Напутствие или GOTO -->
<article class="article">
  <div class="anchor" id="p10.3"></div>
  <h3>10.3 Напутствие или GOTO (218)</h3>

  <p>Инструкция goto позволяет переходить к заранее расставленным меткам в программе. goto способна заменить собой цикл while, да и другие циклы тоже.</p>
  <p>Переход goto портит программу, делая ее громоздкой и малопонятной. Во всех программах можно обойтись без этой команды.</p>

  <h4>Напутствие</h4>
  <p>Сначала вы должны написать что-то сами. Программированием, как и любым другим ремеслом, надо заниматься. Изучение Си, как и любого другого языка программирования, немыслимо без упражнений. Чтобы научиться программировать, нужно программировать. Сначала задачи не должны быть слишком сложные. Разбивайте задачу на части, которые можно отладить отдельно друг от друга. Читайте документацию. Не сдавайтесь. И тогда к вам придет удача.</p>
</article>


<!-- Список литературы -->
<article class="article">
  <div class="anchor" id="p11"></div>
  <h2>Список литературы (225)</h2>

  <ol>
    <li>1992 Керниган, Ритчи - Язык программирования Си</li>
    <li>1982 Уэзрелл - Этюды для программистов</li>
    <li>1984 Керниган, Плоджер - Элементы стиля программирования</li>
    <li>1979 Брукс - Как проектируются и создаются программные комплексы</li>
    <li>1996 Петзолд - Программирование для Windows 95 в двух частях</li>
  </ol>
</article>

