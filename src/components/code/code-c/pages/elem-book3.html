<article class="article">
  <h1>1988 Болски - Язык программирования Си. 96c</h1>
  <p>Конспект книги</p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
    <a href="#p1">1 Введение (9)</a>
  </p>

  <p>
    <a href="#p2">2 Общий синтаксис (10)</a>
  </p>

  <p>
    <a href="#p3">3 Основные типы данных (11)</a>
  </p>

  <p>
    <a href="#p4">4 Операции и выражения (17)</a>
  </p>

  <p>
    <a href="#p5">5 Операторы (32)</a>
  </p>

  <p>
    <a href="#p6">6 Функции (39)</a>
  </p>

  <p>
    <a href="#p7">7 Описания (42)</a>
  </p>

  <p>
    <a href="#p8">8 Препроцессор (52)</a>
  </p>

  <p>
    <a href="#p9">9 Структура программы (55)</a>
  </p>

  <p>
    <a href="#p10">10 Библиотека ввода-вывода (60)</a>
  </p>

  <p>
    <a href="#p11">11 Другие библиотеки (65)</a>
  </p>

  <p>
    <a href="#p12">12 Форматированный вывод (70)</a>
  </p>

  <p>
    <a href="#p13">13 Форматированный ввод (74)</a>
  </p>

  <p>
    <a href="#p14">14 Мобильность программ на языке Си (78)</a>
  </p>
</article>


<!-- 1. Введение -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>1. Введение (9)</h3>

  <p>Язык программирования Си был разработан в начале семидесятых одов как инструментальное средство дляреализации операционной системы UNIX. Однако он набрал популярность и стал универсальным языком программирования высокого уровня, в него включены средства для программирования почти на уровне ассемблера (указатели, побитовые операции). Он позволяет писать компкатные и эффективные программы.</p>
</article>


<!-- 2 Общий синтаксис -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>2 Общий синтаксис (10)</h3>

  <h4>2.1 Формат</h4>
  <p>Пробелы, символы табуляции, перевод на новую строку и перевод страницы используются как разделители. Вместо одного из этих символов можно использовать любое их количество.</p>

  <h4>2.2 Комментарии</h4>
  <p>Комментарии начинаются двумя символами /* и заканчиваются двумя символами */. могут располагаться на однои строке или на нескольких. Разрешены везде, где допустимы пробелы.</p>

  <h4>2.3. Идентификаторы</h4>
  <p>Идентификаторы используются кк имена переменных, функций и типов данных. Допустимы цифры, латинские буквы и символ подчеркивания. Первый символ не может быть цифрой.</p>

  <h4>2.4 Зарезервированные слова</h4>
  <p>Типы данных</p>
  <ol>
    <li>char</li>
    <li>double</li>
    <li>enum</li>
    <li>float</li>
    <li>int</li>
    <li>long</li>
    <li>short</li>
    <li>struct</li>
    <li>union</li>
    <li>unsigned</li>
    <li>void</li>
  </ol>
  <p>Классы памяти</p>
  <ol>
    <li>auto</li>
    <li>extern</li>
    <li>register</li>
    <li>static</li>
  </ol>
  <p>Операторы</p>
  <ol>
    <li>break</li>
    <li>case</li>
    <li>continue</li>
    <li>default</li>
    <li>do</li>
    <li>else</li>
    <li>for</li>
    <li>goto</li>
    <li>if</li>
    <li>return</li>
    <li>sizeof</li>
    <li>switch</li>
    <li>typedef</li>
    <li>while</li>
  </ol>
</article>


<!-- 3 Основные типы данных -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>3 Основные типы данных (11)</h3>

  <p>К основным типам данных относятся символы, целые числа и числа с плавающей точкой. На их основе строятся производные типы данных.</p>

  <h4>3.1 Целые константы</h4>
  <p>Десятичные. Состоят из цифр от 0 до 9. Первой цифрой не может быть 0.</p>
  <p>Восьмеричные. Состоят из цифр от 0 до 7. Первая цифра всегда должна быть 0.</p>
  <p>Шестнадцатеричные. Состоят из цифр от 0 до 9 и букв от A до F. Первые два знака числа это 0x.</p>

  <h4>3.2 Длинные целые константы</h4>
  <p>Десятичные, восьмеричныи и шестнадцатеричные числа могут быть представлены в виде длинной целой константы. Для этого в конце числа должна быть буква L.</p>

  <h4>3.3 Константы с плавающей точкой</h4>
  <p>Константы с плавающей точкой имеют две части - мантису, это целое число до десятичной точки и порядок, это степень в которую возводится мантисса. Имеет две записи - через точку и через букву E.</p>

  <h4>3.4 Символьные константы</h4>
  <p>Символьная константа состоит из одного символа кода ASCCII записанного в апострофах ''.</p>

  <h4>3.5 Строковые константы</h4>
  <p>Строковая константа состоит из последовательности символов кода ASCCII записанной в двойных кавычках "". Строковая константа это массив символов, она имеет тип char []. В конце каждой строки компилятор вставляет нулевой символ '\0' означающий конец строки. Каждая строковая константа сохраняется в отдельном месте в памяти.</p>

  <h4>3.6 Перечислимые константы</h4>
  <p>Перечислимые коснтанты объявляются с помощью слова enum. Каждая такая константа имеет целое значение и трактуется как целая константа.</p>

  <h4>3.7 Размер данных</h4>
  <ol>
    <li>char 8</li>
    <li>int 16 или 32</li>
    <li>short 16</li>
    <li>long 32</li>
    <li>float 32</li>
    <li>double 64</li>
  </ol>
</article>


<!-- 4 Операции и выражения -->
<article class="article">
  <div class="anchor" id="p4"></div>
  <h3>4 Операции и выражения (17)</h3>

  <h4>4.1 Выражения</h4>
  <p>Выражение состоит из операндов и символов операций.</p>

  <h4>4.2 Метаобозначения операндов</h4>
  <p>Каждая операция требует операнды определенного вида.</p>

  <h4>4.3 Арифметические операции</h4>
  <p>Арифметические операции производятся над числами. Складывать и вычитать можно также адрес с числом. Инкремент и декремент можно применять к указателям, при этом указатель будет показывать на следующий или предыдущий адрес объекта того же типа. При инкременте и декременте изменяется значение операнда.</p>

  <h4>4.4 Операция присваивания</h4>
  <p>Значением выражения, в которое входит операция присваивания (=), является значение левого операнда после присваивания.</p>
  <p>Арифметичкские и побитовые операции могут буть объединены с операцией присваивания (+=, -=).</p>

  <h4>4.5 Операции отношения</h4>
  <p>Логическое false представляется нулевым значением. Логическое true представляется любым ненулевым значением. Логические отношения (==, >, >=) возвращают только 0 или 1.</p>

  <h4>4.6 Логические операции</h4>
  <p>Логические операции (&&,||) вначале вычисляют и определяют значение первого выражения и если результат неизвестен, то переходят к вычислению и проверке второго выражения.</p>

  <h4>4.7 Побитовые операции</h4>
  <p>~ дополнение до 1. Меняет в разрядах двоичного числа 1 на 0 и 0 на 1.</p>

  <h4>4.8 Адресные операции</h4>
  <p>&v возвращает адрес переменной v</p>
  <p>*pv возвращает значение переменной, на адрес которой указывает указатель pv.</p>

  <h4>4.9 Операции над массивами</h4>
  <p>Если pe это имя массива, то pe[v] это переменная, отстоящая на v переменных от адреса, заданного pe. pe[v] эквивалентно *(pe + v)</p>

  <h4>4.10 Операции над структурами или объединениями</h4>
  <p>Если sv это имя структуры или объединения, то sv.elem это элемент структуры или объединения.</p>
  <p>Если psv это указатель на структуру или объединение, то psv->elem это элемент структуры или объединения. Запись psv->elem эквивалентна записи *(psv).elem</p>

  <h4>4.11 Другие операции</h4>
  <p>Тернарный оператор a ? b1 : b2</p>
  <p>Оператор запятая. Значением выражения e1, e2 будет значение выражения e2, при этом сначала выполнится выражение e1, потом выражение e2.</p>
  <p>Оператор sizeof возвращает число байт, требуемых для размещения типа данных.</p>
  <p>Операция приведения к типу. Например (int)a приводит переменную a к типу int.</p>
  <p>Оператор круглые скобки () выполняет вызов функции. Значением является возвращаемое значение из функции.</p>

  <h4>4.12 Приоритеты и порядок выполнения операций</h4>
  <p>Если в одном выражении встречаются несколько операций, то они будут выполнены в порядке их приоритета.</p>

  <h4>4.13 Порядок обработки операндов</h4>
  <p>Для четырех операций (&& || ?: ,) гарантируется что левый операнд будет обрабатываться первым. Для остальных операций порядок может быть разным на разных компиляторах.</p>
  <p>Если в выражении значение переменной изменяется (например при присваивании или инкременте), то не используйте больше эту переменную в этом выражении второй раз.</p>

  <h4>4.14 Арифметические преобразования в выражениях</h4>
  <p>Если один из операторов имеет тип int, то операторы с типами char и short преобразуются в тип int.</p>
  <p>Если один из операторов имеет тип unsigned int, то операторы с типами unsigned char и unsigbed short преобразуются в тип unsigned int.</p>
  <p>Если один из операторов имеет тип double, то остальные преобразуются в double.</p>
  <p>Если один из операторов имеет тип long, то остальные преобразуются в тип long.</p>
  <p>Если один из операторов имеет тип unsigned long, то остальные преобразуются в тип unsigned long.</p>
</article>


<!-- 5 Операторы -->
<article class="article">
  <div class="anchor" id="p5"></div>
  <h3>5 Операторы (32)</h3>

  <h4>5.1 Формат и вложенность</h4>
  <p>Формат. Один оператор может занимать одну или более строк. Два или больше операторов могут занимать одну строку.</p>
  <p>Вложенность. Операторы, управляющие порядком выполнения (if, switch, while и т.д.) могут быть вложены друг в друга.</p>

  <h4>5.2 Метка оператора</h4>
  <p>Метка это идентификатор с двоеточием в конце. Метка может стоять перед любым оператором, чтобы на этот оператор можно было перейти с помощью оператора goto.</p>

  <h4>5.3 Составной оператор</h4>
  <p>Составной оператор это несколько операторов записанных в фигурных скобках {}.</p>

  <h4>5.4 Оператор-выражение</h4>
  <p>Любое выражение с точкой с запятой ; является оператором.</p>
  <p>Оператор присваивания  a = 10;</p>
  <p>Оператор вызова функции f();</p>
  <p>Пустой оператор состоит тольо из точки с запятой ; необходим для обозначения пустого тела управляющего оператора.</p>

  <h4>5.5 Оператор завершения break</h4>
  <p>Прекращает выполнения ближайшего вложенного внешнего оператора switch, while, do, for и передает управление следующему за циклом оператору.</p>

  <h4>5.6 Оператор продолжения continue</h4>
  <p>Прекращает текущее выполнение цикла и переходит на следующую итерацию цикла while, do, for.</p>

  <h4>5.7 Оператор возврата return</h4>
  <p>Прекращает выполнение функции и возвращает управление в то место где эта функция вызывалась с передачей возвращаемого значения.</p>

  <h4>5.8 Оператор перехода goto</h4>
  <p>Переходит к оператору, помеченному меткой. Область действия ограничена текущей функцией.</p>

  <h4>5.9 Условный оператор if (else if, else)</h4>
  <p>Проверяет значение логического выражения, если истинно, то выполняется первое действие, если ложно то выполняется действия после слоа else.</p>

  <h4>5.10 Оператор-переключатель switch</h4>
  <p>switch содержит выражение. Каждый case содержит константу. Проверяется выражение и управление передается в case с соответствующей константой. Если ни одна из констант не выпала, то выполняется место с меткой default. Костанта в case не может содржать переменные или вызов функции. В операторах case не могут быть одинаковые константы.</p>

  <h4>5.11 Оператор цикла while</h4>
  <p>Если выражение в while истинно, то цикл выполняется до тех пор пока выражение не станет ложным. Значение выражение определяется до выполнения цикла.</p>

  <h4>5.12 Оператор цикла do-while</h4>
  <p>Сначала выполняется цикл do, потом определяется выражение. Если выражение ложно, то цикл заканчивается. Если выражение истинно, то цикл выполняется еще раз.</p>

  <h4>5.13 Оператор цикла for</h4>
  <p>for (выражение 1; выражение 2; выражение 3) {оператор}</p>
  <p>Выражение 1 описывает инициализацию цикла</p>
  <p>Выражение 2 проверка условия завершения цикла</p>
  <p>Выражение 3 вполняется после итерации цикла перед проверкой условия для следующей итерации.</p>
</article>


<!-- 6 Функции -->
<article class="article">
  <div class="anchor" id="p6"></div>
  <h3>6 Функции (39)</h3>

  <h4>6.1 Определение функции</h4>
  <p>В объявлении функции пишется тип возвращаемого значения, имя функции, принимаемые параметры если есть, тело функции.</p>
  <p>Оператор return возвращает значение из функции. Оператор return не должен ничего возвращать или может отсутствовать если тип возвращаемого значения функции void.</p>

  <h4>6.2 Вызоы функции</h4>
  <p>Существует два способа вызова функции</p>
  <ol>
    <li>имя_функции()</li>
    <li>(*указатель_на_функцию)()</li>
  </ol>
  <p>Указатель_на_функцию это переменная содержащая адрес функции. Имя функции тоже содержит адрес функции. Адрес функции может быть присвоен любому указателю</p>
  <code>указатель = имя_функции;</code>
  <p>В качестве аргументов можно передавать выражения. При вызове функции сначала вычисляются значения переданных выражений, потом эти значения присваиваются параметрам функции.</p>
  <p>Вызов функции это выражение, значением которого является значение, возвращаемое функцией.</p>

  <h4>6.3 Функция main</h4>
  <p>Каждая программа начинает работу с функции main(). При вызове программы, ей можно передать аргументы через параметры функции main().</p>
</article>


<!-- 7 Описания -->
<article class="article">
  <div class="anchor" id="p7"></div>
  <h3>7 Описания (42)</h3>
  <p>Описания используются для определения переменных и для обхывления типов переменных и функций, определенных в другом месте.</p>

  <h4>7.1 Основные типы</h4>
  <p>Основными типами являютия char, int, short, long  и их беззнаковые версии, float, double, void.</p>

  <h4>7.2 Указатели и массивы</h4>
  <ol>
    <li>Указатель на основной тип. char *p. Переменная p является указателем на символ. Это значит что в переменной p должен быть адрес ячейки памяти с символом.</li>
    <li>Указатель на указатель. char **t. Переменная t указатель на указатель символа. Это значит что в переменной t должен быть адрес ячейки, в которой лежит адрес на ячейку с символом.</li>
    <li>Одномерный массив. int a[50]. Переменная a это массив из 50 целых чисел. Это значит что в переменной a лежит адрес на первый элемент массива.</li>
    <li>Двумерный массив. char m[7][50]. Переменная m это массив из семи массивов, каждый из которых содержит 50 символов.</li>
    <li>Массив указателей. char *r[7]. Переменная r это массив из семи указателей на символы.</li>
    <li>Указатель на функцию. int(*f)(). Эта функция возвращает целое число.</li>
  </ol>

  <h4>7.3 Структуры</h4>
  <p>Структура объединяет данные разных типов в одном месте.</p>
<pre>
struct имя_структуры {
  описание_элементов
};
</pre>
<pre>
struct dinner {
  char *place;
  float cost;
  struct dinner *next;
}
</pre>

  <h4>7.4 Поля бит в структурах</h4>
  <p>Поля бит предназначены для экономного размещения в памяти данных небольшого диапазона.</p>

  <h4>7.5 Объединения</h4>
  <p>Объединение описывает переменную, которая может иметь любой тип из некоторого множества типов. Определение объединения аналогично определению структуры.</p>
<pre>
union имя_объединения {
  описание_элементов
};
</pre>

  <h4>7.6 Перечисления</h4>
  <p>Каждое значение данного перечеслимого типа задается идентификатором.</p>
<pre>
enum color {
  red, green, yellow
};
</pre>

  <h4>7.7 Переименование типов</h4>
  <p>Используется для повышения понятности программы.</p>
  <code>typedef старый_тип новый_тип</code>
  <code>typedef long large</code>

  <h4>7.8 Определение локальных переменных</h4>
  <p>Постоянные переменные, сохранаяемые в некоторой области памяти, инициализируются нулем, если явно не заданы начальные значения.</p>
  <p>Временные переменные, сохраняемые в стеке или регистре, содержат мусор, если явно не заданы начальные значения.</p>
  <p>Переменная, определенная в блоке из фигурных скобок {} существует только в этом блоке.</p>
  <p>Регистровая переменная сохраняется в регистрах, если они доступны. Доступ к регистровой переменной более быстрый. К регистровым переменным не применима операция получения адреса &.</p>
  <p>Параметры функции это временные переменные, которые получают значения при вызове функции.</p>
  <code>register int x;</code>
  <p>Статические переменные являются постоянными, так как их значения не теряются при выходе из функции. любые переменные в блоке, кроме параметров функции, могут быть определены как статические. Область действия является блок.</p>
  <code>{static int flag;}</code>

  <h4>7.9 Определение глобальных переменных</h4>
  <p>Глобальные переменные определяются на том же уровне что и функции, т.е. не локальны ни в каком блоке. Постоянные. Инициализируются нулем если не задано начальное значение. Областью действия является вся программа. Должны быть определены только в одном файле и описаны как внешние во всех файлах программы, в которых к ним есть обращения.</p>
  <code>int x;</code>
  <p>Глобальная статическая переменная объявляется на уровне функций при помощи слова static. Область действия один файл.</p>
  <code>static int y;</code>

  <h4>7.10 Инициалиация переменных</h4>
  <p>Переменная может быть инициализирована при объявлении. В качестве начального значения может использоваться любое константное выражение.</p>
  <code>int i = 1;</code>
  <code>int a[] = {1,2,3}</code>
  <code> int b[5] = {1,2,3}</code>
  <p>Если задан размер массива, то значения, не заданные явно, равны 0. Если размер массива не задан, то он определяется по числу начальных значений.</p>

  <h4>7.11 Описание внешних объектов</h4>
  <p>Тип внешних объектов, определенных в другом файле программы, должен быть явно описан.</p>
  <code>extern int x;</code>
  <code>extern int func();</code>
  <p>Если функция не возвращает значение, то ее тип задается как void. Если тип функции не задан, то считается, что она имеет тип int.</p>
</article>


<!-- 8 Препроцессор -->
<article class="article">
  <div class="anchor" id="p8"></div>
  <h3>8 Препроцессор (52)</h3>
  <p>Если строка начинается с символа #, то это командная строка препроцессора. Командная строка препроцессора заканчивается символом перевода на новую строку. Если в конце строки поставить символ обратный слеш '\' то командная строка будет продолжена на следующей строке.</p>

  <h4>8.1 Замена идентификаторов</h4>
  <code>#define STO 100</code>
  <p>Везде в программе константа STO будет заменена на 100.</p>
  <code>#undef STO</code>
  <p>Отменяет определение инедтификатора.</p>

  <h4>8.2 Макросы</h4>
  <p>Для исключения ошибок, параметры макроса необходимо заключать в скобки ().</p>

  <h4>8.3 Включение файлов</h4>
  <code>#include &lt;math.h&gt;</code>
  <p>Препроцессор заменит эту строку содержимым файла math.h. Угловые скобки означают, что файл math.h будет взят из стандартного каталога.</p>
  <code>#include "abc.h"</code>
  <p>Препроцессор заменит эту строку содержимым файла abc.h. Двойные кавычки означают, что файл abc.h будет взят из текущего каталога.</p>

  <h4>8.4 Условная компиляция</h4>
  <p>Если abc не равно нулю.</p>
  <code>#if ABC</code>
  <p>Если константа DEUBG определена директивой #define</p>
  <code>#ifdef DEBUG</code>
  <p>Если константа PROD еще не определена директивой #define</p>
  <code>#ifndef PROD</code>
  <p>Если проверки #if, #ifdef, #ifndef истинны, то выполнять следующий код. Если ложны, то выполнять код после директивы #else. Такая условная конструкция всегда должна заканчиваться директивой #endif.</p>

  <h4>8.5 Номер строки и номер файла</h4>
  <code>#line 20 "abc"</code>
  <p>Препроцессор изменяет номер текущей строки и имя компилируемого файла. Имя файла может быть опущено.</p>
</article>


<!-- 9 Структура программы -->
<article class="article">
  <div class="anchor" id="p9"></div>
  <h3>9 Структура программы (55)</h3>

  <p>Напишем программу, которая вводит до MAXLINES строк со стандартного входа, сортирует строки в лексикографическом порядке, возрастающем или убывающем в зависимости от признака, передаваемого функции main() через аргумент argv. Затем программа записывает отсортированные строки на стандартный выход. Стандартным входом и выходом (stdin и stdout) могут быть терминал, канал или некоторый файл.</p>

  <h4>Пояснения к программе</h4>
  <h4>Файл bblsort.h</h4>
<pre>
#define MAXLINES 100
#define LINESIZE (132 + 1)
</pre>
  <p>Поименованные константы, используемые во всей программе, обычно помещаются в отдельный файл, включаемый в другие файлы программы по мере необходимости. Поэтому при изменении этих параметров будет затронут только один файл.</p>

  <h4>Файл main.c</h4>
<pre>
#include &lt;stdio.h&gt;
#include "bblsort.h"

static int rdlines();
static void wrlines(register int);
void bblsort(register int);

char Line[MAXLINES][LINESIZE]; // буфер строк
int Revflg; // признак направления сортировки

// сортировка строк текста
int main(int argc, char **argv) {
  int numlines;

  Revflg = (argc > 1 && argv[1][0] == '-');

  printf("Enter 3 lines\n");
  numlines = rdlines();
  bblsort(numlines);
  printf("\nHere 3 lines in order\n");
  wrlines(numlines);
}

// чтение строк со стандартного входа
static int rdlines() {
  char *fgets();
  register int i;
  for (i = 0; i &lt; MAXLINES; i++) {
    if (fgets(Line[i], LINESIZE, stdin) == (char *)NULL) {
      break;
    }
  }
  return i;
}

// запись строк на стандартный выход
static void wrlines(register int n) {
  register int i;
  for (i = 0; i &lt; n; i++) {
    fputs(Line[i], stdout);
  }
}
</pre>
  <p>В начале программы подключаются необходимые файлы. Файл stdio.h содержит описания файлов stdin, stdout и константы NULL, необходимых для использования функций fgets() и fputs().</p>
  <p>Типы функций описываются до их вызова.</p>
  <p>Глобальные переменные размещаются в начале файла. Глобальный массив буфера строк и глобальный признак направления сортировки.</p>
  <p>Если функция main() использует параметры, то они должны быть описаны. Функция main() выполняется первой и принимает аргументы из командной строки операционной системы при вызове программы.</p>
  <p>Переменная numlines описана как локальная в блоке с типом int.</p>
  <p>Первый аргумент argv, передаваемый функции main() является именем программы. argv[1] это второй аргумент и argv[1][0] это первый символ второго аргумента. Перед обращением к argv[1][0] проверяется число аргументов argc. При отсутствии второго аргумента выражение argv[1][0] не имеет смысла.</p>
  <p>Функция rdlines() возвращает целое число прочитанных строк, так как она определена как имеющая тип int. Слово static указывает, что функция используется только в данном файле. Переменная i определена как локальная в блоке. Слово register это попытка ускорить выполнение цикла for.</p>
  <p>Поскольку fgets() возвращает значение типа char*, то это значение должно сравниваться с указателем на символ. Поэтому нулевой указатель NULL преобразуется к типу (char*).</p>
  <p>Функция wrlines() не возвращает значения, поэтому она определена как имеющая тип void.</p>
  <p>Параметр n оаркдклкн со словом register для ускорения цикла.</p>

  <h4>bblsort.c</h4>
<pre>
#include "bblsort.h"

static int lexcmp(register int, register int);
static void swap(register int, register int);

extern char Line[][LINESIZE];

// bubble sort
void bblsort(register int n) {
  register int i, j;

  for (i = 1; i &lt;= n - 1; i++) {
    for (j = n - 1; j >= i; j--) {
      if (lexcmp(j - 1, j)) {
        swap(j - 1, j);
      }
    }
  }
}

static int lexcmp(register int i, register int j) {
  int strcmp();
  extern int Revflg;
  register int lc;
  lc = strcmp(Line[i], Line[j]);
  return ((lc &lt; 0 && Revflg) || (lc > 0 && !Revflg));
}

static void swap(register int i, register int j) {
  char *strcpy();
  char temp[LINESIZE];

  strcpy(temp, Line[i]);
  strcpy(Line[i], Line[j]);
  strcpy(Line[j], temp);
}
</pre>
  <p>Чтобы все заработало надо скомпилировать три файла в одну программу</p>
  <code>gcc main.c bblsort.c</code>
</article>


<!-- 10 Библиотека ввода-вывода -->
<article class="article">
  <div class="anchor" id="p10"></div>
  <h3>10 Библиотека ввода-вывода (60)</h3>

  <p>Файл stdio.h содержит:</p>
  <p>Определение типа данных FILE</p>
  <p>Определение параметров: stdin, stdout, stderr, NULL, EOF</p>
  <p>Макроопределения: putc(), getc(), putchar(), getchar(), ferror(), clearerr(), feof(), fileno()</p>

  <h4>10.1 Доступ к файлам</h4>
  <p>Открыть поток ввода-вывода</p>
  <code>FILE *fopen(char *filename, char *type);</code>

  <p>Закрыть поток stream и открыть файл newfile</p>
  <code>FILE *freopen(char *newfile, char *type, FILE *stream);</code>

  <p>Связать поток с дескриптором файла</p>
  <code>FILE *fdopen(int fildes, char *type);</code>

  <p>Закрыть открытый поток ввода-вывода stream</p>
  <code>int fclose(FILE *stream);</code>

  <p>Записать символы из буфера в выходной поток stream</p>
  <code>int fflush(FILE *stream);</code>

  <p>Изменить текущую позицию offset в файле stream</p>
  <code>int fseek(FILE *stream, long offset, int ptrname);</code>

  <p>Переставить указатель текущего байта в потоке на начало файла</p>
  <code>void rewind(FILE *stream);</code>

  <p>Модифицировать буфер потока</p>
  <code>void setbuf(FILE *stream, char *buf);</code>

  <p>Модифицировать буфер потока</p>
  <code>int setvbuf(FILE *stream, char *buf, int type, int size);</code>

  <h4>10.2 Доступ к каналам</h4>
  <p>Создать поток как канал обмена между процессами</p>
  <code>FILE *popen(char *command, char *type);</code>

  <p>Закрыть поток, открытый функцией popen</p>
  <code>int pclose(FILE *stream);</code>

  <h4>10.3 Состояние файла</h4>
  <p>Обнулить признаки ошибки потока</p>
  <code>void clearerr(FILE *stream);</code>

  <p>Проверить состояние конца файла в потоке</p>
  <code>int feof(FILE *stream);</code>

  <p>Проверить состояние ошибки в потоке</p>
  <code>int ferror(FILE *stream);</code>

  <p>Связать дескриптор файла, открытого функцией open с существующим потоком</p>
  <code>int fileno(FILE *stream);</code>

  <h4>10.4 Форматированный ввод-вывод</h4>
  <p>Функции printf, fprintf, sprintf описаны в разделе 12.</p>
  <p>Функции scanf, fscanf, sscanf описаны в разделе 13.</p>

  <h4>10.5 Ввод-вывод строк</h4>
  <p>Прочитать строку из входного потока stream, включая символ новой строки</p>
  <code>char *fgets(char *s, int n, FILE *stream);</code>

  <p>Прочитать строку из стандартного ввода stdin</p>
  <code>char *gets(char *s);</code>

  <p>Записать строку в выходной поток stream</p>
  <code>int fputs(char *s, FILE *stream);</code>

  <p>Записать строку в стандартный вывод stdout</p>
  <code>int puts(char *s);</code>

  <h4>10.6 Ввод символа</h4>
  <p>Прочитать следующий символ из входного потока stream</p>
  <code>int fgetc(FILE *stream);</code>

  <p>Прочитать следующий символ из входного потока</p>
  <code>int getc(FILE *stream);</code>

  <p>Прочитать следующий символ из стандартного ввода stdin</p>
  <code>int getchar();</code>

  <p>Вернуть символ во входной поток</p>
  <code>int ungetc(int c, FILE *stream);</code>

  <h4>10.7 Вывод символа</h4>
  <p>Записать символ в поток</p>
  <code>int fputc(int c, FILE *stream);</code>

  <p>Записать символ в поток</p>
  <code>int putc(int c, FILE *stream);</code>

  <p>Записать символ в стандартный вывод stdout</p>
  <code>int putchar(int c);</code>

  <h4>10.8 Блочный ввод-вывод</h4>
  <p>Прочитать из входного потока определенное число байт (символов)</p>
  <code>int fread(char *ptr, int size, int nitems, FILE *stream);</code>

  <p>Записать в выходной поток определенное число байт</p>
  <code>int fwrite(char *ptr, int size, int nitems, FILE *stream);</code>
</article>


<!-- 11 Другие библиотеки -->
<article class="article">
  <div class="anchor" id="p11"></div>
  <h3>11 Другие библиотеки (65)</h3>

  <h4>11.1 Выполнение команд языка shell</h4>
  <p>Подключить stdio.h</p>
  <p>Выполнит команду языка shell</p>
</article>

