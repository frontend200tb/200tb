<article class="article">
  <h1>2016 Майк МакГрат - Программирование на Си для начинающих. 192c</h1>
  <p>Конспект книги</p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
    <a href="#p1">1 Приступаем к работе (9)</a>
    <br>&nbsp;&nbsp;<a href="#p1.1">1.1 Введение в язык Си (10)</a>
    <br>&nbsp;&nbsp;<a href="#p1.2">1.2 Установка компилятора языка Си (12)</a>
    <br>&nbsp;&nbsp;<a href="#p1.3">1.3 Написание программы на языке Си (14)</a>
    <br>&nbsp;&nbsp;<a href="#p1.4">1.4 Компилирование программы на языке Си (16)</a>
    <br>&nbsp;&nbsp;<a href="#p1.5">1.5 Понимание процесса компилирования (18)</a>
  </p>

  <p>
    <a href="#p2">2 Сохранение значений переменных (21)</a>
    <br>&nbsp;&nbsp;<a href="#p2.1">2.1 Создание переменных в программе (22)</a>
    <br>&nbsp;&nbsp;<a href="#p2.2">2.2 Отображение значений переменных (24)</a>
    <br>&nbsp;&nbsp;<a href="#p2.3">2.3 Ввод значений переменных (26)</a>
    <br>&nbsp;&nbsp;<a href="#p2.4">2.4 Спецификаторы типов данных (28)</a>
    <br>&nbsp;&nbsp;<a href="#p2.5">2.5 Использование глобальных переменных (30)</a>
    <br>&nbsp;&nbsp;<a href="#p2.6">2.6 Размещение переменных в регистрах (32)</a>
    <br>&nbsp;&nbsp;<a href="#p2.7">2.7 Преобразование типов данных (34)</a>
    <br>&nbsp;&nbsp;<a href="#p2.8">2.8 Создание массивов переменных (36)</a>
    <br>&nbsp;&nbsp;<a href="#p2.9">2.9 Описание нескольких измерений (38)</a>
  </p>

  <p>
    <a href="#p3">3 Установка значений переменных (41)</a>
    <br>&nbsp;&nbsp;<a href="#p3.1">3.1 Объявление констант в программе (42)</a>
    <br>&nbsp;&nbsp;<a href="#p3.2">3.2 Перечисление значений констант (44)</a>
    <br>&nbsp;&nbsp;<a href="#p3.3">3.3 Создание константного типа (46)</a>
    <br>&nbsp;&nbsp;<a href="#p3.4">3.4 Определение констант (48)</a>
    <br>&nbsp;&nbsp;<a href="#p3.5">3.5 Отладка с помощью определений (50)</a>
  </p>

  <p>
    <a href="#p4">4 Выполнение операций (53)</a>
    <br>&nbsp;&nbsp;<a href="#p4.1">4.1 Выполнение арифметических операций (54)</a>
    <br>&nbsp;&nbsp;<a href="#p4.2">4.2 Присваивание значений (56)</a>
    <br>&nbsp;&nbsp;<a href="#p4.3">4.3 Сравнение значений (58)</a>
    <br>&nbsp;&nbsp;<a href="#p4.4">4.4 Логические значения (60)</a>
    <br>&nbsp;&nbsp;<a href="#p4.5">4.5 Проверка условий (62)</a>
    <br>&nbsp;&nbsp;<a href="#p4.6">4.6 Измерение размера (64)</a>
    <br>&nbsp;&nbsp;<a href="#p4.7">4.7 Сравнение битовых значений (66)</a>
    <br>&nbsp;&nbsp;<a href="#p4.8">4.8 Флаги (68)</a>
    <br>&nbsp;&nbsp;<a href="#p4.9">4.9 Знакомство с приоритетами (70)</a>
  </p>

  <p>
    <a href="#p5">5 Создание утверждений (73)</a>
    <br>&nbsp;&nbsp;<a href="#p5.1">5.1 Проверка значений выражений (74)</a>
    <br>&nbsp;&nbsp;<a href="#p5.2">5.2 Ветвление с помощью операции switch (76)</a>
    <br>&nbsp;&nbsp;<a href="#p5.3">5.3 Зацикливание с помощью счетчика (78)</a>
    <br>&nbsp;&nbsp;<a href="#p5.4">5.4 Зацикливание с помощью условия (80)</a>
    <br>&nbsp;&nbsp;<a href="#p5.5">5.5 Досрочный выход из циклов (82)</a>
    <br>&nbsp;&nbsp;<a href="#p5.6">5.6 Переход к меткам (84)</a>
  </p>

  <p>
    <a href="#p6">6 Использование функций (87)</a>
    <br>&nbsp;&nbsp;<a href="#p6.1">6.1 Объявление функций (88)</a>
    <br>&nbsp;&nbsp;<a href="#p6.2">6.2 Передача аргументов (90)</a>
    <br>&nbsp;&nbsp;<a href="#p6.3">6.3 Рекурсивные вызовы (92)</a>
    <br>&nbsp;&nbsp;<a href="#p6.4">6.4 Размещение функций в заголовках (94)</a>
    <br>&nbsp;&nbsp;<a href="#p6.5">6.5 Ограничение доступности (96)</a>
  </p>

  <p>
    <a href="#p7">7 Указатели (99)</a>
    <br>&nbsp;&nbsp;<a href="#p7.1">7.1 Получение доступа к данным с помощью указателей (100)</a>
    <br>&nbsp;&nbsp;<a href="#p7.2">7.2 Арифметика указателей (102)</a>
    <br>&nbsp;&nbsp;<a href="#p7.3">7.3 Передача указателей в функции (104)</a>
    <br>&nbsp;&nbsp;<a href="#p7.4">7.4 Создание массивов указателей (106)</a>
    <br>&nbsp;&nbsp;<a href="#p7.5">7.5 Указатели на функции (108)</a>
  </p>

  <p>
    <a href="#p8">8 Работа со строками (111)</a>
    <br>&nbsp;&nbsp;<a href="#p8.1">8.1 Чтение строк (112)</a>
    <br>&nbsp;&nbsp;<a href="#p8.2">8.2 Копирование строк (114)</a>
    <br>&nbsp;&nbsp;<a href="#p8.3">8.3 Объединение строк (116)</a>
    <br>&nbsp;&nbsp;<a href="#p8.4">8.4 Поиск подстрок (118)</a>
    <br>&nbsp;&nbsp;<a href="#p8.5">8.5 Валидация строк (120)</a>
    <br>&nbsp;&nbsp;<a href="#p8.6">8.6 Преобразование строк (122)</a>
  </p>

  <p>
    <a href="#p9">9 Создание структур (125)</a>
    <br>&nbsp;&nbsp;<a href="#p9.1">9.1 Группирование данных в структуру (126)</a>
    <br>&nbsp;&nbsp;<a href="#p9.2">9.2 Определение типа данных с помощью структуры (128)</a>
    <br>&nbsp;&nbsp;<a href="#p9.3">9.3 Использование указателей в структурах (130)</a>
    <br>&nbsp;&nbsp;<a href="#p9.4">9.4 Указатели на структуры (132)</a>
    <br>&nbsp;&nbsp;<a href="#p9.5">9.5 Передача структур в функции (134)</a>
    <br>&nbsp;&nbsp;<a href="#p9.6">9.6 Группирование данных в объединение (136)</a>
    <br>&nbsp;&nbsp;<a href="#p9.7">9.7 Выделение памяти (138)</a>
  </p>

  <p>
    <a href="#p10">10 Получение результата (141)</a>
    <br>&nbsp;&nbsp;<a href="#p10.1">10.1 Создание файла (142)</a>
    <br>&nbsp;&nbsp;<a href="#p10.2">10.2 Чтение и запись символов (144)</a>
    <br>&nbsp;&nbsp;<a href="#p10.3">10.3 Чтение и запись строк (146)</a>
    <br>&nbsp;&nbsp;<a href="#p10.4">10.4 Считывание и запись файлов целиком (148)</a>
    <br>&nbsp;&nbsp;<a href="#p10.5">10.5 Сканирование файловых потоков (150)</a>
    <br>&nbsp;&nbsp;<a href="#p10.6">10.6 Сообщение об ошибках (152)</a>
    <br>&nbsp;&nbsp;<a href="#p10.7">10.7 Получение даты и времени (154)</a>
    <br>&nbsp;&nbsp;<a href="#p10.8">10.8 Запуск таймера (156)</a>
    <br>&nbsp;&nbsp;<a href="#p10.9">10.9 Генерация случайных чисел (158)</a>
    <br>&nbsp;&nbsp;<a href="#p10.10">10.10 Отображение диалогового окна (160)</a>
  </p>

</article>


<!-- 1. Приступаем к работе -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h2>1. Приступаем к работе (9стр)</h2>
</article>


<!-- 1.1 Введение в язык Си -->
<article class="article">
  <div class="anchor" id="p1.1"></div>
  <h3>1.1 Введение в язык Си (10стр)</h3>

  <p>Си - компьютерный язык программирования, созданный Деннисом Ритчи для операционной системы Unix на компьютере PDP-11 в 1972 году. Его предшественником был язык B созданный в 1970 году.</p>
  <p>Операционная система Unix и фактически все ее приложения написаны на языке Си. Однако программы на языке Си можно создавать и на Windows.</p>
  <p>На основе Си созданы более громоздкие языки Java, C++, C#. Язык Си лучше подходит для начинающих, поскольку он более компактный и легкий.</p>
  <p>Программисты со всего мира используют язык Си, поскольку он позволяет получить максимальный контроль над выполнением программ и повышает их эффективность.</p>
  <p>В стандарте языка Си определены несколько библиотек, которые могут быть использованы в ваших собственных программах.</p>
</article>


<!-- 1.2 Установка компилятора языка Си -->
<article class="article">
  <div class="anchor" id="p1.2"></div>
  <h3>1.2 Установка компилятора языка Си (12стр)</h3>

  <p>Программы на языке Си изначально создаются как простыые текстовые файлы, сохраняемые с расширением .c. Они могут быть написаны в любом текстовом редакторе. Для того чтобы выполнить программу, написанную на языке Си, необходимо ее скомпилировать в байт-код, который компьютер сможет понять.</p>
  <p>Компилятор GNU C Cjmpiler (GCC) включен во все дистрибутивы Linux.</p>
  <p>Для Windows нужно установить пакет Minimalist GNU for Windows (MinGW), который содержит компилятор GCC</p>
</article>


<!-- 1.3 Написание программы на языке Си -->
<article class="article">
  <div class="anchor" id="p1.3"></div>
  <h3>1.3 Написание программы на языке Си (14стр)</h3>

  <p>Функция main() - стартовая точка всех программ на языке Си. Компилятор не будет компилировать код, если не найдет внутри программы функцию main()</p>
  <p>При изучении языка программирования в первую очередь пишут программу, выводящую на экран сообщение Hello World!</p>

  <details>
    <summary>Программа 1 (15стр)</summary>
    <p>Выведем на экран сообщение Hello World!</p>
<pre>
#include &lt;stdio.h&gt;

int main()
{
  printf("Hello World!\n");

  return 0;
}
</pre>
  <code>Hello World!</code>
  </details>
</article>


<!-- 1.4 Компилирование программы на языке Си -->
<article class="article">
  <div class="anchor" id="p1.4"></div>
  <h3>1.4 Компилирование программы на языке Си (16стр)</h3>

  <p>В командной строке перейдите в директорию с файлом программы и выполните команду для компилирования файла с именем hello.c</p>
  <code>gcc hello.c</code>
  <p>После компиляции, в этом же каталоге создастся исполняемый файл</p>
  <code>a.exe</code>
  <p>Следующая компиляция любого файла в этом каталоге перезапишет файл a.exe. Если нужно сохранить исполняемый файл для каждой программы отдельно, то нужно при компиляции дать ему другое имя. Например, скомпилируем файл hello.c в исполняемый с именем hello.exe</p>
  <code>gcc hello.c -o hello.exe</code>
</article>


<!-- 1.5 Понимание процесса компилирования -->
<article class="article">
  <div class="anchor" id="p1.5"></div>
  <h3>1.5 Понимание процесса компилирования (18стр)</h3>

  <p>При создании исполняемого файла из исходного файла с текстом программы, компилятор проходит  через четыре этапа и на каждом этапе создает новый файл</p>
  <ol>
    <li>Исходный код (.c)</li>
    <li>Подстановки (.i)</li>
    <li>Код ассемблера (.s)</li>
    <li>Объектный код (.o)</li>
    <li>Исполняемый файл (.exe)</li>
  </ol>

  <ol>
    <li>Предварительная обработка - препроцессор заменяет все директивы препроцессора на нужный код. Получается текстовый файл программы на языке Си с выполненными подстановоками с расширением .i</li>
    <li>Трансляция (преобразование) - компилятор транслирует исходный код в инструкции на языке ассемблера. Получается текстовый файл программы на языке Ассемблера с расширением .s</li>
    <li>Сборка - сборщик переводит инструкции с языка ассемблера в машинный код. Получается двоичный объектный файл с расширение .o</li>
    <li>Компоновка (линковка, связывание) - компоновщик (линкер) связывает полученные двоичные объектные файлы в один исполняемый файл. Полученный файл имеет расширение .exe</li>
  </ol>

  <p>После компиляции все временные файлы удаляются. Чтобы они не удалялись, надо в команду для компилятора добавить опции -save-temps</p>
  <code>gcc hello.c -save-temps</code>

  <p>Программы, написанные на языке ассемблера, могут работать быстрее и занимать меньше места, чем написанные на языке Си. Но их гораздо сложнее писать и поддерживать.</p>
</article>


<!-- 2. Сохранение значений переменных -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h2>2. Сохранение значений переменных (21стр)</h2>
</article>


<!-- 2.1 Создание переменных в программе -->
<article class="article">
  <div class="anchor" id="p2.1"></div>
  <h3>2.1 Создание переменных в программе (22стр)</h3>

  <p>Объявление переменной</p>
  <code>тип_данных имя_переменной;</code>
  <code>int num;</code>

  <p>Можно объявить несколько переменных с одним типом данных</p>
  <code>int num, sum, age;</code>

  <p>Инициализация переменной</p>
  <code>num = 10;</code>

  <p>Объявление с инициализацией</p>
  <code>int num = 10;</code>
  <p>Слева от знака равно стоят L-значения, справа R-значения</p>
</article>


<!-- 2.2 Отображение значений переменных -->
<article class="article">
  <div class="anchor" id="p2.2"></div>
  <h3>2.2 Отображение значений переменных (24стр)</h3>

  <p>Значение переменной можно вывести с помощью функции printf(). Для этого нужно указать спецификатор формата</p>
  <p>Буква в спецификаторе формата определяет тип данных</p>
  <p><strong>%d</strong> целое число от -32768 до +32767</p>
  <p><strong>%ld</strong> длинное целое число от -2<sup>31</sup> до +2<sup>31</sup></p>
  <p><strong>%f</strong> число с плавающей точкой</p>
  <p><strong>%c</strong> один символ</p>
  <p><strong>%s</strong> строка символов</p>
  <p><strong>%p</strong> адрес в памяти</p>

  <p>Цифра в спецификаторе формата определяет число символов, которое будет занимать число</p>
  <p><strong>%7d</strong> добавит пробелы перед числом, чтобы число заняло 7 символов</p>
  <p><strong>%07d</strong> добавит нули перед числом, чтобы число заняло 7 символов</p>
  <p><strong>%.10f</strong> выведет 10 цифр после точки, дополнив недостающие нулями в конце</p>
  <p><strong>%7.3f</strong> выведет 3 цифры после точки, добавит пробелы перед числом, чтобы число заняло 7 символов (включая символ точки)</p>
  <p><strong>%07.3f</strong> выведет 3 цифры после точки, добавит нули перед числом, чтобы число заняло 7 символов (включая символ точки)</p>
  <p><strong>%-10.3f</strong> добавит пробелы после числа, чтобы число заняло 10 символов (включая символ точки)</p>

  <details>
    <summary>Программа 2 (25стр)</summary>
<pre>
#include &lt;stdio.h&gt;

int main()
{
  int num = 100;
  double pi = 3.1415926536;

  printf("%%d %d\n", num);
  printf("%%f %f\n", pi);
  printf("%%7d %7d\n", num);
  printf("%%07d %07d\n", num);
  printf("%%.10f %.10f\n", pi);
  printf("%%7.3f %7.3f\n", pi);
  printf("%%07.3f %07.3f\n", pi);
  printf("%-10.3f %d\n", pi, 0);

  return 0;
}
</pre>
<pre>
%d 100
%f 3.141593
%7d     100
%07d 0000100
%.10f 3.1415926536
%7.3f   3.142
%07.3f 003.142
3.142      0
</pre>
  </details>
</article>


<!-- 2.3 Ввод значений переменных -->
<article class="article">
  <div class="anchor" id="p2.3"></div>
  <h3>2.3 Ввод значений переменных (26стр)</h3>

  <p>Для получения данных от пользователя используют функцию scanf(). Она принимает два аргумента - тип данных и место в памяти где они должны быть сохранены. Первый аргумент - тип данных определяется спецификатором формата. Второй аргумент - переменная, перед которой ставят &, чтобы получить адрес переменной.</p>

  <details>
    <summary>Программа 3 (27стр)</summary>
    <p>Программа принимает символ и два числа. Выводит на экран символ, его адрес в памяти, два числа и их адрес в памяти</p>
<pre>
#include &lt;stdio.h&gt;

int main() {
  char letter;
  int num1, num2;

  printf("Enter symbol ");
  scanf("%c", &letter);
  printf("Enter integer a b ");
  scanf("%d %d", &num1, &num2);
  printf("Symbol %c\n", letter);
  printf("Address symbol %p\n", &letter);
  printf("Integer %d %d\n", num1, num2);
  printf("Address integer %p %p\n", &num1, &num2);

  return 0;
}
</pre>
  </details>
</article>


<!-- 2.4 Спецификаторы типов данных -->
<article class="article">
  <div class="anchor" id="p2.4"></div>
  <h3>2.4 Спецификаторы типов данных (28стр)</h3>

  <p>Тип данных int по умолчани может быть short или long. Ее размер можно указать явно</p>
  <code>short num1;</code>
  <code>long num2;</code>

  <p>Заголовочный файл limits.h содержит размеры каждого типа данных, например INT_MIN, INT_MAX, SHRT_MIN, SHRT_MAX, LONG_MIN, LONG_MAX</p>
  <p>Перед беззнаковым типом ставят слово unsigned</p>
  <p>Оператор sizeof возвращает размер типа данных.</p>

  <details>
    <summary>Программа 4 (29стр)</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;limits.h&gt;

int main() {
  printf("char size %d byte\n", sizeof(char));
  printf("from %d to %d\n", CHAR_MIN, CHAR_MAX);

  printf("short int size %d bytes\n", sizeof(short int));
  printf("from %d to %d\n", SHRT_MIN, SHRT_MAX);

  printf("int size %d bytes\n", sizeof(int));
  printf("from %d to %d\n", INT_MIN, INT_MAX);

  printf("long int size %d bytes\n", sizeof(long int));
  printf("from %ld to %ld\n", LONG_MIN, LONG_MAX);

  printf("long long int size %d bytes\n", sizeof(long long int));
  printf("from %lld to %lld\n", LLONG_MIN, LLONG_MAX);

  printf("float size %d bytes\n", sizeof(float));
  printf("double size %d bytes\n", sizeof(double));
  printf("long double size %d bytes\n", sizeof(long double));

  return 0;
}
</pre>
  </details>
</article>


<!-- 2.5 Использование глобальных переменных -->
<article class="article">
  <div class="anchor" id="p2.5"></div>
  <h3>2.5 Использование глобальных переменных (30стр)</h3>

  <p>Локальные переменные - это переменные объявленные внутри функции. Их область видимости это функция в которой они объявлены, они видны только в ней</p>
  <p>Глобальные переменные - это переменные объявленные вне функций.У них глобальная область видимости, они видны внутри любой функции</p>
  <p>Внешние глобальные переменные должны быть объявлены всего один раз в начале программы. Они также должны быть объявлены внутри каждой функции, которая их будет использовать, с ключевым словом extern.</p>
  <p>Если программа стостоит из нескольких файлов и в этих файлах есть глобальные переменные и функции, то они доступны в любом месте программы. Если мы хотим чтобы глобальные переменные и функции были доступны только внутри тех файлов где были объявлены, то нужно объявлять их с ключевым словом static.</p>
  <p>Если объявить переменную внутри функции с ключевым словом static, то она будет доступна только внутри этой функции, но не пропадет по завершении работы функции и будет существовать до конца работы программы.</p>

  <details>
    <summary>Программа 5 (31стр)</summary>
    <p>Код в файле 05a.c</p>
<pre>
#include &lt;stdio.h&gt;

static int sum = 100;
extern int num;

int main()
{
  extern int sum;
  printf("sum is %d\n", sum);

  extern int num;
  printf("num is %d\n", num);

  return 0;
}
</pre>

  <p>Код в файле 05b.c</p>
<pre>
int num = 200;
</pre>
  </details>
</article>


<!-- 2.6 Размещение переменных в регистрах -->
<article class="article">
  <div class="anchor" id="p2.6"></div>
  <h3>2.6 Размещение переменных в регистрах (32стр)</h3>

  <p>Ключевое слово registr при объявлении переменной указывает компилятору, что эта переменная будет часто использоваться. Компилятор может разместить такие переменные в регистре, чтобы ускорить доступ к ним.</p>
  <p>С ключевым словом registr можно объявить только локальные переменные определенных типов. Часто компилятор игнорирует это слово.</p>
  <p>Ключевое слово volatile при объявлении переменной указывает компилятору не помещать ее в регистры, потому что она может измениться в любой момент.</p>

  <details>
    <summary>Программа 6 (33стр)</summary>
<pre>
#include &lt;stdio.h&gt;

int main()
{
  register int i = 0;
  while (i &lt; 5)
  {
    i++;
    printf("i is %d\n", i);
  }

  return 0;
}
</pre>
  </details>
</article>


<!-- 2.7 Преобразование типов данных -->
<article class="article">
  <div class="anchor" id="p2.7"></div>
  <h3>2.7 Преобразование типов данных (34стр)</h3>

  <p>Компилятор сам преобразует типы данных к одному типу когда происходят операции над данными разных типов</p>
  <p>Программисто может дать указание компилятору преобразовать один тип данных к другому. Это называется приведением типов</p>

  <details>
    <summary>Программа 7 (35стр)</summary>
<pre>
#include &lt;stdio.h&gt;

int main()
{
  int a = (int)5.75;
  char b = (char)257;
  float c = (float)0.1234567;

  printf("%d\n", a);
  printf("%d\n", b);
  printf("%f\n", c);

  return 0;
}
</pre>
  </details>
</article>


<!-- 2.8 Создание массивов переменных -->
<article class="article">
  <div class="anchor" id="p2.8"></div>
  <h3>2.8 Создание массивов переменных (36стр)</h3>

  <p>Массив может хранить несколько элементов. Элементы хранятся последовательно в ячейках массива, которые нумеруются начиная с нуля.</p>
  <p>Объявление массива</p>
  <code>тип_данных имя_массива [размер_массива]</code>
  <code>int nums[3]</code>
  <p>Можно не указывать размер если происходит объявление и инициализация</p>
  <code>char s = {'c', 'a', 't', '\0'}</code>

  <details>
    <summary>Пример 8 (37стр)</summary>
<pre>
#include &lt;stdio.h&gt;

int main()
{
  int nums[3];
  int nums1[3], nums2[6], nums3[9];

  printf("%d\n", nums[0]);
  printf("%d\n", nums1[0]);
  printf("%d\n", nums2[0]);
  printf("%d\n", nums3[0]);

  nums[0] = 10;
  int a[3] = {20, 30, 40};

  printf("%d\n", nums[0]);
  printf("%d\n", a[0]);

  int b[] = {1, 2, 3, 4};
  char str[5] = {'b', 'o', 'o', 'k', '\0'};
  printf("%s\n", str);

  return 0;
}
</pre>
  </details>
</article>


<!-- 2.9 Описание нескольких измерений -->
<article class="article">
  <div class="anchor" id="p2.9"></div>
  <h3>2.9 Описание нескольких измерений (38стр)</h3>

  <p>Массив с одним индексом является одномерным</p>
  <p>Если у массива несколько индексов - то он многомерный</p>
  <p>Массив с двумя индексами двумерный</p>

  <details>
    <summary>Программа 9 (39стр)</summary>
    <p>Вывести элементы двумерного массива</p>
<pre>
'A' 'B' 'C'
 1   2   3
</pre>
<pre>
#include &lt;stdio.h&gt;

int main()
{
  int matrix[2][3] = {{'A', 'B', 'C'}, {1, 2, 3}};

  printf("%c\n", matrix[0][0]);
  printf("%c\n", matrix[0][1]);
  printf("%c\n", matrix[0][2]);
  printf("%d\n", matrix[1][0]);
  printf("%d\n", matrix[1][1]);
  printf("%d\n", matrix[1][2]);

  return 0;
}
</pre>
  </details>
</article>


<!-- 3 Установка значений переменных -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h2>3 Установка значений переменных (41стр)</h2>
</article>


<!-- 3.1 Объявление констант в программе -->
<article class="article">
  <div class="anchor" id="p3.1"></div>
  <h3>3.1 Объявление констант в программе (42стр)</h3>

  <p>Если переменная не должна изменяться, то ее надо объявлять как константу. Константа должна инициализироваться при объявлении. Программа не может изменять значение константы.</p>
  <code>const int MIL = 1000000;</code>
  <p>Если имена констант писать большими буквами, то их легко отличить от переменных.</p>

  <details>
    <summary>Программа 10 (42стр)</summary>
    <p>Выведем на экран три константы - целое число, дробное число и массив</p>
<pre>
#include &lt;stdio.h&gt;

int main()
{
  const int MILLION = 1000000;
  const int FIVE[] = {1, 2, 3, 4, 5};
  const float PI = 3.141593;

  printf("%d\n", MILLION);
  printf("%d\n", FIVE[1]);
  printf("%f\n", PI);

  return 0;
}
</pre>
  </details>

  <details>
    <summary>Программа 11 (43стр)</summary>
    <p>Введем диаметр круга и используя константу пи посчитаем его радиус, окружность и площадь</p>
<pre>
#include &lt;stdio.h&gt;

int main()
{
  const float PI = 3.141593;
  float diameter, radius, circ, area;

  printf("Enter the diameter of a circle in millimeters: ");
  scanf("%f", &diameter);
  circ = PI * diameter;
  radius = diameter / 2;
  area = PI * (radius * radius);

  printf("circ %.2f\n", circ);
  printf("radius %.2f\n", radius);
  printf("area %.2f\n", area);

  return 0;
}
</pre>
  </details>
</article>


<!-- 3.2 Перечисление значений констант -->
<article class="article">
  <div class="anchor" id="p3.2"></div>
  <h3>3.2 Перечисление значений констант (44стр)</h3>

  <p><strong>Перечисление enum</strong> объявляет последовательность числовых констант имеющих свои имена. Если значение первой константы не определено, то она равна 0, следующая 1 и т.д.</p>
  <code>enum {MON, TUE, WED, THU, FRI}</code>
  <code>WED = 2</code>
  <p>Перечисление может иметь имя</p>
  <code>enum WEEK {MON, TUE, WED, THU, FRI}</code>
  <p>При объявлении каждой константе можно присвоить любое числовое значение, но если константа неопределена, то она будет иметь значение на 1 больше предыдущей</p>
  <code>enum {MON = 1, TUE, WED, THU, FRI}</code>
  <code>WED = 3</code>
  <p>Константы в перечислении могут иметь одинаковые значения</p>
  <code>enum {NIL = 0, NONE = 0}</code>

  <details>
    <summary>Программа 12 (45стр)</summary>
<pre>
#include &lt;stdio.h&gt;

int main()
{
  enum SNOOKER{RED = 1, YELLOW, GREEN, BROWN, BLUE, PINK, BLACK};
  int total;
  printf("I potted a red worth %d\n", RED);
  printf("Then a black worth %d\n", BLACK);
  printf("Followed by another red worth %d\n", RED);
  printf("And finaly a blue worth %d\n", BLUE);

  total = RED + BLACK + RED + BLUE;
  printf("All together I scored %d\n", total);

  return 0;
}
</pre>
  </details>
</article>


<!-- 3.3 Создание константного типа -->
<article class="article">
  <div class="anchor" id="p3.3"></div>
  <h3>3.3 Создание константного типа (46стр)</h3>

  <p>После того, как перечисление было создано, оно может быть рассмотрено как новый тип данных, его свойства - имена констант и их значения.</p>
  <p>Создадим новый тип данных</p>
  <code>enum BOOLEAN {FALSE, TRUE}</code>
  <p>Объявить переменную данного типа данных можно двумя способами. Первый написать ее имя после закрывающей скобки при объявлении нового типа данных</p>
  <code>enum BOOLEAN {FALSE, TRUE} flag</code>
  <p>Второй способ</p>
  <code>enum BOOLEAN flag = 1</code>
  <p>С помощью typedef можно определить пользовательские типы данных</p>
  <code>typedef unsigned short int USINT</code>
  <p>Теперь вместо длинного названия типа unsigned short int можно использовать короткое название USINT</p>

  <details>
    <summary>Программа 13 (47стр)</summary>
<pre>
#include &lt;stdio.h&gt;

int main()
{
  enum SNOOKER {RED = 1, YELLOW, GREEN, BROWN, BLUE, PINK, BLACK};
  enum SNOOKER pair = RED + BLACK;
  printf("Pair value: %d\n", pair);

  typedef unsigned short int USINT;
  USINT num = 16;
  printf("Unsigned short int value: %d\n", num);

  return 0;
}
</pre>
  </details>
</article>


<!-- 3.4 Определение констант -->
<article class="article">
  <div class="anchor" id="p3.4"></div>
  <h3>3.4 Определение констант (48стр)</h3>

  <p>Директива препроцессора #define может быть использована для указатия значений констант. Эта директива должна размещаться в начале файла перед кодом программы. Все константы из этой директивы будут перед компиляцией заменены своим значением.</p>
  <p>Директива препроцессора #ifdef называется макросом и проверяет определена ли указанная константа. Каждый макрос должен заканчиваться директиваой #endif</p>

  <details>
    <summary>Программа 14 (49стр)</summary>
<pre>
#include &lt;stdio.h&gt;
#define LINE "_________________"
#define TITLE "C programming in easy steps"
#define AUTHOR "Ivan Kashirin"
#ifdef _WIN32
#define SYSTEM "Windows"
#endif
#ifdef linux
#define SYSTEM "Linux"
#endif

int main()
{
  printf("%s\n%s\n", LINE, TITLE);
  printf("%s\n%s\n", AUTHOR, LINE);
  printf("%s\n", SYSTEM);

  return 0;
}
</pre>
  </details>
</article>


<!-- 3.5 Отладка с помощью определений -->
<article class="article">
  <div class="anchor" id="p3.5"></div>
  <h3>3.5 Отладка с помощью определений (50стр)</h3>

  <p>Директивы определяющие константу</p>
  <p>#define определяет константу</p>
  <p>#undef разопределяет константу</p>

  <p>Директивы позволяющие условное ветвление</p>
  <p>#if</p>
  <p>#else</p>
  <p>#elif (else if)</p>
  <p>#ifdef проверяет что константа уже определена</p>
  <p>#ifndef проверяет что константа еще не определена</p>
  <p>#endif заканчивает блок ветвления</p>

  <details>
    <summary>Программа 15 (50стр)</summary>
<pre>
#include &lt;stdio.h&gt;
#define DEBUG 1

int main() {
  #if DEBUG == 1
    printf("Debug status is 1\n");
  #elif DEBUG == 2
    printf("Debug status is 2\n");
  #else
    #ifdef DEBUG
      printf("Debug is defined\n");
    #endif
    #ifndef DEBUG
      printf("Debug is not defined\n");
    #endif
  #endif

  return 0;
}
</pre>
  </details>
</article>


<!-- 4 Выполнение операций -->
<article class="article">
  <div class="anchor" id="p4"></div>
  <h3>4 Выполнение операций (53стр)</h3>
</article>


<!-- 4.1 Выполнение арифметических операций -->
<article class="article">
  <div class="anchor" id="p4.1"></div>
  <h3>4.1 Выполнение арифметических операций (54стр)</h3>

  <p>Сложение +, вычитание -, умножение *, деление нацело /, остаток от деления %, инкремент ++, декремент --</p>

  <details>
    <summary>Программа 16 (55стр)</summary>
<pre>
#include &lt;stdio.h&gt;

int main()
{
  int a = 4, b = 8, c = 1, d = 1;
  printf("%d\n", a + b);
  printf("%d\n", a - b);
  printf("%d\n", a * b);
  printf("%d\n", a / b);

  printf("%d\n", a++);
  printf("%d\n", ++b);

  return 0;
}
</pre>
  </details>
</article>


<!-- 4.2 Присваивание значений -->
<article class="article">
  <div class="anchor" id="p4.2"></div>
  <h3>4.2 Присваивание значений (56стр)</h3>

  <code>a = b, a += b, a -= b, a *= b, a /= b, a %= b</code>

  <details>
    <summary>Программа 17 (57стр)</summary>
<pre>
#include &lt;stdio.h&gt;

int main()
{
  int a, b;
  printf("a = %d\n", a = 8);
  printf("b = %d\n", b = 4);
  printf("a += b, a = %d\n", a += b);
  printf("a -= b, a = %d\n", a -= b);
  printf("a *= b, a = %d\n", a *= b);
  printf("a /= b, a = %d\n", a /= b);
  printf("a %%= b, a = %d\n", a %= b);


  return 0;
}
</pre>
  </details>
</article>


<!-- 4.3 Сравнение значений -->
<article class="article">
  <div class="anchor" id="p4.3"></div>
  <h3>4.3 Сравнение значений (58стр)</h3>

  <p>==, !=, >, &lt;, >=, &lt;=</p>

  <details>
    <summary>Программа 18 (59стр)</summary>
<pre>
#include &lt;stdio.h&gt;

int main()
{
  int zero = 0, nil = 0, one = 1;
  char upr = 'A', lwr = 'a';

  printf("0 == 0 : %d\n", zero == nil);
  printf("0 == 1 : %d\n", zero == one);
  printf("A == a : %d\n", upr == lwr);
  printf("A != a : %d\n", upr != lwr);
  printf("1 > 0 : %d\n", one > nil);
  printf("1 &lt; 0 : %d\n", one &lt; nil);
  printf("0 >= 0 : %d\n", zero >= nil);
  printf("1 &lt;= 0 : %d\n", one &lt;= nil);

  return 0;
}
</pre>
  </details>
</article>


<!-- 4.4 Логические значения -->
<article class="article">
  <div class="anchor" id="p4.4"></div>
  <h3>4.4 Логические значения (60стр)</h3>

  <p>И &&, ИЛИ ||, НЕ !</p>

  <details>
    <summary>Программа 19 (61стр)</summary>
<pre>
#include &lt;stdio.h&gt;

int main()
{
  int yes = 1, no = 0;

  printf("no && no : %d\n", no && no);
  printf("yes && no : %d\n", yes && no);
  printf("yes && yes : %d\n", yes && yes);
  printf("no || no : %d\n", no || no);
  printf("yes || no : %d\n", yes || no);
  printf("yes || yes : %d\n", yes || yes);
  printf("!yes : %d\n", !yes);
  printf("!no : %d\n", !no);

  return 0;
}
</pre>
  </details>
</article>


<!-- 4.5 Проверка условий -->
<article class="article">
  <div class="anchor" id="p4.5"></div>
  <h3>4.5 Проверка условий (62стр)</h3>

  <p>Тернарный оператор &:</p>
  <code>num = (a > b) ? a: b;</code>

  <details>
    <summary>Программа 20 (63стр)</summary>
<pre>
#include &lt;stdio.h&gt;

int main()
{
  int num = 6;

  (num % 2 != 0) ?
  printf("%d is odd\n", num) : printf("%d is even\n", num);
  printf("There %s ", (num == 1) ? "is" : "are");
  printf("%d %s\n", num, (num == 1) ? "apple" : "apples");

  num = 1;

  (num % 2 != 0) ?
  printf("%d is odd\n", num) : printf("%d is even\n", num);
  printf("There %s ", (num == 1) ? "is" : "are");
  printf("%d %s\n", num, (num == 1) ? "apple" : "apples");

  return 0;
}
</pre>
  </details>
</article>


<!-- 4.6 Измерение размера -->
<article class="article">
  <div class="anchor" id="p4.6"></div>
  <h3>4.6 Измерение размера (64стр)</h3>

  <p>sizeof возвращает целое число - количество байт памяти выделенной под измеряемый объект. Измерить можно переменную, тип данных, массив</p>
  <code>sizeof(char); // 1</code>
  <p>sizeof массива складывается из размера типа данных умноженного на число элементов в массиве.</p>
  <code>sizeof(int[3]); // 12</code>

  <details>
    <summary>Программа 21 (65стр)</summary>
<pre>
#include &lt;stdio.h&gt;

int main()
{
  int num = 1234567890;

  printf("Size of int %d bytes\n", sizeof(int));
  printf("Size of num %d bytes\n", sizeof(num));
  printf("Size of num %d bytes\n", sizeof num);
  printf("Size of array %d bytes\n", sizeof(int[3]));

  struct {int score; char grade;} result;
  printf("Size of struct %d bytes\n", sizeof result);

  return 0;
}
</pre>
  </details>
</article>


<!-- 4.7 Сравнение битовых значений -->
<article class="article">
  <div class="anchor" id="p4.7"></div>
  <h3>4.7 Сравнение битовых значений (66стр)</h3>

  <p>Хотя тип данных char занимает 1 байт, можно совершать операции с каждый его битом отдельно с помощью битовых операций.</p>
  <p>| ИЛИ, & И, ~ НЕ, ^ исключающее ИЛИ, &lt;&lt; битовый сдвиг влево, &gt;&gt; битовый сдвиг вправо</p>
  <p>Битовые операции часто используются при программировании устройств с ограниченными ресурсами</p>

  <details>
    <summary>Программа 22 (67стр)</summary>
    <p>Поменяем значения двух переменных не используя третью переменную</p>
<pre>
#include &lt;stdio.h&gt;

int main()
{
  int x = 10, y = 5;
  printf("x = %d y = %d\n", x, y);

  x = x ^ y;
  y = x ^ y;
  x = x ^ y;
  printf("x = %d y = %d\n", x, y);

  return 0;
}
</pre>
  </details>
</article>


<!-- 4.8 Флаги -->
<article class="article">
  <div class="anchor" id="p4.8"></div>
  <h3>4.8 Флаги (68стр)</h3>

  <p>Переменная типа char занимает 1 байт и может содержать 8 флагов. Чтобы включить четвертый флаг, нужно записать в нее десятичное число 8 (1000<sub>2</sub>)</p>
  <p>Значения битовых флагов можно изменять с помощью битовой операции ~ НЕ, однако следует использовать маску для нулей идущих перед битовыми флагами. Чтобы изменить четыре первых флага числа, надо использовать битовую маску 15 (00001111<sub>2</sub>) с помощью битового оператора & И.</p>
  <p>Переменная типа int занимает 4 байта и может содержать 32 флага.</p>

  <details>
    <summary>Программа 23 (69стр)</summary>
<pre>
#include &lt;stdio.h&gt;

int main()
{
  char flags = 8; // 1000
  flags = flags | 2; // 1010
  printf("flag 1 %s\n", (flags & 1) > 0 ? "ON" : "OFF");
  printf("flag 2 %s\n", (flags & 2) > 0 ? "ON" : "OFF");
  printf("flag 3 %s\n", (flags & 4) > 0 ? "ON" : "OFF");
  printf("flag 4 %s\n", (flags & 8) > 0 ? "ON" : "OFF");

  char mask = 15; // 1111
  flags = ~flags & mask;
  printf("flag 1 %s\n", (flags & 1) > 0 ? "ON" : "OFF");
  printf("flag 2 %s\n", (flags & 2) > 0 ? "ON" : "OFF");
  printf("flag 3 %s\n", (flags & 4) > 0 ? "ON" : "OFF");
  printf("flag 4 %s\n", (flags & 8) > 0 ? "ON" : "OFF");
  printf("flags %d\n", flags);

  return 0;
}
</pre>
  </details>
</article>


<!-- 4.9 Знакомство с приоритетами -->
<article class="article">
  <div class="anchor" id="p4.9"></div>
  <h3>4.9 Знакомство с приоритетами (70стр)</h3>

  <p>Приоритет операций определяет порядок в котором выполняются операции в выражении.</p>

  <details>
    <summary>Программа 24 (71стр)</summary>
<pre>
#include &lt;stdio.h&gt;

int main()
{
  printf("((2*3)+4)-5 %d\n", 2*3+4-5);
  printf("2*((3+4)-5) %d\n", 2*((3+4)-5));
  printf("(7*3) %% 2 %d\n", 7*3%2);
  printf("7*(3 %% 2) %d\n", 7*(3%2));

  int num = 9;
  printf("(8/2)*4 %d\n", --num/2*sizeof(int));
  num = 9;
  printf("8/(2*4) %d\n", --num/(2*sizeof(int)));

  return 0;
}
</pre>
  </details>
</article>


<!-- 5 Создание утверждений -->
<article class="article">
  <div class="anchor" id="p5"></div>
  <h3>5 Создание утверждений (73стр)</h3>
</article>


<!-- 5.1 Проверка значений выражений -->
<article class="article">
  <div class="anchor" id="p5.1"></div>
  <h3>5.1 Проверка значений выражений (74стр)</h3>
</article>


<br>&nbsp;&nbsp;<a href="#p5.2">5.2 Ветвление с помощью операции switch</a>
<br>&nbsp;&nbsp;<a href="#p5.3">5.3 Зацикливание с помощью счетчика</a>
<br>&nbsp;&nbsp;<a href="#p5.4">5.4 Зацикливание с помощью условия</a>
<br>&nbsp;&nbsp;<a href="#p5.5">5.5 Досрочный выход из циклов</a>
<br>&nbsp;&nbsp;<a href="#p5.6">5.6 Переход к меткам</a>

<a href="#p6">6 Использование функций (87)</a>
<br>&nbsp;&nbsp;<a href="#p6.1">6.1 Объявление функций (88)</a>
<br>&nbsp;&nbsp;<a href="#p6.2">6.2 Передача аргументов (90)</a>
<br>&nbsp;&nbsp;<a href="#p6.3">6.3 Рекурсивные вызовы (92)</a>
<br>&nbsp;&nbsp;<a href="#p6.4">6.4 Размещение функций в заголовках (94)</a>
<br>&nbsp;&nbsp;<a href="#p6.5">6.5 Ограничение доступности (96)</a>