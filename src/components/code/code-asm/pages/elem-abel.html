<h1>Конспект книги Питер Абель "Язык ассемблера для IBM PC и программирования"</h1>


<!-- Содержание -->
<div class="article article__content">
  <h2>Содержание</h2>

  <p><a href="#links">links</a></p>
  <p><a href="#about">about</a></p>
  <p><a href="#install">install</a></p>
  <p><a href="#pred">Предисловие</a></p>
  <p><a href="#g1">Глава 1. Введение в семейство компьютеров IBM PC</a></p>
  <p><a href="#g2">Глава 2. Машинное исполнение</a></p>
  <p><a href="#task1">&nbsp;&nbsp;Практика 1. Просмотр памяти</a></p>
  <p><a href="#task2">&nbsp;&nbsp;Практика 2. Пример машинных кодов: непосредственные данные</a></p>
  <p><a href="#task3">&nbsp;&nbsp;Практика 3. Пример машинных кодов: определение данных</a></p>
  <p><a href="#err">Опечатки: стр.36,38</a></p>
</div>


<!-- links -->
<article class="article">
  <div class="anchor" id="links"></div>
  <h2>links</h2>

  <ul>
    <li><a href="https://www.dosbox.com/">dosbox.com</a> DOSBox эмулятор dos</li>
    <li><a href="https://dosbox-x.com/">dosbox-x.com</a> DOSBox-X эмулятор dos</li>
    <li><a href="http://old-dos.ru/index.php?page=files&mode=files&do=show&id=3552">old-dos.ru</a> debug из состава ms-dos</li>
    <li><a href="http://old-dos.ru/files/file_1458.html">old-dos.ru</a> Norton Commander</li>
    <li><a href="http://old-dos.ru/index.php?page=files&mode=files&do=show&id=169">old-dos.ru</a> Volkov Commander</li>
    <li><a href="https://www.old-games.ru/catalog/?platform=1">old-games.ru</a> Игры для DOS</li>
  </ul>
</article>


<!-- about -->
<article class="article">
  <div class="anchor" id="about"></div>
  <h2>about</h2>

  <p>Чтобы выполнять практические задания из этой книги, нужно подготовить свой компьютер. Поскольку на windows 10 нельзя запускать программы DOS, то необходимо установить DOSBox и необходимые программы для нее.</p>

</article>


<!-- install -->
<article class="article">
  <div class="anchor" id="install"></div>
  <h2>install</h2>

  <h4>Установка DOSBox</h4>
  <ol>
    <li>
      <p>Заходим на официальный сайт программы DOSBox</p>
      <code><a href="https://www.dosbox.com/">dosbox.com</a></code>
    </li>
    <li>
      <p>Выбираем пункт меню <strong>Downloads</strong> и в окне <strong>DOSBox (specific versions)</strong> выбираем <strong>Windows</strong>. На компьютер скачается файл установщик</p>
      <code>DOSBox0.74-3-win32-installer.exe (1458 Кб)</code>
    </li>
    <li>
      <p>Запускаем установщик и устанавливаем DOSBox в папку</p>
      <code>d:\programs\DOSBox-0.74-3</code>
    </li>
  </ol>

  <h4>Монтирование папки в качестве диска в DOSBox</h4>
  <ol>
    <li>
      <p>Создаем новую пустую папку</p>
      <code>d:\dos\</code>
    </li>
    <li>
      <p>Запускаем DOSBox и выполняем команду</p>
      <code>mount d d:\dos</code>
    </li>
    <li>
      <p>Переходим в смонтированный диск</p>
      <code>d:</code>
    </li>
  </ol>
  <p>Чтобы при каждом запуске программы не повторять эти действия снова, настроим конфигурацию на автоматическое монтирование диска при запуске программы</p>
  <ol>
    <li>
      <p>Запустим файл</p>
      <code>d:\Programs\DOSBox-0.74-3\DOSBox 0.74-3 Options.bat</code>
    </li>
    <li>
      <p>Откроется файл</p>
      <code>dosbox-0.74-3.conf</code>
      <p>Или откройте его самостоятельно в папке</p>
      <code>c:\Users\11001000\AppData\Local\DOSBox\</code>
    </li>
    <li>
      <p>В конце файла, после <strong>[autoexec]</strong> допишите две строчки</p>
      <code>mount d d:\dos</code>
      <code>d:</code>
    </li>
  </ol>

  <h4>Установка программы debug</h4>
  <ol>
    <li>
      <p>Заходим на сайт</p>
      <code><a href="http://old-dos.ru/index.php?page=files&mode=files&do=show&id=3552">old-dos.ru</a></code>
    </li>
    <li>
      <p>Скачиваем файл</p>
      <code>MS_DEBUG.ver.modified.Multi (rus).rar (34 Кб)</code>
    </li>
    <li>
      <p>Копируем из архива файл debug.exe в папку</p>
      <code>d:\dos\</code>
    </li>
  </ol>

</article>


<!-- Предисловие -->
<article class="article">
  <div class="anchor" id="pred"></div>
  <h2>Предисловие</h2>

  <p>Книга представляет собой учебное пособие по программированию на языке Ассемблер для персональных компьютеров, совместимых с IBM PC, адресованное прежде всего начинающим. Начать практическое программирование можно уже с первых страниц книги. Для работы с книгой необходим постоянный доступ к компьютеру.</p>
  <p>Название книги переведено неудачно. Предпочтительнее "Программирование на языке Ассемблер для IBM PC".</p>

  <ul>
    <li>Появление микропроцессоров в 60-е годы связано с разработкой интегральных схем</li>
    <li>В начале 70-х годов появились микрокомпьютеры на процессоре Intel 8008. Это перввое поколение микропроцессоров</li>
    <li>К 1974 г. появилось второе поколение микропроцессоров общего назначения Intel 8080</li>
    <li>В 1978 г. появились процессоры третьего поколения Intel 8086 с 16-разрядной шиной. Для поддержки более простых устройств и для совместимости с устройствами того времени Intel разработала разновидность процессора 8086 - процессор 8088 с 8-разрядной шиной</li>
    <li>В 1981 г. фирма IBM выбрала процессор Intel 8088 для ее персональных компьютеров</li>
    <li>Стали появляться улучшенные версии. Для процессора 8088 - процессор 80188, а для процессора 8086 - процессоры 80186, 80286 и 80386., которые обеспечивали дополнительные возможности и повысили мощность вычислений</li>
    <li>В 1984 г. появился процессор 80286, которые устанавливают в компьютерах IBM AT</li>
  </ul>

  <p>С этого времени распространение микрокомпьютеров стало причиной популярности языка Ассемблер. Программы на ассемблере требуют значительно меньше объема памяти и времени выполнения. Знание языка Ассемблер и машинного кода дает понимание архитектуры компьютера. В это же время большинство программистов пишут на языках Паскаль и Си, что проще при написании программ и помогает избежать технических особенностей конкретных компьютеров</p>
  <p>Языки высокого уровня разработаны чтобы избежать технических особенностей и различий конкретных компьютеров. Язык Ассемблер разработан для конкретного процессора. Для того чтобы написать программу на языке Ассемблер, для конкретного компьютера, важно знать его архитектуру.</p>
  <p>Для работы с книгой необходимы</p>

  <ul>
    <li>Доступ к персональному компьютеру IBM PC с минимальным объемом ОЗУ 64 Кб</li>
    <li>Знакомство с руководством по IBM PC</li>
    <li>Транслятор с языка Ассемблер, желательно последней версии</li>
    <li>Операционная система PC-DOS или MS_DOS, желательно последней версии</li>
  </ul>
  <p>Данная книга является одновременно и учебником и справочным пособием для работы. Необходимо тщательнро прорабатывать каждую главу и перечитывать материал, который не сразу ясен.</p>
</article>


<!-- Глава 1. Введение в семейство компьютеров IBM PC -->
<article class="article">
  <div class="anchor" id="g1"></div>
  <h2>Глава 1. Введение в семейство компьютеров IBM PC</h2>

  <h3>Биты и байты</h3>
  <p>В основе логики компьютера лежат понятия бита и байта. Благодаря им в компьютерной памяти представляются команды и данные.</p>
  <p>Программа в машинном коде состоит из различных сегментов памяти:</p>
  <ol>
    <li>Сегмент памяти для хранения данных</li>
    <li>Сегмент памяти для хранения машинных команд</li>
    <li>Сегмент памяти для хранения адресов (стек)</li>
  </ol>
  <p>Для выполнения арифметических действий, пересылки данных и адресации процессор имеет ряд регистров.</p>
  <p>Для выполнения программы компьютер помещает программу (машинные команды и данные) в ОЗУ.</p>
  <p>Минимальной единицей информации в компьютере являетя <strong>бит</strong>. Он имеет два состояния 1 (включен) или 0 (выключен)</p>
  <p>Группа из девяти бит представляет собой <strong>байт</strong>, восемь бит которого содержат данные и один бит - <strong>контроль на четность.</strong></p>
  <p>8 бит дают 256 различных комбинаций</p>
  <code>от 0000 0000 до 1111 1111</code>
  <p>8 бит могут использоваться для кодирования символов. С целью стандартизации в персональных компьютерах используется <strong>таблица ASCII</strong>. Например,</p>
  <code>символ * = 00101010 (43). Буква A = 01000001 (65)</code>
  <p><strong>Контроль на четность</strong> - количество единиц в байте всегда должно быть нечетно. Буква A имеет 3 единицы, поэтому контрольный бит для буквы A равен 0. Символ * имеет 2 единицы, поэтому контрольный бит для символа * равен 1. Если количество единиц в байте четно, то система выдает сообщение об ошибке.</p>
  <p>Биты в байте нумеруются от 0 до 7 справа налево</p>
  <code>7 6 5 4 3 2 1 0</code>
  <p>Число 2<sup>10</sup> равно 1024, что состовляет один килобайт.</p>
  <p>Процессор 8086 использует 16-разрядную архитектуру. Он имеет 16-разрядные регистры и 16-разрядную шину, которая позволяет за один раз пересылать 16 бит данных. 16 бит это два байта и называются словом</p>
  <p>Биты в слове нумеруются от 0 до 15 справа налево</p>
  <code>15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0</code>

  <h3>Двоичные числа</h3>
  <p>Компьютер может различать только нулевое и единичное состояние и поэтому работает только с числами в двоичной системе.</p>
  <p>Двоичное число не ограничивается только восемью битами. Процессор 8086 использует 16-разрядную архитектуру и оперирует 16-битовыми числами от 0 до 65535. С помощью преобразований можно обрабатывать 32-разрядные числа (от 0 до 4 294 967 295) и даже больше.</p>

  <h4>Положительные числа</h4>
  <p>Положительные числа имеют 0 в старшем разряде</p>
  <code>1 = 00000001</code>
  <code>2 = 00000010</code>
  <code>3 = 00000011</code>

  <h4>Отрицательные числа</h4>
  <p>Отрицательные числа имеют 1 в старшем разряде.</p>
  <p>Положительное и отрицательное число в сумме должны получить 0. Поэтому чтобы получить из положительного числа отрицательное используют двоичное дополнение - инвертируют все разряды положительного числа и прибавляют 1. Чтобы получить из отрицательного числа положительное также используют двоичное дополнение.</p>
  <code>-1 = 11111111</code>
  <code>-2 = 11111110</code>
  <code>-3 = 11111101</code>

  <p>Компьютер может сложить два числа, но не может вычесть. Двоичное вычитание выполняется просто: инвертируется знак вычитаемого и складываются два числа.</p>

  <h3>Шестнадцатеричные числа</h3>
  <p>Для просмотра байтов в памяти используюь 16-ричные числа. Слово (два байта) будет занимать в двоичном виде 32 знака на экране, а в шестнадцатиричном 4 знака. При отладке в программе dos debug используются 16-разрядные числа.</p>

  <h3>Сегменты</h3>
  <p>Сегмент это область памяти, которая начинается на границе параграфа, т.е. по любому адресу, кратному 16. Размер сегмента - ровно столько сколько необходимо для выполнения программы, но не более 64 Кб.</p>
  <p>Есть три главных сегмента:</p>
  <ol>
    <li>Сегмент кодов. Сегмент кодов содержит машинные команды, которые будут выполняться. Первая команда лежит вначале сегмента. Регистр сегмента кодов (CS) адресует данный сегмент и содержит адрес команды, которая должна выполняться. До начала программы регистр CS должен показывать на  начало сегмента кодов.</li>
    <li>Сегмент данных. Сегмент данных содержит данные, константы и свободные участки памяти, необходимые программе. Регистр сегмента данных (DS) адресует данный сегмент.</li>
    <li>Сегмент стека. Стек содержит адреса возврата из программы в операционную систему и из подпрограмм в основную программу. Регистр сегмента стека (SS) адресует данный сегмент</li>
  </ol>
  <p>Три сегментных регистра содержат начальные адреса сегментов и каждый сегмент начинается на границе параграфа.</p>
  <p>Есть один дополнительный сегмент</p>
  <ol>
    <li>Дополнительный сегмент предназначен для специального использования. Регистр дополнительного сегмента (ES) адресует данный сегмент.</li>
  </ol>
  <p>Внутри программы все адреса памяти являются смещением относительно начала сегмента. Двухбайтовое смещение (16 бит) может быть в пределах</p>
  <code>от 0000 до FFFF (от 0 до 65535)</code>
  <p>Для обращения к любому адресу в программе компьютер складывает адрес в регистре сегмента и смещение. Первый байт в сегменте кодов имеет смещение 0, второй байт - 1 и т.д. до смещения 65535.</p>
  <p>В регистре сегмента 16 бит (от 0000 до FFF0), поскольку адрес в регистре сегмента должен быть кратным 16-ти, поэтому младший байт всегда равен нулю. Число FFF0 позволяет адресовать 65520 (плюс смещение) байт. Но специалисты решили, что нет смысла хранить биты которые всегда равны нулю. Поэтому младший нулевой байт в регистр сегмента не пишут, а добавляют еще один старший байт. Таким образом число FFFF (FFFF0 с младшим нулевым байтом) позволяет адресовать 1048560 байт</p>

  <h3>Регистры</h3>
  <p>Процессоры 8086/8088 имеют 14 регистров, используемых для управления выполняющейся программой, для адресации памяти и для арифметических вычислений. Каждый регистр имеет размер 16 бит и адресуется по имени. Биты в регистре нумеруются слева направо</p>
  <code>15 14 13 12 11 10 9 8 7 6 5 4 3 2 1</code>

  <h4>Сегментные регистры CS, DS, SS, ES</h4>
  <p>Каждый сегментный регистр обеспечивает адресацию памяти объемом 64Kb, которая называется текущим сегментом. Адрес в сегментном регистре предполагает наличие справа 4 нулевых бита (одна шестнадцатеричная цифра)</p>
  <ol>
    <li>Регистр CS. Регистр сегмента кода содержит начальный адрес сегмента кода. Этот адрес плюс значение смещения в регистре командного указателя IP определяют адрес команды, которая выполняется следующей.</li>
    <li>Регистр DS. Регистр сегмента данных содержит начальный адрес сегмента данных. Этот адрес плюс значение смещения, определенное в команде определяют адрес ячейки в сегменте данных.</li>
    <li>Регистр SS. Регистр сегмента стека содержит начальный адрес сегмента стека</li>
    <li>Регистр ES. Если необходимо использовать дополнительный сегментный регистр ES, то нужно инициализировать индексный регистр DI</li>
  </ol>

  <h4>Регистры общего назначения AX, BX, CX, DX</h4>
  <p>Только регистры общего назначения можно адресовать как целиком, так и по каждому байту - старший байт (high) и малдший байт (low)</p>
  <ol>
    <li>Регистр AX. Регистр AX это основной сумматор. Умножение, деление и сдвиг используют регистр AX</li>
    <li>Регистр BX. Регистр BX это базовый регистр. Это единственный регистр общего назначения, который может использоваться в качестве индекса для расширенной адресации</li>
    <li>Регистр CX. Регистр CX является счетчиком. Используется для управления числом повторений в цикле и для операций сдвига влево или вправо</li>
    <li>Регистр DX. Регистр DX является регистром данных. Применяется для больших чисел, которые используют регистровую пару DX:AX</li>
  </ol>

  <h4>Регистровые указатели SP и BP</h4>

  <h3>Архитектура ПК</h3>
</article>


<!-- Глава 2. Машинное исполнение -->
<article class="article">
  <div class="anchor" id="g2"></div>
  <h2>Глава 2. Машинное исполнение</h2>

  <p>Цель: представить машинный язык, ввод команд в память и выполнение программ.</p>
</article>


<!-- Практика 1. Просмотр памяти -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Практика 1. Просмотр памяти</h3>

  <p>Запустим программу DOSBox с монтированным диском C, на котором есть программа <strong>debug.exe</strong>. Для запуска этой программы введем debug и получим приглашение в виде дефиса</p>
  <code>C:\>debug</code>
  <code>-</code>
  <p>Дамп - отображение на экране содержимого памяти. Для дампа нужно использовать команду d (display).</p>

  <ol>
    <li>
      <h4>Размер памяти</h4>
      <p>Сначала проверим размер доступной для работы памяти. Оно может быть меньше чем реально существует. Данное значение находится в ячейках памяти 413H и 414H. 400 - это адрес сегмента, который записывается как 40 (последний ноль подразумевается). 13 - это смещение от начала сегмента</p>
      <code>-d 40:13</code>
      <p>Первые два байта покажут объем памяти в килобайтах в обратной последовательности в шестнадцатеричной системе</p>
      <code>80 02</code>
      <p>Покажем как преобразовать обратное шестнадцатеричное значение в нормальное десятичное</p>
      <code>80 00 -> 00 80 -> 128 Kb</code>
      <code>00 01 -> 01 00 -> 256 Kb</code>
      <code>80 01 -> 01 80 -> 384 Kb</code>
      <code>00 02 -> 02 00 -> 512 Kb</code>
      <code>80 02 -> 02 80 -> 640 Kb</code>
    </li>
    <li>
      <h4>Серийный номер</h4>
      <p>Серийный номер компьютера находится в ячейках памяти по адресу FE000H</p>
      <code>-d FE00:0</code>
      <p>Первые семь двухбайтовых чисел это серийный номер компьютера, после которого идут два копирайта</p>
      <code>00 00 00 00 00 00 00 00-00 00 00 00 00 00</code>
      <code>IBM COMPATUBLE 486 BIOS COPYRIGHT The DOSBox Team</code>
      <code>DOSBox FakeBIOS v1.0</code>
    </li>
    <li>
      <h4>Дата ROM BIOS</h4>
      <p>Дата BIOS в формате mm/dd/yy содержится в ячейках памяти по адресу FFFF5H</p>
      <code>-d ffff:05</code>
      <code>01/01/92</code>
    </li>
  </ol>
  <p>Можно использовать команду d (display) для просмотра любой ячейки памяти. Командой d без параметров можно пролистывать память, показывая адреса следующий за предыдущими</p>
</article>


<!-- Практика 2. Пример машинных кодов: непосредственные данные -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Практика 2. Пример машинных кодов: непосредственные данные</h3>

  <p>Цель данного примера: показать простую программу на машинном языке, ее представление в памяти и результаты ее выполнения. Программы в машинных кодах пишутся в шестнадцатеричном формате</p>
<pre>
B82301    Переслать значение 0123H в AX
052500    Прибавить значение 0025H к AX
8BD8      Переслать содержимое AX в BX
03D8      Прибавить содержимое AX к BX
8BCB      Переслать содержимое BX в CX
2BC8      Вычесть содержимое AX из CX
2BC0      Вычесть содержимое AX из AX (очистка AX)
90        Нет операции
CB        Возврат в DOS
</pre>
  <p>Машинные команды имеют различную длину: <strong>один, два или три байта</strong>. Машинные команды находятся в памяти непосредственно друг за другом. Выполнение программы начинается с первой команды и далее последовательно выполняются остальные.</p>
  <p>Введем эту программу в память и выполним ее, просматривая содержимое регистров после выполнения каждой команды.</p>

  <p>Запустим программу DOSBox с монтированным диском C, на котором есть программа <strong>debug.exe</strong>. Для запуска этой программы введем debug и получим приглашение в виде дефиса</p>
  <code>C:\>debug</code>
  <code>-</code>

  <p>Для ввода машинного кода сразу в память нужно использовать команду <strong>e (enter)</strong></p>
  <code>-e CS:100 B8 23 01 05 25 00</code>

  <p>Параметр CS:100 определяет адрес памяти, куда будут вводиться машинные коды. 100H это 256 байт от начала сегмента кодов. Команда <strong>e (enter)</strong> записывает каждую пару шестнадцатеричных цифр в память в виде байта, начиная с адреса CS:100 до адреса CS:105</p>
  <p>Следующая команда <strong>e (enter)</strong> записывает 6 байт, начиная с адреса CS:106 до адреса CS:10B</p>
  <code>-e CS:106 8B D8 03 D8 8B CB</code>

  <p>Последняя команда <strong>e (enter)</strong> записывает 6 байт, начиная с адреса CS:10C до адреса CS:111</p>
  <code>-e CS:10C 2B C8 2B C0 90 CB</code>

  <p>Введите команду r для просмотра содержимого регистров и флагов. Отладчик показывает содержимое регистров в шестнадцатеричной форме.</p>
<pre>
-r
AX=0000  BX=0000  CX=0000  DX=0000  SP=FFEE  BP=0000  SI=0000  DI=0000
DS=13C6  ES=13C6  SS=13C6  CS=13C6  IP=0100   NV UP EI PL NZ NA PO NC
13C6:0100 B82301         MOV     AX,0123
</pre>

  <p>Регистр CS содержит значение CS=13C6. Регистр IP содержит значение IP = 0100, показывая что первая выполняемая команда смещена на 100 байт от начала сегмента. Поэтому мы записывали программу начиная с адреса CS:100.</p>
  <p>Регистр флагов показывает: NV нет переполнения, UP правое  направление, DI прерывания запрещены, PL знак плюс, NZ не ноль, NA нет внешнего переноса,  PO контроль на  честность и NC нет  переноса.</p>
  <code>NV UP DI PL NZ NA PO NC</code>
  <p>Команда r показывает  также  по  смещению  0100H  первую  выполняемую машинную команду</p>
  <pre>13C6:0100 B82301         MOV     AX,0123</pre>

  <p>Значение <strong>13C6:0100</strong> обозначает смещение 100H байт от начального адреса 13C60 (CS=13C6)</p>
  <p>Значение <strong>B82301</strong> это трех байтовая машинная команда, которая начинается по адресу CS:100</p>
  <p>Значение <strong>MOV AX,0123</strong> это ассемблерный код, соответствующий машинной команде <strong>B82301</strong>. Ассемблерный код это и есть результат работы отладчика. Ассемблерный код нужен для понимания машинных команд. Команда <strong>B82301 MOV AX,0123</strong> пересылает значение 0123H в регистр AX</p>

  <p>В данный момент команда MOV еще не выполнена. Для ее выполнения введите команду t (трассировка)</p>
  <p>В результате команда MOV будет выполнена и отладчик выдаст на экран содержимое регистров, флагов и следующую по очереди команду.</p>

  <p>Машинная команда <strong>B8</strong> пересылает 2 байта данных 0123H в 16-ти разрядный <strong>регистр AX</strong> и соответствует ассемблерному коду <strong>MOV AX,0123</strong>. Младший байт данных 23H попадает в 8-ми разрядный <strong>регистр AL</strong>, а старший байт данных 01H попадает в 8-ми разрядный <strong>регистр AH</strong>. Теперь <strong>регистр AX</strong> содержит значение 0123H.</p>
  <p>Регистр IP=0103 показывает адрес следующей по очереди команды</p>
<pre>
-e CS:100 B8 23 01 05 25 00
-e CS:106 8B D8 03 D8 8B CB
-e CS:10C 2B C8 2B C0 90 CB
-r
AX=0000  BX=0000  CX=0000  DX=0000  SP=FFEE  BP=0000  SI=0000  DI=0000
DS=13C6  ES=13C6  SS=13C6  CS=13C6  IP=0100   NV UP EI PL NZ NA PO NC
13C6:0100 B82301         MOV     AX,0123
-t
AX=0123  BX=0000  CX=0000  DX=0000  SP=FFEE  BP=0000  SI=0000  DI=0000
DS=13C6  ES=13C6  SS=13C6  CS=13C6  IP=0103   NV UP EI PL NZ NA PO NC
13C6:0103 052500         ADD     AX,0025
</pre>

  <p>Для выполнения следующей команды введите команду t (трассировка)</p>
  <p>Машинная команда <strong>05</strong> прибавляет 2 байта данных 0025 к <strong>регистру AX</strong> и соответствует ассемблерному коду <strong>ADD AX,0025</strong>. Младший байт данных 25H прибавится к <strong>регистру AL</strong>, а старший байт данных 00H прибавится к <strong>регистру AH</strong>. Теперь <strong>регистр AX</strong> содержит значение 0148H.</p>
  <p>Регистр IP=0106 показывает адрес следующей по очереди команды</p>
<pre>
AX=0148  BX=0000  CX=0000  DX=0000  SP=FFEE  BP=0000  SI=0000  DI=0000
DS=13C6  ES=13C6  SS=13C6  CS=13C6  IP=0106   NV UP EI PL NZ NA PE NC
13C6:0106 8BD8          MOV     BX,AX
-T

AX=0148  BX=0148  CX=0000  DX=0000  SP=FFEE  BP=0000  SI=0000  DI=0000
DS=13C6  ES=13C6  SS=13C6  CS=13C6  IP=0108   NV UP EI PL NZ NA PO NC
13C6:0108 03D8          ADD     BX,AX
-T

AX=0148  BX=0290  CX=0000  DX=0000  SP=FFEE  BP=0000  SI=0000  DI=0000
DS=13C6  ES=13C6  SS=13C6  CS=13C6  IP=010A   NV UP EI PL NZ AC PO NC
13C6:010A 8BCB          MOV     CX,BX
-T

AX=0148  BX=0290  CX=0290  DX=0000  SP=FFEE  BP=0000  SI=0000  DI=0000
DS=13C6  ES=13C6  SS=13C6  CS=13C6  IP=010C   NV UP EI PL NZ AC PO NC
13C6:010C 2BC8          SUB     CX,AX
-T

AX=0148  BX=0290  CX=0148  DX=0000  SP=FFEE  BP=0000  SI=0000  DI=0000
DS=13C6  ES=13C6  SS=13C6  CS=13C6  IP=010E   NV UP EI PL NZ AC PO NC
13C6:010E 2BC0          SUB     AX,AX
-T

AX=0000  BX=0290  CX=0148  DX=0000  SP=FFEE  BP=0000  SI=0000  DI=0000
DS=13C6  ES=13C6  SS=13C6  CS=13C6  IP=0110   NV UP EI PL ZR NA PO NC
13C6:0110 90            NOP
-T

AX=0000  BX=0290  CX=0148  DX=0000  SP=FFEE  BP=0000  SI=0000  DI=0000
DS=13C6  ES=13C6  SS=13C6  CS=13C6  IP=0111   NV UP EI PL ZR NA PO NC
13C6:0111 CB            RETF
-
</pre>

  <p>Для пошагового выполнения оставшихся команд введите команду t (трассировка)</p>
  <p>Машинная команда <strong>8BD8</strong> копирует содержимое <strong>регистра AX</strong> в <strong>регистр BX</strong> и соответствует ассемблерному коду <strong>MOV BX,AX</strong>. Теперь <strong>регистр BX</strong> содержит значение 0148H.</p>
  <p>Регистр IP=0108 показывает адрес следующей по очереди команды</p>

  <p>Машинная команда <strong>03D8</strong> прибавляет содержимое <strong>регистра AX</strong> к <strong>регистру BX</strong> и соответствует ассемблерному коду <strong>ADD BX,AX</strong>. Теперь <strong>регистр BX</strong> содержит значение 0290H.</p>
  <p>Регистр IP=010A показывает адрес следующей по очереди команды</p>

  <p>Машинная команда <strong>8BCB</strong> копирует содержимое <strong>регистра BX</strong> в <strong>регистр CX</strong> и соответствует ассемблерному коду <strong>ADD CX,BX</strong>. Теперь <strong>регистр CX</strong> содержит значение 0290H.</p>
  <p>Регистр IP=010C показывает адрес следующей по очереди команды</p>

  <p>Машинная команда <strong>2BC8</strong> вычитает содержимое <strong>регистра AX</strong> из <strong>регистра CX</strong> и соответствует ассемблерному коду <strong>SUB CX,AX</strong>. Теперь <strong>регистр CX</strong> содержит значение 0148H.</p>
  <p>Регистр IP=010E показывает адрес следующей по очереди команды</p>

  <p>Машинная команда <strong>2BC0</strong> вычитает содержимое <strong>регистра AX</strong> из <strong>регистра AX</strong> и соответствует ассемблерному коду <strong>SUB AX,AX</strong>. Теперь <strong>регистр AX</strong> содержит значение 0000H.</p>
  <p>Регистр IP=0110 показывает адрес следующей по очереди команды</p>

  <p>Для просмотра программы в машинных кодах в сегменте  кодов введите D для дампа</p>
  <code>D CS:100</code>

  <p>В результате отладчик выдаст на  каждую  строку  экрана  по  16  байт данных в шест. представлении (32 шест. цифры) и в символьном представлении в коде ASCII (один  символ  на  каждую  пару  шест.  цифр).  Представление  машинного кода в символах ASCII не имеет смысла и может быть игнорировано.</p>
  <p>Первая строка дампа показывает содержимое  ячеек от CS:100 до CS:10F. Вторая строка показывает cодержимое ячеек от CS:110 до CS:11F.  Несмотря на то, что ваша  программа  заканчивается  по  адресу CS:111, команда Dump aвтоматически выдаст на восьми строках экрана дамп  с адреса CS:100 до адреса CS:170.</p>
<pre>
-D CS:100
13C6:0100 B8 23 01 05 25 00 8B D8-03 D8 8B CB 2B C8 2B C0 .#..%.......+.+.
13C6:0110 90 CB 8D 46 14 50 51 52-FF 76 28 E8 74 00 8B E5 ...F.PQR.v(.t...
13C6:0120 B8 01 00 50 FF 76 32 FF-76 30 FF 76 2E FF 76 28 ...P.v2.v0.v..v(
13C6:0130 E8 88 15 8B E5 BF 36 18-12 FF 36 16 12 8B 76 28 ......6...6...v(
13C6:0140 FF 74 3A 89 46 06 E8 22-CE 8B E5 30 E4 3D 0A 00 .t:.F.."...0.=..
13C6:0150 75 32 A1 16 12 2D 01 00-8B 1E 18 12 83 DB 00 53 u2...-.........S
13C6:0160 50 8B 76 28 FF 74 3A A3-16 12 89 1E 18 12 E8 FA P.v(.t:.........
13C6:0170 CD 8B E5 30 E4 3D 0D 00-74 0A 83 06 16 12 01 83 ...0.=..t.......
</pre>
  <p>Если нужно повторить выполнение этих команд, сбросьте содержимое регистра IP и повторите трассировку снова</p>
  <code>-r IP 100</code>
  <code>-t</code>
  <p>Для завершения работы с программой DEBUG введите Q (Quit - выход).  В результате произойдет возврат в DOS</p>
  <code>-q</code>
</article>


<!-- Практика 3. Пример машинных кодов: определение данных -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Практика 3. Пример машинных кодов: определение данных</h3>
</article>


<!-- Опечатки -->
<article class="article">
  <div class="anchor" id="err"></div>
  <h3>Опечатки</h3>

  <h4>Страница 36</h4>
  <p>Имеется:</p>
<pre>
2BC8      Вычеместь содержимое AX из AX (очистка AX)
</pre>
  <p>Должно быть:</p>
<pre>
2BC8      Вычеместь содержимое AX из CX
2BC0      Вычеместь содержимое AX из AX (очистка AX)
</pre>

  <h4>Страница 38</h4>
  <p>Имеется:</p>
<pre>
13C6:0100 B8230         MOV     AX,0123
</pre>
  <p>Должно быть:</p>
<pre>
13C6:0100 B82301        MOV     AX,0123
</pre>
  <p>Имеется:</p>
<pre>
DS=13C6  ES=13C6  SS=13C6  CS=13C6  IP=0100   NV UP EI PL NZ AC PO NC
13C6:010E 2BC0          SUB     AX,AX
</pre>
  <p>Должно быть:</p>
<pre>
DS=13C6  ES=13C6  SS=13C6  CS=13C6  IP=010E   NV UP EI PL NZ AC PO NC
13C6:010E 2BC0          SUB     AX,AX
</pre>
</article>

