<h1>C++</h1>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p><a href="#links">links</a></p>
  <ol>
    <li><a href="#links1">online курсы</a></li>
    <li><a href="#links">статьи</a></li>
  </ol>
  <p><a href="#about">about</a></p>
  <p><a href="#install">install</a></p>
  <ol>
    <li><a href="#wsl">Командная строка wsl</a></li>
    <li><a href="#gcc">Компилятор gcc</a></li>
    <li><a href="#clang">Компилятор clang</a></li>
    <li><a href="#vscode">Редактор кода VS Code</a></li>
    <li><a href="#visualstudio">IDE Visual Studio</a></li>
    <li><a href="#console">Первая программа</a></li>
    <li><a href="#gcc-setup">Настройка компилятора g++ и clang++</a></li>
  </ol>
  <p>Практика</p>
  <ul>
    <li><a href="#endl">Конец строки</a></li>
    <li><a href="#namespace">namespase</a></li>
    <li><a href="#locale">Локализация и кириллица в консоли</a></li>
  </ul>
  <p><a href="#struct">Структура программы</a></p>
  <ol>
    <li><a href="#instr">Инструкции</a></li>
    <li><a href="#block">Блок кода</a></li>
    <li><a href="#fmain">Функция main</a></li>
    <li><a href="#include">Директива include</a></li>
    <li><a href="#comments">Комментарии</a></li>
    <li><a href="#compil">Компиляция</a></li>
    <li><a href="#var">Переменная</a></li>
    <li><a href="#init">Инициализация переменной</a></li>
    <li><a href="#const">Константа</a></li>
  </ol>
  <p><a href="#types">Типы данных</a></p>
  <ol>
    <li><a href="#bool">Логический тип bool</a></li>
    <li><a href="#integer">Целочисленные типы</a></li>
    <li><a href="#float">Числа с плавающей точкой</a></li>
    <li><a href="#sizeof">Оператор sizeof()</a></li>
    <li><a href="#char">Символьные типы</a></li>
    <li><a href="#auto">Спецификатор auto</a></li>
  </ol>
  <p><a href="#console">Ввод и вывод в консоли</a></p>
  <p><a href="#using">using Пространство имен и псевдонимы</a></p>
  <p><a href="#assoc">Ассоциативность операторов</a></p>
  <p><a href="#type-conv-no">Неявное преобразование типа</a></p>
  <p><a href="#type-conv">Явное преобразование типа</a></p>
</article>


<!-- links-->
<article class="article">
  <div class="anchor" id="links"></div>
  <h3>links</h3>
</article>


<!-- links1-->
<article class="article">
  <div class="anchor" id="links1"></div>
  <h3>online курсы</h3>
  <p><a href="https://metanit.com/cpp/tutorial/">metanit.com/cpp/tutorial</a> Введение в С++</p>
  <p><a href="https://education.yandex.ru/handbook/cpp/">education.yandex.ru/handbook/cpp</a> Основы С++</p>
  <p><a href="https://stepik.org/course/193691/">https://stepik.org/course/193691/</a> Добрый, добрый C/C++ с Сергеем Балакиревым</p>
  <p><a href="https://stepik.org/course/7/">https://stepik.org/course/7/</a> Программирование на языке C++. Александр Смаль, Михаил Кринкин</p>
  <p><a href="https://stepik.org/course/3206/">https://stepik.org/course/3206/</a> Программирование на языке C++ (продолжение). Александр Смаль</p>
  <p><a href="https://purecodecpp.com/">https://purecodecpp.com/</a> Основы программирования на С++ для начинающих</p>
  <p><a href="https://ravesli.com/uroki-cpp/">https://ravesli.com/uroki-cpp/</a> Уроки С++</p>
  <p><a href="https://natalia.appmat.ru/c&c++/">https://natalia.appmat.ru/c&c++/</a> C & C++ Чибизова Наталья Владимировна</p>
</article>


<!-- links2-->
<article class="article">
  <div class="anchor" id="links2"></div>
  <h3>статьи</h3>
  <p><a href="https://blog.skillfactory.ru/kak-pisat-programmi-c-plus-plus/">blog.skillfactory.ru/kak-pisat-programmi-c-plus-plus</a> Язык программирования С++ разбираемся и пишем простую программу</p>
  <p><a href="https://www.onlinegdb.com/online_c++_compiler/">onlinegdb.com/online_c++_compiler</a> Онлайн компилятор С++</p>
</article>


<!-- about-->
<article class="article">
  <div class="anchor" id="about"></div>
  <h2>about</h2>

  <p>C++ это высокоуровневый компилируемый язык программирования со статической типизацией. В 1969-1973 годах в компании Bell Labs программистом Деннисом Ритчи (Dennis Ritchie) был разработан язык Си. Второй соавтор языка Си это Кен Томпсон.</p>
  <p>Предшественниками языка Си были</p>
  <p>1966 язык BCPL (Деннис Ритчи)</p>
  <p>1969 язык B (Деннис Ритчи)</p>
  <p>1972 язык C (Деннис Ритчи)</p>
  <p>1978 Деннис Ритчи вместе с Брайаном Керниганом написал хорошую книгу "Язык программирования Си"</p>
  <p>В 1979-1980-х годах датский программист Бьерн Страуструп (Bjarne Stroustrup) работал в Bell Labs и разработал язык С++ как расширение к языку Си и назвал его "Си с классами". Он дополнил язык Си возможностями ООП. До этого концепция ООП была реализована в Simula67.</p>
  <p>1983 язык C++</p>
  <p>В 1983 году язык "Си с классами" был переименован в С++. В 1985 году он презентовал свою разработку в книге "Язык программирования С++" и была вывпущена первая коммерческая версия языка С++. Впоследствии в язык С++ добавились новые возможности и язык Си и С++ стали развиваться независимо друг от друга. В 1989 году была выпущена вторая версия языка С++ 2.0. В 2003 году вышла новая версия С++ 03. В 2011 году был издан новый стандарт С++ 11.</p>
</article>


<!-- install-->
<article class="article">
  <div class="anchor" id="install"></div>
  <h2>install</h2>

  <p>Для того чтобы написать свою первую программу на языке C++, достаточно редактора кода и компилятора. В редакторе кода будем писать код, а компилятором компилировать его в исполняемый файл.</p>
  <p>Три самых популярных компилятора это</p>
  <ol>
    <li>Компилятор gcc от проекта GNU</li>
    <li>Компилятор Clang от проекта LLVM</li>
    <li>Компилятор C++ от компании Microsoft (используется в Visual Studio)</li>
  </ol>
  <p>В качестве редактора кода можно использовать и Notepad++ (тоже два плюса как и в C++). Но мы будем использовать VS Code. В него можно поставить расширение для языка C++.</p>
  <p>После того, как первая программа написана, можно поставить среду разработки IDE.</p>
  <p>Самый профессиональный вариант это использовать Microsoft Visual Studio</p>
  <p>Можно использовать Code Blocks</p>
</article>


<!-- Командная строка -->
<article class="article">
  <div class="anchor" id="wsl"></div>
  <h3>Командная строка</h3>

  <p>Проверим что установлена командная строка wsl</p>
  <code>wsl -v</code>
  <code>Версия WSL: 2.3.24.0</code>
  <p>(сокращение от wsl --version)</p>

  <p>На Windows 10 рекомендуем установить WSL (Windows Subsystem for Linux) или WSL2</p>
  <code><a href="https://learn.microsoft.com/ru-ru/windows/wsl/install">https://learn.microsoft.com/ru-ru/windows/wsl/install</a></code>
  <p>Команда установки wsl</p>
  <code>wsl --install</code>
</article>


<!-- Компилятор gcc-->
<article class="article">
  <div class="anchor" id="gcc"></div>
  <h2>Компилятор gcc от проекта GNU</h2>

  <p>Проверим что установлен компилятор gcc</p>
  <code>gcc -v</code>
  <code>gcc.exe (GCC) 14.1.0</code>
  <p>(сокращение от gcc --version)</p>

  <p><a href="https://gcc.gnu.org/">https://gcc.gnu.org/</a> Бесплатный компилятор Си и C++</p>
</article>


<!-- Компилятор clang-->
<article class="article">
  <div class="anchor" id="clang"></div>
  <h2>Компилятор clang от проекта LLVM</h2>

  <p>Проверим что установлен компилятор clang</p>
  <code>clang -v</code>
  <code>clang version 18.1.8</code>
  <p>(сокращение от clang --version)</p>

  <p><a href="https://clang.llvm.org/">https://clang.llvm.org/</a> Бесплатный компилятор Си и C++</p>
</article>


<!-- Редактор кода VS Code-->
<article class="article">
  <div class="anchor" id="vscode"></div>
  <h2>Редактор кода VS Code</h2>
  <h3>Установим бесплатный редактор кода Visual Studio Code</h3>
  <ol>
    <li>
      <p>Переходим на сайт</p>
      <code><a href="https://visualstudio.microsoft.com/ru">https://visualstudio.microsoft.com/ru</a></code>
    </li>
    <li>
      <p>Выбираем Бесплатныя версия Visual Studio - и попадаем на страницу</p>
      <code><a href="https://visualstudio.microsoft.com/ru/free-developer-offers/">https://visualstudio.microsoft.com/ru/free-developers-offers</a></code>
    </li>
    <li>
      <p>Выбираем</p>
      <code>Visual Studio Code - Скачать бесплатно -Пользовательский установщик</code>
      <p>Сохраняем установочный файл на компьютере и запускаем его</p>
      <code>VSCodeUserSetup-x64-q.93.1.exe</code>
    </li>
  </ol>
</article>


<!-- Среда разработки Visual Studio-->
<article class="article">
  <div class="anchor" id="visualstudio"></div>
  <h2>Среда разработки Visual Studio</h2>

  <h3>Установим бесплатную версию Visual Studio Community</h3>
  <ol>
    <li>
      <p>Переходим на сайт</p>
      <code><a href="https://visualstudio.microsoft.com/ru">https://visualstudio.microsoft.com/ru</a></code>
    </li>
    <li>
      <p>Выбираем Бесплатныя версия Visual Studio - и попадаем на страницу</p>
      <code><a href="https://visualstudio.microsoft.com/ru/free-developer-offers/">https://visualstudio.microsoft.com/ru/free-developers-offers</a></code>
    </li>
    <li>
      <p>Выбираем</p>
      <code>Visual Studio Community - Скачать бесплатно</code>
      <p>Сохраняем установочный файл на компьютере и запускаем его</p>
    </li>
    <li>
      <p>Откроется окно</p>
      <code>Идет установка - Visual Studio Community 2022 - 17.11.4</code>
    </li>
    <li>
      <p>Выбираем пункт</p>
      <code>Разработка классических приложений на C++</code>
    </li>
    <li>
      <p>Нажимаем Установить</p>
    </li>
  </ol>

  <h3>Напишем первую программу на C++ в Visual Studio</h3>
  <ol>
    <li>
      <p>Откроем Visual Studio 2022 и выберем пункт</p>
      <code>Начало работы - Создание проекта</code>
    </li>
    <li>
      <p>Откроется окно</p>
      <code>Создание проекта</code>
      <p>Выбираем шаблон</p>
      <code>C++ - Консольное приложение</code>
      <p>Нажимаем Далее</p>
    </li>
    <li>
      <p>Откроется окно</p>
      <code>Настроить новый проект</code>
      <p>Зададим имя проекта</p>
      <code>hello</code>
      <p>Нажимаем Создать</p>
    </li>
    <li>
      <p>Visual Studio создаст новый проект для консольного приложения с файлом hello.cpp который содержит код вывода в консоль строки Hello World. Выбираем меню</p>
      <code>Сборка - Собрать решение (Ctrl+Shift+B)</code>
    </li>
    <li>
      <p>Выбираем меню</p>
      <code>Отладка - Запуск без отладки (Ctrl+F5)</code>
    </li>
  </ol>
</article>


<!-- Первая программа. Вывод в консоль-->
<article class="article">
  <div class="anchor" id="console"></div>
  <h3>Первая программа</h3>

  <ol>

    <li>
      <p>Создадим файл</p>
      <code>hello.cpp</code>
    </li>

    <li>
      <p>Запишем в него код первой программы</p>
<pre>#include &lt;iostream&gt;
int main() {
  std::cout &lt;&lt; "Hello, world!";
  return 0;
}</pre>
    </li>

    <li>
      <p>Откроем терминал и запустим компилятор</p>
      <code>g++ hello.cpp</code>
    </li>

    <li>
      <p>По умолчанию компилятор создаст исполняемый файл <strong>a.exe</strong>. Запустим его</p>
      <code>./a</code>
    </li>

    <li>
      <p>Увидим результат работы программы</p>
      <code>Hello, world!</code>
    </li>

  </ol>
</article>


<!-- Настройка компилятора g++ и clang++ -->
<article class="article">
  <div class="anchor" id="gcc-setup"></div>
  <h3>Настройка компилятора g++ и clang++</h3>

  <p>Можно совместить компиляцию и выполнение одной командой</p>
  <code>g++ source.cpp && ./a</code>

  <p>Можно задать имя исполняемого файла после флага <strong>-o</strong></p>
  <code>g++ source.cpp -o source</code>

  <p>Для компиляции с предупреждениями применяется флаг <strong>-Wall</strong></p>
  <code>g++ -Wall source.cpp</code>

  <p>Можно задать компиляцию в определенный стандарт после флага <strong>-std=</strong></p>
  <code>g++ -std=c++20 source.cpp</code>

  <p>Чтобы гарантировать, что программа будет строго соответствовать определенному стандарту дополнительно используют флаг <strong>-pedantic</strong></p>
  <code>g++ -std=c++20 -Wall -pedantic source.cpp</code>
  <p>В этом случае компилятор будет генерировать предупреждения, если код не соответствует правилам стандарта</p>
</article>


<!-- Конец строки -->
<article class="article">
  <div class="anchor" id="endl"></div>
  <h3>Конец строки</h3>

  <p>Добавим в выводе на консоль конец строки и переход на новую строку</p>
<pre>#include &lt;iostream&gt;
int main() {
  std::cout &lt;&lt; "Hello, world!\n";
  return 0;
}</pre>

  <p>или</p>
<pre>#include &lt;iostream&gt;
int main() {
  std::cout &lt;&lt; "Hello, world!" &lt;&lt; std::endl;
  return 0;
}</pre>
</article>


<!-- namespace -->
<article class="article">
  <div class="anchor" id="namespace"></div>
  <h3>namespace</h3>

  <p>Избавимся от префиксов std::</p>
<pre>#include &lt;iostream&gt;
using namespace std;
int main() {
  cout &lt;&lt; "Hello, world!" &lt;&lt; endl;
  return 0;
}</pre>
</article>


<!-- Локализация и кириллица в консоли-->
<article class="article">
  <div class="anchor" id="locale"></div>
  <h3>Локализация и кириллица в консоли</h3>

  <p>Встроенная функция <strong>setlocale()</strong> явным образом задает текущую локаль для вывода символов. Вместо объекта <strong>cout</strong> применяется объект <strong>wcout</strong>, который работает с символами <strong>Unicode</strong>. В этом случае кодировка исходного кода должна быть в <strong>UTF-8</strong>, а перед строкой указан символ <strong>L</strong></p>
<pre>#include &lt;iostream&gt;
int main() {
  setlocale(LC_ALL, "");
  std::wcout &lt;&lt; L"Привет, мир!";
  return 0;
}</pre>
</article>


<!-- Структура программы -->
<article class="article">
  <div class="anchor" id="struct"></div>
  <h3>Структура программы</h3>
</article>


<!-- Инструкции -->
<article class="article">
  <div class="anchor" id="locale"></div>
  <h3>Инструкции</h3>

  <p>Программа на C++ состоит из набора инструкций. Каждая инструкция (statement) выполняет определенное действие. В конце инструкции ставится точка с запятой (;)</p>
  <code>std::cout &lt;&lt; "Hello world";</code>
</article>


<!-- Блок кода -->
<article class="article">
  <div class="anchor" id="block"></div>
  <h3>Блок кода</h3>

  <p>Набор инструкций может представлять блок кода. Блок кода заключается в фигурные скобки, а инструкции помещаются между открывающей и закрывающей фигурными скобками.</p>
<pre>{
  std::cout &lt;&lt; "Hello world";
  std::cout &lt;&lt; "Bye world";
}</pre>
</article>


<!-- Функция main -->
<article class="article">
  <div class="anchor" id="fmain"></div>
  <h3>Функция main</h3>

  <p>Каждая программа на языке C++ должна иметь как минимум одну функцию - функцию main(). Именно с этой функции начинается выполнение приложения. Ее имя main фиксировано и для всех программ на C++ всегда одинаково.</p>
  <p>Функция также является блоком кода, поэтому ее тело обрамляется фигурными скобками.</p>
<pre>#include &lt;iostream&gt;
int main() {
  std::cout &lt;&lt; "Hello world!";
  return 0;
}</pre>
  <p>Определение функции main начинается с возвращаемого типа. Функция main в любом случае должна возвращать число. Поэтому ее определение начинается с ключевого слова int</p>
</article>


<!-- Директива include -->
<article class="article">
  <div class="anchor" id="include"></div>
  <h3>Директива include</h3>

  <p>Чтобы использовать вывод на консоль, необходимо в начале файла подключать библиотеку iostream с помощью директивы include</p>
  <code>#include &lt;iostream&gt;</code>
  <p>Каждая директива препроцессора размещается на одной строке. В отличие от обычных инструкций, которые завершаются точкой с запятой, директива завершается переводом на новую строку, а начинается со знака решетки #.</p>
</article>


<!-- Комментарии -->
<article class="article">
  <div class="anchor" id="comments"></div>
  <h3>Комментарии</h3>

  <p>При компиляции комментарии игнорируются и не оказывают никакого влияния на работу и размер программы.</p>
  <p>Однострочный комментарий начинается с двойного слеша // и заканчивается концом стоки</p>
  <p>Многострочный комментарий может занимать несколько строк и записывается между символами /* и */</p>
</article>


<!-- Компиляция -->
<article class="article">
  <div class="anchor" id="compil"></div>
  <h3>Компиляция</h3>

  <p>Компиляция исходного кода в исполняемый файл состоит из трех этапов</p>
  <ol>
    <li>Препроцессор обрабатывает все директивы препроцессора (например, #include)</li>
    <li>Компилятор обрабатывает каждый файл с исходным кодом и создает из него объектный файл, который содержит машинный код. Если код написан в нескольких исходный файлах, то для каждого создается свой объектный файл</li>
    <li>Компоновщик (он же линтер) объединяет все объектные файлы в единую программу. Данный процесс называется компоновкой/линковкой</li>
  </ol>
</article>


<!-- Переменная -->
<article class="article">
  <div class="anchor" id="var"></div>
  <h3>Переменная</h3>

  <p>Переменная представляет именнованный участок памяти. Переменная имеет тип, имя, значение. Тип определяет размер занимаемой памяти, какие данные может хранить переменная, какие действия можно делать с этими данными.</p>
  <p>Перед использованием переменной, ее надо определить</p>
  <code>int age;</code>
  <p>Мы определили переменную age с типом int.</p>
</article>


<!-- Инициализация переменной -->
<article class="article">
  <div class="anchor" id="init"></div>
  <h3>Инициализация переменной</h3>

  <p>После определения переменной можно присвоить значение. Присвоение переменной начального значения называется инициализацией.</p>
  <code>age = 20;</code>
  <p>Можно в одной строке выполнить и определение и инициализацию переменной</p>
  <code>int age = 20;</code>
  <p>В C++ есть три вида инициализации</p>
  <ol>
    <li>
      <h4>Нотация присваивания (assignment notation)</h4>
      <p>Значение переменной присваивается с помощью знака равно =</p>
      <code>int age = 38;</code>
      <p>Постоянные значения любого типа называются литералами. Переменной присваивается целочисленный литерал.</p>
    </li>
    <li>
      <h4>Функциональная нотация (function notation)</h4>
      <p>Значение переменной указывается в круглых скобках</p>
      <code>int age (38);</code>
    </li>
    <li>
      <h4>Инициализация в фигурных скобках (braced initialization)</h4>
      <p>Значение переменной указывается в фигурных скобках</p>
      <code>int age {38};</code>
      <p>Инициализация в фигурных скобках безопаснее когда применяется сужающее преобразование. Ожидается, что переменной передается значение, соответствующее ее типу. Если это не так, компилятор попытается преобразовать значение в тип переменной. Сужающее преобразование изменяет значение одного типа на тип с более ограниченным диапазоном значений. Такое преобразование может привести к потери информации.</p>
    </li>
  </ol>
</article>


<!-- Константа -->
<article class="article">
  <div class="anchor" id="const"></div>
  <h3>Константа</h3>

  <p>Константа определяется так же как и переменная, но вначале идет ключевое слово const. Константу нужно определять и инициализировать сразу в одном выражении.</p>
  <code>const int age = 38;</code>
  <code>const float pi {3.14};</code>
</article>


<!-- Типы данных -->
<article class="article">
  <div class="anchor" id="types"></div>
  <h3>Типы данных</h3>

  <p>Каждая переменная имеет определенный тип. Этот тип пишется перед переменной в момент ее определения и его потом нельзя изменить.</p>
</article>


<!-- Логический тип bool -->
<article class="article">
  <div class="anchor" id="bool"></div>
  <h3>Логический тип bool</h3>

  <p>Логический тип bool может хранить одно из двух значений <strong>true</strong> или <strong>false</strong></p>
</article>


<!-- Целочисленные типы -->
<article class="article">
  <div class="anchor" id="integer"></div>
  <h3>Целочисленные типы</h3>

  <p>К целочисленным относятся следующие типы данных</p>
  <ul>
    <li>
      <h4>signed char</h4>
      <p>Занимает 1 байт памяти. Хранит значение от -128 до 127</p>
    </li>
    <li>
      <h4>unsigned char</h4>
      <p>Занимает 1 байт памяти. Хранит значение от 0 до 255</p>
    </li>
    <li>
      <h4>char</h4>
      <p>Занимает 1 байт памяти. Представляет один символ в кодировке ASCII</p>
    </li>
    <li>
      <h4>short</h4>
      <p>Занимает 2 байта памяти. Хранит значение от -32768 до 32767</p>
    </li>
    <li>
      <h4>unsigned short</h4>
      <p>Занимает 2 байта памяти. Хранит значение от 0 до 65535</p>
    </li>
    <li>
      <h4>int</h4>
      <p>Занимает 2 или 4 байта в зависимости от архитектуры процессора. Хранит значение от -32768 до 32767 (при 2 байтах) или от -2 147 483 648 до 2 147 483 647 (при 4 байтах)</p>
    </li>
    <li>
      <h4>unsigned int</h4>
      <p>Занимает 2 или 4 байта в зависимости от архитектуры процессора. Хранит значение от 0 до 65535 (при 2 байтах) или от 0 до 4 294 967 295 (при 4 байтах)</p>
    </li>
    <li>
      <h4>long</h4>
      <p>Занимает 4 или 8 байт в зависимости от архитектуры процессора. Хранит значение от -2 147 483 648 до 2 147 483 647 (при 4 байтах) или от -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807 (при 8 байтах)</p>
    </li>
    <li>
      <h4>unsigned long</h4>
      <p>Занимает 4 байта. Хранит значение от 0 до 4 294 967 295</p>
    </li>
    <li>
      <h4>long long</h4>
      <p>Занимает 8 байт. Хранит значение от -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807</p>
    </li>
    <li>
      <h4>unsigned long long</h4>
      <p>Занимает 8 байт. Хранит значение от 0 до 18 446 744 073 709 551 615</p>
    </li>
  </ul>
  <p>Начиная со стандарта с++14 в язык добавлена возможность разделения разрядов числа с помощью одинарной кавычки</p>
  <code>1'234'567'890</code>
  <p>По умолчанию числа пишутся в десятичной системе счисления. Но можно указать и другие системы</p>
  <p>Шестнадцатеричная система использует префикс 0x или 0X</p>
  <code>int num = 0x1A; // 26 в десятичной</code>
  <p>Восьмеричная системма использует префикс 0</p>
  <code>int num = 0377; // 255 в десятичной</code>
  <p>Двоичная система использует префикс 0b или 0B</p>
  <code>int num = 0b11111111; // 255 в десятичной</code>
</article>


<!-- Числа с плавающей точкой -->
<article class="article">
  <div class="anchor" id="float"></div>
  <h3>Числа с плавающей точкой</h3>

  <p>Число с плавающей точкой состоит из двух частей - мантисы и степени. Оба могут быть положительными или отрицательными. Величина числа - это мантиса, умноженная на десять в степени экспоненты.</p>

  <ul>
    <li>
      <h4>float</h4>
      <p>Занимает 4 байта. Хранит значение от +/- 3.4e-38 до 3.4e+38</p>
      <p>1 бит занимает знак числа. 8 бит для экспоненты. 23 бита для мантиссы (с точностью в 7 десятичных знаков). В сумме 32 бита</p>
    </li>
    <li>
      <h4>double</h4>
      <p>Занимает 8 байт. Хранит значение от +/- 1.7e-308 до 1.7e+308</p>
      <p>1 бит занимает знак числа. 11 бит для экспоненты. 52 бита для мантиссы (с точностью в 16 десятичных знаков). В сумме 64 бита</p>
    </li>
    <li>
      <h4>long double</h4>
      <p>Занимает 8 байт или больше.</p>
    </li>
  </ul>
</article>


<!-- Оператор sizeof() -->
<article class="article">
  <div class="anchor" id="sizeof"></div>
  <h3>Оператор sizeof()</h3>

  <p>Оператор sizeof() возвращает размер памяти в байтах, которую занимает переменная</p>
</article>


<!-- Символьные типы -->
<article class="article">
  <div class="anchor" id="char"></div>
  <h3>Символьные типы</h3>

  <p>В C++ есть следующие символьные типы данных</p>
  <ul>
    <li>
      <h4>char</h4>
      <p>Занимает 1 байт. Представляет один символ в кодировке ASCII. Хранит значение от 0 до 255</p>
      <code>char a1 {'A'};</code>
      <code>char a2 {65};</code>
    </li>
    <li>
      <h4>wchar_t</h4>
      <p>Занимает 2 байта. Представляет расширенный символ. Хранит значение от 0 до 65 535</p>
      <code>wchar_t a1 {L'A'};</code>
      <code>wchar_t a2 {L'\x41'};</code>
      <p>Для вывода в консоль символов wchar_t нужно использовать не std::cout, а поток std::wcout</p>
      <code>std::wcout &lt;&lt; L'\x41';</code>
      <p>При этом поток td::wcout может работать как с char, так и с wchar_t</p>
    </li>
    <li>
      <h4>char8_t</h4>
      <p>Занимает 1 байт. Представляет один символ в кодировке Unicode. Хранит значение от 0 до 255</p>
    </li>
    <li>
      <h4>char16_t</h4>
      <p>Занимает 2 байта. Представляет один символ в кодировке Unicode. Хранит значение от 0 до 65 535</p>
    </li>
    <li>
      <h4>char32_t</h4>
      <p>Занимает 4 байта. Представляет один символ в кодировке Unicode. Хранит значение от 0 до 4 294 967 295</p>
    </li>
  </ul>
</article>


<!-- Спецификатор auto -->
<article class="article">
  <div class="anchor" id="auto"></div>
  <h3>Спецификатор auto</h3>

  <p>Спецификатор auto позволяет компилятору самому определить тип переменной. При объявлении со спецификатором auto переменная должна быть сразу инициализирована.</p>
</article>


<!-- Неявное преобразование типа -->
<article class="article">
  <div class="anchor" id="type-conv-no"></div>
  <h3>Неявное преобразование типа</h3>

  <p>Все целочисленные литералы без суффиксов по умолчанию имеют тип int (signed int). При инициализации переменной с типом unsigned int произойдет неявное преобразование. Компилятор автоматически преобразует тип signed int к типу unsigned int</p>
  <code>unsigned int age {25};</code>
  <p>Если такое преобразование невозможно то будет ошибка компиляции</p>
  <code>unsigned int age {-25};</code>

  <h4>Преобразование в логический тип</h4>
  <p>Значение 0 преобразуется в <strong>false</strong>, все остальные значения преобразуются в <strong>true</strong></p>
  <code>bool a = 1; // true</code>
  <code>bool b = 3.14; // true</code>
  <code>bool c = 'c'; // true</code>
  <code>bool d = 0; // false</code>

  <h4>Преобразование в целый тип из логического</h4>
  <p>Логическое <strong>true</strong> преобразуется в 1, логическое <strong>false</strong> в 0</p>
  <code>int a = true; // 1</code>
  <code>int b = false; // 0</code>

  <h4>Преобразование целого числа в дробное</h4>
  <p>Может произойти потеря точности</p>
  <code>double a = 35005000000333; // 3.5005e+012</code>

  <h4>Преобразование в беззнаковый тип</h4>
  <p>Если значение выходит за диапазон допустимых, то присваивается остаток от деления по модулю</p>
  <code>unsigned char a = -5; // 251</code>
  <code>unsigned short b = -3500; // 62036</code>


<!-- Явное преобразование типа -->
<article class="article">
  <div class="anchor" id="type-conv"></div>
  <h3>Явное преобразование типа</h3>

  <p>Для выполнения явных преобразований типов (explicit type conversion) применяется оператор static_cast</p>
</article>


<!-- Ввод и вывод в консоли -->
<article class="article">
  <div class="anchor" id="console"></div>
  <h3>Ввод и вывод в консоли</h3>

  <p>Ввод и вывод в консоли предоставляются библиотекой <strong>iostream</strong>. Поток - это последовательность символов, которая записывается на устройство ввода-вывода или считывается с него.Консоль - это устройство ввода-вывода.</p>
  <p>Для вывода символов на консоль применяется объект <strong>cout</strong>. Для чтения с консоли применяется объект <strong>cin</strong></p>
  <p>Для вывода на консоль применяется оператор <strong>&lt;&lt;</strong></p>
  <code>std::cout &lt;&lt; "Name" &lt;&lt; std::endl;</code>
  <p><strong>endl</strong> - это перевод на новую строку и сброс буфера</p>
  <p>Для ввода с консоли применяется оператор <strong>&gt;&gt;</strong></p>
  <code>int age;</code>
  <code>std::cout &gt;&gt; age</code>
</article>


<!-- using Пространство имен и псевдонимы -->
<article class="article">
  <div class="anchor" id="using"></div>
  <h3>using Пространство имен и псевдонимы</h3>

  <p>В объектах std::cout, std::cin, std::endl используется префикс std:: который указывает что объекты cout, cin, endl определены в пространстве имен std. А само двойное двоеточие :: это оператор области видимости, который указывает пространство имен в котором определен объект. Без префикса std:: мы эти объекты использовать не можем.</p>
  <p>Оператор using позволяет ввести в программу объекты из различных пространств имен</p>
  <code>using namespace std</code>
  <code>cout &lt;&lt; "age";</code>
  <p>Второе предназанчение слова using это определять псевдонимы для типов. Например, можно сократить название длинных типов</p>
  <code>using ullong = unsigned long long;</code>
  <code>ullong n {10234};</code>
  <p>Для определения псевдонимов можно использовать и старый подход в стиле языка Си с помощью оператора typedef</p>
  <code>typedef unsigned long long ullong;</code>
  <code>ullong n {10234};</code>
</article>


<!-- Ассоциативность операторов -->
<article class="article">
  <div class="anchor" id="assoc"></div>
  <h3>Ассоциативность операторов</h3>

  <p>Операторы могут быть <strong>левоассоциативными</strong> - выполняются слева направо и <strong>правоассоциативными</strong> - выполняются справа налево</p>
  <p>В основном все операторы левоассоциативные</p>
  <p>Правоассоциативные операторы - унарные операторы, операторы присваивания и условный оператор</p>
</article>


