<h1>learn.microsoft.com</h1>

<!-- Заголовок -->
<div class="article">
  <div class="anchor" id="content"></div>
  <h2>Содержание</h2>
</div>

<!-- Содержание -->
<div class="article article__content">

  <div>
    <p><a href="#module">Build JavaScript applications using TypeScript</a> Создание приложений JavaScript с помощью TypeScript</p>
    <p><a href="#module-1">Module 1. Getting Started with TypeScript</a> Начало работы с TypeScript 36 мин</p>
    <p><a href="#module-2">Module 2. Declare Variable Types in TypeScript</a> Объявление типов переменных в TypeScript 38 мин</p>
    <p><a href="#module-3">Module 3. Implement Interfaces in TypeScript</a> Реализация интерфейсов в TypeScript 46 мин</p>
    <p><a href="#module-4">Module 4. Develop Typed Functions in TypeScript</a> Разработка типизированных функций с использованием TypeScript 51 мин</p>
    <p><a href="#module-5">Module 5. Declare and Instantiate Classes in TypeScript</a> Объявление классов и создание их экземпляров в TypeScript 1 ч 7 мин</p>
    <p><a href="#module-6">Module 6. Generics in TypeScript</a> Определение универсальных шаблонов в TypeScript 46 мин</p>
    <p><a href="#module-7">Module 7. Work with External Libraries in TypeScript</a> Доступ к внешним библиотекам из TypeScript 46 мин</p>
    <p><a href="#module-8">Module 8. Organize Code with Namespaces in TypeScript</a> Упорядочение кода с помощью пространств имен TypeScript 46 мин</p>
    </div>

</div>


<!-- module -->
<article class="article">
  <div class="anchor" id="module"></div>
  <h2>Build JavaScript applications using TypeScript</h2>

  <p><a href="https://learn.microsoft.com/api/achievements/share/ru-ru/frontend200tb-0827/WAC4HG5N?sharingId=6364D7D096225EB9">Значек</a></p>

  <p><a href="https://learn.microsoft.com/en-us/training/paths/build-javascript-applications-typescript/">Build JavaScript applications using TypeScript (en)</a>
  <br><a href="https://learn.microsoft.com/ru-ru/training/paths/build-javascript-applications-typescript/">Создание приложений JavaScript с помощью TypeScript (ru)</a></p>

  <p>6 ч 4 мин 8 модулей</p>
  <p>TypeScript предоставляет все возможности JavaScript, а также дополнительный уровень — систему типов TypeScript. В этой схеме обучения показано, как используя TypeScript для разработки JavaScript, можно создавать более надежный код, сокращать ошибки типов среды выполнения, использовать преимущества современных функций, прежде чем они будут доступны в JavaScript, и оптимизировать работу с командами разработчиков.</p>

  <h3>Предварительные требования</h3>
  <ol>
    <li>Знакомство с базовым HTML и JavaScript ES6/2015, включая:
      <ul>
        <li>Условные выражения</li>
        <li>Функции</li>
        <li>Область</li>
        <li>Массивы</li>
        <li>Циклы</li>
        <li>Итераторы</li>
        <li>Объект</li>
        <li>Классы</li>
        <li>Модули</li>
      </ul>
    </li>
    <li>Установленное программное обеспечение:
      <ul>
        <li>Git</li>
        <li>Visual Studio Code</li>
        <li>Node.js</li>
        <li>TypeScript</li>
      </ul>
    </li>
  </ol>
</article>


<!-- module-1 -->
<article class="article">
  <div class="anchor" id="module-1"></div>
  <h2>Модуль 1. Getting Started with TypeScript. Начало работы с TypeScript. 36 мин</h2>

  <p><a href="https://learn.microsoft.com/api/achievements/share/ru-ru/frontend200tb-0827/HYLSQA78?sharingId=6364D7D096225EB9">Значек</a></p>

  <p><a href="https://learn.microsoft.com/en-us/training/modules/typescript-get-started/">Getting Started with TypeScript (en)</a>
  <br><a href="https://learn.microsoft.com/ru-ru/training/modules/typescript-get-started/">Начало работы с TypeScript (ru)</a></p>

  <p>36 мин Модуль 8 единиц(ы)</p>
  <p>В этом модуле представлены сведения о языке TypeScript, причинах его создания и его использовании для разработки JavaScript. Вы также настроите среду разработки TypeScript для будущих упражнений.</p>

  <h3>Цели обучения</h3>
  <p>В этом модуле вы:</p>
  <ul>
    <li>Узнаете, что TypeScript является улучшением JavaScript для веб-разработки.</li>
    <li>Выберете редактор TypeScript.</li>
    <li>Установите TypeScript.</li>
    <li>Настроите проект TypeScript в Visual Studio Code.</li>
  </ul>

  <h3>Предварительные требования</h3>
  <ul>
    <li>Знание JavaScript</li>
  </ul>

  <h3>Этот модуль входит в состав указанных схем обучения</h3>
  <ul>
    <li>Создание приложений JavaScript с помощью TypeScript</li>
  </ul>

  <p>Введение 2 мин</p>
  <p>Общие сведения о TypeScript 5 мин</p>
  <p>Упражнение. Выбор редактора TypeScript 5 мин</p>
  <p>Упражнение. Установка компилятора TypeScript 5 мин</p>
  <p>Компиляция файла TypeScript 5 мин</p>
  <p>Упражнение. Подготовка проекта TypeScript 10 мин</p>
  <p>Проверка знаний 2 мин</p>
  <p>Сводка 2 мин</p>
</article>


<!-- module-1 введение -->
<article class="article">
  <h2>Урок 1 из 8. Введение. 2 мин</h2>

  <p>В этом модуле вы познакомитесь с языком TypeScript, узнаете, почему он был создан, и увидите, как можно использовать его преимущества для разработки JavaScript.</p>
  <p>Вы также настроите среду разработки TypeScript, чтобы подготовиться к будущим упражнениям.</p>

  <h3>Цели обучения</h3>
  <p>Из этого модуля вы узнаете следующее:</p>
  <ul>
    <li>Узнаете, что TypeScript является улучшением JavaScript для веб-разработки.</li>
    <li>Выберете редактор TypeScript.</li>
    <li>Установите TypeScript.</li>
    <li>Настроите проект TypeScript в Visual Studio Code.</li>
  </ul>

  <h3>Необходимые компоненты</h3>
  <ul>
    <li>Знание JavaScript</li>
  </ul>
</article>


<!-- module-1 Общие сведения о TypeScript -->
<article class="article">
  <h2>Урок 2 из 8. Общие сведения о TypeScript. 5 мин</h2>

  <p>JavaScript, один из наиболее используемых в мире языков программирования, стал официальным языком веб-разработки. Разработчики используют его для создания кроссплатформенных приложений, которые могут работать на любой платформе и в любом браузере.</p>
  <p>Хотя JavaScript используется для создания кроссплатформенных приложений, он не предназначен для больших приложений, включающих тысячи или даже миллионы строк кода. В JavaScript отсутствуют некоторые функции более зрелых языков, на которых написаны современные сложные приложения. В интегрированных средах разработки (IDE) будет сложно управлять JavaScript и поддерживать большие базы кода.</p>
  <p>TypeScript позволяет устранить ограничения JavaScript без ущерба для ключевого преимущества JavaScript — возможности выполнять код в любом месте и на любой платформе, браузере или узле.</p>

  <h3>Что такое TypeScript?</h3>
  <p>TypeScript — это язык с открытым кодом, разработанный корпорацией Майкрософт. Это супермножество JavaScript, что означает, что вы можете использовать навыки JavaScript, которые вы уже разработали вместе с некоторыми функциями, которые ранее были недоступны для вас.</p>

  <h3>Подсказки по типам</h3>
  <p>Основной компонент TypeScript — это система типов. В TypeScript можно задать тип данных переменной или параметра, используя указание типа. С помощью указаний типа вы описываете форму объекта для более подробного документирования, чтобы TypeScript проверил правильность работы кода.</p>
  <p>С помощью статической проверки типов TypeScript перехватывает проблемы с кодом на ранних этапах разработки, которые JavaScript не может обнаружить, пока код не будет запущен в браузере. Типы также позволяют описать, что должен делать код. Если вы работаете в команде, ваш коллега затем легко разберется в вашем коде.</p>
  <p>Типы также предоставляют преимущества анализа и продуктивности средств разработки, таких как IntelliSense, навигация на основе символов, переход к определению, поиск всех ссылок, завершение операторов и рефакторинг кода.</p>
  <p>Написание типов может быть необязательным в TypeScript, так как вывод типов позволяет получить большую часть этой возможности без написания дополнительного кода. Если TypeScript может определить тип данных неявно (например, при присвоении значения переменной с помощью <code class="code-inline">let age = 42</code>), он автоматически выводит тип данных.</p>

  <h3>Попробовать! Изучение типов</h3>
  <p>Рассмотрим пример, демонстрирующий использование типов.</p>
  <ol>
    <li>Откройте <a href="https://www.typescriptlang.org/play">тестовую площадку</a> TypeScript. С тестовой площадкой вы познакомитесь более подробно далее в рамках этого модуля.</li>
    <li>
      <p>Скопируйте и вставьте следующий пример кода JavaScript в область TypeScript слева:</p>
      <code>function addNumbers(x, y) {
      <br>return x + y;
      <br>}
      <br>console.log(addNumbers(3, 6));</code>
      <p>Обратите внимание, что тот же код отображается в области .JS справа. На этой панели показан код JavaScript, создаваемый TypeScript после компиляции.</p>
    </li>
    <li>Нажмите <strong>Выполнить</strong>, чтобы выполнить код JavaScript. Затем перейдите на вкладку <strong>Журналы</strong> и обратите внимание, что значение <code class="code-inline">9</code> записывается в консоль. JavaScript назначил тип <code class="code-inline">number</code> параметрам <code class="code-inline">x</code> и <code class="code-inline">y</code>, а функция вернула число.</li>
    <li>Замените <code class="code-inline">3</code> на <code class="code-inline">"three"</code> (включая кавычки) в коде TypeScript и запустите его. Теперь JavaScript присваивает тип <code class="code-inline">string</code> параметру <code class="code-inline">x</code> и возвращает в консоль тип строки "three6". Вы, вероятно, сталкивались с такими ситуациями раньше и знаете, что это может привести к непредвиденным результатам.
    <p>В области TypeScript обратите внимание на красные волнистые линии под именами параметров в функции <code class="code-inline">addNumbers</code>. Строки указывают на то, что тип проверка ер определил ошибки. Наведите указатель мыши на один из параметров и прочтите описание ошибки. TypeScript неявно назначает тип <code class="code-inline">any</code>, который является самым широким типом, так как он может содержать что угодно.</p></li>
    <li>Обновите код TypeScript, чтобы указать тип для каждого параметра. Замените <code class="code-inline">x</code> на <code class="code-inline">x: number</code> и <code class="code-inline">y</code> на <code class="code-inline">y: number</code>.
      <p>Вы заметите, что ошибки теперь ушли из параметров, но новый появился под первым аргументом в вызове функции: "Аргумент типа "string" не может быть назначен параметру типа "number".</p>
    </li>
    <li>Замените на <code class="code-inline">"three"</code> число, чтобы исправить ошибку. Можно передать литеральное значение, переменную или любые другие данные. TypeScript понимает форму объекта, поэтому она может уведомить вас о конфликте типов во время разработки.</li>
    <li>Просмотрите код JavaScript и обратите внимание, что в нем нет изменений. TypeScript смог предоставить тип проверка во время разработки, но не повлиял на полученный код JavaScript, так как он не поддерживает типы.</li>
  </ol>

  <h3>Другие функции кода TypeScript</h3>
  <p>TypeScript имеет больше возможностей написания кода, которые не будут находиться в JavaScript:</p>
  <ul>
    <li>Интерфейсы</li>
    <li>Пространства имен</li>
    <li>Универсальные шаблоны</li>
    <li>Абстрактные классы</li>
    <li>Модификаторы данных</li>
    <li>Необязательные параметры</li>
    <li>Перегрузка функций</li>
    <li>Декораторы</li>
    <li>Тип utils</li>
    <li>Ключевое слово readonly</li>
  </ul>
  <p>Дополнительные сведения о некоторых из этих функций см. в следующих модулях.</p>

  <h3>Совместимость TypeScript с JavaScript</h3>
  <p>TypeScript является строгим надмножеством <a href="https://www.ecma-international.org/ecma-262/6.0/">ECMAScript 2015</a> (ECMAScript 6 или ES6). Эта связь означает, что весь код JavaScript также является кодом TypeScript, а программа TypeScript может легко использовать JavaScript.</p>
  <p>Браузеры понимают только JavaScript. Чтобы приложение работало, при написании его в TypeScript необходимо скомпилировать код и преобразовать его в JavaScript. Преобразование кода TypeScript в код JavaScript осуществляется с помощью компилятора TypeScript или транскомпилятора, совместимого с TypeScript. Полученный JavaScript — это чистый простой код, который работает где угодно: в браузере, на Node.js или в приложениях.</p>

  <h3>Важно!</h3>
  <p>При работе с TypeScript следует помнить, что TypeScript будет скомпилирован (или транскомпилирован) в JavaScript, который и будет выполняться средой выполнения. TypeScript можно использовать в любом проекте, где используется JavaScript.</p>

  <h3>Миграция из JavaScript в TypeScript</h3>
  <p>Внедрение TypeScript не является двоичным выбором, поэтому вы можете постепенно перенести базу кода. Вы можете начать с аннотации существующего JavaScript с помощью JSDoc, а затем переключить несколько файлов для проверки с помощью TypeScript. Вы можете подготовить базу кода к полному преобразованию с течением времени.</p>
  <p>Дополнительные сведения об этом процессе см. в <a href="https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html">руководствах по TypeScript: миграция из JavaScript</a></p>
</article>


<!-- module-1 Упражнение. Выбор редактора TypeScript -->
<article class="article">
  <h2>Урок 3 из 8. Упражнение. Выбор редактора TypeScript. 5 мин</h2>
  <p>Вы можете написать код TypeScript в любом текстовом редакторе или IDE.</p>
  <p>В этом упражнении вы узнаете о параметрах текстового редактора, а затем настроите Visual Studio Code, чтобы можно было выполнить оставшиеся упражнения в этом модуле.</p>

  <h3>Тестовая площадка TypeScript</h3>
  <p>Ранее вы написали простой код TypeScript на тестовой площадке. Тестовая площадка — это место, где можно писать, совместно использовать и изучать TypeScript. Ее можно использовать в следующих целях:</p>
  <ul>
    <li>Изучение TypeScript в среде, где ничего не может сломаться.</li>
    <li>Эксперименты с синтаксисом TypeScript и совместное использование URL-адресов с другими пользователями.</li>
    <li>Эксперименты с различными функциями компилятора TypeScript.</li>
  </ul>
  <p>В этом курсе вы иногда будете использовать тестовую площадку, чтобы испытывать новые концепции TypeScript.</p>

  <h3>Интегрированные среды разработки</h3>
  <p>Для полноценного редактирования и использования инструментов TypeScript можно использовать различные интегрированные среды разработки (IDE), которые поддерживают TypeScript или содержат подключаемые модули или пакеты инструментов, разработанные для его поддержки. В этом модуле используется Visual Studio Code, но вы можете выбрать любой другой редактор.</p>

  <h3>Установка Visual Studio Code</h3>
  <p>Visual Studio Code — это простой и бесплатный редактор исходного кода, который работает в операционных системах macOS, Linux и Windows. Он изначально поддерживает JavaScript, TypeScript и Node.js и имеет обширную экосистему расширений для других языков и сред выполнения.</p>
  <p>Установка Visual Studio Code:</p>
  <ol>
    <li>Перейдите на страницу <a href="https://code.visualstudio.com/download">загрузки Visual Studio Code</a> и выберите вариант загрузки для вашей операционной системы.</li>
    <li>Чтобы получить дополнительные рекомендации по настройке, перейдите на страницу установки операционной системы:
      <ul>
        <li>Linux</li>
        <li>macOS</li>
        <li>Windows</li>
      </ul>
    </li>
  </ol>
  <p>Теперь, когда у вас есть редактор кода, можно приступать к установке TypeScript.</p>
</article>


<!-- module-1 Упражнение. Установка компилятора TypeScript -->
<article class="article">
  <h2>Урок 4 из 8. Упражнение. Установка компилятора TypeScript. 5 мин</h2>
  <p>В редакторе кода может быть встроенная поддержка языка Для TypeScript. Однако чтобы преобразовать код TypeScript в JavaScript, который будет понимать браузер, необходимо сначала установить библиотеку TypeScript. Библиотека также содержит компилятор TypeScript, который называется tsc.</p>
  <p>TypeScript можно установить глобально (доступно в любой точке файловой системы) или локально (доступно только на уровне проекта). В этом упражнении вы установите TypeScript глобально. По мере внедрения TypeScript в более крупные и сложные базы кода вы, скорее всего, перейдете к установке по проектам, чтобы лучше контролировать согласованность проектов.</p>

  <h3>Тестирование установки TypeScript</h3>
  <p>Возможно, на вашем компьютере уже установлен TypeScript. Вы можете проверка, открыв окно командной строки и введя <code class="code-inline">tsc</code>. Если TypeScript установлен, вы увидите версию и список команд компилятора. Теперь все готово к использованию TypeScript.</p>
  <p>Если TypeScript не установлен, появится сообщение о том, что команда не распознана. В этом случае перейдите к следующему шагу упражнения.</p>

  <h3>Установка диспетчера пакетов Node (npm)</h3>
  <p>Для запуска пакета TypeScript потребуется копия Node.js в качестве среды. Node.js, библиотека JavaScript для серверных приложений, не требуется для изучения TypeScript. Но, установив ее, вы также получаете диспетчер пакетов Node, npm — диспетчер пакетов для языка JavaScript. Затем вы сможете использовать npm для установки пакета TypeScript.</p>
  <p>Если вы являетесь разработчиком JavaScript, npm, скорее всего, уже установлен на вашем компьютере. Вы можете проверка, открыв окно командной строки и введя <code class="code-inline">npm version</code>. Если npm установлен, вы увидите версию и список команд компилятора и сможете использовать npm.</p>
  <p>Если npm не установлен, появится сообщение о том, что команда не распознана. Установка Node.js:</p>
  <ol>
    <li>Перейдите на страницу <a href="https://nodejs.org/en/download"></a>Загрузки Node.js.</li>
    <li>Выберите любую из доступных версий Node.js, чтобы скачать и установить ее.</li>
    <li>Чтобы убедиться, что npm установлен, откройте окно командной строки и введите <code class="code-inline">npm version</code>.</li>
  </ol>

  <h3>Установите TypeScript</h3>
  <p>TypeScript доступен в виде пакета в реестре npm — typescript. Установка последней версии TypeScript:</p>
  <ol>
    <li>В окне командной строки введите <code class="code-inline">npm install -g typescript</code>.</li>
    <li>Введите <code class="code-inline">tsc</code>, чтобы убедиться, что TypeScript установлен. Если он успешно установлен, эта команда должна отобразить список команд и параметров компилятора.</li>
  </ol>
</article>


<!-- module-1 Компиляция файла TypeScript -->
<article class="article">
  <h2>Урок 5 из 8. Компиляция файла TypeScript. 5 мин</h2>

  <p>Как вы уже знаете, TypeScript является строгим надмножеством <a href="https://www.ecma-international.org/ecma-262/6.0/">ECMAScript 2015</a> (ECMAScript 6 или ES6). Весь код JavaScript также является кодом TypeScript, и программа TypeScript может легко использовать JavaScript. На самом деле вы можете преобразовать файл JavaScript в файл TypeScript только путем переименования расширения из JS в TS.</p>
  <p>Однако не весь код TypeScript является кодом JavaScript. TypeScript добавляет новый синтаксис в JavaScript, что упрощает чтение и реализацию некоторых функций JavaScript, таких как статический ввод. Хотя код TypeScript упрощает разработку и уменьшает вероятность ошибок, браузеры и большинство других сред выполнения изначально не поддерживают TypeScript. По этой причине TypeScript требует шаг сборки (транскомпилятор) для преобразования его в JavaScript для работы приложения.</p>
  <p>Код TypeScript можно преобразовать в код JavaScript с помощью компилятора TypeScript. Или можно использовать совместимый с TypeScript транскомпилятор, например Babel, swc или Sucrase. Этот процесс удаляет код, относящийся к TypeScript (например, объявления типов и интерфейсы). Кроме того, он создает чистый файл JavaScript, который запускается с веб-страниц и является совместимым с браузерами.</p>

  <h3>Компиляция файла TypeScript</h3>
  <p>Запустите компилятор TypeScript из командной строки с помощью команды <code class="code-inline">tsc</code>. При запуске <code class="code-inline">tsc</code> без параметров он компилирует все файлы TS в текущей папке и создает JS-файл для каждого из них.</p>
  <p>Можно также скомпилировать конкретный файл. Например, чтобы скомпилировать файл TypeScript с именем utility_functions.ts, введите <code class="code-inline">tsc utility_functions.ts</code>.</p>
  <p>Примечание. Вводить расширение файла .ts необязательно.</p>
  <p>Если ошибки компилятора отсутствуют, команда <code class="code-inline">tsc</code> создает файл JavaScript с именем utility_functions.js.</p>
  <p>Если компилятор обнаруживает ошибки в коде, он отображает их в командном окне. Исправьте ошибки в файле TypeScript и повторите команду <code class="code-inline">tsc</code>.</p>

  <h3>Параметры компилятора</h3>
  <p>С помощью параметров компилятора можно управлять созданием JavaScript из исходного TypeScript. Параметры можно задать либо в командной строке, как и при использовании многих интерфейсов командной строки, либо в файле JSON с именем tsconfig.json.</p>
  <p>Вам доступно множество параметров компилятора. Полный список параметров можно найти в документации по интерфейсам командной строки tsc. Ниже перечислены наиболее распространенные из них:</p>
  <ul>
    <li>noImplicitAny</li>
    <li>noEmitOnError</li>
    <li>target</li>
    <li>Параметры каталога</li>
  </ul>
  <p>Для управления компиляцией можно использовать параметры компилятора с командой tsc, в том числе:</p>
  <ul>
    <li>Параметр <code class="code-inline">--noImplicitAny</code> предписывает компилятору вызывать ошибки в выражениях и объявлениях с неявным типом <code class="code-inline">any</code>. Например:
      <code>tsc utility_functions.ts --noImplicitAny</code>
    </li>
    <li>Параметр <code class="code-inline">--target</code> указывает целевую версию ECMAScript для файла JavaScript. В этом примере компилируется файл JavaScript, совместимый с ECMAScript 6:
      <code>tsc utility_functions.ts --target "ES2015"</code>
    </li>
  </ul>
  <p>Дополнительные сведения о других параметрах компилятора см. в следующих модулях.</p>
</article>


<!-- module-1 Упражнение. Подготовка проекта TypeScript -->
<article class="article">
  <h2>Урок 6 из 8. Упражнение. Подготовка проекта TypeScript. 10 мин</h2>

  <p>В этом упражнении вы создадите проект TypeScript. Затем вы убедитесь, что ваша среда разработки правильно настроена, запустив компилятор и убедившись, что файл JavaScript создан.</p>

  <h3>Настройка проекта TypeScript в Visual Studio Code</h3>
  <p>На этом шаге вы создадите рабочую область проекта в Visual Studio Code, а затем инициализируете проект.</p>
  <ol>
    <li>Откройте Visual Studio Code.</li>
    <li>На панели приветствия выберите пункт Добавить папку рабочей области.</li>
    <li>Создайте новую папку проекта и нажмите кнопку Добавить.</li>
    <li>На левой панели нажмите кнопку Обозреватель.</li>
    <li>На панели обозревателя щелкните значок Создать файл.</li>
    <li>В разделе Упражнение по модулю 01 введите имя файла module01.ts, а затем нажмите клавишу ВВОД. Файл TypeScript появится в новом редакторе кода.</li>
  </ol>

  <h3>Создание файла tsconfig.json</h3>
  <p>Компилятор TypeScript применяет поведение по умолчанию при компиляции исходного кода TypeScript. Но вы можете изменить параметры компилятора TypeScript, добавив файл tsconfig.json в корневую папку проекта TypeScript. Этот файл определяет параметры проекта TypeScript, такие как параметры компилятора и включаемые в него файлы.</p>
  <p>Вы можете использовать <code class="code-inline">init</code> параметр компилятора TypeScript для создания файла tsconfig.json с параметрами по умолчанию.</p>
  <ol>
    <li>В Visual Studio Code откройте новое окно терминала, выбрав Терминал - Новый терминал.</li>
    <li>В командной строке введите <code class="code-inline">tsc --init</code>.
      <p>Обратите внимание, что новый файл tsconfig.json добавлен на панель обозревателя. Для просмотра файла, возможно, потребуется обновить панель обозревателя.</p>
    </li>
    <li>Откройте файл tsconfig.json в редакторе кода. Вы увидите, что он имеет множество вариантов, большинство из которых закомментированы. Просмотрите описание каждого включенного параметра.</li>
    <li>В файле tsconfig.json найдите параметр target и измените его на <code class="code-inline">"ES2015"</code>.</li>
    <li>Обновите файл tsconfig.json, чтобы компилятор сохранил все файлы JavaScript в новой папке.
      <p>a. На панели обозревателя создайте в проекте новую папку с именем build.</p>
      <p>b. В файле tsconfig.json найдите параметр <code class="code-inline">outDir</code>, удалите комментарий и задайте для параметра значение build.</p>
    </li>
    <li>Сохраните файл tsconfig.json.</li>
    <li>В командной строке введите <code class="code-inline">tsc</code>. Эта команда считывает файл tsconfig.json и сбрасывает параметры проекта.</li>
  </ol>
  <p>Совет. Дополнительные сведения о файле jsconfig.json см. в справочнике по TSConfig.</p>

  <h3>Компиляция TypeScript в JavaScript</h3>
  <p>Добавим код JavaScript в файл TypeScript, а затем скомпилируем его.</p>
  <ol>
    <li>Скопируйте и вставьте следующий код JavaScript в редактор module01.ts.
      <pre>
function addNumbers(x, y) {
  return x + y;
}
console.log(addNumbers(3, 6));
      </pre>
    <p>Обратите внимание, что даже если код еще не скомпилирован, Visual Studio Code использовал встроенную поддержку TypeScript для проверки типов. Как и ранее, в двух параметрах функции addNumbers есть ошибки типа.</p></li>
    <li>Обновите код TypeScript, чтобы указать тип для каждого параметра. Замените <code class="code-inline">x</code> на <code class="code-inline">x: number</code>, а <code class="code-inline">y</code> — на <code class="code-inline">y: number</code>.</li>
    <li>Сохраните файл TypeScript. Компилятор TypeScript работает только с сохраненной версией файла.</li>
    <li>В командной строке терминала введите <code class="code-inline">tsc module01.ts</code>. Компилятор должен запуститься без ошибок.
      <p>Обратите внимание, что добавлен новый файл JavaScript, но он не содержится в папке сборки в Обозреватель. Для просмотра файла, возможно, потребуется обновить панель обозревателя. При выполнении команды <code class="code-inline">tsc</code> для одного файла компилятор игнорирует файл tsconfig.json.</p>
    </li>
    <li>Чтобы загрузить файл конфигурации и скомпилировать все TS-файлы в папке, запустите <code class="code-inline">tsc</code> без имени файла. Эта команда должна добавить JS-файл в папку сборки. Не забудьте удалить дополнительный JS-файл в корневой папке.</li>
    <li>Откройте файл module01.js, а затем нажмите кнопку Разделить редактор справа в правом верхнем углу, чтобы открыть новое представление редактора.
      <p>Теперь TS- и JS-файлы должны быть доступны параллельно. Обратите внимание, что они идентичны, за исключением того, что файл JS не содержит новых аннотаций типа.</p>
    </li>
    <li>В командной строке терминала введите <code class="code-inline">node ./build/module01.js</code>. Эта команда запускает JavaScript и отображает результат в журнале консоли.</li>
  </ol>

  <h3>Добавление HTML-файла</h3>
  <p>В качестве последнего шага добавьте в проект HTML-файл, чтобы можно было выполнять и тестировать код JavaScript.</p>
  <ol>
    <li>На панели обозревателя щелкните значок Создать файл.</li>
    <li>Введите имя файла module01.html, а затем нажмите клавишу ВВОД. HTML-файл появится в новом редакторе кода.</li>
    <li>Скопируйте и вставьте следующий HTML-код в редактор, а затем сохраните файл.
      <pre>
&lt;!DOCTYPE html&gt;
&lt;html lang="en" dir="ltr"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;Test JavaScript&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1&gt;Test JavaScript&lt;/h1&gt;
    &lt;p id="date"&gt;&lt;/p&gt;
    &lt;p&gt;This page calls the script module01.js and is used for testing.&lt;/p&gt;
    &lt;script src="./build/module01.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
      </pre>
    </li>
    <li>В обозревателе щелкните правой кнопкой мыши module01.html, а затем выберите Открыть в браузере по умолчанию.</li>
    <li>Активируйте средства разработчика для браузера и приступите к написанию кода в TypeScript!</li>
  </ol>

  <h3>Решение упражнения</h3>
  <p>Вы можете скачать готовую рабочую область Visual Studio Code из репозитория кода GitHub. Чтобы запустить решение, необходимо сначала установить на компьютере следующее программное обеспечение:</p>
  <ul>
    <li>Visual Studio Code (или IDE по своему усмотрению).</li>
    <li>Диспетчер пакетов Node (npm).</li>
    <li>Компилятор TypeScript (tsc).</li>
  </ul>
  <p>Для получения наилучших результатов полностью следуйте инструкциям по настройке среды и использованию компилятора TypeScript в этом модуле. После настройки среды можно запустить любые файлы подготовки к заданию или его решения в схеме обучения Сборка приложений JavaScript с помощью TypeScript.</p>
</article>


<!-- module-1 Проверка знаний -->
<article class="article">
  <h2>Урок 7 из 8. Проверка знаний. 2 мин</h2>
  <p>Выберите наиболее подходящий ответ на каждый из приведенных ниже вопросов:</p>
  <ol>
    <li>1. Как связаны TypeScript и JavaScript?
      <ul>
        <li>TypeScript — это надмножество JavaScript.</li>
        <li>TypeScript и JavaScript идентичны.</li>
        <li>TypeScript — это подмножество JavaScript.</li>
      </ul>
    </li>
    <li>2. Зачем нужно компилировать (или транскомпилировать) код TypeScript в JavaScript, прежде чем его можно будет использовать в приложениях?
      <ul>
        <li>Не обязательно, так как для его работы необходимо переименовать только файл TypeScript с расширением JS.</li>
        <li>Код TypeScript считается допустимым javaScript, а код JavaScript недействителен в TypeScript.</li>
        <li>TypeScript включает функции кода, несовместимые с браузерами.</li></li>
      </ul>
    <li>3. Что делает команда npm install -g typescript?
      <ul>
        <li>Устанавливает npm, чтобы можно было установить TypeScript.</li>
        <li>Устанавливает компилятор TypeScript на компьютере глобально.</li>
        <li>Устанавливает Node.js и npm.</li>
      </ul>
    </li>
  </ol>
</article>


<!-- module-1 Сводка -->
<article class="article">
  <h2>Урок 8 из 8. Сводка. 2 мин</h2>
  <p>После изучения этого урока вы можете выполнять следующие задачи:</p>
  <ul>
    <li>Объяснить, что TypeScript является улучшением JavaScript для веб-разработки.</li>
    <li>Выберете редактор TypeScript.</li>
    <li>Установите TypeScript.</li>
    <li>Настроите проект TypeScript в Visual Studio Code.</li>
  </ul>

  <h3>Ресурсы</h3>
  <p>Дополнительные сведения о TypeScript:</p>
  <ul>
    <li><a href="https://www.youtube.com/watch?v=tXK50czRbdA">Секреты TypeScript с Андерсом Хейлсбергом (корпорация Майкрософт)</a>. Создатель TypeScript обсуждает TypeScript 3.4.</li>
    <li><a href="https://www.typescriptlang.org/">Документация по TypeScript и другие ресурсы</a>.</li>
    <li><a href="https://github.com/microsoft/TypeScript">Репозитории TypeScript на GitHub</a>. Участие в сообществе разработчиков открытого кода TypeScript.</li>
    <li><a href="https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html">Руководство по миграции с JavaScript</a>. Дополнительные сведения о переносе существующих проектов JavaScript в TypeScript.</li>
    <li><a href="https://code.visualstudio.com/docs/typescript/typescript-tutorial">Учебник по TypeScript в Visual Studio Code</a>. Дополнительные сведения об использовании TypeScript в Visual Studio Code.</li>
  </ul>
</article>


<!-- module-2 -->
<article class="article">
  <div class="anchor" id="module-2"></div>
  <h2>Модуль 2. Declare Variable Types in TypeScript. Объявление типов переменных в TypeScript. 38 мин</h2>

  <p><a href="https://learn.microsoft.com/api/achievements/share/ru-ru/frontend200tb-0827/8R6RQ83W?sharingId=6364D7D096225EB9">Значек</a></p>

  <p><a href="https://learn.microsoft.com/en-us/training/modules/typescript-declare-variable-types/">Declare variable types in TypeScript (en)</a>
  <br><a href="https://learn.microsoft.com/ru-ru/training/modules/typescript-declare-variable-types/">Объявление типов переменных в TypeScript (ru)</a></p>

  <p>38 мин Модуль 10 единиц(ы)</p>
  <p>JavaScript — язык с динамической типизацией. Это упрощает объявление переменных, но в некоторых случаях может приводить к непредвиденным результатам. Статическая система типов в TypeScript позволяет описывать форму объектов, предоставлять более качественную документацию и проверять правильность работы кода. В TypeScript при объявлении пространств имен, классов, свойств, функций, переменных и других элементов языка с ними связываются типы. Способ определения типа и его сопоставления с элементом языка зависит от характера этого элемента. В этом модуле представлены некоторые из имеющихся типов и показано, как связывать их с переменными. Последующие модули будут посвящены тому, как в интерфейсах, функциях и классах используется статическая типизация.</p>

  <h3>Цели обучения</h3>
  <p>В этом модуле вы научитесь выполнять следующее.</p>
  <ul>
    <li>объяснять преимущества объявления типизированных переменных в TypeScript;</li>
    <li>объявлять переменные с помощью примитивных типов;</li>
    <li>объявлять переменные с помощью типов объектов;</li>
    <li>объявлять переменные с помощью типов объединений и пересечений.</li>
  </ul>

  <h3>Предварительные требования</h3>
  <ul>
    <li>Знакомство с JavaScript.</li>
    <li>Умение объявлять переменные с помощью let и const в JavaScript.</li>
    <li>Базовые познания в TypeScript.</li>
    <li>Установленное программное обеспечение:
      <ul>
        <li>Git</li>
        <li>Visual Studio Code</li>
        <li>Node.js</li>
        <li>TypeScript</li>
      </ul>
    </li>
  </ul>

  <h3>Этот модуль входит в состав указанных схем обучения</h3>
  <ul>
    <li>Создание приложений JavaScript с помощью TypeScript</li>
  </ul>

  <p>Введение 2 мин</p>
  <p>Общие сведения о типах в TypeScript 5 мин</p>
  <p>Примитивные типы в TypeScript 5 мин</p>
  <p>Упражнение. Перечисления 5 мин</p>
  <p>Типы any и unknown в TypeScript 5 мин</p>
  <p>Типы объединений и пересечений в TypeScript 2 мин</p>
  <p>Типы коллекций в TypeScript 5 мин</p>
  <p>Задание. Использование типов в TypeScript 5 мин</p>
  <p>Проверка знаний 2 мин</p>
  <p>Итоги 2 мин</p>
</article>


<!-- module-2 введение -->
<article class="article">
  <h2>Урок 1 из 10. Введение. 2 мин</h2>
  <p>Как динамически типизированный язык JavaScript упрощает объявление переменных, но в некоторых случаях может привести к непредвиденным результатам. Система статического типа в TypeScript позволяет описать форму объекта, предоставить лучшую документацию и разрешить TypeScript проверить правильность работы кода. В TypeScript при объявлении пространств имен, классов, свойств, функций, переменных и других элементов языка с ними связываются типы. Способ определения типа и его сопоставления с элементом языка зависит от характера этого элемента.</p>
  <p>В этом модуле представлены некоторые из имеющихся типов и показано, как связывать их с переменными. Последующие модули будут посвящены тому, как в интерфейсах, функциях и классах используется статическая типизация.</p>

  <h3>Цели обучения</h3>
  <p>По завершении этого модуля вы сможете:</p>
  <ul>
    <li>объяснять преимущества объявления типизированных переменных в TypeScript;</li>
    <li>объявлять переменные с помощью примитивных типов;</li>
    <li>объявлять переменные с помощью типов объектов;</li>
    <li>объявлять переменные с помощью типов объединений и пересечений.</li>
  </ul>

  <h3>Необходимые компоненты</h3>
  <ul>
    <li>Знакомство с JavaScript.</li>
    <li>Умение объявлять переменные с помощью <code class="code-inline">let</code> и <code class="code-inline">const</code> в JavaScript.</li>
    <li>Установленное программное обеспечение:
      <ul>
        <li>Git</li>
        <li>Visual Studio Code</li>
        <li>Node.js</li>
        <li>TypeScript — TypeScript можно установить после установки Node.js, выполнив следующую команду в терминале или окне команд:
          <code>npm install -g typescript</code>
        </li>
      </ul>
    </li>
  </ul>
  <p>Для получения наилучших результатов полностью следуйте инструкциям по настройке окружения и использованию компилятора TypeScript в статье <a href="https://learn.microsoft.com/ru-ru/training/modules/typescript-get-started/">Модуль 01. Начало работы с TypeScript</a>. После настройки окружения можно запустить любые файлы подготовки к заданию или его решения в <a href="https://learn.microsoft.com/ru-ru/training/paths/build-javascript-applications-typescript/">приложении сборки JavaScript</a> с помощью схемы обучения TypeScript.</p>
</article>


<!-- module-2 Общие сведения о типах в TypeScript -->
<article class="article">
  <h2>Урок 2 из 10. Общие сведения о типах в TypeScript. 5 мин</h2>

  <p>Основное преимущество TypeScript заключается в том, что он позволяет добавлять статические типы в код JavaScript. Типы устанавливают статические ограничения на элементы программы, такие как функции, переменные и свойства, благодаря чему компиляторам и средствам разработки проще проводить проверку и оказывать помощь в процессе разработки.</p>
  <p>Система статических типов компиляции TypeScript тесно моделирует динамическую систему типов времени выполнения JavaScript. Система статических типов компиляции позволяет точно выразить связи типов, которые должны существовать при запуске программ. Затем убедитесь, что эти предположения предварительно проверены компилятором TypeScript. Анализ типов TypeScript производится исключительно во время компиляции, поэтому во время выполнения программы дополнительной нагрузки не создается.</p>
  <p>Статические типы также позволяют лучше документировать назначение кода, делая код понятнее для вас и других разработчиков.</p>

  <h3>Объявление переменных let и const</h3>
  <p>В <a href="https://www.ecma-international.org/ecma-262/6.0/">ECMAScript 2015</a> для объявления переменных в JavaScript были добавлены ключевые слова <code class="code-inline">let</code> и <code class="code-inline">const</code>. Это позволило решить некоторые проблемы, связанные с ключевым словом <code class="code-inline">var</code> в предыдущих версиях. Это изменение дает возможность объявлять переменные с областью видимости на уровне блока и запрещает объявлять одну и ту же переменную несколько раз.</p>
  <p>В TypeScript рекомендуется использовать ключевые слова <code class="code-inline">let</code> и <code class="code-inline">const</code> для объявления переменных.</p>
  <p><strong>Примечание.</strong> Разница между ними заключается в том, что объявления let не требуют инициализации, тогда как объявления const всегда инициализируются значением. Кроме того, объявления const нельзя переназначать.</p>

  <h3>Упражнение. Определение типа в TypeScript</h3>
  <p>Типы с переменными можно связывать с помощью явных аннотаций типов или путем неявного определения типа.</p>
  <p>Явные аннотации типов — рекомендуемый, хотя и необязательный метод в TypeScript. Чтобы объявить явный тип, используйте синтаксис <code class="code-inline">variableName: type</code>. <code class="code-inline">let myVariable: number</code> Инструкция объявляет переменную как тип числа без инициализации. Кроме того, можно инициализировать переменную с помощью <code class="code-inline">let myVariable: number = 10</code>.</p>
  <p>Чтобы означать тип переменной с помощью вывода типов, используйте тот же формат, который вы используете в JavaScript. Например, указывает, что переменная имеет тип <code class="code-inline">number</code>, <code class="code-inline">let myVariable = 10</code> так как она инициализирована со значением <code class="code-inline">10</code>.</p>
  <p>Давайте откроем <a href="https://www.typescriptlang.org/play">Playground</a> и посмотрим, как это работает.</p>
  <ol>
    <li>Введите следующие объявления переменных:
      <pre>
let x: number;   //* Explicitly declares x as a number type
let y = 1;       //* Implicitly declares y as a number type
let z;           //* Declares z without initializing it
      </pre>
    </li>
    <li>TypeScript теперь знает, что <code class="code-inline">x</code> имеет тип <code class="code-inline">number</code>. TypeScript также определяет тип <code class="code-inline">y number</code> типа, так как это тип значения, используемого для инициализации. Но что произойдет при попытке присвоить переменной значение другого типа? И что произойдет с переменной z?</li>
    <li>Откройте в Playground вкладку Errors (Ошибки), чтобы можно было отслеживать ошибки.</li>
    <li>Введите <code class="code-inline">x = 1</code>. Это объявление должно работать должным образом без ошибок.</li>
    <li>Введите <code class="code-inline">x = "one"</code>. Как ожидалось, это объявление вызывает ошибку Type "string" не присваивается типу "number", так как статический тип проверка ing не позволяет <code class="code-inline">string</code> назначать переменную.</li>
    <li>Введите <code class="code-inline">y = "one"</code>. Вы увидите, что эта же ошибка возникает, так как TypeScript вычислил, что y имеет тип <code class="code-inline">number</code>.</li>
    <li>Введите имя переменной <code class="code-inline">y</code> с точкой после него и обратите внимание на еще одну особенность. Хотя вы не указали тип переменной <code class="code-inline">y</code> явно, IntelliSense предлагает методы, которые применимы только к типу <code class="code-inline">number</code>.</li>
    <li>Введите <code class="code-inline">z = 1</code> и <code class="code-inline">z = "one"</code>. В TypeScript принимаются оба значения, но почему? Эти объявления работают так же, как и в JavaScript, так как переменная <code class="code-inline">z</code> теперь может принимать любое значение, назначенное ему. TypeScript вычислил тип <code class="code-inline">any</code>, так как вы не назначали <code class="code-inline">z</code> тип или инициализировать его при объявлении. Дополнительные сведения о типе <code class="code-inline">any</code> вы узнаете позже.</li>
  </ol>
  <p>Итак, вы можете неявно определять типы в TypeScript, но зачем? При использовании определения типов вы получаете некоторые преимущества статической проверки типов и технологии IntelliSense и можете постепенно переходить на явные объявления типов в проектах. Однако явные объявления типов позволяют лучше документировать назначение кода и делают его более продуманным.</p>

  <h3>Типы и подтипы в TypeScript</h3>
  <p>Прежде чем углубляться в способы использования типов для объявления переменной, давайте рассмотрим имеющиеся в TypeScript типы и подтипы.</p>

  <h3>Любой тип</h3>
  <p>Все типы в TypeScript являются подтипами одного типа верхнего уровня, называемого any. any — это единственный тип, который может представлять любое значение JavaScript без ограничений. Все остальные типы делятся на примитивные, типы объектов или параметры типов. Они налагают различные статические ограничения на свои значения.</p>

  <h3>Примитивные типы</h3>
  <p>К примитивным типам относятся <code class="code-inline">boolean</code>, <code class="code-inline">number</code>, <code class="code-inline">string</code>, <code class="code-inline">void</code>, <code class="code-inline">null</code> и <code class="code-inline">undefined</code>, а также пользовательские перечисления или типы <code class="code-inline">enum</code>. Тип <code class="code-inline">void</code> нужен лишь для того, чтобы указывать на отсутствие значения, например в функции без возвращаемого значения. Типы <code class="code-inline">null</code> и <code class="code-inline">undefined</code> являются подтипами всех остальных типов. Явно ссылаться на <code class="code-inline">null</code> и <code class="code-inline">undefined</code> типы невозможно. Можно ссылаться только на их значения с помощью литералов <code class="code-inline">null</code> и <code class="code-inline">undefined</code>.</p>

  <h3>Типы объектов и параметры типов</h3>
  <p>Типы объектов — это все классы, интерфейс, массив и литеральные типы (все, что не является примитивным типом).</p>
  <p>Типы классов и интерфейсов вводятся путем объявления классов и интерфейсов, а ссылаться на них следует по имени, присвоенному в объявлении. Типы классов и интерфейсов могут быть универсальными, имеющими один или несколько параметров типа. Эти типы объектов будут рассмотрены подробнее в последующих модулях.</p>
</article>


<!-- module-2 Примитивные типы в TypeScript -->
<article class="article">
  <h2>Урок 3 из 10. Примитивные типы в TypeScript. 5 мин</h2>

  <p>Начнем с самых основных и распространенных типов, которые могут встретиться вам при написании кода на JavaScript или TypeScript. Эти базовые типы позже образуют основные стандартные блоки более сложных типов.</p>

  <h3>Тип Boolean</h3>
  <p>Самым простым типом данных является логический тип boolean, принимающий значение <code class="code-inline">true</code> или <code class="code-inline">false</code>.</p>
  <p>Например:</p>
  <pre>
let flag: boolean;
let yes = true;
let no = false;
  </pre>

  <h3>Типы Number и BigInteger</h3>
  <p>Как и в JavaScript, все числа в TypeScript являются либо значениями с плавающей запятой, либо BigInteger. Числа с плавающей запятой имеют тип <code class="code-inline">number</code>, а BigInteger — тип <code class="code-inline">bigint</code>. Помимо шестнадцатеричных и десятичных литералов, TypeScript поддерживает двоичные и восьмеричные, представленные в ECMAScript 2015.</p>
  <p>Например:</p>
  <pre>
let x: number;
let y = 0;
let z: number = 123.456;
let big: bigint = 100n;
  </pre>

  <h3>Тип строки</h3>
  <p>Ключевое слово <code class="code-inline">string</code> представляет последовательности символов, которые хранятся как единицы кода в Юникоде UTF-16. Как и в JavaScript, в TypeScript строковые данные заключаются в двойные кавычки (<code class="code-inline">"</code>) или одинарные кавычки (<code class="code-inline">'</code>).</p>
  <p>Некоторые примеры:</p>
  <pre>
let s: string;
let empty = "";
let abc = 'abc';
  </pre>
  <p>В TypeScript можно также использовать шаблонные строки, которые могут охватывать несколько строк и содержать внедренные выражения. Эти строки окружены символом backtick/backquote ('), а внедренные выражения имеют форму <code class="code-inline">${ expr }</code>.</p>
  <p>Например:</p>
  <pre>
let firstName: string = "Mateo";
let sentence: string = `My name is ${firstName}.
    I am new to TypeScript.`;
console.log(sentence);
  </pre>
  <p>Результат выполнения этого примера:</p>
  <pre>
My name is Mateo.
    I am new to TypeScript.
  </pre>

  <h3>Типы void, null и undefined</h3>
  <p>В JavaScript и TypeScript есть два примитивных значения, которые указывают на отсутствующее или неинициализированное значение: <code class="code-inline">null</code> и <code class="code-inline">undefined</code>. Эти типы наиболее полезны в контексте функций, поэтому мы рассмотрим их более подробно в одном из последующих модулей.</p>
</article>


<!-- module-2 Упражнение. Перечисления -->
<article class="article">
  <h2>Урок 4 из 10. Упражнение. Перечисления. 5 мин</h2>

  <p>Давайте рассмотрим различные типы данных TypeScript, доступные и эффекты, которые они имеют в нашем коде.</p>

  <h3>Тип перечисления</h3>
  <p>Полезным дополнением к стандартному набору типов данных из JavaScript является тип перечисления или <code class="code-inline">enum</code>.</p>
  <p>Перечисления упрощают работу с наборами связанных констант. Символьное enum имя для набора значений. Перечисления представляются как типы данных, и их можно использовать для создания наборов констант, которые затем применяются в переменных и свойствах.</p>
  <p>Если подпрограмма принимает ограниченный набор переменных, рекомендуется использовать перечисление. Перечисления делают код более понятным и удобочитаемым, особенно при использовании осмысленных имен.</p>
  <p>Использование перечислений:</p>
  <ul>
    <li>помогает сократить количество ошибок, вызванных перестановкой или опечатками;</li>
    <li>упрощает изменение значений в будущем;</li>
    <li>Упрощает чтение кода, что означает, что ошибки будут ползать в него.</li>
    <li>обеспечивает прямую совместимость. При перечислении код, скорее всего, завершится ошибкой, если кто-то изменяет значения, соответствующие именам элементов в будущем.</li>
  </ul>

  <h3>Создание перечисления</h3>
  <p>Перечисления позволяют указать список доступных значений. Они особенно полезны, если у вас есть набор значений, которые может принимать определенный тип переменной. Предположим, что у вас есть поле во внешней базе данных с именем ContractStatus, которая содержит номера 1, 2 или 3, которые представляют следующие состояния контактов: Постоянный, Temp и Ученик. Мы создадим перечисление с этими значениями и рассмотрим поддержку TypeScript.</p>
  <ol>
    <li>Откройте <a href="https://www.typescriptlang.org/play">тестовую площадку</a> и удалите существующий код.</li>
    <li>Введите следующий код, чтобы создать сценарий <code class="code-inline">enum</code> :
      <pre>
enum ContractStatus {
     Permanent,
     Temp,
     Apprentice
}
      </pre>
    </li>
    <li>Теперь объявите для нового сотрудника переменную с именем <code class="code-inline">employeeStatus</code> типа <code class="code-inline">ContractStatus</code> и присвойте ей значение <code class="code-inline">"Temp"</code>. Выведите результат в консоль.
      <pre>
let employeeStatus: ContractStatus = ContractStatus.Temp;
console.log(employeeStatus);
      </pre>
    </li>
    <li>Выберите Выполнить. Обратите внимание на значение, отображаемое в окне Log (Журнал). Какое значение возвращается?</li>
    <li>По умолчанию значения <code class="code-inline">enum</code> начинаются с нуля, поэтому значение <code class="code-inline">Permanent</code> равно 0, <code class="code-inline">Temp</code> равно 1, а <code class="code-inline">Apprentice</code> равно 2. Если нужно, чтобы значения начинались с другого числа (в данном случае 1), укажите это в объявлении <code class="code-inline">enum</code>. Чтобы значения <code class="code-inline">enum</code> начинались с 1, внесите указанные ниже изменения.
      <pre>
enum ContractStatus {
     Permanent = 1,
     Temp,
     Apprentice
}
      </pre>
    </li>
    <li>Повторно запустите код, выбрав Run (Выполнить). Обратите внимание: теперь отображается значение 2.</li>
    <li>Чтобы отобразить имя, связанное со значением перечисления, можно использовать предоставленный индексатор. Добавьте следующую строку в конце кода:
      <code>console.log(ContractStatus[employeeStatus]);</code>
    </li>
    <li>Выполните код. Обратите внимание, что отображается значение Temp ( имя, связанное со значением перечисления 2).</li>
  </ol>
</article>


<!-- module-2 Типы any и unknown в TypeScript -->
<article class="article">
  <h2>Урок 5 из 10. Типы any и unknown в TypeScript. 5 мин</h2>

  <p>Иногда вам потребуется работать со значениями, неизвестными вам во время разработки кода. В таких случаях можно использовать типы <code class="code-inline">any</code> и <code class="code-inline">unknown</code> и контролировать возможные действия с переданными значениями с помощью утверждения типа и условий типа.</p>

  <h3>Любой тип</h3>
  <p><code class="code-inline">any</code> — это единственный тип, который может представлять любое значение JavaScript без ограничений. Этот тип может быть полезен при ожидании значения из сторонней библиотеки или входных данных пользователей, где это значение является динамическим, так как <code class="code-inline">any</code> тип позволит переназначить различные типы значений. Как упоминалось ранее, тип <code class="code-inline">any</code> позволяет постепенно переводить код JavaScript на использование статических типов TypeScript.</p>
  <p>В следующем примере объявляется переменная типа <code class="code-inline">any</code>, и ей присваиваются значения:</p>
  <pre>
let randomValue: any = 10;
randomValue = 'Mateo';   // OK
randomValue = true;      // OK
  </pre>
  <p>При компиляции этого примера ошибка не возникает, так как тип <code class="code-inline">any</code> охватывает значения всех возможных типов. Проверка типа для <code class="code-inline">any</code> не предусмотрена, и вы не обязаны проводить никаких проверок перед вызовом его свойств, их конструированием или обращением к ним.</p>
  <p>Использование типа <code class="code-inline">any</code> в этом примере позволяет вызывать:</p>
  <ul>
    <li>свойство, которого нет у типа;</li>
    <li>randomValue как функцию;</li>
    <li>метод, который применяется только к типу string.</li>
  </ul>
  <p>Поскольку <code class="code-inline">randomValue</code> регистрируется как <code class="code-inline">any</code>, все приведенные ниже примеры являются допустимыми TypeScript и не приводят к ошибке времени компиляции. Однако ошибки среды выполнения могут возникать в зависимости от фактического типа данных переменной. В приведенном выше примере, где для <code class="code-inline">randomValue</code> задано логическое значение, следующие строки кода будут вызывать проблемы во время выполнения:</p>
  <pre>
console.log(randomValue.name);  // Logs "undefined" to the console
randomValue();                  // Returns "randomValue is not a function" error
randomValue.toUpperCase();      // Returns "randomValue is not a function" error
  </pre>
  <p><strong>Важно!</strong> Помните, что все удобство использования <code class="code-inline">any</code> достигается за счет потери безопасности типов. Безопасность типов — одна из основных причин использовать TypeScript. <code class="code-inline">any</code> следует использовать, только когда это действительно необходимо.</p>

  <h3>Тип unknown</h3>
  <p>Хотя тип <code class="code-inline">any</code> очень гибкий, он может вызывать непредвиденные ошибки. Чтобы устранить эту проблему, TypeScript представила <code class="code-inline">unknown</code> тип.</p>
  <p>Тип <code class="code-inline">unknown</code> похож на тип <code class="code-inline">any</code> тем, что типу <code class="code-inline">unknown</code> можно присваивать любое значение. Однако вы не можете получить доступ к свойствам типа <code class="code-inline">unknown</code>, а также вызывать или создавать их.</p>
  <p>В этом примере тип <code class="code-inline">any</code> из предыдущего примера заменяется на <code class="code-inline">unknown</code>. Теперь происходят ошибки проверки типов, что не позволяет скомпилировать код, пока они не будут устранены.</p>
  <pre>
let randomValue: unknown = 10;
randomValue = true;
randomValue = 'Mateo';

console.log(randomValue.name);  // Error: Object is of type unknown
randomValue();                  // Error: Object is of type unknown
randomValue.toUpperCase();      // Error: Object is of type unknown
  </pre>
  <p><strong>Примечание.</strong> Основное различие между any и unknown заключается в том, что вы не можете взаимодействовать с переменной типа unknown. Это вызывает ошибку компилятора. any обходит любые проверки во время компиляции. Объект вычисляется во время выполнения. Если метод или свойство существует, все будет работать нормально.</p>

  <h3>Утверждение типа</h3>
  <p>Если необходимо рассматривать переменную как другой тип данных, можно использовать утверждение типа. Утверждение типа сообщает TypeScript, что вы выполнили все специальные проверка, необходимые перед вызовом инструкции. Это как бы говорит компилятору: "доверься мне, я знаю, что делаю". Утверждение типа похоже на приведение типа в других языках, но не предусматривает специальной проверки или реструктуризации данных. Он не имеет эффекта среды выполнения и используется исключительно компилятором.</p>
  <p>Утверждения типов имеют две формы. Первая из них — синтаксис <code class="code-inline">as</code>:</p>
  <code>(randomValue as string).toUpperCase();</code>
  <p>Вторая — синтаксис с угловыми скобками:</p>
  <code>(&lt;string&gt;randomValue).toUpperCase();</code>
  <p><strong>Примечание.</strong> as — предпочтительный вариант синтаксиса. В некоторых ситуациях, например в JSX, использование &lt; &gt; для преобразования типов в TypeScript может приводить к путанице.</p>
  <p>В приведенном ниже примере выполняется проверка того, что переменная <code class="code-inline">randomValue</code> имеет тип <code class="code-inline">string</code>, перед использованием утверждения типа для вызова метода <code class="code-inline">toUpperCase</code>.</p>
  <pre>
let randomValue: unknown = 10;

randomValue = true;
randomValue = 'Mateo';

if (typeof randomValue === "string") {
    console.log((randomValue as string).toUpperCase());    //* Returns MATEO to the console.
} else {
    console.log("Error - A string was expected here.");    //* Returns an error message.
}
  </pre>
  <p>В TypeScript теперь предполагается, что вы выполнили необходимую проверку. Утверждение типа говорит о том, что переменную <code class="code-inline">randomValue</code> следует рассматривать как <code class="code-inline">string</code>, что позволяет применить метод <code class="code-inline">toUpperCase</code>.</p>

  <h3>Условия типов</h3>
  <p>В предыдущем примере было продемонстрировано использование <code class="code-inline">typeof</code> в блоке <code class="code-inline">if</code> для проверки типа выражения во время выполнения. Этот условный тест называется типозащищенным.</p>
  <p>Возможно, вы знакомы с использованием <code class="code-inline">typeof</code> и <code class="code-inline">instanceof</code> в JavaScript для проверки таких условий. TypeScript поддерживает эти условия и при их использовании в блоке <code class="code-inline">if</code> изменяет определение типа соответствующим образом.</p>
  <p>Чтобы узнать тип переменной, можно использовать приведенные ниже условия.</p>
  <pre>
Тип	       Предикат
string	   typeof s === "string"
number	   typeof n === "number"
boolean	   typeof b === "boolean"
undefined	 typeof undefined === "undefined"
function	 typeof f === "function"
array	     Array.isArray(a)
  </pre>
</article>


<!-- module-2 Типы объединений и пересечений в TypeScript -->
<article class="article">
  <h2>Урок 6 из 10. Типы объединений и пересечений в TypeScript. 2 мин</h2>

  <p>В TypeScript есть и более развитые возможности для объявления типов. Типы объединения и пересечения помогают справиться с ситуациями, когда тип состоит из двух или более возможных типов. Литеральные типы позволяют ограничить значения, назначенные типу, узким списком параметров.</p>

  <h3>Типы объединения</h3>
  <p>Тип объединения описывает значение, которое может иметь один из нескольких типов. Эта гибкость может оказаться полезной, если значение не входит в контроль (например, значения из библиотеки, API или пользовательского ввода).</p>
  <p>Тип <code class="code-inline">any</code> также может принимать различные типы, так зачем использовать объединение? Тип объединения ограничивает назначение значений указанным типам в союзе, в то время как <code class="code-inline">any</code> тип не имеет ограничений. Еще одна причина — поддержка технологии IntelliSense.</p>
  <p>Для разделения типов в объединении используется вертикальная черта (<code class="code-inline">|</code>). В следующем примере <code class="code-inline">multiType</code> может иметь тип <code class="code-inline">number</code> или <code class="code-inline">boolean</code>:</p>
  <pre>
let multiType: number | boolean;
multiType = 20;         //* Valid
multiType = true;       //* Valid
multiType = "twenty";   //* Invalid
  </pre>
  <p>С помощью условий типов можно легко работать с переменной типа объединения. В этом примере функция <code class="code-inline">add</code> принимает два значения, которые могут иметь тип <code class="code-inline">number</code> или <code class="code-inline">string</code>. Если оба значения имеют числовые типы, они складываются. Если оба строкового типа, они сцепляются. В противном случае происходит ошибка.</p>
  <pre>
function add(x: number | string, y: number | string) {
    if (typeof x === 'number' && typeof y === 'number') {
        return x + y;
    }
    if (typeof x === 'string' && typeof y === 'string') {
        return x.concat(y);
    }
    throw new Error('Parameters must be numbers or strings');
}
console.log(add('one', 'two'));  //* Returns "onetwo"
console.log(add(1, 2));          //* Returns 3
console.log(add('one', 2));      //* Returns error
  </pre>

  <h3>Типы пересечений</h3>
  <p>Типы пересечений тесно связаны с типами объединения, но они используются по-разному. Тип пересечения служит для объединения двух или нескольких типов, в результате чего получается тип, имеющий все свойства исходных типов. Пересечение позволяет объединить существующие типы, чтобы получить один тип с всеми нужными функциями.</p>
  <p>В пересечении типы отделяются друг от друга амперсандом (<code class="code-inline">&</code>).</p>
  <p>Типы пересечения чаще всего используются с интерфейсами. В приведенном ниже примере определяются два интерфейса, <code class="code-inline">Employee</code> и <code class="code-inline">Manager</code>, а затем создается тип пересечения <code class="code-inline">ManagementEmployee</code>, объединяющий в себе свойства обоих интерфейсов.</p>
  <pre>
interface Employee {
  employeeID: number;
  age: number;
}
interface Manager {
  stockPlan: boolean;
}
type ManagementEmployee = Employee & Manager;
let newManager: ManagementEmployee = {
    employeeID: 12345,
    age: 34,
    stockPlan: true
};
  </pre>
  <p>Дополнительные сведения об интерфейсах см. в модуле <a href="https://learn.microsoft.com/ru-ru/training/modules/typescript-implement-interfaces/">Реализация интерфейсов в TypeScript</a>.</p>

  <h3>Литеральные типы</h3>
  <p>Литерал — это более конкретный подтип общего типа. Это означает, что <code class="code-inline">"Hello World"</code> это , <code class="code-inline">string</code> но <code class="code-inline">string</code> не <code class="code-inline">"Hello World"</code> внутри системы типов.</p>
  <p>В TypeScript есть три набора литеральных типов: <code class="code-inline">string</code>, <code class="code-inline">number</code> и <code class="code-inline">boolean</code>. С помощью литерального типа можно указать точное значение, которое должно иметь строковая, числовая или логическая переменная (например, "да", "нет" или "возможно").</p>

  <h3>Что такое сужение литерала?</h3>
  <p>При объявлении переменной с помощью <code class="code-inline">var</code> или <code class="code-inline">let</code> в TypeScript компилятор сообщает, что эта переменная изменит его содержимое. При объявлении с помощью let переменная типизируется (например, как <code class="code-inline">string</code>), поэтому она может принимать бесконечное множество потенциальных значений.</p>
  <p>В отличие от этого, при объявлении переменной с помощью <code class="code-inline">const</code> вы указываете TypeScript, что объект никогда не изменится. То есть объявление <code class="code-inline">const</code> задает фиксированное значение (например, "Hello World").</p>
  <p>Переход от бесконечного множества потенциальных вариантов к их конечному числу называется сужением.</p>

  <h3>Определение литеральных типов</h3>
  <p>Литеральные типы представляются как объекты, массивы, функции или конструкторы и служат для создания новых типов на основе существующих.</p>
  <p>Лучше всего продемонстрировать использование литеральных типов на примере. Это определение создает литеральный тип с именем <code class="code-inline">testResult</code>, который может содержать одно из трех значений <code class="code-inline">string</code>:</p>
  <pre>
type testResult = "pass" | "fail" | "incomplete";
let myResult: testResult;
myResult = "incomplete";    //* Valid
myResult = "pass";          //* Valid
myResult = "failure";       //* Invalid
  </pre>
  <p>При задании значения переменной <code class="code-inline">myResult</code> <code class="code-inline">"incomplete"</code> и <code class="code-inline">"pass"</code> допустимых записей, хотя <code class="code-inline">"failure"</code> и не потому, что он не является одним из элементов в <code class="code-inline">testResult</code> определении типа.</p>
  <p>TypeScript также имеет числовые литеральные типы, которые действуют так же, как строковые литералы. Например:</p>
  <pre>
type dice = 1 | 2 | 3 | 4 | 5 | 6;
let diceRoll: dice;
diceRoll = 1;    //* Valid
diceRoll = 2;    //* Valid
diceRoll = 7;    //* Invalid
  </pre>
  <p>При определении литеральных типов или любых сочетаний типов можно также использовать значения <code class="code-inline">boolean</code>.</p>
</article>


<!-- module-2 Типы коллекций в TypeScript -->
<article class="article">
  <h2>Урок 7 из 10. Типы коллекций в TypeScript. 5 мин</h2>

  <p>Типы объектов — это все классы, интерфейс, массив и литеральные типы (все, что не является примитивным типом). Теперь рассмотрим типы массивов и кортежей.</p>

  <h3>Массивы</h3>
  <p>В TypeScript, как и в JavaScript, можно работать с массивами. Они записываются одним из двух способов. В первом случае указывается тип элементов, за которым стоят квадратные скобки (<code class="code-inline">[ ]</code>) для обозначения массива элементов этого типа:</p>
  <code>let list: number[] = [1, 2, 3];</code>
  <p>Во втором случае используется универсальный тип <code class="code-inline">Array</code> и синтаксис <code class="code-inline">Array&lt;type&gt;</code>:</p>
  <code>let list: Array<number> = [1, 2, 3];</code>
  <p>Нет никакого преимущества использовать один над другим, поэтому вам нужно решить, какой синтаксис следует использовать.</p>

  <h3>Кортежи</h3>
  <p>Массивы со значениями одного типа полезны, но иногда требуется массив со смешанными значениями. Для этого в TypeScript есть тип кортежа. Чтобы объявить кортеж, используйте синтаксис <code class="code-inline">variableName: [type, type, ...]</code>.</p>

  <h3>Упражнение. Кортежи</h3>
  <ol>
    <li>Откройте <a href="https://www.typescriptlang.org/play">тестовую площадку</a> и удалите существующий код.</li>
    <li>Введите следующий код, чтобы создать кортеж с элементами <code class="code-inline">string</code> и <code class="code-inline">number</code>:
      <code>let person1: [string, number] = ['Marcia', 35];</code>
    </li>
    <li>Попробуйте добавить еще один элемент в массив. Например:
      <code>let person1: [string, number] = ['Marcia', 35, true];</code>
    </li>
    <li>Обратите внимание, что возникает ошибка, так как элементы кортежа <code class="code-inline">array</code> исправлены. Кортеж <code class="code-inline">person1</code> — это массив, содержащий ровно одно значение <code class="code-inline">string</code> и ровно одно значение <code class="code-inline">number</code>.</li>
    <li>Попробуйте поменять элементы в массиве местами. Например:
      <code>let person1: [string, number] = [35, 'Marcia'];</code>
    </li>
    <li>Вы получите сообщение об ошибке, указывающее, что порядок значений должен соответствовать порядку типов.</li>
  </ol>
</article>


<!-- module-2 Задание. Использование типов в TypeScript -->
<article class="article">
  <h2>Урок 8 из 10. Задание. Использование типов в TypeScript. 5 мин</h2>

  <p>В этой лаборатории вы напишете JavaScript в каждом из следующих упражнений в TypeScript, строго введя каждую из переменных.</p>

  <h3>Упражнение 1. Изменение существующего кода JavaScript для строгой типизации переменных</h3>
  <ol>
    <li>Клонируйте начальный репозиторий, введя следующую команду в командной строке.
      <pre>
git clone https://github.com/MicrosoftDocs/mslearn-typescript
cd mslearn-typescript/code/module-02/m02-start
code .
      </pre>
    </li>
    <li>Откройте файл module02.ts и найдите раздел Exercise 1.</li>
    <li>Измените код, добавив типы в объявления переменных. По завершении скомпилированный код JavaScript должен выглядеть так же, как в исходном примере.
      <pre>
/*  EXERCISE 1
    TODO: Modify the code to add types to the variable declarations.
    The resulting JavaScript should look the same as the original example when you're done. */

let firstName;
let lastName;
let fullName;
let age;
let ukCitizen;

firstName = 'Rebecca';
lastName = 'Smith';
age = 42;
ukCitizen = false;
fullName = firstName + " " + lastName;

if (ukCitizen) {
    console.log("My name is " + fullName + ", I'm " + age + ", and I'm a citizen of the United Kingdom.");
} else {
    console.log("My name is " + fullName + ", I'm " + age + ", and I'm not a citizen of the United Kingdom.");
}
      </pre>
    </li>
  </ol>

  <h3>Упражнение 2. Изменение существующего кода JavaScript для получения нужных результатов с помощью строго типизированных переменных</h3>
  <ol>
    <li>Найдите раздел Exercise 2 в файле module02.ts.</li>
    <li>С помощью типов можно получать нужные результаты операций. Запустите код как есть, а затем измените его так, чтобы переменные в нем были строго типизированными.</li>
    <li>Устраните все обнаруженные ошибки, чтобы в переменную a возвращался результат <code class="code-inline">12</code>.
    <pre>
/* EXERCISE 2
   TODO: Run the code as is and then modify it to have strongly typed variables.
   Then, address any errors you find so that the result returned to a is 12. */

let x;
let y;
let a;

x = 'five';
y = 7;
a = x + y;

console.log(a);
    </pre></li>
  </ol>

  <h3>Упражнение 3. Реализация типа перечисления</h3>
  <ol>
    <li>Найдите раздел Exercise 3 в файле module02.ts.</li>
    <li>Реализуйте тип <code class="code-inline">enum</code> с именем <code class="code-inline">Season</code>, который представляет константы <code class="code-inline">"Fall", "Winter", "Spring" и "Summer".</code></li>
    <li>Обновите функцию, чтобы можно было передать время года, обратившись к элементу <code class="code-inline">enum</code>, например <code class="code-inline">Season.Fall</code> вместо литеральной строки <code class="code-inline">"Fall"</code>.
      <pre>
/* EXERCISE 3
   TODO: In the following code, implement an enum type called Season that represents
   the constants "Fall", "Winter", "Spring", and "Summer". Then, update the function so
   you can pass in the season by referencing an item in the enum, for example
   Season.Fall, instead of the literal string "Fall". */

function whichMonths(season) {
    let monthsInSeason: string;
    switch (season) {
        case "Fall":
            monthsInSeason = "September to November";
            break;
        case "Winter":
            monthsInSeason = "December to February";
            break;
        case "Spring":
            monthsInSeason = "March to May";
            break;
        case "Summer":
            monthsInSeason = "June to August";
    }
    return monthsInSeason;
}

console.log(whichMonths("Fall"));
      </pre>
    </li>
  </ol>

  <h3>Упражнение 4. Объявление типа массива</h3>
  <ol>
    <li>Найдите раздел Exercise 4 в файле module02.ts.</li>
    <li>Объявите массив как тип, который должны иметь элементы в нем.
      <pre>
/* EXERCISE 4
   TODO: Declare the array as the type to match the type of the items in the array. */

let randomNumbers;
let nextNumber;
for (let i = 0; i &lt; 10; i++) {
    nextNumber = Math.floor(Math.random() * (100 - 1)) + 1;
    randomNumbers.push(nextNumber);
}

console.log(randomNumbers);
      </pre>
    </li>
  </ol>

  <h3>Попробуйте свои силы!</h3>
  <p>Чтобы усложнить задачу, возьмите существующий код JavaScript, написанный вами или найденный в Интернете, и перепишите его, добавив базовые типы TypeScript. Вы можете скопировать код JavaScript и вставить его в Playground, а затем отредактировать, или использовать другой редактор, например Visual Studio Code.</p>

  <h3>Решение задания</h3>
  <p>Просмотрите окончательную версию кода, введя следующую команду в командной строке.</p>
  <pre>
cd ../m02-end
code .
  </pre>
  <p>Откройте файл module02.ts, чтобы просмотреть решение этого задания.</p>
</article>


<!-- module-2 Проверка знаний -->
<article class="article">
  <h2>Урок 9 из 10. Проверка знаний. 2 мин</h2>

  <p>Выберите наилучший ответ на каждый из вопросов ниже. Затем нажмите кнопку Проверьте свои ответы.</p>
  <ol>
    <li>1. К какой категории подтипов any относятся типы boolean, number, string и enum?
      <ul>
        <li>Параметры типа.</li>
        <li>Типы объектов.</li>
        <li>Примитивные типы.</li>
      </ul>
    </li>
    <li>2. Какие из следующих типов являются примерами типов объектов?
      <ul>
        <li>Array.</li>
        <li>void.</li>
        <li>Параметры типа.</li>
      </ul>
    </li>
    <li>3. В чем основное различие между типами any и unknown?
      <ul>
        <li>Типу unknown можно присвоить любое значение, а у типа any есть ряд ограничений.</li>
        <li>К свойствам типа unknown можно обращаться, а к свойствам типа any нет.</li>
        <li>К свойствам типа any можно обращаться, а к свойствам типа unknown нет.</li>
      </ul>
    </li>
    <li>4. Как называется функция в TypeScript, сообщающая компилятору: "Я знаю, что делаю"?
      <ul>
        <li>Сужение литерала.</li>
        <li>Утверждение типа.</li>
        <li>Условие типа.</li>
      </ul>
    </li>
    <li>5. Что такое кортеж?
      <ul>
        <li>Массив с бесконечным числом элементов одного типа.</li>
        <li>Массив с определенным числом элементов одного типа.</li>
        <li>Массив с определенным числом элементов одного или нескольких типов.</li>
      </ul>
    </li>
  </ol>
</article>


<!-- module-2 Сводка -->
<article class="article">
  <h2>Урок 10 из 10. Сводка. 2 мин</h2>
  <p>После изучения этого урока вы можете выполнять следующие задачи:</p>
  <ul>
    <li>объяснять преимущества объявления типизированных переменных в TypeScript;</li>
    <li>объявлять переменные с помощью примитивных типов;</li>
    <li>объявлять переменные с помощью типов объектов;</li>
    <li>объявлять переменные с помощью типов объединений и пересечений.</li>
  </ul>

  <h3>Ресурсы</h3>
  <p>Воспользуйтесь этими ресурсами, чтобы узнать больше.</p>
  <ul>
    <li>Чтобы узнать больше о примитивных типах и типе массива, обратитесь к <a href="https://www.typescriptlang.org/docs/handbook/basic-types.html">руководству по основным типам TypeScript.</a></li>
    <li>Чтобы узнать больше о типах перечислений, обратитесь к <a href="https://www.typescriptlang.org/docs/handbook/enums.html">руководству по перечислениям в TypeScript.</a></li>
    <li>Чтобы узнать больше об условиях типов, обратитесь к <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html">справочному руководству по расширенным типам в TypeScript.</a></li>
    <li>Чтобы узнать больше о литеральных типах, обратитесь к <a href="https://www.typescriptlang.org/docs/handbook/literal-types.html">руководству по литеральным типам в TypeScript.</a></li>
    <li>Чтобы узнать больше о типах объединений и пересечений, обратитесь к <a href="https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html">руководству по этим расширенным типам в TypeScript.</a></li>
  </ul>
</article>


<!-- module-3 -->
<article class="article">
  <div class="anchor" id="module-3"></div>
  <h2>Модуль 3. Declare Variable Types in TypeScript. Реализация интерфейсов в TypeScript. 46 мин</h2>

  <p><a href="https://learn.microsoft.com/api/achievements/share/ru-ru/frontend200tb-0827/FZUET2HX?sharingId=6364D7D096225EB9">Значек</a></p>

  <p><a href="https://learn.microsoft.com/en-us/training/modules/typescript-implement-interfaces/">Implement interfaces in TypeScript (en)</a>
  <br><a href="https://learn.microsoft.com/ru-ru/training/modules/typescript-implement-interfaces/">Реализация интерфейсов в TypeScript (ru)</a></p>

  <p>46 мин Модуль 8 единиц(ы)</p>
  <p>JavaScript не поддерживает интерфейсы, поэтому, если вы разработчик JavaScript, у вас может не быть опыта работы с ними. В TypeScript интерфейсы можно использовать так же, как в традиционном объектно-ориентированном программировании. Можно также использовать интерфейсы для определения типов объектов. Как раз об этом мы и будем говорить в этом модуле.</p>

  <h3>Цели обучения</h3>
  <p>В этом модуле вы научитесь выполнять следующее.</p>
  <ul>
    <li>Объяснение причин использования интерфейса в TypeScript.</li>
    <li>Объявление интерфейса и создание его экземпляра.</li>
    <li>Расширение интерфейса.</li>
    <li>Объявление интерфейса с пользовательскими типами массивов.</li>
  </ul>

  <h3>Предварительные требования</h3>
  <ul>
    <li>Знание TypeScript.</li>
    <li>Опыт работы с JavaScript</li>
    <li>Опыт работы с функциями и массивами в JavaScript</li>
    <li>Установленное программное обеспечение:
      <ul>
        <li>Git</li>
        <li>Visual Studio Code</li>
        <li>Node.js</li>
        <li>TypeScript</li>
      </ul>
    </li>
  </ul>

  <h3>Этот модуль входит в состав указанных схем обучения</h3>
  <p>Создание приложений JavaScript с помощью TypeScript</p>
  <p>Введение 2 мин</p>
  <p>Общие сведения об интерфейсах в TypeScript 5 мин</p>
  <p>Упражнение. Объявление и создание экземпляра интерфейса в TypeScript 5 мин</p>
  <p>Упражнение. Расширение интерфейса в TypeScript 5 мин</p>
  <p>Другие способы использования интерфейсов в Typescript 5 мин</p>
  <p>Задание. Использование интерфейсов в TypeScript 20 мин</p>
  <p>Проверка знаний 2 мин</p>
  <p>Сводка 2 мин</p>
</article>


<!-- module-3 Введение -->
<article class="article">
  <h2>Урок 1 из 8. Введение. 2 мин</h2>

  <p>JavaScript не поддерживает интерфейсы, поэтому, если вы разработчик JavaScript, у вас может не быть опыта работы с ними. В TypeScript интерфейсы можно использовать так же, как в традиционном объектно-ориентированном программировании. Можно также использовать интерфейсы для определения типов объектов. Как раз об этом мы и будем говорить в этом модуле.</p>

  <h3>Цели обучения</h3>
  <p>По завершении этого модуля вы сможете:</p>
  <ul>
    <li>Объяснение причин использования интерфейса в TypeScript.</li>
    <li>Объявление интерфейса и создание его экземпляра.</li>
    <li>Расширение интерфейса.</li>
    <li>Объявление интерфейса с пользовательскими типами массивов.</li>
  </ul>

  <h3>Необходимые компоненты</h3>
  <ul>
    <li>Знание TypeScript</li>
    <li>Знакомство с JavaScript.</li>
    <li>Опыт работы с функциями и массивами в JavaScript</li>
    <li>Установленное программное обеспечение:
      <ul>
        <li>Git</li>
        <li>Visual Studio Code</li>
        <li>Node.js</li>
        <li>TypeScript. TypeScript можно установить после установки Node.js и выполнения указанной ниже команды в терминале или командном окне.
          <code>npm install -g typescript</code>
        </li>
      </ul>
    </li>
  </ul>
  <p>Для получения наилучших результатов полностью следуйте инструкциям по настройке окружения и использованию компилятора TypeScript в статье <a href="https://learn.microsoft.com/ru-ru/training/modules/typescript-get-started/">Модуль 01. Начало работы с TypeScript</a>. После настройки окружения можно запустить любые файлы подготовки к заданию или его решения в <a href="https://learn.microsoft.com/ru-ru/training/paths/build-javascript-applications-typescript/">приложении сборки JavaScript</a> с помощью схемы обучения TypeScript.</p>
</article>


<!-- module-3 Общие сведения об интерфейсах в TypeScript -->
<article class="article">
  <h2>Урок 2 из 8. Общие сведения об интерфейсах в TypeScript. 5 мин</h2>

  <p>Одним из основных принципов TypeScript является тот факт, что проверка типов нацелена на форму значений. Иногда это называется неявной типизацией или структурной подтипизацией. В TypeScript интерфейсы выполняют именование этих типов и являются эффективным способом определения "контракта кода" в коде, а также контрактов с кодом за пределами проекта.</p>
  <p>Начнем с обзора интерфейсов: что это такое и как их можно использовать в коде TypeScript.</p>

  <h3>Что такое интерфейс?</h3>
  <p>Интерфейсы можно использовать для описания объекта, именования и параметризации типов объектов, а также для составления существующих типов именованных объектов в новые.</p>
  <p>Этот простой интерфейс определяет два свойства и метод объекта <code class="code-inline">Employee</code>.</p>
  <pre>
interface Employee {
    firstName: string;
    lastName: string;
    fullName(): string;
}
  </pre>
  <p>Обратите внимание, что интерфейс не инициализирует и не реализует свойства, объявленные внутри него. Это обусловлено тем, что единственным заданием интерфейса является описание типа. Он определяет, что требует контракт кода, а переменная, функция или класс, реализующие интерфейс, удовлетворяют контракту, предоставляя необходимые сведения о реализации.</p>
  <p>После определения интерфейса его можно использовать как тип и получить все преимущества проверки типов и IntelliSense.</p>
  <p>В этом примере интерфейс реализуется путем объявления переменной типа <code class="code-inline">Employee</code>. Он выполняет контракт, передавая значения для свойств <code class="code-inline">firstName</code> и <code class="code-inline">lastName</code> и указывая, что метод <code class="code-inline">fullName</code> должен объединять свойства <code class="code-inline">firstName</code> и <code class="code-inline">lastName</code> и вернуть результат.</p>
  <pre>
let employee: Employee = {
    firstName : "Emil",
    lastName: "Andersson",
    fullName(): string {
        return this.firstName + " " + this.lastName;
    }
}

employee.firstName = 10;  //* Error - Type 'number' is not assignable to type 'string'
  </pre>
  <p>Проверка типа гарантирует, что число 10 не может быть назначено employee.firstName, так как ожидается string.</p>
  <p>Поскольку TypeScript имеет систему структурных типов, тип интерфейса с определенным набором элементов считается идентичным другому типу интерфейса или литерала типа объекта с таким же набором элементов, и один можно заменить на другой. Если интерфейс и класс реализуют одну и ту же структуру, они взаимозаменяемы. Пример см. в разделе Структурная типизация на тестовой площадке.</p>
  <p>Интерфейсы не имеют представления во время выполнения; они существуют только во время компиляции. Интерфейсы особенно полезны для документирования и проверки требуемой формы свойств, объектов, передаваемых в качестве параметров, и объектов, возвращаемых функциями. Это позволяет перехватывать ошибки и гарантировать передачу правильных параметров во время компиляции, а не ожидать их обнаружения в среде выполнения.</p>

  <h3>Причины использования интерфейса в TypeScript</h3>
  <p>Интерфейсы часто являются ключевой точкой контакта между любыми двумя частями кода TypeScript, особенно при работе с существующим кодом JavaScript или встроенными объектами JavaScript.</p>
  <p>Интерфейс можно использовать в следующих целях:</p>
  <ul>
    <li>Создание сокращенных имен для часто используемых типов. При использовании даже простого интерфейса, подобного описанному в предыдущем примере, вы по-прежнему получаете преимущества IntelliSense и проверки типов.</li>
    <li>Согласованность дисков в наборе объектов, так как каждый объект, реализующий интерфейс, работает с теми же определениями типов. Это может быть полезно при работе с группой разработчиков и при необходимости обеспечит передачу правильных значений в свойства, конструкторы или функции. Например, объекты, реализующие интерфейс, должны реализовать все необходимые члены интерфейса. Поэтому, если вы не передаете все необходимые параметры правильного типа, компилятор TypeScript выдаст ошибку.</li>
    <li>Описание существующих API-интерфейсов JavaScript и уточнение параметров функции и типов возвращаемого значения. Это особенно полезно при работе с библиотеками JavaScript, например jQuery. Интерфейс может дать четкое представление о том, что ожидает функция и что она будет возвращать, без постоянного обращения к документации.</li>
  </ul>

  <h3>Чем интерфейс отличается от псевдонима типа?</h3>
  <p>Приведенный выше интерфейс Employee можно также выразить как псевдоним типа с помощью ключевого слова type:</p>
  <pre>
type Employee = {
    firstName: string;
    lastName: string;
    fullName(): string;
}
  </pre>
  <p>Псевдоним типа — это определение типа данных, например объединение, примитив, пересечение, кортеж или любой другой тип. Интерфейсы, с другой стороны, позволяют описывать фигуры данных, например объект. Псевдонимы типов могут действовать как интерфейсы. Однако существуют незначительные отличия. Ключевое отличие заключается в том, что псевдоним типа нельзя открыть повторно, чтобы добавить новые свойства, в то время как интерфейс можно легко расширять. Кроме того, с помощью псевдонима типа можно описать только объединение или кортеж.</p>
</article>


<!-- module-3 Упражнение. Объявление и создание экземпляра интерфейса в TypeScript -->
<article class="article">
  <h2>Урок 3 из 8. Упражнение. Объявление и создание экземпляра интерфейса в TypeScript. 5 мин</h2>

  <p>Чтобы объявить интерфейс, начните с interface ключевое слово с именем интерфейса (идентификатором).) Имя интерфейса может не быть одним из предопределенных имен типов в системе типов. И, по соглашению, имена интерфейсов находятся в PascalCase.</p>
  <p><strong>Примечание.</strong> Рекомендации по написанию кода TypeScript предполагают, что интерфейсы не должны начинаться с буквы I.</p>
  <p>Затем определите свойства (или члены) интерфейса и их тип. Свойства могут быть обязательными, необязательными или только для чтения.</p>
  <ol>
    <li>Обязательное поле.	Все свойства являются обязательными, если не указано иное.	firstName: string;</li>
    <li>Необязательное.	Добавьте вопросительный знак (?) в конец имени свойства. Используйте его для необязательных свойств. Это предотвращает вызов системой типов ошибки, если свойство пропущено.	firstName?: string;</li>
    <li>Только чтение.	Добавьте ключевое слово readonly перед именем свойства. Используйте его для свойств, которые должны быть изменены только при создании объекта.	readonly firstName: string;</li>
  </ol>

  <h3>Объявление интерфейса с членами</h3>
  <ol>
    <li>Откройте <a href="https://www.typescriptlang.org/play">тестовую площадку</a> и удалите существующий код.</li>
    <li>Объявите интерфейс с именем IceCream, который включает два свойства: flavor как string и scoops как number.
      <pre>
interface IceCream {
    flavor: string;
    scoops: number;
}
      </pre>
    </li>
    <li>Теперь можно реализовать новый интерфейс. Начнем с использования интерфейса IceCream как типа в объявлении переменной. Объявите новую переменную с именем myIceCream типа IceCream и присвойте значения требуемым свойствам. Когда вы начнете вводить имя свойства, IntelliSense предложит правильные имена и типы. Проверьте работу, отобразив значение на консоли.
      <pre>
let myIceCream: IceCream = {
    flavor: 'vanilla',
    scoops: 2
}

console.log(myIceCream.flavor);
      </pre>
    </li>
    <li>Выберите Выполнить. Обратите внимание, что в окне Журнал отображается вкус (flavor).</li>
    <li>Теперь создадим функцию в нижней части с именем tooManyScoops, которая использует интерфейс IceCream в качестве типа параметра. Эта функция проверяет количество ложек (scoops) в объекте IceCream и возвращает сообщение на основе результата. Чтобы протестировать работу, передайте объект {flavor: 'vanilla', scoops: 5} в качестве параметра и проверьте результат, выведя его на консоль.
      <pre>
function tooManyScoops(dessert: IceCream) {
    if (dessert.scoops >= 4) {
      return dessert.scoops + ' is too many scoops!';
    } else {
      return 'Your order will be ready soon!';
    }
}

console.log(tooManyScoops({flavor: 'vanilla', scoops: 5}));
      </pre>
    </li>
    <li>Запустите код, нажав кнопку Выполнить. Выходные данные должны выглядеть следующим образом.
      <pre>
"vanilla"
"5 is too many scoops!"
      </pre>
    </li>
    <li>Откройте область JavaScript и обратите внимание на различия между кодом JavaScript и кодом TypeScript. Интерфейс не имеет представления в коде JavaScript.</li>
    <li>Что произойдет, если добавить в интерфейс IceCream еще одно свойство? Давайте добавим новое свойство с именем instructions и присвоим ему тип string.</li>
    <li>Проверьте ошибки, отображаемые в коде. Чтобы устранить их, необходимо добавить свойство instructions в сведения о реализации объявления переменной и добавить его в качестве параметра, передаваемого функции. Пока сделайте свойство instructions необязательным, добавив вопросительный знак в имя свойства. Все ошибки разрешатся, так как свойство instructions больше не требуется интерфейсу.</li>
  </ol>
  <p>Пока все в порядке. Но мороженое сандей без топпингов — это просто мороженое. Далее мы рассмотрим, как расширить интерфейс.</p>
</article>


<!-- module-3 Упражнение. Расширение интерфейса в TypeScript -->
<article class="article">
  <h2>Урок 4 из 8. Упражнение. Расширение интерфейса в TypeScript. 5 мин</h2>

  <p>Интерфейсы могут дополнять друг друга. Это позволяет копировать члены одного интерфейса в другой, обеспечивая большую гибкость при разделении интерфейсов на многократно используемые компоненты.</p>
  <p>При расширении интерфейса одним или несколькими интерфейсами применяются следующие правила.</p>
  <ul>
    <li>Вы должны реализовать все необходимые свойства из всех интерфейсов.</li>
    <li>Два интерфейса могут иметь одно и то же свойство, если свойство имеет то же имя и тип.</li>
    <li>Если два интерфейса имеют свойство с одинаковым именем, но разными типами, необходимо объявить новое свойство таким образом, чтобы результирующее свойство было подтипом обоих интерфейсов.</li>
  </ul>

  <h3>Расширение интерфейса</h3>
  <p>Существует несколько типов десертов, которые можно создать из интерфейса IceCream (сандей, молочные коктейли и т. д.), но все они имеют различные свойства в дополнение к объявленным в IceCream. Расширим интерфейс с помощью нового, Sundae, и объявим его свойства.</p>
  <ol>
    <li>Продолжите работу над проектом на тестовой площадке.</li>
    <li>В объявлении интерфейса IceCream объявите новый интерфейс с именем Sundae, который выполняет операцию extends с интерфейсом IceCream. Интерфейс Sundae включает четыре новых свойства:
      <ul>
        <li>sauce литерального типа 'chocolate' | 'caramel' | 'strawberry';</li>
        <li>nuts типа boolean (необязательно);</li>
        <li>whippedCream типа boolean (необязательно);</li>
        <li>instructions типа boolean (необязательно);</li>
      </ul>
      <pre>
interface Sundae extends IceCream {
    sauce: 'chocolate' | 'caramel' | 'strawberry';
    nuts?: boolean;
    whippedCream?: boolean;
    instructions?: boolean;
}
      </pre>
    </li>
    <li>Обратите внимание на ошибку в новом интерфейсе. TypeScript обнаружил, что оба интерфейса, IceCream и Sundae, имеют свойство instructions, но принадлежат разным типам. Чтобы устранить эту ошибку, давайте создадим оба свойства instructions одного типа string.</li>
    <li>Давайте попробуем создать новый интерфейс, изменив переменную myIceCream на тип Sundae. Это приведет к ошибке: Свойство 'sauce' отсутствует в типе '{ flavor: string; scoops: number; }', но требуется в типе 'Sundae'. В интерфейс Sundae добавлено четыре новых свойства, но требовалось только свойство sauce.
      <pre>
let myIceCream: Sundae = {
    flavor: 'vanilla',
    scoops: 2
}
      </pre>
    </li>
    <li>Исправьте ошибку, добавив требуемое свойство, а также любое из необязательных свойств по желанию.
      <pre>
let myIceCream: Sundae = {
    flavor: 'vanilla',
    scoops: 2,
    sauce: 'caramel',
    nuts: true
}
      </pre>
    </li>
    <li>Теперь попробуйте реализовать интерфейс Sundae в функции tooManyScoops. Ошибки не отображаются в самой функции, но вызов функции в следующей строке приводит к ошибке. Это обусловлено тем, что ожидается три обязательных параметра. Устраните ошибку, добавив свойство sauce в вызов функции.
      <pre>
function tooManyScoops(dessert: Sundae) {
    if (dessert.scoops >= 4) {
        return dessert.scoops + ' is too many scoops!';
    } else {
        return 'Your order will be ready soon!';
    }
}
console.log(tooManyScoops({flavor: 'vanilla', scoops: 5, sauce: 'caramel'}));
      </pre>
    </li>
  </ol>
</article>


<!-- module-3 Другие способы использования интерфейсов в Typescript -->
<article class="article">
  <h2>Урок 5 из 8. Другие способы использования интерфейсов в Typescript. 5 мин</h2>

  <p>Теперь, когда вы знакомы с основами объявления и реализации интерфейса, давайте рассмотрим другие способы его использования.</p>

  <h3>Создание индексируемых типов</h3>
  <p>Можно использовать интерфейсы, описывающие типы массивов, в которые можно выполнять индексирование.</p>
  <p>Индексируемые типы имеют сигнатуру индекса, описывающую тип, который можно использовать для индексирования объекта, а также соответствующие возвращаемые типы при индексировании.</p>
  <p>Например, интерфейс IceCreamArray объявляет сигнатуру индекса как number и возвращает тип string. Эта сигнатура индекса указывает, что IceCreamArray индексируется числом и будет возвращать строку.</p>
  <pre>
interface IceCreamArray {
    [index: number]: string;
}

let myIceCream: IceCreamArray;
myIceCream = ['chocolate', 'vanilla', 'strawberry'];
let myStr: string = myIceCream[0];
console.log(myStr);
  </pre>
  <p>Можно также использовать встроенный тип массива или псевдоним типа для пользовательского массива, но с помощью интерфейса можно определить собственный тип массива, чтобы любой, кто хочет работать с этим интерфейсом, мог применять его согласованно.</p>

  <h3>Описание API JavaScript с помощью интерфейса</h3>
  <p>Обычно разработчики JavaScript и TypeScript испытывают трудности при работе с внешними библиотеками JavaScript. Вы можете использовать интерфейс, чтобы описывать существующие API-интерфейсы JavaScript и уточнять параметры функции и типы возвращаемого значения. Интерфейс дает четкое представление о том, что ожидает API и что он будет возвращать.</p>
  <p>API fetch — это собственная функция JavaScript, которую можно использовать для взаимодействия с веб-службами. В этом примере объявляется интерфейс Post для возвращаемых типов в JSON-файле, а затем используется fetch с async и await для создания строго типизированного ответа.</p>
  <pre>
const fetchURL = 'https://jsonplaceholder.typicode.com/posts'
// Interface describing the shape of our json data
interface Post {
    userId: number;
    id: number;
    title: string;
    body: string;
}
async function fetchPosts(url: string) {
    let response = await fetch(url);
    let body = await response.json();
    return body as Post[];
}
async function showPost() {
    let posts = await fetchPosts(fetchURL);
    // Display the contents of the first item in the response
    let post = posts[0];
    console.log('Post #' + post.id)
    // If the userId is 1, then display a note that it's an administrator
    console.log('Author: ' + (post.userId === 1 ? "Administrator" : post.userId.toString()))
    console.log('Title: ' + post.title)
    console.log('Body: ' + post.body)
}

showPost();
  </pre>
  <p>В этой схеме обучения мы не будем рассматривать использование async/await. Если вы хотите узнать больше об этом, см. видео из курса <a href="https://learn.microsoft.com/ru-ru/shows/beginners-series-to-javascript/">JavaScript для начинающих:</a></p>
  <ul>
    <li><a href="https://youtu.be/CjOVvs61zAQ">Использование async/await в JavaScript с длительными операциями</a></li>
    <li><a href="https://youtu.be/YwmlRkrxvkk">async/await для управления обещаниями</a></li>
    <li><a href="https://youtu.be/XLxIqq3HlL8">Ролик: async/await для управления обещаниями</a></li>
  </ul>

  <a href="https://www.youtube.com/playlist?list=PLlrxD0HtieHhW0NCG7M536uHGOtJ95Ut2">youtube</a>

  <p><strong>Совет.</strong> Хотя предыдущие версии ECMAScript, такие как ES3, не поддерживают async и await, компилятор TypeScript может создать совместимый код для реализации этой функции. Это позволяет воспользоваться преимуществами более новой функции при нацеливании на более старые браузеры! На тестовой площадке скопируйте и вставьте приведенный выше пример, задайте целевую версию ES3 и просмотрите вспомогательный код, формируемый TypeScript, чтобы это было возможно.</p>
</article>


<!-- module-3 Задание. Использование интерфейсов в TypeScript -->
<article class="article">
  <h2>Урок 6 из 8. Задание. Использование интерфейсов в TypeScript. 20 мин</h2>

  <p>В этом задании код JavaScript преобразуется в строго типизированный код с помощью интерфейсов.</p>
  <p>Код JavaScript содержит две функции: calculateInterestOnlyLoanPayment, которая рассчитывает платеж по неамортизационному кредиту, и calculateConventionalLoanPayment, которая вычисляет платеж по обычному кредиту. Как и в большинстве случаев расчета по кредитам, обе функции принимают параметры principal и interestRate. Различие между ними заключается в том, что функция calculateConventionalLoanPayment принимает третье свойство, months, а функция calculateInterestOnlyLoanPayment — нет.</p>
  <ul>
    <li>principal	Основная сумма кредита.</li>
    <li>interestRate	Годовая процентная ставка по кредиту. Например, 5 % указывается как 5.</li>
    <li>months	Срок кредита в месяцах. Для неамортизационного кредита это свойство не требуется, так как количество месяцев не имеет значения (кредит не будет погашаться, каждый месяц погашается только процент).</li>
  </ul>
  <p>В этом упражнении вы выполните следующие действия.</p>
  <ol>
    <li>Объявите интерфейс Loan, который определяет два свойства: principal и interestRate.</li>
    <li>Объявите интерфейс ConventionalLoan, который расширяет Loan и определяет дополнительное свойство, необходимое для обычного кредита, months.</li>
    <li>Обновите обе функции, чтобы реализовать новые интерфейсы, и строго типизируйте параметры.</li>
  </ol>

  <h3>Упражнение 1. Объявление интерфейсов</h3>
  <ol>
    <li>Клонируйте начальный репозиторий, введя следующую команду в командной строке.
      <pre>
git clone https://github.com/MicrosoftDocs/mslearn-typescript
cd mslearn-typescript/code/module-03/m03-start
code .
      </pre>
    </li>
    <li>Откройте файл module03.ts.</li>
    <li>Найдите TODO: Declare the Loan interface. Объявите интерфейс Loan, который определяет два свойства: principal и interestRate, каждое — number.
      <pre>
interface Loan {
    principal: number,
    interestRate: number    //* Interest rate percentage (eg. 14 is 14%)
}
      </pre>
    </li>
    <li>Найдите TODO: Declare the ConventionalLoan interface. Объявите интерфейс ConventionalLoan, который расширяет Loan и определяет дополнительное свойство, необходимое для обычного кредита, months, как number.
      <pre>
interface ConventionalLoan extends Loan {
    months: number      //* Total number of months
}
      </pre>
    </li>
  </ol>

  <h3>Упражнение 2. Реализация интерфейсов</h3>
  <ol>
    <li>Найдите TODO: Update the calculateInterestOnlyLoanPayment function. Замените два параметра в функции calculateInterestOnlyLoanPayment объектом типа Loan (например, loanTerms: Loan) и введите возвращаемое значение функции в виде string.
      <pre>
function calculateInterestOnlyLoanPayment(loanTerms: Loan): string {
    // ...
}
      </pre>
    </li>
    <li>Вы заметите несколько ошибок, так как TypeScript не распознает параметры interestRate и principal. Замените имена параметров в функции свойствами объекта Loan. (Например, loanTerms.interestRate).
      <pre>
function calculateInterestOnlyLoanPayment(loanTerms: Loan): string {
    // Calculates the monthly payment of an interest only loan
    let interest = loanTerms.interestRate / 1200;   // Calculates the Monthly Interest Rate of the loan
    let payment;
    payment = loanTerms.principal * interest;
    return 'The interest only loan payment is ' + payment.toFixed(2);
}
      </pre>
    </li>
    <li>Введите переменные interest и payment в функции calculateInterestOnlyLoanPayment в качестве numbers.</li>
    <li>Протестируйте функцию calculateInterestOnlyLoanPayment, чтобы убедиться, что она работает правильно. Помните, что теперь необходимо передать параметры в функцию в виде объекта Loan.
      <pre>
let interestOnlyPayment = calculateInterestOnlyLoanPayment({principal: 30000, interestRate: 5});
console.log(interestOnlyPayment);     //* Returns "The interest only loan payment is 125.00"
      </pre>
    </li>
    <li>Найдите TODO: Update the calculateConventionalLoanPayment function. Обновите функцию calculateConventionalLoanPayment, на этот раз заменив три параметра объектом типа ConventionalLoan и типом возвращаемого значения функции в виде string. Внесите остальные изменения в реализацию функции calculateConventionalLoanPayment.
      <pre>
function calculateConventionalLoanPayment(loanTerms: ConventionalLoan): string {
    // Calculates the monthly payment of a conventional loan
    let interest: number = loanTerms.interestRate / 1200;   // Calculates the Monthly Interest Rate of the loan
    let payment: number;
    payment = loanTerms.principal * interest / (1 - (Math.pow(1/(1 + interest), loanTerms.months)));
    return 'The conventional loan payment is ' + payment.toFixed(2);
}
      </pre>
    </li>
    <li>Протестируйте функцию calculateConventionalLoanPayment, чтобы убедиться, что она работает правильно. Помните, что теперь необходимо передать параметры в функцию в виде объекта ConventionalLoan.
      <pre>
let conventionalPayment = calculateConventionalLoanPayment({principal: 30000, interestRate: 5, months: 180});
console.log(conventionalPayment);     //* Returns "The conventional loan payment is 237.24"
      </pre>
    </li>
  </ol>

  <h3>Решение задания</h3>
  <p>Просмотрите окончательную версию кода, введя следующую команду в командной строке.</p>
  <pre>
cd ../m03-end
code .
  </pre>
  <p>Откройте файл module03.ts, чтобы просмотреть решение для этого задания. Дополнительные сведения о настройке среды разработки для запуска решения см. в разделе Подготовка к заданию выше.</p>
</article>


<!-- module-3 Проверка знаний -->
<article class="article">
  <h2>Урок 7 из 8. Проверка знаний. 2 мин</h2>

  <p>Выберите наилучший ответ на каждый из вопросов ниже. Затем нажмите кнопку Проверьте свои ответы.</p>
  <ol>
    <li>1. Какова основная задача интерфейса?
      <ul>
        <li>Определение сведений о реализации для объекта.</li>
        <li>Описание свойств и возвращаемых типов объекта.</li>
        <li>Выполнение контракта кода для объекта.</li>
      </ul>
    </li>
    <li>2. Как предотвратить возникновение ошибки в системе типов при пропуске свойства в интерфейсе?
      <ul>
        <li>Сделать свойство необязательным.</li>
        <li>Сделать свойство обязательным.</li>
        <li>Сделать свойство доступным только для чтения.</li>
      </ul>
    </li>
    <li>3. Что происходит при расширении одного интерфейса другим?
      <ul>
        <li>Несколько интерфейсов могут иметь одно и то же свойство, если свойство имеет то же имя.</li>
        <li>Если у двух интерфейсов есть свойство с одинаковым именем, но с разными типами, TypeScript полностью пропускает это свойство.</li>
        <li>Вы должны реализовать все необходимые свойства из всех интерфейсов.</li>
      </ul>
    </li>
  </ol>
</article>


<!-- module-3 Сводка -->
<article class="article">
  <h2>Урок 8 из 8. Сводка. 2 мин</h2>

  <p>Теперь, после изучения этого модуля, вы можете выполнять следующие задачи.</p>
  <ul>
    <li>Объяснение причин использования интерфейса в TypeScript.</li>
    <li>Объявление интерфейса.</li>
    <li>Реализация интерфейса.</li>
    <li>Объявление интерфейса с пользовательскими типами массивов.</li>
  </ul>

  <h3>Ресурсы</h3>
  <p>Воспользуйтесь этими ресурсами, чтобы узнать больше.</p>
  <ul>
    <li>Дополнительные сведения об интерфейсах см. в документе <a href="https://www.typescriptlang.org/docs/handbook/2/objects.html">Руководстве по TypeScript: интерфейсы.</a></li>
  </ul>
</article>


<!-- module-4 -->
<article class="article">
  <div class="anchor" id="module-4"></div>
  <h2>Модуль 4. Develop typed functions by using TypeScript. Разработка типизированных функций с использованием TypeScript. 51 мин</h2>

  <p><a href="https://learn.microsoft.com/api/achievements/share/ru-ru/frontend200tb-0827/QDA973TE?sharingId=6364D7D096225EB9">Значек</a></p>

  <p><a href="https://learn.microsoft.com/en-us/training/modules/typescript-develop-typed-functions/">Develop typed functions by using TypeScript (en)</a>
  <br><a href="https://learn.microsoft.com/ru-ru/training/modules/typescript-develop-typed-functions/">Разработка типизированных функций с использованием TypeScript (ru)</a></p>

  <p>51 мин Модуль 9 единиц(ы)</p>
  <p>Если вы умеете писать функции на JavaScript, значит вам уже известно, как писать функции на TypeScript. Но в TypeScript к стандартным функциям JavaScript добавлен ряд новых возможностей, которые упрощают работу с ними.</p>

  <h3>Цели обучения</h3>
  <p>В этом модуле вы научитесь выполнять следующее.</p>
  <ul>
    <li>Объяснять преимущества использования типов в функциях.</li>
    <li>Писать функции, которые имеют обязательные и необязательные параметры, параметры по умолчанию и параметры rest.</li>
    <li>Определять типы функций с помощью псевдонимов типов или интерфейсов.</li>
  </ul>

  <h3>Предварительные требования</h3>
  <ul>
    <li>Знание TypeScript</li>
    <li>Опыт работы с JavaScript</li>
    <li>Опыт работы с функциями и массивами в JavaScript</li>
    <li>Установленное программное обеспечение:
      <ul>
        <li>Git</li>
        <li>Visual Studio Code</li>
        <li>Node.js</li>
        <li>TypeScript</li>
      </ul>
    </li>
  </ul>

  <h3>Этот модуль входит в состав указанных схем обучения</h3>
  <p>Создание приложений JavaScript с помощью TypeScript</p>
  <p>Введение 2 мин</p>
  <p>Создание функций на TypeScript 5 мин</p>
  <p>Упражнение. Создание функций 5 мин</p>
  <p>Функция с параметрами 5 мин</p>
  <p>Упражнение. Функция с параметрами 5 мин</p>
  <p>Упражнение. Определение типов функции 5 мин</p>
  <p>Задание. Использование функций на TypeScript 20 мин</p>
  <p>Тест на проверку знаний 2 мин</p>
  <p>Сводка и ресурсы 2 мин</p>
</article>


<!-- module-4 Введение -->
<article class="article">
  <h2>Урок 1 из 9. Введение. 2 мин</h2>

  <p>Если вы умеете писать функции на JavaScript, значит вам уже известно, как писать функции на TypeScript. Но в TypeScript к стандартным функциям JavaScript добавлен ряд новых возможностей, которые упрощают работу с ними.</p>

  <h3>Цели обучения</h3>
  <p>По завершении этого модуля вы сможете:</p>
  <ul>
    <li>Объяснять преимущества использования типов в функциях.</li>
    <li>Писать функции, которые имеют обязательные и необязательные параметры, параметры по умолчанию и параметры rest.</li>
    <li>Определять типы функций с помощью псевдонимов типов или интерфейсов.</li>
  </ul>

  <h3>Необходимые компоненты</h3>
  <ul>
    <li>Знание TypeScript</li>
    <li>Знакомство с JavaScript.</li>
    <li>Опыт работы с функциями и массивами в JavaScript</li>
    <li>Установленное программное обеспечение:
      <ul>
        <li>Git</li>
        <li>Visual Studio Code</li>
        <li>Node.js</li>
        <li>TypeScript. TypeScript можно установить после установки Node.js и выполнения указанной ниже команды в терминале или командном окне.
          <code>npm install -g typescript</code>
        </li>
      </ul>
    </li>
  </ul>
  <p>Для получения наилучших результатов полностью следуйте инструкциям по настройке окружения и использованию компилятора TypeScript в статье <a href="https://learn.microsoft.com/ru-ru/training/modules/typescript-get-started/">Модуль 01. Начало работы с TypeScript</a>. После настройки окружения можно запустить любые файлы подготовки к заданию или его решения в <a href="https://learn.microsoft.com/ru-ru/training/paths/build-javascript-applications-typescript/">приложении сборки JavaScript</a> с помощью схемы обучения TypeScript.</p>
</article>


<!-- module-4 Создание функций на TypeScript -->
<article class="article">
  <h2>Урок 2 из 9. Создание функций на TypeScript. 5 мин</h2>

  <p>В JavaScript определения функций не указывают типы данных для параметров, не выполняют проверку типов для переданных аргументов и не проверяют количество полученных аргументов. Поэтому необходимо добавить логику для проверки этих параметров в функции.</p>
  <p>TypeScript упрощает разработку функций и устранение неполадок, позволяя вводить параметры и возвращать значения. В TypeScript также предусмотрены новые возможности для параметров. Например, хотя в функциях JavaScript все параметры являются необязательными, в TypeScript можно обозначить параметры как обязательные или необязательные.</p>
  <p>Добавление типов в функции помогает предотвратить передачу значений, которые не следует передавать в функции. Типизированные функции особенно важны при работе с более крупными базами кода или функциями, разработанными другими пользователями. Хотя добавление типов не создает существенных отличий, оно дает такое преимущество, как проверка типов передаваемых в функцию значений и возвращаемых ею данных. Вместо того чтобы добавлять в функцию всю логику для проверки правильности типа передаваемого и возвращаемого значения, с помощью TypeScript можно гарантировать правильность типов значений при разработке кода. Кроме того, при создании логики функции будет доступна полная поддержка автозаполнения, так как редактор будет знать тип данных параметров, в то время как код JavaScript, как правило, определить его не может. Автозаполнение особенно полезно при использовании функций, разработанных другими пользователями, так как TypeScript определяет необходимые типы входных и выходных данных.</p>
  <p>Как и в JavaScript, функции в TypeScript можно определять несколькими способами. Рассмотрим, чем отличаются эти функции в связи с добавлением типов в TypeScript.</p>

  <h3>Именованные функции</h3>
  <p>Именованная функция — это объявление функции, написанное с помощью ключевого слова function, для которого в текущей области указано уникальное имя. Объявления именованных функций загружаются в контекст выполнения перед выполнением любого кода. Этот процесс называется подъемом, и это означает, что вы можете использовать функцию перед объявлением.</p>
  <p>Для объявления именованной функции в TypeScript используется такой же, как и для ее определения в JavaScript. Единственное отличие в TypeScript заключается в том, что здесь можно добавить заметку с типом для параметров и возвращаемого значения функции.</p>
  <p>Эта функция принимает два параметра типа number и возвращает значение типа number.</p>
  <pre>
function addNumbers (x: number, y: number): number {
   return x + y;
}
addNumbers(1, 2);
  </pre>

  <h3>Анонимные функции</h3>
  <p>Выражение функции (или анонимная функция) — это функция, которая не загружается предварительно в контекст выполнения и выполняется только тогда, когда встречается в коде. Выражения функций создаются во время выполнения и должны быть объявлены перед их вызовом. Они не подняты, в отличие от именованных объявлений функций, которые будут подняты сразу после начала выполнения программы и могут вызываться до их объявления.</p>
  <p>Выражения функций представляют значения, поэтому они обычно назначаются переменной или передаются в другие функции и могут быть анонимными, то есть функция не имеет имени.</p>
  <p>В этом примере выражение function присваивается переменной addNumbers. Обратите внимание, что вместо имени функции отображается она сама, что делает ее анонимной. Теперь эту переменную можно использовать для вызова функции.</p>
  <pre>
let addNumbers = function (x: number, y: number): number {
   return x + y;
}
addNumbers(1, 2);
  </pre>
  <p>В следующем примере показано, как выглядит именованной функции sum при написании в виде анонимной функции. Обратите внимание, что имя sum было заменено ключевое словоfunction, а функция реализована как выражение в объявлении переменной.</p>
  <pre>
let sum = function (input: number[]): number {
    let total: number =  0;
    for(let i = 0; i &lt; input.length; i++) {
        if(isNaN(input[i])) {
            continue;
        }
        total += Number(input[i]);
    }
    return total;
}

console.log(sum([1, 2, 3]));
  </pre>
  <p>Как и ранее, при использовании анонимных функций вы получаете проверку типов и IntelliSense. В этом примере обратите также внимание на то, что переменная sum не типизирована, но TypeScript может определить ее тип с помощью так называемой "контекстной типизации", своего рода определения типа. Контекстная типизация может сократить количество усилий, необходимых для сохранения типа программы.</p>

  <h3>Функции со стрелкой</h3>
  <p>Функции со стрелками (также называемые лямбда-выражениями или функциями с жирными стрелками, поскольку для их определения используется оператор =>), обеспечивают краткий синтаксис для определения анонимной функции. Из-за их краткости функции со стрелками часто используются с простыми функциями, а также в некоторых сценариях обработки событий.</p>
  <p>В этом примере сравнивается синтаксис анонимной функции function и синтаксис функции со стрелкой в одну строку. Функция со стрелкой позволяет сократить синтаксис, пропустив ключевое слово function и добавив оператор => между параметрами и телом функции.</p>
  <pre>
// Anonymous function
let addNumbers1 = function (x: number, y: number): number {
   return x + y;
}

// Arrow function
let addNumbers2 = (x: number, y: number): number => x + y;
  </pre>
  <p>Обратите внимание, что в этом примере фигурные скобки удалены, а оператор return отсутствует. Однострочные функции со стрелками могут использоватькраткий синтаксис тела или неявный возврат, допускающий пропуск фигурных скобок и ключевого слова return.</p>
  <p>Если тело функции имеет более одной строки, заключите его в фигурные скобки и включите инструкцию return (при необходимости). В этом примере показано, как выглядит анонимная функция в предыдущем примере при написании в виде функции со стрелкой.</p>
  <pre>
let total2 = (input: number[]): number => {
    let total: number =  0;
    for(let i = 0; i &lt; input.length; i++) {
        if(isNaN(input[i])) {
            continue;
        }
        total += Number(input[i]);
    }
    return total;
}
  </pre>
  <p><strong>Совет.</strong> Функции со стрелками были введены в ES2015, поэтому их поддерживают не все браузеры. TypeScript позволяет воспользоваться преимуществами этих типов функций, а затем при необходимости транскомпилировать код в более ранние версии JavaScript, чтобы он работал с более старыми браузерами.</p>
</article>


<!-- module-4 Упражнение. Создание функций -->
<article class="article">
  <h2>Урок 3 из 9. Упражнение. Создание функций. 5 мин</h2>

  <p>При выполнении этого упражнения вы создадите две именованные функции со строго типизированными параметрами и возвращаемыми значениями.</p>
  <ol>
    <li>Откройте тестовую площадку и удалите существующий код.</li>
    <li>Скопируйте следующую функцию JavaScript в тестовую площадку. Обратите внимание, что параметр message неявно имеет тип any.
      <pre>
function displayAlert(message) {
    alert('The message is ' + message);
}
      </pre>
    </li>
    <li>Теперь присвойте тип string параметру message. Эта именованной функция не возвращает значение, чтобы вы могли оставить возвращаемый тип (вы также можете передать обратно void в качестве возвращаемого типа, но это не обязательно.
      <pre>
function displayAlert(message: string) {
    alert('The message is ' + message);
}
      </pre>
    </li>
    <li>Попробуйте вызвать функцию, передав string в качестве параметра. Теперь попробуйте передать number. TypeScript проверит тип параметра и уведомит вас о конфликте. В зависимости от того, что вы пытаетесь выполнить с помощью этой функции, можно взять число в кавычки, дополнить типы значений, принимаемых параметром, типом объединения (например, msg: string | number) или добавить в функцию логику для обработки различных типов передаваемых в нее значений.</li>
    <li>Ниже приведен еще один пример. Функция sum суммирует числа в массиве и возвращает результат. Скопируйте код JavaScript в тестовую площадку.
      <pre>
function sum(input) {
    let total =  0;
    for(let count = 0; count &lt; input.length; count++) {
        if(isNaN(input[count])){
            continue;
        }
        total += Number(input[count]);
    }
    return total;
}
      </pre>
    </li>
    <li>Попробуйте вызвать функцию с одним числом в качестве параметра, например sum(5). Он принимает значение, но не возвращает правильный результат, так как параметр не передается в виде массива.</li>
    <li>Задайте тип параметра массиву number значений, задайте тип возвращаемой функции numberи задайте тип переменной totalnumber.input
      <pre>
function sum(input: number[]): number {
    let total: number =  0;
    for(let count = 0; count &lt; input.length; count++) {
        if(isNaN(input[count])){
            continue;
        }
        total += Number(input[count]);
    }
    return total;
}
      </pre>
    </li>
    <li>Теперь, если вы вызываете функцию с sum(5), TypeScript помечает проблему типа с параметром.</li>
    <li>Попробуйте вызвать функцию с массивом значений, имеющих смешанные типы, например sum([1, 'two', 3]). Значения внутри массива относятся к типу проверка, а TypeScript возвращает ошибку:Type 'string' is not assignable to type 'number'.</li>
  </ol>
</article>


<!-- module-4 Функция с параметрами -->
<article class="article">
  <h2>Урок 4 из 9. Функция с параметрами. 5 мин</h2>

  <p>Компилятор TypeScript по умолчанию предполагает, что требуются все параметры, определенные в функции. При вызове функции компилятор TypeScript проверяет следующее:</p>
  <ul>
    <li>Значения были предоставлены для каждого параметра.</li>
    <li>передаются ли только те параметры, которые необходимы функции;</li>
    <li>Параметры передаются в том порядке, в котором они определены в функции.</li>
  </ul>
  <p>Эти требования отличаются от JavaScript. JavaScript предполагает, что все параметры являются необязательными и позволяют передавать больше (или меньше) аргументов функции, чем определено им.</p>
  <p>В дополнение к обязательным параметрам можно определить функции с необязательными параметрами, параметрами по умолчанию и параметрами rest, а также с деконструированными параметрами объекта.</p>

  <h3>Обязательные параметры</h3>
  <p>Если не указано иное, все параметры функции являются обязательными, а число аргументов, передаваемых в функцию, должно соответствовать числу обязательных параметров, которые требуются функции.</p>
  <p>В этом примере все параметры являются обязательными.</p>
  <pre>
function addNumbers (x: number, y: number): number {
   return x + y;
}

addNumbers(1, 2); // Returns 3
addNumbers(1);    // Returns an error
  </pre>

  <h3>Необязательные параметры</h3>
  <p>Кроме того, можно определить необязательные параметры, добавив в конец имени параметра вопросительный знак (?).</p>
  <p>В этом примере x является обязательным, а y — необязательным параметром. Необязательный параметр должен следовать после всех обязательных параметров в списке параметров. Кроме того, чтобы эта функция возвращала правильное значение, необходимо учитывать вероятность того, что y может передаваться как неопределенное.</p>
  <pre>
function addNumbers (x: number, y?: number): number {
    if (y === undefined) {
        return x;
    } else {
        return x + y;
    }
}

addNumbers(1, 2); // Returns 3
addNumbers(1);    // Returns 1
  </pre>

  <h3>Параметры по умолчанию</h3>
  <p>Необязательным параметрам можно также присвоить значения по умолчанию. Если значение передается необязательному параметру в качестве аргумента, ему будет присвоено это значение. В противном случае ему присваивается значение по умолчанию. Как и в случае с необязательными параметрами, параметры по умолчанию должны следовать после обязательных параметров в списке параметров.</p>
  <p>В этом примере x является обязательным, а y — необязательным параметром. Если значение не передается y, значение по умолчанию равно 25.</p>
  <pre>
function addNumbers (x: number, y = 25): number {
   return x + y;
}

addNumbers(1, 2);  // Returns 3
addNumbers(1);     // Returns 26
  </pre>

  <h3>Параметры rest</h3>
  <p>Если вы хотите работать с несколькими параметрами в качестве группы (например, передавая их в массив). Или, если вы не знаете, сколько параметров функция в конечном итоге займет. Можно использовать параметры rest. Параметры rest обрабатываются как неограниченное число необязательных параметров. Вы можете убирать их или добавлять в любом количестве.</p>
  <p>В этом примере есть один обязательный параметр и необязательный параметр с именем restOfNumbers, который может принимать любое количество дополнительных чисел. Многоточие (...) перед restOfNumbers указывает компилятору, что необходимо создать массив переданных функции аргументов, и присвоить ему имя, чтобы его можно было использовать в функции.</p>
  <pre>
let addAllNumbers = (firstNumber: number, ...restOfNumbers: number[]): number => {
   let total: number =  firstNumber;
   for(let counter = 0; counter &lt; restOfNumbers.length; counter++) {
      if(isNaN(restOfNumbers[counter])){
         continue;
      }
      total += Number(restOfNumbers[counter]);
   }
   return total;
}
  </pre>
  <p>Теперь функция может принимать одно или несколько значений и возвращать результат.</p>
  <pre>
addAllNumbers(1, 2, 3, 4, 5, 6, 7);  // returns 28
addAllNumbers(2);                    // returns 2
addAllNumbers(2, 3, "three");        // flags error due to data type at design time, returns 5
  </pre>

  <h3>Деконструированные параметры объекта</h3>
  <p>Параметры функции являются позициальными и должны быть переданы в порядке, в котором они определены в функции. Позиционные параметры могут сделать код менее читаемым при вызове функции с несколькими параметрами, которые являются необязательными или одинаковыми типами данных.</p>
  <p>Для включения именованных параметров можно использовать метод, называемый деконструктивным параметрами объекта. Этот метод позволяет использовать интерфейс для определения именованных, а не позиционных параметров в функциях.</p>
  <p>В следующем примере определяется интерфейс с именем Message, который определяет два свойства. displayMessage В функции Message объект передается в качестве параметра, предоставляя доступ к свойствам, как будто они являются обычными параметрами.</p>
  <pre>
interface Message {
   text: string;
   sender: string;
}

function displayMessage({text, sender}: Message) {
    console.log(`Message from ${sender}: ${text}`);
}

displayMessage({sender: 'Christopher', text: 'hello, world'});
  </pre>
</article>


<!-- module-4 Упражнение. Функция с параметрами -->
<article class="article">
  <h2>Урок 5 из 9. Упражнение. Функция с параметрами. 5 мин</h2>

  <p>При выполнении этого упражнения вы создадите функции, которые имеют обязательные и необязательные параметры, а также параметры по умолчанию.</p>

  <h3>Обязательные параметры</h3>
  <ul>
    <li>Откройте тестовую площадку и удалите существующий код.</li>
    <li>Введите следующую функцию со стрелкой, которая принимает три обязательных параметра.
      <code>let addThreeNumbers = (x: number, y: number, z: number): number => x + y + z;</code>
    </li>
    <li>Попробуйте вызвать функцию, введя addThreeNumbers(10, 20). TypeScript инициирует ошибку Ожидалось аргументов: 3, получено: 2. Не указан аргумент для "z". При запуске функция возвращает NaN, поскольку третий аргумент был передан как undefined, что делает вычисление недопустимым.</li>
    <li>Что происходит при вводе addThreeNumbers(10, 20, 30, 40)? TypeScript вызывает ошибку Ожидалось аргументов: 3, получено: 4. При запуске четвертый аргумент удаляется, а функция возвращает 60.</li>
  </ul>

  <h3>Необязательные параметры</h3>
  <ul>
    <li>Попробуйте сделать параметр y в функции необязательным. Что происходит?
      <code>let addThreeNumbers = (x: number, y?: number, z: number): number => x + y + z;</code>
    </li>
    <li>TypeScript инициирует ошибку, так как в данном случае имеет значение положение необязательных параметров. В списке параметров необязательные параметры должны следовать после всех обязательных параметров. Попробуйте вместо параметра y сделать необязательным параметр z. Кроме того, чтобы эта функция возвращала правильное значение, ее также необходимо обновить с учетом вероятности того, что z может теперь передаваться как undefined. Теперь вы можете вызвать функцию с помощью addThreeNumbers(10, 20) или addThreeNumbers(10, 20, 30).
      <pre>
let addThreeNumbers = (x: number, y: number, z?: number): number => {
    if((z === undefined)) {
        return x + y;
    } else {
        return x + y + z;
    }
};
      </pre>
    </li>
  </ul>

  <h3>Параметры по умолчанию</h3>
  <ul>
    <li>Введите следующую функцию со стрелкой, которая принимает три обязательных параметра.
      <code>let subtractThreeNumbers = (x: number, y: number, z: number): number => x - y - z;</code>
    </li>
    <li>Присвойте параметру z значение по умолчанию 100, заменив z: number на z = 100.
      <code>let subtractThreeNumbers = (x: number, y: number, z = 100): number => x - y - z;</code>
    </li>
    <li>Попробуйте вызвать функцию с двумя и тремя аргументами для проверки результата.
      <pre>
subtractThreeNumbers(10, 20);       // returns -110 because 'z' has been assigned the value 100
subtractThreeNumbers(10, 20, 15);   // returns -25
      </pre>
    </li>
  </ul>
</article>


<!-- module-4 Упражнение. Определение типов функции -->
<article class="article">
  <h2>Урок 6 из 9. Упражнение. Определение типов функции. 5 мин</h2>

  <p>Вы можете определить типы функций, а затем использовать их при создании функций. Эта конструкция полезна, если вы хотите применить сигнатуру одного типа функции к нескольким функциям.</p>
  <p>Тип функции можно определить с помощью псевдонима типа или интерфейса. Принцип действия обоих подходов по сути не отличается, поэтому выбирайте тот, который вам лучше всего подходит. Интерфейс лучше, если вы хотите расширить тип функции. Псевдоним типа лучше подходит, если требуется использовать объединения или кортежи.</p>
  <p>Давайте создадим функцию, которая выполняет операцию добавления или вычитающую операцию в зависимости от значения переданного ему параметра. Операции сложения и вычитания принимают два числа, x и y, и возвращают результат в виде числа.</p>
  <ul>
    <li>Откройте тестовую площадку и удалите существующий код.</li>
    <li>Определите тип функции с именем calculator, используя псевдоним типа. Сигнатура типа содержит список параметров (x: number, y: number) и возвращает объект number, отделенный оператором стрелки (=>). (Обратите внимание, что синтаксис сигнатуры типа такой же, как и у функции со стрелкой.)
      <code>type calculator = (x: number, y: number) => number;</code>
    </li>
    <li>Теперь тип функции можно использовать как сигнатуру типа при объявлении функций. Объявите две переменные типа функции calculator: одну для операции сложения, а другую для операции вычитания. Протестируйте новые функции, возвратив результат каждой из них в консоль.
      <pre>
let addNumbers: calculator = (x: number, y: number): number => x + y;
let subtractNumbers: calculator = (x: number, y: number): number => x - y;

console.log(addNumbers(1, 2));
console.log(subtractNumbers(1, 2));
      </pre>
    </li>
    <li>Тип функции calculator можно также использовать для передачи значений из другой функции. Введите функцию doCalculation, которая возвращает результат функции addNumbers или subtractNumbers в зависимости от значения, переданного в параметр operation.
      <pre>
let doCalculation = (operation: 'add' | 'subtract'): calculator => {
    if (operation === 'add') {
        return addNumbers;
    } else {
        return subtractNumbers;
    }
}
      </pre>
    </li>
    <li>Попробуйте выполнить функцию, введя. console.log(doCalculation('add')(1, 2)). Как можно видеть, TypeScript может предоставить справку IntelliSense на основе типов, определенных в doCalculation и calculator.</li>
    <li>Теперь закомментируйте тип функции calculator и объявите новый с помощью интерфейса. Обратите внимание, что сигнатура типа немного отличается. В качестве разделителя между списком параметров и типом возвращаемого значения вместо оператора со стрелкой используется двоеточие (:). Замените функцию calculator интерфейсом Calculator в объявлениях переменных. Когда все будет готово, код должен работать точно так же.
      <pre>
// type calculator = (x: number, y: number) => number;
interface Calculator {
    (x: number, y: number): number;
}
      </pre>
    </li>
  </ul>

  <h3>Определение типа функции</h3>
  <p>При определении функции имена параметров функции не должны совпадать с именами в типе функции. Хотя для имени параметров в сигнатуре типа в обоих местах имена игнорируются при проверка, если два типа функций совместимы.</p>
  <p>Вы также можете отключить типы параметров и возвращаемый тип, так как TypeScript будет выводить эти типы из определения типа функции.</p>
  <p>Что касается TypeScript, эти три оператора идентичны.</p>
  <pre>
let addNumbers: Calculator = (x: number, y: number): number => x + y;
let addNumbers: Calculator = (number1: number, number2: number): number => number1 + number2;
let addNumbers: Calculator = (num1, num2) => num1 + num2;
  </pre>
</article>


<!-- module-4 Задание. Использование функций на TypeScript -->
<article class="article">
  <h2>Урок 7 из 9. Задание. Использование функций на TypeScript. 20 мин</h2>

  <p>В этой лаборатории вы преобразуете некоторые функции JavaScript в TypeScript.</p>

  <h3>Упражнение 1. Преобразование функции JavaScript в TypeScript с строго типизированными параметрами и возвращаемыми типами</h3>
  <p>Следующий код JavaScript содержит три функции:</p>
  <ul>
    <li>Функция BuildArray формирует массив уникальных случайных чисел. Она принимает параметр items, определяющий количество элементов в массиве, и параметр sortOrder, определяющий, порядок сортировки массива (по возрастанию или по убыванию).</li>
    <li>sortDescending и sortAscending — это функции сравнения, которые указывают методу sort(), как сортировать числа в порядке возрастания или убывания.</li>
  </ul>
  <p>Преобразуйте функции в TypeScript со строго типизированными параметрами и типами возвращаемых значений.</p>
  <ol>
    <li>Клонируйте начальный репозиторий, введя следующую команду в командной строке.
      <pre>
git clone https://github.com/MicrosoftDocs/mslearn-typescript
cd mslearn-typescript/code/module-04/m04-start
code .
      </pre>
    </li>
    <li>Откройте файл module04.ts.</li>
    <li>Найдите TODO: Update the BuildArray function.</li>
    <li>BuildArray В функции добавьте типы в список параметров, возвращаемое значение и переменные.
      <pre>
function buildArray(items: number, sortOrder: 'ascending' | 'descending'): number[] {
   let randomNumbers: number[] = [];
   let nextNumber: number;

   for (let counter = 0; counter &lt; items; counter++) {
       nextNumber = Math.ceil(Math.random() * (100 - 1));
       if (randomNumbers.indexOf(nextNumber) === -1) {
         randomNumbers.push(nextNumber);
       } else {
         counter--;
       }
   }

   if (sortOrder === 'ascending') {
     return randomNumbers.sort(sortAscending);
   } else {
     return randomNumbers.sort(sortDescending);
   }
}
      </pre>
    </li>
    <li>Найдите TODO: Convert the sortDescending and sortAscending functions to arrow functions.</li>
    <li>Преобразуйте функции sortDescending и sortAscending в анонимные и назначьте их переменным с тем же именем.
      <pre>
let sortDescending = (a, b) => {
   if (a &gt; b) {
       return -1;
   } else if (b &gt; a) {
       return 1;
   } else {
       return 0;
   }
}

let sortAscending = (a, b) => {
    if (a &gt; b) {
      return 1;
    } else if (b &gt; a) {
      return -1;
    } else {
      return 0;
    }
  }
      </pre>
    </li>
    <li>Найдите TODO: Declare a new function type for the sortDescending and sortAscending functions.</li>
    <li>Объявите новый тип функции для функций sortDescending и sortAscending, используя псевдоним типа или интерфейс.
      <code>type compareFunctionType = (a: number, b:number) => number;</code>
    </li>
    <li>В объявлениях переменных для sortDescending и sortAscending примените новый тип функции в качестве типа переменной.
      <pre>
let sortDescending: compareFunctionType = (a, b) => {
   if (a &gt; b) {
       return -1;
   } else if (b &gt; a) {
       return 1;
   } else {
       return 0;
   }
}

let sortAscending: compareFunctionType = (a, b) => {
    if (a &gt; b) {
      return 1;
    } else if (b &gt; a) {
      return -1;
    } else {
      return 0;
    }
  }
      </pre>
    </li>
    <li>Протестируйте работу, вызвав функцию buildArray.
      <pre>
let myArray1 = buildArray(12, 'ascending');
let myArray2 = buildArray(8, 'descending');
console.log(myArray1);
console.log(myArray2);
      </pre>
    </li>
  </ol>

  <h3>Упражнение 2. Преобразование функции JavaScript в TypeScript с использованием необязательных параметров</h3>
  <p>Эта функция JavaScript возвращает сумму платежа для ссуды.</p>
  <ol>
    <li>Найдите TODO: Update the LoanCalculator function.</li>
    <li>Преобразуйте функцию loanCalculator в TypeScript со строго типизированными параметрами, переменными и типами возвращаемых значений.</li>
    <li>Сделайте параметр months необязательным, но присвойте ему значение по умолчанию, равное 12 месяцам, если оно опущено.
      <pre>
function loanCalculator (principal: number, interestRate: number, months = 12): string {
    let interest: number = interestRate / 1200;   // Calculates the monthly interest rate
    let payment: number;
    payment = principal * interest / (1 - (Math.pow(1/(1 + interest), months)));
    return payment.toFixed(2);
}
      </pre>
    </li>
    <li>Проверьте работу, вызвав функцию loanCalculator только с обязательными параметрами.
      <pre>
let myLoan = loanCalculator(1000, 5);
console.log(myLoan);
      </pre>
    </li>
  </ol>

  <h3>Попробуйте свои силы!</h3>
  <p>Чтобы усложнить задачу, возьмите существующий код JavaScript, написанный вами или найденный в Интернете, и перепишите его на TypeScript, используя полученные знания о функциях. Вы можете скопировать код JavaScript и вставить его в Playground, а затем отредактировать, или использовать другой редактор, например Visual Studio Code.</p>

  <h3>Решение задания</h3>
  <p>Просмотрите окончательную версию кода, введя следующую команду в командной строке.</p>
  <pre>
cd ../m04-end
code .
  </pre>
  <p>Откройте файл module04.ts, чтобы просмотреть решение этого задания.</p>
</article>


<!-- module-4 Проверка знаний -->
<article class="article">
  <h2>Урок 8 из 9. Проверка знаний. 2 мин</h2>

  <p>Выберите наилучший ответ на каждый из вопросов ниже. Затем нажмите кнопку Проверьте свои ответы.</p>
  <ol>
    <li>1. Каково различие между параметрами функций в TypeScript и JavaScript?
      <ul>
        <li>Параметры TypeScript являются обязательными по умолчанию, но их можно обозначить как необязательные. Параметры JavaScript всегда необязательные.</li>
        <li>Параметры TypeScript совпадают с параметрами JavaScript.</li>
        <li>Параметры TypeScript всегда необязательные. Параметры JavaScript являются обязательными по умолчанию, но их можно обозначить как необязательные.</li>
      </ul>
    </li>
    <li>2. Для чего чаще всего используется анонимная функция?
      <ul>
        <li>Если необходимо применить одну и ту же сигнатуру функции к нескольким функциям.</li>
        <li>Если нужна возможность повторного использования функции во всем коде.</li>
        <li>Если необходимо назначить выражение функции переменной.</li>
      </ul>
    </li>
    <li>3. Как определить тип функции, если его необходимо расширить?
      <ul>
        <li>Можно использовать либо интерфейс, либо псевдоним типа. Оба варианта работают одинаково.</li>
        <li>Его необходимо определить с помощью интерфейса.</li>
        <li>Его необходимо определить с помощью псевдонима типа.</li>
      </ul>
    </li>
  </ol>
</article>


<!-- module-4 Сводка и ресурсы -->
<article class="article">
  <h2>Урок 9 из 9. Сводка и ресурсы. 2 мин</h2>

  <p>Теперь, когда вы изучили этот модуль, вы можете:</p>
  <ul>
    <li>Объяснять преимущества использования типов в функциях.</li>
    <li>Писать функции, которые имеют обязательные и необязательные параметры, параметры по умолчанию и параметры rest.</li>
    <li>Определять типы функций с помощью псевдонимов типов или интерфейсов.</li>
  </ul>

  <h3>Ресурсы</h3>
  <p>Воспользуйтесь этими ресурсами, чтобы узнать больше.</p>
  <ul>
    <li>Дополнительные сведения о функциях см. в <a href="https://www.typescriptlang.org/docs/handbook/functions.html">руководстве по TypeScript (в разделе о функциях).</a></li>
    <li>Дополнительные сведения о типах функций см. в <a href="https://www.typescriptlang.org/docs/handbook/interfaces.html">руководстве по TypeScript (в разделе об интерфейсах)</a></li>
  </ul>
</article>


<!-- module-5 -->
<article class="article">
  <div class="anchor" id="module-5"></div>
  <h2>Модуль 5. Getting Started with TypeScript. Объявление классов и создание их экземпляров в TypeScript. 1 ч 7 мин</h2>

  <p><a href="https://learn.microsoft.com/api/achievements/share/ru-ru/frontend200tb-0827/9NSVGVFU?sharingId=6364D7D096225EB9">Значек</a></p>

  <p><a href="https://learn.microsoft.com/en-us/training/modules/typescript-declare-instantiate-classes/">Declare and instantiate classes in TypeScript (en)</a>
  <br><a href="https://learn.microsoft.com/ru-ru/training/modules/typescript-declare-instantiate-classes/">Объявление классов и создание их экземпляров в TypeScript (ru)</a></p>

  <p>1 ч 7 мин Модуль 14 единиц(ы)</p>
  <p>Классы в TypeScript расширяют функциональные возможности ES6, добавляя специальные функции TypeScript, например заметки с типами для членов класса, модификаторы доступа и возможность указания обязательных или необязательных параметров. Еще одним преимуществом языка TypeScript является то, что его можно использовать для разработки с применением классов, а затем при необходимости компилировать результат в код JavaScript, который работает во всех основных браузерах и на всех распространенных платформах.</p>

  <h3>Цели обучения</h3>
  <p>В этом модуле вам предстоит выполнить следующее.</p>
  <ul>
    <li>Объяснить, как использовать классы TypeScript для описания формы объектов.</li>
    <li>Объявить класс с помощью TypeScript.</li>
    <li>Создать экземпляр класса с помощью TypeScript.</li>
    <li>Применить модификаторы доступа к классу.</li>
    <li>Определить статические свойства в классе.</li>
    <li>Объявить класс, расширяющий другой класс.</li>
    <li>Объявить интерфейс, чтобы точно задать форму класса.</li>
    <li>Определить, когда следует использовать интерфейс или класс для определения структуры объекта.</li>
  </ul>

  <h3>Предварительные требования</h3>
  <ul>
    <li>Знание TypeScript</li>
    <li>Опыт работы с JavaScript</li>
    <li>Опыт работы с функциями, интерфейсами и классами TypeScript</li>
    <li>Установленное программное обеспечение:
      <ul>
        <li>Git</li>
        <li>Visual Studio Code</li>
        <li>Node.js</li>
        <li>TypeScript</li>
      </ul>
    </li>
  </ul>

  <h3>Этот модуль входит в состав указанных схем обучения</h3>
  <p>Создание приложений JavaScript с помощью TypeScript</p>
  <p>Введение 2 мин</p>
  <p>Общие сведения о классах в TypeScript 5 мин</p>
  <p>Упражнение. Создание класса 5 мин</p>
  <p>Упражнение. Создание экземпляра класса 5 мин</p>
  <p>Модификаторы доступа 5 мин</p>
  <p>Упражнение. Применение модификаторов доступа к классу 2 мин</p>
  <p>Определение статических свойств 2 мин</p>
  <p>Расширение класса с помощью наследования 2 мин</p>
  <p>Упражнение. Расширение класса 5 мин</p>
  <p>Упражнение. Объявление интерфейса для точного определения формы класса 5 мин</p>
  <p>Рекомендации по проектированию 5 мин</p>
  <p>Задание. Преобразование трех функций TypeScript в определение класса 20 мин</p>
  <p>Проверка знаний 2 мин</p>
  <p>Итоги 2 мин</p>
</article>


<!-- module-5 Введение -->
<article class="article">
  <h2>Урок 1 из 14. Введение. 2 мин</h2>
</article>


<!-- module-6 -->
<article class="article">
  <div class="anchor" id="module-6"></div>
  <h2>Модуль 6. Getting Started with TypeScript. Начало работы с TypeScript. 36 мин</h2>

  <p><a href="https://learn.microsoft.com/api/achievements/share/ru-ru/frontend200tb-0827/FZUB8HQX?sharingId=6364D7D096225EB9">Значек</a></p>

  <p><a href="https://learn.microsoft.com/en-us/training/modules/typescript-generics/">Define generics in TypeScript (en)</a>
  <br><a href="https://learn.microsoft.com/ru-ru/training/modules/typescript-generics/">Определение generics в TypeScript (ru)</a></p>

  <p>46 мин Модуль 8 единиц(ы)</p>
</article>


<!-- module-7 -->
<article class="article">
  <div class="anchor" id="module-7"></div>
  <h2>Модуль 7. Access external libraries from TypeScript. Доступ к внешним библиотекам из TypeScript. 46 мин</h2>

  <p><a href="https://learn.microsoft.com/api/achievements/share/ru-ru/frontend200tb-0827/24XG7SLV?sharingId=6364D7D096225EB9">Значек</a></p>

  <p><a href="https://learn.microsoft.com/en-us/training/modules/typescript-work-external-libraries/">Access external libraries from TypeScript (en)</a>
  <br><a href="https://learn.microsoft.com/ru-ru/training/modules/typescript-work-external-libraries/">Доступ к внешним библиотекам из TypeScript (ru)</a></p>

  <p>46 мин Модуль 8 единиц(ы)</p>
</article>


<!-- module-8 -->
<article class="article">
  <div class="anchor" id="module-8"></div>
  <h2>Модуль 8. Getting Started with TypeScript. Упорядочение кода с помощью пространств имен TypeScript. 46 мин</h2>

  <p><a href="https://learn.microsoft.com/api/achievements/share/ru-ru/frontend200tb-0827/VKY6ZFNM?sharingId=6364D7D096225EB9">Значек</a></p>

  <p><a href="https://learn.microsoft.com/en-us/training/modules/typescript-namespaces-organize-code/">Organize code using TypeScript namespaces (en)</a>
  <br><a href="https://learn.microsoft.com/ru-ru/training/modules/typescript-namespaces-organize-code/">Упорядочение кода с помощью пространств имен TypeScript (ru)</a></p>

  <p>46 мин Модуль 8 единиц(ы)</p>
</article>