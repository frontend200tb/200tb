<h1>String</h1>

<!-- Заголовок -->
<div class="article">
  <div class="anchor" id="content"></div>
  <h2>Содержание</h2>
</div>

<!-- Содержание -->
<div class="article article__content">

  <div>
    <p><a href="#links">links</a></p>
    <p><a href="#string">string</a></p>
    <p><a href="#methods">Методы строк</a></p>
  </div>

</div>

<!-- links-->
<article class="article">
  <div class="anchor" id="links"></div>
  <h2>links</h2>

  <p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String">developer.mozilla.org/String</a></p>
  <p><a href="https://learn.javascript.ru/string">learn.javascript.ru/string</a></p>
  <p><a href="https://doka.guide/js/string/">doka.guide/js/string</a></p>
  <p><a href="https://jsexpert.net/handbook/javascript/string/">jsexpert.net/handbook/javascript/string</a></p>
  <p><a href="https://metanit.com/web/javascript/6.1.php">metanit.com</a></p>
</article>

<!-- string-->
<article class="article">
  <div class="anchor" id="string"></div>
  <h2>Строка (тип данных string) в Javascript</h2>

  <h3>Строковый литерал</h3>
  <p>Строковый литерал можно записать одним из трех способов</p>
  <code>'qwerty' // в одинарных кавычках
    <br>"asdfg" // в двойных кавычках
    <br>`zxcvb` // в обратных кавычках</code>
    
  <h3>Состав строки</h3>
  <p>Внутри строки можно использовать три вида символов</p>
  <code>'qwerty' // обычные символы (буквы, цифры и т.д.)
    <br>'\n\t' // escape-последовательности (\n новая строка, \t табуляция)
    <br>'\u0056\u0179\u2190' // unicode символы (\u0056 V, \u0179 Ź, u2190 ←)
  </code>
  <p>Escape-последовательность это обратный слеш (\) за которым пишется буква или цифры. Рассматривается как один символ и является допустимой символьной константой. Обычно используется для указания действий, например возврата каретки или табуляции, на терминалах и принтерах.</p>
  
  <h3>1. Какой тип данных у строки</h3>
  <p>Есть два типа строк: строки примитивного типа и строки типа объект (String Object).</p>

  <h3>2. Как создать строку примитивного типа</h3>
  <p>Строковые примитивы это строковые литералы и строки, возвращенные вызовом String без ключевого слова new.</p>

  <p>Инициализируем примитивную строку. Присваиваем переменной литерал строки.</p>
  <code>const a = 'Frontend';</code>

  <p>Инициализируем примитивную строку. Присваиваем переменной результат работы глобального объекта String</p>
  <code>const b = String('Backend');</code>

  <h3>Как проверить что перед нами строка примитивного типа</h3>
  <p>Оператор typeof должен вернуть значение 'string'.</p>
  <code>typeof a;
  <br>'string'</code>
  <code>typeof b;
  <br>'string'</code>

  <h3>3. Как создать строку String Object</h3>
  <p>Инициализируем String Object. Вызываем конструктор нового объекта через ключевое слово new и в качестве параметра передаем в конструктор литерал строки.</p>
  <code>const c = new String('Fullstack');</code>
  <p>Методы и свойства String Objects доступны для всех строк. Если методы и свойства нужно вызвать на примитивном типе, то JavaScript осуществляет конвертацию строки в объект и обратно каждый раз, когда вызывается метод или свойство.</p>

  <h3>Как проверить что перед нами строка типа String Object</h3>
  <p>Оператор typeof должен вернуть значение 'object'. Оператор instanceof String должен вернуть значение true.</p>
  <code>typeof c;
  <br>'object'</code>
  <code>c instanceof String;
  <br>true</code>

  <h3>4. Как преобразовать строку примитивного типа в String Object</h3>
  <p>JavaScript автоматически преобразует примитивы в объекты String, так что на строковых примитивах возможно использовать методы объекта String.</p>

  <p>В контекстах, когда на примитивной строке вызывается метод или происходит поиск свойства, JavaScript автоматически оборачивает строковый примитив объектом и вызывает на нём метод или ищет в нём свойство.</p>

  <h3>5. Как преобразовать объект String в строковый примитив</h3>
  <p>Объект String также всегда может быть преобразован в его примитивный аналог при помощи метода valueOf().</p>

  <h3>6. Как индексируется строка</h3>
  <p>Каждый символ строки соответствует индексу, начиная с 0.</p>

  <h3>7. Как получить доступ к символу строки</h3>
  <p>Используя квадратные скобки, можно получить доступ к любому символу строки.</p>
  <code>'Frontend'[4];
  <br>t</code>
  </code>

  <h3>8. Как изменить строку</h3>
  <p>Строки неизменяемы. Содержимое строки в JavaScript нельзя изменить. Нельзя взять символ посередине и заменить его. Как только строка создана — она такая навсегда.</p>
  <code>let str = 'Frontend';
  <br>str[0] = 'f'; // ошибка</code>
  <p>Можно создать новую строку и записать ее в ту же самую переменную.</p>
  <code>let str = 'Frontend'
  <br>str = str.toUpperCase(); // 'FRONTEND'</code>
</article>

<article class="article">
  <h3>8. Свойства строк</h3>
  <p>Строки имеют только одно свойство - length.</p>

  <table>
    <tr>
      <td>1</td>
      <th>constructor</th>
      <td>Возвращает функцию конструктор строки <strong>function String() { [native code] }</strong></td>
    </tr>
    <tr>
      <td>2</td>
      <th>length</th>
      <td>Возвращает количество символов в строке</td>
    </tr>
    <tr>
      <td>3</td>
      <th>prototype</th>
      <td>Возвращает ссылку на объект String.prototype. Позволяет добавлять новые свойства и методы к объекту String().</td>
    </tr>
  </table>
</article>

<article class="article">
  <h3>Свойство constructor</h3>
  <p><em>(Возвращает <strong>function</strong>)</em></p>
  <p><em>(Появился в <strong>ES1</strong>)</em></p>
  <p>Свойство constructor у строки возвращает функцию, которая создала прототип строки <strong>function String() { [native code] }</strong></p>
  <code>let a = 'aaa';
  <br>a.constructor
  <br>f String() { [native code] }</code>
  <code>let b = new String('bbb');
  <br>b.constructor
  <br>f String() { [native code] }</code>
</article>

<article class="article">
  <h3>Свойство length</h3>
  <p><em>(Возвращает <strong>number</strong>)</em></p>
  <p><em>(Появился в <strong>ES1</strong>)</em></p>
  <p>Возвращает количество символов в строке</p>
  <code>'Frontend'.length
  <br>8</code>
  <code>a = 'Front';
  <br>b = a.length;</code>
  <p>Свойство length не изменяет исходную строку</p>
  <code>console.log(a); // 'Front'</code>
  <p>Свойство length возвращает number</p>
  <code>console.log(b); // 4</code>
</article>

<article class="article">
  <h3>Свойство prototype</h3>
  <p><em>(Возвращает <strong>String.prototype</strong>)</em></p>
  <p><em>(Появился в <strong>ES1</strong>)</em></p>
  <p>Ссылка на объект String.prototype</p>
</article>

<!-- Методы строк-->
<article class="article">
  <div class="anchor" id="methods"></div>
  <h3>9. Методы строк</h3>
  <p>Методы строк не изменяют исходную строку.</p>
  <p>Методы объекта String, записанные в его прототипе String.prototype.</p>
  <table>
    <tr>
      <td>1</td>
      <th><a href="#string-at">at()</a></th>
      <td>Возвращает символ по его индексу в строке. Возвращает <strong>string</strong></td>
    </tr>
    <tr>
      <td>2</td>
      <th><a href="#string-char-at">charAt()</a></th>
      <td>Возвращает символ по его индексу в строке. Возвращает <strong>string</strong></td>
    </tr>
    <tr>
      <td>3</td>
      <th><a href="#string-char-code-at">charCodeAt()</a></th>
      <td>Возвращает Unicode (целое число между 0 и 65535) символа по его индексу в строке. Возвращает <strong>number</strong></td>
    </tr>
    <tr>
      <td>4</td>
      <th><a href="#string-code-point-at">codePointAt()</a></th>
      <td>Возвращает Unicode (целое число между 0 и 65535) символа по его индексу в строке. Возвращает <strong>number</strong></td>
    </tr>
    <tr>
      <td>5</td>
      <th><a href="#string-concat">concat()</a></th>
      <td>Объединяет переданные в параметрах строки с исходной строкой и возвращает объединенную строку. Возвращает <strong>string</strong></td>
    </tr>
    <tr>
      <td>6</td>
      <th><a href="#string-ends-with">endsWith()</a></th>
      <td>Возвращает true если строка оканчивается на указанную подстроку. Возвращает <strong>boolean</strong></td>
    </tr>
    <tr>
      <td>7</td>
      <th><a href="#string-from-char-code">String.fromCharCode()</a></th>
      <td>Преобразует значения Unicode в символы. Возвращает <strong>string</strong></td>
    </tr>
    <tr>
      <td>8</td>
      <th><a href="#string-from-code-point">String.fromCodePoint()</a></th>
      <td>Возвращает строку, созданную из указанной последовательности кодовых точек. Возвращает <strong>string</strong></td>
    </tr>
    <tr>
      <td>9</td>
      <th><a href="#string-includes">includes()</a></th>
      <td>Возвращает true если строка содержит указанную подстроку. Возвращает <strong>boolean</strong></td>
    </tr>
    <tr>
      <td>10</td>
      <th><a href="#string-index-of">indexOf()</a></th>
      <td>Возвращает индекс первого вхождения в строке. Возвращает <strong>number</strong></td>
    </tr>
    <tr>
      <td>11</td>
      <th><a href="#string-is-well-formed">isWellFormed()</a></th>
      <td>returns a boolean indicating whether this string contains any lone surrogates.</td>
    </tr>
    <tr>
      <td>12</td>
      <th><a href="#string-last-index-of">lastIndexOf()</a></th>
      <td>Возвращает индекс последнего вхождения в строке</td>
    </tr>
    <tr>
      <td>13</td>
      <th><a href="#string-locale-compare">localeCompare()</a></th>
      <td>Возвращает 1, 0, -1 как результат сравнения двух строк</td>
    </tr>
    <tr>
      <td>14</td>
      <th><a href="#string-match">match()</a></th>
      <td>Ищет строку для соответствия регулярному выражению и возвращает совпадения</td>
    </tr>
    <tr>
      <td>15</td>
      <th><a href="#string-match-all">matchAll()</a></th>
      <td>возвращает итератор по всем результатам при сопоставлении строки с регулярным выражением</td>
    </tr>
    <tr>
      <td>16</td>
      <th><a href="#string-normalize">normalize()</a></th>
      <td>возвращает форму нормализации Юникода данной строки</td>
    </tr>
    <tr>
      <td>17</td>
      <th><a href="#string-pad-end">padEnd()</a></th>
      <td>Добавление символов в конец строки</td>
    </tr>
    <tr>
      <td>18</td>
      <th><a href="#string-pad-start">padStart()</a></th>
      <td>Добавление символов в начало строки</td>
    </tr>
    <tr>
      <td>19</td>
      <th><a href="#string-raw">String.raw()</a></th>
      <td>используется для получения необработанной строки из шаблона</td>
    </tr>
    <tr>
      <td>20</td>
      <th><a href="#string-repeat">repeat()</a></th>
      <td>Возвращает строку, повторяющую исходную указанное количество раз</td>
    </tr>
    <tr>
      <td>21</td>
      <th><a href="#string-replace">replace()</a></th>
      <td>Заменяет указанное значение (первое вхождение) в строке</td>
    </tr>
    <tr>
      <td>22</td>
      <th><a href="#string-replace-all">replaceAll()</a></th>
      <td>Заменяет указанное значение (все вхождения) в строке</td>
    </tr>
    <tr>
      <td>23</td>
      <th><a href="#string-search">search()</a></th>
      <td></td>
    </tr>
    <tr>
      <td>24</td>
      <th><a href="#string-search">slice()</a></th>
      <td>Извлечение подстроки</td>
    </tr>
    <tr>
      <td>25</td>
      <th><a href="#string-search">split()</a></th>
      <td>Разбиение строк</td>
    </tr>
    <tr>
      <td>26</td>
      <th><a href="#string-starts-with">startsWith()</a></th>
      <td></td>
    </tr>
    <tr>
      <td>27</td>
      <th><a href="#string-starts-with">substring()</a></th>
      <td>Извлечение подстроки</td>
    </tr>
    <tr>
      <td>28</td>
      <th><a href="#string-to-local-lower-case">toLocaleLowerCase()</a></th>
      <td></td>
    </tr>
    <tr>
      <td>29</td>
      <th><a href="#string-to-local-upper-case">toLocaleUpperCase()</a></th>
      <td></td>
    </tr>
    <tr>
      <td>30</td>
      <th><a href="#string-to-lower-case">toLowerCase()</a></th>
      <td>Преобразует все символы в нижний регистр</td>
    </tr>
    <tr>
      <td>31</td>
      <th><a href="#string-to-string">toString()</a></th>
      <td></td>
    </tr>
    <tr>
      <td>32</td>
      <th><a href="#string-to-upper-case">toUpperCase()</a></th>
      <td>Преобразует все символы в верхний регистр</td>
    </tr>
    <tr>
      <td>33</td>
      <th><a href="#string-to-well-formed">toWellFormed()</a></th>
      <td>returns a string where all lone surrogates of this string are replaced with the Unicode replacement character U+FFFD.</td>
    </tr>
    <tr>
      <td>34</td>
      <th><a href="#string-trim">trim()</a></th>
      <td>Отсечение пробелов в начале и конце строки</td>
    </tr>
    <tr>
      <td>35</td>
      <th><a href="#string-trim-end">trimEnd()</a></th>
      <td>Отсечение пробелов в конце строки</td>
    </tr>
    <tr>
      <td>36</td>
      <th><a href="#string-trim-start">trimStart()</a></th>
      <td>Отсечение пробелов в начале строки</td>
    </tr>
    <tr>
      <td>37</td>
      <th><a href="#string-value-of">valueOf()</a></th>
      <td></td>
    </tr>
  </table>
</article>

<!-- 1. at() -->
<article class="article">
  <div class="anchor" id="string-at"></div>
  <h3>Метод at()</h3>
  <p><em>(Возвращает <strong>string</strong>)</em></p>
  <p><em>(Появился в <strong>es2022</strong>)</em></p>
  <p><strong>Метод at(index) возвращает символ</strong> по его индексу в строке если index - целое число от нуля до длины строки - 1</p>
  <p>Возвращает символ по его позиции начиная с конца строки если index - целое отрицательное число от -1 до длины строки - 1</p>
  <p>Возвращает undefined если index выходит за пределы этого диапазона</p>
  <p>Метод at() лучше чем charAt() тем что работает еще и с отрицательными индексами</p>
  <code>'abcde'.at(0);
  <br>a</code>
  <code>'abcde'.at(4);
  <br>e</code>
  <code>'abcde'.at(5);
  <br>undefined</code>
  <code>'abcde'.at(-1);
  <br>e</code>
  <code>'abcde'.at(-5);
  <br>a</code>
  <h3>Метод at(). Особенности</h3>
  <p>Если в качестве параметра приходит дробное число, то дробная часть отбрасывается</p>
  <code>'abcde'.at(3.9999);
  <br>d</code>
  <p>Если в качестве параметра приходит число в виде строки, то она преобразуется в число</p>
  <code>'abcde'.at('2');
  <br>c</code>
  <p>Возвращает первый символ строки в следующих случаях:</p>
  <code>'abcde'.at();
  <br>a</code>
  <code>'abcde'.at(0);
  <br>a</code>
  <code>'abcde'.at(false);
  <br>a</code>
  <code>'abcde'.at('');
  <br>a</code>
  <code>'abcde'.at('anystring');
  <br>a</code>
  <code>'abcde'.at(null);
  <br>a</code>
  <code>'abcde'.at(undefined);
  <br>a</code>
  <code>'abcde'.at(NaN);
  <br>a</code>
  <p>Возвращает второй символ строки в следующих случаях:</p>
  <code>'abcde'.at(true);
  <br>b</code>
  <h3>Отличие между at() и charAt()</h3>
  <p>1. at() это новый улучшенный метод, позволяет использовать отрицательные числа для поиска от конца строки
  <br>2.  если index выходит за пределы диапазона, то at() возвращает undefined, charAt() возвращает пустую строку</p>
</article>

<!-- 2. charAt() -->
<article class="article">
  <div class="anchor" id="string-char-at"></div>
  <h3>Метод charAt()</h3>
  <p><em>(Возвращает <strong>string</strong>)</em></p>
  <p><em>(Появился в <strong>ES1</strong>)</em></p>
  <p><strong> Метод charAt(index) возвращает символ</strong> по его индексу в строке если index - целое число от нуля до длины строки - 1</p>
  <p>Возвращает пустую строку если index выходит за пределы строки</p>
  <code>'abcde'.charAt(0);
  <br>a</code>
  <code>'abcde'.charAt(4);
  <br>e</code>
  <code>'abcde'.charAt(-1);
  <br>''</code>
  <code>'abcde'.charAt(5);
  <br>''</code>
  <h3>Метод charAt(). Особенности</h3>
  <p>Если в качестве параметра приходит дробное число, то дробная часть отбрасывается</p>
  <code>'abcde'.charAt(3.9999);
  <br>d</code>
  <p>Если в качестве параметра приходит число в виде строки, то она преобразуется в число</p>
  <code>'abcde'.charAt('2');
  <br>c</code>
  <p>Возвращает первый символ строки в следующих случаях:</p>
  <code>'abcde'.charAt();
  <br>a</code>
  <code>'abcde'.charAt(0);
  <br>a</code>
  <code>'abcde'.charAt(false);
  <br>a</code>
  <code>'abcde'.charAt('');
  <br>a</code>
  <code>'abcde'.charAt('anystring');
  <br>a</code>
  <code>'abcde'.charAt(null);
  <br>a</code>
  <code>'abcde'.charAt(undefined);
  <br>a</code>
  <code>'abcde'.charAt(NaN);
  <br>a</code>
  <p>Возвращает второй символ строки в следующих случаях:</p>
  <code>'abcde'.charAt(true);
  <br>b</code>
</article>

<!-- 3. charCodeAt() -->
<article class="article">
  <div class="anchor" id="string-char-code-at"></div>
  <h3>Метод charCodeAt()</h3>
  <p><em>(Возвращает <strong>number</strong>)</em></p>
  <p><em>(Появился в <strong>ES1</strong>)</em></p>
  <p><strong>Метод charCodeAt возвращает Unicode символа</strong> (целое число между 0 и 65535) по его индексу в строке.</p>
  <p>Возвращает NaN если index выходит за пределы строки</p>
  <code>'ABCDE'.charCodeAt(0);
  <br>65</code>
  <code>'ABCDE'.charCodeAt(4);
  <br>69</code>
  <code>'ABCDE'.charCodeAt(5);
  <br>NaN</code>
  <code>'ABCDE'.charCodeAt(-1);
  <br>NaN</code>
  <h3>Метод charCodeAt(). Особенности</h3>
  <p>Если в качестве параметра приходит дробное число, то дробная часть отбрасывается</p>
  <code>'ABCDE'.charCodeAt(0.9999);
  <br>65</code>
  <p>Если в качестве параметра приходит число в виде строки, то она преобразуется в число</p>
  <code>'ABCDE'.charCodeAt('2');
  <br>67</code>
  <p>Возвращает Unicode первого символа строки в следующих случаях:</p>
  <code>'ABCDE'.charCodeAt();
  <br>65</code>
  <code>'ABCDE'.charCodeAt(0);
  <br>65</code>
  <code>'ABCDE'.charCodeAt(false);
  <br>65</code>
  <code>'ABCDE'.charCodeAt('');
  <br>65</code>
  <code>'ABCDE'.charCodeAt('anystring');
  <br>65</code>
  <code>'ABCDE'.charCodeAt(null);
  <br>65</code>
  <code>'ABCDE'.charCodeAt(undefined);
  <br>65</code>
  <code>'ABCDE'.charCodeAt(NaN);
  <br>65</code>
  <p>Возвращает второй символ строки в следующих случаях:</p>
  <code>'ABCDE'.charCodeAt(true);
  <br>66</code>
  <h3>Отличие между charCodeAt() и codePointAt()</h3>
  <p>Внутренняя кодировка строк в JavaScript – это UTF-16, то есть под каждый символ отводится ровно два байта.</p>
  <p>Но под всевозможные символы всех языков мира 2 байт не хватает. Поэтому бывает так, что одному символу языка соответствует два Юникодных символа (итого 4 байта). Такое сочетание называют «суррогатной парой»</p>
  <p>Заметим, однако, что не всякий китайский иероглиф – суррогатная пара. Китайскими иероглифами суррогатные пары, естественно, не ограничиваются. Ими представлены редкие математические символы, а также некоторые символы для эмоций.</p>
  <p>В современный JavaScript добавлены методы String.fromCodePoint и str.codePointAt – аналоги String.fromCharCode и str.charCodeAt, корректно работающие с суррогатными парами.</p>
</article>

<!-- 4. codePointeAt() -->
<article class="article">
  <div class="anchor" id="string-code-pointe-at"></div>
  <h3>Метод codePointAt()</h3>
  <p><em>(Возвращает <strong>number</strong>)</em></p>
  <p><em>(Появился в <strong>es6</strong>)</em></p>
  <p><strong>Метод charCodeAt возвращает Unicode символа</strong> (целое число между 0 и 65535) по его индексу в строке.</p>
  <p>Возвращает undefined если index выходит за пределы строки</p>
  <p>Метод codePointAt() лечше чем charCodeAt() тем что работает еще и с суррогатными парами</p>
  <code>'ABCDE'.codePointAt(0);
  <br>65</code>
  <code>'ABCDE'.codePointAt(4);
  <br>69</code>
  <code>'ABCDE'.codePointAt(5);
  <br>undefined</code>
  <code>'ABCDE'.codePointAt(-1);
  <br>undefined</code>
  <h3>Метод codePointAt(). Особенности</h3>
  <p>Если в качестве параметра приходит дробное число, то дробная часть отбрасывается</p>
  <code>'ABCDE'.codePointAt(0.9999);
  <br>65</code>
  <p>Если в качестве параметра приходит число в виде строки, то она преобразуется в число</p>
  <code>'ABCDE'.codePointAt('2');
  <br>67</code>
  <p>Возвращает первый символ строки в следующих случаях:</p>
  <code>'ABCDE'.codePointAt();
  <br>65</code>
  <code>'ABCDE'.codePointAt(0);
  <br>65</code>
  <code>'ABCDE'.codePointAt(false);
  <br>65</code>
  <code>'ABCDE'.codePointAt('');
  <br>65</code>
  <code>'ABCDE'.codePointAt('anystring');
  <br>65</code>
  <code>'ABCDE'.codePointAt(null);
  <br>65</code>
  <code>'ABCDE'.codePointAt(undefined);
  <br>65</code>
  <code>'ABCDE'.codePointAt(NaN);
  <br>65</code>
  <p>Возвращает второй символ строки в следующих случаях:</p>
  <code>'ABCDE'.charAt(true);
  <br>66</code>
</article>

<!-- 5. concat() -->
<article class="article">
  <div class="anchor" id="string-concat"></div>
  <h3>Метод concat()</h3>
  <p><em>(Возвращает <strong>string</strong>)</em></p>
  <p><em>(Появился в <strong>ES1</strong>)</em></p>
  <p>Без параметров возвращает ту же самую строку</p>
  <code>'abcde'.concat();
  <br>abcde</code>
  <p>С одним или более параметрами преобразуют каждый параметр в строку и по очереди добавляют в конец исходной строки, возвращая новую строку</p>
  <code>'abcde'.concat(1234);
  <br>abcde1234</code>
  <code>'abcde'.concat('Backend', 123, null, NaN, '', undefined, Infinity);
  <br>abcdeBackend123nullNaNundefinedInfinity</code>
</article>

<!-- 6. endsWith() -->
<article class="article">
  <div class="anchor" id="string-ends-with"></div>
  <h3>Метод endsWith()</h3>
  <p><em>(Возвращает <strong>boolean</strong>)</em></p>
  <p><em>(Появился в <strong>ES6</strong>)</em></p>
  <p>Метод endsWith проверяет, заканчивается ли строка на указанную в первом параметре подстроку. Если заканчивается, то возвращает true, а если не заканчивается, то false. Вторым необязательным параметром можно принудительно указать длину строки. В этом случае проверка будет не настоящего конца строки, а указанного.</p>
</article>

<!-- 7. String.fromCharCode() -->
<article class="article">
  <div class="anchor" id="string-from-char-code"></div>
  <h3>Метод String.fromCharCode()</h3>
  <p><em>(Возвращает <strong>string</strong>)</em></p>
  <p><em>(Появился в <strong>ES1</strong>)</em></p>
  <p>Преобразует числовые значения Юникода UTF-16 от 0 до 65535 (0xFFFF) в читаемые символы. Числа больше 0xFFFF усекаются</p>
  <code>String.fromCharCode(72, 101, 108, 108, 11);
  <br>'Hello'</code>
</article>

<!-- 8. String.fromCodePoint() -->
<article class="article">
  <div class="anchor" id="string-from-code-point"></div>
  <h3>Метод String.fromCodePoint()</h3>
  <p><em>(Возвращает <strong>string</strong>)</em></p>
  <p><em>(Появился в <strong>ES6</strong>)</em></p>
  <p>Возвращает строку, созданную из указанной последовательности кодовых точек</p>
  <code>String.fromCodePoint(65, 90);
  <br>'AZ'</code>
</article>

<!-- 9. includes() -->
<article class="article">
  <div class="anchor" id="string-includes"></div>
  <h3>Метод includes()</h3>
  <p><em>(Возвращает <strong>boolean</strong>)</em></p>
  <p><em>(Появился в <strong>ES6</strong>)</em></p>
  <p>Метод includes выполняет поиск заданной строки в текущей с учетом регистра. Первым параметром метод принимает строку, которую нужно найти, вторым необязательным - позицию, с которой нужно начинать поиск. После выполнения метод возвращает true или false.</p>
</article>

<!-- 10. indexOf() -->
<article class="article">
  <div class="anchor" id="string-index-of"></div>
  <h3>Метод indexOf()</h3>
  <p><em>(Возвращает <strong>number</strong>)</em></p>
  <p><em>(Появился в <strong>ES1</strong>)</em></p>
  <p>Методы indexOf() и lastIndexOf() принимают символ или строку, возвращают индекс.</p>
  <p>Возвращает индекс первого вхождения в строке</p>
  <code>'Frontend'.indexOf('n');
  <br>3</code>
  <code>'Frontend'.indexOf('ont');
  <br>2</code>
  <code>a = 'Frontend';
  <br>b = a.indexOf('n');</code>
  <p>Метод indexOf() не изменяет исходную строку</p>
  <code>console.log(a); // 'Frontend'</code>
  <p>Метод indexOf() возвращает number</p>
  <code>console.log(b); // 3</code>
</article>

<!-- 11. isWellFormed() -->
<article class="article">
  <div class="anchor" id="string-is-well-formed"></div>
  <h3>Метод isWellFormed()</h3>
  <p><em>(Появился в <strong>ES2024</strong>)</em></p>
  <p>Значения строк в ECMAScript представляют собой последовательность из 16-битных беззнаковых целочисленных значений.</p>
  <p>В правильно сформированных строках каждое целочисленное значение в последовательности представляет собой отдельную единицу UTF-16 юникодного текста. Однако не все последовательности представляют собой UTF-16 юникодный текст.</p>

  <p>Также в правильно сформированных строках кодовые единицы в диапазоне от 0xD800 до 0xDBFF (ведущие суррогаты) и от 0xDC00 до 0xDFFF (заключительные суррогаты) должны появляться парами и по порядку. Строки с непарными или неправильно упорядоченными суррогатами считаются неправильно сформированными.</p>
    
  <p>Новый стандарт предлагает ввести метода для проверки, является ли строка правильно сформированной. Метод должен улучшить производительность и увеличит понятность для читателей кода.</p>
</article>

<!-- 12. lastIndexOf() -->
<article class="article">
  <div class="anchor" id="string-last-index-of"></div>
  <h3>Метод lastIndexOf()</h3>
  <p><em>(Возвращает <strong>number</strong>)</em></p>
  <p><em>(Появился в <strong>ES1</strong>)</em></p>
  <p>Методы indexOf() и lastIndexOf() принимают символ или строку, возвращают индекс.</p>
  <p>Возвращает индекс последнего вхождения символа в строке</p>
  <code>"Frontend".lastIndexOf('n');
  <br>6</code>
  <code>a = 'Frontend';
  <br>b = a.lastIndexOf('n');</code>
  <p>Метод indexOf() не изменяет исходную строку</p>
  <code>console.log(a); // 'Frontend'</code>
  <p>Метод indexOf() возвращает number</p>
  <code>console.log(b); // 6</code>
</article>

<!-- 13. localeCompare() -->
<article class="article">
  <div class="anchor" id="string-locale-compare"></div>
  <h3>Метод localeCompare()</h3>
  <p><em>(Возвращает <strong>number</strong>)</em></p>
  <p><em>(Появился в <strong>ES1</strong>)</em></p>
  <p>Метод localeCompare() сравнивает две строки в текущей локали. Локаль основана на настройках языка браузера.</p>
  <code>string.localeCompare(compareString)</code>
  <p>Возвращает одно из трех значений:
  <br>-1, если строка сортируется до compareString
  <br>0, если две строки равны
  <br>1, если строка сортируется после compareString
  </p>
</article>

<!-- 14. match() -->
<article class="article">
  <div class="anchor" id="string-match"></div>
  <h3>Метод match()</h3>
  <p><em>(Появился в <strong>ES1</strong>)</em></p>
  <p>Метод match() ищет строку для соответствия регулярному выражению и возвращает совпадения в качестве объекта Array.</p>
</article>

<!-- 15. matchAll() -->
<article class="article">
  <div class="anchor" id="string-match-all"></div>
  <h3>Метод matchAll()</h3>
  <p>возвращает итератор по всем результатам при сопоставлении строки с регулярным выражением</p>
</article>

<!-- 16. normalize() -->
<article class="article">
  <div class="anchor" id="string-normalize"></div>
  <h3>Метод normalize()</h3>
  <p>возвращает форму нормализации Юникода данной строки</p>
</article>

<!-- 17. padEnd() -->
<article class="article">
  <div class="anchor" id="string-pad-end"></div>
  <h3>Метод padEnd(num [, str])</h3>
  <p>Возвращает новую строку указанной длины num. Если исходная строка была длинее, то она возвращается без изменений.</p>
  <code>"Frontend".padEnd(5);
  <br>“Frontend”</code>
  <p>Без второго параметра добавляет в конце пробелы до указанной длины строки.</p>
  <code>"Frontend".padEnd(10);
  <br>“Frontend  ”</code>
  <p>Второй необязательный параметр str это строка, которую надо добавить в конце до указанной длины строки.</p>
  <code>"Frontend".padEnd(10, “*”);
  <br>“Frontend**”</code>
  <p>Если str слишком длинная, то она обрезается.</p>
  <code>"Frontend".padEnd(10, “vue”);
  <br>“Frontendvu”</code>
  <p>Если str слишком короткая, то она повторяется.</p>
  <code>"Frontend".padEnd(20, “vue”);
  <br>"Frontendvuevuevuevue"</code>
</article>

<!-- 18. padStart() -->
<article class="article">
  <div class="anchor" id="string-pad-start"></div>
  <h3>Метод padStart(num [, str])</h3>
  <p>Возвращает новую строку указанной длины num. Если исходная строка была длинее, то она возвращается без изменений.</p>
  <code>"Frontend".padStart(5);
  <br>“Frontend”</code>
  <p>Без второго параметра добавляет в начале пробелы до указанной длины строки.</p>
  <code>"Frontend".padStart(10);
  <br>“  Frontend”</code>
  <p>Второй необязательный параметр str это строка, которую надо добавить в начале до указанной длины строки.</p>
  <code>"Frontend".padStart(10, “*”);
  <br>“**Frontend”</code>
  <p>Если str слишком длинная, то она обрезается.</p>
  <code>"Frontend".padStart(10, “vue”);
  <br>“vuFrontend”</code>
  <p>Если str слишком короткая, то она повторяется.</p>
  <code>"Frontend".padStart(20, “vue”);
  <br>"vuevuevuevueFrontend"</code>
</article>

<!-- 19. String.raw() -->
<article class="article">
  <div class="anchor" id="string-raw"></div>
  <h3>Метод String.raw()</h3>
  <p>используется для получения необработанной строки из шаблона</p>
  <code>String.raw`Привет\n${2 + 3}!`;
  <br>'Привет\n5!', символ после 'Привет' не является символом новой строки</code>
</article>

<!-- 20. repeat() -->
<article class="article">
  <div class="anchor" id="string-repeat"></div>
  <h3>Метод repeat()</h3>
  <p><em>(Появился в <strong>ES6</strong>)</em></p>
  <p>Без параметров возвращает пустую строку</p>
  <code>'front'.repeat();
  <br>''</code>
  <p>Если параметр 0 или который при привидении к number дает 0 ('0', NaN, false, null, undefined) возвращает пустую строку</p>
  <code>'front'.repeat(NaN);
  <br>''</code>
  <p>Если параметр 1 или при привидении к number дает 1 ('1', true) возвращает исходную строку</p>
  <code>'front'.repeat(true);
  'front'</code>
  <p>Если параметр число или приводится к числу, возвращает строку, повторяющую исходную указанное количество раз</p>
  <code>'front'.repeat(3);
  'frontfrontfront'</code>
  <code>a = 'front';
  <br>b = a.repeat('3');</code>
  <p>Метод repeat() не изменяет исходную строку</p>
  <code>console.log(a); // 'front'</code>
  <p>Метод repeat() возвращает string</p>
  <code>console.log(b); // 'frontfrontfront'</code>
</article>

<!-- 21. replace() -->
<article class="article">
  <div class="anchor" id="string-replace"></div>
  <h3>Метод replace()</h3>
  <p><em>(Появился в <strong>ES1</strong>)</em></p>
  <p>Ищет в строке указанное значение или регулярное выражение и возвращает новую строку, в которой выполнена замена на второй параметр</p>
  <code>"Frontend".replace(“Front”, “Back”);
  <br>Backend</code>
</article>

<!-- 22. replaceAll() -->
<article class="article">
  <div class="anchor" id="string-replace-all"></div>
  <h3>Метод replaceAll()</h3>
  <p>Заменяет все найденные совпадения другой строкой</p>
  <code>"FrontFrontend".replace(“Front”, “Back”);
  <br>BackBackend</code>
</article>

<!-- 23. search() -->
<article class="article">
  <div class="anchor" id="string-search"></div>
  <h3>Метод search()</h3>
  <p><em>(Появился в <strong>ES1</strong>)</em></p>
</article>

<!-- 24. slice() -->
<article class="article">
  <div class="anchor" id="string-slice"></div>
  <h3>Метод slice()</h3>
  <p><em>(Появился в <strong>ES1</strong>)</em></p>
  <p>Возвращает символы начиная с указанного индекса и до конца строки</p>
  <code>"Frontend".slice(“5”);
  <br>end</code>
  <p>Возвращает символы между двумя индексами</p>
  <code>"Frontend".slice(“5, 7”);
  <br>en</code>
  <p>Можно указывать отрицательные значения</p>
  <code>"Frontend".slice(“-5, -2”);
  <br>nte</code>
</article>

<!-- 25. split() -->
<article class="article">
  <div class="anchor" id="string-split"></div>
  <h3>Метод split()</h3>
  <p><em>(Появился в <strong>ES1</strong>)</em></p>
  <p>Без параметров возвращает массив из одного элемента, содержащего исходную строку</p>
  <code>'Frontend'.split();
  <br>['Frontend']</code>
  <p>Если параметр это пустая строка, то возвращает массив из всех символов исходной строки</p>
  <code>'Frontend'.split('');
  <br>['F', 'r', 'o', 'n', 't', 'e', 'n', 'd']</code>
  <p>Возвращает массив строк из исходной строки по символу переданному в параметрах</p>
  <code>'Front end developer'.split(' ');
  <br>['Front', 'end', 'developer']</code>
  <code>a = 'Frontend';
  <br>b = a.split('');</code>
  <p>Метод split() не изменяет исходную строку</p>
  <code>console.log(a); // 'Frontend'</code>
  <p>Метод split() возвращает array</p>
  <code>console.log(b); // ['F', 'r', 'o', 'n', 't', 'e', 'n', 'd']</code>
</article>

<!-- 26. startsWith() -->
<article class="article">
  <div class="anchor" id="string-starts-with"></div>
  <h3>Метод startsWith()</h3>
  <p><em>(Появился в <strong>ES6</strong>)</em></p>
</article>

<!-- 27. substring() -->
<article class="article">
  <div class="anchor" id="string-substring"></div>
  <h3>Метод substring(indexA [, indexB])</h3>
  <p><em>(Появился в <strong>ES1</strong>)</em></p>
  <p>Если указать только один параметр, то возвращает символы начиная с указанного индекса indexA и до конца строки</p>
  <code>"Frontend". substring(5);
  <br>end</code>
  <p>Если указать два параметра, то возвращает символы между двумя индексами</p>
  <code>"Frontend". substring(5, 7);
  <br>en</code>
  <p>В отличие от slice, можно задавать start больше, чем end. Отрицательные значения не поддерживаются, они интерпретируются как 0.</p>
</article>

<!-- 28. toLocaleLowerCase() -->
<article class="article">
  <div class="anchor" id="string-to-local-lower-case"></div>
  <h3>Метод toLocaleLowerCase()</h3>
  <p><em>(Появился в <strong>ES1</strong>)</em></p>
</article>

<!-- 29. toLocaleUpperCase() -->
<article class="article">
  <div class="anchor" id="string-to-local-upper-case"></div>
  <h3>Метод toLocaleUpperCase()</h3>
  <p><em>(Появился в <strong>ES1</strong>)</em></p>
</article>

<!-- 30. toLowerCase() -->
<article class="article">
  <div class="anchor" id="string-to-lower-case"></div>
  <h3>Метод toLowerCase()</h3>
  <p><em>(Появился в <strong>ES1</strong>)</em></p>
  <p>Не принимает параметры, преобразует все символы в нижний регистр, возвращает новую строку</p>
  <code>'Frontend'.toLowerCase();
  <br>frontend</code>
  <code>a = 'Frontend';
  <br>b = a.toLowerCase();</code>
  <p>Метод toLowerCase() не изменяет исходную строку</p>
  <code>console.log(a); // 'Frontend'</code>
  <p>Метод toLowerCase() возвращает string</p>
  <code>console.log(b); // 'frontend'</code>
</article>

<!-- 31. toString() -->
<article class="article">
  <div class="anchor" id="string-to-string"></div>
  <h3>Метод toString()</h3>
  <p><em>(Появился в <strong>ES1</strong>)</em></p>
  <p>возвращает строку, представляющую указанный объект</p>
  <code>var x = new String("Привет, мир");
  <br>console.log(x.toString()); // Отобразит 'Привет, мир'</code>
</article>

<!-- 32. toUpperCase() -->
<article class="article">
  <div class="anchor" id="string-to-upper-case"></div>
  <h3>Метод toUpperCase()</h3>
  <p><em>(Появился в <strong>ES1</strong>)</em></p>
  <p>Не принимает параметры, преобразует все символы в верхний регистр, возвращает новую строку</p>
  <code>'Frontend'.toUpperCase();
  <br>'FRONTEND'</code>
  <code>a = 'Frontend';
  <br>b = a.toUpperCase();</code>
  <p>Метод toUpperCase() не изменяет исходную строку</p>
  <code>console.log(a); // 'Frontend'</code>
  <p>Метод toUpperCase() возвращает string</p>
  <code>console.log(b); // 'FRONTEND'</code>
</article>

<!-- 33. toWellFormed() -->
<article class="article">
  <div class="anchor" id="string-to-well-formed"></div>
  <h3>Метод toWellFormed()</h3>
</article>

<!-- 34. trim() -->
<article class="article">
  <div class="anchor" id="string-trim"></div>
  <h3>Метод trim()</h3>
  <p><em>(Появился в <strong>ES3</strong>)</em></p>
  <p>Возвращает строку без пробелов в начале и конце строки</p>
  <code>"   Frontend   ".trim();
  <br>“Frontend”</code>
</article>

<!-- 35. trimEnd() -->
<article class="article">
  <div class="anchor" id="string-trim-end"></div>
  <h3>Метод trimEnd()</h3>
  <p>Возвращает строку без пробелов в конце строки</p>
  <code>"   Frontend   ".trimEnd();
  <br>“   Frontend”</code>
</article>

<!-- 36. trimStart() -->
<article class="article">
  <div class="anchor" id="string-trim-start"></div>
  <h3>Метод trimStart()</h3>
  <p>Возвращает строку без пробелов в начале строки</p>
  <code>"   Frontend   ".trimStart();
  <br>“Frontend   ”</code>
</article>

<!-- 37. valueOf() -->
<article class="article">
  <div class="anchor" id="string-value-of"></div>
  <h3>Метод valueOf()</h3>
  <p><em>(Появился в <strong>ES1</strong>)</em></p>
</article>
