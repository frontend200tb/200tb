<h1>String</h1>

<!-- Заголовок -->
<div class="article">
  <div class="anchor" id="content"></div>
  <h2>Содержание</h2>
</div>

<!-- Содержание -->
<div class="article article__content">

  <div>
    <p><a href="#links">links</a></p>
    <p><a href="#string">string</a></p>
    <p><a href="#properties">Свойства строк</a></p>
    <p><a href="#methods">Методы строк</a></p>
  </div>

</div>


<!-- links -->
<article class="article">
  <div class="anchor" id="links"></div>
  <h2>links</h2>

  <p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String">developer.mozilla.org/String</a></p>
  <p><a href="https://learn.javascript.ru/string">learn.javascript.ru/string</a></p>
  <p><a href="https://doka.guide/js/string/">doka.guide/js/string</a></p>
  <p><a href="https://jsexpert.net/handbook/javascript/string/">jsexpert.net/handbook/javascript/string</a></p>
  <p><a href="https://metanit.com/web/javascript/6.1.php">metanit.com</a></p>
</article>


<!-- string -->
<article class="article">
  <div class="anchor" id="string"></div>
  <h2>Строка (тип данных string) в Javascript</h2>

  <h3>Строковый литерал</h3>
  <p>Строковый литерал можно записать одним из трех способов</p>
  <code>'qwerty' // в одинарных кавычках
    <br>"asdfg" // в двойных кавычках
    <br>`zxcvb` // в обратных кавычках</code>
    
  <h3>Состав строки</h3>
  <p>Внутри строки можно использовать три вида символов</p>
  <code>'qwerty' // обычные символы (буквы, цифры и т.д.)
    <br>'\n\t' // escape-последовательности (\n новая строка, \t табуляция)
    <br>'\u0056\u0179\u2190' // unicode символы (\u0056 V, \u0179 Ź, u2190 ←)
  </code>
  <p>Escape-последовательность это обратный слеш (\) за которым пишется буква или цифры. Рассматривается как один символ и является допустимой символьной константой. Обычно используется для указания действий, например возврата каретки или табуляции, на терминалах и принтерах.</p>
  
  <h3>1. Какой тип данных у строки</h3>
  <p>Есть два типа строк: строки примитивного типа и строки типа объект (String Object).</p>

  <h3>2. Как создать строку примитивного типа</h3>
  <p>Строковые примитивы это строковые литералы и строки, возвращенные вызовом String без ключевого слова new.</p>

  <p>Инициализируем примитивную строку. Присваиваем переменной литерал строки.</p>
  <code>const a = 'Frontend';</code>

  <p>Инициализируем примитивную строку. Присваиваем переменной результат работы глобального объекта String</p>
  <code>const b = String('Backend');</code>

  <h3>Как проверить что перед нами строка примитивного типа</h3>
  <p>Оператор typeof должен вернуть значение 'string'.</p>
  <code>typeof a;
  <br>'string'</code>
  <code>typeof b;
  <br>'string'</code>

  <h3>3. Как создать строку String Object</h3>
  <p>Инициализируем String Object. Вызываем конструктор нового объекта через ключевое слово new и в качестве параметра передаем в конструктор литерал строки.</p>
  <code>const c = new String('Fullstack');</code>
  <p>Методы и свойства String Objects доступны для всех строк. Если методы и свойства нужно вызвать на примитивном типе, то JavaScript осуществляет конвертацию строки в объект и обратно каждый раз, когда вызывается метод или свойство.</p>

  <h3>Как проверить что перед нами строка типа String Object</h3>
  <p>Оператор typeof должен вернуть значение 'object'. Оператор instanceof String должен вернуть значение true.</p>
  <code>typeof c;
  <br>'object'</code>
  <code>c instanceof String;
  <br>true</code>

  <h3>4. Как преобразовать строку примитивного типа в String Object</h3>
  <p>JavaScript автоматически преобразует примитивы в объекты String, так что на строковых примитивах возможно использовать методы объекта String.</p>

  <p>В контекстах, когда на примитивной строке вызывается метод или происходит поиск свойства, JavaScript автоматически оборачивает строковый примитив объектом и вызывает на нём метод или ищет в нём свойство.</p>

  <h3>5. Как преобразовать объект String в строковый примитив</h3>
  <p>Объект String также всегда может быть преобразован в его примитивный аналог при помощи метода valueOf().</p>

  <h3>6. Как индексируется строка</h3>
  <p>Каждый символ строки соответствует индексу, начиная с 0.</p>

  <h3>7. Как получить доступ к символу строки</h3>
  <p>Используя квадратные скобки, можно получить доступ к любому символу строки.</p>
  <code>'Frontend'[4];
  <br>t</code>
  </code>

  <h3>8. Как изменить строку</h3>
  <p>Строки неизменяемы. Содержимое строки в JavaScript нельзя изменить. Нельзя взять символ посередине и заменить его. Как только строка создана — она такая навсегда.</p>
  <code>let str = 'Frontend';
  <br>str[0] = 'f'; // ошибка</code>
  <p>Можно создать новую строку и записать ее в ту же самую переменную.</p>
  <code>let str = 'Frontend'
  <br>str = str.toUpperCase(); // 'FRONTEND'</code>
</article>


<!-- Свойства строк -->
<article class="article">
  <div class="anchor" id="properties"></div>
  <h2>Свойства строк</h2>

  <p>После создания любая строка имеет два свойства</p>
  <ol>
    <li><a href="#string-constructor">constructor</a> возвращает функцию конструктор строки <strong>function String() { [native code] }</strong></li>
    <li><a href="#string-length">length</a> возвращает количество символов в строке</li>
  </ol>
  <p>Еще одно свойство есть у объекта String:</p>
  <ol>
    <li><a href="#string-prototype">String.prototype</a> возвращает ссылку на объект String.prototype. Позволяет добавлять новые свойства и методы к объекту String()</li>
  </ol>
</article>


<!-- Свойство constructor -->
<article class="article">
  <div class="anchor" id="string-constructor"></div>
  <h3>Свойство constructor</h3>
  <p><em>(Возвращает <strong>function</strong>)</em></p>
  <p><em>(Появился в <strong>ES1</strong>)</em></p>
  <p>Свойство constructor у строки возвращает функцию, которая создала прототип строки <strong>function String() { [native code] }</strong></p>
  <code>let a = 'aaa';
  <br>a.constructor
  <br>f String() { [native code] }</code>
  <code>let b = new String('bbb');
  <br>b.constructor
  <br>f String() { [native code] }</code>
</article>


<!-- Свойство length -->
<article class="article">
  <div class="anchor" id="string-length"></div>
  <h3>Свойство length</h3>
  <p><em>(Возвращает <strong>number</strong>)</em></p>
  <p><em>(Появился в <strong>ES1</strong>)</em></p>
  <p>Возвращает количество символов в строке</p>
  <code>'Frontend'.length
  <br>8</code>
  <code>a = 'Front';
  <br>b = a.length;</code>
  <p>Свойство length не изменяет исходную строку</p>
  <code>console.log(a); // 'Front'</code>
  <p>Свойство length возвращает number</p>
  <code>console.log(b); // 4</code>
</article>


<!-- Свойство String.prototype -->
<article class="article">
  <div class="anchor" id="string-prototype"></div>
  <h3>Свойство String.prototype</h3>
  <p><em>(Возвращает <strong>String.prototype</strong>)</em></p>
  <p><em>(Появился в <strong>ES1</strong>)</em></p>
  <p>Ссылка на объект String.prototype</p>
</article>


<!-- Методы строк-->
<article class="article">
  <div class="anchor" id="methods"></div>
  <h2>Методы строк</h2>

  <p>Методы строк не изменяют исходную строку.</p>
  <p>Методы объекта String, записанные в его прототипе String.prototype.</p>
  <ol>
    <li>
      <a href="#string-at">at()</a>
      <br>Принимает индекс (целое число, также и отрицательное)
      <br>Возвращает символ по его индексу
    </li>
    <li>
      <a href="#string-char-at">charAt()</a>
      <br>Принимает индекс (целое число)
      <br>Возвращает символ по его индексу
    </li>
    <li>
      <a href="#string-char-code-at">charCodeAt()</a>
      <br>Принимает индекс (целое число)
      <br>Возвращает Unicode символа по его индексу
    </li>
    <li>
      <a href="#string-code-point-at">codePointAt()</a>
      <br>Принимает индекс (целое число)
      <br>Возвращает Unicode символа по его индексу
    </li>
    <li>
      <a href="#string-concat">concat()</a>
      <br>Принимает любое количество аргументов для объединения с исходной строкой
      <br>Возвращает новую строку, в которой объединяет исходной строку с указанными строками
    </li>
    <li>
      <a href="#string-ends-with">endsWith()</a>
      <br>Принимает подстроку и опционально индекс до которого проверять совпадение подстроки
      <br>Возвращает true если исходная строка в указанном индексе оканчивается на указанную подстроку, иначе возвращает false
    </li>
    <li>
      <a href="#string-from-char-code">String.fromCharCode()</a>
      <br>Принимает числовые значения Unicode
      <br>Возвращает строку из преобразованных в символы значений Unicode
    </li>
    <li>
      <a href="#string-from-code-point">String.fromCodePoint()</a>
      <br>Принимает числовые значения Unicode
      <br>Возвращает строку из преобразованных в символы значений Unicode
    </li>
    <li>
      <a href="#string-includes">includes()</a>
      <br>Принимает подстроку и опционально начальный индекс для поиска
      <br>Возвращает true если строка содержит указанную подстроку
    </li>
    <li>
      <a href="#string-index-of">indexOf()</a>
      <br>Принимает подстроку и опционально начальный индекс для поиска
      <br>Возвращает индекс первого вхождения в строке. Если подстрока не найдена, то возвращает -1
    </li>
    <li>
      <a href="#string-is-well-formed">isWellFormed()</a>
      <br>Не принимает параметры
      <br>Возвращает true если строка не содержит суррогатные пары, иначе возвращает false
    </li>
    <li>
      <a href="#string-last-index-of">lastIndexOf()</a>
      <br>Принимает подстроку и опционально индекс
      <br>Возвращает индекс первого вхождения с конца строки или с указанного индекса к началу. Возвращает -1 если подстрока не найдена
    </li>
    <li>
      <a href="#string-locale-compare">localeCompare()</a>
      <br>Принимает строку и два опционалных параметра
      <br>Возвращает 1, 0, -1 как результат сравнения двух строк
    </li>
    <li>
      <a href="#string-match">match()</a>
      <br>Принимает регулярное выражение
      <br>Возвращает массив, содержащий совпадения, по одному элементу для каждого совпадения или null, если совпадение не найдено
    </li>
    <li>
      <a href="#string-match-all">matchAll()</a>
      <br>Принимает регулярное выражение
      <br>Возвращает итератор по всем результатам при сопоставлении строки с регулярным выражением
    </li>
    <li>
      <a href="#string-normalize">normalize()</a>
      <br>Принимает опционально одну из четырех форм нормализации (NFC, NFD, NFKC и NFKD)
      <br>Возвращает строку, нормализованную в соответствии с указанной формой, по-умолчанию используется NFC
    </li>
    <li>
      <a href="#string-pad-end">padEnd()</a>
      <br>Принимает новую длину строки и опционально подстроку
      <br>Возвращает строку дополненную в конце до новой длины указанными подстроками, по-умолчанию пробелами
    </li>
    <li>
      <a href="#string-pad-start">padStart()</a>
      <br>Принимает новую длину строки и опционально подстроку
      <br>Возвращает строку дополненную в начале до нужной длины указанными подстроками, по-умолчанию пробелами
    </li>
    <li>
      <a href="#string-raw">String.raw()</a>
      <br>Принимает шаблонную строку
      <br>Возвращает необработанную форму указанной шаблонной строки
    </li>
    <li>
      <a href="#string-repeat">repeat()</a>
      <br>Принимает положительное число
      <br>Возвращает строку, повторяющую исходную указанное количество раз
    </li>
    <li>
      <a href="#string-replace">replace()</a>
      <br>Принимает первым параметром шаблон (регулярное выражение или подстроку), вторым параметром заменитель (подстроку или функцию)
      <br>Возвращает исходную строку, заменяя первое вхождение шаблона заменителем
    </li>
    <li>
      <a href="#string-replace-all">replaceAll()</a>
      <br>Принимает первым параметром шаблон (регулярное выражение или подстроку), вторым параметром заменитель (подстроку или функцию)
      <br>Возвращает исходную строку, заменяя все вхождения шаблона заменителем
    </li>
    <li>
      <a href="#string-search">search()</a>
      <br>Принимает строку или регулярное выражение
      <br>Возвращает индекс первого вхождения в строку, иначе возвращает -1
    </li>
    <li>
      <a href="#string-slice">slice()</a>
      <br>Принимает начальный индекс и опционально конечный индекс
      <br>Возвращает подстроку исходной строки между двумя индексами, или по-умолчанию до конца строки. Индексы могут быть также отрицательными
    </li>
    <li>
      <a href="#string-split">split()</a>
      <br>Принимает опционально строку в качестве разделителя и число, ограничивающее количество найденных подстрок
      <br>Возвращает массив подстрок
    </li>
    <li>
      <a href="#string-starts-with">startsWith()</a>
      <br>Принимает подстроку и опционально индекс с которого проверять совпадение подстроки
      <br>Возвращает true если исходная строка с указанного индекса начинается на указанную подстроку, иначе возвращает false
    </li>
    <li>
      <a href="#string-starts-with">substring()</a>
      <br>Принимает начальный индекс и опционально конечный индекс
      <br>Возвращает подстроку исходной строки между двумя индексами, или по-умолчанию до конца строки.
    </li>
    <li>
      <a href="#string-to-local-lower-case">toLocaleLowerCase()</a>
      <br>Не принимает параметры
      <br>Возвращает строку с символами в нижнем регистре в соответствии с языком браузера
    </li>
    <li>
      <a href="#string-to-local-upper-case">toLocaleUpperCase()</a>
      <br>Не принимает параметры
      <br>Возвращает строку с символами в верхнем регистре в соответствии с языком браузера
    </li>
    <li>
      <a href="#string-to-lower-case">toLowerCase()</a>
      <br>Не принимает параметры
      <br>Возвращает строку с символами в нижнем регистре
    </li>
    <li>
      <a href="#string-to-string">toString()</a>
      <br>Не принимает параметры
      <br>Возвращает строку, представляющую указанный объект. Делает то же самое что и метод valueOf()
    </li>
    <li>
      <a href="#string-to-upper-case">toUpperCase()</a>
      <br>Не принимает параметры
      <br>Возвращает строку с символами в верхнем регистре
    </li>
    <li>
      <a href="#string-to-well-formed">toWellFormed()</a>
      <br>Не принимает параметры
      <br>Возвращает строку, где все одиночные суррогаты заменены на Unicode с символом U+FFFD
    </li>
    <li>
      <a href="#string-trim">trim()</a>
      <br>Не принимает параметры
      <br>Возвращает строку без пробелов в начале и конце строки
    </li>
    <li>
      <a href="#string-trim-end">trimEnd()</a>
      <br>Не принимает параметры
      <br>Возвращает строку без пробелов в конце строки
    </li>
    <li>
      <a href="#string-trim-start">trimStart()</a>
      <br>Не принимает параметры
      <br>Возвращает строку без пробелов в начале строки
    </li>
    <li>
      <a href="#string-value-of">valueOf()</a>
      <br>Не принимает параметры
      <br>Возвращает примитивное значение объекта String. Делает то же самое что и метод toString()
    </li>
  </ol>
</article>


<!-- 1. at() -->
<article class="article">
  <div class="anchor" id="string-at"></div>
  <h3>1. Метод at(index)</h3>
  <strong>Появился</strong> в es2022
  <br><strong>Принимает</strong> индекс (целое число, также и отрицательное)
  <br><strong>Возвращает</strong> символ по его индексу</p>

  <h3>Задачи на метод at()</h3>
  <p>Получить первый символ строки</p>
  <code>'ABCxyz'.at(0); // A</code>
  <code>'ABCxyz'.at(-6); // A</code>
  <code>'ABCxyz'.at('ABCxyz'.length - 6); // A</code>
  <p>Получить последний символ строки</p>
  <code>'ABCxyz'.at(-1); // z</code>
  <code>'ABCxyz'.at(5); // z</code>
  <code>'ABCxyz'.at('ABCxyz'.length - 1); // z</code>

  <h3>Метод at(). Особенности</h3>
  <p>Возвращает символ по его позиции начиная с конца строки если index - целое отрицательное число от -1 до длины строки - 1</p>
  <code>'ABCxyz'.at(-5); // B</code>
  <p>Возвращает undefined если index выходит за пределы этого диапазона</p>
  <code>'ABCxyz'.at(6); // undefined</code>
  <code>'ABCxyz'.at(-100); // undefined</code>
  <p>Если в качестве параметра приходит дробное число, то дробная часть отбрасывается</p>
  <code>'ABCxyz'.at(3.9999); // x</code>
  <p>Если в качестве параметра приходит число в виде строки, то она преобразуется в число</p>
  <code>'ABCxyz'.at('2'); // C</code>
  <p>Возвращает первый символ строки в следующих случаях:</p>
  <code>'ABCxyz'.at(); // A</code>
  <code>'ABCxyz'.at(0); // A</code>
  <code>'ABCxyz'.at(false); // A</code>
  <code>'ABCxyz'.at(''); // A</code>
  <code>'ABCxyz'.at('anystring'); // A</code>
  <code>'ABCxyz'.at(null); // A</code>
  <code>'ABCxyz'.at(undefined); // A</code>
  <code>'ABCxyz'.at(NaN); // A</code>
  <p>Возвращает второй символ строки в следующих случаях:</p>
  <code>'ABCxyz'.at(1); // B</code>
  <code>'ABCxyz'.at(true); // B</code>

  <h3>Отличие между at() и charAt()</h3>
  <ul>
    <li>at() это новый улучшенный метод</li>
    <li>at() позволяет использовать отрицательные числа для поиска от конца строки</li>
    <li>at() возвращает undefined если index выходит за пределы диапазона</li>
    <li>charAt() возвращает пустую строку если index выходит за пределы диапазона</li>
  </ul>
</article>


<!-- 2. charAt() -->
<article class="article">
  <div class="anchor" id="string-char-at"></div>
  <h3>2. Метод charAt(index)</h3>
  <strong>Появился</strong> в ES1
  <br><strong>Принимает</strong> индекс (целое число)
  <br><strong>Возвращает</strong> символ по его индексу

  <h3>Задачи на метод charAt()</h3>
  <p>Получить первый символ строки</p>
  <code>'ABCxyz'.charAt(0); // A</code>
  <code>'ABCxyz'.charAt('ABCxyz'.length - 6); // A</code>
  <p>Получить последний символ строки</p>
  <code>'ABCxyz'.charAt('ABCxyz'.length - 1); // z</code>
  <code>'ABCxyz'.charAt(5); // z</code>

  <h3>Метод charAt(). Особенности</h3>
  <p>Возвращает пустую строку если index выходит за пределы строки</p>
  <code>'ABCxyz'.charAt(-1); // ''</code>
  <code>'ABCxyz'.charAt(6); // ''</code>
  <p>Если в качестве параметра приходит дробное число, то дробная часть отбрасывается</p>
  <code>'ABCxyz'.charAt(3.9999); // x</code>
  <p>Если в качестве параметра приходит число в виде строки, то она преобразуется в число</p>
  <code>'ABCxyz'.charAt('2'); // C</code>
  <p>Возвращает первый символ строки в следующих случаях:</p>
  <code>'ABCxyz'.charAt(); // A</code>
  <code>'ABCxyz'.charAt(0); // A</code>
  <code>'ABCxyz'.charAt(false); // A</code>
  <code>'ABCxyz'.charAt(''); // A</code>
  <code>'ABCxyz'.charAt('anystring'); // A</code>
  <code>'ABCxyz'.charAt(null); // A</code>
  <code>'ABCxyz'.charAt(undefined); // A</code>
  <code>'ABCxyz'.charAt(NaN); // A</code>
  <p>Возвращает второй символ строки в следующих случаях:</p>
  <code>'ABCxyz'.charAt(1); // B</code>
  <code>'ABCxyz'.charAt(true); // B</code>
</article>


<!-- 3. charCodeAt() -->
<article class="article">
  <div class="anchor" id="string-char-code-at"></div>
  <h3>3. Метод charCodeAt(index)</h3>
  <strong>Появился</strong> в ES1
  <br><strong>Принимает</strong> индекс (целое число)
  <br><strong>Возвращает</strong> Unicode символа (целое число между 0 и 65535) по его индексу

  <h3>Задачи на метод charCodeAt()</h3>
  <p>Получить Unicode первого символа строки</p>
  <code>'ABCxyz'.charCodeAt(0); // 65</code>
  <code>'ABCxyz'.charCodeAt('ABCxyz'.length - 6); // 65</code>
  <p>Получить Unicode последнего символа строки</p>
  <code>'ABCxyz'.charCodeAt('ABCxyz'.length - 1); // 122</code>
  <code>'ABCxyz'.charCodeAt(5); // 122</code>

  <h3>Метод charCodeAt(). Особенности</h3>
  <p>Возвращает NaN если index выходит за пределы строки</p>
  <code>'ABCxyz'.charCodeAt(6); // NaN</code>
  <code>'ABCxyz'.charCodeAt(-1); // NaN</code>
  <p>Если в качестве параметра приходит дробное число, то дробная часть отбрасывается</p>
  <code>'ABCxyz'.charCodeAt(0.9999); // 65</code>
  <p>Если в качестве параметра приходит число в виде строки, то она преобразуется в число</p>
  <code>'ABCxyz'.charCodeAt('2'); // 67</code>
  <p>Возвращает Unicode первого символа строки в следующих случаях:</p>
  <code>'ABCxyz'.charCodeAt(); // 65</code>
  <code>'ABCxyz'.charCodeAt(0); // 65</code>
  <code>'ABCxyz'.charCodeAt(false); // 65</code>
  <code>'ABCxyz'.charCodeAt(''); // 65</code>
  <code>'ABCxyz'.charCodeAt('anystring'); // 65</code>
  <code>'ABCxyz'.charCodeAt(null); // 65</code>
  <code>'ABCxyz'.charCodeAt(undefined); // 65</code>
  <code>'ABCxyz'.charCodeAt(NaN); // 65</code>
  <p>Возвращает второй символ строки в следующих случаях:</p>
  <code>'ABCxyz'.charCodeAt(1); // 66</code>
  <code>'ABCxyz'.charCodeAt(true); // 66</code>
</article>


<!-- 4. codePointeAt() -->
<article class="article">
  <div class="anchor" id="string-code-pointe-at"></div>
  <h3>4. Метод codePointAt(index)</h3>
  <strong>Появился</strong> в es6
  <br><strong>Принимает</strong> индекс (целое число)
  <br><strong>Возвращает</strong> Unicode символа (целое число между 0 и 65535) по его индексу</p>

  <h3>Задачи на метод codePointAt()</h3>
  <p>Получить Unicode первого символа строки</p>
  <code>'ABCxyz'.codePointAt(0); // 65</code>
  <p>Получить Unicode последнего символа строки</p>
  <code>'ABCxyz'.codePointAt('ABCxyz'.length - 1); // 122</code>
  <code>'ABCxyz'.codePointAt(5); // 122</code>

  <h3>Метод codePointAt(). Особенности</h3>
  <p>Возвращает undefined если index выходит за пределы строки</p>
  <code>'ABCxyz'.codePointAt(5); // undefined</code>
  <code>'ABCxyz'.codePointAt(-1); // undefined</code>
  <p>Если в качестве параметра приходит дробное число, то дробная часть отбрасывается</p>
  <code>'ABCxyz'.codePointAt(0.9999); // 65</code>
  <p>Если в качестве параметра приходит число в виде строки, то она преобразуется в число</p>
  <code>'ABCxyz'.codePointAt('2'); // 67</code>
  <p>Возвращает код первого символа строки в следующих случаях:</p>
  <code>'ABCxyz'.codePointAt(); // 65</code>
  <code>'ABCxyz'.codePointAt(0); // 65</code>
  <code>'ABCxyz'.codePointAt(false); // 65</code>
  <code>'ABCxyz'.codePointAt(''); // 65</code>
  <code>'ABCxyz'.codePointAt('anystring'); // 65</code>
  <code>'ABCxyz'.codePointAt(null); // 65</code>
  <code>'ABCxyz'.codePointAt(undefined); // 65</code>
  <code>'ABCxyz'.codePointAt(NaN); // 65</code>
  <p>Возвращает код второго символа строки в следующих случаях:</p>
  <code>'ABCxyz'.charAt(1); // 66</code>
  <code>'ABCxyz'.charAt(true); // 66</code>

  <h3>Отличие между codePointAt() и charCodeAt()</h3>
  <ul>
    <li>codePointAt() это новый улучшенный метод</li>
    <li>codePointAt() корректно работает с суррогатными парами</li>
    <li>codePointAt() возвращает undefined если index выходит за пределы строки</li>
    <li>charCodeAt() возвращает NaN если index выходит за пределы строки</li>
  </ul>

  <p>В современный JavaScript добавлены методы String.fromCodePoint и str.codePointAt – аналоги String.fromCharCode и str.charCodeAt, корректно работающие с суррогатными парами.</p>
  <p>Внутренняя кодировка строк в JavaScript – это UTF-16, то есть под каждый символ отводится ровно два байта.</p>
  <p>Но под всевозможные символы всех языков мира 2 байт не хватает. Поэтому бывает так, что одному символу языка соответствует два Юникодных символа (итого 4 байта). Такое сочетание называют «суррогатной парой»</p>
  <p>Заметим, однако, что не всякий китайский иероглиф – суррогатная пара. Китайскими иероглифами суррогатные пары, естественно, не ограничиваются. Ими представлены редкие математические символы, а также некоторые символы для эмоций.</p>
</article>


<!-- 5. concat() -->
<article class="article">
  <div class="anchor" id="string-concat"></div>
  <h3>5. Метод concat(str[, str2, ..., strN])</h3>
  <strong>Появился</strong> в ES1
  <br><strong>Принимает</strong> любое количество аргументов для объединения с исходной строкой. Каждый аргумент приводится к строке методом toString()
  <br><strong>Возвращает</strong> новую строку, в которой объединяет исходной строку с указанными строками

  <h3>Задачи на метод concat()</h3>
  <p>Соединить две строки</p>
  <code>'abcde'.concat('fghij'); // 'abcdefghij'</code>
  <p>Добавить числа и буквы в конец строки</p>
  <code>'abcde'.concat(1, 2, 3, 'q', 'w'); // 'abcde123qw'</code>

  <h3>Метод concat(). Особенности</h3>
  <p>Без параметров возвращает ту же самую строку</p>
  <code>'abcde'.concat(); // 'abcde'</code>
  <p>С одним или более параметрами преобразуют каждый параметр в строку и по очереди добавляют в конец исходной строки, возвращая новую строку</p>
  <code>'abcde'.concat(1234); // 'abcde1234'</code>
  <code>'abcde'.concat('Backend', 123, null, NaN, '', undefined, Infinity);
  <br>'abcdeBackend123nullNaNundefinedInfinity'</code>
</article>


<!-- 6. endsWith() -->
<article class="article">
  <div class="anchor" id="string-ends-with"></div>
  <h3>6. Метод endsWith(str[, length])</h3>
  <strong>Появился</strong> в ES6
  <br><strong>Принимает</strong> подстроку и опционально индекс до которого проверять совпадение подстроки
  <br><strong>Возвращает</strong> true если исходная строка в указанном индексе оканчивается на указанную подстроку, иначе возвращает false

  <h3>Задачи на метод endsWith()</h3>
  <p>Проверить что строка заканчивается на 'px'</p>
  <code>'200px'.endsWith('px'); // true</code>
  <p>Проверить что первые 5 символов строки заканчиваются на 'px'</p>
  <code>'200px;'.endsWith('px', 5); // true</code>

  <h3>Метод endsWith(). Особенности</h3>
  <p>Без параметров возвращает false</p>
  <code>'abcdefgh'.endsWith(); // false</code>
  <p>Возвращает true если первый параметр пустая строка</p>
  <code>'abcdefgh'.endsWith(''); // true</code>
  <code>'abcdefgh'.endsWith('', null); // true</code>
</article>


<!-- 7. String.fromCharCode() -->
<article class="article">
  <div class="anchor" id="string-from-char-code"></div>
  <h3>7. Метод String.fromCharCode(num1,...,numN)</h3>
  <strong>Появился</strong> в ES1
  <br><strong>Принимает</strong> числовые значения Unicode от 0 до 65535
  <br><strong>Возвращает</strong> строку из преобразованных в символы значений Unicode

  <h3>Задачи на метод String.fromCharCode()</h3>
  <p>Создать строку по кодам в десятичном формате</p>
  <code>String.fromCharCode(65, 66, 89, 90, 97, 98, 121, 122); // 'ABYZabyz'</code>
  <p>Создать строку по кодам в шестнадцатиричном формате</p>
  <code>String.fromCharCode(0x41, 0x42, 0x59, 0x5A, 0x61, 0x62, 0x79, 0x7A); // 'ABYZabyz'</code>
  <p>Создать строку по кодам в восьмеричном формате</p>
  <code>String.fromCharCode(0o101, 0o102, 0o131, 0o132, 0o141, 0o142, 0o171, 0o172); // 'ABYZabyz'</code>
  <p>Создать строку по кодам в двоичном формате</p>
  <code>String.fromCharCode(0b1000001, 0b1000010, 0b1000011); // 'ABC'</code>

  <h3>Метод String.fromCharCode(). Особенности</h3>
  <p>Числа больше 0xFFFF усекаются.</p>
  <code>String.fromCharCode(0x10041, 0x10042, 0x10043); // 'ABC'</code>
  <p>Не работает с суррогатными парами. Возвращает неправильный символ</p>
  <code>String.fromCharCode(0x1F304); // ''</code>
  <p>Работает только с 16 битным юникодом от 0 (0x0000) до 65535 (0xFFFF). Чтобы получить символ из диапазона от 65536 (0x10000) до 1114111 (0x10FFFF) нужно 32 битное число разбить на суррогатную пару двух 16 битных чисел</p>
  <p>Чтобы получить правильный символ надо разбить суррогатную пару на два 16 битных числа</p>
  <code>String.fromCharCode(0xD83C, 0xDF04); // '🌄'</code>
</article>


<!-- 8. String.fromCodePoint() -->
<article class="article">
  <div class="anchor" id="string-from-code-point"></div>
  <h3>8. Метод String.fromCodePoint()</h3>
  <strong>Появился</strong> в ES6
  <br><strong>Принимает</strong> числовые значения Unicode от 0x0000 до 0x10FFFF
  <br><strong>Возвращает</strong> строку из преобразованных в символы значений Unicode

  <h3>Задачи на метод String.fromCodePoint()</h3>
  <p>Создать строку по кодам в десятичном формате</p>
  <code>String.fromCodePoint(65, 66, 89, 90, 97, 98, 121, 122); // 'ABYZabyz'</code>
  <p>Создать строку по кодам в шестнадцатиричном формате</p>
  <code>String.fromCodePoint(0x41, 0x42, 0x59, 0x5A, 0x61, 0x62, 0x79, 0x7A); // 'ABYZabyz'</code>
  <p>Создать строку по кодам в восьмеричном формате</p>
  <code>String.fromCodePoint(0o101, 0o102, 0o131, 0o132, 0o141, 0o142, 0o171, 0o172); // 'ABYZabyz'</code>
  <p>Создать строку по кодам в двоичном формате</p>
  <code>String.fromCodePoint(0b1000001, 0b1000010, 0b1000011); // 'ABC'</code>

  <h3>Метод String.fromCodePoint(). Особенности</h3>
  <p>Кодовая точка — это число, присвоенное одному символу</p>
  <p>Кодовые точки — это числа в диапазоне от 0x0000 до 0x10FFFF</p>
  <p>Работает с суррогатными парами. Возвращает правильный символ из одного 32 битного числа</p>
  <code>String.fromCodePoint(0x1F304); // '🌄'</code>
  <p>Также правильный символ можно получить разбив суррогатную пару на два 16 битных числа</p>
  <code>String.fromCodePoint(0xD83C, 0xDF04); // '🌄'</code>

  <h3>Отличие между String.fromCodePoint() и String.fromCharCode()</h3>
  <ul>
    <li>String.fromCodePoint() это новый улучшенный метод</li>
    <li>String.fromCodePoint() принимает числа от 0x0000 до 0x10FFFF</li>
    <li>String.fromCodePoint() позволяет работать с суррогатными парами</li>
  </ul>
</article>


<!-- 9. includes() -->
<article class="article">
  <div class="anchor" id="string-includes"></div>
  <h3>9. Метод includes(str[, index])</h3>
  <strong>Появился</strong> в ES6
  <br><strong>Принимает</strong> подстроку и опционально начальный индекс для поиска
  <br><strong>Возвращает</strong> true если исходная строка содержит указанную подстроку. Иначе возвращает false. 
  <p>Начинает искать с указанного индекса, если индекс не указан, то ищет с начала строки.</p>
  
  <h3>Задачи на метод includes()</h3>
  <p>Проверить вхождение символов в строку</p>
  <code>'abcdef'.includes('cd'); // true</code>
  <code>'abcdef'.includes('ac'); // false</code>
  <p>Проверить вхождение символов в строку начиная со второго индекса</p>
  <code>'abcdef'.includes('cd', 2); // true</code>
  <p>Проверить вхождение символов в строку начиная с третьего индекса</p>
  <code>'abcdef'.includes('cd', 3); // false</code>

  <h3>Метод includes(). Особенности</h3>
  <p>Без параметров всегда возвращает false</p>
  <code>'abcdef'.includes(); // false</code>
  <p>Возвращает true если передать пустую строку</p>
  <code>'abcdef'.includes(''); // true</code>
</article>


<!-- 10. indexOf() -->
<article class="article">
  <div class="anchor" id="string-index-of"></div>
  <h3>10. Метод indexOf(str[, index])</h3>
  <strong>Появился</strong> в ES1
  <br><strong>Принимает</strong> подстроку и опционально начальный индекс для поиска</p>
  <br><strong>Возвращает</strong> индекс первого вхождения в строке, если подстрока не найдена, то возвращает -1</p>

  <h3>Задачи на метод indexOf()</h3>
  <p>Найти индекс символа в строке</p>
  <code>'abcdef'.indexOf('c'); // 2</code>
  <code>'abcdef'.indexOf('f'); // 3</code>
  <code>'abcdef'.indexOf('g'); // -1</code>
  <p>Найти индекс символа в строке начиная со второго индекса</p>
  <code>'abcdef'.indexOf('c', 2); // 2</code>
  <p>Найти индекс символа в строке начиная с третьего индекса</p>
  <code>'abcdef'.indexOf('c', 3); // -1</code>

  <h3>Метод indexOf(). Особенности</h3>
  <p>Без параметров всегда возвращает -1</p>
  <code>'abcdef'.indexOf(); // -1</code>
  <p>Возвращает 0 если передать пустую строку</p>
  <code>'abcdef'.indexOf(''); // 0</code>
</article>


<!-- 11. isWellFormed() -->
<article class="article">
  <div class="anchor" id="string-is-well-formed"></div>
  <h3>11. Метод isWellFormed()</h3>
  <strong>Появился</strong> в ES2024
  <br><strong>Не принимает параметры</strong>
  <br><strong>Возвращает</strong> true если строка не содержит суррогатные пары, иначе возвращает false

  <h3>Задачи на метод isWellFormed()</h3>
  <p>Проверить что строка не содержит суррогатные пары</p>
  <code>'abcdef'.isWellFormed(); // true</code>
  <code>'abcdef'.isWellFormed(); // true</code>

  <h3>Метод isWellFormed(). Особенности</h3>
  <p>Значения строк в ECMAScript представляют собой последовательность из 16-битных беззнаковых целочисленных значений.</p>
  <p>В правильно сформированных строках каждое целочисленное значение в последовательности представляет собой отдельную единицу UTF-16 юникодного текста. Однако не все последовательности представляют собой UTF-16 юникодный текст.</p>

  <p>Также в правильно сформированных строках кодовые единицы в диапазоне от 0xD800 до 0xDBFF (ведущие суррогаты) и от 0xDC00 до 0xDFFF (заключительные суррогаты) должны появляться парами и по порядку. Строки с непарными или неправильно упорядоченными суррогатами считаются неправильно сформированными.</p>
    
  <p>Новый стандарт предлагает ввести метод isWellFormed() для проверки, является ли строка правильно сформированной и метод toWellFormed() для замены любых одиночных или неправильно упорядоченных суррогатов, если они присутствуют, на U+FFFD (символ замены в Юникоде)</p>
  <code>'ab\uD800'.isWellFormed(); // false</code>
  <code>'new\uD800'.isWellFormed(); // false</code>
  <code>'hello'.isWellFormed(); // true</code>
</article>


<!-- 12. lastIndexOf() -->
<article class="article">
  <div class="anchor" id="string-last-index-of"></div>
  <h3>12. Метод lastIndexOf(str[, index])</h3>
  <strong>Появился</strong> в ES1
  <br><strong>Принимает</strong> подстроку и опционально индекс
  <br><strong>Возвращает</strong> индекс первого вхождения с конца строки или с указанного индекса к началу. Возвращает -1 если подстрока не найдена</p>

  <h3>Задачи на метод lastIndexOf()</h3>
  <p>Найти индекс символа в строке</p>
  <code>'abcabc'.lastIndexOf('c'); // 5</code>
  <code>'abcabc'.lastIndexOf('b'); // 4</code>
  <code>'abcabc'.lastIndexOf('g'); // -1</code>
  <p>Найти индекс символа в строке начиная с 4 индекса к началу</p>
  <code>'abcabc'.lastIndexOf('c', 4); // 2</code>
  <p>Найти индекс символа в строке начиная с 1 индекса к началу</p>
  <code>'abcabc'.lastIndexOf('c', 1); // -1</code>

  <h3>Метод lastIndexOf(). Особенности</h3>
  <p>Без параметров всегда возвращает -1</p>
  <code>'abcabc'.lastIndexOf(); // -1</code>
  <p>Возвращает длину строки если передать пустую строку</p>
  <code>'abcabc'.lastIndexOf(''); // 6</code>
  <code>'abcabc'.lastIndexOf('', 4); // 4</code>
</article>


<!-- 13. localeCompare() -->
<article class="article">
  <div class="anchor" id="string-locale-compare"></div>
  <h3>13. Метод localeCompare(str[, locales, options])</h3>
  <strong>Появился</strong> в ES1
  <br><strong>Принимает</strong> строку и два опционалных параметра, определяющих правила форматирования языка
  <br><strong>Возвращает</strong> одно из трех значений, сравнивая исходную строку с переданной строкой в текущей локали. Локаль основана на настройках языка браузера.
  <ul>
    <li>-1, если исходная строка сортируется до переданной строки</li>
    <li>0, если две строки равны</li>
    <li>1, если исходная строка сортируется после переданной строки</li>
  </ul>

  <h3>Задачи на метод localeCompare()</h3>
  <p>Сравнить две строки</p>
  <code>'ab'.localeCompare('cd'); // -1</code>
  <code>'ab'.localeCompare('ab'); // 0</code>
  <code>'cd'.localeCompare('ab'); // 1</code>
</article>


<!-- 14. match() -->
<article class="article">
  <div class="anchor" id="string-match"></div>
  <h3>14. Метод match(regexp)</h3>
  <strong>Появился</strong> в ES1
  <br><strong>Принимает</strong> регулярное выражение
  <br><strong>Возвращает</strong> массив, содержащий совпадения, по одному элементу для каждого совпадения или null, если совпадение не найдено

  <h3>Задачи на метод match()</h3>
  <p>Найти все совпадения в строке независимо от регистра</p>
  <code>let str = "A drop of ink may make a million THINK"; 
  <br>str.match(/ink/gi); // ['ink', 'INK']</code>
</article>


<!-- 15. matchAll() -->
<article class="article">
  <div class="anchor" id="string-match-all"></div>
  <h3>15. Метод matchAll()</h3>
  <strong>Появился</strong> в ES2020
  <br><strong>Принимает</strong> регулярное выражение</p>
  <br><strong>Возвращает</strong> все совпадения с регулярным выражением в виде итерируемого объекта, каждый элемент которого содержит массив из найденного и его карманов. Метод может вызываться только с модификатором g. Если совпадений нет, то вернет null.</p>
  <p>Получим все совпадения и переберем их циклом:</p>
<pre>let str = '12 34 56';
let matches = str.matchAll(/(\d)(\d)/g);

for (let match of matches) {
  console.log(match);
}</pre>
  <p>Результат выполнения кода:</p>
<pre>[12, 1, 2]
[34, 3, 4]
[56, 5, 6]</pre>
  <p>Преобразуем итерируемый объект в обычный массив:</p>
<pre>let res = Array.from(matches);

console.log(res);</pre>
  <p>Результат выполнения кода:</p>
<pre>[
[12, 1, 2],
[34, 3, 4],
[56, 5, 6]
]</pre>

  <h3>Метод matchAll(). Особенности</h3>
  <p>Если объект regex не имеет флага /g, будет выдана ошибка TypeError.</p>
  <code>'abcd123'.matchAll(/d/); // TypeError: String.prototype.matchAll </code>
</article>


<!-- 16. normalize() -->
<article class="article">
  <div class="anchor" id="string-normalize"></div>
  <h3>16. Метод normalize([form])</h3>
  <strong>Появился</strong> в ES2015
  <br><strong>Принимает</strong> опционально одну из четырех форм нормализации (NFC, NFD, NFKC и NFKD)
  <br><strong>Возвращает</strong> строку, нормализованную в соответствии с указанной формой, по-умолчанию используется NFC</p>

  <h3>Задачи на метод normalize()</h3>
  <p>Некоторые символы имеют больше чем одна кодовая точка для своего обозначения. Например следующие две строчки кода вернут символ 'Ç'</p>
  <code>String.fromCharCode(0xc7); 'Ç'</code>
  <code>String.fromCharCode(0x43, 0x327); 'Ç'</code>
  <p>Но при этом полученные символы не равны друг другу</p>
  <code>String.fromCharCode(0xc7) === String.fromCharCode(0x43, 0x327);</code>
  <p>Для того чтобы сравнить одинаковые символы (полученные разным способом) необходимо нормализовать строки с этими символами</p>
  <code>String.fromCharCode(0xc7).normalize() === String.fromCharCode(0x43, 0x327).normalize(); // true</code>

  <h3>Метод normalize(). Особенности</h3>
  <p>В Unicode есть четыре главные формы нормализации</p>
  <ol>
    <li>NFC — форма нормализации канонической композицией (Normalization Form Canonical Composition, 'NFC'), по умолчанию;</li>
    <li>NFD — форма нормализации канонической декомпозицией (Normalization Form Canonical Decomposition, 'NFD');</li>
    <li>NFKC — форма нормализации совместимой композицией (Normalization Form Compatibility Composition, 'NFKC');</li>
    <li>NFKD — форма нормализации совместимой декомпозицией (Normalization Form Compatibility Decomposition, 'NFKD').</li>
  </ol>
  <p>Если параметр form не является одним из вышеперечисленных значений, будет выброшено исключение RangeError.</p>
  <p>Unicode присваивает уникальное числовое значение, называемое кодовой точкой, каждому символу. Например, кодовая точка для «А» задается как U+0041. Однако иногда абстрактный символ может быть представлен более одной кодовой точкой или же последовательностью кодовых точек. Символ «ñ» может быть представлен либо кодовой точкой U+00F1, либо сочетанием «n» (U+006E), и тильды объединения (U+0303). Поскольку кодовые точки разные, сравнение строк не будет рассматривать их как равные. А так как количество кодовых точек в каждой версии разное, то и длина у них разная. Метод normalize() помогает решить эту проблему путем преобразования строки в нормализованную форму. Она общая для всех последовательностей кодовых точек, представляющих одни и те же символы.</p>
</article>


<!-- 17. padEnd() -->
<article class="article">
  <div class="anchor" id="string-pad-end"></div>
  <h3>17. Метод padEnd(num [, str])</h3>
  <strong>Появился</strong> в ES2017
  <br><strong>Принимает</strong> новую длину строки и опционально подстроку
  <br><strong>Возвращает</strong> новую строку дополненную до новой длины в конце указанными подстроками, по-умолчанию пробелами

  <h3>Задачи на метод padEnd()</h3>
  <p>Дополнить строку длиной 5 до длины 10 пробелами в конце строки</p>
  <code>'12345'.padEnd(10); // '12345     '</code>
  <p>Дополнить строку длиной 5 до длины 10 звездочками в конце строки</p>
  <code>'12345'.padEnd(10, '*'); // '12345*****'</code>

  <h3>Метод padEnd(). Особенности</h3>
  <p>Если дополнять пустыми строками то длина не изменится</p>
  <p>Дополнить строку длиной 5 до длины 10 пустыми строками в конце строки</p>
  <code>'12345'.padEnd(10, ''); // '12345'</code>
 
  <p>Если исходная строка была длинее, то она возвращается без изменений.</p>
  <code>'abcd'.padEnd(1); // 'abcd'</code>
  <code>'abcd'.padEnd(0); // 'abcd'</code>
  <code>'abcd'.padEnd(-3); // 'abcd'</code>
  <p>Второй необязательный параметр str это строка, которую надо добавить в конце до указанной длины строки.</p>
  <code>'abcd'.padEnd(8, 'efgh'); // 'abcdefgh'</code>
  <p>Если str слишком длинная, то она обрезается.</p>
  <code>'abcd'.padEnd(6, 'efgh'); // 'abcdef'</code>
  <p>Если str слишком короткая, то она повторяется.</p>
  <code>'abcd'.padEnd(10, 'efgh'); // 'abcdefghef'</code>
  <code>'abcd'.padEnd(12, 'efgh'); // 'abcdefghefgh'</code>
</article>


<!-- 18. padStart() -->
<article class="article">
  <div class="anchor" id="string-pad-start"></div>
  <h3>18. Метод padStart(num [, str])</h3>
  <strong>Появился</strong> в ES2017
  <br>Принимает новую длину строки и опционально подстроку</p>
  <br>Возвращает новую строку дополненную до новой длины в начале указанными подстроками, по-умолчанию пробелами</p>
  
  <h3>Задачи на метод padStart()</h3>
  <p>Дополнить строку длиной 5 до длины 10 пробелами в начале строки</p>
  <code>'12345'.padStart(10); // '     12345'</code>
  <p>Дополнить строку длиной 5 до длины 10 звездочками в начале строки</p>
  <code>'12345'.padStart(10, '*'); // '*****12345'</code>

  <h3>Метод padStart(). Особенности</h3>
  <p>Если дополнять пустыми строками то длина не изменится</p>
  <p>Дополнить строку длиной 5 до длины 10 пустыми строками в начале строки</p>
  <code>'12345'.padStart(10, ''); // '12345'</code>

  <p>Если исходная строка была длинее, то она возвращается без изменений.</p>
  <code>'abcd'.padStart(1); // 'abcd'</code>
  <code>'abcd'.padStart(0); // 'abcd'</code>
  <code>'abcd'.padStart(-3); // 'abcd'</code>
  <p>Второй необязательный параметр str это строка, которую надо добавить в начале до указанной длины строки.</p>
  <code>'abcd'.padStart(8, 'efgh'); // 'efghabcd'</code>
  <p>Если str слишком длинная, то она обрезается.</p>
  <code>'abcd'.padStart(6, 'efgh'); // 'efabcd'</code>
  <p>Если str слишком короткая, то она повторяется.</p>
  <code>'abcd'.padStart(10, 'efgh'); // 'efghefabcd'</code>
  <code>'abcd'.padStart(12, 'efgh'); // 'efghefghabcd'</code>
</article>


<!-- 19. String.raw() -->
<article class="article">
  <div class="anchor" id="string-raw"></div>
  <h3>19. Метод String.raw(str)</h3>
  <strong>Появился</strong> в ES6
  <br><strong>Принимает</strong> шаблонную строку
  <br><strong>Возвращает</strong> необработанную строку из шаблона

  <h3>Задачи на метод String.raw()</h3>
  <p>Определить путь к файлам windows без двойного экранирования</p>
  <code>String.raw`c:\files\node\test.js`; // 'c:\\files\\node\\test.js'</code>
  <code>let path = String.raw`c:\files\node\test.js`;
  <br>path // 'c:\\files\\node\\test.js'
  </code>

  <h3>Метод String.raw(). Особенности</h3>
  <code>String.raw`Привет\n${2 + 3}!`;
  <br>'Привет\n5!', символ после 'Привет' не является символом новой строки</code>
</article>


<!-- 20. repeat() -->
<article class="article">
  <div class="anchor" id="string-repeat"></div>
  <h3>20. Метод repeat(num)</h3>
  <strong>Появился</strong> в ES6
  <br><strong>Принимает</strong> положительное число
  <br><strong>Возвращает</strong> строку, повторяющую исходную указанное количество раз

  <h3>Задачи на метод repeat()</h3>
  <p>Повторить строку три раза</p>
  <code>'abc'.repeat(3); / 'abcabcabc'</code>

  <h3>Метод repeat(). Особенности</h3>
  <p>Вызывает исключение RangeError если параметр отрицательное число или результат превышает максимально допустимую длину строки</p>
  <p>Без параметров возвращает пустую строку</p>
  <code>'abcd'.repeat(); // ''</code>
  <p>Если параметр 0 или который при привидении к number дает 0 ('0', NaN, false, null, undefined) возвращает пустую строку</p>
  <code>'abcd'.repeat(NaN); // ''</code>
  <p>Если параметр 1 или при привидении к number дает 1 ('1', true) возвращает исходную строку</p>
  <code>'abcd'.repeat(true); // 'abcd'</code>
</article>


<!-- 21. replace() -->
<article class="article">
  <div class="anchor" id="string-replace"></div>
  <h3>21. Метод replace(regexp|str, newstr|function)</h3>
  <strong>Появился</strong> в ES1
  <br><strong>Принимает</strong> первым параметром шаблон (регулярное выражение или подстроку), вторым параметром заменитель (подстроку или функцию)
  <br><strong>Возвращает</strong> исходную строку, заменяя первое вхождение шаблона заменителем

  <h3>Задачи на метод replace()</h3>
  <p>Заменить первое вхождение символов в строке</p>
  <code>'abcdabcd'.replace('abcd', 'efgh'); // 'efghabcd'</code>
  <code>'abcdabcd'.replace(/abcd/, 'efgh'); // 'efghabcd'</code>
  <p>Заменить все вхождения символов в строке. Чтобы заменить все вхождения шаблона, необходимо использовать регулярное выражение с ключом g (глобальный поиск).</p>
  <code>'abcdabcd'.replace(/abcd/g, 'efgh'); // 'efghefgh'</code>
  
  <h3>Метод replace(). Особенности</h3>
  <p>Без параметров возвращает исходную строку</p>
  <code>'abcdabcd'.replace(); // 'abcdabcd'</code>
  <p>Без второго параметра заменит первое вхождение на undefined</p>
  <code>'abcdabcd'.replace('a'); // 'undefinedbcdabcd'</code>
</article>


<!-- 22. replaceAll() -->
<article class="article">
  <div class="anchor" id="string-replace-all"></div>
  <h3>22. Метод replaceAll(regexp|str, newstr|function)</h3>
  <strong>Появился</strong> в ES2021
  <br><strong>Принимает</strong> первым параметром шаблон (регулярное выражение или подстроку), вторым параметром заменитель (подстроку или функцию)
  <br><strong>Возвращает</strong> исходную строку, заменяя все вхождения шаблона заменителем

  <h3>Задачи на метод replaceAll()</h3>
  <p>Заменить первое вхождение символов в строке</p>
  <code>'abcdabcd'.replaceAll('abcd', 'efgh'); // 'efghabcd'</code>
  <code>'abcdabcd'.replaceAll(/abcd/g, 'efgh'); // 'efghabcd'</code>

  <h3>Метод replaceAll(). Особенности</h3>
  <p>Регулярное выражение без глобального флага ('g') выдаст ошибку TypeError</p>
  <code>'abcdabcd'.replaceAll(/abcd/, 'efgh'); // Uncaught TypeError: String.prototype.replaceAll called with a non-global RegExp argument</code>
</article>


<!-- 23. search() -->
<article class="article">
  <div class="anchor" id="string-search"></div>
  <h3>23. Метод search(regexp)</h3>
  <strong>Появился</strong> в ES1
  <br><strong>Принимает</strong> строку или регулярное выражение
  <br><strong>Возвращает</strong> индекс первого вхождения в строку, иначе возвращает -1

  <h3>Задачи на метод search()</h3>
  <p>Найти первую заглавную букву в строке</p>
  <code>'my little Pony'.search(/[A-Z]/); // 10</code>
  <p>Найти первую цифру в строке</p>
  <code>'my 12 Pony'.search(/[0-9]/); // 3</code>
  <p>Найти слово 'второй'</p>
  <code>'первый второй третий'.search('второй'); // 7</code>

  <h3>Метод search(). Особенности</h3>
  <p>Без парамеров возвращает 0</p>
  <code>'abcdabcd'.search(); // 0</code>
  <p>Возвращает индекс первого вхождения в строку</p>
  <p>Возвращает -1 если совпадения не найдено</p>
  <code>'abcdabcd'.search('1'); // -1</code>
</article>


<!-- 24. slice() -->
<article class="article">
  <div class="anchor" id="string-slice"></div>
  <h3>24. Метод slice(startIndex[, endIndex])</h3>
  <strong>Появился</strong> в ES1
  <br><strong>Принимает</strong> начальный индекс и опционально конечный индекс, может быть также отрицательный
  <br><strong>Возвращает</strong> подстроку исходной строки между двумя индексами, или по-умолчанию до конца строки
  
  <h3>Задачи на метод slice()</h3>
  <p>Вернуть новую строку с пятого индекса</p>
  <code>'12345abc'.slice(5); // 'abc'</code>
  <p>Вернуть новую строку между 5 и 10 индексами</p>
  <code>'12345abc12345'.slice(5, 10); // 'abc12'</code>
  <p>Вернуть последний символ</p>
  <code>'12345abc'.slice(-1); // 'c'</code>

  <h3>Метод slice(). Особенности</h3>  
  <p>Без параметров возвращает копию строки</p>
  <code>'abcdefgh'.slice(); // 'abcdefgh'</code>
  <p>Можно указывать отрицательные значения</p>
  <code>'abcdefgh'.slice(-4, -2); // 'ef'</code>
  <p>Если первый параметр не число, то он явно приводится к числу</p>
  <code>'abcdefgh'.slice('4'); // 'efgh'</code>
  <p>Если первый параметр нельзя привести к числу, то он заменяется на 0</p>
  <code>'abcdefgh'.slice('4ff'); // 'abcdefgh'</code>
</article>


<!-- 25. split() -->
<article class="article">
  <div class="anchor" id="string-split"></div>
  <h3>25. Метод split([str, limit])</h3>
  <strong>Появился</strong> в ES1
  <br><strong>Принимает</strong> опционально строку в качестве разделителя и число, ограничивающее количество найденных подстрок
  <br><strong>Возвращает</strong> массив подстрок

  <h3>Задачи на метод split()</h3>
  <p>Вернуть массив с одним элементом - исходной строкой. Для этого применим метод без параметров</p>
  <code>'Frontend'.split(); // ['Frontend']</code>
  <p>Вернуть массив из всех символов исходной строки. Для этого в качестве параметра передадим пустую строку</p>
  <code>'Frontend'.split(''); // ['F', 'r', 'o', 'n', 't', 'e', 'n', 'd']</code>
  <p>Разделить строку на массив по пробелу</p>
  <code>'Front end developer'.split(' '); // ['Front', 'end', 'developer']</code>

  <h3>Метод split(). Особенности</h3>  
  <p>Второй параметр ограничивает длину возвращаемого массива</p>
  <code>'Frontend'.split('', 5); // ['F', 'r', 'o', 'n', 't']</code>
  <p>Сам разделитель не входит в возвращаемый массив</p>
  <code>'Frontend'.split('nt'); // ['Fro', 'end']</code>
</article>


<!-- 26. startsWith() -->
<article class="article">
  <div class="anchor" id="string-starts-with"></div>
  <h3>26. Метод startsWith(str[, position])</h3>
  <strong>Появился</strong> в ES6
  <br><strong>Принимает</strong> подстроку и опционально индекс с которого проверять совпадение подстроки
  <br><strong>Возвращает</strong> true если исходная строка с указанного индекса начинается на указанную подстроку, иначе возвращает false</p>

  <h3>Задачи на метод startsWith()</h3>
  <p>Проверить что строка начинается на '200'</p>
  <code>'200px'.startsWith('200'); // true</code>
  <p>Проверить что с 3 индекса строка начинается на 'px'</p>
  <code>'200px;'.startsWith('px', 3); // true</code>

  <h3>Метод startsWith(). Особенности</h3>
  <p>Без параметров возвращает false</p>
  <code>'abcdefgh'.startsWith(); // false</code>
  <p>Возвращает true если первый параметр пустая строка</p>
  <code>'abcdefgh'.startsWith(''); // true</code>
  <code>'abcdefgh'.startsWith('', null); // true</code>
</article>


<!-- 27. substring() -->
<article class="article">
  <div class="anchor" id="string-substring"></div>
  <h3>27. Метод substring(startIndex [, endIndex])</h3>
  <p><em>(Появился в <strong>ES1</strong>)</em></p>
  <br><strong>Принимает</strong> начальный индекс и опционально конечный индекс. Отрицательные индексы заменяются на 0
  <br><strong>Возвращает</strong> подстроку исходной строки между двумя индексами, или по-умолчанию до конца строки
  
  <h3>Задачи на метод substring()</h3>
  <p>Вернуть новую строку с пятого индекса</p>
  <code>'12345abc'.substring(5); // 'abc'</code>
  <p>Вернуть новую строку между 5 и 10 индексами</p>
  <code>'12345abc12345'.substring(5, 10); // 'abc12'</code>

  <h3>Метод substring(). Особенности</h3>  
  <p>Без параметров возвращает копию строки</p>
  <code>'abcdefgh'.substring(); // 'abcdefgh'</code>
  <p>Отрицательные индексы заменяются на 0. При одном отрицательном параметре вернется копия строки, при двух отрицательных параметрах вернется пустая строка</p>
  <code>'abcdefgh'.substring(-4); // 'abcdefgh'</code>
  <code>'abcdefgh'.substring(-4, -2); // ''</code>
  <p>Если первый параметр не число, то он явно приводится к числу</p>
  <code>'abcdefgh'.substring('4'); // 'efgh'</code>
  <p>Если первый параметр нельзя привести к числу, то он заменяется на 0</p>
  <code>'abcdefgh'.substring('4ff'); // 'abcdefgh'</code>
  <p>Если первый параметр нельзя привести к числу, то он заменяется на 0</p>
  <code>'abcdefgh'.substring('4ff'); // 'abcdefgh'</code>
  <p>В отличие от slice, можно задавать start больше, чем end. В этом случае индексы поменяются местами</p>
  <code>'abcdefgh'.substring(4, 1); // 'bcd'</code>
</article>


<!-- 28. toLocaleLowerCase() -->
<article class="article">
  <div class="anchor" id="string-to-local-lower-case"></div>
  <h3>28. Метод toLocaleLowerCase()</h3>
  <strong>Появился</strong> в ES1
  <br><strong>Не принимает параметры</strong>
  <br><strong>Возвращает</strong> строку с символами в нижнем регистре в соответствии с языком браузера
  
  <h3>Задачи на метод toLocaleLowerCase()</h3>
  <p>Привести все символы к нижнему регистру</p>
  <code>'HELLO'.toLocaleLowerCase(); // 'hello'</code>
</article>


<!-- 29. toLocaleUpperCase() -->
<article class="article">
  <div class="anchor" id="string-to-local-upper-case"></div>
  <h3>29. Метод toLocaleUpperCase()</h3>
  <strong>Появился</strong> в ES1
  <br><strong>Не принимает параметры</strong>
  <br><strong>Возвращает</strong> строку с символами в верхнем регистре в соответствии с языком браузера
  
  <h3>Задачи на метод toLocaleUpperCase()</h3>
  <p>Привести все символы к верхнему регистру</p>
  <code>'hello'.toLocaleUpperCase(); // 'HELLO'</code>
</article>


<!-- 30. toLowerCase() -->
<article class="article">
  <div class="anchor" id="string-to-lower-case"></div>
  <h3>30. Метод toLowerCase()</h3>
  <strong>Появился</strong> в ES1
  <br><strong>Не принимает параметры</strong>
  <br><strong>Возвращает</strong> строку с символами в нижнем регистре
  
  <h3>Задачи на метод toLowerCase()</h3>
  <p>Привести все символы к нижнему регистру</p>
  <code>'HELLO'.toLowerCase(); // 'hello'</code>
</article>


<!-- 31. toString() -->
<article class="article">
  <div class="anchor" id="string-to-string"></div>
  <h3>31. Метод toString()</h3>
  <strong>Появился</strong> в ES1
  <br><strong>Не принимает параметры</strong></p>
  <br><strong>Возвращает</strong> строку, представляющую указанный объект
  <p>Объект String переопределяет метод toString(), унаследованный из объекта Object; он не наследует метод Object.prototype.toString(). Для объектов String метод toString() возвращает строку, представляющую объект и делает тоже самое, что и метод String.prototype.valueOf().</p>

  <h3>Задачи на метод toString()</h3>
  <p>Привести к строке объект Stirng</p>
  <code>new String('Привет, мир').toString(); // 'Привет, мир'</code>

  <h3>Метод toString(). Особенности</h3>
  <br>new String('frontend').toString() === 'frontend'.toString(); // true</code>
  <p>Если применить к строке то создаст ее копию</p>
  <code>'Привет'.toString(); // 'Привет'</code>
  <p>Делает то же самое что и метод valueOf()</p>
  <code>'Привет'.toString() === 'Привет'.valueOf(); // true</code>
  <code>new String('Привет').toString() === new String('Привет').valueOf(); // true</code>
</article>


<!-- 32. toUpperCase() -->
<article class="article">
  <div class="anchor" id="string-to-upper-case"></div>
  <h3>32. Метод toUpperCase()</h3>
  <strong>Появился</strong> в ES1
  <br><strong>Не принимает параметры</strong>
  <br><strong>Возвращает</strong> строку с символами в верхнем регистре
  
  <h3>Задачи на метод toUpperCase()</h3>
  <p>Привести все символы к верхнему регистру</p>
  <code>'hello'.toUpperCase(); // 'HELLO'</code>
</article>


<!-- 33. toWellFormed() -->
<article class="article">
  <div class="anchor" id="string-to-well-formed"></div>
  <h3>33. Метод toWellFormed()</h3>
  <strong>Появился</strong> в ES2024
  <p><strong>Не принимает параметры</strong></p>
  <p><strong>Возвращает</strong> строку, где все одиночные суррогаты заменены на Unicode с символом U+FFFD</p>
  <p>Значения строк в ECMAScript представляют собой последовательность из 16-битных беззнаковых целочисленных значений.</p>
  <p>В правильно сформированных строках каждое целочисленное значение в последовательности представляет собой отдельную единицу UTF-16 юникодного текста. Однако не все последовательности представляют собой UTF-16 юникодный текст.</p>

  <p>Также в правильно сформированных строках кодовые единицы в диапазоне от 0xD800 до 0xDBFF (ведущие суррогаты) и от 0xDC00 до 0xDFFF (заключительные суррогаты) должны появляться парами и по порядку. Строки с непарными или неправильно упорядоченными суррогатами считаются неправильно сформированными.</p>
    
  <p>Новый стандарт предлагает ввести метод isWellFormed() для проверки, является ли строка правильно сформированной и метод toWellFormed() для замены любых одиночных или неправильно упорядоченных суррогатов, если они присутствуют, на U+FFFD (символ замены в Юникоде)</p>

  <h3>Задачи на метод toUpperCase()</h3>
  <p>Заменим все неправильно сформированные суррогаты на правильно сформированные</p>
<pre>if (!someString.isWellFormed()) {
  someString = someString.toWellFormed(); 
}</pre>
  <code>'ab\uD800'.toWellFormed(); // 'ab�'</code>
  <code>'new\uD800'.toWellFormed(); // 'new�'</code>
  <code>'hello'.toWellFormed(); // 'hello'</code>
</article>


<!-- 34. trim() -->
<article class="article">
  <div class="anchor" id="string-trim"></div>
  <h3>34. Метод trim()</h3>
  <strong>Появился</strong> в ES3
  <br><strong>Не принимает параметры</strong>
  <br><strong>Возвращает</strong> строку без пробелов в начале и конце строки

  <h3>Задачи на метод trim()</h3>
  <p>Обрезать пробелы в начале и в конце строки</p>
  <code>'   Frontend   '.trim(); // 'Frontend'</code>
</article>


<!-- 35. trimEnd() -->
<article class="article">
  <div class="anchor" id="string-trim-end"></div>
  <h3>35. Метод trimEnd()</h3>
  <strong>Появился</strong> в ES2019
  <br><strong>Не принимает параметры</strong>
  <br><strong>Возвращает</strong> строку без пробелов в конце строки

  <h3>Задачи на метод trimEnd()</h3>
  <p>Обрезать пробелы в конце строки</p>
  <code>'   Frontend   '.trimEnd(); // '   Frontend'</code>
</article>


<!-- 36. trimStart() -->
<article class="article">
  <div class="anchor" id="string-trim-start"></div>
  <h3>36. Метод trimStart()</h3>
  <strong>Появился</strong> в ES2019
  <br><strong>Не принимает параметры</strong>
  <br><strong>Возвращает</strong> строку без пробелов в начале строки

  <h3>Задачи на метод trimStart()</h3>
  <p>Обрезать пробелы в конце строки</p>
  <code>'   Frontend   '.trimStart(); // 'Frontend   '</code>
</article>


<!-- 37. valueOf() -->
<article class="article">
  <div class="anchor" id="string-value-of"></div>
  <h3>37. Метод valueOf()</h3>
  <strong>Появился</strong> в ES1
  <br><strong>Не принимает параметры</strong>
  <br>Возвращает примитивное значение объекта String в виде строкового типа данных. Это значение эквивалентно значению вызова метода String.prototype.toString()

  <h3>Задачи на метод valueOf()</h3>
  <p>Вернуть строковое значение объекта Stirng</p>
  <code>new String('Привет, мир').valueOf(); // 'Привет, мир'</code>

  <h3>Метод valueOf(). Особенности</h3>
  <br>new String('frontend').valueOf() === 'frontend'.valueOf(); // true</code>
  <p>Если применить к строке то создаст ее копию</p>
  <code>'Привет'.valueOf(); // 'Привет'</code>
  <p>Делает то же самое что и метод toString()</p>
  <code>'Привет'.toString() === 'Привет'.valueOf(); // true</code>
  <code>new String('Привет').toString() === new String('Привет').valueOf(); // true</code>
</article>
