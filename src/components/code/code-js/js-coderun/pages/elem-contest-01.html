<h1>Яндекс Контест</h1>


<!-- Ссылки -->
<article class="article">
  <h2>Ссылки</h2>
  <p><a href="https://contest.yandex.ru/">contest.yandex.ru</a></p>
  <p><a href="https://yandex.ru/support2/contest/ru/examples-stdin-stdout">Чтение и запись в stdin или stdout</a></p>
  <p><a href="https://github.com/chrisryana/yandex_algorithm">Задачи Яндекс.Контест</a></p>
  <p><a href="https://habr.com/ru/companies/yandex/articles/430560/">Фронтенд, алгоритмы и опоссум Фридрих. Разбираем задачи конкурса Яндекса</a></p>
  <p><a href="https://github.com/feeedback/yandex-interview-contest">Яндекс.Контест. Подготовка к собеседованию</a></p>
</article>


<!-- Содержание -->
<div class="article">
  <h2>Содержание</h2>

  <p><a href="#task-1">Чтение и запись</a></p>
  <p><a href="#task-a1">A. Камни и драгоценности</a></p>
  <p><a href="#task-b1">B. Последовательно идущие единицы</a></p>
  <p><a href="#task-c1">C. Удаление дубликатов</a></p>
</div>


<!-- Чтение и запись -->
<article class="article">
  <div class="anchor" id="task-1"></div>
  <h2>Чтение и запись</h2>

  <h4>Node JS 8.16 Чтение и запись в файл</h4>
<pre>const fs = require('fs')
let fileContent = fs.readFileSync("input.txt", "utf8");

const [a, b] = fileContent.toString().split(' ')

const result = Number(a) + Number(b)

fs.writeFileSync("output.txt", result.toString())</pre>

  <h4>Node JS 8.16 Чтение и запись в stdin или stdout</h4>
<pre>sum = (data) => {
  let mas = data.toString().split(' ');
  return +mas[0] + +mas[1];
};
       
let cnt, res;
process.stdin.on('data', data => {
  res = sum(data);
  process.stdout.write(res + '');
  process.exit();
});</pre>
</article>


<!-- A. Камни и украшения -->
<article class="article">
  <div class="anchor" id="task-a1"></div>
  <h2>A. Камни и драгоценности</h2>

  <h2>Описание</h2>
  <p>Даны две строки строчных латинских символов: строка J и строка S. Символы, входящие в строку J, — «драгоценности», входящие в строку S — «камни». Нужно определить, какое количество символов из S одновременно являются «драгоценностями». Проще говоря, нужно проверить, какое количество символов из S входит в J.</p>

  <h4>Формат ввода</h4>
  <p>На двух первых строках входного файла содержатся две строки строчных латинских символов: строка J и строка S. Длина каждой не превосходит 100 символов.</p>

  <h4>Формат вывода</h4>
  <p>Выходной файл должен содержать единственное число — количество камней, являющихся драгоценностями.</p>

  <h4>Пример</h4>
  <code>Ввод ab, aabbccd</code>
  <code>Вывод 4</code>

  <details>
    <summary>Решение</summary>
    <p>Для каждого символа из строки с камнями проверим входит ли он в строку с драгоценностями.</p>
    <p>Сложность линейная O(n). где n - длина строки с камнями</p>
<pre>function stonesAndJewelry(j, s) {
  let result = 0;
  for (let i = 0; i &lt; s.length; i++) {
    if (j.includes(s[i])) {
      result++;
    }
  }

  return result;
}</pre>
  <p>Тест</p>
  <code>let j1 = 'asdfgh';</code>
  <code>let s1 = 'fghjklfg';</code>
  <code>console.log(stonesAndJewelry(j1,s1)); // 5</code>
  </details>
</article>


<!-- B. Последовательно идущие единицы -->
<article class="article">
  <div class="anchor" id="task-b1"></div>
  <h2>B. Последовательно идущие единицы</h2>

  <h2>Описание</h2>
  <p>Требуется найти в бинарном векторе самую длинную последовательность единиц и вывести её длину.</p>
  <p>Желательно получить решение, работающее за линейное время и при этом проходящее по входному массиву только один раз.</p>

  <h4>Формат ввода</h4>
  <p>Первая строка входного файла содержит одно число n, n ≤ 10000. Каждая из следующих n строк содержит ровно одно число — очередной элемент массива.</p>

  <h4>Формат вывода</h4>
  <p>Выходной файл должен содержать единственное число — длину самой длинной последовательности единиц во входном массиве.</p>

  <h4>Пример</h4>
  <code>Ввод 5, 1, 0, 1, 0, 1</code>
  <code>Вывод 1</code>

  <details>
    <summary>Решение</summary>
    <p>Бинарный вектор это последовательность нулей и единиц длиной n. Соберем все аргументы функции из последовательности нулей и единиц в массив оператором rest. Заведем переменную result для результата и ones для текущей последовательности единиц. Пройдемся по массиву и будем считать все единицы записывая в ones, записывая максимальный результат в result. Если будет приходить 0, то ones сбрасываем в 0.</p>
    <p>Сложность линейная O(n). где n - длина вектора</p>
<pre>function togetherOnes(n, ...args) {
  let result = 0;
  let ones = 0;
  for (let i = 0; i &lt; args.length; i++) {
    if (args[i] === 1) {
      ones++;
      if (ones &gt; result) {
        result = ones;
      }
    } else {
      ones = 0;
    }
  }

  return result;
}</pre>
  <p>Тест</p>
  <code>console.log(togetherOnes(8, 1,1,1,0,1,0,1,1)); // 3</code>
  <code>console.log(togetherOnes(8, 1,0,0,0,1,0,1,1)); // 2</code>
  </details>
</article>


<!-- C. Удаление дубликатов -->
<article class="article">
  <div class="anchor" id="task-c1"></div>
  <h2>C. Удаление дубликатов</h2>

  <h2>Описание</h2>
  <p>Дан упорядоченный по неубыванию массив целых 32-разрядных чисел. Требуется удалить из него все повторения.</p>
  <p>Желательно получить решение, которое не считывает входной файл целиком в память, т.е., использует лишь константный объем памяти в процессе работы.</p>

  <h4>Формат ввода</h4>
  <p>Первая строка входного файла содержит единственное число n, n ≤ 1000000.</p>
  <p>На следующих n строк расположены числа — элементы массива, по одному на строку. Числа отсортированы по неубыванию.</p>

  <h4>Формат вывода</h4>
  <p>Выходной файл должен содержать следующие в порядке возрастания уникальные элементы входного массива.</p>

  <h4>Пример 1</h4>
  <code>Ввод 5, 2, 4, 8, 8, 8</code>
  <code>Вывод 2, 4, 8</code>

  <h4>Пример 2</h4>
  <code>Ввод 5, 2, 2, 2, 8, 8</code>
  <code>Вывод 2, 8</code>

  <details>
    <summary>Решение</summary>
    <p>Создаем массив result и сразу кладем в него первый элемент входного массива. Проходим по остальным элементам и если очередного элемента нет в массиве result то добавляем его</p>
    <p>Сложность линейная O(n). где n - длина входного массива</p>

<pre>function removeDuplicates(n, ...args) {
  let result = [args[0]];
  for (let i = 1; i &lt; args.length; i++) {
    if (result[result.length-1] !== args[i]) {
      result.push(args[i]);
    }
  }

  return result;
}</pre>
  <p>Тест</p>
  <code>console.log(removeDuplicates(5, 2,2,2,6,8)); // [2,6,8]</code>
  <code>console.log(removeDuplicates(5, 2,2,4,8,8,8)); // [2,4,8]</code>
  <code>console.log(removeDuplicates(5, 2,3,3,6,8,8,9)); // [2,3,6,8,9]</code>
  </details>



