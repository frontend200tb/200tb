<h1>JavaScript</h1>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p><a href="#links">links</a></p>
  <p><a href="#games">Игры для обучения</a></p>
  <p><a href="#es">ECMAScript</a></p>
  <p><a href="#expression">Выражение (expression)</a></p>
  <p><a href="#variable">Переменная</a></p>
  <p><a href="#typeof">Типы данных</a></p>
  <p><a href="#func">Функции</a></p>
  <p><a href="#error">Обработка ошибок</a></p>
  <p><a href="#statement">Инструкция (statement)</a></p>
  <p><a href="#if">Условие (if, switch)</a></p>
  <p><a href="#for">Цикл (for, while)</a></p>
</article>


<!-- links -->
<article class="article">
  <div class="anchor" id="links"></div>
  <h2>links</h2>

  <p><a href="https://es5.javascript.ru/">es5.javascript.ru</a> Перевод стандарта ES5</p>
  <p><a href="https://doka.guide/js/">doka.guide/js</a> Дока — это документация для разработчиков на понятном языке</p>
  <p><a href="https://my-js.org/">my-js.org</a> MyJavaScript Руководства, шпаргалки</p>
  <p><a href="https://metanit.com/web/javascript/">metanit.com/web/javascript</a> Руководство по JavaScript (обновление 2023-07-15)</p>
  <p><a href="https://jsexpert.net/handbook/">jsexpert.net/handbook/</a> JavaScript справочник</p>
  <p><a href="https://www.w3resource.com/javascript-exercises/">w3resource.com/javascript-exercises/</a> JavaScript упражнения</p>
  <p><a href="https://www.30secondsofcode.org/">30secondsofcode.org</a> 30secondsofcode.org</p>
  <p><a href="https://www.javascripttutorial.net/">javascripttutorial.net</a> JavaScript Tutorial</p>

  <h3>Статьи на habr</h3>

  <p><a href="https://habr.com/ru/articles/188010/">Знай сложности алгоритмов</a> (Eric Rowell 2013-07-29)</p>
  <p><a href="https://habr.com/ru/articles/196560/">Введение в анализ сложности алгоритмов (часть 1)</a> (Dionysis Zindros 2013-10-07)</p>
  <p><a href="https://habr.com/ru/companies/livetyping/articles/324196/">Краткая история JavaScript. Часть 1</a> (Андрей Руденко 2017-03-17)</p>
  <p><a href="https://habr.com/ru/companies/livetyping/articles/324506/">Краткая история JavaScript. Часть 2</a> (Андрей Руденко 2017-03-21)</p>
  <p><a href="https://habr.com/ru/companies/livetyping/articles/324908/">Краткая история JavaScript. Часть 3</a> (Андрей Руденко 2017-03-27)</p>
  <p><a href="https://habr.com/ru/articles/740934/">ECMAScript 2015, 2016, 2017, 2018, 2019, 2020, 2021</a> (Ирина Мельникова @JetBlackCodes 2023-06-09)</p>
  <p><a href="https://habr.com/ru/articles/741372/">Новые возможности ECMAScript 2021-2023</a> (Ирина Мельникова @JetBlackCodes 2023-06-13)</p>
  <p><a href="https://habr.com/ru/post/518386/">JavaScript: полное руководство по классам</a> (Dmitri Pavlutin 2020-09-09)</p>
  <p><a href="https://habr.com/ru/post/522380/">Объектно-ориентированный JavaScript простыми словами</a> (Zell Liew 2020-10-07)</p>
  <p><a href="https://habr.com/ru/company/otus/blog/547098/">Основы JavaScript: почему вы должны знать, как работает JS-движок</a> (OTUS 2021-03-15)</p>
  <p><a href="https://habr.com/ru/post/552076/">Используй console.log () как про</a> (Marko Denic 2021-04-12)</p>
  <p><a href="https://habr.com/ru/company/ruvds/blog/554288/">JavaScript-классы — это не просто «синтаксический сахар»</a> (Andrea Giammarchi 2021-05-03)</p>
  <p><a href="https://habr.com/ru/company/ruvds/blog/665290/">Знакомство с ООП на примере JavaScript</a> (Germán Cocca 2022-05-15)</p>
  <p><a href="https://habr.com/ru/post/666972/">20+ консольных команд, которые изменят ваше представление об отладке</a> (Web Dev Simplified 2022-05-20)</p>
  <p><a href="https://habr.com/ru/post/667662/">Приведение значений к Boolean в JavaScript</a> (Natalie Pina 2022-05-25)</p>
  <p><a href="https://habr.com/ru/companies/yandex/articles/718084/">Полное понимание асинхронности в браузере</a> (gbiz 2023-02-28)</p>
  <p><a href="https://habr.com/ru/articles/216997/">Размышления о стандартной библиотеке JavaScript. Core.js</a> (2014-11-18)</p>

  <h3>Статьи</h3>

  <p><a href="https://dmitripavlutin.com/javascript-classes-complete-guide/">The Complete Guide to JavaScript Classes</a> (Dmitri Pavlutin 2019-12-11)</p>
  <p><a href="https://frontend-stuff.com/blog/object-oriented-programming/">ООП в JavaScript Вкратце об объектно-ориентированном программировании</a> (Alexey Myzgin 2020-01-24)</p>
  <p><a href="https://gcoder.ru/gajd-dlya-razvitiya-frontend-razrabotchika-v-2021/">ГАЙД ДЛЯ РАЗВИТИЯ ФРОНТЕНД-РАЗРАБОТЧИКА В 2021</a></p>
  <p><a href="https://ru.hexlet.io/blog/posts/js-s-chego-nachat">С чего начать изучение JavaScript и как это делать эффективно</a> (Екатерина Самохвалова 2022-09-22)</p>
  <p><a href="https://ru.hexlet.io/blog/posts/stoit-li-uchit-javascript-perspektivy-situatsiya-na-rynke-truda-mneniya-ekspertov">Стоит ли учить JavaScript: перспективы, ситуация на рынке труда, мнения экспертов</a> (Дмитрий Дементий 2023-01-10)</p>

  <h3>Статьи на habr. Подготовка к собеседованию</h3>

  <p><a href="https://habr.com/ru/company/ruvds/blog/505480/">Как пройти собеседование в GitLab, попасть в команду разработчиков Vue и стать Staff-engineer</a> (RUVDS.com 2020-06-06)</p>
  <p><a href="https://habr.com/ru/company/prequel/blog/666136/">Войти в IT в 27 лет. Что получилось за 4 года</a> (Prequel 2022-05-17)</p>
  <p><a href="https://habr.com/ru/company/netologyru/blog/667520/">Что спрашивают у начинающего разработчика JavaScript на собеседованиях и в тестовых заданиях</a> (Нетология 2022-05-24)</p>

  <h3>Статьи. Подготовка к собеседованию</h3>

  <p><a href="https://gcoder.ru/kak-ponyat-chto-vy-gotovy-zanyat-poziciyu-front-end-razrabotchika/">КАК ПОНЯТЬ, ЧТО ВЫ ГОТОВЫ ЗАНЯТЬ ПОЗИЦИЮ FRONT-END РАЗРАБОТЧИКА</a> (2020-12-30)</p>
  <p><a href="https://tproger.ru/problems/sobesedovanie-na-poziciju-middle-javascript-razrabotchika-primery-zadach-i-neobhodimye-znanija/">Собеседование на позицию Middle JavaScript разработчика: примеры задач и необходимые знания</a> (Дмитрий Шостак 2021-01-27)</p>
  <p><a href="https://webdevblog.ru/7-voprosov-dlya-sobesedovaniya-o-zamykanie-v-javascript-smozhete-li-vy-na-nih-otvetit/">7 вопросов для собеседования о замыкание в JavaScript. Сможете ли вы на них ответить</a> (Dmitri Pavlutin 2021-02-15)</p>
  <p><a href="https://gcoder.ru/5-sovetov-dlya-pervogo-goda-raboty-junior-razrabotchika/">5 СОВЕТОВ ДЛЯ ПЕРВОГО ГОДА РАБОТЫ JUNIOR РАЗРАБОТЧИКА</a> (2021-03-17)</p>
  <p><a href="https://ru.hexlet.io/blog/posts/kak-dzhunu-napisat-soprovoditelnoe-pismo">Как джуну написать сопроводительное письмо, за которое его возьмут на работу</a> (Наталья Ёркина 2022-02-02)</p>
  <p><a href="https://ru.hexlet.io/blog/posts/kak-dzhunu-nayti-rabotu-i-gde-nachinat-karieru">Как джуну найти работу и где лучше начинать карьеру в IT: советы от Хекслета</a> (Екатерина Самохвалова 2023-04-14)</p>
</article>


<!-- Игры для обучения -->
<article class="article">
  <div class="anchor" id="games"></div>
  <h2>Игры для обучения</h2>

  <a href="https://codecombat.com/">codecombat.com</a>
</article>


<!-- ECMAScript -->
<article class="article">
  <div class="anchor" id="es"></div>
  <h2>ECMAScript Editions</h2>
  <table class="ws-table-all">
  <tbody><tr>
  <th>Ver</th>
  <th>Official Name</th>
  <th>Дата выхода</th>
  <th>Description</th>
  </tr>
  <tr>
  <td>ES1</td>
  <td>ECMAScript 1</td>
  <td>Июнь 1997</td>
  <td>First edition</td>
  </tr>
  <tr class="tr-space"></tr>
  <tr>
  <td>ES2</td>
  <td>ECMAScript 2</td>
  <td>Июнь 1998</td>
  <td>Editorial changes</td>
  </tr>
  <tr class="tr-space"></tr>
  <tr>
  <td>ES3</td>
  <td>ECMAScript 3 (1999)</td>
  <td>Декабрь 1999</td>
  <td>Added regular expressions<br>
  Added try/catch<br>
  Added switch<br>
  Added do-while</td>
  </tr>
  <tr class="tr-space"></tr>
  <tr>
  <td>ES4</td>
  <td>ECMAScript 4</td>
  <td>Не выпущена</td>
  <td>Never released</td>
  </tr>
  <tr>
  <td>ES5</td>
  <td>ECMAScript 5 (2009)</td>
  <td>Декабрь 2009</td>
  <td>
  Added "strict mode"<br>
  Added JSON support<br>
  Added String.trim()<br>
  Added Array.isArray()<br>
  Added Array iteration methods<br>
  Allows trailing commas for object literals<br>
  </td>
  </tr>
  <tr>
  <td>ES6</td>
  <td>ECMAScript 2015</td>
  <td>Июнь 2015</td>
  <td>Added let and const<br>
  Added default parameter values<br>
  Added Array.find()<br>
  Added Array.findIndex()<br>
  </td>
  </tr>
  <tr>
  <td>ES7</td>
  <td>ECMAScript 2016</td>
  <td>Июнь 2016</td>
  <td>Added exponential operator (**)<br>
  Added Array.includes()
  </td>
  </tr>
  <tr>
  <td>ES8</td>
  <td>ECMAScript 2017</td>
  <td>Июнь 2017</td>
  <td>Added string padding<br>
  Added Object.entries()<br>
  Added Object.values()<br>
  Added async functions<br>
  Added shared memory<br>
  Allows trailing commas for function parameters<br>
  </td>
  </tr>
  <tr>
  <td>ES9</td>
  <td>ECMAScript 2018</td>
  <td>Июнь 2018</td>
  <td>
  Added rest / spread properties<br>
  Added asynchronous iteration<br>
  Added Promise.finally()<br>
  Additions to RegExp
  </td>
  </tr>
  <tr>
  <td>ES10</td>
  <td>ECMAScript 2019</td>
  <td>Июнь 2019</td>
  <td>
  String.trimStart()<br>
  String.trimEnd()<br>
  Array.flat()<br>
  Object.fromEntries<br>
  Optional catch binding
  </td>
  </tr>
  <tr>
  <td>ES11</td>
  <td>ECMAScript 2020</td>
  <td>Июнь 2020</td>
  <td>
  The Nullish Coalescing Operator (??)<br>
  </td>
  </tr>

  </tbody></table>
</article>


<!-- Выражение (expression) -->
<article class="article">
  <div class="anchor" id="expression"></div>
  <h2>Выражение (expression)</h2>

  <p>Выражение всегда возвращает значение.</p>
  <p>Число это выражение. Если записать число, интерпретатор вернет это число</p>
  <code>10 // 10</code>

  <p>Сложение чисел это выражение. Результатом будет число</p>
  <code>5 + 2 // 7</code>

  <p>Строка это выражение. Если записать строку, интерпретатор вернет эту строку</p>
  <code>'abc' // 'abc'</code>

  <p>Конкатенация строк это выражение. Результатом будет одна строка</p>
  <code>'Привет ' + 'мир' // 'Привет мир'</code>

  <p>Выражение с логическими операторами вернет логическое значение</p>
  <code>a > b || c !== d</code>

  <p>Вызов функции это выражение. Функция всегда возвращает значение.</p>
  <code>myFunction(a, b)</code>

  <p>Присваивание значения переменной это выражение. Оно вернет значение переменной.</p>
  <code>a = 5 // 5</code>
</article>


<!-- Переменная -->
<article class="article">
  <div class="anchor" id="variable"></div>
  <h2>Переменная</h2>

  <p>Переменная сохраняет значение для повторного доступа к этому значению. Переменная это как контейнер, который хранит в себе какое-то значение.</p>

  <hr>

  <h3>Имена переменных</h3>

  <ol>
    <li>
      <h4>PascalCase</h4>
      <p>Так называют типы и классы.</p>
    </li>
    <li>
      <h4>DB_PASSWORD</h4>
      <p>Так называют константы, которые известны до запуска приложения и не меняются.</p>
    </li>
    <li>
      <h4>camelCase</h4>
      <p>Так называют переменные и функции.</p>
    </li>
  </ol>

  <p>Имена переменных должны быть понятными.</p>

  <hr>

  <h3>Объявление переменных</h3>
  <p>Способы объявления переменных</p>
  <ol>
    <li>
      <h4>var</h4>
      <h4>Scope (область видимости)</h4>
      <p>Функциональная область видимости если объявлена внутри функции. Глобальная область видимости если объявлена вне функции</p>
      <h4>Hoisting</h4>
      <p>Поднимается наверх своей области видимости с инициализацией значением undefined</p>
      <h4>Re-declaration</h4>
      <p>Может быть переобъявлена в той же области видимости</p>
      <h4>Mutability</h4>
      <p>Может изменять свое значение</p>
    </li>
    <li>
      <h4>let</h4>
      <p>Появился в es6.</p>
      <h4>Scope (область видимости)</h4>
      <p>Блочная область видимости. Ограничена блоком, в котором она объявлена</p>
      <h4>Hoisting</h4>
      <p>Поднимается наверх своей области видимости, но не инициализирована (temporal dead zone)</p>
      <h4>Re-declaration</h4>
      <p>Не может быть переобъявлена в той же области видимости</p>
      <h4>Mutability</h4>
      <p>Может изменять свое значение</p>
    </li>
    <li>
      <h4>const</h4>
      <p>Появился в es6.</p>
      <h4>Scope (область видимости)</h4>
      <p>Блочная область видимости. Ограничена блоком, в котором она объявлена</p>
      <h4>Hoisting</h4>
      <p>Поднимается наверх своей области видимости, но не инициализирована (temporal dead zone)</p>
      <h4>Re-declaration</h4>
      <p>Не может быть переобъявлена в той же области видимости</p>
      <h4>Mutability</h4>
      <p>Не может изменять свое значение для примитивных типов. Однако для объектов и массивов, свойства или элементы могут быть изменены</p>
    </li>
  </ol>

  <hr>

  <h3>Тип переменной</h3>
  <p>Тип переменной определяется типом присвоенного значения.</p>
</article>


<!-- Типы данных -->
<article class="article">
  <div class="anchor" id="typeof"></div>
  <h2>Типы данных</h2>

  <p>В js есть 7 примитивных типов и один ссылочный тип</p>

  <hr>

  <h3>Примитивные типы</h3>
  <ol>
    <li>number</li>
    <li>string</li>
    <li>boolean</li>
    <li>null</li>
    <li>undefined</li>
    <li>bigint</li>
    <li>symbol</li>
  </ol>
  <p>Если переменной присвоить значение примитивного типа, то переменная будет содержать само значение.</p>

  <hr>

  <h3>Ссылочный тип</h3>
  <ol>
    <li>object</li>
  </ol>
  <p>К ссылочному типу object также относятся массив (array) и функция (function).</p>
  <p>Если переменной присвоить значение ссылочного типа, то переменная будет соделжать ссылку на адрес в памяти, где записан сам объект. Объект хранится в области памяти. Объект не хранится в переменной. В переменной хранится только ссылка на область памяти.</p>
  <p>Можно иметь много разных переменных, которые указывают на один и тот же объект. Если обратиться к любой такой переменной и изменить в объекте любое свойство, то объект изменится во всех переменных, ссылающихся на него.</p>

  <hr>

  <h3>Статическая и динамическая типизация</h3>
  <p>В языках со статической типизацией при объявлении переменной указывается ее тип. Тип переменной изменить уже нельзя. Он остается постоянный (статичкеским).</p>
  <p>В языках с динамической типизацией, как в js, при объявлении переменной не нужно указывать ее тип. Переменная принимает тип присвоенного ей значения. Если потом в переменную записать другое значение с другим типом, то тип переменной тоже изменится.</p>
</article>


<!-- Функции -->
<article class="article">
  <div class="anchor" id="func"></div>
  <h2>Функции</h2>

  <p>Рассмотрим разницу между функциями</p>
  <ol>
    <li>
      <h4>Объявленная функция (function declaration)</h4></li>
    <li>
      <h4>Функциональное выражение (function expression)</h4>
    </li>
    <li>
      <h4>Стрелочная функция (arrow function)</h4>
    </li>
  </ol>

  <h3>Объявленная функция (function declaration)</h3>
  <p>Создается переменная с именем myFn значением которой является функция.</p>
<pre>function myFn(a, b) {
  return a + b;
}</pre>
  <p>Впоследствии такую переменную можно перезаписать с другим значением и функция потеряется.</p>

  <h3>Функциональное выражение (function expression)</h3>
  <p>Функциональное выражение не имеет имени. Оно всегда анонимное.</p>
<pre>function(a, b) {
  return a + b;
}</pre>

  <p>Функциональное выражение можно присвоить переменной и вызывать его через эту переменную.</p>
<pre>const myFn = function(a, b) {
  return a + b;
}</pre>
<p>Впоследствии такую переменную нельзя перезаписать с другим значением и функция не потеряется.</p>

  <p>Функциональное выражение часто используют в callback функциях.</p>
<pre>setTimeout(function() {
  console.log('сообщение');
}, 1000)</pre>

  <h3>Стрелочная функция (arrow function)</h3>
  <p>Стрелочная функция не имеет имени. Она всегда анонимная. Для нее не пишется слово function. Начинается со скобок. В скобках пишутся параметры. Если параметров нет, то скобки остаются пустыми. После скобок пишется знак => который похож на стрелку вправо. После идет тело функции.</p>
<pre>(a, b) => {
  return a + b;
}</pre>

  <p>Стрелочную функцию можно присвоить переменной и вызывать ее через эту переменную.</p>
<pre>const myFn = (a, b) => {
  return a + b;
}</pre>
  <p>Впоследствии такую переменную нельзя перезаписать с другим значением и функция не потеряется.</p>

<p>Стрелочную функцию часто используют в callback функциях.</p>
<pre>setTimeout( () => {
  console.log('сообщение');
}, 1000)</pre>

  <p>Синтаксис стрелочной функции можно сократить.</p>
  <ul>
    <li>Если у стрелочной функции только один параметр, то круглые скобки можно опустить.
      <code>a => { retutn a + a }</code>
    </li>
    <li>Если тело стрелочной функции состоит только из одного выражения, то фигурные скобки можно опустить. Стрелочная функция вернет результат этого выражения. Поэтому слово return тоже можно опустить.
      <code>a => a + a</code>
    </li>
  </ul>
</article>


<!-- Обработка ошибок -->
<article class="article">
  <div class="anchor" id="error"></div>
  <h2>Обработка ошибок</h2>

  <p>Мы можем самостоятельно сгенерировать ошибки. Например, бросим ошибку внутри функции</p>
<pre>function fn() {
  throw new Error('some error');
}
fn() // выполнение кода остановится, поскольку появилась необработанная ошибка</pre>

<h3>Блок try/catch</h3>
<p>Для обработки ошибок используется блок try/catch. Выполнение кода не останавливается, а продолжается.</p>
<pre>try {
  // блок кода в котором может появиться ошибка
} catch (error) {
  // блок кода выполнится в случае ошибки в блоке try
}</pre>
<pre>try {
  throw new Error('some error');
} catch (error) {
  console.log(error.message); // выведет в консоль 'some error'
}
// выполнение кода продолжится, поскольку ошибка обработана</pre>
</article>


<!-- Инструкция (statement) -->
<article class="article">
  <div class="anchor" id="statement"></div>
  <h2>Инструкция (statement)</h2>

  <p>Есть выражение, инструкция и выражение-инструкция</p>
  <p>Выражение всегда возвращает значение. Например, присваивание значения переменной это выражение.</p>
  <code>a = 5</code>

  <p>Инструкция выполняет действие. Например, объявление переменной</p>
  <code>let a</code>

  <p>Выражение может стать инструкцией и получится выражение-инструкция. Но не наоборот, инструкция не может стать выражением.</p>

  <h3>Инструкции</h3>
  <p>Каждую инструкцию надо завершать точкой с запятой. Исключение: после блока инструкций, точка с запятой не требуется. Инструкции надо размещать на разных строках.</p>
  <p>Объявление переменной это инструкция</p>
  <code>let a;</code>

  <p>Объявление и инициализация переменной это инструкция</p>
  <code>let a = 5;</code>

  <p>Конструкция if это инструкция</p>
<pre>if (a > b) {
  console.log('a');
}</pre>

  <p>Конструкция for это инструкция</p>
<pre>for (let i = 0; i &lt; 5; i++) {
  console.log(i);
}</pre>

  <h3>Выражения-инструкции</h3>
  <p>Строка это выражение. Если после выражения поставить точку с запятой то это станет выражение-инструкция</p>
  <code>'abc';</code>

  <p>Присваивание это выражение. Если записать присваивание на отдельной строке и поставить точку с запятой то это станет выражение-инструкция.</p>
  <code>a = a + 3;</code>

  <p>Вызов функции это выражение. Любая функция возвращает значение. Если поставить в конце точку с запятой то она станет выражение-инструкция.</p>
  <code>myFn(a, b);</code>

  <h3>Отличия выражения от выражения-инструкции</h3>
  <p>Выражения могут быть использованы как аргументы в вызовах функций</p>
  <code>myFn(2 + 3);</code>
  <code>myFn(c = 2 + 3);</code>
  <p>Иструкции не могут быть использованы как аргументы в вызовах функций. Это приведет к ошибке</p>
  <code>myFn(let c); // uncaught SyntaxError</code>
  <code>myFn(c = 2 + 3;); // uncaught SyntaxError</code>
</article>


<!-- Условие (if, switch) -->
<article class="article">
  <div class="anchor" id="if"></div>
  <h2>Условие (if, switch)</h2>

  <ol>
    <li>if</li>
    <li>if else</li>
    <li>if else if</li>
    <li>switch</li>
    <li>Тернарный оператор</li>
  </ol>

  <h3>Инструкция if</h3>
  <p>Если условие истинно, то выполнится блок кода. Если ложно - то не выполнится.</p>
<pre>if (условие) {
  // блок кода
}</pre>

  <p>Если a больше 1, увеличим а на 1.</p>
<pre>let a = 5
if (a > 1) {
  a += 1
}</pre>

  <p>Если в объекте a нет свойства с, создадим в объекте а свойство с со значением 2.</p>
<pre>let a = {b: 1}
if (!a.c) {
  a.c = 2
}</pre>

  <h3>Инструкция if else</h3>
  <p>Если условие истинно, то выполнится блок кода 1. Если ложно - блок кода 2. Блок кода точно выполнится, но только один из них.</p>
<pre>if (условие) {
  // блок кода 1
} else {
  // блок кода 2
}</pre>

  <h3>Инструкция if else if</h3>
  <p>Сначала проверяется первое условие if. Если условие истинно, то выполнится блок кода 1. Если ложно - проверяется второе условие else if. Если условие истинно, то выполнится блок кода 2. Если ложно - выполнится блок кода 3. Блок кода точно выполнится, но только один из них.</p>
<pre>if (условие 1) {
  // блок кода 1
} else if (условие 2) {
  // блок кода 2
} else {
  // блок кода 3
}</pre>

  <h3>Инструкция switch</h3>
  <p>Сначала вычисляется выражение, если результат равен A, то выполнится блок кода 1, если B - блок кода 2. Если нет ни одного совпадения то выполнится блок кода по-умолчанию</p>
<pre>switch (выражение) {
  case A:
    // блок кода 1
    break;
  case B:
    // блок кода 2
    break;
  default:
    // блок кода по-умолчанию
}</pre>

  <p>Если не записать break, то будут выполняться все блоки кода, пока не встретиться break или пока не закончится switch</p>
<pre>switch (выражение) {
  case A:
    // блок кода 1
  case B:
    // блок кода 2
  default:
    // блок кода по-умолчанию
}</pre>

  <h3>Тернарный оператор</h3>
  <p>У тернарного оператора три операнда. Конструкция с тернарным оператором это выражение. Выражение возвращает значение. Если условие истинно, то возвращается Выражение 1, если ложно - Выражение 2.</p>
  <code>Условие ? Выражение 1 : Выражение 2</code>
</article>


<!-- Цикл (for, while) -->
<article class="article">
  <div class="anchor" id="for"></div>
  <h2>Цикл (for, while)</h2>

  <ol>
    <li>for</li>
    <li>while</li>
    <li>do while</li>
    <li>for in для объектов</li>
    <li>for in для массивов</li>
    <li>for of</li>
  </ol>

  <h3>Цикл for</h3>
<pre>for (let i = 0; i &lt; 5; i++ {
  console.log(i);
}</pre>

  <p>Цикл for можно использовать для массивов.</p>
<pre>const arr = ['A', 'B', 'C']
  for (let i = 0; i &lt; arr.length; i++ {
  console.log(arr[i]);
}</pre>

  <p>Но это не рекомендуется. Рекомендуется использовать функции высшего порядка forEach, map и другие.</p>
  <p>forEach выполняет действия с каждым элементом массива и возвращает undefined</p>
<pre>const arr = ['A', 'B', 'C']
  arr.forEach((element, index, array) => {
    console.log(element, index);
})</pre>

  <h3>Цикл while</h3>
  <p>Сначала проверяется условие. Если условие истинно, то выполняется блок кода. После чего опять проверяется условие.</p>
<pre>while (условие) {
  // блок кода
}</pre>
<pre>let i = 0
while (i &lt; 5) {
  console.log(i)
  i++
}</pre>
  <p>Если условие ложно, то цикл while ни разу не выполнится.</p>

  <h3>Цикл do while</h3>
  <p>Сначала выполняется блок кода. После чего проверяется условие. Если условие истинно, то опять выполняется блок кода и опять проверяется условие.</p>
<pre>do {
  // блок кода
} while (условие)</pre>
<pre>let i = 0
do {
  console.log(i)
  i++
} while (i &lt; 5)</pre>
  <p>Цикл do while всегда выполнится хотя бы один раз, даже если условие ложно.</p>

  <h3>Цикл for in для объектов</h3>
  <p>Перебирает все свойства (key) объекта (obj). Перебирает не только собственные свойства, но и унаследованные.</p>
<pre>for (let key in obj) {
  // блок кода выполняется для каждого свойства
}</pre>
<pre>const obj = {a: 'A', b: 'B', c: 'C'}
for (let key in obj) {
  console.log (`${key} : ${obj[key]}`)
}</pre>

  <p>Для объектов можно использовать методы keys и values, чтобы получить массив ключей и массив значений и работать с этими массивами уже методами массивов. Метод keys возвращает только собственные свойства.</p>
<pre>const obj = {a: 'A', b: 'B', c: 'C'}

Object.keys(obj).forEach(key => {
  console.log(key, obj[key])
})

Object.values(obj).forEach(value => {
  console.log(value)
})</pre>

  <h3>Цикл for in для массивов</h3>
  <p>Циклом for in можно перебрать ключи массива</p>
<pre>const arr = ['A', 'B', 'C']
for (let key in arr) {
  console.log(arr[key])
}</pre>
  <p>Но так делать не рекомендуется. Рекомендуется использовать forEach - родной метод массива.</p>

  <h3>Цикл for of</h3>
  <p>Оператор for of выполняет цикл обхода итерируемых объектов. Например, Array, Map, Set, String, arguments.</p>
<pre>for (element of iterable) {
  // блок кода
}</pre>

  <p>Строка это итерируемый объект. Можно перебирать все символы строки</p>
<pre>const str = 'abcde'
for (let char of str) {
  console.log(char)
}</pre>

  <p>Циклом for of можно перебрать элементы массива</p>
<pre>const arr = ['A', 'B', 'C']
for (let element of arr) {
  console.log(element)
}</pre>

  <p>Цикл for of нельзя использовать для объектов.</p>
</article>

