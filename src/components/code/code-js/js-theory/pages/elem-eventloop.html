<h1>Event Loop</h1>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p><a href="#links">links</a></p>
  <p><a href="#evloop">eventloop</a></p>
  <ol>
    <li><a href="#terms">Термины</a></li>
    <li><a href="#eventloop">Как работает Event Loop</a></li>
    <li><a href="#callstack">Как работает Call Stack</a></li>
    <li><a href="#webapi">Как работает Web API</a></li>
    <li><a href="#microtask">Очередь Microtask</a></li>
    <li><a href="#macrotask">Очередь Macrotask</a></li>
    <li><a href="#raf">Очередь requestAnimationFrame</a></li>
    <li><a href="#ric">Очередь requestIdleCallback</a></li>
    <li><a href="#queue">Сравнение очередей</a></li>
    <li><a href="#render">Render (отрисовка страницы)</a></li>
  </ol>

</article>


<!-- links -->
<article class="article">
  <div class="anchor" id="links"></div>
  <h3>links</h3>

  <p><a href="https://coderoad.ru/25915634/%D0%A0%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D0%B0-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-%D0%BC%D0%B8%D0%BA%D1%80%D0%BE%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B5%D0%B9-%D0%B8-%D0%BC%D0%B0%D0%BA%D1%80%D0%BE%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B5%D0%B9-%D0%B2-%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%BA%D1%81%D1%82%D0%B5-%D1%86%D0%B8%D0%BA%D0%BB%D0%B0-%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B9">coderoad.ru</a> Разница между микрозадачей и макрозадачей в контексте цикла событий</p>

  <h3>Ссылки на habr</h3>
  <p><a href="https://habr.com/ru/articles/680846/">Базовое понимание принципа Eventloop</a> (2022.08.02)</p>
  <p><a href="https://habr.com/ru/companies/yandex/articles/718084/">Полное понимание асинхронности в браузере</a> (2023.02.28)</p>
</article>


<!-- eventloop -->
<article class="article">
  <div class="anchor" id="evloop"></div>
  <h3>Eventloop</h3>

  <p>Для работы сайта браузер выделяет один-единственный поток, который должен успевать одновременно делать две важные задачи: выполнять код и обновлять интерфейс. Но один поток в один момент времени может совершать только одно действие. Поэтому поток выполняет эти задачи по очереди, чтобы создать иллюзию параллельного выполнения. Это и есть цикл событий (event loop).</p>
  <p>JS это синхронный язык программирования и выполняется в один поток</p>
</article>


<!-- terms -->
<article class="article">
  <div class="anchor" id="terms"></div>
  <h3>Термины</h3>

  <p><strong>Event Loop (цикл событий)</strong> это специальный механизм, который работает с Heap (куча), Call Stack (стек вызовов), Web API (API, предоставляемый браузером), Callback Queue (очередь колбэков) и Render (отрисовка страницы).</p>

  <p><strong>Heap (куча)</strong> это область памяти, где хранятся объекты.</p>

  <p><strong>Call stack (стек вызовов)</strong> участок памяти организованный ввиде стека LIFO, в который попадают вызванные функции после чего выполняются.</p>

  <p><strong>Tick</strong> это одна итерация event loop и она забирает из стека вызовов одну задачу (task) и выполняет ее.</p>

  <p><strong>Web API</strong> это интерфейс, предоставляемый браузером. С помощью него мы можем взаимодействовать с DOM-деревом, таймерами, отслеживать клики по элементам, отправлять запросы и т.д.</p>

  <p><strong>Callback Queue (очередь колбеков)</strong> внутри себя имеет две очереди для макротасок и для микротасок.</p>

  <p><strong>Microtask queue (очередь микротасок)</strong> сюда также попадают функции, но в отличии от макро - микро таски будут выполняться до тех пор, пока они есть в очереди, и перед макротасками им отдается приоритет.</p>

  <p><strong>Render queue (очередь рендера)</strong> сюда попадают задачи на отрисовку страницы</p>

  <p><strong>Macrotask queue (очередь макротасок)</strong> сюда попадают некоторые функции (по принципу FIFO какие именно мы разберем далее), и если callstack пустой, то первая из очереди будет помещена в callstack и доступна к выполнению. Далее как только callstack очистится, будет вызвана следующая и т.д.</p>
</article>


<!-- Как работает Event loop -->
<article class="article">
  <div class="anchor" id="eventloop"></div>
  <h3>Как работает Event loop</h3>

  <ol>
    <li>Сначала Event Loop проходится по синхронному коду и последовательно его разбирает.</li>
    <li>Если видит объявление объекта, переменной, функции и т.д. то сохраняет их в памяти Heap (куча).</li>
    <li>Если видит команду или вызов функции то передает ее в Call Stack для выполнения</li>
    <li>Когда в Call Stack попадает команда или функция она сразу же выполняется и удаляется из Call Stack и Event Loop продолжает проходить по синхронному коду</li>
    <li>Если команда из Call Stack изменяет DOM-дерево, то задача на изменение DOM-дерева попадает в очередь Render</li>
    <li>Если в Call Stack попадает функция, которая вызывает другую функцию, то первая функция не удалияется из Call Stack пока не выполнится и удалится вторая функция.</li>
    <li>Когда Call Stack становится пуст, то Event Loop продолжает проходить по синхронному коду.</li>
    <li>Когда  Call Stack становится пуст и закончится весь синхронный код, Event Loop смотрит на очередь микрозадач и последовательно, задачу за задачей, передает в Call Stack для выполнения</li>
    <li>Когда закончится очередь микрозадач, Call Stack становится пуст и закончится весь синхронный код, Event Loop берет одну задачу из очереди Render. Обновление интерфейса выполняет движок браузера</li>
    <li>Когда закончится очередь микрозадач, Call Stack становится пуст и закончится весь синхронный код, Event Loop берет одну задачу из очереди макрозадач и передает в Call Stack для выполнения</li>
    <li>После этого один tick (проход по циклу событий) заканчивается и все начинается сначала</li>
    <li>Если на каком-то этапе задач нет, то Event Loop переходит к следующему</li>
  </ol>
</article>


<!-- Как работает Call Stack -->
<article class="article">
  <div class="anchor" id="callstack"></div>
  <h3>Как работает Call Stack</h3>

  <ol>
    <li>Если в call stack приходит команда, которая может выполниться сразу, то она выполняется и сразу же удаляется из стека вызова</li>
    <li>Если приходит вызов функции, то для нее создается свой контекст выполнения и она сразу же выполняется</li>
    <li>Если приходит вызов функции, которая вызывает другую функцию, то по принципу стека, первая функция остается в стеке и в стек загружается вторая функция. Для второй функции создается свой контекст выполнения. Сначала выполнится функция, которая пришла позже. Потом завершит свою работу первая функция.</li>
    <li>Если приходит вызов асинхронной функции, то он передается в Web API, и сразу же удаляется из стека вызова.</li>
  </ol>
</article>


<!-- Как работает Web API -->
<article class="article">
  <div class="anchor" id="webapi"></div>
  <h3>Как работает Web API</h3>

  <p>Web API работает параллельно с event loop и независимо от него. Как только асинхронный вызов попал в Web API, event loop продолжает свою работу. Если асинхронная функция из Web API должена вернуть callback, то он попадает в Callback Queue.</p>
  <p>Методы Web API работают либо синхронно, либо асинхронно: первые выполнятся в текущем тике, а вторые в одном из следующих тиков. Хороший пример синхронных вызовов — это работа DOM.</p>
  <p>Создание элемента, вставка в DOM и выставление свойств — это синхронные операции, которые выполняются в текущем тике. Поэтому совершенно нет разницы, когда мы выставим текст для кнопки — до вставки в DOM или после неё. Браузер обновит интерфейс только после полного завершения синхронных операций, так что пользователь увидит сразу актуальное состояние интерфейса.</p>
  <p>Когда мы пишем асинхронный код, то гарантируем, что задача будет выполняться в следующем тике. При этом он может начаться как до обновления интерфейса, так и после. Например, когда циклу событий требуется выполнить очередную задачу, он может либо выполнить её сразу после предыдущей, либо сначала обновить интерфейс, а только потом выполнить следующую задачу. Для разработчиков это не играет особой роли. Важно просто понимать, что асинхронная задача выполнится когда-то в будущем.</p>
  <p>Хороший пример асинхронного вызова — это запрос данных с сервера. Через функцию обратного вызова описывается задача, которая будет выполнена когда-то в будущем после получения данных.</p>
</article>


<!-- Очередь Microtask -->
<article class="article">
  <div class="anchor" id="microtask"></div>
  <h3>Очередь Microtask</h3>

  <p>Event Loop будет выполнять микрозадачи до тех пор, пока очередь не опустеет. Благодаря этому, движок гарантирует, что все задачи из очереди имеют доступ к одинаковому состоянию DOM.</p>

  <h4>Какие задачи попадают в очередь микрозадач (Microtask Queue):</h4>
  <ol>
    <li><code>process.nextTick()</code></li>
    <li><code>Promise callback</code></li>
    <li><code>async functions</code></li>
    <li><code>queueMicrotask()</code></li>
    <li><code>Generator</code></li>
    <li><code>MutationObserver</code></li>
    <li><code>Intersection Observer</code></li>
  </ol>
</article>


<!-- Очередь Macrotask -->
<article class="article">
  <div class="anchor" id="macrotask"></div>
  <h3>Очередь Macrotask</h3>

  <p>Задачи попадают в очередь через асинхронный браузерный API. Сперва где-то в отдельном потоке выполняется асинхронная операция, а после её завершения в очередь добавляется задача, готовая к выполнению в стеке вызовов.</p>

  <h4>Какие задачи попадают в очередь макрозадач (Macrotask Queue):</h4>
  <ol>
    <li><code>setTimeout()</code></li>
    <li><code>setInterval()</code></li>
    <li><code>setImmediate()</code></li>
    <li><code>addEventListener()</code></li>
    <li><code>requestAnimationFrame()</code></li>
    <li><code>XMLHttpRequest</code></li>
  </ol>
</article>


<!-- Очередь requestAnimationFrame -->
<article class="article">
  <div class="anchor" id="raf"></div>
  <h3>Очередь requestAnimationFrame</h3>

  <p>requestAnimationFrame (или сокращённо rAF) позволяет выполнить JavaScript-код прямо перед обновлением интерфейса. Каким-то другим способом, например через таймеры, эмулировать такое поведение практически невозможно.</p>
  <p>Основная задача requestAnimationFrame — это плавное выполнение JavaScript-анимаций, но используют его нечасто, так как анимации проще и эффективнее задать средствами CSS. Тем не менее он занимает своё полноценное место в цикле событий.</p>
  <p>Задач, которые нужно выполнить перед обновлением следующего кадра, может быть несколько, поэтому у requestAnimationFrame есть своя отдельная очередь.</p>
  <p>Задачи из очереди выполняются один раз перед обновлением интерфейса в порядке их добавления</p>
<pre>
requestAnimationFrame(() => {
  console.log('one')
})

requestAnimationFrame(() => {
  console.log('two')
})

requestAnimationFrame(() => {
  console.log('three')
})

// one two three
</pre>
  <p>Написать повторяющуюся задачу, которая будет выполняться снова и снова, можно через рекурсивную функцию. Причём, если по какой-то причине потребуется отменить выполнение, это можно сделать через cancelAnimationFrame. Но надо убедиться, что в него передаётся актуальный идентификатор, потому что каждый вызов rAF создаёт новый requestId.</p>
<pre>
let requestId

function animate () {
  requestId = requestAnimationFrame(animate)
}

requestId = requestAnimationFrame(animate)

setTimeout(() => {
  // отменить анимации через какое-то время
  cancelAnimationFrame(requestId)
}, 3000)
</pre>
</article>


<!-- Очередь requestIdleCallback -->
<article class="article">
  <div class="anchor" id="ric"></div>
  <h3>Очередь requestIdleCallback</h3>

  <p>requestIdleCallback (или сокращённо rIC) добавляет задачи в ещё одну (четвёртую) очередь, которая будет выполняться в период простоя браузера, когда нет более приоритетных задач из других очередей.</p>
<pre>
function sendAnalytics () {
  // отправить данные для аналитики
}

requestIdleCallback(sendAnalytics, { timeout: 2000 })
</pre>
  <p>В качестве второго аргумента можно указать timeout и, если задача не будет выполнена в течение указанного числа миллисекунд, то она добавится в обычную очередь, после чего выполнится в порядке общей очереди.</p>
  <p>По аналогии с requestAnimationFrame, чтобы регулярно добавлять задачу в очередь, потребуется написать рекурсивную функцию, а для остановки — передать актуальный идентификатор в cancelIdleCallback.</p>
</article>


<!-- Сравнение очередей -->
<article class="article">
  <div class="anchor" id="queue"></div>
  <h3>Сравнение очередей</h3>

  <p>Очередь микрозадач — это самая приоритетная очередь, с неё начинается выполнение кода. Работа браузера с этой очередью продолжается до тех пор, пока в ней есть задачи, сколько бы времени это ни заняло.</p>

  <p>Из очереди задач движок выполняет, как правило, одно или несколько заданий, стараясь уложиться в 16,6 миллисекунды. Как только пройдёт отведённое время, движок пойдёт обновлять интерфейс, даже если в очереди остались задачи. К ним он вернётся на следующем витке цикла событий.</p>

  <p>requestAnimation выполнит все задачи из своей очереди, потому что он гарантирует выполнение кода перед обновлением интерфейса. Но если в ходе выполнения кто-то добавит новые задания в очередь, то они выполнятся уже на следующем витке.</p>

  <p>Когда наступит время простоя и в других очередях не будет более приоритетных задач, выполнится одно или несколько заданий requestIdleCallback. Таким образом, эта очередь чем-то похожа на очередь задач, но с более низким приоритетом.</p>

  <p>Взаимодействие с очередями происходит через:</p>
  <ul>
    <li>задачи — таймеры, события (включая обработку postMessage);</li>
    <li>микрозадачи — обещания, асинхронные функции, Observer API, queueMicrotask;</li>
    <li>requestAnimationFrame, requestIdleCallback — соответствующие вызовы API.</li>
  </ul>

</article>


<!-- Render (отрисовка страницы) -->
<article class="article">
  <div class="anchor" id="render"></div>
  <h3>Render (отрисовка страницы)</h3>

  <h4>Стадии рендера:</h4>
  <ol>
    <li>
      <h4>Style (Style calculation)</h4>
      <p>Строится DOM дерево. Строится CSSOM дерево. Строится Render дерево. На этом этапе браузер пересчитывает изменение стилей, вызванное операциями JavaScript, и рассчитывает медиа-выражения. Применяет селекторы к элементам и определяет какие стили к чему надо применить. Может быть много правил к одному селектору и много селекторов в разных файлов. Все это надо вместе собрать и посчитать. Чем сложнее селектор тем сложнее подсчитать стили.</p>
    </li>
    <li>
      <h4>Layout (reflow) (составление макета)</h4>
      <p>На этом этапе браузер по размерам и позиции расставляет элементы.</p>
    </li>
    <li>
      <h4>Paint</h4>
      <p>На этом этапе движок отрисовывает элементы и применяет к ним стили, которые влияют только на внешний вид, например, цвет, фон и т.д.</p>
    </li>
    <li>
      <h4>Composite</h4>
      <p>На этом этапе движок применяет оставшиеся специфические стили, например, относящиеся к трансформации и слоям.</p>
    </li>
  </ol>
  <p>Браузер может пропускать некоторые операции, если они не нужны. Понимать, когда браузер выполняет или пропускает тот или иной шаг, может быть полезным для оптимизации веб-страницы.</p>
</article>
