<h1>Объект Set</h1>


<!-- links -->
<article class="article">
  <h2>links</h2>
  <p><a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Set">developer.mozilla.org</a></p>
  <p><a href="https://learn.javascript.ru/map-set">learn.javascript.ru/map-set</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p><a href="#about">about</a></p>
  <p><a href="#create">Создание объекта Set</a></p>
  <p><a href="#iterate">Перебор объекта Set</a></p>
  <p><a href="#properties">Свойства объекта Set</a></p>
  <p><a href="#methods">Методы объекта Set</a></p>
</article>


<!-- about -->
<article class="article">
  <div class="anchor" id="about"></div>
  <h2>about</h2>

  <p>Объект Set позволяет хранить уникальные значения любого типа, будь то примитивы или ссылки на объекты. Значение в Set может встречаться только один раз; оно уникально в коллекции. Вы можете перебирать элементы набора в порядке вставки. Порядок вставки соответствует порядку, в котором каждый элемент был успешно вставлен в коллекцию методом add() (то есть, когда был вызван add(), в наборе ещё не было такого элемента). При добавлении нового элемента в Set происходит проверка, добавлялся ли такой элемент ранее.</p>

  <p>Объект Set – это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз.</p>
</article>


<!-- Создание объекта Set -->
<article class="article">
  <div class="anchor" id="create"></div>
  <h2>Создание объекта Set</h2>

  <p>const nums = new Set() создает новый пустой объект set, в который потом можно будет добавлять элементы</p>

  <p>new Set(iterable) – создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив, строка), то копирует его уникальные значения в новый Set.</p>
  <code>new Set([1,2,2,3,3,3,4,5,5]); // { 1, 2, 3, 4, 5 }</code>
  <code>new Set('absssee'); // { 'a', 'b', 's', 'e' }}</code>
</article>


<!-- Перебор объекта Set -->
<article class="article">
  <div class="anchor" id="iterate"></div>
  <h2>Перебор объекта Set</h2>

  <p>Мы можем перебрать содержимое объекта set как с помощью метода for..of, так и используя forEach</p>
  <p>Для объекта Set не существует ключа key, как в объекте Map. Поэтому перебирать Set с помощью цикла for..in не получится.</p>

  <code>const nums = new Set([5,5,2,1,1]);</code>
  <code>for (let num of nums) console.log(num); // 5,2,1</code>
  <code>nums.forEach(num => {console.log(num)}); // 5,2,1</code>
</article>


<!-- Свойства объекта Set -->
<article class="article">
  <div class="anchor" id="properties"></div>
  <h2>Свойства объекта Set</h2>
  
  <p>После создания любая коллекция имеет два свойства</p>
  <ol>
    <li><a href="#set-constructor">constructor</a> возвращает функцию конструктор коллекции <strong>function Set() { [native code] }</strong></li>
    <li><a href="#set-size">size</a> возвращает количество элементов в коллекции</li>
  </ol>
  <p>Еще одно свойство есть у объекта Set:</p>
  <ol>
    <li><a href="#set-prototype">Set.prototype</a> возвращает ссылку на объект Set.prototype. Позволяет добавлять новые свойства и методы к объекту Set()</li>
  </ol>
</article>


<!-- Свойство size -->
<article class="article">
  <div class="anchor" id="set-size"></div>
  <h3>Свойство size</h3>

  <p>Коллекции Set имеют только одно свойство - size.</p>
  <p>Значение size является целым числом, которое показывает как много записей имеет объект Set. Функция для установки size равна undefined; вы не можете изменить это свойство.</p>

  <code>new Set('aaaaaabbbb').size; // 2</code>
</article>


<!-- Методы объекта Set -->
<article class="article">
  <div class="anchor" id="methods"></div>
  <h2>Методы объекта Set</h2>

  <p>Методы объекта Set, записанные в его прототипе Set.prototype.</p>
  <ol>
    <li>
      <a href="#set-add">add()</a>
      <br>Изменяет исходную коллекцию
      <br>Принимает значение элемента, добавляемого в коллекцию
      <br>Возвращает исходную коллекцию с добавленным элементом
    </li>
    <li>
      <a href="#set-clear">clear()</a>
      <br>Изменяет исходную коллекцию
      <br>Не принимает параметры
      <br>Возвращает undefined. Удаляет все элементы из коллекции
    </li>
    <li>
      <a href="#set-delete">delete()</a>
      <br>Изменяет исходную коллекцию
      <br>Принимает значение элемента, удаляемого из коллекции
      <br>Возвращает true, если элемент был успешно удален, иначе false
    </li>
    <li>
      <a href="#set-difference">difference()</a>
      <br>Не изменяет исходную коллекцию
      <br>Принимает другую коллекцию для сравнения и выбора отличающихся элементов только из исходной коллеции
      <br>Возвращает новую коллекцию с элементами, которые есть в исходной коллекции но нет в указанной.
    </li>
    <li>
      <a href="#set-entries">entries()</a>
      <br>Не изменяет исходную коллекцию
      <br>Не принимает параметры
      <br>Возвращает новый Итератор, который содержит массив [значение, значение] для каждого элемента, полученного в Set в порядке их добавления
    </li>
    <li>
      <a href="#set-forEach">forEach()</a>
      <br>Не изменяет исходную коллекцию
      <br>Принимает callback-функцию, которая будет выполнена для каждого элемента
      <br>Возвращает undefined
    </li>
    <li>
      <a href="#set-has">has()</a>
      <br>Не изменяет исходную коллекцию
      <br>Принимает значение, которое нужно проверить на наличие в коллекции
      <br>Возвращает true, если указанное значение есть в коллекции, иначе false
    </li>
    <li>
      <a href="#set-intersection">intersection()</a>
      <br>Не изменяет исходную коллекцию
      <br>Принимает другую коллекцию для операции пересечения двух множеств
      <br>Возвращает новую коллекцию с элементами, которые совпадают в исходных коллекциях
    </li>
    <li>
      <a href="#set-isDisjointFrom">isDisjointFrom()</a>
      <br>Не изменяет исходную коллекцию
      <br>Принимает другую коллекцию для сравнения не имеет ли указанная коллекция общих элементов с исходной
      <br>Возвращает true, если указанная коллекция не имеет общих элементов с исходной, иначе false
    </li>
    <li>
      <a href="#set-isSubsetOf">isSubsetOf()</a>
      <br>Не изменяет исходную коллекцию
      <br>Принимает другую коллекцию для сравнения что в ней находятся все элементы исходной коллекции
      <br>Возвращает true, если все элементы исходной коллекции входят в указанную коллекцию
    </li>
    <li>
      <a href="#set-isSupersetOf">isSupersetOf()</a>
      <br>Не изменяет исходную коллекцию
      <br>Принимает другую коллекцию для сравнения на вхождения в исходную коллекцию
      <br>Возвращает true, если все элементы указанной коллекции входят в исходную коллекцию
    </li>
    <li>
      <a href="#set-keys">keys()</a>
      <br>Не изменяет исходную коллекцию
      <br>Не принимает параметры
      <br>Возвращает новый итератор. Метод keys() Полностью эквивалентен методу values()
    </li>
    <li>
      <a href="#set-symmetricDifference">symmetricDifference()</a>
      <br>Не изменяет исходную коллекцию
      <br>Принимает другую коллекцию для выбора отличающихся элементов из обоих коллекций
      <br>Возвращает новую коллекцию, которая содержит элементы, которые не входят одновременно в обе коллекции
    </li>
    <li>
      <a href="#set-union">union()</a>
      <br>Не изменяет исходную коллекцию
      <br>Принимает другую коллекцию для операции объединения двух множеств
      <br>Возвращает новую коллекцию, которая содержит уникальные элементы из обоих коллекций
    </li>
    <li>
      <a href="#set-values">values()</a>
      <br>Не изменяет исходную коллекцию
      <br>Не принимает параметры
      <br>Возвращает новый итератор, который содержит значения из исходной коллекции в порядке их добавления в коллекцию
    </li>
  </ol>
</article>




