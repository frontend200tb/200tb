<h1>Яндекс Контест</h1>


<!-- Ссылки -->
<article class="article">
  <h2>Ссылки</h2>
  <p><a href="https://contest.yandex.ru/">contest.yandex.ru</a></p>
  <p><a href="https://yandex.ru/support2/contest/ru/examples-stdin-stdout">Чтение и запись в stdin или stdout</a></p>
  <p><a href="https://github.com/chrisryana/yandex_algorithm">Задачи Яндекс.Контест</a></p>
  <p><a href="https://habr.com/ru/companies/yandex/articles/430560/">Фронтенд, алгоритмы и опоссум Фридрих. Разбираем задачи конкурса Яндекса</a></p>
  <p><a href="https://github.com/feeedback/yandex-interview-contest">Яндекс.Контест. Подготовка к собеседованию</a></p>
  <p><a href="https://github.com/GH-TIMe/Yandex.Interview">Подготовка к очному собеседованию в Яндекс Дзене по направлению "Стажёр во frontend разработку"</a></p>
</article>


<!-- Содержание -->
<div class="article">
  <h2>Содержание</h2>

  <p><a href="#task-1">Чтение и запись</a></p>
  <p><a href="#task-a1">A. Камни и драгоценности</a></p>
  <p><a href="#task-b1">B. Последовательно идущие единицы</a></p>
  <p><a href="#task-c1">C. Удаление дубликатов</a></p>
  <p><a href="#task-d1">D. Генерация скобочных последовательностей</a></p>
  <p><a href="#task-e1">E. Анаграммы</a></p>
  <p><a href="#task-f1">F. Слияние k сортированных списков</a></p>
  <p><a href="#test">Тестовая задача вакансии</a></p>
</div>


<!-- Чтение и запись -->
<article class="article">
  <div class="anchor" id="task-1"></div>
  <h2>Чтение и запись</h2>

  <h4>Node JS 8.16 Чтение и запись в файл</h4>
<pre>const fs = require('fs')
let fileContent = fs.readFileSync("input.txt", "utf8");

const [a, b] = fileContent.toString().split(' ')

const result = Number(a) + Number(b)

fs.writeFileSync("output.txt", result.toString())</pre>

  <h4>Node JS 8.16 Чтение и запись в stdin или stdout</h4>
<pre>sum = (data) => {
  let mas = data.toString().split(' ');
  return +mas[0] + +mas[1];
};

let cnt, res;
process.stdin.on('data', data => {
  res = sum(data);
  process.stdout.write(res + '');
  process.exit();
});</pre>
</article>


<!-- A. Камни и украшения -->
<article class="article">
  <div class="anchor" id="task-a1"></div>
  <h2>A. Камни и драгоценности</h2>

  <h2>Описание</h2>
  <p>Даны две строки строчных латинских символов: строка J и строка S. Символы, входящие в строку J, — «драгоценности», входящие в строку S — «камни». Нужно определить, какое количество символов из S одновременно являются «драгоценностями». Проще говоря, нужно проверить, какое количество символов из S входит в J.</p>

  <h4>Формат ввода</h4>
  <p>На двух первых строках входного файла содержатся две строки строчных латинских символов: строка J и строка S. Длина каждой не превосходит 100 символов.</p>

  <h4>Формат вывода</h4>
  <p>Выходной файл должен содержать единственное число — количество камней, являющихся драгоценностями.</p>

  <h4>Пример</h4>
  <code>Ввод ab, aabbccd</code>
  <code>Вывод 4</code>

  <details>
    <summary>Решение (function)</summary>
    <p>Для каждого символа из строки с камнями проверим входит ли он в строку с драгоценностями.</p>
    <p>Сложность линейная O(n). где n - длина строки с камнями</p>
<pre>function stonesAndJewelry(j, s) {
  let result = 0;
  for (let i = 0; i &lt; s.length; i++) {
    if (j.includes(s[i])) {
      result++;
    }
  }

  return result;
}</pre>
  <p>Тест</p>
  <code>let j1 = 'asdfgh';</code>
  <code>let s1 = 'fghjklfg';</code>
  <code>console.log(stonesAndJewelry(j1,s1)); // 5</code>
  </details>

  <details>
    <summary>Решение (stdin, stdout)</summary>
<pre>const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin
});

let lines = [];
rl.on('line', (line) => {
    lines.push(line);
}).on('close', () => {
    const [jewels, stones] = lines
    let result = 0;
    for (let i = 0; i &lt; stones.length; i++) {
        if (jewels.includes(stones.charAt(i))) {
            ++result;
        }
    }
    process.stdout.write(result.toString());
});</pre>
  </details>
</article>


<!-- B. Последовательно идущие единицы -->
<article class="article">
  <div class="anchor" id="task-b1"></div>
  <h2>B. Последовательно идущие единицы</h2>

  <h2>Описание</h2>
  <p>Требуется найти в бинарном векторе самую длинную последовательность единиц и вывести её длину.</p>
  <p>Желательно получить решение, работающее за линейное время и при этом проходящее по входному массиву только один раз.</p>

  <h4>Формат ввода</h4>
  <p>Первая строка входного файла содержит одно число n, n ≤ 10000. Каждая из следующих n строк содержит ровно одно число — очередной элемент массива.</p>

  <h4>Формат вывода</h4>
  <p>Выходной файл должен содержать единственное число — длину самой длинной последовательности единиц во входном массиве.</p>

  <h4>Пример</h4>
  <code>Ввод 5, 1, 0, 1, 0, 1</code>
  <code>Вывод 1</code>

  <details>
    <summary>Решение (function)</summary>
    <p>Бинарный вектор это последовательность нулей и единиц длиной n. Соберем все аргументы функции из последовательности нулей и единиц в массив оператором rest. Заведем переменную result для результата и ones для текущей последовательности единиц. Пройдемся по массиву и будем считать все единицы записывая в ones, записывая максимальный результат в result. Если будет приходить 0, то ones сбрасываем в 0.</p>
    <p>Сложность линейная O(n). где n - длина вектора</p>
<pre>function togetherOnes(n, ...args) {
  let result = 0;
  let ones = 0;
  for (let i = 0; i &lt; args.length; i++) {
    if (args[i] === 1) {
      ones++;
      if (ones &gt; result) {
        result = ones;
      }
    } else {
      ones = 0;
    }
  }

  return result;
}</pre>
  <p>Тест</p>
  <code>console.log(togetherOnes(8, 1,1,1,0,1,0,1,1)); // 3</code>
  <code>console.log(togetherOnes(8, 1,0,0,0,1,0,1,1)); // 2</code>
  </details>

  <details>
    <summary>Решение (stdin, stdout)</summary>
<pre>const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin
});

let lines = [];
rl.on('line', (line) => {
    lines.push(line);
    if (+lines[0] &lt;= lines.length - 1) {
        rl.close();
    }
}).on('close', () => {
    let n = lines[0];
    let str = lines.slice(1, n + 2).join(",");
    let maxLen = 0;
    let len = 0;
    for (let i = 0; i &lt; str.length; i++) {
        switch (str[i]) {
            case "1":
                len++;
                if (maxLen &lt; len) {
                    maxLen = len;
                }
                break;
            case "0":
                len = 0;
                break;
        }
    }
    process.stdout.write(maxLen.toString());
});</pre>
  </details>
</article>


<!-- C. Удаление дубликатов -->
<article class="article">
  <div class="anchor" id="task-c1"></div>
  <h2>C. Удаление дубликатов</h2>

  <h2>Описание</h2>
  <p>Дан упорядоченный по неубыванию массив целых 32-разрядных чисел. Требуется удалить из него все повторения.</p>
  <p>Желательно получить решение, которое не считывает входной файл целиком в память, т.е., использует лишь константный объем памяти в процессе работы.</p>

  <h4>Формат ввода</h4>
  <p>Первая строка входного файла содержит единственное число n, n ≤ 1000000.</p>
  <p>На следующих n строк расположены числа — элементы массива, по одному на строку. Числа отсортированы по неубыванию.</p>

  <h4>Формат вывода</h4>
  <p>Выходной файл должен содержать следующие в порядке возрастания уникальные элементы входного массива.</p>

  <h4>Пример 1</h4>
  <code>Ввод 5, 2, 4, 8, 8, 8</code>
  <code>Вывод 2, 4, 8</code>

  <h4>Пример 2</h4>
  <code>Ввод 5, 2, 2, 2, 8, 8</code>
  <code>Вывод 2, 8</code>

  <details>
    <summary>Решение (function)</summary>
    <p>Создаем массив result и сразу кладем в него первый элемент входного массива. Проходим по остальным элементам и если очередного элемента нет в массиве result то добавляем его</p>
    <p>Сложность линейная O(n). где n - длина входного массива</p>

<pre>function removeDuplicates(n, ...args) {
  let result = [args[0]];
  for (let i = 1; i &lt; args.length; i++) {
    if (result[result.length-1] !== args[i]) {
      result.push(args[i]);
    }
  }

  return result;
}</pre>
  <p>Тест</p>
  <code>console.log(removeDuplicates(5, 2,2,2,6,8)); // [2,6,8]</code>
  <code>console.log(removeDuplicates(5, 2,2,4,8,8,8)); // [2,4,8]</code>
  <code>console.log(removeDuplicates(5, 2,3,3,6,8,8,9)); // [2,3,6,8,9]</code>
  </details>

  <details>
    <summary>Решение (stdin, stdout)</summary>
<pre>const fs = require('fs');
const readline = require('readline');

const rl = readline.createInterface({
  input: fs.createReadStream('input.txt'),
  terminal: false
});

let str = '', prev;

rl.once('line', () => {
  rl.on('line', line => {
    if (line != prev) str += `${prev = line}\n`;
    if (str.length > 150000) {
      fs.appendFileSync('output.txt', str);
      str = '';
    }
  }).on('close', () => fs.appendFileSync('output.txt', str));
});</pre>
  </details>
</article>


<!-- D. Генерация скобочных последовательностей -->
<article class="article">
  <div class="anchor" id="task-d1"></div>
  <h2>D. Генерация скобочных последовательностей</h2>

  <p>Дано целое число n. Требуется вывести все правильные скобочные последовательности длины 2n, упорядоченные лексикографически</p>
  <p>В задаче используются только круглые скобки.</p>
  <p>Желательно получить решение, которое работает за время, пропорциональное общему количеству правильных скобочных последовательностей в ответе, и при этом использует объём памяти, пропорциональный n.</p>

  <h4>Формат ввода</h4>
  <p>Единственная строка входного файла содержит целое число n, 0 ≤ n ≤ 11</p>

  <h4>Формат вывода</h4>
  <p>Выходной файл содержит сгенерированные правильные скобочные последовательности, упорядоченные лексикографически.</p>

  <h4>Примеры</h4>
  <code>n = 1 ()</code>
  <code>n = 2 ()(), (())</code>
  <code>n = 3 ()()(), ()(()), (())(), ((())), (()())</code>

  <details>
    <summary>Решение (function)</summary>
<pre>function main(str, leftBr, rightBr, N) {
  // base 0
  if (leftBr === N) {
    for (let i = 0; i &lt; N - rightBr; i++) {
      str += ")";
    }
    console.log('2',str);
    return str;
  }
  // recursive
  doLeftBracket(str, leftBr, rightBr, N);
  if (leftBr > rightBr) {
    doRightBracket(str, leftBr, rightBr, N);
  }
}

function doLeftBracket(str, leftBr, rightBr, N) {
  str += "(";
  main(str, ++leftBr, rightBr, N);
}

function doRightBracket(str, leftBr, rightBr, N) {
  str += ")";
  main(str, leftBr, ++rightBr, N);
}

function brackets(N) {
  let str = '';
  main(str, 0, 0, N);
}
let w1 = 1; // ()
let w2 = 2; // (()), ()()
let w3 = 3;

brackets(w3);</pre>
  </details>

  <details>
    <summary>Решение (stdin, stdout)</summary>
<pre>const fs = require('fs');
const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin
});

let result = [], str = "";

rl.once("line", (N) => {
    main(str, 0, 0, +N);
    rl.close();
});

function main(str, leftBr, rightBr, N) {
    // base 0
    if (leftBr === N) {
        for (let i = 0; i &lt; N - rightBr; i++) {
            str += ")";
        }
        fs.appendFileSync('output.txt', `${str}\n`);
        return str;
    }
    // recursive
    doLeftBracket(str, leftBr, rightBr, N);
    if (leftBr > rightBr) {
        doRightBracket(str, leftBr, rightBr, N);
    }
}

function doLeftBracket(str, leftBr, rightBr, N) {
    str += "(";
    main(str, ++leftBr, rightBr, N);
}

function doRightBracket(str, leftBr, rightBr, N) {
    str += ")";
    main(str, leftBr, ++rightBr, N);
  }</pre>
  </details>
</article>


<!-- E. Анаграммы -->
<article class="article">
  <div class="anchor" id="task-e1"></div>
  <h2>E. Анаграммы</h2>

  <p>Даны две строки, состоящие из строчных латинских букв. Требуется определить, являются ли эти строки анаграммами, т. е. отличаются ли они только порядком следования символов.</p>

  <h4>Формат ввода</h4>
  <p>Входной файл содержит две строки строчных латинских символов, каждая не длиннее 100 000 символов. Строки разделяются символом перевода строки.</p>

  <h4>Формат вывода</h4>
  <p>Выходной файл должен содержать единицу, если строки являются анаграммами, и ноль в противном случае.</p>

  <h4>Пример</h4>
  <code>Ввод qiu iuq Вывод 1</code>
  <code>Ввод zpri zprc Вывод 0</code>

  <details>
    <summary>Решение за время O(N*logN), память O(1), изменяя входные данные</summary>
    <p>Можно отсортировать входные строки и после этого сравнить. Если мы сортируем входные строки, то не тратим дополнительной памяти, но изменяем входные данные. Сложность O(N*logN) потому что мы делаем сортировку.</p>
  </details>

  <details>
    <summary>Решение за время O(N*logN), память O(N), не изменяя входные данные</summary>
    <p>Можно скопировать содержимое строк в новые структу и отсортировать и после этого сравнить. Тогда мы не будем изменять входные данные, но нам потребуется линейная дополнительная память O(N). Сложность O(N*logN) потому что мы делаем сортировку.</p>
  </details>

  <details>
    <summary>Решение за время O(N), память O(N), не изменяя входные данные</summary>
    <p>Можно поместить содержимое строк в ассоциативный массив. Затем сравнить содержимое ассоциативных массивов. Тогда нам потребуется линейная дополнительная память O(N). Сложность по времени линейная O(N), поскольку не требуется сортировка. И не изменяются входные строки.</p>
<pre>// функция создает из строки объект
function createObj(str) {
  let dict = {};
  for (let i = 0; i &lt; str.length; i++) {
    if (!dict[str[i]]) {
      dict[str[i]] = 0;
    }
    dict[str[i]]++;
  }
  return dict;
}

function isAnagram(a,b) {
  if (a.length !== b.length) {
    return false;
  }

  const dictA = createObj(a);
  const dictB = createObj(b);

  for (let char in dictA) {
    if (dictA[char] !== dictB[char]) {
      return false;
    }
  }
  return true;;
}</pre>
  </details>
</article>


<!-- F. Слияние k сортированных списков -->
<article class="article">
  <div class="anchor" id="task-f1"></div>
  <h2>F. Слияние k сортированных списков</h2>

  <p>Даны k отсортированных в порядке неубывания массивов неотрицательных целых чисел, каждое из которых не превосходит 100. Требуется построить результат их слияния: отсортированный в порядке неубывания массив, содержащий все элементы исходных k массивов.</p>
  <p>Длина каждого массива не превосходит 10 * k.</p>
  <p>Постарайтесь, чтобы решение работало за время k * log(k) * n, если считать, что входные массивы имеют длину n.</p>

  <h4>Формат ввода</h4>
  <p>Первая строка входного файла содержит единственное число k, k ≤ 1024.</p>
  <p>Каждая из следующих k строк описывает по одному массиву. Первое число каждой строки равняется длине соответствующего массива, оставшиеся числа этой строки описывают значения элементов этого же массива. Элементы массивов являются неотрицательными целыми числами и не превосходят 100.</p>

  <h4>Формат вывода</h4>
  <p>Выходной файл должен содержать отсортированный в порядке неубывания массив, содержащий все элементы исходных массивов.</p>

  <h4>Пример</h4>
<pre>Ввод
4
6 2 26 64 88 96 96
4 8 20 65 86
7 1 4 16 42 58 61 69
1 84
Вывод
1 2 4 8 16 20 26 42
58 61 64 65 69 84 86
88 96 96
</pre>

  <details>
    <summary>Решение (input.txt)</summary>
<pre>const fs = require('fs');
const readline = require('readline');

const rl = readline.createInterface({
  input: fs.createReadStream('input.txt'),
  terminal: false
});

const countNum = [...Array(101)].fill(0);
rl.once('line', () => {
    rl.on('line', line => {
        let subArray = line.split(" ");
        for (let i = 1; i &lt; subArray.length; i++) {
            countNum[+subArray[i]]++;
        }
    }).on('close', () => countNum.forEach((item, index) => fs.appendFileSync('output.txt', `${index} `.repeat(item))));
});</pre>
  </details>
</article>


<!-- Тестовая задача вакансии -->
<article class="article">
  <div class="anchor" id="test"></div>
  <h2>Тестовая задача вакансии</h2>

  <p>Дана доска размером M * N клеток. Клетка может находиться в одном из двух состояний: 1 — живая, 0 — мёртвая. Каждая клетка взаимодействует с восемью соседями. Правила таковы:</p>
  <ul>
    <li>Живая клетка, у которой меньше двух живых соседей, погибает.</li>
    <li>Живая клетка, у которой два или три живых соседа, выживает.</li>
    <li>Живая клетка, у которой больше трёх живых соседей, погибает.</li>
    <li>Мёртвая клетка, у которой три живых соседа, возрождается.</li>
  </ul>
  <p>Напишите программу, которая будет:</p>
  <ul>
    <li>случайным образом генерить стартовое состояние;</li>
    <li>уметь получать его из файла (способ выбирается через параметры запуска в консоли);</li>
    <li>каждую секунду выводить в консоль новое состояние доски.</li>
  </ul>

  <details>
    <summary>Решение</summary>
<pre>/**
* To run the program, Node JS was used. To load a file, you must specify the path to it.
* The file is written as a matrix of elements with a space separator.
* During testing, a text file (.txt) was downloaded with the following contents:
* 0 0 0 1
* 1 1 0 1
* 0 0 0 0
* 1 0 1 1
* 0 1 1 0
* 0 1 0 1
* 0 0 0 0
* 1 0 1 0
*
* @author Averyanov Timofey <timhaha@yandex.ru>
*/
(function() {
    "use strict";

    const rl = require('readline').createInterface({
        input: process.stdin,
        output: process.stdout
    });

    const question0 = "---\nWhat do you want to do?\n\t1. Generate a board\n\t2. Load file\nEnter 1 or 2: ",
          question1 = "---\nEnter board size m x n. Example: 2 3\nSize: ",
          question2 = "---\nEnter the path to the file. Example: 'data/matrix.txt'\npath: ";

    new Promise(resolve => {
        rl.question(question0, num => {
            switch (+num) {
                case 1: {
                    rl.question(question1, size => {
                        rl.close();
                        resolve(fillBoard(size));
                    });
                }
                case 2: {
                    rl.question(question2, path => {
                        rl.close();
                        resolve(fileLoad(path));
                    });
                }
            }
        });
    }).then(board => {
        console.log("The initial state of the cell board:");
        console.table(board);
        setInterval(() => {
            board = updateBoard(board);
            console.table(board);
        }, 1000);
    });


    /**
    * Loads data located locally (with a space separator) and transforms it into a matrix of cells
    *
    * @param {string} path - the path to the file
    * @return {object} cell matrix
    */
    function fileLoad(path) {
        try {
            let board = require("fs").readFileSync(path);
            return board.toString('utf8').split("\r\n").map(row => row.split(" ").map(item => +item));
        } catch(err) {
            throw Error("Error!");
        }
    }

    /**
    * Сreates a matrix with random numbers 0 and 1
    *
    * @param {object} size - width and heiht of board
    * @return {object} cell matrix
    */
  function fillBoard(size) {
      let n = +size.split(" ")[0],
          m = +size.split(" ")[1];
      return [...Array(n)].map( () => [...Array(m)].map( () => Math.round( Math.random() ) ) );
  }

  /**
  * Updates cell board
  *
  * @param {object} board - updating board
  * @return {object} updated board
  */
  function updateBoard(board) {
      let n = board.length,
          m = board[0].length;
      let updatedBoard = board.map( (row, i) => row.map( (col, j) => {
          let cells = numLivingCells(board, i, j, n, m);
          switch (col) {
              case 1:
                  return (cells === 2 || cells === 3) ? 1 : 0;
              case 0:
                  return (cells === 3) ? 1 : 0;
          }
      }));
      return updatedBoard;
  }

  /**
  * Counts the number of living cells around a given
  *
  * @param {object} board - updating board
  * @param {number} i - x coordinate
  * @param {number} j - y coordinate
  * @param {number} n - width of board
  * @param {number} m - heiht of board
  * @return {number} number of cells
  */
  function numLivingCells(board, i, j, n, m) {
      let cellsAlive = 0;
      for (let k = i - 1; k &lt;= i + 1; k++) {
          for (let t = j - 1; t &lt;= j + 1; t++) {
              if ((k !== i || t !== j) && k >= 0 && k &lt; n && t >= 0 && t &lt; m && board[k][t] === 1) {
                  cellsAlive++;
              }
          }
      }
      return cellsAlive;
  }
}());</pre>
  </details>
</article>



