<h1>Деревья от Максима Фатина</h1>


<!-- links -->
<article class="article">
  <h2>links</h2>

  <p><a href="https://www.youtube.com/@fatin.maksim/videos">youtube Максим Фатин</a></p>
  <p><a href="https://algocode.io/">https://algocode.io/</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p><a href="#bintree">Двоичные деревья</a></p>
  <p><a href="#traver">Базовые обходы</a></p>
  <ol>
    <li><a href="#bintree1">Preorder</a></li>
    <li><a href="#bintree2">Inorder</a></li>
    <li><a href="#bintree3">Postorder</a></li>
    <li><a href="#bintree4">Поиск суммы в бинарном дереве</a></li>
  </ol>
  <p><a href="#level">Обходы по уровням</a></p>
  <ol>
    <li><a href="#bintree5">Level order</a></li>
    <li><a href="#bintree6">Zigzag level order</a></li>
    <li><a href="#bintree7">Вид справа</a></li>
    <li><a href="#bintree8">Вид слева</a></li>
  </ol>
  <p><a href="#equal">Сравнение деревьев</a></p>
  <ol>
    <li><a href="#bintree9">Симметричное дерево</a></li>
    <li><a href="#bintree10">Идентичные деревья</a></li>
  </ol>
  </ol>
  <p><a href="#bst">Бинарное дерево поиска (BST)</a></p>
  <ol>
    <li><a href="#bst1">Золотое правило BST</a></li>
    <li><a href="#bst2">Проверка всех листьев</a></li>
    <li><a href="#bst3">Валидация дерева поиска</a></li>
    <li><a href="#bst4">Из массива в дерево поиска</a></li>
    <li><a href="#bst5">Ближайшее значение</a></li>
    <li><a href="#bst6">K-ый наименьший элемент в BST</a></li>
    <li><a href="#bst7">K-ый наибольший элемент в BST</a></li>
  </ol>
</article>


<!-- Двоичные деревья -->
<article class="article">
  <div class="anchor" id="bintree"></div>
  <h3>Двоичные деревья</h3>

  <h3>Терминология</h3>
  <ol>
    <li>Узел (node)</li>
    <li>Родитель (parent). У родителя есть хотя бы один ребенок</li>
    <li>Ребенок (child). У ребенка есть родитель</li>
    <li>Бинарное дерево. Каждый узел имеет не больше чем 2 ребенка</li>
    <li>Лист (leaf). У листьев нет детей</li>
    <li>Корень (root). У корня нет родителя</li>
    <li>Ребро. Соединяет два узла. Родителя и ребенка</li>
    <li>Высота дерева - число ребер от корня до самого удаленного узла</li>
    <li>Поддеревья. Левое и правое. Если у вершины есть дети, значит у нее есть левое и правое поддерево</li>
    <li>Бамбук Это крайний случай, когда у каждого узла (кроме корня) есть только один родитель и у каждого узла (кроме листа) есть только один ребенок. Дерево вырождается в прямую линию</li>
    <li>Сбалансированное дерево. Высоба левого и правого поддерева различаются не больше, чем на 1. Высота O(logN), где N - числов вершин</li>
    <li>Несбалансированное дерево. Поддеревья имеют разницу высот больше 1</li>
  </ol>

  <h3>Хранение дерева</h3>
  <p>Дерево можно представить в двух форматах</p>
  <ol>
    <li>Массив</li>
    <li>Структура данных</li>
  </ol>
  <p>В массиве корень дерева лежит по индексу 0. Дальше индексы массива, где расположены дети определяются по следующей формуле</p>
  <code>i // индекс массива</code>
  <code>2*i + 1 // левый ребенок</code>
  <code>2*i + 2 // правый ребенок</code>
  <p>В структуре хранятся значения и указатели на левого и правого ребенка</p>
<pre>
class TreeNode {
  constructor(val, left, right) {
    this.val = val;
    this.left = left;
    this.right = right;
  }
}
</pre>

  <h3>Дополнительные данные в узлах</h3>
  <p>В узлах могут лежать какие-то дополнительные данные. Например, сумма поддеревьев, но это уже получилось дерево отрезков.</p>
<pre>
  class TreeNode {
    constructor(val, left, right) {
      this.val = val;
      this.left = left;
      this.right = right;
      this.sum = this.val + this.left.val + this.right.val;
    }
  }
  </pre>

  <h3>Введение в бинарные деревья</h3>
  <h4>Базовые обходы</h4>
  <ol>
    <li>Основы бинарного поиска (теория)</li>
    <li>Прямой обход</li>
    <li>Центрированный обход</li>
    <li>Обратный обход</li>
  </ol>

  <h4>Закрепляем базовые обходы</h4>
  <ol>
    <li>Сумма листьев в дереве</li>
    <li>Сумма левых листьев</li>
    <li>Сумма правых листьев</li>
  </ol>

  <h4>Обход по уровням</h4>
  <ol>
    <li>Обход по уровням</li>
    <li>Вид справа</li>
    <li>Обход зигзагом</li>
  </ol>

  <h3>Дерево на собеседовании</h3>
  <h4>Сравнение деревьев</h4>
  <ol>
    <li>Симметричное дерево</li>
    <li>Идентичные деревья</li>
  </ol>

  <h4>Глубина дерева</h4>
  <ol>
    <li>Максимальная глубина дерева</li>
    <li>Минимальная глубина дерева</li>
    <li>Сбалансированное дерево</li>
  </ol>

  <h4>Построение дерева</h4>
  <ol>
    <li>Бинарное дерево из массива</li>
    <li>Массив из бинарного дерева</li>
  </ol>

  <h4>Наименьший общий предок</h4>
  <ol>
    <li>НОП не нулевых вершин</li>
    <li>Наименьший общий предок</li>
  </ol>

  <h4>Сумма вершин на пути</h4>
  <ol>
    <li>Сумма от корня до листа</li>
  </ol>

  <h3>Бинарное дерево поиска (BST)</h3>
  <h4>Проверка BST</h4>
  <ol>
    <li>Проверка всех листьев</li>
    <li>Правильное дерево поиска</li>
  </ol>

  <h4>Эффективный поиск элементов</h4>
  <ol>
    <li>Поиск ближайшего значения</li>
    <li>Поиск k-го наименьшего элемента</li>
    <li>Поиск k-го наибольшего элемента</li>
  </ol>
</article>


<!-- Базовые обходы -->
<article class="article">
  <div class="anchor" id="traver"></div>
  <h3>Базовые обходы</h3>
</article>


<!-- 1. Preorder -->
<article class="article">
  <div class="anchor" id="bintree1"></div>
  <h3>Классические обходы деревьев</h3>

  <h3>1. Preorder</h3>
  <p>Дан корень бинарного дерева и требуется вернуть массив значений узлов в preorder порядке</p>

  <p>Пример</p>
<pre>
               1
        /             \
       2               5
    /     \         /     \
   3       4       6       7
 /   \   /   \   /   \   /   \
nil nil nil nil nil nil nil nil
</pre>
  <code>[1, 2, 3, 4, 5, 6, 7]</code>
  <p>Как решается эта задача. Вначале приходит корень дерева. Добавляем его в массив с ответом [1]. Идем в левое поддерево. Добавляем значение левого ребенка в массив [1, 2]. Идем в левое поддерево. Добавляем значение левого ребенка в массив [1, 2, 3]. Дальше детей нет. Возвращаемся к родителю и идем в правое поддерево. Добавляем значение правого ребенка в массив [1, 2, 3, 4]. Дальше детей нет. Возвращаемся к ближайшему родителю у которого есть ребенок. Это корень. Идем в правое поддерево. Добавляем значение правого ребенка в массив [1, 2, 3, 4, 5]. Идем в левое поддерево. Добавляем значение [1, 2, 3, 4, 5,6]. Дальше детей нет. Возвращаемся к родителю и идем в правое поддерево. Добавляем значение правого ребенка в массив [1, 2, 3, 4, 5, 6, 7]. Возвращаемся к корню. Все вершины добавлены в массив.</p>

  <details>
    <summary>Preorder Traversal</summary>
  <h4>Алгоритм</h4>
  <ol>
    <li>Заведем переменную res для результата и запишем в нее пустой массив
      <code>let res = [];</code>
    </li>
    <li>Вызовем функцию preorder, которую мы сейчас напишем, и передадим в нее корень root и пока пустой массив res
      <code>preorder(root, res);</code>
    </li>
    <li>Теперь напишем функцию preorder, которая принимает узел node и массив res с результатом</li>
    <li>Если в узле node ничего нет, то это пустой узел и просто выходим из функции, ничего не записывая в ответ
      <code>if (!node) return;</code>
    </li>
    <li>Если в узле node есть значение, то добавляем его в ответ
      <code>res.push(node.val);</code>
    </li>
    <li>Идем в левое поддерево
      <code>preorder(node.left, res);</code>
    </li>
    <li>Идем в правое поддерево
      <code>preorder(node.right, res);</code>
    </li>
  </ol>

<pre>
class TreeNode {
  constructor(val, left, right) {
    this.val = val;
    this.left = left;
    this.right = right;
  }
}

function preorderTraversal(root) {
  let res = [];
  preorder(root, res);
  return res;
}

function preorder(node, res) {
  if (!node) {
    return;
  }

  res.push(node.val);
  preorder(node.left, res);
  preorder(node.right, res);
}
</pre>
  </details>

  <p>Алгоритм</p>
  <ol>
    <li>если nil-вершина, то возвращаемся к родителю</li>
    <li>идем в левого ребенка</li>
    <li>добавляем значение вершины в ответ</li>
    <li>идем в правого ребенка</li>
  </ol>

  <p>Сложность по времени O(n), где n - число вершин</p>
  <p>Сложность по памяти O(h), где h - высота дерева</p>

  <p>Вопросы</p>
  <ol>
    <li>Обязательно идти сначала влево, а потом вправо? Ответ: Да. В этом смысл обхода.</li>
    <li>А мне разрешат писать рекурсивное решение? Есть ограничение на стекфрейму. Тысяча вершин обязательно вызовит переполнение стека. Решение не самое идеальное, но его хватает.</li>
    <li>Где применяется preorder?</li>
  </ol>
</article>


<!-- 2. Inorder -->
<article class="article">
  <div class="anchor" id="bintree2"></div>
  <h3>2. Inorder</h3>

  <p>Дан корень бинарного дерева и требуется вернуть массив значений узлов в inorder порядке</p>

  <p>Пример</p>
<pre>
               4
        /             \
       2               6
    /     \         /     \
   1       3       5       7
 /   \   /   \   /   \   /   \
nil nil nil nil nil nil nil nil
</pre>
<code>[1, 2, 3, 4, 5, 6, 7]</code>
  <p>Как решается эта задача. К нам приходит корень дерева (4). Идем в левое поддерево. Левая вершина (2) не nil, поэтому идем дальше в левое поддерево. Левая вершина (1) не nil. Идем дальше в левое поддерево. Левая вершина nil. Возвращаемся к родителю (1) и добавляем значение родителя в массив [1]. Идем в правое поддерево. Правая вершина nil. Вовзращаемся к родителю (1). Возвращаемся к родителю (2) и добавляем значение родителя в массив [1, 2]. Идем в правое поддерево. Правая вершина (3) не nil. Идем в левое поддерево. Левая вершина nil. Возвращаемся к родителю (3) и добавляем значение родителя в массив [1, 2 ,3]. Возвращаемся к родителю (2). Возвращаемся к корню (4). Добавляем значение корня в массив [1, 2, 3, 4].</p>

  <details>
    <summary>Inorder Traversal</summary>
  <h4>Алгоритм</h4>
  <ol>
    <li>Заведем переменную res для результата и запишем в нее пустой массив
      <code>let res = [];</code>
    </li>
    <li>Вызовем функцию inorder, которую мы сейчас напишем, и передадим в нее корень root и пока пустой массив res
      <code>inorder(root, res);</code>
    </li>
    <li>Теперь напишем функцию inorder, которая принимает узел node и массив res с результатом</li>
    <li>Если в узле node ничего нет, то это пустой узел и просто выходим из функции, ничего не записывая в ответ
      <code>if (!node) return;</code>
    </li>
    <li>Если в узле node есть значение, то идем в левое поддерево
      <code>inorder(node.left, res);</code>
    </li>
    <li>Добавляем значение узла в ответ
      <code>res.push(node.val);</code>
    </li>
    <li>Идем в правое поддерево
      <code>inorder(node.right, res);</code>
    </li>
  </ol>

<pre>
class TreeNode {
  constructor(val, left, right) {
    this.val = val;
    this.left = left;
    this.right = right;
  }
}

function inorderTraversal(root) {
  let res = [];
  inorder(root, res);
  return res;
}

function inorder(node, res) {
  if (!node) {
    return;
  }

  inorder(node.left, res);
  res.push(node.val);
  inorder(node.right, res);
}
</pre>
  </details>

<p>Алгоритм</p>
<ol>
  <li>если nil-вершина, то возвращаемся к родителю</li>
  <li>идем в левого ребенка</li>
  <li>добавляем значение вершины в ответ</li>
  <li>идем в правого ребенка</li>
</ol>
</article>


<!-- 3. Postorder -->
<article class="article">
  <div class="anchor" id="bintree3"></div>
  <h3>3. Postorder</h3>

  <p>Дан корень бинарного дерева и требуется вернуть массив значений узлов в postorder порядке</p>

  <p>Пример</p>
<pre>
              7
       /             \
      3               6
   /     \         /     \
  1       2       4       5
 /   \   /   \   /   \   /   \
nil nil nil nil nil nil nil nil
</pre>
  <code>[1, 2, 3, 4, 5, 6, 7]</code>
  <p>Как решается эта задача. К нам приходит корень дерева (7). Идем в левое поддерево. Левая вершина (3) не nil, поэтому идем дальше в левое поддерево. Левая вершина (1) не nil. Идем дальше в левое поддерево. Левая вершина nil. Возвращаемся к родителю (1). Идем в правое поддерево. Правая вершина nil. Вовзращаемся к родителю (1) и добавляем значение родителя в массив [1]. Возвращаемся к родителю (3). Идем в правое поддерево. Правая вершина (2) не nil. Идем в левое поддерево. Левая вершина nil. Возвращаемся к родителю (2) и добавляем значение родителя в массив [1, 2]. Возвращаемся к родителю (3) и добавляем значение родителя в массив [1, 2, 3]. Возвращаемся к корню (7). Идем в правое поддерево (6).</p>

  <details>
    <summary>Postorder Traversal</summary>
  <h4>Алгоритм</h4>
  <ol>
    <li>Заведем переменную res для результата и запишем в нее пустой массив
      <code>let res = [];</code>
    </li>
    <li>Вызовем функцию postorder, которую мы сейчас напишем, и передадим в нее корень root и пока пустой массив res
      <code>postorder(root, res);</code>
    </li>
    <li>Теперь напишем функцию postorder, которая принимает узел node и массив res с результатом</li>
    <li>Если в узле node ничего нет, то это пустой узел и просто выходим из функции, ничего не записывая в ответ
      <code>if (!node) return;</code>
    </li>
    <li>Если в узле node есть значение, то идем в левое поддерево
      <code>postorder(node.left, res);</code>
    </li>
    <li>Идем в правое поддерево
      <code>postorder(node.right, res);</code>
    </li>
    <li>Добавляем значение узла в ответ
      <code>res.push(node.val);</code>
    </li>
  </ol>

<pre>
class TreeNode {
  constructor(val, left, right) {
    this.val = val;
    this.left = left;
    this.right = right;
  }
}

function postorderTraversal(root) {
  let res = [];
  postorder(root, res);
  return res;
}

function postorder(node, res) {
  if (!node) {
    return;
  }

  postorder(node.left, res);
  postorder(node.right, res);
  res.push(node.val);
}
</pre>
  </details>

  <p>Алгоритм</p>
  <ol>
    <li>если nil-вершина, то возвращаемся к родителю</li>
    <li>идем в левого ребенка</li>
    <li>идем в правого ребенка</li>
    <li>добавляем значение вершины в ответ</li>
  </ol>

  <p>Отличия обхода preorder, inorder, postorder -  в разном порядке добавляем вершины в ответ.</p>
  <p>preorder. Проход дерева слева направо и сверху вниз. Встречается очень часто.</p>
  <p>inorder. Вывести в отсортированном порядке элементы в двоичном дереве поиска. Встречается редко.</p>
  <p>postorder. Преподсчет (сумм) для дерева отрезков. Встречается очень редко.</p>
</article>


<!-- Поиск суммы в бинарном дереве -->
<article class="article">
  <div class="anchor" id="bintree4"></div>
  <h3>Поиск суммы в бинарном дереве</h3>
</article>


<!-- Обходы по уровням -->
<article class="article">
  <div class="anchor" id="level"></div>
  <h3>Обходы по уровням</h3>
</article>


<!-- Level order -->
<article class="article">
  <div class="anchor" id="bintree5"></div>
  <h3>Паттерны</h3>

  <h3>Level order pattern</h3>

  <p>Дан корень бинарного дерева. Нужно обойти дерево слева направо и сверху вниз и вернуть массив вершин каждого уровня</p>

  <p>Пример</p>
<pre>
               3
       /              \
     9                 4
   /   \           /       \
 nil    2         1         8
      /   \     /   \     /   \
     5    nil nil   nil nil   nil
    / \
  nil nil
</pre>
  <code>[[3], [9, 4], [2, 1, 8], [5]]</code>

  <details>
    <summary>Решение</summary>
    <p>Пусть верхний уровень будет нулевой, на нем вершина 3. Потом первый уровень с вершинами 9,4. Потом второй уровень с вершинами 2,1,8. Потом третий уровень с вершиной 5. На каждом уровне идем слева направо и записываем вершины в массив.</p>
    <p>Идея решения. Возьмем preorder обход. Дополнительно будем передавать текущи уровень в нашу рекурсивную функцию. Для ответа заведем двумерный массив. Индексами первого массива будут уровни, а значением для каждогшо индекса первого массива будет массив с вершинами этого уровня.</p>
    <p>Пройдем алгоритм по шагам.</p>
    <ol>
      <li>В первом шаге мы берем корень.В функцию передаем уровень 0 и вершину 3. Функция добавит вершину 3 в массив по индексу 0.</li>
      <li>Второй шаг, из вершины 3 мы идем в вершину 9. В функцию передаем уровень 1 и вершину 9. Функция добавит вершину 9 в массив по индексу 1.</li>
      <li>Третий шаг, из вершины 9 мы идем в вершину nil. В функцию передаем уровень 2 и вершину nil. Функция проверяет что это вершина nil и сразу делает return, ничего не выполняя</li>
      <li>Четвертый шаг, из вершины 9 мы идем в вершину 2. В функцию передаем уровень 2 и вершину 2. Функциия добавит вершину 2 в массив по индексу 2.</li>
      <li>Пятый шаг, из вершины 2 мы идем в вершину 5. В функцию передаем уровень 3 и вершину 5. Функция добавит вершину 5 в массив по индексу 3.</li>
      <li>Из вершины 5 пробуем зайти сначала влево, потом вправо, там будет nil. Потом поднимемся в вершину 2 и пробуем зайти вправо, там будет nil. Потом поднимаемся к корню. Сейчас мы обошли левое поддерево. Теперь идем в правое</li>
      <li>Из вершины 3 идем в вершину 4. И так пока не обойдем правое поддерево. в результате получим двумерный массив с ответом</li>
    </ol>

<pre>
class TreeNode {
  constructor(val, left, right) {
    this.val = val;
    this.left = left;
    this.right = right;
  }
}

function preorder(root, level, res) {
  if (!root) {
    return;
  }

  if (res.length === level) {
    res.push([]);
  }
}

// делаем preorder обход и добавляем вершину
// на текущий уровень в конец списка
res[level].push(root.val);

preorder(root.left, level + 1, res)
preorder(root.right, level + 1, res)

function levelorder(root) {
  var res = [];
  preorder(root, 0, res);
  return res;
}
</pre>
  </details>

  <p>Сложность по времени O(N)</p>
  <p>Сложность по памяти O(N)</p>
</article>


<!-- Zigzag level order -->
<article class="article">
  <div class="anchor" id="bintree6"></div>
  <h3>Zigzag level order</h3>

  <p>Дан корень бинарного дерева. Нужно обойти дерево по зигзагу. Это значит, слева направо, потом справа налево.</p>
  <p>Начинаем с нулевого уровня и каждый уровень меняем направление обхода. Нулевой уровень, где только одна вершина - корень, слева направо, т.е. берем просто эту одну вершину. Первый уровень обходим уже справо налево</p>

  <p>Пример</p>
<pre>
               3
       /              \
     9                 4
   /   \           /       \
 nil    2         1         8
      /   \     /   \     /   \
     5    nil nil   nil nil   nil
    / \
  nil nil
</pre>
  <code>[[3], [4, 9], [2, 1, 8], [5]]</code>

  <p>Идея решения. Запустить Level order. Потом пройтись по результату и на нечетных уровнях делать reverse для массива с вершинами.</p>
</article>


<!-- Вид справа -->
<article class="article">
  <div class="anchor" id="bintree7"></div>
  <h3>Вид справа</h3>

  <p>Дан корень бинарного дерева. Нужно вернуть массив самых правых вершин дерева на каждом уровне.</p>

  <p>Пример</p>
<pre>
             3
      /              \
    9                 4
  /   \           /       \
nil    2         1         8
     /   \     /   \     /   \
    5    nil nil   nil nil   nil
  /   \
nil   nil
</pre>
  <code>[3, 4, 8, 5]</code>

  <p>Идея решения. Запустить Level order. Но вместо того чтобы в каждом индексе хранить массив, мы будем хранить последний элемент.</p>
</article>


<!-- Вид слева -->
<article class="article">
  <div class="anchor" id="bintree8"></div>
  <h3>Вид слева</h3>

  <p>Дан корень бинарного дерева. Нужно вернуть массив самых правых вершин дерева на каждом уровне.</p>

  <p>Пример</p>
<pre>
             3
      /              \
    9                 4
  /   \           /       \
nil    2         1         8
     /   \     /   \     /   \
    5    nil nil   nil nil   nil
  /   \
nil   nil
</pre>
  <code>[3, 9, 2, 5]</code>

  <p>Идея решения. Запустить Level order. Но вместо того чтобы в каждом индексе хранить массив, мы будем хранить первый элемент.</p>
</article>


<!-- Сравнение деревьев -->
<article class="article">
  <div class="anchor" id="equal"></div>
  <h3>Сравнение деревьев</h3>
</article>


<!-- Симметричное дерево -->
<article class="article">
  <div class="anchor" id="bintree9"></div>
  <h3>Симметричное дерево</h3>

  <p>Дан корень бинарного дерева. Нужно вернуть true, если дерево симметрично, и false, если несимметрично</p>

  <p>Пример</p>
<pre>
                    5
         /                     \
        2                        2
    /       \                /       \
   4         8              8         4
  / \     /     \         /   \     /   \
nil nil  5       1       1     5  nil   nil
        / \     / \     / \
      nil nil nil nil nil nil
</pre>
  <code>true</code>

  <p>Алгоритм</p>
  <ol>
    <li>Из корня дерева нужно пойти в левую и правую вершину и сравнить их.</li>
    <li>Сначала сравниваем на nil. Если одна вершина nil, а другая нет то все дерево несимметрично.</li>
    <li>Сравниваем вершины. Если они не одинаковые то все дерево несимметрично.</li>
    <li>Если вершины одинаковые. Из левой вершины идем в левую, из правой в правую. Сравниваем их</li>
  </ol>

  <details>
    <summary>Решение</summary>
<pre>
// Definition for a binary tree node
type TreeNode struct {
  Val int
  Left *TreeNode
  Right *TreeNode
}

func isSymmetricSubtree(left *TreeNode, right *TreeNode) bool {
  if (left == nil || right == nil) {
    return left == nil && right == nil
  }
  if (left.Val != right.Val) {
    return false
  }
  return isSymmetricSubtree(left.Left, right.Right) && isSymmetricSubtree(left.Right, right.Left)
}

func isSymmetricTree(root *TreeNode) bool {
  return isSymmetricSubtree(root.Left, rootRight)
}
</pre>

  <p>Сложность по времени O(N)</p>
  <p>Сложность по памяти O(N)</p>

  </details>
</article>


<!-- Идентичные деревья -->
<article class="article">
  <div class="anchor" id="bintree10"></div>
  <h3>Идентичные деревья</h3>

  <p>Дан корень бинарного дерева. Нужно вернуть true, если деревья одинаковые, и false в противном случае</p>

  <p>Пример</p>
<pre>
       1                1
    /     \          /     \
   2       3        2       3
  / \     / \      / \     / \
nil nil nil nil  nil nil nil nil
</pre>
  <code>true</code>
</article>


<!-- Бинарное дерево поиска -->
<article class="article">
  <div class="anchor" id="bst"></div>
  <h3>Бинарное дерево поиска (BST)</h3>

  <p>В бинарном дереве поиска для каждой вершины верно, что все вершины слева будут меньше, все вершины справа будут больше</p>
</article>


<!-- Золотое правило BST -->
<article class="article">
  <div class="anchor" id="bst1"></div>
  <h3>Золотое правило BST</h3>

  <p>Золотое правило: если мы выполняем inorder (центрированный) обход, то мы получим отсортированный порядок</p>

  <p>Пример</p>
<pre>
      5
     / \
    3   6
   / \   \
  2   4   7
 /
1
</pre>
  <code>Input: root = [5,3,6,2,4,null,7,1]</code>
  <code>Output: [1,2,3,4,5,6,7]</code>

  <p>Обычно сортировка занимает NlogN времени, но используя inorder обход мы можем выполнить сортировку за O(N)</p>

  <p>Алгоритм inorder обхода</p>
  <ol>
    <li>Если текущий узел пустой - возвращаемся в родительскую вершину</li>
    <li>Обходим левое поддерево рекурсивно</li>
    <li>Добавляем значение текущего узла в ответ</li>
    <li>Обходим правое поддерево рекурсивно</li>
    <li>Возвращаемся в родительскую вершину</li>
  </ol>

  <details>
    <summary>inorder обход</summary>
<pre>
class TreeNode {
  constructor(val=0, left=null, right=null) {
    this.val = val,
    this.left = left,
    this.right = right
  }
}

function traversal(node, result) {
  // если вершина пустая, то возвращаемся к родителю
  if (node === null) {
    return;
  }

  // обходим левое поддерево
  traversal(node.left, result);

  // добавляем значение вершины в ответ
  result.push(node.val);

  // обходим правое поддерево
  traversal(node.right, result);
}

function inorderTraversal(root) {
  result = [];
  traversal(root, result);
  return result;
}
</pre>
  </details>

</article>


<!-- Проверка всех листьев -->
<article class="article">
  <div class="anchor" id="bst2"></div>
  <h3>Проверка всех листьев</h3>

  <p>Дан корень бинарного дерева поиска root и числа minVal и maxVal. Нужно проверить, что для каждой вершины node в дереве верно minVal &lt;= node.val &lt;= maxVal</p>

  <p>Пример</p>
<pre>
     10
    /  \
   5    11
  / \     \
-2   7     15
    /
   6
</pre>
  <code>Input: minVal = -5, maxVal = 15</code>
  <code>Output: true</code>

  <p>Если решать обходом всех узлов и проверкой каждого узла, то это будет медленно. Обход всех узлов займет O(N) повремени. Но мы воспользуемся свойством бинарного дерева поиска. Минимальное значение будет в левом поддереве в первой вершине, которая не имеет левого потомка. Максимальное значение будет в правом поддереве в первой вершине, которая не имеет правого потомка.</p>

  <p>Сложность по времени O(N)</p>
  <p>Сложность по памяти O(1)</p>

  <details>
    <summary>Решение</summary>
<pre>
function validateTreeValues(root, minVal, maxVal) {
  // нахождение значения самой левой вершины
  function getLeftmostValue(node) {
    while (node.left) {
      node = node.left;
    }
    return node.val;
  }

  // нахождение значения самой правой вершины
  function getRightmostValue(node) {
    while (node.right) {
      node = node.right;
    }
    return node.val;
  }

  // если нет корня
  if (!root) {
    return true;
  }

  // находим минимальное значение в BST
  leftmost = getLeftmostValue(root);

  // находим максимальное значение в BST
  rightmost = getRightmostValue(root);

  // валидация условия
  return minVal &lt;= leftmost && rightmost &lt;= maxVal;
}
</pre>
  </details>
</article>


<!-- Валидация дерева поиска -->
<article class="article">
  <div class="anchor" id="bst3"></div>
  <h3>Валидация дерева поиска</h3>

  <p>Дан корень бинарного дерева. Нужно проверить является ли дерево правильным бинарным деревом поиска</p>

  <p>Пример</p>
<pre>
     10
    /  \
   5    11
  / \     \
-2   7     15
    /
   6
</pre>
  <code>Output: true</code>

  <p>Идея решения. Дополнительно для каждой вершины хранить диапазон допустимых значений.</p>
  <p>Алгоритм</p>
  <ol>
    <li>Корень может быть любой. Диапазон для корня (-Infinity, +Infinity). Диапазон - не включительно, сторого больше левого значения и строго меньше правого значения. Корень равен 10</li>
    <li>Идем от корня в левую вершину. Диапазон (-Infinity, 10). Левая вершина равна 5</li>
    <li>Идем в левую вершину от вершины 5. Диапазон (-Infinity, 5). Вершина равна -2.</li>
    <li>Возвращаемся обратно в вершину 5 и идем в правую вершину. Диапазон (5, 10). Вершина равна 7.</li>
    <li>Идем в левую вершину. Диапазон (5, 7). Вершина равна 6.</li>
    <li>На этом обход левого поддерева закончен. Все вершины входят в свои диапазоны. Переходим в правое поддерево</li>
    <li>Идем от корня в правую вершину. Диапазон (10, +Infinity). Правая вершина равна 11.</li>
    <p>Идем в правую вершину от вершины 11. Диапазон (11, +Infinity). Вершина равна 15</p>
  </ol>

  <p>Сложность по времени O(N). Где N - число вершин. Потому что нужно обойти все вершины</p>
  <p>Сложность по памяти O(h). Где h - высота дерева. При обходе мы используем рекурсию и количество рекурсивных вызовов ограничивается высотой</p>

  <details>
    <summary>Решение</summary>
<pre>
function isValidBST(root) {
  function isValid(node, left, right) {
    // если пустая вершина, то все хорошо
    if (!node) {
      return true;
    }
    // если текущая вершина не лежит в нужном диапазоне,
    // то и все дерево не является правильным BST
    if (!((left &lt; node.val) && (node.val &lt; right)) {
      return false;
    }
    // обновляем границы диапазона для поддерева
    return isValid(node.left, left, node.val) &&
           isValid(node.right, node.val, right);
  }

  return isValid(root, -Infinity, +Infinity);
}
</pre>
  </details>
</article>


<!-- Из массива в дерево поиска -->
<article class="article">
  <div class="anchor" id="bst4"></div>
  <h3>Из массива в дерево поиска</h3>

  <p>Дан целочисленный массив nums, элементы которого отсортированы в порядке возрастания. Нужно преобразовать массив nums в сбалансированное по высоте двоичное дерево поиска</p>

  <p>Пример</p>
  <code>Input: [-2,4,6,12,18,21]</code>
<pre>
Output:
     6
  /    \
-2      18
  \    /  \
   4 12    21
</pre>

  <p>Высота левого и правого поддерева отличаются не более чем на 1</p>
  <p>Для того чтобы построить такое дерево воспользуемся алгоритмом</p>
  <ol>
    <li>Поставим левый указатель left на начало массива, правый указатель right на конец массива</li>
    <li>Найдем середину массива middle. Сложим указатели, поделим пополам и округлим до целого значения вниз. Получим индекс вершины которую поставим в корень дерева
      <code>left = 0;</code>
      <code>right = 5;</code>
      <code>middle = Math.floor((left + right) / 2); // 2</code>
    </li>
    <li>Корень дерева равен 6. Все что слева от 6  - пойдет в левое поддерево</li>
    <li>Начнем строить левое поддерево. Перенесем правый указатель на индекс (middle - 1). Теперь так же как искали корень, найдем левую вершину
      <code>left = 0;</code>
      <code>right = 1;</code>
      <code>node = Math.floor((left + right) / 2); // 0</code>
    </li>
    <li>Перенесем правый указатель на индекс (node-1). Проверяем условие, что left > right, а это значит что это пустая вершина. Возвращаем правый указатель на место right = 1</li>
    <li>Перенесем левый указатель вправо на 1 и получим left = right, left = 1. По индексу 1 находится вершина 4.</li>
  </ol>

  <details>
    <summary>Решение</summary>
<pre>
function toBST(nums, left, right) {
  // возвращаем пустую вершинку
  if (l>r) {
    return;
  }
  // вычисляем средний элемент между left и right
  mid = Math.floor((left + right) / 2);

  return new TreeNode(
    nums[mid],
  // рекурсивно строим левое поддерево,
  // которое будет сбалансированно по высоте
  toBST(nums, left, mid-1),

  // рекурсивно строим правое поддерево,
  // которое будет сбалансировано по высоте
  toBST(nums, mid+1, right),

  );
}

function sortedArrayToBST(nums) {
  return toBST(nums, 0, nums.lenght - 1);
}
</pre>
  </details>
  <p>Сложность по времени O(N)</p>
  <p>Сложность по памяти O(h)</p>
</article>


<!-- Ближайшее значение -->
<article class="article">
  <div class="anchor" id="bst5"></div>
  <h3>Ближайшее значение</h3>

  <p>Дан корень бинарного дерева поиска и число. Нужно найти вершину со значением, ближайшим к данному числу</p>

  <p>Пример</p>
<pre>
     10
    /  \
   5    11
  / \     \
-2   8     15
    /
   6
target = 6.2
</pre>
  <code>Output: 6</code>

  <details>
    <summary>Алгоритм</summary>
    <ol>
      <li>Заводим переменную res для ответа</li>
      <li>Заводим переменную dif для разности между target и result</li>
      <li>Заводим переменную cur для текущей вершины</li>
      <li>Заходим в корень дерева. Задаем начальные значения переменным
        <code>cur = 10; res = cur; dif = Math.abs(res - target)</code>
      </li>
      <li>Чтобы выбрать следующую вершину, проверяем условие
        <code>if (target &lt; cur) // true</code>
        Идем в левое поддерево.</li>
      <li>Левая вершина равна 5. Обновляем текущее значение
        <code>cur = 5</code>
        Проверяем нужно ли обновить результат
        <code>if (cur - target &lt; dif) // true</code>
        Обновляем результат и разницу
        <code>result = cur; dif = result - target.</code>
      </li>
      <li>Чтобы выбрать следующую вершину, проверяем условие
        <code>if (target &lt; cur) // false</code>
        Идем в правое поддерево.</li>
      <li>Правая вершина равна 8. Обновляем текущее значение
        <code>cur = 8</code>
        Проверяем нужно ли обновить результат
        <code>if (cur - target &lt; dif) // false</code>
      </li>
      <li>Чтобы выбрать следующую вершину, проверяем условие
        <code>if (target &lt; cur) // true</code>
        Идем в левое поддерево.</li>
      <li>Левая вершина равна 6. Обновляем текущее значение
        <code>cur = 6</code>
        Проверяем нужно ли обновить результат
        <code>if (cur - target &lt; dif) // true</code>
        Обновляем результат и разницу
        <code>result = cur; dif = result - target.</code>
      </li>
      <li>Чтобы выбрать следующую вершину, проверяем условие
        <code>if (target &lt; cur) // true</code>
        Идем в правое поддерево.</li>
      <li>Праваой вершины нету. Поэтому поиск закончен. Вершина с ближайшим значением найдена. Вернем результат</li>
    </ol>
  </details>

</article>


<!-- K-ый наименьший элемент в BST -->
<article class="article">
  <div class="anchor" id="bst6"></div>
  <h3>K-ый наименьший элемент в BST</h3>

  <p>Дан корень правильного бинарного дерева поиска и число k. Нужно венуть k-ый наименьший элемент в дереве (отсчет для k начинается с 1)</p>

  <p>Пример</p>
<pre>
input: k = 3
     10
    /  \
   5    11
  / \     \
-2   7     15
</pre>
  <code>Output: 7</code>

  <p>Для того чтобы понять какой должен быть ответ, отсортируем все числа</p>
  <code>-2, 5, 7, 10, 11, 15</code>
  <p>По условию, отсчет k начинается с 1, поэтому наименьшее третье число это 7</p>
  <p>Если применить inorder traversal к BST, то получим массив с отсортированными элементами. И ответом будет просто третий элемент сначала массива. Но можно и не создавать весь массив, а просто остановиться на нужном элементе, выполняя inorder traversal</p>
  <p>Подсчет каждого следующего наименьшего элемента ведется в момент когда возвращаемся из левой пустой вершины</p>

  <details>
    <summary>Решение</summary>
    <h4>Алгоритм</h4>
    <ol>
      <li>От корня идем в левое поддерево</li>
      <li>Проверяем пустая ли левая вершина</li>
      <li>Левая вершина равна 5. Идем в левое поддерево</li>
      <li>Проверяем пустая ли левая вершина</li>
      <li>Левая вершина равна -2. Идем в левое поддерево</li>
      <li>Проверяем пустая ли левая вершина</li>
      <li>Левая вершина пустая. Возвращаемся в вершину -2. Обновляем k
        <code>k = k - 1;</code>
      </li>
      <li>Проверяем k
        <code>if (k === 0)</code>
      </li>
      <li>k еще не равна нулю. Идем в правое поддерево</li>
    </ol>
    <p>Сложность по времени O(N)</p>
    <p>Сложность по памяти O(h)</p>
<pre>
function kthSmallest(root, k) {
  function inorder(node) {
    // если вершина пустая
    if (node === null) {
      return null;
    }

    // идем влево
    let result = inorder(node.left);

    // если нашли результат, то вернем его
    if (result !== null) {
      return result;
    }

    k = k - 1;
    if (k === 0) {
      // нашли k-ую наименьшую
      return node.val;
    }

    // идем вправо
    return inorder(node.right);
  }

  return inorder(root);
}
</pre>
  </details>
</article>


<!-- K-ый наибольший элемент в BST -->
<article class="article">
  <div class="anchor" id="bst7"></div>
  <h3>K-ый наибольший элемент в BST</h3>

  <p>Дан корень правильного бинарного дерева поиска и число k. Нужно венуть k-ый наибольший элемент в дереве (отсчет для k начинается с 1)</p>

  <p>Пример</p>
<pre>
input: k = 4
     10
    /  \
   5    11
  / \     \
-2   7     15
</pre>
  <code>Output: 7</code>

  <p>Идея решения. Возьмем решение для задачи про k-ый наименьший элемент. И поменяем две строчки местами</p>
  <details>
    <summary>Решение</summary>
<pre>
function kthBigest(root, k) {
  function inorder(node) {
    // если вершина пустая
    if (node === null) {
      return null;
    }

    // идем право
    let result = inorder(node.right); // изменили left на right

    // если нашли результат, то вернем его
    if (result !== null) {
      return result;
    }

    k = k - 1;
    if (k === 0) {
      // нашли k-ую наибольшую
      return node.val;
    }

    // идем влево
    return inorder(node.left);  // изменили right на left
  }

  return inorder(root);
}
</pre>
  </details>
  <p>Сложность по времени O(N)</p>
  <p>Сложность по памяти O(h)</p>
</article>

