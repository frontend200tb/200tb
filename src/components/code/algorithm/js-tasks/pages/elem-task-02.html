<h1>Задачи от Максима Фатина</h1>


<!-- links -->
<article class="article">
  <h2>links</h2>

  <p><a href="https://www.youtube.com/@fatin.maksim/videos">youtube Максим Фатин</a></p>
  <p><a href="https://algocode.io/">https://algocode.io/</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p><a href="#array">Массив</a></p>
  <p><a href="#hash">Хэш-таблица</a></p>
  <ol>
    <li><a href="#hash1">Сумма двух чисел в не отсортированном массиве</a></li>
    <li><a href="#hash2">Топ К часто встречающихся элементов</a></li>
    <li><a href="#hash3">Изоморфные строки</a></li>
    <li><a href="#count">Сортировка подсчетом</a></li>
    <li><a href="#count1">Анаграмма</a></li>
  </ol>
  <p><a href="#point">Два указателя</a></p>
  <ol>
    <li>
      <a href="#point1">С двух сторон</a>
      <p><a href="#point11">1.1 Отсортированный массив в квадрате</a></p>
      <p><a href="#point12">1.2 Палиндром</a></p>
      <p><a href="#point13">1.3 Палиндром сложный</a></p>
      <p><a href="#point14">1.4 Уровень воды</a></p>
      <p><a href="#point15">1.5 Сумма двух чисел в отсортированном массиве</a></p>
    </li>
    <li>
      <a href="#point2">Каждому по указателю</a>
      <p><a href="#point21">2.1 Объединить два неубывающих массива</a></p>
      <p><a href="#point22">2.2 Общие элементы отсортированных массивов</a></p>
    </li>
    <li>
      <a href="#point3">Медленный и быстрый указатели</a>
      <p><a href="#point31">Перемещение нулей</a></p>
    </li>
  </ol>
  <p><a href="#bit">Операции с битами</a></p>
  <ol>
    <li><a href="#bit1">Поменять 2 числа местами</a></li>
    <li><a href="#bit2">Число, которое встречается в массиве 1 раз</a></li>
    <li><a href="#bit3">Два числа, которые встречаются в массиве 1 раз</a></li>
  </ol>
  <p><a href="#matrix">Матрица</a></p>
  <ol>
    <li><a href="#matrix1">Сумма чисел на двух диагоналях матрицы</a></li>
  </ol>
  <p><a href="#bfsdfs">Поиск в ширину - BFS и поиск в глубину - DFS</a></p>
  <ol>
    <li><a href="#bfsdfs1">Острова на матрице из суши и воды</a></li>
  </ol>
  <p><a href="#binsearch">Бинарный поиск</a></p>
  <ol>
    <li><a href="#binsearch1">Найти число в отсортированном массиве</a></li>
    <li><a href="#binsearch2">Найти сдвиг в отсортированном массиве со сдвигом</a></li>
    <li><a href="#binsearch3">Найти число в отсортированном массиве со сдвигом</a></li>
  </ol>
  <p><a href="#linkedlist">Связный список (Linked list)</a></p>
  <ol>
    <li><a href="#dummynode">Паттерн Dummy node (фейковый узел)</a></li>
    <li><a href="#linkedlist1">Удалить N-ый узел с конца списка</a></li>
    <li><a href="#linkedlist2">Объединить два связных списка в возрастающем порядке</a></li>
  </ol>
  <p><a href="#stack">Стек, очередь</a></p>
  <p><a href="#sort">Сортировки</a></p>
</article>


<!-- Массив -->
<article class="article">
  <div class="anchor" id="array"></div>
  <h3>Массив</h3>
</article>


<!-- Хэш таблица -->
<article class="article">
  <div class="anchor" id="hash"></div>
  <h3>Хэш таблица</h3>


  <h4>Операции и их сложность</h4>
  <ol>
    <li>Поиск</li>
    <li>Вставка</li>
    <li>Получение</li>
    <li>Удаление</li>
  </ol>
  <p>Сложность по времени в среднем за O(1). Но очень редко, когда перестраивается хеш-таблица за O(N). Если хеш-таблица заранее выделила себе мало памяти и начали появлятся коллизии (когда разные элементы должны быть записаны в одну ячейку памяти), то происходит релокация (перестроение всей таблицы). Этот процесс по времени и по памяти имеет сложность O(N).</p>

  <h4>Что может быть ключем хеш-таблицы</h4>
  <p>Ключем хеш-таблицы может быть все что угодно (число, строка и т.д.). В некоторых языках ключем не могут быть mutable type.</p>

  <h4>Count sort (сортировка подсчетом)</h4>
  <p>Используют когда маленькое количество уникальных элементов</p>
  <p>Если элементы известны заранее, то можно использовать массив. Например, только две цифры 0 и 1, диапазон чисел от 0 до 9, буквы от a до z. Если элементы неизвестны, то используют словарь.</p>

  <h4>Анаграмма</h4>
  <p>Группировка анаграмм</p>
  <p>Поиск анаграмм</p>
  <p>Проверка на анаграмму</p>
</article>


<!-- 1. Сумма двух чисел в не отсортированном массиве -->
<article class="article">
  <div class="anchor" id="hash1"></div>
  <h3>1. Сумма двух чисел в не отсортированном массиве</h3>

  <p>Дан не отсортированный массив чисел и число. Определить, есть ли в массиве два числа , которые в сумме равны заданному числу</p>

  <p>Пример</p>
  <code>Input: [7,13,6,5], target = 18</code>
  <code>Output: true</code>

  <details>
    <summary>Решение</summary>
    <p>Метод хэш таблицы</p>
    <h4>Алгоритм</h4>
    <ol>
      <li>Заведем переменную dict для хранения пар ключ-значение и запишев в нее пустой объект
        <code>let dict = {};</code>
      </li>
      <li>Пройдем циклом по массиву
        <code>for (let i = 0; i &lt; nums.length; i++)</code>
      </li>
      <li>Если разница между target и текущим значением есть в словаре, то возвращаем true
        <code>if (t - nums[i] in dict) return true;</code>
      </li>
      <li>Если нет, то добавляем в словарь текущее значение
        <code>dict[nums[i]] = i;</code>
      </li>
      <li>Если цикл закончился, значит нет двух чисел с нужной суммой. Возвращаем false</li>
    </ol>
<pre>
function twoSum(nums, t) {
  let dict = {};

  for (let i = 0; i &lt; nums.length; i++) {
    if (t - nums[i] in dict) {
      return true;
    } else {
      dict[nums[i]] = i;
    }
  }
  return false;
}

console.log(twoSum([7,13,6,5], 18)); // true
console.log(twoSum([7,13,6,5], 21)); // false
</pre>
  </details>
  <p>Сложность по времени O(N). Сложность по памяти O(N)</p>

</article>


<!-- Паттерн "ключ-значение - значение-ключ" -->
<article class="article">
  <div class="anchor" id="key"></div>
  <h3>Паттерн "ключ-значение - значение-ключ"</h3>
</article>


<!-- 2. Топ К часто встречающихся элементов -->
<article class="article">
  <div class="anchor" id="hash2"></div>
  <h3>2. Топ К часто встречающихся элементов</h3>

  <p>Дан целочисленный массив nums и целое число k, нужно вернуть k наиболее частых элементов. Можно вернуть ответ в любом порядке</p>

  <p>Пример</p>
  <code>Input: nums = [5,3,1,5,5,3,7], k = 2</code>
  <code>Output: [5,3]</code>

  <p>Идея решения. Перебирать элементы и для каждого элемента считать сколько раз он встретился. Записывать в славарь. Ключем будет элемент, значением - его количество. Когда хеш-таблица создана, нужно создать массив размером n+1, где индексами будут значения из словаря (количество одинаковых элементов), а значением для каждого ключа будет массив с ключами из первого словаря (сами элементы). Таким образом, мы сделаем замену "ключа-значение" на "значение-ключ"</p>
  <details>
    <summary>Решение</summary>
    <p>Решение с помощью хещ-таблицы и паттерна "ключ-значение - значение-ключ"</p>
    <h4>Алгоритм</h4>
    <ol>
      <li>Заведем переменную res для массива с результатом
        <code>const res = [];</code>
      </li>
      <li>Заведем переменную dict для словаря, где ключем будет элемент входного массива, а значением - сколько раз он встречается
        <code>const dict = {};</code>
      </li>
      <li>Заведем переменную count для массива размером n+1, где индекс будут значения из словаря, а значением - массив с элементами
        <code>const count = [];</code>
      </li>
      <li>Пройдем циклом по входному массиву
        for (let num of nums)
      </li>
      <li>Если очередного элемента нет в словаре, то добавим его в словарь как ключ со значением 0
        <code>if (!(num in dict)) dict[num] = 0;</code>
      </li>
      <li>Увеличим значение dict[num] на 1</li>
      <li>Когда цикл закончится, закончится и формирование словаря
      </li>
      <li>
        Пройдем циклом по словарю
        <code>for (let num in dict)</code>
      </li>
      <li>Добавим очередной ключ словаря в массив count с индексом равным значению из словаря</li>
      <li>Пройдем по массиву count с конца и добавим первые k элементов в массив с результатом</li>
    </ol>
<pre>
function topKFrenq(nums, k) {
  const res = [];
  // ключ - число
  // значение - сколько раз встретилось
  const dict = {};
  // инекс - сколько раз встретилось число
  // значение - массив чисел, которые встретились столько раз
  const count = [];

  for (let num of nums) {
    if (!(num in dict)) {
      dict[num] = 0;
    }
    dict[num]++;
  }

  for (let num in dict) {
    let freq = dict[num];
    count[freq].push(Number(num));
  }

  for (let i = count.length - 1; i > 0; i--) {
    for (let num of count) {
      if (k &lt;= 0) {
        return res;
      }
      res.push(num);
      k--;
    }
  }
  return res;
}
</pre>
  </details>
</article>


<!-- 3. Изоморфные строки -->
<article class="article">
  <div class="anchor" id="hash3"></div>
  <h3>3. Изоморфные строки</h3>

  <p>Даны две строки s и t, определите, являются ли они изоморфными</p>

  <p>Две строки s и t изоморфны, если символы в s можно заменить, чтобы получить t</p>
  <p>Все вхождения символа должны быть заменены другим символом с сохранением порядка символов. Никакие два символа не могут отображаться в один и тот же символ, но символ может отображаться сам на себя</p>

  <h4>Пример 1</h4>
  <code>Input: s = "abacaba", t = "totxtot"</code>
  <code>Output: true</code>

  <h4>Пример 2</h4>
  <code>Input: s = "foo", t = "bar"</code>
  <code>Output: false</code>

  <p>Идея решения. Для каждой строки заведем свой словарь. И будем запоминать какая буква одной строке соответствует какой букве другой строки. Если какая-то буква не соответствует, то будем возвращать false</p>

  <details>
    <summary>Решение</summary>
    <h4>Алгоритм</h4>
    <ol>
      <li>Заведем два словаря dict1 и dict2 для каждой строки
        <code>const dict1 = {}, dict2 = {};</code>
      </li>
      <li>Заведем две переменные p1 и p2 для указателя для каждой строки. Поставим указатели на первый символ
        <code>let p1 = 0, p2 = 0;</code>
      </li>
      <li>Пройдем циклом по строке
        <code>for (let i = 0; i &lt; s.length; i++)</code>
      </li>
      <li>Если в первом словаре нет ключа равного символу первой строки, запишем в первый словарь ключ равный символу первой строки и значение равное символу второй строки
        <code>dict1[s[i]] = t[i];</code>
      </li>
      <li>Если такой символ есть, то проверяем чему равен этот символ во второй строке и сравниваем со значением в первом словаре</li>
      <li>Елсли совпадает то идем дальше, если не совпадает то вернем false. Строки не изоморфны</li>
      <li>Если во втором словаре нет ключа равного симолу второй строки, запишем во второй словарь ключ равный символу второй строки и значение равное символу первой строки
        <code>dict1[t[i]] = s[i];</code>
      </li>
      <li>Если такой символ есть, то проверяем чему равен этот символ в первой строке и сравниваем со значением во втором словаре</li>
      <li>Елсли совпадает то идем дальше, если не совпадает то вернем false. Строки не изоморфны</li>
      <li>Когда цикл закончится, то вернем true. Все символы совпали значит строки изоморфны</li>
    </ol>
<pre>
function isIsomorhic(s, t) {
  const dict1 = {}, dict2 = {};
  let p1 = 0, p2 = 0;
  for (let i = 0; i &lt; s.length; i++) {
    if (s[i] in dict1)
  }
}
</pre>
  </details>
  <p>Сложность по времени O(N). Сложность по памяти O(N)</p>
</article>


<!-- Сортировка подсчетом -->
<article class="article">
  <div class="anchor" id="count"></div>
  <h3>Сортировка подсчетом</h3>

  <p>Сортировка подсчетом (count sort). Используется когда входных элементов много, а различных вариантов одного элемента мало. Например в строках используются только английские буквы. Всего 26 английских букв. А сама строка может состоять из тысяч букв.</p>
  <p>Для перевода буквы в число будем использовать ASCII таблицу</p>
  <code>'a' = 97, 'z' = 122</code>
  <p>Создадим массив из 26 элементов и заполним их нулями. Берем по очереди каждую букву строки, вычисляем ее ASCII код, вычитаем ASCII код буквы 'a' и увеличиваем количество букв в массиве с таким кодом на 1</p>
</article>


<!-- 1. Анаграмма -->
<article class="article">
  <div class="anchor" id="count1"></div>
  <h3>1. Анаграмма</h3>

  <p>У нас есть две строки. Надо проверить является ли одна строка анаграммой другой строки.</p>
  <p>Ограничение: строка содержит только английские буквы в нижнем регистре и ее длина не может превышать 5000 символов</p>
  <p>Анаграмма - слово или фраза, образованная путем перестановки букв другого слова или фразы</p>
  <p>Число различных букв в 2 строках должно совпадать, чтобы одна строка стала анаграммой другой строки</p>

  <p>Примеры</p>
  <code>isAnagram('dog', 'god'); // true</code>
  <code>isAnagram('dog', 'good'); // false</code>

  <details>
    <summary>Решение (простое, но не оптимальное)</summary>
    <p>Отсортировать две строки и сравнить. Если они равны, то возвращаем true (это анаграмма). Если не равны, то возвращаем false.</p>
    <p>Сложность по времени O(NlogN) - это сложность сортировки. Сложность по памяти O(N) поскольку каждую строку переводим в массив, при сортировки массива вернется новый массив</p>

<pre>function isAnagram(str1, str2) {
  return str1.split('').sort().join('') == str2.split('').sort().join('');
}</pre>
  </details>

  <details>
    <summary>Решение (оптимальное)</summary>
    <p>Будем использовать метод сортировки подсчетом.</p>
    <p>Сложность по времени O(N) потому что мы должны один раз пройтись по всем элементам массива. Сложность по памяти O(1) потому что количество различных элементов заранее известно (26 английских букв)</p>
    <p>Для перевода буквы в число будем использовать ASCII таблицу</p>
    <code>'a' = 97, ..., 'z' = 122</code>
    <h4>Алгоритм</h4>
    <ol>
      <li>Создадим два массива count1 и count2 из 26 элементов и заполним их нулями. Для подсчета букв первой и второй строки.
        <code>let count1 = Array(26).fill(0);</code>
        <code>let count2 = Array(26).fill(0);</code>
      </li>
      <li>Сначала подсчитываем количество для каждой буквы в первой строке.</li>
      <li>Берем по очереди каждую букву первой строки, вычисляем ее ASCII код, вычитаем ASCII код буквы 'a'. и увеличиваем количество букв в массиве с таким кодом на 1</li>
      <li>Точно также подсчитываем количество для каждой буквы во второй строке</li>
      <li>Сравниваем два массива и возвращаем результат. Чтобы сравнить два массива, переведем каждый из них в строку.</li>
    </ol>

<pre>function isAnagram(str1, str2) {
  let count1 = Array(26).fill(0);
  let count2 = Array(26).fill(0);

  for (let i = 0; i &lt; str1.length; i++) {
    count1[str1.charCodeAt(i) - 97]++
  }

  for (let i = 0; i &lt; str2.length; i++) {
    count2[str2.charCodeAt(i) - 97]++
  }

  return count1.join() == count2.join();
}</pre>
  </details>
</article>


<!-- Два указателя -->
<article class="article">
  <div class="anchor" id="point"></div>
  <h3>Два указателя</h3>

  <p>Метод двух указателей можно разделить на 3 группы</p>
  <ol>
    <li>С двух сторон. Например, есть массив. Заводим две переменные pl и pr для два левого и правого указателя. Левый ставим на начало массива, а правый - на конец. Сравниваем элементы массива, на которые указывают указатели. На основе некоторого условия двигаем левый указатель вправо или правый влево. Указатели двигаем друг к другу пока они не встретятся</li>
    <li>Каждому по указателю. Например, есть два массива. Заводим две переменные p1 и p2 для первого и второго указателя. Первый ставим на начало первого массива, второй - на начало второго. Сравниваем элементы на которые указывают указатели. На основе некоторого условия двигаем первый или второй указатель вправо к концу массива. Указатель двигается пока не дойдет до конца массива.</li>
    <li>Медленный и быстрый указатели. Например, есть массив. Заведем две переменные ps и pf для медленного и быстрого указателя.</li>
  </ol>
</article>


<!-- 1. С двух сторон -->
<article class="article">
  <div class="anchor" id="point1"></div>
  <h3>1. С двух сторон</h3>
</article>


<!-- 1.1 Отсортированный массив в квадрате -->
<article class="article">
  <div class="anchor" id="point11"></div>
  <h3>1.1 Отсортированный массив в квадрате</h3>

  <p>Дан массив целых чисел nums, отсортированный в неубывающем порядке. Вернуть массив квадратов каждого числа, отсортированный в неубывающем порядке</p>

  <p>Пример</p>
  <code>Input: nums = [-4,-1,0,3,10]</code>
  <code>Output: [0,1,9,16,100]</code>

  <p>Идея решения. При возведении в квадрат отрицательное число становится положительным. Поэтому самым максимальным числом в результате может стать либо первое либо последнее число исходного массива возведенное в квадрат. Поэтому надо сравнить квадраты первого и последнего числа и максимальный поставить в конец результирующео массива. Потом сдвинуть один указатель и опять сравнить два карайних числа.</p>
  <details>
    <summary>Решение</summary>
    <h4>Алгоритм</h4>
    <ol>
      <li>Заведем переменную res для результата. Положим в нее пустой массив</li>
        <code>let res = [];</code>
      <li>Заведем две переменные pl и pr для левого и правого указателя. Левый поставим на начало массива, правый - на конец
        <code>let pl = 0, pr = nums.length - 1;</code>
      </li>
      <li>Пройдем циклом пока левый указатель меньше или равен правому
        <code>while (pl &lt;= pr)</code>
      </li>
      <li>Сравним квадраты двух элементов. Если квадрат левого элемент больше, то добавим его в массив res и двигаем левый указатель вправо, иначе записываем квадрат правого элемента и двигаем правый указатель влево</li>
      <li>Получили массив, отсортированный по убыванию. Перевернем массив и вернем результат</li>
    </ol>
<pre>
function sortedSquares(nums) {
  const res = [];
  let pl = 0, pr = nums.length - 1;

  while (pl &lt;= pr) {
    if (Math.abs(nums[pl]) > Math.abs(nums[pr])) {
      res.push(Math.pow(nums[pl], 2));
      pl++;
    } else {
      res.push(Math.pow(nums[pr], 2));
      pr--;
    }
  }
  return res.reverse();
}

console.log(sortedSquares([-4,-1,0,3,10])); // [0,1,9,16,100]
</pre>
  </details>
  <p>Сложность по времени O(N). Сложность по памяти O(1).</p>
</article>


<!-- 1.2 Палиндром -->
<article class="article">
  <div class="anchor" id="point12"></div>
  <h3>1.2 Палиндром</h3>

  <p>Проверить является ли строка палиндромом</p>
  <p>Палиндром - это строка, которая читается слева-направо и справа-налево одинаково</p>

  <p>Пример</p>
  <code>isPalindrome('topot'); // true</code>
  <code>isPalindrome('topoot'); // false</code>

  <details>
    <summary>Решение (простое, но не оптимальное)</summary>
    <p>Создать еще одну строку, но перевернутую и сравнить если строки будут равны, значит это палиндром.</p>
    <p>Сложность по времени O(N). Сложность по памяти O(N)</p>
<pre>function isPalindrome(str) {
  let rev = str.split('').reverse().join('');
  return str === rev;
}</pre>
  </details>

  <details>
    <summary>Решение (оптимальное)</summary>
    <p>Метод двух указателей.</p>
    <h4>Алгоритм</h4>
    <ol>
      <li>Заведем две переменные l и r для левого и правого указателей. Левый указатель поставим на первую букву строки. Правый указатель поставим на последнюю букву строки.
        <code>let l = 0, r = str.length - 1;</code>
      </li>
      <li>Запустим цикл пока левый указатель меньше правого
        <code>while (l &lt; r)</code>
      </li>
      <li>Будем сравнивать буквы. Если они не равны, то вернем false
        <code>if (str[l] != str[r]) retirn false;</code>
      </li>
      <li>Если они равны, то сдвинем левый указатель на 1 вправо, правый указатель на 1 влево.
        <code>l++; r--;</code>
      </li>
      <li>Когда левый указатель станет равен или больше правого, вернем true</li>
    </ol>
    <p>Сложность по времени O(N). Сложность по памяти O(1) потому что мы не используем дополнительную развернутую строку</p>

<pre>function isPalindrome(str) {
  let l = 0, r = str.length - 1;
  while (l &lt; r) {
    if (str[l] != str[r]) {
      return false
    }
    l++;
    r--;
  }
  return true;
}</pre>
  </details>
</article>


<!-- 1.3 Палиндром сложный -->
<article class="article">
  <div class="anchor" id="point13"></div>
  <h3>1.3 Палиндром сложный</h3>

  <p>Усложним задачу на палиндром. Во входной строке переведем все символы из верхнего регистра в нижний. Удалим все символы, которые не являются буквами или цифрами</p>

  <p>Пример</p>
  <code>1A,baC AB: a 1 -> 1a,bac ab: a 1 -> 1abacaba1 -> true</code>

  <details>
    <summary>Решение</summary>
    <p>Также воспользуемся двумя указателями, как и в предыдущем случае. Напишем вспомогательную функцию alNum() которая проверяет является ли переданный символ буквой или цифрой. Будем проверять каждый символ и если это не буква или цифра, то переходим к следующему символу. Таким образом, сначала сдвигаем левый указатель до первой буквы или цифры, потом сдвигаем правый указатель до первой буквы или цифры. Потом сравниваем два символа, переведенные в нижний регистр.</p>
    <p>Сложность по времени O(N). Сложность по памяти O(1)</p>

<pre>function isPalindrome(str) {
  let l = 0;
  let r = str.length - 1;
  while (l &lt; r) {
    if (!alNum(str[l])) {
      l++;
      continue;
    }
    if (!alNum(str[r])) {
      r--;
      continue;
    }
    if (str[l].toLowerCase() != str[r].toLowerCase()) {
      return false
    }
    l++;
    r--;
  }
  return true;
}

function alNum(a) {
  let b = a.charCodeAt(0);
  if ( b > 47 &&  b &lt; 58 || b > 64 && b &lt; 91 || b > 96 && b &lt; 123) {
    return true;
  } else {
    return false;
  }
}</pre>
  </details>
</article>


<!-- 1.4 Уровень воды -->
<article class="article">
  <div class="anchor" id="point14"></div>
  <h3>1.4 Уровень воды</h3>

  <p>К нам приходит массив чисел обозначающих высоту линий. Сколько максимум воды поместится между двумя любыми линиями если уровень воды не может превышать высоту линии</p>

  <p>Пример</p>
  <code>maxArea([1, 8, 6, 2, 5, 4, 8, 3, 7]); // 49</code>
  <p>Здесь максимум воды поместится между линиями 1 и 8. Высота линий 8 и 7, значит высота воды равна 7, она не может подняться выше 7 Ширина воды равна 7, так как она между 8 и 1, 8-1=7.</p>
<pre>
  #         #
  #         #   #
  # #       #   #
  # #   #   #   #
  # #   # # #   #
  # #   # # # # #
  # # # # # # # #
#_#_#_#_#_#_#_#_#
1 8 6 2 5 4 8 3 7
0 1 2 3 4 5 6 7 8
</pre>
<p>Если решать переборам и перебрать все пары, то получим квадратичную сложность O(n2) и это не оптимально. Оптимальное решение будет через два указателя.</p>

<details>
  <summary>Решение (оптимальное)</summary>
  <h4>Алгоритм</h4>
  <ol>
    <li>Заведем две переменные l и r для левого и правого указателя. Левый поставим на первый элемент массива, правый - на последний.
      <code>let l = 0, r = arr.length - 1;</code>
    </li>
    <li>Заведем две переменные max и cur. max для ответа, в которой будем хранить максимальную площадь. cur для текущей площади. Сначала там будет 0
      <code>let max = 0, cur = 0;</code>
    </li>
    <li>Запустим цикл пока левый указатель меньше правого
      <code>while (l &lt; r)</code>
    </li>
    <li>Обновляем текущую площадь
      <code>cur = Math.min(arr[l], arr[r]) * (r - l);</code>
    </li>
    <li>В переменную max записываем максимум из cur и max
      <code>max = Math.max(max, curr);</code>
    </li>
    <li>Двигаем указатель, который показывает на меньшую высоту</li>
  </ol>

  <pre>function maxArea(arr) {
  let l = 0, r = arr.length - 1;
  let max = 0, cur = 0;

  while (l &lt; r) {
    cur = Math.min(arr[l], arr[r]) * (r - l);
    max = Math.max(max, cur);
    if (arr[l] > arr[r]) {
      r--;
    } else {
      l++;
    }
  }

  return max;
}</pre>
  </details>
</article>


<!-- 1.5 Сумма двух чисел в отсортированном массиве -->
<article class="article">
  <div class="anchor" id="point15"></div>
  <h3>1.5 Сумма двух чисел в отсортированном массиве</h3>

  <p>Дан отсортированный массив чисел и число. Определить, есть ли в массиве два числа , которые в сумме равны заданному числу</p>

  <p>Пример</p>
  <code>Input: [4,4], target = 8</code>
  <code>Output: true</code>

  <p>Пример</p>
  <code>Input: [1,2,7,13,18], target = 15</code>
  <code>true</code>

  <details>
    <summary>Решение</summary>
    <p>Метод двух указателей</p>
    <h4>Алгоритм</h4>
    <ol>
      <li>Заведем две переменные l и r для левого и правого указателя и зададим им начальные значения - первый и последний индекс массива
        <code>let l = 0, r = nums.length - 1;</code>
      </li>
      <li>Пройдем циклом пока левый указатель меньше правого
        <code>while (l &lt; r)</code>
      </li>
      <li>Проверим сумму чисел на которые указывают указатели. Если сумма равна target, возвращаем true</li>
      <code>if (nums[l] + nums[r] === t)</code>
      <li>Если сумма больше target, двигаем правый указатель влево, если меньше, двигаем левый указатель вправо
        <code>if (nums[l] + nums[r] > t)</code>
      </li>
      <li>Если цикл закончился, значит никакие два числа не дали в сумме target. Возвращаем false</li>
    </ol>
<pre>
function twoSum(nums, t) {
  let l = 0, r = nums.length - 1;

  while (l &lt; r) {
    if (nums[l] + nums[r] === t) {
      return true;
    } else if (nums[l] + nums[r] > t) {
      r--;
    } else {
      l++;
    }
  }
  return false;
}

console.log(twoSum([1, 2, 7, 13, 15, 18, 29], 15)); // true
console.log(twoSum([1, 2, 7, 13, 15, 18, 29], 10)); // false
</pre>
  </details>
  <p>Сложность по времени O(N). Сложность по памяти O(1)</p>

</article>


<!-- 2. Каждому по указателю -->
<article class="article">
  <div class="anchor" id="point2"></div>
  <h3>2. Каждому по указателю</h3>
</article>


<!-- 1. Объединить два неубывающих массива -->
<article class="article">
  <div class="anchor" id="point21"></div>
  <h3>1. Объединить два неубывающих массива</h3>

  <p>Есть два неубывающих массива. Нужно их объединить в один неубывающий массив.</p>
  <p>Неубывающий массив - это массив, в котором значение каждого следующего элемента не меньше предыдущего. В отличие от возрастающего массива он может иметь ещё и равные элементы</p>
  <p>Напишем функцию arrayMerge(a1, a2), которая принимает два неубывающих массива и возвращает один объединенный неубывающий массив</p>

  <p>Примеры</p>
  <code>arrayMerge([-2, 3, 3], [-5, 0]); // [-5, -2, 0, 3, 3]</code>
  <code>arrayMerge([1, 2, 4], [9]); // [1, 2, 4, 9]</code>
  <code>arrayMerge([6], []); // [6]</code>

  <details>
    <summary>Решение (простое, но не оптимальное)</summary>
    <h4>Алгоритм</h4>
    <ol>
      <li>Создадим массив res для результата и положим в него все элементы которые у нас есть
        <code>let res = a1.concat(a2);</code>
      </li>
      <li>Отсортируем массив res
        <code>res.sort((a, b) => a - b);</code>
      </li>
      <li>Вернем результат
        <code>return res;</code>
      </li>
    </ol>

    <p>Оценим сложность по времени и памяти это решение. По времени сложность O(NlogN) - это сложность сортировки. Мы создаем дополнительный массив. Пусть размер первого массива n, а второго - m. Тогда дополнительная память это сумма элементов двух массивов n + m. Сложность по памяти O(n + m)</p>

<pre>function arrayMerge(a1, a2) {
  let res = a1.concat(a2);
  res.sort((a, b) => a - b);
  return res;
}</pre>
  </details>

  <details>
    <summary>Решение (оптимальное)</summary>
    <p>Напишем оптимальное решение. Оптимальное оно будет по времени. По памяти нельзя его улучшить, потому что ответ мы должны все равно отдавать в новом массиве, не изменяя входящие массивы.</p>
    <p>Будем использовать метод двух указателей.</p>
    <h4>Алгоритм</h4>
    <ol>
      <li>Заведем переменную res для результата. Положим в нее пустой массив
        <code>let res = [];</code>
      </li>
      <li>Заведем две переменные p1 и p2 для указателей. Поставим первый указатель на первый элемент первого массива, второй - на первый элемент второго.
        <code>let p1 = 0, p2 = 0;</code>
      </li>
      <li>Заведем две переменные len1 и len2 для длин массивов. Чтобы на каждой итерации не вычислять длину заново. Запишем в len1 длину первого массива, а в len2 - второго
        <code>let len1 = a1.length, len2 = a2.length;</code>
      </li>
      <li>Запустим цикл пока один из указателей не дойдет до конца массива
        <code>while (p1 &lt; len1 || p2 &lt; len2)</code>
      </li>
      <li>На каждой итерации будем выбирать наименьший элемент и добавлять его в результирующий массив. Тот элемент, который мы взяли, тот указатель мы и будем сдвигать. Если один из указателей выходит за пределы массива, то добавляем элементы с другого указателя, пока он тоже не выйдет из массива.</li>
    </ol>
    <p>Сложность по времени O(n + m) поскольку вместо сортировки мы проходим один раз по каждому массиву</p>

<pre>function arrayMerge(a1, a2) {
  let res = [];
  let p1 = 0, p2 = 0;
  let len1 = a1.length, len2 = a2.length;
  while (p1 &lt; len1 || p2 &lt; len2) {
    if (p2 >= len2 || p1 &lt; len1 && a1[p1] &lt;= a2[p2]) {
      res.push(a1[p1]);
      p1++;
    } else {
      res.push(a2[p2]);
      p2++
    }
  }
  return res;
}</pre>
  </details>
</article>


<!-- 2.2 Общие элементы отсортированных массивов -->
<article class="article">
  <div class="anchor" id="point22"></div>
  <h3>2.2 Общие элементы отсортированных массивов</h3>

  <p>Найти пересечение двух отсортированных массивов ИЛИ</p>
  <p>Для двух отсортированных массивов найти все эелементы, которые встречаются в обоих массивах и ответ вернуть в отсортированном массиве.</p>

  <p>Пример</p>
  <code>Input: nums1 = [2,2,5,8,14,19,29,30]</code>
  <code>nums2 = [-3,0,1,2,2,2,8,19]</code>
  <code>Output: [2,2,8,19]</code>

  <details>
    <summary>Решение (оптимальное)</summary>
    <p>Будем использовать метод двух указателей. Паттерн "Каждому по указателю"</p>
    <h4>Алгоритм</h4>
    <ol>
      <li>Заведем переменную res для результата. Положим в нее пустой массив
        <code>const res = [];</code>
      </li>
      <li>Заведем две переменные p1 и p2 для указателей. Поставим первый указатель на первый элемент первого массива, второй - на первый элемент второго.
        <code>let p1 = 0, p2 = 0;</code>
      </li>
      <li>Запустим цикл пока один из указателей не дойдет до конца массива
        <code>while (p1 &lt; a.length || p2 &lt; b.length)</code>
      </li>
      <li>Будем сравнивать два элемента nums[p1] и nums[p2].</li>
      <li>Если они равны, то элемент добавляется массив res и двигаем оба указателя вправо.</li>
      <li>Если не равны, то двигаем вправо указатель на меньшее число.</li>
      <li>Когда один из массивов закончился, выходим из цикла и возвращаем массив res</li>
    </ol>
<pre>
function intersect(a, b) {
  const res = [];
  let p1 = 0, p2 = 0;

  while (p1 &lt; a.length && p2 &lt; b.length) {
    if (a[p1] > b[p2]) {
      p2++;
    } else if (a[p1] &lt; b[p2]) {
      p1++;
    } else {
      res.push(a[p1]);
      p1++;
      p2++;
    }
  }
  return res;
}

let n1 = [2,2,5,8,14,19,29,30];
let n2 = [-3,0,1,2,2,2,8,19];
console.log(intersect(n1, n2)); // [2,2,8,19]
</pre>
  </details>
  <p>Сложность по времени O(n+m). Сложность по памяти O(min(n,m)).</p>
</article>


<!-- 3. Медленный и быстрый указатель -->
<article class="article">
  <div class="anchor" id="point3"></div>
  <h3>3. Медленный и быстрый указатель</h3>
</article>


<!-- 3.1 Перемещение нулей -->
<article class="article">
  <div class="anchor" id="point31"></div>
  <h3>3.1 Перемещение нулей</h3>

  <p>Дан целочисленный массив nums, переместите все нули в его конец, сохранив относительный порядок ненулевых элементов. Сделайте это in-place (на месте), не создавая копию массива</p>

  <p>Пример</p>
  <code>Input: nums = [2,0,0,9,3,0,1]</code>
  <code>Output: [2,9,3,1,0,0,0]</code>

  <p>Пример</p>
  <code>Input: nums = [2,3,0,9,3,0,1]</code>
  <code>Output: [2,3,9,3,1,0,0]</code>

  <p>Идея решения. Создать быстрый и медленный указатели. Быстрый будет идти первый и искать не нулевой элемент. медленый будет идти за ним с шагом 1 и указывать куда надо переместить ненулевой элемент. Когда быстрый указатель выходит за пределы массива, то все элементы начиная с медленного указателя должны быть нулями.</p>

  <p>Сложность по времени O(N). Сложность по памяти O(1).</p>
</article>


<!-- Операции с битами -->
<article class="article">
  <div class="anchor" id="bit"></div>
  <h3>Операции с битами</h3>
</article>


<!-- 1. Поменять 2 числа местами -->
<article class="article">
  <div class="anchor" id="bit1"></div>
  <h3>1. Поменять 2 числа местами</h3>

  <p>Пусть в двух x и y записаны два числа. Нужно поменять их местами не используя третью переменную</p>
  <p>Есть два способа сделать это</p>
  <p>Первый способ с помощью сложения и вычитания</p>
<pre>x = x + y;
y = x - y;
x = x - y;
</pre>
  <p>Второй способ с помощью операции XOR (исключающее ИЛИ)</p>
<pre>x = x ^ y;
y = x ^ y;
x = x ^ y;
</pre>
</article>


<!-- 2. Число, которое встречается в массиве 1 раз -->
<article class="article">
  <div class="anchor" id="bit2"></div>
  <h3>2. Число, которое встречается в массиве 1 раз</h3>

  <p>Приходит массив целых чисел. Каждое число встречается 2 раза, кроме одного. Найти это число, которое встречается в массиве один раз.</p>
  <p>Нужно решить за константную память O(1). Независимо от длины массива должно выделяться одинаковое количество дополнительной памяти. Использовать хеш таблицу не получится, потому что она требует O(N) памяти</p>

  <p>Пример</p>
  <code>uniq([2, 2, 1]); // 1</code>
  <code>uniq([4, 1, 2, 1, 2]); // 4</code>
  <code>uniq([2]); // 2</code>

  <details>
    <summary>Решение через XOR</summary>
    <p>Пройдем по массиву чисел и выполним исключающее ИЛИ с каждый элементом. Таким образом две одинаковые цифры при исключающем ИЛИ в результате дадут 0.</p>
    <p>Сложность по времени O(N). Сложность по памяти O(1)</p>
  <pre>function uniq(arr) {
  let result = 0;
  for (let i = 0; i &lt; arr.length; i++) {
    result ^= arr[i];
  }
  return result;
}</pre>
  </details>

  <details>
    <summary>Решение через подсчет бит</summary>
    <p>Заведем массив bitsCount для хранения сумм бит всех чисел.  Пройдем по массиву чисел и каждое число переводим в двоичный формат и каждый бит складываем с битами в bitsCount. Пройдем по массиву bitsCount и для каждого числа вычислим остаток от деления на 2. Получим новый массив, в котором будет наш ответ в двоичном виде.</p>
    <p>Сложность по времени O(N). Сложность по памяти O(1) потому что размер bitsCount равен разрядности чисел во входном массиве и не зависит от числа элементов в массиве.</p>
<pre>function uniq(arr) {
  let bitsCount = Array(32).fill(0);
  for (let num of arr) {
    // делаем + 2 ** 31 чтобы работать с положительными числами
    // и не переводить отрицательные в 2-ю систему счисления
    num = num + 2 ** 31;
    let i = 0;
    while (num != 0) {
      bitsCount[i] += num % 2;
      num = Math.floor(num/2);
      i++;
    }
  }
  let result = 0;
  for (let i = 0; i &lt; bitsCount.length; i++) {
    result = result * 2 + bitsCount[bitsCount.length-1-i] % 2;
  }
  return result - 2 ** 31;
}</pre>
  </details>

  <h4>Решение через подсчет бит является универсальным</h4>
  <p>Изменим условие задачи. Найти число, которое встречается 1 раз, а все остальные числа встречаются ровно 3 раза. В универсальном решении нужно будет изменить только одну строчку.</p>

  <details>
    <summary>Решение через подсчет бит</summary>
    <p>Вместо того чтобы использовать %2 мы теперь будем использовать %3</p>
<pre>function uniq(arr) {
  let bitsCount = Array(32).fill(0);
  for (let num of arr) {
    // делаем + 2 ** 31 чтобы работать с положительными числами
    // и не переводить отрицательные в 2-ю систему счисления
    num = num + 2 ** 31;
    let i = 0;
    while (num != 0) {
      bitsCount[i] += num % 2;
      num = Math.floor(num/2);
      i++;
    }
  }
  let result = 0;
  for (let i = 0; i &lt; bitsCount.length; i++) {
    result = result * 2 + bitsCount[bitsCount.length-1-i] % 3;
  }
  return result - 2 ** 31;
}</pre>
  </details>
  <p>Это решение имеет ограничение. Если одно число встречалось N раз, а все остальные M раз, при этом N % M не должно быть равно нулю.</p>
</article>


<!-- 3. Два числа, которые встречаются в массиве 1 раз -->
<article class="article">
  <div class="anchor" id="bit3"></div>
  <h3>3. Два числа, которые встречаются в массиве 1 раз</h3>

  <p>Нужно найти два числа A и B, которые встречаются в массиве только один раз</p>

  <details>
    <summary>Решение с битовой маской</summary>
    <p>Посчитаем XOR для всех чисел в массиве. Одинаковые числа дадут в результате ноль. Останется XOR от двух разных чисел, которые мы ищем. Это числа разные, поэтому у них есть хотя бы один бит, который отличается. Найдем первый бит, который отличается у чисел A и B</p>
<pre>function uniq(arr) {
  // считаем xor для всех чисел в массиве
  let numsXor = 0;
  for (let num of arr) {
    numsXor ^= num;
  }
  // теперь numsXor = A ^ B
  // гдк A и B искомые числа

  // находим первый бит, который не совпадает
  // у искомых чисел A и B (можно взять любой бит)
  // я беру последний равный 1
  let bitMask = numsXor & (numsXor - 1) ^ numsXor;
  // теперь будем делать xor только для тех чисел
  // где есть совпадение по nonZeroBit
  // таким образом мы найдем одно из двух чисел
  // (можно искать и где не совпадает, в этом случае
  // мы найдем не A, а B)
  let A = 0;
  for (let num of arr) {
    if ((bitMask & num) !== 0) {
      A ^= num;
    }
  }
  let B = numsXor ^ A;
  return [A, B];
}</pre>
  </details>
</article>


<!-- Матрица -->
<article class="article">
  <div class="anchor" id="matrix"></div>
  <h3>Матрица</h3>
</article>


<!-- 1. Сумма чисел на двух диагоналях матрицы -->
<article class="article">
  <div class="anchor" id="matrix"></div>
  <h3>1. Сумма чисел на двух диагоналях матрицы</h3>

  <p>Дана матрица. Двумерный массив. Нужно найти сумму всех элементов на двух диагоналях</p>
  <p>Пример</p>
<pre>
[1, 12, 13, 5]
[15, 2, 6, 18]
[9, 7, 3, 12]
[8, 14, 25, 4]
Ответ 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 = 36
</pre>
<pre>
[1, 2]
[3, 4]
Ответ 1 + 2 + 3 + 4 = 10
</pre>
  <p>Перед написанием кода важно уточнить ограничения. Они достаточно сильно могут влиять на решение задачи. Какой максимальный размер матрицы? Всегда ли матрица квадратная? В нашей задаче максимальный размер матрицы 100 на 100 и она всегда квадратная. Какие числа могут быть в матрице? Точно ли что сумма диагональных элементов не вызовет переполнение? В нашей задаче переполнения не будет.</p>

  <details>
    <summary>Решение</summary>
    <p>Сначала обдумаем решение. Пусть есть три матрицы 4х4, 3х3 и 2х2</p>
<pre>
1 0 0 2
0 1 2 0
0 2 1 0
2 0 0 1
Ответ 12
</pre>
<pre>
1 2 3
4 5 6
7 8 9
Ответ 25
</pre>
<pre>
1 2
3 4
Ответ 10
</pre>
    <p>Для матриц с четным размером (4х4) работает такая формула</p>
    <code>mat[i][i] + mat[i][n-i-1]</code>
    <p>Для нечетной матрицы по этой формуле центральный элемент, который лежит на пересечении двух диагоналей, будет складываться дважды. Чтобы проверить что мы складываем разные элементы, надо чтобы i не было равно n-i-1</p>
    <p>Сложность по времени O(N). Сложность по памяти O(1)</p>
<pre>function sum(mat) {
  let len = mat.length;
  let result = 0;
  for (let i = 0; i &lt; len; i++) {
    result += mat[i][i];
    if (i != len-i-1) {
      result += mat[i][len-i-1];
    }
  }
  return result;
}</pre>
  </details>
</article>


<!-- Поиск в ширину - BFS и поиск в глубину - DFS -->
<article class="article">
  <div class="anchor" id="bfsdfs"></div>
  <h3>Поиск в ширину - BFS и поиск в глубину - DFS</h3>
</article>


<!-- 1. Острова на матрице из суши и воды -->
<article class="article">
  <div class="anchor" id="bfsdfs1"></div>
  <h3>1. Острова на матрице из суши и воды</h3>

  <p>Дана матрица из единиц и нулей. Где 1 это суша, а 0 это вода. Выглядит как карта. Участки суши могут образовывать острова. Участки суши образовывают остров если распологаются на соседних клетках по вертикали или горизонтали. Сколько на такой карте островов? Соседние по диагонали клетки не считаются островом</p>

  <p>Пример</p>
<pre>[
[0, 0, 1, 0, 0],
[0, 1, 1, 0, 0],
[0, 1, 1, 0, 0],
[0, 0, 0, 1, 1],
[1, 0, 0, 0, 0]
]</pre>
  <code>Ответ три острова</code>

  <p>Пример</p>
<pre>[
[1, 1, 0, 0, 0],
[1, 1, 0, 0, 0],
[0, 0, 1, 0, 0],
[0, 0, 0, 1, 1],
]</pre>
  <code>Ответ три острова</code>

  <p>Пример</p>
<pre>[
  [1, 1],
  [1, 1]
]</pre>
  <code>Ответ один остров</code>

  <p>Это задача на <strong>поиск в ширину - BFS</strong> и <strong>поиск в глубину - DFS</strong>. Это способы обойти граф. При BFS мы обходим граф равномерно во все стороны. При DFS мы идем по одному пути пока он не закончится, после этого выбираем другое направление.</p>
  <p>Нужно пройтись по всем клеткам суши и помечать их как пройденные (окрашивать). Неважно в ширину или в глубину мы будем идти, важно чтобы в конце все клетки были окрашены.</p>
  <p>В данной задаче хватит рекурсивной реализации DFS. Лучше взять ее. Она проще в написании. Там меньше кода.</p>

  <details>
    <summary>Решение с помощью рекурсивного DFS</summary>
  <p>Для запоминания того что мы вершину посетили (покрасили) будем использовать дополнительный массив used, который по размеру равен размеру входящей матрицы. Изначально все значения равны false, так как мы ни одну вершину еще не посещали. После посещения вершины, ее значение в матрице used делаем true</p>
  <p>Проходим по входному массиву и если пришла 1 (суша) и в массиве used стоит false (она еще не посещена), то будем для нее запускать DFS</p>
  <p>В каком порядке будем обходить вершины в DFS? Из каждой вершины сначала пробуем идти вниз, потом влево, потом вверх, потом вправо.</p>
  <p>Когда мы начинаем обход вершин надо делать несколько проверок. Первая проверка это то что мы не вышли за границы матрицы. Вторая проверка это то что в клетке 1 (суша). Третья проверка это то что вершина посещена. Если вершина прошла все проверки, то помечаем ее как посещенную (в массиве used отмечаем true) и идем к следующей вершине. Когда дойдем до вершины из которой мы уже обошли во все четыре стороны, то вернемся в предыдущую вершину. И так пока не дойдем снова до первой вершины с которой мы начали обход.</p>
  <p>Когда мы закончим обход из одной вершины, то прибавим 1 к числу найденных островов. Проходим далее по входному массиву, пока не дойдем до следующей вершины, которая 1 (суша) и в массиве used стоит false (она еще не посещена). Для нее также запустим DFS</p>
  <p>Сложность по времени O(n*m). Сложность по памяти O(n*m). Где n*m размер матрицы.</p>
  <p>Недостаток рекурсивного решения - при большой матрице будет переполнение стека вызовов.</p>

<pre>function countIslands(mat) {
  let len = mat.length;
  let len2 = mat[0].length;
  // создадим матрицу used
  let used = [];
  // заполним матрицу used значением false
  for (let i = 0; i &lt; len; i++) {
    used[i] = [];
    for (let j = 0; j &lt; len2; j++) {
      used[i][j] = false;
    }
  }
  let result = 0;
  // начинаем обходить входную матрицу
  for (let i = 0; i &lt; len; i++) {
    for (let j = 0; j &lt; len2; j++) {
      // клетка посещена или там вода
      if (used[i][j] || mat[i][j] === 0) {
        continue;
      }
      // выполняем поиск в глубину
      dfs(i, j, used, mat);
      result++;
    }
  }
  return result;
}

function dfs(x, y, used, mat) {
  // вышли за границы матрицы
  if (x &lt; 0 || x >= mat.length || y &lt; 0 || y >= mat[0].length) {
    return;
  }
  // клетка посещена или там вода
  if (used[x][y] || mat[x][y] === 0) {
    return;
  }
  // помечаем клетку как посещенную
  used[x][y] = true;
  // сдвиг относительно текущей позиции
  let steps = [
    [1, 0],  // вниз   x = x + 1
    [0, -1], // влево  y = y - 1
    [-1, 0], // вверх  x = x - 1
    [0, 1]   // вправо y = y + 1
  ];
  // обходим всех соседей
  for(let step of steps) {
    nextX = x + step[0];
    nextY = y + step[1];
    dfs(nextX, nextY, used, mat);
  }
}</pre>
  </details>

  <p>Пример</p>
<pre>[
[0, 0, 0, 1, 1],
[0, 0, 0, 1, 1],
[0, 0, 0, 1, 1],
[1, 1, 1, 0, 0],
[0, 1, 1, 1, 1]
]</pre>
  <code>Ответ два острова</code>

  <details>
    <summary>Решение с помощью BFS</summary>
    <p>Для BFS нам понадобится очередь q. Алгоритм начинается также как и для DFS - мы ищем первую клетку 1 (суша) и used = false. Для нее будем запускать поиск в ширину. Сразу добавляем эту клетку в очередь q. При добавлении клетки в очередь в массиве used помечаем что мы посетили данную вершину (true). Теперь, пока очередь не пуста, будем выполнять следующий алгоритм (BFS).</p>
    <p>1. Достаем элемент из очереди</p>
    <p>2. Будем обходить всех его соседей</p>
    <p>3. Сначала проверим что для соседа выполняется три условия. Первое условие что клетка не вышла за границы массива. Второе условия что в клетке находится 1 (суша). Третье условие что клетка еще не посещена, в массиве used стоит false.</p>
    <p>4. Если все три условия выполняются, то добавляем ее в очередь. Ставим used = true</p>
    <p>Когда всех соседей обошли, начинаем алгоритм сначала, т.е. берем следующий элемент из очереди</p>
    <p>Сложность по времени O(n*m). Сложность по памяти O(n*m). Где n*m размер матрицы.</p>

<pre>function countIslands(mat) {
  let len = mat.length;
  let len2 = mat[0].length;
  // создадим матрицу used
  let used = [];
  // заполним матрицу used значением false
  for (let i = 0; i &lt; len; i++) {
    used[i] = [];
    for (let j = 0; j &lt; len2; j++) {
      used[i][j] = false;
    }
  }
  let result = 0;
  // начинаем обходить входную матрицу
  for (let i = 0; i &lt; len; i++) {
    for (let j = 0; j &lt; len2; j++) {
      // клетка посещена или там вода
      if (used[i][j] || mat[i][j] === 0) {
        continue;
      }
      // выполняем поиск в глубину
      bfs(i, j, used, mat);
      result++;
    }
  }
  return result;
}

function bfs(x, y, used, mat) {
  // сразу кладем элемент в очередь
  let q = [[x, y]];
  // помечаем элемент как посещенный
  used[x][y] = true;
  // пока очередь не пуста выполняем алгоритм
  while (q.length > 0) {
    // достаем элемент из очереди
    [x, y] = q.shift();
    // сдвиг относительно текущей позиции
    let steps = [
      [1, 0],  // вниз   x = x + 1
      [0, -1], // влево  y = y - 1
      [-1, 0], // вверх  x = x - 1
      [0, 1]   // вправо y = y + 1
    ];
    // обходим всех соседей
    for(let step of steps) {
      nextX = x + step[0];
      nextY = y + step[1];
      // вышли за границы матрицы
      if (nextX &lt; 0 || nextX >= mat.length || nextY &lt; 0 || nextY >= mat[0].length) {
        continue;
      }
      // клетка посещена или там вода
      if (used[nextX][nextY] || mat[nextX][nextY] === 0) {
        continue;
      }
      // добавляем элемент в очередь
      q.push([nextX, nextY]);
      // помечаем элемент как посещенный
      used[nextX][nextY] = true;
    }
  }
}</pre>
  </details>

  <p>Остается только рассказать как написать нерекурсивный DFS. Как сделать поиск в глубину не рекурсивным, а итеративным, как поиск в ширину. Это очень просто. Нужно взять реализацию BFS. Переименовать функцию BFS в DFS. И поменять одну строку.</p>

  <code>[x, y] = q.shift(); // достаем элемент из очереди</code>
  <code>[x, y] = q.pop(); // достаем элемент из очереди</code>

  <p>Единственное чем отличается поиск в ширину и в глубину в итеративной реализации это тем какая <strong>структура данных</strong> используется. Для поиска в ширину мы используем <strong>очередь</strong>, а для поиска в глубину нужно использовать <strong>стек</strong>. В поиске в ширину мы каждый раз забираем первый элемент (из массива, который реализует очередь). В поиске в глубину мы забираем последний элемент (из массива, который реализует стек).</p>

  <details>
    <summary>Решение с помощью итеративного DFS</summary>
    <p>Итеративный поиск в глубину использует очередь, в отличие от рекурсивного решения, которое изспользует стек вызовов.</p>
<pre>function countIslands(mat) {
  let len = mat.length;
  let len2 = mat[0].length;
  // создадим матрицу used
  let used = [];
  // заполним матрицу used значением false
  for (let i = 0; i &lt; len; i++) {
    used[i] = [];
    for (let j = 0; j &lt; len2; j++) {
      used[i][j] = false;
    }
  }
  let result = 0;
  // начинаем обходить входную матрицу
  for (let i = 0; i &lt; len; i++) {
    for (let j = 0; j &lt; len2; j++) {
      // клетка посещена или там вода
      if (used[i][j] || mat[i][j] === 0) {
        continue;
      }
      // выполняем поиск в глубину
      dfs(i, j, used, mat);
      result++;
    }
  }
  return result;
}

function dfs(x, y, used, mat) {
  // сразу кладем элемент в очередь
  let q = [[x, y]];
  // помечаем элемент как посещенный
  used[x][y] = true;
  // пока очередь не пуста выполняем алгоритм
  while (q.length > 0) {
    // достаем элемент из очереди
    [x, y] = q.pop();
    // сдвиг относительно текущей позиции
    let steps = [
      [1, 0],  // вниз   x = x + 1
      [0, -1], // влево  y = y - 1
      [-1, 0], // вверх  x = x - 1
      [0, 1]   // вправо y = y + 1
    ];
    // обходим всех соседей
    for(let step of steps) {
      nextX = x + step[0];
      nextY = y + step[1];
      // вышли за границы матрицы
      if (nextX &lt; 0 || nextX >= mat.length || nextY &lt; 0 || nextY >= mat[0].length) {
        continue;
      }
      // клетка посещена или там вода
      if (used[nextX][nextY] || mat[nextX][nextY] === 0) {
        continue;
      }
      // добавляем элемент в очередь
      q.push([nextX, nextY]);
      // помечаем элемент как посещенный
      used[nextX][nextY] = true;
    }
  }
}</pre>
  </details>
</article>


<!-- Бинарный поиск -->
<article class="article">
  <div class="anchor" id="binsearch"></div>
  <h3>Бинарный поиск</h3>

  <p>Использовать бинарный поиск для решения можно если удается разбить входны данные на две непрерывающиеся последовательности по каким нибудь признакам.</p>
</article>


<!-- 1. Найти число в отсортированном массиве -->
<article class="article">
  <div class="anchor" id="binsearch1"></div>
  <h3>1. Найти число в отсортированном массиве</h3>

  <p>Есть массив nums отсортированный в возрастающем порядке. Проверить есть ли в этом массиве число target. Если такого числа нет, то вернуть -1. Если такое число есть, то вернуть его позицию.</p>

  <p>Пример</p>
  <code>nums = [-1, 0, 3, 5, 9, 12]; target = 9;</code>
  <code>Ответ 4</code>

  <p>Для входный данных можно придумать функцию, которая превратит наш массив из чисел в массив из true и false. При этом сначала будут идти все true, а потом false. В этой задаче такой функцие будет</p>
  <code>nums[i] &lt;= target</code>
  <p>То есть мы смогли разбить входные данные на две непрерывающиеся последовательности. И это будет работать для любых входных данных. Поэтому данную задачу можно решать бинарным поиском.</p>
  <p>Будем называть элементы, которые дают ture - хорошими, а false - плохими. В этом случае target может быть только последним хорошим элементом. Именно поэтому после бинарного поиска нужно проверить что он равен target.</p>
  <p>В бинарном поиске мы ищем не один элемент target, а два элемента. Первый где заканчивается true, второй - где начинается false. То есть первый указатель встанет на последний хороший элемент, а второй указатель - на первый плохой.</p>
  <p>Сложность по времени O(logN). Сложность по памяти O(1).</p>

  <details>
    <summary>Решение с помощью бинарного поиска</summary>
    <p>Заведем два указателя l и r. l указывает на первый элемент массива, r указывает за пределы массива на следующий (несуществующий) элемент после последнего. Будем сдвигать левый указатель вправо, а правый влево до тех пор пока они не будут указывать на соседние элементы (разница между ними будет 1).</p>
    <p>Ответ будет находиться в элементе указывающем на l. Чтобы l мог принимать значения [0, nums.length - 1] т.е. от первого и до последнего индекса включительно, сдвигаем r на 1 вправо от последнего индекса массива.</p>
<pre>function search(nums, target) {
  let l = 0;
  let r = nums.length;
  while (r - l > 1) {
    // определяем середину
    let m = Math.floor((l + r) / 2);
    if (isGood(nums[m], target)) {
      // если число по индексу m хорошее, то двигаем левый указатель
      l = m;
    } else {
      // если число по индексу m плохое, то двигаем правый указатель
      r = m;
    }
  }
  // если левый указатель указывает на target
  // то вернуть левый указатель, иначе -1
  return nums[l] === target ? l : -1;
}

function isGood(val, target) {
  return val &lt;= target;
}</pre>
  </details>
</article>


<!-- 2. Найти сдвиг в отсортированном массиве со сдвигом -->
<article class="article">
  <div class="anchor" id="binsearch2"></div>
  <h3>2. Найти сдвиг в отсортированном массиве со сдвигом</h3>

  <p>Есть массив чисел nums. Он отсортирован по возрастанию, но со сдвигом.</p>

  <p>Пример</p>
  <code>nums = [4,5,6,7,1,2,3];</code>
  <code>Ответ 4</code>
  <p>Массив [4,5,6,7,1,2,3] получен из массива [1,2,3,4,5,6,7] сдвигом на 4 элемента вправо</p>

  <p>Чтобы найти сдвиг (offset) с помощью бинарного поиска, определим функцию, которая будет возвращать для всех элементов сначала true, а потом false</p>

  <p>Пример 1</p>
  <code>nums = [4,5,6,7,0,1,2]</code>
<pre>
    good   bad
[4 5 6 7 | 0 1 2]
       l   r
</pre>
  <p>Здесь элементы с 4 по 7 хорошие, с 0 по 2 плохие и сдвиг равен 4.</p>

  <p>Пример 2</p>
  <code>nums = [1,2,3,4,5]</code>
<pre>
good    bad
    [ | 1 2 3 4 5]
  l     r
</pre>
  <p>В этом примере хороших элементов нет и сдвиг равен 0.</p>
  <p>Сдвиг равен индексу, на который указывает правый указатель r.</p>

  <details>
    <summary>Решение с помощью бинарного поиска</summary>
    <p>Ответ будет находиться в правом указателе r. Поэтому указатель r может принимать значения [0, nums.length - 1]</p>
<pre>function offset(nums) {
  function isGood(i) {
    return nums[i] >= nums[nums.length-1];
  }

  let l = -1;
  let r = nums.length - 1;
  while (r - l > 1) {
    // определяем середину
    let m = Math.floor((l + r) / 2);
    if (isGood(m)) {
      // если число по индексу m хорошее, то двигаем левый указатель
      l = m;
    } else {
      // если число по индексу m плохое, то двигаем правый указатель
      r = m;
    }
  }
  // то вернуть правый указатель
  return r;
}</pre>
  </details>
</article>


<!-- 3. Найти число в отсортированном массиве со сдвигом -->
<article class="article">
  <div class="anchor" id="binsearch3"></div>
  <h3>3. Найти число в отсортированном массиве со сдвигом</h3>

  <h3>Задача на бинарный поиск, который надо применить 2 раза</h3>
  <p>Есть массив чисел nums. Он отсортирован по возрастанию, но со сдвигом. Еще есть target - число, позицию которого нужно вернуть, если оно есть в массиве nums. Если его нет - вернуть -1.</p>

  <p>Пример</p>
  <code>search([4,5,6,7,1,2,3], 5); // 1</code>
  <p>Массив [4,5,6,7,1,2,3] получен из массива [1,2,3,4,5,6,7] сдвигом на 4 элемента вправо</p>

  <p>Бинарный поиск нужно применить 2 раза.</p>
  <p>1. Когда будем искать сам сдвиг</p>
  <p>2. Для поиска самого элемента</p>

<pre>function offset(nums) {
  function isGood(i) {
    return nums[i] >= nums[nums.length-1];
  }

  let l = -1;
  let r = nums.length - 1;
  while (r - l > 1) {
    // определяем середину
    let m = Math.floor((l + r) / 2);
    if (isGood(m)) {
      // если число по индексу m хорошее, то двигаем левый указатель
      l = m;
    } else {
      // если число по индексу m плохое, то двигаем правый указатель
      r = m;
    }
  }
  // вернуть правый указатель
  return r;
}

function search(nums, target) {
  function isGood(i) {
    return nums[i] &lt;= target;
  }

  // обычный бинарный поиск, но смещаем на offset дополнительно
  let shift = offset(nums);
  let l = 0;
  let r = nums.length;
  while (r - l > 1) {
    // определяем середину
    // Ошибка №1 это делать m=(l+r+shift)/2
    let m = Math.floor((l + r) / 2);
    if (isGood((m+shift) % nums.length)) {
      // если число по индексу m хорошее, то двигаем левый указатель
      l = m;
    } else {
      // если число по индексу m плохое, то двигаем правый указатель
      r = m;
    }
  }
  // Ошибка №2 это забыть сделать (l+shift) % nums.length
  // Берем остаток от деления чтобы не выйти за границы массива
  let realLeft = (l + shift) % nums.length;
  // если левый указатель указывает на target
  // то вернуть левый указатель, иначе -1
  return nums[realLeft] === target ? realLeft : -1;
}</pre>
</article>


<!-- Связный список (Linked list) -->
<article class="article">
  <div class="anchor" id="linkedlist"></div>
  <h3>Связный список (Linked list)</h3>

  <p>Linked list - это структура данных, состоящая из узлов. В узле хранится его значение и указатель на следующий узел</p>

  <p>Пример</p>
  <p>Есть связный список из двух узлов. Первый узел хранит указатель на второй узел. Второй узел хранит указатель на null, потому что это последний узел и третьего узла нет</p>

  <p>На собеседовании нужно самому реализовать поиск длины списка. Пройтись по каждому узлу и посчитать длину всего списка. По времени это O(N).</p>
  <p>Различают односвязный список и двусвязный. В односвязном списке из одной вершины можно идти только в следующую, но не предыдущую</p>

  <p>Пример связного списка</p>
<pre>
class LinkedList {
  constructor(val, next) {
    this.val = val;
    this.next = next;
  }
}</pre>
</article>


<!-- Паттерн Dummy node (фейковый узел) -->
<article class="article">
  <div class="anchor" id="dummynode"></div>
  <h3>Паттерн Dummy node (фейковый узел)</h3>

  <p>Паттерн Dummy node упрощает решение для задач со связным списком. Добавим фейковую вершину перед головой списка. Эта фейковая вершина станет новой головой списка, которая будет указывать на настоящую голову. В таком случае, у нас всегда будет предыдущая вершина и удаление первой вершины не будет никаким исключением.</p>
  <p>Паттерн dammy node - это присоединение фейковой вершины к голове списка и используется в двух случаях. Когда мы не хотим делать крайним случаем (corner case) удаление первой вершины. И когда мы не знаем какая из вершин должна быть первой в ответе, то есть не знаем куда цеплять ответ.</p>

  <h4>Список задач на leetcode</h4>
  <p>19. Remove Nth node from end of list</p>
  <p>21. Merge two sorted lists</p>
  <p>23. Merge K sorted lists</p>
</article>


<!-- 1. Удалить N-ый узел с конца списка -->
<article class="article">
  <div class="anchor" id="linkedlist1"></div>
  <h3>1. Удалить N-ый узел с конца списка</h3>

  <p>Дана голова связного списка и число N. Нужно удалить N-ый узел с конца. Вернуть получившийся список.</p>
  <p>N-ый узел гарантированно есть. N не может быть больше чем длина самого списка</p>

  <p>Пример</p>
  <code>{1,2,3,4,5}. удалить 2 с конца вершину.</code>
  <code>Ответ {1,2,3,5}</code>

  <p>Есть два популярных решения.</p>

  <h4>Решение 1</h4>
  <p>Пройтись по списку и узнать длину. Зная длину мы можем найти элемент, который находится перед N-ым с конца. Само удаление происходит за счет изменения связи. Чтобы удалить N-ый элемент, нужно в элементе N-1 удалить ссылку на N-ый элемент и поставить ссылку на N+1 элемент.</p>
  <p>А если этот N-ый элемент является головой списка и никаких элементов перед ним нет? Можно отдельно обработать этот corner case, сделать в коде дополнительный if, но гораздо красивее будет если реализовать это с помощью паттерна Dummy node.</p>
  <p>Если в вашем языке программирования нет Garbage Collector (например, в языке Си), нужно почистить память для удаленной вершины и для dummy node, так как он больше не нужен.</p>

  <details>
    <summary>Решение 1 (в два прохода)</summary>
<pre>
class ListNode {
  constructor(val, next) {
    this.val = val;
    this.next = next;
  }
}

let list4 = new ListNode(4, null);
let list3 = new ListNode(3, list4);
let list2 = new ListNode(2, list3);
let list = new ListNode(1, list2);

function removeNode(head, n) {
  // добавим фейковый узел перед головой списка
  let dummyNode = new ListNode(0, head);

  // находим длину списка с учетом dummyNode
  let len = 0;
  let curr = dummyNode;
  while(curr) {
    curr = curr.next;
    len++;
  }

  // проверим n
  if (n &lt; 1 || n > len - 1) {
    return 0;
  }

  // доходим до (n-1)-ой вершины с конца
  curr = dummyNode;
  for(let i = 0; i &lt; len - n - 1; i++) {
    curr = curr.next;
  }

  // удаляем вершину
  curr.next = curr.next.next;

  return dummyNode.next;
}

console.log(removeNode(list, 2));
</pre>
  </details>

  <p>В первом решении мы сделали 2 прохода по списку. В первом проходе мы нашли длину. Во втором проходе мы дошли до нужной вершины и сделали само удаление.</p>
  <p>Сложность по времени O(N)</p>
  <p>Сложность по памяти O(1)</p>

  <h4>Решение 2</h4>
  <p>Во втором решении будет один проход, но асимптотика остается такой же. Определять длину списка не будем, поэтому первый проход нам не нужен.</p>
  <p>Добавим два указателя slow и fast. Сначала они указывают на dummyNode, то есть на голову списка. Потом двигаем fast на n+1 узлов вперед, так что slow будет указывать на (n-1)-ый узел от указателя fast. Далее двигаем fast за конец списка. Указатель slow будет показывать на (n-1)-ый узел с конца списка. Совершаем удаление n-ой вершины с конца и возвращаем новый список</p>

  <details>
    <summary>Решение 2 (в один проход)</summary>
<pre>
class ListNode {
  constructor(val, next) {
    this.val = val;
    this.next = next;
  }
}

let list4 = new ListNode(4, null);
let list3 = new ListNode(3, list4);
let list2 = new ListNode(2, list3);
let list = new ListNode(1, list2);

function removeNode(head, n) {
  // добавим фейковый узел перед головой списка
  let dummyNode = new ListNode(0, head);

  // добавим два указателя
  let slow = dummyNode;
  let fast = dummyNode;

  // делаем расстояние n+1 между slow и fast
  for (let i = 0; i &lt; n + 1; i++) {
    fast = fast.next;
  }

  // двигаем указатели, пока fast не выйдет за пределы списка
  while (fast) {
    slow = slow.next;
    fast = fast.next;
  }

  // удаляем вершину
  slow.next = slow.next.next;

  return dummyNode.next;
}

console.log(removeNode(list, 2));
</pre>
  </details>
</article>


<!-- 2. Объединить два связных списка в возрастающем порядке -->
<article class="article">
  <div class="anchor" id="linkedlist2"></div>
  <h3>2. Объединить два связных списка в возрастающем порядке</h3>

  <p>Даны два связных списка, которые отсортированы в возрастающем порядке. Вернуть новый список, который содержит все элементы из двух списков и отсортирован в возрастающем порядке.</p>
  <p>Здесь отлично подходит паттерн dummy node потому что мы не знаем какая из вершин в первом или во втором списке должна быть первой в ответе. И когда мы не знаем куда крепить ответ, отлично подходит dummy node паттерн. Мы заводим фейковую вершину и к ней будем крепить наш результат. Благодаря этому паттерну исчезают множество if в ваших решениях.</p>

  <p>Пример</p>
  <code>Первый список {1,2,4}, Второй список {1,3,4}</code>
  <code>Output: {1,1,2,3,4,4}</code>

  <details>
    <summary>Решение</summary>
<pre>
class ListNode {
  constructor(val=0, next=null) {
    this.val = val;
    this.next = next;
  }
}

let list13 = new ListNode(4, null);
let list12 = new ListNode(2, list13);
let list11 = new ListNode(1, list12);

let list23 = new ListNode(4, null);
let list22 = new ListNode(3, list23);
let list21 = new ListNode(1, list22);

function getVal(node) {
  if (!node) {
    return Infinity;
  }
  return node.val;
}

function mergeLists(list1, list2) {
  // добавим фейковый узел перед головой списка
  let dummyNode = new ListNode();

  // запишем в ответ фейковый узел
  let curr = dummyNode;

  // пока есть узлы хоть в одном списке
  while (list1 || list2) {
    if (getVal(list1) &lt; getVal(list2)) {
      curr.next = list1;
      list1 = list1.next;
    } else {
      curr.next = list2;
      list2 = list2.next;
    }
    curr = curr.next;
  }

  return dummyNode.next;
}

console.log(mergeLists(list11, list21));
</pre>
  </details>
</article>


<!-- Стек, очередь -->
<article class="article">
  <div class="anchor" id="stack"></div>
  <h3>Стек, очередь</h3>
</article>


<!-- Сортировки -->
<article class="article">
  <div class="anchor" id="sort"></div>
  <h3>Сортировки</h3>

  <ol>
    <li>
      <h4>Квадратичные</h4>
      <p>Сложность во времени O(n<sup>2</sup>)</p>
      <p>Сложность по памяти O(1)</p>
    </li>
    <li>
      <h4>Логарифмические</h4>
      <p>Сложность по времени O(nlogn)</p>
      <p>Сложность по памяти O(logn)</p>
    </li>
    <li>
      <h4>Сортировка подсчетом</h4>
      <p>Сложность по времени O(n)</p>
      <p>Сложность по памяти O(n)</p>
      <p>Применяют только при небольшом количестве уникальных элементов</p>
    </li>
  </ol>
</article>

