<h1>Тестовая задача с Яндекс.Контест на Weekend Offer 2024</h1>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>
  <p><a href="#links">links</a></p>
  <p><a href="#b">B. Сборочная линия</a></p>
</article>


<!-- links -->
<article class="article">
  <div class="anchor" id="b"></div>
  <h2>links</h2>

  <p><a href="https://habr.com/ru/articles/435084/">https://habr.com/ru/articles/435084/</a> Как работать с async/await в циклах JavaScript</p>
</article>


<!-- B. Сборочная линия -->
<article class="article">
  <div class="anchor" id="b"></div>
  <h2>B. Сборочная линия</h2>

  <p>Ограничение времени	10 секунд</p>
  <p>Ограничение памяти	1024.0 Мб</p>
  <p>Ввод	input.json</p>
  <p>Вывод	output.json</p>
  <p>Вы устроились на продвинутый сборочный цех айти-разнорабочим, чтобы стать помощником главного инженера.</p>
  <p>Задача цеха — автоматизированно выполнять предоставленные клиентами заказы по сборке.</p>
  <p>В цеху есть N линий сборки, работающих одновременно. Каждая линия сборки работает беспрерывно до тех пор, пока есть актуальные задачи на сегодня. Задачи по сборке цех принимает каждый день, но все задачи поступившие во время рабочего дня, откладываются на следующий. У задач может быть приоритетность, она учитывается при распределении задач на линиях сборки, задача с самым большим приоритетом — идет первой в работу (если есть 2 задачи с одинаковым приоритетом, будет выполнена сначала первая добавленная).</p>
  <p>Сейчас распределение заказов между линиями сборки выполняет планировщица Зинаида, непревзойденный мастер, но она скоро выходит на пенсию. Ваш новый начальник хочет чтобы завод продолжил работать также оптимально и понял, что это отличный момент для автоматизации. Звучит как идеальная задача для новичка. Вам поручили сделать новую программу для управления сборочными линиями, которая также будет ежедневно генерировать список отчетов о проделанной работе для каждой линии сборки.</p>

  <h4>Формат ввода</h4>
  <p>Необходимо реализовать класс AssemblyLineScheduler. Конструктор получает n (1 ≤ n ≤ 1024) — количество сборочных линий.</p>
  <p>Заказы добавляются методом appendJob. В рамках одного теста может быть не более 10^5 вызовов этого метода.</p>
  <p>У заказа есть уникальный строковый идентификатор id (1 ≤ id.length ≤ 10), приоритет priority (1 ≤ priority ≤ 10^9) и метод execute, запускающий его исполнение. Этот метод возвращает promise, который который будет resolved или rejected через время t мс (1 ≤ t ≤ 1024). Resolved, если контроль качества пройден и rejected в противном случае.</p>
  <p>В начале каждого дня вызывается метод start. Он должен исполнить пул заказов предыдущего дня и вернуть статистику использования каждой линии - сколько времени линия была загружена (в мс), какие задачи исполнила, сколько из них прошли контроль качества и сколько не прошли. В рамках одного теста метод start будет вызван p раз (1 ≤ p ≤ 10).</p>

  <details>
    <summary>Код условия</summary>
<pre>/**
* @typedef Job
* @property {string} id Уникальный идентификатор задачи, 1 ≤ id.length ≤ 10.
* @property {number} priority Приоритет задачи, 1 ≤ priority ≤ 10^9. Чем выше число, тем выше приоритет.
* @property {() => Promise<undefined>} execute Функция, выполняющая задание.
* Может быть resolved или rejected через длительное время.
*/

/**
* @typedef JobReport
* @property {number} qcPassed Общее количество выполненных успешно задач.
* @property {number} qcFailed Общее количество невыполненных задач.
* @property {string[]} jobIds Идентификаторы взятых в работу заказов.
* @property {number} timeSpent Количество проведённых в работе миллисекунд.
*/

class AssemblyLineScheduler {
  /**
  * @param {number} n Число сборочных линий, 1 ≤ n ≤ 1024
  */
  constructor(n) {}

  /**
  * Добавляет задачу в пул задач следующего дня.
  * В рамках одного теста может быть не более 10^5 вызовов этого метода.
  * @param {Job} job
  */
  appendJob(job) {}

  /**
  * Запускает обработку задач из пула и выдаёт список отчётов.
  * В рамках одного теста может быть не более 10 вызовов этого метода.
  * @returns {Promise<JobReport[]>}
  */
  start() {}
}

module.exports = { AssemblyLineScheduler };</pre>
  </details>

  <h4>Формат вывода</h4>
  <p>В результате решения могут быть обозначены следующие вердикты:</p>
  <ul>
    <li>OK — верный ответ.</li>
    <li>WrongAnswer (WA) — неправильный ответ.</li>
    <li>TimeLimitExceeded (TL) — превышено максимальное время выполнения проверки задачи.</li>
    <li>MemoryLimitExceeded (ML) — превышено ограничение на оперативную память.</li>
    <li>RuntimeError (RE) — программа завершила работу с ненулевым кодом возврата или тип возвращаемых данных не соответствует ожидаемому (проверьте, что результат start соответствует сигнатуре в jsdoc).</li>
    <li>Crash — запуск программы завершился ошибкой.</li>
  </ul>

  <h4>Пример</h4>

  <details>
    <summary>Ввод</summary>
<pre>{
  "linesCount": 3,
  "jobsBatches": [
    [
      {
        "id": "1",
        "priority": 344327634,
        "time": 69,
        "resolve": false,
        "async": false
      },
      {
        "id": "2",
        "priority": 439182113,
        "time": 68,
        "resolve": false,
        "async": false
      },
      {
        "id": "3",
        "priority": 267746535,
        "time": 83,
        "resolve": true,
        "async": false
      },
      {
        "id": "4",
        "priority": 412201989,
        "time": 61,
        "resolve": true,
        "async": false
      },
      {
        "id": "5",
        "priority": 211178799,
        "time": 94,
        "resolve": true,
        "async": false
      }
    ]
  ]
}</pre>
  </details>

  <details>
    <summary>Вывод</summary>
<pre>[
  [
    [0,1,["1"],69],
    [2,0,["4","3"],144],
    [1,1,["2","5"],162]
  ]
]</pre>
  </details>

  <h4>Примечания</h4>
  <p>Для измерения времени используйте Date.now() — в тестах будет использована библиотека @sinonjs/fake-timers, которая обеспечит измерение времени без погрешности. Версия Node.js, используемая при запуске кода, — 20.10.0.</p>

  <details>
    <summary>Примерный код теста:</summary>
<pre>const { AssemblyLineScheduler } = require('./solution');

(async () => {
  const generateJob = () =>
    function () {
      return new Promise((resolve, reject) => {
        setTimeout(() => {
          Math.random() &gt; 0.8 ? resolve() : reject();
        }, 1 + Math.floor(Math.random() * 100));
      });
    };

  const scheduler = new AssemblyLineScheduler(3);
  const reports = [];
  for (let day = 0; day &lt; 2; day += 1) {
    for (let i = 0; i &lt; 10; i += 1) {
      // это лишь примерный код, задачи могут также быть добавлены прямо во время работы (в процессе исполнения start асинхронно)
      scheduler.appendJob({
        id: String(i),
        priority: 10,
        execute: generateJob(),
      });

    }

    reports.push(await scheduler.start());
  }

  console.log(JSON.stringify(reports, null, 4));
})();</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Разобьем задачу на шаги</p>
    <ol>
      <li>
        <p>Для решения нужно написать class AssemblyLineScheduler и экспортировать его из модуля</p>
<pre>class AssemblyLineScheduler {}
module.exports = { AssemblyLineScheduler };</pre>
      </li>
      <li>
        <p>В классе нужно реализовать три метода</p>
        <ul>
          <li>constructor() {}</li>
          <li>appendJob() {}</li>
          <li>start() {}</li>
        </ul>
<pre>class AssemblyLineScheduler {}
  constructor() {}
  appendJob() {}
  start() {}
module.exports = { AssemblyLineScheduler };</pre>
      </li>
      <li>
        <p>Метод constructor() принимает один параметр n (число линий сборки) и возвращает (неявно) объект (экземпляр класса) с двумя свойствами - n (число линий сборки), jobs (пустой массив задач).</p>
<pre>constructor(n) {
  this.n = n;
  this.jobs = [];
}</pre>
      </li>
      <li>
        <p>Метод appendJob() принимает один параметр job (задача), это объект, содержащий</p>
        <ol>
          <li>поле id (строка с номером задачи)</li>
          <li>поле priority (целое число, приоритет задачи). Чем выше тем важнее</li>
          <li>метод execute(). Не принимает параметры, возвращает Promise в состоянии pending, который перейдет в состояние fulfilled или rejected через случайное количество миллисекунд</li>
        </ol>
        <p>Метод appendJob() добавляет задачу в массив задач.</p>
<pre>appendJob(job) {
  this.jobs.push(job);
}</pre>
      </li>
      <li>
        <p>Метод start() должен распределить все задачи по линиям сборки и когда все задачи выполнятся вернуть статистику использования каждой линии. Это массив, в котором содержится n массивов со статистикой о работе на каждой сборочной линии. Каждый из n массивов содержит четыре элемента</p>
        <ol>
          <li>Сколько задач прошли контроль качества</li>
          <li>Сколько задач не прошли контроль качества</li>
          <li>массив с id номерами выполненных задач</li>
          <li>время выполнения работ на этой линии</li>
        </ol>
      </li>
      <li>
        <p>Обнулим массив со статистикой использования каждой линии</p>
        <code>this.lines = [];</code>
      </li>
      <li>
        <p>Отсортируем задачи по приоритету от меньшего приоритета к большему, чтобы можно было доставать задачи из конца массива. Тем самым будет уменьшаться массив задач.</p>
<pre>this.jobs.sort((a,b) => a.priority - b.priority);</pre>
      </li>
      <li>
        <p>В массив со статистикой использования каждой линии запишем начальный результат, до выполнения задач</p>
<pre>for (let i = 0; i &lt; this.n; i++) {
  this.lines[i] = [0,0,[],0];
}</pre>
      </li>
      <li>
        <p>Напишем асинхронную (async) функцию runTask(), которая будет принимать одну задачу и отчет по одной линии. Функция runTask() будет ждать (await) выполнения задачи и результат добавлять в отчет по линии. Если выполнится успешно (fulfilled), то увеличим счетчик успешно выполненных задач. Если выполнится неуспешно (rejected), то увеличим счетчик неуспешно выполненных задач. При любом результате (finally) добавим номер задачи в массив с номерами задач. А также замерим время выполнения задачи и прибавим к времени выполнения задач на линии.</p>
<pre>async function runTask(task, line) {
  let time1 = Date.now();
  await task.execute().then(() => {
    // fulfilled, число выполненных задач
    line[0]++;
  }).catch(() => {
    // rejected, число невыполненных задач
    line[1]++;
  }).finally(() => {
    // id задач
    line[2].push(task['id']);
    let time2 = Date.now();
    let time = time2 - time1;
    // время выполнения всех задач
    line[3] += time;
  })
}</pre>
      <li>
        <p>Напишем асинхронную (async) стрелочную (чтобы не потерять контекст this) функцию runJobs(), которая ничего не принимает.</p>
        <p>Функция runJobs() должна вернуть промис (Promise.allSettled()), который выполнится, когда все задачи на всех линиях будут выполнены.</p> 
        <p>Она распределит задачи из массива задач по линиям сборки, а когда задача на линии завершится, то будет добавлять туда следующую задачу.</p>
        <p>Распределение задач по линиям. Для массива со статистикой выполним метод map, который для каждой линии выполнит асинхронную callback-функцию, которая будет ждать выполнение всех задач на линии. Метод map вернет новый массив с промисами по каждой линии.</p> 
        <p>Напишем реализацию callback-функции. Если (if) массив задач (this.jobs) не пустой, брать (this.jobs.push()) из него задачу, передавать вместе с отчетом по линии в функцию runTask() и ждать ее выполнения. Когда функция runTask() выполнит первую задачу, в цикле (whie) пока массив задач (this.jobs) не пустой, брать (this.jobs.push()) следующую задачу, передавать ее в функцию runTask() и ждать ее выполнения.</p>
        <p>Функция runJobs() вернет Promise.allSettled в состоянии pending, который принимает массив промисов по каждой линии сборки, который выполнится, когда выполнятся все асинхронные задачи на каждой линии сборки.</p>
<pre>const runJobs = async () => {
  return Promise.allSettled(this.lines.map(async (line) => {
    if (this.jobs.length) {
      const task = this.jobs.pop();
      await runTask(task, line).then(async () => {
        while (this.jobs.length) {
          const task = this.jobs.pop();
          await runTask(task, line);
        }
      });
    }
  }))
}</pre>
      </li>
      <li>
        <p>У меня программа не отрабатывала как надо. Первая линия забирала себе первую задачу, после завершения забирала следующую, и так весь массив задач делала толко одна линия. Я наше статью на хабре и воспользовался ей, чтобы все линии могли забрать себе по одной задаче, а потом уже добавлять новые асинхронно.</p>
        <h4>1. Не дожидаться результата выполнения</h4>
        <p>Мы можем определить анонимную функцию как асинхронную:</p>
<pre>async function processArray(array) {
  array.forEach(async (item) => {
    await func(item);
  })
  console.log('Done!');
}</pre>
        <p>Но forEach не будет дожидаться выполнения завершения задачи. forEach — синхронная операция. Она просто запустит задачи и пойдет дальше.</p>
      </li>
      <li>
        <p>Мы должны сделать метод start() асинхронный (async), чтобы запустить функцию runJobs() и подождать (await) ее выполнения. Она выполнится когда выполнятся все промисы в массиве, переданном в метод Promise.allSettled. При этом промис перейдет из состояния pending в состояние fulfilled.</p>
      </li>
      <li>После того как отработают все задачи из массива задач, метод старт перейдет к строчке
        <code>return this.lines;</code>
        <p>И вернет массив со статистикой использования каждой линии</p>
      </li>

<pre>async start() {
  this.lines = [];
  this.jobs.sort((a,b) => a.priority - b.priority);

  for (let i = 0; i &lt; this.n; i++) {
    this.lines[i] = [0,0,[],0];
  }

  async function runTask(task, line) {
    let time1 = Date.now();
    await task.execute().then(() => {
      line[0]++;
    }).catch(() => {
      line[1]++;
    }).finally(() => {
      line[2].push(task['id']);
      let time2 = Date.now();
      let time = time2 - time1;
      line[3] += time;
    })
  }

  const runJobs = async () => {
    return Promise.allSettled(this.lines.map(async (line) => {
      if (this.jobs.length) {
        const task = this.jobs.pop();
        await runTask(task, line).then(async () => {
          while (this.jobs.length) {
            const task = this.jobs.pop();
            await runTask(task, line);
          }
        });
      }
    }))
  }

  await runJobs();
  
  return this.lines;
}</pre>

  </details>
</article>










