<h1>Алгоритмы</h1>

<!-- Заголовок -->
<div class="article">
  <div class="anchor" id="content"></div>
  <h2>Содержание</h2>
</div>

<!-- Содержание -->
<div class="article article__content">

  <div>
    <p><a href="#about">О алгоритмах</a></p>
    <p><a href="#links">Links</a></p>
    <p><a href="#props">Свойства алгоритмов</a></p>
    <p><a href="#bigo">Сложность</a></p>
    <p><a href="#sort">Сортировка</a></p>
    <p><a href="#search">Поиск</a></p>
    </div>

</div>


<!-- about -->
<article class="article">
  <div class="anchor" id="about"></div>
  <h2>О алгоритмах</h2>
</article>


<!-- links -->
<article class="article">
  <div class="anchor" id="links"></div>
  <h2>Links</h2>

  <p><a href="https://teach-in.ru/course/algorithms">teach-in.ru/course/algorithms</a> Лекции преподавателей МГУ</p>
  <p><a href="hhttps://education.yandex.ru/handbook/algorithms">education.yandex.ru/handbook/algorithms</a> Яндеск образование. Основы алгоритмов</p>
  <p><a href="https://education.yandex.ru/journal/osnovnye-vidy-sortirovok-i-primery-ikh-realizatsii">education.yandex.ru</a> Основные виды сортировок и примеры их реализации (Илья Шишков 2020-01-16)</p>
  <p><a href="https://education.yandex.ru/knowledge/algoritmy">education.yandex.ru</a> Алгоритмы (Илья Волков 2020-04-24)</p>
  <p><a href="https://bimlibik.github.io/posts/complexity-of-algorithms/">bimlibik.github.io</a> Сложность алгоритмов. Big O. Основы. (2020-10-29)</p>
  <p><a href="https://thecode.media/sort/">thecode.media</a> Зачем нужна сортировка в программировании (2021-06-30)</p>
  <p><a href="https://dzen.ru/a/ZEpeLTjDQ28UUYOp">dzen.ru</a> Алгоритмы программирования: применение и сложность O(n) (2023-04-27)</p>

  <h3>Статьи на habr</h3>
  <p><a href="https://habr.com/ru/articles/204600/">Пузырьковая сортировка и все-все-все</a> (velemak 2013-12-03)</p>

  <h3>learn.coderslang.com</h3>
  <p><a href="https://learn.coderslang.com/ru/0036-javascript-bubble-sort/">learn.coderslang.com/ru/0036-javascript-bubble-sort</a> Сортировка пузырьком на JavaScript (2021.02.20)</p>
  <p><a href="https://learn.coderslang.com/ru/0037-javascript-optimized-bubble-sort.-coctail-sort/">learn.coderslang.com/ru/0037-javascript-optimized-bubble-sort.-coctail-sort</a> Улучшенная сортировка пузырьком на JavaScript. Шейкерная сортировка (2021.02.21)</p>
</article>


<!-- Свойства алгоритмов -->
<article class="article">
  <div class="anchor" id="props"></div>
  <h2>Свойства алгоритмов</h2>

  <ol>
    <li><strong>Дискретность</strong> – алгоритм представляется как последовательность ин-
струкций исполнителя. Каждая инструкция выполняется только после
того, как закончилось выполнение предыдущей команды.</li>
    <li><strong>Конечность (результативность, финитность)</strong> – алгоритм должен за-
канчиваться после выполнения конечного числа инструкций.</li>
    <li><strong>Детерминированность</strong> – каждый шаг алгоритма должен быть одно-
значно определен – записан на формальном языке исполнителя. Де-
терминированность обеспечивает совпадение результатов, получаемых
при многократном выполнении алгоритма, на одном и том же наборе
входных данных.</li>
    <li><strong>Массовость</strong> – алгоритм решения задачи должен быть применим для
некоторого класса задач, различающихся лишь значениями входных
данных.</li>
  </ol>
</article>


<!-- bigo -->
<article class="article">
  <div class="anchor" id="bigo"></div>
  <h2>Сложность</h2>

  <ol>
    <li>Сложность по времени</li>
    <li>Сложность по памяти</li>
  </ol>

  <h3>Сложность по времени</h3>
  <p>Сложность по времени это максимальное количество шагов, требующихся алгоритму для завершения ппо мере увеличения n.</p>
  <ol>
    <li>
      <h3>Постоянное время O(1)</h3>
      <p>Наиболее эффективный порядок величины. Алгоритм выполняется за постоянное время, когда ему требуется одно и то же количество шагов вне зависимости от объема задачи</p>
      <p>Например, алгоритм выбора первого элемента из набора данных. Независимо от размера n вы выбираете первый элемент за один шаг. Время алгоритма не меняется с увеличением набора данных.</p>
    </li>
    <li>
      <h3>Логарифмическое время O(log n)</h3>
      <p>Логарифмическое время - это вторая по эффективности временная сложность. Время выполнения алгоритма растет пропорционально логарифму размера входных даных.</p>
      <p>Например, двоичный поиск, который может не учитывать множество значений в каждом цикле.По мере увеличения набора данных количество шагов алгоритма растет достаточно медленно.</p>
    </li>
    <li>
      <h3>Линейное время O(n)</h3>
      <p>Такой алгоритм растет пропорционально росту размера задачи.</p>
      <p>Например, надо в одном цикле перебрать все входные данные. В линейном алгоритме по мере роста n количество шагов алгоритма увеличиватся на то же количество n.</p>
    </li>
    <li>
      <h3>Линейно-логарифмическое время O(n log n)</h3>
      <p>Растет как умножение линейных и логарифмических сложностей. Операция O(log n) вычисляется n раз. Линейно-логарифмические алгоритмы разделяют набор данных на меньшие части и каждую из них обрабатывают по отдельности.</p>
      <p>Например, большинство наиболее эффективных алгоритмов сортировки, такие как сортировка слиянием, являются линейно-логарифмическими.</p>
    </li>
    <li>
      <h3>Квадратичное время O(n**2)</h3>
      <p>Алгоритм выполняется за квадратичное время, когда его производительность прямо пропорциональна размеру задачи в квадрате.</p>
      <p>Например, вложенный цикл будет иметь квадратичную сложность, когда данные перебираются в цикле и для каждого элемента опять в цикле перебираются данные. Простые алгоритмы сортировки, такие как пузырьковая и сортировка вставками выполняются за квадратичное время.</p>
    </li>
    <li>
      <h3>Кубическое время O(n**3)</h3>
      <p>Алгоритм выполняется за кубическое время, когда производительность прямо пропорциональна размеру задачи в кубе.</p>
    </li>
    <li>
      <h3>Экспоненциальное время O(c**n)</h3>
      <p>Наихудшая сложность алгоритма. Содержит константу, увеличенную до размеров задачи. Количество шагов алгоритма растет с невероятной скоростью.</p>
      <p>Например, для угадывания пароля из 8 десятичных цифр придется выполнить 100 миллионов шагов. Отгадывание пароля это пример алгоритма полного перебора, проверяющего все возможные варианты. Алгоритмы полного перебора неэффективны.</p>
    </li>
  </ol>
  <p>Сложность алгоритма зависит от входных данных. Поэтому необходимо учитывать сложность в лучшем, худшем и среднем случае. Например, в лучшем случае, во время поиска, мы можем найти элемент в первом элементе списка. В худшем случае элемента может не быть вообще и алгоритм полностью выполнит свою работу только перебрав все данные.</p>

  <h3>Сложность по памяти</h3>
  <p>У компьютера есть ограниченные ресурсы, такие как память, поэтому важно учитывать не только временную сложность, но и потребление ресурсов. Сложность по памяти это объем памяти необходимый алгоритму. Чем меньше памяти требуется алгоритму тем лучше.</p>

  <h3>Оптимизация алгоритма</h3>
  <p>Важно понимать порядок величины чтобы оптимизировать алгоритм. Нужно изменять порядок величины.Например, при O(n**2) с двумя циклами вместо оптимизации процессов внутри циклов, постарайтесь избавиться от одного цикла.</p>
</article>


<!-- sort -->
<article class="article">
  <div class="anchor" id="sort"></div>
  <h2>Сортировка</h2>

  <ol>
    <li>Сортировка пузырьком (Bubble Sort)</li>
    <li>Сортировка перемешиванием (шейкерная сортировка)</li>
    <li>Сортировка расчёской</li>
    <li>Сортировка вставками (Insertion Sort)</li>
    <li>Сортировка выбором</li>
    <li>Сортировка Шелла (Shell Sort)</li>
    <li>Сортировка подсчетом (Counting Sort)</li>
    <li>Сортировка слиянием (Merge Sort)</li>
    <li>Пирамидальная сортировка</li>
    <li>Быстрая сортировка Хоара (Quick Sort)</li>
    <li>Гномья сортировка (Gnome Sort)</li>
  </ol>

  <h3>1. Сортировка пузырьком (Bubble Sort)</h3>
  <p>Сортировка пузырьком — один из самых известных алгоритмов сортировки. Здесь нужно последовательно сравнивать значения соседних элементов и менять числа местами, если предыдущее оказывается больше последующего. Таким образом элементы с большими значениями оказываются в конце списка, а с меньшими остаются в начале.</p>
  <p>Когда дойдем до конца массива, то самый последний элемент будет гарантированно на своем месте. Самый большой пузырек всплыл на поверхность воды. Мы повторим процедуру еще раз, но уже до предпоследнего элемента. После второй итерации, на своих позициях будет уже 2 последних элемента. Будем повторять алгоритм до тех пор, пока у нас не останется только первый элемент.</p>
<pre>function bubbleSort(arr) {
  for (let i = 0; i &lt; arr.length; i++) {
    for (let j = 0; j &lt; arr.length - i; j++) {
      if (arr[j] &gt; arr[j + 1]) {
        let tmp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = tmp;
      }
    }
  }
  return arr;
}</pre>
  <p>Этот алгоритм считается учебным и почти не применяется на практике из-за низкой эффективности: он медленно работает на тестах, в которых маленькие элементы (их называют «черепахами») стоят в конце массива. Однако на нём основаны многие другие методы, например, шейкерная сортировка и сортировка расчёской.</p>

  <h3>Улучшенная сортировка пузырьком</h3>
  <p>Алгоритм пузырьковой сортировки никак не следит за текущим состоянием массива. Даже если на вход мы отправим уже отсортированный массив, нам нужно будет столько же итераций цикла, как и для неотсортированного массива, чтобы получить результат. Быстродействие пузырьковой сортировки в JavaScript можно улучшить, если добавить флаг (логическую переменную) который будет следить за тем был ли хотя бы один обмен на текущей итерации. Если нет, то массив отсортирован и задача выполнена.</p>
<pre>function bubbleSort(arr) {
  let isSwap = false;
  for (let i = 0; i &lt; arr.length; i++) {
    for (let j = 0; j &lt; arr.length - i; j++) {
      if (arr[j] &gt; arr[j + 1]) {
        let temp = arr[j + 1];
        arr[j + 1] = arr[j];
        arr[j] = temp;
        isSwap = true;
      }
    }
    if (!isSwap) {
      return arr;
    }
  }
  return arr;
}</pre>
  <p>Если отсортировать массив в котором все элементы уже расположены по возрастанию, то нам нужна будет только одна итерация внешнего цикла. Поэтому в лучшем случае мы получим сложность O(n).</p>

  <h3>2. Сортировка перемешиванием (шейкерная сортировка)</h3>
  <p>Шейкерная сортировка отличается от пузырьковой тем, что она двунаправленная: алгоритм перемещается не строго слева направо, а сначала слева направо, затем справа налево.</p>
  <p>Начинаем мы точно так же, как и в пузырьковой сортировке, и “выдавливаем наверх” максимальный элемент. После этого, разворачиваемся и “толкаем вниз” минимальный из оставшийся элементов.</p>
  <p>Оказавшись в начале массива, на своих местах будет уже 2 элемента - первый и последний. Остановимся когда дойдем до середины массива. Таким образом сделаем в 2 раза меньше итераций внешнего цикла. За счет этого скорость шейкерной сортировки будет немного выше, чем у обычного пузырька.</p>
  <p>Начнем с небольшого рефакторинга и вынесем функцию обмена наружу. Назовем ее swap</p>
<pre>function swap(arr, i, j) {
  let temp = arr[j];
  arr[j] = arr[i];
  arr[i] = temp;
}

function cocktailSort(arr) {
  let left = 0;
  let right = arr.length - 1;
  let isSwap = false;
  while(left &lt; right) {
    for (let i = left; i &lt; right; i++) {
      if (arr[i] &gt; arr[i + 1]) {
        swap(arr, i, i + 1);
        isSwap = true;
      }
    }
    if (!isSwap) {
      return arr;
    }
    isSwap = false;
    right--;
    for (let i = right; i &gt; left; i--) {
      if (arr[i] &lt; arr[i - 1]) {
        swap(arr, i, i - 1);
        isSwap = true;
      }
    }
    if (!isSwap) {
      return arr;
    }
    isSwap = false;
    left++;
  }
  return arr;
}</pre>

  <h3>3. Сортировка расчёской</h3>
  <p>Сортировка расчёской — улучшение сортировки пузырьком. Её идея состоит в том, чтобы «устранить» элементы с небольшими значения в конце массива, которые замедляют работу алгоритма. Если при пузырьковой и шейкерной сортировках при переборе массива сравниваются соседние элементы, то при «расчёсывании» сначала берётся достаточно большое расстояние между сравниваемыми значениями, а потом оно сужается вплоть до минимального.</p>
  <p>Первоначальный разрыв нужно выбирать не случайным образом, а с учётом специальной величины — фактора уменьшения, оптимальное значение которого равно 1,247. Сначала расстояние между элементами будет равняться размеру массива, поделённому на 1,247; на каждом последующем шаге расстояние будет снова делиться на фактор уменьшения — и так до окончания работы алгоритма.</p>
<pre>// исходный массив
  var arr = [3,14,1,7,9,8,11,6,4,2]

  // получаем длину массива
  const l = arr.length;
  // оптимальное число для вычисления шага сравнения
  const factor = 1.247;
  // получаем точный шаг сравнения
  let gapFactor = l / factor;
  // пока шаг больше единицы
  while (gapFactor &gt; 1) {
      // округляем шаг до целого
      const gap = Math.round(gapFactor);
      // и организуем цикл как в пузырьковой сортировке
      for (let i = 0, j = gap; j &lt; l; i++, j++) {
          // если сначала идёт большое число
          if (arr[i] &gt; arr[j]) {
              // меняем их местами
              [arr[i], arr[j]] = [arr[j], arr[i]];
          }
          // выводим текущее состояние массива в консоль
          // это необязательный шаг, он здесь для наглядности
          console.log(arr);
      }
      // в конце цикла рассчитываем новый шаг
      gapFactor = gapFactor / factor;
  }</pre>
  <p>Расчёска лучше пузырьковой сортировки, потому что в ней намного меньше операций перестановки. Именно перестановка занимает основное время процессора. В самом худшем случае алгоритм сортировки расчёской будет работать так же, как и пузырьковая, а в среднем — алгоритм работает быстрее пузырьковой.</p>

  <h3>4. Сортировка вставками (Insertion Sort)</h3>
   <p>При сортировке вставками массив постепенно перебирается слева направо. При этом каждый последующий элемент размещается так, чтобы он оказался между ближайшими элементами с минимальным и максимальным значением.</p>

  <h3>5. Сортировка выбором</h3>
  <p>Сначала нужно рассмотреть подмножество массива и найти в нём максимум (или минимум). Затем выбранное значение меняют местами со значением первого неотсортированного элемента. Этот шаг нужно повторять до тех пор, пока в массиве не закончатся неотсортированные подмассивы.</p>

  <h3>6. Сортировка Шелла (Shell Sort)</h3>

  <h3>7. Сортировка подсчетом (Counting Sort)</h3>

  <h3>8. Сортировка слиянием (Merge Sort)</h3>

  <h3>9. Пирамидальная сортировка</h3>

  <h3>10. Быстрая сортировка Хоара (Quick Sort)</h3>

  <h3>11. Гномья сортировка (Gnome Sort)</h3>


</article>


<!-- sort -->
<article class="article">
  <div class="anchor" id="sort"></div>
  <h2>Поиск</h2>

  <ol>
    <li>Линейный поиск</li>
    <li>Двоичный (бинарный) поиск</li>
  </ol>

  <h3>Линейный поиск</h3>
  <p>Линейный поиск числа перебирает каждый элемент в наборе данных и сравнивает его с целевым числом. Если находит совпадение то выдает ответ, что число найдено в списке. Если проходит все числа от первого до последнего и совпадения не будет, то выдает ответ что число отсутствует в списке.</p>
  <p>Временная сложность линейного поиска O(n). O(n) это худший случай, если элемент окажется последний в списке и придется просмотреть каждый элемент, чтобы найти его. В лучшем случае элемент окажется первым в списке и с сложность будет O(1). В среднем линейному поиску требуется n/2 шагов.</p>
  <p>Линейный поиск используют если данные не отсортированы. Если данные отсортированы то можно использовать двоичный поиск.</p>

  <h3>Двоичный (бинарный) поиск</h3>
  <p>Двоичный поиск работает только с отсортированными данными. Первый шаг это определить среднее число. Второй шаг это сравнить целевое число со средним числом. Если число совпало то алгоритм закончен, если нет то переходим на третий шаг. Третий шаг определить целевое число больше или меньше среднего числа. Отбросить ненужную половину чисел и искать в нужной.</p>
  <p>Временная сложность двоичного поиска O(log n). Это эффективнее чем линейный поиск. Линейный поиск среди миллиона элементов займет миллион шагов. Двоичный поиск среди миллиона элементов займет 20 шагов.</p>
  <p>Когда при двоичном поиске первый раз делим список пополам, то остается n/2 элементов, после второй итерации n/(2*2), после третьей n/(2**3) и т.д. Двоичный поиск при каждой итерации делит список пополам, а это значит, что основание логарифма, описывающего время выполнени поиска, равно 2. Тем не менее, в нотации "О большое" основание логарифма не имеет значение, потому что его можно изменить, умножив логарифм на константу.</p>
  <p>Если есть большой список, к которому требуется выполнить много поисковых запросов, то выгоднее отсортировать данные один раз, чтобы ускорить каждый поиск в будущем.</p>
  </article>