<h1>Алгоритмы</h1>

<!-- Заголовок -->
<div class="article">
  <div class="anchor" id="content"></div>
  <h2>Содержание</h2>
</div>

<!-- Содержание -->
<div class="article article__content">

  <ol>
    <li><a href="#links">Links</a></li>
    <li><a href="#props">Свойства алгоритмов</a></li>
    <li>
      <a href="#bigo">Сложность</a>
      <ol>
        <li><a href="#bigo-1">Константное время O(1)</a></li>
        <li><a href="#bigo-logn">Логарифмическое время O(log n)</a></li>
        <li><a href="#bigo-n">Линейное время O(n)</a></li>
        <li><a href="#bigo-nlogn">Линейно-логарифмическое время O(n log n)</a></li>
        <li><a href="#bigo-n2">Квадратичное время O(n**2)</a></li>
        <li><a href="#bigo-n3">Кубическое время O(n**3)</a></li>
        <li><a href="#bigo-cn">Экспоненциальное время O(c**n)</a></li>
        <li><a href="#bigo-f">Факториальное время O(!)</a></li>
      </ol>
    </li>
    <li><a href="#bigo-js">Сложность встроенных методов JavaScript</a></li>
    <li>
      <a href="#sort">Сортировка</a>
      <ol>
        <li><a href="#sort-bubble">Сортировка пузырьком (Bubble Sort)</a></li>
        <li><a href="#sort-cocktail">Сортировка перемешиванием (шейкерная сортировка) (Cocktail sort)</a></li>
        <li><a href="#sort-comb">Сортировка расчёской (Comb sort)</a></li>
        <li><a href="#sort-insertion">Сортировка вставками (Insertion Sort)</a></li>
        <li><a href="#sort-selection">Сортировка выбором (Selection sort)</a></li>
        <li><a href="#sort-shell">Сортировка Шелла (Shell Sort)</a></li>
        <li><a href="#sort-count">Сортировка подсчетом (Counting Sort)</a></li>
        <li><a href="#sort-merge">Сортировка слиянием (Merge Sort)</a></li>
        <li><a href="#sort-heap">Пирамидальная сортировка (сортировка кучей) (HeapSort)</a></li>
        <li><a href="#sort-quick">Быстрая сортировка Хоара (Quick Sort)</a></li>
        <li><a href="#sort-gnome">Гномья сортировка (Gnome Sort)</a></li>
      </ol>
    </li>
    <li>
      <a href="#search">Поиск</a>
      <ol>
        <li><a href="#search-1">Линейный поиск</a></li>
        <li><a href="#search-2">Двоичный (бинарный) поиск</a></li>
        <li><a href="#search-3">Поиск в глубину (Depth-First Search)</a></li>
        <li><a href="#search-4">Поиск в ширину (Breadth-First Search)</a></li>
        <li><a href="#search-5">Алгоритм Дейкстры</a></li>
      </ol>
    </li>
    <li><a href="#train">Тренировки по алгоритмам от Яндекс (Михаил Густокашин)</a></li>
  </ol>

</div>


<!-- links -->
<article class="article">
  <div class="anchor" id="links"></div>
  <h2>Links</h2>

  <p><a href="https://teach-in.ru/course/algorithms">teach-in.ru/course/algorithms</a> Лекции преподавателей МГУ</p>
  <p><a href="hhttps://education.yandex.ru/handbook/algorithms">education.yandex.ru/handbook/algorithms</a> Яндеск образование. Основы алгоритмов</p>
  <p><a href="https://education.yandex.ru/journal/osnovnye-vidy-sortirovok-i-primery-ikh-realizatsii">education.yandex.ru</a> Основные виды сортировок и примеры их реализации (Илья Шишков 2020-01-16)</p>
  <p><a href="https://education.yandex.ru/knowledge/algoritmy">education.yandex.ru</a> Алгоритмы (Илья Волков 2020-04-24)</p>
  <p><a href="https://bimlibik.github.io/posts/complexity-of-algorithms/">bimlibik.github.io</a> Сложность алгоритмов. Big O. Основы. (2020-10-29)</p>
  <p><a href="https://thecode.media/sort/">thecode.media</a> Зачем нужна сортировка в программировании (2021-06-30)</p>
  <p><a href="https://dzen.ru/a/ZEpeLTjDQ28UUYOp">dzen.ru</a> Алгоритмы программирования: применение и сложность O(n) (2023-04-27)</p>

  <h3>Статьи на habr</h3>
  <p><a href="https://habr.com/ru/articles/204600/">habr.com/ru/articles/204600</a> Пузырьковая сортировка и все-все-все (2013-12-03)</p>
  <p><a href="https://habr.com/ru/companies/simbirsoft/articles/769312/">habr.com/ru/companies/simbirsoft/articles/769312</a> 9 алгоритмов сортировки и поиска для JS, о которых вас спросят на собеседовании (2023-10-24)</p>
  <p><a href="https://habr.com/ru/articles/782608/">habr.com/ru/articles/782608</a> Сложность алгоритмов. Разбор Big O (2023-12-22)</p>

  <h3>learn.coderslang.com</h3>
  <p><a href="https://learn.coderslang.com/ru/0036-javascript-bubble-sort/">learn.coderslang.com/ru/0036-javascript-bubble-sort</a> Сортировка пузырьком на JavaScript (2021.02.20)</p>
  <p><a href="https://learn.coderslang.com/ru/0037-javascript-optimized-bubble-sort.-coctail-sort/">learn.coderslang.com/ru/0037-javascript-optimized-bubble-sort.-coctail-sort</a> Улучшенная сортировка пузырьком на JavaScript. Шейкерная сортировка (2021.02.21)</p>
</article>


<!-- Свойства алгоритмов -->
<article class="article">
  <div class="anchor" id="props"></div>
  <h2>Свойства алгоритмов</h2>

  <ol>
    <li><strong>Дискретность</strong> – алгоритм представляется как последовательность инструкций исполнителя. Каждая инструкция выполняется только после того, как закончилось выполнение предыдущей команды.</li>
    <li><strong>Конечность (результативность, финитность)</strong> – алгоритм должен заканчиваться после выполнения конечного числа инструкций.</li>
    <li><strong>Детерминированность</strong> – каждый шаг алгоритма должен быть однозначно определен – записан на формальном языке исполнителя. Детерминированность обеспечивает совпадение результатов, получаемых при многократном выполнении алгоритма, на одном и том же наборе входных данных.</li>
    <li><strong>Массовость</strong> – алгоритм решения задачи должен быть применим для некоторого класса задач, различающихся лишь значениями входных данных.</li>
  </ol>
</article>


<!-- bigo -->
<article class="article">
  <div class="anchor" id="bigo"></div>
  <h2>Сложность</h2>

  <p>Big O это асимптотическая сложность, которая описывает верхнюю границу (наихудший случай) сложности алгоритма при увеличении размера входных данных, или то, как рост размера входных данных влияет на количество операций.</p>
  <p>Big O не гарантирует, что алгоритм O(1) будет самым быстрым, но даёт понять, что скорость работы этого алгоритма не будет зависеть от входных данных.</p>

  <p>Big Theta (Θ): Big Theta также оценивает верхнюю и нижнюю границы временной сложности алгоритма, но описывает точную сложность, а не только наихудший случай, как Big O. Θ(f(n)) обозначает, что время выполнения алгоритма ограничено функцией f(n) как сверху, так и снизу.</p>

  <p>Big Omega (Ω): Big Omega оценивает нижнюю границу временной сложности алгоритма. Ω(f(n)) говорит о том, что алгоритм выполнится не быстрее, чем функция f(n).</p>
  <ol>
    <li>Сложность по времени</li>
    <li>Сложность по памяти</li>
  </ol>

  <h3>Сложность по времени</h3>
  <p>Сложность по времени это максимальное количество шагов, требующихся алгоритму для завершения ппо мере увеличения n.</p>

  <p>Сложность алгоритма зависит от входных данных. Поэтому необходимо учитывать сложность в лучшем, худшем и среднем случае. Например, в лучшем случае, во время поиска, мы можем найти элемент в первом элементе списка. В худшем случае элемента может не быть вообще и алгоритм полностью выполнит свою работу только перебрав все данные.</p>

  <h3>Сложность по памяти</h3>
  <p>У компьютера есть ограниченные ресурсы, такие как память, поэтому важно учитывать не только временную сложность, но и потребление ресурсов. Сложность по памяти это объем памяти необходимый алгоритму. Чем меньше памяти требуется алгоритму тем лучше.</p>

  <h3>Оптимизация алгоритма</h3>
  <p>Важно понимать порядок величины чтобы оптимизировать алгоритм. Нужно изменять порядок величины.Например, при O(n**2) с двумя циклами вместо оптимизации процессов внутри циклов, постарайтесь избавиться от одного цикла.</p>
</article>


<!-- 1. Константное время O(1) -->
<article class="article">
  <div class="anchor" id="bigo-1"></div>
  <h3>1. Константное время O(1)</h3>
  <p>Наиболее эффективный порядок величины. Алгоритм выполняется за постоянное время, когда ему требуется одно и то же количество шагов вне зависимости от объема задачи</p>
  <p>Например, алгоритм выбора первого элемента из набора данных. Независимо от размера n вы выбираете первый элемент за один шаг. Время алгоритма не меняется с увеличением набора данных.</p>
  <p>Время выполнения алгоритма не зависит от размера входных данных. Например, доступ к элементу массива по индексу.</p>
  <p>Это самый быстрый и эффективный вид временной сложности.</p>
  <p>Примеры алгоритмов с оценкой временной сложности O(1):</p>
  <ol>
    <li>Доступ к элементу в массиве по индексу. Например, если у вас есть массив с данными, вы можете мгновенно получить доступ к элементу массива, указав его индекс, независимо от размера массива.</li>
    <li>Вставка или удаление элемента в конец списка (очереди) фиксированной длины. В этом случае операция выполняется быстро и не зависит от количества элементов в списке.</li>
  </ol>
</article>


<!-- 2. Логарифмическое время O(log n) -->
<article class="article">
  <div class="anchor" id="bigo-logn"></div>
  <h3>2. Логарифмическое время O(log n)</h3>
  <p>Логарифмическое время - это вторая по эффективности временная сложность. Время выполнения алгоритма растет пропорционально логарифму размера входных даных.</p>
  <p>Время выполнения алгоритма растет медленно с увеличением размера входных данных. Например, бинарный поиск в отсортированном массиве.</p>
  <p>Бинарный поиск ищет значение в отсортированном массиве, разделяя его пополам на каждой итерации. Поиск начинается с середины массива. Если значение, которое мы ищем, больше среднего элемента, поиск продолжается в правой половине массива. Если оно меньше, то в левой. Таким образом, на каждой итерации мы уменьшаем область поиска примерно в два раза, что обеспечивает логарифмическую сложность O(log n).</p>
</article>


<!-- 3. Линейное время O(n) -->
<article class="article">
  <div class="anchor" id="bigo-n"></div>
  <h3>Линейное время O(n)</h3>
  <p>Время выполнения алгоритма пропорционально размеру входных данных. Например, просмотр всех элементов в массиве.</p>
  <p>Например функция findMax ищет максимальное значение в массиве arr.</p>
<pre>function findMax(arr) {
  let max = arr[0];
  for (let i = 1; i &lt; arr.length; i++) {
      if (arr[i] &gt; max) {
          max = arr[i];
      }
  }
  return max;
}</pre>
  <p>Алгоритм начинает с предположения, что первый элемент массива (arr[0]) является максимальным, а затем линейно (то есть по одному элементу) перебирает остальные элементы, сравнивая каждый с текущим максимальным. Сложность этого алгоритма O(n), так как время выполнения растет линейно с увеличением количества элементов в массиве arr.</p>
</article>


<!-- 4. Линейно-логарифмическое время O(n log n) -->
<article class="article">
  <div class="anchor" id="bigo-nlogn"></div>
  <h3>Линейно-логарифмическое время O(n log n)</h3>
  <p>Растет как умножение линейных и логарифмических сложностей. Операция O(log n) вычисляется n раз. Линейно-логарифмические алгоритмы разделяют набор данных на меньшие части и каждую из них обрабатывают по отдельности.</p>
  <p>Время выполнения алгоритма растет быстрее, чем линейно, но медленнее, чем квадратично. Например, сортировка слиянием (merge sort).</p>
</article>


<!-- 5. Квадратичное время O(n**2) -->
<article class="article">
  <div class="anchor" id="bigo-n2"></div>
  <h3>Квадратичное время O(n**2)</h3>
  <p>Алгоритм выполняется за квадратичное время, когда его производительность прямо пропорциональна размеру задачи в квадрате.</p>
  <p>Например, вложенный цикл будет иметь квадратичную сложность, когда данные перебираются в цикле и для каждого элемента опять в цикле перебираются данные. Простые алгоритмы сортировки, такие как пузырьковая и сортировка вставками выполняются за квадратичное время.</p>
  <p>Например функция sumOfPairs ищет сумму всех пар элементов в массиве:</p>
<pre>function sumOfPairs(arr) {
  let sum = 0;
  for (let i = 0; i &lt; arr.length; i++) {
      for (let j = 0; j &lt; arr.length; j++) {
          sum += arr[i] + arr[j];
      }
  }
  return sum;
}
const myArray = [1, 2, 3, 4];
console.log(sumOfPairs(myArray)); // Результат: 40</pre>
  <p>Этот код имеет два вложенных цикла, каждый из которых проходится по всему массиву. Количество операций в циклах равно n * n, где n - это длина массива.</p>
</article>


<!-- 6. Кубическое время O(n**3) -->
<article class="article">
  <div class="anchor" id="bigo-n3"></div>
  <h3>Кубическое время O(n**3)</h3>
  <p>Время выполнения алгоритма зависит от размера входных данных в кубе. Например, алгоритмы, которые имеют три вложенных цикла, такие как некоторые методы многомерной обработки данных.</p>
  <p>Например функция multiplyMatrices умножает две матрицы</p>
<pre>function multiplyMatrices(matrix1, matrix2) {
  let result = [];
  const m = matrix1.length;
  const n = matrix2[0].length;
  const p = matrix2.length;

  for (let i = 0; i &lt; m; i++) {
      result[i] = [];
      for (let j = 0; j &lt; n; j++) {
          result[i][j] = 0;
          for (let k = 0; k &lt; p; k++) {
              result[i][j] += matrix1[i][k] * matrix2[k][j];
          }
      }
  }
  return result;
}

const matrixA = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];

const matrixB = [
  [9, 8, 7],
  [6, 5, 4],
  [3, 2, 1]
];

console.log(multiplyMatrices(matrixA, matrixB));</pre>
  <p>Этот алгоритм умножения матриц имеет три вложенных цикла: первый проходится по строкам первой матрицы, второй по столбцам второй матрицы, а третий - по общим элементам для умножения. Количество операций равно n * n * n, где n - это размер матрицы. Это приводит к кубической сложности O(n^3).</p>
</article>


<!-- 7. Экспоненциальное время O(c**n) -->
<article class="article">
  <div class="anchor" id="bigo-cn"></div>
  <h3>Экспоненциальное время O(c**n)</h3>
  <p>Наихудшая сложность алгоритма. Содержит константу, увеличенную до размеров задачи. Количество шагов алгоритма растет с невероятной скоростью.</p>
  <p>Например, для угадывания пароля из 8 десятичных цифр придется выполнить 100 миллионов шагов. Отгадывание пароля это пример алгоритма полного перебора, проверяющего все возможные варианты. Алгоритмы полного перебора неэффективны.</p>
  <p>Это часто встречается в алгоритмах, которые решают проблемы методом "разделяй и властвуй" или используют рекурсию без оптимизации.</p>
  <p>Примером алгоритма с экспоненциальной сложностью может служить рекурсивное вычисление чисел Фибоначчи:</p>
<pre>function fibonacci(n) {
  if (n &lt;= 1) {
      return n;
  } else {
      return fibonacci(n - 1) + fibonacci(n - 2);
  }
}</pre>
  <p>Этот код использует рекурсию для вычисления чисел Фибоначчи. Однако каждый раз, когда вызывается функция fibonacci, она порождает два дополнительных вызова, что приводит к экспоненциальному увеличению количества вызовов функций с увеличением n.</p>
</article>


<!-- 8. Факториальное время O(n!) -->
<article class="article">
  <div class="anchor" id="bigo-f"></div>
  <h3>Факториальное время O(n!)</h3>
  <p>Это самая высокая степень роста времени выполнения алгоритма. Время выполнения алгоритма растет факториально от размера входных данных. Этот тип сложности встречается, например, при переборе всех возможных комбинаций элементов, что делает его чрезвычайно неэффективным для больших значений n.</p>
  <p>Пример алгоритма с факториальной сложностью может быть перебор всех перестановок элементов массива</p>
<pre>function permute(arr) {
  function swap(a, b) {
      const temp = arr[a];
      arr[a] = arr[b];
      arr[b] = temp;
  }

  function generate(n) {
      if (n === 1) {
          console.log(arr);
      } else {
          for (let i = 0; i &lt; n - 1; i++) {
              generate(n - 1);
              if (n % 2 === 0) {
                  swap(i, n - 1);
              } else {
                  swap(0, n - 1);
              }
          }
          generate(n - 1);
      }
  }

  generate(arr.length);
}

const myArray = [1, 2, 3];
permute(myArray);</pre>
  <p>Этот код создает все возможные перестановки элементов массива путем рекурсивного генерирования всех возможных комбинаций. Количество операций, необходимых для генерации всех перестановок, равно факториалу длины массива.</p>
</article>


<!-- Сложность встроенных методов JavaScript -->
<article class="article">
  <div class="anchor" id="bigo-js"></div>
  <h2>Сложность встроенных методов JavaScript</h2>

  <p>Встроенные методы JavaScript обычно имеют свои собственные характеристики сложности, которые варьируются в зависимости от конкретного метода и типа данных, с которыми они работают. Вот несколько примеров:</p>

  <ol>
    <li>
      <h3>Массивы:</h3>
      <p>Добавление/удаление элемента в конце массива (например, push, pop): Сложность O(1). Эти операции работают быстро, так как не требуется сдвигать все элементы при добавлении или удалении элемента в начале массива.</p>
      <p>Добавление/удаление элемента в начале массива (например, unshift, shift): Сложность O(n). При добавлении или удалении элемента в начале массива требуется сдвиг всех остальных элементов.</p>
      <p>Доступ к элементу по индексу (например, arr[index]): Сложность O(1). Элементы массива обычно доступны напрямую по индексу, что делает эту операцию очень эффективной.</p>
    </li>
    <li>
      <h3>Строки:</h3>
      <p>Слияние строк (например, использование + или concat): Сложность может быть O(n), так как при слиянии строк может потребоваться создание новой строки и копирование символов из оригинальных строк.</p>
    </li>
    <li>
      <h3>Объекты:</h3>
      <p>Доступ к свойствам объекта (например, obj.prop): Обычно сложность доступа к свойствам объекта - O(1), но это может измениться в случае использования Map или WeakMap, где сложность доступа может быть ближе к O(log n) из-за особенностей реализации.</p>
      <p>Добавление/удаление свойств объекта: Обычно сложность добавления/удаления свойств в объекте - O(1).</p>
    </li>
  </ol>
</article>


<!-- sort -->
<article class="article">
  <div class="anchor" id="sort"></div>
  <h2>Сортировка</h2>

  <ol>
    <li>Сортировка пузырьком (Bubble Sort)</li>
    <li>Сортировка перемешиванием (шейкерная сортировка) (Cocktail sort)</li>
    <li>Сортировка расчёской (Comb sort)</li>
    <li>Сортировка вставками (Insertion Sort)</li>
    <li>Сортировка выбором (Selection sort)</li>
    <li>Сортировка Шелла (Shell Sort)</li>
    <li>Сортировка подсчетом (Counting Sort)</li>
    <li>Сортировка слиянием (Merge Sort)</li>
    <li>Пирамидальная сортировка (сортировка кучей) (HeapSort)</li>
    <li>Быстрая сортировка Хоара (Quick Sort)</li>
    <li>Гномья сортировка (Gnome Sort)</li>
  </ol>
</article>


<!-- 1. Сортировка пузырьком (Bubble Sort) -->
<article class="article">
  <div class="anchor" id="sort-bubble"></div>
  <h3>1. Сортировка пузырьком (Bubble Sort)</h3>
  <p>Сортировка пузырьком — один из самых известных алгоритмов сортировки. Здесь нужно последовательно сравнивать значения соседних элементов и менять числа местами, если предыдущее оказывается больше последующего. Таким образом элементы с большими значениями оказываются в конце списка, а с меньшими остаются в начале.</p>
  <p>Когда дойдем до конца массива, то самый последний элемент будет гарантированно на своем месте. Самый большой пузырек всплыл на поверхность воды. Мы повторим процедуру еще раз, но уже до предпоследнего элемента. После второй итерации, на своих позициях будет уже 2 последних элемента. Будем повторять алгоритм до тех пор, пока у нас не останется только первый элемент.</p>
<pre>function bubbleSort(arr) {
  for (let i = 0; i &lt; arr.length; i++) {
    for (let j = 0; j &lt; arr.length - i; j++) {
      if (arr[j] &gt; arr[j + 1]) {
        let tmp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = tmp;
      }
    }
  }
  return arr;
}</pre>
  <p>Этот алгоритм считается учебным и почти не применяется на практике из-за низкой эффективности: он медленно работает на тестах, в которых маленькие элементы (их называют «черепахами») стоят в конце массива. Однако на нём основаны многие другие методы, например, шейкерная сортировка и сортировка расчёской.</p>

  <h3>Улучшенная сортировка пузырьком</h3>
  <p>Алгоритм пузырьковой сортировки никак не следит за текущим состоянием массива. Даже если на вход мы отправим уже отсортированный массив, нам нужно будет столько же итераций цикла, как и для неотсортированного массива, чтобы получить результат. Быстродействие пузырьковой сортировки в JavaScript можно улучшить, если добавить флаг (логическую переменную) который будет следить за тем был ли хотя бы один обмен на текущей итерации. Если нет, то массив отсортирован и задача выполнена.</p>
<pre>function bubbleSort(arr) {
  let isSwap = false;
  for (let i = 0; i &lt; arr.length; i++) {
    for (let j = 0; j &lt; arr.length - i; j++) {
      if (arr[j] &gt; arr[j + 1]) {
        let temp = arr[j + 1];
        arr[j + 1] = arr[j];
        arr[j] = temp;
        isSwap = true;
      }
    }
    if (!isSwap) {
      return arr;
    }
  }
  return arr;
}</pre>
  <p>Если отсортировать массив в котором все элементы уже расположены по возрастанию, то нам нужна будет только одна итерация внешнего цикла. Поэтому в лучшем случае мы получим сложность O(n).</p>
</article>


<!-- 2. Сортировка перемешиванием (шейкерная сортировка) (Cocktail sort) -->
<article class="article">
  <div class="anchor" id="sort-cocktail"></div>
  <h3>2. Сортировка перемешиванием (шейкерная сортировка) (Cocktail sort)</h3>
  <p>Шейкерная сортировка отличается от пузырьковой тем, что она двунаправленная: алгоритм перемещается не строго слева направо, а сначала слева направо, затем справа налево.</p>
  <p>Начинаем мы точно так же, как и в пузырьковой сортировке, и “выдавливаем наверх” максимальный элемент. После этого, разворачиваемся и “толкаем вниз” минимальный из оставшийся элементов.</p>
  <p>Оказавшись в начале массива, на своих местах будет уже 2 элемента - первый и последний. Остановимся когда дойдем до середины массива. Таким образом сделаем в 2 раза меньше итераций внешнего цикла. За счет этого скорость шейкерной сортировки будет немного выше, чем у обычного пузырька.</p>
  <p>Начнем с небольшого рефакторинга и вынесем функцию обмена наружу. Назовем ее swap</p>
<pre>function swap(arr, i, j) {
  let temp = arr[j];
  arr[j] = arr[i];
  arr[i] = temp;
}

function cocktailSort(arr) {
  let left = 0;
  let right = arr.length - 1;
  let isSwap = false;
  while(left &lt; right) {
    for (let i = left; i &lt; right; i++) {
      if (arr[i] &gt; arr[i + 1]) {
        swap(arr, i, i + 1);
        isSwap = true;
      }
    }
    if (!isSwap) {
      return arr;
    }
    isSwap = false;
    right--;
    for (let i = right; i &gt; left; i--) {
      if (arr[i] &lt; arr[i - 1]) {
        swap(arr, i, i - 1);
        isSwap = true;
      }
    }
    if (!isSwap) {
      return arr;
    }
    isSwap = false;
    left++;
  }
  return arr;
}</pre>
</article>


<!-- 3. Сортировка расчёской (Comb sort) -->
<article class="article">
  <div class="anchor" id="sort-sort"></div>
  <h3>3. Сортировка расчёской (Comb sort)</h3>
  <p>Сортировка расчёской — улучшение сортировки пузырьком. Её идея состоит в том, чтобы «устранить» элементы с небольшими значения в конце массива, которые замедляют работу алгоритма. Если при пузырьковой и шейкерной сортировках при переборе массива сравниваются соседние элементы, то при «расчёсывании» сначала берётся достаточно большое расстояние между сравниваемыми значениями, а потом оно сужается вплоть до минимального.</p>
  <p>Первоначальный разрыв нужно выбирать не случайным образом, а с учётом специальной величины — фактора уменьшения, оптимальное значение которого равно 1,247. Сначала расстояние между элементами будет равняться размеру массива, поделённому на 1,247. После каждого прохода расстояние делится на фактор уменьшения и таким образом получается новое значение. В конце концов оно сужается до минимального значения - единицы, и массив просто досортировывается обычным "пузырьком".</p>
<pre>// исходный массив
  var arr = [3,14,1,7,9,8,11,6,4,2]

  // получаем длину массива
  const l = arr.length;

  // оптимальное число для вычисления шага сравнения
  const factor = 1.247;

  // получаем точный шаг сравнения
  let gapFactor = l / factor;

  // пока шаг больше единицы
  while (gapFactor &gt; 1) {
      // округляем шаг до целого
      const gap = Math.round(gapFactor);
      // и организуем цикл как в пузырьковой сортировке
      for (let i = 0, j = gap; j &lt; l; i++, j++) {
          // если сначала идёт большое число
          if (arr[i] &gt; arr[j]) {
              // меняем их местами
              [arr[i], arr[j]] = [arr[j], arr[i]];
          }

          // выводим текущее состояние массива в консоль
          // это необязательный шаг, он здесь для наглядности
          console.log(arr);
      }
      // в конце цикла рассчитываем новый шаг
      gapFactor = gapFactor / factor;
  }</pre>
  <p>Расчёска лучше пузырьковой сортировки, потому что в ней намного меньше операций перестановки. Именно перестановка занимает основное время процессора. В самом худшем случае алгоритм сортировки расчёской будет работать так же, как и пузырьковая, а в среднем — алгоритм работает быстрее пузырьковой.</p>
</article>


<!-- 4. Сортировка вставками (Insertion Sort) -->
<article class="article">
  <div class="anchor" id="sort-insertion"></div>
  <h3>4. Сортировка вставками (Insertion Sort)</h3>
  <p>При сортировке вставками массив постепенно перебирается слева направо. При этом каждый последующий элемент размещается так, чтобы он оказался между ближайшими элементами с минимальным и максимальным значением.</p>
<pre>function insertionSort(inputArr) { 
  let n = inputArr.length; 
  for (let i = 1; i &lt; n; i++) {

  // выбираем первый элемент в неотсортированном массиве
  let current = inputArr[i];

  // последний элемент отсортированного массива
  let j = i-1; 
  while ((j &gt; -1) && (current &lt; inputArr[j])) { 
  inputArr[j+1] = inputArr[j]; 
  j--; 
  } 
  inputArr[j+1] = current; 
  } 
  return inputArr; 
}</pre>
  <p>Итерация начинается со второго элемента. Считаем отсортированным по умолчанию первый элемент. Для каждой итерации мы отслеживаем current элемент. Каждый current элемент будет первым элементом несортированного массива - и каждый элемент перед ним будет принадлежать отсортированному массиву.</p>
  <p>Через в while цикла, мы проходим отсортированный массив и сдвиг элементы вправо, открывая пространство для current элемента должны быть вставлено.</p>
  <p>Как только мы найдем для него подходящее место, current элемент вставляется во вновь открытый слот. Этот процесс повторяется для каждой итерации, пока массив не будет отсортирован.</p>
</article>


<!-- 5. Сортировка выбором (Selection sort) -->
<article class="article">
  <div class="anchor" id="sort-selection"></div>
  <h3>5. Сортировка выбором (Selection sort)</h3>
  <p>Сортировка выбором начинается с поиска наименьшего элемента в списке и обмена его с первым элементом (таким образом, наименьший элемент помещается в окончательную позицию в отсортированном массиве). Затем мы сканируем массив, начиная со второго элемента, в поисках наименьшего среди оставшихся n-1 элементов и обмениваем найденный наименьший элемент со вторым, т.е. помещаем второй наименьший элемент в окончательную позицию в отсортированном массиве. В общем случае, при i-ом проходе по списку (0 &lt;= i &lt;= n-2) алгоритм ищет наименьший элемент среди последних n-i элементов и обменивает его с A[ i ]. После выполнения n-1 проходов список оказывается отсортирован.</p>
  <p>После каждой итерации необходимо проверять на один элемент меньше, пока не будет отсортирован весь массив или список.</p>
<pre>function selectionSort(inputArr) { 
  let n = inputArr.length;
      
  for(let i = 0; i &lt; n; i++) {
      // Находим наименьшее число в правой части массива
      let min = i;
      for(let j = i; j &lt; n; j++) {
          if(inputArr[j] &lt; inputArr[min]) {
              min=j; 
          }
       }
       if (min != i) {
           // Заменяем элементы
           let tmp = inputArr[i]; 
           inputArr[i] = inputArr[min];
           inputArr[min] = tmp;      
      }
  }
  return inputArr;
}</pre>
</article>


<!-- 6. Сортировка Шелла (Shell Sort) -->
<article class="article">
  <div class="anchor" id="sort-shell"></div>
  <h3>6. Сортировка Шелла (Shell Sort)</h3>

<pre>function ShellSort(A)
  {
      var n = A.length, i = Math.floor(n/2);
      while (i &gt; 0)
       { for (var j = 0; j &lt; n; j++)
          { var k = j, t = A[j];
            while (k &gt;= i && A[k-i] > t)
             { A[k] = A[k-i]; k -= i; }
            A[k] = t;
          }
        i = (i==2) ? 1 : Math.floor(i*5/11);
       }
      return A;
  }</pre>
</article>


<!-- 7. Сортировка подсчетом (Counting Sort) -->
<article class="article">
  <div class="anchor" id="sort-count"></div>
  <h3>7. Сортировка подсчетом (Counting Sort)</h3>

  <p>Вначале для каждого элемента массива подсчитывается количество элементов, меньших, чем он, и на основе этой информации текущий элемент помещается в соответствующее место отсортированного массива. </p>
<pre>function SimpleCountingSort(A) {   
  var n = A.length, Count = [], B = [];
  for (var i = 0; i &lt; n; i++) Count[ i ] = 0;
  for (var i = 0; i &lt; n-1; i++)
    { for (var j = i+1; j &lt; n; j++)
      { if (A[ i ] &lt; A[j]) Count[j]++;
        else Count[ i ]++;
      }
    }
  for (var i = 0; i &lt; n; i++) B[Count[ i ]] = A[ i ];
  return B;
}</pre>
</article>


<!-- 8. Сортировка слиянием (Merge Sort) -->
<article class="article">
  <div class="anchor" id="sort-merge"></div>
  <h3>8. Сортировка слиянием (Merge Sort)</h3>

<pre>function Merge(a,low,mid,high) {    //Вспомогательная функция.
  var b = new Array(high+1-low), h, i, j = mid+1, k, h = low, i = 0;
  while (h &lt;= mid && j &lt;= high )
    { if (a[h] &lt;= a[j]){ b[ i ]=a[h]; h++; }
      else             { b[ i ]=a[j]; j++; }
      i++;
    }
  if (h &gt; mid){ for (k = j; k &lt;= high; k++){ b[ i ]=a[k]; i++; } }
  else        { for (k = h; k &lt;= mid; k++){  b[ i ]=a[k]; i++; } }    
  for (k=0; k&lt;=high-low; k++) a[k+low]=b[k];
  return a;
}

function MergeSort(A) {     //Функция сортировки слиянияем.
  function merge_sort(a,low,high)
    { if (low &lt; high)
      { var mid = Math.floor((low+high)/2);
        merge_sort(a, low, mid);
        merge_sort(a, mid+1, high);
        Merge(a, low, mid, high);
      }
    }
  var n = A.length;
  merge_sort(A, 0, n-1);
  return A;
}</pre>
</article>


<!-- 9. Пирамидальная сортировка (сортировка кучей) (HeapSort) -->
<article class="article">
  <div class="anchor" id="sort-heap"></div>
  <h3>9. Пирамидальная сортировка (сортировка кучей) (HeapSort)</h3>

<pre>function HeapSort(A) {
  if (A.length == 0) return [];
  var n = A.length, i = Math.floor(n/2), j, k, t;
  while (true)
  { if (i &gt; 0) t = A[--i];
    else { n--;
            if (n == 0) return A;
            t = A[n];  A[n] = A[0];
          }        
    j = i;  k = j*2+1;
    while (k &lt; n)
      { if (k+1 &lt; n && A[k+1] &gt; A[k]) k++;
        if (A[k] &gt; t)
        { A[j] = A[k];  j = k;  k = j*2+1; }
        else break;
      }
    A[j] = t; 
  }
}</pre>
</article>


<!-- 10. Быстрая сортировка Хоара (Quick Sort) -->
<article class="article">
  <div class="anchor" id="sort-quick"></div>
  <h3>10. Быстрая сортировка Хоара (Quick Sort)</h3>

<pre>function QuickSort(A) {
  if (A.length == 0) return [];
  var a = [], b = [], p = A[0];
  for (var i = 1; i &lt; A.length; i++)
    { if (A[ i ] &lt; p) a[a.length] = A[ i ];
      else b[b.length] = A[ i ];
    }
  return QuickSort(a).concat( p,QuickSort(b) );
}</pre>
</article>


<!-- 11. Гномья сортировка (Gnome Sort) -->
<article class="article">
  <div class="anchor" id="sort-gnome"></div>
  <h3>11. Гномья сортировка (Gnome Sort)</h3>

  <p>Гномья сортировка (англ. Gnome sort) — алгоритм сортировки, похожий на сортировку вставками, но в отличие от последней перед вставкой на нужное место происходит серия обменов, как в сортировке пузырьком.</p>

<pre>function GnomeSort(A) {
  var n = A.length, i = 1, j = 2;
  while (i &lt; n)
    { if (A[i-1] &lt; A[ i ]){ i = j; j++; }
      else
        { var t = A[i-1]; A[i-1] = A[ i ]; A[ i ] = t;
          i--;
          if (i == 0){ i = j; j++; }
        }
    }
  return A;
}</pre>
</article>


<!-- Поиск -->
<article class="article">
  <div class="anchor" id="search"></div>
  <h2>Поиск</h2>

  <ol>
    <li>Линейный поиск</li>
    <li>Двоичный (бинарный) поиск</li>
    <li>Поиск в глубину (Depth-First Search)</li>
    <li>Поиск в ширину (Breadth-First Search)</li>
    <li>Алгоритм Дейкстры</li>
  </ol>
</article>


<!-- Линейный поиск -->
<article class="article">
  <div class="anchor" id="search-1"></div>
  <h3>Линейный поиск</h3>
  <p>Линейный поиск числа перебирает каждый элемент в наборе данных и сравнивает его с целевым числом. Если находит совпадение то выдает ответ, что число найдено в списке. Если проходит все числа от первого до последнего и совпадения не будет, то выдает ответ что число отсутствует в списке.</p>
  <p>Временная сложность линейного поиска O(n). O(n) это худший случай, если элемент окажется последний в списке и придется просмотреть каждый элемент, чтобы найти его. В лучшем случае элемент окажется первым в списке и с сложность будет O(1). В среднем линейному поиску требуется n/2 шагов.</p>
  <p>Линейный поиск используют если данные не отсортированы. Если данные отсортированы то можно использовать двоичный поиск.</p>
<pre>const linearSearch = (arr, findEl) => {
  for (let i = 0; i &lt; arr.length; i++) {
    if (arr[i] === findEl) {	
      return i
    }
  }
  return -1
}</pre>
  <p>Запускаем цикл по массиву i.</p>
  <p>Проверяем текущий элемент на соответствие искомому элементу, в случае не соответствия идём дальше. Если элемент соответствует искомому, возвращаем его индекс.</p>
  <p>Если элемента нет в массиве, возвращаем -1.</p>
  <p>Сложность алгоритма: О(n).</p>
</article>


<!-- Двоичный (бинарный) поиск -->
<article class="article">
  <div class="anchor" id="search-2"></div>
  <h3>Двоичный (бинарный) поиск</h3>
  <p>Двоичный поиск работает только с отсортированными данными. Первый шаг это определить среднее число. Второй шаг это сравнить целевое число со средним числом. Если число совпало то алгоритм закончен, если нет то переходим на третий шаг. Третий шаг определить целевое число больше или меньше среднего числа. Отбросить ненужную половину чисел и искать в нужной.</p>
  <p>Временная сложность двоичного поиска O(log n). Это эффективнее чем линейный поиск. Линейный поиск среди миллиона элементов займет миллион шагов. Двоичный поиск среди миллиона элементов займет 20 шагов.</p>
  <p>Когда при двоичном поиске первый раз делим список пополам, то остается n/2 элементов, после второй итерации n/(2*2), после третьей n/(2**3) и т.д. Двоичный поиск при каждой итерации делит список пополам, а это значит, что основание логарифма, описывающего время выполнени поиска, равно 2. Тем не менее, в нотации "О большое" основание логарифма не имеет значение, потому что его можно изменить, умножив логарифм на константу.</p>
  <p>Если есть большой список, к которому требуется выполнить много поисковых запросов, то выгоднее отсортировать данные один раз, чтобы ускорить каждый поиск в будущем.</p>
  <p>Пример функции бинарного поиска на JavaScript, которая имеет сложность O(log n):</p>
<pre>function binarySearch(arr, target) {

  // Создаём два указателя на начало массива и конец массива.
  let left = 0;
  let right = arr.length - 1;

  //Запускаем цикл, который итерируется до тех пор, пока указатель на начало не совпадает с указателем на конец массива.
  while (left &lt;= right) {

    //Внутри цикла создаём указатель на середину массива.
    let mid = Math.floor((left + right) / 2);

    // Проверяем, если элемент по середине равен искомому элементу, возвращаем его индекс.
    if (arr[mid] === target) {
        return mid; // элемент найден
    } else if (arr[mid] &lt; target) {
        left = mid + 1; // искать в правой половине
    } else {
        right = mid - 1; // искать в левой половине
    }
  }

  // элемент не найден
  return -1; 

}</pre>
  <p>Бинарный поиск ищет значение в отсортированном массиве, разделяя его пополам на каждой итерации. Поиск начинается с середины массива. Если значение, которое мы ищем, больше среднего элемента, поиск продолжается в правой половине массива. Если оно меньше, то в левой. Таким образом, на каждой итерации мы уменьшаем область поиска примерно в два раза, что обеспечивает логарифмическую сложность O(log n).</p>
</article>


<!-- Поиск в глубину (Depth-First Search) -->
<article class="article">
  <div class="anchor" id="search-3"></div>
  <h3>Поиск в глубину (Depth-First Search)</h3>
  <p>Поиск в глубину — это алгоритм обхода или поиска в таких структурах данных, как деревья или графы. Основан на такой структуре данных, как стек. Алгоритм начинает работу с корневого узла (в случае графа в качестве корневого узла выбирается какой-либо произвольный узел) и прежде чем вернуться назад, проходит как можно дальше по каждой ветви.</p>
  <p>Сложность алгоритма: O(V + E).</p>

  <p>Шаги реализации:</p>
  <ol>
    <li>В случае обхода графа необходимо проинициализировать объект visited, который будет хранить вершины, которые прошёл алгоритм во избежание попадания в бесконечный цикл. В случае обхода по дереву этот шаг можно пропустить.</li>
    <li>Создаём массив stack, который будет исполнять роль стека, сразу заполняем его значением вершины, с которой начнём обход.</li>
    <li>Запускаем цикл, который будет итерироваться до тех пор, пока стек не опустеет.</li>
    <li>Достаём первое значение из стека и помещаем его в переменную vert.</li>
    <li>Проверяем, имеет ли эта вершина дочерние вершины.</li>
    <li>В случае если дочерние вершины найдены, добавляем их в начало стека.</li>
    <li>В случае обхода графа запускаем цикл, который будет проходить по дочерним вершинам, и если они не были пройдены алгоритмом ранее, класть их в стек.</li>
  </ol>

  <p>Пример кода в дереве:</p>
<pre>const dfs = (tree, start) => {
  const stack = [start];

  while (stack.length &gt; 0) {
    const vert = stack.shift(); // Выбираем первую вершину из стека

    if (tree[vert]) {
      stack.unshift(...tree[vert]); // Добавляем вершины в начало стека
    }
  }
};</pre>
  <p>Пример кода в графе:</p>
<pre>const dfs = (graph, start) => {
  const visited = {};
  const stack = [start];

  while (stack.length !== 0) {
    const vert = stack.shift(); // Выбираем первую вершину из стека

    if (!visited[vert]) {
      visited[vert] = true; // Отмечаем вершину как пройденую, если ранее не проходили её
    }

    if (graph[vert]) {
      for (let subVert of graph[vert]) {
        if (!visited[subVert]) {
          stack.unshift(subVert); // Добавляем вершину в начало стека
        }
      }
    }
  }
};</pre>
  <p>Алгоритм следует использовать в следующих случаях:</p>
  <ol>
    <li>Когда мы знаем, что искомая вершина находится дальше всего от стартовой, или если граф имеет большую ширину.</li>
    <li>Когда нам необходимо найти пути между вершинами.</li>
  </ol>
</article>


<!-- Поиск в ширину (Breadth-First Search) -->
<article class="article">
  <div class="anchor" id="search-4"></div>
  <h3>Поиск в ширину (Breadth-First Search)</h3>
  <p>Алгоритм поиска в ширину очень похож на описанный выше алгоритм поиска в глубину, отличается лишь тем, что в начале проходит все соседние узлы начальной вершины, потом все соседние узлы соседних вершин, и так далее, пока не пройдёт весь граф или не найдёт искомую вершину. Ещё одно отличие заключается в том, что основан этот алгоритм на такой структуре данных, как очередь.</p>
  <p>Сложность алгоритма: O(V + E).</p>

  <p>Шаги реализации:</p>
  <ol>
    <li>В случае обхода графа создаём объект visited, который будет хранить в себе информацию о пройденных вершинах, чтобы избежать бесконечного цикла.</li>
    <li>Создаём массив queue, который будет исполнять роль очереди.</li>
    <li>Запускаем цикл, который будет итерироваться до тех пор, пока очередь не опустеет.</li>
    <li>Достаём первый элемент из очереди и помещаем его в переменную vert.</li>
    <li>Проверяем, имеет ли эта вершина дочерние вершины.</li>
    <li>Если дочерние вершины имеются, добавляем их в конец очереди.</li>
    <li>В случае обхода графа запускаем цикл, который будет проходить по дочерним вершинам текущей вершины vert, и если алгоритм не проходил их ранее, добавляем их в конец очереди.</li>
  </ol>

  <p>Пример кода в дереве:</p>
<pre>const bfs = (tree, start) => {
  const queue = [start];

  while (queue.length !== 0) {
    const vert = queue.shift(); // Выбираем первую вершину из очереди

    if (tree[vert]) {
      queue.push(...tree[vert]); // Добавляем вершины в конец очереди
    }
  }
};</pre>
  <p>Пример кода в графе:</p>
<pre>const bfs = (graph, start) => {
  const visited = {};
  const queue = [start];

  while (queue.length !== 0) {
    const vert = queue.shift(); // Выбираем первую вершину из очереди

    if (!visited[vert]) {
      visited[vert] = true; // Отмечаем вершину как пройденую, если ранее не проходили её
    }

    if (graph[vert]) {
      for (let subVert of graph[vert]) {
        if (!visited[subVert]) {
          queue.push(subVert); // Добавляем вершину в конец очереди
        }
      }
    }
  }
};</pre>
  <p>Алгоритм следует использовать в следующих случаях:</p>
  <ol>
    <li>Когда мы знаем, что искомая вершина находится близко к стартовой, или если граф имеет большую глубину.</li>
    <li>Когда нам необходимо найти кратчайшее расстояние в невзвешенном графе.</li>
  </ol>
</article>


<!-- Алгоритм Дейкстры -->
<article class="article">
  <div class="anchor" id="search-5"></div>
  <h3>Алгоритм Дейкстры</h3>

  <p>Основная идея алгоритма — создание дерева кратчайших путей с заданным источником в качестве корня. Алгоритм Дейкстры — один из самых популярных алгоритмов для нахождения короткого пути в взвешенном графе. Незаменим в работе GPS-навигации.</p>

  <p>Сложность алгоритма: O(E * log V)</p>

  <p>Шаги реализации:</p>
  <ol>
    <li>Создаём объект parents, который будет хранить историю переходов по графу, объект costs , который будет хранить стоимости переходов, массив queue — очередь обхода вершин.</li>
    <li>Запускаем цикл, который проходит по вершинам графа и заполняет стартовыми значениями объект стоимости и очередь.</li>
    <li>Стоимость перехода в стартовую вершину равна 0, для остальных вершин Infinity.</li>
    <li>Запускаем цикл по очереди, находим элемент с наименьшей стоимостью перехода и помещаем её в переменную.</li>
    <li>Если элемент с наименьшей стоимостью существует и значение перехода в него не равно Infinity, запускаем цикл по дочерним вершинам.</li>
    <li>Находим новую стоимость, складывая стоимость перехода в родительскую и дочернюю вершину.</li>
    <li>Если стоимость перехода в дочернюю вершину больше новой стоимости, то обновляем стоимость для дочерней вершины в объекте стоимости, в истории переходов для дочерней вершины устанавливаем значение родительской вершины и добавляем дочернюю вершину с новой стоимостью в конец очереди.</li>
    <li>Повторяем шаги 4-7, пока очередь не опустеет.</li>
  </ol>

  <p>Пример кода:</p>
<pre>const getLowestCostNode = (queue) => {
  let min = Infinity;
  let lowIndex;

  for (let i = 0; i &lt; queue.length; i++) {
    const [, value] = queue[i];
    if (value &lt; min) {
      min = value;
      lowIndex = i;
    }
  }

  const lowestNode = queue.splice(lowIndex, 1)[0];
  return lowestNode;
};

const dijkstra = (graph, start) => {
  const parents = {};
  const costs = {};
  const queue = [];

  for (let vert in graph) {
    if (vert === start) {
      costs[vert] = 0;
      queue.push([vert, 0]);
    } else {
      costs[vert] = Infinity;
      queue.push([vert, Infinity]);
    }
    parents[vert] = null;
  }

  while (queue.length) {
    const node = getLowestCostNode(queue);
    let [vert, value] = node;
    const cost = costs[vert];

    if (node || value !== Infinity) {
      for (let subNode in graph[vert]) {
        const nextSubNodeValue = graph[vert][subNode];
        const newCost = cost + nextSubNodeValue;
          if (costs[subNode] &gt; newCost) {
            costs[subNode] = newCost;
            parents[subNode] = vert;
            queue.push([subNode, newCost]);
          }
      }
    }
  }
};</pre>

  <p>Алгоритм следует использовать в следующих случаях:</p>
  <ol>
    <li>Когда необходимо найти кратчайший путь в взвешенном графе.</li>
    <li>Когда граф не имеет отрицательных весов.</li>
  </ol>
</article>


<!-- Тренировки по алгоритмам от Яндекс (Михаил Густокашин) -->
<article class="article">
  <div class="anchor" id="train"></div>
  <h3>Тренировки по алгоритмам от Яндекс (Михаил Густокашин)</h3>

  <p>Чего хотят на алгоритмическом собеседовании (и в реальной жизни)?</p>
  <ol>
    <li>Умения писать работаюдий код</li>
    <li>Умения тестировать свой код</li>
    <li>Умения писать эффективный код</li>
  </ol>

  <h3>Задача 1. Самый частый символ</h3>
  <p>Дана строка (в кодировке UTF-8), найти самый часто встречающийся в ней символ. Если таких символов несколько - найти любой.</p>

  <p>Решение 1. O(n^2)</p>
  <p>Переберем все позиции и для каждой позиции в строке еще раз переберем все позиции и в случае совпадения прибавим к счетчику единицу. Найдем максимальное значение счетчика.</p>

  <p>Решение 2. O(n*k)</p>
  <p>Переберем все символы, встречающиеся в строке, а затем переберем все позиции и в случае совпадения прибавим к счетчику единицу. Найдем максимальное значение счетчика.</p>

  <p>Решение 3. O(n+k) = O(n)</p>
  <p>Заведем словарь, где ключом является символ, а значением - сколько раз он встретился. Если символ встретился впервые - создаем элемент словаря с ключом, совпадающим с этим символом и значением ноль. Прибавляем к элементу словаря с ключом, совпадающим с этим символом, единицу</p>

  <h3>Задача 2. Максимальный элемент</h3>
  <p>Найти максимальный элемент в массиве.</p>

  <p>Решение.</p>
  <p>Сначала нужно в ответ положить нулевой элемент массива. Потом пройтись по всем элементам массива и сравнивая их с ответом, присвоивать ответу большее значение. В конце надо вернуть ответ.</p>

  <h3>Задача 3. Второй по величине элемент</h3>
  <p>Найти второе по величине число (такое, которое будет максимальным, если вычеркнуть из последовательности одно максимальное число)</p>

  <p>Решение.</p>
  <p>Заведем две переменные max для максимального числа и max2 для второго по величине числа. Сравним первые два числа и запишем одно в max, другое в max2. Проходим по всем числам и сначала сравниваем число now с первым максимумом. Если now больше max, то max записываем в max2, а now записываем в max, при этом предыдущее значение max2 теряется. Если now меньше max, то сравниваем now со вторым максимумом. Если now больше max2, то записываем now в max2, при этом предыдущее значение max2 также теряется.</p>

  <h3>Задача 4. Минимальное четное число</h3>
  <p>Найти минимальное четное число в последовательности, вывести -1, если ни одного четного нет.</p>

  <p>Решение.</p>
  <p>Сначала положим в ответ -1. Если четного числа не будет, то вернется -1, как и нужно из условия задачи. Проходим по всем числам и сначала проверяем что число четное (остаток от деления на 2 равен 0) и в ответе лежит -1 или это число меньше чем в ответе. Тогда присваиваем ответу новое число.</p>

  <h3>Задача 5. Поиск минимума и максимума одновременно</h3>
  <p>Найти одновременно минимум и максимум, используя как можно меньше сравнений.</p>

  <p>Решение 1.</p>
  <p>Два раза проходим по всем числам. Первый раз ищем минимум. Второй раз ищем максимум. Это займет 2n операций.</p>

  <p>Решение 2.</p>
  <p>Разобьем все числа по парам. Сравнивая числа в каждой паре выбираем меньшее и большее из двух чисел. Это можно сделать за одно сравнение. Эта операция займет n/2 сравнений. Теперь минимум будем искать среди минимальных элементов, а максимум среди ма. Это два линейных поиска по n/2 элементам. Таким образом для решения мы затратим 3n/2 операций, что на n/2 операций меньше чем в первом решении.</p>

  <h3>Задача 5. Барьерный элемент</h3>
  <p>Найти индекс вхождения числа x в последовательность или вывести n (длину последовательности), если не нашлось</p>

  <p>Решение</p>
  <p>Записываем в конец последовательности элемент x, который надо найти. Проходим по массиву и если элемент встретится, то выводим его индекс. Если изначално элемента в массиве не было, то вернется индекс последнего элемента (равный длине начального массива), в который мы положили x. Это идея барьерного элемента, когда мы заранее задаем некий барьер и обходимся обычным линейным поиском без каких либо булевых переменных и лишних проверок. Мы приделали барьер на который линейный поиск напорится и выведет нужное число.</p>

  <h3>Задача 6. Соседние элементы в двумерных массивах</h3>
  <p>Найти соседние элементы в двумерном массиве из n на n элементов</p>

  <p>Решение.</p>
  <p>Будем использовать массив сдвигов. Для крайнев случаев, когда клетка прижата к краю или в углу мы можем выйти за пределы массива. А чтобы не выйти за пределы массива будем использовать барьерный метод. Создаем новый двумерный массив, который на 2 больше по каждому измерению и заполняем его рамочку значением барьера, например -1. А исходный массив будет внутри нового массива с барьером. Теперь когда мы проверяем крайние клетки, вместо того чтобы смотреть существует ли массив в соседней клетке, мы можем проверить на наличие в клетке барьерного чилса. И если в клетке барьерное число, то мы ее не анализируем. Например, надо найти клетку, которая больше всех своих соседей. Тогда клетки с -1 не участвуют в сравнениях.</p>

  <h3>Задача 7. Сапер</h3>
  <p>Даны координаты мин на поле, вывести поле для игры в сапер. Мины пометить звездочкой, а в поле без мин вывести число, равное количеству мин в соседних 8 клетках.</p>

  <p>Решение.</p>

  <h3>Задача 8. pitcraft</h3>
  <p>Остров игрока представляет собой набор столбцов различной высоты, состоящих из блоков камня и окруженный морем. Над островом прошел сильный дождь, который заполнил водой все низины. Определите, сколько блоков воды осталось после дождя в низинах на острове.</p>

  <p>Решение.</p>
  <p>Если вершина одна, то выбираем вершину. Слева от нее вода будет стекать в море, заполняя собой все впадины. И справа от нее вода будет стекать в море заполняя собой все впадины. Если вершин несколько, то между ними останется вода во впадинах, а слева и справа вода будет стекать в море.</p>

  <h3>Задача 9. RLE</h3>
  <p>Дана строка (возможно, пустая), состоящая из букв A-Z. Нужно сжать строку. Если буква встречается более одного раза подряд, то рядом с буквой писать число сколько раз она встречается подряд. Написать функцию RLE, которая на выходе даст строку вида - буква и цифра, означающая сколько букв подряд идет, затем следующая буква и т.д.</p>
  <p>Пример, на входе AAAABBBCCXYZDDDD. на выходе A4B3C2XYZD4</p>

  <p>Решение.</p>

  <h3>Задача 10. Газон</h3>
  <p>Трава пострижена в прямоугольнике с углами (x1, y1) и (x2, y2). В каждой целой точке растет пучок травы. Круговой дождеватель установлен в (x3, y3), радиус r. Сколько пучков пострижено и полито?</p>

  <p>Решение 1. Неэффективное. Перебрать все пучки травы</p>
  <p>Постриженые пучки травы находятся в прямоугольнике, а политые в круге. Надо найти пересечение этих фигур. И в этом пересечении будут пучки, которые и пострижены и политы. Проверим что точка лежит внутри прямоугольника, то есть х координата лежит между x1 и x2, а y координата лежит между y1 и y2. Проверим что точка лежит внутри круга по теореме Пифагора. (x - x3)^2 + (y - y3)^2 должно быть меньше или равно r^2.</p>

  <p>Решение 2. Чуть лучше. Перебрать пучки травы только внутри прямоугольника</p>
  <p>Мы будем знать что наши пучки все пострижены и будем проверять только то что они политы или нет. В худшем случае, когда весь участок пострижен, это не даст нам ускорения. Но в среднем случае даст.</p>

  <p>Решение 3. Правильное.</p>
  <p>Если прямоуголькик и круг не пересакаются, то возвращаем 0. Если пересекаются, то находим максимум левого x прямоуголькика и левого x круга, затем находим минимум между правого x прямоугольника и правого x круга. Между этими значениями будут x координаты нужных пучков. Находим минимум верхнего y прямоугольника и верхнего y круга, затем находим максимум нижнего y прямоугольника и нижнего y круга. Между этими значениями будут y координаты нужных пучков.</p>

  <h3>Задача 11. Покраска деревьев</h3>
  <p>Вася красит деревья с номерами [P - V, P + V]. Маша красит деревья с номерами [M - Q, M + Q]. Сколько деревьев они покрасят?</p>

  <p>Решение.</p>
  <p>Ключевые идеи.</p>
  <ol>
    <li>Заводить множества или списки нельзя - большие входные данные</li>
    <li>Если отрезки пересекаются - берем длину от максимума из левых границ до максимума из правых границ</li>
    <li>Если отрезки не пересекаются - берем сумму длин отрезков</li>
    <li>Как проверить пересечение?</li>
  </ol>
</article>





