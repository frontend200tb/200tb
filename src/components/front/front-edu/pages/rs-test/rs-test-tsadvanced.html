<article class="article">
  <div id="link-to-quiz" class="btn-back">назад</div>

  <h1>[St2] TS Advanced [EN]</h1>

  <strong>41 вопрос. Выполнил на 85 баллов из 100</strong>
</article>


<article class="article">
  <h3>1. A primitive data type which represents the type of values that never occur.</h3>
  <ul>
    <li>any</li>
    <li><strong>never</strong></li>
    <li>null</li>
    <li>void</li>
    <li>undefined</li>
    <li>unknown</li>
  </ul>
</article>


<article class="article">
  <h3>2. A primitive type indicating intentional absence of the value. It has the same characteristics as the type in JS.</h3>
  <ul>
    <li>never</li>
    <li>unknown</li>
    <li>any</li>
    <li>void</li>
    <li><strong>null</strong></li>
  </ul>
</article>


<article class="article">
  <h3>3. A primitive type indicating that a value is not defined. It has the same characteristics as the type in JS.</h3>
  <ul>
    <li>any</li>
    <li>void</li>
    <li>never</li>
    <li>null</li>
    <li><strong>undefined</strong></li>
  </ul>
</article>


<article class="article">
  <h3>4. A type which represents the return value of functions which don't return a value.</h3>
  <ul>
    <li>any</li>
    <li>never</li>
    <li>unknown</li>
    <li><strong>void</strong></li>
    <li>null</li>
    <li>undefined</li>
  </ul>
</article>


<article class="article">
  <h3>5. Can a class be used as an interface?</h3>
  <ul>
    <li>yes, it can</li>
    <li>no</li>
    <li><strong>by default, no, but conditions can be created to make it possible</strong></li>
  </ul>
</article>


<article class="article">
  <h3>6. Can a class be used as a type specifier?</h3>
  <ul>
    <li><strong>yes, it can</strong></li>
    <li>no</li>
    <li>by default, no, but conditions can be created to make it possible</li>
  </ul>
</article>


<article class="article">
  <h3>7. Can an interface contain getters and setters?</h3>
  <ul>
    <li>yes, it can</li>
    <li><strong>no</strong></li>
  </ul>
</article>


<article class="article">
  <h3>8. Can be abstract: (checkbox)</h3>
  <ul>
    <li><strong>field</strong></li>
    <li>type</li>
    <li><strong>class</strong></li>
    <li>interface</li>
    <li>namespace</li>
    <li><strong>method</strong></li>
    <li>import and export</li>
  </ul>
</article>


<article class="article">
  <h3>9. Can you specify the allowed data types for a getter and setter in an interface?</h3>
  <ul>
    <li>yes, you can</li>
    <li><strong>no</strong></li>
  </ul>
</article>


<article class="article">
  <h3>10. Choose the correct answer:</h3>
  <ul>
    <li>TS supports namespaces, namespaces cannot be nested</li>
    <li>TS does not support namespaces</li>
    <li><strong>TS supports namespaces, namespaces can be nested</strong></li>
    <li>TS supports namespaces, namespaces can be nested, namespaces cannot be exported</li>
  </ul>
</article>


<article class="article">
  <h3>11. Creates a tuple type from the types used in the type parameters of a function.</h3>
  <ul>
    <li>Omit&lt;T, K&gt;</li>
    <li>Record&lt;K, T&gt;</li>
    <li>Pick&lt;T, K&gt;</li>
    <li>Extract&lt;T, K&gt;</li>
    <li><strong>no correct answer</strong></li>
  </ul>
</article>


<article class="article">
  <h3>12. Creates a type by selecting a set of properties K (keys) from T.</h3>
  <ul>
    <li>Omit&lt;T, K&gt;</li>
    <li>Record&lt;K, T&gt;</li>
    <li><strong>Pick&lt;T, K&gt;</strong></li>
    <li>Extract&lt;T, K&gt;</li>
    <li>no correct answer</li>
  </ul>
</article>


<article class="article">
  <h3>13. Creates a type by selecting all properties from T and then removing K (keys):</h3>
  <ul>
    <li><strong>Omit&lt;T, K&gt;</strong></li>
    <li>Record&lt;K, T&gt;</li>
    <li>Pick&lt;T, K&gt;</li>
    <li>Extract&lt;T, K&gt;</li>
    <li>no correct answer</li>
  </ul>
</article>


<article class="article">
  <h3>14. Creates a type consisting of all properties of T where the value is set as required.</h3>
  <ul>
    <li>Readonly&lt;T&gt;</li>
    <li><strong>Required&lt;T&gt;</strong></li>
    <li>Omit&lt;T&gt;</li>
    <li>Partial&lt;T&gt;</li>
    <li>Parameters&lt;T&gt;</li>
    <li>NonNullable&lt;T&gt;</li>
    <li>ConstructorParameters&lt;T&gt;</li>
    <li>ReturnType&lt;T&gt;</li>
    <li>InstanceType&lt;T&gt;</li>
  </ul>
</article>


<article class="article">
  <h3>15. Creates a type consisting of the return type of the function T</h3>
  <ul>
    <li>Readonly&lt;T&gt;</li>
    <li>Required&lt;T&gt;</li>
    <li>Omit&lt;T&gt;</li>
    <li>Partial&lt;T&gt;</li>
    <li>Parameters&lt;T&gt;</li>
    <li>NonNullable&lt;T&gt;</li>
    <li>ConstructorParameters&lt;T&gt;</li>
    <li><strong>ReturnType&lt;T&gt;</strong></li>
    <li>InstanceType&lt;T&gt;</li>
  </ul>
</article>


<article class="article">
  <h3>16. Creates a type consisting of the type of an instance of the constructor function in T.</h3>
  <ul>
    <li>Readonly&lt;T&gt;</li>
    <li>Required&lt;T&gt;</li>
    <li>Omit&lt;T&gt;</li>
    <li>Partial&lt;T&gt;</li>
    <li>Parameters&lt;T&gt;</li>
    <li>NonNullable&lt;T&gt;</li>
    <li>ConstructorParameters&lt;T&gt;</li>
    <li>ReturnType&lt;T&gt;</li>
    <li><strong>InstanceType&lt;T&gt;</strong></li>
  </ul>
</article>


<article class="article">
  <h3>17. Creates a type that excludes null and undefined from Type:</h3>
  <ul>
    <li>Readonly&lt;T&gt;</li>
    <li>Required&lt;T&gt;</li>
    <li>Omit&lt;T&gt;</li>
    <li>Partial&lt;T&gt;</li>
    <li>Parameters&lt;T&gt;</li>
    <li><strong>NonNullable&lt;T&gt;</strong></li>
    <li>ConstructorParameters&lt;T&gt;</li>
    <li>ReturnType&lt;T&gt;</li>
    <li>InstanceType&lt;T&gt;</li>
  </ul>
</article>


<article class="article">
  <h3>18. Creates a type with all properties of T set as optional.</h3>
  <ul>
    <li>Readonly&lt;T&gt;</li>
    <li>Required&lt;T&gt;</li>
    <li>Omit&lt;T&gt;</li>
    <li><strong>Partial&lt;T&gt;</strong></li>
    <li>Parameters&lt;T&gt;</li>
    <li>NonNullable&lt;T&gt;</li>
    <li>ConstructorParameters&lt;T&gt;</li>
    <li>ReturnType&lt;T&gt;</li>
    <li>InstanceType&lt;T&gt;</li>
  </ul>
</article>


<article class="article">
  <h3>19. Creates a type with all properties of T set as read-only.</h3>
  <ul>
    <li><strong>Readonly&lt;T&gt;</strong></li>
    <li>Required&lt;T&gt;</li>
    <li>Omit&lt;T&gt;</li>
    <li>Partial&lt;T&gt;</li>
    <li>Parameters&lt;T&gt;</li>
    <li>NonNullable&lt;T&gt;</li>
    <li>ConstructorParameters&lt;T&gt;</li>
    <li>ReturnType&lt;T&gt;</li>
    <li>InstanceType&lt;T&gt;</li>
  </ul>
</article>


<article class="article">
  <h3>20. Does the interface remain in the code after compilation?</h3>
  <ul>
    <li>yes, it remains</li>
    <li><strong>no</strong></li>
    <li>by default, no, but conditions can be created to make it possible</li>
  </ul>
</article>


<article class="article">
  <h3>21. How can you check if an object belongs to a class in TS?</h3>
  <ul>
    <li>inheritenceOf</li>
    <li><strong>instanceOf</strong></li>
    <li>typeof</li>
    <li>extends</li>
  </ul>
</article>


<article class="article">
  <h3>22. How does TypeScript implement type assertions?</h3>
  <ul>
    <li>const x: number = (number) '123'</li>
    <li>const x: number = as.number '123'</li>
    <li>const x: number = '123'.asNumber</li>
    <li><strong>const x: number = &lt;number&gt; '123'</strong></li>
  </ul>
</article>


<article class="article">
  <h3>23. In TS, classes are inherited from each other using the keyword:</h3>
  <ul>
    <li><strong>extends</strong></li>
    <li>implements</li>
    <li>as</li>
    <li>inherit</li>
  </ul>
</article>


<article class="article">
  <h3>24. Is the 'extends' keyword used in generics?</h3>
  <ul>
    <li><strong>yes, it is used</strong></li>
    <li>no</li>
  </ul>
</article>


<article class="article">
  <h3>25. Is there support for classes and constructors within them in TS?</h3>
  <ul>
    <li><strong>yes, both classes and class constructors</strong></li>
    <li>only classes</li>
    <li>only class constructors</li>
    <li>no</li>
  </ul>
</article>


<article class="article">
  <h3>26. No operations are allowed on this type. Equivalent to the any type.</h3>
  <ul>
    <li>null</li>
    <li>undefined</li>
    <li>void</li>
    <li>never</li>
    <li><strong>unknown</strong></li>
  </ul>
</article>


<article class="article">
  <h3>27. Please choose the correct syntax for generics in a function. (checkbox)</h3>
  <ul>
    <li><strong>function test&lt;A&gt;(arg: A[ ]): A[ ] {...}</strong></li>
    <li>function test&lt;T&gt;(arg&lt;T&gt;): T {...}</li>
    <li>function test: T(arg: T): T {...}</li>
    <li><strong>function test&lt;T&gt;(arg: T): T {...}</strong></li>
    <li>function test&lt;T&gt;(arg&lt;T&gt;) &lt;T&gt; {...}</li>
  </ul>
</article>


<article class="article">
  <h3>28. Select the correct imports and exports in TS: (checkbox)</h3>
  <ul>
    <li><strong>export var test = 5;</strong></li>
    <li><strong>import { a, b, c} from './test.js'</strong></li>
    <li><strong>import { a as v, b, c} from './test.js'</strong></li>
    <li><strong>export default function test(){...}</strong></li>
    <li><strong>import * as a from './test.js'</strong></li>
    <li><strong>export type Test = { .... }</strong></li>
  </ul>
</article>


<article class="article">
  <h3>29. Select the correct statement:</h3>
  <ul>
    <li>Unlike ES6, in TS, any file containing import or export is considered a module.</li>
    <li><strong>Just like in ES6, in TS, any file containing import or export is considered a module.</strong></li>
    <li>In TS, any file containing import (but not export) is considered a module.</li>
    <li>In TS, any file containing export (but not import) is considered a module.</li>
  </ul>
</article>


<article class="article">
  <h3>30. Select the correct statements: (checkbox)</h3>
  <ul>
    <li><strong>Modifiers public, protected, and private cannot be applied to static fields</strong></li>
    <li><strong>Static fields of a class are not associated with specific instances of the class</strong></li>
    <li>Static fields of a class are not inherited</li>
    <li><strong>Static fields of a class can be accessed through the class constructor object</strong></li>
  </ul>
</article>


<article class="article">
  <h3>31. What does a TypeScript conditional type look like?</h3>
  <ul>
    <li><strong>T extends U ? X : Y</strong></li>
    <li>T if U ? X : Y</li>
    <li>T === U ? X : Y</li>
    <li>If T extends U Then X Else Y</li>
  </ul>
</article>


<article class="article">
  <h3>32. What does Partial&lt;T&gt; do in TypeScript?</h3>
  <ul>
    <li>Converts all properties of T into required properties</li>
    <li><strong>Converts all properties of T into optional properties</strong></li>
    <li>Converts all properties of T into read-only properties</li>
    <li>Converts all properties of T not to accept null or undefined</li>
  </ul>
</article>


<article class="article">
  <h3>33. What does the TypeScript unknown type represent?</h3>
  <ul>
    <li><strong>The type of a variable is not known to the compiler</strong></li>
    <li>The type of a variable is any object</li>
    <li>The type of a variable is any non-null object</li>
    <li>The type of a variable is any non-undefined object</li>
  </ul>
</article>


<article class="article">
  <h3>34. What is the correct syntax when an argument is optional?</h3>
  <ul>
    <li>function test(a: string) { ... }</li>
    <li>function test?(a: string) { ... }</li>
    <li><strong>function test(a?: string) { ... }</strong></li>
    <li>function test(a:? string) { ... }</li>
  </ul>
</article>


<article class="article">
  <h3>35. What keyword is used in the implementation of a generic constraint?</h3>
  <ul>
    <li>instance</li>
    <li>implements</li>
    <li><strong>extends</strong></li>
    <li>as</li>
    <li>inheritance</li>
  </ul>
</article>


<article class="article">
  <h3>36. What type of function corresponds to the call test('5')? (checkbox)</h3>
  <ul>
    <li>function test(val: number): number</li>
    <li>function test(val: number, t: string): number</li>
    <li><strong>function test(val: string): number</strong></li>
    <li>function test(val: number, t?: string): number</li>
    <li><strong>function test(val: string, t?: string): number</strong></li>
  </ul>
</article>


<article class="article">
  <h3>37. What utility types exist in TS? (checkbox)</h3>
  <ul>
    <li><strong>Omit</strong></li>
    <li><strong>ReturnType</strong></li>
    <li><strong>PartialType</strong></li>
    <li><strong>InstanceType</strong></li>
    <li><strong>Required</strong></li>
    <li><strong>Pick</strong></li>
    <li><strong>Extract</strong></li>
    <li><strong>Exclude</strong></li>
    <li>This</li>
  </ul>
</article>


<article class="article">
  <h3>38. Which keyword is used to declare a namespace?</h3>
  <ul>
    <li>export</li>
    <li>constructon</li>
    <li>name</li>
    <li>set</li>
    <li><strong>namespace</strong></li>
    <li>TS does not have namespaces</li>
  </ul>
</article>


<article class="article">
  <h3>39. Which modifiers can be applied during type binding? (checkbox)</h3>
  <ul>
    <li>readonly and ?</li>
    <li>, and -</li>
    <li>+ and |</li>
    <li>& and &&</li>
    <li><strong>||</strong></li>
    <li><strong>! and !!</strong></li>
  </ul>
</article>


<article class="article">
  <h3>40. Which operator lets us validate that the type of an expression matches some type, without changing the resulting type of that expression?</h3>
  <ul>
    <li>reassures</li>
    <li>satisfies</li>
    <li><strong>typeof</strong></li>
    <li>no correct answer</li>
  </ul>
</article>


<article class="article">
  <h3>41. Which utility type can be used to represent all subsets of a given type?</h3>
  <ul>
    <li><strong>Partial</strong></li>
    <li>Readonly</li>
    <li>Record</li>
    <li>Omit</li>
  </ul>
</article>
