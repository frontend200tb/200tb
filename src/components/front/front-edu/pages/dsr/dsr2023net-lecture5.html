<a href="#" id="edu-dsr">назад</a>

<h1>2023-10-30 DSR .NET School 2023 Lecture #5 Infrastructure</h1>

<h2>Лекция 5. Инфраструктура</h2>

<ul>
  <li>
    <p>Добрый день. Меня видно? Слышно? Всем добрый вечер. Рад вас снова видеть. Давайте начнем сегоднюшнюю лекцию. Сегодня будет достаточно простая лекция. Скорее для отдыха небольшого. Поговорим об инфраструктуре. На прошлой лекции мы поговорили про веб приложения в целом. Из чего оно состоит. И разобрали игровую архитектуру. До того момента как мы перейдем непосредственно к программированию, давайте немножко поговорим о том, что нам пригодится для работы. Что пригодится для разработки систем. Про такую инфраструктуру сегодня поговорим. О чем сегодня пойдет речь.</p>
  </li>

  <li>
    <h3>О чем будет эта лекция</h3>
    <p>Visual Studio
    <br>Git / GitFlow / GitHub
    <br>Docker
    <br>RabbitMQ
    <br>Redis
    <br>OpenAPI / Swagger
    <br>Fiddler
    <br>Postman
    <br>DocFX
    <br>DBeaver
    <br>Installers
    </p>
  </li>

  <li>Сегодня мы поговорим немножко про Visual Studio. Поговорим в целом про IDE. А Visual Studio это одна из IDE. Скрины у меня сделаны про Visual Studio, будем говорить на базе нее. У кого есть Rider, умеете ей пользоваться, кто привык - никакой разницы, можете искать аналогию и искать похожее у себя. Там 100% это есть. Поговорим про Git, что такое GitFlow. Чем отличается от гита, от гитхаба. Docker, RabbitMQ немножко поподробней. Redis и тулзы, которые нам пригодятся для работы. В частности OpenAPI и инструмент Swager, который позволяет этот API создавать.</li> 
  
  <li>В целом, вкратце мы про это поговорим. И я приготовил вам небольшой кусочек по RabbitMQ и по Redis, чтобы можно было посмотреть вживую. В конце лекции посмотрим на кусок кода и посмотрим как эта штука работает. Потом я исходный код выложу в репозиторий. Ссылку выложу в наш телеграм. Можно будет скачать и смотреть. В будущем в этот же репозиторий гитхаба буду выкладывать новые лекции и потом там будем делать практику.</li>

  <li>Давайте приступим. Я сегодя постараюсь вас долго не задерживать. Потому что тема, я считаю, достаточно легкая, обзорная. Надо просто на нее посмотреть. И дальше уже чисто попробовать руками.</li>

  <li>
    <h2>VS - Установка</h2>
  </li>

  <li>Итак. Visual Studio. Я думал что бы вам рассказать про Visual Studio. И первое дело, что я рекомендую сделать, это установка. Сначала скачайте инсталятор. Сейчас все делается через инсталятор. Обязательно отметьте ASPNET and web development с ним мы будем работать. А для удовольствия, для себя можете отметить и поставить .NET desktop development, Mobile development with .NET и Universal Windows Platform development</li>

  <li>После того как выберете пакет ASPNET and web development, зайдите в Individual components и поставьте себе нужные пакеты. И обязательно зайдите на Language packs и поставьте English. Я ничего не имею против переведенных средств, но в этом случае вы будете работать именно с переводом. Переведено достаточно неплохо, но вам в голове придется постоянно делать обратный переворот. Искать слово build вместо сборка или сборка вместо build. Ну и надо с командой говорить на одном языке. Сразу выберете универсальный, который для программирования main, и его используйте.</li>

  <li>После откройте Installation locations куда поставить. Нажимаете установку и ждете долго. Visual Studio может долго скачиваться. Долго устанавливаться. На слабых компьютерах по полдня.</li>

  <li>Для райдера установите все по умолчанию .Он все нормально сделает. И поставьте английский язык. Интерфейс с английским языком внутри.</li>

  <li>
    <h2>VS - Проекты, решения</h2>
    <p>Что у нас есть в Visual Studio. С чего начинается наш веб проект. Вообще есть проект и решение. В чем отличие. Когда мы создаем новый проект Create a new project, мы можем выбрать много темплейтов, который нам нужен. Что из себя будет представлять проект. Справа у нас есть Solution Explorer. И есть несколько проектов. Solution означает сборка. То есть несколько проектов, объединенных в кучу. Внутри Solution проекты. Проект это непосредственно си шарп фолдер и он что-то делает.</p>
    <p>Как он будет в папке лежать? В то место куда мы это положили. У меня будет папка моего solution и внутри несколько вложенных папок. Каждая папка это проект, а файл .sln это solution, в котором будут ссылки на них. Можете посмотреть, там обычный xml с кучей информации, как microsoft любит. В нем можно разобраться и даже руками его делать.</p>
  </li>

  <li>Внутри проекта будет следующая структура. Папки bin и obj для сборок. Сюда будут украдываться сборки. Объектный файл для сборки и для них исполняемый. Для каждой платформы будут создаваться свои папки со своим пакетом сборки. По сути там будет лежать ваше приложение. Файлы с расширением .cs это код на языке си шарп. Бегать по тому из чего состоитVisual Studio. Смотреть окошки, как я делал в прошлом году, смысла нет.</li>

  <li>
    <h2>Что однозначно пригодится</h2>
    <p>Solution and code navigation</p>
    <p>Output and error logs</p>
    <p>Breakpoints</p>
    <p>Watches</p>
    <p>NuGet</p>
    <p>Terminal</p>
    <p>Package Manager</p>
    <p>Test Explorer</p>
    <p>Auto documentation markup</p>
    <p>Refactoring tools</p>
    <p>Publication tools</p>
  </li>

  <li>Давайте поговорим на что обратить внимание и что искать в любой IDE. Во-первых изучите как отображается приложение, проекты. Что такое solution как им управлять. Где кнопки build и compile. Clear и так далее. Научитесь навигировать по коду. Это не только выбор в дереве solution файла - два раза щелкнуть, открыть. Можно навигироваться по коду через гиперссылки, которые автоматически строятся внутри кода уже. Если нажать ctrl и навести на что-то - можно прыгнуть вглубь или наверх. Обязательно изучите потому что это сильно помогает.</li>

  <li>Вам обязательно понадобятся Output and error logs. Когда вы будете собирать и у вас неполучится, читайте сообщения об ошибках. Там будет информация которая позволит вам разобраться где ошибка и ее быстро исправить. output покажет как ваше приложение собралось и куда оно собралось.</li>

  <li>Breakpoints это такие точки. Вы можете в коде поставить напротив строки. Приложение запускаете, выполняете и когда программа долшла до этой строки - все останавливается. Вы можете посмотреть содержимое переменных, пройти по шагам, выполнить дебаг. Breakpoints бывают безусловные, остановка на нужной строке кода. Или условные , например, если переменная больше 10.</li>

  <li>Watches это набор утилит, которые позволяют посмотреть и отслеживать переменные. Сделать так чтобы вот эта переменная отслеживалась. И дальше идете по шагам и смотрите как она увеличивается или уменьшается. Они бывают постоянные, закрепляемые - просто гвоздиком прижали. Они где-то на коде будут висеть. Или остановились и сделали калькуляцию.</li>

  <li>NuGet для си шарпа это тоже самое, что npm для мира javascript. Это технология подгрузки готовых билиотек и подключение их к вашему проекту. Самостоятельно вы будете делать какую-то чать, а львиную часть настроек будет делать за вас NuGet пакеты. Даже просто когда вы создаете проект в студии, у вас там куча NuGet пакетов от microsoft уже подключено. Например, нужно подключить slager и у вас появилась целая функциональность. Настроили - все работает. Можете писать самостоятельно NuGet пакеты. Позже у нас будет целый слайдик. Мы про это специально поговорим. Они бывают бесплатные и платные. Вы можете купить набор компонент. Подключить их через NuGet. Прописать в код лицензию. И получить хорошую функциональность, которую самостоятельно вы бы очень долго писали.</li>

  <li>Termanal. Сейчас через Terminal работают много.Через него работают с гитом, те которые профессионалы. Поэтому найдите где у вас находится терминал.</li>

  <li>Package Manager. Это встроенный внутрь Visual Studio powershell. Он позиционируется на определенную папку. И позволяет выполнять команды в указанном месте. С помощью Package Manager мы будем создавать миграции. Как в райдере не скажу, возможно придется пользоваться обычными командами из терминала.</li>

  <li>Если будете писать тесты, найдите где находится Tests Explorer. Изучите как он запускается. Что это такое. Сегодня для Visual Studio я вам покажу.</li>

  <li>Auto documentation markup. Полезная вещь. Надо изучить. Ничего сложного нет. Я сейчас на коде покажу что это такое и зачем.</li>

  <li>Рекомендую изучить refactoring. Если кто-то давно работает с Visual Studio он наверняка себе ставил решарпер - самый популярный extension для того чтобы выполнять рефакторинг. Тот кто работает с Rider у них решарпер уже внутри. В Visual Studio даже у community version достаточно неплохой набор рефакторинг утилит. Можно пользоваться. Я часто пользуюсь самой популярной какая есть это rename. Очень активно использую.</li>

  <li>Publication tool. После того как приложение написали, его необходимо опубликовать. На самом деле, можно все это публиковать через терминал. В обычных командах dotnet publish и дальше параметры. Но зачастую, можно настроить несколько вариантов публикации. Например публикация в папку или сервер. Для этого есть определенные тулы, которые при помощи конфигурационных файлов за вас эту работу будут делать. Найдите, посмотрите как пользоваться.</li>

  <li>90% того что вам потребуется от IDE здесь написано.</li>

  <li>
    <h2>Автодокументирование</h2>
    <pre>
    /// &lt;summary&gt;
    /// Constructor for matrix
    /// &lt;/summary&gt;
    /// &lt;param name="rowCount"&gt;Count of rows&lt;/param&gt;
    /// &lt;param name="colCount"&gt;Count of columns&lt;/param&gt;

    public Matrix(int rowCount, int colCount)
    {
      this.rowCount = rowCount;
      this.colCount = colCount;

      if (rowCount &lt;= 0 || colCount &lt;= 0)
        throw new ArgumentException("rowCount or colCount must be greater than zero");

      data = new int[rowCount, colCount];
    }

    static void Main(string[] args)
    {
      var mtrx = new Matrix(5, 5);
      mtrx.Fill(1);
      mtrx.Print();
    }
    </pre>
  </li>

  <li>Когда вы пишете любой класс. Вы можете поставить три слеша и у вас автоматически будет собран такой блок. То есть summary и для всех параметров добавится строчка param name. Если в класс добавить лишний параметр то уже Visual Studio будет ругаться и при помощи быстроко действия этот параметр можно добавить в автодокументацию. Для таких комментариев целая куча утилит работает, которые помогают вам писать хороший код. Во-первых это помогает непосредственно вам. Если у вас есть комментарий, то потом вы будете видеть подсказки при наведении на параметры класса. Если вы будете красиво и правильно описывать свои коды, ваш код будет самодокументируемым. И для того чтобы понять его не надо лезть внутрь, в документацию. Хорошие короткие комментарии вам помогут при использовании классов. На базе этих документируемых тегов, можно настроить работу слагера. И у вас будет автоматически генерироваться более хороша API документация. Можно настроить работу с автодокументированием кода и созданием документации по коду при помощи утилиты DocFX. Вы научитесь этим пользоваться. У вас будет привычка, через какое-то время вы без этого уже не сможете.</li>

  <li>
    <h2>Рефакторинг</h2>
  </li>
  
  <li>
    <h3>Rename</h3>
    <p>- Установить курсор на переименовываемый элемент</p>
    <p>- Нажать Ctrl+R+R</p>
    <p>- Аккуратно ввести новое имя</p>
    <p>- Нажать Enter</p>
  </li>

  <li>
    <h3>Other</h3>
    <p>- Установить курсор в нужное место или выделить нужный текст</p>
    <p>- Выбрать "Quick Action and Refactorings"</p>
    <p>- Выбрать нужное действие</p>
  </li>

  <li>Рефакторинг это быстрая правка. В коде что-то надо быстро поменять. Например, нашли ошибку. У вас есть переменная, которую вы уже в 50 местах используете. И вы замечаете в имени переменной грамматическую ошибку. Как поправить. Первое это взять поиском все найти и переправить. Глобальный поиск по файлу. Заменить одно слово на другое. Никогда так не делал. Кучу проблем огребете. Если слово короткое и неуникальное. Ладно еще если код поменяете, а если поменяются конфигурационные файлы, потом в жизни не найдете. Поэтому лучше так не делать. Или делать очень аккуратно. Можно найти и потом по каждой штучке руками и глазами пробежать - надо менять или не надо.</li>

  <li>А можно воспользоваться функцией рефакторинга. Рефакторинга достаточно много. В Visual Studio при наведении мышкой можно увидеть Quick Actions and Refactorings Ctrl+ю или Rename Ctrl+R+R или Remove and Sort Usings Ctrl+R+G. Ctrl+R+R нажали и появится окошко, которое позволит быстренько все поменять. Прямо в коде меняете название, исправляете ошибку, нажимаете OK. Studio пробегает по всему коду, находит именно эту переменную и ее поменяет. Ничего лишнего не зацепится.</li>

  <li>Есть еще какие вещи. У вас есть кусок кода, который вы хотели бы превратить в функцию. Можно сделать руками. Выделить и сказать хочу сделать extract метод. Выбираете какой. Нажимаете Enter и везде где у вас есть такой кусок кода будет подставлена функция. Локальные переменные, привести типы... На самом деле сейчас рефакторинг очень сильно помогает. Даже помогает код писать проще. Например, два вопросика поставить вместо if.</li>

  <li>В каждой IDE есть свои горячие клавиши. И их можно настроить. Почему с Visual Studio на Rider трудно перепрыгивать? Разный набор ключевых слов, горячих клавиш. Пока привыкнешь к этому. Потом нормально. Можно посмотреть "функция рефакторинга в Visual Studio" или "функция рефакторинга в Rider". Заведите себе маленький проект. Я использую Rename переменной, функции, неймспейса.</li>

  <li>
    <h2>Отладка</h2>
    <p>Для отладки можно использовать</p>
    <p>- Терпение, представление "как оно должно быть вообще"</p>
    <p>- Точки останова: простые или с условиями</p>
    <p>Инструменты для вычисления значений переменных:
    <br>- Хинты
    <br>- Watches (autos, locals, quick watch, pinned values)</p>
    <p>- Логи</p>
  </li>

  <li>Чтобы писать код без багов, вам придется пользоваться отладкой. Это проверка вашего алгоритма, идеи которую вы заложили в код на истинность. При этом никто не говорит что наш алгоритм верный и мы учли вообще все условия. Например, алгоритм может быть четким, а систему запускаете - может валиться. Почему? Потоки, например, не учли. Или несколько процессов лезут в одну точку. Те же потоки не синхронизированы. Надо решать как такие вещи преодолеть. Этот процесс называется отладка. Что для отладки использовать? Самое главное для отладки это не инструмент, а голова. Отладка это сравнение алгоритма который реализован в коде с алгоритмом который был в голове.</li>

  <li>Если вы пытаетесь изучить другой код. В этом случае отладка это способ изучения данног кода. Некоторые так пишут код, что без отладки не понимаешь вообще что он делает. Особенно если это legacy. Вы должны представлять что программа должна делать, где какие переменные. И должны сравнить - а то что выполняется физически оно должно так выполняться? И надо делать выводы.</li>

  <li>Терпение. Нельзя запустить отладку и сразу сказать - " а вот где ошибка". Простенькую можно быстро найти, а серьезную можно целый день искать. У меня был случай, очень долго искал ошибку. Часа 4 искал ошибку. Была ошибка в алгоритме. Я открыл рабочую директорию и копию файла из другой папки. Я изменения вносил в этот файл, который к проекту не прицеплен был. И чтобы я ни делал в этом файле. Что не вношу - ошибка не исчезает. Через 4 часа я догадался посмотреть а там ли я правлю. Оказалось что не там. Вернулся в нужный файл и поправил в течение 5 минут. Так что терпение и уверен что вы справитесь.</li>

  <li>Точки остановки breakpoints бывают просто безусловные. Поставил в коде. Программа дошла до этой строчки, сидите и изучайте. Или с условием, правой кнопкой на брейкпоинт и дальше настраиваете что хотите.</li>

  <li>Еще вам помогут инструменты для вычисления значений. При наведении мышкой можно сразу посмотреть какое значение у переменной, можно посмотреть хинты и wathes. Это инструментальные средства.</li>

  <li>Кроме инструментальных средств есть еще Логи. Простенькую программу, алгоритм вы можете проверить с помощью студии. А что-то серьезное, особенно если распределенное вы можете посмотреть единственным способом - это логи. Поэтому в серьезных системах не выкидывайте их сразу. Пытайтесь их правильно писать, подробно, в нужном виде. Если надо будет разобраться почему ваша программа по кусочкам работает а в целом нет, запустите систему логирования и все увидете. Это не только для отладки. Логи еще очен сильно помогают для аудита. В крупных системах систему логирования стараются сделать так чтобы ни байта не было потеряно. Много информации о безопасности, кто нас взламывает. По логам можно посмотреть метрику. Но смотрите чтобы в логи не попадали никакие пароли и закрытая информация. За это безопасники могут настучать по голове.</li>

  <li>
    <h2>Тестирование</h2>
    <p>Что необходимо для написания автоматизированного теста:</p>
    <p>- Код, который можно протестировать</p>
    <p>- Четкое исходное задание и правильный ответ к нему</p>
    <p>- Набор тестовых данных</p>
    <p>- Программные заглушки или имитаторы</p>
    <p>Тест должен:</p>
    <p>- Иметь правильное название</p>
    <p>- Проверять только что-то одно</p>
    <p>- Быть максимально простым и линейным</p>
  </li>

  <li>Мы все написали, отладили теперь надо тестировать. У нас будет одна практика про тестирование. Маленький тест напишем на практическом занятии. Там будет более подробно. Для тестов в коде пишут юнит и интеграционные тесты. Unit тесты тестируют кусочек. В интеграционных обычно используют Docker, который поднимает образ готовой системы. И тестируют всю систему. Тесты помогают не только убедиться что в будущем ваше приложение не сломается, они еще помогают протестировать нагрузку. Если у вас есть на это время, если клиент и руководство на это готовы, то старайтесь делать тесты. На практике, к сожалению, заказчики тесты выкидывают, по причине что они достаточно тяжело и дорого пишутся. Тесты простые, но их достаточно много и поэтому на них тратится много времени. Поэтому заказчик говорит "ну тесты нам сейчас не нужны, лучше на фичи добавьте, а там посмотрим". Но это смотря для кого. Для серьезных систем: банковских систем, медицинских систем, систем принятия решений, самолетные... Тесты здесь это must have. Их лучше не упускать. Поленитесь написать тест и самолет упадет. Цена ошибки очень высокая.</li>

  <li>В IDE или где-нибудь вам главное научиться их писать. Тест должен иметь правильное название. Делать их очень короткими. Не надо одним тестом все проверять. Как роль создается, изменяется, удаляется, назначается, есть ли у пользователя полномочия для этой роли. Это все должны быть разные тесты. Я не тестировщик, название всех тестов не знаю. Я пишу unit тесты, интеграционные тесты и нагрузочные иногда. Это для программиста нормально.</li>
  
  <li>Архитектурный тест не знаю что это такое. Если вы написали правильную архитектуру. То по какой причине она может стать не правильной?</li>

  <li>
    <h2>Публикация</h2>
    <p>- Выбрать Publish в контекстном меню для проекта</p>
    <p>- Создать профиль публикации</p>
    <p>- Ввести требуемые параметры</p>
    <p>- Указать место хранения сборки</p>
    <p>- Выполнить сборку и публикацию проекта</p>
    <p>- Проверить результат в месте назначения (например, в директории)</p>
  </li>

  <li>Публикацию также можно выполнить при помощи CLI команд dotnet, например
    <code>dotnet publish -p:PublishProfile=FolderProfile</code>
  </li>

  <li>Публикация это важный процесс. Это превращение вашего проекта в исполняемый модуль. Для x64 это будет одна сборка. Для x86 другая сборка. Процесс превращения исходных кодов во что-то другое называется публикацией. В студии если вы используете профиль, то можете сделать несколько вариантов - для windows и для linux. Потом можно создать сборку из студии или вызвав команду, где указать нужный profile.</li>

  <li>
    <h2>NuGet</h2>
    <p>Если в студии открыть NuGet, то мы увидем такую формочку. Что у нас здесь есть? У нас есть репозиторий. NuGet можно поднять локально, он может быть приватный. Вы можете на сервере или локально на компьютере создать папочку и туда все пакеты складывать. NuGet это собраный кусочек вашего пакета, с определенной версией, с определенными правилами. Который можно просто подключить и пользоваться. Например, можете себе сделать библиотечку математических утилит. И вы их между своими проектами не копируете а просто подключаете из локального Nuget репозитория.</p>
  </li>

  <li>Создать Nuget пакет просто. Вы можете любое приложение в Nuget превратить с помощью dotnet команд. nuget.org это репозиторий, место в интернете куда эти нугеты складываются. Вы можете там зарегистрировать свой аккаунт, он бесплатный, и туда публиковать. Ничего в этом сложного нет.</li>

  <li>Что из себя nuget представляет? У вас есть три кнопки Browse, Installed и Updates. Поле поиска, в которое можно ввести название пакета и найти его. Выбираем нужный пакет из найденных. Щелкаем на него и говорим установить. Пакет будет установлен в ваше приложение или в список solution. Альтернативный способ - открыть файл c.proj и руками вписать то что надо. Это строчки xml внутри c.proj.</li>

  <li>Вкладка Installed покажет то что у вас есть и вы сможете это обновить, отключить, удалить. Вкладка Update нужна если поменяется версия, то вам предложат их обновить. Ничего сложного нет.</li>

  <li>
    <h2>Extensions</h2>
    <p>Откроем окошко Manage Extensions. Самый популярный extension это ReSharper. Обратите внимание что у него стоит значек Trial это означает что он должен быть куплен. Тут большое количество бесплатных extensions, но есть и платные. Чтобы купить платные extensions надо открыть вкладку Online и выбрать Visual Studio Marketplace. На практике я никакими extensions не пользуюсь.</p>
  </li>

  <li>Про IDE больше разговаривать нечего. Надо просто взять и попробовать. Ничего сложного нет. Предлагаю идти дальше.</li>

  <li>
    <h2>GIT - шпаргалка</h2>
    <p>https://git-scm.com/</p>
    <pre>
    Create a Repository
    git init [project_name] - create a new lokal repository
    git clone my_url - download from an existing repository
    </pre>
  </li>

  <li>Вторая важная вещь, которая вам потребуется, это GIT. Сейчас GIT это must have. Его все используют. Рекомендую с ним разобраться, почитать. Найдите обучающий курс по гиту и пройдите его, желательно с практикой.</li>

  <li>Что такое git? Это программа, написанная на плюсах, которая позволяет работать с кодом. У него есть внутренний репозиторий. Он туда все складывает - исходные коды. И сохраняет все что вы делаете. В любой момент вы можете сделать слепок своего кода. И потом в любой момент к нему вернуться. Даже одному человеку с ним работать удобно. Можно исправлять ошибки, делать эксперименты в соседней ветке. Поддержка кода без гита сложно делается. Заказчику что-то отдали. Пока вы новую фичу делаете, он со старым кодом работает.</li>

  <li>Working directory -> add -> Staging (index) -> commit -> Local repository -> push -> Remote repository</li>

  <li>Как работает git. У нас есть удаленный репозиторий и есть рабочая папка с проектом. Когда мы что-то написали в рабочем проекте, подключаем эту папку к гиту. И гит начинает следить за файлами в этой папке. Git это консольная программа и управляется при помощи консольных команд. И если есть удобные средства , то это все костыли для того чтобы удобно работать с командой.</li>

  <li>
    <h2>GIT FLOW</h2>
    <p>Когда несколько программистов работают а одном проекте, то появляется хаос небольшой. Чтобы этот хаос уменьшить придумали git flow это такой поток. Это просто программисты договорились как они будут работать с гитом. Качаем себе репозиторий. Теперь у нас есть ветка Master (или Main), в которой есть коммиты. Мы создаем ветку develop от последнего комита и будем в этой ветке всю программу выращивать. Это основной ствол нашего приложения. Несколько программистов могут делать ветки от ветки develop и делать в них свои фичи и никому не мешать. Все работают параллельно. Кто закончил свою работу, он ее сливает с веткой develop.</p>
  </li>

  <li>Пока мы в ветке разработки develop что то делали, позвонил клиент и сказал что нашел ошибку в основном приложении на ветке master. Мы от ветки master делаем hotfix ветку, устраняем ошибку, и сливаем ее опять на master.</li>

  <li>Если работать в команде, строго рекомендую договориться о git flow и не нарушать.</li>

  <li>
    <h2>GIT - инструментарий</h2>
    <p>- Консоль</p>
    <p>- Встроенный клиент IDE (VisualStudio, Rider, VSCode, Idea, WebStorm)</p>
    <p>- Специализированные клиенты (TortoiseGit, Fork, SourseTree, GitHub Desktop</p>
  </li>

  <li>Cool программисты используют console.</li>

  <li>
    <h2>GitHub/BitBucket/GitLab</h2>
    <p>GitHub pricing</p>
    <p>- Free: unlimited public and private repositories, unlimited number of collaborators, 500MB of storage;</p>
    <p>- Team($4/month): 2GB of repositories and all features of the free plan</p>
    <p>- Enterprise ($12/month): 50GB of storage, advanced auditing, and SAML, all features of the Team plan.</p>
    <p>- GitHub One (the custom pricing): the ultimate plan giving access to 24/7 official support, enchanced security, and continuous learning bonuses.</p>
  </li>

  <li>GitHub/BitBucket/GitLab у них есть версии бесплатные. Есть вся инфраструктура чтобы работать с кодом. Помимо гита там есть CI/CD. В gitlab это называется merge reauest, в github это pull request. Когда вы сделали пачку изменений, то вы делаете запрос на слияние изменений с основной веткой. И на основной ветке появляется промежуточное состояние - такой-то программист хочет в такую-то ветку иделать изменения. Человек, у которого есть соответствующие права, просмотрит эти изменения и применит. Синьер перед тем как это применить просматривает код, смотрит что изменилось, если надо то задает вопросы. Код ревью может делать и группа программистов. Он выполняет merge и все изменения появляются в основной ветке.</li>

  <li>
    <h2>Docker</h2>
    <p>https://www.docker.com/</p>
    <p>Docker host</p>
    <p>Docker daemon</p>
    <p>Docker client</p>
    <p>Docker image</p>
    <p>Docker container</p>
    <p>Docker registry</p>
    <p>Dockerfile</p>
  </li>

  <li>Docker сейчас очень популярный инструмент. Это одно из средств виртуализации, которое серьезно повысило удобство разработки сложных систем. В частности, в использовании всяких элементов. Сегодня покажу как это делается. Что такое docker? Это система виртуализации, которая ставится на вашу машину и позволяет запустить сервис внутри вашей машины. Например, если вам нужен SQL сервер, вы можете при помощи docker поставить себе SQL сервер. Мы этим докером будем пользоваться для того чтобы делать микросервисы.</li>

  <li>Что из себя представляет docker архитектурно. У нас есть host, который ставится внутрь системы. Которая работает с контейнерами, которые построены на базе имеджей.</li>

  <li>
    <h2>Docker image</h2>
    <p>Это закрытый шаблон и в него влезть никак нельзя. Только при помощи специального докер файла, который делает докер образ. Мы можем собирать наше приложение как бы из слоев. Например возьмем за основу сервер Debian, на него положим Python. И сверху положим наше приложение.</p>
  </li>

  <li>
    <h2>Docker container</h2>
    <p>Если к докер образу сверху добавить слой для записи, то получится докер контейнер.</p>
  </li>

  <li>
    <h2>Docker commands</h2>
  </li>

  <li>Как работает dicker? Как и git. Он тоже управляется консолью. Есть приложение docker desktop для учебных целей. В open source проектах он бесплатный, для комерческих - вы денежку платите. Лучше поставить docker и работать через CLI.</li>

  <li>
    <h2>Dockerfile</h2>
    <p>Это файл, на основании которого, все делается.</p>
  </li>

  <li>
    <h2>Docker compose</h2>
    <p>Файл docker-compose.yml делается на синтаксисе yaml. Здесь делаются глобальные настройки.</p>
    <p>docker-compose.override.yml. Здесь делается тонкая настройка.</p>
  </li>

  <li>Docker стал таким полезным потому что позволяет запустить несколько контейнеров и связать их между собой. С докером мы будем работать. Докер - часть практики. С докером надо будет работать на курсовой. Поэтому мы на этом остановимся. Он не слишком сложный в теории. Кому интересней поглубже посмотреть найдите какой-нибудь курс или почитайте документацию. Просто документации обычно много.</li>

  <li>
    <h2>MessageQueue</h2>
    <p>RabbitMQ</p>
    <p>ZeroMQ</p>
    <p>Azure Service Bus</p>
    <p>Amazon Simple Queue Service</p>
    <p>Yandex Message Queue</p>
    <p>и т.д.</p>
  </li>

  <li>MessageQueue это та часть которая позволяла бы работать с посылками. Мы несколько микросервисов подключаем в единой шине. И взаимодействие наших микросервисов происходит не напрямую друг с другом а через эту шину.</li>

  <li>
    <h2>MessageQueue - RabbitMQ</h2>
    <p>https://www.rabbitmq.com/</p>
    <h3>Установка Docker.RabbitMQ</h3>
    <p>docker pull rabbitmq:3-management</p>
    <p>docker run --restart=always -d --name some-rabbit -p 5672:5672 -p 5673:5673 -p 15672:15672 rabbitmq:3-management</p>
  </li>

  <li>
    <h2>Кэширование - Концепция</h2>
    <p>Если у нас есть набор тяжелых запросов к базе данных, который редко меняется. Его разумно не каждый раз вычислять. А вычислить один раз и положить результат в определенное место. Когда он снова понадобиться, то не вычислять его заново а сразу вернуть готовый результат. Если не понадобится, то потом можно его удалить. Кэшировать надо не все что попало. Чаще всего кэш идет на read. Если вы будете делать кэш на быстро изменяемые данные, то смысла в нем нет, он наоборот понесет только зло. Вы помимо того что будете возвращать данные, будете еще забивать информацию для кэша</p>
  </li>

  <li>Концепция кэширования следующая. Мы из приложения сперва лезем в кэш. Если в кэше есть то что нам надо то мы это берем и возвращаем. Если в кэше этого нет то наше приложение лезет в базу данных збирает это, кэширует и возвращает. Первый запрос будет выполнятся долго. А второй запрос уже быстрее.</li>

  <li>
    <h2>Кэширование - Средства</h2>
    <p>Memcached (http://memcaced.org/)</p>
    <p>Redis (http:/redis.io/)</p>
    <p>MemoryCache</p>
  </li>

  <li>В кэше должна храниться информация которую не критично удалить. Нельзя хранить информацию, которая не попала в базу данных. Например, информацию о платеже положить в кэш, а потом из кэша записать в базу данных это очень плохая идея. Надо сначала записать в базу данных. Убедиться что все записано. Достать и положить в кэш. И уже кэшом пользоваться это хорошая идея. Кэш это такая система которая не гарантирует сохранность данных совсем.</li>

  <li>
    <h2>Кэширование - Redis</h2>
    <p>htto://redis.io/</p>
    <p>Установка Docker.Redis</p>
    <p>docker pull redis</p>
    <p>docker run --restart=always -d -p 6379:6379 redis</p>
  </li>

  <li>На этом сайте можете про него почитать. Делаем docker pull redis. Последняя версия. Делаем docker run redis на таком-то порту. При помощи docker у нас redis установлен и можно с ним работать. В чем у docker большой плюс. И rabbit и redis ысе установили. Если в данный момент rabbit не нужен, я его просто остановил и у меня ресурсы освободились.</li>

  <li>
    <h2>OpenAPI / Swagger</h2>
    <p>OpenAPI Specification</p>
    <p>http://swagger.io/resources/open-api/</p>
    <p>OpenApi Editor</p>
    <p>http://editor.swagger.io/?_ga=2.8124978.1295150636.1636210095-812025047.1633122614</p>
  </li>

  <li>Swagger сейчас must have для API. Сейчас он называется OpenAPI. Если вы по спецификации опишите API, то даже не имея API, мобильный разработчик сможет с ним работать. OpenAPI это стандарт по которому надо определить какие у нас есть эндпоинты, какие есть модели, с чем они связаны, что может возвратить, какие ошибки и т.д. Все что надо знать чтобы с нашим API работать описывает API спецификация. Есть редактор Editor swagger. Вы можете им воспользоваться и с нуля написать. Можете через docker этот редактор себе стянуть. И он будет у вас локально работать, не в интернете.</li>

  <li>Swager (раньше назывался swagger, а сейчас - OpenAPI) это инструмент для автоматического формирования спецификации. Мы будем работать со swagger для того чтобы создать спецификацию внутри нашего приложения. Практического, которое будем делать на практике, и курсового проекта. Кроме того, он еще используется для тестирования и для отладки. Сильно повышает возможность тестирования и возможность разработки.</li>

  <li>
    <p>http://app.swaggerhub.com/</p>
    <p>Как это выглядит. У нас есть файлик. Он должен быть описан в yaml или json. В нем есть методы post, get и т.д. Это tool, для того чтобы изучить API и с ним работать. В студии мы будем все делать посредством пакета Swashbuckle.AspNetCore. Swagger мы будем настраивать. Почитайте про него. Полезная вещь.</p>
  </li>

  <li>
    <h2>DocFX</h2>
    <p>http://dotnet.github.io/docfx/</p>
  </li>

  <li>DocFX это утилита microsoft. Сейчас она встроена в дотнет. Ее можно будет скачать при помощи дотнета. Это система для получения документации по коду, модулю. Может быть кому-то для учебы понадобится. Разберитесь как эта система делается. Он пробегает по вашему коду, собирает всю информацию. И это делается автоматом. На выходе будет сайт с документацией, либо можно pdf сделать и преподавателю показать.</li>

  <li>
    <h2>Postman</h2>
    <p>http://www.postman.com/</p>
  </li>

  <li>Postman наверно вы все и так знаете. Это инструмент, который позволяет отправлять запросы на API. И это основной инструмент для тестирования API. Он может послать любой запрос. Крайне полезная вещь. Можно ввести заголовки, боди, отправить запрос, получить результат. Может вести историю.</li>

  <li>
    <h2>Fiddler</h2>
    <p>https://www.telerik.com/fiddler</p>
  </li>

  <li>Fiddler редко сейчас я его вижу уже. Он позволял перехватить траффик между браузером и локальным webapi приложением. Позволял получать все запросы, которые шли через наш компьютер, через браузер. Когда-то мне очень сильно помогал. Можно было запустить сайт, щелкнуть какую-нибудь команду и посмотреть какие запросы и ответы пришли с сервера. Только надо их отсортировать. Для этого есть тулзы, фильтры.</li>

  <li>
    <h2>DBeaver</h2>
    <p>https://dbeaver.io/</p>
  </li>

  <li>DBeaver это пока самый удобный и самый легкий инструмент для работы с базой данных. Это opensource. Есть платная и бесплатная версия. Платная версия будет работать с NoSQL. Мы можем делать SQLLite, Postgress всевозможные базы данных. Это единый инструмент для того, чтобы работать с базами данных. В Visual Studio такого инструмента нет. В Rider есть свой.</li>

  <li>
    <h2>Инсталляторы для Windows</h2>
    <p>WiX</p>
    <p>Advanced Installer</p>
    <p>InnoSetup</p>
    <p>InstallShield</p>
    <p>и т.д.</p>
  </li>

  <li>WiX бесплатный от microsoft. Платные Advanced Installer, InnoSetup, InstallShield. Сейчас инсталляторы редко используют. Сейчас используют action при помощи CI/CD на gitlab или github git репозитории. Но иногда клиенты требуют инсталляторы. Это уже на самостоятельное изучение. Мы с этим работать не будем.</li>

  <li>
    <h2>Вопросы?</h2>
    <p>Я вам покажу кусочек кода. Хотел вам показать Cash, Test и Rabbit. Если вопросов нет, тогда я предлагаю переключиться на студию. Я подготовил небольшой проект, чтобы посмотреть можно было.</p>
  </li>

  <li>
    <pre>
    <Project Sdk="Microsofr.NET.Sdk">

      <PropertyGroup>
        <OutputType>Exe</OutputType>
        <TargetFramework>net5.0</TargetFramework>
      </PropertyGroup>

      <ItemGroup>
        <PackageReference Include="StackExchange.Redis" Version="2.2.79" />
      </ItemGroup>

    </Project>
    </pre>
  </li>

  <li>Вот наш solution, в котором есть несколько папок RabbitMQ, Redis. В Rabbit я сделал сервисный проект Rabbit. Это библиотечка которая будет работать с Rabbit. Вкратце покажу как работает. Базовые основы. Что у нас есть? Это сервис, который цепляется к Rabbit и позволяет получать данные.</li>

  <li>Тест выполняется впараллель. Имейте ввиду, что если приложение пишет кучу логов и вы выполняете кучу тестов, на которые эти логи нельзя отключить. То эти логи ваши тесты переполнят. Таким образом работает тестирование. Ну и здесь вы можете написать их сколько угодно. У нас будет практика, гже мы будем писать тесты к нашему приложению. Так что потом поиграемся. Это все что я хотел сегодня рассказать. По тулзам мы поговорили. Есть вопросы?</li>

  <li>Практика будет в формате live coding. Я открою studio. Открою новый пустой solution. И буду писать с вами приложение. А вы будете смотреть и желательно повторять. После того как все закончится, ваша задача будет это самостоятельно повторить руками чтобы у вас к следующей лекции было все в том же виде. Если вы это дело действительно руками создадите до конца, то к окончанию практики сможете писать приложения. По крайней мере простые, по какому-то формату, но уже самостоятельно. По крайней мере руками потрогаете. Практика покажет, тот кто самостоятельно, то что мы сделаем, онлайн повторит, он уже будет достаточно крут.</li>

  <li>Следующий понедельник выходной. Следующая лекция будет 9 ноября. Мы будем говорить про .net CLR.</li>
</ul>