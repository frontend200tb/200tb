<article class="article">
	<div id="link-to-dsr2023net" class="btn-back">назад</div>

  <h1>2023-10-09 Lecture #2 C# типы данных</h1>
</article>


<article class="article">
  <p>Лекцию читает Екатерина</p>

  <p>Меня зовут Екатерина. Я буду вам читать лекции по языку C#. В нашем курсе их предусмотрено 2 штуки. Сегодня будет первая лекция. В этой лекции мы в основном будем обсуждать основные конструкции языка, типы, как с ними можно работать, для чего они нужны. Иногда что лучше использовать, что не надо использовать. Преимущества и недостатки. Основная информация для этих лекций была взята из книги Джеффри Рихтера .net by c# CLR. (2013 Рихтер - CLR via C# (4е).pdf) </p>
  <p>Вы можете с ней ознакомиться, она очень большая и я не рекомендую начинать с нее изучение языка. Для начинающих я рекомендую почитать документацию Microsoft. Может быть что-то попроще, но не с этой книги. Если вы хотите углубиться, понять как на самом деле устроена платформа дотнет, что такое IL код, что такое garbage collector и т.д. нужно почитать эту книгу. Лекции у нас будут этому посвящены, но чуть позже. Сегодня мы будем разговаривать, в основном, про язык C#.</p>
</article>
  
<article class="article">
  <h3>О чем будет эта лекция</h3>
  <p>- Основные сведения о типах
  <br>- Методы, параметры, свойства
  <br>- Делегаты и события
  <br>- Обобщения
  <br>- Интерфейсы и абстрактные классы</p>

  <p>Сегодня мы поговорим о типах, какие типы существуют в языке C# на платформе дотнет. Какие существуют члены типов, методы, параметры, свойства. Что такое делегаты и события. Поговорим немного об обобщениях и в конце обсудим интерфейсы, абстрактные классы, в чем различие, что лучше использовать.</p>
</article>

<article class="article">
  <h2>1. Основные сведения о типах</h2>

  <h3>Классификация типов</h3>
  <p>- ссылочный тип (reference type)
  <br>- тип значения (value type)
  <br>В стеке (stack) хранятся типы значения (value types) и указатели на ссылочные типы (pointers to the reference type)
  <br>В куче (heap) хранятся ссылочные типы (reference types)
  </p>

  <p>Я надеюсь, что здесь не все новички, а люди знакомые с языком C#. Напишите, кто уже что-то писал на C#. Может что-то в университете, консольные приложения. Чтобы я понимала сколько тут новичков, сколько старичков. Для одних надо пояснить некоторые моменты, для других напомнить.</p>
  <p>На платформе дотнет существует два типа данных – ссылочные типы и типы значения. Что их, в основном, отличает друг от друга. Ссылочный тип хранятся в куче (Heap), а типы значения хранятся в стеке (Stack). То есть, когда мы создаем переменную типа значения int, то в стек будет записана переменная с этим значением. int равный трем будет лежать в стеке так как он есть. Если мы создаем ссылочный тип, например, экземпляр класса, то в стек будет записана переменная со значением адреса на кучу, в которой размещен экземпляр. Я думаю, что это основа основ.</p>

  <h2>Иерархия типов</h2>
  <p>Несмотря на это, базовым типом для всех типов в языке является тип Object. Поэтому все стринги, массивы, классы, которые вы объявляете в программе будут неявно наследовать этот тип. Вы можете явно его унаследовать, но это необязательно. Типы значения тоже наследуют тип Object неявным образом. Через тип System.ValueType. 
  <code>
  System.Object - System.ValueType - System.Int32
  <br>System.Object - System.ValueType - System.Boolean
  <br>System.Object - System.ValueType - System.Enum - All enums
  </code>
  <code>
  System.Object - System.String
  <br>System.Object - System.Array
  </code>
  Это сделано чтобы любой тип в вашей программе имел минимальный набор методов, например ToString, GetHashCode, Equals.</p>

  <h3>Приведение и преобразование типов</h3>

  <h3>- Неявное преобразование</h3>
  <p>Преобразования из меньших в большие целочисленные типы и преобразования из производных классов в базовые классы
  <code>// Derived class to base class
  <br>Derived d = new Derived();
  <br>Base b = d;
  <br>
  <br>// 32-bit int to 64-bit long
  <br>Int num = 2147483647;
  <br>Long bigNum = num;</code>
  </p>

  <h3>- Явное преобразование (приведение)</h3>
  <p>Способ явно указать компилятору, что необходимо выполнить преобразование и что вам известно, что может произойти потеря данных или приведение может завершиться сбоем во время выполнения.
  <code>Double x = 1234.7;
  <br>Int a;
  <br>a = (int)x;</code>
  </p>

  <p>Так как у нас все типы наследуются, и мы можем их друг другу присваивать, существует механизм приведения и преобразования. Существует неявное преобразование и явное преобразование (приведение).</p>
  <p>Неявное преобразование работает при преобразовании производных классов в базовые классы. Это когда мы переменную типа наследника присваиваем в переменную базового класса.</p>
  <p>Тоже самое работает для значимых системных типов. Например int и long. Если int занимает меньше памяти 32 бита, то мы можем его без потери данных засунуть в long, который занимает 64 бита. Это можно сделать неявно, ничего не говоря компилятору. Компилятор сам все сделает безопасным способом и все будет хорошо.</p>
  <p>Но еще существует явное преобразование, оно называется приведение типов. Оно работает когда мы хотим double засунуть в int, мы должны компилятору явно сказать, что мы знаем о возможной потере данных. Мы явно указываем компилятору какой тип мы хотим видеть. Так можно делать со значимыми типами и с сылочными типами. Но даже если компилятор не заругается, в рантайме можно получить исключение invalid cast exception и все может рухнуть.</p>

  <h3>- Пользовательские преобразования</h3>
  <p>Преобразования выполняются специальными методами, которые можно определить для включения явных и неявных преобразований.
  <code>public static implicit operator byte(MyClass d) => d.digit;
  <br>public static explicit operator MyClass(byte b) => new MyClass(b);</code>
  </p>

  <h3>- Преобразования с использованием вспомогательных классов</h3>
  <p>System.Convert
  <br>Int32.Parse, Double.Parse
  <br>и т.д.
  </p>

  <p>Существуют еще пользовательские преобразования. Это операторы явных и неявных преобразований, которые вы описываете в своем классе. Например, тип MyClass приводим к типу byte неявным образом. И явным образом приводим тип byte к типу MyClass. Мы подробно не будем останавливаться на этих оперетарах. Просто знайте что они есть. Если хотите, побольше прочитайте о них. На моей практике еще не было случаев когда эти преобразования были нужны. Обычно используют вспомогательные классы  - System.Convert, Int.Parse, Double.Parse и другие. Существует большое количество библиотек, которые поддерживают разные преобразования. Стоит только что-нибудь погуглить и все найдете.</p>
  <p>Таким образом, мы можем тип наследника всегда привести к базовому типу. И мы знаем, что значимый тип наследуется от типа Object. Значит мы тип можем привести к типу Object. Когда мы приводим значимый тип к типу Object то происходит процесс называемый Упаковка.</p>

  <h3>Упаковка и распаковка (boxing & unboxing)</h3>

  <h3>Упаковка значимых типов в ссылочные:</h3>
  <p>1. В управляемой куче выделяется память – длина значимого типа плюс специальные переменные.
  <br>2. Поля значимого типа копируются в выделенную память
  <br>3. Возвращается адрес объекта
  <code>int i = 123; // i – value type
  <br>object o = I; // boxing
  <br>int j = (int)o; // unboxing</code>
  </p>

  <p>В чем заключается этот процесс. Давайте посмотрим на пример. У нас есть переменная типа int. Мы ее создали, инициализировали и потом засунулимв переменную типа object. В этот момент происходит процесс упаковки. Выделяется область памяти в куче (Heap), где хранятся значения ссылочных типов. Туда переносим значение значимого типа. Возвращаем в переменную адрес на эту область памяти в куче. И эта переменная будет себя вести как ссылочный тип.</p>

  <p>Unboxing это обратная операция упаковки, когда мы хотим обратно получить значимый тип и снова с ним работать как с интежером. А не постоянно натыкаться на проблемы, что это объект и мы не можем складывать. Мы хотим дальше с ним работать как с интом. Нам надо его распаковать. Надо сделать явным образом приведение. И у нас в переменной j будет снова тип значения как он и был в переменной i изначально. Я надеюсь здесь все понятно.</p>
  <p>Это не самый быстрый процесс. Это нагружает работу с памятью и процессор. Рекомендуется таких преобразований не делать. Механизм языка позволяет это делать по-другому. Работать со значимыми типами и реализовывать для них такие структуры чтобы можно было с ними работать как со значимыми и как с сылочными типами. Так лучше не делать, но если вы это увидите, то знайте что происходит этот процесс.</p>

  <h3>2. Из чего состоит тип</h3>

  <h3>Члены типа</h3>
  <pre>
    public class Dog
    {
      // Const
      private const string BarkingSound = "woof";

      // Field
      private string _name;

      // Property
      public string Name
      {
        get
        {
          return _name;
        }
        set
        {
          _name = value;
        }
      }

      // Auto-implemented properties for trivial get and set
      public uint Age { get; set; }

      // Static constructor is called at most one time, before any
      // instance constructor is invoked or member is accessed.
      static Dog() { }

      // Constructor without parameters
      public dog() {}

      public string Bark()
      {
        return $"{BackingSound}-{BackingSound}";
      }

      // Overloaded operator ==
      public static bool operator ==(Dog obj1, Dog obj2) {}

      // Overloaded operator !=
      public static bool operator !=(Dog obj1, Dog obj2) {}

      // Implicit conversion operator
      public static implicit operator Dog(Animal animal) {}

      // Explicit conversion operator
      public static explicit operator Dog(Animal animal) {}

      // Event
      public event Action DogWhining;

      // Nested type
      public enum Breed
      {
        Labrador,
        Beagle,
        Corgi
      }
    }
  </pre>

  <p>Рассмотрим на примере класса Dog, который я создала. Подробнее мы будем обсуждать чуть позже в нашей лекции. Пока давайте ознакомимся с конструкциями, которые у него есть. У него есть следующие члены. У него есть константа - это поле времени компиляции которая будет подставлена в нужном месте. Здесь я создала стринговую константу "woof" как будет собачка говорить. Дальше я создала поле name. Обернула его в свойство. Вся эта конструкция может быть заменена на тривиальное автосгенерированное проперти { get; set; }. Мы это обсудим попозже.</p> 
  <p>Дальше у нас есть конструкторы типов. Они помечены ключевым словом static. И конструкторы экземпляров. Их может быть сколько угодно. Они могут быть с параметрами или без, public или private. Это тоже мы обсудим. Может быть какие-то методы для работы с нашим классом. Например, собачка умеет гавкать в методе Bark. Дальше могут быть переопределены операторы. Например, оператор равенства == и оператор неравенства !=. Я здесь не написала никакой реализации данного метода. Просто чтобы была видна сигнатура.</p> 
  <p>Дальше есть операторы явного преобразования. Я из животного хочу создавать собачку. Здесь какая-то логика должна быть. Но я поленилась и ее не добавила. И есть событие, которое помечается ключевым словом event. Оно имеет тип делегата. Событие того, что собачка заскулила.</p>
  <p>Любой класс может содержать вложенные типы. Например, у меня тип enum перечисление. Здесь три собачки - лабрадор, бигль и корги. Давайте посмотрим подробнее на каждый из этих компонентов класса. Но в начале мы поговорим, конечно же, про видимость. У нас класс, поле, свойство помечены модификатором. На самом деле есть модификаторы по умолчанию. Например у класса это internal. У поля и свойства это private. Но хорошая практика это везде писать модификатор. Чтобы не заставлять других разработчиков и себя самого через какое-то время вспоминать а какой же здесь модификатор по умолчанию. И код выглядит более лаконично и аккуратно.</p>
</article>

<article class="article">
  <h3>Видимость</h3>

  <h3>Модификатор доступа</h3>
  <p>public – неограниченный доступ
  <br>protected – доступен из класса или типам, которые являются производными от содержащего класса
  <br>internal – доступен в текущей сборке
  <br>protected internal – доступен в текущей сборке и типам, которые являются производными от содержащего класса
  <br>private -  доступен только содержащему классу
  <br>private protected – доступен содержащему классу и производному классу той же сборки C# 7.2
  </p>

  <p>Давайте быстренько по ним пройдемся.</p>
  <p>Public это неограниченный достуа. Все что вы пометили public будет видно везде, во всех сборках, во всех классах. Его можно достать, посмотреть, изменить.</p> 
  <p>Protected доступен только внутри класса, который его объявил, и внутри классов наследников. Дальше мы не можем никак его посмотреть.</p> 
  <p>Internal доступен в текущей сборке. Если вы достали dll, подгрузили или взяли из другого проекта, и засунули к себе в приложение, то все что там помечено internal не будет доступно в вашем классе. Потому что он из другой сборки.</p> 
  <p>Protected internal это небольшое расширение видимости internal. Доступен в текущей сборке и в производных типах от данного класса.</p> 
  <p>Private доступен только из содержащего его класса.</p> 
  <p>Private protected расширяет видимость private. Доступен также производному классу той же сборки. Производный класс из другой сборки его уже не видит.</p>

  <h3>Статические классы</h3>
  <p>Статический класс – удобный контейнер для группировки логически связанных членов (методов, полей, свойств или событий), которые не требуют получения или установки каких-либо внутренних полей экземпляра.</p>

  <pre>
  public static class Math
  {
    public static double Abs(double value)
    {
      // calculating
    }

    public static double Min(double val1, double val2)
    {
      // calculating
    }

    //etc.
  }

  Math.Min(15/16, 12/13);
  </pre>
  <pre>
  public static class ValidationMessages
  {
    public const string EmailPhoneRequired = "Email or phone are required.";
    public const string UserIdRequired = "User id is required.";
    public const string UsernameRequired = "Username is required.";
    public const string PhoneRequired = "Phone is required.";
    public const string InvalidEmail = "Email is incorrect.";
  }

  ToastService.Show(ValidationMessages.UsernameRequired);
  </pre>

  <p>Статические классы это те же классы, помеченые ключевым словом static. Все члены статического класса тоже должны быть помечены ключевым словом static. Зачем же такие классы создавать. Данные классы не могут содержать конструкторов экземпляра. Потому что они в принципе не могут иметь экземпляры. Они могут иметь конструкторы типов, которые инициализируют значения статических членов класса. Вы не знаете когда ваш класс будет создан, это регулируется непосредственно компилятором. Но мы знаем точно и наверняка, что он будет создан до того как мы обратимся к любому его члену. Время его жизни равно жизни приложения. Как работать с этим классом.</p> 
  <p>Например, все знают класс Math для работы с математическими операциями. Там много методов, например Abs, Min. Мы не используем слово new, мы не создаем новый экземпляр класса. Мы просто пишем имя класса, точка, имя метода, круглые скобки с параметрами, например Math.Min(int a, int b).</p>
  <p>Или более практический пример. В вашем приложении вы хотите делать валидацию. И у вас много формочек, где пользователь вводит имя, телефон, емейл... Вы написали кучу правил валидации. И хотите отображать сообщение а что конкретно произошло не так. Когда пользователь, например, не ввел имя. Вы хотите показать "Username is required". Вы везде инлайново повтыкали эти строки. Потом вы поняли что это повторение кода. Тогда мы создаем статический класс ValidationMessages и помещаем в него все сообщения, связанные с валидацией. Тогда в нашем сервисе просто выводим поле статического класса вместо сообщения. ToastService.Show(ValidationMessages.UsernameRequired). Нам компилятор подскажет что там должно быть чтобы мы не ошиблись.</p> 
  <p>Главное использование статических классов - для того чтобы сгруппировать связанные члены (методы, поля, свойства, события). И чтобы их было удобно доставать. Состояния здесь нет, экземпляров нет. Поэтому мы их используем через имя класса.</p>

  <h3>Статические классы</h3>
  <p>- Имеет модификатор static
  <br>- Содержит только статические члены
  <br>- Невозможно создать экземпляр
  <br>- Не может содержать конструкторы экземпляров
  <br>- Не может быть унаследован
  <br>- Не может наследовать ни один класс или интерфейс, кроме Object</p>

  <h3>Вопрос: Какая разница между private protected и protected</h3>
  <p>Private доступен только данному классу. Например вы создали класс Dog. Его свойство private name доступно только методам, свойству, конструктору данного класса. Поле private доступно только методам, операторам, свойствам, конструктору данного класса. То есть вы не сможете написать new Dog, засунуть его в переменную и попытаться достать поле name. Потому что его оттуда уже не видно. Поэтому мы пишем слово private, когда не хотим показывать вызывающему коду поле private name. Private protected открывает это поле для всех производных класса Dog  в текущей сборке.</p>

  <h3>Вопрос: Почему свойства объявленные как const в классе static мы не помечаем как sttic?</h3>
  <p>Потому что константы по умолчанию уже static. В данном случае это синонимы. Как const static.</p>
</article>

<article class="article">
  <h3>3. Константы и поля</h3>
  <p>Константа (const) – это идентификатор, значение которого никогда не меняется
  <br>Поле – это член данных, который хранит экземпляр значимого типа или ссылку на ссылочный тип.
  </p>

  <pre>
  public class VeryUsefulClass
  {
    private const int ConstValue = 1;
    private readonly int _fieldValue;

    public VeryUsefulClass(int fieldValue)
    {
      _fieldValue = dieldValue;
    }
  }
  </pre>

  <p>
    Константу надо понимать как константу компиляции. Это значит, что в момент когда скомпилировался код, везде вместо имени константы будет вставлено значение константы. Это немножко оптимизирует время выполнения кода. Потому что программа не будет каждый раз искать по имени константы ее значение где-то там в памяти.
  </p>

  <p>
    Поле это член данных, который зависит от типа. Может содержать значимый тип, ссылочный тип. Инициализируется во время выполнения. Константу никак нельзя инициализировать во время выполнения - она не изменяема. Поле мы можем инициализировать во время выполнения и потом изменить.
  </p>

  <p>
    Чем отличается константа и поле readonly? Всем, кроме того что их нельзя изменить по коду. Константа это константа компиляции. Readonly это константа времени выполнения. Readonly поле может быть инициализировано только в конструкторе и больше нигде. И когда компилятор будет натыкаться на это поле, он будет ходить и спрашивать "а чему оно равно?" в памяти. А когда компилятор будет сталкиваться с константой, он будет видеть сразу ее значение, а не имя.
  </p>

  <p>
    Const (константа компиляции) и readonly (константа времени выполнения) нельзя изменить по коду. Const должна быть инициализирована во время объявления. Readonly можно объявить, а потом инициализировать в конструкторе.
  </p>
</article>

<article class="article">
  <h2>4. Методы</h2>

  <h2>Конструкторы</h2>
  <p>Конструкторы – это специальные методы, позволяющие корректно инициализировать новый экземпляр типа.</p>
  <p>Статические конструкторы (конструкторы типов) – это инициализаторы типа. Используются для инициализации любых статических данных или для выполнения определенного действия, которое необходимо выполнить только один раз.</p>

  <pre>
  // Static constructor is called at most one time, before any
  // instance constructor is invoked or member is accessed.
  static Dog() {}

  // Constructor without parameters
  public Dog() {}
  </pre>

  <p>Конструкторы это тоже методы. Методы, которые инициализируют экземпляры. Когда мы пишем myClass = new, то создаем конструктор, который будет инициализировать экземпляр.</p>

  <p>Статические конструкторы это методы, которые инициализируют типы. Служат, в основном, для инициализации статических полей. Это редкое явления, но оно есть. Мы не знаем когда будет вызван статический конструктор, но он обязательно будет вызван до того как мы обратимся к статическим членам. И мы не можем его контролировать. У статического конструктора нельзя поставить модификатор public и его нельзя вызвать извне. И он не может иметь параметры, потому что вызывает средой выполнения. </p>
  

  <h2>Виртуальные методы</h2>

  <pre>
  public class Human
  {
    public void Introduce()
    {
      Console.WriteLine("I'm a human!");
    }
  }

  public class Student : Human
  {
    public void Introduce()
    {
      Console.WriteLine("I'm a student!");
    }
  }

  Human human = new Student();
  human.Introduce(); // I'm a human!
  </pre>

  <h2>Виртуальные методы</h2>
  <p>Виртуальные члены класса могут быть переопределены в классе потомке
  <br>За счет виртуальных членов реализуется свойство ООП – полиморфизм
  </p>

  <pre>
  public class Human
  {
    public virtual void Introduce()
    {
      Console.WriteLine("I'm a human!");
    }
  }

  public class Student : Human
  {
    public override void Introduce()
    {
      Console.WriteLine("I'm a student!");
    }
  }

  Human human = new Student();
  human.Introduce(); // I'm a student!
  </pre>

  <pre>
  public class BadlyConstructedType
  {
    protected bool IsReady = false;

    public BadlyConstructedType()
    {
      Console.WriteLine("Calling base ctor.");
      DoSomething();
    }

    // This will be overridden in the derived type.
    public virtual void DoSomething()
    {
      Console.WriteLine("Base DoSomething");
    }
  }
  </pre>

  <pre>
  public class DerivedType : BadlyConstructedType
  {
    public DerivedType()
    {
      Console.WriteLine("Calling derived ctor.");
      IsReady = true;
    }

    public override void DoSomething()
    {
      Console.WriteLine("Derived DoSomething is called. Am I ready? {0}", IsReady);
    }
  }

  DerivedType derivedInstance = new DerivedType();
  </pre>

  <p>
  С помощью ключевого слова virtual в базовом классе помечается метод, который может быть переопределен в классе наследнике. С помощью ключевого слова override в классе наследнике помечаем метод, который мы в нем переопределяем. Это важный механизм языка си шарп, который позволяет реализовать свойство ООП - полиморфизм. Это когда класс наследник ведет себя по другому чем класс родитель.
  </p>

  <p>Нельзя вызывать виртуальные члены в конструкторе. Потому что есть порядок вывполнения конструкторов при инициализации объектов. Когда мы вызываем конструктор наследника, то вначале вызовется конструктор базового класса и только потом конструктор наследника. Здесь неявным образом вызывается конструктор базового класса.</p>
</article>

<article class="article">
  <h2>Методы расширений (extensions)</h2>

  <pre>
  public class Student
  {
    public int Id { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
  }

  var student = new Student()
  {
    Id = "1",
    FirstName = "Michael",
    LastName = "Scott"
  };

  var fullName = student.FullName(); //returns Michael Scott
  </pre>

  <pre>
    public class Student
    {
      public int Id { get; set; }
      public string FirstName { get; set; }
      public string LastName { get; set; }

      public string FullName() => $"{FirstName} {LastName}";
    }  
  </pre>

  <pre>
  public class Student
  {
    public int Id { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
  }

  public static class StudentExtensions
  {
    public static string FullNema(this Student student) => $"{FirstName} {LastName}";
  } 
  </pre>

  <p>
    Важный механизм языка си шарп - методы расширений. Представим что у нас есть класс public class Student. И у него есть свойства public int Id, public string FirstName, public string LastName. И пусть нам нужно определить метод public string FullName который конкатенирует FirstName и LastName. Но что, если нам не хочется изменять наш готовый класс Student? Для этого используют механизм расширений. Мы объявляем статический класс public static class StudentExtensions и в этом классе объявляем статический метод, который делает то что нам нужно. public static string FullName(this Student student) => $"{FirstName} {LastName}"; И теперь мы можем создать экземпляр класса var student = new Student() и вызвать у него этот метод var fullname = student.FullName();
  </p>

  <p>
    Методы расширений могут иметь не только один параметр, помеченый ключевым словом this. Здесь можно много разных параметров передавать. Главное, что это должен мыть статический метод в статическом класси и первым параметром передается экземпляр того класса, для которого пишется этот метод расширения.
  </p>

  <p>
    Мы постараемся вам все дать за две лекции. Цель лекций дать вам больше практических знаний, чем углубляться во все сложности языка и конструкций. Все что будет рассказано на этих двух лекциях это больше практическое. Если кто-то уже писал на дотнете, то вы уже сталкивались с методами расширения. Те же linq это методы расширений, которые лежат в отдельном статическом классе.
  </p>
</article>

<article class="article">
  <h2>5. Параметры</h2>

  <h2>Параметры методов</h2>
  <p>По умолчанию параметры передаются по значению.
  <br>- Для типов значений – копируется реальное значение в новую переменную
  <br>- Для ссылочных типов – копируется ссылка в новую переменную
  <br>Ключевые слова out и ref позволяют передавать объекты по ссылке.
  </p>
  
  <p>
    Поговорим про параметры методов. Все параметры передаются в методы по-умолчанию по значению. Для типов значения, значение будет скопировано в новую переменную. Для ссылочных типов будет скопирована ссылка в новую переменную. Чтобы передать параметры по ссылке нужно использовать ключевые слова out и ref. Первый параметр передается по значению, второй - по ссылке. При этом первая переменная изменится только внутри этого метода. Первая переменная копируется и изменится значение только в скопированной переменной. А вторая переменная изменится и внутри метода и снаружи. У второй переменной скопируется адрес на ее значение. Изменится значение в адресе, на который указывает и скопированная переменная и переданная переменная.
  </p>

  <p>Посмотрим как это работает. Пусть у нас есть метод, который увеличивает два числа на 1.</p>
  <pre>
  public static void Increase(int a, ref int b)
  {
    a++;
    b++;
  }
  
  public static void Check()
  {
    int a = 10;
    int b = 20;

    Increase(a, ref b)
    Console.WriteLine($"a = {a}, b = {b}"); // a = 10, b = 21
  }
  </pre>

  <pre>
  public static void Change(Student a, Student b)
  {
    a.FirstName = "New Anna";
    b = new Student()
    {
      firstName = 'new John'
    };
  }

  public static void Check()
  {
    Student a = new Student()
    {
      FirstName = "Anna"
    };
    Student b = new Student()
    {
      FirstName = "John"
    };

    Change(a, ref b);
    Console.WriteLine($"a = {a.FirstName}, b = {b.FirstName}");
    // a = New Anna, b = John
  }
  </pre>
    
  <p>
    Нужно ли для ссылочных переменных ключевое слово ref? Если мы передадим в метод два объекта типа Student и попытаемся изменить им имя. То ссылочные типы скопируются в новые переменный. В первой переменной мы поменяем значение и оно также изменится для переданной переменной. Во вторую переменную мы запишем новый объект типа Student и эта переменная будет уже ссылваться на другую область памяти в куче, где лежит этот новый объект. А вторая переданная переменная никак не изменится. Но если мы хотим чтобы новый экземпляр записался в переданную переменную, то надо ее передавать в метод с ключевым словом ref. То есть для изменения свойств объекта можно передавать без слова ref. Но если надо изменить весь объект целиком, то нужно слово ref.
  </p>

  <p>Вопрос: Какое отличие ref от out? Переменная передаваемая через ref должна быть инициализирована до передачи в метод. Переменная передаваемая через out должна быть инициализирована перед выходом из метода.</p>
</article>

<article class="article">
  <h2>6. Свойства</h2>

  <pre>
  // Field
  private string _name;

  // Property
  public string Name
  {
    get
    {
      return _name;
    }
    set
    {
      _name = value;
    }
  }

  //Auto-implemented properties for trivial get and set
  publicunit Age { get; set; }
  </pre>

  <p>Свойства помогают реализовать механизм ООП - инкапсуляция. Мы можем регулировать доступ к полю. Мы можем создать приватное свойство и установить к нему геттер и сеттер для доступа к нему. Например у нас есть закрытое свойство private string _name. И есть свойство public string Name с геттером, который возвращает значение этого свойства и сеттером, который устанавливает значение этого свойства. Из вызывающего кода мы не можем обратиться к молю _name. Но можем обратиться к свойству Name. В методе set можно установить проверку что имя не пустое.</p>

  <p>Все свойства это пара методов public uint Age { get; set; }. При этом будет сгенерировано закрытое поле и два метода для работы с ним. get и set могут иметь различные модификторы доступа. Мы можем написать Age { get; protected set; }. В этом случае get будет доступен всем, а set будет доступен только классам наследникам.</p>

  <h2>Особенности:</h2>
  <p>- в отличие от полей, можно регулировать доступ отдельно на чтение, отдельно на запись.
  <br>- свойства, по сути методы, могут вызывать исключения
  <br>- свойства нельзя передать в метод с ключевым словом ref или out.
  </p>
</article>
  
<article class="article">
  <h2>7. Делегаты</h2>
  <p>Делегат – это тип, представляющий из себя цепочку ссылок на методы с определенными входными параметрами и типом возвращаемого значения</p>

  <pre>
  public delegate int Counter(int x, int y);

  public int Sum(int a, int b)
  {
    return a + b;
  }

  public int Subtraction(int a, int b)
  {
    return a - b;
  }

  public int Multiplication(int a, int b)
  {
    return a * b;
  }
  </pre>
  
  <p>Делегат - это сигнатура метода, которая позволяет использовать другой метод вместо него. Когда создаем что-то с ключевым словом delegate, то компилятор это разворачивает в класс, экземпляр которого будет содержать в себе цепочку. Когда мы пишем delegate, то мы создаем новый тип. И этот тип хранит в себе ссылки на методы.</p>
</article>

<article class="article">
  <h2>8. События (Events)</h2>
  <p>События – вид членов, которые можно определить в типе. Если в типе определено событие, то этот тип (или экземпляр) может уведомлять другие объекты о некоторых особых ситуациях, которые могут случиться.</p>
  
  <p>
    Важной вещью являются события. Они сильно связаны с делегатами. Но это разные вещи. Событие это тоже член какого-то типа. И с помощью него можно отслеживать какие-то события, которые возникли в типе другими типами и как-то на них реагировать. Например, есть тип Publisher у которого есть события. На эти события могут подписаться классы, которые видят данный класс и эти события. Что значит подписаться? Это значит что они говорят, что мы хотим слушать когда это событие возникнет и как-то на него среагировать. Подписчик 1 подписывается на событие своим обработчиком, а подписчик 2 подписывается уже своим обработчиком на это же событие. Если в какой-то момент это событие вдруг происходит, все подписчики будут об этом уведомлены. И в этот момент отработает каждый обработчик этого события.
  </p>
</article>

<article class="article">
  <h2>9. Обобщения (Generic)</h2>
  <p>Обобщения – это еще один механизм, позволяющий многократно использовать универсальный код.</p>

  <pre>
  public static void GetInfo(object value)
  {
    Console.WriteLine(value.ToString());
  }
  </pre>

  <pre>
  public static void GetInfo<T>(T value)
  {
    Console.WriteLine(value.ToString());
  }
  </pre>
    
  <p>Обобщения - это важный механизм, с которым вы будете много работать дальше. Особенно на практике в ходе данного курса. Иногда нужно написать метод, который работает не только с одним типом входных данных. Мы хотим чтобы он работал со всеми типами.</p>
  
  <h2>Ограничения обобщений</h2>
  <pre>
  public class Human
  {
    protected string Name { get; set; }
    public virtual void Introduce()
    {
      Console.WriteLine($"Hi! I'm a human, my name is {Name}!");
    }
  }

  public class Student : Human
  {
    public override void Introduce()
    {
      Console.WriteLine($"Hi! I'm a student, my name is {Name}!");
    }
  }

  public class Meeting<T>
    where T: Human
  {
    private readonly T _firstHuman;
    private readonly T _secondHuman;

    public Meeting(T first, T second)
    {
      _firstHuman = first;
      _secondHuman = second;
    }

    public void Introducing()
    {
      _firstHuman.Introduce();
      _secondHuman.Introduce();
    }
  }

  var meeting = new Meeting<Human>(new Human(){ Name = "John" }, new Student(){ Name = "Mike" });
  meeting.Introducing();
  </pre>

  <p>Ограничения обобщений нужны для того чтобы класс работал только с одним классом и его наследником, а не со всеми типами сразу. Пусть у нас есть класс public class Human. И от него есть производный класс наследник public class Student: Human. Тогда с помощью ограничения обобщений мы можем написать класс public class Meeting<T> where T: Human, который работает только с классом Human и его наследниками.</p>
</article>

<article class="article">
  <h2>10. Интерфейсы и абстрактные классы</h2>
  <p>Интерфейс – это именованный набор сигнатур методов. Если какой-то класс имплементирует интерфейс, он обязан реализовать все описанные с нем методы.</p>

  <h2>Для чего нужны интерфейсы:</h2>
  <p>- Единый контракт
  <br>- Уменьшение связности кода (SOLID)
  <br>- Множественное наследование
  </p>
  
  <p>Интерфейс это какой-то контракт, который показывает каким образом должен вести себя класс, который его реализует. И класс, который его реализует, обязательно должен реализовать все методы, объявленные в этом интерфейсе. Синтаксически наследование интерфейсов выглядит так же как и наследование классов. Ваши кусочки кода не должны зависеть друг от друга, а должны зависеть от абстарций. Интерфейс это абстракция, поэтому он реализует приницип SOLID. Это когда при изменении реализации одного кода менялся другой код. Си шарп не позволяет наследоваться от нескольких классов, но позволяет реализовывать несколько интерфейсов.</p>

  <p>Зачем нужно уменьшать связность кода и реализовывать несколько интерфейсов? Пусть мы написали игру и в ней есть персонаж Троль и арена, на которой троли будут биться. Арена это класс, который при инициализации принимает двух троллей, которые будут между собой биться. Такая арена будет только для тролей. Но вот в игру добавили еще персонажей - рыцарей. И теперь арену нужно переписывать, чтобы на ней могли драться и рыцари. Получился класс, который сильно привязан к реализации персонажа. Чтобы этого не было нужно создать интерфейс Персонаж, который описывает что умеет делать троль, рыцарь. И сделать троля и рыцаря реализацией этого интерфейса. Тогда и арена может работать с интерфейсом персонажа, а не с его реализацией - тролем, рыцарем. Интерфейс позволяет сделать код гибким и расширяемым.</p>

  <h2>Абстрактный класс</h2>
  <p>Абстрактный класс – это класс, в котором есть хотя бы один абстрактный член (сигнатура которого объявлена, а реализация не определена)</p>

  <pre>
  abstract class Education
  {
    public abstract void Enter();
    public abstract void Study();
    public virtual void PassExams()
    {
      Console.WriteLine("Сдаем выпускные экзамены");
    }
  }

  class school : Education
  {
    public override void Enter()
    {
      Console.WriteLine("Идем в первый класс");
    }

    public override void Study()
    {
      Console.WriteLine("Посещаем уроки, делаем домашние задания");
    }
  }

  class University : Education
  {
    public override void Enter()
    {
      Console.WriteLine("Сдаем вступительные экзамены и поступаем в ВУЗ");
    }

    public override void Study()
    {
      Console.WriteLine("Посещаем лекции");
      Console.WriteLine("Проходим практику");
    }

    public override void PassExams()
    {
      Console.WriteLine("Сдаем экзамен по специальности");
    }
  }
  </pre>
    
  <p>Абстрактный класс не может иметь экземпляра. От абстрактного класса должен унаследоваться другой класс и реализовать абстрактные методы.</p>

  <p>В классе наследнике мы обязаны реализовать абстрактные методы класса родителя. И если захотим, то можем переопределить виртуальные методы. Если мы их не переопределим, то они будут использованы из абстрактного класса. Абстрактный класс нужен когда уже есть базовая логика, которую мы хотим расширять. Например класс abstract class Educaion с абстрактными методами public abstract void Enter(); и public abstract void Study(); и виртуальным методом public virtual void PassExams() {}. Во всех классах наследниках сдают выпускные экзамены, а варианты как можно поступить и обучаться будут разные.</p>

  <h2>Когда использовать абстрактные классы, а когда интерфейсы?</h2>
  <p>- Абстрактный класс используется когда есть система связанных типов, и требуется реализовать для них базовую функциональность, которую они будут использовать
  <br>- Интерфейсы же используются как описание некоторого перечня функций, присущих разрозненным объектам, каждый из которых реализует интерфейс по-своему.
  </p>
</article>
  
<article class="article">
  <h2>Вопросы.</h2>
  <p>В следующей лекции мы будем разговаривать про более практические вещи, которые обязательно вам пригодятся на практике. Будем говорить про async, await. Будем говорить про асинхронное параллельное программирование. Про exception. Будут немного более сложные вещи, но более интересные и более практически важные.</p>

  <p>- Как событие работает в коде?</p>
  <p>- Событие может быть вызвано только в том классе, которое его объявило. Компилятор преобразует событие в закрытое поле с двумя методами Add и Remove. Add добавляет обработчик, Remove удаляет. Так как поле закрытое, то вызвать событие можно только из класса, в котором оно объявлено. В другом классе на него можно подписаться (начать его слушать).</p>
  
  <p>На следующей лекции мы будем обсуждать параллельное программирование. Но мы не будем углубляться в эту тему. Вам не придется самим выделять потоки и их дерижировать в своем приложении. Вам придется работать с тасками и с асинхронным кодом. Может быть обсудим что-то связанное с мониторами, локами, семафорами если хватит времени.</p>
</article>
