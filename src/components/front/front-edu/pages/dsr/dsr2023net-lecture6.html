<a href="#" id="edu-dsr">назад</a>

<h1>2023-11-09 DSR .NET School 2023 Lecture #6 DBMS</h1>

<h2>Лекция 6. Базы данных</h2>

<ul>
  <li>
    <p>Всем добрый вечер. Меня видно? Слышно? Сегодня у нас лекция смещена на четверг относительно понедельника. Был праздник. Все одохнули. Продолжим. Я вас на прошлой лекции немножко ввел в заблуждение. Обещал по NET рассказать, но NET будет следующая лекция. Сегодня мы поговорим еще немного о том что надо сейчас веб разработчикам, то что важно. И после этого мы пойдем целенаправленно в сторону NET в сторону практики.</p>
    <p>Наша сегодняшняя лекция будет посвещена базам данных. Мы про них поговорим. Почему это важно? Современный веб разработчик это не только тот кто пишет сайт, а тот кто пишет серьезный и бэкэнд. Если вы идете в ту среду, вам надо знать базы данных, выбирать их под разные задачи. У нас системы уже начинают собираться на серверах. Они становятся мощными, тяжелые, много клиентов. Соответственно нужен и соответствующий инструментарий. Вот сегодня про этот инструментарий мы и поговорим. Лекция будет легкая. Многие из вас что-то из этого знали. Если будут вопросы - пишите, будем сразу разбирать.</p>
  </li>

  <li>
    <h2>О чем будет эта лекция</h2>
    <p>- Зачем нужны базы данных</p>
    <p>- Виды баз данных</p>
    <p>- Области применения</p>
    <p>- Реляционные БД, нормализация</p>
    <p>- SQL, DDL, execution plan, оптимизация</p>
    <p>- Не реляционные БД (NoSQL), виды</p>
    <p>- Эксплуатация на практике (партиционирование, репликация, шардинг, failover)</p>
    <p>- ORM</p>
  </li>

  <li>Базы данных. Что может быть проще? Давайте посмотрим. О чем поговорим? Что такое базы данных, зачем они нужны, какие бывают. Расскажу некоторые вещи по реляционным базам данных, которые классические. Поговорим про NoSQL базы данных. И я в конце дам некоторые архитектурные знания, если вы будете строить нечто большое. Представление как с помощью баз данных можно обрабатывать очень большие базы данных. Это будет обзорно. Если вы будете в ту сторону свою карьеру развивать, надо будет детальнее изучить, но по крайней мере основы  будете знать</li>

  <li>
    <h2>Данные / БД / СУБД</h2>
    <p>Данные - какая-либо информация, представляющая ценность</p>
    <p>База данных - набор данных, организованных по каким-либо правилам</p>
    <p>Система управления базой данных - средство для хранения, представления и манипулирования данными в базе данных.</p>
  </li>

  <li>Давайте для начала разберем что такое базы данных. Просто введем некоторую классификацию. Чтобы мы друг друга понимали, нам надо определить только три термина - данные, база данных, система управления базой данных. В обычном разговоре программисты эти вещи путают и не совсем понимают. Данные это информация. Это то что мы храним. То, ради чего нам все остальное и надо. База данных это набор информации, после того как она организована, склассифицирована. Это может быть набор книг, журналов, бухгалтерской отчетности. Даже ваш дневник, который вы в тетрадке ведете это база данных, определенным образом организована и хранащая информацию. Система управления базой данных уже имеет отношение к IT это те самые MSSQL, PostGrass, MongoDB и т.д. Также в общих чертах и библиотека это система управления базой данных. Медленная, управляется вручную. Мы будем под СУБД понимать техническое средство для управления базой данных.</li>

  <li>
    <h2>Основные задачи СУБД</h2>
    <p>- Хранение данных</p>
    <p>- Изменение данных по запросу</p>
    <p>- Поиск и предоставление данных по запросу</p>
    <p>- Разделение доступа к информации и средствам манипулирования ею</p>
    <p>- Поддержка порядка и целостности данных при манипуляции с ними</p>
    <p>- Масштабирование</p>
    <p>- Обеспечение сохранности данных (резервные копии)</p>
  </li>

  <li>База данных нужна, во-первых, для хранения. Для поиска, изменения данных. Сейчас скорость предоставления данных очень важная вещь. Клиенты стали избалованные. По себе посмотрите. Если вы заходите на сайт а он ничего не стал вам выдавать. Вы плюнете и пойдете на другой. Если интернет магазин при попытке показать вам товар будет долго думать, то это уже не допустимо.</li>

  <li>
    <h2>Области применения СУБД</h2>
  </li>

  <li>Где могут применяться СУБД? Везде!</li>

  <li>
    <h2>Виды СУБД</h2>
    <p>- Файлы</p>
    <p>- Иерархические базы данных</p>
    <p>- Сетевые базы данных</p>
    <p>- Реляционные базы данных</p>
    <p>- Ключ-значение</p>
    <p>- Документные базы данных</p>
    <p>- Графовые базы данных</p>
    <p>- Колончатые базы данных</p>
    <p>- Базы данных временных рядов</p>
    <p>- NewSQL базы данных</p>
    <p>- Многомодельные базы данных</p>
  </li>

  <li>
    <h2>Файлы</h2>
    <p>Особенности:</p>
    <p>- ограничен тип и уровень сложности хранимой информации</p>
    <p>- трудно установить связи между компонентами данных</p>
    <p>- отсутствие функций параллелизма</p>
    <p>- практичны только для систем с небольшими требованиями к чтению и записи</p>
    <p>- используются для хранения конфигурационных данных</p>
    <p>- нет необходимости в стороннем программном обеспечении</p>
    <p>- вся логика реализуется самостоятельно</p>
    <p>Примеры:</p>
    <p>- csv, xml</p>
  </li>

  <li>
    <p>Самы первые СУБД хранились просто в файле.</p>
    <p>Например, в файле есть какие-то слова, разделенные запятой, двоеточием или точкой с запятой. И таким образом структурирована некоторая информация. Если запятой и точкой с запятой, то это формат csv. Наверняка вы его видели. Какие у него плюсы? Ничего лишнего не требуется. Просто берете файл и в него что хотите пишете. csv это самый простой формат. Если что-то посерьезней, то это xml, json. В своих форматах никто не запрещает делать. Это один из форматов базы данных</p>
  </li>

  <li>
    <h2>Иерархические базы данных</h2>
    <p>Особенности:</p>
    <p>- ограничен тип и уровень сложности хранимой информации</p>
    <p>- информация организована в виде древовидной структуры с отношениями "предок-потомок"</p>
    <p>- каждая запись может иметь не более одного родителя</p>
    <p>- связи между записями выполнены в виде физических указателей</p>
    <p>- невозможно реализовать отношения "многих-ко-многим"</p>
    <p>Примеры:</p>
    <p>- Файловые системы, DNS, LDAP</p>
  </li>

  <li>Здесь каждый узел имеет набор подчиненных узлов, которые тоже имеют подчиненные узлы и т.д. Удобно перемещать узлы между собой, удобно представлять данные.</li>

  <li>
    <h2>Сетевые базы данных</h2>
    <p>Особенности:</p>
    <p>- сетевые базы данных представляются не деревом, а общим графом</p>
    <p>- ограничены теми же шаблонами доступа, что иерархические БД</p>
    <p>Примеры:</p>
    <p>- IDMS</p>
  </li>

  <li>Отличие от иерархической базы данных, где все связи идут от одного ко многим, в том что здесь добавили возможность устанавливать связи между связями. Это первое развитие иерархической базы данных. Это система где узлы между собой определенными связями связаны.</li>

  <li>
    <h2>Реляционные базы данных</h2>
    <p>Особенности:</p>
    <p>- поле в таблице, называемое внешним ключом, может содержать ссылки на столбцы в других таблицах, что позволяет их соединять</p>
    <p>- высокоорганизованная структура и гибкость делает реляционные БД мощными и адаптируемыми к различным типам данных</p>
    <p>- для доступа к данным используется язык структурированных запросов (SQL)</p>
    <p>- надежный выбор для многих приложений</p>
    <p>Примеры:</p>
    <p>- MS SQL Server, Oracle, PostgreSQL, MySQL, MariaDB, SQLite</p>
  </li>

  <li>Реляционные чаще всего сейчас используются. Это мейнстрим. Это не только разработки, которые относятся к сайтам, но и промышленные разработки, банковские разработки. Всю нашу инфомацию мы должны описать при помощи объектов, которые представляют собой таблицу с атрибутами и полями. И есть целая куча правил, которые позволяют нашу информацию правильно организовать, получать. Это популярный и мощный подход.</li>

  <li>
    <h2>Ключ-Значение</h2>
    <p>Особенности:</p>
    <p>- хранилища обеспечивают быстрый и малозатратный доступ</p>
    <p>- часто хранят данные конфикураций и информацию о состоянии данных, представленных словарями или хэшем</p>
    <p>- нет жесткой схемы отношения между данными, поэтому в таких БД часто хранят одновременно различные типы данных</p>
    <p>- разработчик отвечает за определение схемы именования ключей и за то, чтобы значение имело соответствующий тип/формат</p>
    <p>Примеры:</p>
    <p>- Redis, Memcached, ETCD</p>
  </li>

  <li>Ключ - Значение это база данных которая основана на быстрой математике на основе хэшей. У нас есть ключ и к нему мы цепляем определенный набор информации. Если мы знаем ключ, то можем очень быстро получить информацию по этому ключу. Поиск по ключу делается при помощи быстрых алгоритмов: обход бинарного дерева, хэш таблицы и т.д. Эта база данных - анлалог dictionary  в си шарп. Плюсы - очень быстрый доступ. Минусы - мы не можем установить другие связи и для получения нужной информации приходится делать несколько запросов в базу данных. Чаще всего используется для хэша.</li>

  <li>
    <h2>Документо-ориентированные БД</h2>
    <p>Особенности:</p>
    <p>- база данных не предписывает определенный формат или схему</p>
    <p>- каждый документ может иметь свою внутреннюю структуру</p>
    <p>- документные БД являются хорошим выбором для быстрой разработки</p>
    <p>- В любой момент можно менять свойства данных, не изменяя структуру или сами данные</p>
    <p>Примеры:</p>
    <p>- MongoDB, RethinkDB</p>
  </li>

  <li>Документно-ориентированные БД так же как и ключ-значение имеют какой-то ключ. А в качестве данных мы храним json объект, в котором есть документ. Плюсы - имея ключ к записи мы моментально получаем всю информацию. Гибкость в данных. Нам не надо самому базу данных разрабатывать.</li>

  <li>
    <h2>Графовые БД</h2>
    <p>Особенности:</p>
    <p>- выглядят аналогично сетевым</p>
    <p>- фокусируются на связях между элементами</p>
    <p>- явно отображает связи между типами данных</p>
    <p>- не требуют пошагового обхода для перемещения между элементами</p>
    <p>- нет ограничений в типах представляемых связей</p>
    <p>Примеры:</p>
    <p>Neo4j, JanusGraph, Dgraph</p>
  </li>

  <li>Графы поинтереснее чем иерархическая и сетевая модель. Определенные таблицы - узлы связаны с другими узлами при помощи ребер. И мы можем знать не только информацию об узле, но и каком образом они друг с другом взаимодействуют. Каждая база данных имеет математический аппарат для своей работы. Мы можем делать взаимосвязи, строить сетевые графы. Можем определять степени родства. Можно использовать в соцсетях. А связи будут показывать кто друг, кто заблокирован и т.д.</li>

  <li>
    <h2>Колончатые БД</h2>
    <p>Особенности:</p>
    <p>- БД удобны при работе с приложениями, требующими высокой производительности</p>
    <p>- данные и метаданные записи доступны по одному идентификатору</p>
    <p>- гарантировано размещение всех данных из строки в одном кластере, что упрощает сегментацию и масштабирование данных</p>
    <p>Примеры:</p>
    <p>- Cassandra, HBase</p>
  </li>

  <li>Колончатые БД это интересный подход. Нужны чтобы очень быстро получать информацию к объекты. Есть набор ключей и набор колонок. Для каждого ключа есть колонка значений. Это подход для систем с большим количеством данных.</li>

  <li>
    <h2>БД временных рядов</h2>
    <p>Особенности:</p>
    <p>- ориентированы на запись</p>
    <p>- предназначены для обработки постоянного потока входных данных</p>
    <p>- производительность зависит от количества отслеживаемых элементов, интервала опроса между записью новых значений и фактической полезной нагрузки данных</p>
    <p>Примеры:</p>
    <p>- Prometheus, OpenTSDB, InfluxDB, TimescaleDB</p>
  </li>

  <li>Это база данных, у которой очень быстрая скорость записи. Есть задачи, где надо не потерять ничего, это должно быть очень быстро и очень надежно. Чтобы такие задачи реального времени реализовать есть базы данных временных рядов. В чем у них плюс. Они в поток вбивают свои данные без ограничений и другие сервисы могут эту информацию считывать чтобы, например, ее анализировать. Чаще всего они используются для потоковых данных. У Postgres есть расширение которое включает в Postgres временные ряды.</li>

  <li>
    <h2>NewSQL БД</h2>
    <p>NewSQL БД наследуют реляционную структуру и семантику, но построены с использованием более современных, масштабируемых конструкций. Цель - обеспечить большую масштабируемость, нежели реляционные БД, и более высокие гарантии согласованности, чем в NoSQL.</p>
    <p>Особенности:</p>
    <p>- возможность горизонтального масштабирования</p>
    <p>- высокая доступность</p>
    <p>- большая производительность и репликация</p>
    <p>- небольшой функционал и гибкость</p>
    <p>- немалое потребление ресурсов и необходимость специализированных знаний для работы с базой данных</p>
    <p>Примеры:</p>
    <p>- MemSQL, VoltDB, spanner, Calvin, CockroachDB, FaunaDB, YugabyteDB</p>
  </li>

  <li>
    <h2>Многомодельные БД</h2>
    <p>Многомодельные базы данных - базы, объединяющие функциональные возможности нескольких видов БД. Преимущества такого подхода очевидны - одна и та же система может использовать различные представления для разных типов данных.</p>
    <p>Особенности:</p>
    <p>- помогают уменьшить нагрузку на СУБД</p>
    <p>- позволяют расширяться до новых моделей по мере изменения потребностей без внесения изменений в базовую инфраструктуру</p>
    <p>- обеспечивают непрерывный доступ и простое распределение данных</p>
    <p>- имеют линейную масштабируемость и просты для разработки</p>
    <p>Примеры:</p>
    <p>- ArangoDB, OrientDB, Couchbase</p>
  </li>

  <li>Это не отдельный класс задач, а системы собранные из своих концепций и имеют свой инструментарий.</li>

  <li>
    <h2>Реляционные СУБД (РСУБД)</h2>
    <p>MS SQL Server</p>
    <p>Oracle</p>
    <p>PostgreSQL</p>
    <p>SQLite</p>
    <p>MySQL</p>
    <p>MariaDB</p>
    <p>Microsoft Access</p>
    <p>и т.д.</p>
  </li>

  <li>Что такое реляционные БД? Таблицы, колонки, строки, отношения. У нас есть база данных, в которой данные мы организуем в виде таблиц. В таблице есть набор колонок column, которая является характеристикой объекта и есть строка row это уже непосредственно объект. Такая таблица описывает нашу предметную область. Если надо что-то поменять, то мы добавляем таблички но при этом модернизируем сам софт. Это минус, это достаточно дорого.</li>

  <li>
    <h2>ER-диаграммы. Нотация</h2>
    <p>Это отношения между блоками. Entity, Relationships, Many-to-One, Many-to-Many. Это ядро нашей базы данных. Структурированная система. Зная эту диаграмму можно уже работать с данными.</p>
  </li>

  <li>
    <h2>Ключи</h2>
    <p>Таблицы связываются при помощи ключей. Ключ это одно или несколько полей, которое определяет уникальность, по которому можно определить что за объект хранится в данной строке. PK - Primary Key бывает простой и составной и идентифицирует записи. FK - Foreign Key по которому ссылаемся на другую запись.</p>
  </li>

  <li>Поскольку у нас большое количество ключей, то на больших объемах они начинают подтормаживать. Многие компании сознательно отказываются от установки жестких Foreign Key для того, чтобы обеспечить более быструю скорость работы с данными. В этом случае у нас нет защиты и мы можем что-то удалить. Удалить справочник клиентов, например, и у нас все накладные поломаются. Разработчики идут на риск, чтобы в отсутствии внешнего ключа можно было больше клиентов обработать. Обычно все отлаживают, долго тестируют и если никаких проблем нет, аккуратно ключи удаляют. И потом трясутся чтобы ничего не сломалось.</li>

  <li>
    <h2>Ограничения</h2>
    <p>Not Null - запрет на пустые значения</p>
    <p>UNIQUE - значение в таблице в колонке должно быть уникально</p>
    <p>PRIMARY KEY - первичный ключ должен быть уникальным и не пустым</p>
    <p>FOREIGN KEY - можно хранить только значения, которые есть в связанной таблице в ее первичном ключе</p>
    <p>CHECK - значение должно удовлетворять заданному условию</p>
    <p>DEFAULT - значение по умолчанию, записываемое при вставке записи</p>
  </li>

  <li>На каждые ключи, на базу, на таблицу мы можем навесить ряд ограничений. У разных СУБД набор ограничений разный.</li>

  <li>
    <h2>Индексы</h2>
    <p>- Кластеризованые</p>
    <p>- Нк кластеризованые</p>
  </li>

  <li>Если база данных маленькая, то мы всю ее можем обратобать в памяти, а если большая то мы уже начинаем просаживаться по скорости. Простым перебором мы уже не сможем сделать. И чтобы сократить время поиска информации были придуманы индексы. Индексы это служебные таблички в которых лежат указатели с адресами таблиц где какая информация лежит. Это используется не только для того чтобы можно было сделать селект данных. По индексам можно делать и всевозможные проверки уникальности. На одну таблицу может быть несколько индексов на одно или несколько полей. Не кластеризованный индекс на одну таблицу может быть только один. Кому интересно почитайте как работают индексы.</li>

  <li>Мне пришлось писать базу данных. Это была простая проверка телефонных логов. И мне по ним нужно было быстро искать. Простой перебор был написан достаточно быстро, но работал по паре часов. Пришлось это все ускорять. И я сделал примитивную систему индексов. Получилось ускорение раз в 100. И я понял что правильный индекс это для базы данных очень хорошо.</li>

  <li>
    <h2>Какие бывают индексы:</h2>
    <p>- простые</p>
    <p>- уникальные</p>
    <p>- составные</p>
    <p>- частичные</p>
    <p>- полнотекстовые</p>
    <p>- пространственные</p>
    <p>и т.д.</p>
  </li>

  <li>
    <h2>Триггеры</h2>
    <p>Триггер - это SQL процедура, которая срабатывает при каком-нибудь событии (INSERT, DELETE или UPDATE).</p>
    <p>Триггер может вызываться до или после выполнения изменения (BEFORE, AFTER)</p>
    <p>Триггеры хранятся и управляются СУБД</p>
    <p>Триггер не может быть вызван или выполнен вручную, СУБД автоматически вызывает его после модификации данных в соответствующей таблице</p>
    <p>Триггер имеет возможность сравнивать существующие и новые данные в измерняемых строках</p>
    <p>Триггеры действуют в рамках родительской транзакции</p>
  </li>

  <li>
    <h2>Процедуры/Функции</h2>
    <p>MySQL</p>
    <p>PostgreSQL</p>
  </li>

  <li>Процедуры и функции имеют разный синтаксис и в разных СУБД будут действовать по разному. Смысл в том что мы какую-то логику можем перенести в СУБД и потом использовать.</li>

  <li>
    <h2>Виды, материализованные виды (SQL Views)</h2>
    <p>Например, у нас есть много таблиц данных и нам надо из них сделать отчет и получить на выходе одну таблицу данных.</p>
  </li>

  <li>
    <h2>Транзакции</h2>
    <p>Транзакция - неделимая с точки зрения воздействия на базу данных цепочки операций, выполнямых по принципу "или ВСЕ, или НИЧЕГО"</p>
  </li>
  
  <li>
    <h3>ACID свойства:</h3>
    <p>Atomacity (атомарность) - гарантия того, что выполнятся все операции транзакции либо не выполнится ни одна.</p>
    <p>Consistency (непротиворечивость) - состояние базы данных находится в непротиворечивом состоянии до и после выполнения транзакции.</p>
    <p>Isolation (изоляция) - во время выполнения транзакции другие процессы не должны видеть данные в промежуточном состоянии.</p>
    <p>Durability (долговечность) - гарантия того, что если получено уведомление об успешном выполнении транзакции, можно быть уверенным, что изменения не будут отменены из-за какого-либо сбоя.</p>
  </li>

  <li>
    <h2>Уровни изоляции транзакций</h2>
    <p>0. Неподтвержденное чтение (Read Uncommitted, Dirty Read, грязное чтение). Чтение незафиксированных изменений своей транзакции и конкурирующих транзакций, возможны нечистые, неповторяемые чтения и фантомы.</p>
    <p>1. Подтвержденное чтение (Read Commited). Чтение всех изменений своей транзакции и зафиксированных изменений конкурирующих транзакций, нечистые чтения невозможны, возможны неповторяемые чтения и фантомы.</p>
    <p>2. Повторяемое чтение (Repeatable Read, Snapshot). Чтение всех изменений своей транзакции, любые изменения, внесенные конкурирующими транзакциями после начала своей, недоступны, нечистые и неповторяемые чтения невозможны, возможны фантомы.</p>
    <p>3. Упорядоченный (Serializable, сериализуемый). Чтение транзакции выполняются в строгой последовательности, результаты действий которых не зависят от порядка выполнения шагов транзакции (запрещено чтение всех данных измененных с начала транзакции, в том числе и своей транзакцией), фантомы невозможны. Чем выше уровень изоляции, тем больше требуется ресурсов, чтобы их поддерживать.</p>
  </li>

  <li>
    <h2>Блокировки</h2>
    <p>По области действия</p>
    <p>- на поле</p>
    <p>- на запись (на набор записей)</p>
    <p>- на таблицу (на набор таблиц)</p>
    <p>- на БД</p>
    <p>По строгости</p>
    <p>- Совместная</p>
    <p>- Исключительная</p>
    <p>По логике реализации</p>
    <p>- оптимистическая</p>
    <p>- пессимистическая</p>
  </li>

  <li>
    <h2>Нормализация (1,2,3 формы)</h2>
    <p>Нормализация это процесс разбития на небольшие кусочки. Из одно таблицы с базой данных получается несколько таблиц. Чем больше мы разбиваем тем сложнее становится. И это не всегда эффективно. Надо искать компромисс. Нормализовывать надо до того уровня когда это приносит пользу.</p>
  </li>

  <li>
    <h2>Плюсы реляционных БД</h2>
    <p>Хорошо подходит для того чтобы хранить и обрабатывать редко изменяемые структурированные данные.</p>
    <h2>Минусы реляционных БД</h2>
    <p>Изменения. Если надо часто менять базу данных то это будет выходить дороже.</p>    
  </li>

  <li>
    <h2>DDL - Data Definition Language</h2>
    <p>Это специальный язык, который позволяет создать и описать нашу базу данных. Чаще всего стараются писать базу данных при помощи средств разработки. Получается красивая база данных, но при попытке перенести - единственный способ это backup. Альтернативный способ, очень правильный и я рекомендую им пользоваться, это создавать базу данных при помощи команд (create database, create table, alter table, truncate table). Можете написать скрипт, который при помощи команд базу данных с нуля создаст и заполнит данными. У вас будет просто текстовый файлик, который вы можете положить на гит и с ним прекрасно работать. Это неплохой способ.</p>
  </li>

  <li>
    <h2>SQL</h2>
    <p>SQL - это язык структурированных запросов, предназначенный для манипулирования данными в реляционной базе данных.</p>
    <p>SQL - стандартный язык для системы реляционных баз данных. Все системы управления реляционными базами данных (RDMS), такие как MySQL, MS ACCESS, Oracle, Sybase, Informix, Postgres и SQL Server, используют SQL в качестве стандартного языка баз данных.</p>
    <p>Различные СУБД могут использовать собственные диалекты, такие как:</p>
    <p>- MS SQL Server с использованием Transact-SQL</p>
    <p>- Oracle с использованием PL/SQL</p>
    <p>- PostgreSQL - PL/PgSQL</p>
  </li>

  <li>SQL это язык для манипулирования данными. Есть базовый язык и есть нотации для каждого языка, которые уже разработчики делают. Например для MS SQL есть Transact SQL, для Oracle это PL/SQL. Это язык который позволяет вставить данные, получить данные.</li>

  <li>
    <h2>SQL (structure query language) - Insert</h2>
    <p>Как можно при помощи SQL вставить запись. Insert внутрь таблицы. Указываем какие нужны колонки и какие в эти колонки вставить values. Если надо вставить много. Сделаем insert в таблицы, указываем колонки и сделаем подзапрос заполнить таблицу из другой таблицы.</p>
    <pre>
      INSERT INFO table_name (column1, column2, column3, ...)
      VALUES (value1, value2, value3, ...)
    </pre>
    <pre>
      INSERT INFO table2 (column1, column2, column3, ...)
      SELECT column1, column2, column3, ...
      FROM table1
      WHERE condition;
    </pre>
  </li>

  <li>
    <h2>SQL - Update</h2>
    <p>Обновить таблицу. В какие колонки что надо поставить, где какое-то условие. Где id=10 например.</p>
    <pre>
      UPDATE table_name
      SET column1 = value1, column2 = value2, ...
      WHERE contidion;
    </pre>
  </li>

  <li>
    <h2>SQL - Delete</h2>
    <p>Delete здесь все просто. Удалить из таблицы, где условие. Мы можем удалить одну или несколько записей, где выполняется условие. Truncate table мы можем удалить всю таблицу, все данные. Например, какие-то логи нам уже не нужны и delete from table пересчитывать будет долго. Он тоже все удалит, но на больших данных truncate это сделает мгновенно.</p>
    <pre>
      DELETE FROM table_name WHERE condition;
    </pre>
    <pre>
      TRUNCATE TABLE table_name;
    </pre>
  </li>

  <li>
    <h2>SQL - Select</h2>
    <p>Select это получение доступа. Мы можем стделать select каких-то колонок из какой-то таблицы по условию. Мы должны сформировать запрос, объединить данные, чтобы получить то что нам надо. И СУБД на основании языка эти данные предоставит.</p>
    <h3>AND Syntax</h3>
    <pre>
      SELECT column1, column2, ...
      FROM table_nameWHERE condition1 AND condition2 AND condition3 ...;
    </pre>
    <h3>OR Syntax</h3>
    <pre>
      SELECT column1, column2, ...
      FROM table_name
      WHERE condition1 OR condition2 OR conditio3 ...;
    </pre>
    <h3>NOT Syntax</h3>
    <pre>
      SELECT column1, column2, ...
      FROM table_name
      WHERE NOT condition;
    </pre>
  </li>

  <li>
    <h2>SQL - Агрегирующие функции / Группировка</h2>
    <p>Есть простой WHERE, а есть агрегирующие функции с группировкой GROUP BY, ORDER BY. Получаем колонку из таблицы по условию и делаем группировку и сортировку.</p>
    <pre>
      SELECT column_name(s)
      FROM table_name
      WHERE condition
      GROUP BY column_name(s)
      ORDER BY column_name(s);
    </pre>
    <h3>The SQL COUNT(), AVG() and SUM() Functions</h3>
    <p>Если нужно отфильтровать поля, то в select мы можем их заагрегировать. По группировке таблица будет схлопнута, по AVG будет сумма подсчитана. Если нужно поле отсортировать то используем оператор having. Например, покажи все позиции , где сумма больше 10.</p>
    <pre>
      SELECT column_name(s)
      FROM table_name
      WHERE condition
      GROUP BY column_name(s)
      HAVING condition
      ORDER BY column_name(s);
    </pre>
  </li>

  <li>
    <h2>SQL - Joins</h2>
    <p>Типы объединений:</p>
    <p>(INNER) JOIN Возвращает записи, значения которых совпадают в обеих таблицах</p>
    <p>LEFT (OUTER) JOIN Возвращает все записи из левой таблицы и соответствующие записи из правой таблицы</p>
    <p>RIGHT (OUTER) JOIN Возвращает все записи из правой таблицы и соответствующие записи из левой таблицы</p>
    <p>FULL (OUTER) JOIN Возвращает все записи, если есть совпадения в левой и правой таблице</p>
    <p>Специально внес потому что многие путают. Смотрите как это работает. У нас есть всего два вида объединения inner join и outer join. Для inner join можно опустить слово inner, получается select join table1 и table2. В обычном join мы по ключу пересекаем поля которые есть и в первой таблице и во второй. inner внутренний, outer внешний. Разница в чем? Когда мы делаем внешнее соединение. Я на собеседованиях спрашиваю: что делает операция lleft inner join? Из десяти девять точно начинают мне объяснять что она делает. На самом деле inner только для простого join. Left это для outer. Вот такая ловушка. Что делает left join? У нас есть левая табличка которая объединяется с правой по какому-то условию. left join возвращает все поля из левой таблицы, абсолютно все и добавляет к ним те записи включая пустые значения которые есть в правой. Если есть соответствие левой и правой таблицы, то там будут заполнены поля, если нет соответствия, то правая таблица будет нулями заполнена.full join мы возвращаем все записи левой и правой таблицы. Есть еще cross join это через запятую. Каждая таблица будет перечисление всех полей. До того как join ввели в обиход, все таблицы связывались через запятые.</p>
  </li>

  <li>
    <h2>SQL - Inner join</h2>
    <pre>
      SELECT column_name(s)
      FROM table1
      INNER JOIN table2
      ON table1.column_name = table2.column_name;
    </pre>
  </li>

  <li>
    <h2>SQL - Left join</h2>
    <pre>
      SELECT column_name(s)
      FROM table1
      LEFT JOIN table2
      ON table1.column_name = table2.column_name;
    </pre>
  </li>

  <li>
    <h2>SQL - Right join</h2>
    <pre>
      SELECT column_name(s)
      FROM table1
      RIGHT JOIN table2
      ON table1.column_name = table2.column_name;
    </pre>
  </li>

  <li>
    <h2>SQL - Full join</h2>
    <pre>
      SELECT column_name(s)
      FROM table1
      FULL OUTER JOIN table2
      ON table1.column_name = table2.column_name
      WHERE condition;
    </pre>
  </li>

  <li>
    <h2>SQL - Вложенные запросы</h2>
    <p>Можно использовать LEFT JOIN, можно использовать вложенные запросы</p>
  </li>

  <li>
    <h2>Оптимизация, execution plan</h2>
    <p>В СУБД есть такая вещь как execution plan. Его можно достать или при помощи команд или визуально посмотреть. Он показывает как СУБД разобрал ваш запрос. Вы можете посмотреть где у вас узкое место и вы можете переписать запрос. Если вы напишете запрос правильно, он будет работать быстрее чем неправильный запрос. Чем меньшим количеством данных вы будете оперировать, то есть как можно раньше отсечете все ненужное, тем эффективнее будет работать запрос. Он достаточно умный, умеет кешировать, умеет разбирать. Вплоть до того если вы будете один запрос несколько раз запрашивать, он его даже стирать не будет. "Вы тоже самое просите? - На те вам теже самые данные". Он сам себе что-то закэшировал.</p>
  </li>

  <li>По реляционке наверно уже хватит. Дальше дело практики. Многие с ней работали. Дальше поговорим о нереляционной базе данных. Нереляционки. Зачем они были придуманы? Как я уже говорил, реляционки они достаточно тяжелые в поддержке, их надо придумать. Качественно придумать структуру баз данных это наука. "Навскидку, я сейчас все сделаю, все получится" - нет , ничего не получится, там надо серьезно разбираться. Надо уже мыслить концепциями таблиц, колонок. Еще есть минусы, что она плохо работает с неструктурированными данными, требует дополнительных расходов. Народ начал придумывать альтернативные вещи. Все нереляционки называются NoSQL.</li>

  <li>
    <h2>NoSQL</h2>
    <p>Key-Value Store. Например, redis, riak</p>
    <p>Wide Column Store. Например, HBase, cassandra</p>
    <p>Document Store. Например, mongoDB, CouchDB</p>
    <p>Graph Store. Например, Neo4j, InfiniteGraph</p>
  </li>

  <li>
    <h2>Отличие NoSQL от РБД</h2>
    <p>В структурированной Relational data model все четко. Таблицы, связи, перечисления. А в document data model есть документик, в котором что-то хранится в каком-то виде. Это может быть json, xml, бинарный формат. Внутри каждого элемента хранятся все данные о нем. И получив такой документ мы получаем всю информацию. Плюсы: можно делать связи, можно эффективно использовать место. Не надо думать о том ЧТО мы там храним, а надо правильно обрабатывать то что туда записали. Следить только за версионностью документа. Сами СУБД структурно проще и быстрее работают. Но не всегда. На самом деле это не так.</p>
  </li>

  <li>
    <h2>Документ в NoSQL</h2>
    <p>Может быть любой уровень вложенности. Плюсы - достали все за раз. Минусы - чтобы изменить элемент нужно пробежаться по всем элементам и поменять его везде.</p>
  </li>

  <li>
    <h2>Плюсы и минусы NoSQL БД</h2>
    <p>Плюсы. Гибкость данных. Более простые СУБД. Лучше масштабируются. Нет необходимости высокой квалификации программиста, поддержка проще.</p>
    <p>Минусы. Надо четко следить за БД. Сложнее обслуживать.</p>
  </li>

  <li>Про сами СУБД поговорили. Любую СУБД надо будет изучать когда вы будете с ней работать. Там есть и плюсы и минусы. Как к ней подключаться. Это уже дело практики.</li>

  <li>
    <h2>Промышленное использование СУБД</h2>
    <p>Особенности промышленного использования СУБД</p>
    <p>- Отказоустойчивость</p>
    <p>- Скорость записи и чтения</p>
    <p>- Надежность</p>
    <p>- Масштабирование</p>
    <p>- Непрерывность работы</p>
  </li>

  <li>
    <h2>Репликация</h2>
    <p>Представьте что есть одна СУБД, которая очень сильно нагружена. Нагружена на чтение. Много клиентов ее смотрят. Если будет одна база данных то начнутся проблемы. Будут тормоза. Разбить на несколько баз данных не очень хорошо. Как потом собрать эти данные в кучу? В одной копии измените запись и в другой копии измените эту запись на другое значение. СУБД между собой не взаимодействуют. Клиенты пишут в базу данных а у вас потом проблемы. В таком случае применяют репликацию. Выделяется одна база данных DB Primary куда все можно записать. Она все передает на другие базы данных - реплики DB Replica. Получается мы записали в одну базу данных и эта информация появилась во всех. Если клиенту надо записать в базу данных то через балансировщик Load Balancer он подключается к первой базе данных, а если надо прочитать, то он подключается к любой свободной. В итоге базы данных на чтение можно масштабировать. В итоге мы уменьшаем очередь появления информации на стороне клиента. Можно делать копии через backup.</p>
  </li>

  <li>
    <h2>Партиционирование</h2>
    <p>Представьте что у вас база данных с немеренным количеством данных. Например, соцсеть.</p>
  </li>

  <li>
    <h2>Шардирование</h2>
  </li>

  <li>
    <h2>Файловеры</h2>
    <p>Если сгорит база данных то исчеснет вся база. Применяется файловер. Это копия базы данных. Если с оригиналом чтото случается, то запасная базаданных становится главной. Какое то время эта база данных работает. За это время мы чиним второй файловер, его восстанавливаем и делаем его stand by.</p>
  </li>

  <li>
    <h2>Резервные копии</h2>
    <p>Виды резервного копирования баз данных</p>
    <p>- Полное резервное копирование</p>
    <p>- Дифференциальное резервное копирование</p>
    <p>- Инкрементное резервное копирование</p>
    <p>- Обратное инкрементное резервное копирование</p>
  </li>

  <li>Это очень важно. Никогда не игнорируйте резервное копирование базы данных. Резервная копия зачастую может спасти кучу нервов. У меня был опыт. Все было хорошо. Не сделал бэкап, потому что 200 раз его делал и ничего не случилось. В этот раз не стал делать. Просто накатил скрипт на рабочую базу данных, который делал мелкую правку. Даже не тестировал. Когда скрипт выполнился. Это заняло пару секунд. Я вспомнил что забыл написать WRF в запросе. В итоге все данные были приведены к одному значению. Я name пытался у кого-то поменять и все клиенты стали однофамильцами. Ошибся в запросе. Бэкапа у меня не было. Через 15 минут я получил звонок с отдела продаж - "что за ерунда?". Меня спасло то что у меня был бекап системный, который делался раз в день. И я его откатил на несколько часов назад. Потом ходил помогал восстанавливал руками данные которые за этот день накопились. Лучше пусть вам не пригодится чем у вас этого не будет. Как и копирование не только базы данных но и своих исходных кодов. Если вы что-то сделали - сохраните это куда нибудь, в гитхаб выложите.</li>

  <li>
    <h2>Full Backaup</h2>
    <p>Это самое популярное резервное копирование. Делаете один раз в неделю.</p>
  </li>

  <li>
    <h2>Differential Backup</h2>
    <p>Раз в день копируйте те изменения которые происходят. Когда надо будет восстановить, мы позьмем полный бэкап и будем накатывать на него изменения.</p>
  </li>

  <li>Так как мы будем писать на си шарп код, какие у нас есть варианты работы с базой данных? Каждая СУБД предоставляет свой драйвер, определенный провайдер. Есть провайдеры неродные. Можете свой провайдер написать если ваб будет удобнее и быстрее. Есть платные провайдеры. Можете их в NuGet найти.</li>

  <li>
    <h2>Провайдеры</h2>
    <p>MS SQL Server System.Data.SqlClient</p>
    <p>Oracle ODP.NET</p>
    <p>PostgreSQL Npgsql</p>
    <p>MySQL MySQL.Data.MySqlClient</p>
    <p>MongoDB MongoDB.Driver</p>
    <p>Redis StackExchange.Redis</p>
    <p>Memcached EnyimMemcachedCore</p>
    <p>Cassandra CassandraCSharpDriver</p>
    <p>Neo4j Neo4j.Driver.Simple</p>
  </li>

  <li>
    <h2>ORM - Object-relational mapping</h2>
    <p>Это вводная часть. К нас потом будет большая лекция. ORM это подход, когда мы должны отвязять нашу базу данных от кода. Если раньше мы писали SQL запросы join, seect, четко вламывались в нашу базу данных, с ней интегрировались на 100%, выжимали из нее все соки. В итоге очень эффективно меж собой работали. Плюсы - мы эффективно отработали. Минусы - мы завязаны на одну базу данных, надо имать достаточную квалификацию, могут быть SQL инъекции. ORM это альтернативный подход, когда пытаемся программиста оградить от базы данных, потому что ему трудно понять базу даных. На самом деле не рекомендую такой подход. Разберитесь с базами. Хуже не будет. Но отказ от прямой работы с базой данных это не хорошо. Что предлагает ORM? У нас есть база данных. Мы ее описываем в виде метаданных. И при помощи тулзов работаем с базой данных. В итоге есть набор слоев между базой данных и между нами. Смысл ORM это данные, которые приходят от СУБД трансформируются в объекты и отдаются нам. Мы при помощи СУБД и провайдера превращаем наш запрос в SQL запрос и отправляем на SQL. Таким образом мы можем менять СУБД. Путем отключения базы данных и подключения провайдера. И мы защищены от прямых инъекция в базы данных. Минусы - целая куча кода посередине. Если ORM некачественно сделали то мы теряем производительность. Сдесь нужно соблюдать балланс. ORM сейчас на достаточно высоком уровне. И они уже очен хорошо работают. 
    </p>
  </li>

  <li>
    <h2>ORM - Entity Framework</h2>
    <p>Database First Approach</p>
    <p>Code First Approach</p>
  </li>

  <li>Какие у нас есть ORM? Один из ORM это Entity Framework.  У нас есть подходы к ORM. Это есть в лекциях отдельно. Мы можем взять базу данных, превратить в код и у нас будет entity понимать что мы хотим с этой базой данных оперировать. Можно на базу данных наплевать. Мы создаем код, который по правилам описан, работаем с кодом, а база данных гдето там лежит</li>

  <li>
    <h1>ORM - NHibernate</h1>
    <p>Есть ORM NHibernate. Мы описываем мапинг при промощи xml. И после этого мы можем общаться напрямую. NHiberNate будет брать на себя работу всю.</p>
  </li>

  <li>
    <h2>ORM - Dapper</h2>
    <p>Есть еще вариант Dapper но это еще не совсем URM. Это по сути мапер. Что он делает? Низкоуровневая система. Мы включаем SQL запрос. Выполняем запрос на какой-то конекшион к любой базе данных. Тогда SQL запрос нужно написать к этой базе данных, с той нотацией которую он поддерживает. И после этого мы просто получаем результат и мапим его на определенных класс. Он автоматически превращаем наши запросы в объкт. И дальше мы с ним работаем как с объектом. Но при этом мы не можем модифицировать базу данных. Мы будем на практике работать с Entity. В принципе про базу данных все что я хотел рассказать я рассказал.</p>
  </li>

  <li>
    <h2>Вопросы?</h2>
  </li>
</ul>