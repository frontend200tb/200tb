<a href="#" id="edu-dsr">назад</a>

<h1>2023-11-13 DSR .NET School 2023 Lecture #7 Net platform</h1>

<h2>Лекция 7. Платформа .Net</h2>

<ul>
  <li>Здравствуйте. Сегодня мы очередную лекцию начинаем. Мы приближаемся непосредственно к практическим задачам. И сегодня у нас лекция будет посвящена платформе .net. Она не такая длинная. Я думаю мы ее пораньше немножко сегодня закончим. И со следующей лекции у нас будут практические части, где мы будем обсуждать про web API и конкретно изучать, какие там элементы, из чего она состоит, на что стоит на старте внимание обратить. И если все хорошо будет, то на следующей неделе у нас начнется практика.
  </li>

  <li>
    <h2>О чем будет эта лекция</h2>
    <p>- что такое фреймворк</p>
    <p>- что такое платформа .net</p>
    <p>- как она работает и из чего состоит</p>
    <p>- вехи развития фреймворка</p>
    <p>- основные понятия фреймворка</p>
    <p>- что такое сборщик мусора</p>
    <p>- область применения</p>
  </li>

  <li>Мы сегодня поговорим о платформе .net и фреймворках на ее базе. Поговорим о сборщике мусора, о памяти. И где она применяется. Пол лекции будет просто так ознакомительные, легкая. Но половину лекции стоит посмотреть, потому что часто задают это на собеседованиях. Обзорно мы сегодня это обсудим. Если будут вопросы - задавайте. Если будет желание изучить поглубже, то это на самостоятельное обучение. Информации у нас достаточно. Любая серьезная книжка расскажет побольше. Давайте начнем</li>

  <li>
    <h2>Что такое фреймворк?</h2>
    <p>Сначала программисты писали все "с нуля" (работу с файлами, текстом, математические функции и т.д.). Потом еще раз тоже самое, потом еще раз.</p>
    <p>В итоге он выделил все в отдельный набор функций, который стал БИБЛИОТЕКОЙ</p>
    <p>Со временем программист начал понимать, что все приложения, которые он пишет, примерно похожи друг на друга (состоит из одних частей, имеет сходную структуру и т.д.)</p>
    <p>Была выделена система, которая делала что-то абстрактное, общее, в которую внедряется уникальный код, который делал специфику. Получился ФРЕЙМВОРК.</p>
    <p>Подумали еще и объединили фреймворки и получили СТЭК ФРЕЙМВОРКОВ</p>
  </li>

  <li>Кто знает чем отличается фреймворк от библиотеки? Напишите в чате фреймворк и библиотека это одно и то же? "Фреймворк это целая система включающая несколько библиотек". Ну и библиотека может включать несколько библиотек. Например, библиотеки с сетью, с видео, со звуком. И будет такая большущая библиотека, но фреймворком она считаться не может.</li>

  <li>Смотрите. Изначально, когда программисты только начинали свою работу. Когда программы только появлялись, они были у каждого свои. Сети не было, обмен информации на перфокартах, потом на дискетках. На старте ничего не было. Когда программист писал свой софт, он понимал что некоторые вещи он делает одно и то же. И выносил это в функции, наприме, работа с математикой. И формировались кусочки повторяемого кода, которые он начинал таскать от приложения к приложению. Я думаю у каждого есть такая библиотечка, которая уже требует большого рефакторинга. Зато удобно, привыкли и т.д. У меня их тоже было немеряно и сейчас есть. Вот такой набор функций, потом кто-то сел привел все это в порядок, выкинул лишнее и это стало называться библиотекой. Библиотека это набор функций, метод, правил, которые определяют какое-то действие. И вы когда подключаете библиотеку - просто пользуетесь функционалом.</li>

  <Li>Проходит время. Программисты пишут. И понимают что уникальных задач не так уж и много. Если он в какой-то нише работает, например, разрабатывает сайты. У сайтов одно ядро - работа с http, работа с request/response, обработка логов, работа с юзерами, аутентификация, авторизация. Они очень сильно похожи. И когда программист начинает писать новый сайт, он берет свой старый продукт, чистит его до какого-то общего состояния и начинает в него писать что-то еще. Со временем эта тенденция была выявлена. И получилось так, что можно написать какой-то кусок кода, в который внести изменения и этот код будет по одним правилам выполнять разные задачи. И этот подход, при котором у нас есть уже написанный скелет и в него мы вносим уже какую-то логику, и называется Фреймворк. В этом отличие. Библиотеку подключаем и используем ее готовые функции. А в фреймворке мы пишем по определенным правилам.</Li>

  <li>Например, есть библиотека Math. Это библиотека оформленная в виде статического класса, в котором есть куча чего-то. Есть фреймворк asp.net для создания MVC приложений. У вас уже из коробки есть куча кода. И вы пишете контроллер. Вас не волнует каким образом делать роутинг. Вы пишите только внутренность сайта. А все что снаружи за вас написал уже фреймворк. Если вы работаете на .net то это уже целый стэк фреймворков. Есть фреймворк и для web api и для мобильного приложения.</li>

  <li>
    <h2>Платформа .Net</h2>
    <p>Среда выполнения (Execution Runtime Environment)</p>
    <p>Программное обеспечение (Software)</p>
  </li>

  <li>Давайте немного поговорим про платформу .net. Еще до появления всяких платформ, а .net не первая появилась, до не еще было. У нас была среда выполнения (Execution Runtime Environment), например, компьютер и программное обеспечение (Software), которое было заточено под нашу среду выполнения. Например мы запускали .exe файл и он работал на виндовсе. И windows уже сам работал с аппаратным обеспечением, подключался к винчестеру, к памяти. В чем здесь особенность? Под каждую среду выполнения (операционную систему) нам надо писать свою программу. Например, приложения которые хорошо работали на pentium, уже не могли работать на 486-ом. 32 битные приложения и 64 битные приложения. Приложения из одной системы линукс не могли запускаться на другой системе линукс. Все операционные системы были вразноброд, они и сейчас-то вразноброд. У каждого свои подходы, свои api. Поэтому нельзя было сделать приложение которое могло работать во всех системах.</li>

  <li>Как работает .net? У нас есть программа. Программа бывает интерпретируемая или компилируемая. Интерпретируемая программа выполняет те команды, которые в ней записаны как текст. И если есть интерпретатор под разные операционные системы, то программа может заработать на разных операционных системах. Например код php будет работать и в интерпретаторе под линукс и под виндовс. То же python и javascript. Компилируемая программа компилируется в промежуточный код и работает через библиотеки с операционной системой. Здесь можно сделать кросспратформенность, но при этом мы теряем в скорости. Потому что каждый раз мы должны работать с кодом. К компилируемым относятся java, pascal, c#, typescript.</li>

  <li>
    <h2>Как работает платформа</h2>
    <p>Как было раньше:</p>
    <p>- или компилировалось в исполняемый файл</p>
    <p>- или представляло собой COM объект</p>
    <p>Чем .net лучше:</p>
    <p>- упрощена модель установки (Global Assembly Cache)</p>
    <p>- обратная совместимость</p>
    <p>- независимость от языка программирования</p>
    <p>- и, с недавнего времени, кроссплатформенность</p>
  </li>

  <li>При помощи com объекта можно было сделать драйвер работы с принтером, сканером штрих кодов. Чем .net лучше? Когда придумывали технологию java, еще раньше чем .net. Использовали такой подход. Для каждой машины создавалась виртуальная машина (java virtual machine). И виртуальная машина брала на себя всю работу с операционной системой. Программист писал код на java и мог запустить его на любой операционной системе если там есть виртуальная машина.</li>

  <li>В .net сделали немножно по-другому. В системе есть Global Assambly Cache куда собираются и кэшируются все кусочки кода и в итоге работают</li>

  <li>Java стал мейнстримом. Захватил разработку тяжелых банковских приложений, корпоративных приложений. Он не очень хорош для написания визуальных приложений. А вот серверную часть на java писать очень хорошо. И бизнес серьезно начал перетекать на java. Microsoft видел что деньги утекают, решил сюда вклиниться и урвать какую-нибудь часть. Они взяли разработчика delphi и он взял все плюсы какие были и сделал первую версию языка c#. Потом он же написал и typescript. Была выпущена платформа .net которая немного отличалась от java. Первые версии были простенькие, глючные. Но постепенно он развился.</li>

  <li>
    <h2>Из чего состоит платформа</h2>
    <p>Общая исполняемая среда (CLR или Core CLR)</p>
    <p>Общая система типов (CTS)</p>
    <p>Общая спецификация языка (CLS)</p>
    <p>Базовая система классов (BCL)</p>
    <p>Фреймворки (Frameworks)</p>
  </li>

  <li>
    <table border="1">
      <tr>
        <td>C#</td><td>F#</td><td>VB.NET</td><td>C++</td><td>IronPython</td><td>IronRuby</td><td>...</td>
      </tr>
      <tr>
        <td colspan="7">Common Language Specification</td>
      </tr>
      <tr>
        <td>WCF</td><td>ASP.NET (WebForms, MVC)</td><td>SignalR</td><td>Windows Foundation</td>
        <td rowspan="2">WPF</td><td rowspan="2">WinForms</td><td rowspan="2">Silverlight</td>
      </tr>
      <tr>
        <td colspan="4">ADO.NET & Entity Framework</td>
      </tr>
      <tr>
        <td colspan="7">Base Class Library (BCL)</td>
      </tr>
      <tr>
        <td colspan="7">Common Language Runtime (CLR)</td>
      </tr>
      <tr>
        <td colspan="7">Operating System</td>
      </tr>
    </table> 
  </li>

  <li>Типовая система .net это слоистая технология. У нас есть операционная система. Ниже аппаратное железо. Над операционной системой мы ставим всю платформу фреймворк .net. Это даже не фреймворк а полноценная разработка. В отличие от java, она ставится на машину целиком. На операционную систему накладывается слой CLR. Она выполняет наш код на конкретно этой операционной системе. Для каждой операционной системы windows, linux, macOs установится своя .net платформа. Следующий слой BCL. Следующий слой набор фреймворков. Следующий это общая спецификация языков. И , наконец, последний это язык программирования.</li>

  <li>Любой человек может взять подходящий ему язык программирования, например, c#. Написать на c# код и потом скомпилировать и он будет выполняться на операционной системе. Причем код будет унифицирован для всех операционок. По сути, операционки для кода уже нет. Не все фреймворки одойдут. Для линукса нет фреймворка WPF, но для него можно использовать сторонний фреймворк Avalonia.</li>

  <li>
    <h2>Common Language Runtime (CLR)</h2>
    <p>Основа - IL (Intermediate Language) или MSIL (Microsoft Intermediate Language) или CIL (Common Intermediate Language)</p>
    <p>****.dll или ****.exe Сборка (Assembly)</p>
  </li>

  <li>Основа для CLR это IL код. Программист пишет исходный код на языке C#. Во время компиляции исходный код компилируется в bytecode, который содержит IL код и метаданные. И этот код записывается в выходной файл в виде исполняемого кода программы. Когда мы запускаем этот файл, то весь код еще раз компилируется в JIT (Just in time) компиляторе для выполнения. То есть во время выполнения байткода CLR переводит этот код в машинный код и исполняет его на операционной системе. Скомпилированные кусочки байткода попадают в кеш. При первом запуске программа работает медленнее. А при повторных быстрее как раз за счет этого кэша.</li>

  <li>Получается два уровня абстракции. Уровень языка, который компилируется в промежуточный код. Промежуточный код, который при помощи JIT компилируется в нативный код. Иногда внутри managed кода (который управляется платформой) сделать unmanaged код. Пометить какой-то блок unsaved, например, вставка на ассемблере. Мы делаем кусок кода, который исключается из работы нашей .net. Он компилируется, мы можем к нему обращаться, но он уже работает минуя всю нашу систему, просто как внешний плагин. В managed code случае .net будет нам помогать, включать garbage collector. А в unmanaged случае все будет под нашу ответственность. Не рекомендуется использовать unmanaged code, но такая возможность есть.</li>

  <li>Кодга мы собираем приложение, мы в итоге можем получить либо dll, либо exe. Все dll которые входят в сборку будут составлять наше приложение.</li>

  <li>
    <h2>Common Type System (CTS)</h2>
  </li>

  <li>В разных языках есть разные типы. В Visual Basic тип Integer и в C# тип int преобразуются в IL в тип Int32. Система типов CTS стандартизирует работу с типами. Она приводит к одному виду разные типы из разных языков.</li>

  <li>
    <h2>Common Language Specification (CLS)</h2>
  </li>

  <li>На платформе CLR есть типы CTS. Язык C# имеет свои типы, другой язык - свои. Все эти множества типов где-то пересекаются и дают CLS. И CLR должна все конструкции языков программирования преобразовать в конструкции CLS. В итоге, у нас есть общая спецификация методов, общее описание типов и наша среда CLR, которая выполняется на операционной системе. Разработчик компилятора должен взять язык, трансформировать все типы данных к списку CTS, а все команды к списку CLS. У нас получается ядро, которое позволяет код на любом языке запускать на любой платформе.</li>

  <li>
    <h2>Base Class Library (BCL)</h2>
    <p>System.Web</p>
    <p>System.Data</p>
    <p>System.Windows.Forms</p>
    <p>System.Drawing</p>
    <p>System.Xml</p>
    <p>System</p>
  </li>

  <li>Чтобы жизнь казалась полегче, разработали BCL. Это набор библиотек, которые собраны внутри неймспейсов, в которых реализованы базовые вещи. Например, работа с коллекциями, со списком, с файлами, с потоками. На уровень выше работа с базами данных, с SQL клиентами. Эти классы это база. Они должны быть у всех. Они разработаны в рамках CLR.</li>

  <li>
  <h2>Фреймворки</h2>
    <pre>
  Sites, Services
  |
  Web Forms, Web Pages, SPA (MVC, Web Api), SignalR
  |
  ASP.NET
    </pre>
  </li>

  <li>Мы, как программисты, работаем в этой области. У нас есть фреймворки, с которыми мы на .net работаем. У нас есть набор готовых систем, с которыми мы должны работать.</li>

  <li>
    <h2>История развития .net</h2>
    <p>Period of .NET Framework</p>
    <p>2002 .NET Framework 1.0</p>
    <p>2003 .NET Framework 1.1</p>
    <p>2005 .NET Framework 2.0</p>
    <p>2006 .NET Framework 3.0</p>
    <p>2007 .NET Framework 3.5</p>
    <p>2010 .NET Framework 4.0</p>
    <p>2012 .NET Framework 4.5</p>
    <p>2013 .NET Framework 4.5.1</p>
    <p>2014 .NET Framework 4.5.2</p>
    <p>2015 .NET Framework 4.6</p>
    <p>2016 .NET Framework 4.6.1</p>
    <p>2017 .NET Framework 4.7</p>
    <p>2019 .NET Framework 4.8</p>
    <p>Period of .NET Core</p>
    <p>2016 .NET Core 1.0</p>
    <p>2017 .NET Core 2.0</p>
    <p>2019 .NET Core 3.0</p>
    <p>Period of .NET</p>
    <p>2020 .NET 5.0</p>
    <p>2021 .NET 6.0</p>
    <p>2022 .NET 7.0</p>
    <p>2023 .NET 8.0</p>
  </li>

  <li>.NET Framework работал только под Windows. И этим проигрывал яве, которая была кроссплатформенной. В .NET Core многие вещи были переписаны в лучшую сторону. Он уже кроссплатформенный.</li>

  <li>
    <h2>Планы развития .Net</h2>
    <p>2019 november .NET 3.1 LTS</p>
    <p>2020 november .NET 5.0 current</p>
    <p>2021 november .NET 6.0 LTS</p>
    <p>2022 november .NET 7.0 current</p>
    <p>2023 november .NET 8.0 LTS</p>
  </li>

  <li>LTS (long Time Support) длится 2 года. Current - промежуточная версия, там добивают свои ошибки. Надо работать на самой свежей версии LTS. Переход между версиями сейчас безболезненный </li>

  <li>
    <h2>.Net Standard</h2>
    <p>APP MODELS</p>
    <p>.NET FRAMEWORK - WPF, Windows Forms, ASP.NET</p>
    <p>.NET CORE - UWP, ASP.NET Core</p>
    <p>XAMARIN - iOS, OS X, Android</p>
  </li>

  <li>Это минимально возможная спецификация, которая для всех общая. Нет стандарт нужен, чтобы разработчики, которые пишут библиотеки, и под каждый новый фреймворк, что-то подписывают. Это было придумано для библиотек. Чтобы им было попроще. Net Standard развивается от версии 1.0 уже до версии 2.1. И есть соответсвия между версиями фреймворка и версией .net standard. Например, net core 3.0 поддерживавет стандарт net standard 2.0.</li>

  <li>
    <h2>Организация памяти</h2>
    <p>Call Stack</p>
    <p>Stack Memory</p>
    <p>Heap Space</p>
  </li>

  <li>Давайте посмотрим как в Нете организована память. Есть два вида памяти - стек и куча. Если открыть стек вызовов (Call Stack), исполнение программы начинается с функции Main(). В стеке хранятся переменные (value) и ссылки (reference). В куче хранятся созданные экземпляры объектов. Стек чистится автоматически. Куча чистится не автоматически. Куча чистится либо при помощи garbage collector либо руками. Если вы пишете на языке C++ или Pascal, то за памятью следите самостоятельно. Если выделяете память, то потом ее нужно удалить. Если не удалите, то скоро память переполнится. И случаются утечки памяти - когда память никто не использует , а она вся занята. В языках java, javascript, c# есть сборщик мусора и за памятью следить не надо. Вы можете создать объект, попользоваться им, и забыть. Не надо ничего помнить. Код гораздо упрощается. Количество ошибок уменьшается. Приложения становятся надежнее и проще. Но имеет и накладные расходы, но мощности компьютеров сейчас такие, что этим можно пренебречь.</li>

  <li>
    <h2>Garbage collector - Как работает</h2>
    <p>Это отдельный процесс, который живет в приложении. Он берет приложение на контроль и за ним следит. Например, у нас есть приложение и у него есть куча созданных объектов, на которые оно ссылается. Сборщик мусора находит все объекты, которые ничьи, на которые нет ссылок и их вырезает. В итоге остаются только те объекты , которые нужны, на которые есть ссылки и памяти становится больше.</p>
  </li>

  <li>
    <h2>Garbage collector - Этапы</h2>
    <p>Marking - Маркирует живые объекты</p>
    <p>Relocating - Обновляет ссылки на объекты, которые будут упакованы</p>
    <p>Compackting - Упаковывает живые объекты</p>
  </li>

  <li>Garbage collector работает в три этапа. Сначала маркирует живые объекты. Подсчитывает какие объекты нужны, а какие нет. Делает релокацию, какие объекты будут упакованы. Живые объекты мы распологаем в памяти так, чтобы не было пропусков, сжимаем память. При этом меняются указатели на эти объекты. И они могут меняться произвольное количество раз за врмя жизни приложения. Поэтому здесь нет смысла хранить указатели. Потому что указатель может поменяться каждый раз когда работает сборщик мусора.</li>

  <Li>Но есть и минус в работе сборщика мусора. Наше приложение работает в несколько потоков. В отдельном потоке запускается сборщик мусора и пока он работает, все остальные потоки ждут (останавливаются, suspended). Каждый раз когда запускается сборщик мусора, наше приложение подвисает. Поэтому сборщик мусора это вещь хорошая, но тоже имеет свои накладные расходы. Чтобы оптимизировать работу сборщика мусора, надо понять что он работает не в туже секунду, когда объект не нужен.</Li>

  <li>
    <h2>Garbage collector - Когда?</h2>
    <p>Когда происходит сборка мусора</p>
    <p>- в системе мало свободной физической памяти</p>
    <p>- Объем используемой приложением памяти превышает постоянно настраиваемый порог</p>
    <p>- Вызван метод GC.Collect</p>
  </li>

  <li>Garbage collector может запуститься когда захочет, когда ему надо. Если в системе много оперативной памяти, то не факт что сборщик мусора вообще запустится. Есть занятая память, которая никому не нужна, но я ее освобождать не буду, потомучто места и так всем хватает. У сборщика мусора есть оптимизационный алгоритм. Для оптимизации он разделяет объекты на три генерации: Generation 0 (short-lived objects), Generation 1, Generation 2 (long-lived objects). Новые созданные объекты сначала попадают в Generation 0. Сборщик мусора часто заглядывает в generation 0 чтобы проверить переменные. Если переменная никому не нужна, то он ее удалит. Если кому-то нужна, то он переместит ее в Generation 1. Сборщик мусора редко заглядывает в generation 1. Но когда заглядывает то смотрит, если переменная никому не нужна, то удаляет ее, а если нужна то перемещает в generation 3. И туда заглядывает еще реже. Сборщик мусора ничего процессах не портит, не влазиет ни в какой проект, он просто говорит "всем стоять", делает свое дело и потом говорит "работайте дальше".</li>

  <li>
    <h2>Области применения .net</h2>
    <p>Web, Mobile, Desktop, Microservices, Gaming, Machine Learning, Cloud, Internet of Things</p>
  </li>

  <li>.net очень хорошо развивается, сейчас это уже приятный язык. Большой спрос на .net разработчиков и в России и в мире. Технология .net стала везде расползаться. Раньше был сторонний проект Xamarin для написания мобильных приложений. Microsoft его выкупил, модернизировал и выпустил maui приложения. И мобильные приложения на maui технологии можно писать. Maui + Blazor можно веб приложения писать. Для тех команд, которые не хотят развивать фронтенд отдел и у них есть сильный бекенд отдел, то для них Blazor позволяет писать веб приложения.</li>

  <li>Пример применения Desktop - WinForms. Классическое windows приложение. Примерно такой подход был реализован в Delphi. Delphi подход мне например больше нравится, у них покрасивее сделано. Мне привычнее. Здесь тоже ничего но не так. Не так удобно, может дело вкуса. На WinForms я немного писал, на Delphi писал достаточно много. Поэтому могу сравнить.</li>

  <li>Пример применения Desktop - WPF. Можно делать приложения не только при помощи форм и окошек, но и при помощи специальных средств. Программируем на C#, а верстка делается на xml подобной верстке xaml. В отличие от раскидывания кнопок в WinForms, в WPF отрисовка декларативная - мы пишем код. В итоге можем красивае приложение получить. Microsoft Visual Studio написана как раз на WPF.</li>

  <li>WEB - ASP.NET WebForms. Это старая технология на aspx. Предполагает писать для веба так же как обычные приложения.</li>

  <li>WEB - ASP.Net MVC. Здесь новые технологии, легковесный фреймворк для того чтобы писать MVC (Model View Controller) приложения. Можно написать контроллер, привязать к нему модель. На базе шаблона и определенных правил будет сформирована реальная картинка в html. Без участия программиста, он будет работать непосредственно в браузере.</li>

  <li>WEB - ASP.Net Razor Pages. Развитием от MVC стал Razor Pages. Это альтернативный способ. Если в MVC мы идем от контроллера к view. То в Razor Pages все инкапсулировано внутрь страницы. У нас есть страница и есть обработчик. Как бы вернулись к WebForms. На самом деле инструмент интересен. Позволяет рисовать красивые простенькие технологии. И достаточно компактный. Мне нравится.</li>

  <li>WEB - ASP.Net WebAPI. В отличие от Razor Pages где с помощью html пользователю дается какая-то красота, в WebAPI пользователю никакая красота не дается, а дается набор методов. При помощи которых мы данные передаем, что-то делаем и данные возвращаем. Чаще всего сейчас это используется для того чтобы писать SPA приложения. Когда фронтенд написан на базе SPA фреймворка - vue, react, angular или blazor. И сервер является бекендом. Плюс на базе WebAPI можно сделать микросервис. Здесь специально фреймворк ASP.Net настроен таким образом, что он возвращает не странички а JSON. И кучу работы с программиста снимает.</li>

  <li>UWP (Universal Windows Program). Он не сильно стал популярным, поэтому не сильно интересен. Это разработка приложений под Windows 10 и выше. Это попытка сделать нативный язык, как на планшетах, но только для Windows.</li>

  <li>XAMARIN / MAUI. Сейчас вышел релиз MAUI, который делает на базе C# кода, компилирует его в нативный код, который запускается на айфоне, андроиде и виндовсфоне. Это кроссплатформенное приложение у которого есть одна кодовая база и два автоматически генерируемых направления. Для написания корпоративных систем, например, корпоративный чат, где не требуется оптимизация или внедрение в систему. Это вполне хороший бизнес продукт. Сейчас для мобилки есть куча других фреймворков. И react native например.</li>

  <li>UNITY. Это написание игрушек. Здесь на C# обрабатывается вся логика. Набор инструментов для работы со спрайтами, с моделями, со звуком</li>

  <li>
    <h2>Что осталось за кадром</h2>
    <p>ML.Net (Machine learning)</p>
    <p>IoT (Intenet of Things)</p>
    <p>Cloud (Azure)</p>
    <p>Microservices</p>
    <p>и так далее</p>
  </li>

  <li>Сейчас много где .net применяется. Работа с фреймворком .net и с C# достаточно прогрессивна и востребована. Если вы их выучите, проблем не будет с трудоустройством. Сейчас во многих компаниях базовый стек веб приложений сдела на .net. Это Касперский, Контур, Озон. Писать для .net на C# достаточно интересно и мне нравится.</li>

  <li>
    <h2>Вопросы?</h2>
  </li>
</ul>