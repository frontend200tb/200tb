<a href="#" id="edu-dsr">назад</a>

<h1>2023-10-23 DSR .NET School 2023/24 Lecture #4 Web application</h1>

<ul>
  <li>
    <p>Здравствуйте. Меня видно? Слышно? Давайте приступим. Прошу прощения за 5 минутную задержку. Настраивал оборудование, чтобы теперь все было хорошо. Первое что я хотел спросить. Нормально ли вам видно экран? Я знаю что у некоторых он очень мелкий. Посмотрите зум - там есть автоувеличение. У кого неудобно смотреть, то тогда попробуйте там. В принципе сегодня слайды будут такие - вчитываться в них не надо. В основном схемки, поэтому будет нормально. Давайте начнем. Чат я буду периодически поглядывать. Так что будут какие-то вопросы - пишите. По ходу дела я буду на них отвлекаться и отвечать. Если вдруг там не отвечу, значит в конце.</p>

    <p>Добро пожаловать на нашу очередную лекцию. Сегодня у нас четвертая лекция. Мы начинаем практическую часть с точки зрения веб приложения. Наш курс называется Web Application. Ну соответственно сегодня мы поговорим что такое веб приложения.</p>
  </li>

  <li>
    <h3>О чем будет эта лекция</h3>
    <p>
      - Что такое веб приложения
      <br>- Что такое Интернет
      <br>- Протоколы
      <br>- Архитектура
      <br>- Серверная часть
      <br>- Клиентская часть
      <br>- Что такое SOAP, REST, GraphQL, gRPC
      <br>- Уязвимости
    </p>
  </li>

  <li>
    <p>Итак, о чем будет сегодняшняя лекция. Сегодняшняя лекция будет так и назваться Веб приложения. Мы поговорим о том что это такое. Поговорим вообще что такое Интернет. Как он работает в целом. Как получается что мы какую-то строчку вводим и она что-то нам находит где что-то лежит. Поговорим более детально о протоколах. Интернет это техническое решение и у него есть свои языки. Протокол это и есть. Архитектуру, серверную часть, клиентскую. Поговорим об архитектурных стилях. Ну и вконце про уязвимости. Чисто так для общего развития.</p> 
    <p>Лекция вводная. Я буду говорить такие общие вещи для того чтобы примерно понимали что это такое. Потому что зачастую, все сосредотачиваются на технической части. Например, пишем сайт и мы упираемся в HTML, CSS и так далее. Но при этом абсолютно не понимая как вообще этот сайт работает. Для большей части программистов, для джунов, это не важно. Важно действительно писать хороший код, решать задачи. Но если вы хотите развиваться дальше, то желательно это понимать и просто интересно как это работает все.</p>
  </li>

  <li>
    <h3>Что такое веб приложение</h3>
    <p>Как было:</p>
    <p>
      - Просто сайт
      <br>- Сайт с какой-то логикой - Интернет-Портал
      <br>- Ну и может быть Интранет-портал
    </p>
  </li>

  <li>
    <p>Что такое веб приложение? В начале давайте в историю немножко окунемся. Изначально был просто сайт. Когда интернет только появился - сделали какой-то сайт. Сайт-визитка, информационный сайт. Место в интернете. Потом добавили туда какую-то логику, добавили чат, возможность заказывать что-то, оплату. Стал уже не просто сайт. Его стали называть интернет-портал. Потом они разделились на те к которым можно получить доступ из сети и те которые были только внутренние - интранет-порталы. И так было до какого-то времени. Интернет развивался. Появлялись новые мощные компьютеры, новые задачи и потребности.</p>
  </li>

  <li>
    <p>А сейчас?</p>
    <p>
      - Сайт, портал, интернет
      <br>- BE для мобильного приложения
      <br>- Межсервисное API
      <br>- API
      <br>- Виджет
      <br>- Плагин
      <br>- SPA
      <br>- BE для толстого клиента
      <br>- и т.д.
    </p>
  </li>

  <li>
    <p>Сейчас у нас есть сайт, портал, интернет. У нас есть backend для мобильного приложения. У нас есть несколько сервисов, которые мужду собой работают, общаются посредством веб приложений. Внешний API, виджет, который на сайт внедрился при помощи разметки. Плагины, SPA приложения. Даже backend для толстого клиента. Например, у нас есть система, которая вместо баз данных, обращается на сервис, шлет такие же запросы. С одной стороны это устанавливается на наш компьютер, а с другой у него ничего своего нет, он просто представляет удобный UI/UX для пользователя - клиент. А вся работа ведется через интернет. Проще сказать что является НЕ веб приложением. Мир ушел в сеть, ушел в интернет.</p>
  </li>

  <li>
    <h3>Примеры web-приложений</h3>
    <p>
      - Информационные сайты, порталы
      <br>- онлайн-магазины и электронная коммерция
      <br>- социальные сети
      <br>- почтовые сервисы
      <br>- медиа сервисы (аудио/видео)
      <br>- CRM, ERP, WMS
      <br>- Административные панели (cloud, hosting, constructors)
      <br>- онлайн сервисы (чаты, онлайн-запись)
      <br>- игры
      <br>- и т.д.
    </p>
  </li>

  <li>
    <p>Примеры веб приложений. Так, чтобы понимать. Сайт и портал. Здесь понятно, здесь вопросов нет. Онлайн-магазины, соцсети, почтовые сервисы - это тоже веб приложения. У вас где-то развернут SMTP сервер и он работает по сети. Медиа сервисы - это наши любимые ютубы, рутубы. Их сейчас очень много. CRM, ERP, WMS - это системы класса управления предприятием. Клиентские системы, системы упрвления предприятием, складские системы. Есть панели административные. Вы можете в клауде создать свое приложение. Средстави другого веб приложения делать свое новое веб приложение. Хостинги, конструкторы. Сейчас на каждом хостинге есть свой конструктор, где можете запрограммировать себе свой сайт. Платить небольшие деньги хостингу и у вас будет свой сайт. Онлайн сервисы, чаты, онлайн запись. Видели в уголочке обычно появляется запись - Поговорить с оператором. Это скорее всего не внутренняя система у сайта, а сделан какой-то виджет, внедряется внутрь сайта и живет вообще параллельно. Для его активации делаете какой-то код. И этот код уже на другом сайте, который час поставляет, выделяет определенную область и в ней работает ваш чат. Игры - отличный пример веб приложений. Игры можно рассмотреть как толстый клиент. У вас есть игра которая отрисовкой занимается, всем остальным но при этом все запросы, вся логика лежит на сервере. Типов веб приложений достаточно много.
    </p>
  </li>

  <li>
    <h3>Преимущества web-приложений</h3>
    <p>
      - Доступ с любого устройства
      <br>- Кроссплатформенность
      <br>- Отсутствие клиентского ПО (но не всегда)
      <br>- Безопасность
      <br>- Масштабируемость
      <br>- Снижение стоимости разработки и поддержки
      <br>- Снижение сложности администрирования
      <br>- Защита от потери данных- Экономия ресурсов поставщика
    </p>
  </li>

  <li>
    <p>Какие у нас есть преимущества. На самом деле, у любого приложения, есть и плюсы и минусы. Нам надо найти баланс, который нам важен и стратегию куда двигаться. Если плюсы от использования приложения, решения превалируют над минусами, значит это хорошее решение и надо туда идти. Первое преимущество это доступ с любого устройства. Кроссплатформенность. Раньше было много браузеров, сейчас поменьше. Все на хромиуме в основном пишется. Но есть windows, linux, всевозможные телефоны. Если писать под каждое приложение на нативном языке, то это будет долго, нудно и никому не надо. Здесь кроссплатформенность работает. Помимо кроссплатформенности клиента, где вы будете это приложение запускать, распространена кроссплатформенность сервера.</p>

    <p>Отсутствие клиентского ПО. Если вы какую-то игрушку ставите, то клиент вам все таки нужен. Но чаще всего вы заходите в браузер и не надо больше ничего инсталлировать. Если вам не понравилось - вы просто больеш этот сайт не открываете.</p>

    <p>Безопасность и масштабируемость. Поскольку веб приложение делается общее, то очень сложно при современных технологиях, если защищаться, поломать ваш компьютер, вашу систему. Плюс хорошая система, хорошее приложение должно и ваши данные еще защищать.</p>

    <p>Снижение стоимости разработки. Вместо десяти инсталляторов, надо будет поддерживать одну систему. Соответственно, ее и поддерживать проще.</p>

    <p>Администрирование. Если кто-то когда-то устанавливал приложения из сети. Можете представить. У кого-то работает, у кого-то не работает, у кого-то не скачалось, целая куча всяких проблем. Здесь достаточно просто всем ссылки разослать и проверить что все заработало.</p>

    <p>Потеря данных. Если хорошая система, ресурсы поставщика могут экономиться. Вы будете делать приложение, которое будет масштабироваться под ваши запросы. Если слабенькая нагрузка - мало платите в месяц. Когда станет побольше - только тогда побольше и заплатите. Не надо сразу вкладываться в большой сервер. Это только основные преимущества. Можно придумать и свои</p>
  </li>

  <li>
    <h3>Недостатки web-приложений</h3>

    <p>
      - Повышенные требования к качеству кода
      <br>- Повышенные требования к программной части системы
      <br>- Повышенные требования к аппаратной части системы
      <br>- Безопасность
      <br>- Масштабируемость
      <br>- Требования к квалификации разработчиков
      <br>- Усложнение процесса администрирования и поддержки
      <br>- Дополнительные затраты на резервное копирование и хранение
      <br>- Увеличенная стоимость владения системой
    </p>
  </li>

  <li>
    <p>Давайте подумаем про недостатки. Вы очень сильно удивитесь некоторые преимущества - они же становятся недостатками. Во-первых, качество кода. Программисты, которые пишут десктопное приложение и программисты, которые пишут серверное приложение с большой нагрузкой, должны иметь разные квалификации. Если написать какую-то ерунду на сервере, она обязательно выплывет. Программные системы. То что вы на клиенте никогда не использовали, например MySQL, здесь уже вам может не хватать. Postgress и так далее. Железо надо мощное. Оно мощное для приложения, но для клиента оно будет меньше.</p>

    <p>Безопасность и масштабируемость. Не так-то просто обеспечить безопасность на сервере и масштабируемость. Для этого сейчас есть специалисты - девопсы. Квалификация разработчиков - это уже по-сути качество кода.</p>

    <p>Администрирование и поддержка. Нужно смотреть работает - не работает, разделять доступ и т.д. Надо будет на что-то деньги вкладывать.</p>

    <p>Но, преимуществ гораздо больше хоты бы для того что можно очень быстро получить какой-то сервис, какую-то информацию. Например, вам нужны исходные коды - вы зашли в гитхаб и скачали исходные коды. Быстрый обмен информацией, быстрый доступ к информации. Защищенность. Все плюсы гораздо перевешивают все неудобства какие есть. И эти недостатки чаще всего относятся не к критическим недостаткам, а к сложностям. А со сложностями программист должен бороться. Компаниям, которые зарабатывают деньги это вообще не вопрос. Это сложности бизнеса, которые надо решать. Это вообще не недостаток. Инвестиции в современное железо легко отбиваются работой пользователями с вашим софтом. Интересен - железо будет не самой большой статьей затрат.</p>
  </li>

  <li>
    <h3>Что такое Интернет</h3>

    <p> Интернет (англ. Internet) - всемирная система объединенных компьютерных сетей, основанная на использовании протокола IP и маршрутизации пакетов данных. Понятие часто упоминается как "Всемирная сеть" и "Глобальная сеть".
    <br>1967 г - Начал разрабатываться ARPANET
    <br>1969 г Впервые связали два ПК по сети
    <br>1971 г - В сети уже 15 узлов
    <br>1972 г - объединены сетью 50 университетов и организаций в США
    <br>1983 г - Внедрение TCP / IP
    <br>1989 г - Разработана и реализована WWW
    <br>1990 г - Появился первый текстовый браузер
    <br>1994 г - Появились браузеры Mosaic, Netscape, IE
    <br>1995 г - Ответственность за интернет перешла в частный сектор
    </p>
  </li>

  <li>
    <p>Что такое интернет? Я здесь накидал небольшую историю. Он родился примерно в 1967 году. Это была сеть, которую в США начали придумывать как средство для военных. Для быстрого обмена информацией между штабами. Потом туда подвязалась Говернет. И институты между собой начали делать обмен. И постепенно система выросла уже в более интересную вещь. В 1967 году ARPANET начала разрабатываться, через два года умудрились соединить два компьютера по сети. Какой-то протокол и начали файлы передавать. С 67 года и до 95 интернет был проприетарным. В 1995 году он вышел в частный сектор. И тут пошел бум. Из простого информационного обмена файлами и обмена почтой он начал вырастать в то, что он есть сейчас. А это уже не просто интернет. Это в придачу ко всему и какая-то сеть, основанная на сети интернет. Локальная сеть, которая не ограничена вашей локальностью компьютера. Можете легко соединиться через WPN с США и работать, если вам требуется. Все так и делают.</p>
  </li>

  <li>
    <h3>Инфраструктура Интернета</h3>
    <p>Конечный пользователь - Локальный провайдер - Региональный провайдер - Магистральный провайдер</p>
  </li>

  <li>
    <p>Как работает у нас интернет. Если по общему смотреть. У нас конечный пользователь это все мы. Есть магистральный провайдер. Это обычно большие, те которые владеют оптикой. Есть региональный провайдер. У них есть протоколы, договоренности. Получить интернет конкретного магистрального провайдера вы не сможете никогда. Это оптовый продавец. Магистральный провайдер это уровня России. Региональный провайдер это какой-то регион. Локальный провайдер это с которым мы работаем. Например, теле2 или билайн, который нам интернет раздает. Мы кидаем информацию и она начинает каким-то образом ходить. Причем для нас это прозрачно. Это общая глобальная сеть. Кому интересно, почитайте как она устроена. Чаще всего, магистральный провайдер может соединять Россию или Европу с США, например. Идет здоровый оптоволоконный кабель по дну моря. И там дальше раздает уже.</p>
  </li>

  <li>
    <h3>OSI модель</h3>
    <p>7 Layers of the OSI Model
    <br>Application.
    <br>- End User layer
    <br>- HTTP, FTP, IRC, SSH, DNS
    <br>Presentation
    <br>- Syntax layer
    <br>- SSL, SSH, IMAP, FTP, MPEG, JPEG
    <br>Session
    <br>- Synch & send to port
    <br>- API's, Sockets, WinSock
    <br>Transport
    <br>- End-to-end connections
    <br>- TCP, UDP
    <br>Network
    <br>- Packets
    <br>- IP, ICMP, IPSec, IGMP
    <br>Data Link
    <br>- Frames
    <br>- Ethernet, PPP, Switch, Bridge
    <br>Physical
    <br>- Physical structure
    <br>- Coax, Fiber, Wireless, Hubs, Repeaters
    </p>
  </li>

  <li>
    <p>У нас есть компьютер. У нас есть сетевая карта, которая соединяется с другими сетевыми картами. Все делится на кусочки. Есть низкий уровень. То есть мы на уровне системы пишем в машинных кодах. Там программа работает. Потом навязывается уровень абстракции. И делает из этого на языке высокого уровня. И так далее. В конце сидит пользователь и пишет в чатике сообщение. Один пользователь написал в чате сообщение и как это идет к другому пользователю с точки зрения сети? Есть принятая слоеная модель OSI. Это модель которая делит на то каким образом эта вся информация приходит. На самом деле, в интернете физически буковки не летают нигде. И даже оптика, которая перекинута между странами, работает на физическом законе. И мы выделили логические моделки, которые делятся на несколько слоев.</p>

    <p>Физический уровень - это с чем мы работаем. Например, мы можем передать радиосигнал, мы можем передать световой сигнал. Запись на какой-нибудь кристалик на флешке. Это все физика. За счет чего ваша информация передается.</p>

    <p>Дальше слой Data Link. Это ethernet, bridges. Это все на чам работают роутеры. То что от нас скрыто. Есть специальные протоколы, которые кусочки информации отправляют по физическому каналу. Мы можем в роутер вогнать информацию с коаксиального кабеля а дальше пустить ее через оптику. Если роутер так умеет делать. Это уровень как мы данные между собой передаем.</p>

    <p>Network это каким образом мы передаем по сети. Это пакетики данных, которые надо собирать. У нас есть IP. Не просто данные, которые передались куда-то. А уже передались куда-то конкретно.</p>

    <p>Выше уровень транспортный. Он работает на базе нетворка. Есть TCP, UDP. Мы начинаем работать с двумя точками. Берем две точки и данные между ними перекидываем.</p>

    <p>Дальше сессии. Это сокеты, винсокеты. Мы на них можем уже влиять. Но не надо.</p>

    <p>Презентационный слой. Это то что мы качаем.</p>

    <p>И уровень апликейшн. Это работа с http, ftp. Здесь как раз мы сидим и работаем. Мы, как программисты, работаем на уровне приложения. Такая слоеная модель передачи информации. От радиосигнала до картинки.</p>
  </li>

  <li>
    <h3>Адресация в сети Интернет</h3>
    <p>Хост (сервер) - Локальная сеть - Компьютер пользователя</p>
  </li>

  <li>
    <p>Нетворк это связь нескольких узлов (устройств) между собой. Мы должны иметь возможность информацию, как минимум, находить. Например, вы пытаетесь послать письмо мне. Вы не знаете где я нахожусь. На каком компьютере, какой у меня адрес, он может поменяться в какой-то момент. Я могу с сотового телефона зайти. Процедуры, которые внизу, от нас скрыты. Компьютер не бездельничает, когда мы ничего не делаем. У каждой точечки и у каждого хоста должен быть какой-то адрес. Точки которые имеют реальное или виртуальное воплощение это хост. Мы можем работать с хостом по протоколам TCP и UDP. TCP это протокол который гарантирует корректность передачи данных. Он медленнее чем UDP и работает следующим образом.</p>
    
    <p>Мы соединяем два компьютера, найдя их по IP, и начинаем слать между ними информацию. Мы шлем информацию маленькими кусочками и у каждого подписана контрольная сумма. На транспортном уровне , берется наша посылка и автоматически разбивается на кусочки, кусочки подписываются и отправляются по сети в параллель. Они, кто быстрее а кто медленнее, приходят на приемник. Там уже сетевая карта их собирает, склеивает, проверяет. Если какой-то пакет пришел испорченный, она его еще раз перезапрашивает. В итоге получает всю посылку. Что отправили - то и пришло. Таким образом, TCP считается протоколом с гарантированной передачей данных. Либо дойдет все полностью, либо вообще не дойдет.</p>

    <p>UDP работает так - я вышел в сеть, прокричаль какую-то информацию. И сказал что информация нужна такому-то компьютеру, например Петровичу. Все ее услышали, но только Петрович ее поймал и что-то с ней сделал. Какие плюсы? Мне не надо подтверждение. Я информацию послал и отлично. Быстро установил коннект. Быстро прошла связь. По адресам ушло много информации. Какие минусы. Петрович меня может не услышать. Или он не понял, что к нему пришло. Это решается по TCP/IP. Но UDP считает так - я лучше десять раз крикну и это будет быстрее чем я напишу письмо , упакую и отправлю.</p>

    <p>Как компьютеры друг друга видят. IP4 это четырех значная 8-байтовая маска (четыре цифры, размером по 8 байт) по которой определяется адрес компьютера в сети. IP (192.168.70.1). Ей все всегда пользовались. Она хорошая, удобная но есть один минус. У нее порядка 4 миллиардов адресов. Но с ростом количества компьютеров, мобильных устройств и прочее, число IP адресов может быстро закончиться. Поэтому придумывают IP6. Много устройств еще работают на IP4, поэтому он еще поддерживается.</p>
  </li>

  <li>
    <p>HOST
    <br>TCP UDP
    <br>IP (192.168.70.1)
    <br>Port
    <br>0 - 1023 системные
    <br>1024 - 49151 зарегистрированные
    <br>49152 - 65535 динамические
    </p>
  </li>

  <li>
    <p>IP это любой один компьютер. Но глупо было бы делать так что внутри одного компьютера всего одно приложение. Например, установили на компьютер базу данных и больше ничего там нет. Часто компьютер может много чего в себе держать. Например, две базы данных. Поэтому внутри компьютера есть возможность добавлять порты. Это уже дополнительный идентификатор к IP который показывает не только хост, но и место, куда послать. В рамках одного компьютера хост и порт может быть открыт один. И вся информация в него сваливается. Каким образом? Мне в сеть кидается информация - IP такой-то, порт такой-то получи пакет данных. Все остальные его проигнорировали. Кому не надо он вообще не попал. А кому надо он попал. Все все слышат и только нужные адресаты получают.</p>

    <p>Первые 1024 порта системные. Сюда лезть не желательно.</p>

    <p>Интернет дает возможность людям быстро находить. Для этого нужно писать человеческим языком, а не цифрами. Например, буквами. Что при этом происходит. Пользователь ввел строку из букв selectel.ru. Наш компьютер ничего об этом не знает и передает их дальше на резолвер. Резолвер это DNS это сервер. Dynamic Name System. Есть пачки серверов и каждому из них прописан конкретный ip-шник. Когда вы свой сайт будете регистрировать. Вы покупаете доменное имя. И если вы хотите чтобы доменное имя работало, вы непосредственно у вашего провайдера где вы будете должны сказать - мое купленное имя лежит здесь. И если кто-то ввел это слово, то адресуй его сюда. Я здесь подхвачу и все отдам. DNS сервера все это дело поддерживают. Мы обратились к резолверу, если у него этого адреса нет, то он обращается к более крупному, например в зоне ru и тот уже передает адрес нужному DNS серверу у которого есть ip этого сайта. DNS сервер возвращает нам на наш компьютер ip-шник и мы уже на этот ip-шник шлем запрос. И мы попадаем на selectel.ru.</p>
    
    <p>Примерно так работает DNS. DNS обновляется автоматически. Если мы поменяли сайт, то в течении 3 часов это обновляется. Если сайт хранится очень далеко, например, в Африке. То вы сначала обновите ваш DNS потом следующий и так по времени до суток. DNS сервер периодически эту информацию спрашивает у сайтов, с которыми он связан. И таким образом поддерживается актуальная инфомрация. Также компьютер кеширует эту информацию. И мы можем сделать эмуляцию в файле windows host на какой-то ip-шник поставить какое-то имя. Так же можно и от реклам отцепиться. Узнать ip-шники adware сервисов и их на себя замкнуть и никакие рекламы приходить не будут. Таким образом работает DNS. Есть по DNS вопросы? DNS это система , которая позволяет читабельное для человека имя превратить в ip-шник. И ничего больше. А уже дальше работает веб сервер.</p>
  </li>

  <li>
    <h3>Что такое адрес cool.blog.mysite.ru</h3>
    <p>cool домен 4-го уровня
    <br>blog домен 3-го уровня
    <br>mysite домен 2-го уровня
    <br>ru домен 1-го (верхнего) уровня
    </p>
  </li>

  <li>
    <p>Что такое адрес. Мы должны определенным образом сформировать имя. Читаем справа налево до точки. Домен 1-го уровня, потом 2-го и так далее.</p>
  </li>

  <li>
    <h3>Что такое гиперссылка (href) http://user:pass@site.com:80/pa/th?q=val#hash</h3>
    <p>http - protocol
    <br>user - username
    <br>pass - password
    <br>site.com:80 - host
    <br>site.com - hostname
    <br>80 - port
    <br>/pa/th?q=val - path
    <br>/pa/th - pathname
    <br>?q=val - search
    <br>#hash - hash
    </p>
  </li>

  <li>
    <p>Что у нас вообще может быть в адресе. Рассмотрим URL. У нас есть протокол http. Может быть user password но не обязательно. Тот что до собачки. У нас есть hostname site.com. Порт 80. Путь к ресурсу, например, к страничке. Далее уже какие-то опции и хеш, чтобы адресоваться к конкретному месту на странице.</p>
  </li>

  <li>
    <p>Есть стандарт для именования URL/URI/URN</p>
  </li>

  <li>
    <h3>DNS</h3>
    <p>Типы записей DNS
    <br>A - адрес IPv4
    <br>AAAA - адрес IPv6
    <br>CNAME - псевдоним для доменного имени
    <br>MX - адрес почтового сервера
    <br>SRV - адреса и порты сетевых сервисов
    <br>NS - адреса DNS-серверов, ответственных за зону
    <br>PTR - доменное имя для IP-адреса
    <br>Другие редко используемые типы записей
    </p>
    <p>Запрос записей разных типов
    <br>nslookup -type=XXX yandex.ru
    </p>
  </li>

  <li>
    <p>Что такое DNS. Изначально он писался очень давно. На нем хранятся DNS записи соответствия адесов ip-шникам. Допустим мы купили доменное имя. Они продаются и перепродаются. Некоторые стоят больших денег. Если вы сможете купить yandex.ru и продать его то можно озолотиться. Есть бизнесмены которые скупают хорошие имена, а потом их продают. 99% не выстрелят, а один выстрелит и покроет затраты на все остальные. На самом деле это список, где написано хост такой-то лежит на таком-то адресе. Чаще всего с этим работает администратор и львиная часть девелоперов никогда в жизни с этим не сталкивается.</p>
  </li>

  <li>
    <h3>Архитектура web-приложения</h3>
    <p>Клиент - Интернет - Сервер</p>
  </li>

  <li>
    <p>Давайте поговорим про архитектуру web-приложения. У нас есть Клиенты , сеть Интернет. Почему интернет? Сейчас любая сеть поднимается в интернет, локальная сеть ушла в прошлое. Множество сервисов лежать внутри облаков, связанных между собой по сети интернет. Несколько клиентов обращаются к серверу, сервер возвращает ответ.</p>
  </li>

  <li>
    <h3>Что такое сервер</h3>
    <p>- Приложение, которое располагается на выделенном физическом или виртуальном сервере
    <br>- Имеет собственный IP адрес и порт
    <br>- Работает под управлением веб-сервера или является self-hosted
    <br>- Имеет известный протокол или API для взаимодействия с ним
    </p>
  </li>

  <li>
    <h3>Что такое клиент</h3>
    <p>- Браузер
    <br>- Различные API клиенты:
    <br>&nbsp;&nbsp;- Мобильные приложения
    <br>&nbsp;&nbsp;- Сторонние веб-серверы
    <br>- Специализированный "толстый" клиент
    <br>&nbsp;&nbsp;- ERP, CRM, WMS
    <br>&nbsp;&nbsp;- Мессенджеры
    <br>&nbsp;&nbsp;- Игровые клиенты
    <br>- Утилиты
    <br>- Аппаратные решения
    </p>
  </li>

  <li>
    <p>Львиная часть клиентов сейчас это браузер. Сторонние веб серверы в качестве клиента это когда два сервера между собой поговорили, например, что запрос от пользователя имеет право получить доступ к ресурсу. Мессенджеры, утилиты, аппаратные решения, к интернету может подключаться даже роутер. Вы купили роутер и через интернет его надо настроить и он на это время стал клиентом.</p>
  </li>

  <li>
    <h3>Клиент - Сервер</h3>
    <p>HTML
    <br>JSON
    <br>XML
    <br>Проприетарные форматы
    <br>Бинарные данные
    </p>
  </li>

  <li>
    <p>Какие у нас есть взаимодействия. Когда мы работаем с клиентом, то мы отправляем информацию и получаем информацию. Это примерно то же самое что мы делаем с методами. Мы вызвали метод и передали туда данные и получили результат. Здесь тоже самое только не внутри памяти вашего компьютера а внутри сети. Для того чтобы общаться клиенту с сервером были придуманы протоколы. Первый протокол, который стал базовым стандартом это HTML. Все браузеры должны его поддерживать. Правда сейчас chromium всех выкинул с рынка. Сделал все хорошо и бесплатно - забирайте себе и пользуйтесь. HTML для отображения страницы. Для передачи данных с сервера и на сервер это JSON. Удобный, компактный вариант. Еще есть XML в которой есть группы, подгруппы, параметры. JSON кроссплатформенный, с ним многие языки нативно работают. JSON сейчас популярен. Есть какие-то проприетарные форматы. Вы можете сделать свой протокол. Ну и бинарные данные. Когда данные ходят между сервисами. Не надо уже никаких ключей. Надо сделать быстро, желательно мгновенно, защищенно и не тратить лишнего траффика.</p>
  </li>

  <li>
    <h3>HTTP</h3>
    <p>Это Hyper Text Transfer Protocol. Он изначально разрабатывался как набор правил, который позволяет двум точкам понять друг друга. Когда вы посылаете информацию с точки на точку, то на самом деле вы посылаете текст. Клиент делает на сервер html request, который имеет header и body. В header говорится что нужно сделать, а в body какие-то данные. На что сервер отправляет http response, которые тоже имеет header и body. В header говорится на что сервер отвечает и в body сам ответ.Что из себя представляет он внутри.</p>

    <p>Где можно посмотреть эти запросы и ответы. В браузере надо открыть инструменты разработчика, выбрать network</p>
  </li>

  <li>
    <h3>HTTP - Коды ответов</h3>

    <p>1xx - Informational. The server acknowledges a request
    <br>2xx - Success. The server completed the request as expected
    <br>3xx - Redirection. The client must perform further actions to complete the request successfully
    <br>4xx - Client Eror. The API request failed with the information provided by the client
    <br>5xx - Server Error. The server failed to fulfill a valid request due to an error with server
    </p>
  </li>

  <li>
    <h3>HTTPS</h3>
    <p>Вся передаваемая информация ( даже логин и пароль ) по http видна всем промежуточным роутерам между клиентом и сервером. Поэтому поверх http накладывают tls и получают https протокол. На стороне клиента и сервера есть секретный ключ, который шифрует все данные. Есть симметричное и асимметричное шифрование. http и https это request и response. От клиента запрос, от сервера ответ. Если клиент ничего не спрашивает, то сервер ничего ему и не отвечает. Когда я первый раз отправляю https запрос к сайту. Я в ответ получаю ключ для симметричного шифрования. И с этим ключем в рамках этой сессии работаю.</p>
  </li>

  <li>
    <h3>WebSocket</h3>
    <p>Возникла потребность в протоколе, который позволит и серверу обращаться к клиенту. Придумали WebSocket. Это надстройка над http. А wss надстройка над https. Клиент по http соединяется с сервером и говорит - я хочу с тобой работать через websocket. Если сервер согласится, то на клиенте и на сервере поднимаются открытые сокеты, которые начинают слушать информацию друг от друга. Двунаправленное соединение. Сервер может по этому сокету что-то послать и клиент может по этому сокету что-то послать. Таким образом делают чаты. Не все серверы и клиенты могут делать вебсокет - не всем это разрешено.</p>
  </li>

  <li>
    <h3>HTML</h3>
    <p>Это один из подвидов XML. Язык гипертекстовой разметки. В нем есть один блок htlm, блок head и блок body. То что показывается на странице лежит в body. Web разработчики - frontend и fullstack должны уметь верстать на html. В браузере html трансформируется в DOM иерархическую структуру, по которой можно уже искать элементы и что-то с ними делать. Javascript в браузере работает не с текстом html, а с DOM.</p>
  </li>

  <li>
    <h3>CSS верстка</h3>
    <p>Раньше CSS позволял только поменять цвет, шрифт и остальные простые вещи. Сейчас CSS используется для адаптивности, когда сайт на разных устройствах и на разных размерах браузера выглядит по разному. При помощи CSS определяется размещение элементов.</p>
    <p>a { background-color: yellow; }</p>
    <p>Таким образом можно в CSS выбрать элемент и назначить ему стили. CSS это достаточно большая тема и выходит за рамки данного курса</p>
  </li>

  <li>
    <h3>CSS Фреймворки</h3>
    <p>Bootstrap
    <br>Foundation
    <br>Bulma
    <br>UIKit
    <br>Materialize
    <br>Tailwind CSS
    </p>
  </li>

  <li>
    <h3>CSS препроцессоры</h3>
    <p>Зачем нужны
    <br>- Позволяют упростить разработку
    <br>- Позволяют повторное использование кода
    <br>- Позволяют использовать переменные
    <br>- Позволяют минимизировать объем CSS кода
    <br>Какие есть препроцессоры
    <br>- Less
    <br>- Sass
    </p>
  </li>

  <li>
    <h3>JavaScript</h3>
    <p>- Интерпретируемый
    <br>- Регистрозависимый
    <br>- Однопоточный
    <br>- Имеет сборщик мусора
    <br>- Умеет автоматически приводить типы
    <br>- и многое другое
    </p>
  </li>

  <li>    
    <p>Современные веб приложения и сайты не могут жить без JavaScript. JavaScript сейчас везде мейнстрим захватил.</p>
  </li>

  <li>
    <h3>TypeScript</h3>
    <p>- Строго типизированный
    <br>- Ранний поиск ошибок
    <br>- Обратно-совместимый с JS
    <br>- Более строгий и читаемый код
    <br>- Реализует ООП
    </p>
  </li>

  <li>    
    <p>В 2012 году микрософт сделал typescript. Причем typescript разрабатывал Хейлсберг, который сначала разработал Delfi а потом разработал C#. Это развитие языка. Если Javascript интерпретируемый, то Typescript уже компилируемый язык. На typescripte пишут код, который проверяет типы, защищает от ошибок, но на самом деле он должен потом скомпилироваться в javascript. Браузер с чистым typescript не работает. Проверка типов позволяет избежать ошибок на ранней стадии. На базе typescript написаны VSCode, Node.js, Angular.</p>
  </li>

  <li>
    <h3>JS Фреймворки</h3>
    <p>- Angular
    <br>- React
    <br>- Vue
    <br>- React Native
    <br>- Electron
    </p>
  </li>

  <li>
    <h3>AJAX</h3>
    <p>Для чего нужна AJAX. В традиционном веб приложении мы отсылаем на сервер запрос. Сервер нам присылает в ответ html страничку, например. С это страницы мы еще запрашиваем CSS, JS какие то картинки и т.д. После этого браузер уже отображает эту страничку сформированную целиком. Плюсы - это быстро и даже самый тупой браузер с этим справляется. Минусы - никакой интерактивности. Поэтому решили сделать технологию AJAX. Как это работает. Первый раз браузер посылает на сервер запрос и получает страничку с джаваскриптом, который уже сам может делать AJAX запросы без перезагрузки страницы целиком. Например, при нажатии на кнопку javascript посылает AJAX запрос серверу и в ответ сервер отдает данные на основании которых кнопка потом станет синей.  И это называется AJAX когда один раз загрузили страницу и потом гоняем данные к серверу и обратно без перезагрузки.</p>
  </li>

  <li>
    <h3>CORS</h3>
    <p>Main request: defines origin. Same-origin requests (always allowed). Cross-origin requests (controlled by CORS). Нужен для защиты пользователя от сторонних сайтов.</p>
  </li>

  <li>
    <h3>JQuery</h3>
    <p>Селекторы
    <br>Управление DOM
    <br>Динамика
    <br>Плагины
    </p>
  </li>

  <li>
    <p>JQuery это популярная библиотека, которая позволяет сделать интерактивность на сайте. Взяли на себя удобную работу с DOM. На ней написано немерянное количество плагинов.</p>
  </li>

  <li>
    <h3>SPA приложения</h3>
    <p>SPA приложение можно делать на чистом js, react (от программистов фейсбука), angular (от программистов гугла), vue. Каждое приложение разбивается на кусочки - на компоненты. Например, компонент меню, хедер, статья. И мы их собираем вместе.</p>
  </li>

  <li>
    <h3>Blazor</h3>
    <p>Микрософт тоже захотел сделать свой фреймфорк для SPA приложений. Первая попытка была SilverLite но комьюнити его не приняла.Тогда микрософт переманила часть .net разработчиков на разработку веба и сделала Blazor. Blazor есть двух видов. Первый на базе Web Assembly делает классические SPA приложения. В этом случае отличие Blazor от Vue только в способе работы с DOM и разметкой. На браузере запускаем WebAssembly. На WebAssembly запускается .NET платформа. Таким образом мы запускаем .net внутри браузера и с ним живем. Но все общение с сервером делается посредством request-response через rest, через websockets и т.д. Вторая схема Blazor которую предлагает микрософт - это где клиентского приложения как бы не существует. Это Server Render приложение. Мы запускаем в браузере приложение. Приложение по вебсокету через библиотеку SignalR соединяется с сервером и получает по запросу маленькие кусочки которые автоматически вклиниваются в нужное место на странице. И вы уже разрабатываете десктопное приложение. Это выход для тех кто не хочет работать с классическими приложениями. Сейчас на Blazor уже можно делать даже мобильные приложения.
    </p>
  </li>

  <li>
    <h3>Web server</h3>
    <p>У нас есть приложение и база данных. Мы купили домен, разместили их на хостинге на сервере. Все хорошо работает до тех пор пока к нам не стало приходить много людей и поступать много запросов в базу данных.</p>
    
    <h3>+ Хранилище</h3>
    <p>Начинает уже все подтормаживать. И теперь база данных становится узким местом. Что делать? Мы делам несколько баз данных. Создаем для них кластер. Делаем одну базу данных для записи. И много баз данных для чтения. Настраиваем PostGress чтобы все что мы записали в одну базу данных быстренько копировалось в остальные. Таким образом мы развязались с базами данных. Но у нас есть еще файлы, картинки. И мы хотим чтобы эти файлы тоже не хранились на нашем сервере. Давайте вынесем их на какой то сервис, амазон с-3 - это система для хранения файлов. Все картинки теперь храним там, все документы в защищенном месте. Приложение опять стало маленьким</p>

    <h3>+ Кэширование</h3>
    <p>Потом мы начинаем понимать, что одно и то же делается - дай мне какую-нибудь страничку. И все подряд запросы запрашивают эту страничку. А мы каждый раз делаем запросы в базу данных, собираем все в кучу. Долго. Решаем добавить кэш. На базе Redis например. И часть информации, которая не меняется скидываем в кэш. Просят страничку, смотрю в кэш, если она там есть - отдаю ее. База данных не нагружается, скорость увеличилась.</p>

    <h3>+ Балансировщик</h3>
    <p>Через какое-то время понимаем что все хорошо, но само приложение начинает теперь не справляться. Ограничивается мощностью компьютера, размером памяти. И мы начинаем наше приложение разделять. Это на одном компьютере, а это на втором и т.д. Мы сделали несколько инстансов нашего приложения на разных компьютерах сервера. И для того чтобы это все работало повесили балансировщик. Клиент приходит на балансировщик, а он уже сам распределяет какое приложение ему показать. У балансировщика будет IP всей системы, а у приложений будет у каждого собственное IP. Теперь мы должны соблюдать некоторые правила. Каждый инстанс приложения должен быть stateless. Внутри ничего не должно храниться. Получил запрос, отработал, вернул результат и забыл об этом. Тогда клиент делая разные запросы может попадать на разные интсансы приложений и ему нет никакой разницы. Когда в рамках одного или нескольких серверов есть несколько инстансов это называется горизонтальное масштабирование. Мы просто начинаем увеличивать количество наших сервисов (хотя сервер может быть и один). Они начинают работать каждый со своей базой данных, они читают один кэш.</p>

    <h3>+ Микросервис</h3>
    <p>Мы понимаем что у нас куча однотипных действий. Делается одно и то же. Тогда мы из нашего сервиса достаем эти однотипные действия и кладем в микросервисы. Например, один микросервис будет делать картинки, второй отпраляет емейлы, третий отправляет смс сообщения. В итоге наши начальные сервисы еще разгружаются.</p>

    <h3>+ Шина данных</h3>
    <p>Добавляем шину данных. Которая ставится между микросервисами и нашей системой и отвязывает их. Получается очень гибкая система.</p>

    <h3>+ Потоковая обработка</h3>
    <h3>+ Архив данных</h3>
  </li>
  
  <li>
    <h3>API architecture styles</h3>
    <p>SOAP XML-based for enterprise applications
    <br>RESTful Resource-based for web servers
    <br>GraphQL Query language reduce network load
    <br>gRPC High performance for microservices
    <br>WebSocket Bi-directional for low-latency data exchange
    <br>Webhook - Asynchronous for event-driven application
    </p>
  </li>

  <li>
    <p>Поговорим про то как общается клиент с нашим веб приложением. Это все способы общения клиента с сервером, либо сервера с сервером.</p> 
    
    <p>SOAP это специальный протокол, разработанный микрософт и предназначен для обращений сервис + сервис. Здесь можно организовать транзакции. Если какой-то протокол не пришел то все отменится. Здесь можно организовать защиту, шифрацию. Сейчас при помощи SOAP в России активно идет взаимодействие с госуслугами. Система межведомственных взаимодействий работает на базе SOAP. Построена на базе http. Например, формирует письмо и по http его отправляет. Плюсы - защищенность, шифрование, можно отследить что куда и как. Это нужно для того чтобы обеспечить надежность. Минусы - большие объемы, не все типы и библиотеки поддерживаются. Например, на мобильные приложения не поддерживаются.</p>

    <p>REST это мягкие правила. На них сейчас все и пишется.
    <br>client-server
    <br>stateless
    <br>cashable
    <br>uniform interface
    <br>layered system
    <br>code on demand
    <br>starting with the null style
    </p>
    <p>Построен на базе http. Отправляем запрос по http и приходит ответ или json по http. REST это правила. RESTful это приложения которые полностью поддерживают все эти правила.</p>
  </li>

  <li>
    <h3>HTTP методы</h3>
    <p>GET
    <br>POST
    <br>PUT
    <br>DELETE
    <br>TRACE
    <br>OPTIONS
    <br>CONNECT
    <br>PATCH
    </p>
  </li>

  <li>
    <h3>GraphQL</h3>
    <p>Мы вместе с request отправляем json строчку - json блок, в котором говорим что мы хотим получить. Посылаем наш запрос на сервер. Там уже есть GraphQL библиотека, которая знает где что взять. Она ищет ответ в базе данных или других сервисах и возвращает нам ответ именно о том что мы попросили. В итоге вы можете сами регулировать тот объем информации, который будет по сети гоняться. Можно послать запрос на получение и на изменение информации. Еще в GraphQL можно сделать подписку на события. Если что-то поменялось - вам придет ответ.</p>
  </li>

  <li>
    <h3>gRPC</h3>
    <p>Local Call vs Remote Procedure Call. Открытый протокол для обмена бинарными данными.</p>
  </li>

  <li>
    <h3>WebHook</h3>
    <p>WebHook vs Polling. При polling мы постоянно делаем запрос пока не получим нужный нам ответ. WebHook дает информацию и говорит - как будет результат пришли его мне.</p>
  </li>

  <li>
    <h3>Уязвимости</h3>
    <p>- Инъекция
    <br>- Сломанная аутентификация
    <br>- Раскрытие конфиденциальных данных
    <br>- Внешние атаки XML (XXE)
    <br>- Нарушенный контроль доступа
    <br>- Неверная конфигурация безопасности
    <br>- Межсайтовый скриптинг (XSS)
    <br>- Небезопасная десериализация
    <br>- Использование компонентов с известными уязвимостями
    <br>- Недостаточное ведение журнала и мониторинг
    </p>
  </li>

  <li>
    <h3>Рекомендации по защите</h3>
    <p>- Установите и включите файрволл
    <br>- Регулярно проводите оценку уязвимости
    <br>- Не используйте старые версии серверов, фреймворков, библиотек, сервисов
    <br>- Записывайте и анализируйте сбои в работе системы
    <br>- Используйте анализаторы исходного кода и средства поиска уязвимостей
    <br>- Учитесь сами и обучайте свою команду правилам защиты
    <br>- Обращайтесь в специализированные компании для аудита и защиты информационных систем
    </p>
  </li>

</ul>
