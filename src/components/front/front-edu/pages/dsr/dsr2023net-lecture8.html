<article class="article">
	<div id="link-to-dsr2023net" class="btn-back">назад</div>

  <h1>2023-11-20 DSR .NET School 2023 Lecture #8 Asp Net Core</h1>
</article>

<article class="article">
  <h2>Лекция 8. ASP Net Core - Web API</h2>

  <p>Всем добрый вечер. Мы приближаемся к практической части. Теорию в большей части мы закончили. Сегодня лекция про Asp Web API. Из каких кусков она состоит, на что надо обратить внимание. И нам это пригодится уже в этот четверг. Потому что в этот четверг, напоминаю, начинается практика. Не опаздывайте, пожалуйста. Будет более интересно с практической точки зрения. У нас будет 6 практических занятий. На одно больше чем в прошлом году. Решили сделать одно дополнительное по тестированию. Будет 4 занятия по созданию API. 1 занятие по Blazor. Мы будем создавать Blazor приложение. И 6-ое последнее занятие будет по тестам. После этого, одновременно с практикой, закончатся и лекции.</p>

  <p>У нас небольшие изменения в лектории. Практические занятия будут записаны и у вас будет доступ в гитхаб. Там будут предоставлены исходники, можете скачать и посмотреть. Видео как помощник, чтобы посмотреть что к чему. А так, будете самостоятельно разбирать код. Вместо лекции по бизнес логике у нас на следующей неделе начнется лекция по persistance слоям. По базам данных мы решили сделать две лекции по AST. А бизнес логику я расскажу сегодня. Она достаточно проста, так что вы ничего не потеряете. Итак, сегодня у нас Web API основа + бизнес логика. Следующие два занятия это подключение БД и работа с entity фреймворк. И две лекции по Blazor. И у нас остаются чисто практические занятия. Давайте начнем.</p>
</article>

<article class="article">
  <h2>О чем будет эта лекция</h2>
  <p>1. Что такое WebApi в ASP.Net</p>
  <p>2. Архитектура проекта, разделение ответственности</p>
  <p>Middleware</p>
  <p>Инъекции зависимостей (DI)</p>
  <p>Документирование (Open API)</p>
  <p>Версионирование, логирование, health check</p>
  <p>DTO-модели, AutoMapper</p>
  <p>Валидация данных, FluentValidator</p>
  <p>Идентификация/Аутентификация/Авторизация</p>
  <p>JWT/Identity servers</p>
  <p>Коды возврата или исключения? Что выбрать?</p>

  <p>О чем мы сегодня поговорим. Поговорим что такое WebApi. Относительно прошлого года поубирал отсюда всю воду. Не буду вам показывать формочки где это все делается. Мы все это будем проходить на практике. Если кто-то имел доступ к лекциям или видел как это было в прошлом году, не пугайтесь ничего не потеряете. Просто перераспределили и лишнюю работу с теоретической частью поубирали и оставили то что действительно важно и что стоит обсудить. Но все по формочкам, по docker и остальному у нас будет на практике, поэтому практику я не рекомендую пропускать. Желательно чтобы вы ее очень хорошо прошли.</p>

  <p>Итак, сегодня мы поговорим про WebApi, что это такое и зачем он нужен. По архитектуре. Немножко по DI, по важным библиотекам, которые стоит подключить. Которые вам помогут сделать красивый WebApi. И в конце мы поговорим про идентификацию, что это такое и как с ней быть. Потому что WebApi так же как и обычный сайт требует авторизации и идентификации и это важно, особенно в современном мире.</p>
</article>

<article class="article">
  <h2>1. Что такое WebApi в ASP.Net</h2>

  <p>.NET SCL</p>
  <ul>
    <li>Desktop</li>
    <li>Cloud</li>
    <li>Mobile</li>
    <li>Games</li>
    <li>AI</li>
    <li>
      <p>ASP.NET Core</p>
      <ul>
        <li>Blazor</li>
        <li>SignalR</li>
        <li>
          <p>MVC</p>
          <ul>
            <li>Razor Pages</li>
            <li>Web API</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>

  <p>Итак, что же такое WebApi. Эту картинку вы наверняка уже видели. Это микрософтовская картинка, просто перерисованная. У нас есть стек фреймворка .Net, на нем есть стек ASP.Net Core. На нем есть фреймворки MVC, Blazor, SignalR. Blazor, SignalR нам сейчас не сильно интересны. На базе MVC сделаны еще два фреймворка Razor Pages и Web API. Нас интересуют сейчас эти две вещи. Razor Pages вкратце коснусь когда до этого дойду. Web API это как раз наш целевой продукт ради которого этот курс и разработан. Вы должны хорошо научиться писать Web API.</p>

  <p>Web API это в принципе очень простая вещь. Это какой-то сервер, который принимает на вход машиночитабельную информацию. Делает с ней полезное действие. И в ответ возвращает другую машинночитабельную информацию. Отличие от простого сайта в то что сайт шлет запросы на получение страницы, а в ответ возвращает html страницу или кусочек кода, который нужен пользователю. Web API пользователю ничего не должен. Он работает для других систем и сервисов. Например, у вас есть класс у которого большой набор интерфейсов, функций. Web API можно рассматривать примерно точно также. У вас есть сервер, на котором развернута работающая система, у которой есть какой-то интерфейс. Что можно делать, какие данные посылать, куда посылать и какие ответы вам вернутся. Это классический web.api на основе restfull.</p>

  <p>Web API может работать не только с RestFul, он может работать и с websocket на базе SignalR - один раз послали и меняемся данными. Он может работать по jrpc. В этом случае request и responce будут бинарные посылки определенным образом запакованные. Он може работать через GraphQL и т.д. Но суть остается той же. Есть у нас какие-то endpoints на входе которых мы принимаем сигнал снаружи. Потом что-то делаем и в ответ что-то возвращаем. Давайте про всевозможные GraphQL и JRPC вы разберетесь самостоятельно. А мы будем рассматривать вариант самый классический, самый распростаненный.</p>

  <p>Итак, API. У нас есть какой-то сервер и какой-то публичный клиент (software). Каждый клиент шлет какие-то request. И сервер в ответ шлет response. Web API с точки зрения ASP.Net это черный ящик, который имеет кучу входов, которые называют endpoints. Их иногда называют "ручки" - за что можно подергать. Как Web API представлен в проекте. Если вы откроете студию и выберете создать Web API. У вас будет примерно что-то такое подставлено. Здесь я вам показываю Web Api нестандартный. То есть то что мы будем делать на практике. Здесь важно вам что знать. Есть контроллер C# BooksController.cs. В API контролеры могут делаться сейчас в коротком виде для микросервисов, например, когда нету ничего. И вся логика будет забита в классе Program. Либо можно сделать классический, т.е. это вынесенный отдельно контроллер. В данном случае нас интересует BooksController. Если мы откроем его, у нас будет наш BooksController. Здесь у нас есть соглашение по именам. ASP.Net найдет все букс контроллеры, которые унаследолваны от класса нетс. Отсечет отсюда слово контроллер и сделает Books. Этот Books и будет ендпоинтом. В каждом контроллере есть набор методов, публичных, например GetBooks это экшн. То что в MVC называлось экшн. Контроллер и экшн. Только в MVC экшн возвращаль вьюху, рендереную html страницу, а WebAPI может вернуть JSON. Или вернуть какой-то статус, например OK. Он здесь легковесный. Не надо никаким образом с html работать.</p> 
  
  <p>Теперь вопрос. У нас может быть много контроллеров, экшенов. Как это все разводится? Для того чтобы можно было это все развести, в системе предусмотрен мехнизм Routing. Routing на самом деле есть не только здесь, а везде. В SPA приложениях, Angular, React, Razor pages. Просто здесь он до какой-то точки уже устоялся. В старых MVC этот роутинг настраивался в специальных местах. Не очень удобно. Большей частью генерировался автоматически, отсекая слово Controller. Не всегда это удобно. Потому что не всегда удобно имена ендпоинтов сопоставлять с именами классов. Ендпоинты стараются сделать в виде camalCase. А в C# код пишется в PascalCase. Есть какие-то именованные правила, которые гармонично смотрятся внутри определенного кода. Если все это дело совмещать, то код будет не очень радовать глаз. Поэтому каки-то образом развили систему и пришли к такому виду роутинга.</p>
</article>

<article class="article">
  <h2>WebApi endpoints - Routing</h2>
  <p>На весь контроллер</p>
  <pre>
    [ApiVersion("1.0")]
    [Route("v{version:apiVersion}/[controller]")]
    public class BooksController : ControllerBase {}
  </pre>
  <p>На действие</p>
  <pre>
    [HttpGet]
    [Route("")]
    public List<Models.BookModel> GetBooks() {}
  </pre>

  <p>Как сейчас можно назначить ендпоинту имя. Что такое request/response. Это просто на сервер посылается текст и сервер этот текст обрабатывает. Как из этого текста найти вход в функцию? Которая будет какое-то действие делать. Передать можно при помощи роутинга и мапинга. Мапинг приводит наши параметры, которые мы передали из JSON, в объект, который этот контроллер принимает. В данном случае здесь никаких параметров нет. Если мы сделаем int у нас будет какая-то строка, будет пытаться преобразоваться и если найдется, то это действие выполнится.</p> 
  
  <p>Как можно роутинг настроить? При помощи аттрибута route мы можем настроить роутинг на весь контроллер. У нас есть переменная часть версии, у нас будет кусочек про версионирование так что имейте ввиду, и в квадратных скобках это контроллер. Контроллер здесь будет браться имя контроллера, отсекая Controller. В данном случае будет браться Books. Зачем это делать. Можно просто написать Books, а можете Controller и он будет просто браться отсюда. Иногда, чтобы не писать на base контроллер, например, свой вешать такой путь ну и соответственно дальше работать. Какой-то способ оптимизации кода. Я предпочитаю здесь указывать конкретно что. Соответственно так будет более понятно. Можно написать контроллер, можно написать на действие. В данном случае route без ничего означает по умолчанию. Если вам придет на контроллер get запрос без ничего, мы оттуда будем брать. Должно быть уникально, то есть HttpGet без роута должно быть только на одном экшене.</p>

  <h2>WebApi endpoints - Routing</h2>
  <p>Аттрибуты для определения методов</p>
  <ul>
    <li>[HttpGet], [HttpPost] и т.д.</li>
    <li>[HttpGet(route)], [HttpPost(route)]</li>
  </ul>
  <p>Аттрибуты для определения маршрута</p>
  <ul>
    <li>[Route]</li>
  </ul>
  <p>Аттрибуты для определения маршрута в RazorPages</p>
  <ul>
    <li>@page "route"</li>
  </ul>

  <p>Какие у нас могут быть еще назначения. Мы можем детализировать наш request по-методу - HttpGet, HttpPost. Можем описаь HttpGet внутри роутера. Можете определить атрибут route. Если вы используете RazorPages вы можете использовать route непосредствено на странице при помощи @page. RazorPages мы применять не будем, на практике с ним поиграемся. Все похоже стало, вопрос только в оформлении.</p>

  <h2>WebApi endpoints - Routing</h2>
    
<pre>[Route("{id:int}/details")]
[ResponseType(typeof(BookDetailDto))]
pubic async Task&lt;IHttpActionResult&gt; GetBookDetail(int id)
{</pre>
    
<pre>[Route("{genre}")]
public IQueryable&lt;BookDto&gt; GetBooksByGenre(string genre)
{</pre>

<pre>[Route("~/api/authors/{authorId:int}/books")]
public IQueryable&lt;BookDto&gt; GetBooksByAuthor(int authorId)
{</pre>

<pre>[Route("date/{pubdate:datetime}")]
public IQueryable&lt;BookDto&gt; GetBooks(DateTime pubdate)
{</pre>

<pre>[Route("date/{pubdate:datetime:regex(\\d{4}-\\d{2}-\\d{2})}")]
public IQueryable&lt;BookDto&gt; GetBooks(DateTime pubdate)
{</pre>

  <p>Примеры. Какие у нас есть примеры. На первом примере у нас есть endpoint GetBookDetail в который приходит id. Внутри роута мы можем использовать переменные, они описаны в первой строчке и кусок текста. Единственно, надо убедиться что {id:int} будет уникальной. Если использовать id:string и потом еще где-нибудь то система выдаст ошибку. В данном случае, смотрим, у нас должен быть localhost какой-то от контроллера. И блок 10/details. Это значит что мы для книжки номер 10 покажем детали.</p> 
  
  <p>Во втором примере можем использовать строковую переменную без указания деталей {genre}.</p> 
  
  <p>В третьем примере можно использовать сложную вещь "~/api/authors/{authorId:int}/books".</p> 
  
  <p>В четвертом примере "date/{pubdate:datetime}". Через двоеточие мы можем указать любой тип. И система попытается параметр pubdate привести к типу datetime. Если сможет, тогда пойдет дальше. Если не сможет, то у нас bad request.</p> 
  
  <p>В пятом примере так как это у нас строка, то можем использовать регулярное выражение regexp. Например приходит datetime в такой строке - год - месяц - день. Это уже смотрите кто вам что присылает и в каком виде вы должны работать.</p>

  <p>Все что я вам показал, оно придет в роуте, часть в url. Не всегда так надо. Поэтому часто мы можем уточнить, где нам надо получить эти данные.</p>

  <h2>WebApi endpoints - Routing - Sources</h2>
  <p>[FromQuery] - Gets values from the query string</p>
  <p>[FromRoute] - Gets values from route data</p>
  <p>[FromForm] - Gets values from posted form fields</p>
  <p>[FromBody] - Gets values from the request body</p>
  <p>[FromHeader] - Gets values from HTTP headers</p>

  <p>Какие у нас есть sources. Например, у нас есть источники. Они прописываются в примере таким образом.</p>

  <code>
    http://RouteParameters?QueryParameters
  </code>

  <p>Мы можем сделать свой класс. В который будет автоматически сделан маппинг из наших входных параметров.</p>

  <code>
    public ActionResult<Pet> Create([FromBody] Pet pet)
  </code>

  <p>И можем сказать что мы ожидаем этот класс, что все данные будут лежать в body запросе. До вопроса это route параметр, а после вопроса это query параметры. FromQuery будет присылаться в QueryParameters. FromRoute будет присылаться в RouteParameters. FromForm будет присылаться в виде формы. Вы ее отправляете в html. FromBody весь запрос придет в body.</p>  
  
  <p>Здесь надо помнить что у get запроса body нет, поэтому вы запросить можете но это будет неправильно. FromHeader это в заголовке. Request это строка, поэтому все что мы делаем это способы каким образом где что дать. Класс Create из тела запроса возьмет класс Pet, а это у нас Name и Breed. Мы можем как здесь целиком искать, мы можем при помощи параметров в самой моделе раскрасить. Это мы возьмем в Route, это мы возьмем в Query и т.д. Ну тут уж смотрите самостоятельно. Чем проще тем лучше, тем понятнее. Но в ряде случаев иногда бывает надо похимичить.</p>   

  <pre>
    public class pet
    {
      public string Name {get; set; } = null;
      [FromQuery] // Attribute is ignored.
      public stringBreed {get; set; } = null
    }
  </pre>

  <p>По роутингу надеюсь тут вопросов нет. Плюс мы еще поиграемся на практике. Здесь просто имейте ввиду, тут надо просто набить руку. Ничего тут сложного нет. Опять же есть документация.</p> 
</article>

<article class="article">
  <h2>Middleware - Зачем</h2>
  <p>Выполнить какое-либо действие перед тем (или после того), как выполнится основное действие.</p>
  <p>Обработать ошибки</p>
  <p>Собственное протоколирование</p>
  <p>Проверка лицени</p>
  <p>Авторизация</p>
  <p>и т.д.</p>

  <p>Когда мы разговаривали с вами что WebApi это по сути набор endpoints. То есть у нас пошел request и возвращается response. Каким образом выполняется весь процесс. Он построен на основании промежуточных действий. У нас приходит request. Спервы выполняется одно действие, потом другое, потом еще. И эта куча промежуточных действий, они общие. Наш кусок кода, на основе какого-то скелета, а все наружи от нас скрыто. Выполняется шагами. Если какое-то действие проходит, то идет дальше.</p>

  <p>Эти кусочки, которые выполняются по мере прохождения реквеста и потом по мере возвращения респонса называется Middleware. По сути - промежуточные слоки. Вся система asp.net построена на том что вы собираете матрешку из этих кусочков. Вы собираете какие куски должны что делать. Это делается при помощи middleware. Все что мы сейчас будем настраивать, по сути все middleware. Зачем они нужны? Выполнять действие до или после реквеста. Первым делом вы делаете какой-то реквест, например, проверяете есть ли у пользователя доступ. Правильны ли у него какие-то данные, правильна ли валидация. Обработать ошибки. Вы можете глобально сказать в try catch обернуть и сказать все. Если здесь ошибка прошла - сделай что-то. Не стандартную обработку, а какую- то свою. Влепить протоколирование, добавить проверку лицензии. Авторизация тоже делается. Даже раскраска того же JSON. Например у вас какойто class вернул JSON. И вы его хотите каким-то образом отдать на клиент. Например, убрать из него все пробелы. Зашифровать. Это тоже может делать middleware.</p>

  <p>Как она работает. У нас есть Middleware. По сути это определенный класс. Определенным интерфейсом, на который приходит request. К нам приходит request, мы что-то с ним делаем и говорим next(). Как только мы вызвали next, у нас есть цепочка этих middleware, вызывается следующий middleware. Что-то делается с запросом и потом next(). И так далее. В конце, когда все middleware наши прошли - пришли до нашего кода Application code. Здесь в контроллере Controllers/Action мы что-то сделали и отдаем ответ. И middleware уже в обратном порядке возвращают response. В итоге клиент получает что-то. В принципе все просто.</p>

  <h2>Middleware - Order</h2>
  <p>При указании middleware иногда важно указывать их в нужном виде. Если у нас есть use autorization, use authentification. Попытайся авторизовать до аутентификации и у вас будет ошибка. Всегда нужно выставлять middleware в нужном порядке. Если порядок не важен, то можно и по другому. Старайтесь порядок выдерживать правильно.</p>

  <p>Request -> app.UseExceptionHandler() -> app.UseHsts() -> app.UseHttpRedirection -> app. UseStaticFiles() -> app.UseCookiePolicy() -> app.UseRouting() -> app.UseCors() -> app.UseAuthentification() -> app.UseAuthorization() -> app.UseSession() -> app.UseMiddleware&lt;CustomMiddleware&gt;() -> app.UseEndpoints() Потом в обратном порядке -> Response</p>

  <p>Посмотрим как работает этот порядок. У нас есть request и первым делом стандартно система делает UseExceptionHandler() обрабатывает ошибки. Потом подключает UseHsts. Потом UseRedirection. Если мы пытаемся сделать реквест на http, он нас автоматически редиректнет на https. UseStaticFiles и так далее. И так пройдет вся цепочка. Поэтому вы можете request, response на каждой цепочке что-то делать самостоятельно. </p>

  <h2>Middleware - Custom</h2>
<pre>
public class LogURLMiddleware
{
  private readonly RequestDelegate _next;
  private readonly ILogger&lt;LogURLMiddleware&gt; _logger;
  public LogURLMiddleware(RequestDelegate next, ILoggerFactory loggerFactory)
  {
    _next = next;
    _logger = loggerFactory?.CreateLogger&lt;LogURLMiddleware&gt;() ??
    throw new ArgumentNullException(nameof(loggerFactory));
  }
  public async Task InvokeAsync(HttpContext context)
  {
    _logger.LogInformation($"Request URL: {Microsoft.AspNetCore.Http.Extensions.UriHelp}")
    await this._nest(context);
  }
}
</pre>

    <p>Как это можно сделать. Вы можете написать свой Middleware. Это обычный класс, у которого есть функция InvokeAsync. Если у вас есть функция InvokeAsync, то у вас уже есть Middleware. Мы здесь делаем логгер LogURLMiddleware. И в InvokeAsync мы логгируем наш request, все что нам пришло. И говорим - выполняйся дальше.</p>

<pre>
public static class LogURLMiddlewareExtensions
{
  public static IApplicationBuilder UseLogUrl(this IApplicationBuilder app)
  {
    return app.UseMiddleware&lt;LogURLMiddleware&gt;();
  }
}

app.UseLogUrl();
</pre>

  <p>Мы подключим наш Middleware в нашу систему. И как только дойдет до Middleware. В нашу запись будет записано что такой реквест прошел. Таким образом можно сделать свое логирование. И если этот метод мы сделаем статичным классом, то можно его вызывать через app.UseUrl(). Таким образом мы можем сделать и систему проверки лицензий. Вы на входе проверяете request, в реквесте есть данные лицензии, вы оттуда информацию достаете, проверяете лицензия ли это, актуальная ли она еще. И если что-то не актуальное просто сразу говорите - извините, у вас нет лицензии.</p>

  <p>Что это означает. Что до баз данных неавторизованный код без лицензии вообще не пройдет.</p>

  <h2>Middleware - Example</h2>
  <p>Пример Middleware здесь про Exception. Если вам надо Exception преобразовать и вернуть на клиент в виде определенной структуры. Для того чтобы клиент, получив ошибку не сильно думал что это. Он просто обработал. Как это делается. Мы создаем класс ExceptionMiddleware. Получили делегат на next. И сделали функцию InvokeAsync. В которой обернем try catch, обернем Invoke. И если мы поймали BatchException то делаем одно. Если ProcessException то другое. Если RepositoryException то третье. И в конце если какая-то ошибка есть , мы ее формируем в JSON. Если нет значит не сработает наш Middleware и в данном случае он не нужен. Таким образом, любые ошибки придут в нужной форме на SPA приложение. Для того чтобы подключить app.UseMiddleware&lt;ExceptionsMiddleware&gt;() ставим в нужном месте и все, забываем про случайные ошибки.</p>

  <p>По Middleware вопросы есть? Все понятно здесь? Не так все сложно, поэтому пойдем дальше.</p>
</article>

<article class="article">
  <h2>2. Архитектура проекта - Слои</h2>
  <p>User -> Presentation Layer -> Business Logic Layer -> Data Access Layer -> DataBase</p>

  <p>Поговорим немножко про архитектуру. Архитектур много. Все приводить смысла нет. Остановимся на той которая пригодится для работы. У нас есть пользователь. Какие этапы он должен пройти? Первым делом он должен наткнуться на Presentation layer.</p> 
  
  <p>User - Presentation Layer - Business Logic Layer - Data Access Layer - Database</p>

  <p>Это уровень презентации приложения. Здесь описан контроллер, api, роутинг. Это то что взаимодействует с внешним клиентом. Презентация что-то делает и посылает команду в слой бизнес логики. Слой Business Logic Layer это основной рабочий слой. Он должен сделать простые вещи. Он должен проверить авторизацию. Проверить правильно ли пришел реквест. Сделать форматные проверки. Если он ожидает данные это должны быть данные. Если он ожидает строчку это должна быть строчка. Если он ожидает число, то придти должно число. Но уровень презентации не должен лезть в базу данных, не должен делать какие-то действияю. Каждый слой, каждый кусочек приложения, должен заниматься чем-то своим. Презентационный слой, его задача общаться с клиентом. Получить запрос, проверить. Вернуть клиенту ответ системы в том виде в котором от него ожидают.</p>

  <p>Бизнес логика это ядро. Один или несколько сервисов, состоящих из кучи классов. Которые всю эту логику и выполняют. И уже в бизнес логике хороошо проверить что эти данные консистентны. Например, проверка на уникальность. Уровню презентации на самом деле все равно. сказали создай юзера Иванов - создали. Бизнес логика уже должна проверять. Здесь же выполняются права, здесь же надо делать и логгирование. Здесь делать всякие проверки и так далее. Бизнес логика это из класса который сама себя вызывает. Класс для работы с юзером вызывает класс для посылки письма. Класс для посылки письма вызывает сообщение о посылке RabbitMQ. Внутри можете навертеть все что угодно.</p>

  <p>Вы команду послали, вы сразу проверили и сказали либо я не могу создать тебе юзера либо что-то сделали. Вот тебе его данные. Persistance слой получил эти данные. Мне сказали юзера, обернука я его в xml, потому что клиент так просит и отдам на клиент. Бизнес логика чаще всего тестируется. Если у вас классы все четкие, вы можете подключить сюда unit тесты. И проверить как все это дело работает. Если у вас оно инкапсулировано в одном месте, то проверите. Если оно у вас разбросано по 10 местам, я думаю что вы тест напишите с большим трудом, а если напишите то весьма плохой.</p>

  <p>Бизнес логика какие-то действия сделала. Бизнес слой может работать не только с базой данных, он может послать запрос на другой микросервис, может выполнить несколько действий: создать юзера, создать права юзеру, отослать письмо администратору. Это одна инкапсулированная логика. В этом смысл бизнес логики. Если у нас есть Data access layer, то он работает с обычными командами - создай юзера, удали юзера. Его задача проверить полученную информацию, трансформировать ее в подходящий вариант для использования подключенной базы данных, либо для внешнего сервиса, необязательно базы данных. Data access layer может легко работать с репозиторием в интернете и какие-то действия выполнить.</p>

  <p>Так и получается. У нас реквест обработался, проверился поверхностно и отдался бизнес логике. Например, это запрос, бизнес логика сделала с ним что-то серьезное. Например, сохранила в базу данных, проверила какие-то действия. В ответ каждый раз вернула - ОК. Общие константы и методы для всех уровней выносятся в отдельные куски кода и  находятся в Core Infrastructure Layer. Вот такая слоистая архитектура достаточно удобная и простая для того чтобы делать веб апликейшн, она подходит для микросервисов. Кому мало можете посмотреть луковую архитектуру, clean code. Все архитектуры об одном и том же говорят и пытаются показать куда какие куски надо класть.</p>

  <p>Вы можете делать что угодно. На уровне контроллера напрямую писать в базу данных. Никто вам запретить не может. Или можете сделать два контроллера. Один будет для SPA приложения, другой для мобильного. И там и там у вас будет функция создания юзера полноценная. С проверками, с отправкой почты и т.д. Но проблема в том что такой код будет плох (дублирование, неразделение ответственности) и через какое-то время вы его, как минимум, поддерживать не сможете. Либо будет очень много ошибок. Все архитектуры нужны для того чтобы программисты придерживались одного подхода. И если выбранная архитектура хорошая, удобная, все ее поддерживают, то проект управляем. Если четких правил нет, то один программист пишет одно, другой другое. Это кошмар для тимлида и кошмар для проекта. Про архитектуру поговорили.</p>
</article>

<article class="article">
  <h2>Взаимодействие между слоями</h2>
  <p>Вариант 1. Не изолировать слой от соседей. (Потребитель создает и использует классы бизнес-логики напрямую или через DI. Имеет полный доступ к их реализации)</p>
  <p>Вариант 2. Частично изолировать слой от соседей (потребитель использует только интерфейсы и общие модели для доступа к классам бизнес-логики)</p>
  <p>Вариант 3. Полностью изолировать слой от соседей (потребитель создает и отправляет команды к бизнес логике, подписывается на ответы. Классы бизнес-логики ведут себя также)</p>
</article>