<article class="article">
	<div id="link-to-dsr2023net" class="btn-back">назад</div>

  <h1>2023-10-02 Lecture #1 Software Developer</h1>
</article>


<article class="article">
  <p>Лекцию читает Андрей Кононов (автор курса)</p>

  <p>Здравствуйте! Напишите, пожалуйста, меня видно, слышно? Требуется ли что-то прибавить? Отлично. Все, здорово. Немножко поставлю здесь чат. Если что – пишите, я буду поглядывать в него периодически и отвечать на вопросы. Итак, всем здравствуйте.</p>

  <p>Сегодня у нас первая лекция нашей школы. Надеюсь, это будет интересно и полезно всем. Сегодня у нас вводная лекция. Сегодня мы немножко поговорим на отвлеченные темы. Для разогрева. Я считаю, что эта лекция одна из самых выжных. По сути, просто поговорим, пообсуждаем. Приветствуется обратная связь, если у вас будут какие-то вопросы, пожелания или ответы на вопросы, я буду периодически задавать, не стесняйтесь, пишите в чат. Будем вместе разбираться.</p>
  <p>Немножко о курсе, еще раз. Тем, кто не был на презентации. У нас будет курс, который называется Web Appication Development. И он будет сосредоточен на платформе .NET как целевой. После того как вы этот курс успешно пройдете, вы вполне можете создать самостоятельно Web API приложение и клиент к нему. Как минимум на Blazor, как максимум кто соответственно на что готов. По большому счету различие для web клиента blazor или там например какое-то WPF приложение или какой-нибудь мобильный клиент, именно с точки зрения архитектуры и подхода нет. Разница будет только во фреймворке, в языках, но при этом концептуально все останется как есть. Это вот основная цель нашей школы. </p>
  <p>Но при этом мы не сосредотачиваемся только на изучении .NET и каких-то фреймворков. Они будут идти параллельно. Я и наши учителя постараемся дать вам базовые знания, которые пригодятся не только для .NET но и в целом для понимания что такое веб разработка, что такое вообще разработка. Лекция, которая сегодня будет проходить – она такая, вообще общая. Дальше поговорим об архитектуре. Какие-то вопросы, которые вам сильно могут помощь на прохождении собеседований. Так что будет интересно. Слушайте, задавайте, участвуйте активно. Если какие-то есть действительно вопросы, которые вас как-то волнуют или на которые требуется дать расширенный ответ, не стесняйтесь, можно будет писать и по ходу лекции я постараюсь на них ответить. Если они будут достаточно простенькими и не будут сильно влиять на процесс. Либо можно писать в наш телеграмм, ну и соответсвтенно кто может – отвечайте. Как я уже говорил, программирование - это командная работа. Наши преподаватели и я тоже будем стараться ответить. Отлично. Давайте начнем нашу лекцию.</p>
</article>  

<article class="article">
  <h3>Лекция 1 Профессия Software developer</h3>
  <p>Мы сегодня поговорим от том что такое Software developer, что такое Software development. Немножко расскажу о компаниях. Если вы будете работать как разработчик внутри IT компании. У вас будет понимание как там все изнутри устроено. Кто за что отвечает. И поможет вам решить в каким направлении вам интереснее развиваться. Потому что IT чем интересен, вы можете развиваться куда угодно. Можете стать программистом, можете стать PM или пойти в направление QA. Про это сегодня расскажем. Куда лежит душа. Все направления важны. Все направления интересны. Постараюсь дать ответы на вопросы, которые позволят вам для себя решить, что интереснее вам.</p>
</article>
  
<article class="article">
  <h3>О чем будет эта лекция:</h3>
  <p>- Знакомство с профессией. Любая профессия должна давать какой-то продукт.
  <br>- Что производит программист
  <br>- Зачем нужна команда
  <br>- Почему писать системы сложно
  <br>- Почему не удается написать то, что планировали
  <br>- Деструктивные факторы в работе
  <br>- Качество работы программиста
  <br>- Инструменты и технологии
  <br>- Процесс разработки</p>
</article>
  
<article class="article">
  <p>О чем будет сегодняшняя лекция. Что мы сегодня разберем. Поговорим немного о самой професси. Поговорим о продукте. Любая профессия должна давать какой-то продукт. Поговорим что же делает программист. О команде поговорим. Всевозможные правила как можно писать код, как нельзя писать код. Или, точнее, как не стоит писать. Писать код можно как угодно, как вам нравится. Но если вы хотите работать в команде, хотите работать эффективно. То есть сложившиеся временем правила. Поговорим по качеству. Поговорим об инструментах немножко. Это вводная лекция, поэтому записывать ничего не надо. Будет запись лекции. Можно будет ее пересмотреть. Чашечку кофе и чашечку чая с шоколадкой можно сделать.</p>
</article>
  
<article class="article">
  <h3>Группы программистов:</h3>
  <p>- просто прохожие
  <br>- для себя
  <br>- сотрудники
  <br>- фрилансеры
  <br>- стартаперы</p>

  <p>Давайте сперва поговорим про программистов. Что такое программист. Я начну издалека и постепенно придем к современности. Первые программисты писали на перфокартах. Они делились на системных программистов, на математиков. Системные программисты делились на тех и на тех. Классификация это мое самое не любимое дело и когда я сам был студентом. Но при этом все преподаватели очень любили классификацию. Делили ее на группы, заставляли заучивать. Это все ерунда. Заучил, сдал, забыл. Главное понимать качество. Я , конечно пошутил , с классификацией. Мы этим заниматься не будем. Давайте посмотрим кто такие программисты. А вы попробуйте определить для себя кто вы для себя. Может быть какую-то роль себе найдете.</p>

  <p>Первый программист, которых я выделяю, это «прохожий». Сейчас неимоверное количество людей хотять в IT. Они даже не хотят стать программистами, они хотят в IT. Львиная часть тех, кто хочет в IT не понимает что такое IT, не понимает что такое программирование. Просто знают что здесь есть деньги, есть префиренции, может быть еще что-то и просто пытаются сюда попасть. Я таких называю просто прохожий. Из них, вполне возможно что есть те которые как-то изучат профессию и смогут что-то делать, но львиная чать – они пойдут посмотрят и ничего делать не будут. Они будут интересоваться, они будут читать какие-то научные статьи, максимум на habr посидят. Могут сыпать терминами. Знать что Java лучше чем .NET, а javascript бьет и .net и яву. По большому счету, в жизни не писали кода и никогда не напишут. Такие программисты считаются «зрители». Они вряд ли смогут профессионально работать.</p>
  
  <p>Следующая группа – это те которые пишут «для себя». Это те которым действительно интересно. Программирование – хобби. Они могут написать какой-то реально серьезный софт. Не исключено. Они могут спрограммировать не только какое-то приложение, сайт, они могут спрограммировать что-то на RASBERY.API, собрать что-то на Arduino, прицепить процессор и его запрограммировать и так далее. Они в итоге получают какие-то интересные решения, интересные вещи для себя. Они не собираются это профессионально отлаживать. Делать так чтобы это можно продовать и так далее.</p>
  
  <p>Следующие ребята – это «сотрудники». Львиная часть программистов, которые работают в IT сфере это именно «сотрудники». Чем занимаются сотрудники. Сотрудники пишут код по потребности которую им дает руководитель, дают клиенты. Они – исполнители.</p>
  
  <p>Еще выделяются «фрилансеры». Это по сути бизнесмен. То есть тот кто пишет что-то для себя, который не хочет видеть у себя начальника, он ценит свободу. Но при этом точно так же работает на клиента. Он действительно программист. Возможно в чем-то более широкий кругозор и более высококлассный программист, чем рядовой сотрудник. Хотя бы за счет того, что больше проектов делал, больше видел. Но он такой же сотрудник, только начальник у него – он сам.</p>
  
  <p>Есть «стартаперы». Это те, которые хотят сделать что-то новое. Самостоятельно, для себя, они начинают двигать индустрию. Львиная часть из них прогорает. Еще большая часть бросает на старте все это дело. Некоторые бросают свой стартап на моменте обсуждения «на чем мы будем писть». У них какая-то жилка и они пытаются сделать что-то свое. Когда-то многие сотрудники и фрилансеры пытались сделать свой стартап. Я не исключение. Я до сих пор хочу его сделать, идеи есть. Но, скорее всего, они как идеи и останутся. Им не интересно как работать над скучными задачами, над которыми работают сотрудники. Есть сотрудники, которые работают по найму, у них реально сложные проекты. Львиная часть сотрудников делают какие-то формочки, скриптики, таскают друг у друга с сайтов информацию. Так сложились звезды сейчас, к сожалению. Некоторые делают, например, систему заказов на Озон. Сравните – спарсить сайт или сделать распределенную систему, чтобы можно было большим количеством магазинов управлять.</p>
  
  <p>Это в общем. Кто-то здесь увидел себя, кто-то не увидел. Здесь нет плохих групп. Это всё группы по психологии и в большей части они определяют какой у вас сейчас внутренний настрой, что вам больше нравится. Просто «прохожий» – ну интересно. «Для себя» – что-то сделал и забыл. «Сотрудник» хочет работать по заказам, ему нужны задачи. Он не собирается и не хочет искать клиента, ему не нужны проблемы с бухгалтерией. Он хочет просто работать и получать зарплату. «Фрилансер» не хочет над собой никакой власти. Он может искать заказы, но при этом несет все риски. «Стартап» это вообще рисковый проект, все бросаем, все делаем, кто-то выстрелит, кто-то нет.</p>
  
  <p>Вы, как программист, как сотрудник, можете постоянно перемещаться между этими группами. Просто подумайте что вам нравится. Это может помочь вам выбрать комфортную область где можно применить ваши знания, где будет интересно.</p>
</article>

<article class="article">
  <h3>Качества хорошего программиста</h3>
  <p>- интеллект и умение выражать свои мысли
  <br>- страсть
  <br>- настойчивость
  <br>- любовь к новому и самообучение
  <br>- гибкость мышления</p>

  <p>Мы поговорили кто такие программисты. Программист бывает хорошим или плохим. Давайте об этом поговорим. Что надо для того чтобы стать хорошим программистом. Самое главное, это интеллект и умение выражать свои мысли. Почему? Интеллект чтобы человек мог думать, у него должен быть кругозор. И умение выражать свои мысли. Очень важное качество. Человек, который не может четко выразить свои мысли, скорее всего хорошую программу написать не сможет. И управлять не сможет. Программирование - это перевод с каких-то мыслей на машинный код через язык программирования. Объясняет компьютеру как и что надо сделать. Компьютеры это устройства довольно тупые, им необходимо рассказать все очень четко и подробно. Если где-то что-то неправильно сделать и компьютер будет делать что-то неправильно. Отсюда и львиная часть ошибок. Что-то не учли, что-то не то сделали. Поэтому не программирование важно, а именно вот эта вещь.</p>

  <p>Следом, я бы отметил страсть. Настоящий программист он страстно увлечен этой профессией. Если со стороны посмотреть как выглядит программист. Это кто-то сидит на клавиатуре долбит, глаза горят. И для всех остальных выглядит немножко сумасшедшим. На самом деле для того чтобы писать программы необходимо это дело любить. Если вам не нравится профессия, скорее всего, вам будет здесь не комфортно. Это только на старте нового проекта интересно, а потом начнется работа с legacy, работа с какими-то скучными задачами однотипными, исправление каких-то багов. И если вам программирование не нравится, просто будет постоянно дискомфортно. И это еще одна из веще почему не все смогут стать программистами.</p>
  
  <p>У меня были знакомые в университете. Один знакомый. Я всегда его вспоминаю. Отличный программист. Все прекрасно делал. Жил программированием. Его отчислили из ВГУ по причине неявки и хронических пропусков занятий. Но при этом он не пропустил ни одного дня, ходил даже в субботу, в компьютерный класс. Это было достаточно давно. Компьютеры были редкостью. Только в институтах стояли. Ни у кого дома их не было. И он просто программировал. Самостоятельно что-то учился, изучал. Вот его отчислили за непосещаемость. При этом он не сильно расстроился и сейчас работает в очень хорошей компании. Потому что он это дело очень любил.</p>

  <p>Настойчивость. Особенно при исправлении багов. Или, например, доделки системы до конца. Без настойчивости будет большое желание все бросить на старте.</p>

  <p>Любовь к новому и самообучение. Это вечные студенты программисты. Постоянно новые фреймворки, постоянно новые технологии. Кто-то лучше придумал архитектуру, кто-то хуже. Надо посмотреть. Выучив один язык и на нем вечно жить наверно можно, но скорее всего не в России а где-нибудь в Америке где есть еще компании которые пишут на старых языках вплоть до фортрана. Большие здоровые системы. Те люди, которые их изучили получают там неплохие зарплаты и обслуживают этот старый язык. У них высокие зарплаты потому что их уже очень мало как динозавров. Если вы хотите двигаться в ногу со временем, скорее всего, придется постоянно учиться и будьте к этому готовы.</p>

  <p>Ну и гибкость мышления. С чем это может быть связано? Изучив, как мы на лекции как писать web api приложение, это будет архитектура которую я вам предложу. Вовсе не означает что эта архитектура идеальна со всех сторон. Она с какой-то стороны хороша, с какой-то стороны может быть улучшена. Но если вы будете это решение везде транслировать. Не попытаетесь посмотреть плюсы, минусы, что-то другое. В итоге сами себя ограничете. Надо постоянно смотреть по сторонам. Постоянно пытаться что-то придумать. Говорят, программирование – это искусство костылей. Если делать грамотный костыль для кода, то это тоже надо придумать каким образом это сделать.</p>

  <p>Обратите внимание что в качествах хорошего программиста я не написал ни математические знания, ни умение писать архитектуру, ни знание десяти языков программирования. Все, на самом деле, это не важно. Это все сложно, в некоторых местах пригодится. Но если у вас есть эти пять качеств, то выучить язык – вообще не проблема.</p>
</article>
  
<article class="article">
  <h3>Программист или разработчик?</h3>
  <p>Чем программист отличается от разработчика?
  <br>- Программист – пишет код
  <br>- Разработчик – разрабатывает решение</p>
  <h3>Уровни квалификации (Position)</h3>
  <p>- Trainee
  <br>- Junior
  <br>- Normal
  <br>- Senior
  <br>- Lead
  </p>

  <p>Программист это специалист, который пишет код. Ничего больше. Задача на входе и код на выходе. Разработчик рассматривает немножко шире. Он разрабатывает решение. Например, программист пришивает пуговицы, а разработчик делает костюм. Некоторые скажут что разработчик равно программист. Но не всегда. Результат работы программиста это код. Хороший программист пишет хороший код. А разработчик смотрит не только на код, он смотрит на архитектуру, на ценности, на тест-кейсы. Поэтому разработчики ценятся повыше.</p>

  <p>Посмотрим какие есть уровни квалификации. Это очень приблизительная вещь. В каждой компании это понятие может варироваться. В некоторых компаниях сеньёрами считают тех кого смогли продать на сеньёрскую должность. Неважно какие у него знания. Если за него клиент платит как за сеньёра – он сеньёр. У каждой компании свои принципы. Я предложу мнение как можно определить на каком уровне вы и к чему надо стремиться. Я выделил пять типовых уровней.</p>

  <p>Trainee это начинающий. Может не знать язык, не знать технологию, но очень сильно хочет выучиться. Студент, практикант.</p>

  <p>Junior это уже программист. Он должен уметь писать код. Должен знать язык, какие-то основы. Он должен не просто писать какой-то код, он должен писать качественный код. Это минимальная позиция программиста. Junior это тот который делает работу. Он обязательно получает задачи. Конкретные, расписанные, с ограниченными сроками. Ему дают маленькую задачу и он должен ее качественно решить. Если вы идете на джуна, вы должны это уметь. Junior решения принимать не должен.</p>

  <p>Normal это человек, который может сам принимать какие-то решения относительно кода. Например, как сделать какую-то функцию по-другому. Ему дают уже не просто задачи, например, сделай мне функцию, в которой надо три параметра, которой надо на выходе такие-то поля. Его уже просят, например, сделай мне функцию расчета факториала. И он сам может разобрать что надо подать на вход, что должно быть на выходе. Он знает как внутри модуля сделать правильную архитектуру. Как разбить по слоям. С кем связаться. Какие библиотеки использовать. Это нормальный, состоявшийся программист у которого еще не хватает опыта, обязанностей для того чтобы вырасти на уровень выше.</p>

  <p>Senior это тот который может решать проблемы системы целиком. Проблемы заказчика. Если junior пишет код, normal решает проблемы приложения, senior уже решает проблемы заказчика. Он смотрит на архитектуру. Может создать с нуля систему. Может выбрать из двух систем лучшую. Может выбрать фреймворк. Необязательно все писать на .NET. Можно написать один модуль на .NET, второй на node.js, третий вообще на python или typescript. И если в кучу все это собрать то получится решение которое будет работать быстро и все делать хорошо. Сеньёр уже эту работу выполнить сможет. Он сможет сказать сколько на это потребуется времени и т.д. Сеньер это старший, считайте что вы уже научились.</p>

  <p>Lead на самом деле это тоже что и senior. Но я считаю что лид это немножко старше по психологии. Сеньер может быть очень отличным разработчиком. Но он может не быть лидом. У него не хватает каких-то софт качеств или он не хочет этим заниматься. Не все сеньеры хотят быть лидами. Он больше упирается в сторону железа. А лид уже с точки зрения того что у него команда, он умеет руководить людьми, умеет ставить задачи, нести за них ответственность, как их организовывать. Чаще всего лиды вырастают из сеньеров. Поэтому они примерно одной области. Считайте что лид это тот который может решить проблему заказчика с помощью других людей. Сеньер и лид равны, просто у них разное приложение сил.</p>
</article>
  
<article class="article">
  <h3>Продукт, который делает программист</h3>
  <p>Продукт, который выпускает программист это код.</p>
  <h3>Почему важно писать хороший код:</h3>
  <p>Чтобы не тратить время на его понимание
  <br>- новым сотрудникам
  <br>- коллегам
  <br>- себе через месяц</p>
  <p>Чтобы код можно было поддерживать и развивать</p>
  <p>Чтобы проще искать и исправлять ошибки</p>
  <p>Чтобы относительно просто подстраиваться под изменения требований</p>
  <p>Чтобы не было мучительно стыдно в будущем</p>

  <p>Зачем нам писать хороший код? Если мы написали код, он скомпилировался, программа работает. Хороший код писать надо для того чтобы не тратить время на его понимание. Никто никогда не пытался посмотреть свой код, который год назад писали? Со словами «кто же это писал?». Представьте что у вас есть здоровая система, и там кто-то пишет реально плохой код. Приходит новый сотрудник и очень мучительно разбирается в нем. Ладно там все работает, но непонятно как работает. Но исправление мелкой неточности, которую нашел заказчик или исправление микрофичи выливается в огромное количество времени и еще может потом все сломаться. Писать хороший код надо чтобы коллеги и себе через месяц не тратить дополнительно время на понимение. Это навык, который со временем приходит. Если будете стараться писать код хорошо, он будет писаться сам.</p>

  <p>Чтобы код можно было поддерживать и развивать. Если плохой код, то его очень сложно поддерживать. Хороший код это где можно написать функцию, можно его расширить, быстрее найти ошибку. И самое главное, что вытекает из поддержки и развития это возможность вносить изменения. Хороший код с хорошей архитектурой позволяет его модифицировать. А заказчики это такие люди, которые постоянно что-то еще хотят. Это не плохо. Если заказчик хочет от вашего софта чтобы вы постоянно что-то допилили, доделали, это значит что он ему нужен и он будет деньги платить. Если заказчик скажет «мне от вас больше ничего не надо». Варианта два. Вы сделали что-то идеально что соответствует. Или что более вероятно заказчик в вас разочаровался и больше не хочет с вам дело имать. И никаких денег никто не получит. Поэтому это важно. Если заказчик просит какие-то фичи – это отлично.</p>

  <p>Если пишите хороший код – дальше будет лучше. Ну и ситуация. Вы сейчас джун, написали код. Потом вы нормал. Дописали модуль. Теперь вы сеньер. А пришел джун разбирается в коде и ругается. А вы понимаете что это ваш код. И вы как его начальник будете себя чувствовать не очень хорошо.</p>
</article>
  
<article class="article">
  <h3>Метрики качества кода</h3>
  <p>Метрику качества я нашел в книжке «Идеальный код». Конечно шуточная. Это количество чертей в минуту. Если чертей мало , то это хороший код. Шутка, не шутка. Но это, наверно, единственно правильный подход. Если вы понимаете код, он читается и никаких претензий к коду нет – значит код хороший. Единого мнения, например сделать отступы и код будет считаться хорошим, - нет. У каждого проекта он свой. У каждой команды он тоже свой. Самое главное, чтобы код был понятен и не было желания выкинуть его на свалку и переписать.</p>

  <h3>Как улучшить качество кода.</h3>
  <p>Читать книги:
  <br>- Чистый код (Роберт Мартин)
  <br>- Рефакторинг (Мартин Фаулер)
  <br>Следовать устоявшимся стандартам и принципам
  <br>- Паттерны проектирования
  <br>- Принципы SOLID
  <br>Смотреть как делают другие, пытаться понять и повторить
  <br>Использовать иные источники информации
  <br>- Youtube, семинары, конференции и т.д.
  <br>Практиковаться
  </p>

  <p>Читать книжки. Читать какие-то материалы. Заниматься рефакторингом постоянно. Уделять время на архитектуру и дизайн. Не всегда это возможно. Не во всех проектах это возможно. Особенно в требованиях заказчики могут задать написать быстро систему и не давать время на рефакторинг. Но старайтесь хотя бы по мелочам это дело делать. Каждый раз когда вы приходите на шашлыки и увидели мусор – возьмите и уберите. То же самое, если в коде нашли какую-то ерунду – чуть-чуть поправьте ее. Единственное требование – не сломать. А то можно поправить так что потом вся система рухнет. И все очень аккуратно.</p>

  <p>Если вы начинающий программист да и в будущем, надо каким-то стандартам стараться следовать. Все эти принципы, паттерны это сложившиеся на практике решения, которые позволяют нормализовать процесс написания кода чтобы всем было понятно. Если вы будете писать по такому паттерну, кто-то на него глянет – «а! это вот так пишется» и поймет логику сразу. Есть некоторые вещи – тот же SOLID, мы его рассмотрим в этой лекции, который позволяет более качественно проектировать код и не добавлять плохой код в приложение.</p>

  <p>Очень крайне рекомендую смотреть как делают другие. У меня когда есть время я стараюсь с гитхаба стягивать интересные проекты и смотреть какая там архитектура, какие модули, как они имена называют. Это тоже полезно.</p>

  <p>Смотреть другие источники информации – youtube, семинары, конференции. Если есть возможность их смотреть или посещать то это всегда полезно. Не факт, что посетив семинар вы получите дзен как это надо делать, но появятся какие-то мысли, какие-то новые идеи, в голове отложится и потом скомпилируется и в результате будет хорошо.</p>

  <p>Ну и практиковаться это, пожалуй, самое важное. Если вы будете это все выполнять, но не будете писать код, вы будете просто теоретиком и, скорее всего, хороший код вы написать никогда не сможете. Программист учится кончиками пальцев.</p>

  <h3>Продукт, который делает команда.</h3>
  <p>Продукт, который делает команда – Решение проблемы заказчика.</p>
  <p>Внимание вопрос: почему нельзя сделать все самому?</p>

  <p>Сеньер способен решать проблему заказчика, но не значит, что он будет это делать. Но проблемы бывают разные. Если для фриланса один человек может сделать какое то мелкое решение, например, написать модуль, сайт, то серьезные системы в одиночку сделать нельзя. Это одна из основных причин почему стартапы рушатся. Потому что, во-первых, очень большое количество работы нужно сделать, которая не связана с программированием. Поэтому стартапы останавливаются еще в начале. А те, которые дальше прошли, они потом перерастают из программистов в бизнесмены и уже решают по-другому задачи. И поэтому нанимают в работу уже команду. Представьте, что команда не пишет код, а решает проблему. Когда вы будете работать в компании, имейте ввиду, что вы работаете не для себя, вы работаете для заказчика. Чем раньше вы это поймете, тем быстрее вы будете в связке с заказчиком и будете делать то что надо. У вас будет меньше потерь времени. И вы будете более ценны для вашего руководителя. И для вашей компании.</p>
  <p>Волшебный вопрос: почему нельзя сделать все самому?</p>
  <p>На самом деле можно. Если вы гений. Если у вас много свободного времени. Свободное время равно свободным деньгам. Нам надо зарабатывать деньги чтобы жить. Но если у вас очень много денег и вы готовы делать систему, возможно вам нет смысла делать эту систему, деньги можно по-другому зарабатывать, например, инвестиции. Ну допустим, у вас все есть. Это хобби. Можно сделать. Но что-то большое самостоятельно сделать нельзя.</p>
</article>

<article class="article">
  <h3>Роли в команде разработки системы:</h3>
  <p>- PM (Product Manager)
  <br>- BA (Бизнес аналитики)
  <br>- Developers (Разработчики)
  <br>- QA (тестировщики)
  <br>- DevOps</p>
  <h3>О ком мы забыли еще</h3>
  <p>- Бухгалтерия
  <br>- Маркетинг / Продажи
  <br>- Техподдержка
  <br>-Администрация
  <br>- DBA / Sysadmins
  </p>

  <p>В каждой команде все друг другу помогают и часть работы на себя берут. Основные роли, которые есть в команде это проектные менеджеры, бизнес аналитики, разработчики, тестировщики. Каждая из этих работ слабо пересекается с другой, она очень специфическая. Совмещать, например, роль девелопера и девопса можно, но в этом случае вы будете работать не эффективно. Либо будут затраты по времени большие. Все работы будет делать один человек друг за дружкой. Либо качество снизится.</p>
  <p>Это только команда разработки. Если вы хотите сделать стартап, который будет что-то продавать, то у вас должна быть обязательно бухгалтерия. Продукт нужно продвигать. Пользователи начнут звонить со словами «почему у меня ничего не работает и почему эта кнопка красная». Когда становится много людей то появится еще и администрация. Например, в офис нужна еще и уборщица. Будут компы и их надо настраивать в сети и т.д. С ростом команды появляется и обслуживающий персонал. Делать все самостоятельно уже в принципе невозможно. Мелкое – легко, что-то среднее и большое – уже нет.</p>

  <h3>Роли команды</h3>
  <p>- Product Manager
  <br>- Project Manager
  <br>- Business Analytic
  <br>- System Analytic
  <br>- System Architect
  <br>- UI/UX desiner
  <br>- BE developer
  <br>- FE developer
  <br>- QAA engineer
  <br>- QA engineer
  <br>- DevOps
  </p>

  <p>Теперь подробнее о ролях в команде, которая занимается разработкой. Самый главный это Product Manager. Он знает что такое продукт, что он умеет делать, как он должен продаваться. Он определяет каким продукт должен быть. Он общается с заказчиком, может отказывать заказчикам. Он четко фокусируется на целевых группах клиентов и в них работает. Плохой продукт менеджер пытается всем все пообещать и в итоге вместо хорошего продукта появляется франкенштейн, который через какое-то время загнется. Продукт менеджер определяет стратегию развития продукта. Что надо сделать, кому будем продавать. Что будем делать в первую очередь и т.д. Без него не получится.</p>
  <p>Проджект менеджер -  это человек, который будет управлять вашим проектом. Он будет делать то что продукт менеджер придумал. Основная задача проджект менеджера это загрузить команду. Обеспечить их работой, обеспечить их задачами. Связать все по времени. Если несколько отделов работает, то когда один закончил его результаты сразу подхватил второй без простоев. Он может следить за мотивацией, добавлять и удалять людей в команду. Он может не влиять на сам продукт. Он работает на то чтобы этот продукт был сделан.</p>
  <p>Бизнес аналитики бывают двух видов – бизнес аналитики и системные аналитики. В чем отличие? Бизнес аналитики – это аналитики, которые работают с клиентами, то есть они направлены наружу. Они собирают информацию от заказчика: что им требуется, в каком виде им требуется. Они додумывают за них какие-то схемы, какие-то правила, детализируют их. Например, поле ввода. Что надо сделать если в поле ввода пустое значение, какое сообщение надо показать. Выдаст ли ошибку. Он должен конспектировать все за заказчиком, чтобы не потерять. И пытаться все это свести. Потому что заказчики - это такие люди, которые путаются в показаниях, хотят противоположных вещей. Пул этих требований надо перевести из хаоса хотелок в направленный поток, который можно реализовать. И все документируется. Этим занимается бизнес аналитик. Бизнес аналитики не занимаются созданием систем вообще. Они создают концепт системы с точки зрения клиента.</p>
  <p>Системный аналитик – это тот, который как раз пишет систему. Ему от бизнес анализа приходит задача. Например, надо сделать форму регистрации. Он уже определяет, что в форме регистрации будут такие-то поля. Здесь мы поставим такой-то фреймворк. Система будет такой-то архитектуры. Они описывают техническую часть. В больших компаниях, где большие системы, такие роли разделяются. Чаще всего, бизнес аналитики и системные аналитики связаны в одной области. Например, есть бизнес аналитик сеньер который вышел из технической среды. Если системный аналитик вышел из QA не из программистов, то системный аналитик выполняет роль системного архитектора.</p>
  <p>Системный архитектор – это тот, который эту систему пишет, то есть проектирует. Какие базы использовать, какой структуры базы, будем это настраивать на вейселе или своих серверах, микросервис или монолит. Вот такие решения. Делает архитектуру приложения.</p>
  <p>UI/UX дизайнеры рисуют красивый интерфейс, чтобы нравилось заказчику. UI это картинка, а UX это user expirience чтобы было удобно пользоваться. Дизанер который только рисует красиво, но не думает как это сделать удобным для пользователя – это плохой дизайнер. Хороший дизайнер помимо того, что он рисует красиво, он обязан продумать как пользователь будет с этим интерфейсом работать. В том ли месте располагается кнопка. Хороший дизайнер тоже на вес золота. Чаще всего стараются какие-то дизайники нарисовать. Причем на дизайне все смотрится шикарно, но частенько дизайнеры пренебрегают тем что у пользователя могут быть фамилии с разным количеством букв. Нарисуют все на коротенькие фамилии и все смотрится красиво. А большие фамилии уже не помещаются. Хороший дизайнер должен это дело предусмотреть. А в современном мире надо еще на мобильные приложения смотреть.</p>
  <p>Бекенд девелоперы. Чаще всего все системы у нас это internet paste. Они где-то там лежат или на сервере. Бекенд девелоперы занимаются тем что они это ядро пишут. Это система которая лежит на сервере, любой бекенд. Они его разрабатывают. У них чаще всего нет никакого фронтенда. Они на ружу посавляют API.</p>
  <p>Фронтенд девелоперы. Делают модули для взаимодействия с пользователями. Это и web девелоперы и wpf (оконные на виндовс) девелоперы и мобильные девелоперы. Весь софт который общается и взаимодействует с клиентом это фронт. Все которые пишут систему это бекендеры.</p>
  <p>Могут быть QAA инженеры которые занимаются тестированием и автоматизированием. Они не обязательно есть во всех компаниях. Они пишут скрипты, настраивают тестовые стенды, пытаются приложение сломать с точки зрения нагрузки. Пишут кучу тестов, которые пытаются проверить чтобы ничего не сломалось. Хороший QAA инженер позволяет сократить риск появления регрессии. Регрессия это когда все работало, но вы поместили картинку и все сломалось.</p>
  <p>Есть еще QA инженеры. Это тестировщики. Они тестируют софт вручную. Не все можно протестировать автоматически. Тем более работа QAA достаточно сложная и сравнима с работой бизнес аналитика плюс программист. Тестирует не только то что сделано, но и все что придумал дизайнер и описал аналитик.</p>
  <p>Современные системы очень большие. DevOps заставляют вашу систему жить. Они смотрят на нагрузки, на каких серверах все это лежит. Востребованная и высокооплачиваемая работа. Хороших девопсов очень мало.</p>

  <p>Это типовые роли для разработки софта. Если есть какой-то продукт. Клиент что-то хочет сделать. То продукт менеджер может быть исключен. В роли продукт менеджера выступает клиент. При небольшом проекте роли объединяют и один специалист могжет делать несколько ролей. Не всегда это хорошо. На сильных синьеров навязывают работы PM и это не всегда счастье. Архитекторы это штучный товар и хорошехо архитектора вырастить достаточно сложно.</p>
</article>
  
<article class="article">
  <h3>Качественный софт</h3>
  <p>Качественный софт должен сделать клиента счастливым. Если клиент получит не то что он хотел, то он не принесет столько денег или уйдет к другой компании разработчику. Поэтому обеспечить качественный продукт это очень важно. Самое первое качество к которому могут быть претензии это работа бизнес аналитика. Если бизнес аналитик не до конца понял что нужно клиенту, не доконца доказал и спустил эту информацию вниз. Уже все равно какой код вы написали, получится система которая не нужна заказчику. Он будет давать претенцзии что он хотел не то. Если клиент вам платит , то вам все равно, просто клиент получит больше расход на систему. В какой-то момент у него может закончится бюджет и он потратит деньги и может ничего не получить. И будет всем подряд говорить что эта компания плохая. Если клиент платит fixed cost это означает что вам нужно переделать уже за свой счет. А переделка за свой счет если есть ошибка в архитектуре, это будет тяжело, сложно, больно. Кому это хорошо? Никому.</p>
  <p>То есть первая ошибка – это бизнес аналитика. Потом это архитектура неправильная. Что-то не предусмотрели. Самый простой способ – где-то накосячил – хлопнул дверью и ушел в другую компанию. Не хороший подход. IT рынок высоких специалистов не такой большой. И можно попасть туда где будут знать как ты плохо сделал и ушел. Свою репутацию надо беречь всегда.</p>
  <p>Если вы просто рядовой программист. За джуном, конечно, приглядывают но особой ответственности он не несет. Normal пытается сделать свою работу, чтобы она была хорошая. Пытается смотреть за своими соседями, замечаете и исправляете их ошибки, ведете активную позицию. Руководство все это замечает. Если есть результат, то у вас будет быстрее проходить карьерный рост. Вы будете получать более интересные продукты. За вас будут драться PM. Это карьера, это деньги, это более интересная работа. Не пренебрегайте качеством, старайтесь сделать все лучше. Смотрите не только на свой кусок кода, но и пытайтесь посмотреть на всю систему в целом. Вы работаете в команде и если 9 человек из 10 сделали плохо, ваш идеальный результат никому не нужен, вы просто потратите время.</p>

  <h3>«Я не знаю точно, чего я хотел, но точно не этого».</h3>
  <p>Ни один заказчик никогда толком не скажет что он хочет. Уже на старте надо пытаться точно выяснить что он хочет. Что-то предлагать ему. Бывают ситуации когда он хотел одно, с ним детально поговорили и он хочет диаметрально другого. Просто он этого не понимал.</p>
  <p>Небольшой пример.</p>
  <p>На старте проекта Заказчик ставит задачу:</p>
  <p>Сделайте мне игру, где курочка будет ходить по двору и клевать зернышки. А я буду этой курочкой управлять чтобы она ходила. На мобильном приложении. Полгода, думаю вам должно хватить.</p>
  <p>В середине проекта Продукт менеджер говорит:</p>
  <p>Да, и доделайте еще, чтобы она махала крыльями и кудахтала.</p>
  <p>В конце проекта приходит Менеджер и говорит:</p>
  <p>Хочу чтобы в 3D</p>
  <p>Из-за того что программисты узнали что заказчик хочет в 3D уже в конце проекта, проект будет выкинут насмарку. Заказчик ничего не возьмет. У компании будет отрицательная репутация. Несколько слов может кардинально поменять сам объем работ. Имейте это ввиду и пытайтесь на старте всегда что-то выяснить. Если вы работаете программистом, пытайтесь это выяснить у вашего руководителя, у вашего лида. Не просто – «сделай мне функцию», а спросите «а какую функцию написать». Немножко продумайте получше.</p>

  <h3>С чем смириться сразу:</h3>
  <p>- Четких требований вам никто никогда не даст
  <br>- Требования будут меняться по ходу работы
  <br>- По инициативе заказчика
  <br>- В связи с техническими причинами
  <br>- В связи с ошибками проектирования и планирования
  <br>- В связи с новыми административными требованиями
  <br>- Вообще не понятно почему
  <br>- Заказчик будет уверен, что маленькие изменения ни на что не повлияют</p>

  <p>Ни заказчик, ни начальник четких требований не даст. Заказчик по причине того, что он толком не знает или хочет очень многого и не может это сформулировать. Для этого нужны бизнес аналитики чтобы понять и доказать заказчику что реально он хочет. Лиды или старшие товарищи просто загружены и четких указаний давать не будут, поэтому придется додумывать. С этим придется смириться.</p>
  <p>Требования всегда будут меняться по ходу работы. Заказчик еще чего-нибудь захотел. Или вы поняли что надо поменять архитектуру. Если вы пишете систему, связанную с данными, может выйти какой-нибудь закон о защите персональных данных. И чтобы не попасть под статью необходимо эту систему быстро переделать. Если пишете систему для бухгалтерии, то там периодически выходят новые формы, новые отчеты и надо чтобы было актуально и быстро иначе ваша система никому не будет нужна. Требования могут поменяться просто так. Вплоть до того что несколько бизнес аналитиков будут задачу по-разному понимать, по-разному описывать и в итоге будете делать что-то другое. И вам надо будет постоянно что-то переделывать. Просто к этому будьте готовы.</p>
  <p>Заказчик всегда уверен, что он просит какую-то мелочь которая ни на что не влияет. У меня заказчик попросил какую-то мелочь и считал что это мелочь. А для команды это вылилось в три месяца работы. Заказчик думал ерунда какая-то. В итоге сильно долго переделывали.</p>
</article>
  
<article class="article">
  <h3>Как минимизировать влияние изменения требований:</h3>
  <p>- Максимально выясняете все на старте проекта, убедитесь, что заказчик вас правильно понял
  <br>- Активно коммуницируйте с заказчиком или потенциальными потребителями
  <br>- Договаривайтесь с заказчиком о правилах игры, если возможно
  <br>- Внимательно изучайте инструменты и технологии перед стартом
  <br>- Стройте правильную архитектуру системы, снижайте связность модулей
  <br>- Пишите качественный код
  <br>- Разрабатывайте автоматизированные тесты
  <br>- Документируйте все
  </p>

  <p>Как можно минимизировать. Я описал страшную ситуацию. На самом деле все не так страшно. Надо просто принять правила игры и с этим работать. Первое - выясняйте. Не просто выясняете что вы поняли что хочет заказчик. Имейте ввиду, когда заказчик вам что-то объяснил, вы что-то поняли, что-то в голове представили – вы решаете не его задачу, вы решаете свою задачу. После того как вы начнете делать, вы будете решать то что поняли вы. Убедитесь что он вас правильно понял. Сделайте ему макеты, нарисуйте, поговорите с ним несколько раз. Если действительно все правильно, вы его поняли, он вас понял. Вероятность того что вы все нормально сделаете будет 80 и выше процентов.</p>
  <p>Например, было задание на курсовую работу. Студент начал делать по-своему. И в итоге сделал все красиво, все много, все отлично. Но от того задания сделано было 50%. Проект в объеме больше на 300% а в задании сделано на 50%. Куча времени не туда и заказчик получил не то что хотел. Это можно избежать.</p>
  <p>Второе. Общайтесь с заказчиком, с потребителями чем больше тем лучше. Не надо думать что вы поняли что надо сделать и вы знаете лучше чем он. Ничего подобного. Вы будете смотреть со своей колокольни. Заказчику, возможно, надо что-то другое.</p>
  <p>С заказчиком надо договориться. Что если он вдруг чего-то меняет, то мы останавливаем работу, договоримся, подумаем что уже есть. Чтобы не встрять в ситуацию, что вы сделали работу, а заказчик потом говорит что он сам не знал что хотел. И соответственно он будет добавлять требований, менять. А в итоге у вас деньги закончатся, а софт не получится.</p>
  <p>Перед тем как что-то обещать заказчику, обязательно оцените чем вы можете это сделать. Не надо говорить «ну я это сделаю на том языке, то – на том». Посмотрите, технологие какие есть, можно ли ими пользоваться в будущем. Тот же пример, Docker или Dentity Server4, которые мы будем использовать в нашей работе. Ситуация в чем, оба были бесплатные. С какого-то время владельцы этих технологий посчитали что рынок они уже захватили и можно сделать их платными. Вот и смотрите заказчик готов будет заплатить за это или нет. Если нет, то вам эти технологии не подойдут. Это в принципе справедливо для уровня синьера и выше. Но все равно, просто знайте. На своем уровне тоже можете все это дело оттранслировать.</p>
  <p>Стройте правильную архитектуру, снижайте связность модулей. Для того чтобы можно было какие-то модули выкинуть, какие-то переписать. По возможности, чтобы это не ломало систему.</p>
  <p>Пишите качественный код, чтобы было понятно.</p>
  <p>Если у вас есть сложная система и есть возможность и время, потому что некоторые заказчики на тесты время не дают, разрабатывайте автоматизированные тесты. У вас будет уверенность что ваша система не сломается.</p>
  <p>И волшебная фраза – документируйте все. Чтобы не было мучительно больно вспоминать откуда такое требование. По возможности все сохраняйте, пишите, говорите когда и кто и т.д. В случае чего, можете вспомнить почему так сделалось. Либо можете заказчику показать почему так сделано – «ты же сам три недели назад сказал делать так». Если не будет документов, не будет доказательств, то скорее всего, вам скажут «я этого не говорил». И будете думать почему.</p>

  <p>Если система плохо спроектирована то она будет выглядеть как карточный домик, построенный на костылях.</p>

  <h3>Как думаете что произойдет если:</h3>
  <p>- тронуть какой-нибудь костыль
  <br>- отвяжется лодочка снизу
  <br>- вылезет еще один баг где-то внутри
  <br>- кто-то решит все поправить
  <br>- заказчик будет весить немного больше, чем QA инженер.
  </p>

  <p>Если у вас плохая архитектура, вы постоянно чего-то доделываете. Можете быть уверены, что какие-то вещи наверняка сломаются. Хороший код написан достаточно просто, структурно, повторяемо, в каком-то виде даже скучно. Но самое главное, у него нет магических связей, которые позволяют этот код сломать. Старайтесь такой делать. Если вы в вашем коде не пытаетесь решить проблему, а пытаетесь ее замазать, то система рано или поздно, вас подведет. И хорошо если подведет заранее. А если на презентации заказчику?</p>

  <h3>Диалог двух программистов вечером:</h3>
  <p>- Давай зальем наши правки
  <br>- Давай. Главное нам ничего не сломать
  <br>- Да, вроде бы, мы ничего, кроме своего модуля не трогали… Заливай…
  <br>- Заливаю… Готово. По домам?
  <br>- Ага
  <br>На следующий день:
  <br>- У меня ничего не работает!
  <br>- Кто удалил нужный мне файл?
  <br>- А! У заказчика база рухнула!
  </p>

  <p>Есть правило ничего не выкладывать в релиз перед выходными. Если вы не тестируете и ничего не проверяете. То скорее всего получите такую картиночку. Это не сказки. Я сам такие ситуации ловил. Рекомендую про это помнить и постараться не делать так. Получается что любая система как карточный домик, трогать ее нигде нельзя.</p>

  <h3>Что же делать, чтобы ничего не сломалось? Да хотя бы, чтобы не сломалось у заказчика</h3>
  <p>- Определяете правила корректности работы своих модулей
  <br>- Пишите тесты заранее, включайте их в процесс сборки
  <br>- Документируйте изменения и их причины
  <br>- Старайтесь смотреть на систему в целом, пытайтесь понять, что может «зацепить» ваше изменение
  <br>- Обязательно тестируйте перед публикацией в production и передачей заказчику
  <br>- Делайте резервные копии чаще
  </p>

  <p>Во-первых, определите для ваших модулей, когда они работают хорошо, а когда плохо. Чтобы было понятно – этот модуль работает хорошо если он делает то-то и то-то.</p>
  <p>Если есть возможность писать тесты – пишите.</p>
  <p>Про документирование я уже сказал.</p>
  <p>Важная вещь. Если будете смотреть на систему, то пытайтесь смотреть не только с точки зрения вашего модуля, а немножко выше. Как ваш модуль на что-то влияет. Когда один архитектор на это смотрит, у него один взгляд, он может перегружен и что-то не заметить. Если вся команда пытается посмотреть как модули между собой связаны, то у вас будет хорошая интеграция между модулями и все будет нормально.</p>
  <p>Важно. Перед тем как вы передаете, особенно в продакшн или заказчику – тестируйте. Тестируйте не только саму систему. Тестируйте процесс обновления. Если есть возможность скачайте базу с продакшн и попробуйте на нее накатить. Убедитесь что у вас прекрасно работает софт. Накатывайте заказчику. В итоге у заказчика ломается база данных или ваша система не работает или работает плохо.</p>
  <p>Перед тем как вы что-то сделаете – сделайте копию. Убедитесь что у вас есть возможность откатить.</p>
</article>
  
<article class="article">
  <h3>Какое бывает тестирование</h3>
  <p>- ручное
  <br>- автоматизированное
  <br>- интеграционное
  </p>

  <p>Тесты важны для того чтобы заказчику не сделать плохо. Семь раз отмерь, один отрежь. Пословица как раз про это. Какое бывает тестирование? Ручное мы просто тестируем руками и смотрим что к чему. Если команда QA достаточно сильное, то ручное тестирование задокументировано, понятно куда заходить, какие-то цепочки путей прописаны. Я видел как наши тестировщики DSR делали таблички. Проверить name. Введите туда русскую букву, латинскую букву, юникод. И все вещи которые надо прогнать, ручной тестировщик прогоняет и убеждается что все есть. </p>
  <p>Если какие-то вещи можно автоматизировать, в частности мы будем в рамках курса, последняя практика, которая будет уже под новый год, будем писать тесты чтобы тестировать наш API. По возможности если можно что-то автоматизировать – сделайте это. Это будет проще, это будет лучше.</p>
  <p>Интеграционное это когда мы тестируем систему целиком. Не просто какой-нибудь unit test. Мы собираем наши данные, наши сервисы и смотрим как они между собой живут. Это достаточно большая работа. Я об этом много рассказывать не буду. В DSR есть QA school и QAA school. Добро пожаловать. Кто хочет поучиться. Точно так же бесплатно. Обращайтесь. Хороший тестировщик должен быть хороший программист и желательно иметь навык тестирования. В этом случае он будет больше видеть и лучше проектировать систему.</p>

  <h3>Тут все просто – сейчас сяду и напишу.</h3>
  <p>Как обычно происходит в жизни:
  <br>- Масштабные планы, революционные идеи, плащ героя на стене
  <br>- Что-то пошло не так… Да ладно, один костыль ничего не решает
  <br>- Этого мы не предусмотрели… Давайте заплатку поставим пока
  <br>- Этот модуль не работает совсем, давайте его перепишем
  <br>- Хм, что значит нет данных? Ок, надергаем из Интернета
  <br>- Угомоните уже нашего QA!
  <br>- Какие планы? Пусть хоть вообще заработает
  <br>- Вот это монстр получился
  <br>- Перепишем все заново?
  </p>

  <p>Программист говорит «сейчас я быстренько все напишу, тут же все понятно и опыт есть, я же сеньер».  В жизни все происходит немножко не так. У нас есть какие-то планы. Мы придумали систему. Будем сейчас ее писать. Даже деньги поделили которые акционеры дадут за нашу систему. </p>
  <p>Начали что-то делать. Где-то что-то не учли. Влепили один костыль. Ну все нормально. Ничего страшного.</p>
  <p>Что-то еще не предусмотрели. И так далее.</p>
  <p>Модуль начал глючить. Мы его переписали.</p>
  <p>Стянули что-то с интернета. QA начал тестировать, начал ошибки кидать со скоростью пулемета. В итоге вместо того чтобы уже новый модуль делать у которого подходит срок, вы начинаете ошибки исправлять. Хотите этого QA пристрелить. Не надо этого делать. QA это важные люди. Они очень важны для команды.</p>
  <p>Планы летят в мусорку потому что уже ничего не работает. Какое развитие, нам бы уже хоть что-то сделать. В итоге что-то делаем и понимаем, что в начале хотели сделать идеальный продукт, а получился монстр. Единственное желание после этого это переписать все заново.</p>

  <p>На самом деле, это не такая юмористическая вещь. Потому что многие системы несколько раз переписываются. Даже крупные системы. И от этого никто не защищен. Лучше на старте больше думать чтобы этого хоть немножко избежать. Я думаю, вы пример в интернете найдете такой системы, которую писали, бросили и переписали заново. Это хотя бы наш рутуб. Кучу времени его писали, он достаточно медленный был. Сейчас другая команда его переписывает. Я даже уверен что они старый код поменяли. Просто мое мнение.</p>

  <p>Почему так происходит? </p>
  <h3>Проблема 100-го кирпича</h3>
  <p>На самом деле, в софте есть одна большая проблема. Называется проблема сотого кирпича. Строитель первый кирпич кладет долго. Потом второй. Когда доходит до последнего сотого кирпича, то у него уже опыт и система достраивается. И мастерок правильно держит. У него все автоматизируется. И уже сотый кирпич он кладет элементарно. В софте ничего так не получается. Самая легкая вещь, которую в разработке софта можно делать это первая. Каждое следующее добавление увеличивает сложность. Чем больше вы пишете тем система становится сложнее и какое-то изменение сделать сложнее. Проблема 100-го кирпича это причина почему софт получается не такой как мы хотели. Это был рассказ про сложность.</p>

  <h3>Так в чем сложность?</h3>
  <p>Первая сложность – это непосредственно сама сложность
  <br>- Алгоритмическая
  <br>- Трудоемкость разработки
  <br>- Информационная сложность
  <br>- Сложность тестирования
  <br>Вторая сложность – это не полная информация о задаче
  <br>Третья сложность – изменяемые или уточняемые требования
  <br>Четвертая сложность – окружение, инфраструктура
  <br>Пятая сложность – мотивация, выгорание, человеческий фактор
  </p>

  <p>Первая сложность в разработке системы - это сама сложность. Писать хороший код – само по себе сложно. У нас есть алгоритмические трудности, есть трудоемкость разработки. У нас есть информационна сложность, надо добиваться где-то данные доставать. Есть сложность тестирования. Простенькую программу протестировать можно, а попробуйте протестируйте микросервис. С каждым добавлением растет количество функций внутри. При добавлении новой фичи надо чтобы и предыдущие не сломались. Возможно старые вещи поменять под новую фичу. С каждым новым добавлением сложность растет.</p>
  <p>Вторая сложность - это не полная информация о задаче. Как красная линия идет. Вполне возможно, что вы решаете не ту задачу, которую надо решать.</p>
  <p>Третья – это требования. Это опять следствие того что у вас неполная задача.</p>
  <p>Четвертая – это окружение и инфраструктура. Писали-писали и вдруг поняли, что у вас сервер не справляется. Сервер – вещь дорогая. Что надо делать?</p>
  <p>И пятая, одна из основных, она вытекает из всех предыдущих. Это человеческий фактор: мотивация, выгорание, ошибки, отсутствие команды, переманивание в другие компании где больше денег платят. И чтобы сделать большую сложную систему этим всем надо каким-то образом управлять.</p>
</article>
  
<article class="article">
  <h3>Что же делать?</h3>
  <p>- Со ложностью системы
  <br>- Не полной информацией о задаче
  <br>- Изменяемыми или уточняемыми требованиями
  <br>- Окружением, инфраструктурой
  <br>- Мотивацией, выгоранием, человеческим фактором
  <br>- Прочими сложностями
  </p>

  <p>Что можно сделать? Это скорее лекция к PM, но все равно будет интересно. Полезно послушать. Сложность системы надо снижать. По возможности убирать непонятные вещи, декомпозировать задачи. Разбивать сложные задачи на более мелкие, чтобы они были попроще. По неполной задаче пообщаться с заказчиком, попытаться что-то выявить. Требования - документировать. По мотивации – работать с людьми. Можно что-то делать и надо что-то делать. Если хотя бы один пункт пустите на самотек, то это может привести к катастрофическим последствиям.</p>
  <p>Ну пока вы рядовой программист это не сильно критично. Но если вы будете PM и не заметите что у вас программист сидит на headhunter, у вас в какой-то критический момент может просто напросто исчезнуть программист на проекте. Если это ключевой программист, то будет вообще больно. Если он не ключевой программист – вы теряете время, пока он ищет работу он не работает на вашем проекте, а это сроки, деньги. И у вас риски срыва проекта.</p>

  <h3>Получается, что разработка – это лотерея какая-то?</h3>
  <p>На самом деле нет. Все почему-то сравнивают разработку софта со строительством. Это не правильно. Разработка любой информационной системы, особенно на заказ никакого отношения к строительству не имеет. Поэтому и применять принцип строительства здесь нельзя. </p>
  <p>Разработка софта это скорее выращивание дерева. Если у вас две группы людей будут делать одну и туже систему (выращивать дерево), вы никогда не получите двух одинаковых деревьев. Они будут разные. Они будут с разными ответвлениями. Два одинаковых дома построить легко. Два одинаковых дерева вырастить невозможно математически. Считайте что софт это выращивание вашего сада. С этой стороны и смотрите. Как надо выращивать хороший сад? За ним надо ухаживать, его надо обрезать, его надо планировать, смотреть какие рядом деревья можно сажать, а какие – нет. Не сажать под большими деревьями кустарник, которому света не будет. Считайте что ваш софт – это живая система.</p>

  <h3>Очень-очень упрощенный процесс</h3>
  <p>Типовые стадии разработки системы
  <br>- Проработка бизнес требований
  <br>- Дизайн системы
  <br>- Составление плана и оценка бюджета
  <br>- Разработка (итерационно)
  <br>- Тестирование (итерационно)
  <br>- Презентация заказчику (итерационно)
  <br>- Доставка
  <br>- Поддержка
  </p>

  <p>Какие у нас вообще типовые стадии процесса могут быть при разработке системы. Проработка бизнес требований. На старте мы должны с заказчиком поговорить и выяснить что надо сделать. Потом спроектировать саму систему и согласовать. Дизайн системы это не только дизайн модулей. Скорее дизайн системы это где у нас какие блоки, какие фичи будут. После того как этот дизайн системы, видение системы, концепт системы, примерная архитектура были согласованы, всеми приняты и бизнесом, в том числе, архитекторами. Составляется план, высчитывается оценка и после этого идет разработка, тестирование, презентация и доставка. Доставка – это или дистрибутив отдать или выложить куда-нибудь на облако. Разработка, тестирование и презентация обычно идут итерационно, частями. Очень мало систем, особенно в софте, которые могут сделать за один раз. Это или какая-то система под ключ. Например, небольшая мобильная игра. Или действительно маленькая система. Если система для работы с людьми, то стоит организовать поддержку клиентов.</p>
</article>
  
<article class="article">
  <h3>Как «выращивают» программы</h3>
  <p>- Подход «Водопад» (Waterfall model)
  <br>- Итерационный подход (iterative)
  <br>- Гибкий подход (agile – scrum, agile - kanban)
  </p>

  <p>Как выращивать программы? Подходов больше, я написал самые основные. Дря разных систем и задач применяются разные подходы. Водопад это проект в котором каждый следующий этап выполняется после того как предыдущий закончен. Применяется для систем с очень высокими требованиями к качеству, надежности. Например, система управления самолетом, навигационная система. Никакого agile там быть в принципе не может. Строго и досконально прописываются все требования, много раз дезайнится, досконально тестируется. Уже на этапе подготовки к дезайну пишутся тесты, критерии по которым данная система будет приниматься. Что надо ввести на вход, что в итоге должно получиться. Пишутся здоровенные, толстые талмуды с требованиями. И каждое тестирование проверяет насколько качестенно система выполняет требования ТЗ. Это промышленность, космос, военные. И внести изменения в такие проекты достаточно сложно. Сам заказчик на изменения уже не пойдет. Если вы при водопаде предложите windows заменит на linux - никто вам этого не позволит. Надо было думать заранее. Waterflow - это в одну сторону.</p>
  <p>Итерационный подход (iterative). Договорились о чем-то, оценили, сделали, показали. И такими кусочками идем. Если что-то сделали и не понравилось, до делаем ответвление – поменяли и вернулись. Есть свои технологии, фазы дизайна, разработки, тестирования. Основное это процесс идет кусочками. По такому принципу все и работают. </p>
  <p>Гибкий подход (agile, scrum, kanban). Здесь уже более четко описаны технологии итераций. Должен быть product owner. Он делает фичи, собирает бэклок. На основании бэклока команда и скрам мастер планируют спринт (это период 1-4 недель, за который надо сделать релиз). Команда быстро с этим делом работает. Каждый день проводятся дейли митинги. В конце спринта из всех задач делается релиз. Демо заказчику, если все хорошо, переходят на следующий этап. Получается что agile не имеет финишной цели. Гибкий подход применяем кодгда заказчик не знает что хочет. Он кидает разные тикеты. И на основании этих тикетов создается система. Но чтобы она делалась не просто абы как, сделали такой ритмичный подход. Есть Agile scram он работает по периодам. Есть Agile kanban</p>
  <p>Backlog – stories – to do – in progress – to verify - done
  <br>Гибкий подход (agile - kanban). У нас есть backlog. Мы просто складываем все в кучу. И никаких временных рабок нет. Каждый разработчик берет понравившуюся ему задачу, кладет в in progress. В to do определили, что задачу надо сделать важной и у нас здесь есть какое-то количество задач, например, сделать авторизацию, нарисовать логотип. С команды берут задачи с которыми могут справится, начинают ее делать, проверяется и кладется в done. Как только задачи из to do перерастают в done, делается релиз. Почему называется канбан? Это пошло из японии. Просто была доска и на ней были наклейки. И каждый брал и переклеивал. Если scrum это управляемая система со спринтами, то в kanban надо просто что-то делать. И у scrum и у kanban мы не знаем что в итоге у нас получится, мы работаем над тасками. Такие схемы работают за почасовую оплату. Сделал – за часы тебе заплатили. Заказчику чем хорошо? Не хочет платить – просто остановился и получил ту ситуацию, которая максимально приближена на тот момент. Он ее уже видел и он на ней работает. Если ему все еще дальше нравится, он просто платит и дает задачи. Мы ее делаем. И для команды разработки хорошо и заказчику хорошо. Это по поводу архитектуры.</p>

  <h3>Я  художник, я так вижу!</h3>

  <p>Очень важно в разработке софта – правильно понять друг друга. Заказчик хочет одно, выразил это своими словами. Бизнес аналитик внес свою какую-то долю по непонятности. Программист понял по-своему, начал что-то делать. Дизайнер где-то увидел красивый интерфейс и хочет его применить. В итоге получается большое количество всяких нестыковок. На старте хорошо бы договориться между всеми командами об одном и том же, чтобы вы друг друга понимали. То есть надо согласовать общий словарь. Если вы говорите с заказчиком – говорите в терминах, которые понимает заказчик. Если вы работаете с бухгалтерией, то говорите в терминах счетов, проводок. Если вы работаете с заказами на товары, то это заказы, складские остатки. И уж точно не стоит заказчику говорить про entity, behavior, классы, слои – ему это не надо. Внутри команды заказы могут быть разные. Например заказ на склад и заказ на магазин. Это разные заказы и если вы с этим не разберетесь то будет дискомуникейшн.</p>

  <h3>Иван Иванович, можно я не буду читать его код? Ну пожалуйста!</h3>
  <p>Старайтесь писать код понятно
  <br>- Используйте принциаы CleanCode
  <br>- Будьте последовательными в написании кода
  <br>Не забывайте про хорошие комментарии
  <br>Старайтесь делать простую архитектуру. Там, где это возможно
  <br>Следуйте стандартам и договоренностям внутри команды
  <br>Не злоупотребляйте новыми конструкциями языка без необходимости
  <br>Если есть возможность, то делайте рефакторинг
  <br>Используйте средства для форматирования кода (LINT)
  </p>

  <p>Если ты пишешь плохой код, то его никто читать не хочет. А если никто не хочет его читать, очень трудно найти людей которые будут его поддерживать. А если это ваш код то вы будете с ним постоянно жить. Значит вас на новый проект могут не перевести потому что этим никто заниматься не хочет. Старайтесь код писать хорошо. Используйте принципы CleanCode. Будьте последовательны в написании кода. Не надо писать один модуль в одном стиле а другой модуль в другом стиле. Пишите хорошие комментарии. Не надо все комментировать. Хороший комментарий помогает понять что надо сделать. Хороший код сам себя комментирует. Если вы пишите понятный код – ему комментарии не нужны.</p>
  <p>Архитектуру не надо усложнять. Если есть возможность сделать по-простому, то сделайте по-простому. Не стоит злоупотреблять синтаксическим сахаром. В том же нете понапридумывали новые языки. Новый switch например, никто его не любит но он там есть. Обычно народ путается когда его видит. Если есть такой риск, то лучше им вообще не пользоваться. Пользуйтесь проверенными старыми стандартными кусками кода. Договоритесь внутри команды как вы будете писать код. Если к вам много пришло, чтобы все писали одинаково. На практике у меня была ситуация, когда один программист очень сильно любилделать табами отступы. Другой очень сильно любил двумя пробелами. Там драки были в курилке до реальной драки. Сейчас уже проще, есть линтеры которые могут все это дело привести. Но программисты всегда найдут где выделиться и вот этого лучше в команде не делать. Договориться и пользоваться одинково. Я бы вам посоветовал вообще код не переписывать. То что студия поставляет. Один раз привыкнуть чтобы потом с этим не мучаться.</p>
</article>

<article class="article">
  <h3>Принцип хорошего кода DRY</h3>
  <p>don’t repeat youself 
  <br>не повторяй себя.
  <br>Каждая часть знания должна иметь единственное, непротиворечивое и авторитетное представление в рамках системы
  <br>1. Не храните одни данные в разных местах (особенно в разном формате)
  <br>2. Не дублируйте данные или код (наш любимый копипаст)
  <br>3. Делайте декомпозицию задач, старайтесь повторно использовать свой код
  <br>4. Делайте модульную архитектуру
  <br>5. Применятся не везде
  </p>

  <p>Есть несколько принципов, которые позволяют хороший код собрать. Не надо делать копипасты. Не надо делать копипасты кода. Не надо делать копипасты базы данных. Надо писать так чтобы все было в одном месте. И если потом потребуется что-то поменять, то вы это поменяете только в одном месте, а не в нескольких местах.</p>
  <p>Например, база данных. Вы сделали таблицу юзеров. Потом вы делаете другой класс и вместо того чтобы сослаться на таблицу юзеров которая существует, вы делаете свою другую таблицу юзеров для нового модуля. Потом пишете скрипт, который с той таблицы юзеров что-то перемещает сюда. Во-первых, увеличится сложность. Во-вторых, сделаете кучу проблем. А что делать если одна таблица будет пустая?</p>
  <p>Если есть одинаковые куски кода то лучше вынести все в отдельный метод. Еще пример, формат. В одном месте вы храните в базе данных, в другом в XML. Не очень хорошо. Декомпозиция задач – если у вас есть код, который вы используете в двух местах, вынесете его в другую функцию. </p>

  <p>Не везде применяется этот подход. Это принципы, а не стандарты, не законы. Их надо использовать только там где вы четко знаете что они нужны. По возможности их стоит писать. Но если эффективнее без них, то лучше их не использовать. Допустим у вас есть интернет игра. Есть сервер, на котором лежит информация о том какой у вас набор танков, сколько у вас денег и т.д. Раз они лежат на сервере то мы можем с сервера их всегда брать. Можно делать запрос и он все вернет. Единственное, что никакие сервера такое количество запросов не выдержат. В этом случае часть информации копируется на клиент и работает там. Это нарушение принципа DRY потому что информация и там и там одинаковая. Но мы получили преимущество по производительности, снизили нагрузку на сервер. Но на сервере тоже самое делать не очень хорошо.</p>
</article>

<article class="article">
  <h3>Принцип хорошего кода KISS</h3>
  <p>Keep it simple, stupid (keep it short and simple)
  <br>Сделай это проще
  <br>1. Не надо делать дополнительных функций, не перегружайте интерфейс не нужными методами (или кнопками)
  <br>2. Не пытайтесь реализовать бизнес логику, которая учитывает абсолютно все возможные варианты
  <br>3. Не надо увеличивать количество уровней абстракции
  <br>4. Не закладывайте функции «про запас»
  <br>5. Не используйте ненужные или модные фреймворки
  <br>6. Не пытайтесь достигнуть абсолютной точности или предельной детализации
  </p>

  <p>Принцип KISS заключается в том, что не надо делать лишнее. Если вас чего-то не просили – старайтесь этого не делать. Не надо делать бизнес логику слишком сложную. Например, в форме ввода данных не надо использовать все варианты данных, а только те, которые наиболее часто используются. При неправильно вводе можно написать «ваши данные неправильные», а можно написать «количество букв больше 100 и вы ввели запрещенные символы $ и т.д.». Напишите как короче, чтобы не усложнять бизнес логику. </p>
  <p>Если система не требует увеличения абстракции, то не надо это делать. Был случай, на одном из собеседований надо было hello world сделать. Там такое количество абстракций было сделано, что в итоге не успели это дописать. Было красиво, но код не работал. Не закладывайте функции «про запас». Если сейчас вам эта функция не нужна, то нет смысла ее писать. Во-первых, если вы ее напишите, ее потом надо будет тестировать, поддерживать. А она, возможно, никогда не пригодится. Плюс на нее надо кучу времени потратить. А функция реально может быть не нужна.</p>
  <p>На javascript, например, очень популярно использовать модные фреймворки. Это вредно, потому что каждый фрейвфорк цепляет за собой какое-то количество javascript кода и оно тянется на компьютер пользователя. Больше трафик, больше тормозов, больше памяти требуется. По возможности не надо использовать ненужное. Только если он действительно нужен и принесет пользу.</p>
  <p>Не пытайтесь достигнуть абсолютной точности или предельной детализации. Например, надо изготовить деталь ценой Х, и диаметром 10мм. Когда вы будете ее обрабатывать токарным станком, то диаметр может быть 10.01. Но если его сделать точно 10, то он будет уже в 100 раз дороже. Возможно, такое качество и не надо, зато будет гораздо дешевле. Не надо вылизывать весь код. Сделайте короче и попроще. Чтобы было проще понимать, проще тестировать. Если надо что-то уточнить, то потом уточните.</p>
</article>
  
<article class="article">
  <h3>Принцип хорошего кода YAGNY</h3>
  <p>You aren’t gonna need it
  <br>Не надо делать того, что не нужно
  <br>1. Заказчик не должен платить за то, что он не заказывал
  <br>2. Заказчик не должен разбираться в том, чего ему не требуется
  <br>3. Разработчики не должны тратить свое время на то, что не требуется
  <br>4. Тестировщики не должны тестировать то, что не требуется заказчику
  <br>5. Надо будет обновлять документацию, конфигурировать CI/CD, править тесты
  <br>6. Реализация не нужных функций может повлиять на реализацию нужных функций
  </p>

  <p>Еще есть принцип YAGNY. Не надо делать того, что не нужно. Очено похоже на KISS. Смысл в том, что если это делать не надо, то не делайте это. Если заказчик не заплатил за супер систему логирования, а вы без нее жить не можете – не надо делать систему логирования. Если он хочет простую систему, например, почта, а вы для этого микросервис поднимаете – не надо микросервис делать. Заказчик не должен в этом разбираться. Даже ему это доказывать не надо. Используйте эти модули только если это реально надо. Разработчики тоже не должны тратить время на то, что не требуется. Тестировщики не должны тестировать если что-то не нужно. Пока вы будете делать не нужные функции, вы не напишите нужных функций. Возможно, то что вы хотите сделать – делать не надо.</p>
</article>
  
<article class="article">
  <h3>Как съесть слона</h3>
  <p>Любая система сложная. И если ее делать бездумно, то она бездумная и получится. Если представить систему в виде огромного объема наботы. Ее надо декомпозировать. Разбейте задачу на несколько частей, на модули. Если модуль делается элементарно – делайте. Если нет – бейте его еще дальше пока не разобъете до элементарных. После этого посмотрите на все элементарные блоки и посмотрите, что из этого взаимозаменяемо, используется в нескольких местах. Например, формы создания диалогов. Можно вынести их в отдельный сервис. Общение с API сервером тоже вынесите в отдельный сервис. Вот так у вас получится правильная, хорошая архитектура. Смысл фразы «съесть слона» в том, что кажется что большую систему невозможно сделать, но когда ее декомпозируешь до мелочей, то она оказывается достаточно тривиальная. Можно поделить такие задачи между программистами и потом все собрать в единую систему.</p>
</article>
  
<article class="article">
  <h3>Как управлять муравейником</h3>
  <h3>Инструмены</h3>
  <p>- Wiki (Wiki, TFS, GitLab)
  <br>- Ticket systems (TFS, Jira, GitLab)
  <br>- Bug Trackers (Mantis, Jira, TFS, GitLab)
  <br>- Source control system (SVN, GIT)
  <br>- UML, диаграммы Ганта, Word, Excel, Project
  </p>
  <h3>Методологии</h3>
  <p>- SOLID
  <br>- GoF patterns
  <br>- Стандарты разработки
  </p>

  <p>Если у вас сложная большая задача, то у вас есть большая команда «муравейник». Как им управлять? Идеальная команда – когда все отличные специалисты. Можно кидать задачи и они все делают. Но на практике реальная команда выглядит по-другому. У каждого программиста есть свои тараканы в голове, свои мнения, свои амбиции. Все вроде хорошие и веселые.</p>
  <p>Что нужно чтобы помагать команде. Идеальная команда самоорганизуется сама по себе. Реальной команде надо помочь. И для того чтобы помочь, в компании используются разные инструменты. Во времена, когда я учился, про это информации не было. А сейчас это наверное в институте проходят. Wiki это база знаний, где можно все записывать и отслеживать.</p>
  <p>Ticket systems. Тикеты это те же самые задачи которые наклеивались на канбан и в беклог кидались. Куча систем. Team foundation system, jira, gitlab. У github есть своя система работы. Автоматизированные системы управления тикетами. Платные и бесплатные.</p> 
  <p>Баг трекеры. Jira подходит. Есть Mantis. Bug trackers это системы которые учитывают работу над ошибками. Тестировщик или клиент кидает что у него такая-то ошибка. Ее надо анализировать сколько дать время разработчику, тестировщику. И тот кто эту ошибку кинул может смотреть на какой стадии находится работа над ней. Обязательно сейчас используются системы контроля версий. Никуда без них. Самая популярная из них это GIT. Но кое-где еще используется SVN. Для описания можно применять UML, диаграммы Ганта. Если кто-то хочет этим позаниматься рекомендую посмотреть сервис Plant UML. Это новый подход. Смысл в том, что вы пишете диаграмки UML-ки в виде текстов. Можно написать в тексте и он нарисует по ней диаграмму. На базе Plant UML некоторые компании делают даже отчетность. У вас есть какое-то дерево сложное и надо распечатать это дерево. Это долго, нудно. Можно на основании диаграмм получить UML и получить картинку.</p>
  <p>Можно применять эти инструменты. В команде надо договариваться. Нужно обучать команду чтобы она использовала паттерны, чтобы писать примерно одинаково. Особенно в больших командах. И использовать стандарты внешние и внутренние. Использовать инструменты и договоренности.</p>

  <h3>У меня все ходы записаны</h3>
  <p>Кто стер пыль с моего стола?
  <br>Там был записан важный телефон!
  </p>
</article>
  
<article class="article">
  <h3>Системы контроля версий</h3>
  <p>- git, svn, bazaar, mercurian
  <br>Назначение
  <br>- Хранение полной истории изменений
  <br>- Описание причин всех производимых изменений
  <br>- Откат изменений, если что-то пошло не так
  <br>- Поиск причины и ответственного за появления ошибок в программе
  <br>- Совместная работа группы над одним проектом
  <br>- Возможность изменять код, не мешая работе других пользователей
  <br>- Возможность экспериментировать без риска
  </p>

  <p>Система контроля версий нужна чтобы в любой момент времени можно было поднять слепок кода который был на момент вашего комита. Основная и самая популярная система – это git. Без нее уже не могут работать. Основная цель – это документирование всего процесса разработки, поднятие кода, откат изменений если что-то не пошло, можно посмотреть код и совместная работа. Гит позволяет сделать заливку изменений исходного кода контролируемо. И перед тем как залить, можно сделать код ревью. Опытный человек или команда могут заранее, пока еще код не испорчен, могут все проверить и попросить разработчика исправить ошибки. Этот процесс называется код ревью и он очень важен. Гит сейчас must have.</p>

  <h3>VCS – как это работает?</h3>
  <p>Как работает Version Contrl System. Репозиторий это папка на сервере, в которой мы храним код. У нас есть главная ветка, мы можем от нее сделать branch ( копию этой папки). Что то поделать в новой ветке. Причем главная ветка останется без изменений. От нее можем сделать еще одну ветку и второй человек будет работать на второй ветке. Когда все сделано, мы тестируем и потом сливаем эти ветки в главную.</p>
  <p>Как работает git? У нас есть удаленный сервер. Можно хранить и локально, но очень не рекомендую. На удаленном сервере хранится удаленная папка. Мы себе ее клонируем локально. С ней что-то делаем. Комитим ее в рабочую копию. И удаленный репозиторий отличается от локальноко. Каждый коммит имеет свой номер, видно что помнялось, можно посмотреть разницу. Потом делаем push на сервер и наши папки становятся идентичными. Тут нужна практика. С гитом надо научиться работать.</p>
</article>
  
<article class="article">
  <h3>Я бы сделал, но у меня принципы</h3>
  <p>S Single responsibility principle
  <br>O Open/closed principle
  <br>L Liskov substitution principle
  <br>I Interface segregation principle
  <br>D Dependency inversion principle
  </p>

  <p>SOLID это набор пяти принципов. Которые очень сильно любят на собеседованиях. Их нужно понять и выучить. Это определенные наработки, которые позволяют сделать красивый, правильный код.</p>
  <p>Принцип единой ответственности. Каждый класс должен отвечать только за одну операцию. В одном методе, классе нужно делать только что-то одно. Если класс делает несколько вещей, то пока вы делаете одну вещь, то можете сломать другую. Он постоянно растет и поддерживать его сложно. Надо сделать несколько классов. Отдельный класс повар, класс садовник, класс водитель и использовать их по мере необходимости.</p>
  <p>Принцип открытости/закрытости. Классы должны быть открыты для расширения, но закрыты для модификации. Это нужно чтобы не сломать старое. Нужно писать такие классы которые можно расширять, развивать, но нельзя изменять, модифицировать. Если вы пишете класс и со временем класс меняет функциональность это означает что у вас будет здоровый мешок проблем.</p>
  <p>Принцип подстановки Барбары Лисков. Если есть класс и мы от него делаем класс наследник. То наследник должен делать то же что и родитель плюс что-то свое. Наследующий класс должен дополнять, а не замещать поведение базового класса. Например, мы пишем класс для работы с новым оборудованием, который наследуется от класса для работы со старым оборудованием. Теперь наш новый класс должен ументь работать и со старым оборудованием и с новым. Если в новом классе открючим возможность работы со старым оборудованием, то это наршит принцип подстановки Барбары Лисков и новое приложение будет уже не такое полезное как старое. Нужно грамотно проектировать новые классы чтобы не сломать старые существующие системы. Наследник не должен терять функционал предка. Он должен его расширить. Если кто-то попросит старый модуль, то наследник его выполнит.</p>
  <p>Принцип разделения интерфейсов. Не следует ставить клиент в зависимость от методов, которые он не использует. Не делайте один интерфейс, который делает все. Разбейте его на несколько где каждый выполняет только свою функцию. Когда мы получим класс с такими интерфейсами, то будет понятно что этот класс делает. У него не будет лишних методов, которые были все реализованы в одном интерфейсе, но не используются классом. Это влияет и на чистоту кода. Это будет гораздо проще тестировать. Если нам нужен наследник класса, то он должен полностью реализовать всю функциональность класса и добавить какую-то свою. Наследник сможет работать и со старыми модулями и с новыми.</p>
  <p>Принцип инверсии зависимостей. Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций. Класс не должен зависить от реализации. Класс должен зависить от абстракций. Например, есть класс который может резать пиццу. Можно в классе написать что он режет пиццу круглым ножом. Этим мы повысили связанность кода. Вместо реализации круглого ножа в классе, нужно просто сделать так чтобы подключившись через интерфейс к данному классу можно было отрезать любым инструментом. На основании этой инверсии зависимостей мы будем потом смотреть как в .NET работает IDE. Не надо зависеть от конкретных реализаций. Если есть функция не специфичная данному классу, оберните ее в интерфейс и передайте ее снаружи. Желательно использовать принципы SOLID если вы пишите большую серьезную программу. На основании инверсии зависимостей мы будем потом смотреть как в нет работает IDE. Не надо зависеть от конкретных реализаций если у вас есть функция которая неспецифична данному классу, оберните ее интерфейосом и передайте снаружи.</p>
  <p>Некоторые принципы прямо просятся. Они стали подробными, популярными, ими все пользуются. Возможно и не осознавая этого. Если вы будете делать их это отлично. Если у вас одноразовая программа и никому это не надо, то вспомните принцип что не надо усложнять код.</p>
</article>
  
<article class="article">
  <h3>Я все сделал! Действительно?</h3>
  <p>- Не бывает программ без багов. Бывают недостаточно протестированные
  <br>- Если что-нибдь может пойти не так, оно пойдет не так (закон Мерфи)
  <br>- Программисты просто не умеют тестировать качественно
  <br>- Все работало хорошо у вас на компьютере? А на сервер оно вообще установится?
  <br>- На 10 записях все летало! А на 100? А на 1000? Остановится?
  <br>- Не работает функционал, который сдали полгода назад?
  <br>- Что-то на лице заказчика нет радости? Может неудобно или непонятно?
  <br>- Как это мы сделали систему всего на 70%? По спецификачии все ок!
  </p>

  <p>Мы подошли к финишу, сделали софт, все работает, все прогнали. Готовы отдать клиенту. Уверены что готовы отдать? Давайте посмотрим. Программа без багов не бывает, бывает недостаточно протестированная. Для того чтобы была программа без багов, программист должен быть очень продвинутым тестировщиком. На практике программисты и тестировщики это разные люди. Если программист изучил навыки тестирования, понял как это делать – он свой уровень и ценность своего софта поднимает на порядок. Рекомендую.</p>
  <p>Пример на своем опыте. В начале карьеры я пришел на работу, прекрасно писал системы. Тестировщикам сказал что пишу отличный код и его тестировать не надо. Тестировщик говорит – покажи. Я даю маленькую самую лучшую программу и тестировщик ее ломает в течение одной минуты. Он в поле логина вводит строчку из 8 тысяч символов. Нажимает ОК и программа падает. Никто же не догадывался что такой длинный элемент вставлять в SQL нельзя. В SQL запрос упал. Никогда никто такую ошибку не проверял. А у тестировщика есть навыки и технологии и соответствующий склад ума. Они знают как софт сломать. Слосвл. И я понял что я делаю что-то не так.</p>
  <p>Вспоминаю одну интересную ситуацию. Когда я писал софт для скалада. Надо было обязательно все позиции учитывать каждый день. Склад должен был отчитываться в накладной о том сколько принял товара, сколько списал товара. Все сопротивлялись. Потому что это лишняя работа. Именно работники склада. А потом когда внедрили все утихло. Все работает. Начальство хвалит. Идилия длилась ровно полгода. Через полгода я просто решил немножко программу изменить по базе данных надо было запрос сделать. И все данные рухнули. Все отчеты поломались. Хорошо у меня бэкап был. Начал разбираться в чем проблема. Оказывается, я не предусмотрел, что в поле ввода количество можно вводить отрицательные значения. А пользователи это нашли в течение 15 минут. И они в конце дня просто подгоняли отрицательными значениями под то что им надо. И в итоге отчеты все были прекрасные, все было хорошо. До момента пока я не попытался сделать рефакторинг. Это ошибка QA. Это серьезная ошибка бизнеса, потому что задача не была решена. Руководство хотело получить четкую систему движения товара. В итоге получило систему которая себя обнуляла каждый день потому что пользователи могли это сделать. Это баги. Поэтому если ваша программа работает хорошо, то она просто недотестирована. Лучше предполагать что что-то будет не так.</p>
  <p>Если что-то может пойти не так, то оно пойдет не так. Программисты не умеют тестировать качественно по той причине, что программисты не будут делать так как ненадо. Они знают что если куда-то тыкать ненадо то они туда тыкать и не будут. Если программист долго писал свой код, он ему уже достаточно сильно надоел чтобы он его еще тестировал. Он прогонит какую-то базовую цепочку и все. Если вы умеете тестировать и хотите что вы будете лучше.</p>
  <p>Следующее. У вас на компьютере все работает. Но вы ни разу не пробовали установить это на сервер. Пример, написали приложение для .NET. В докере отлично работает. Выбрали продакшн сервис. А там на операционно системе нет .NET и установить его туда нельзя. Софт есть , а запустить его нельзя. Пришлось изучать как устанавливать систему без .NET и доделывать систему. Просто что-то не учли.</p>
  <p>Нагрузочное тестирование. Если софт прекрасно работает на 10 записях. Выкладываете всю эту систему наружу. К вам приходят 1000 пользователей и сервер падает. Желательно это тоже тестировать.</p>
  <p>Еще сюрприз может быть когда мы что-то долго делали и не проверяли. Новый функционал работает, а старый отломался. Просто забыли тестировать.</p>
  <p>Еще пример. Вы все прекрасно сделали а заказчику это не нравится. Заказчик посмотрел и ему показалось некрасиво. У него нет цели рботать с этим софтом у него цель работать меньше и проще. Если вы сделаете неудобный сложный интерфейс, он будет плохо к этому относиться.</p>
  <p>Заказчик может назвать список дел которые само по себе разумеется и это тоже надо было сделать. Но это само собой разумеещееся для него, а вовсе не для вас.</p>
</article>
  
<article class="article">
  <h3>Служба QA</h3>
  <p>Главная задача: доказать, что продукт некаечественный.
  <br>Главная цель: сберечь вашу репутацию перед заказчиком.
  <br>- Помогает на ранней стадии проверить то ли мы сделали или нет
  <br>- Помогает на ранней стадии проверить гипотезы, заложенные при разработке
  <br>- Помогает отладить UI/UX
  <br>- Проверяет, ничего ли мы не сломали с выпуском новой версии
  <br>- Проверяет ресурсные требования, скорость работы, эргогомику
  <br>- Проверяет соответствие документации реальному функционалу
  </p>

  <p>Как с этим можно бороться? Для этих целей в больших компаниях вводится службе QA (тестировщики). Если вы как программист должны писать продукт качественный, то основная цель QA это доказать что продукт некачественный. Потому что вы эту некачественность исправите. А как доказать что продукт качественный если критерий качества нет? Главная цель – сберечь репутацию перед заказчиком. Грамотный тестировщик это очень ценный сотрудник для продукта. Они тестируют продукт с точки зрения пользователя. Они тестируют так что ни один разработчик не проверит. Будет тыкать куда попало, вводить разные гадости и заранее, до заказчика все эти ошибки найдет. Лучше их найдет внутренняя служба QA заранее чем их найдет заказчик. Или найдет клиент заказчика. Тогда будет вообще катастрофа. Эта штука работает на нас.</p>
  <p>Что нам помогает сделать служба QA и вообще тестировщики. На ранней стадии проверить как мы сделали бизнес требования. Можно проверить гипотезы. Тестировщик поработал и говорит это все неудобно, исправляйте. Отладка UI и UX. Вряд ли разработчики будут смотреть что видно в разных разрешениях. Проверяют требования, скорость, эргономику, документацию. Мы можем сделать то что документации не соответствует. Кто-то должен это проверить. Это делают QA вручную. QAA может прогнать автоматические тесты и софт будет тестироваться постоянно. Цель - качество.</p>
</article>
  
<article class="article">
  <h3>Ну все, зовите Печкина</h3>
  <p>Каналы доставки:
  <br>- Рассылка (публикация) дистрибутивов
  <br>- Доставка через пакетный менеджер
  <br>- Публикация в AppStore, GooglePlay и т.д.
  <br>- Развертывание на серверах заказчика.
  <br>- Развертывание в облаке
  <br>- Доставка через исходный код
  <br>- Организация SaaS
  <br>- Обновление собственного сервиса
  </p>

  <p>Прошли тестирование. Тестировщик сказал «пойдет, сдавайте заказчику». Как можно наш софт отправить заказчику. Если это софт, то можно рассылкой дистрибутивов. Часто вместе с бумажками, красивым диском с логотипчиком и голограммками. Пакетный менеджер например, публикация через store, google play. Если заказчик просит все настроить ему то тогда развертывание на серверах заказчика или в облаке. Некоторые заказчики говорят дайте нам исходный код и настройте CI CD и мы будем сами делать. Иногда это SaaS (soft as a service) и заказчик получает обновленную версию сайта. Это способ доставки. Обычно этим уже занимаются девопсы. Если девопса нет, то тим лид или PM.</p>

  <h3>На что стоит обратить внимание</h3>
  <p>- Необходимо планировать и вести учет версий
  <br>- Вести Release Notes к выпущенным версиям
  <br>- Автоматизировать процессы сборки, тестирования и доставки
  <br>- Тестировать процесс обновления
  <br>- Почаще делать резервные копии
  <br>- Предупреждать пользователей о временной неработоспособности сервисов, если необходимо
  <br>- Собирать обратную связь от пользователей по работе обновления
  </p>

  <p>На что стоит обратить внимание когда вы будете отдавать заказчику эту информацию. Первое – на версии. Планируйте и ведите в них учет. По ним будете вести release notes и записывать что изменилось. Процессы сборки, тестирования и доставки лучше автоматизировать. Не проблема доставить софт один раз или два. Но когда это делать 200 раз то можно с ума сойти. Поэтому лучше это автоматизировать. Обязательно тестируйте процесс обновления. Мало того что вы код сделали. Накат обновлений на базу пользователей может привести к порче данных. Перед тем как это сделать желательно у себя иметь предыдущую базу данных и на ней все проверить чтобы заказчику не навредить.</p>
  <p>Делайте резервные копии почаще. Предупреждайте пользователей о том что сервис отвалится. А то некоторые втихоря обновляют, а у пользователя там открыты документы. Надо планировать этот процесс. Собирайте обратную связь, убедитесь что у заказчика прошло все хорошо. Все эти нехитрые действия помогут не получить негатив от заказчика.</p>

  <h3>А как же происходит на самом деле</h3>
  <p>- Проснуться
  <br>- Открыть бэклог, составить план на день, почитать и понять требования к задачам
  <br>- Поучаствовать в стендап-митинге, сказать, что все хорошо и готов к новым свершениям
  <br>- Сделать новую ветку в VCS, попробовать реализовать задачу
  <br>- Понять, что требования к заданию не полные или противоречивые, полдня попытаться выяснить что именно надо сделать
  <br>- Попробовать реализовать задачу снова еще раз
  <br>- Поймать какую-то проблему в реализации, еще полдня гуглить решение, пить много кофе, начать серьезно посматривать на подаренный кем-то и стоящий на полке шаманский бубен
  <br>- Найти на форуме способ решить проблему, доделать задачу, отдать ее на тестирование, уйти домой
  <br>- На утро получить от QA небольшую книжку с описанием сделанных ошибок, прочитать ее, начать всерьез думать, что работа таксистом не такая уж и плохая
  <br>- Исправить все баги, периодически постукивая в шаманский бубен и соображая кому надо молиться, чтобы, ну к примеру, SQL запрос отрабатывал немного быстрее. Отдать все в релиз
  <br>- Получить огромное облегчение и положительные эмоции после того, как все заработает так, как надо
  </p>

  <p>Это конечно юмористическое. На самом деле работа программиста достаточно интересная. Для меня самая лучшая. Она позволяет себя реализовать. Вы можете сделать новое, современное, деньги за это платят хорошие. Крайне рекомендую тем кто сможет этот путь пройти, получить кайф для себя. Она будет радовать.</p>
</article>
  
<article class="article">
  <h3>Вопросы.</h3>

  <p>- Паттерны проектирования. Будут ли они рассматриваться?</p>
  <p>- Нет. Паттерны проектирования - это теоретическая вещь. Здесь мы будем больше иметь отношение к практике. Поэтому задача этого курса чтобы вы самостоятельно собрали готовое реальное приложение. Паттерны поучите сами. Там ничего особо сложного нет. Львиная часть паттернов, которые есть, студия сама уже реализовала. Если они вам пригодятся на практике, ну отлично, как-то разберетесь. Можно и без паттернов. Обычно стандартных подходов для работы вполне достаточно. Но это не означает что их не надо учить. Я рекомендую с ними ознакомиться. Чтобы понимать какие они есть и если вы их увидите в коде чтобы понимали что там делается. Паттерн чем хорош? Вы глянули – ага, это такой-то паттерн и уже кусок кода в голове собран. В рамках курса .NET изучаться не будет. Был Java курс там изучались. Возможно будут изучаться в будущем.</p>

  <p>- Рекомендуете ли вы идти начинающим программистам в магистратуру?</p>
  <p>- Это вообще никаким образом не связано. Как я уже говорил. У меня был знакомый, который институт бросил, но при этом прекрасный программист. Один раз я собеседовал человека который закончил магистратуру и аспирантуру, но при этом в IDE не смог мне толком цикл написать. Магистратура, она не повредит. Это в любом случае знания, статус, корочка. Если хотите, то почему нет.</p>

  <p>- Домашка будет?</p>
  <p>- Домашки не будет. Домашка будет самостоятельная. Я проверять ее не буду. У нас будет практика. Крайне рекомендую эту практику повторить. Набрать. Программист это тот кто пальцами пишет. И в память будет вбиваться через пальцы. Если вы будете просто читать, толку не будет.</p>

  <p>- Можно без образования?</p>
  <p>- Без вопросов. Для того чтобы программировать вам образование не нужно. Вам нужны знания, вам нужны навыки. Если вы будете писать серьезный софт для шифрования, там без математики и без образования никак. Для того чтобы простенькие сайты рисовать – не обязательно. Высшее образование – это такой период где вас учат самостоятельно учиться, самостоятельно что-то делать. Если вы это умеете, то почему нет.</p>

  <p>- Какую IDE будем использовать?</p>
  <p>- Мы будем использовать VS Code и VS Community, а вы можете любую использовать.</p>

  <p>- Будет предоставляться учебный план или расписание программы, потому что не знаем что мы будем проходить?</p>
  <p>- Учебный план сформирован. Я его в ближайшее время выложу в телеграмм. Какие будут лекции. Кто будет читать. В какие календари. Все обязательно будет. Но внутренний, разумеется, у нас есть.</p>

  <p>- Можно начинать говнокодить а после разбираться как написать лучше?</p>
  <p>- Говнокодить никогда не рекомендую. Старайтесь качественно писать настолько, насколько вы готовы. Не надо говнокодить специально. Это плохо. Никто не будет требовать от вас такого уровня, чтобы вы как сеньеры писали. Просто сделайте хорошо и все. Для начинающего это нормальная работа. Вы просто учитесь. У нас сначала будет вводный курс по шарпам. А потом мы будет просто пошагам делать. Вы можете делать тоже самое просто повторяя за мной. Вы откроете студио, откроете видео и начнете писать тоже самое. Понаступаете на грабли, но в этоге вы это соберете и у вас получите. И вы будете уже не trainee а как минимум джуны.</p>

  <p>- Есть у вас вакансия .NET разработчика?</p>
  <p>- У нас сейчас .NET вакансия немножко прекращена в связи с санкциями. Но я четко знаю что .NET разработчиков активно берут наши компании другие МТС, Озон, Касперский. Эта вакансия сама по себе весьма актуальна. Здесь 100%. Не исключаю что и у нас эти вакансии откроются. Так что попадайте к нам в резерв. У нас библиотека копится. Как только будет появляться возможность, будем искать. Наш HR очень сильно любит ваши резюме и ваши знания.</p>

  <p>- Насколько возможно получить оффер в конце обучения?</p>
  <p>- Возможно, но для этого надо быть выдающимся. Из-за того что у нас есть санкции, такого большого набора как раньше не будет. В этом году мы взяли одного человека. То есть оффер получить вполне возможно. Все зависит от вас. Но надо быть на голову выше чем остальные.</p>

  <p>- Онлайн ворк?</p>
  <p>- Да. Мы работаем онлайн. Офлайн по-разному.</p>

  <p>- Не нарушает ли solid принципы rich модели?</p>
  <p>- Нет. Не нарушает. На самом деле, даже когда вы делаете какие-то rich модели, вы можете их делать красиво. Со всеми приницами. Почему нет? Если вы в rich модели сделаете один метод который будет делать все - это плохо. Он нарушает single responsibility принцип. Разбейте этот метод на кусочки, сделайте какие-то приватные методы и у вас все принципы будет учтены. Все эти принципы solid, kiss, dry это не рекомендации к написанию кода. Это рекомендации к тому как код надо построить, к архитектуре кода. Оно придет со временем. Сперва будете писать код с кучей комментариев. Он будет длинный и постепенно вам будет надоедать, по себе знаю. И будете писать кода все меньше и меньше пока он на экране ноутбука не будет помещаться легко. Чтобы его легко было читать и легко понимать. И тогда можете делать следующим оразом. У вас есть сверху модуль. Вы например, end поинт пишите. Определили в end поинте методы add, create, delete. Описали методы, описали модельки. Эти модельки отдали куда-то дальше. И в итоге вы сверху пишете. У вас уже весь каркас снаружи есть. Осталось написать только внутренности. И вы будете эти внутренности настолько декомпозировать, что в каждом методе останется по 5 - 6 строчек кода. В итоге вы очень легко сможете понять где у вас что сломалось. Если систему логирования вы настроили. У вас стандартно будет логироваться красиво. Это придет со временем. На старте, если вы про это будете знать и обращать внимение - это время придет быстрее.</p>
</article>

<article class="article">
  <p>Спасибо за внимание. Следующая лекция будет в следующий понедельник. У нас будет си шарп первая лекция. На неделе я сделаю расписание и опубликую в телеграмм. Будут вопросы – пишите в телеграмм. Добро пожаловать на курс. Удачи! Успехов!</p>
</article>