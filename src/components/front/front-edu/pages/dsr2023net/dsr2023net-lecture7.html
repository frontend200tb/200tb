<article class="article">
	<div id="link-to-dsr2023net" class="btn-back">назад</div>

  <h1>2023-11-13 DSR .NET School 2023 Lecture #7 .Net platform</h1>
</article>

<article class="article">
  <h2>Лекция 7. Платформа .Net</h2>

  <p>Здравствуйте. Сегодня мы очередную лекцию начинаем. Мы приближаемся непосредственно к практическим задачам. И сегодня у нас лекция будет посвящена платформе .net. Она не такая длинная. Я думаю мы ее пораньше немножко сегодня закончим. И со следующей лекции у нас будут практические части, где мы будем обсуждать про web API и конкретно изучать, какие там элементы, из чего она состоит, на что стоит на старте внимание обратить. И если все хорошо будет, то на следующей неделе у нас начнется практика.</p>

  <h2>О чем будет эта лекция</h2>
  <p>1. Что такое фреймворк</p>
  <p>2. Платформа .Net</p>
  <p>3. Как работает платформа .Net и из чего состоит</p>
  <p>4. Вехи развития фреймворка</p>
  <p>5. Основные понятия фреймворка</p>
  <p>6. Что такое сборщик мусора</p>
  <p>7. Область применения</p>

  <p>Мы сегодня поговорим о платформе .net и фреймворках на ее базе. Поговорим о сборщике мусора, о памяти. И где она применяется. Пол лекции будет просто так ознакомительные, легкая. Но половину лекции стоит посмотреть, потому что часто задают это на собеседованиях. Обзорно мы сегодня это обсудим. Если будут вопросы - задавайте. Если будет желание изучить поглубже, то это на самостоятельное обучение. Информации у нас достаточно. Любая серьезная книжка расскажет побольше. Давайте начнем</p>
</article>

<article class="article">
  <h2>1. Что такое фреймворк?</h2>
  <p>Сначала программисты писали все "с нуля" (работу с файлами, текстом, математические функции и т.д.). Потом еще раз тоже самое, потом еще раз.</p>
  <p>В итоге он выделил все в отдельный набор функций, который стал БИБЛИОТЕКОЙ</p>
  <p>Со временем программист начал понимать, что все приложения, которые он пишет, примерно похожи друг на друга (состоит из одних частей, имеет сходную структуру и т.д.)</p>
  <p>Была выделена система, которая делала что-то абстрактное, общее, в которую внедряется уникальный код, который делал специфику. Получился ФРЕЙМВОРК.</p>
  <p>Подумали еще и объединили фреймворки и получили СТЭК ФРЕЙМВОРКОВ</p>

  <p>Кто знает чем отличается фреймворк от библиотеки? Напишите в чате фреймворк и библиотека это одно и то же? "Фреймворк это целая система включающая несколько библиотек". Ну и библиотека может включать несколько библиотек. Например, библиотеки с сетью, с видео, со звуком. И будет такая большущая библиотека, но фреймворком она считаться не может.</p>

  <p>Смотрите. Изначально, когда программисты только начинали свою работу. Когда программы только появлялись, они были у каждого свои. Сети не было, обмен информации на перфокартах, потом на дискетках. На старте ничего не было. Когда программист писал свой софт, он понимал что некоторые вещи он делает одно и то же. И выносил это в функции, наприме, работа с математикой. И формировались кусочки повторяемого кода, которые он начинал таскать от приложения к приложению. Я думаю у каждого есть такая библиотечка, которая уже требует большого рефакторинга. Зато удобно, привыкли и т.д. У меня их тоже было немеряно и сейчас есть. Вот такой набор функций, потом кто-то сел привел все это в порядок, выкинул лишнее и это стало называться библиотекой. Библиотека это набор функций, метод, правил, которые определяют какое-то действие. И вы когда подключаете библиотеку - просто пользуетесь функционалом.</p>

  <p>Проходит время. Программисты пишут. И понимают что уникальных задач не так уж и много. Если он в какой-то нише работает, например, разрабатывает сайты. У сайтов одно ядро - работа с http, работа с request/response, обработка логов, работа с юзерами, аутентификация, авторизация. Они очень сильно похожи. И когда программист начинает писать новый сайт, он берет свой старый продукт, чистит его до какого-то общего состояния и начинает в него писать что-то еще. Со временем эта тенденция была выявлена. И получилось так, что можно написать какой-то кусок кода, в который внести изменения и этот код будет по одним правилам выполнять разные задачи. И этот подход, при котором у нас есть уже написанный скелет и в него мы вносим уже какую-то логику, и называется Фреймворк. В этом отличие. Библиотеку подключаем и используем ее готовые функции. А в фреймворке мы пишем по определенным правилам. Библиотека подключается снаружи. Фреймворк модифицируется внутри. Эта абстрактная система которую выделили в отдельный кусок кода и написали правила, где сделали входы, конфигурируемые кусочки, которые позволяют превратить все это в рабочий софт - это считается фреймворком. Потом объединили эти фреймворки в кучу и получили стек фреймворков.</p>

  <p>Например, есть библиотека Math. Это библиотека оформленная в виде статического класса, в котором есть куча чего-то. Есть фреймворк asp.net для создания MVC приложений. У вас уже из коробки есть куча кода. И вы внутри пишете контроллер. Вас не волнует каким образом делать роутинг. Вы пишите только внутренность сайта. А все что снаружи за вас написал уже фреймворк. Если вы работаете на .net то это уже целый стэк фреймворков. Есть фреймворк и для web api и для мобильного приложения. Основное отличие библиотеки от фремворка: библиотека это кирпич, мы строим дом, у вас есть кирпичи, краска - это библиотечки. Мы из них строим дом. А если у вас есть уже готовая коробка дома, а вы внутри уже можете сделать любые квартиры, но внешне все стены будут одинаковые - это фреймворк. Если у вас будут спрашивать: библиотека или фреймворк? Не путайтесь. Немножко разные подходы.</p>
</article>

<article class="article">
  <h2>2. Платформа .Net</h2>
  <p>Среда выполнения (Execution Runtime Environment)</p>
  <p>Программное обеспечение (Software)</p>

  <p>Давайте немного поговорим про платформу .net. Еще до появления всяких платформ, а .net не первая появилась, до не еще было. У нас была среда выполнения (Execution Runtime Environment), например, компьютер и программное обеспечение (Software), которое было заточено под нашу среду выполнения. Например мы запускали .exe файл и он работал на виндовсе. И windows уже сам работал с аппаратным обеспечением, подключался к винчестеру, к памяти. В чем здесь особенность? Под каждую среду выполнения (операционную систему) нам надо писать свою программу. Например, приложения которые хорошо работали на pentium, уже не могли работать на 486-ом. 32 битные приложения и 64 битные приложения. Приложения из одной системы линукс не могли запускаться на другой системе линукс. Все операционные системы были вразноброд, они и сейчас-то вразноброд. У каждого свои подходы, свои api. Поэтому нельзя было сделать приложение которое могло работать во всех системах.</p>

  <p>Как работает .net? У нас есть программа. Программа бывает интерпретируемая или компилируемая. Интерпретируемая программа выполняет те команды, которые в ней записаны как текст. И если есть интерпретатор под разные операционные системы, то программа может заработать на разных операционных системах. Например код php будет работать и в интерпретаторе под линукс и под виндовс</p> 
  
  <p>Программа - Интерпретируемая. Здесь можно сделать кросспратформенность, но при этом мы теряем в скорости. Потому что каждый раз мы должны работать с кодом как с текстом. К интерпретируемым относятся php, python и javascript.</p> 
  
  <p>Программа - Компилируемая - Промежуточный код - Библиотеки - Операционная система. Компилируемая программа компилируется в промежуточный код и работает через библиотеки с операционной системой. Компилируем под определенную операционную систему и у нас получается приложение которое сразу выполняется, оно в понятном для операционной системы выде. Но компилировать надо под разные системы. Нужно писать под каждую платформу. Чтобы быть универсальным надо много знать. Трудно поддерживать. Трудно людей найти. К компилируемым относятся java, pascal, c#, typescript, rust. </p>
</article>

<article class="article">
  <h2>3. Как работает платформа .Net</h2>
  <p>Как было раньше:</p>
  <p>- или компилировалось в исполняемый файл</p>
  <p>- или представляло собой COM объект</p>
  <p>Чем .net лучше:</p>
  <p>- упрощена модель установки (Global Assembly Cache)</p>
  <p>- обратная совместимость</p>
  <p>- независимость от языка программирования</p>
  <p>- и, с недавнего времени, кроссплатформенность</p>

  <p>Как работало изначально? Пытались сделать в любой операционной системе какие-то универсальные вещи чтобы что-то облегчить. Для виндовс мы могли скомпилировать файл и положить внутрь операционной системы и запускать. Либо мы могли собрать .com объект, зарегистрировать и положить его в систему. И наше приложение представляло собой не .exe файл, а набор dll, которые внедрялись внутрь windows и их можно было по специальному идентификатору достать и что-то сделать. Например, при помощи .com объекта можно было сделать драйвер работы с принтером. Драйвер работы с внешним сканером штрих-кода. Таким образом пытались универсальности добиться. Если драйверы были написаны под разные системы, например х64 и х86, вашему приложению проще работать с оборудованием.</p>

  <p>Чем .net лучше? Когда придумывали технологию java, еще раньше чем .net. Использовали такой подход. Для каждой машины создавалась виртуальная машина (java virtual machine). И виртуальная машина брала на себя всю работу с операционной системой. Программист писал код на java и мог запустить его на любой операционной системе если там есть виртуальная машина. Есть обратная совместимость. Если запускается в одном месте, то запускается везде. Код на java мог быть запущен даже на процессорах, если для них был JVM.</p>

  <p>В windows делался либо .exe файл, либо .com объект, который регистрировался. В .net сделали немножно по-другому. В системе есть Global Assambly Cache куда собираются и кэшируются все кусочки кода и в итоге работают. У .Net есть обратная совместимость и независимость от языка программирования. С какого-то времени развился до кроссплатформенности.</p>

  <p>Было много языков. И паскаль, и с++, и visual basic microsoft очень долго делал и развивал. Не взлетел visual basic, никому он толком не нужен кроме тех которые макросы в офисе писали, ну и какую-то еще ерунду для себя. У с++ были реальные плюсы, которые microsoft поддерживал. Но у него был один реальный минус здоровый. Во-первых, чтобы на нем писать, надо было изучить эти плюсы.Их много всяких диалектов. Для каждого могли быть свои различия. Чтобы писать не просто вычислительные функции надо было знать не только сам язык, но и правила работы с платформой. Например писать на плюсах для windows и для linux - какая-то разница есть. Это было сложно.</p>

  <p>Для того чтобы упростить программирование придумали язык Pascal в компании Borland. Turbo Pascal и так далее. Чем хорошо? Паскаль был очень простой язык. Легко было учить. Но были и минусы. Он был не си подобный. Кучу народа пришлось переобучать. Немножко переключилось внимание комьюнити. Он изучался как учебный. Его никто всерьез толком не воспринимал. Хотя потом он вырос в серьезные языки. На его базе был сделан язык Delfi. На нем большое количество людей писали хорошие вещи. Это компилируемый язык. Он и сейчас есть. На нем еще пишут. Но это был не microsoft. Microsoft на это смотрел со стороны.</p>

  <p>Потом придумали Java. Он все плюсы и Garbage Collector взял и стал мейнстримом. Захватил разработку всевозможных банковских приложений, тяжелых корпоративных приложений. Он не очень хорош для написания визуальных приложений. Даже на delfi писать красивые приложения гораздно проще чем на Java. А вот серверную часть на java писать очень хорошо. И бизнес серьезно начал перетекать на java. Microsoft видел что деньги утекают, решил сюда вклиниться и урвать какую-нибудь часть. Они взяли разработчика delphi и он взял все плюсы какие были и сделал первую версию языка c#. Потом он же написал и typescript. Была выпущена платформа .net которая немного отличалась от java. Первые версии были простенькие, глючные. Но идея была интересная и он постепенно развился.</p>
</article>

<article class="article">
  <h2>Из чего состоит платформа</h2>
  <p>Общая исполняемая среда (CLR или Core CLR)</p>
  <p>Общая система типов (CTS)</p>
  <p>Общая спецификация языка (CLS)</p>
  <p>Базовая система классов (BCL)</p>
  <p>Фреймворки (Frameworks)</p>

  <table border="1">
    <tr>
      <td>C#</td><td>F#</td><td>VB.NET</td><td>C++</td><td>IronPython</td><td>IronRuby</td><td>...</td>
    </tr>
    <tr>
      <td colspan="7">Common Language Specification</td>
    </tr>
    <tr>
      <td>WCF</td><td>ASP.NET (WebForms, MVC)</td><td>SignalR</td><td>Windows Foundation</td>
      <td rowspan="2">WPF</td><td rowspan="2">WinForms</td><td rowspan="2">Silverlight</td>
    </tr>
    <tr>
      <td colspan="4">ADO.NET & Entity Framework</td>
    </tr>
    <tr>
      <td colspan="7">Base Class Library (BCL)</td>
    </tr>
    <tr>
      <td colspan="7">Common Language Runtime (CLR)</td>
    </tr>
    <tr>
      <td colspan="7">Operating System</td>
    </tr>
  </table> 

  <p>Как работает .net и из чего состоит. Давайте посмотрим. Типовая система .net это слоистая технология. У нас есть операционная система. Ниже аппаратное железо. Над операционной системой мы ставим всю платформу фреймворк .net. Это даже не фреймворк а полноценная разработка. В отличие от java, она ставится на машину целиком. На операционную систему накладывается слой CLR. Она выполняет наш код на конкретно этой операционной системе. Для каждой операционной системы windows, linux, macOs установится своя .net платформа. Следующий слой BCL. Следующий слой набор фреймворков. Следующий это общая спецификация языков. И , наконец, последний это язык программирования.</p>

  <p>Любой человек может взять подходящий ему язык программирования, например, c#. Написать на c# код и потом скомпилировать и он будет выполняться на операционной системе. Причем код будет унифицирован для всех операционок. По сути, операционки для кода уже нет. Не все фреймворки подойдут. Для линукса нет фреймворка WPF, но для него можно использовать сторонний фреймворк Avalonia.</p>
</article>

<article class="article">
  <h2>Common Language Runtime (CLR)</h2>
  <p>Основа - IL (Intermediate Language) или MSIL (Microsoft Intermediate Language) или CIL (Common Intermediate Language)</p>
  <p>****.dll или ****.exe Сборка (Assembly)</p>

  <p>Основа для CLR это IL код. Программист пишет исходный код на языке C#. Во время компиляции исходный код компилируется в bytecode, который содержит IL код и метаданные. И этот код записывается в выходной файл в виде исполняемого кода программы. Когда мы запускаем этот файл, то весь код еще раз компилируется в JIT (Just in time) компиляторе для выполнения. То есть во время выполнения байткода CLR переводит этот код в машинный код и исполняет его на операционной системе. Скомпилированные кусочки байткода попадают в кеш. При первом запуске программа работает медленнее. А при повторных быстрее как раз за счет этого кэша.</p>

  <p>Получается два уровня абстракции. Уровень языка, который компилируется в промежуточный код. Промежуточный код, который при помощи JIT компилируется в нативный код. У нас есть managed code (который управляется платформой), который мы на си шарп написали. Он проходит через Compiler (Компилятор). Компилятор генерирует MSIL код. MSIL код проходит через CLR (JIT Compiler) и получается native code, который уже выполняется в операционной системе. Иногда мы хотим внутри managed кода сделать unmanaged код. Пометить какой-то блок unsaved, например, вставка на ассемблере. Мы делаем кусок кода, который исключается из работы нашей .net. Он компилируется, мы можем к нему обращаться, но он уже работает минуя всю нашу систему, просто как внешний плагин. В managed code случае .net будет нам помогать, включать garbage collector. А в unmanaged случае все будет под нашу ответственность. Не рекомендуется использовать unmanaged code, но такая возможность есть.</p>

  <p>Кодга мы собираем приложение, мы в итоге можем получить либо dll, либо exe. Все dll которые входят в сборку будут составлять наше приложение. Это по поводу общей схемы работы. Как она работает. Теперь - почему она работает.</p>
</article>

<article class="article">
  <h2>Common Type System (CTS)</h2>

  <p>Основой у нас есть Common Type System. В разных языках есть разные типы. В Visual Basic есть тип Integer, в C# есть тип int. На самом деле это одно и тоже. Преобразуются в IL в тип Int32. Система типов CTS стандартизирует работу с типами. Она приводит к одному виду разные типы из разных языков. Какие у нас есть типы? Все типы делятся на две категории Value Types и Reference Types.</p>

  <p>Value Types это обычные типы для простых данных которые хранятся в стеке. К ним относятся Built-In Value Types, User-Defined Value Types, Enumerations.</p>

  <p>Reference Types это типы для сложных данных (массивы, коллекции), которые хранятся в куче. К ним относятся Self Describing Types, Pointer Types, Interface Types. К ним применяются функции boxing, unboxing.</p>
</article>

<article class="article">
  <h2>Common Language Specification (CLS)</h2>

  <p>Это еще один уровень абстракции. На платформе CLR есть типы CTS. Язык C# имеет свои команды, Visual Basic - свои, Fortran - свои. Все эти множества команд где-то пересекаются и дают CLS. Что делает .Net? Он определяет стандартную спецификации языка. Определяет набор функций, которые необходимо реализовать и которые должны выполняться в IL коде. И CLR должна все конструкции языков программирования преобразовать в конструкции, которые описаны в спецификации CLS. В итоге, у нас есть общая спецификация методов, общее описание типов и наша среда CLR, которая выполняется на операционной системе. Разработчик компилятора должен взять язык, трансформировать все типы данных к списку CTS, а все команды к списку CLS. У нас получается ядро, которое позволяет код на любом языке запускать на любой платформе.</p>
</article>

<article class="article">
  <h2>Base Class Library (BCL)</h2>
  <p>System.Web</p>
  <p>System.Data</p>
  <p>System.Windows.Forms</p>
  <p>System.Drawing</p>
  <p>System.Xml</p>
  <p>System</p>

  <p>Чтобы жизнь казалась полегче, разработали BCL. Это набор библиотек, которые собраны внутри неймспейсов, в которых реализованы базовые вещи. Например, работа с коллекциями, со списком, с файлами, с текстом, с потоками. На уровень выше работа с базами данных, с SQL клиентами. Эти классы это база. Они должны быть у всех. Они разработаны в рамках CLR.</p>
</article>

<article class="article">
  <h2>Фреймворки</h2>
  <pre>
  Sites, Services
  |
  Web Forms, Web Pages, SPA (MVC, Web Api), SignalR
  |
  ASP.NET
  </pre>

  <p>Мы, как программисты, работаем в этой области. У нас есть фреймворки, с которыми мы на .net работаем. Например, ASP.NET фреймворк - для работы с вебом. У нас есть набор готовых систем, с которыми мы должны работать. И нам абсолютно все равно какая у нас платформа. Если мы хотим писать в .net не на си шарпах а на паскале - пожалуйста. Ищите компилятор для паскаля (он, кстати, есть) и будете писать на паскале. Те же Делфи имеют компилятор с языка Делфи в IL код.</p>
</article>

<article class="article">
  <h2>История развития .net</h2>
  <p>Period of .NET Framework</p>
  <p>2002 .NET Framework 1.0</p>
  <p>2003 .NET Framework 1.1</p>
  <p>2005 .NET Framework 2.0</p>
  <p>2006 .NET Framework 3.0</p>
  <p>2007 .NET Framework 3.5</p>
  <p>2010 .NET Framework 4.0</p>
  <p>2012 .NET Framework 4.5</p>
  <p>2013 .NET Framework 4.5.1</p>
  <p>2014 .NET Framework 4.5.2</p>
  <p>2015 .NET Framework 4.6</p>
  <p>2016 .NET Framework 4.6.1</p>
  <p>2017 .NET Framework 4.7</p>
  <p>2019 .NET Framework 4.8</p>
  <p>Period of .NET Core</p>
  <p>2016 .NET Core 1.0</p>
  <p>2017 .NET Core 2.0</p>
  <p>2019 .NET Core 3.0</p>
  <p>Period of .NET</p>
  <p>2020 .NET 5.0</p>
  <p>2021 .NET 6.0</p>
  <p>2022 .NET 7.0</p>
  <p>2023 .NET 8.0</p>

  <p>Как .NET развивался? В 2001 году все началось. В 2002 появился первый фреймворк. Какое то время он развивался до версии .NET Framework 4.8.2 в 2019 году. Это была эпоха Net фреймворка. .NET Framework работал только под Windows. И этим проигрывал яве, которая была кроссплатформенной. В 2016 году появились навыки и знания и команды и опыт. Микрософт решил выйти на уровень кроссплатформенности и выпустил .NET Core. Это переработанный .NET Framework. В .NET Core многие вещи были переписаны в лучшую сторону. В 2016 году вышел .NET Core 1.0, он уже кроссплатформенный. Он развивался до версии .NET Core 3.1 в 2019 году. После него уже уже вышла .Net 5.0 в 2020 году. С 2021 года .NET Framework и .NET Core ушли и стал просто .NET.</p>
</article>

<article class="article">
  <h2>Планы развития .Net</h2>
  <p>2019 november .NET 3.1 LTS</p>
  <p>2020 november .NET 5.0 current</p>
  <p>2021 november .NET 6.0 LTS</p>
  <p>2022 november .NET 7.0 current</p>
  <p>2023 november .NET 8.0 LTS</p>

  <p>LTS (long Time Support) длится 2 года. Current - промежуточная версия, там добивают свои ошибки. Надо работать на самой свежей версии LTS. Это не мешает пользоваться более ранними версиями, потом сделать апгрейд и все протестировать еще раз. Переход между версиями сейчас безболезненный. Хотя переход с .NET Framework на .NET Core был сложный, проще было некоторые вещи переписать. Сейчас уже хорошая поддержка. Ничего особенно нового не добавляется. Все хорошее уже придумали. Добавляется синтаксический сахар.</p>

  <p>Это по поводу .NET Core. У Микрософт есть еще такое понятие как .Net Standard.</p>
</article>

<article class="article">
  <h2>.Net Standard</h2>
  <p>APP MODELS</p>
  <ul>
    <li>.NET FRAMEWORK - WPF, Windows Forms, ASP.NET</li>
    <li>.NET CORE - UWP, ASP.NET Core</li>
    <li>XAMARIN - iOS, OS X, Android</li>
  </ul>
  <p>.NET STANDARD LIBRARY One library to rule them all</p>
  <p>COMMON INFRASTRUCTURE</p>
  <ul>
    <li>Compilers</li>
    <li>Languages</li>
    <li>Runtime components</li>
  </ul>

  <p>.Net Standard это выделенные еще кусочки правил и описание. Это минимально возможная спецификация, которая для всех общая. Ее выделили из того что есть - .NET FRAMEWORK, .NET CORE, XAMARIN из готовых финальных частей и сделали общую часть. Ее описали и сказали что это .Net Standard. .Net Standard нужен, чтобы разработчики, которые пишут библиотеки, и под каждый новый фреймворк, что-то подписывают. Это было придумано для библиотек. Чтобы им было попроще. Net Standard развивается от версии 1.0 уже до версии 2.1. И есть соответсвия между версиями фреймворка и версией .net standard. Например, net core 3.0 поддерживавет стандарт net standard 2.0. Если нужно написать компонент для всех платформ, можно воспользоваться стандартом, который поддерживается этими платформами.</p>
</article>

<article class="article">
  <h2>Организация памяти</h2>
  <p>Call Stack</p>
  <p>Stack Memory</p>
  <p>Heap Space</p>

  <p>Давайте посмотрим как в Нете организована память. Есть два вида памяти - стек и куча. Если открыть стек вызовов (Call Stack), исполнение программы начинается с функции Main(). Например фуркция main() вызывает Person(String) и есть метод setPersonName(String). И Person и setPersonName размещаются в стеке. При вызове функции, все аттрибуты сваливаются в стек. Выполняются какие-то действия. Когда функция завершилась - стек чистится. Есть алгоритмы, они несложные, можете их поискать, но сейчас это неважно.</p> 
  
  <p>В стеке хранятся ссылки на объекты и ссылки на строки. Строки неизменяемы и зачем их все хранить в стеке, если можно сделать ссылку, а строки хранить в куче. Поэтому менять строку просто так нельзя. Если вы это делаете, то у других которые ссылаются на эту же строку, все поменяется. Поэтому если вы что-то меняете в строке, то создается новая строка, а все остальные которые ссылались на старую так и ссылаются. Когда никто ссылваться не будет - garbage collector очистит. Таким образом работает строка.</p> 
  
  <p>В стеке хранятся переменные (value) и ссылки (reference). В куче хранятся созданные экземпляры объектов. Стек чистится автоматически. Куча чистится не автоматически. Куча чистится либо при помощи garbage collector либо руками. Если вы пишете на языке C++ или Pascal, то за памятью следите самостоятельно. Если выделяете память, то потом ее нужно удалить. Если не удалите, то скоро память переполнится. И случаются утечки памяти - когда память никто не использует, а она вся занята.</p> 
  
  <p>В языках java, javascript, c# есть сборщик мусора и за памятью следить не надо. Вы можете создать объект, попользоваться им, и забыть. Не надо ничего помнить. Код гораздо упрощается. Количество ошибок уменьшается. Приложения становятся надежнее и проще. Но имеет и накладные расходы, но мощности компьютеров сейчас такие, что этим можно пренебречь.</p>
</article>

<article class="article">
  <h2>Garbage collector - Как работает</h2>
  <p>Для того чтобы чистилась память (heap) есть сборщик мусора. Это отдельный процесс, который живет в приложении. Он берет приложение на контроль и за ним следит. Например, у нас есть приложение и у него есть куча созданных объектов, на которые оно ссылается. Сборщик мусора находит все объекты, которые ничьи, на которые нет ссылок и их вырезает. В итоге остаются только те объекты , которые нужны, на которые есть ссылки и памяти становится больше.</p>
</article>

<article class="article">
  <h2>Garbage collector - Этапы</h2>
  <ul>
    <li>Marking - Маркирует живые объекты</li>
    <li>Relocating - Обновляет ссылки на объекты, которые будут упакованы</li>
    <li>Compacting - Упаковывает живые объекты</li>
  </ul>

  <p>Garbage collector работает в три этапа. Сначала маркирует живые объекты. Подсчитывает какие объекты нужны, а какие нет. Делает релокацию, обновляет ссылки на объекты которые будут упакованы. Живые объекты мы распологаем в памяти так, чтобы не было пропусков, сжимаем память. Вот так в три этапа он и работает.</p> 
  
  <p>При этом меняются указатели на эти объекты. И они могут меняться произвольное количество раз за врмя жизни приложения. Поэтому здесь нет смысла хранить указатели. Потому что указатель может поменяться каждый раз когда работает сборщик мусора.</p>

  <p>Но есть и минус в работе сборщика мусора. Наше приложение работает в несколько потоков. В отдельном потоке запускается сборщик мусора и пока он работает, все остальные потоки ждут (останавливаются, suspended). Каждый раз когда запускается сборщик мусора, наше приложение подвисает. Поэтому сборщик мусора это вещь хорошая, но тоже имеет свои накладные расходы. Чтобы оптимизировать работу сборщика мусора, надо понять что он работает не в туже секунду, когда объект не нужен. Он может запуститься когда в системе становится мало памяти.</p>
</article>

<article class="article">
  <h2>Garbage collector - Когда?</h2>
  <p>Когда происходит сборка мусора</p>
  <ul>
    <li>В системе мало свободной физической памяти</li>
    <li>Объем используемой приложением памяти превышает постоянно настраиваемый порог</li>
    <li>Вызван метод GC.Collect</li>
  </ul>

  <p>Garbage collector может запуститься когда захочет, когда ему надо. Если в системе много оперативной памяти, то не факт что сборщик мусора вообще запустится. Есть занятая память, которая никому не нужна, но я ее освобождать не буду, потомучто места и так всем хватает.</p> 
  
  <p>У сборщика мусора есть оптимизационный алгоритм. Для оптимизации он разделяет объекты на три генерации: Generation 0 (short-lived objects), Generation 1, Generation 2 (long-lived objects). Новые созданные объекты сначала попадают в Generation 0. Сборщик мусора часто заглядывает в generation 0 чтобы проверить переменные. Если переменная никому не нужна, то он ее удалит. Если кому-то нужна, то он переместит ее в Generation 1. Сборщик мусора редко заглядывает в generation 1. Но когда заглядывает то смотрит, если переменная никому не нужна, то удаляет ее, а если нужна то перемещает в generation 2. И туда заглядывает еще реже. Сюда могут попадать объекты объемом больше 80 кбайт. Для них нужно выделять много памяти, дефрагментацию делать, поэтому их сразу кладут в generation 2. Эти объекты называются large object heap. Которые не пытаются засунуть в короткоживущие объекты.</p> 
  
  <p>Сборщик мусора запускается когда ему надо и сразу разделяет объекты по поколениям. Таким образом он оптимизируется, работает достаточно быстро. И для программиста незаметно. Где сборщик мусора будет мешать? Если вы в цикле будете создавать новые строчки. То все эти данные попадут в heap и сборщику мусора будет тяжеловато. Это важно если вы будете писать высоконагруженное оптимизированное приложение. Для большинства api это не критично.</p>
  
  <p>Сборщик мусора не работает синхронно. Он останавливает все. Когда он начинает работать - все остальные стоят на паузе. Он должен во первых все посчитать, во вторых поменять ссылки, упаковать память. Там работы немеряно. Он ничего в процессах не портит, не влазиет ни в какой проект, он просто говорит "всем стоять", делает свое дело и потом говорит "работайте дальше".</p>
</article>

<article class="article">
  <h2>Области применения .net</h2>
  <p>Web, Mobile, Desktop, Microservices, Gaming, Machine Learning, Cloud, Internet of Things</p>

  <p>Где у нас .net может применяться. .net очень хорошо развивается, сейчас это уже приятая технология. Вместе с языками он приволок кучу стандартов. Большой спрос на .net разработчиков и в России и в мире. Особенно в тех местах где требуется бекенд писать. Там где раньше применялась только java. java тяжелый язык. А си шарп легкий язык. Технология .net стала везде расползаться. На нем можно писать и веб приложения и мобильные приложения. Раньше был сторонний проект Xamarin для написания мобильных приложений. Microsoft его выкупил, модернизировал и выпустил maui приложения. И мобильные приложения на maui технологии можно писать. Maui + Blazor можно веб приложения писать. Для тех команд, которые не хотят развивать фронтенд отдел и у них есть сильный бекенд отдел, то для них Blazor позволяет писать веб приложения. Десктоп можно писать, например, на WPF. Микросервисы - можно внедрять докер и писать гейминг, машинное обучение, облака с AWS azure, интернет вещей и т.д. Областей применения достаточно много.</p>

  <p>Пример применения Desktop - WinForms. Классическое windows приложение. Компоненты раскидываем с окне при помощи мышки. Щелкаем - получаем какое-то действие. Устанавливаем флажки на действия, например, enable, disable. И получаем такое приложение. Примерно такой подход был реализован в Delphi. Delphi подход мне например больше нравится, у них покрасивее сделано. Мне привычнее. Здесь тоже ничего но не так. Не так удобно, может дело вкуса. На WinForms я немного писал, на Delphi писал достаточно много. Поэтому могу сравнить.</p>

  <p>Пример применения Desktop - WPF. Можно делать приложения не только при помощи форм и окошек, но и при помощи специальных средств. Программируем на C#, а верстка делается на xml подобной верстке xaml. В отличие от раскидывания кнопок в WinForms, в WPF отрисовка декларативная - мы пишем код. В итоге можем красивае приложение получить. Microsoft Visual Studio написана как раз на WPF.</p>

  <p>WEB - ASP.NET WebForms. Это старая технология на aspx. Предполагает писать для веба так же как обычные приложения.</p>

  <p>WEB - ASP.Net MVC. Здесь новые технологии, легковесный фреймворк для того чтобы писать MVC (Model View Controller) приложения. Можно написать контроллер, привязать к нему модель. На базе шаблона и определенных правил будет сформирована реальная картинка в html. Без участия программиста, он будет работать непосредственно в браузере.</p>

  <p>WEB - ASP.Net Razor Pages. Развитием от MVC стал Razor Pages. Это альтернативный способ. Если в MVC мы идем от контроллера к view. То в Razor Pages все инкапсулировано внутрь страницы. У нас есть страница и есть обработчик. Как бы вернулись к WebForms. На самом деле инструмент интересен. Позволяет рисовать красивые простенькие технологии. И достаточно компактный. Мне нравится.</p>

  <p>WEB - ASP.Net WebAPI. В отличие от Razor Pages где с помощью html пользователю дается какая-то красота, в WebAPI пользователю никакая красота не дается, а дается набор методов. При помощи которых мы данные передаем, что-то делаем и данные возвращаем. Чаще всего сейчас это используется для того чтобы писать SPA приложения. Когда фронтенд написан на базе SPA фреймворка - vue, react, angular или blazor. И сервер является бекендом. Плюс на базе WebAPI можно сделать микросервис. Здесь специально фреймворк ASP.Net настроен таким образом, что он возвращает не странички а JSON. И кучу работы с программиста снимает.</p>

  <p>UWP (Universal Windows Program). Он не сильно стал популярным, поэтому не сильно интересен. Это разработка приложений под Windows 10 и выше. Это попытка сделать нативный язык, как на планшетах, но только для Windows.</p>

  <p>XAMARIN / MAUI. Сейчас вышел релиз MAUI, который делает на базе C# кода, компилирует его в нативный код, который запускается на айфоне, андроиде и виндовсфоне. Это кроссплатформенное приложение у которого есть одна кодовая база и два автоматически генерируемых направления. Для написания корпоративных систем, например, сбор отчетов, корпоративный чат, где не требуется оптимизация или внедрение в систему. Это вполне хороший бизнес продукт. Сейчас для мобилки есть куча других фреймворков. И react native например. XAMARIN берет c# код, трансформирует его в нативный iOS или android код и получается дистрибутив этого приложения в разных системах. Выкладывайте его с store и раздавайте.</p>

  <p>UNITY. Это написание игрушек. Здесь на C# обрабатывается вся логика. Получив из unity набор инструментов для работы со спрайтами, с моделями, с пересечением моделей, со звуком, с физикой, можете на C# писать логику игры, формочки рисовать и т.д.</p>
</article>

<article class="article">
  <h2>Что осталось за кадром</h2>
  <p>ML.Net (Machine learning)</p>
  <p>IoT (Intenet of Things)</p>
  <p>Cloud (Azure)</p>
  <p>Microservices</p>
  <p>и так далее</p>

  <p>Сейчас много где .net применяется. Работа с фреймворком .net и с C# достаточно прогрессивна и востребована. Если вы их выучите, проблем не будет с трудоустройством. Сейчас во многих компаниях базовый стек веб приложений сделан на .net. Это Касперский, Контур, Озон. Очень много серьезных крупных игроков и куча помельче они используют .net для того чтобы делать свой бизнес, что-то автоматизировать для себя. Не обязательно это софтверные конторы, которые делают что-то для кого-то. Может быть производственная компания, например, завод, которая автоматизирует у себя при помощи этих технологий. Вещь хорошая, рекомендую. Не пожалеете. Писать для .net на C# достаточно интересно и мне нравится.</p>
</article>

<article class="article">
  <h2>Вопросы?</h2>
  <p>Лекция сегодня закончилась. Есть ли какие-то вопросы? Пожелания? Что-то еще стоит поподробней рассказать? Вопросов нет. Тогда предлагаю перейти с вопросами в телеграм. Задавайте, будем разбирваться, что-то расскажу, объясню. Всем большое спасибо. Жду вас в следующий понедельник. Начнется версия по web api. Мы будем рассматривать более подробно этот фреймфорк. Из чего он состоит, как настраивается. И потом будет уже практика. Будет livecoding, готовьте свои ноутбуки. Будем пытаться вместе писать.</p>
</article>