<article class="article">
  <h1>Конспект методички ч.1</h1>
</article>


<div id="link-to-vgu2025cpp" class="btn-back">назад</div>


<article class="article">
  <p>Авсеева, Чернышов - ООП на языке C++. Часть 1. 2025. 76стр</p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p><a href="#p2">2 Введение в классы (14)</a></p>
  <p><a href="#p2.1">2.1 Структуры и объединения (14)</a></p>
  <p><a href="#p2.2">2.2 Понятие класса (18)</a></p>
  <p><a href="#p2.3">2.3 Конструкторы и деструкторы (26)</a></p>
  <p><a href="#p2.4">2.4 Конструкторы с параметрами, перегрузка конструкторов (31)</a></p>
</article>


<!-- 2 Введение в классы -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>2 Введение в классы</h3>

  <p>Класс представляет собой механизм для создания новых типов данных. Понятие класса произошло от двух других понятий - структура и объединение.</p>
</article>


<!-- 2.1 Структуры и объединения -->
<article class="article">
  <div class="anchor" id="p2.1"></div>
  <h3>2.1 Структуры и объединения</h3>

  <p><strong>Структура</strong> это упорядоченная совокупность данных различных типов, к которой можно обращаться как к единому целому. Можно в одном объявлении объявить и стрктурный тип и переменные этого типа. Имя типа может отсутствовать, тогда тип будет безымянным и в других частях программы нельзя будет объявлять данные этого типа. Переменными структурного типа могут быть переменные, указатели и массивы. Если переменные в объявлении отсутствуют, то объявляется только тип структуры.</p>

<pre>
struct Point {
  int x, y;
} point, *point_ptr, point_arr[3];
</pre>

  <p>Структуру Point можно использовать для создания типа Rectangle. Напишем три различные структуры для создания прямоугольника.</p>

  <p>Создадим прямоугольник координатами левого верхнего и правого нижнего угла.</p>

<pre>
struct Rect1 {
  Point p1;
  Point p2;
};
</pre>

  <p>Создадим прямоугольник координатами левого верхнего и правого нижнего угла, заданных в массиве.</p>

<pre>
struct Rect1 {
  Point p[2];
};
</pre>

  <p>Создадим прямоугольник координатой левого верхнего угла, высотой и шириной прямоугольника.</p>

<pre>
struct Rect1 {
  Point p;
  int width;
  int height;
};
</pre>

  <p>Создадим узел дерева, содержащий указатель на значение и указатели на левый и правый дочерний узел.</p>

<pre>
struct Value;
struct Node {
  Value *val;
  Node *left, *right;
};
</pre>

  <p>Членами структур могут быть <strong>битовые поля</strong>, когда в поле памяти переменной целого типа (int или unsigned int) размещается несколько целых данных меньшей длины.</p>

  <p>Пусть нам надо хранить два целых значения - 3-х битовое и 11-ти битовое. Их можно хранить в одной переменной типа int, используя битовые поля.</p>

<pre>
struct Bits {
  unsigned int type1:3;
  unsigned int type2:11;
};
</pre>

  <p><strong>Объединение</strong> можно определить как структуру, все компоненты которой размещаются в памяти с одного и того же адреса. Одновременно объединение может содержать только одно значение. Для значения выделяется память достаточная для хранения члена объединения наибольшего размера. Объединение позволяет обращаться к одному и тому же участку памяти по разным именам и интерпретировать его как значения разных типов.</p>

<pre>
union uword {
  unsigned int u;
  unsigned char b[2];
}
</pre>

  <p>Описания типов, структур и объединений могут быть достаточно большими. Их можно сократить, определив для них синонимы с помощью ключевого слова typedef.</p>

  <code>typedef struct {double re, im} COMPLEX;</code>
  <code>typedef int* PINT;</code>
  <code>COMPLEX ca, *pca;</code>
  <code>PINT pi;</code>

  <p>Члены структуры могут открытыми (объявленными после слова public) и закрытыми (объявленными после слова private). По умолчанию все члены структуры открытые.</p>
</article>


<!-- 2.2 Понятие класса -->
<article class="article">
  <div class="anchor" id="p2.2"></div>
  <h3>2.2 Понятие класса</h3>

  <p>Синтаксис класса похож на синтаксис структуры.</p>

<pre>
class Point {
  int x, y;
};
</pre>

  <p>Имя класса становится новым типом данных и используется для создания объектов класса.</p>
  <p>Члены класса могут открытыми (объявленными после слова public) и закрытыми (объявленными после слова private). По умолчанию все члены класса закрытые.</p>

  <p>Чтобы увидеть разницу между открытыми и закрытыми членами класса и структуры, напишем структуру Vector3D и класс Vector3D.</p>

<pre>
struct Vector3D {
  double mod();
  double projection (vector3D r);

private:
  double x, y, z;
};
</pre>

<pre>
class Vector3D {
  double x, y, z;

public:
  double mod();
  double projection (vector3D r);
};
</pre>

  <p>В языке C++ структуры остаются для поддержки совместимости с языком C.</p>

  <p>Мы описали класс Vector3d, но не описали функции вычисления длины вектора mod() и нахождения проекции одного вектора на другой projection(Vector2D r). Для определения методов вне класса, нужно после имени класса использовать два двоеточия :: операцию расширения области видимости.</p>

<pre>
double Vector::mod() {
  return sqrt (x*x + y*y + z*z);
}

double Vector3D::projection (Vector3D r) {
  return (x*r.x + y*r.y = z*r.z) / mod();
}
</pre>

  <p>После того, как создан класс и созданы методы класса, можно создавать и работать с объектами красса.</p>

<pre>
int main() {
  Vector3D a, b;
  double dMod, dPro;
  dMod = a.mod();
  dPro = b.projection(a);
}
</pre>

  <h4>Преимущество сокрытия свойств.</h4>

  <p>Пользователи класса получают доступ к свойствам и методам, объявленным с модификатором public, которые образуют открытый интерфейс класса.</p>
  <p>Объявим все переменные с модификатором public.</p>

<pre>
class Vector3D {
public:
  double x, y, z;
</pre>

<pre>
int main() {
  Vector3D a;
  a.x = 7;
  cout &lt;&lt; a.x &lt;&lt; '\n';
}
</pre>

  <p>Эта программа пока работает нормально, но если нам нужно изменить способ хранения переменных, например хранить их в массиве, то программу пришлось бы переписывать.</p>
  <p>При сокрытии переменных нужно знать какие методы явшяются доступными и как они вызываются. Нет необходимости знасть как класс реализован внутри.</p>
  <p>Обычно свойства класса делают приватными, а функции для доступа к этим свойствам - публичные.</p>

<pre>
class Vector3D {
private:
  double x, y, z;

public:
  void setX(double _x) {
    x = _x;
  }
  double getX() {
    return x;
  }
}
</pre>

<pre>
int main() {
  Vector3D a;
  a.setX(7);
  cout &lt;&lt; a.getX() &lt;&lt; '\n';
}
</pre>

  <p>Если теперь в реализации класса изменить способ хранения переменных x, y, z, то в основной программе ничего менять не нужно.</p>

<pre>
class Vector3D {
private:
  double vec[3];

public:
  void setX(double _x) {
    vec[0] = _x;
  }
  double getX() {
    return vec[0];
  }
}
</pre>

<pre>
int main() {
  Vector3D a;
  a.setX(7);
  cout &lt;&lt; a.getX() &lt;&lt; '\n';
}
</pre>

  <p>Обычно вектор задается сразу всеми координатами. Поэтому описание класса может выглядет так:</p>

<pre>
class Vector3D {
private:
  double x, y, z;

public:
  double mod() {
    return sqrt(x*x + y*y + z*z);
  }

  double projection(Vector3D r) {
    return (x*r.x + y*r.y + z*r.z) / mod();
  }

  void set(double _x, double _y, double _z) {
    x = _x;
    y = _y;
    z = _z;
  }
}
</pre>

  <p>Рассмотрим еще один пример, показывающий необходимость сокрытия свойств класса. Допустим в классе нужен список имен. Данный список можно реализовать с помощью различных конструкций: динамический массив, строки, array, vector, map, list и т.д. Однако при использовании класса нам не нужно знать детали его реализации.</p>
  <p>Классы с открытыми свойствами имеют ту же проблему, что и глобальные переменные. Нет контроля над тем, кто имеет к ним доступ и как их использует.</p>
  <p>Создадим класс для работы со строками</p>

<pre>
class MyString {
  char* s;
  int len;
}
</pre>

  <p>Две переменные, являющиеся полями класса, связаны между собой. Значение len должно соответствовать длине строки s. Изменение одной величины без изменения другой приведет к ошибкам. Поэтому правильно сделать эти переменные закрытыми и предоставлять пользователю только методы изменения полей.</p>

  <p>Если есть массив в публичной части класса, то пользователь может обратиться к несуществующему элементу массива, что приведет к ошибке.</p>

<pre>
class IntArray {
public:
  int m[10];
};
</pre>

<pre>
int main() {
  IntArray arr;
  arr.m[16] = 2;
}
</pre>

  <p>Но если мы напишем массив в приватной части класса, то пользователь будет использовать публичные методы для доступа к элементам массива. В этом методе нужно делать проверку на правильность.</p>

<pre>
class IntArray {
  int m[10];

public:
  void setValue(int index, int value) {
    if (index &lt; 0 || index >= 10) {
      return;
    }
    m[index] = value;
  }
}
</pre>
</article>


<!-- 2.3 Конструкторы и деструкторы -->
<article class="article">
  <div class="anchor" id="p2.3"></div>
  <h3>2.3 Конструкторы и деструкторы</h3>

  <p>При создании объекта автоматически вызывается конструктор для инициализации полей объекта. Конструктор это метод, имя которого совпадает с именем класса. Конструктор ничего не возвращает и при его описании не пишут слово void.</p>
  <p>Конструктор, который не имеет параметров или все параметры имеют значения по умолчанию, называется конструктором по умолчанию. Он вызывается когда пользователем не указаны значения для инициализации полей класса. В классе Vector3D конструктор по умолчанию может задать нулевой вектор</p>

<pre>
Vector3D() {
  x = y = z = 0;
}
</pre>

  <p>Деструктор это функция которая вызывается при удалении объекта. Если при создании объекта динамически выделялась память, то при удалении объекта ее нужно освободить. Локальные объекты удаляются когда они выходят из области видимости. Глобальные объекты удаляются при завершении программы. Для простых объектов (в которых поля инициализируются статически) деструктор не нужен, так как C++ выполнит очистку выделяемой для них памяти самостоятельно.</p>
  <p>Но если объект содержит любые внешние ресурсы (динамически выделенную память, файл, базу данных...), деструктор является идеальным решением, поскольку он выполняет действия с объектом перед его уничтожением.</p>
  <p>Если деструктор не определен, компилятор автоматически создает пустой деструктор.</p>

  <p>Деструктор может быть вызван и явным образом</p>
  <code>Vector3D a(1, 2, 3);</code>
  <code>a.~Vector3D();</code>

  <p>Конструктор и деструктор не могут быть описаны в закрытой части класса.</p>

<pre>
class Vector3D {
  double x, y, z;

public:
  Vector3D();
  ~Vector3D();

  double mod();
  double projection(Vector3D r);
  void set(double, double, double);
  void print();
};

// конструктор по умолчанию
Vector3D::Vector3D() {
  x = y = z = 0;
  cout &lt;&lt; "Constructor\n";
}

Vector3D::~Vector3D() {
  cout &lt;&lt; "Destructor\n";
}

double Vector3D::mod() {
  return sqrt (x*r.x + y*r.y + z*r.z) / mod();
}

double Vector3D::projection(Vector3D r) {
  return (x*r.x + y*r.y + z*r.z) / mod();
}

void Vector3D::set(double _x, double _y, double _z) {
  x = _x;
  y = _y;
  z = _z;
}

void Vector3D::print() {
  cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; ' ' &lt;&lt; z &lt;&lt; '\n';
}
</pre>

<pre>
int main() {
  Vector3D A;
  A.print();
  A.set(3,4,0);
  A.print();
  cout &lt;&lt; A.mod() &lt;&lt; '\n';
}
</pre>

  <p>Результат</p>
<pre>
Constructor
0 0 0
3, 4, 0
5.0
Destructor
</pre>

  <p>В прошлом примере деструктор можно было не писать, а использовать деструктор по умолчанию, который создает компилятор.</p>
  <p>Рассмотрим класс для работы с динамическим массивом.</p>

<pre>
class Massiv {
private:
  int *m;
  int len;

public:
  Massiv(int _len) {
    m = new int[_len];
    len = _len;
  }

  ~Massiv() {
    delete[] m;
  }

  void setValue(int index, int value) {
    m[index] = value;
  }

  int getValue(int index) {
    return m[index];
  }

  int getLen() {
    return len;
  }
};
</pre>

<pre>
int main() {
  Massiv arr(15);

  for (int i = 0; i &lt; 15; i++) {
    arr.setValue(i, i+1);
  }

  cout &lt;&lt; "Value of element 7 is " &lt;&lt; arr.getValue(7);
}
</pre>

  <p>Результат</p>
  <code>Value of element 7 is 8</code>
</article>


<!-- 2.4 Конструкторы с параметрами, перегрузка конструкторов -->
<article class="article">
  <div class="anchor" id="p2.4"></div>
  <h3>2.4 Конструкторы с параметрами, перегрузка конструкторов</h3>

  <p>Конструкторы могут иметь параметры. Для этого нужно добавить параметры в объявление и определение констуктора. Затем, при создании объекта, требуется задать параметры в качестве аргументов.</p>

<pre>
class Vector3D {
  double x, y, z;

public:
  Vector3D();
  Vector3D(double _x, double _y, double _z = 0);
};

Vector3D::Vector3D() {
  x = y = z = 0;
  cout &lt;&lt; "Constructor (0,0,0)\n";
}

Vector3D::Vector3D(double _x, double _y, double _z) {
  x = _x;
  y = _y;
  z = _z;
  cout &lt;&lt; "Constructor (x,y,z)\n";
}
</pre>

<pre>
int main() {
  Vector3D A;
  A.set(1, 2, 0);
  Vector3D B(3, 4, 5);
  Vector3D C(6, 7);
}
</pre>
</article>
