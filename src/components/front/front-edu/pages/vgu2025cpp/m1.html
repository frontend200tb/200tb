<article class="article">
  <h1>Конспект методички ч.1</h1>
</article>


<div id="link-to-vgu2025cpp" class="btn-back">назад</div>


<article class="article">
  <p>Авсеева, Чернышов - ООП на языке C++. Часть 1. 2024. 76стр</p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p><a href="#p2">2 Введение в классы (14)</a></p>
  <p><a href="#p2.1">2.1 Структуры и объединения (14)</a></p>
  <p><a href="#p2.2">2.2 Понятие класса (18)</a></p>
  <p><a href="#p2.3">2.3 Конструкторы и деструкторы (26)</a></p>
  <p><a href="#p2.4">2.4 Конструкторы с параметрами, перегрузка конструкторов (31)</a></p>
  <p><a href="#p2.5">2.5 Список инициализации членов класса (35)</a></p>
  <p><a href="#p3">3 Использование классов на практике (38)</a></p>
  <p><a href="#p3.1">3.1 Указатели и ссылки на объекты (38)</a></p>
  <p><a href="#p3.2">3.2 Указатель this (40)</a></p>
  <p><a href="#p3.3">3.3 Перегружаемые операторы (42)</a></p>
  <p><a href="#p3.4">3.4 Присваивание объектов (46)</a></p>
  <p><a href="#p3.5">3.5 Передача объектов в фугкцию и возвращение объекта. Конструктор копирования (52)</a></p>
  <p><a href="#p3.6">3.6 Встраиваемые функции (61)</a></p>
  <p><a href="#p3.7">3.7 Статические компоненты класса (63)</a></p>
  <p><a href="#p3.8">3.8 Композиция классов (65)</a></p>
  <p><a href="#p3.9">3.9 Вложенные классы (69)</a></p>
  <p><a href="#p4">Библиографический список (74)</a></p>
</article>


<!-- 2 Введение в классы -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>2 Введение в классы</h3>

  <p>Класс представляет собой механизм для создания новых типов данных. Понятие класса произошло от двух других понятий - структура и объединение.</p>
</article>


<!-- 2.1 Структуры и объединения -->
<article class="article">
  <div class="anchor" id="p2.1"></div>
  <h3>2.1 Структуры и объединения</h3>

  <p><strong>Структура</strong> это упорядоченная совокупность данных различных типов, к которой можно обращаться как к единому целому. Можно в одном объявлении объявить и стрктурный тип и переменные этого типа. Имя типа может отсутствовать, тогда тип будет безымянным и в других частях программы нельзя будет объявлять данные этого типа. Переменными структурного типа могут быть переменные, указатели и массивы. Если переменные в объявлении отсутствуют, то объявляется только тип структуры.</p>

<pre>
struct Point {
  int x, y;
} point, *point_ptr, point_arr[3];
</pre>

  <p>Структуру Point можно использовать для создания типа Rectangle. Напишем три различные структуры для создания прямоугольника.</p>

  <p>Создадим прямоугольник координатами левого верхнего и правого нижнего угла.</p>

<pre>
struct Rect1 {
  Point p1;
  Point p2;
};
</pre>

  <p>Создадим прямоугольник координатами левого верхнего и правого нижнего угла, заданных в массиве.</p>

<pre>
struct Rect1 {
  Point p[2];
};
</pre>

  <p>Создадим прямоугольник координатой левого верхнего угла, высотой и шириной прямоугольника.</p>

<pre>
struct Rect1 {
  Point p;
  int width;
  int height;
};
</pre>

  <p>Создадим узел дерева, содержащий указатель на значение и указатели на левый и правый дочерний узел.</p>

<pre>
struct Value;
struct Node {
  Value *val;
  Node *left, *right;
};
</pre>

  <p>Членами структур могут быть <strong>битовые поля</strong>, когда в поле памяти переменной целого типа (int или unsigned int) размещается несколько целых данных меньшей длины.</p>

  <p>Пусть нам надо хранить два целых значения - 3-х битовое и 11-ти битовое. Их можно хранить в одной переменной типа int, используя битовые поля.</p>

<pre>
struct Bits {
  unsigned int type1:3;
  unsigned int type2:11;
};
</pre>

  <p><strong>Объединение</strong> можно определить как структуру, все компоненты которой размещаются в памяти с одного и того же адреса. Одновременно объединение может содержать только одно значение. Для значения выделяется память достаточная для хранения члена объединения наибольшего размера. Объединение позволяет обращаться к одному и тому же участку памяти по разным именам и интерпретировать его как значения разных типов.</p>

<pre>
union uword {
  unsigned int u;
  unsigned char b[2];
}
</pre>

  <p>Описания типов, структур и объединений могут быть достаточно большими. Их можно сократить, определив для них синонимы с помощью ключевого слова typedef.</p>

  <code>typedef struct {double re, im} COMPLEX;</code>
  <code>typedef int* PINT;</code>
  <code>COMPLEX ca, *pca;</code>
  <code>PINT pi;</code>

  <p>Члены структуры могут открытыми (объявленными после слова public) и закрытыми (объявленными после слова private). По умолчанию все члены структуры открытые.</p>
</article>


<!-- 2.2 Понятие класса -->
<article class="article">
  <div class="anchor" id="p2.2"></div>
  <h3>2.2 Понятие класса</h3>

  <p>Синтаксис класса похож на синтаксис структуры.</p>

<pre>
class Point {
  int x, y;
};
</pre>

  <p>Имя класса становится новым типом данных и используется для создания объектов класса.</p>
  <p>Члены класса могут открытыми (объявленными после слова public) и закрытыми (объявленными после слова private). По умолчанию все члены класса закрытые.</p>

  <p>Чтобы увидеть разницу между открытыми и закрытыми членами класса и структуры, напишем структуру Vector3D и класс Vector3D.</p>

<pre>
struct Vector3D {
  double mod();
  double projection (vector3D r);

private:
  double x, y, z;
};
</pre>

<pre>
class Vector3D {
  double x, y, z;

public:
  double mod();
  double projection (vector3D r);
};
</pre>

  <p>В языке C++ структуры остаются для поддержки совместимости с языком C.</p>

  <p>Мы описали класс Vector3d, но не описали функции вычисления длины вектора mod() и нахождения проекции одного вектора на другой projection(Vector2D r). Для определения методов вне класса, нужно после имени класса использовать два двоеточия :: операцию расширения области видимости.</p>

<pre>
double Vector::mod() {
  return sqrt (x*x + y*y + z*z);
}

double Vector3D::projection (Vector3D r) {
  return (x*r.x + y*r.y = z*r.z) / mod();
}
</pre>

  <p>После того, как создан класс и созданы методы класса, можно создавать и работать с объектами красса.</p>

<pre>
int main() {
  Vector3D a, b;
  double dMod, dPro;
  dMod = a.mod();
  dPro = b.projection(a);
}
</pre>

  <h4>Преимущество сокрытия свойств.</h4>

  <p>Пользователи класса получают доступ к свойствам и методам, объявленным с модификатором public, которые образуют открытый интерфейс класса.</p>
  <p>Объявим все переменные с модификатором public.</p>

<pre>
class Vector3D {
public:
  double x, y, z;
</pre>

<pre>
int main() {
  Vector3D a;
  a.x = 7;
  cout &lt;&lt; a.x &lt;&lt; '\n';
}
</pre>

  <p>Эта программа пока работает нормально, но если нам нужно изменить способ хранения переменных, например хранить их в массиве, то программу пришлось бы переписывать.</p>
  <p>При сокрытии переменных нужно знать какие методы явшяются доступными и как они вызываются. Нет необходимости знасть как класс реализован внутри.</p>
  <p>Обычно свойства класса делают приватными, а функции для доступа к этим свойствам - публичные.</p>

<pre>
class Vector3D {
private:
  double x, y, z;

public:
  void setX(double _x) {
    x = _x;
  }
  double getX() {
    return x;
  }
}
</pre>

<pre>
int main() {
  Vector3D a;
  a.setX(7);
  cout &lt;&lt; a.getX() &lt;&lt; '\n';
}
</pre>

  <p>Если теперь в реализации класса изменить способ хранения переменных x, y, z, то в основной программе ничего менять не нужно.</p>

<pre>
class Vector3D {
private:
  double vec[3];

public:
  void setX(double _x) {
    vec[0] = _x;
  }
  double getX() {
    return vec[0];
  }
}
</pre>

<pre>
int main() {
  Vector3D a;
  a.setX(7);
  cout &lt;&lt; a.getX() &lt;&lt; '\n';
}
</pre>

  <p>Обычно вектор задается сразу всеми координатами. Поэтому описание класса может выглядет так:</p>

<pre>
class Vector3D {
private:
  double x, y, z;

public:
  double mod() {
    return sqrt(x*x + y*y + z*z);
  }

  double projection(Vector3D r) {
    return (x*r.x + y*r.y + z*r.z) / mod();
  }

  void set(double _x, double _y, double _z) {
    x = _x;
    y = _y;
    z = _z;
  }
}
</pre>

  <p>Рассмотрим еще один пример, показывающий необходимость сокрытия свойств класса. Допустим в классе нужен список имен. Данный список можно реализовать с помощью различных конструкций: динамический массив, строки, array, vector, map, list и т.д. Однако при использовании класса нам не нужно знать детали его реализации.</p>
  <p>Классы с открытыми свойствами имеют ту же проблему, что и глобальные переменные. Нет контроля над тем, кто имеет к ним доступ и как их использует.</p>
  <p>Создадим класс для работы со строками</p>

<pre>
class MyString {
  char* s;
  int len;
}
</pre>

  <p>Две переменные, являющиеся полями класса, связаны между собой. Значение len должно соответствовать длине строки s. Изменение одной величины без изменения другой приведет к ошибкам. Поэтому правильно сделать эти переменные закрытыми и предоставлять пользователю только методы изменения полей.</p>

  <p>Если есть массив в публичной части класса, то пользователь может обратиться к несуществующему элементу массива, что приведет к ошибке.</p>

<pre>
class IntArray {
public:
  int m[10];
};
</pre>

<pre>
int main() {
  IntArray arr;
  arr.m[16] = 2;
}
</pre>

  <p>Но если мы напишем массив в приватной части класса, то пользователь будет использовать публичные методы для доступа к элементам массива. В этом методе нужно делать проверку на правильность.</p>

<pre>
class IntArray {
  int m[10];

public:
  void setValue(int index, int value) {
    if (index &lt; 0 || index >= 10) {
      return;
    }
    m[index] = value;
  }
}
</pre>
</article>


<!-- 2.3 Конструкторы и деструкторы -->
<article class="article">
  <div class="anchor" id="p2.3"></div>
  <h3>2.3 Конструкторы и деструкторы</h3>

  <p>При создании объекта автоматически вызывается конструктор для инициализации полей объекта. Конструктор это метод, имя которого совпадает с именем класса. Конструктор ничего не возвращает и при его описании не пишут слово void.</p>
  <p>Конструктор, который не имеет параметров или все параметры имеют значения по умолчанию, называется конструктором по умолчанию. Он вызывается когда пользователем не указаны значения для инициализации полей класса. В классе Vector3D конструктор по умолчанию может задать нулевой вектор</p>

<pre>
Vector3D() {
  x = y = z = 0;
}
</pre>

  <p>Деструктор это функция которая вызывается при удалении объекта. Если при создании объекта динамически выделялась память, то при удалении объекта ее нужно освободить. Локальные объекты удаляются когда они выходят из области видимости. Глобальные объекты удаляются при завершении программы. Для простых объектов (в которых поля инициализируются статически) деструктор не нужен, так как C++ выполнит очистку выделяемой для них памяти самостоятельно.</p>
  <p>Но если объект содержит любые внешние ресурсы (динамически выделенную память, файл, базу данных...), деструктор является идеальным решением, поскольку он выполняет действия с объектом перед его уничтожением.</p>
  <p>Если деструктор не определен, компилятор автоматически создает пустой деструктор.</p>

  <p>Деструктор может быть вызван и явным образом</p>
  <code>Vector3D a(1, 2, 3);</code>
  <code>a.~Vector3D();</code>

  <p>Конструктор и деструктор не могут быть описаны в закрытой части класса.</p>

<pre>
class Vector3D {
  double x, y, z;

public:
  Vector3D();
  ~Vector3D();

  double mod();
  double projection(Vector3D r);
  void set(double, double, double);
  void print();
};

// конструктор по умолчанию
Vector3D::Vector3D() {
  x = y = z = 0;
  cout &lt;&lt; "Constructor\n";
}

Vector3D::~Vector3D() {
  cout &lt;&lt; "Destructor\n";
}

double Vector3D::mod() {
  return sqrt (x*r.x + y*r.y + z*r.z) / mod();
}

double Vector3D::projection(Vector3D r) {
  return (x*r.x + y*r.y + z*r.z) / mod();
}

void Vector3D::set(double _x, double _y, double _z) {
  x = _x;
  y = _y;
  z = _z;
}

void Vector3D::print() {
  cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; ' ' &lt;&lt; z &lt;&lt; '\n';
}
</pre>

<pre>
int main() {
  Vector3D A;
  A.print();
  A.set(3,4,0);
  A.print();
  cout &lt;&lt; A.mod() &lt;&lt; '\n';
}
</pre>

  <p>Результат</p>
<pre>
Constructor
0 0 0
3, 4, 0
5.0
Destructor
</pre>

  <p>В прошлом примере деструктор можно было не писать, а использовать деструктор по умолчанию, который создает компилятор.</p>
  <p>Рассмотрим класс для работы с динамическим массивом.</p>

<pre>
class Massiv {
private:
  int *m;
  int len;

public:
  Massiv(int _len) {
    m = new int[_len];
    len = _len;
  }

  ~Massiv() {
    delete[] m;
  }

  void setValue(int index, int value) {
    m[index] = value;
  }

  int getValue(int index) {
    return m[index];
  }

  int getLen() {
    return len;
  }
};
</pre>

<pre>
int main() {
  Massiv arr(15);

  for (int i = 0; i &lt; 15; i++) {
    arr.setValue(i, i+1);
  }

  cout &lt;&lt; "Value of element 7 is " &lt;&lt; arr.getValue(7);
}
</pre>

  <p>Результат</p>
  <code>Value of element 7 is 8</code>
</article>


<!-- 2.4 Конструкторы с параметрами, перегрузка конструкторов -->
<article class="article">
  <div class="anchor" id="p2.4"></div>
  <h3>2.4 Конструкторы с параметрами, перегрузка конструкторов</h3>

  <p>Конструкторы могут иметь параметры. Для этого нужно добавить параметры в объявление и определение констуктора. Затем, при создании объекта, требуется задать параметры в качестве аргументов.</p>

<pre>
class Vector3D {
  double x, y, z;

public:
  Vector3D();
  Vector3D(double _x, double _y, double _z = 0);
};

Vector3D::Vector3D() {
  x = y = z = 0;
  cout &lt;&lt; "Constructor (0,0,0)\n";
}

Vector3D::Vector3D(double _x, double _y, double _z) {
  x = _x;
  y = _y;
  z = _z;
  cout &lt;&lt; "Constructor (x,y,z)\n";
}
</pre>

<pre>
int main() {
  Vector3D A;
  A.set(1, 2, 0);
  Vector3D B(3, 4, 5);
  Vector3D C(6, 7);
}
</pre>

  <p>Перегруженный конструктор может содержать второй метод создания объекта. Конструктор по умолчанию и конструктор с параметрами это наиболее распространенный вариант перегрузки конструкторов. Иногда удобно оставить только один конструктор с параметрами, которые имеют значения по умолчанию. В этом случае будет только один метод создания объектов.</p>

<pre>
class Vector3D {
  double x, y, z;

public:
  Vector3D(double _x = 0, double _y = 0, double _z = 0);
};

Vector3D::Vector3D(double _x, double _y, double _z) {
  x = _x;
  y = _y;
  z = _z;
  cout &lt;&lt; "Constructor\n";
}
</pre>

<pre>
int main() {
  Vector3D A;
  Vector3D B(1,2,3);
}
</pre>
</article>


<!-- 2.5 Список инициализации членов класса -->
<article class="article">
  <div class="anchor" id="p2.5"></div>
  <h3>2.5 Список инициализации членов класса</h3>

  <p>Поля класса можно инициализировать в конструкторе через оператор присваивания. При этом сначала создаются x, y, z, затем выполняется тело конструктора, в котором этим переменным присваиваются значения.</p>

<pre>
class Vector3D {
  double x, y, z;

public:
  Vector3D();
};

Vector3D::Vector3D() {
  x = 0;
  y = 0;
  z = 0;
  cout &lt;&lt; "Constructor\n";
}
</pre>

  <p>Однако некоторые типы данных (именованные константы и ссылки) должны быть инициализированы сразу, непосредственно при их объявлении. Для решения этой проблемы существует метод инициализации полей класса через список инициализации вместо присваивания им значений после объявления.</p>
  <p>Инициализировать переменные можно двумя способами</p>
  <code>int a = 5; // копирующая инициализация</code>
  <code>int b(10); // прямая инициализация</code>

  <p>Список инициализации в конструкторе использует прямую инициализацию.</p>

<pre>
class Vector3D {
  double x, y, z;

public:
  Vector3D() : x(0), y(0), z(0) {
    cout &lt;&lt; "Constructor\n";
  }
};
</pre>

  <p>В конструкторе с параметрами также можно использовать список инициализации.</p>

<pre>
class Vector3D {
  double x, y, z;

public:
  Vector3D(double _x, double _y, double _z) : x(_x), y(_y), z(_z) {
    cout &lt;&lt; "Constructor\n";
  }
};
</pre>

  <p>Инициализировать константу в классе можно только в списоке инициализации, потому что константам нельзя присваивать значения после объявления.</p>

<pre>
class Values {
  const int val;

public:
  Values() : val(7) {}
};
</pre>
</article>


<!-- 3 Использование классов на практике -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>3 Использование классов на практике</h3>
</article>


<!-- 3.1 Указатели и ссылки на объекты -->
<article class="article">
  <div class="anchor" id="p3.1"></div>
  <h3>3.1 Указатели и ссылки на объекты</h3>

  <p>При работе с самим объектом доступ к его полям осуществляется через операцию точка ".". При работе с указателем на объект доступ к его полям осуществляется через операцию стрелочка "->". Для создания указателя на объект надо поставить звездочку "*" между типом объекта и его именем при объявлении. Для получения адреса объекта надо поставить амперсанд "&" перед указателем на объект. Для выделения памяти под новый объект используется оператор new.</p>

<pre>
int main() {
  Vector3D A(1,2,3);
  Vector3D* pA;
  pA = &amp;A;
  Vector3D* pB = new Vector3D(4,5,6);
  double dM = pA->mod();
  double dP = pA->projection(*pB);
}
</pre>

  <p>Ссылка это элемент, родственный указателю. Ссылка является скрытым указателем и всегда работает как другое, дополнительное имя переменной.</p>

  <p>Рассмотрим как передать в функцию указатель.</p>

<pre>
void toZero(Vector3D* vec) {
  vec->set(0,0,0);
}

int main() {
  Vector3D A(1,2,3);
  toZero(&A);
}
</pre>

  <p>То же самое можно сделать с помощью ссылки. Передадим в функцию ссылку.</p>

<pre>
void toZero(Vector3D& vec) {
  vec->set(0,0,0);
}

int main() {
  Vector3D A(1,2,3);
  toZero(A);
}
</pre>

  <p>Когда функция в качестве параметра принимает объект, то она создает его копию и работает с ней. Когда функция в качестве параметра принимает ссылку на объект, то она создает копию ссылки, которая ссылается на переданный объект и фактически работает с самим объектом. Передача в качестве параметра ссылки гарантироует что функция работает с самим объектом, а не с его копией.</p>
</article>


<!-- 3.2 Указатель this -->
<article class="article">
  <div class="anchor" id="p3.2"></div>
  <h3>3.2 Указатель this</h3>

  <p>Опять рассмотрим уже описанный класс Vector3D</p>

<pre>
class Vector3D {
  double x, y, z;

public:
  Vector3D(double _x = 0, double _y = 0, double _z = 0)
  : x(_x), y(_y), z(_z) {}

  double mod() {
    return sqrt (x*r.x + y*r.y + z*r.z) / mod();
  }

  double projection(Vector3D r) {
    return (x*r.x + y*r.y + z*r.z) / mod();
  }
};
</pre>

  <p>Для каждого объекта класса не создается копия метода класса. Каждый метод класса представлен в оперативной памяти в единственном экземпляре и в момент вызова получает один скрытый параметр - указатель на объект, для которого данный метод вызван. Этот указатель имеет имя <strong>this</strong>. Доступ к самому объекту в этом случае осуществляется с помощью операции разыменования *this.</p>

  <p>Создадим два объекта класса Vector3D и вызовем для одного из них метод projection.</p>

<pre>
int main() {
  Vector3D a(1,2,3);
  Vector3D b(4,5,6);

  double dPro = b.projection(a);
}
</pre>

  <p>Компилятор понимает что при вызове b.projection(a) метод projection вызывается для объекта b. Во время компиляции компилятор  конвертирует его в метод projection(&b, a). Теперь это стандартный вызов функции, в котором объект b передается в качестве первого параметра по ссылке.</p>
  <p>Поскольку при вызове метода компилятор видит два входных параметра, то и тело функции при компиляции меняется так, чтобы обрабатывать два параметра.</p>

<pre>
double projection(Vector3D* const this, Vector3D r) {
  return (this->x*r.x + this->y*r.y + this->z*r.z) / this->mod();
}
</pre>
</article>


<!-- 3.3 Перегружаемые операторы -->
<article class="article">
  <div class="anchor" id="p3.3"></div>
  <h3>3.3 Перегружаемые операторы</h3>

  <p>Рассмотрим простой пример</p>

<pre>
int i1, i2, i3;
long l1, l2, l3;
double d1, d2, d3;
i1 = i2 + i3;
l1 = l2 + l3;
d1 = d2 + d3;
</pre>

  <p>Во всех трех случаях сложения используется оператор "+". Но в каждом случае компилятор выполнит разный набор инструкций, зависящий от типа данных операндов. Оператор "+" имеет перегрузки для работы с разными типами данных.</p>
  <p>Программист, при создании новых типов данных, например с помощью классов, может перегружать встроенные операторы для их работы с новыми типами данных. Для этого в классе аналогично прототипу функции объявляется прототип оператора с добавлением ключевого слова operator.</p>

<pre>
class Vector3D {
  double x, y, z;

public:
  Vector3D();
  Vector3D(double _x, double _y, double _z);

  Vector3D operator+(const Vector3D& b);
  Vector3D& operator++();
  Vector3D operator++(int);
};

Vector3D Vector3D::operator+(const Vector3D& b) {
  return Vector3D(x + b.x, y + b.y, z + b.z);
}

Vector3D& Vector3D::operator++() {
  ++x, ++y, ++z;
  return *this;
}

Vector3D Vector3D::operator++(int) {
  Vector3D b(x,y,z);
  x++, y++, z++;
  return b;
}
</pre>

  <p>После того как написаны перегрузки операторов в калссе вектора, мы можем применять эти операторы к векторам в нашей программе.</p>

<pre>
int main() {
  Vector3D A(1, 1, 1) B, C;
  B = A;
  C = A + B; // C = A.operator+(B);
  ++A;
  A++;
}
</pre>

  <p>Операторы префиксный инкремент и постфиксный инкремент должны вызывать разные функции. Для решения этой проблемы для префиксного инкремена ++A компилятор вызывает функцию operator++(), а для постфиксного инкремента компилятор вызывает функцию operator++(int). Компилятор различает эти две формы и вызывает для них разные перегруженные функции. Чтобы создать другую сигнатуру для постфиксной версии, комплиятор передает в дополнительном аргументе int фиктивную константу.</p>

  <p>При передаче аргументов в перегруженные операторы нужно учитывать следующее:</p>
  <ul>
    <li>если объект, передаваемый в качестве аргумента, только читается, но не изменяется оператором, его следует передавать как ссылку на константу</li>
    <li>тип возвращаемого значения выбирается в зависимости от смысла оператора. Если оператор создает новый объект, то в качестве возвращаемого значения следует использовать этот объект.</li>
    <li>операторы инкремента и декремента изменяют объект и поэтому нельзя передавать его как константу. Префиксная форма возвращает значение объекта после его изменения, поэтому для нее логично возвращать *this в виде ссылки. Постфиксная форма возвращает значение объекта до изменения, поэтому в ней приходится создавать отдельный объект и изменять его.</li>
  </ul>

  <p>Существуют ограничения на перегрузку операторов:</p>
  <ul>
    <li>оператор должен уже существовать в языке.</li>
    <li>нельзя перегружать операторы для встроенных типов данных.</li>
    <li>нельзя перегружать операторы ".", ".*", "?:", "::" и символ препроцессора "#".</li>
  </ul>
</article>


<!-- 3.4 Присваивание объектов -->
<article class="article">
  <div class="anchor" id="p3.4"></div>
  <h3>3.4 Присваивание объектов</h3>

  <p>Один объект можно присвоить другому, если оба объекта имеют одинаковый тип. Когда объект A присваивается объекту B, происходит побитовое копирование всех элементов данных A в элементы данных B. Если объекты имеют разные типы, компилятор выдаст ошибку.</p>
  <p>Если два одинаковых объект имеют разные типы, то их нельзя присваивать друг другу.</p>
  <p>Если объекты содержат указатели, то происходит поверхностное копирование, то есть копируется указатель на адрес в памяти. Причем новый адрес для нового объекта не выделяется. При этом переменная по этому адресу одновременно меняется в обоих объектах.</p>

<pre>
class Pair {
  int a;
  int* b;

public:
  Pair() {
    a = 0;
    b = new int;
  }
  void set(int _a, int _b) {
    a = _a;
    *b = _b;
  }
  int geta() {
    return a;
  }
  int getb() {
    return *b;
  }
}
</pre>

<pre>
int main() {
  Pair c1, c2;
  c1.set(10, 11);
  c2 = c1;
  c1.set(100,111);

  cout &lt;&lt; "c1.b = " &lt;&lt; c1.getb() &lt;&lt; endl;
  cout &lt;&lt; "c2.b = " &lt;&lt; c2.getb() &lt;&lt; endl;
}
</pre>

  <p>В результате *c1.b = 111 и *c2.b = 111.</p>
  <p>Для решения этой проблемы перегружают оператор присваивания, в котором правильно присваивают переменные указатели, выделяя для них новую память. Оператор присваивания и конструктор копирования выполняют идентичную работу: оба копируют значения из одного объекта в другой. Отличие лишь в том, что конструктор копирования используется только при инициализации новых объектов, а оператор присваивания используется для уже существующих объектов.</p>

<pre>
class Pair {
  int a;
  int* b;

public:
  Pair& operator=(const Pair& p) {
    // проверка что объект
    // присваивается самому себе
    if (this == &p) {
      return *this;
    }
    a = p.a;
    *b = *(p.b);
    return this;
  }
};
</pre>

  <p>Рассмотрим пример неправильной перегрузки оператора "+="</p>

<pre>
class Pair {
  int a;
  int* b;

public:
  Pair(int _a = 0, int _b = 0) {
    a = _a;
    b = new int;
    *b = _b;
    cout &lt;&lt; "Constructor\n";
    print();
  }

  ~Pair() {
    cout &lt;&lt; "Destructor\n";
    print();
    delete b;
  }

  void print() {
    cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; " b = " &lt;&lt; b
         &lt;&lt; " *b = " &lt;&lt; *b &lt;&lt; endl;
  }

  Pair& operator+=(const Pair& p) {
    if (this == &p) {
      return *this;
      a += p.a;
      *b += *p.b;
      return *this;
    }
  }
};
</pre>

<pre>
int main() {
  Pair A(1, 2);
  A.print();
  A += A;
  cout &lt;&lt; "_________\n";
  A.print();
}
</pre>

  <p>После операции A += A мы рассчитываем получить (2,4), но вместо этого получаем (1,2).</p>
  <p>В результате после операции "+=" значение объекта не изменится, потому что перегруженный оператор видит что это тот же самый объект и возвращает его ничего с ним не делая. В данном случае такая проверка была не нужна, чтобы оператор работал правильно и мог на входе получать тот же объект.</p>

  <p>Рассмотрим еще один пример неправльной перегрузки.</p>

<pre>
class MyString {
  char* m;
  int len;

public:
  MyString(const char* _m = "", int _len = 0) : len(_len) {
    if (!_len) {
      m = 0;
    } else {
      m = new char[_len];
    }
    for (int i = 0; i &lt; _len; i++) {
      m[i] = _m[i];
    }
  }

  MyString& operator=(const MyString& str);

  void print() {
    cout &lt;&lt; m &lt;&lt; endl;
  }
}

// неверный вариант перегрузки
Mystring& MyString::operator=(const MyString& str) {
  // Если m имеет значение, то удаляем это значение
  if (m) {
    delete[] m;
  }
  len = str.len;
  m = new char[str.len];
  for (int i = 0; i &lt; str.len; i++) {
    m[i] = str.m[i];
  }
  return *this;
}
</pre>

<pre>
int main() {
  MyString A("Anton", 7);
  A = A;
  A.print();
}
</pre>

  <p>При выполнении данной программы в момент присваивания A = A, вызовется перегруженный оператор присваивания, который сразу проверит, что оба объекта являются одним и тем же объектом. Если это так, то произойдет удаление значения, чтобы не случилась утечка памяти. Значение объекта A удалится, но объект str имеет тот же адрес памяти, что и A. Поэтому str.m станет висячим указателем. То есть указателем на несуществующую память. При попытке обратиться по этому указателю либо получим мусорные данные, либо программа завершится с ошибкой.</p>
  <p>Все операторы присваивания изменяют левосторонний операнд. Чтобы результат присваивания мог использоваться в цепочках вида a = b = c, оператор доолжен вернуть ссылку на левосторонний операнд. Значит возвращаемое значение должно быть ссылкой на объект, не являющийся константной.</p>

  <p>Пример с трехмерным вектором</p>

<pre>
class Vector3D {
  double x, y, z;

public:
  Vector3D();
  Vector3D(double _x, double _y, double _z);
  Vector3D& operator=(const Vector3D& b);
  Vector3D& operator+=(const Vector3D& b);
};

Vector3D& Vector3D::operator=(const Vector3D& b) {
  if (this == &b) {
    return *this;
  }
  x = b.x;
  y = b.y;
  z = b.z;
  return *this;

  Vector3D& Vector3D::operator+=(const Vector3D& b) {
    x += b.x;
    y += b.y;
    z += b.z;
    return *this;
  }
}
</pre>
</article>


<!-- 3.5 Передача объектов в фугкцию и возвращение объекта. Конструктор копирования -->
<article class="article">
  <div class="anchor" id="p3.5"></div>
  <h3>3.5 Передача объектов в фугкцию и возвращение объекта. Конструктор копирования</h3>

  <p>В качетстве аргументов в функцию можно передавать не только переменные но и объекты. В языке C++ все аргументы передаются по значению. Это означает что внутри функции создается копия аргумента и только к этой копии можно обратиться внутри функции.</p>
  <p>При передаче объекта в функцию появляется новый объект. Когда работа функции завершится, то этот новый объект (копия аргумента) удаляется. Создание, изменение и удаление копии объекта внутри функции не должно влиять на сам объект.</p>

<pre>
class Pair {
  int a, b;

public:
  Pair(int _a = 0, int _b = 0) : a(_a), b(_b) {
    cout &lt;&lt; "Constructor\n";
    print();
  }

  ~Pair() {
    cout &lt;&lt; "Destructor\n";
    print();
  }

  void print() {
    cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt;
    " b = " &lt;&lt; b &lt;&lt; endl;
  }
};
</pre>

<pre>
void f(Pair obj) {
  cout &lt;&lt; "Function\n";
}

int main() {
  Pair A(1, 2);
  cout &lt;&lt; "___________\n";
  f(A);
  cout &lt;&lt; "___________\n";
}
</pre>

  <p>Результат</p>

<pre>
Constructor
a = 1 b = 2
___________
Function
Destructor
a = 1 b = 2
___________
Destructor
a = 1 b = 2
</pre>

  <p>Конструктор вызывается только один раз. Это происходит при создании объекта. Деструктор вызывается два раза - один раз для копии, второй раз для самого объекта. Если деструктор освобождает динамически выделенную память, то может возникнуть проблема из за того что он вызывается два раза.</p>
  <p>Если объект содержит указатель на динамически выделенную память, то при копировании создается объект, указывающий на ту же область памяти. Когда деструктор копии освобождает память, то объект указывает на освобожденную память, к которой уже не имеет доступа. Объект при этом разрушается.</p>

<pre>
class Pair {
  int a;
  int* b;

public:
  Pair (int _a = 0, int _b = 0) {
    a = _a;
    b = new int;
    *b = _b;
    cout &lt;&lt; "Constructor\n";
    print();
  }
  ~Pair() {
    cout &lt;&lt; "Destructor\n";
    print();
    delete b;
  }

  void print() {
    cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; " b = "
    &lt;&lt; b &lt;&lt; " *b = " &lt;&lt; *b &lt;&lt; endl;
  }
};
</pre>

<pre>
void f(Pair obj) {
  cout &lt;&lt; "Function\n";
}

int main() {
  Pair A(1, 2);
  cout &lt;&lt; "___________\n";
  f(A);
  cout &lt;&lt; "___________\n";
  A.print();
}
</pre>

  <p>В итоге программа завершится с ошибкой.</p>

<pre>
Constructor
a = 1 b = 008B01F0 *b = 2
___________
Function
Destructor
a = 1 b = 008B01F0 *b = 2
___________
a = 1 b = 008B01F0 *b = -890909988
Destructor
a = 1 b = 008B01F0 *b = 7
</pre>

  <p>Конструктор по прежнему срабатывает один раз при создании объекта A. При выходе из функции срабатывает деструктор для копии объекта, который удаляет значение *b которое было связано с указателем b. При завершении программы срабатывает деструктор для объекта, который пытается освободит память, выделенную для указателя b, что приводит к ошибке, эта память уже занята другими данными.</p>
  <p>Похожая проблема возникает когда из функции необходимо вернуть объект. Возвращаемый тип у функции должен иметь тип класса и объект нужно возвращать в операторе return. Однако если объект содержит динамически выделенную память и деструктор, то при выходе из функции объект может неожиданно разрушиться.</p>

<pre>
class Pair {
  int a, b;

public:
  Pair(int _a = 0, int _b = 0) : a(_a), b(_b) {
    cout &lt;&lt; "Constructor\n";
    print();
  }
  ~Pair() {
    cout &lt;&lt; "Destructor\n";
    print();
  }
  void print() {
    cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt;
    " b = " &lt;&lt; b &lt;&lt; endl;
  }
};
</pre>

<pre>
Pair f() {
  cout &lt;&lt; "Function\n";
  Pair obj(1, 2);
  return obj;
}

int main() {
  Pair A;
  cout &lt;&lt; "_________\n";
  A(f);
  cout &lt;&lt; "_________\n";
}
</pre>

  <p>Результат</p>

<pre>
Constructor
a = 0 b = 0
____________
Function
Constructor
a = 1 b = 2
Destructor
a = 1 b = 2
Destructor
a = 1 b = 2
___________
Destructor
a = 1 b = 2
</pre>

  <p>Конструктор срабатывает два раза: для объекта A и для объекта obj. Деструктор срабатывает три раза. После вызова функции в ней создается временный объект, который она возвращает. В момент завершения функции срабатывает первый деструктор для временного объекта. Второй и третий раз деструктор вызывается при завершении программы для объектов A и obj.</p>
  <p>Когда деструктор возвращает динамически выделенную память для временного объекта, то она разрушается и для возвращенного объекта, поскольку указатели в них указывают на одну и ту же память.</p>
  <p>Для решения этой проблемы надо использовать <strong>конструктор копирования</strong>. Конструктор копирования позволяет точно определить порядок создания копии объекта. Конструктор копирования вызывается всякий раз, когда создается копия объекта. Мы рассмотрели два таких случая. Во-первых, при передаче объекта в качестве параметра функции. Во-вторых, при создании временного объекта, когда функция должна возвратить объект. Третий случай это когда один объект инициализируется другим объектом.</p>

<pre>
class Pair {
  int a;
  int* b;

public:
  Pair(int _a = 0, int _b = 0) {
    a = _a;
    b = new int;
    *b = _b;
    cout &lt;&lt; "Constructor\n";
    print();
  }
  Pair(const Pair& obj) {
    a = obj.a;
    b = new int(*obj.b);
    cout &lt;&lt; "Copy constructor\n";
    print();
  }
  ~Pair() {
    cout &lt;&lt; "Destructor\n";
    print();
    delete b;
  }
  void print() {
    cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; " b = "
    &lt;&lt; b &lt;&lt; " *b = " &lt;&lt; *b &lt;&lt; endl;
  }
};
</pre>

<pre>
void f(Pair obj) {
  cout &lt;&lt; "Function\n";
  obj.print();
}

void main() {
  Pair A(1, 2);
  Pair B = A;
  cout &lt;&lt; "___________\n";
  A.print();
  B.print();
  cout &lt;&lt; "___________\n";
}
</pre>

  <p>Результат</p>

<pre>
Constructor
a = 1 b = 00AD2E30 *b = 2
Copy constructor
a = 1 b = 00AD2E20 *b = 2
____________
a = 1 b = 00AD2E30 *b = 2
a = 1 b = 00AD2E20 *b = 2
____________
Destructor
a = 1 b = 00AD2E30 *b = 2
Destructor
a = 1 b = 00AD2E20 *b = 2
</pre>

  <p>Создадим класс Array для работы с массивом целых чисел, в котором проверяется и недопускается выход за границы массива. Поскольку память для массива выделяется с помощью оператора new, то для инициализации одного объекта другим объектом предоставляется конструктор копирования.</p>

<pre>
class Array {
  int *p;
  int size;

public:
  Array(int sz) {
    p = new int[sz];
    if (!p) {
      exit(1);
    }
    size = sz;
  }
  ~Array() {
    delete[] p;
  }
  Array(const Array &a); // конструктор копирования
  void put(int i, int j) {
    if (i >= 0 && i &lt; size) {
      p[i] = j;
    }
  }
  int get (int i) {
    return p[i];
  }
};

Array::Array(const Array &a) {
  p = new int[a.size];
  if (!p) {
    exit(1);
  }
  for (int i = 0; i &lt; a.size; i++) {
    p[i] = a.p[i];
  }
}
</pre>

<pre>
int main() {
  Array num(10);
  for (int i = 0; i &lt; 10; i++) {
    num.put(i, i);
  }
  for (int i = 9; i >= 0; i--) {
    cout &lt;&lt; num.get(i);
  }
  cout &lt;&lt; '\n';

  Array x(num);
  for (int i = 0; i &lt; 10; i++) {
    cout &lt;&lt; x.get(i);
  }
}
</pre>

  <p>Когда объект num используется для инициализации объекта x, то вызывается конструктор копирования, выделяющий новую память, начальный адрес которой помещается в x.p, а затем содержаие массива num копируется в массив объекта x. Таким образом, объекты num и x содержат массивы с одинаковыми значениями, но расположенными в разных областях памяти. Без конструктора копирования использовался бы констурктор по умолчанию, который путем побитового копирования создал бы новый массив в той же области памяти что и старый.</p>
  <p>Теперь, при использовании конструктора копирования можно смело передавать объекты в качестве параметров функций и возвращать объекты из функции. При этом количество вызовов конструкторов будт совпадать с количеством вызовов деструкторов.</p>
</article>


<!-- 3.6 Встраиваемые функции -->
<article class="article">
  <div class="anchor" id="p3.6"></div>
  <h3>3.6 Встраиваемые функции</h3>

  <p>Снова рассмотрим класс Vector3D.</p>

<pre>
class Vector3D {
  double x, y, z;

public:
  double mod() {
    return sqrt(x*x + y*y + z*z);
  }
  double projection(Vector3D r) {
    return (x*r.x + y*r.y + z*r.z) / mod();
  }
  Vector3D operator+(const Vector3D &b);
};

Vector3D Vector3D::operator+(const Vector3D &b) {
  return Vector3D(x + b.x, y + b.y, z + b.z);
}
</pre>

  <p>Методы класса можно писать внутри класса. Методы mod и projection написаны внутри класса. Можно поместить прототип метода внутри класса, а его определение написать вне класса, как у оператора "+".</p>
  <p>Первый способ используется для простых и коротких методов, которые не предполагается изменять. Описание классов помещают в заголовочные файлы, которые включаются в программу с помощью директивы #include. В этом случае компилятор генерирует машинные инструкции, которые непосредственно вставляются в текст. Это снижает затраты на их исполненияа, поскольку нет механизма вызова функций и возврата из функции. То есть такие методы становятся inline или встраиваемыми.</p>
  <p>Второй способ используется для сложных методов. Затрачивается время на вызов таких функций и возврат из них. Однако при добавлении ключевого слова inline они будут себя вести также как и в первом случае.</p>

<pre>
inline Vector3D Vector3D::operator+(const Vector3D &b) {
  return Vector3D(x + b.x, y + b.y, z + b.z);
}
</pre>

  <p>Теперь оператор "+" станет встраиваемой функцией.</p>
  <p>inline не является командой для компилятора, это просьба сделать метод встраиваемым. Компилятор сам решает делать функцию встраиваемой или нет.</p>
</article>


<!-- 3.7 Статические компоненты класса -->
<article class="article">
  <div class="anchor" id="p3.7"></div>
  <h3>3.7 Статические компоненты класса</h3>

  <p>Переменные и функции, объявленные вне класса или функции с описателем static, имеют область действия, ограниченную файлом, в котором они объявлены.</p>
  <p>Переменные с описателем static, объявленные внутри функции имеют область действия, ограниченную функцией, в которой они объявлены, но сохраняют свои значения после выхода из функции и инициализируются только при первом обращении к функции.</p>
  <p>Поля класса, объявленные с описателем static являются общими для всех объектов этого класса и размещаются в памяти отдельно от данных каждого объекта.</p>
  <p>К статическим полям класса можно обратиться по имени класса или по имени объекта класса. К статическим полям класса можно обращаться до создания объектов класса. Однако статическое поле класса обязательно должно быть инициализировано вне описания класса.</p>

<pre>
class TBase {
  static int nw;
  int size;
  int count;
  int maxCount;
  int delta;
};

int TBase::nw = 1;
</pre>

  <p>Если описание класса производится в заголовочном файле, то инициализация статической переменной класса помещается в файл .cpp содержащий описание методов класса. Если класс определен непосредственно в файле с кодом, то инициализация статической переменной класса производится сразу под классом.</p>
  <p>Если статические поля объявлены как private, то для доступа к ним можно использовать статические методы, которые могут вызываться до создания экземпляров этого класса и имеют доступ только к статическим полям класса.</p>

<pre>
class X {
  int x1, x2;
  static int sx1, sx2;

public:
  static void fsx(int _sx1, int _sx2) {
    sx1 = _sx1;
    sx2 = _sx2;
  }
};

int X::sx1 = 1;
int X::sx2 = 2;
</pre>

<pre>
int main() {
  X::fsx(3, 4);
}
</pre>
</article>


<!-- 3.8 Композиция классов -->
<article class="article">
  <div class="anchor" id="p3.8"></div>
  <h3>3.8 Композиция классов</h3>

  <p><strong>Композиция</strong> это использование объектов существующих классов внутри новых классов.</p>
  <p>Напишем класс X, который нам нужно многократно использовать.</p>

<pre>
class X {
  int i;

public:
  X() { i = 0; }
  void set(int ii) { i = ii; }
  int read() { return i; }
  int permute() { return i = i * 47; }
};
</pre>

  <p>Напишем класс Y, в котором объявлена переменная класса X.</p>

<pre>
class Y {
  int i;

public:
  X x; // внутренний объект
  Y() { i = 0; }
  void f(int ii) { i = ii; }
  int g() { return i; }
};
</pre>

<pre>
int main() {
  Y y;
  y.f(47);
  y.x.set(37); // обращение к внутреннему объекту
}
</pre>

  <p>На практике внутренние объекты объявляются закрытыми, доступ к ним предоставляется методами в соответствующем классе, что позволяет изменять реализацию открытого интерфейса нового класса (называемого <strong>композитным</strong>).</p>

<pre>
class Y {
  int i;
  X x;

public:
  Y() {i = 0; }
  void f(int ii) { i = ii; x.set(ii); }
  int g() { return i * x.read(); }
  void permute() { x.permute(); }
};
</pre>

<pre>
int main() {
  Y y;
  y.f(47);
  y.permute();
}
</pre>

  <p>В приведенном примере функция внутреннего объекта permute() переносится в интерфейс композитного класса, а остальные функции класса X используются в функциях класса Y.</p>

  <p>Рассмотрим класс Car</p>

<pre>
class Engine {
public:
  void start() {}
  void rev() {}
  void stop() {}
};

class Wheel {
public:
  void inflate(int psi) {}
};

class Window {
public:
  void rollup() {}
  void rolldown() {}
};

class Door {
public:
  Window window;
  void open() {}
  void close() {}
};

class Car {
public:
  Engine engine;
  Wheel wheel[4];
  Door left, right;
};
</pre>

<pre>
int main() {
  Car car;
  car.left.window.rollup();
  car,wheel[0].inflate(72);
}
</pre>

  <p>Композитный класс Car объявляет внутренние объекты открытыми.</p>
</article>


<!-- 3.9 Вложенные классы -->
<article class="article">
  <div class="anchor" id="p3.9"></div>
  <h3>3.9 Вложенные классы</h3>

  <p>Класс, объявленный внутри другого класса, называется <strong>вложенным классом</strong>. Вложение не создает член класса, а определяет тип, который известен лишь локально в содержащем его классе. Вложенные классы создаются как вспомогательные при реализации другого класса, чтобы избежать конфликта имен.</p>

  <p>Рассмотрим класс Queue, реализующий очередь.</p>

<pre>
class Queue {
private:
  struct Node {
    Item item;
    Node* next;
  }
};
</pre>

  <p>Вложенная структура похожа на вложенный класс, но не имеет всех возможностей класса, например нет заданного конструктора.</p>
  <p>Объекты Node создаются только в методе добавления в очередь.</p>

<pre>
bool Queue::enqueuer(const Item& item) {
  if (isfull()) {
    // если очередь заполнена
    return false
  }
  Node* add = new Node;
  add->item = item;
  add->next = NULL;
}
</pre>

  <p>В этом коде после создания объекта Node его переменным присваиваются значения. Такие действия уместнее выполнять в конструкторе. Добавим конструктор в класс Queue.</p>

<pre>
class Queue {
  class Node {
  public:
    Item item;
    Node* next;
    Node(const Item& i) : item(i), next(0) {}
  };
};

bool Queue::enqueuer(const Item& item) {
  if (isfull()) {
    return false;
  }
  Node* add = new Node(item);
}
</pre>

  <p>В коде метода enqueuer теперь используется конструктор, что делает метод короче и надежнее.</p>
  <p>В данном примере конструктор описан при объявлении класса. Если потребуется определить его вне класса, то нужно учитывать, что класс Node содержится внутри класса Queue. Это делается с помощью двух операций расширения области видимости.</p>
  <code>Queue::Node::Node(const Item& i) : item(i), next(0) {}</code>

  <p>Для доступа к вложенному классу надо помнить 2 вещи:</p>
  <ol>
    <li>Место объявления вложенного класса определяет его область видимости. Только в области видимости могут создаваться объекты этого класса.</li>
    <li>Доступ к свойствам и методам определяют модификаторы private, protected, public.</li>
  </ol>
  <p>Если вложенный класс объявлен в закрытом разделе базового класса, то он известен только этому классу и неизвестен извне, а также неизвестен его наследникам.</p>
  <p>Если вложенный класс объявлен в защищенном разделе базового класса, то он известен этому классу и его наследникаи и неизвестен извне.</p>
  <p>Если вложенный класс объявлен в открытом разделе базового класса, то для доступа к нему вне базового класса необходимо использовать операцию расширения области видимости (::).</p>
  <code>Queue::Node node;</code>

  <p>Если класс оказывается в области видимости, вступают в действие правила управления доступом к нему. Все объекты вложенного класса обычно делают открытыми, для доступа к ним из базового класса. Это не вредит остальной программе, так как все равно вложенный класс виден только внутри базового.</p>
</article>


<!-- Библиографический список -->
<article class="article">
  <div class="anchor" id="p4"></div>
  <h3>Библиографический список</h3>

  <ol>
    <li>Павловская. C/C++. Процедурное и объектно-ориентированное программирование. 2015. 496с</li>
    <li>Шилдт. Самоучитель C++. 1997. 512с</li>
    <li>Бабэ. Просто и ясно о Borland C++. Версии 4.0 и 4.5. 1997. 512с</li>
    <li>Страуструп. Язык программирования C++. 1995. 400с</li>
    <li>Клочков. Введение в объектно-ориентированное программирование. 1995. 70с</li>
    <li>Элиас. Справочное руководство по языку C++ с комментариями. 1992. 371с</li>
    <li>Керниган, Ритчи. Язык программирования Си. 1989. 428с</li>
    <li>Ирэ Пол. Объектно-ориентированное программирование с использованием C++. 1995. 386с</li>
  </ol>
</article>
