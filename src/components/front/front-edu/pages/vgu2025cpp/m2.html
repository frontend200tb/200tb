<article class="article">
  <h1>Конспект методички ч.2</h1>
</article>


<div id="link-to-vgu2025cpp" class="btn-back">назад</div>


<article class="article">
  <p>Авсеева, Чернышов - ООП на языке C++. Часть 2. 2024. 80стр</p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p><a href="#p4">4 Наследование в языке C++ (3)</a></p>
  <p><a href="#p4.1">4.1 Модификаторы наследования (3)</a></p>
  <p><a href="#p4.2">4.2 Конструкторы и деструкторы при наследовании (9)</a></p>
  <p><a href="#p4.3">4.3 Пример построения классов при наследовании (14)</a></p>
  <p><a href="#p4.4">4.4 Совместимость типов при наследовании (20)</a></p>
  <p><a href="#p5">5 Виртуальные методы (23)</a></p>
  <p><a href="#p5.1">5.1 Раннее и позднее связывание (23)</a></p>
  <p><a href="#p5.2">5.2 Виртуальные функции (27)</a></p>
  <p><a href="#p5.3">5.3 Применение виртуальных функций при использовании указателей на базовые классы (29)</a></p>
  <p><a href="#p5.4">5.4 Виртуальные деструкторы (31)</a></p>
  <p><a href="#p5.5">5.5 Динамическое приведение типов (34)</a></p>
  <p><a href="#p5.6">5.6 Абстрактные классы (40)</a></p>
  <p><a href="#p6">6 Дружественные функции (42)</a></p>
  <p><a href="#p6.1">6.1 Доступ к защищенным элементам класса (42)</a></p>
  <p><a href="#p6.2">6.2 Переопределение операторов с помощью дружественных функций (46)</a></p>
  <p><a href="#p7">7 Шаблоны (параметризованные типы) (50)</a></p>
  <p><a href="#p7.1">7.1 Шаблоны функций (51)</a></p>
  <p><a href="#p7.2">7.2 Отождествление типов аргументов в шаблонах (55)</a></p>
  <p><a href="#p7.3">7.3 Шаблоны классов (57)</a></p>
  <p><a href="#p7.4">7.4 Шаблоны классов: не только для типов (60)</a></p>
  <p><a href="#p7.5">7.5 Наследование в шаблонах классов (64)</a></p>
  <p><a href="#p8">8 Методология программирования (65)</a></p>
  <p><a href="#p8.1">8.1 Декомпозиция и абстракция (66)</a></p>
  <p><a href="#p8.2">8.2 Абстракция через параметризацию (68)</a></p>
  <p><a href="#p8.3">8.3 Абстракция через спецификацию (69)</a></p>
  <p><a href="#p8.4">8.4 Процедурная абстракция (71)</a></p>
  <p><a href="#p8.5">8.5 Абстракция данных (73)</a></p>
  <p><a href="#p8.6">8.6 Классы операций (75)</a></p>
  <p><a href="#p8.7">8.7 Полнота (75)</a></p>
</article>


<!-- 4 Наследование в языке C++ -->
<article class="article">
  <div class="anchor" id="p4"></div>
  <h3>4 Наследование в языке C++</h3>

</article>


<!-- 4.1 Модификаторы наследования -->
<article class="article">
  <div class="anchor" id="p4.1"></div>
  <h3>4.1 Модификаторы наследования</h3>

  <p>Когда один класс наследуется другим, первый из них называется <strong>базовым или родительским</strong> классом, а класс-наследник называется <strong>производным, потомком или дочерним</strong> классом.</p>

<pre>
// базовый класс
class Parent {};

// производный класс
class Child : public Parent {};
</pre>

  <p>При определении класса-потомка за его именем следует разделитель-двоеточие ":", затем необязытельный модификатор наследования и имя родительского класса. По умолчанию модификатор наследования privte.</p>
  <p>Модификатор наследования определяет видимость полей и методов класса родителя для самого класса потомка и его будущих наследников. Модификатор protected открывает доступ наследникам и дружественным класса.</p>

  <p>Рассмотрим пример.</p>

<pre>
class Parent {
private:
  int m_private;

protected:
  int m_protected;

public:
  int m_public;
};

class Child: public Parent {
public:
  Child() {
    m_private = 1; // запрещено
    m_protected = 2; // разрешено
    m_public = 3; // разрешено
  }
};
</pre>

<pre>
int main() {
  Parent parent;
  parent.m_private = 1; // запрещено
  parent.m_protected = 2; // запрещено
  parent.m_public = 3; // разрешено
}
</pre>

  <p>Модификатор protected предоставляет доступ всем производным классам. Поэтому любые изменения членов с модификатором protected в базовом классе приведут к тому, что придется внести изменения во все производные классы, работающие с этими членами.</p>
  <p>Модификатор private предоставляет лучшую защиту данных от изменений. При этом для доступа к ним делают открытый интерфейс пользователя, используя методы set() и get().</p>
  <p>Таким образом, модификатор private используется при закрытом наследовании, protected - защищенном наследовании, public - открытом наследовании.</p>
  <p>При закрытом (private) наследовании все элементы базового класса становятся закрытыми (private) для производного класса и недоступны в нем.</p>
  <p>При защищенном (protected) наследовании открытые (public) и защищенные (protected) элементы базового класса становятся защищенными (protected) в производном классе.</p>
  <p>При открытом (public) наследовании открытые (public) элементы базового класса остаются открытыми (public) в производном классе, а защищенные (protected) элементы базового класса остаются защищенными (protected) в производном классе.</p>
  <p>Закрытые (private) элементы базового класса при любом типе наследования остаются недоступными в производном классе.</p>
  <p>Таким образом, в производном классе можно еще сильнее ограничить доступ к элементам базового класса, но сделать элементы доступнее никогда нельзя.</p>

  <p>Рассмотрим пример открытого наследования.</p>

<pre>
class Parent {
private:
  int m_private;

protected:
  int m_protected;

public:
  int m_public;
};

class Pub : public Parent {
public:
  Pub() {
    m_private = 1; // запрещено
    m_protected = 2; // разрешено
    m_public = 3; // разрешено
  }
};
</pre>

<pre>
int main() {
  Parent parent;
  parent.m_private = 1; // запрещено
  parent.m_protected = 2; // запрещено
  parent.m_public = 3; // разрешено

  Pub pub;
  pub.m_private = 1; // запрещено
  pub.m_protected = 2; // запрещено
  pub.m_public = 3; // разрешено
}
</pre>

  <p>При закрытом наследовании все элементы базового класса наследуются как закрытые. Это прекращает процесс дальнейшего наследования. Рассмотрим пример закрытого наследования.
  </p>

<pre>
class Parent {
private:
  int m_private;

protected:
  int m_protected;

public:
  int m_public;
};

class Priv : private Parent {
public:
  Priv() {
    m_private = 1; // запрещено
    m_protected = 2; // разрешено
    m_public = 3; // разрешено
  }
};
</pre>

<pre>
int main() {
  Parent parent;
  parent.m_private = 1; // запрещено
  parent.m_protected = 2; // запрещено
  parent.m_public = 3; // разрешено

  Priv pub;
  priv.m_private = 1; // запрещено
  priv.m_protected = 2; // запрещено
  priv.m_public = 3; // запрещено
}
</pre>

  <p>На практике наследование типа private и protected используется редко.</p>
</article>


<!-- 4.2 Конструкторы и деструкторы при наследовании -->
<article class="article">
  <div class="anchor" id="p4.2"></div>
  <h3>4.2 Конструкторы и деструкторы при наследовании</h3>

  <p>Базовый и производный класс могут иметь конструкторы и деструкторы. Конструкторы выполняются в порядке наследования, а деструкторы - в обратном порядке.</p>
  <p>Такой порядок происходит из-за того что базовый класс не значет о существовании производного класса. Инициализация в нем выполняется независимо от производного класса и может стать основой для инициализации в производном классе. Инициализация первым базового класса гарантирует, что при инициализации производного класса могут использоваться элементы базового класса, которые уже проинициализированы. Поскольку базовый класс лежит в основе производного, вызов деструктора базового класса раньше деструктора производного может привести к разрушению производного класса до того, как он выполнит свой деструктор, освобождающий выделенную память.</p>

<pre>
class Parent {
public:
  Parent() {
    cout &lt;&lt; "Parent constructor\n";
  }
  ~Parent() {
    cout &lt;&lt; "Parent destructor\n";
  }
};

class Child : public Parent {
public:
  Child() {
    cout &lt;&lt; "Child constructor\n";
  }
  ~Child() {
    cout &lt;&lt; "Child destructor\n";
  }
};
</pre>

<pre>
int main() {
  Parent parent;
  Child child;
}
</pre>

  <p>Результат</p>

<pre>
Parent constructor
Parent constructor
Child constructor
Child destructor
Parent destructor
Parent destructor
</pre>

  <p>Конструкторы базового и производного класса могут иметь параметры. При наследовании если параметры есть только у конструктора производного класса, то они передаются обычным способом. Однако если параметры есть у конструктора базового класса, то необходимо передать их ему из конструктора производного класса. В этом случае используется расширенная запись коснтруктора производного класса через двоеточие ":".</p>
  <p>Конструкторы базового и производного класса могут иметь как одинаковые так и различные параметры. Конструктор производного класса может использовать все переданные ему аргументы сам, а может и не использовать их, а передать их в конструктор базового класса.</p>

<pre>
class Parent {
protected:
  int i;

public:
  Parent(int _i) {
    i = _i;
    cout &lt;&lt; "Parent constructor\n";
  }
  ~Parent() {
    cout &lt;&lt; "Parent destructor\n";
  }
}

class Child : public Parent {
  int n;

public:
  Child(int _n, int _i) : Parent(_i) {
    n - _n;
    cout &lt;&lt; "Child constructor\n";
  }
  ~Child() {
    cout &lt;&lt; "Child destructor\n";
  }
}
</pre>

<pre>
int main() {
  Child child(2, 3);
}
</pre>

  <p>Рассмотрим пример, когда конструктор базового класса имеет больше параметров, чем конструктор производного класса.</p>

<pre>
class Parent {
  int i, j;

public:
  Parent(int _i, int _j) {
    i = _i;
    j = _j;
    cout &lt;&lt; "Parent constructor\n";
  }
  ~Parent() {
    cout &lt;&lt; "Parent destructor\n";
  }
  int getI() {
    return i;
  }
  int getJ() {
    return j;
  }
}

class Child : public Parent {
  int n;

public:
  Child(int _n);
  ~Child() {
    cout &lt;&lt; "Child destructor\n";
  }
  int getN() {
    return n;
  }
};

Child::Child(int _n) : Parent(_n/2, _n%2) {
  n = _n;
}
</pre>

<pre>
int main() {
  Child child(15);
  cout &lt;&lt; child.getI() &lt;&lt; ' ' &lt;&lt; child.getJ()
  &lt;&lt; ' ' &lt;&lt; child.getN() &lt;&lt; endl;
}
</pre>

  <p>В конструкторе производного класса описывается вызов конструктора базового класса.</p>
</article>


<!-- 4.3 Пример построения классов при наследовании -->
<article class="article">
  <div class="anchor" id="p4.3"></div>
  <h3>4.3 Пример построения классов при наследовании</h3>

  <p>Напишем класс Pixel который имеет три поля: координаты x и y и видимость пиксела на экране. Добавим методы для инициализации пикселя, а также методы Show(), Hide(), MoveTo().</p>

<pre>
class Point {
protected:
  int X;
  int Y;
  bool Visible;

public:
  int getX() { return X; }
  int getY() { return Y; }
  bool isVisible() { return Visible; }

  // конструктор копирования
  Point(cont Point& cp) {
    X = cp.X;
    Y = cp.Y;
    Visible = cp.Visible;
  }

  // прототип конструктора
  Point(int _X = 0, int _Y = 0);
  void Show();
  void High();
  void MoveTo(int _X, int _Y);
};

// конструктор
Point::Point(int _X, int _Y) {
  X = _X;
  Y = _Y;
  Visible = false;
}

void Point::Show() {
  Visible = true;
}

void Point::Hide() {
  Visible = false;
}

void Point::MoveTo(int _X, int _Y) {
  Hide();
  X = _X;
  Y = _Y;
  Show();
}
</pre>

<pre>
int main() {
  Point Center(320, 120); // объект типа Point
  Point *point_ptr; // указатель на тип Point
  point_ptr = &amp;Center; // указатель на Center
}
</pre>

<pre>
Point aPoint;
Point bPoint(100);
Point Row[80];
</pre>

<pre>
Point pointA(50, 50);
pointA.Show();
pointA.MoveTo(100, 130);
pointA.Hide();
</pre>

  <p>Если потребуется создать новый класс, то можно его создать с нуля или воспользоваться готовым классом Point, сделав его базовым.</p>
  <p>Создадим класс Circle, окружность имеющач центр и радиус.</p>

<pre>
class Circle : public Point {
  int r; // радиус

public:
  Circle(int _X, int _Y, int _r);
  void Show();
  void Hide();
  void Expand(int dr);
  void Contract(int dr);
  void MoveTo(int _X, int _Y);
};

Circle::Circle(int _X, int _Y, int _r) : Point(_X, _Y) {
  r = _r;
}

void Circle::Show() {
  Visible = true;
}

void Circle::Hide() {
  Visible = false;
}

void Circle::Expand(int dr) {
  Hide();
  r += dr;
  Show();
}

void Circle::Contract(int dr) {
  Expand(-dr);
}

void Circle::MoveTo(int _X, int _Y) {
  Hide();
  X = _X;
  Y = _Y;
  Show();
}
</pre>

<pre>
int main() {
  Circle C(150, 200, 50);
  // центр в точке (150, 200)
  // радиус 50

  C.Show();
  getch();
  C.MoveTo(300, 100);
  getch();
  C.Expand(50);
  getch();
  C.Contract(70);
  getch();
}
</pre>

  <p>Если нужно вызвать метод базового класса в одноименном методе производного класса, нужно выполнить обычный вызов функции, но с добавлением имени базового класса и оператора разрешения области видимости</p>

<pre>
void Circle::Show() {
  Visible = true;
  Point::Show();
}

void Circle::Hide() {
  Visible = false;
  Point::Hide();
}
</pre>
</article>


<!-- 4.4 Совместимость типов при наследовании -->
<article class="article">
  <div class="anchor" id="p4.4"></div>
  <h3>4.4 Совместимость типов при наследовании</h3>

  <p>Объекты одного и того же типа (класса) являются совместимыми. Их можно присваивать друг другу. Объекты производного класса совместимы с объектами базового класса, но не наоборот. Это значит, что объекты производного класса можно использовать вместо объектов базового класса. Совместимость распространаятеся от потомков к предку.</p>
  <p>Три формы совместимости:</p>
  <ol>
    <li>Между экземплярами объектов</li>
    <li>Между указателями на объекты</li>
    <li>Между формальными и фактическими параметрами функций</li>
  </ol>

<pre>
Point APoint, *ptrPoint;
Circle ACircle, *ptrCircle;

APoint = ACircle;
APoint = *ptrCircle;
ptrPoint = &amp;ACircle;
ptrPoint = ptrCircle;
</pre>

  <p>При присваивании тот, кто присваивается должен быть не меньше, чем тот, кому присваивается. Порожденный тип содержит все поля родительского типа и что-то еще свое. Поэтому порожденный тип всегда не меньше родительского типа и может быть ему присвоен.</p>

<pre>
class Parent {
protected:
  int m;

public:
  Parent(int value): m(value) {}
  const char* getName() {return "Parent";}
  int getValue() {retirn m;}
};

class Child : public Parent {
public:
  Child(int value): Parent(value) {}
  const char* getName() {return "Child";}
  int getValueDoubled() {return m * 2;}
};
</pre>

<pre>
int main() {
  Child child(7);
  cout &lt;&lt; "child is a " &lt;&lt; child.getName()
  &lt;&lt; " value = " &lt;&lt; child.getValue() &lt;&lt; '\n';

  Parent &rParent = child;
  cout &lt;&lt; "rParent is a " &lt;&lt; rParent.getName()
  &lt;&lt; " value = " &lt;&lt; rParent.getValue() &lt;&lt; '\n';

  Parent *pParent = &amp;child;
  cout &lt;&lt; "pParent is a " &lt;&lt; pParent->getName()
  &lt;&lt; " value = " &lt;&lt; pParent->getName() &lt;&lt; '\n';
}
</pre>

  <p>Результат</p>
<pre>
child is a Child value = 7
rParent is a Parent value = 7
pParent is a Parent value = 7
</pre>

  <p>rParent и pParent являются ссылкой и указателем класса Parent. Они не имеют доступа к методу Child::getName(). Поэтому будет вызываться метод Parent::getName(). Также они не имеют доступа к методу Child::getValueDoubled().</p>
</article>


<!-- 5 Виртуальные методы -->
<article class="article">
  <div class="anchor" id="p5"></div>
  <h3>5 Виртуальные методы</h3>

</article>


<!-- 5.1 Раннее и позднее связывание -->
<article class="article">
  <div class="anchor" id="p5.1"></div>
  <h3>5.1 Раннее и позднее связывание</h3>

  <p>Чтобы показать или спрятать точку мы использовали методы Point.Show() и Point.Hide(). Класс Circle это наследник класса Point. Чтобы показать или спрятать окружность мы написали методы Circle.Show() и Circle.Hide().</p>
  <p>Чтобы двигать точку по экрану мы использовали метод Point.MoveTo(). В методе Point.MoveTo() вызываются методы Pojnt.Show() и Point.Hide() поэтому у нас двигается именно точка. Чтобы двигать окружность по экрану мы написали метод Circle.MoveTo(). В методе Circle.MoveTo() вызываются методы Circle.Show() и Circle.Hide() поэтому у нас двигается именно окружность.</p>
  <p>Компилятор сначала ищет метод внутри текущего класса. Если метод не найден, то компилятор ищет его у родительского класса.</p>
  <p>Принятие решения на этапе компиляции относится к механизму <strong>раннего связывания</strong>.</p>
  <p>В процессе компиляции программы компилятор конвертирует каждую инструкцию программы в одну или несколько строк машинного кода. Каждой строке машинного кода присваивается собственный уникальный адрес. То же самое происходит и при обработке функций: когда компилятор встречает функцию, она конвертируется в машинный код и получает свой адрес.</p>
  <p>Связывание – это процесс, который используется для конвертации идентификаторов (таких как имена переменных или функций) в адреса.</p>
  <p>Раннее связывание означает, что компилятор может напрямую связать имя идентификатора (например, имя функции или переменной) с машинным адресом. Поэтому, когда компилятор встречает вызов функции, он заменяет его инструкцией машинного кода, которая сообщает процессору о том, как перейти к адресу функции.</p>
  <p>К двум классам Point и Circle добавим еще один класс Rectangle, который будет наследником класса Point. Координаты x и y будут обозначать верхний левый угол прямоугольника. Добавим к ним два поля length и width для длины и широты и переопределим методы Show(), Hide(), MoveTo().</p>
  <p>Мы хотим работать с парами однотипных объектов, отображая их на экране. Напишем две перегруженные функции для отображения пары окружностей и пары прямоугольников.</p>

<pre>
void showPair(const Circle& c1, const Circle& c2) {
  c1.Show();
  c2.Show();
}

void showPair(const Rectangle& r1, const Rectangle& r2) {
  r1.Show();
  r2.Show();
}
</pre>

  <p>При создании еще наследников класса Point, для каждого из них мы вынуждены перегружать функцию showPair(). Логичнее описать единственный экземпляр функции showPair(), которы мог бы работыть с объектами базового класса и со всеми наследниками.</p>

<pre>
void showPair(const Point& p1, const Point& p2) {
  p1.Show();
  p2.Show();
}
</pre>

  <p>Вызовем теперь функцию showPair() для наследников класса Point.</p>
<pre>
Circle circle1(0, 0, 1), circle2(5, 6, 10);
Rectangle rect1(-1, -1, 10, 20), rect2(2, 5, 1, 8);
showPair(circle1, circle2);
showPair(rect1, rect2);
showPair(circle1, rect1);
</pre>

  <p>В результате на экране отобразится лишь по две точки, потому что в каждом случае будет вызван метод Show() базового класса Point.</p>

  <p>Решить эту проблему можно используя виртуальные методы, реализуемые с помощью механизма <strong>позднего связывания</strong>.</p>
  <p>Для реализации механизма позднего связывания используются указатели на функции. Указатель на функию - это тип указателя, который указывает на функцию вместо переменной. Теперь функция может быть вызвана как через оператор вызова функции так и через указатель на функцию. Вызов функции через указатель на функцию называется <strong>непрямой ( или косвенный) вызов функции</strong>.</p>
  <p>Недостаток позднего связывания в том, что процессор должен сперва прочитать адрес, хранящийся в указателе, а затеп только перейти к этому адресу. Этот дополнительный шаг замедляет процесс вызова функции.</p>
  <p>Преимущество позднего связывания в том, что решение о том какую функцию нужно вызвать, может быть отложено до запуска самой программы.</p>
  <p>Отличие раннего и позднего связывания в том, что при раннем связывании функция связывается с адресом на этапе компиляции, а при позднем связывании - на этапе выполнения программы.</p>
</article>


<!-- 5.2 Виртуальные функции -->
<article class="article">
  <div class="anchor" id="p5.2"></div>
  <h3>5.2 Виртуальные функции</h3>

  <p><strong>Виртуальные методы</strong> описанные в классах потомках замещают собой эти методы в классах предках, если вызываются на объектах, принадлежащих потомкам.</p>
  <p>Виртуальные методы обеспечивают полиморфизм классов. Функции, описанные в базовом классе как виртуальные, могут быть модифицированы в производных классах, причем связывание будет происходить не на этапе компиляции, а в момент обращения к данному методу.</p>

  <p>Напишем классы Point и Circle с виртуальными методами.</p>

<pre>
class Point {
public:
  virtual void Show();
  virtual void Hide();
  void MoveTo(int _x. int _y);
};

class Circle : public Point {
public:
  virtual void Show();
  virtual void Hide();
};
</pre>

  <p>В классе Circle нет метода MoveTo(), он наследуется из класса Point. Но при вызове метода Point.MoveTo() будут вызываться методы Point.Show() и Point.Hide(), а при вызове метода Circle.MoveTo() будут вызываться методы Circle.Show() и Circle.Hide(). Поэтому при вызове метода MoveTo() для объекта класса Circle по экрану будет перемещаться окружность.</p>
  <p>Преимущество виртуальных функций - чтобы новые дочерние классы автоматически работали со старым кодом, без необходимости внесения изменений со стороны программиста.</p>
  <p>Теперь вернемся к функции showPair() для отображения пары фигур. Если сделать метод Show() виртуальным, то функция showPair() правильно отобразит переданные ей в качестве параметров объекты.</p>

<pre>
void showPair(const Point& p1, const Point& p2) {
  p1.Show();
  p2.Show();
}
</pre>
</article>


<!-- 5.3 Применение виртуальных функций при использовании указателей на базовые классы -->
<article class="article">
  <div class="anchor" id="p5.3"></div>
  <h3>5.3 Применение виртуальных функций при использовании указателей на базовые классы</h3>

  <p>Указатель на базовый класс может использоваться в качестве указателя на любой производный класс от базового.</p>

<pre>
Point p(100, 20);
Circle c(20, 30, 10);
Point *pPtr;
pPtr = &amp;p; // указывает на объект базового класса
pPtr = &amp;c; // указывает на объкт производного класса
</pre>

  <p>При помощи указателя на объект можно вызвать метод этого объекта через оператор стрелка "->".</p>
  <code>pPtr->MoveTo(10, 10);</code>
  <p>С помощью указателя можно вызвать и виртуальные методы.</p>
  <p>Вызовем виртуальный метод объекта базового класса.</p>
<pre>
pPtr = &amp;p;
pPtr->Show(10, 10);
</pre>
  <p>Вызовем виртуальный метод объекта производного класса.</p>
<pre>
pPtr = &amp;c;
pPtr->Show(10, 10);
</pre>

  <p>Напишем функцию Jump() - прыжок объекта на высоту h.</p>
<pre>
void Jump(Point* figure, int h) {
  int oldX = figure->getX();
  int oldY = figure->getY();
  delay(100);
  figure->MoveTo(oldX, oldY - h);
  delay(100);
  figure->MoveTo(oldX, oldY);
}
</pre>

  <p>Функции Jump() можно передавать указатель на объект типа Point и на объекты классов порожденных от класса Point.</p>
  <p>Методы getX(), getY, MoveTo() и Show() есть в классе Point и в классе Circle.</p>
  <p>getX(), getY, MoveTo() это статические методы и их адрес известен еще во время компиляции.</p>
  <p>Show() это виртуальный метод. Есть его разные варианты для разных классов. Point.Show() для класса Point, Circle.Show() для класса Circle.</p>
  <p>Во время компиляции не известно объект какого класса будет передан в функцию Jump(). Во время выполнения программы если объект имеет тип Point, то вызовется функция Point.Show(), если объект имеет тип Circle, то вызовется функция Circle.Show().</p>
  <p>Метод Show() должен содержаться во всех классах, порожденных от класса Point. Поэтому функция Jump() может изобразить объект любого класса, порожденного от класса Point, независимо существовал ли данный класс при компиляции функции Jump() или нет.</p>
</article>


<!-- 5.4 Виртуальные деструкторы -->
<article class="article">
  <div class="anchor" id="p5.4"></div>
  <h3>5.4 Виртуальные деструкторы</h3>

  <p>При выходе из области видимости статических объектов производного класса автоматически вызываются деструкторы в таком порядке: деструктор производного класса, деструктор базового класса.</p>
  <p>Если объект производного класса создан динамически и разрушается с помощью указателя на базовый класс, то вызов деструктора производного класса не производится, что приводит к потере (не освобождению) области памяти, выделенной уникальным полям, относящимся к производному классу.</p>

<pre>
class Parent {
public:
  ~Base() {
    cout &lt;&lt; "Destructor Parent\n";
  }
};

class Child : public Parent {
  int* m;

public:
  Child(int len) {
    m = new int[len];
  }
  ~Child() {
    cout &lt;&lt; "Destructor Child\n";
    delete[] m;
  }
};
</pre>

<pre>
int main() {
  Parent *p = new Child(5);
  delete p;
}
</pre>

  <p>Результат</p>
  <code>Destructor Parent</code>

  <p>Вызовется деструктор класса Parent, а память под массив m останется не освобожденной.</p>
  <p>Для того чтобы при удалении объекта класса Child сработал деструктор этого класса, необходимо объявить деструктор базового класса виртуальным.</p>

<pre>
class Parent {
public:
  virtual ~Base() {
    cout &lt;&lt; "Destructor Parent\n";
  }
};

class Child : public Parent {
  int* m;

public:
  Child(int len) {
    m = new int[len];
  }
  ~Child() {
    cout &lt;&lt; "Destructor Child\n";
    delete[] m;
  }
};
</pre>

<pre>
int main() {
  Parent *p = new Child(5);
  delete p;
}
</pre>

  <p>Результат</p>
  <code>Destructor Child</code>
  <code>Destructor Parent</code>
</article>


<!-- 5.5 Динамическое приведение типов -->
<article class="article">
  <div class="anchor" id="p5.5"></div>
  <h3>5.5 Динамическое приведение типов</h3>

  <p>Рассмотрим пример, когда в коде есть указатель на базовый класс, при этом нужно получить доступ к данным из производного класса.</p>

<pre>
class Animal {
  string name;

public:
  Animal(string _name) : name(_name) {}
  string getName() {
    return name;
  }
  virtual void makeSound() {
    cout &lt;&lt; "Any sound\n";
  }
};

class Cat : public Animal {
public:
  Cat(string _name) : Animal(_name) {}
  void makeSound() {
    cout &lt;&lt; "Meow\n";
  }
  void leakMilk() {
    cout &lt;&lt; "Leak milk\n";
  }
};

class Dog : public Animal {
public:
  Dog(string _name) : Animal(_name) {}
  void makeSound() {
    cout &lt;&lt; "Gav-gav\n";
  }
  void serve() {
    cout &lt;&lt; "Serve";
  }
};
</pre>

  <p>Класс Animal содержит виртуальный метод makeSound(), который переопределяется в дочерних классах, и метод getName(), который наследуется дочерними классами. Производные классы Cat и Dog содержат по одному собственному методу leakMilk() и serve().</p>
  <p>Если присвоить указателю на базовый класс адрес объекта производного класса, то нельзя вызвать с помощью этого указателя собственные методы производного класса.</p>

<pre>
Animal* dog = new Dog("Reks");
dog->serve(); // возникнет ошибка
// класс Animal не содержит метод serve()
</pre>

  <p>Если для решения этой проблемы мы добавим в класс Animal виртуальную функцию serve(), то это приведет к лишнему коду, который требуется только для производного класса Dog и не имеет никакого отношения к производному классу Cat.</p>
  <p>Эту проблему можно решить с помощью <strong>оператора динамического приведения типа</strong>.</p>

  <p>В C++ можно преобразовать указатель на производный класс в указатель на базовый класс.</p>
  <p><strong>Повышающее приведение типа</strong> это присвоение указателя на производный класс указателю базового класса:</p>
  <code>Animal* dog = new Dog("Reks");</code>

  <p>Для наглядности заменим эту конструкцию на два оператора.</p>
<pre>
Dog* pDog = new Dog("Reks");
Animal* dog = pDog;
</pre>

  <p>В C++ можно также преобразовать указатель на базовый класс в указатель на производный класс.</p>
  <p><strong>Понижающее приведение типа</strong> это присвоение указателя на базвый класс указателю производного класса с помощью оператора dynamic_cast</p>

<pre>
int main() {
  Animal* dogA = new Dog("Reks");
  Animal* catA = new Cat("Murka");
  cout &lt;&lt; dogA->getName() &lt;&lt; '\n';
  cout &lt;&lt; catA->getName() &lt;&lt; '\n';

  Cat* cat = dynamic_cast &lt;Cat*&gt;(catA);
  if (cat) {
    cout &lt;&lt; cat->getName() &lt;&lt; '\n';
    cat->makeSound();
    cat->leakMilk();
  }

  // вернется нулевой указатель, потому что
  // такое преобразование невозможно
  Cat* cat1 = dynamic_cast &lt;Cat*&gt;(dogA);

  Animal* animal = new Animal("Animal");
  // вернется нулевой указатель, потому что
  // такое преобразование невозможно
  Cat* cat2 = dynamic_cast &lt;Cat*&gt;(animal);
}
</pre>

  <p>Оператор dynamic_cast работает и с указателями и со ссылками. Между работой с указателями и со ссылками есть одно отличие. Поскольку нельзя вернуть нулевую ссылку (потому что ее не существует в языке C++), то при неправильном преобразовании ссылок генерируется исключение.</p>

<pre>
Animal* catA = new Cat("Murka");
Cat &cat = dynamic_cast&lt;Cat&&gt;(*catA);
cat.getName();
cat.makeSound();
cat.leakMilk();

Animal* dogA = new Dog("Reks");
// вызовется исключение
Cat &cat1 = dynamic_cast &lt;Cat&&gt;(*dogA);
</pre>

  <p>Понижающее приведение типов с помощью dynamic_cast не работает в следующих случаях:</p>
  <ol>
    <li>При использовании модификатора наследования private или protected</li>
    <li>Если базовый класс не имеет ни одной виртуальной функции. В этом случае копмилятор не строит виртуальных таблиц и преобразвание не возможно.</li>
  </ol>
</article>


<!-- 5.6 Абстрактные классы -->
<article class="article">
  <div class="anchor" id="p5.6"></div>
  <h3>5.6 Абстрактные классы</h3>

  <p>Если виртуальная функция в базовом классе не выполняет никаких действий, то можно ее объявить как <strong>чисто виртуальную функцию</strong> и класс становится <strong>абстрактным</strong>.</p>
  <code>virtual makeSound() = 0;</code>

  <p>Поскольку у чисто виртуального метода нет тела, то у абстрактного класса нельзя создать объект. Значит, абстрактный класс обязательно должен наследоваться.</p>

<pre>
class Point {
protected:
  int X;
  int Y;
  Boolean Visible;

public:
  int GetX(void) {return X;}
  int GetY(void) {return Y;}
  Boolean isVisible() {return Visible;}
  Point(int _x = 0, int _y = 0);
  virtual void Show() = 0;
  virtual void Hide() = 0;
  void MoveTo(int _x, int _y) {
    Hide();
    X = _x;
    Y = _y;
    Show();
  }
};
</pre>

  <p>Класс Point содержит чисто виртуальные методы, поэтому является абстрактным. Несмотря на то, что от него теперь нельзя создать объект, конструктор ему все же нужен чтобы инициализировать переменные X, Y, Visible для использования их в производных классах.</p>
  <p><strong>Интерфейсы или интерфейсные классы</strong> не имеют полей класса, а все их методы являются чисто виртуальными.</p>
</article>


<!-- 6 Дружественные функции -->
<article class="article">
  <div class="anchor" id="p6"></div>
  <h3>6 Дружественные функции</h3>

</article>


<!-- 6.1 Доступ к защищенным элементам класса -->
<article class="article">
  <div class="anchor" id="p6.1"></div>
  <h3>6.1 Доступ к защищенным элементам класса</h3>

  <p>Иногда стоит задача реализовать функцию, которая не является методом класса, но имеет доступ к его закрытым компонента. Для решения этой задачи используют дружественные функции класса.</p>
  <p>Плюсом данного решения является то, что дружественная функция может быть другом двух и более классов.</p>

<pre>
class Circle;

class Point {
  friend bool IsInside(Circle &C, Point &P);
};

class Circle: public Point {
  friend bool IsInside(Circle &C, Point &P);
};
</pre>

  <p>Мы написали прототип функции IsInside(), которая определяет находится ли объект точка внутри объекта круг. Теперь напишем саму эту функцию.</p>

<pre>
bool IsInside(Circle &C, Point &P) {
  if ((C.X - P.X.)*(C.X - P.X) + (C.Y - P.Y)*(C.Y - P.Y) &lt;= C.R * C.R) {
    return true;
  } else {
    return false;
  }
}
</pre>

  <p>Функция IsInside() не является методом какого-либо класса, но получает доступ к закрытым областям классов Point и Circle. Это только потому что в декларации класса есть прототип дружественной функции IsInside().</p>

  <p>Функция одного класса может быть дружественной другому классу.</p>

<pre>
class X {
  void f();
};

class Y {
  friend void X::f();
}
</pre>

  <p>Все функции одного класса могут быть дружественными другому классу.</p>

<pre>
class Y {
  friend class X;
}
</pre>

  <p>В этом случае, скорее всего система классов разработана неверно. Потому что один класс открывает полный доступ ко всей своей защищенной информации дргому классу.</p>
</article>


<!-- 6.2 Переопределение операторов с помощью дружественных функций -->
<article class="article">
  <div class="anchor" id="p6.2"></div>
  <h3>6.2 Переопределение операторов с помощью дружественных функций</h3>

  <p>Раньше мы переопределяли операторы для класса Vector3D:</p>

<pre>
class Vector3D {
  Vector3D operator+(const Vector3D &b);
};

Vector3D Vector3D::operator+(const Vector3D &b) {
  return Vector3D(x + b.x, y + b.y, z + b.z);
};
</pre>

  <p>Теперь переопределим тот же самый оператор с использованием дружественной функции.</p>

<pre>
class Vector3D {
  friend Vector3D operator+(const Vector3D &a, const Vector3D &b);
};

Vector3D operator+(const Vector3D &a, const Vector3D &b) {
  return Vector3D(a.x + b.x, a.y + b.y, a.z + b.z);
};
</pre>

  <p>В одних случаях для доступа к закрытой части класса следует использовать методы класса, а в других - дружественные функции.</p>
  <p>Операция, изменяющая состояние объекта, должна быть элементом класса.</p>
  <p>Операция, не изменяющая состояние объекта, например, операторы &lt;&lt; и &gt;&gt; для ввода-вывода могут быть дружественными.</p>

<pre>
class Pair {
  int a, b;

public:
  Pair(int A = 0, int B = 0) : a(A), b(B) {}
};
</pre>

  <p>Оператор "&lt;&lt;" это оператор побитового сдвига влева. Но класс ostream перегружает этот оператор для всех базовых типов. При создании своего класса мы тоже можем захотеть использовать оператор "&lt;&lt;" для вывода данных созданного типа. Однако изменить заголовочный файл iostream мы уже не можем, так как он являются частью стандартной библиотеки STL.</p>
  <p>Поэтому мы должны сами перегрузить оператор "&lt;&lt;" в своей программе.  Если перегрузить оператор "&lt;&lt;" функцией внутри своего класса</p>

<pre>
class Pair {
  void operator&lt;&lt;(ostream& os);
}
</pre>

  <p>то придется использовать обратную форму записи</p>
  <code>pair &lt;&lt; cout;</code>

  <p>Чтобы использовать обычную запись, нужно использовать дружественную функцию.</p>

<pre>
friend void operator&lt;&lt;(ostream& os, Pair& p) {
  os &lt;&lt; " a = " &lt;&lt; p.a &lt;&lt; " b = " &lt;&lt; p.b;
}
</pre>

  <code>cout &lt;&lt; pair;</code>

  <p>Для того чтобы было возможно делать последовательный вывод, оператор "&lt;&lt;" должен возвращать объект типа ostream.</p>

<pre>
friend ostream& operator&lt;&lt;(ostream& os, Pair& p) {
  os &lt;&lt; " a = " &lt;&lt; p.a &lt;&lt; " b = " &lt;&lt; p.b;
  return os;
}
</pre>

  <p>Аналогично перегружается оператор ">>"</p>

<pre>
friend istream& operator>>(istream& os, Pair& p) {
  os >> p.a >> p.b;
  return os;
}
</pre>
</article>


<!-- 7 Шаблоны (параметризованные типы) -->
<article class="article">
  <div class="anchor" id="p7"></div>
  <h3>7 Шаблоны (параметризованные типы)</h3>

  <p>Допустим, мы создали функцию, которая принимает два целых числа и возвращает их сумму.</p>

<pre>
int sum(int a, int b) {
  return a + b;
}
</pre>

  <p>Допустим, нам требуется чтобы эта же функция могла работать с вещественными числами. Для этого можно перегрузить функцию.</p>

<pre>
double sum(double a, double b) {
  return a + b;
}
</pre>

  <p>Перегрузка позволяет использовать функции с одинаковым именем для работы с разными типами данных. Но это не избавляет нас от дублирования кода. И нам приходится описывать один и тот же алгоритм в разных местах программы много раз.</p>
  <p>Решением этой проблемы могло бы стать использование макроподстановок. Однако это тоже имеет свои недостатки. Во-первых, макроподстановки используют только при описании довольно простых функций. Во-вторых, макроподстановки не обеспечивают контроль типов данных, что может привести к появлению непредсказуемых ошибок. В-третьих, макросы не производят вызов функции, а подставляются в те места, где оно используется, что может сильно увеличить размер программы.</p>
  <p>Хорошим решением станет использование шаблонов. Шаблон можно написать сразу, а типы данных, с которыми он работает уточнять позднее, по мере необходимости. Это возможно, поскольку используемый тип данных является параметром.</p>
  <p>В C++ имеются два типа шаблонов - шаблоны функций и шаблоны классов.</p>
</article>


<!-- 7.1 Шаблоны функций -->
<article class="article">
  <div class="anchor" id="p7.1"></div>
  <h3>7.1 Шаблоны функций</h3>

  <p>Шаблон функции начинается со слова template, за которым пишут список параметров шаблона.</p>
  <p>Напишем шаблон функции, которая находит минимум из двух переменных одного типа.</p>

<pre>
template &lt;class X&gt;
X min (X a, X b) {
  return a &lt; b ? a : b;
}
</pre>

  <p>class X обозначает абстрактный тип, который используется внутри шаблона в качестве типа параметров функции и типа возвращаемого значения. X представляет собой тип, который будет задан позднее.</p>

  <p>Если необходимо найти минимум из двух целых чисел, то вызывать функцию надо так:</p>
  <code>int m = min(1, 2);</code>

  <p>Получив конкретный тип данных, компилятор автоматически сгенерирует экземпляр функции:</p>

<pre>
int min(int a, int b) {
  return a &lt; b ? a : b;
}
</pre>
</article>


<!-- 7.2 Отождествление типов аргументов в шаблонах -->
<article class="article">
  <div class="anchor" id="p7.2"></div>
  <h3>7.2 Отождествление типов аргументов в шаблонах</h3>

  <p>Компилятор генерирует экземпляты функций из шаблонов согласно типам параметров, заданным при вызове функций. </p>

<pre>
template &lt;class X&gt;
X min (X a, X b) {
  return a &lt; b ? a : b;
}
</pre>

  <p>Функция min будет работать правильно, если оба ее аргумента имеют один и тот же тип</p>

<pre>
int i = min(1, 2);
double d = min(1.2, 3.4);
</pre>

  <p>Если при вызове функции задать аргументы различных типов, то это приведет к ошибке, так как компилятор не сможет построить экземпляр функции по шаблону.</p>
  <p>Первывй способ решения этой проблемы это приведение типов при вызове функции.</p>

  <code>int i = min((int)'a', 100);</code>

  <p>Второй способ это явно указать версию экземпляра шаблона во время вызова функции.</p>

  <code>int i = min&lt;int&gt;('a', 100);</code>

  <p>Третий способ это создать шаблон, который имеет параметры различных типов.</p>

<pre>
template &lt;class X1, class X2&gt;
X1 min(X1 a, X2 b) {
  return a &lt; (X1)b ? a : (X1)b;
}
</pre>

  <p>Теперь, если написать</p>

  <code>min(2.5, 100);</code>

  <p>то компилятор построит версию функции min() с заголовком:</p>
  <code>double min(double, int);</code>
</article>


<!-- 7.3 Шаблоны классов -->
<article class="article">
  <div class="anchor" id="p7.3"></div>
  <h3>7.3 Шаблоны классов</h3>

  <p>Используя шаблоны классов мы можем получить <strong>контейнерные классы</strong>. Контейнерные классы это структуры данных, элементами которых могут быть как переменные встроенных типов, так и объекты классов, созданных пользователем.</p>

<pre>
template &lt;class X&gt;
class Pair {
  X a, b;

public:
  Pair(X _a, X _b);
  X Max();
  X Min();
  int isEqual();
};
</pre>

  <p>Класс Pair хранит пару значений. Функции класса позволяют определять минимум, максимум и являются ли значения равными.</p>
  <p>Описание шаблона функции Min(), принадлежащей шаблону класса Pair необходимо начинать с написания слова template.</p>

<pre>
template &lt;class X&gt;
X Pair &lt;X&gt;::Min() {
  return a &lt; b ? a : b;
}
</pre>

  <p>Напишем остальные методы класса Pair.</p>

<pre>
// конструктор
template &lt;class X&gt;
Pair &lt;X&gt;::Pair(X _a, X _b) : a(_a), b(_b) {}

// метод Max
template &lt;class X&gt;
X Pair &lt;X&gt;::Max() {
  return a > b ? a : b;
}

// метод isEqual
template &lt;class X&gt;
int Pair &lt;X&gt;::isEqual() {
  if (a == b) {
    return 1;
  }
  return 0;
}
</pre>

  <p>Для того чтобы создать экземпляр класса Pair для пользовательского класса MyClass, то этот класс должен содержать общедоступные методы:</p>

<pre>
// конструктор копирования
MyClass(const MyClass&);

// перегруженные операции сравнения
int operator==(MyClass);
int operator&lt;(MyClass);
int operator&gt;(MyClass);
</pre>
</article>


<!-- 7.4 Шаблоны классов: не только для типов -->
<article class="article">
  <div class="anchor" id="p7.4"></div>
  <h3>7.4 Шаблоны классов: не только для типов</h3>

  <p>Шаблон класса может использоваться не только для любого типа данных. Можно использовать дополнительные параметры шаблона с фиксированным типом данных для создания объектов разной размерности. Этот механизм широко используется при создании шаблонов контейнерных классов.</p>
  <p>В классе Pair число элементов равно двум и это число фиксировано. Напишем шаблон для класса Vector, в котором будем использовать дополнительный параметр для фиксированного типа данных.</p>

<pre>
template &lt;class X, int n&gt;
class Vector {
  X *coord;
  int current;

public:
  Vector();
  ~Vector() {delete[] coord;}
  void newCoord(X x);
  X Max();
  X Min();
  int isEqual();
}
</pre>

  <p>Параметр int n, заданный в заголовке шаблона, не используется в описании класса, но используется в описании его методов. Напишем конструктор Vector, использующий значение n для задания размера массива.</p>

<pre>
// конструктор
template &lt;class X, int n&gt;
Vector &lt;X, n&gt;::Vector() {
  coord = new X[n];
  current = 0;
}
</pre>

  <p>На основе созданного шаблона класса Vector создадим объекты.</p>

<pre>
Vector &lt;int, 20&gt; small_vector_of_int;
// Вектор из 20 элементов типа int
Vector &lt;int, 1000&gt; big_vector_of_int;
// Вектор из 1000 элементов типа int
Vector &lt;myClass, 30&gt; vector_of_myClass;
// Вектор из 30 элементов типа myClass
</pre>
</article>


<!-- 7.5 Наследование в шаблонах классов -->
<article class="article">
  <div class="anchor" id="p7.5"></div>
  <h3>7.5 Наследование в шаблонах классов</h3>

  <p>В шаблонах класса поддерживается механизм наследования. Пусть класс Pair это базовый класс, который содержит два элемента a и b. Создадим от него производный класс Trio, который содержит три элемента a, b и c.</p>

<pre>
template &lt;class X&gt;
class Pair {
protected:
  X a, b;

public:
  Pair(X _a, Z _b);
  X Max();
  X Min();
  int isEqual();
};

template &lt;class X&gt;
class Trio: public Pair &lt;X&gt; {
  X c;

public:
  Trio(X _a, X _b, X _c);
};

template &lt;class X&gt;
Trio&lt;X&gt;::Trio(X _a, X _b, X _c) : Pair &lt;X&gt; (_a, _b), c(_c) {}
</pre>

  <p>Вызов родительского конструктора также сопровождается передачей типа x в качестве параметра.</p>
</article>


<!-- 8 Методология программирования -->
<article class="article">
  <div class="anchor" id="p8"></div>
  <h3>8 Методология программирования</h3>

  <p>При увеличении размера программы, ее приходится разбивать на <strong>модули</strong>. Это называется <strong>декомпозицией</strong>. Если над программой работает несколько программистов, то программа может быть разбита на части, причем каждая из них может создаваться отдельными участниками независимо от других. Модули должны быть независимы друг от друга, чтобы можно было вносить изменения в один модуль, не изменяя другие.</p>
</article>


<!-- 8.1 Декомпозиция и абстракция -->
<article class="article">
  <div class="anchor" id="p8.1"></div>
  <h3>8.1 Декомпозиция и абстракция</h3>

  <p>Принципы декомпозиции:</p>
  <ol>
    <li>Каждая подзадача должна иметь один и тот же уровень рассмотрения.</li>
    <li>Каждая подзадача может быть решена независимо от остальных.</li>
    <li>Полученные решения могут быть объединены вместе, позволяя в конечном итоге решить исходную задачу.</li>
  </ol>

  <p>Пример 1. Группа авторов создает пьесу, причем каждый из них пишет текст для одного персонажа. Хотя каждый автор справится со своей задачей, о смысле готового произведения говорить не приходится.</p>
  <p>Стадии декомпозиции должен предшествовать этап абстракции. Мы абстрагируемся от деталей реализации и сводим задачу к более простой, после чего декомпозиция такой задачи окажется более простой по сравнению с исходной.</p>
  <p>Пример 2. Группа авторов предварительно оговаривает сюжет пьесы, смысл отдельных диалогов и т.п.</p>
  <p>Декомпозиция нужна для разбиения программ на модули, которые затем могут быть объединены для решения основной задачи. Абстрагирование предлагает продуманный выбор таких модулей.</p>
  <p>Эффективной возможностью предусмотреть механизмы, которые позволяли бы программисту создавать свои собственные абстракции является использование функций. Разделяя в программе тело функции и обращение к ней, язык позволяет реализовать два важных метода абстракции: <strong>абстракцию через параметризацию</strong> и <strong>абстракцию через спецификацию</strong>.</p>
</article>


<!-- 8.2 Абстракция через параметризацию -->
<article class="article">
  <div class="anchor" id="p8.2"></div>
  <h3>8.2 Абстракция через параметризацию</h3>

  <p>Абстракция через параметризацию позволяет, используя параметры, в любом месте программы выполнить одни и те же действия над различными данными. Это делает фунцию более универсальной.</p>
</article>


<!-- 8.3 Абстракция через спецификацию -->
<article class="article">
  <div class="anchor" id="p8.3"></div>
  <h3>8.3 Абстракция через спецификацию</h3>

  <p>Абстракция через параметризацию позволяет не обращаться к телу самой функции, чтобы понять что она делает. Смысл функции должен быть понятен через спецификацию. Спецификачия описывает соглашение между разработчиком и пользователем. Всю информацию для использования функции разработчик помещает в спецификацию. Пользователь использует функцию не полагаясь на ее реализацию а полагаясь только на спецификацию.</p>
  <p>Абстракция через параметризацию и через спецификацию позволяют определить два типа абстраций: процедурную абстракцию и абстракцию данных, каждый из которых использует оба описанных выше подхода.</p>
</article>


<!-- 8.4 Процедурная абстракция -->
<article class="article">
  <div class="anchor" id="p8.4"></div>
  <h3>8.4 Процедурная абстракция</h3>

  <p>Процедурная абстракция - наиболее известный в программировании тип абстракции. Всякий кто использовал подпрограммы, реализовывал тем самым процедурную абстракцию.</p>
  <p>В абстракции через параметризацию мы абстрагируемся от конкретных используемых данных. Нам не важно какие значения имеют данные, важно только их количество и тип.</p>
  <p>В абстракции через спецификацию нам важно <strong>что</strong> делает функция, а не то <strong>как</strong> она это делает.</p>
  <p>Абстракция через спецификацию наделяет структуру программы <strong>локальностью</strong> и <strong>модифицируемостью</strong>.</p>
  <p>Локальность означает, что анализ одной абстракции не зависит от анализа другой абстракции. Это позволяет состовлять программу из абстракций, созданных разными людьми.</p>
  <p>Модифицируемость означает, что изменение реализации абстракции не затрагивает ее спецификацию. Поэтому не нужно вносить изменения в программу, использующую эту абстракцию.</p>
</article>


<!-- 8.5 Абстракция данных -->
<article class="article">
  <div class="anchor" id="p8.5"></div>
  <h3>8.5 Абстракция данных</h3>

  <p>Новые типы данных должны включать в себя абстракции через параметризацию и абстракции через спецификацию. Абстракция через параметризацию осуществляется использованием параметров там, где это имеет смысл. Абстракция через спецификацию достигается за счет того, что мы представляем операции как часть пипа. При отсутствии прямого доступа к данным, имеется необходимый набор операций для работы с данными.</p>
  <p>Абстракция данных позволяет проектировать программу еще до выбора конкретных структур данных, опираясь только на спецификацию абстракции. Потом при выборе или изменении структур данных не нужно будет менять саму программу.</p>
</article>


<!-- 8.6 Классы операций -->
<article class="article">
  <div class="anchor" id="p8.6"></div>
  <h3>8.6 Классы операций</h3>

  <p>Операции абстракции данных распадаются на четыре категории.</p>
  <ol>
    <li>Примитивные конструкторы. Эти операции создают объекты не используя никаких объектов в качестве аргументов.</li>
    <li>Конструкторы. Эти операции используют в качестве аргументов объекты и создают другие объекты такого же типа.</li>
    <li>Модификаторы. Эти операции модифицируют объекты соответствующего им типа. Например, оператор push для стека.</li>
    <li>Наблюдатели. Эти операции используются для получения информации об объекте. Например, оператор size.</li>
  </ol>
</article>


<!-- 8.7 Полнота -->
<article class="article">
  <div class="anchor" id="p8.7"></div>
  <h3>8.7 Полнота</h3>

  <p>Тип данных является полным, если он обеспечивает достаточный набор операций. Абстракция данных должна содержать в себе операции как минимум из трех категорий. Например, примитивные конструкторы, наблюдатели, модификаторы.</p>
</article>
