<a href="#" id="edu-dsr">назад</a>

<h1>2023-10-09 C# типы данных</h1>

2023.10.09 пн (18.30 – 20.00)
Лекция 2 C# типы данных
Меня зовут Екатерина. Я буду вам читать лекции по языку C# в нашем курсе их предусмотрено 2 штуки. Сегодня будет первая лекция. В этой лекции мы в основном будем обсуждать основные конструкции языка, типы, как с ними можно работать, для чего они нужны. Иногда что нужно использовать, что не надо использовать. Преимущества и недостатки. Основная информация для этих лекций была взята из книги Джеффри Рихтера .net by c# CLR. (2013 Рихтер - CLR via C# (4е).pdf) 
Вы можете с ней ознакомиться, она очень большая и я не рекомендую начинать с нее изучение языка. Для начинающих я рекомендую почитать документацию Microsoft. Может быть что-то попроще, но не с этой книги. Если вы хотите углубиться, понять как на самом деле устроена платформа дотнет, что такое IL код, что такое garbage collector и т.д. нужно почитать эту книгу. Лекции у нас будут этому посвящены, но чуть позже.
Сегодня мы будем разговаривать, в основном, про язык C#.
О чем будет эта лекция
- Основные сведения о типах
- Методы, параметры, свойства
- Делегаты и события
- Обобщения
- Интерфейсы и абстрактные классы
Сегодня мы поговорим о типах, какие типы существуют в языке C# на платформе дотнет. Какие существуют члены типов, методы, параметры, свойства. Что такое делегаты и события. Поговорим немного об обобщениях и в конце обсудим интерфейсы, абстрактные классы, в чем различие, что лучше использовать.
1. Основные сведения о типах
Классификация типов
- ссылочный тип (reference type)
- тип значения (value type)
Я надеюсь, что здесь не все новички, а люди знакомые с языком C#. Напишите, кто уже что-то писал на C#. Может что-то в университете, консольные приложения. Чтобы я понимала сколько тут новичков, сколько старичков. 
На платформе дотнет существует два типа – ссылочные типы и типы значения. Что их, в основном, отличает друг от друга. Ссылочный тип хранятся в куче (Heap), а типы значения хранятся в стеке (Stack). То есть, когда мы создаем переменную типа значения int, то в стек будет записана переменная с этим значением. Если мы создаем ссылочный тип, например, экземпляр класса, то в стек будет записана переменная со значением адреса на кучу, в которой размещен экземпляр. Я думаю, что это основа основ. 
Несмотря на это, базовым типом для всех типов в языке является тип Object. Поэтому все стринги, массивы, классы, которые вы объявляете в программе будут неявно наследовать этот тип. Вы можете явно его унаследовать, но это необязательно. Типы значения тоже наследуют тип Object неявным образом. Через тип System.ValueType. Это сделано чтобы любой тип в вашей программе имел минимальный набор методов, например ToString, GetHashCode, Equals.
Приведение и преобразование типов
- Неявное преобразование
Преобразования из меньших в большие целочисленные типы и преобразования из производных классов в базовые классы
// Derived class to base class
Derived d = new Derived();
Base b = d;
// 32-bit int to 64-bit long
Int num = 2147483647;
Long bigNum = num;
- Явное преобразование (приведение)
Способ явно указать компилятору, что необходимо выполнить преобразование и что вам известно, что может произойти потеря данных или приведение может завершиться сбоем во время выполнения.
Double x = 1234.7;
Int a;
a = (int)x;
Так как у нас все типы наследуются, и мы можем их друг другу присваивать, существует механизм приведения и преобразования. Существует неявное преобразование и явное преобразование (приведение). 
Если int занимает меньше памяти 32 бита, то мы можем его без потери данных засунуть в long, который занимает 64 бита. Это можно сделать неявно, ничего не говоря компилятору. Компилятор сам все сделает безопасным способом и все будет хорошо.
Если мы хотим double засунуть в int, мы должны компилятору явно сказать, что мы знаем о возможной потере данных. Мы явно указываем компилятору какой тип мы хотим видеть. Так можно делать со значимыми типами и с сылочными типами. Но даже если компилятор не заругается, в рантайме можно получить исключение и все может рухнуть.
- Пользовательские преобразования
Преобразования выполняются специальными методами, которые можно определить для включения явных и неявных преобразований.
public static implicit operator byte(MyClass d) => d.digit;
public static explicit operator MyClass(byte b) => new MyClass(b);
- Преобразования с использованием вспомогательных классов
System.Convert
Int32.Parse, Double.Parse
и т.д.
Существуют еще пользовательские преобразования. Это операторы явных и неявных преобразований, которые вы описываете в своем классе. Например, тип MyClass приводим к типу byte неявным образом. И явным образом приводим тип byte к типу MyClass. На моей практике еще не было случаев когда эти преобразования были нужны.
Обычно используют вспомогательные классы  - Convert, Parse. Существует большое количество библиотек, которые поддерживают разные преобразования. Стоит только что-нибудь погуглить и все найдете.
Таким образом, мы можем тип наследника всегда привести к базовому типу. И мы знаем, что значимый тип наследуется от типа Object. Значит мы тип можем привести к типу Object. Когда мы приводим значимый тип к типу Object то происходит процесс называемый Упаковка.
Упаковка и распаковка (boxing & unboxing)
Упаковка значимых типов в ссылочные:
1. В управляемой куче выделяется память – длина значимого типа плюс специальные переменные.
2. Поля значимого типа копируются в выделенную память
3. Возвращается адрес объекта
int i = 123; // i – value type
object o = I; // boxing
int j = (int)o; // unboxing
Например, мы переменную типа int засунули в переменную типа object. В этот момент происходит процесс упаковки. Выделяется область памяти в куче (Heap), где хранятся значения ссылочных типов. Туда переносим значение значимого типа. Возвращаем в переменную адрес на эту область памяти в куче. И эта переменная будет себя вести как ссылочный тип.
Unboxing это обратная операция упаковки, когда мы хотим обратно получить значимый тип и снова с ним работать как с интежером. Нам надо его распаковать. Надо сделать явным образом приведение. 
Это не самый быстрый процесс. Это нагружает работу с памятью и процессор. Рекомендуется таких преобразований не делать. Механизм языка позволяет это делать по-другому. Работать со значимыми типами и реализовывать для них такие структуры чтобы можно было с ними работать как со значимыми и как с сылочными типами. Так лучше не делать, но если вы это увидите, то знайте что происходит этот процесс.
2. Из чего состоит тип
Члены типа
Рассмотрим на примере нашего класса Dog. У него есть константа, поле, конструкторы типов, конструкторы экземпляра
Видимость
Модификатор доступа
public – неограниченный доступ
protected – доступен из класса или типам, которые являются производными от содержащего класса
internal – доступен в текущей сборке
protected internal – доступен в текущей сборке и типам, которые являются производными от содержащего класса
private -  доступен только содержащему классу
private protected – доступен содержащему классу и производному классу той же сборки C# 7.2
Статические классы
Статический класс – удобный контейнер для группировки логически связанных членов (методов, полей, свойств или событий), которые не требуют получения или установки каких-либо внутренних полей экземпляра.
3. Константы и поля
Константа (const) – это идентификатор, значение которого никогда не меняется
Поле – это член данных, который хранит экземпляр значимого типа или ссылку на ссылочный тип.
Const (константа компиляции) и readonly (константа времени выполнения) нельзя изменить по коду. Const должна быть инициализирована во время объявления. Readonly можно объявить, а потом инициализировать в конструкторе.
4. Методы
Конструкторы – это специальные методы, позволяющие корректно инициализировать новый экземпляр типа.
Статические конструкторы (конструкторы типов) – это инициализаторы типа. Используются для инициализации любых статических данных или для выполнения определенного действия, которое необходимо выполнить только один раз.
Виртуальные методы
Виртуальные члены класса могут быть переопределены в классе потомке
За счет виртуальных членов реализуется свойство ООП – полиморфизм
Нельзя вызывать виртуальные члены в конструкторе.
Методы расширений (extensions)
5. Параметры
Параметры методов
По умолчанию параметры передаются по значению.
- Для типов значений – копируется реальное значение в новую переменную
- Для ссылочных типов – копируется ссылка в новую переменную
Ключевые слова out и ref позволяют передавать объекты по ссылке.
6. Свойства
Особенности: 
- в отличие от полей, можно регулировать доступ отдельно на чтение, отдельно на запись.
- свойства, по сути методы, могут вызывать исключения
- свойства нельзя передать в метод с ключевым словом ref или out.
7. Делегаты
Делегат – это тип, представляющий из себя цепочку ссылок на методы с определенными входными параметрами и типом возвращаемого значения
8. События
События – вид членов, которые можно определить в типе. Если в типе определено событие, то этот тип (или экземпляр) может уведомлять другие объекты о некоторых особых ситуациях, которые могут случиться.
9. Обобщения (Generic)
Обобщения – это еще один механизм, позволяющий многократно использовать универсальный код.
Ограничения обобщений
10. Интерфейсы и абстрактные классы
Интерфейс – это именованный набор сигнатур методов. Если какой-то класс имплементирует интерфейс, он обязан реализовать все описанные с нем методы.
Для чего нужны интерфейсы:
- Единый контракт
- Уменьшение связности кода (SOLID)
- Множественное наследование
Абстрактный класс – это класс, в котором есть хотя бы один абстрактный член (сигнатура которого объявлена, а реализация не определена)
Абстрактный класс не может иметь экземпляра. От абстрактного класса должен унаследоваться другой класс и реализовать абстрактные методы.
Когда использовать абстрактные классы, а когда интерфейсы?
- Абстрактный класс используется когда есть система связанных типов, и требуется реализовать для них базовую функциональность, которую они будут использовать
- Интерфейсы же используются как описание некоторого перечня функций, присущих разрозненным объектам, каждый из которых реализует интерфейс по-своему.
Вопросы.
В следующей лекции мы будем разговаривать про более практические вещи, которые обязательно вам пригодятся на практике. Будем говорить про async, await. Будем говорить про асинхронное параллельное программирование. Про exception. Будут немного более сложные вещи, но более интересные и более практически важные.
Как событие работает в коде?
Событие может быть вызвано только в том классе, которое его объявило. Компилятор преобразует событие в закрытое поле с двумя методами Add и Remove. Add добавляет событие, Remove удаляет. Так как поле закрытое, то вызвать событие можно только из класса, в котором оно объявлено. В другом классе на него можно подписаться (начать его слушать).
Вам не придется самим выделять потоки и их дерижировать. Вам придется работать с тасками и с асинхронным кодом. Может быть обсудим что-то связанное с мониторами, локами, семафорами если хватит времени.
