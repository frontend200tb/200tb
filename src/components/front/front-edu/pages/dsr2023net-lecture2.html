<a href="#" id="edu-dsr">назад</a>

<h1>2023-10-09 Lecture #2 C# типы данных</h1>

<ul>

  <li>
    <p>Лекцию читает Екатерина</p>
  </li>

  <li>
    <p>Меня зовут Екатерина. Я буду вам читать лекции по языку C#. В нашем курсе их предусмотрено 2 штуки. Сегодня будет первая лекция. В этой лекции мы в основном будем обсуждать основные конструкции языка, типы, как с ними можно работать, для чего они нужны. Иногда что лучше использовать, что не надо использовать. Преимущества и недостатки. Основная информация для этих лекций была взята из книги Джеффри Рихтера .net by c# CLR. (2013 Рихтер - CLR via C# (4е).pdf) </p>
    <p>Вы можете с ней ознакомиться, она очень большая и я не рекомендую начинать с нее изучение языка. Для начинающих я рекомендую почитать документацию Microsoft. Может быть что-то попроще, но не с этой книги. Если вы хотите углубиться, понять как на самом деле устроена платформа дотнет, что такое IL код, что такое garbage collector и т.д. нужно почитать эту книгу. Лекции у нас будут этому посвящены, но чуть позже. Сегодня мы будем разговаривать, в основном, про язык C#.</p>
  </li>
  
  <li>
    <h3>О чем будет эта лекция</h3>
    <p>- Основные сведения о типах
    <br>- Методы, параметры, свойства
    <br>- Делегаты и события
    <br>- Обобщения
    <br>- Интерфейсы и абстрактные классы</p>
  </li>
  
  <li>
    <p>Сегодня мы поговорим о типах, какие типы существуют в языке C# на платформе дотнет. Какие существуют члены типов, методы, параметры, свойства. Что такое делегаты и события. Поговорим немного об обобщениях и в конце обсудим интерфейсы, абстрактные классы, в чем различие, что лучше использовать.</p>
  </li>
  
  <li>
    <h3>1. Основные сведения о типах</h3>
    <h3>Классификация типов</h3>
    <p>- ссылочный тип (reference type)
    <br>- тип значения (value type)
    <br>В стеке (stack) хранятся типы значения (value types) и указатели на ссылочные типы (pointers to the reference type)
    <br>В куче (heap) хранятся ссылочные типы (reference types)
    </p>
  </li>
  
  <li>
    <p>Я надеюсь, что здесь не все новички, а люди знакомые с языком C#. Напишите, кто уже что-то писал на C#. Может что-то в университете, консольные приложения. Чтобы я понимала сколько тут новичков, сколько старичков. Для одних надо пояснить некоторые моменты, для других напомнить.</p>
    <p>На платформе дотнет существует два типа данных – ссылочные типы и типы значения. Что их, в основном, отличает друг от друга. Ссылочный тип хранятся в куче (Heap), а типы значения хранятся в стеке (Stack). То есть, когда мы создаем переменную типа значения int, то в стек будет записана переменная с этим значением. int равный трем будет лежать в стеке так как он есть. Если мы создаем ссылочный тип, например, экземпляр класса, то в стек будет записана переменная со значением адреса на кучу, в которой размещен экземпляр. Я думаю, что это основа основ.</p>
    <p>Несмотря на это, базовым типом для всех типов в языке является тип Object. Поэтому все стринги, массивы, классы, которые вы объявляете в программе будут неявно наследовать этот тип. Вы можете явно его унаследовать, но это необязательно. Типы значения тоже наследуют тип Object неявным образом. Через тип System.ValueType. Это сделано чтобы любой тип в вашей программе имел минимальный набор методов, например ToString, GetHashCode, Equals.</p>
  </li>
  
  <li>
    <h3>Приведение и преобразование типов</h3>
  </li>
  
  <li>
    <h3>- Неявное преобразование</h3>
    <p>Преобразования из меньших в большие целочисленные типы и преобразования из производных классов в базовые классы
    <br>// Derived class to base class
    <br>Derived d = new Derived();
    <br>Base b = d;
    <br>
    <br>// 32-bit int to 64-bit long
    <br>Int num = 2147483647;
    <br>Long bigNum = num;
    </p>
  </li>
  
  <li>
    <h3>- Явное преобразование (приведение)</h3>
    <p>Способ явно указать компилятору, что необходимо выполнить преобразование и что вам известно, что может произойти потеря данных или приведение может завершиться сбоем во время выполнения.
    <br>Double x = 1234.7;
    <br>Int a;
    <br>a = (int)x;
    </p>
  </li>
  
  <li>
    <p>Так как у нас все типы наследуются, и мы можем их друг другу присваивать, существует механизм приведения и преобразования. Существует неявное преобразование и явное преобразование (приведение).</p>
    <p>Неявное преобразование работает при преобразовании производных классов в базовые классы. Это когда мы переменную типа наследника присваиваем в переменную базового класса.</p>
    <p>Тоже самое работает для значимых системных типов. Например int и long. Если int занимает меньше памяти 32 бита, то мы можем его без потери данных засунуть в long, который занимает 64 бита. Это можно сделать неявно, ничего не говоря компилятору. Компилятор сам все сделает безопасным способом и все будет хорошо.</p>
    <p>Но еще существует явное преобразование, оно называется приведение типов. Оно работает когда мы хотим double засунуть в int, мы должны компилятору явно сказать, что мы знаем о возможной потере данных. Мы явно указываем компилятору какой тип мы хотим видеть. Так можно делать со значимыми типами и с сылочными типами. Но даже если компилятор не заругается, в рантайме можно получить исключение invalid cast exception и все может рухнуть.</p>
  </li>
  
  <li>
    <h3>- Пользовательские преобразования</h3>
    <p>Преобразования выполняются специальными методами, которые можно определить для включения явных и неявных преобразований.
    <br>public static implicit operator byte(MyClass d) => d.digit;
    <br>public static explicit operator MyClass(byte b) => new MyClass(b);
    </p>

    <h3>- Преобразования с использованием вспомогательных классов</h3>
    <p>System.Convert
    <br>Int32.Parse, Double.Parse
    <br>и т.д.
    </p>
  </li>
  
  <li>
    <p>Существуют еще пользовательские преобразования. Это операторы явных и неявных преобразований, которые вы описываете в своем классе. Например, тип MyClass приводим к типу byte неявным образом. И явным образом приводим тип byte к типу MyClass. Мы подробно не будем останавливаться на этих оперетарах. Просто знайте что они есть. Если хотите, побольше прочитайте о них. На моей практике еще не было случаев когда эти преобразования были нужны. Обычно используют вспомогательные классы  - System.Convert, Int.Parse, Double.Parse и другие. Существует большое количество библиотек, которые поддерживают разные преобразования. Стоит только что-нибудь погуглить и все найдете.</p>
    <p>Таким образом, мы можем тип наследника всегда привести к базовому типу. И мы знаем, что значимый тип наследуется от типа Object. Значит мы тип можем привести к типу Object. Когда мы приводим значимый тип к типу Object то происходит процесс называемый Упаковка.</p>
  </li>
  
  <li>
    <h3>Упаковка и распаковка (boxing & unboxing)</h3>
  </li>
  
  <li>
    <h3>Упаковка значимых типов в ссылочные:</h3>
    <p>1. В управляемой куче выделяется память – длина значимого типа плюс специальные переменные.
    <br>2. Поля значимого типа копируются в выделенную память
    <br>3. Возвращается адрес объекта
    <br>
    <br>int i = 123; // i – value type
    <br>object o = I; // boxing
    <br>int j = (int)o; // unboxing
    </p>
  </li>
  
  <li>
    <p>В чем заключается этот процесс. Давайте посмотрим на пример. У нас есть переменная типа int. Мы ее создали, инициализировали и потом засунулимв переменную типа object. В этот момент происходит процесс упаковки. Выделяется область памяти в куче (Heap), где хранятся значения ссылочных типов. Туда переносим значение значимого типа. Возвращаем в переменную адрес на эту область памяти в куче. И эта переменная будет себя вести как ссылочный тип.</p>
  </li>
  
  <li>
    <p>Unboxing это обратная операция упаковки, когда мы хотим обратно получить значимый тип и снова с ним работать как с интежером. А не постоянно натыкаться на проблемы, что это объект и мы не можем складывать. Мы хотим дальше с ним работать как с интом. Нам надо его распаковать. Надо сделать явным образом приведение. И у нас в переменной j будет снова тип значения как он и был в переменной i изначально. Я надеюсь здесь все понятно.</p>
    <p>Это не самый быстрый процесс. Это нагружает работу с памятью и процессор. Рекомендуется таких преобразований не делать. Механизм языка позволяет это делать по-другому. Работать со значимыми типами и реализовывать для них такие структуры чтобы можно было с ними работать как со значимыми и как с сылочными типами. Так лучше не делать, но если вы это увидите, то знайте что происходит этот процесс.</p>
  </li>
  
  <li>
    <h3>2. Из чего состоит тип</h3>
  </li>
  
  <li>
    <h3>Члены типа</h3>
    <p>Рассмотрим на примере класса Dog, который я создала. Подробнее мы будем обсуждать чуть позже в нашей лекции. Пока давайте ознакомимся с конструкциями, которые у него есть. У него есть следующие члены. У него есть константа - это поле времени компиляции которая будет подставлена в нужном месте. Здесь я создала стринговую константу "woof" как будет собачка говорить. Дальше я создала поле name. Обернула его в свойство. Вся эта конструкция может быть заменена на тривиальное автосгенерированное проперти { get; set; }. Мы это обсудим попозже.</p> 
    <p>Дальше у нас есть конструкторы типов. Они помечены ключевым словом static. И конструкторы экземпляров. Их может быть сколько угодно. Они могут быть с параметрами или без, public или private. Это тоже мы обсудим. Может быть какие-то методы для работы с нашим классом. Например, собачка умеет гавкать в методе Bark. Дальше могут быть переопределены операторы. Например, оператор равенства == и оператор неравенства !=. Я здесь не написала никакой реализации данного метода. Просто чтобы была видна сигнатура.</p> 
    <p>Дальше есть операторы явного преобразования. Я из животного хочу создавать собачку. Здесь какая-то логика должна быть. Но я поленилась и ее не добавила. И есть событие, которое помечается ключевым словом event. Оно имеет тип делегата. Событие того, что собачка заскулила.</p>
    <p>Любой класс может содержать вложенные типы. Например, у меня тип enum перечисление. Здесь три собачки - лабрадор, бигль и корги. Давайте посмотрим подробнее на каждый из этих компонентов класса. Но в начале мы поговорим, конечно же, про видимость. У нас класс, поле, свойство помечены модификатором. На самом деле есть модификаторы по умолчанию. Например у класса это internal. У поля и свойства это private. Но хорошая практика это везде писать модификатор. Чтобы не заставлять других разработчиков и себя самого через какое-то время вспоминать а какой же здесь модификатор по умолчанию. И код выглядит более лаконично и аккуратно.</p>
  </li>
  
  <li>
    <h3>Видимость</h3>
  </li>
  
  <li>
    <h3>Модификатор доступа</h3>
    <p>public – неограниченный доступ
    <br>protected – доступен из класса или типам, которые являются производными от содержащего класса
    <br>internal – доступен в текущей сборке
    <br>protected internal – доступен в текущей сборке и типам, которые являются производными от содержащего класса
    <br>private -  доступен только содержащему классу
    <br>private protected – доступен содержащему классу и производному классу той же сборки C# 7.2
    </p>
  </li>
  
  <li>
    <p>Давайте быстренько по ним пройдемся. Public это неограниченный достуа. Все что вы пометили public будет видно везде, во всех сборках, во всех классах. Его можно достать, посмотреть, изменить. Protected доступен только внутри класса, который его объявил, и внутри классов наследников. Internal доступен в текущей сборке. Если вы дернули себе откуда то dll и засунули напрямую к себе в приложение, то все что там помечено internal не будет доступно в вашем классе. Потому что он из другой сборки. Protected internal это небольшое расширение видимости internal. Доступен и в производных от данного класса. Private доступен только из содержащего его класса. Private protected расширяет видимость private. Доступен также производному классу той же сборки. Производный класс из другой сборки его уже не видит.</p>
  </li>

  <li>
    <h3>Статические классы</h3>
    <p>Статический класс – удобный контейнер для группировки логически связанных членов (методов, полей, свойств или событий), которые не требуют получения или установки каких-либо внутренних полей экземпляра.
    <br>- Имеет модификатор static
    <br>- Содержит только статические члены
    <br>- Невозможно создать экземпляр
    <br>- Не может содержать конструкторы экземпляров
    <br>- Не может быть унаследован
    <br>- Не может наследовать ни один класс или интерфейс, кроме Object
  </li>
  
  <li>
    <p>Статические классы это те же классы, помеченые ключевым словом static. Все члены статического класса тоже должны быть помечены ключевым словом static. Зачем же такие классы создавать. Данные классы не могут содержать конструкторов экземпляра. Потому что они в принципе не могут иметь экземпляры. Они могут иметь конструкторы типов, которые инициализируют значения статических членов класса. Вы не знаете когда ваш класс будет создан, это регулируется непосредственно компилятором. Но мы знаем точно и наверняка, что он будет создан до того как мы обратимся к любому его члену. Время его жизни равно жизни приложения. Как работать с этим классом.</p> 
    <p>Например, все знают класс Math для работы с математическими операциями. Там много методов, например Abs, Min. Мы не используем слово new, мы не создаем новый экземпляр класса. Мы просто пишем имя класса, точка, имя метода, круглые скобки с параметрами, например Math.Min(int a, int b).</p>
    <p>Или более практический пример. В вашем приложении вы хотите делать валидацию. И у вас много формочек, где пользователь вводит имя, телефон, емейл... Вы написали кучу правил валидации. И хотите отображать сообщение а что конкретно произошло не так. Когда пользователь, например, не ввел имя. Вы хотите показать "Username is required". Вы везде инлайново повтыкали эти строки. Потом вы поняли что это повторение кода. Тогда мы создаем статический класс ValidationMessages и помещаем в него все сообщения, связанные с валидацией. Тогда в нашем сервисе просто выводим поле статического класса вместо сообщения. ToastService.Show(ValidationMessages.UsernameRequired). Нам компилятор подскажет что там должно быть чтобы мы не ошиблись.</p> 
    <p>Главное использование статических классов - для того чтобы сгруппировать связанные члены (методы, поля, свойства, события). И чтобы их было удобно доставать. Состояния здесь нет, экземпляров нет. Поэтому мы их используем через имя класса.</p>
  </li>

  <li>
    <h3>Вопрос: Какая разница между private protected и protected</h3>
    <p>Private доступен только данному классу. Поле private доступно только методам, операторам, свойствам, конструктору данного класса.</p>
  </li>
  <li>
    <h3>3. Константы и поля</h3>
  </li>
  
  Константа (const) – это идентификатор, значение которого никогда не меняется
  Поле – это член данных, который хранит экземпляр значимого типа или ссылку на ссылочный тип.
  Const (константа компиляции) и readonly (константа времени выполнения) нельзя изменить по коду. Const должна быть инициализирована во время объявления. Readonly можно объявить, а потом инициализировать в конструкторе.
  4. Методы
  Конструкторы – это специальные методы, позволяющие корректно инициализировать новый экземпляр типа.
  Статические конструкторы (конструкторы типов) – это инициализаторы типа. Используются для инициализации любых статических данных или для выполнения определенного действия, которое необходимо выполнить только один раз.
  Виртуальные методы
  Виртуальные члены класса могут быть переопределены в классе потомке
  За счет виртуальных членов реализуется свойство ООП – полиморфизм
  Нельзя вызывать виртуальные члены в конструкторе.
  Методы расширений (extensions)
  5. Параметры
  Параметры методов
  По умолчанию параметры передаются по значению.
  - Для типов значений – копируется реальное значение в новую переменную
  - Для ссылочных типов – копируется ссылка в новую переменную
  Ключевые слова out и ref позволяют передавать объекты по ссылке.
  6. Свойства
  Особенности: 
  - в отличие от полей, можно регулировать доступ отдельно на чтение, отдельно на запись.
  - свойства, по сути методы, могут вызывать исключения
  - свойства нельзя передать в метод с ключевым словом ref или out.
  7. Делегаты
  Делегат – это тип, представляющий из себя цепочку ссылок на методы с определенными входными параметрами и типом возвращаемого значения
  8. События
  События – вид членов, которые можно определить в типе. Если в типе определено событие, то этот тип (или экземпляр) может уведомлять другие объекты о некоторых особых ситуациях, которые могут случиться.
  9. Обобщения (Generic)
  Обобщения – это еще один механизм, позволяющий многократно использовать универсальный код.
  Ограничения обобщений
  10. Интерфейсы и абстрактные классы
  Интерфейс – это именованный набор сигнатур методов. Если какой-то класс имплементирует интерфейс, он обязан реализовать все описанные с нем методы.
  Для чего нужны интерфейсы:
  - Единый контракт
  - Уменьшение связности кода (SOLID)
  - Множественное наследование
  Абстрактный класс – это класс, в котором есть хотя бы один абстрактный член (сигнатура которого объявлена, а реализация не определена)
  Абстрактный класс не может иметь экземпляра. От абстрактного класса должен унаследоваться другой класс и реализовать абстрактные методы.
  Когда использовать абстрактные классы, а когда интерфейсы?
  - Абстрактный класс используется когда есть система связанных типов, и требуется реализовать для них базовую функциональность, которую они будут использовать
  - Интерфейсы же используются как описание некоторого перечня функций, присущих разрозненным объектам, каждый из которых реализует интерфейс по-своему.
  Вопросы.
  В следующей лекции мы будем разговаривать про более практические вещи, которые обязательно вам пригодятся на практике. Будем говорить про async, await. Будем говорить про асинхронное параллельное программирование. Про exception. Будут немного более сложные вещи, но более интересные и более практически важные.
  Как событие работает в коде?
  Событие может быть вызвано только в том классе, которое его объявило. Компилятор преобразует событие в закрытое поле с двумя методами Add и Remove. Add добавляет событие, Remove удаляет. Так как поле закрытое, то вызвать событие можно только из класса, в котором оно объявлено. В другом классе на него можно подписаться (начать его слушать).
  Вам не придется самим выделять потоки и их дерижировать. Вам придется работать с тасками и с асинхронным кодом. Может быть обсудим что-то связанное с мониторами, локами, семафорами если хватит времени.
</ul>
