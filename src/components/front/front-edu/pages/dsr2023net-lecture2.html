<a href="#" id="edu-dsr">назад</a>

<h1>2023-10-09 Lecture #2 C# типы данных</h1>

<ul>

  <li>
    <p>Лекцию читает Екатерина</p>
  </li>

  <li>
    <p>Меня зовут Екатерина. Я буду вам читать лекции по языку C#. В нашем курсе их предусмотрено 2 штуки. Сегодня будет первая лекция. В этой лекции мы в основном будем обсуждать основные конструкции языка, типы, как с ними можно работать, для чего они нужны. Иногда что лучше использовать, что не надо использовать. Преимущества и недостатки. Основная информация для этих лекций была взята из книги Джеффри Рихтера .net by c# CLR. (2013 Рихтер - CLR via C# (4е).pdf) </p>
    <p>Вы можете с ней ознакомиться, она очень большая и я не рекомендую начинать с нее изучение языка. Для начинающих я рекомендую почитать документацию Microsoft. Может быть что-то попроще, но не с этой книги. Если вы хотите углубиться, понять как на самом деле устроена платформа дотнет, что такое IL код, что такое garbage collector и т.д. нужно почитать эту книгу. Лекции у нас будут этому посвящены, но чуть позже. Сегодня мы будем разговаривать, в основном, про язык C#.</p>
  </li>
  
  <li>
    <h3>О чем будет эта лекция</h3>
    <p>- Основные сведения о типах
    <br>- Методы, параметры, свойства
    <br>- Делегаты и события
    <br>- Обобщения
    <br>- Интерфейсы и абстрактные классы</p>
  </li>
  
  <li>
    <p>Сегодня мы поговорим о типах, какие типы существуют в языке C# на платформе дотнет. Какие существуют члены типов, методы, параметры, свойства. Что такое делегаты и события. Поговорим немного об обобщениях и в конце обсудим интерфейсы, абстрактные классы, в чем различие, что лучше использовать.</p>
  </li>
  
  <li>
    <h3>1. Основные сведения о типах</h3>
    <h3>Классификация типов</h3>
    <p>- ссылочный тип (reference type)
    <br>- тип значения (value type)
    <br>В стеке (stack) хранятся типы значения (value types) и указатели на ссылочные типы (pointers to the reference type)
    <br>В куче (heap) хранятся ссылочные типы (reference types)
    </p>
  </li>
  
  <li>
    <p>Я надеюсь, что здесь не все новички, а люди знакомые с языком C#. Напишите, кто уже что-то писал на C#. Может что-то в университете, консольные приложения. Чтобы я понимала сколько тут новичков, сколько старичков. Для одних надо пояснить некоторые моменты, для других напомнить.</p>
    <p>На платформе дотнет существует два типа данных – ссылочные типы и типы значения. Что их, в основном, отличает друг от друга. Ссылочный тип хранятся в куче (Heap), а типы значения хранятся в стеке (Stack). То есть, когда мы создаем переменную типа значения int, то в стек будет записана переменная с этим значением. int равный трем будет лежать в стеке так как он есть. Если мы создаем ссылочный тип, например, экземпляр класса, то в стек будет записана переменная со значением адреса на кучу, в которой размещен экземпляр. Я думаю, что это основа основ.</p>
    <p>Несмотря на это, базовым типом для всех типов в языке является тип Object. Поэтому все стринги, массивы, классы, которые вы объявляете в программе будут неявно наследовать этот тип. Вы можете явно его унаследовать, но это необязательно. Типы значения тоже наследуют тип Object неявным образом. Через тип System.ValueType. Это сделано чтобы любой тип в вашей программе имел минимальный набор методов, например ToString, GetHashCode, Equals.</p>
  </li>
  
  <li>
    <h3>Приведение и преобразование типов</h3>
  </li>
  
  <li>
    <h3>- Неявное преобразование</h3>
    <p>Преобразования из меньших в большие целочисленные типы и преобразования из производных классов в базовые классы
    <br>// Derived class to base class
    <br>Derived d = new Derived();
    <br>Base b = d;
    <br>
    <br>// 32-bit int to 64-bit long
    <br>Int num = 2147483647;
    <br>Long bigNum = num;
    </p>
  </li>
  
  <li>
    <h3>- Явное преобразование (приведение)</h3>
    <p>Способ явно указать компилятору, что необходимо выполнить преобразование и что вам известно, что может произойти потеря данных или приведение может завершиться сбоем во время выполнения.
    <br>Double x = 1234.7;
    <br>Int a;
    <br>a = (int)x;
    </p>
  </li>
  
  <li>
    <p>Так как у нас все типы наследуются, и мы можем их друг другу присваивать, существует механизм приведения и преобразования. Существует неявное преобразование и явное преобразование (приведение).</p>
    <p>Неявное преобразование работает при преобразовании производных классов в базовые классы. Это когда мы переменную типа наследника присваиваем в переменную базового класса.</p>
    <p>Тоже самое работает для значимых системных типов. Например int и long. Если int занимает меньше памяти 32 бита, то мы можем его без потери данных засунуть в long, который занимает 64 бита. Это можно сделать неявно, ничего не говоря компилятору. Компилятор сам все сделает безопасным способом и все будет хорошо.</p>
    <p>Но еще существует явное преобразование, оно называется приведение типов. Оно работает когда мы хотим double засунуть в int, мы должны компилятору явно сказать, что мы знаем о возможной потере данных. Мы явно указываем компилятору какой тип мы хотим видеть. Так можно делать со значимыми типами и с сылочными типами. Но даже если компилятор не заругается, в рантайме можно получить исключение invalid cast exception и все может рухнуть.</p>
  </li>
  
  <li>
    <h3>- Пользовательские преобразования</h3>
    <p>Преобразования выполняются специальными методами, которые можно определить для включения явных и неявных преобразований.
    <br>public static implicit operator byte(MyClass d) => d.digit;
    <br>public static explicit operator MyClass(byte b) => new MyClass(b);
    </p>

    <h3>- Преобразования с использованием вспомогательных классов</h3>
    <p>System.Convert
    <br>Int32.Parse, Double.Parse
    <br>и т.д.
    </p>
  </li>
  
  <li>
    <p>Существуют еще пользовательские преобразования. Это операторы явных и неявных преобразований, которые вы описываете в своем классе. Например, тип MyClass приводим к типу byte неявным образом. И явным образом приводим тип byte к типу MyClass. Мы подробно не будем останавливаться на этих оперетарах. Просто знайте что они есть. Если хотите, побольше прочитайте о них. На моей практике еще не было случаев когда эти преобразования были нужны. Обычно используют вспомогательные классы  - System.Convert, Int.Parse, Double.Parse и другие. Существует большое количество библиотек, которые поддерживают разные преобразования. Стоит только что-нибудь погуглить и все найдете.</p>
    <p>Таким образом, мы можем тип наследника всегда привести к базовому типу. И мы знаем, что значимый тип наследуется от типа Object. Значит мы тип можем привести к типу Object. Когда мы приводим значимый тип к типу Object то происходит процесс называемый Упаковка.</p>
  </li>
  
  <li>
    <h3>Упаковка и распаковка (boxing & unboxing)</h3>
  </li>
  
  <li>
    <h3>Упаковка значимых типов в ссылочные:</h3>
    <p>1. В управляемой куче выделяется память – длина значимого типа плюс специальные переменные.
    <br>2. Поля значимого типа копируются в выделенную память
    <br>3. Возвращается адрес объекта
    <br>
    <br>int i = 123; // i – value type
    <br>object o = I; // boxing
    <br>int j = (int)o; // unboxing
    </p>
  </li>
  
  <li>
    <p>В чем заключается этот процесс. Давайте посмотрим на пример. У нас есть переменная типа int. Мы ее создали, инициализировали и потом засунулимв переменную типа object. В этот момент происходит процесс упаковки. Выделяется область памяти в куче (Heap), где хранятся значения ссылочных типов. Туда переносим значение значимого типа. Возвращаем в переменную адрес на эту область памяти в куче. И эта переменная будет себя вести как ссылочный тип.</p>
  </li>
  
  <li>
    <p>Unboxing это обратная операция упаковки, когда мы хотим обратно получить значимый тип и снова с ним работать как с интежером. А не постоянно натыкаться на проблемы, что это объект и мы не можем складывать. Мы хотим дальше с ним работать как с интом. Нам надо его распаковать. Надо сделать явным образом приведение. И у нас в переменной j будет снова тип значения как он и был в переменной i изначально. Я надеюсь здесь все понятно.</p>
    <p>Это не самый быстрый процесс. Это нагружает работу с памятью и процессор. Рекомендуется таких преобразований не делать. Механизм языка позволяет это делать по-другому. Работать со значимыми типами и реализовывать для них такие структуры чтобы можно было с ними работать как со значимыми и как с сылочными типами. Так лучше не делать, но если вы это увидите, то знайте что происходит этот процесс.</p>
  </li>
  
  <li>
    <h3>2. Из чего состоит тип</h3>
  </li>
  
  <li>
    <h3>Члены типа</h3>
    <p>Рассмотрим на примере класса Dog, который я создала. Подробнее мы будем обсуждать чуть позже в нашей лекции. Пока давайте ознакомимся с конструкциями, которые у него есть. У него есть следующие члены. У него есть константа - это поле времени компиляции которая будет подставлена в нужном месте. Здесь я создала стринговую константу "woof" как будет собачка говорить. Дальше я создала поле name. Обернула его в свойство. Вся эта конструкция может быть заменена на тривиальное автосгенерированное проперти { get; set; }. Мы это обсудим попозже.</p> 
    <p>Дальше у нас есть конструкторы типов. Они помечены ключевым словом static. И конструкторы экземпляров. Их может быть сколько угодно. Они могут быть с параметрами или без, public или private. Это тоже мы обсудим. Может быть какие-то методы для работы с нашим классом. Например, собачка умеет гавкать в методе Bark. Дальше могут быть переопределены операторы. Например, оператор равенства == и оператор неравенства !=. Я здесь не написала никакой реализации данного метода. Просто чтобы была видна сигнатура.</p> 
    <p>Дальше есть операторы явного преобразования. Я из животного хочу создавать собачку. Здесь какая-то логика должна быть. Но я поленилась и ее не добавила. И есть событие, которое помечается ключевым словом event. Оно имеет тип делегата. Событие того, что собачка заскулила.</p>
    <p>Любой класс может содержать вложенные типы. Например, у меня тип enum перечисление. Здесь три собачки - лабрадор, бигль и корги. Давайте посмотрим подробнее на каждый из этих компонентов класса. Но в начале мы поговорим, конечно же, про видимость. У нас класс, поле, свойство помечены модификатором. На самом деле есть модификаторы по умолчанию. Например у класса это internal. У поля и свойства это private. Но хорошая практика это везде писать модификатор. Чтобы не заставлять других разработчиков и себя самого через какое-то время вспоминать а какой же здесь модификатор по умолчанию. И код выглядит более лаконично и аккуратно.</p>
  </li>
  
  <li>
    <h3>Видимость</h3>
  </li>
  
  <li>
    <h3>Модификатор доступа</h3>
    <p>public – неограниченный доступ
    <br>protected – доступен из класса или типам, которые являются производными от содержащего класса
    <br>internal – доступен в текущей сборке
    <br>protected internal – доступен в текущей сборке и типам, которые являются производными от содержащего класса
    <br>private -  доступен только содержащему классу
    <br>private protected – доступен содержащему классу и производному классу той же сборки C# 7.2
    </p>
  </li>
  
  <li>
    <p>Давайте быстренько по ним пройдемся.</p>
    <p>Public это неограниченный достуа. Все что вы пометили public будет видно везде, во всех сборках, во всех классах. Его можно достать, посмотреть, изменить.</p> 
    <p>Protected доступен только внутри класса, который его объявил, и внутри классов наследников. Дальше мы не можем никак его посмотреть.</p> 
    <p>Internal доступен в текущей сборке. Если вы достали dll, подгрузили или взяли из другого проекта, и засунули к себе в приложение, то все что там помечено internal не будет доступно в вашем классе. Потому что он из другой сборки.</p> 
    <p>Protected internal это небольшое расширение видимости internal. Доступен в текущей сборке и в производных типах от данного класса.</p> 
    <p>Private доступен только из содержащего его класса.</p> 
    <p>Private protected расширяет видимость private. Доступен также производному классу той же сборки. Производный класс из другой сборки его уже не видит.</p>
  </li>

  <li>
    <h3>Статические классы</h3>
    <p>Статический класс – удобный контейнер для группировки логически связанных членов (методов, полей, свойств или событий), которые не требуют получения или установки каких-либо внутренних полей экземпляра.
    <br>- Имеет модификатор static
    <br>- Содержит только статические члены
    <br>- Невозможно создать экземпляр
    <br>- Не может содержать конструкторы экземпляров
    <br>- Не может быть унаследован
    <br>- Не может наследовать ни один класс или интерфейс, кроме Object
  </li>
  
  <li>
    <p>Статические классы это те же классы, помеченые ключевым словом static. Все члены статического класса тоже должны быть помечены ключевым словом static. Зачем же такие классы создавать. Данные классы не могут содержать конструкторов экземпляра. Потому что они в принципе не могут иметь экземпляры. Они могут иметь конструкторы типов, которые инициализируют значения статических членов класса. Вы не знаете когда ваш класс будет создан, это регулируется непосредственно компилятором. Но мы знаем точно и наверняка, что он будет создан до того как мы обратимся к любому его члену. Время его жизни равно жизни приложения. Как работать с этим классом.</p> 
    <p>Например, все знают класс Math для работы с математическими операциями. Там много методов, например Abs, Min. Мы не используем слово new, мы не создаем новый экземпляр класса. Мы просто пишем имя класса, точка, имя метода, круглые скобки с параметрами, например Math.Min(int a, int b).</p>
    <p>Или более практический пример. В вашем приложении вы хотите делать валидацию. И у вас много формочек, где пользователь вводит имя, телефон, емейл... Вы написали кучу правил валидации. И хотите отображать сообщение а что конкретно произошло не так. Когда пользователь, например, не ввел имя. Вы хотите показать "Username is required". Вы везде инлайново повтыкали эти строки. Потом вы поняли что это повторение кода. Тогда мы создаем статический класс ValidationMessages и помещаем в него все сообщения, связанные с валидацией. Тогда в нашем сервисе просто выводим поле статического класса вместо сообщения. ToastService.Show(ValidationMessages.UsernameRequired). Нам компилятор подскажет что там должно быть чтобы мы не ошиблись.</p> 
    <p>Главное использование статических классов - для того чтобы сгруппировать связанные члены (методы, поля, свойства, события). И чтобы их было удобно доставать. Состояния здесь нет, экземпляров нет. Поэтому мы их используем через имя класса.</p>
  </li>

  <li>
    <h3>Вопрос: Какая разница между private protected и protected</h3>
    <p>Private доступен только данному классу. Например вы создали класс Dog. Его свойство private name доступно только методам, свойству, конструктору данного класса. Поле private доступно только методам, операторам, свойствам, конструктору данного класса. То есть вы не сможете написать new Dog, засунуть его в переменную и попытаться достать поле name. Потому что его оттуда уже не видно. Поэтому мы пишем слово private, когда не хотим показывать вызывающему коду поле private name. Private protected открывает это поле для всех производных класса Dog  в текущей сборке.</p>
  </li>

  <li>
    <h3>Вопрос: Почему свойства объявленные как const в классе static мы не помечаем как sttic?</h3>
    <p>Потому что константы по умолчанию уже static. В данном случае это синонимы. Как const static.</p>
  </li>

  <li>
    <h3>3. Константы и поля</h3>
    <p>  Константа (const) – это идентификатор, значение которого никогда не меняется
    <br>Поле – это член данных, который хранит экземпляр значимого типа или ссылку на ссылочный тип.
    </p>
  </li>
  
  <li>
    Константу надо понимать как константу компиляции. Это значит, что в момент когда скомпилировался код, везде вместо имени константы будет вставлено значение константы. Это немножко оптимизирует время выполнения кода. Потому что программа не будет каждый раз искать по имени константы ее значение где-то там в памяти.
  </li>

  <li>
    Поле это член данных, который зависит от типа. Может содержать значимый тип, ссылочный тип. Инициализируется во время выполнения. Константу никак нельзя инициализировать во время выполнения - она не изменяема. Поле мы можем инициализировать во время выполнения и потом изменить.
  </li>

  <li>
    Чем отличается константа и поле readonly? Всем, кроме того что их нельзя изменить по коду. Константа это константа компиляции. Readonly это константа времени выполнения. Readonly поле может быть инициализировано только в конструкторе и больше нигде. И когда компилятор будет натыкаться на это поле, он будет ходить и спрашивать "а чему оно равно?" в памяти. А когда компилятор будет сталкиваться с константой, он будет видеть сразу ее значение, а не имя.
  </li>

  <li>
    Const (константа компиляции) и readonly (константа времени выполнения) нельзя изменить по коду. Const должна быть инициализирована во время объявления. Readonly можно объявить, а потом инициализировать в конструкторе.
  </li>
  
  <li>
    <h2>4. Методы</h2>
    <p>Конструкторы – это специальные методы, позволяющие корректно инициализировать новый экземпляр типа.</p>
    <p>Статические конструкторы (конструкторы типов) – это инициализаторы типа. Используются для инициализации любых статических данных или для выполнения определенного действия, которое необходимо выполнить только один раз.</p>
  </li>
  
  <li>Конструкторы это тоже методы. Методы, которые инициализируют экземпляры. Когда мы пишем myClass = new, то создаем конструктор, который будет инициализировать экземпляр.</li>

  <li>Статические конструкторы это методы, которые инициализируют типы. Служат, в основном, для инициализации статических полей. Это редкое явления, но оно есть. Мы не знаем когда будет вызван статический конструктор, но он обязательно будет вызван до того как мы обратимся к статическим членам. И мы не можем его контролировать. У статического конструктора нельзя поставить модификатор public и его нельзя вызвать извне. И он не может иметь параметры, потому что вызывает средой выполнения. </li>
  
  <li>
    <h2>Виртуальные методы</h2>
    <p>Виртуальные члены класса могут быть переопределены в классе потомке
    <br>За счет виртуальных членов реализуется свойство ООП – полиморфизм
    </p>
  </li>
  
  <li>
    С помощью ключевого слова virtual в базовом классе помечается метод, который может быть переопределен в классе наследнике. С помощью ключевого слова override в классе наследнике помечаем метод, который мы в нем переопределяем. Это важный механизм языка си шарп, который позволяет реализовать свойство ООП - полиморфизм. Это когда класс наследник ведет себя по другому чем класс родитель.
  </li>

  <li>Нельзя вызывать виртуальные члены в конструкторе. Потому что есть порядок вывполнения конструкторов при инициализации объектов. Когда мы вызываем конструктор наследника, то вначале вызовется конструктор базового класса и только потом конструктор наследника. Здесь неявным образом вызывается конструктор базового класса.</li>
  
  <li>
    <h2>Методы расширений (extensions)</h2>
  </li>
  
  <li>
    Важный механизм языка си шарп - методы расширений. Представим что у нас есть класс public class Student. И у него есть свойства public int Id, public string FirstName, public string LastName. И пусть нам нужно определить метод public string FullName который конкатенирует FirstName и LastName. Но что, если нам не хочется изменять наш готовый класс Student? Для этого используют механизм расширений. Мы объявляем статический класс public static class StudentExtensions и в этом классе объявляем статический метод, который делает то что нам нужно. public static string FullName(this Student student) => $"{FirstName} {LastName}"; И теперь мы можем создать экземпляр класса var student = new Student() и вызвать у него этот метод var fullname = student.FullName();
  </li>

  <li>
    Методы расширений могут иметь не только один параметр, помеченый ключевым словом this. Здесь можно много разных параметров передавать. Главное, что это должен мыть статический метод в статическом класси и первым параметром передается экземпляр того класса, для которого пишется этот метод расширения.
  </li>

  <li>
    Мы постараемся вам все дать за две лекции. Цель лекций дать вам больше практических знаний, чем углубляться во все сложности языка и конструкций. Все что будет рассказано на этих двух лекциях это больше практическое. Если кто-то уже писал на дотнете, то вы уже сталкивались с методами расширения. Те же linq это методы расширений, которые лежат в отдельном статическом классе.
  </li>

  <li>
    <h2>5. Параметры</h2>
  </li>
  
  <li>
    <h2>Параметры методов</h2>
    <p>По умолчанию параметры передаются по значению.
    <br>- Для типов значений – копируется реальное значение в новую переменную
    <br>- Для ссылочных типов – копируется ссылка в новую переменную
    <br>Ключевые слова out и ref позволяют передавать объекты по ссылке.
    </p>
  </li>
  
  <li>
    Поговорим про параметры методов. Все параметры передаются в методы по-умолчанию по значению. Для типов значения, значение будет скопировано в новую переменную. Для ссылочных типов будет скопирована ссылка в новую переменную. Чтобы передать параметры по ссылке нужно использовать ключевые слова out и ref.
  </li>

  <li>
    Посмотрим как это работает. Пусть у нас есть метод, который увеличивает два числа на 1.
    <code>
      public static void Increase(int a, ref int b) {
      <br>  a++;
      <br>  b++;
      <br>}
    </code>
    Первый параметр передается по значению, второй - по ссылке. При этом первая переменная изменится только внутри этого метода. Первая переменная копируется и изменится значение только в скопированной переменной. А вторая переменная изменится и внутри метода и снаружи. У второй переменной скопируется адрес на ее значение. Изменится значение в адресе, на который указывает и скопированная переменная и переданная переменная.
  </li>

  <li>
    Нужно ли для ссылочных переменных ключевое слово ref? Если мы передадим в метод два объекта типа Student и попытаемся изменить им имя. То ссылочные типы скопируются в новые переменный. В первой переменной мы поменяем значение и оно также изменится для переданной переменной. Во вторую переменную мы запишем новый объект типа Student и эта переменная будет уже ссылваться на другую область памяти в куче, где лежит этот новый объект. А вторая переданная переменная никак не изменится. Но если мы хотим чтобы новый экземпляр записался в переданную переменную, то надо ее передавать в метод с ключевым словом ref. То есть для изменения свойств объекта можно передавать без слова ref. Но если надо изменить весь объект целиком, то нужно слово ref.
  </li>

  <li>Вопрос: Какое отличие ref от out? Переменная передаваемая через ref должна быть инициализирована до передачи в метод. Переменная передаваемая через out должна быть инициализирована перед выходом из метода.</li>

  <li>
    <h2>6. Свойства</h2>
  </li>
  
  <li>Свойства помогают реализовать механизм ООП - инкапсуляция. Мы можем регулировать доступ к полю. Мы можем создать приватное свойство и установить к нему геттер и сеттер для доступа к нему. Например у нас есть закрытое свойство private string _name. И есть свойство public string Name с геттером, который возвращает значение этого свойства и сеттером, который устанавливает значение этого свойства. Из вызывающего кода мы не можем обратиться к молю _name. Но можем обратиться к свойству Name. В методе set можно установить проверку что имя не пустое.</li>

  <li>Все свойства это пара методов public uint Age { get; set; }. При этом будет сгенерировано закрытое поле и два метода для работы с ним. get и set могут иметь различные модификторы доступа. Мы можем написать Age { get; protected set; }. В этом случае get будет доступен всем, а set будет доступен только классам наследникам.</li>

  <li>
    <h2>Особенности:</h2>
    <p>- в отличие от полей, можно регулировать доступ отдельно на чтение, отдельно на запись.
    <br>- свойства, по сути методы, могут вызывать исключения
    <br>- свойства нельзя передать в метод с ключевым словом ref или out.
    </p>
  </li>
  
  <li>
    <h2>7. Делегаты</h2>
    <p>Делегат – это тип, представляющий из себя цепочку ссылок на методы с определенными входными параметрами и типом возвращаемого значения</p>
  </li>
  
  <li>Делегат - это сигнатура метода, которая позволяет использовать другой метод вместо него. Когда создаем что-то с ключевым словом delegate, то компилятор это разворачивает в класс, экземпляр которого будет содержать в себе цепочку. Когда мы пишем delegate, то мы создаем новый тип. И этот тип хранит в себе ссылки на методы.</li>
  
  <li>
    <h2>8. События</h2>
    <p>События – вид членов, которые можно определить в типе. Если в типе определено событие, то этот тип (или экземпляр) может уведомлять другие объекты о некоторых особых ситуациях, которые могут случиться.</p>
  </li>
  
  
  9. Обобщения (Generic)
  Обобщения – это еще один механизм, позволяющий многократно использовать универсальный код.
  Ограничения обобщений
  10. Интерфейсы и абстрактные классы
  Интерфейс – это именованный набор сигнатур методов. Если какой-то класс имплементирует интерфейс, он обязан реализовать все описанные с нем методы.
  Для чего нужны интерфейсы:
  - Единый контракт
  - Уменьшение связности кода (SOLID)
  - Множественное наследование
  Абстрактный класс – это класс, в котором есть хотя бы один абстрактный член (сигнатура которого объявлена, а реализация не определена)
  Абстрактный класс не может иметь экземпляра. От абстрактного класса должен унаследоваться другой класс и реализовать абстрактные методы.
  Когда использовать абстрактные классы, а когда интерфейсы?
  - Абстрактный класс используется когда есть система связанных типов, и требуется реализовать для них базовую функциональность, которую они будут использовать
  - Интерфейсы же используются как описание некоторого перечня функций, присущих разрозненным объектам, каждый из которых реализует интерфейс по-своему.
  Вопросы.
  В следующей лекции мы будем разговаривать про более практические вещи, которые обязательно вам пригодятся на практике. Будем говорить про async, await. Будем говорить про асинхронное параллельное программирование. Про exception. Будут немного более сложные вещи, но более интересные и более практически важные.
  Как событие работает в коде?
  Событие может быть вызвано только в том классе, которое его объявило. Компилятор преобразует событие в закрытое поле с двумя методами Add и Remove. Add добавляет событие, Remove удаляет. Так как поле закрытое, то вызвать событие можно только из класса, в котором оно объявлено. В другом классе на него можно подписаться (начать его слушать).
  Вам не придется самим выделять потоки и их дерижировать. Вам придется работать с тасками и с асинхронным кодом. Может быть обсудим что-то связанное с мониторами, локами, семафорами если хватит времени.
</ul>
