<h1>Сложность алгоритмов</h1>


<!-- Содержание -->
<div class="article">
  <h2>Содержание</h2>

  <p><a href="#bigo">Сложность</a></p>
  <ol>
    <li><a href="#bigo-1">Константное время O(1)</a></li>
    <li><a href="#bigo-logn">Логарифмическое время O(log n)</a></li>
    <li><a href="#bigo-n">Линейное время O(n)</a></li>
    <li><a href="#bigo-nlogn">Линейно-логарифмическое время O(n log n)</a></li>
    <li><a href="#bigo-n2">Квадратичное время O(n**2)</a></li>
    <li><a href="#bigo-n3">Кубическое время O(n**3)</a></li>
    <li><a href="#bigo-cn">Экспоненциальное время O(c**n)</a></li>
    <li><a href="#bigo-f">Факториальное время O(!)</a></li>
  </ol>
  <p><a href="#bigo-js">Сложность встроенных методов JavaScript</a></p>
</div>


<!-- bigo -->
<article class="article">
  <div class="anchor" id="bigo"></div>
  <h2>Сложность</h2>

  <p>Big O это асимптотическая сложность, которая описывает верхнюю границу (наихудший случай) сложности алгоритма при увеличении размера входных данных, или то, как рост размера входных данных влияет на количество операций.</p>
  <p>Big O не гарантирует, что алгоритм O(1) будет самым быстрым, но даёт понять, что скорость работы этого алгоритма не будет зависеть от входных данных.</p>

  <p>Big Theta (Θ): Big Theta также оценивает верхнюю и нижнюю границы временной сложности алгоритма, но описывает точную сложность, а не только наихудший случай, как Big O. Θ(f(n)) обозначает, что время выполнения алгоритма ограничено функцией f(n) как сверху, так и снизу.</p>

  <p>Big Omega (Ω): Big Omega оценивает нижнюю границу временной сложности алгоритма. Ω(f(n)) говорит о том, что алгоритм выполнится не быстрее, чем функция f(n).</p>
  <ol>
    <li>Сложность по времени</li>
    <li>Сложность по памяти</li>
  </ol>

  <h3>Сложность по времени</h3>
  <p>Сложность по времени это максимальное количество шагов, требующихся алгоритму для завершения ппо мере увеличения n.</p>

  <p>Сложность алгоритма зависит от входных данных. Поэтому необходимо учитывать сложность в лучшем, худшем и среднем случае. Например, в лучшем случае, во время поиска, мы можем найти элемент в первом элементе списка. В худшем случае элемента может не быть вообще и алгоритм полностью выполнит свою работу только перебрав все данные.</p>

  <h3>Сложность по памяти</h3>
  <p>У компьютера есть ограниченные ресурсы, такие как память, поэтому важно учитывать не только временную сложность, но и потребление ресурсов. Сложность по памяти это объем памяти необходимый алгоритму. Чем меньше памяти требуется алгоритму тем лучше.</p>

  <h3>Оптимизация алгоритма</h3>
  <p>Важно понимать порядок величины чтобы оптимизировать алгоритм. Нужно изменять порядок величины.Например, при O(n**2) с двумя циклами вместо оптимизации процессов внутри циклов, постарайтесь избавиться от одного цикла.</p>
</article>


<!-- 1. Константное время O(1) -->
<article class="article">
  <div class="anchor" id="bigo-1"></div>
  <h3>1. Константное время O(1)</h3>
  <p>Наиболее эффективный порядок величины. Алгоритм выполняется за постоянное время, когда ему требуется одно и то же количество шагов вне зависимости от объема задачи</p>
  <p>Например, алгоритм выбора первого элемента из набора данных. Независимо от размера n вы выбираете первый элемент за один шаг. Время алгоритма не меняется с увеличением набора данных.</p>
  <p>Время выполнения алгоритма не зависит от размера входных данных. Например, доступ к элементу массива по индексу.</p>
  <p>Это самый быстрый и эффективный вид временной сложности.</p>
  <p>Примеры алгоритмов с оценкой временной сложности O(1):</p>
  <ol>
    <li>Доступ к элементу в массиве по индексу. Например, если у вас есть массив с данными, вы можете мгновенно получить доступ к элементу массива, указав его индекс, независимо от размера массива.</li>
    <li>Вставка или удаление элемента в конец списка (очереди) фиксированной длины. В этом случае операция выполняется быстро и не зависит от количества элементов в списке.</li>
  </ol>
</article>


<!-- 2. Логарифмическое время O(log n) -->
<article class="article">
  <div class="anchor" id="bigo-logn"></div>
  <h3>2. Логарифмическое время O(log n)</h3>
  <p>Логарифмическое время - это вторая по эффективности временная сложность. Время выполнения алгоритма растет пропорционально логарифму размера входных даных.</p>
  <p>Время выполнения алгоритма растет медленно с увеличением размера входных данных.</p>
  
  <h4>Пример 1. Бинарный поиск в отсортированном массиве</h4>
<pre>function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;
  while (left &lt;= right) {
    let mid = Math.floor((left + right) / 2);
    if (arr[mid] === target) {
        return mid; // элемент найден
    } else if (arr[mid] &lt; target) {
        left = mid + 1; // искать в правой половине
    } else {
        right = mid - 1; // искать в левой половине
    }
  }
  return -1; 
}</pre>
  <p>Бинарный поиск ищет значение в отсортированном массиве, разделяя его пополам на каждой итерации. Поиск начинается с середины массива. Если значение, которое мы ищем, больше среднего элемента, поиск продолжается в правой половине массива. Если оно меньше, то в левой. Таким образом, на каждой итерации мы уменьшаем область поиска примерно в два раза, что обеспечивает логарифмическую сложность O(log n).</p>

  <h4>Пример 2. Перевод числа в двоичную систему</h4>
<pre>function decToBin(dec) {
  if (dec === 0) {
    return '0';
  }
  let bin = '';
  while (dec > 0) {
    bin = dec % 2 + bin;
    dec = Math.floor(dec / 2);
  }
  return bin;
}</pre>
  <p>Сложность будет логарифмическое. Мы здесь так же как в бинарном поиске постоянно делим на 2.</p>
</article>


<!-- 3. Линейное время O(n) -->
<article class="article">
  <div class="anchor" id="bigo-n"></div>
  <h3>Линейное время O(n)</h3>

  <p>Время выполнения алгоритма пропорционально размеру входных данных. Например, просмотр всех элементов в массиве.</p>

  <h4>Пример 1. Функция findMax возвращает максимальное число из массива</h4>
<pre>function findMax(arr) {
  let max = arr[0];
  for (let i = 1; i &lt; arr.length; i++) {
      if (arr[i] &gt; max) {
          max = arr[i];
      }
  }
  return max;
}</pre>
  <p>Алгоритм начинает с предположения, что первый элемент массива (arr[0]) является максимальным, а затем линейно (то есть по одному элементу) перебирает остальные элементы, сравнивая каждый с текущим максимальным. Сложность этого алгоритма O(n), так как время выполнения растет линейно с увеличением количества элементов в массиве arr.</p>

  <h4>Пример 2. Функция getSum возвращает сумму чисел массива</h4>
<pre>function getSum(arr) {
  let sum = 0;
  for (let i = 0; i &lt; arr.length; i++) {
    sum += arr[i];
  }
  return sum;
}</pre>

  <h4>Пример 3. Отрисовка TODO листа за O(N+M)</h4>
<pre>function renderTodos(todos) {
  const n = todos.length;
  const todoListBlock = document.getElementsByClassName('todo-list')[0];
  for (let i = 0; i &lt; n; i++) {
    todoListBlock.appendChild(renderTodo(todos[i].comment));
  }
}</pre>
  
</article>


<!-- 4. Линейно-логарифмическое время O(n log n) -->
<article class="article">
  <div class="anchor" id="bigo-nlogn"></div>
  <h3>Линейно-логарифмическое время O(n log n)</h3>
  <p>Растет как умножение линейных и логарифмических сложностей. Операция O(log n) вычисляется n раз. Линейно-логарифмические алгоритмы разделяют набор данных на меньшие части и каждую из них обрабатывают по отдельности.</p>
  <p>Время выполнения алгоритма растет быстрее, чем линейно, но медленнее, чем квадратично. Например, сортировка слиянием (merge sort).</p>
</article>


<!-- 5. Квадратичное время O(n**2) -->
<article class="article">
  <div class="anchor" id="bigo-n2"></div>
  <h3>Квадратичное время O(n**2)</h3>
  <p>Алгоритм выполняется за квадратичное время, когда его производительность прямо пропорциональна размеру задачи в квадрате.</p>
  <p>Например, вложенный цикл будет иметь квадратичную сложность, когда данные перебираются в цикле и для каждого элемента опять в цикле перебираются данные. Простые алгоритмы сортировки, такие как пузырьковая и сортировка вставками выполняются за квадратичное время.</p>

  <h4>Пример 1. Функция sumOfPairs ищет сумму всех пар элементов в массиве:</h4>
<pre>function sumOfPairs(arr) {
  let sum = 0;
  for (let i = 0; i &lt; arr.length; i++) {
      for (let j = 0; j &lt; arr.length; j++) {
          sum += arr[i] + arr[j];
      }
  }
  return sum;
}
const myArray = [1, 2, 3, 4];
console.log(sumOfPairs(myArray)); // Результат: 40</pre>
  <p>Этот код имеет два вложенных цикла, каждый из которых проходится по всему массиву. Количество операций в циклах равно n * n, где n - это длина массива.</p>

  <h4>Пример 2. Отрисовка TODO листа за O(N*M)</h4>
<pre>function renderTodos(todos) {
  const n = todos.length;
  for (let i = 0; i &lt; n; i++) {
    document.getElementsByClassName('todo-list')[0]
      .appendChild(renderTodo(todos[i].comment));
  }
}</pre>
  <p>На вход приходит список тудушек и есть какая-то функция renderTodo. Она не описана. Будем считать что она работает за константную сложность.</p>
  <p>Здесь полиномиальная сложность - O(N*M). Где N это количество элементов в массиве todos, а M количество узлов в DOM дереве. Потому что внутри цикла каждый раз делается поиск по классу, который работает за линейную сложность.</p> 
</article>


<!-- 6. Кубическое время O(n**3) -->
<article class="article">
  <div class="anchor" id="bigo-n3"></div>
  <h3>Кубическое время O(n**3)</h3>
  <p>Время выполнения алгоритма зависит от размера входных данных в кубе. Например, алгоритмы, которые имеют три вложенных цикла, такие как некоторые методы многомерной обработки данных.</p>
  <p>Например функция multiplyMatrices умножает две матрицы</p>
<pre>function multiplyMatrices(matrix1, matrix2) {
  let result = [];
  const m = matrix1.length;
  const n = matrix2[0].length;
  const p = matrix2.length;

  for (let i = 0; i &lt; m; i++) {
      result[i] = [];
      for (let j = 0; j &lt; n; j++) {
          result[i][j] = 0;
          for (let k = 0; k &lt; p; k++) {
              result[i][j] += matrix1[i][k] * matrix2[k][j];
          }
      }
  }
  return result;
}

const matrixA = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];

const matrixB = [
  [9, 8, 7],
  [6, 5, 4],
  [3, 2, 1]
];

console.log(multiplyMatrices(matrixA, matrixB));</pre>
  <p>Этот алгоритм умножения матриц имеет три вложенных цикла: первый проходится по строкам первой матрицы, второй по столбцам второй матрицы, а третий - по общим элементам для умножения. Количество операций равно n * n * n, где n - это размер матрицы. Это приводит к кубической сложности O(n^3).</p>
</article>


<!-- 7. Экспоненциальное время O(c**n) -->
<article class="article">
  <div class="anchor" id="bigo-cn"></div>
  <h3>Экспоненциальное время O(c**n)</h3>
  <p>Наихудшая сложность алгоритма. Содержит константу, увеличенную до размеров задачи. Количество шагов алгоритма растет с невероятной скоростью.</p>
  <p>Например, для угадывания пароля из 8 десятичных цифр придется выполнить 100 миллионов шагов. Отгадывание пароля это пример алгоритма полного перебора, проверяющего все возможные варианты. Алгоритмы полного перебора неэффективны.</p>
  <p>Это часто встречается в алгоритмах, которые решают проблемы методом "разделяй и властвуй" или используют рекурсию без оптимизации.</p>

  <h4>Пример 1. Рекурсивное вычисление чисел Фибоначчи</h4>
<pre>function fibonacci(n) {
  if (n &lt;= 1) {
      return n;
  } else {
      return fibonacci(n - 1) + fibonacci(n - 2);
  }
}</pre>
  <p>Этот код использует рекурсию для вычисления чисел Фибоначчи. Однако каждый раз, когда вызывается функция fibonacci, она порождает два дополнительных вызова, что приводит к экспоненциальному увеличению количества вызовов функций с увеличением n.</p>

  <h4>Пример 2. Задача о сумме подмножеств</h4>
  <p>Написать функцию, которая из входящено массива выберет все комбинации чисел, сумма которых будет равна 10</p>
</article>


<!-- 8. Факториальное время O(n!) -->
<article class="article">
  <div class="anchor" id="bigo-f"></div>
  <h3>Факториальное время O(n!)</h3>
  <p>Это самая высокая степень роста времени выполнения алгоритма. Время выполнения алгоритма растет факториально от размера входных данных. Этот тип сложности встречается, например, при переборе всех возможных комбинаций элементов, что делает его чрезвычайно неэффективным для больших значений n.</p>
  <p>Пример алгоритма с факториальной сложностью может быть перебор всех перестановок элементов массива</p>
<pre>function permute(arr) {
  function swap(a, b) {
      const temp = arr[a];
      arr[a] = arr[b];
      arr[b] = temp;
  }

  function generate(n) {
      if (n === 1) {
          console.log(arr);
      } else {
          for (let i = 0; i &lt; n - 1; i++) {
              generate(n - 1);
              if (n % 2 === 0) {
                  swap(i, n - 1);
              } else {
                  swap(0, n - 1);
              }
          }
          generate(n - 1);
      }
  }

  generate(arr.length);
}

const myArray = [1, 2, 3];
permute(myArray);</pre>
  <p>Этот код создает все возможные перестановки элементов массива путем рекурсивного генерирования всех возможных комбинаций. Количество операций, необходимых для генерации всех перестановок, равно факториалу длины массива.</p>
</article>


<!-- Сложность встроенных методов JavaScript -->
<article class="article">
  <div class="anchor" id="bigo-js"></div>
  <h2>Сложность встроенных методов JavaScript</h2>

  <p>Встроенные методы JavaScript обычно имеют свои собственные характеристики сложности, которые варьируются в зависимости от конкретного метода и типа данных, с которыми они работают. Вот несколько примеров:</p>

  <ol>
    <li>
      <h3>Массивы:</h3>
      <p>Добавление/удаление элемента в конце массива (например, push, pop): Сложность O(1). Эти операции работают быстро, так как не требуется сдвигать все элементы при добавлении или удалении элемента в начале массива.</p>
      <p>Добавление/удаление элемента в начале массива (например, unshift, shift): Сложность O(n). При добавлении или удалении элемента в начале массива требуется сдвиг всех остальных элементов.</p>
      <p>Доступ к элементу по индексу (например, arr[index]): Сложность O(1). Элементы массива обычно доступны напрямую по индексу, что делает эту операцию очень эффективной.</p>
    </li>
    <li>
      <h3>Строки:</h3>
      <p>Слияние строк (например, использование + или concat): Сложность может быть O(n), так как при слиянии строк может потребоваться создание новой строки и копирование символов из оригинальных строк.</p>
    </li>
    <li>
      <h3>Объекты:</h3>
      <p>Доступ к свойствам объекта (например, obj.prop): Обычно сложность доступа к свойствам объекта - O(1), но это может измениться в случае использования Map или WeakMap, где сложность доступа может быть ближе к O(log n) из-за особенностей реализации.</p>
      <p>Добавление/удаление свойств объекта: Обычно сложность добавления/удаления свойств в объекте - O(1).</p>
    </li>
  </ol>

  <p>Если у нас есть задача по частому поиску в массиве, например, мы хотим N раз найти элемент в массиве из N элементов. То решение с использованием indexOf даст нам квадратичную сложность. Но если мы вначале остортируем массив с помощью сортировки слиянием, а затем будем искать бинарным поиском то в сумме это даст линейно-логарифмическую сложность. И тогда наш код будет работать гораздо быстрее.</p>
</article>
