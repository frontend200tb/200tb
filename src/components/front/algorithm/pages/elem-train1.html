<h1>Тренировки по алгоритмам 1.0 (2021.06.30)</h1>


<!-- Содержание -->
<div class="article">
  <h2>Содержание</h2>
  <ol>
    <li>
      <a href="#train-1">Лекция №1. Сложность, тестирование, особые случаи</a>
      <ol>
        <li><a href="#train-1-task-1">Задача 1. Самый частый символ</a></li>
        <li><a href="#train-1-os">Особые случаи</a></li>
        <li><a href="#train-1-test">Тестирование</a></li>
        <li><a href="#train-1-task-2">Задача 2. Квадратное уравнение</a></li>
      </ol>
    </li>
    <li>
      <a href="#train-2">Лекция №2. Линейный поиск</a>
      <ol>
        <li><a href="#train-2-task-1">Задача 1. Найти первое вхождение</a></li>
        <li><a href="#train-2-task-2">Задача 2. Найти последнее вхождение</a></li>
        <li><a href="#train-2-task-3">Задача 3. Найти максимальное число</a></li>
      </ol>
    </li>
  </ol>
</div>


<!-- Лекция №1. Сложность, тестирование, особые случаи -->
<article class="article">
  <div class="anchor" id="train-1"></div>
  <h2>Лекция №1. Сложность, тестирование, особые случаи</h2>

  <p>Здравствуйте, меня зовут Михаил Густокашин. Я преподаю на факультете компьютерных наук в высшей школе экономики. Предмет про алгоритмы и структуры данных. Я не работаю в Яндексе, не провожу собеседования.</p>
  <p>Чего хотят на алгоритмическом собеседовании?</p>
  <ol>
    <li>Умения писать работаюдий код</li>
    <li>Умения тестировать свой код</li>
    <li>Умения писать эффективный код</li>
  </ol>
  <p>Задача на собеседовании обычно похожа на олимпиадную задачу по информатике, но на собеседовании задачи обычно простые. Если умеете решать олимпиадные задачи, то алгоритмическую секцию пройдете достаточно легко. Как этого достичь?</p>
  <ol>
    <li>Написать 10 000 строк работающего, эффективного и протестированного кода</li>
    <li>Найти задачи для тренировок можно на leetcode.com, codeforces.com и т.п.</li>
    <li>Наш курс поможет правильно подходить к решению задач</li>
  </ol>

  <h4>План занятий</h4>
  <ol>
    <li>Сложность, тестирование, особые случаи</li>
    <li>Ллинейный поиск</li>
    <li>Множества</li>
    <li>Словари и сортировка подсчетом</li>
    <li>Префиксные суммы и два указателя</li>
    <li>Бинарный поиск</li>
    <li>Сортировака событий</li>
    <li>Деревья</li>
  </ol>

  <h4>Как устроены занятия</h4>
  <ol>
    <li>Две лекции в неделю - по понедельникам и средам</li>
    <li>К каждой лекции - контест, примерно на 10 задач</li>
    <li>Разбор задач по пятницам</li>
  </ol>

  <h4>Содержание сегодняшней лекции</h4>
  <ol>
    <li>Сложность алгоритмов</li>
    <li>Особые случаи</li>
    <li>Тестирование</li>
  </ol>

  <h4>Сложность алгоритмов</h4>
  <p>Что такое сложность?</p>
  <ol>
    <li>Сложность алгоритма - порядок количества действий, которые выполняет алгоритм</li>
    <li>Например, в программе два вложенных цикла, каждый от 1 до N, тогда сложность составляет O(N^2)</li>
    <li>100*N = O(N), 2*N = O(N). Здесь 100 и 2 - константы, не зависящие от размера входных данных. Константы не так сильно влияют на скорость работы алгоритма при больших параметрах</li>
    <li>Еще бывает "пространственная сложность" - сколько дополнительной памяти требует алгоритм. Пространственная сложность не может быть больше временной, потому что чтобы положить значение в ячейку памяти на это тоже требуется время.</li>
  </ol>

  <p>На собеседовании хотят решение задачи с наименьшей асимптотической сложностью. Посмотрим на примерах и все станет понятно.</p>
</article>


<!-- Задача 1. Самый частый символ -->
<article class="article">
  <div class="anchor" id="train-1-task-1"></div>
  <h2>Задача 1. Самый частый символ</h2>

  <p>Дана строка (в кодировке UTF-8). Найти самый часто встречающийся в ней символ. Если несколько символов встречаются одинаково часто, то можно вывести любой.</p>

  <h4>Решение 1. O(n^2)</h4>
  <p>Переберем все позиции и для каждой позиции в строке еще раз переберем все позиции и в случае совпадения прибавим к счетчику единицу. Найдем максимальное значение счетчика.</p>

  <details>
    <summary>Решение</summary>
<pre>function findChar(str) {
  let result = '';
  let max = 0;
  for (i = 0; i &lt; str.length; i++) {
    let counter = 0;
    for (j = 0; j &lt; str.length; j++) {
      if (str[i] === str[j]) {
        counter++;
      }
    }
    if (counter &gt; max) {
      result = str[i];
      max = counter;
    }
  }
  return result;
}</pre>
  </details>

  <h4>Решение 2. O(n*k)</h4>
  <p>Переберем все символы, встречающиеся в строке, а затем переберем все позиции и в случае совпадения прибавим к счетчику единицу. Найдем максимальное значение счетчика.</p>

  <details>
    <summary>Решение</summary>
  <pre>function findChar(str) {
    let result = '';
    let max = 0;
    for (char of new Set(str)) {
      let counter = 0;
      for (j = 0; j &lt; str.length; j++) {
        if (char === str[j]) {
          counter++;
        }
      }
      if (counter &gt; max) {
        result = char;
        max = counter;
      }
    }
    return result;
  }</pre>
  </details>

  <h4>Решение 3. O(n+k) = O(n)</h4>
  <p>Заведем словарь, где ключом является символ, а значением - сколько раз он встретился. Если символ встретился впервые - создаем элемент словаря с ключом, совпадающим с этим символом и значением ноль. Прибавляем к элементу словаря с ключом, совпадающим с этим символом, единицу. Проходимся по всей строке - это n операций. Потом проходимся по всем ключам в словаре - это k операций. Это у Михаила.</p>

  <details>
    <summary>Решение Михаила</summary>
<pre>function findChar(str) {
  let result = '';
  max = 0;
  let dic = {};
  for (let i = 0; i &lt; str.length; i++) {
    if (!dic[str[i]]) {
      dic[str[i]] = 0;
    }
    dic[str[i]]++;
  }
  for (key in dic) {
    if (dic[key] &gt; max) {
      max = dic[key];
      result = key;
    }
  }
  return result;
}</pre>
  </details>
  <p>А я придумал алгоритм за O(n) без k. Проходимся только по строке, где сразу обновляем максимум и новый результат - это n операций.</p>

  <details>
    <summary>Мое решение</summary>
<pre>function findChar(str) {
  let result = '';
  max = 0;
  let dic = {};
  for (let i = 0; i &lt; str.length; i++) {
    if (dic[str[i]]) {
      dic[str[i]]++;
    } else {
      dic[str[i]] = 1;
    }
    if (dic[str[i]] &gt; max) {
      max = dic[str[i]];
      result = str[i];
    }
  }
  return result;
}</pre>
  </details>
</article>


<!-- Особые случаи -->
<article class="article">
  <div class="anchor" id="train-1-os"></div>
  <h2>Особые случаи</h2>

  <h4>Особые случаи</h4>
  <p>Вернемся к задаче 1 и удалим вторую строку</p>
  <code>let result = '';</code>
  <p>Это инициализация переменной, которая будет возвращена в результате. Если убрать эту строку, то может произойти особый случай, когда к нам ничего не пришло и мы пытаемся вывести переменную которую создаем в цикле, который не разу не выполнился. Произойдет runTimeError - ошибка времени выполнения. Запись этой строки гарантирует возврат значения из функции. Это и есть обработка особого случая.</p>
  <p>Если в задаче 1 удалить другую строку</p>
  <code>max = dic[key];</code>
  <p>То как искать такую ошибку? Надо прокрутить решение в голове на реальных входных данных, например на строке 'aab'.</p>

  <h4>Сумма последовательности</h4>
  <p>Дан массив чисел. Найти их сумму.</p>

  <details>
    <summary>Решение</summary>
  <p>Мы помним, что пустые строки, последовательности, массивы это страшная вещь и мы стараемся их сразу обработать чтобы ничего не сломалось. Пишем, если длина массива 0 то сразу возвращаем 0, иначе просуммируем все числа.</p>
<pre>function sum(nums) {
  if (nums.length === 0) {
    return 0;
  } else {
    let result = nums[0];
    for (let i = 1; i &lt; nums.length; i++) {
      result += nums[i];
    }
    return result;
  }
}</pre>

  <p>Но в данном случае это уже было лишнее. Потому что if можно убрать и сразу инициализировать результат нулем.</p>

<pre>function sum(nums) {
  let result = 0;
  for (let i = 0; i &lt; nums.length; i++) {
    result += nums[i];
  }
  return result;
}</pre>
  </details>

  <h4>Максимум последовательности</h4>
  <p>Дан массив чисел. Найти максимальное число.</p>

  <details>
    <summary>Решение</summary>
    <p>Мы помним, что для нахождения суммы последовательности мы сначала в результат записывали 0, а потом вычисляли сумму.</p>
<pre>function max(nums) {
  let result = 0;
  for (let i = 0; i &lt; nums.length; i++) {
    if (nums[i] &gt; result) {
      result = nums[i];
    }
  }
  return result;
}</pre>
    <p>Это будет работать, пока не возникнет ситуация, когда все числа будут отрицательные. Мы выведем 0, которого даже нет в последовательности. Поэтому обработаем этот случай, если последовательность пустая, то выведем, например, пустую строку.</p>
<pre>function max(nums) {
  if (nums.length === 0) {
    return '';
  } else {
    let result = nums[0];
    for (let i = 1; i &lt; nums.length; i++) {
      if (nums[i] &gt; result) {
        result = nums[i];
      }
    }
    return result;
  }
}</pre>
  </details>
</article>


<!-- Тестирование -->
<article class="article">
  <div class="anchor" id="train-1-test"></div>
  <h2>Тестирование</h2>

  <p>Что нужно тестировать?</p>
  <ol>
    <li>Тесты из условия (если есть)</li>
    <li>Общие случаи</li>
    <li>Особые случаи</li>
  </ol>

  <p>Программу после сдачи могут проверять автоматические тесты, или если писали код на листочке, то ее будет проверять собеседующий. Поставьте себе челендж всегда все сдавать с первой попытки. Это круто и это значит что вы все тщательно протестировали.</p>

  <p>Посмотрим какие тесты нужно сделать к задаче про максимум последовательности.</p>
  <code>[1,3,2]; // общий случай, максимум в середине</code>
  <code>[1,2,3]; // краевой случай, максимум на последнем месте</code>
  <code>[3,2,1]; // краевой случай, максимум на первом месте</code>
  <code>[1,1,1]; // все элементы одинаковые</code>
  <code>[1]; // всего один элемент</code>
  <code> // нет ни одного элемента</code>
  <code>[-1,-2,-3]; // все числа отрицательные</code>

  <h4>Советы по составлению тестов</h4>
  <ol>
    <li>Если есть примеры - реши их руками и сверь ответ. Если не совпадает, то либо правильных ответов может быть несколько, либо ты неправильно понял задачу</li>
    <li>Сначала составь несколько примеров и реши задачу руками, чтобы лучше понять условие и чтобы потом было с чем сравнить</li>
    <li>Проверь последовательность из одного элемента и пустую</li>
    <li>"Краевые эффекты" - проверь, что программа работает корректно в начале и конце последовательности, сделай тесты, чтобы ответ находился на первом и на последнем месте в последовательности</li>
    <li>Составь покрытие всех ветвлений, так чтобы был тест, который входит в каждый if и else</li>
    <li>Подбери тесты чтобы е было ни одного вхождения в цикл</li>
    <li>Один тест - одна возможная ошибка</li>
  </ol>
</article>


<!-- Задача 2. Квадратное уравнение -->
<article class="article">
  <div class="anchor" id="train-1-task-2"></div>
  <h2>Задача 2. Квадратное уравнение</h2>

  <h4>Покрытие тестами</h4>
  <p>Задача. Даны три целых числа a,b,c. Найдите все корни уравнения ax^2+bx+c=0 и выведите их в порядке возрастания</p>
  <p>Дискриминант d равен</p>
  <code>d = b^2-4ac</code>
  <p>корни квадратного уравнения x1 и x2 равны</p>
  <code>x1 = (-b - sqrt(d))/2a</code>
  <code>x2 = (-b + sqrt(d))/2a</code>

  <details>
    <summary>Решение 1</summary>
<pre>let d = b**2 - 4*a*c;
let x1 = (-b - Math.sqrt(d))/2*a;
let x2 = (-b + Math.sqrt(d))/2*a;
</pre>
    <p>Решение выдает неправильный результат, потому что мы неправильно переписали формулу. 2*a нужно взять в скобочки.</p>
  </details>

  <details>
    <summary>Решение 2</summary>
<pre>let d = b**2 - 4*a*c;
let x1 = (-b - Math.sqrt(d))/(2*a);
let x2 = (-b + Math.sqrt(d))/(2*a);
</pre>
    <p>Это решение имеет недостатки. Если дискриминант равен нулю то существует только один корень. А у нас получится два корня, которые равны друг другу.</p>
  </details>

  <details>
    <summary>Решение 3</summary>
    <p>Учтем случай когда дискриминант равен 0.</p>
<pre>let d = b**2 - 4*a*c;
if (d === 0) {
  let x1 = -b/(2*a);
} else {
  let x1 = -b - Math.sqrt(d)/(2*a);
  let x2 = -b + Math.sqrt(d)/(2*a);
}</pre>
    <p>Если дискриминант меньше нуля то программа выдаст ошибку, поскольку нельзя взять корень из отрицательного числа и это значит что уравнение не имеет корней.</p>
    <p>В квадратном уравнении слева стоит функция, которая представляет собой параболу. А справа 0 это значение x при котором парабола пересекает ось x. Парабола может пересекать в двух местах, касаться своей нижней точкой или не пересекать, а лежать выше оси x.</p>
  </details>

  <details>
    <summary>Решение 4</summary>
<pre>let d = b**2 - 4*a*c;
if (d === 0) {
  let x1 = -b/(2*a);
} else if (d &gt; 0) {
  let x1 = -b - Math.sqrt(d)/(2*a);
  let x2 = -b + Math.sqrt(d)/(2*a);
}</pre>
    <p>Если ввести 0,1,1 то ответ должен быть -1, а программа выдает ошибку. При а = 0 выражение 0x^2 = 0 и это уже не квадратное уравнение, а линейное уравнение.</p>
  </details>

  <details>
    <summary>Решение 5</summary>
    <p>Если a=0 то это уже линейное уравнение. Обработаем этот случай. Будет один корень x1 = -c/b</p>
<pre>if (a === 0) {
  let x1 = -c/b;
} else {
  let d = b**2 - 4*a*c;
  if (d === 0) {
    let x1 = -b/(2*a);
  } else if (d &gt; 0) {
    let x1 = -b - Math.sqrt(d)/(2*a);
    let x2 = -b + Math.sqrt(d)/(2*a);
  }
}
</pre>
    <p>Если ввести 0,0,1 то программа выдает ошибку. Потому что b=0 и мы получаем деление на 0.</p>
  </details>

  <details>
    <summary>Решение 6</summary>
    <p>Обработаем случай когда b=0</p>
<pre>if (a === 0) {
  if (b !== 0) {
    let x1 = -c/b;
  }
} else {
  let d = b**2 - 4*a*c;
  if (d === 0) {
    let x1 = -b/(2*a);
  } else if (d &gt; 0) {
    let x1 = -b - Math.sqrt(d)/(2*a);
    let x2 = -b + Math.sqrt(d)/(2*a);
  }
}
</pre>
    <p>Если ввести 0,0,0 то при любом x уравнение будет равно 0. А у нас ничего не выводится.</p>
  </details>

  <details>
    <summary>Решение 7</summary>
    <p>Обработаем случай когда b=0 и c=0</p>
<pre>if (a === 0) {
  if (b !== 0) {
    let x1 = -c/b;
  }
  if (b === 0 && c === 0) {
    return 'при любом x';
  }
} else {
  let d = b**2 - 4*a*c;
  if (d === 0) {
    let x1 = -b/(2*a);
  } else if (d &gt; 0) {
    let x1 = -b - Math.sqrt(d)/(2*a);
    let x2 = -b + Math.sqrt(d)/(2*a);
  }
}
</pre>
    <p>Если ввести -5,4,1 то ответ должен быть -0.2, 1.0, а мы выводим 1.0, -0.2. То есть корни выводятся в неправильном порядке. Это происходит что мы делим на отрицательное число 2*a.</p>
  </details>

  <details>
    <summary>Решение 8</summary>
    <p>Обработаем случай когда a меньше 0</p>
<pre>if (a === 0) {
  if (b !== 0) {
    let x1 = -c/b;
  }
  if (b === 0 && c === 0) {
    return 'при любом x';
  }
} else {
  let d = b**2 - 4*a*c;
  if (d === 0) {
    let x1 = -b/(2*a);
  } else if (d &gt; 0) {
    let x1 = -b - Math.sqrt(d)/(2*a);
    let x2 = -b + Math.sqrt(d)/(2*a);
    if (x1 &gt; x2) {
      let temp = x2;
      x2 = x1;
      x1 = temp;
    }
  }
}
</pre>
    <p>Итого получилось 8 попыток для решения задачи на квадратное уравнение. Программа полностью состоит из заплаток.</p>
  </details>
</article>


<!-- Лекция №2. Линейный поиск -->
<article class="article">
  <div class="anchor" id="train-2"></div>
  <h2>Лекция №2. Линейный поиск</h2>

  <p>Линейный поиск - это совсем несложный алгоритм. Поэтому будем в основном рассматривать его на примере разных задач.</p>

  <h4>Содержание сегодняшней лекции</h4>
  <ol>
    <li>Классические задачи линейного поиска</li>
    <li>Два прохода</li>
    <li>Задача с собеседования</li>
  </ol>

  <p>Что такое линейный поиск?</p>
  <ol>
    <li>Линейный поиск - способ поиска, когда перебираются все элементы</li>
    <li>Сложность линейного поиска - линейная O(N)</li>
    <li>Обычно ищут "подходящий" элемент или "наиболее подходящий" элемент</li>
  </ol>
</article>


<!-- Задача 1. Найти первое вхождение -->
<article class="article">
  <div class="anchor" id="train-2-task-1"></div>
  <h2>Задача 1. Найти первое вхождение</h2>

  <p>Дана последовательность чисел длиной N. Найти первое (левое) вхождение числа X в нее или вывести -1, если число X не встречалось.</p>

  <details>
    <summary>Решение</summary>
  </details>
  <p>Сначала положим в ответ -1, затем будем перебирать все элементы. Если текущий элемент равен X и ответ равен -1, запишем в ответ текущую позицию. Проверка result === -1 нужна для того чтобы запомнилось именно первое вхождение.</p>
<pre>function findX(nums, x) {
  let result = -1;
  for (let i = 1; i &lt; nums.length; i++) {
    if (nums[i] === x && result === -1) {
      result = i;
    }
  }
  return result;
}</pre>
</article>


<!-- Задача 2. Найти последнее вхождение -->
<article class="article">
  <div class="anchor" id="train-2-task-2"></div>
  <h2>Задача 2. Найти последнее вхождение</h2>

  <p>Дана последовательность чисел длиной N. Найти последнее (правое) вхождение числа X в нее или вывести -1, если число X не встречалось.</p>

  <details>
    <summary>Решение</summary>
  </details>
  <p>Сначала положим в ответ -1, затем будем перебирать все элементы. Если текущий элемент равен X - запишем в ответ текущую позицию. Здесь может быть много присваиваний, но на асимптотическую сложность это не повлияет.</p>
<pre>function findX(nums, x) {
  let result = -1;
  for (let i = 1; i &lt; nums.length; i++) {
    if (nums[i] === x) {
      result = i;
    }
  }
  return result;
}</pre>
</article>


<!-- Задача 3. Найти максимальное число -->
<article class="article">
  <div class="anchor" id="train-2-task-3"></div>
  <h2>Задача 3. Найти максимальное число</h2>

  <p>Дана последовательность чисел длиной N (N больше 0). Найти максимальное число в последовательности.</p>
</article>





