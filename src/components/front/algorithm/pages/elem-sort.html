<h1>Алгоритмы сортировки</h1>


<!-- Содержание -->
<div class="article">
  <h2>Содержание</h2>
  <p><a href="#sort">Сортировка</a></p>
  <ol>
    <li><a href="#sort-bubble">Сортировка пузырьком (Bubble Sort)</a></li>
    <li><a href="#sort-cocktail">Сортировка перемешиванием (шейкерная сортировка) (Cocktail sort)</a></li>
    <li><a href="#sort-comb">Сортировка расчёской (Comb sort)</a></li>
    <li><a href="#sort-insertion">Сортировка вставками (Insertion Sort)</a></li>
    <li><a href="#sort-selection">Сортировка выбором (Selection sort)</a></li>
    <li><a href="#sort-shell">Сортировка Шелла (Shell Sort)</a></li>
    <li><a href="#sort-count">Сортировка подсчетом (Counting Sort)</a></li>
    <li><a href="#sort-merge">Сортировка слиянием (Merge Sort)</a></li>
    <li><a href="#sort-heap">Пирамидальная сортировка (сортировка кучей) (HeapSort)</a></li>
    <li><a href="#sort-quick">Быстрая сортировка Хоара (Quick Sort)</a></li>
    <li><a href="#sort-gnome">Гномья сортировка (Gnome Sort)</a></li>
  </ol>
</div>


<!-- sort -->
<article class="article">
  <div class="anchor" id="sort"></div>
  <h2>Сортировка</h2>

  <ol>
    <li>Сортировка пузырьком (Bubble Sort)</li>
    <li>Сортировка перемешиванием (шейкерная сортировка) (Cocktail sort)</li>
    <li>Сортировка расчёской (Comb sort)</li>
    <li>Сортировка вставками (Insertion Sort)</li>
    <li>Сортировка выбором (Selection sort)</li>
    <li>Сортировка Шелла (Shell Sort)</li>
    <li>Сортировка подсчетом (Counting Sort)</li>
    <li>Сортировка слиянием (Merge Sort)</li>
    <li>Пирамидальная сортировка (сортировка кучей) (HeapSort)</li>
    <li>Быстрая сортировка Хоара (Quick Sort)</li>
    <li>Гномья сортировка (Gnome Sort)</li>
  </ol>
</article>


<!-- 1. Сортировка пузырьком (Bubble Sort) -->
<article class="article">
  <div class="anchor" id="sort-bubble"></div>
  <h3>1. Сортировка пузырьком (Bubble Sort)</h3>
  <p>Сортировка пузырьком — один из самых известных алгоритмов сортировки. Здесь нужно последовательно сравнивать значения соседних элементов и менять числа местами, если предыдущее оказывается больше последующего. Таким образом элементы с большими значениями оказываются в конце списка, а с меньшими остаются в начале.</p>
  <p>Когда дойдем до конца массива, то самый последний элемент будет гарантированно на своем месте. Самый большой пузырек всплыл на поверхность воды. Мы повторим процедуру еще раз, но уже до предпоследнего элемента. После второй итерации, на своих позициях будет уже 2 последних элемента. Будем повторять алгоритм до тех пор, пока у нас не останется только первый элемент.</p>
<pre>function bubbleSort(arr) {
  for (let i = 0; i &lt; arr.length; i++) {
    for (let j = 0; j &lt; arr.length - i; j++) {
      if (arr[j] &gt; arr[j + 1]) {
        let tmp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = tmp;
      }
    }
  }
  return arr;
}</pre>
  <p>Этот алгоритм считается учебным и почти не применяется на практике из-за низкой эффективности: он медленно работает на тестах, в которых маленькие элементы (их называют «черепахами») стоят в конце массива. Однако на нём основаны многие другие методы, например, шейкерная сортировка и сортировка расчёской.</p>

  <h3>Улучшенная сортировка пузырьком</h3>
  <p>Алгоритм пузырьковой сортировки никак не следит за текущим состоянием массива. Даже если на вход мы отправим уже отсортированный массив, нам нужно будет столько же итераций цикла, как и для неотсортированного массива, чтобы получить результат. Быстродействие пузырьковой сортировки в JavaScript можно улучшить, если добавить флаг (логическую переменную) который будет следить за тем был ли хотя бы один обмен на текущей итерации. Если нет, то массив отсортирован и задача выполнена.</p>
<pre>function bubbleSort(arr) {
  let isSwap = false;
  for (let i = 0; i &lt; arr.length; i++) {
    for (let j = 0; j &lt; arr.length - i; j++) {
      if (arr[j] &gt; arr[j + 1]) {
        let temp = arr[j + 1];
        arr[j + 1] = arr[j];
        arr[j] = temp;
        isSwap = true;
      }
    }
    if (!isSwap) {
      return arr;
    }
  }
  return arr;
}</pre>
  <p>Если отсортировать массив в котором все элементы уже расположены по возрастанию, то нам нужна будет только одна итерация внешнего цикла. Поэтому в лучшем случае мы получим сложность O(n).</p>
</article>


<!-- 2. Сортировка перемешиванием (шейкерная сортировка) (Cocktail sort) -->
<article class="article">
  <div class="anchor" id="sort-cocktail"></div>
  <h3>2. Сортировка перемешиванием (шейкерная сортировка) (Cocktail sort)</h3>
  <p>Шейкерная сортировка отличается от пузырьковой тем, что она двунаправленная: алгоритм перемещается не строго слева направо, а сначала слева направо, затем справа налево.</p>
  <p>Начинаем мы точно так же, как и в пузырьковой сортировке, и “выдавливаем наверх” максимальный элемент. После этого, разворачиваемся и “толкаем вниз” минимальный из оставшийся элементов.</p>
  <p>Оказавшись в начале массива, на своих местах будет уже 2 элемента - первый и последний. Остановимся когда дойдем до середины массива. Таким образом сделаем в 2 раза меньше итераций внешнего цикла. За счет этого скорость шейкерной сортировки будет немного выше, чем у обычного пузырька.</p>
  <p>Начнем с небольшого рефакторинга и вынесем функцию обмена наружу. Назовем ее swap</p>
<pre>function swap(arr, i, j) {
  let temp = arr[j];
  arr[j] = arr[i];
  arr[i] = temp;
}

function cocktailSort(arr) {
  let left = 0;
  let right = arr.length - 1;
  let isSwap = false;
  while(left &lt; right) {
    for (let i = left; i &lt; right; i++) {
      if (arr[i] &gt; arr[i + 1]) {
        swap(arr, i, i + 1);
        isSwap = true;
      }
    }
    if (!isSwap) {
      return arr;
    }
    isSwap = false;
    right--;
    for (let i = right; i &gt; left; i--) {
      if (arr[i] &lt; arr[i - 1]) {
        swap(arr, i, i - 1);
        isSwap = true;
      }
    }
    if (!isSwap) {
      return arr;
    }
    isSwap = false;
    left++;
  }
  return arr;
}</pre>
</article>


<!-- 3. Сортировка расчёской (Comb sort) -->
<article class="article">
  <div class="anchor" id="sort-sort"></div>
  <h3>3. Сортировка расчёской (Comb sort)</h3>
  <p>Сортировка расчёской — улучшение сортировки пузырьком. Её идея состоит в том, чтобы «устранить» элементы с небольшими значения в конце массива, которые замедляют работу алгоритма. Если при пузырьковой и шейкерной сортировках при переборе массива сравниваются соседние элементы, то при «расчёсывании» сначала берётся достаточно большое расстояние между сравниваемыми значениями, а потом оно сужается вплоть до минимального.</p>
  <p>Первоначальный разрыв нужно выбирать не случайным образом, а с учётом специальной величины — фактора уменьшения, оптимальное значение которого равно 1,247. Сначала расстояние между элементами будет равняться размеру массива, поделённому на 1,247. После каждого прохода расстояние делится на фактор уменьшения и таким образом получается новое значение. В конце концов оно сужается до минимального значения - единицы, и массив просто досортировывается обычным "пузырьком".</p>
<pre>// исходный массив
  var arr = [3,14,1,7,9,8,11,6,4,2]

  // получаем длину массива
  const l = arr.length;

  // оптимальное число для вычисления шага сравнения
  const factor = 1.247;

  // получаем точный шаг сравнения
  let gapFactor = l / factor;

  // пока шаг больше единицы
  while (gapFactor &gt; 1) {
      // округляем шаг до целого
      const gap = Math.round(gapFactor);
      // и организуем цикл как в пузырьковой сортировке
      for (let i = 0, j = gap; j &lt; l; i++, j++) {
          // если сначала идёт большое число
          if (arr[i] &gt; arr[j]) {
              // меняем их местами
              [arr[i], arr[j]] = [arr[j], arr[i]];
          }

          // выводим текущее состояние массива в консоль
          // это необязательный шаг, он здесь для наглядности
          console.log(arr);
      }
      // в конце цикла рассчитываем новый шаг
      gapFactor = gapFactor / factor;
  }</pre>
  <p>Расчёска лучше пузырьковой сортировки, потому что в ней намного меньше операций перестановки. Именно перестановка занимает основное время процессора. В самом худшем случае алгоритм сортировки расчёской будет работать так же, как и пузырьковая, а в среднем — алгоритм работает быстрее пузырьковой.</p>
</article>


<!-- 4. Сортировка вставками (Insertion Sort) -->
<article class="article">
  <div class="anchor" id="sort-insertion"></div>
  <h3>4. Сортировка вставками (Insertion Sort)</h3>
  <p>При сортировке вставками массив постепенно перебирается слева направо. При этом каждый последующий элемент размещается так, чтобы он оказался между ближайшими элементами с минимальным и максимальным значением.</p>
<pre>function insertionSort(inputArr) { 
  let n = inputArr.length; 
  for (let i = 1; i &lt; n; i++) {

  // выбираем первый элемент в неотсортированном массиве
  let current = inputArr[i];

  // последний элемент отсортированного массива
  let j = i-1; 
  while ((j &gt; -1) && (current &lt; inputArr[j])) { 
  inputArr[j+1] = inputArr[j]; 
  j--; 
  } 
  inputArr[j+1] = current; 
  } 
  return inputArr; 
}</pre>
  <p>Итерация начинается со второго элемента. Считаем отсортированным по умолчанию первый элемент. Для каждой итерации мы отслеживаем current элемент. Каждый current элемент будет первым элементом несортированного массива - и каждый элемент перед ним будет принадлежать отсортированному массиву.</p>
  <p>Через в while цикла, мы проходим отсортированный массив и сдвиг элементы вправо, открывая пространство для current элемента должны быть вставлено.</p>
  <p>Как только мы найдем для него подходящее место, current элемент вставляется во вновь открытый слот. Этот процесс повторяется для каждой итерации, пока массив не будет отсортирован.</p>
</article>


<!-- 5. Сортировка выбором (Selection sort) -->
<article class="article">
  <div class="anchor" id="sort-selection"></div>
  <h3>5. Сортировка выбором (Selection sort)</h3>
  <p>Сортировка выбором начинается с поиска наименьшего элемента в списке и обмена его с первым элементом (таким образом, наименьший элемент помещается в окончательную позицию в отсортированном массиве). Затем мы сканируем массив, начиная со второго элемента, в поисках наименьшего среди оставшихся n-1 элементов и обмениваем найденный наименьший элемент со вторым, т.е. помещаем второй наименьший элемент в окончательную позицию в отсортированном массиве. В общем случае, при i-ом проходе по списку (0 &lt;= i &lt;= n-2) алгоритм ищет наименьший элемент среди последних n-i элементов и обменивает его с A[ i ]. После выполнения n-1 проходов список оказывается отсортирован.</p>
  <p>После каждой итерации необходимо проверять на один элемент меньше, пока не будет отсортирован весь массив или список.</p>
<pre>function selectionSort(inputArr) { 
  let n = inputArr.length;
      
  for(let i = 0; i &lt; n; i++) {
      // Находим наименьшее число в правой части массива
      let min = i;
      for(let j = i; j &lt; n; j++) {
          if(inputArr[j] &lt; inputArr[min]) {
              min=j; 
          }
       }
       if (min != i) {
           // Заменяем элементы
           let tmp = inputArr[i]; 
           inputArr[i] = inputArr[min];
           inputArr[min] = tmp;      
      }
  }
  return inputArr;
}</pre>
</article>


<!-- 6. Сортировка Шелла (Shell Sort) -->
<article class="article">
  <div class="anchor" id="sort-shell"></div>
  <h3>6. Сортировка Шелла (Shell Sort)</h3>

<pre>function ShellSort(A)
  {
      var n = A.length, i = Math.floor(n/2);
      while (i &gt; 0)
       { for (var j = 0; j &lt; n; j++)
          { var k = j, t = A[j];
            while (k &gt;= i && A[k-i] > t)
             { A[k] = A[k-i]; k -= i; }
            A[k] = t;
          }
        i = (i==2) ? 1 : Math.floor(i*5/11);
       }
      return A;
  }</pre>
</article>


<!-- 7. Сортировка подсчетом (Counting Sort) -->
<article class="article">
  <div class="anchor" id="sort-count"></div>
  <h3>7. Сортировка подсчетом (Counting Sort)</h3>

  <p>Вначале для каждого элемента массива подсчитывается количество элементов, меньших, чем он, и на основе этой информации текущий элемент помещается в соответствующее место отсортированного массива. </p>
<pre>function SimpleCountingSort(A) {   
  var n = A.length, Count = [], B = [];
  for (var i = 0; i &lt; n; i++) Count[ i ] = 0;
  for (var i = 0; i &lt; n-1; i++)
    { for (var j = i+1; j &lt; n; j++)
      { if (A[ i ] &lt; A[j]) Count[j]++;
        else Count[ i ]++;
      }
    }
  for (var i = 0; i &lt; n; i++) B[Count[ i ]] = A[ i ];
  return B;
}</pre>
</article>


<!-- 8. Сортировка слиянием (Merge Sort) -->
<article class="article">
  <div class="anchor" id="sort-merge"></div>
  <h3>8. Сортировка слиянием (Merge Sort)</h3>

<pre>function Merge(a,low,mid,high) {    //Вспомогательная функция.
  var b = new Array(high+1-low), h, i, j = mid+1, k, h = low, i = 0;
  while (h &lt;= mid && j &lt;= high )
    { if (a[h] &lt;= a[j]){ b[ i ]=a[h]; h++; }
      else             { b[ i ]=a[j]; j++; }
      i++;
    }
  if (h &gt; mid){ for (k = j; k &lt;= high; k++){ b[ i ]=a[k]; i++; } }
  else        { for (k = h; k &lt;= mid; k++){  b[ i ]=a[k]; i++; } }    
  for (k=0; k&lt;=high-low; k++) a[k+low]=b[k];
  return a;
}

function MergeSort(A) {     //Функция сортировки слиянияем.
  function merge_sort(a,low,high)
    { if (low &lt; high)
      { var mid = Math.floor((low+high)/2);
        merge_sort(a, low, mid);
        merge_sort(a, mid+1, high);
        Merge(a, low, mid, high);
      }
    }
  var n = A.length;
  merge_sort(A, 0, n-1);
  return A;
}</pre>
</article>


<!-- 9. Пирамидальная сортировка (сортировка кучей) (HeapSort) -->
<article class="article">
  <div class="anchor" id="sort-heap"></div>
  <h3>9. Пирамидальная сортировка (сортировка кучей) (HeapSort)</h3>

<pre>function HeapSort(A) {
  if (A.length == 0) return [];
  var n = A.length, i = Math.floor(n/2), j, k, t;
  while (true)
  { if (i &gt; 0) t = A[--i];
    else { n--;
            if (n == 0) return A;
            t = A[n];  A[n] = A[0];
          }        
    j = i;  k = j*2+1;
    while (k &lt; n)
      { if (k+1 &lt; n && A[k+1] &gt; A[k]) k++;
        if (A[k] &gt; t)
        { A[j] = A[k];  j = k;  k = j*2+1; }
        else break;
      }
    A[j] = t; 
  }
}</pre>
</article>


<!-- 10. Быстрая сортировка Хоара (Quick Sort) -->
<article class="article">
  <div class="anchor" id="sort-quick"></div>
  <h3>10. Быстрая сортировка Хоара (Quick Sort)</h3>

<pre>function QuickSort(A) {
  if (A.length == 0) return [];
  var a = [], b = [], p = A[0];
  for (var i = 1; i &lt; A.length; i++)
    { if (A[ i ] &lt; p) a[a.length] = A[ i ];
      else b[b.length] = A[ i ];
    }
  return QuickSort(a).concat( p,QuickSort(b) );
}</pre>
</article>


<!-- 11. Гномья сортировка (Gnome Sort) -->
<article class="article">
  <div class="anchor" id="sort-gnome"></div>
  <h3>11. Гномья сортировка (Gnome Sort)</h3>

  <p>Гномья сортировка (англ. Gnome sort) — алгоритм сортировки, похожий на сортировку вставками, но в отличие от последней перед вставкой на нужное место происходит серия обменов, как в сортировке пузырьком.</p>

<pre>function GnomeSort(A) {
  var n = A.length, i = 1, j = 2;
  while (i &lt; n)
    { if (A[i-1] &lt; A[ i ]){ i = j; j++; }
      else
        { var t = A[i-1]; A[i-1] = A[ i ]; A[ i ] = t;
          i--;
          if (i == 0){ i = j; j++; }
        }
    }
  return A;
}</pre>
</article>
