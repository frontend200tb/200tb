<h1>Алгоритмы поиска</h1>

<!-- Содержание -->
<div class="article">
  <h2>Содержание</h2>
  <a href="#search">Поиск</a>
  <ol>
    <li><a href="#search-1">Линейный поиск</a></li>
    <li><a href="#search-2">Двоичный (бинарный) поиск</a></li>
    <li><a href="#search-3">Поиск в глубину (Depth-First Search)</a></li>
    <li><a href="#search-4">Поиск в ширину (Breadth-First Search)</a></li>
    <li><a href="#search-5">Алгоритм Дейкстры</a></li>
  </ol>
</div>


<!-- Поиск -->
<article class="article">
  <div class="anchor" id="search"></div>
  <h2>Поиск</h2>

  <ol>
    <li>Линейный поиск</li>
    <li>Двоичный (бинарный) поиск</li>
    <li>Поиск в глубину (Depth-First Search)</li>
    <li>Поиск в ширину (Breadth-First Search)</li>
    <li>Алгоритм Дейкстры</li>
  </ol>
</article>


<!-- Линейный поиск -->
<article class="article">
  <div class="anchor" id="search-1"></div>
  <h3>Линейный поиск</h3>
  <p>Линейный поиск числа перебирает каждый элемент в наборе данных и сравнивает его с целевым числом. Если находит совпадение то выдает ответ, что число найдено в списке. Если проходит все числа от первого до последнего и совпадения не будет, то выдает ответ что число отсутствует в списке.</p>
  <p>Временная сложность линейного поиска O(n). O(n) это худший случай, если элемент окажется последний в списке и придется просмотреть каждый элемент, чтобы найти его. В лучшем случае элемент окажется первым в списке и с сложность будет O(1). В среднем линейному поиску требуется n/2 шагов.</p>
  <p>Линейный поиск используют если данные не отсортированы. Если данные отсортированы то можно использовать двоичный поиск.</p>
<pre>const linearSearch = (arr, findEl) => {
  for (let i = 0; i &lt; arr.length; i++) {
    if (arr[i] === findEl) {	
      return i
    }
  }
  return -1
}</pre>
  <p>Запускаем цикл по массиву i.</p>
  <p>Проверяем текущий элемент на соответствие искомому элементу, в случае не соответствия идём дальше. Если элемент соответствует искомому, возвращаем его индекс.</p>
  <p>Если элемента нет в массиве, возвращаем -1.</p>
  <p>Сложность алгоритма: О(n).</p>
</article>


<!-- Двоичный (бинарный) поиск -->
<article class="article">
  <div class="anchor" id="search-2"></div>
  <h3>Двоичный (бинарный) поиск</h3>
  <p>Двоичный поиск работает только с отсортированными данными. Первый шаг это определить среднее число. Второй шаг это сравнить целевое число со средним числом. Если число совпало то алгоритм закончен, если нет то переходим на третий шаг. Третий шаг определить целевое число больше или меньше среднего числа. Отбросить ненужную половину чисел и искать в нужной.</p>
  <p>Временная сложность двоичного поиска O(log n). Это эффективнее чем линейный поиск. Линейный поиск среди миллиона элементов займет миллион шагов. Двоичный поиск среди миллиона элементов займет 20 шагов.</p>
  <p>Когда при двоичном поиске первый раз делим список пополам, то остается n/2 элементов, после второй итерации n/(2*2), после третьей n/(2**3) и т.д. Двоичный поиск при каждой итерации делит список пополам, а это значит, что основание логарифма, описывающего время выполнени поиска, равно 2. Тем не менее, в нотации "О большое" основание логарифма не имеет значение, потому что его можно изменить, умножив логарифм на константу.</p>
  <p>Если есть большой список, к которому требуется выполнить много поисковых запросов, то выгоднее отсортировать данные один раз, чтобы ускорить каждый поиск в будущем.</p>
  <p>Пример функции бинарного поиска на JavaScript, которая имеет сложность O(log n):</p>
<pre>function binarySearch(arr, target) {

  // Создаём два указателя на начало массива и конец массива.
  let left = 0;
  let right = arr.length - 1;

  //Запускаем цикл, который итерируется до тех пор, пока указатель на начало не совпадает с указателем на конец массива.
  while (left &lt;= right) {

    //Внутри цикла создаём указатель на середину массива.
    let mid = Math.floor((left + right) / 2);

    // Проверяем, если элемент по середине равен искомому элементу, возвращаем его индекс.
    if (arr[mid] === target) {
        return mid; // элемент найден
    } else if (arr[mid] &lt; target) {
        left = mid + 1; // искать в правой половине
    } else {
        right = mid - 1; // искать в левой половине
    }
  }

  // элемент не найден
  return -1; 

}</pre>
  <p>Бинарный поиск ищет значение в отсортированном массиве, разделяя его пополам на каждой итерации. Поиск начинается с середины массива. Если значение, которое мы ищем, больше среднего элемента, поиск продолжается в правой половине массива. Если оно меньше, то в левой. Таким образом, на каждой итерации мы уменьшаем область поиска примерно в два раза, что обеспечивает логарифмическую сложность O(log n).</p>
</article>


<!-- Поиск в глубину (Depth-First Search) -->
<article class="article">
  <div class="anchor" id="search-3"></div>
  <h3>Поиск в глубину (Depth-First Search)</h3>
  <p>Поиск в глубину — это алгоритм обхода или поиска в таких структурах данных, как деревья или графы. Основан на такой структуре данных, как стек. Алгоритм начинает работу с корневого узла (в случае графа в качестве корневого узла выбирается какой-либо произвольный узел) и прежде чем вернуться назад, проходит как можно дальше по каждой ветви.</p>
  <p>Сложность алгоритма: O(V + E).</p>

  <p>Шаги реализации:</p>
  <ol>
    <li>В случае обхода графа необходимо проинициализировать объект visited, который будет хранить вершины, которые прошёл алгоритм во избежание попадания в бесконечный цикл. В случае обхода по дереву этот шаг можно пропустить.</li>
    <li>Создаём массив stack, который будет исполнять роль стека, сразу заполняем его значением вершины, с которой начнём обход.</li>
    <li>Запускаем цикл, который будет итерироваться до тех пор, пока стек не опустеет.</li>
    <li>Достаём первое значение из стека и помещаем его в переменную vert.</li>
    <li>Проверяем, имеет ли эта вершина дочерние вершины.</li>
    <li>В случае если дочерние вершины найдены, добавляем их в начало стека.</li>
    <li>В случае обхода графа запускаем цикл, который будет проходить по дочерним вершинам, и если они не были пройдены алгоритмом ранее, класть их в стек.</li>
  </ol>

  <p>Пример кода в дереве:</p>
<pre>const dfs = (tree, start) => {
  const stack = [start];

  while (stack.length &gt; 0) {
    const vert = stack.shift(); // Выбираем первую вершину из стека

    if (tree[vert]) {
      stack.unshift(...tree[vert]); // Добавляем вершины в начало стека
    }
  }
};</pre>
  <p>Пример кода в графе:</p>
<pre>const dfs = (graph, start) => {
  const visited = {};
  const stack = [start];

  while (stack.length !== 0) {
    const vert = stack.shift(); // Выбираем первую вершину из стека

    if (!visited[vert]) {
      visited[vert] = true; // Отмечаем вершину как пройденую, если ранее не проходили её
    }

    if (graph[vert]) {
      for (let subVert of graph[vert]) {
        if (!visited[subVert]) {
          stack.unshift(subVert); // Добавляем вершину в начало стека
        }
      }
    }
  }
};</pre>
  <p>Алгоритм следует использовать в следующих случаях:</p>
  <ol>
    <li>Когда мы знаем, что искомая вершина находится дальше всего от стартовой, или если граф имеет большую ширину.</li>
    <li>Когда нам необходимо найти пути между вершинами.</li>
  </ol>
</article>


<!-- Поиск в ширину (Breadth-First Search) -->
<article class="article">
  <div class="anchor" id="search-4"></div>
  <h3>Поиск в ширину (Breadth-First Search)</h3>
  <p>Алгоритм поиска в ширину очень похож на описанный выше алгоритм поиска в глубину, отличается лишь тем, что в начале проходит все соседние узлы начальной вершины, потом все соседние узлы соседних вершин, и так далее, пока не пройдёт весь граф или не найдёт искомую вершину. Ещё одно отличие заключается в том, что основан этот алгоритм на такой структуре данных, как очередь.</p>
  <p>Сложность алгоритма: O(V + E).</p>

  <p>Шаги реализации:</p>
  <ol>
    <li>В случае обхода графа создаём объект visited, который будет хранить в себе информацию о пройденных вершинах, чтобы избежать бесконечного цикла.</li>
    <li>Создаём массив queue, который будет исполнять роль очереди.</li>
    <li>Запускаем цикл, который будет итерироваться до тех пор, пока очередь не опустеет.</li>
    <li>Достаём первый элемент из очереди и помещаем его в переменную vert.</li>
    <li>Проверяем, имеет ли эта вершина дочерние вершины.</li>
    <li>Если дочерние вершины имеются, добавляем их в конец очереди.</li>
    <li>В случае обхода графа запускаем цикл, который будет проходить по дочерним вершинам текущей вершины vert, и если алгоритм не проходил их ранее, добавляем их в конец очереди.</li>
  </ol>

  <p>Пример кода в дереве:</p>
<pre>const bfs = (tree, start) => {
  const queue = [start];

  while (queue.length !== 0) {
    const vert = queue.shift(); // Выбираем первую вершину из очереди

    if (tree[vert]) {
      queue.push(...tree[vert]); // Добавляем вершины в конец очереди
    }
  }
};</pre>
  <p>Пример кода в графе:</p>
<pre>const bfs = (graph, start) => {
  const visited = {};
  const queue = [start];

  while (queue.length !== 0) {
    const vert = queue.shift(); // Выбираем первую вершину из очереди

    if (!visited[vert]) {
      visited[vert] = true; // Отмечаем вершину как пройденую, если ранее не проходили её
    }

    if (graph[vert]) {
      for (let subVert of graph[vert]) {
        if (!visited[subVert]) {
          queue.push(subVert); // Добавляем вершину в конец очереди
        }
      }
    }
  }
};</pre>
  <p>Алгоритм следует использовать в следующих случаях:</p>
  <ol>
    <li>Когда мы знаем, что искомая вершина находится близко к стартовой, или если граф имеет большую глубину.</li>
    <li>Когда нам необходимо найти кратчайшее расстояние в невзвешенном графе.</li>
  </ol>
</article>


<!-- Алгоритм Дейкстры -->
<article class="article">
  <div class="anchor" id="search-5"></div>
  <h3>Алгоритм Дейкстры</h3>

  <p>Основная идея алгоритма — создание дерева кратчайших путей с заданным источником в качестве корня. Алгоритм Дейкстры — один из самых популярных алгоритмов для нахождения короткого пути в взвешенном графе. Незаменим в работе GPS-навигации.</p>

  <p>Сложность алгоритма: O(E * log V)</p>

  <p>Шаги реализации:</p>
  <ol>
    <li>Создаём объект parents, который будет хранить историю переходов по графу, объект costs , который будет хранить стоимости переходов, массив queue — очередь обхода вершин.</li>
    <li>Запускаем цикл, который проходит по вершинам графа и заполняет стартовыми значениями объект стоимости и очередь.</li>
    <li>Стоимость перехода в стартовую вершину равна 0, для остальных вершин Infinity.</li>
    <li>Запускаем цикл по очереди, находим элемент с наименьшей стоимостью перехода и помещаем её в переменную.</li>
    <li>Если элемент с наименьшей стоимостью существует и значение перехода в него не равно Infinity, запускаем цикл по дочерним вершинам.</li>
    <li>Находим новую стоимость, складывая стоимость перехода в родительскую и дочернюю вершину.</li>
    <li>Если стоимость перехода в дочернюю вершину больше новой стоимости, то обновляем стоимость для дочерней вершины в объекте стоимости, в истории переходов для дочерней вершины устанавливаем значение родительской вершины и добавляем дочернюю вершину с новой стоимостью в конец очереди.</li>
    <li>Повторяем шаги 4-7, пока очередь не опустеет.</li>
  </ol>

  <p>Пример кода:</p>
<pre>const getLowestCostNode = (queue) => {
  let min = Infinity;
  let lowIndex;

  for (let i = 0; i &lt; queue.length; i++) {
    const [, value] = queue[i];
    if (value &lt; min) {
      min = value;
      lowIndex = i;
    }
  }

  const lowestNode = queue.splice(lowIndex, 1)[0];
  return lowestNode;
};

const dijkstra = (graph, start) => {
  const parents = {};
  const costs = {};
  const queue = [];

  for (let vert in graph) {
    if (vert === start) {
      costs[vert] = 0;
      queue.push([vert, 0]);
    } else {
      costs[vert] = Infinity;
      queue.push([vert, Infinity]);
    }
    parents[vert] = null;
  }

  while (queue.length) {
    const node = getLowestCostNode(queue);
    let [vert, value] = node;
    const cost = costs[vert];

    if (node || value !== Infinity) {
      for (let subNode in graph[vert]) {
        const nextSubNodeValue = graph[vert][subNode];
        const newCost = cost + nextSubNodeValue;
          if (costs[subNode] &gt; newCost) {
            costs[subNode] = newCost;
            parents[subNode] = vert;
            queue.push([subNode, newCost]);
          }
      }
    }
  }
};</pre>

  <p>Алгоритм следует использовать в следующих случаях:</p>
  <ol>
    <li>Когда необходимо найти кратчайший путь в взвешенном графе.</li>
    <li>Когда граф не имеет отрицательных весов.</li>
  </ol>
</article>
