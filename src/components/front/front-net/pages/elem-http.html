<h1>HTTP протокол</h1>

<!-- Заголовок -->
<div class="article">
  <div class="anchor" id="content"></div>
  <h2>Содержание</h2>
</div>

<!-- Содержание -->
<div class="article article__content">

  <div>
    <p><a href="#links">links</a></p>
    <p><a href="#about">Что такое HTTP</a></p>
    <p><a href="#consist">Из чего состоит HTTP</a></p>
    <p><a href="#work">Как работает HTTP</a></p>
    <p><a href="#request">Структура HTTP запроса</a>
    <br> - <a href="#start-line">Стартовая строка (Start line)</a>
    <br> - <a href="#method">Методы в стартовой строке</a>
    <br> - <a href="#url">URL в стартовой строке</a>
    <br> - <a href="#version">Версии HTTP</a>
    <br> - <a href="#http-headers">Заголовки HTTP (HTTP Headers)</a></p>
    <p><a href="#response">Структура HTTP ответа</a>
    <br> - <a href="#status-line">Строка статуса (Status line)</a>
    <br> - <a href="#status-code">Код состояния (Status code)</a></p>
  </div>

</div>


<!-- links -->
<article class="article">
  <div class="anchor" id="links"></div>
  <h2>links</h2>

  <h3>Статьи</h3>
  <p><a href="https://skillbox.ru/media/code/chto-takoe-http-i-zachem-on-nuzhen/">skillbox.ru</a> Что такое HTTP и зачем он нужен (2022.09.30)</p>
  <p><a href="https://otus.ru/journal/http-zaprosi-i-statusi/">otus.ru</a> HTTP-запросы и статусы (2023.05.14)</p>
  <p><a href="https://otus.ru/journal/http-zaprosy-ot-a-do-ya/">otus.ru</a> HTTP-запросы от А до Я (2023.05.14)</p>

  <h3>Статьи на habr</h3>
  <p><a href="https://habr.com/ru/companies/avito/articles/710660/">habr.com/ru/companies/avito/articles/710660</a> Ультимативный гайд по HTTP. Структура запроса и ответа (Алексей Ивасюта 2023.03.29)</p>
</article>


<!-- Что такое HTTP -->
<article class="article">
  <div class="anchor" id="about"></div>
  <h2>Что такое HTTP</h2>

  <p>HTTP или HyperText Transfer Protocol – это протокол передачи гипертекста. Является протоколом прикладного уровня, используемым для передачи данных. Он представляет собой список правил, по которым компьютеры обмениваются данными в интернете. HTTP умеет передавать все возможные форматы файлов — например, видео, аудио, текст. Но при этом состоит только из текста.</p>

  <p>Протокол HTTP используют ещё с 1992 года. Он очень простой, но при этом довольно функциональный. А ещё HTTP находится на самой вершине модели OSI (на прикладном уровне), где приложения обмениваются друг с другом данными. А работает HTTP с помощью протоколов TCP/IP и использует их, чтобы передавать данные.</p>

  <p>Кроме HTTP в интернете работает ещё протокол HTTPS. Аббревиатура расшифровывается как «защищённый протокол передачи гипертекста» (или HyperText Transfer Protocol Secure). Он нужен для безопасной передачи данных по Сети. Всё происходит по тем же принципам, как и у HTTP, правда, перед отправкой данные дополнительно шифруются, а затем расшифровываются на сервере.</p>
  
  <p>Например, HTTPS используют во время ввода данных банковской карты или паролей на сайтах — да и в целом большинство современных сайтов используют именно его.</p>
</article>


<!-- Из чего состоит HTTP -->
<article class="article">
  <div class="anchor" id="consist"></div>
  <h2>Из чего состоит HTTP</h2>

  <p>HTTP состоит из двух элементов: клиента и сервера. Клиент отправляет запросы и ждёт данные от сервера. А сервер ждёт, пока ему придёт очередной запрос, обрабатывает его и возвращает ответ клиенту.</p>

  <p>Обычно эта связь между клиентом и сервером имеет посредников в виде прокси-серверов. Они нужны для разных операций — например, для безопасности и конфиденциальности, кэширования или распределения нагрузки на серверы.</p>

  <p>Клиентом может быть любое устройство, через которое пользователь запрашивает данные. Часто в роли клиента выступает веб-браузер, программы для отладки приложений или даже командная строка. Главная особенность клиента — он всегда инициирует запрос.</p>

  <p>Сервер — это устройство, которое обрабатывает запросы клиента. Он может состоять как из одного компьютера, так и из кластера. А ещё несколько виртуальных серверов могут находиться на одной физической машине.</p>
  
  <p>Прокси-серверы — это второстепенные серверы, которые располагаются между клиентом и главным сервером. Они обрабатывают HTTP-запросы, а также ответы на них. Чаще всего прокси-серверы используют для кэширования и сжатия данных, обхода ограничений и анонимных запросов. И ещё — обычно между клиентом и основным сервером находится один или несколько таких прокси-серверов.</p>
</article>


<!-- Как работает HTTP -->
<article class="article">
  <div class="anchor" id="work"></div>
  <h2>Как работает HTTP</h2>

  <p>Весь процесс передачи HTTP-запроса можно разбить на семь шагов. Давайте разберём их подробнее.</p>
  
  <ol>
    <li>
      <h3>Шаг первый — вписываем URL в браузер</h3>
      <p>Чтобы отправить HTTP-запрос, нужно использовать URL-адрес — это «унифицированный указатель ресурса» (или Uniform Resource Locator). Он указывает браузеру, что нужно использовать HTTP-протокол, а затем получить файл с этого адреса обратно. Обычно URL-адреса начинаются с http:// или https:// (зависит от версии протокола).</p>
    </li>
    <li>
      <h3>Шаг второй — браузер находит IP-адрес</h3>
      <p>Для пользователей URL-адрес — это набор понятных слов: Skillbox, Yandex, Google. Но для компьютера эти понятные нам слова — набор непонятных символов. Поэтому браузер отправляет введённые вами слова в DNS, преобразователь URL-адресов в IP-адреса. DNS расшифровывается как «доменная система имён» (Domain Name System), и его можно представить как огромную таблицу со всеми зарегистрированными именами для сайтов и их IP-адресами. DNS возвращает браузеру IP-адрес, с которым тот уже умеет работать.</p>
    </li>
    <li>
      <h3>Шаг третий — браузер отправляет HTTP-запрос</h3>
      <p>Теперь браузер начинает составлять HTTP-запрос с вложенным в него IP-адресом. Формируется http запрос, который упаковывается в сетевой пакет и отправляется в сеть.</p>
    </li>
    <li>
      <h3>Шаг четвёртый — прохождение маршрутизаторов</h3>
      <p>Пакет проходит через цепочку маршрутизаторов, каждый из которых проверяет пункт назначения и перенаправляет кратчайшим путем.</p>
    </li>
    <li>
      <h3>Шаг пятый — запрос приходит на сервер</h3>
      <p>Запрос приходит на сервер, где производится его распаковка и определение приложения, которое займется его обработкой. Статические файлы (изображения, javascript) возвращаются без обработки, тогда как php файлы нужно выполнить на интерпретаторе и только после этого вернуть результат пользователю. Интерпретатор выполняет код, при необходимости обращаясь к базе данных, файлам, другим сервисам и возвращает результат.</p>
    </li>
    <li>
      <h3>Шаг шестой — сервер отправляет ответ</h3>
      <p>После получения и обработки HTTP-запроса сервер создаёт ответ и отправляет его обратно клиенту. В нём содержатся дополнительная информация (метаданные) и запрашиваемые данные.</p>
    </li>
    <li>
      <h3>Шаг седьмой — браузер отображает веб-страницу</h3>
      <p>Как только браузер получил ответ с веб-страницей, он отображает её с помощью внутреннего движка, при необходимости подгружая дополнительные ресурсы (изображения, стили и т.д).. И на этом весь процесс отправки и получение HTTP-запросов заканчивается, а клиент получает нужные ему данные.</p>
    </li>
  </ol>
</article>


<!-- Структура HTTP запроса -->
<article class="article">
  <div class="anchor" id="request"></div>
  <h2>Структура HTTP запроса</h2>

  <p>Как запросы, так и ответы имеют следующую структуру</p>
  <ol>
    <li>
      <h3><a href="#start-line"></a>Стартовая строка (Start line)</h3>
      <p>В ней передается метод запроса, url и версия протокола. Стартовая строка занимает ровно одну строчку.</p>
    </li>
    <li>
      <h3><a href="#http-headers"></a>Заголовки HTTP (HTTP Headers)</h3>
      <p>Заголовок это пара ключ: значение разделенная двоеточием. Каждый заголовок записывается с новой строки и занимает ровно одну строчку. Заголовки передают дополнительные данные.</p>
    </li>
    <li>Пустая строка (Blank line), которая сообщает, что все метаданные для конкретного запроса или ответа были отправлены</li>
    <li>Тело запроса (Body). Тело HTTP-запроса может быть не у всех запросов. Например, для методов GET, HEAD, DELETE, OPTIONS тело, как правило, не нужно. А вот для методов типа POST оно необходимо — чтобы отправлять на сервер информацию для обновления, например.</li>
  </ol>
</article>


<!-- Стартовая строка (Start line) -->
<article class="article">
  <div class="anchor" id="start-line"></div>
  <h2>Стартовая строка (Start line)</h2>

  <p>Стартовая строка записывается в одну строку и состоит из трех элементов записанных через пробел. Различается стартовая строка для запроса и для ответа.</p>
  <p>Стартовая строка для запроса</p>
  <ol>
    <li>Метод HTTP-запроса. Это короткое слово на английском, которое указывает что нужно сделать.</li>
    <li>Цель запроса. URL, включающий в себя протокол, домен, путь к ресурсу на сервере.</li>
    <li>Версия протокола. Обычно HTTP/1.1 или HTTP/2</li>
  </ol>
  <p>Пример стартовой строки</p>
  <code>GET /index.html HTTP/1.1</code>
  <p>метод - GET,
  <br>цель - /index.html,
  <br>протокол - HTTP/1.1</p>
</article>


<!-- Методы в стартовой строке -->
<article class="article">
  <div class="anchor" id="method"></div>
  <h2>Методы в стартовой строке</h2>

  <p>Основные методы в HTTP запросах</p>
  <ol>
    <li>
      <h3>CONNECT</h3>
      <p>Запускает TCP/IP туннель, то есть двустороннюю связь с сервером.</p>
    </li>
    <li>
      <h3>DELETE (Удаление ресурса)</h3>
      <p>Удаляет существующий ресурс на сервере</p>
    </li>
    <li>
      <h3>GET (Получение ресурса)</h3>
      <p>Запрашивает ресурс. Дополнительные данные могут быть переданы через строку запроса (Query String) в составе URL (например ?param=value)</p>
    </li>
    <li>
      <h3>HEAD</h3>
      <p>Запрашивает только заголовки, которые сервер бы вернул при получении GET-запроса к тому же ресурсу. Используется чтобы узнать размер запрашиваемого ресурса перед его загрузкой</p>
    </li>
    <li>
      <h3>OPTIONS</h3>
      <p>Запрашивает информацию о сервере, в том числе информацию о допускаемых к использованию на сервере HTTP-методов.</p>
    </li>
    <li>
      <h3>PATCH (Обновление ресурса)</h3>
      <p>Отправляет данные на сервер и вносит частичные изменения в указанный ресурс по указанному расположению.</p>
    </li>
    <li>
      <h3>POST (Создание или обновление ресурса)</h3>
      <p>Отправляет данные на сервер для создания новой записи или обновления информации.</p>
    </li>
    <li>
      <h3>PUT (Обновление ресурса)</h3>
      <p>Отправляет данные на сервер и полностью заменяет все текущие данные на те которые были отправлены в запросе.</p>
    </li>
    <li>
      <h3>TRACE</h3>
      <p>Позволяет клиенту получить информацию, вносимую или изменяемую промежуточными серверами.</p>
    </li>
  </ol>
</article>


<!-- URL в стартовой строке -->
<article class="article">
  <div class="anchor" id="url"></div>
  <h2>URL в стартовой строке</h2>

  <p>Получение доступа к ресурсам по HTTP-протоколу осуществляется с помощью указателя URL (Uniform Resource Locator). URL представляет собой строку, которая позволяет указать запрашиваемый ресурс и еще ряд параметров.</p>

  <p>Структура url, где обязательные только scheme и host</p>
  <code>[scheme]://[host]:[port][path][query string]</code>
  <p>Для [scheme] = http по умолчанию используется [port] = 80</p>
  <p>Для [scheme] = https по умолчанию используется [port] = 443</p>
  <p>Для [path] по умолчанию используется index.html или index.php</p>
  <p>[query string] начинается со знака вопроса (?), за которым следует пара «параметр-значение», между которыми расположен символ равно (=). В поле Query String могут быть переданы несколько параметров с помощью символа амперсанд (&) в качестве разделителя.</p>
</article>


<!-- Версии HTTP -->
<article class="article">
  <div class="anchor" id="version"></div>
  <h2>Версии HTTP</h2>

  <p>Протокол HTTP представил миру Тим Бернерс-Ли в марте 1991 года</p>
  <ol>
    <li>
      <h3>HTTP/0.9</h3>
      <p>В 1991 году была опубликована первая версия протокола с названием HTTP/0.9. Эта реализация была проста, как топор. От интернет-ресурса того времени требовалось только загружать запрашиваемую HTML-страницу и HTTP/0.9 справлялся с этой задачей. Обычный запрос к серверу выглядел так:</p>
      <code>GET /http-spec.html</code>
      <p>В протоколе был определен единственный метод GET и и указывался путь к ресурсу. Так пользователи получали страничку. После этого открытое соединение сразу закрывалось. </p>
    </li>
    <li>
      <h3>HTTP/1.0</h3>
      <p>Стало понятно, что нужно не только получать странички от сервера, но и отправлять ему данные. В 1996 году вышла версия протокола 1.0.</p>
      <p>Что изменилось:</p>
      <ol>
        <li>В запросе теперь надо было указывать версию протокола. Так сервер мог понимать, как обрабатывать полученные данные.</li>
        <li>В ответе от сервера появился статус завершения обработки запроса.</li>
        <li>К запросу и ответу добавился новый блок с заголовками.</li>
        <li>Добавили поддержку новых методов:
          <ul>
            <li>HEAD запрашивает ресурс так же, как и метод GET, но без тела ответа. Так можно получить только заголовки, без самого ресурса.</li>
            <li>POST добавляет сущность к определённому ресурсу. Часто вызывает изменение состояния или побочные эффекты на сервере. Например, так можно отправить запрос на добавление нового поста в блог.</li>
          </ul>
        </li>
      </ol>
    </li>
    <li>
      <h3>HTTP/1.0</h3>
    </li>
    <li></li>
  </ol>
</article>


<!-- Заголовки HTTP (HTTP Headers) -->
<article class="article">
  <div class="anchor" id="http-headers"></div>
  <h2>Заголовки HTTP (HTTP Headers)</h2>

  <p>Заголовок это пара ключ: значение разделенная двоеточием. Каждый заголовок записывается с новой строки и занимает ровно одну строчку. Заголовки передают дополнительные данные.</p>

  <p>В запросах может передаваться большое число различных заголовков, но все их можно разделить на четыре категории:</p>
  <ol>
    <li>
      <h3><a href="#head-general">General Headers (Основные заголовки)</a></h3>
      <p>Применяются к любому сообщению клиента и сервера целиком.</p>
    </li>
    <li>
      <h3><a href="#head-request">Request Headers (Заголовки запроса)</a></h3>
      <p>Уточняют некоторую информацию о запросе, сообщая дополнительный контекст или ограничивая его некоторыми логическими условиями.</p>
    </li>
    <li>
      <h3><a href="#head-response">Response Headers (Заголовки ответа)</a></h3>
      <p>Только для ответов от сервера</p>
    </li>
    <li>
      <h3><a href="#head-entity">Entity Headers (Заголовки сущности)</a></h3>
      <p>Сопровождают каждую сущность сообщения</p>
    </li>
  </ol>

  <p>Примеры заголовков</p>

  <ol>
    <li>
      <h3>Content-Security-Policy</h3>
      <p>Реализует механизм защиты от угроз межсайтового выполнения скриптов.</p>
    </li>
    <li>
      <h3>X-Custom-Header</h3>
      <p>пользовательские заголовки, начинающиеся с X- с произвольными именем. Через них реализуется специфическая логика обработки для конкретного сервера. Если веб-сервер не поддерживает такие заголовки, то он проигнорирует их.</p>
    </li>
  </ol>

</article>


<!-- General Headers (Основные заголовки) -->
<article class="article">
  <div class="anchor" id="head-general"></div>
  <h2>General Headers (Основные заголовки)</h2>

  <ol>
    <li>
      <h3>Cache-Control</h3>
      <p>Определяет директивы, которые должны быть выполнены системой кэширования</p>
    </li>
    <li>
      <h3>Connection</h3>
      <p>Позволяет отправителю определить желаемые свойства для данного конкретного соединения и не должно связываться с прокси через текущее соединение.</p>
    </li>
    <li>
      <h3>Date</h3>
      <p>При работе с HTTP, время и дата должны быть представлены во времени по Гринвичу (Greenwich Mean Time – GMT) во всех случаях без исключений.</p>
    </li>
    <li>
      <h3>Pragma</h3>
      <p>Используется для внедрения имплементации специальных директив, которые могут быть приняты любым реципиентом в цепочке запрос/ответ.</p>
    </li>
    <li>
      <h3>Trailer</h3>
      <p>Указывает, что данный набор заголовков представлен в виде последовательности сообщений, которые закодированы с помощью фрагментации кодировки передачи.</p>
    </li>
    <li>
      <h3>Transfer-Encoding</h3>
      <p>Указывает, какой тип преобразования был применён к телу сообщения. Используется для безопасного обмена данными между клиентом и сервером.</p>
    </li>
    <li>
      <h3>Upgrade</h3>
      <p>Позволяет клиенту определять дополнительные протоколы обмена данными, которые он поддерживает и хотел бы использовать в случае, если он поддерживается сервером.</p>
    </li>
    <li>
      <h3>Via</h3>
      <p>Это поле используется соединениями и прокси для указывания промежуточных протоколов и адресатов. Если данные идут не напрямую, а через прокси.</p>
    </li>
    <li>
      <h3>Warning</h3>
      <p>Используется для хранения дополнительной информации о статусе или преобразовании данных, которые могут не отображаться в самом сообщении.</p>
    </li>
  </ol>
</article>


<!-- Request Headers (Заголовки запроса) -->
<article class="article">
  <div class="anchor" id="head-request"></div>
  <h2>Request Headers (Заголовки запроса)</h2>

  <ol>
    <li>
      <h3>Accept</h3>
      <p>Список MIME типов, которые ожидает клиент, перечисленные через запятую. А для указания того, что клиент принимает любые типы, используется следующая последовательность — */*.</p>
    </li>
    <li>
      <h3>Accept-Charset</h3>
      <p>Список кодировок, которые ожидает клиент.</p>
    </li>
    <li>
      <h3>Accept-Encoding</h3>
      <p>Список форматов сжатия данных, которые поддерживает клиент.</p>
    </li>
    <li>
      <h3>Accept-Language</h3>
      <p>Указывает набор приемлемых языков для ответа.</p>
    </li>
    <li>
      <h3>Authorization</h3>
      <p>Используется в качестве еще одного метода идентификации клиента на сервере. После успешной идентификации сервер возвращает токен, уникальный для каждого конкретного клиента. В отличие от куки, данный токен хранится исключительно на стороне клиента и отправляется клиентом только по запросу сервера. Существует несколько типов аутентификации, конкретный метод определяется тем веб-сервером или веб-приложением, к которому клиент обращается за ресурсом.</p>
    </li>
    <li>
      <h3>Cookie</h3>
      <p>Данный заголовок может содержать в себе одну или несколько пар «Куки-Значение» в формате cookie=value. Куки представляют собой небольшие фрагменты данных, которые хранятся как на стороне клиента, так и на сервере, и выступают в качестве идентификатора. Куки передаются вместе с запросом для поддержания доступа клиента к ресурсу. Помимо этого, куки могут использоваться и для других целей, таких как хранение пользовательских предпочтений на сайте и отслеживание клиентской сессии. Несколько кук в одном заголовке могут быть перечислены с помощью символа точка с запятой ;, который  используется как разделитель.</p>
    </li>
    <li>
      <h3>Expect</h3>
      <p>Указывает, что данный набор поведений сервера требуется клиентом.</p>
    </li>
    <li>
      <h3>From</h3>
      <p>Данное поле содержит email пользователя, который контролирует запросы пользователя</p>
    </li>
    <li>
      <h3>Host</h3>
      <p>Используется для указания того, с какого конкретно хоста запрашивается ресурс. В качестве возможных значений могут использоваться как доменные имена, так и IP-адреса. На одном HTTP-сервере может быть размещено несколько различных веб-сайтов. Для обращения к какому-то конкретному требуется данный заголовок.</p>
    </li>
    <li>
      <h3>Max-Forwards</h3>
      <p>Обеспечивает механизм с методами TRACE и OPTIONS для ограничения количества прокси или соединений, которые могут передавать запрос следующему серверу.</p>
    </li>
    <li>
      <h3>Proxy-Authorization</h3>
      <p>Позволяет клиенту определять себя (или своего пользователя) для прокси, который требует аутентификации.</p>
    </li>
    <li>
      <h3>Range</h3>
      <p>Поле заголовка Range определяет диапазон запрашиваемого из документа контента в байтах.</p>
    </li>
    <li>
      <h3>Referer</h3>
      <p>Используется для указания того, откуда поступил текущий запрос.</p>
    </li>
    <li>
      <h3>TE</h3>
      <p>Указывает расширение кодировка передачи, которая должна быть принята запросом или не должна.</p>
    </li>
    <li>
      <h3>User-Agent</h3>
      <p>Заголовок используется для описания клиента, который запрашивает ресурс. Он содержит достаточно много информации о пользовательском окружении. Например, может указать, какой браузер используется в качестве клиента, его версию, а также операционную систему, на которой этот клиент работает.</p>
    </li>
  </ol>
</article>


<!-- Response Headers (Заголовки ответа) -->
<article class="article">
  <div class="anchor" id="head-response"></div>
  <h2>Response Headers (Заголовки ответа)</h2>

  <ol>
    <li>
      <h3>Accept-Ranges</h3>
      <p>Позволяет серверу указывать принятие им диапазона запросов.</p>
    </li>
    <li>
      <h3>Age</h3>
      <p>Передаёт ожидания относительно времени (в секундах), прошедшего с момента ответа, который был сгенерирован сервером.</p>
    </li>
    <li>
      <h3>ETag</h3>
      <p>Обеспечивает текущее значение тэга сущности для варианта, на который был сделан запрос.</p>
    </li>
    <li>
      <h3>Location</h3>
      <p>Используется для перенаправления реципиента на URL, отличную от запрашиваемой.</p>
    </li>
    <li>
      <h3>Proxy-Authenticate</h3>
      <p>Данное поле заголовка должно быть включено как часть ответа 407 (Proxy Authentification Required).</p>
    </li>
    <li>
      <h3>Retry-After</h3>
      <p>Может быть использовано вместе с ответом 503 (Service Unavailable), чтобы указать, как долго сервис будет недоступен для запросов.</p>
    </li>
    <li>
      <h3>Server</h3>
      <p>Содержит информацию о ПО, которое используется сервером, обрабатывающем запрос.</p>
    </li>
    <li>
      <h3>Set-Cookie</h3>
      <p>Содержит пары значений “имя/значение”, информации по этой URL.</p>
    </li>
    <li>
      <h3>Vary</h3>
      <p>Определяет, что сущность имеет несколько ресурсов, которые могут варьироваться в зависимости от определённого списка заголовков запроса.</p>
    </li>
    <li>
      <h3>WWW-Authenticate</h3>
      <p>Должен быть включён в ответ 401 (Unauthorized).</p>
    </li>
  </ol>
</article>


<!-- Entity Headers (Заголовки сущности) -->
<article class="article">
  <div class="anchor" id="head-entity"></div>
  <h2>Entity Headers (Заголовки сущности)</h2>

  <ol>
    <li>
      <h3>Allow</h3>
      <p>Содержит список методов, которые поддерживаются ресурсом, определяемом URL.</p>
    </li>
    <li>
      <h3>Content-Encoding</h3>
      <p>Используется как модификатор для типа медиа файлов. Если кодировка контента, запрашиваемая клиентом не поддерживается сервером, то будет получен ответ 415 (Unsupported Media Type).</p>
    </li>
    <li>
      <h3>Content-Language</h3>
      <p>Определяет языки для определённой сущности. Если мы хотим использовать несколько языков, то мы должны указать их символы через запятую.</p>
    </li>
    <li>
      <h3>Content-Length</h3>
      <p>Сообщает длину контента в теле запроса в байтах.</p>
    </li>
    <li>
      <h3>Content-Location</h3>
      <p>Используется для поддержки локации ресурса для сущности, помещённой в сообщение, когда сущность запрашивается из локации, отличной от URI запрашиваемого ресурса.</p>
    </li>
    <li>
      <h3>Content-MD5</h3>
      <p>Данный заголовок используется для поддержки MD5 для сущности.</p>
    </li>
    <li>
      <h3>Content-Range</h3>
      <p>Данное поле заголовка отсылается с частью сущности для того, чтобы указать, где именно в целой сущности должна размещаться часть. Когда HTTP сообщение содержит контент с одним диапазоном, то оно передаётся с заголовками Content-Range и Content-Length, для того, чтобы показать количество уже переданных байтов.</p>
    </li>
    <li>
      <h3>Content-Type</h3>
      <p>Определяет MIME тип документа в теле запроса или ответа.</p>
    </li>
    <li>
      <h3>Expires</h3>
      <p>Указывает дату и время, после которого ответ считается устаревшим.</p>
    </li>
    <li>
      <h3>Last-Modified</h3>
      <p>Данное поле заголовка указывает дату и время, когда (по мнению сервера) был крайний раз изменён файл.</p>
    </li>
  </ol>
</article>


<!-- Структура HTTP ответа -->
<article class="article">
  <div class="anchor" id="response"></div>
  <h2>Структура HTTP ответа</h2>

  <p>HTTP-ответ является сообщением, которое сервер отправляет клиенту в ответ на его запрос. Его структура равна структуре HTTP-запроса: стартовая строка, заголовки и тело.</p>
</article>


<!-- Строка статуса (Status line) -->
<article class="article">
  <div class="anchor" id="status-line"></div>
  <h2>Строка статуса (Status line)</h2>

  <p>Стартовая строка записывается в одну строку и состоит из трех элементов записанных через пробел. Различается стартовая строка для запроса и для ответа.</p>
  <p>Стартовая строка для ответа называется строка статуса и содержит три элемента</p>
  <ol>
    <li>Версия протокола. Обычно HTTP/1.1 или HTTP/2</li>
    <li>Код состояния, который указывает, насколько успешно завершилась обработка запроса</li>
    <li>Пояснение — короткое текстовое описание к коду состояния. Используется исключительно для того, чтобы упростить понимание и восприятие человека при просмотре ответа.</li>
  </ol>
  <p>Пример строки состояния</p>
  <code>HTTP/1.1 200 OK</code>
  <p>протокол - HTTP/1.1
  <br>код состояния - 200
  <br>пояснение - OK</p>
</article>


<!-- Код состояния (Status code) -->
<article class="article">
  <div class="anchor" id="status-code"></div>
  <h2>Код состояния (Status code)</h2>

  <p>Код состояния состоит из трех цифр. Первая цифра от 1 до 5 говорит о том к какой из пяти категорий относится ответ</p>

  <ol>
    <li>
      <h3><a href="#code-1xx">1xx. Информационные ответы</a></h3>
      <p>Коды 1xx носят исключительно информативный характер и никак не влияют на обработку запроса.</p>
    </li>
    <li>
      <h3><a href="#code-2xx">2xx. Успешные ответы</a></h3>
      <p>Коды 2xx возвращаются в случае успешной обработки клиентского запроса.</p>
    </li>
    <li>
      <h3><a href="#code-3xx">3xx. Редиректы</a></h3>
      <p>Коды 3xx используются для перенаправления клиента.</p>
    </li>
    <li>
      <h3><a href="#code-4xx">4xx. Ошибка в запросе клиента</a></h3>
      <p>Коды 4xx указывают на то, что клиент сформировал некорректный запрос.</p>
    </li>
    <li>
      <h3><a href="#code-5xx">5xx. Ошибка на сервере</a></h3>
      <p>Коды 5xx указывают на то, что на сервере произошла ошибка.</p>
    </li>
  </ol>
</article>


<!-- 1xx. Информационные ответы -->
<article class="article">
  <div class="anchor" id="code-1xx"></div>
  <h2>1xx. Информационные ответы</h2>
  
  <ul>
    <li>100 Continue (Продолжить). Промежуточный ответ, который говорит о том, что запрос успешно принят.</li>
    <li>101 Switching Protocol (Переключился протокол). Присылается в ответ на запрос, в котором есть заголовок Upgrade. Это означает, что сервер переключился на протокол, который был указан в заголовке. Такая методика используется, например, для переключения на протокол Websocket.</li>
    <li>102 Processing (В обработке). Запрос получен сервером, но его обработка ещё не завершена.</li>
    <li>103	Early Hints</li>
    <li>104-199	Unassigned</li>
  </ul>
</article>


<!-- 2xx. Успешные ответы -->
<article class="article">
  <div class="anchor" id="code-2xx"></div>
  <h2>2xx. Успешные ответы</h2>

  <ul>
    <li>200 OK (Успешно). Пояснение говорит само за себя. Запрос успешно выполнен в соответствии с переданным методом (GET, HEAD, POSTa).</li>
    <li>201 Created (Создано). В результате выполнения запроса PUT был создан ресурс.</li>
    <li>202	Accepted (Принято). Для действий, которые занимают много времени для обработки и не могут быть выполнены сразу. Это означает, что запрос принят к обработке, но обработка не завершена.</li>
    <li>203	Non-Authoritative Information (Неавторитетная информация). Предоставленная информация взята не из оригинального источника (а, например, из кэша, который мог устареть, или из резервной копии, которая могла потерять актуальность). Предоставленная информация может совпадать, а может и не совпадать с оригинальными данными.</li>
    <li>204	No Content (Нет контента). Тело ответа должно быть пустым. Ответ на запрос PUT, POST или DELETE, когда REST API отказывается отправлять обратно любое сообщение о состоянии проделанной работы. Ответ на GET запрос, чтобы указать, что запрошенный ресурс существует, но не имеет данных для добавления их в тело ответа.</li>
    <li>205	Reset Content (Сброшенное содержимое). Сервер успешно обработал запрос и обязывает клиента сбросить введенные пользователем данные. В ответе не должно передаваться никаких данных (в теле ответа). Обычно применяется для возврата в начальное состояние формы ввода данных на клиенте.</li>
    <li>206 Partial Content (Частичное содержимое). Сервер выполнил часть GET запроса ресурса. Используется для загрузки контента в несколько потоков.</li>
    <li>207	Multi-Status</li>
    <li>208	Already Reported</li>
    <li>209-225	Unassigned</li>
    <li>226	IM Used</li>
    <li>227-299	Unassigned</li>
  </ul>
</article>


<!-- 3xx. Редиректы -->
<article class="article">
  <div class="anchor" id="code-3xx"></div>
  <h2>3xx. Редиректы</h2>

  <ul>
    <li>300	Multiple Choices (Несколько вариантов). По указанному URI существует несколько вариантов предоставления ресурса по типу MIME, по языку или по другим характеристикам. Сервер передаёт с сообщением список альтернатив, давая возможность сделать выбор клиенту автоматически или пользователю.</li>
    <li>301 Moved Permanently (Перемещён на постоянной основе). Запрашиваемый ресурс на постоянной основе переехал на новый адрес. Тогда новый путь к ресурсу указывается сервером в заголовке Location ответа.</li>
    <li>302 Found (Найдено). Указывает, что запрошенный ресурс временно изменён. Например, после успешной авторизации клиент может быть перенаправлен на страницу своего профиля. Тогда временный путь к ресурсу указывается сервером в заголовке Location ответа.</li>
    <li>303	See Other (Смотрите другое). Позволяет указать ссылку на ресурс, не заставляя клиента загружать ответ. Вместо этого клиент может отправить GET запрос на URL указанный в заголовке Location.</li>
    <li>304 Not Modified (Не изменен). Используется для кеширования. Тело ответа должно быть пустым. Если запрошенный ресурс не был изменён, клиент может продолжать использовать сохранённую версию ответа. Нет необходимости повторно передавать ресурс, так как у клиента все еще есть ранее загруженная копия.</li>
    <li>305	Use Proxy (Используйте прокси). Доступ к запрошенному ресурсу ДОЛЖЕН быть осуществлен через прокси-сервер, указанный в поле Location. Поле Location предоставляет URI прокси. Ожидается, что получатель повторит этот запрос с помощью прокси.</li>
    <li>306	(Unused)</li>
    <li>307 Temporary Redirect (Временный редирект). Не будет обрабатывать запрос клиента. Вместо этого клиент должен повторно отправить запрос на URL, указанный в заголовке Location. Однако в будущих запросах клиент по-прежнему должен использоваться исходный URL. Имеет то же значение, что и код 301, за исключением того, что клиент не может менять метод последующего запроса.</li>
    <li>308 Permanent Redirect (Постоянное перенаправление). Нужно повторить запрос на другой адрес без изменения применяемого метода. Имеет то же значение, что и код 301, за исключением того, что клиент не может менять метод последующего запроса.</li>
    <li>309-399	Unassigned</li>
  </ul>
</article>


<!-- 4xx. Ошибка в запросе клиента -->
<article class="article">
  <div class="anchor" id="code-4xx"></div>
  <h2>4xx. Ошибка в запросе клиента</h2>

  <ul>
    <li>400 Bad Request (Недействительный запрос). Означает, что сервер не может корректно обработать полученные данные. Появляется тогда, когда не соблюдается синтаксис протокола передачи.</li>
    <li>401 Unauthorized (Неавторизованно). Для получения ответа на этот запрос нужна авторизация. Появляется, если клиент использует неправильные авторизационные данные.</li>
    <li>402 Payment Required (Требуется оплата). Указывается при необходимости оплаты доступа к серверной части.</li>
    <li>403 Forbidden (Запрещено). У клиента нет прав доступа к запрашиваемой странице. В отличие от 401, дальнейшая аутентификация невозможна.</li>
    <li>404 Not Found (Не найдено). Сервер не смог найти запрашиваемую страницу. Пожалуй, это самый известный в интернете код ответа. Появляется при попытке попасть на несуществующую страничку.</li>
    <li>405 Method Not Allowed (Метод не разрешён). Вызов этого метода запрещён на стороне сервера. Обязательные методы GET и HEAD не могут быть запрещены.</li>
    <li>406 Not Acceptable. Сообщение, которое указывает на то, что веб-сайт передает контент, который не может быть распознан с клиентской стороны. Проблема заключается в методе сжатия, формате страницы и так далее. Иногда высвечивается при неправильной конфигурации кодировки. Встречается код крайне редко.</li>
    <li>407 Proxy Authentication Required. Работает почти так же, как и 401. Разница заключается в том, что логин и пароль требуются для прокси, а не для основного подключения.</li>
    <li>408 Request Timeout. Разрыв соединения с клиентской частью ввиду того, что подключение не используется. Сервер долгое время ждал ответа, но соединение не было налажено. Эта ошибка часто появляется после длительной и безуспешной попытки зайти на ту или иную веб-страничку.</li>
    <li>409 Conflict. Несоответствие запроса с клиентской стороны ожиданиям сервера.</li>
    <li>410 Gone. Аналог 404 ошибки, который указывает на перманентность отсутствия веб-страницы.</li>
    <li>411 Length Required. Сервер не хочет принимать «команды» со стороны клиента, потому что отсутствует определение заголовка Content-Length. </li>
    <li>412 Precondition Failed. Указывает на отклонение пользовательской «команды». Доступ к выбранному проекту не разрешен. В основном возникает ввиду неправильной настройки работы методов.</li>
    <li>413 Payload Too Large. Посланная «команда» с клиентской стороны слишком длинная.</li>
    <li>414 URL Too Long. Превышение лимита длины URL.</li>
    <li>415 Unsupported Media Type. Загрузка данных на сервер в неподходящем формате.</li>
    <li>416	Range Not Satisfiable</li>
    <li>417	Expectation Failed</li>
    <li>418	(Unused)</li>
    <li>419-420	Unassigned</li>
    <li>421	Misdirected Request</li>
    <li>422	Unprocessable Content</li>
    <li>423	Locked</li>
    <li>424	Failed Dependency</li>
    <li>425	Too Early</li>
    <li>426	Upgrade Required</li>
    <li>427	Unassigned</li>
    <li>428	Precondition Required</li>
    <li>429 Too Many Request. На сервер было послано слишком много запросов за небольшой промежуток времени.</li>
    <li>430	Unassigned</li>
    <li>431 Request Header Fields Too Large. В посылаемой «команде» применяются слишком длинные заголовки.</li>
    <li>432-449	Unassigned</li>
    <li>450 Blocked Windows Parental Controls. Сообщение, которое будет часто преследовать детей. Оно указывает на родительский контроль от Microsoft. Высвечивается, если пользователь пытался посетить запрещенный родителем ресурс. Изменяется ситуация при помощи корректировки параметров упомянутой ранее службы.</li>
    <li>451	Unavailable For Legal Reasons</li>
    <li>452-499	Unassigned</li>
  </ul>
</article>


<!-- 5xx. Ошибка на сервере -->
<article class="article">
  <div class="anchor" id="code-5xx"></div>
  <h2>5xx. Ошибка на сервере</h2>

  <ul>
    <li>500 Internal Server Error (Внутренняя ошибка). В процессе обработки запроса сервер столкнулся с ошибкой, которую не смог обработать.</li>
    <li>501 Not Implemented (Не реализовано). Сервер не поддерживает запрашиваемый метод. Методы GET и HEAD являются обязательными и не должны возвращать этот код.</li>
    <li>502 Bad Gateway (Плохой шлюз). Эта ошибка обычно означает, что в процессе обработки запроса сервер выполнил обращение к внутренней службе, но получил недействительный ответ.</li>
    <li>503 Service Unavailable (Сервис недоступен). Зачастую причиной этой ошибки бывает отключение или перегрузка сервера.</li>
    <li>504 Gateway Timeout (тайм-аут шлюза). Этот ответ об ошибке возвращается, когда сервер не может получить ответ от внутренней службы вовремя.</li>
    <li>505 HTTP Version Not Supported — версия HTTP, используемая в запросе, не поддерживается сервером.</li>
    <li>506 Variant Also Negotiates. Возникает при неправильной первоначальной настройке серверной стороны. Указывает на сбои базовых конфигураций.</li>
    <li>507 Insufficient Storage. Указывает на нехватку со стороны серверной части пространства в хранилище для обработки клиентской «команды».</li>
    <li>508 Loop Detected. Высвечивается при обнаружении бесконечного цикла в клиентском запросе. Может расцениваться как провал запроса и всей обрабатываемой операции.</li>
    <li>509 Bandwidth Limit Exceeded. Указывает на то, что серверная сторона потребляет трафика больше, чем позволено.</li>
    <li>510 Not Extended. Высвечивается, если клиент отправляет запрос на использование какого-либо расширения, отсутствующего на сервере. Исправляется путем избавления от декларирования неподдерживаемых расширений из конструкции. Можно добавить поддержку того или иного компонента на сервер.</li>
    <li>511 Network Authentication Required. Указывает на то, что перед выходом в сеть необходимо авторизоваться.</li>
    <li>512-599	Unassigned</li>
  </ul>
</article>




