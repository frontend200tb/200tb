<h1>Webpack</h1>
<div class="content__menu">
  <p class="content__menu-link" id="content__menu-link1">about</p>
  <p class="content__menu-link" id="content__menu-link2">links</p>
  <p class="content__menu-link" id="content__menu-link3">install</p>
  <p class="content__menu-link" id="content__menu-link4">entry</p>
  <p class="content__menu-link" id="content__menu-link5">output</p>
  <p class="content__menu-link" id="content__menu-link6">rules</p>
  <p class="content__menu-link" id="content__menu-link7">plugins</p>
  <p class="content__menu-link" id="content__menu-link8">webpack.config.js</p>
</div>
<div class="content__items">
  <div class="content__item" id="content__item1">
    <h3>About</h3>
    <ul>
      <li>Webpack — это статический сборщик модулей JavaScript в единый JS-файл (инструмент, позволяющий скомпилировать
        несколько модулей в один файл), содержащий все необходимое для запуска приложения.
        <p>Webpack применяют как при frontend, так и в backend разработке на Node.js. Он анализирует модули приложения,
          создает на основе операторов import и/или require() граф зависимостей модулей и собирает модули в правильном
          порядке в один или более бандл (bundle, узел), на который может ссылаться файл index.html.</p>
        <p>У самого WebPack есть несколько основных терминов:</p>
        <p>Конфигурационный файл (Configuration)</p>
        <p>Входная точка (Entry)</p>
        <p>Точка выхода (Output)</p>
        <p>Загрузчики (Loaders)</p>
        <p>Плагины (Plugins)</p>
        <p>Режимы (Modes)</p>
        <h4>Конфигурационный файл (Configuration)</h4>
        <p>Сам конфигурационный файл всегда один — webpack.config.js. В нем мы указываем экспортируемый объект, которй и
          является конфигурацией для Webpack:</p><code>module.exports = {};</code>
        <p>Основные свойства объекта module.exports это entry, output, module, plugins, mode, cache, watch, watchOptions
        </p>
      </li>
      <li>Webpack это упаковщик модулей (отдельных частей программы) в единую систему. Изначально применялся для сборки
        JS, но в настоящее время применяется для сборки любых ресурсов HTML, CSS, шрифтов, изображений. Loader
        (обработчик) - преобразовывает определенный тип файла в JS модуль. Loader это js function которая принимает
        исходный код и возвращает обработанный код. Plugins (плагины) позволяют делать все то, что не позволяют делать
        loaders. Compiler сборщик. Compilartion объект сборки.</li>
    </ul>
  </div>
  <div class="content__item" id="content__item2">
    <h3>Ссылки</h3>
    <ul>
      <li><a href="https://webpack.js.org/">https://webpack.js.org/</a></li>
    </ul>
    <h3>Статьи на habr</h3>
    <ul>
      <li><a href="https://habr.com/ru/post/514838/">Webpack: руководство для начинающих (2020-08-12)</a></li>
      <li><a href="https://habr.com/ru/post/519064/">Основы настройки Webpack (2020-09-15)</a></li>
      <li><a href="https://habr.com/ru/post/524260/">Настройка Webpack 5 с нуля (2020-10-20)</a></li>
      <li><a href="https://habr.com/ru/post/701724/">Настройка Webpack 5 (2022-11-25)</a></li>
      <li><a href="https://habr.com/ru/company/piter/blog/710844/">Полный обзор webpack (2023-01-16)</a></li>
    </ul>
    <h3>Статьи</h3>
    <ul>
      <li><a href="https://www.internet-technologies.ru/articles/rukovodstvo-po-webpack-dlya-novichkov.html">Webpack -
          что это? Руководство по для новичков (2019-08-19)</a></li>
      <li><a href="https://www.cat-in-web.ru/webpack-from-zero/">Webpack с нуля: это совсем не страшно (2019-12-30)</a>
      </li>
      <li><a href="https://daruse.ru/webpack-5-sozdanie-bazovoj-konfiguraczii">Webpack 5: создание базовой конфигурации
          (2021-04-21)</a></li>
      <li><a href="https://vc.ru/dev/418917-krupnyy-gayd-po-webpack">Крупный гайд по Webpack (2022-05-10)</a></li>
    </ul>
  </div>
  <div class="content__item" id="content__item3">
    <h3>Установка webpack</h3>
    <ol>
      <li>Проверим версии установленных node.js и npm
        <code>
          node -v
          <br>v18.18.2
          <br>npm -v
          <br>9.8.1
        </code>
        (сокращенно от node --version и npm --version)
        если их нет, то поставить с оффициального сайта <a href="https://nodejs.org/en/">nodejs</a>
      </li>
      <li>Установим webpack и webpack-cli глобально
        <code>
          npm i -g webpack webpack-cli
        </code>
        в папке
        <code>c:\Users\11001000\AppData\Roaming\npm\node_modules\</code>
        появятся две папки с файлами
        <code>webpack и webpack-cli</code>
      </li>
      <li>Создадим папку для нашего проекта и перейдем в нее
        <code>
          mkdir project-webpack
          <br>cd project-webpack
          <br>d://project-Webpack/
        </code>
      </li>
      <li>Инициализируем проект<code>npm init -y</code>(то же что и npm init , не отвечая на вопросы)</li>
      <li>В итоге в папке с проектом появится файл package.json. После этого можно устанавливать пакеты, которые будут
        являться зависимостями для нашего приложения.<code>d://project-webpack/package.json</code></li>
      <li>Установим webpack и webpack-cli в качестве зависимостей для разработки (dev dependencies).
        <p>webpack - сборщик модулей и ресурсов</p>
        <p>webpack-cli - интерфейс командной строки для вебпака</p><code>npm i -D webpack webpack-cli</code>(сокращенно
        от npm install --save-dev webpack webpack-cli)
      </li>
      <li>Чтобы понять что они установились, проверим версии пакетов
        <code>
          npm run webpack -v
          <br>9.8.1
          <br>npm run webpack-cli -v
          <br>9.8.1
        </code>
      </li>
      <li>В итоге в папке с проектом появится папка node_modules и файл package-lock.json,. В node_modules установлены
        webpack, webpack-cli и все необходимые зависимости для того чтобы они работали. Эту папку трогать не нужно
        <code>
          d://project-webpack/node_modules
          <br>d://project-webpack/package-lock.json
        </code>
      </li>
      <li>Для проверки работы webpack создадим файл src/index.js и dist/index.html, внутри которого подключим скрипт
        <code>&lt;script src="main.js"&gt;&lt;/script&gt;</code>
      </li>
      <li>В файл package.json напишем
        <code>
          "scripts": { 
          <br>&nbsp;&nbsp;"build": "webpack" 
          <br>} 
        </code>
        <p>Теперь можно запустить webpack командной</p>
        <pre>npm run build</pre>
        <p>В папку dist (если ее не было то она создастся) запишется файл main.js в который соберется весь javascript из
          файла src/index.js со всеми импортами которые включены в него из других файлов js. По умолчанию этот файл
          минифицируется и такая сборка готова в продакшн</p>
      </li>
      <li>Для того чтобы разделить сборку для продакшн и для разработки надо в package.json прописать две разные команды
        <code>
          "scripts": { 
          <br>&nbsp;&nbsp;"build": "webpack --mode production",
          <br>&nbsp;&nbsp;"dev": "webpack --mode development"
          <br>} 
        </code>
        <p>Теперь можно запустить webpack в режиме разработки командной</p>
        <code>npm run dev</code>
      </li>
      <li>Webpack установлен с настройками по умолчанию! Для того чтобы настроить webpack под задачи проекта создадим
        конфигурационный файл webpack.config.js
        <code>
          touch webpack.config.js
          <br>d://project-webpack/webpack.config.js
        </code>
      </li>
    </ol>
  </div>
  <div class="content__item" id="content__item4">
    <h3>Entry point (входная точка)</h3>
    <ul>
      <li>Входная точка это файл, который нужно включить первым и от которого будут идти все импорты. По умолчанию это
        файл src/index.js. Есть несколько способов определить входную точку. Запишем в файл конфигурации
        webpack.config.js экспортируемый объект, содержащий</li>
    </ul>
    <ol>
      <li>Один файл в формате String
        <code>
          module.exports = {
          <br>&nbsp;&nbsp;entry: './src/index.js',
          <br>};
        </code>
      </li>
      <li>Один файл в формате Array
        <code>
          module.exports = {
          <br>&nbsp;&nbsp;entry: ['./src/index.js'],
          <br>};
          </code>
      </li>
      <li>Несколько файлов в формате Array
        <code>
          module.exports = {
          <br>&nbsp;&nbsp;entry: ['./src/index.js', './src/app.js'],
          <br>};
        </code>
      </li>
      <li>Один файл в формате Object
        <code>
          module.exports = {
          <br>&nbsp;&nbsp;entry: {app: './src/index.js',},
          <br>};
        </code>
      </li>
      <li>Несколько файлов в формате Object
        <code>
          module.exports = {
          <br>&nbsp;&nbsp;entry: {
          <br>&nbsp;&nbsp;&nbsp;&nbsp;index: './src/index.js',
          <br>&nbsp;&nbsp;&nbsp;&nbsp;app: './src/app.js',
          <br>&nbsp;&nbsp;},
          <br>};
        </code>
      </li>
    </ol>
  </div>
  <div class="content__item" id="content__item5">
    <h3>Output (Точка выхода)</h3>
    <ul>
      <li>Свойство output говорит куда выкладывать собранные файлы и как их называть. По умолчанию Webpack собирает весь
        javascript в один файл ./dist/main.js и остальные файлы в папку ./dist. </li>
      <li>Чтобы указать другое имя нужно использовать свойство filename
        <code>
          module.exports = {
          <br>&nbsp;&nbsp;output: {
          <br>&nbsp;&nbsp;&nbsp;&nbsp;filename: 'bundle.js',
          <br>&nbsp;&nbsp;},
          <br>};
        </code>
      </li>
      <li>Используем модуль path чтобы в различных операционных системах был правильный путь к выходному файлу
        <code>
          const path = require('path');
          <br>module.exports = {
          <br>&nbsp;&nbsp;output: {
          <br>&nbsp;&nbsp;&nbsp;&nbsp;path: path.resolve(__dirname, 'dist'),
          <br>&nbsp;&nbsp;&nbsp;&nbsp;filename: 'bundle.js',
          <br>&nbsp;&nbsp;},
          <br>};
        </code>
      </li>
      <li>Можно очистить папку dist перед сборкой
        <code>
          const path = require('path');
          <br>module.exports = {
          <br>&nbsp;&nbsp;output: {
          <br>&nbsp;&nbsp;&nbsp;&nbsp;clean: true, 
          <br>&nbsp;&nbsp;},
          <br>};
        </code>
      </li>
      <li>Webpack работает не только с javascript который собирается в одном файле, но и с html, css, картинками для
        которых и указывается выходная директория, чтобы правильно перенести их
        <code>
          module.exports = {
          <br>&nbsp;&nbsp;output: {
          <br>&nbsp;&nbsp;&nbsp;&nbsp;assetModuleFilename: '[name][ext]',
          <br>&nbsp;&nbsp;},
          <br>};
        </code>
      </li>
    </ul>
  </div>
  <div class="content__item" id="content__item6">
    <h3>Loaders (загрузчики)</h3>
    <ol>
      <li>По умолчанию webpack понимает только файлы JavaScript и JSON. Загрузчики (loaders) позволяют webpack
        обрабатывать другие типы файлов и преобразовывать их. Чтобы webpack понимал файлы других типов, которые мы
        импортируем в файл index.js, то нужны загрузчики. Например, для css файлов - css-loader, для pug файлов -
        pug-loader, для typescript файлов - ts-loader. Лоадеры – это скрипты, которые принимают на вход содержимое
        файла, обрабатывают его и возвращают красивый и удобный результат. Для лоадеров придумали правила (rules).
        Правила (rules) это объекты в конфигурации, которые указывают на файлы, которые нужно обработать и указывают
        лоадер. Перед тем как использовать лоадеры их надо скачать с помощью NPM</li>
      <li>html-loader нужен чтобы собирать html файлы через js
        <code>
          module: {
          <br>&nbsp;&nbsp;rules:[
          <br>&nbsp;&nbsp;&nbsp;&nbsp;{
          <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test: /\.html$/,
          <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loader: "html-loader",
          <br>&nbsp;&nbsp;&nbsp;&nbsp;}
          <br>&nbsp;&nbsp;]
          <br>}
        </code>
      </li>
      <li>Babel. Чтобы писать код на современном языке, а выкладывать код на ES5, который понятен всем браузерам, надо
        использовать babel. Установим необходимые пакеты
        <code>npm i -D @babel/core @babel/preset-env babel-loader</code>
        <p>babel core — содержит всю логику транспиляции;</p>
        <p>babel preset env — основной набор плагинов с реализацией возможностей javascript, учитывающих поддержку
          нужных браузеров;</p>
        <p>babel loader — собственно лоадер, обеспечивающий взаимодействие с webpack.</p>
        <pre>module: {
  rules:[
    {
      test: /\.js$/,
      exclude: /node_modules/,
      use: {loader: 'babel-loader'}
    }
  ]
}</pre>
        <p>Создадим файл настроек .babelrc и запишем в него</p>
        <pre>{
  "presets": ["@babel/preset-env"],
  "browserslist": [
    "last 2 versions",
    "not dead"
  ]
}        
</pre>
      </li>
      <li>Scss. Вариант 1 В сборке стили будут встроены в файл index.js. При загрузке в браузере стили будут
        встраиваться в тег style файла index.html
        <pre>npm i -D sass-loader sass css-loader style-loader</pre>
        <p>sass-loader загружает файлы SCSS и передает компилятору sass</p>
        <p>sass компилирует код в CSS.</p>
        <p>css-loader позволяет импортировать css файл в js</p>
        <p>style-loader внедряет CSS в DOM. Он разместит результат в index.js, который при запуске подключит стили через
          тег style в файле index.html</p>
        <p>Напишем rules (правила) для scss</p>
        <pre>module: {
  rules:[
    {
      test: /\.(scss|sass|css)$/,
      use: ['style-loader', 'css-loader', 'sass-loader'],
    }
  ]
}
</pre>
      </li>
      <li>Scss. Вариант 2 В сборке стили будут вынесены в отдельный файл style.css, который будет подключен в теге link
        файла index.html. Плагин postcss-loader добавит autoprefix для создания кроссбраузерного css
        <pre>npm i -D sass-loader sass css-loader mini-css-extract-plugin
npm i -D postcss-loader postcss postcss-preset-env</pre>
        <p>postcss-loader - загрузчик CSS файлов для пост-обработки. Должен работать с каким нибудь плагином.</p>
        <p>postcss-preset-env это плагин для PostCSS, который конвертирует современный CSS в код, понятный большинству
          браузеров, включением необходимых полифилов.</p>
        <p>Напишем rules (правила) для scss</p>
        <pre>const MiniCssExtractPlugin = require("mini-css-extract-plugin");
module.exports = {
  module: {
    rules:[
      {
        test: /\.scss$/,
        use: [MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader', 'sass-loader'],
      }
    ]
  }
  plugins: [
    new MiniCssExtractPlugin(),
  ],
}</pre>
        <p>Создадим файл настроек postcss.config.js и запишем в него</p>
        <pre>module.exports = {
  plugins: {
    'postcss-preset-env': {
      browsers: 'last 2 versions',
    },
  },
}
</pre>
      </li>
      <li>Напишем rules (правила) для шрифтов
        <pre>module: {
  rules: [
    {
      test: /\.(otf|ttf|eot|woff|woff2)$/,
      type: 'asset/resource',
    },
  ]
}
</pre>
      </li>
      <li>Напишем rules (правила) для картинок
        <pre>output: {
  //Название выходного файла будет соответствовать исходному
  assetModuleFilename: '[name][ext]'
},
module: {
  rules: [        
    {
      test: /\.(png|jpg|jpeg|gif)$/i,
      type: 'asset/resource'
    }
  ]
}</pre>
        <p>Дальше</p>
        <pre>{
  test: /\.(png|jpg|jpeg|gif)$/i,
  use: [
    {
      loader: 'file-loader',
      options: {
        name: '[name]-[hash].[ext]',
        outputPath: 'img',
      },
    },
  ],
},
</pre>
      </li>
    </ol>
  </div>
  <div class="content__item" id="content__item7">
    <h3>Plugins (Плагины)</h3>
    <ol>
      <li>Плагины — внешние модули для Webpack, которые позволяют управлять и обрабатывать файлы, которые не
        импортируются в JavaScript.</li>
      <li>Плагин HTMLWebpackPlugin автоматически создает HTML-файл с уже подключенным скриптом. Установим
        html-webpack-plugin
        <pre>npm i -D html-webpack-plugin</pre>
        <p>Запишем в webpack.config.js</p>
        <pre>const HtmlWebpackPlugin = require('html-webpack-plugin');
module.exports = {
  plugins: [
    new HtmlWebpackPlugin()
  ],
};
</pre>
        <p>Научим HTMLWebpackPlugin создавать файл на основе шаблона, задавать имя выходного файла, копировать файл
          favicon.svg в выходную директорию и автоматически подключать его в index.html</p>
        <pre>const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
module.exports = {
  plugins: [
    new HtmlWebpackPlugin({
      template: path.resolve(__dirname, './src/index.html'),
      filename: 'index.html', 
      favicon: "./src/favicon.svg",
    })
  ],
};
</pre>
      </li>
      <li>Используем filemanager-webpack-plugin для копирования файлов из папки src/assets в папку dist. Установим
        filemanager-webpack-plugin
        <pre>npm i -D filemanager-webpack-plugin</pre>
        <p>Чтобы скопировать файл src/favicon.svg в ./dist и файлы из src/assets в ./dist/assets запишем в
          webpack.config.js</p>
        <pre>const path = require('path');
const FileManagerPlugin = require('filemanager-webpack-plugin');
module.exports = {
  plugins: [
    new FileManagerPlugin({
      events: {
        onEnd: {
          copy: [
            {
              source: path.resolve(__dirname, './src/favicon.svg'),
              destination: path.resolve(__dirname, './dist/favicon.svg'),
            },
            {
              source: path.resolve(__dirname, './src/assets'),
              destination: path.resolve(__dirname, './dist/assets'),
            },
          ],
        },
      },
    }),
  ],
};</pre>
        <p>Свойство onEnd указывает что копирование будет после сборки</p>
        <p>Свойство onStart указывает что копирование будет перед сборкой, но тогда если во время сборки делать очистку
          папки dist командой clean: true то скопированные файлы удалятся</p>
      </li>
    </ol>
  </div>
  <div class="content__item" id="content__item8">
    <h3>webpack.config.js</h3>
    <ol>
      <li>Webpack по умолчанию не требует конфигурационного файла. Исходным файлом (entry) является src/index.js,
        выходным файлом (output) является dist/main.js и собирается он в режиме (mode) production mode. Настроить
        webpack можно используя файл конфигурации webpack.config.js</li>
      <li>Javascript файлы. Простая конфигурация собирает js файлы в один файл и можно задать имя входному и выходному
        файлам. Запишем в файл webpack.config.js
        <pre>module.exports = {
  entry: './src/index.js',
  output: './dist/index.js'
}
</pre>
      </li>
      <li>Настроим свою конфигурацию. Сначала установим необходимые пакеты
        <pre>npm i -D webpack-dev-server html-webpack-plugin 
npm i -D css-loader sass-loader sass
npm i -D mini-css-extract-plugin
npm i -D postcss-loader postcss postcss-preset-env
npm i -D html-loader
npm i -D pug-loader pug
npm i -D filemanager-webpack-plugin
npm i -D babel-loader @babel/core @babel/preset-env
npm i -D ts-loader typescript
</pre>
        <p>Запишем в package.json </p>
        <pre>"scripts": {
  "serve": "webpack serve --open --mode development",
  "dev": "webpack --mode development",
  "build": "webpack --mode production",
},</pre>
        <p>Запишем в webpack.config.js </p>
        <pre>const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
const FileManagerPlugin = require('filemanager-webpack-plugin');

module.exports = {
  entry: './src/index.js',
  output: {
    clean: true, 
    path: path.resolve(__dirname, './dist'),
    filename: 'index.js',
  },
  module: {
    rules: [
      {
        test: /\.(scss|sass|css)$/,
        use: [ MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader', 'sass-loader' ],
      },
      {
        test: /\.html$/i,
        loader: "html-loader",
      },
      {
        test: /\.pug$/,
        loader: 'pug-loader',
      },
      {
        test: /\.js$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: ['@babel/preset-env']
          }
        }
      },
      {
        test: /\.ts$/,
        exclude: /node_modules/,
        use: {
          loader: 'ts-loader',
          options: {
            presets: ['@babel/preset-env']
          }
        }
      },
    ],
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: path.resolve(__dirname, './src/index.pug'),
      filename: 'index.html', 
      favicon: "./src/favicon.svg",
    })
    new MiniCssExtractPlugin(),
    new FileManagerPlugin({
      events: {
        onEnd: {
          copy: [
            {
              source: path.join('src', 'assets'),
              destination: 'dist',
            },
          ],
        },
      },
    }),
  ],
  devServer: {
    static: {
      directory: path.resolve(__dirname, 'src'),
    },
    watchFiles: path.join(__dirname, 'src'),
    port: 9000,
  },
};
</pre>
      </li>
      <li>Разница между path.join и path.resolve
        <p>path.join соединяет в одну строку переданные ей аргументы используя специфичный для операционной системы
          разделитель (/ или \) и нормализирует ее.</p>
        <pre>path.join('path', 'to', 'another', '..', 'another', 'file')</pre>
        <p>Вернет для Linux </p>
        <pre>'path/to/another/file'</pre>
        <p>Вернет для Windows </p>
        <pre>'path\to\another\file'</pre>
        <p>Нормализация заключается в том что не возвращается</p>
        <pre>'path/to/another/../another/file'</pre>
        <p>path.resolve возвращает абсолютный путь по тем сегментам которые переданны в аргументы</p>
        <pre>path.resolve('/how', 'to', 'code')</pre>
        <p>Вернет</p>
        <pre>'/how/to/code'</pre>
      </li>
      <li>Сервер. Есть несколько способов, которые позволяют при сохранении кода автоматически его собирать и обновлять
        в браузере. Рассмотрим вариант webpack-dev-server. Установим webpack-dev-server
        <pre>npm i -D webpack-dev-server</pre>
        <p>Пропишем в файле webpack.config.js</p>
        <pre>const path = require('path');
module.exports = {
  devServer: {
    static: {
      directory: path.resolve(__dirname, 'src'),
    },              
    watchFiles: path.join(__dirname, 'src'),
    port: 9000, 
  }
}</pre>
        <p>Пропишем в package.json</p>
        <pre>"scripts": {
  "serve": "webpack serve --open --mode development",
}</pre>
        <p>serve означает запустить веб сервер.</p>
        <p>--open автоматически запускает браузер, который в системе установлен по умолчанию.</p>
        <p>--mode development включает режим разработки.</p>
        <p>Теперь сервер можно запустить командной</p>
        <pre>npm run serve </pre>
        <p>Для остановки сервера надо нажать</p>
        <pre>CTRL + c</pre>
      </li>
      <li>Очистка выходной папки. Я знаю три способа. Будем пользоваться первым
        <P>Первый способ. Очистка выходной папки средствами webpack</P>
        <pre>module.exports = {
  output: {
    clean: true, 
  },
};</pre>
        <p>Второй способ. Установим clean-webpack-plugin, очищающий директорию «dist» при каждой сборке проекта</p>
        <pre>npm i -D clean-webpack-plugin</pre>
        <p>Запишем в файл webpack.config.js</p>
        <pre>const { CleanWebpackPlugin } = require('clean-webpack-plugin')
module.exports = {
    plugins: [
      new CleanWebpackPlugin(),
    ],
}</pre>
        <p>Третий способ. Каталог dist не очищается, а удаляется. Установим filemanager-webpack-plugin</p>
        <pre>npm i -D filemanager-webpack-plugin</pre>
        <p>Запишем в файл webpack.config.js</p>
        <pre>const { FileManagerPlugin } = require('filemanager-webpack-plugin')
module.exports = {
    plugins: [
      new FileManagerPlugin(
        events: {
          onStart: {
            delete: ['dist'],
          },
        },                  
      ),
    ],
}</pre>
      </li>
    </ol>
  </div>
</div>