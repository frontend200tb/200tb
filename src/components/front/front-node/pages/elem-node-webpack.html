<h1>Webpack</h1>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p><a href="#about">about</a></p>
  <p><a href="#links">links</a></p>
  <p><a href="#install">install</a></p>
  <p><a href="#config">webpack.config.js</a></p>
  <ol>
    <li><a href="#entry">entry</a></li>
    <li><a href="#output">output</a></li>
    <li><a href="#clean">clean</a></li>
    <li><a href="#loaders">loaders</a></li>
    <li><a href="#rules">module - rules</a></li>
    <li><a href="#plugins">plugins</a></li>
    <li><a href="#devserver">devServer</a></li>
    <li><a href="#devtool">devtool</a></li>
  </ol>
  <p><a href="#uconfig">Настроим свой webpack.config.js</a></p>
</article>


<!-- about -->
<article class="article">
  <div class="anchor" id="about"></div>
  <h2>about</h2>

  <p>Webpack — это статический сборщик модулей JavaScript в единый JS-файл (инструмент, позволяющий скомпилировать несколько модулей в один файл), содержащий все необходимое для запуска приложения.</p>
  <p>Webpack применяют как при frontend, так и в backend разработке на Node.js. Он анализирует модули приложения, создает на основе операторов import и/или require() граф зависимостей модулей и собирает модули в правильном порядке в один или более бандл (bundle, узел), на который может ссылаться файл index.html.</p>
  <p>У самого WebPack есть несколько основных терминов:</p>
  <p>Конфигурационный файл (Configuration)</p>
  <p>Входная точка (Entry)</p>
  <p>Точка выхода (Output)</p>
  <p>Загрузчики (Loaders)</p>
  <p>Плагины (Plugins)</p>
  <p>Режимы (Modes)</p>

  <h3>Конфигурационный файл (Configuration)</h3>
  <p>Сам конфигурационный файл всегда один — webpack.config.js. В нем мы указываем экспортируемый объект, которй и является конфигурацией для Webpack:</p>
  <code>module.exports = {};</code>
  <p>Основные свойства объекта module.exports это entry, output, module, plugins, mode, cache, watch, watchOptions</p>
  <p>Webpack это упаковщик модулей (отдельных частей программы) в единую систему. Изначально применялся для сборки JS, но в настоящее время применяется для сборки любых ресурсов HTML, CSS, шрифтов, изображений. Loader(обработчик) - преобразовывает определенный тип файла в JS модуль. Loader это js function которая принимает исходный код и возвращает обработанный код. Plugins (плагины) позволяют делать все то, что не позволяют делать loaders. Compiler сборщик. Compilartion объект сборки.</p>
</article>


<!-- links -->
<article class="article">
  <div class="anchor" id="links"></div>
  <h2>links</h2>

  <p><a href="https://webpack.js.org/">https://webpack.js.org/</a></p>
  
  <h3>Статьи на habr</h3>
  <p><a href="https://habr.com/ru/post/514838/">Webpack: руководство для начинающих (2020-08-12)</a></p>
  <p><a href="https://habr.com/ru/post/519064/">Основы настройки Webpack (2020-09-15)</a></p>
  <p><a href="https://habr.com/ru/post/524260/">Настройка Webpack 5 с нуля (2020-10-20)</a></p>
  <p><a href="https://habr.com/ru/post/701724/">Настройка Webpack 5 (2022-11-25)</a></p>
  <p><a href="https://habr.com/ru/company/piter/blog/710844/">Полный обзор webpack (2023-01-16)</a></p>

  <h3>Статьи</h3>
  <p><a href="https://www.internet-technologies.ru/articles/rukovodstvo-po-webpack-dlya-novichkov.html">Webpack - что это? Руководство по для новичков (2019-08-19)</a></p>
  <p><a href="https://www.cat-in-web.ru/webpack-from-zero/">Webpack с нуля: это совсем не страшно (2019-12-30)</a></p> 
  <p><a href="https://daruse.ru/webpack-5-sozdanie-bazovoj-konfiguraczii">Webpack 5: создание базовой конфигурации
          (2021-04-21)</a></p>
  <p><a href="https://vc.ru/dev/418917-krupnyy-gayd-po-webpack">Крупный гайд по Webpack (2022-05-10)</a></p> 
</article>


<!-- install -->
<article class="article">
  <div class="anchor" id="install"></div>
  <h2>install</h2>

  <ol>
    <li>Проверим версии установленных node.js и npm
      <code>
        node -v
        <br>v20.12.0
        <br>npm -v
        <br>10.5.0
      </code>
      (сокращенно от node --version и npm --version)
      если их нет, то поставить с оффициального сайта <a href="https://nodejs.org/en/">nodejs</a>
    </li>
    <li>Установим webpack, webpack-cli и webpack-dev-server глобально
      <code>
        npm i -g webpack webpack-cli webpack-dev-server
      </code>
      в папке
      <code>c:\Users\11001000\AppData\Roaming\npm\node_modules\</code>
      появятся три папки
      <code>webpack, webpack-cli и webpack-dev-server</code>
    </li>
    <li>Создадим папку для нашего проекта и перейдем в нее
      <code>
        mkdir project-webpack
        <br>cd project-webpack
        <br>d://project-Webpack/
      </code>
    </li>
    <li>Инициализируем проект
      <code>npm init -y</code>
      (то же что и npm init , не отвечая на вопросы)
    </li>
    <li>В итоге в папке с проектом появится файл package.json. После этого можно устанавливать пакеты, которые будут являться зависимостями для нашего приложения.
      <code>d://project-webpack/package.json</code>
    </li>
    <li>Установим webpack, webpack-cli и webpack-dev-server в качестве зависимостей для разработки (dev dependencies).
      <p>webpack - сборщик модулей и ресурсов</p>
      <p>webpack-cli - интерфейс командной строки для вебпака</p>
      <p>webpack-dev-server - сервер для разработки</p>
      <code>npm i -D webpack webpack-cli webpack-dev-server</code>(сокращенно
      от npm install --save-dev webpack webpack-cli webpack-dev-server)
    </li>
    <li>Чтобы понять что они установились, проверим версии пакетов
      <code>
        npm run webpack -v
        <br>10.5.0
        <br>npm run webpack-cli -v
        <br>10.5.0
        <br>npm run webpack-dev-server -v
        <br>10.5.0
      </code>
    </li>
    <li>В итоге в папке с проектом появится папка node_modules и файл package-lock.json,. В node_modules установлены webpack, webpack-cli, webpack-dev-server и все необходимые зависимости для того чтобы они работали. Эту папку трогать не нужно
      <code>
        d://project-webpack/node_modules
        <br>d://project-webpack/package-lock.json
      </code>
    </li>
    <li>В файле package.json появятся записи:</li>
<pre>"devDependencies": {
  "webpack": "^5.87.0",
  "webpack-cli": "^5.1.4",
  "webpack-dec-server":"4^11.1"
}</pre>
    <li>Для проверки работы webpack создадим файл src/index.js и dist/index.html, внутри которого подключим скрипт
      <code>&lt;script src="main.js"&gt;&lt;/script&gt;</code>
    </li>
    <li>В файл package.json напишем
      <code>
        "scripts": { 
        <br>&nbsp;&nbsp;"build": "webpack" 
        <br>} 
      </code>
      <p>Теперь можно запустить webpack в режиме разработки командной</p>
      <pre>npm run build</pre>
      <p>В папку dist (если ее не было то она создастся) запишется файл main.js в который соберется весь javascript из
        файла src/index.js со всеми импортами которые включены в него из других файлов js. По умолчанию этот файл
        минифицируется и такая сборка готова в продакшн</p>
    </li>
    <li>В файле package.json пропишем три команды
<pre>"scripts": {
  "serve": "webpack server --mode development --open"
  "build": "webpack --mode production",
  "dev": "webpack --mode development"
}</pre>
      <p>Для запуска сервера для разработки нужно выполнить команду</p>
      <code>npm run serve</code>
       <p>Для запуска сборки в режиме разработки нужно выполнить команду</p>
      <code>npm run dev</code>
      <p>Для запуска сборки в режиме продакшн нужно выполнить команду</p>
      <code>npm run build</code>
   </li>
    <li>Webpack установлен с настройками по умолчанию</li>
  </ol>
</article>


<!-- config -->
<article class="article">
  <div class="anchor" id="config"></div>
  <h2>webpack.config.js</h2>


  <p>Webpack по умолчанию:</p>
  <ol>
    <li>собирает js файлы в один файл</li>
    <li>не требует конфигурационного файла</li>
    <li>исходным файлом (entry) является src/index.js</li>
    <li>выходным файлом (output) является dist/main.js</li>
    <li>собирается в режиме (mode) production mode</li>
  </ol>

  <p>Webpack по умолчанию не требует конфигурационного файла. Исходным файлом (entry) является src/index.js, выходным файлом (output) является dist/main.js и собирается он в режиме (mode) production mode. Настроить webpack можно используя файл конфигурации webpack.config.js</p>
  <p>Для того чтобы настроить webpack под задачи проекта создадим конфигурационный файл webpack.config.js</p>
  <code>
    touch webpack.config.js
    <br>d://project-webpack/webpack.config.js
  </code>
  <p>Внутри этого файла экспортируем объект с настройками в виде commonJS модуля</p>
  <code>module.exports = {}</code>

  <p>Простая конфигурация собирает js файлы в один файл и можно задать имя входному и выходному файлам. Запишем в файл webpack.config.js</p>
<pre>module.exports = {
  entry: './src/index.js',
  output: './dist/index.js'
}</pre>
</article>


<!-- entry -->
<article class="article">
  <div class="anchor" id="entry"></div>
  <h2>Entry point (входная точка)</h2>

  <p>Входная точка это файл, который нужно включить первым и от которого будут идти все импорты. По умолчанию это файл src/index.js. Есть несколько способов определить входную точку. Запишем в файл конфигурации webpack.config.js экспортируемый объект, содержащий</p>
  <ol>
    <li>Один файл в формате String
      <code>
        module.exports = {
        <br>&nbsp;&nbsp;entry: './src/index.js',
        <br>};
      </code>
    </li>
    <li>Один файл в формате Array
      <code>
        module.exports = {
        <br>&nbsp;&nbsp;entry: ['./src/index.js'],
        <br>};
        </code>
    </li>
    <li>Несколько файлов в формате Array
      <code>
        module.exports = {
        <br>&nbsp;&nbsp;entry: ['./src/index.js', './src/app.js'],
        <br>};
      </code>
    </li>
    <li>Один файл в формате Object
      <code>
        module.exports = {
        <br>&nbsp;&nbsp;entry: {app: './src/index.js',},
        <br>};
      </code>
    </li>
    <li>Несколько файлов в формате Object
      <code>
        module.exports = {
        <br>&nbsp;&nbsp;entry: {
        <br>&nbsp;&nbsp;&nbsp;&nbsp;index: './src/index.js',
        <br>&nbsp;&nbsp;&nbsp;&nbsp;app: './src/app.js',
        <br>&nbsp;&nbsp;},
        <br>};
      </code>
    </li>
  </ol>
</article>


<!-- output -->
<article class="article">
  <div class="anchor" id="output"></div>
  <h2>Output (Точка выхода)</h2>

  <p>Свойство output говорит куда выкладывать собранные файлы и как их называть. По умолчанию Webpack собирает весь javascript в один файл ./dist/main.js и остальные файлы в папку ./dist.</p>
  <p>Чтобы указать другое имя нужно использовать свойство filename</p>
  <code>
    module.exports = {
    <br>&nbsp;&nbsp;output: {
    <br>&nbsp;&nbsp;&nbsp;&nbsp;filename: 'bundle.js',
    <br>&nbsp;&nbsp;},
    <br>};
  </code>
  <p>Используем модуль path чтобы в различных операционных системах был правильный путь к выходному файлу</p>
  <code>
    const path = require('path');
    <br>module.exports = {
    <br>&nbsp;&nbsp;output: {
    <br>&nbsp;&nbsp;&nbsp;&nbsp;path: path.resolve(__dirname, 'dist'),
    <br>&nbsp;&nbsp;&nbsp;&nbsp;filename: 'bundle.js',
    <br>&nbsp;&nbsp;},
    <br>};
  </code>
  <p>Можно очистить папку dist перед сборкой</p>
  <code>
    const path = require('path');
    <br>module.exports = {
    <br>&nbsp;&nbsp;output: {
    <br>&nbsp;&nbsp;&nbsp;&nbsp;clean: true, 
    <br>&nbsp;&nbsp;},
    <br>};
  </code>
  <p>Webpack работает не только с javascript который собирается в одном файле, но и с html, css, картинками для которых и указывается выходная директория, чтобы правильно перенести их</p>
  <code>
    module.exports = {
    <br>&nbsp;&nbsp;output: {
    <br>&nbsp;&nbsp;&nbsp;&nbsp;assetModuleFilename: '[name][ext]',
    <br>&nbsp;&nbsp;},
    <br>};
  </code>
</article>


<!-- clean -->
<article class="article">
  <div class="anchor" id="clean"></div>
  <h2>clean (Очистка выходной папки)</h2>

  <p>Очистка выходной папки. Я знаю три способа. Будем пользоваться первым</p>
  
  <ol>
    <li>
      <P>Первый способ. Очистка выходной папки средствами webpack</P>
<pre>module.exports = {
  output: {
    clean: true, 
  },
};</pre>
    </li>
    <li>
      <p>Второй способ. Установим clean-webpack-plugin, очищающий директорию «dist» при каждой сборке проекта</p>
      <code>npm i -D clean-webpack-plugin</code>
      <p>Запишем в файл webpack.config.js</p>
<pre>const { CleanWebpackPlugin } = require('clean-webpack-plugin')
module.exports = {
  plugins: [
    new CleanWebpackPlugin(),
  ],
}</pre>
    </li>
    <li>
      <p>Третий способ. Каталог dist не очищается, а удаляется. Установим filemanager-webpack-plugin</p>
      <code>npm i -D filemanager-webpack-plugin</code>
      <p>Запишем в файл webpack.config.js</p>
<pre>const { FileManagerPlugin } = require('filemanager-webpack-plugin')
module.exports = {
  plugins: [
    new FileManagerPlugin(
      events: {
        onStart: {
          delete: ['dist'],
        },
      },                  
    ),
  ],
}</pre>
    </li>
  </ol>
</article>


<!-- loaders -->
<article class="article">
  <div class="anchor" id="loaders"></div>
  <h2>Loaders (загрузчики)</h2>

  <p>По умолчанию webpack понимает только файлы JavaScript и JSON. Загрузчики (loaders) позволяют webpack обрабатывать другие типы файлов и преобразовывать их. Чтобы webpack понимал файлы других типов, которые мы импортируем в файл index.js, то нужны загрузчики. Например, для css файлов - css-loader, для pug файлов - pug-loader, для typescript файлов - ts-loader. Лоадеры – это скрипты, которые принимают на вход содержимое файла, обрабатывают его и возвращают красивый и удобный результат. Для лоадеров придумали правила (rules). Правила (rules) это объекты в конфигурации, которые указывают на файлы, которые нужно обработать и указывают лоадер. Перед тем как использовать лоадеры их надо скачать с помощью NPM</p>

  <ol>
    <li>
      <h4>html-loader</h4>
      <p>html-loader нужен чтобы собирать html файлы через js</p>
<pre>module: {
  rules:[
    {
      test: /\.html$/,
      loader: "html-loader",
    }
  ]
}</pre>
    </li>
    <li>
      <h4>babel-loader</h4>
      Чтобы писать код на современном языке, а выкладывать код на ES5, который понятен всем браузерам, надо использовать babel. Установим необходимые пакеты
      <code>npm i -D @babel/core @babel/preset-env babel-loader</code>
      <p>babel core — содержит всю логику транспиляции;</p>
      <p>babel preset env — основной набор плагинов с реализацией возможностей javascript, учитывающих поддержку нужных браузеров;</p>
      <p>babel loader — собственно лоадер, обеспечивающий взаимодействие с webpack.</p>
<pre>module: {
  rules:[
    {
      test: /\.js$/,
      exclude: /node_modules/,
      use: {loader: 'babel-loader'}
    }
  ]
}</pre>
    <p>Создадим файл настроек .babelrc и запишем в него объект с настройками для babel.</p>
    <p>presets - правила преобразования</p>
    <p>browserslist - список браузеров в которых будет работать преобразованный код</p>
<pre>{
  "presets": ["@babel/preset-env"],
  "browserslist": [
    "last 2 versions",
    "not dead"
  ]
}</pre>
    </li>
    <li>
      <h4>css-loader style-loader</h4>
      Вариант 1 В сборке стили будут встроены в файл index.js. При загрузке в браузере стили будут встраиваться в тег style файла index.html
      <code>npm i -D css-loader style-loader</code>
      <p>css-loader позволяет импортировать css файл в js</p>
      <p>style-loader внедряет CSS в DOM. Он разместит результат в index.js, который при запуске подключит стили через тег style в файле index.html</p>
      <p>Напишем rules (правила) для scss</p>
      <pre>module: {
  rules:[
    {
      test: /\.css$/,
      use: ['style-loader', 'css-loader'],
    }
  ]
}
</pre>
      <p>Теперь внутри js файла мы можем делать импорт стилей</p>
      <code>import './style.scss';</code>
    </li>
    <li>
      <h4>css-loader mini-css-extract-plugin</h4>
      Вариант 2 В сборке стили будут вынесены в отдельный файл style.css, который будет подключен в теге link файла index.html.
      <code>npm i -D css-loader mini-css-extract-plugin</code>
<pre>const MiniCssExtractPlugin = require("mini-css-extract-plugin");
module.exports = {
  module: {
    rules:[
      {
        test: /\.css$/,
        use: [MiniCssExtractPlugin.loader, 'css-loader'],
      }
    ]
  }
  plugins: [
    new MiniCssExtractPlugin(),
  ],
}</pre>
    </li>
    <li>
      <h4>sass-loader</h4>
      <p>sass-loader загружает файлы SCSS и передает компилятору sass</p>
      <p>sass компилирует код в CSS.</p>
      <code>npm i -D sass-loader sass</code>
      <p>Напишем rules (правила) для scss</p>
<pre>module: {
  rules:[
    {
      test: /\.(scss|sass|css)$/,
      use: [MiniCssExtractPlugin.loader, 'css-loader', 'sass-loader'],
    }
  ]
}</pre>
    </li>
    <li>
      <h4>postcss-loader</h4>
      Плагин postcss-loader добавит autoprefix для создания кроссбраузерного css
      <code>npm i -D postcss-loader postcss postcss-preset-env</code>
      <p>postcss-loader - загрузчик CSS файлов для пост-обработки. Должен работать с каким нибудь плагином.</p>
      <p>postcss-preset-env это плагин для PostCSS, который конвертирует современный CSS в код, понятный большинству браузеров, включением необходимых полифилов.</p>
<pre>const MiniCssExtractPlugin = require("mini-css-extract-plugin");
module.exports = {
  module: {
    rules:[
      {
        test: /\.(scss|sass|css)$/,
        use: [MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader', 'sass-loader'],
      }
    ]
  }
  plugins: [
    new MiniCssExtractPlugin(),
  ],
}</pre>
      <p>Создадим файл настроек postcss.config.js и запишем в него</p>
<pre>module.exports = {
  plugins: {
    'postcss-preset-env': {
      browsers: 'last 2 versions',
    },
  },
}
</pre>
    </li>
    <li>
      <h4>pug-loader</h4>
      pug-loader позволяет добавить html препроцессор pug в проект
      <code>npm i -D pug-loader pug</code>
<pre>module: {
  rules:[
    {
      test: /\.pug$/,
      loader: 'pug-loader',
    }
  ]
}</pre>
  </ol>
</article>


<!-- module - rules -->
<article class="article">
  <div class="anchor" id="rules"></div>
  <h2>module - rules (правила)</h2>

  <ol>
    <li>      
      <h4>Шрифты</h4>
      Напишем rules (правила) для шрифтов
<pre>module: {
  rules: [
    {
      test: /\.(otf|ttf|eot|woff|woff2)$/,
      type: 'asset/resource',
    },
  ]
}</pre>
    </li>
    <li>
      <h4>Картинки</h4>
      Напишем rules (правила) для картинок
<pre>output: {
  //Название выходного файла будет соответствовать исходному
  assetModuleFilename: '[name][ext]'
},
module: {
  rules: [        
    {
      test: /\.(png|jpg|jpeg|gif)$/i,
      type: 'asset/resource'
    }
  ]
}</pre>

      <p>Дальше</p>
<pre>{
  test: /\.(png|jpg|jpeg|gif)$/i,
  use: [
    {
      loader: 'file-loader',
      options: {
        name: '[name]-[hash].[ext]',
        outputPath: 'img',
      },
    },
  ],
},</pre>
    </li>
  </ol>
</article>


<!-- plugins -->
<article class="article">
  <div class="anchor" id="plugins"></div>
  <h2>Plugins (Плагины)</h2>
  
  <p>Плагины — внешние модули для Webpack, которые позволяют управлять и обрабатывать файлы, которые не импортируются в JavaScript.</p>

  <ol>
    <li>
      <h4>html-webpack-plugin</h4>
      Плагин HTMLWebpackPlugin автоматически создает HTML-файл с уже подключенным скриптом. Установим
      html-webpack-plugin
      <code>npm i -D html-webpack-plugin</code>
      <p>Запишем в webpack.config.js</p>
<pre>const HtmlWebpackPlugin = require('html-webpack-plugin');
module.exports = {
  plugins: [
    new HtmlWebpackPlugin()
  ],
};</pre>
      <p>Научим HTMLWebpackPlugin создавать файл на основе шаблона, задавать имя выходного файла, копировать файл favicon.svg в выходную директорию и автоматически подключать его в index.html</p>
      <pre>const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
module.exports = {
  plugins: [
    new HtmlWebpackPlugin({
      template: path.resolve(__dirname, './src/index.html'),
      filename: 'index.html', 
      favicon: "./src/favicon.svg",
    })
  ],
};
</pre>
    </li>
    <li>
      <h4>filemanager-webpack-plugin</h4>
      Используем filemanager-webpack-plugin для копирования файлов из папки src/assets в папку dist. Установим filemanager-webpack-plugin
      <pre>npm i -D filemanager-webpack-plugin</pre>
      <p>Чтобы скопировать файл src/favicon.svg в ./dist и файлы из src/assets в ./dist/assets запишем в webpack.config.js</p>
<pre>const path = require('path');
const FileManagerPlugin = require('filemanager-webpack-plugin');
module.exports = {
  plugins: [
    new FileManagerPlugin({
      events: {
        onEnd: {
          copy: [
            {
              source: path.resolve(__dirname, './src/favicon.svg'),
              destination: path.resolve(__dirname, './dist/favicon.svg'),
            },
            {
              source: path.resolve(__dirname, './src/assets'),
              destination: path.resolve(__dirname, './dist/assets'),
            },
          ],
        },
      },
    }),
  ],
};</pre>
      <p>Свойство onEnd указывает что копирование будет после сборки</p>
      <p>Свойство onStart указывает что копирование будет перед сборкой, но тогда если во время сборки делать очистку папки dist командой clean: true то скопированные файлы удалятся</p>
    </li>
  </ol>
</article>


<!-- webpack-dev-server -->
<article class="article">
  <div class="anchor" id="devserver"></div>
  <h2>webpack-dev-server</h2>

  <p>Сервер. Есть несколько способов, которые позволяют при сохранении кода автоматически его собирать и обновлять в браузере. Рассмотрим вариант webpack-dev-server. Установим webpack-dev-server</p>
    <pre>npm i -D webpack-dev-server</pre>
    <p>Пропишем в файле webpack.config.js</p>
    <pre>const path = require('path');
module.exports = {
  devServer: {
    static: {
      directory: path.resolve(__dirname, 'src'),
    },              
    watchFiles: path.join(__dirname, 'src'),
    port: 9000,
    overlay: true,
  }
}</pre>
    <p>Пропишем в package.json</p>
<pre>"scripts": {
  "serve": "webpack serve --mode development --open",
}</pre>
    <p>serve означает запустить веб сервер.</p>
    <p>--mode development включает режим разработки.</p>
    <p>--open автоматически запускает браузер, который в системе установлен по умолчанию.</p>
    <p>Теперь сервер можно запустить командной</p>
    <pre>npm run serve </pre>
    <p>Для остановки сервера надо нажать</p>
    <pre>CTRL + c</pre>
</article>


<!-- devtool -->
<article class="article">
  <div class="anchor" id="devtool"></div>
  <h2>devtool</h2>

  <p>Для того чтобы создать source map нужно указать свойство devtool</p>
<pre>
module.exports = {
  devtool: 'source-map',
};  
</pre>

</article>


<!-- Настроим свою конфигурацию webpack.config.js -->
<article class="article">
  <div class="anchor" id="uconfig"></div>
  <h2>Настроим свою конфигурацию webpack.config.js</h2>

  <p>Настроим свою конфигурацию. Сначала установим необходимые пакеты</p>
<pre>npm i -D webpack-dev-server 
npm i -D html-loader
npm i -D css-loader mini-css-extract-plugin
npm i -D sass-loader sass
npm i -D postcss-loader postcss postcss-preset-env
npm i -D html-webpack-plugin filemanager-webpack-plugin
npm i -D babel-loader @babel/core @babel/preset-env
npm i -D ts-loader typescript
</pre>

  <p>В файле package.json должны появиться зависимости для разработки</p>
<pre>
"devDependencies": {
  "@babel/core": "^7.20.5",
  "@babel/plugin-proposal-class-properties": "^7.18.6",
  "@babel/preset-env": "^7.20.2",
  "babel-loader": "^9.1.0",
  "css-loader": "^6.7.2",
  "file-loader": "^6.2.0",
  "filemanager-webpack-plugin": "^8.0.0",
  "html-loader": "^4.2.0",
  "html-webpack-plugin": "^5.5.0",
  "http-server": "^14.1.1",
  "mini-css-extract-plugin": "^2.7.1",
  "postcss": "^8.4.19",
  "postcss-loader": "^7.0.2",
  "postcss-preset-env": "^7.8.3",
  "sass": "^1.56.1",
  "sass-loader": "^13.2.0",
  "style-loader": "^3.3.1",
  "ts-loader": "^9.4.1",
  "typescript": "^4.9.3",
  "webpack": "^5.87.0",
  "webpack-cli": "^5.1.4",
  "webpack-dev-server": "^4.11.1"
},</pre>

  <p>Запишем в package.json</p>
<pre>"scripts": {
  "serve": "webpack serve --mode development --open",
  "dev": "webpack --mode development",
  "build": "webpack --mode production",
},</pre>

  <p>Запишем в webpack.config.js </p>
<pre>const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
const FileManagerPlugin = require('filemanager-webpack-plugin');

module.exports = {
  entry: './src/index.js',
  output: {
    clean: true, 
    path: path.resolve(__dirname, './dist'),
    filename: 'index.js',
    assetModuleFilename: 'assets/[name][ext]',
  },
  module: {
    rules: [
      {
        test: /\.html$/i,
        loader: "html-loader",
      },
      {
        test: /\.(scss|sass|css)$/,
        use: [ MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader', 'sass-loader' ],
      },
      {
        test: /\.js$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
        }
      },
      {
        test: /\.ts$/,
        exclude: /node_modules/,
        use: {
          loader: 'ts-loader',
          options: {
            presets: ['@babel/preset-env']
          }
        }
      },
      {
        test: /\.(png|jpg|jpeg|gif|svg)$/i,
        type: 'asset/resource',
      }
    ],
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: path.resolve(__dirname, './src/index.pug'),
      filename: 'index.html', 
      favicon: "./src/favicon.svg",
    })
    new MiniCssExtractPlugin({
      filename: 'style.css',
    }),
    new FileManagerPlugin({
      events: {
        onEnd: {
          copy: [
            {
              source: path.resolve(__dirname, './src/static'),
              destination: path.resolve(__dirname, './dist/'),
            },
          ],
        },
      },
    }),
  ],
  devServer: {
    client: {
      overlay: true,
    },
    static: {
      directory: path.resolve(__dirname, 'dist'),
    },
    watchFiles: path.join(__dirname, 'src'),
    port: 9000,
    hot: true,
  },
  devtool: 'source-map',
};</pre>

  <p>Запишем в файл .babelrc</p>
<pre>{
  "presets": ["@babel/preset-env"]
}</pre>

  <h4>Разница между path.join и path.resolve</h4>
  <p>path.join соединяет в одну строку переданные ей аргументы используя специфичный для операционной системы разделитель (/ или \) и нормализирует ее.</p>
  <code>path.join('path', 'to', 'another', '..', 'another', 'file')</code>
  <p>Вернет для Linux </p>
  <code>'path/to/another/file'</code>
  <p>Вернет для Windows </p>
  <code>'path\to\another\file'</code>
  <p>Нормализация заключается в том что не возвращается</p>
  <code>'path/to/another/../another/file'</code>
  <p>path.resolve возвращает абсолютный путь по тем сегментам которые переданны в аргументы</p>
  <code>path.resolve('/how', 'to', 'code')</code>
  <p>Вернет</p>
  <code>'/how/to/code'</code>
</article>