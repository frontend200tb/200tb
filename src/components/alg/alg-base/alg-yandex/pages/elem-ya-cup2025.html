<h1>YandexCup 2025</h1>


<article class="article">
  <p><a href="https://new.contest.yandex.ru/contests/84268/problem" target="_blank">new.contest.yandex.ru/contests/84268/problem</a></p>
  <p>Контест состоялся 2 ноября 2025 вс с 17.00 до 21.00. Всего надо решить 11 задач за 4 часа.</p>
</article>


<!-- Содержание -->
<article class="article">
  <h3>Содержание</h3>

  <p><a href="#p1">A. Mosaic Lover</a></p>
  <p><a href="#p2">B. Подмозаики</a></p>
  <p><a href="#p3">C. Коридор из мозаики</a></p>
  <p><a href="#p4">D. Восстановление мозаики</a></p>
  <p><a href="#p5">E. Закупаем Лукум</a></p>
  <p><a href="#p6">F. Композиция мозаик</a></p>
  <p><a href="#p7">G. Зейтин и красивая мозаика</a></p>
  <p><a href="#p8">H. Мозаичный шифр</a></p>
  <p><a href="#p9">I. Из Стамбула на Манхэттен</a></p>
  <p><a href="#p10">J. За нами следят</a></p>
  <p><a href="#p11">K. Симметрия мозаики</a></p>

</article>


<!-- A. Mosaic Lover -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>A. Mosaic Lover</h3>

  <div class="time-memory">(Время 1с. Память 256мб)</div>

  <p>У вас есть n белых и m чёрных камешков. Используя все камешки, необходимо собрать красивую мозаику.</p>

  <p>Мозаика считается красивой, если выполняются следующие условия:</p>
  <ul>
    <li>она имеет квадратную форму (то есть состоит из kxk камешков для некоторого целого k>0);</li>
    <li>каждая строка в ней является палиндромом, то есть читается одинаково слева направо и справа налево.</li>
  </ul>
  <p>Определите, можно ли составить красивую мозаику, используя все камешки.</p>

  <h4>Формат ввода</h4>
  <p>Каждый тест состоит из нескольких наборов входных данных. В первой строке находится одно целое число t (1 ≤ t ≤ 100) — количество наборов входных данных. Далее следует описание наборов входных данных.</p>

  <p>Далее следуют t строк, каждая из которых содержит два целых числа n и m (0 ≤ n, m ≤ 2500 и n + m ≤ 2500) — количество белых и чёрных камешков соответственно.</p>

  <h4>Формат вывода</h4>
  <p>Для каждого набора входных данных выведите «YES», если можно составить красивую мозаику, и «NO» в противном случае. Выводите ответы в том же порядке, в котором заданы входные наборы данных.</p>

  <details>
    <summary>Пример</summary>
<pre>
3
4 5
2 3
8 8
</pre>
<pre>
YES
NO
YES
</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Сначала проверим, что можно собрать квадрат. Число камешек не превышает 2500, это квадрат со стороной 50.</p>
    <p>Если сторона квадрата нечетная, то всегда можно собрать красивую мозаику.</p>
    <p>Если сторона квадрата четная, то число камешек одного цвета должна быть четная. Заметим, что в этом случае четность белых и черных камешек одинаковая, поэтому нет разницы какие камешки проверять на четность.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int t;
  cin >> t;

  while (t--) {
    int n; // число белых камешков
    int m; // число черных камешков
    cin >> n >> m;

    int k = 0; // сторона квадрата

    // проверка на квадрат
    for (int i = 1; i &lt;= 50; i++) {
      if (i * i == n + m) {
        k = i;
      }
    }

    if (k == 0) {
      cout &lt;&lt; "NO\n";
    } else if (k % 2 == 0 && n % 2 != 0) {
      cout &lt;&lt; "NO\n";
    } else {
      cout &lt;&lt; "YES\n";
    }
  }
}
</pre>
  </details>
</article>


<!-- B. Подмозаики -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>B. Подмозаики</h3>

  <div class="time-memory">(Время 0.5с. Память 256мб)</div>

  <p>Начинающий мозаичист Марат на днях составил две черно-белые мозаики a и b на прямоугольных холстах одинакового размера.</p>

  <p>Каждая мозаика состоит из n строк и m столбцов. На пересечении i-й строки и j-го столбца находится квадратный элемент мозаики, покрашенный в цвет ai,j у первой мозаики и в цвет bi,j у второй.</p>

  <p>Марат хочет рассмотреть все такие пары подмозаик, что:</p>
  <ol>
    <li>Первая подмозаика — это непрерывный подпрямоугольник в первой мозаике;</li>
    <li>Вторая подмозаика — это непрерывный подпрямоугольник во второй мозаике;</li>
    <li>Индексы углов подмозаик совпадают;</li>
    <li>Значения цветов в обоих подмозаиках во всех позициях совпадают.</li>
  </ol>

  <p>Обратите внимание, что в каждой паре подмозаики имеют одинаковую площадь. Марат интересуется, насколько большая площадь может быть.</p>

  <h4>Формат ввода</h4>
  <p>Каждый тест состоит из нескольких наборов входных данных. В первой строке находится одно целое число t (1 ≤ t ≤ 10<sup>3</sup>) —количество наборов входных данных. Далее следует описание наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит два целых числа n и m (1 ≤ n, m ≤ 1000) — размеры мозаик.</p>

  <p>Каждая из следующих n строк содержит m символов — описание мозаики a. На i-й строке в j-м столбце находится число ai,j(ai,j ∈ {0,1}) — описание цвета очередного элемента первой мозаики.</p>

  <p>Каждая из следующих n строк содержит m символов — описание мозаики b. На i-й строке в j-м столбце находится число bi,j(bi,j ∈ {0,1}) — описание цвета очередного элемента первой мозаики.</p>

  <p></p>Гарантируется, что сумма по всем nxm не превосходит 10<sup>6</sup>.

  <h4>Формат вывода</h4>
  <p>Для каждого набора входных данных выведите одно целое число — ответ на задачу.</p>

  <details>
    <summary>Пример</summary>
<pre>
5
4 5
00110
10101
01010
01010
00110
10101
01010
01010
4 5
00000
00000
00000
00000
11111
11111
11111
11111
1 1
0
1
1 1
1
1
5 3
110
110
010
010
010
111
111
101
101
101
</pre>
<pre>
20
0
0
1
4
</pre>
  </details>

  <details>
    <summary>Решение</summary>

    <h4>Пример 2</h4>
<pre>
1
6 6
111111
111111
111111
111111
111111
111111
111111
011111
001111
000111
000011
000001
</pre>
<pre>
12
</pre>

    <p>Соберем две матрицы для первой и второй мозаики.</p>
    <p>Создадим матрицу H размером n+1 на m, заполненую нулями, для хранения высот прямоугольников. +1 нужно для рамки снизу. Для каждой ячейки H[i][j] посчитаем число совпадающих ячеек вниз.</p>
    <p>Создадим стек st для отслеживания индексов столбцов матрицы H. По разнице индексов будем находить ширину прямоугольника.</p>
    <p>Будем проходить по каждой строке матрицы H. Для каждой строки будем проходить по каждому столбцу. Для каждого столбца мы проверяем, можно ли добавить его в стек (если его высота больше или равна высоте столбца на вершине стека).</p>
    <p>Если в ячейке ненулевая высота, то проверяем если стек пустой, то кладем в него высоту H[i][j] и запоминаем текущую высоту. Если стек не пустой, проверяем если текущая высота не более высоты H[i][j], то кладем в стек высоту H[i][j], иначе если высота H[i][j] меньше текущей высоты, то обновляем сумму, кладем высоту H[i][j] в стек и обновляем текущую высоту.</p>
    <p>Если в ячейке нулевая высота, проверяем если есть непосчитанная сумма, обновляем сумму, очищаем стек, обнуляем текущую высоту. Иначе ничего не делаем.</p>
    <p>При переходе на новую строку, проверяем если есть непосчитанная сумма обновляем сумму, очищаем стек, обнуляем текущую высоту и начинаем собирать новый прямоугольник. Иначе ничего не делаем.</p>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;stack&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
    // условная компиляция
  #ifdef _DEBUG
    freopen("input.txt", "rt", stdin);
    freopen("output.txt", "wt", stdout);
  #endif

  int t; // число тестов
  cin >> t;

  while (t--) {
    int n, m; // размер мозаики
    cin >> n >> m;

    vector&lt;string&gt; A(n); // первая мозаика
    for (int i = 0; i &lt; n; i++) {
      cin >> A[i];
    }
    vector&lt;string&gt; B(n); // вторая мозаика
    for (int i = 0; i &lt; n; i++) {
      cin >> B[i];
    }

    // матрица из n+1 строк и m столбцов
    // заполненная нулями
    vector&lt;vector&lt;int&gt; &gt; H(n + 1, vector&lt;int&gt;(m, 0));

    // для каждой ячейки посчитаем число
    // совпадающих ячеек вниз
    for (int i = n - 1; i >= 0; i--) {
      for (int j = 0; j &lt; m; j++) {
        if (A[i][j] == B[i][j]) {
          H[i][j] = H[i + 1][j] + 1;
        } else {
          H[i][j] = 0;
        }
      }
    }

    stack&lt;int&gt; st; // стек для индексов столбцов
    int h = 0; // высота прямоугольника
    int cur_area = 0; // текущая площадь
    int area = 0; // максимальная площадь

    // для каждой строки
    for (int i = 0; i &lt; n; i++) {
      int j = 0; // индекс столбца

      // для каждого столбца
      while (j &lt; m) {
        if (H[i][j]) {
          // если есть высота

          if (st.empty()) {
            // если стек пуст
            st.push(j);
            h = H[i][st.top()];
            j++;

          } else if (h &lt;= H[i][j]) {
            // если столбец не меньше высоты
            st.push(j);
            h = H[i][st.top()];
            j++;

          } else {
            // если столбец меньше высоты
            // берем верхний индекс и удаляем из стека
            h = H[i][st.top()];
            st.pop();

            // обновить площадь
            cur_area = h * (st.empty() ? j : j - st.top() - 1);
            area = max(area, cur_area);
          }

        } else {
          // если нет высоты
          // обработать оставшиеся в стеке индексы
          while (!st.empty()) {
            // пока в стеке есть индексы
            // берем верхний индес и удаляем из стека
            h = H[i][st.top()];
            st.pop();

            // обновить площадь
            cur_area = h * (st.empty() ? j : j - st.top() - 1);
            area = max(area, cur_area);
          }

          // очистить высоту
          h = 0;
          j++;
        }
      }

      // при переходе на новую строчку
      // обработать оставшиеся в стеке индексы
      while (!st.empty()) {
        // пока в стеке есть индексы
        // берем верхний индес и удаляем из стека
        h = H[i][st.top()];
        st.pop();

        // обновить площадь
        cur_area = h * (st.empty() ? j : j - st.top() - 1);
        area = max(area, cur_area);
      }

      // очистить высоту
      h = 0;
    }

    cout &lt;&lt; area &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- C. Коридор из мозаики -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>C. Коридор из мозаики</h3>

  <div class="time-memory">(Время 1с. Память 256мб)</div>

  <p>В Турции очень много древних достопримечательностей. Приехав в эту страну, Вы первым делом решили записаться на экскурсию в какой-нибудь храм. На месте вы увидели длинный коридор, пол которого состоял из больших фрагментов мозаики, выстроенных в линию.</p>

  <p>Длина шага позволяла Вам двигаться на соседний фрагмент или через один. Достигнув конца этого коридора, Вы посчитали число фрагментов — их было n.</p>

  <p>Под впечатлением экскурсии Вы много думали и задались разными вопросами. Один из них: а как происходит реставрация? Логичное предположение, что иногда некоторые фрагменты достают и заменяют отреставрированными. А их на месте на время реставрации ставят знак, запрещающий туда наступать. Получается настоящая полоса препятствий!</p>

  <p>И дальше Вы начали думать: а существует ли такая конфигурация из реставрируемых фрагментов, что количество различных способов пройти по коридору, двигаясь только вперёд на соседний фрагмент или через один, равняется k, при этом отправлять на реставрацию фрагменты с номерами 1 и n нельзя. В уме решить такую задачу не смогли и решили написать программу, которая даст ответ на этот вопрос.</p>

  <h4>Формат ввода</h4>
  <p>Единственная строка входных данных содержит два целых числа, 2 ≤ n ≤ 10<sup>4</sup> — количество клеток и 1 ≤ k ≤ 10<sup>18</sup> — желаемое количество способов пройти по коридору из мозаики.</p>

  <h4>Формат вывода</h4>
  <p>В первой строке выведите одно целое число l — количество одновременно реставрируемых фрагментов. Если конфигурации не существует, то выведите -1.</p>

  <p>Если искомая конфигурация достижима, то во второй строке выведите l целых чисел в возрастающем порядке, разделённых пробелом: a1, … , al — номера фрагментов, которые необходимо отправить на реставрацию, чтобы число способов добраться до конца коридора равнялось k.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>9 10</code>
<pre>
1
6
</pre>

    <h4>Пример 2</h4>
    <code>4 3</code>
    <code>0</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Это динамическое программирование. Храним вектор из числа способов попасть в каждую ячейку. Есть только один способ попасть в первую ячейку DP[1] = 1. Следующие ячейки считаются как числа Фибоначчи DP[i] = DP[i-1] + DP[i-2]. Но есть предварительное условие для каждого числа, в клетке не должно быть препятствия. Ответ лежит в DP[n].</p>
  </details>
</article>


<!-- D. Восстановление мозаики -->
<article class="article">
  <div class="anchor" id="p4"></div>
  <h3>D. Восстановление мозаики</h3>

  <div class="time-memory">(Время 2с. Память 256мб)</div>

  <p>Это интерактивная задача.</p>

  <p>Вы ведёте археологические раскопки и только что обнаружили N частей древней мозаики. Вы пронумеровали эти части от 1 до N и хотите выложить их в один ряд на позиции от 1 до N. Правда, вы пока не уверены, какую из частей нужно разместить в каждой из позиций.</p>

  <p>Вы решили проконсультироваться с коллегами из местного исторического общества. К сожалению, средств на вашем спутниковом телефоне хватит только на 10 сообщений.</p>

  <p>В одном сообщении вы можете отправить фото одной или нескольких частей мозаики, а в ответ коллеги отправят вам номера позиций, в которых эти части следует разместить. Порядок фото при отправке нарушается, поэтому коллеги всегда будут присылать вам список позиций в порядке возрастания.</p>

  <p>Восстановите мозаику.</p>

  <h4>Протокол взаимодействия</h4>
  <p>Первая строка входных данных содержит одно целое число N (1 ≤ N ≤ 500) — количество частей мозаики.</p>
  <p>Далее вы можете сделать не более 10 запросов. Каждый запрос должен быть одного из двух видов:</p>
  <ul>
    <li>
      <p>Если вы хотите проконсультироваться с коллегами, выведите слово CHECK. Далее в этой строке выведите K (1 ≤ K ≤ N) различных целых чисел Ai (1 ≤ Ai ≤ N) — номера частей мозаики, фото которых вы отправляете коллегам.</p>
      <p>После этого запроса ваша программа должна ввести K различных целых чисел Pi (1 ≤ Pi ≤ N) — номера позиций, на которых должны располагаться описанные части, в порядке возрастания.</p>
    </li>
    <li>
      <p>Если вы определили правильный порядок частей, выведите слово RESULT. Далее в этой строке выведите N различных целых чисел Aj (1≤Aj≤N) — номера частей мозаики, которые должны быть размещены в позициях 1,2, ..., N.</p>
      <p>Этот запрос должен быть последним, после него ваша программа должна завершить работу.</p>
    </li>
  </ul>

  <p>В конце каждого запроса не забудьте вывести перевод строки и сбросить буфер вывода:</p>
  <ul>
    <li>fflush(stdout) или cout.flush() в C++;</li>
    <li>System.out.flush() в Java;</li>
    <li>stdout.flush() в Python;</li>
    <li>Для других языков см. документацию.</li>
  </ul>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
3

1 2

2 3
</pre>
<pre>
CHECK 1 2

CHECK 2 3

RESULT 1 2 3
</pre>

    <h4>Пример 2</h4>
<pre>
4

2 3 4

1 2

1 4
</pre>
<pre>
CHECK 1 2 3

CHECK 2 4

CHECK 4 3

RESULT 4 2 1 3
</pre>
  </details>
</article>


<!-- E. Закупаем Лукум -->
<article class="article">
  <div class="anchor" id="p5"></div>
  <h3>E. Закупаем Лукум</h3>

  <div class="time-memory">(Время 1с. Память 256мб)</div>

  <p>Недавно в Яндекс Лавке появилась возможность заказать Рахат Лукум — одну из самых популярных сладостей, придуманных в Османской империи в конце XVIII века в Стамбуле. Всего на продажу выставлены n различных позиций лукума, пронумерованных от 1 до n, и, к счастью, некоторые было решено раздать любимым участникам Кубка Яндекса.</p>

  <p>Известно, что будет k различных независимых друг от друга акций, и i-я акция будет покрывать все позиции с номерами в диапазоне от li до ri и при этом существовать с вероятностью pi / qi. Иными словами, вероятность существования одной акции не зависит от существования другой, и если акция существует, то она применяется ко всем товарам в указанном диапазоне номеров.</p>

  <p>Теперь же Вас попросили для каждой позиции определить вероятность того, что к ней будет применена ровно одна акция. Для каждой позиции выведите искомую вероятность по модулю 10<sup>9</sup> + 7.</p>

  <p>Вероятность можно выразить в виде несократимой дроби x / y. Вы должны вывести значение x⋅y<sup>-1</sup> mod(10<sup>9</sup> + 7), где y<sup>-1</sup> — целое число, такое, что y⋅y<sup>-1</sup>  mod(10<sup>9</sup> + 7) = 1.</p>

  <h4>Формат ввода</h4>
  <p>Первая строка ввода содержит два целых числа n и k (1 ≤ n, k ≤ 2⋅10<sup>5</sup>) — количество предложений и количество акций.</p>

  <p>i-я из следующих k строк ввода содержит по 4 целых числа, описывающих i-ю акцию li, ri, pi, qi (1 ≤ li ≤ ri ≤ n, 1 ≤ pi &lt; qi&lt;10<sup>9</sup> + 7)</p>

  <h4>Формат вывода</h4>
  <p>Выведите единственную строку, содержащую n целых чисел, где i-е число представляет собой вероятность по модулю 10<sup>9</sup>  +  того, что i-е предложение будет покрыто ровно одной акцией.</p>

  <details>
    <summary>Пример</summary>
<pre>
5 3
1 3 1 2
2 4 1 3
3 4 5 6
</pre>
    <code>500000004 500000004 361111114 611111116 0</code>
  </details>
</article>


<!-- F. Композиция мозаик -->
<article class="article">
  <div class="anchor" id="p6"></div>
  <h3>F. Композиция мозаик</h3>

  <div class="time-memory">(Время 1с. Память 256мб)</div>

  <p>Гуляя по туристическим местам, Вы увидели в сувенирном магазине интересную игру, где надо из небольших фрагментов собирать мозаику. Каждый фрагмент промаркирован цифрой от 0 до 9.</p>

  <p>Вы закупили их огромное количество. Таким образом, можно считать, что экземпляров каждого фрагмента у вас бесконечное множество.</p>

  <p>Добравшись до отеля, Вы решили собрать k красивых мозаик, каждая из которых представляет собой некоторое количество фрагментов, выложенных в ряд. Мозаика считается красивой, если число, образованное цифрами с фрагментов мозаики, не содержит лидирующих нулей. Красотой мозаики является число, полученное путём последовательного выписывания цифр соответствующих фрагментов в десятичное число.</p>

  <p>Собрав множество красивых мозаик, Вы решили объединить их в композицию и выложили их в один ряд. Красотой композиции решили считать число, полученное выписыванием цифр всех фрагментов мозаик.</p>

  <p>В этот момент Вы задались вопросом, какую максимальную красоту композиции вы можете получить из мозаик, сумма красоты которых равна n.</p>

  <h4>Формат ввода</h4>
  <p>Единственная строка входных данных содержит два целых числа 1 ≤ n ≤ 10<sup>3000</sup>, 1 ≤ k ≤ — сумма красот мозаик и число мозаик в композиции, соответственно.</p>

  <h4>Формат вывода</h4>
  <p>В единственной строке выведите k целых чисел, разделённых пробелом — значения красот мозаик, входящих в композицию, расположенных слева направо в композиции с максимальной красотой.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>13 2</code>
    <code>3 10</code>

    <h4>Пример 2</h4>
    <code>4 3</code>
    <code>4 0 0</code>
  </details>
</article>


<!-- G. Зейтин и красивая мозаика -->
<article class="article">
  <div class="anchor" id="p7"></div>
  <h3>G. Зейтин и красивая мозаика</h3>

  <div class="time-memory">(Время 2с. Память 256мб)</div>

  <p>Стамбульский горилленок Зейтин нашёл мозаику из n фрагментов. Фрагменты расположены в ряд и имеют целочисленные цвета a1, a2, . . . , an. </p>

  <p>Зейтин не любит одинокие простые делители. Он считает фрагмент мозаики цвета x красивым только если для каждого простого p верно, что если x делится на p без остатка, то x делится на p<sup>2</sup> без остатка. Например, фрагменты мозаики с цветами 4, 8, 200 — красивые, а фрагменты с цветами 2, 13, 75 — нет.</p>

  <p>Подотрезок мозаики al, al+1, . . . , ar считается красивым только если каждый его фрагмент красивый.</p>

  <p>НОД подотрезка мозаики al, al+1, . . . , ar — это такое наибольшее целое число, которое является делителем цвета каждого фрагмента мозаики al . . . ar.</p>

  <p>Помогите Зейтину посчитать сумму НОД всех красивых подотрезков мозаики. Если красивых подотрезков мозаики нет, сумма считается равной нулю.</p>

  <h4>Формат входных данных</h4>
  <p>Каждый тест состоит из нескольких наборов входных данных. В первой строке находится одно целое число t (1 ⩽ t ⩽ 10<sup>4</sup>) — количество наборов входных данных. Далее следует описание наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит одно целое число n (1 ⩽ n ⩽ 2 · 10<sup>5</sup>) — количество элементов в мозаике.</p>

  <p>Вторая строка каждого набора входных данных содержит n целых чисел a1, a2, . . . , an (2 ⩽ ai ⩽ 10<sup>7</sup>) — цвета фрагментов мозаике.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превосходит 2 · 10<sup>5</sup>.</p>

  <h4>Формат выходных данных</h4>
  <p>Для каждого набора входных данных выведите единственное целое число — ответ на задачу.</p>

  <details>
    <summary>Пример</summary>
<pre>
4
1
2
5
40 10000000 2 13 228
6
25 8 2 200 200 216
7
8869743 26569 120125 4959529 9150625 1865956 5132808
</pre>
<pre>
0
10000000
866
30125379
</pre>
  </details>
</article>


<!-- H. Мозаичный шифр -->
<article class="article">
  <div class="anchor" id="p8"></div>
  <h3>H. Мозаичный шифр</h3>

  <div class="time-memory">(Время 4с. Память 512мб)</div>

  <h4>Это задача с двойным запуском.</h4>
  <p>Скоро вам предстоит поездка в Турцию. Вы очень хотите проникнуться атмосферой, и поэтому всю ночь смотрели познавательные телепередачи про историю Турции. Вы узнали, что раньше там жили лучшие учёные своего времени.</p>

  <p>В одном из сюжетов рассказывалось, что учёные умели кодировать бинарные числа в виде мозаик! А так как мозаики — это реальные объекты, то они изобрели способ, который позволял сделать это с ограничением на число фрагментов в мозаике.</p>

  <p>Вы знаете, что древние учёные брали бинарную строку длины n и кодировали её с помощью правильной скобочной последовательности длины не более n + 70. Выкладывали мозаику из фрагментов двух цветов, где открывающей скобке был сопоставлен чёрный фрагмент, а закрывающей — белый. Эту мозаику можно было передать на другой конец империи, и местный учёный, знающий шифр, мог раскодировать в изначальную строку.</p>

  <p>Вам стало интересно, а как можно реализовать такой шифр? Вы уже написали программу для проверки корректности и тесты. Осталось придумать сам алгоритм шифрования!</p>

  <h4>Протокол взаимодействия</h4>
  <p>Первая строка входных данных содержит одно целое число R (R ∈ {1, 2}) — номер текущего запуска.</p>

  <h4>1 Первый запуск</h4>
  <p>Если R = 1, то вторая и последующие строки входных данных описываются следующим образом.</p>
  <p>Вторая строка входных данных содержит одно целое число t (1 ⩽ t ⩽ 10<sup>5</sup>) — количество независимых тестовых случаев.</p>

  <p>Каждая из следующих t строк содержит бинарную строку si. Гарантируется, что Pti=1 |si| ⩽ 10<sup>6</sup>, где |si| обозначает длину i-й строки.</p>

  <p>Для каждого тестового случая выведите в отдельной строке корректную ПСП. Длина ответа для i-го теста не должна превышать |si| + 70. Ответы необходимо выводить в том же порядке, в котором поступают входные строки.</p>

  <h4>2 Второй запуск</h4>
  <p>Если R = 2, то вторая и последующие строки входных данных описываются следующим образом.</p>

  <p>Вторая строка входных данных содержит одно целое число t (1 ⩽ t ⩽ 105) — количество независимых тестовых случаев.</p>

  <p>В каждой из следующих t строк подается ПСП — одна из тех последовательностей, которые ваше решение выдало на первом запуске. Обратите внимание, что порядок ПСП может отличаться от порядка их вывода на первом запуске.</p>

  <p>Для каждой ПСП выведите исходную бинарную строку, которая была закодирована на первом запуске. Строки следует выводить в порядке появления соответствующих ПСП во входных данных.</p>

  <details>
    <summary>Примеры</summary>
<pre>
1
2
101010
000111
</pre>
<pre>
(()()())
(((())))()
</pre>
<pre>
2
2
(((())))()
(()()())
</pre>
<pre>
000111
101010
</pre>
    <p>Правильная скобочная последовательность (ПСП) — это последовательность из открывающих и закрывающих круглых скобок, в которой между скобками можно расставить символы «+» и 1 так, чтобы получившееся выражение стало корректным арифметическим.</p>
  </details>
</article>


<!-- I. Из Стамбула на Манхэттен -->
<article class="article">
  <div class="anchor" id="p9"></div>
  <h3>I. Из Стамбула на Манхэттен</h3>

  <div class="time-memory">(Время 1с. Память 256мб)</div>

  <p>В Стамбуле растет множество разных деревьев: кипарисы, платаны, магнолии, сосны и другие. Бывают так же и довольно необычные: например, встречается тот вид деревьев, что называют ненаправленным связным ациклическим графом.</p>

  <p>Арслан смог договориться о поставке дерева последнего вида на Манхэттен. Разумеется, на Манхэттене есть свои правила того, как нужно размещать дерево. Они описаны ниже.</p>
  <ul>
    <li>Размещение дерева на Манхэттене происходит в k-мерном пространстве с манхэттенской метрикой.</li>
    <li>Каждой вершине исходного дерева однозначно сопоставляется некоторая точка в этом пространстве. Для вершины v будем обозначать эту точку как p(v).</li>
    <li>Между любыми двумя вершинами u и v расстояние в исходном дереве совпадает с расстоянием между точками p(v) и p(u) в заданном пространстве.</li>
    <li>Число k должно быть минимально возможным (чтобы дерево не занимало слишком много места!).</li>
  </ul>

  <p>Несмотря на договоренность о поставке, Арслан немного не подумал о том, как он будет выполнять эти странные правила размещения дерева, поэтому просит Вас о помощи!</p>

  <h4>Формат входных данных</h4>
  <p>Каждый тест состоит из нескольких наборов входных данных. В первой строке находится одно целое число t (1 ⩽ t ⩽ 200) — количество наборов входных данных. Далее следует описание наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит одно целое число n (1 ⩽ n ⩽ 100) — количество вершин в дереве.</p>

  <p>Каждая из следующих n - 1 строк содержит два целых числа ui, vi (1 ⩽ ui, vi ⩽ n, ui ̸= vi) — описание очередного ребра. Гарантируется, что множество ребер образует дерево.</p>

  <h4>Формат выходных данных</h4>
  <p>Для каждого набора входных данных выведите следующее.</p>

  <p>В первой строке выведите одно целое число k (1 ⩽ k ⩽ 10<sup>3</sup>) — минимальная размерность манхэттенского пространства.</p>

  <p>В каждой из следующей n строк выведите k целых чисел, где на v-й строке должны быть выведены p(v)1, p(v)2, . . . , p(v)k — координаты точки p(v) (-10<sup>6</sup> ⩽ p(v)i ⩽ 10<sup>6</sup>).</p>

  <p>Если существует несколько решений, выведите любое.</p>

  <details>
    <summary>Пример</summary>
<pre>
5
2
1 2
5
1 2
1 3
1 4
1 5
10
1 2
2 3
2 4
4 5
4 6
6 7
6 10
7 8
7 9
9
1 2
1 3
1 4
4 5
4 6
6 7
6 8
6 9
1
</pre>
<pre>
1
0
1
2
1 0
2 0
1 -1
1 1
0 0
3
4 0 0
3 0 0
3 0 1
2 0 0
2 1 0
1 0 0
1 -1 0
1 -2 0
1 -1 -1
0 0 0
3
3 0 0
4 0 0
3 0 1
2 0 0
2 0 -1
1 0 0
1 -1 0
1 1 0
0 0 0
1
0
</pre>
  </details>
</article>


<!-- J. За нами следят -->
<article class="article">
  <div class="anchor" id="p10"></div>
  <h3>J. За нами следят</h3>

  <div class="time-memory">(Время 3с. Память 512мб)</div>

  <p>Как всем известно, за нами следят. Инопланетяне. Прямо из космоса. И чтобы не остаться в стороне, хорошо было бы внести вклад в историю, которую пишут внеземные разумы о нашей планете, прилагая к ней различные снимки. Ну или хотя бы засветиться в сюжете на Humanoid-TV. Поэтому ArgovDI, как вождь племени, решил украсить небольшой кусочек своей земли, представляющий поле размерами n на m клеток, мозаикой, выложенной из красивых камней. Каждый из них занимает ровно одну клетку поля. На поле, как можно догадаться, сейчас нет ни одного камня.</p>

  <p>В его племени есть k семей, каждая из которых готова предоставить по такому случаю либо один свой камушек (их самую лучшую работу), который необходимо разместить в точности на xi-й клетке сверху и yi-й клетке слева, либо остальные (пусть они и не такие красивые) li камней, но свою лучшую работу оставить себе. Стоит уточнить, что каждая семья очень хочет поучаствовать, поэтому не может не выставлять ничего. В случае выбора не в сторону самого красивого камня все остальные li камней должны быть расставлены.</p>

  <p>Так как ArgovDI в душе еще и дизайнер, он не хочет, чтобы мозаика получилась слишком скучной. Под скучностью он понимает максимум среди следующих величин по всем строкам: количество клеток от самого левого камня до самого правого (включая клетки под ними самими) в рамках одной строки.</p>

  <p>ArgovDI, к сожалению, сильно занят вопросами воспитания и развития своего племени, поэтому попросил Вас помочь ему найти способ выбрать камни таким образом, чтобы скучность мозаики была минимально возможной.</p>

  <h4>Формат входных данных</h4>
  <p>Первой строка содержит три целых числа 1 ⩽ n, m, k ⩽ 10<sup>5</sup>; nm ⩽ 10<sup>5</sup> – количество строк в поле, количество столбцов, количество племен соответственно.</p>

  <p>Следующая строка содержит 2k целых чисел, записанных через пробел: x1, y1, x2, y2, . . . , xk, yk — список координат, куда необходимо поместить лучшую работу i-й семьи (1 ⩽ xi ⩽ n, 1 ⩽ yi ⩽ m).</p>

  <p>Каждая из следующих k строк содержит одно целое число li (0 ⩽ li &lt; 10<sup>5</sup>) — количество камней, которое необходимо расставить в качестве альтернативы лучшей работы семьи. Далее на этой строке заданы li координат: Xi,1, Yi,1, . . . ,Xi,li , Yi,li . Все числа на строке разделены пробелом.</p>

  <p>Гарантируется, что все точки, предоставленные во входных данных, попарно различны.</p>

  <h4>Формат выходных данных</h4>
  <p>В первой строке выведите единственное число — минимальную возможную скучность мозаики.</p>

  <p>Во второй строке выведите целое число r, а затем, через пробел, r целых чисел i1, . . . , ir — номера семей, которым необходимо оставить своё лучшее творение себе.</p>

  <details>
    <summary>Пример</summary>
<pre>
4 4 5
1 1 1 2 1 4 4 3 1 3
3 2 3 3 1 3 2
0
1 2 4
2 4 2 4 1
0
</pre>
<pre>
2
3 1 3 4
</pre>
  </details>
</article>


<!-- K. Симметрия мозаики -->
<article class="article">
  <div class="anchor" id="p11"></div>
  <h3>K. Симметрия мозаики</h3>

  <div class="time-memory">(Время 2с. Память 1024мб)</div>

  <p>Вы очень прониклись древним искусством мозаики. Сделали множество своих творений и теперь хотите научиться их сравнивать.</p>

  <p>Для этого каждому фрагменту мозаики Вы сопоставили маленькую латинскую букву. Какое же счастье, что различных фрагментов было не более 26. Таким образом, каждую мозаику можно представить в виде строки s.</p>

  <p>Красотой такой строки является количество пар подотрезков таких, что если развернуть сначала первый подотрезок, а потом второй, то строка не изменится. Так как это число может быть большим, выведите его по модулю 998244353.</p>

  <p>Приведем более формальное объяснение. Пусть s = s<sub>1</sub>s<sub>2</sub>...s<sub>n</sub> — строка длины n. Тогда для 1 ⩽ l ⩽ r ⩽ n обозначим за F(s, l, r) строку, в которой развернули подотрезок [l, r]: F(s, l, r) = s<sub>1</sub>s<sub>2</sub>...s<sub>l-1</sub>s<sub>r</sub>s<sub>r-1</sub>...s<sub>l+1</sub>s<sub>l</sub>s<sub>r+1</sub>s<sub>r+2</sub>...s<sub>n</sub>. Вам нужно посчитать количество пар подотрезков ([l1, r1], [l2, r2]), таких что F(F(s, l1, r1), l2, r2) = s.</p>

  <p>Обратите внимание, что порядок подотрезков в паре имеет значение.</p>

  <h4>Формат входных данных</h4>
  <p>Каждый тест состоит из нескольких наборов входных данных. В первой строке находится одно целое число t (t ⩽ 10<sup>5</sup>) — количество наборов входных данных. Далее следует описание наборов входных данных.</p>

  <p>Первая и единственная строка каждого набора входных данных содержит строку s. Строка состоит из латинских букв в нижнем регистре.</p>

  <p>Гарантируется, что сумма длин строк не превосходит 10<sup>6</sup>.</p>

  <h4>Формат выходных данных</h4>
  <p>Для каждого набора входных данных выведите одно целое число — красоту мозаики по модулю 998244353.</p>

  <details>
    <summary>Пример</summary>
<pre>
7
aa
aaa
aaaa
aboba
abbaccabba
abbracaddabra
mozaististanbul
</pre>
<pre>
9
36
100
57
405
385
338
</pre>
  </details>
</article>
