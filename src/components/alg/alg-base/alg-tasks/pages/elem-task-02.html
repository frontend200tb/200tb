<h1>Сборник задач по алгоритмам и структурам данных</h1>


<!-- links -->
<article class="article">
  <h2>links</h2>

  <p><a href="https://shadhelper.notion.site/e03c5086f74b495488e2af71058c51c3">shadhelper.notion.site</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p><a href="#t1">1. Массивы и хэширование</a></p>
  <ol>
    <li><a href="#t1_1">Проверка на анаграмму</a></li>
    <li><a href="#t1_2">Проверка на дубликаты в массиве</a></li>
    <li><a href="#t1_3">Две суммы</a></li>
    <li><a href="#t1_4">Кодирование и декодирование списка строк</a></li>
    <li><a href="#t1_5">Самая длинная последовательность в массиве</a></li>
    <li><a href="#t1_6">Найти произведение элементов массива, кроме i-го элемента</a></li>
    <li><a href="#t1_7">K наиболее часто встречающихся элементов</a></li>
    <li><a href="#t1_8">Группировка анаграмм в массиве строк</a></li>
    <li><a href="#t1_9">Проверка правильности заполнения судоку</a></li>
  </ol>
  <p><a href="#t2">2. Два указателя</a></p>
  <ol>
    <li><a href="#t2_1">Проверка на палиндром</a></li>
    <li><a href="#t2_2">Две суммы в отсортированном массиве</a></li>
    <li><a href="#t2_3">Нахождение троек чисел в массиве, сумма которых равна 0</a></li>
    <li><a href="#t2_4">Нахождение объема контейнера</a></li>
    <li><a href="#t2_5">Количество воды, задерживаемое в ландшафте</a></li>
  </ol>
  <p><a href="#t3">3. Стэк</a></p>
  <ol>
    <li><a href="#t3_1">Проверка правильности скобочной последовательности</a></li>
    <li><a href="#t3_2">Дневные температуры</a></li>
    <li><a href="#t3_3">Минимальный стэк</a></li>
    <li><a href="#t3_4">Вычислить арифметическое выражение в обратной польской записи</a></li>
    <li><a href="#t3_5">Генерация правильных скобочных последовательностей</a></li>
    <li><a href="#t3_6">Количество автомобильных флотов</a></li>
    <li><a href="#t3_7">Нахождение площади наибольшего прямоугольника в гистограмме</a></li>
  </ol>
  <p><a href="#t4">4. Метод скользящего окна</a></p>
  <ol>
    <li><a href="#t4_1">Лучшее время для покупки и продажи акций</a></li>
    <li><a href="#t4_2">Перестановка в строке</a></li>
    <li><a href="#t4_3">Самая длинная повторяющаяся замена символа</a></li>
    <li><a href="#t4_4">Самая длинная подстрока без повторяющихся символов</a></li>
    <li><a href="#t4_4">Самая длинная подстрока без повторяющихся символов</a></li>
    <li><a href="#t4_5">Максимальное количество скользящих окон</a></li>
    <li><a href="#t4_6">Минимальная подстрока окна</a></li>
  </ol>
  <p><a href="#t5">5. Связный список</a></p>
  <ol>
    <li><a href="#t5_1">Цикл в связном списке</a></li>
    <li><a href="#t5_2">Объединить два отсортированных списка</a></li>
    <li><a href="#t5_3">Обратный связный список</a></li>
    <li><a href="#t5_4">Least Recently Used (LRU) кэш</a></li>
    <li><a href="#t5_5">Найдите повторяющееся число</a></li>
    <li><a href="#t5_6">Сложите два числа</a></li>
    <li><a href="#t5_7">Скопировать список со случайным указателем</a></li>
    <li><a href="#t5_8">Удалить N-й узел из конца списка</a></li>
    <li><a href="#t5_9">Изменить порядок в списке</a></li>
    <li><a href="#t5_10">Обратные узлы в k-группе</a></li>
    <li><a href="#t5_11">Объединить k отсортированных списков</a></li>
  </ol>
  <p><a href="#t6">6. Деревья</a></p>
  <ol>
    <li><a href="#t6_1">Поиск поддерева в бинарном дереве</a></li>
</article>


<!-- 1. Массивы и хэширование -->
<article class="article">
  <div class="anchor" id="t1"></div>
  <h3>1. Массивы и хэширование</h3>
</article>


<!-- 1.1 Проверка на анаграмму -->
<article class="article">
  <div class="anchor" id="t1_1"></div>
  <h3>1.1 Проверка на анаграмму</h3>

  <p><a href="https://leetcode.com/problems/valid-anagram/">https://leetcode.com/problems/valid-anagram/</a></p>

  <p>Дано две строки s и t, вернуть true, если t является анаграммой s, и false в противном случае.</p>

  <p>Анаграмма - это слово или фраза, образованная перестановкой букв другого слова или фразы, как правило, используя все исходные буквы ровно один раз.</p>
</article>


<!-- 1.2 Проверка на дубликаты в массиве -->
<article class="article">
  <div class="anchor" id="t1_2"></div>
  <h3>1.2 Проверка на дубликаты в массиве</h3>

  <p><a href="https://leetcode.com/problems/contains-duplicate/">https://leetcode.com/problems/contains-duplicate/</a></p>

  <p>Написать функцию check_duplicates(nums), где: - nums - массив целых чисел. Функция должна вернуть `True`, если в массиве `nums` есть хотя бы один повторяющийся элемент. В противном случае, функция должна вернуть `False`.</p>
</article>


<!-- 1.3 Две суммы -->
<article class="article">
  <div class="anchor" id="t1_3"></div>
  <h3>1.3 Две суммы</h3>

  <p><a href="https://leetcode.com/problems/two-sum/">https://leetcode.com/problems/two-sum/</a></p>

  <p>Дан массив целых чисел `nums` и целое число `target`. Необходимо вернуть индексы двух чисел из массива `nums`, сумма которых равна `target`.</p>

  <p>Вы можете предположить, что каждый входной массив имеет только одно решение, и вы не можете использовать один и тот же элемент дважды.</p>

  <p>Вы можете вернуть ответ в любом порядке.</p>
</article>


<!-- 1.4 Кодирование и декодирование списка строк -->
<article class="article">
  <div class="anchor" id="t1_4"></div>
  <h3>1.4 Кодирование и декодирование списка строк</h3>

  <p><a href="https://leetcode.com/problems/encode-and-decode-strings/">https://leetcode.com/problems/encode-and-decode-strings/</a></p>

  <p>Необходимо разработать алгоритм кодирования списка строк в одну строку. Закодированная строка будет отправлена по сети и затем декодирована обратно в исходный список строк. Необходимо реализовать функции `encode` и `decode`.</p>
</article>


<!-- 1.5 Самая длинная последовательность в массиве -->
<article class="article">
  <div class="anchor" id="t1_5"></div>
  <h3>1.5 Самая длинная последовательность в массиве</h3>

  <p><a href="https://leetcode.com/problems/longest-consecutive-sequence/">https://leetcode.com/problems/longest-consecutive-sequence/</a></p>

  <p>Дан массив nums с целочисленными значениями. Необходимо найти длину самой длинной последовательности элементов в массиве. Напишите функцию longest_consecutive_sequence(nums: List[int]) -> int, которая принимает на вход неотсортированный массив целых чисел nums и возвращает целое число - длину самой длинной последовательности элементов в массиве.</p>
</article>


<!-- 1.6 Найти произведение элементов массива, кроме i-го элемента -->
<article class="article">
  <div class="anchor" id="t1_6"></div>
  <h3>1.6 Найти произведение элементов массива, кроме i-го элемента</h3>

  <p><a href="https://leetcode.com/problems/product-of-array-except-self/">https://leetcode.com/problems/product-of-array-except-self/</a></p>

  <p>Дан массив целых чисел nums. Необходимо вернуть массив answer, где answer[i] равен произведению всех элементов массива nums, кроме nums[i].</p>

  <p>Гарантируется, что произведение любого префикса или суффикса массива nums помещается в 32-битный целочисленный тип данных.</p>

  <p>Время выполнения алгоритма должно быть O(n), без использования операции деления.</p>
</article>


<!-- 1.7 K наиболее часто встречающихся элементов -->
<article class="article">
  <div class="anchor" id="t1_7"></div>
  <h3>1.7 K наиболее часто встречающихся элементов</h3>

  <p><a href="https://leetcode.com/problems/top-k-frequent-elements/">https://leetcode.com/problems/top-k-frequent-elements/</a></p>

  <p>Дан массив целых чисел nums длиной n и целое число k. Необходимо вернуть k наиболее часто встречающихся элементов массива nums.</p>
</article>


<!-- 1.8 Группировка анаграмм в массиве строк -->
<article class="article">
  <div class="anchor" id="t1_8"></div>
  <h3>1.8 Группировка анаграмм в массиве строк</h3>

  <p><a href="https://leetcode.com/problems/group-anagrams/">https://leetcode.com/problems/group-anagrams/</a></p>

  <p>Дан массив строк strs. Необходимо сгруппировать все анаграммы вместе и вернуть ответ в любом порядке.</p>
</article>


<!-- 1.9 Проверка правильности заполнения судоку -->
<article class="article">
  <div class="anchor" id="t1_9"></div>
  <h3>1.9 Проверка правильности заполнения судоку</h3>

  <p><a href="https://leetcode.com/problems/valid-sudoku/">https://leetcode.com/problems/valid-sudoku/</a></p>

  <p>Необходимо проверить, правильно ли заполнена судоку доска размером 9х9. Проверка должна осуществляться только для заполненных ячеек в соответствии с следующими правилами:</p>

  <p>- Каждая строка должна содержать цифры от 1 до 9 без повторений.</p>
  <p>- Каждый столбец должен содержать цифры от 1 до 9 без повторений.</p>
  <p>- Каждый из девяти блоков 3х3 должен содержать цифры от 1 до 9 без повторений.</p>
  <p>Примечание:</p>
  <p>- Доска судоку (частично заполненная) может быть правильной, но не обязательно разрешимой.</p>
  <p>- Проверка должна осуществляться только для заполненных ячеек в соответствии с указанными правилами.</p>
</article>


<!-- 2. Два указателя -->
<article class="article">
  <div class="anchor" id="t2"></div>
  <h3>2. Два указателя</h3>
</article>


<!-- 2.1 Проверка на палиндром -->
<article class="article">
  <div class="anchor" id="t2_1"></div>
  <h3>2.1 Проверка на палиндром</h3>

  <p><a href="https://leetcode.com/problems/valid-palindrome/">https://leetcode.com/problems/valid-palindrome/</a></p>

  <p>Дана строка s. Напишите функцию, которая проверяет, является ли строка s палиндромом. Строка s является палиндромом, если она читается одинаково как справа налево, так и слева направо, после приведения всех букв к нижнему регистру и удаления всех неалфавитно-цифровых символов. Неалфавитно-цифровые символы - это символы, не являющиеся буквами или цифрами.</p>
</article>


<!-- 2.2 Две суммы в отсортированном массиве -->
<article class="article">
  <div class="anchor" id="t2_2"></div>
  <h3>2.2 Две суммы в отсортированном массиве</h3>

  <p><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/">https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/</a></p>

  <p>Дан отсортированный по возрастанию массив целых чисел `numbers` с индексацией с 1 до `n`. Требуется найти два числа в массиве, сумма которых равна заданному числу `target`. Пусть эти числа будут `numbers[index1]` и `numbers[index2]`, где `1 &lt;= index1 &lt; index2 &lt;= n`.</p>

  <p>Необходимо вернуть индексы найденных чисел, увеличенные на 1, в виде массива `[index1, index2]` длиной 2.</p>

  <p>Тесты гарантируют, что решение существует и единственно. Необходимо использовать только константное дополнительное пространство.</p>
</article>


<!-- 2.3 Нахождение троек чисел в массиве, сумма которых равна 0 -->
<article class="article">
  <div class="anchor" id="t2_3"></div>
  <h3>2.3 Нахождение троек чисел в массиве, сумма которых равна 0</h3>

  <p><a href="https://leetcode.com/problems/3sum/">https://leetcode.com/problems/3sum/</a></p>

  <p>Дан массив целых чисел nums. Необходимо вернуть все тройки [nums[i], nums[j], nums[k]], такие что i != j, i != k, j != k и nums[i] + nums[j] + nums[k] == 0.</p>

  <p>Обратите внимание, что в решении не должно быть дубликатов троек.</p>

  <h4>Входные данные:</h4>
  <p>- Массив целых чисел nums, где 0 &lt;= len(nums) &lt;= 3000.</p>

  <h4>Выходные данные:</h4>
  <p>- Список всех уникальных троек чисел, сумма которых равна 0.</p>
</article>


<!-- 2.4 Нахождение объема контейнера -->
<article class="article">
  <div class="anchor" id="t2_4"></div>
  <h3>2.4 Нахождение объема контейнера</h3>

  <p><a href="https://leetcode.com/problems/container-with-most-water/">https://leetcode.com/problems/container-with-most-water/</a></p>

  <p>Дан массив неотрицательных целых чисел height, представляющий собой высоты n вертикальных линий. На каждой линии находятся две точки, где i-я линия имеет координаты (i, height[i]) и (i, 0). Найти две линии, которые вместе с осью x образуют контейнер, который может содержать наибольший объем воды.</p>
</article>


<!-- 2.5 Количество воды, задерживаемое в ландшафте -->
<article class="article">
  <div class="anchor" id="t2_5"></div>
  <h3>2.5 Количество воды, задерживаемое в ландшафте</h3>

  <p><a href="https://leetcode.com/problems/trapping-rain-water/">https://leetcode.com/problems/trapping-rain-water/</a></p>

  <p>Дан массив из n неотрицательных целых чисел, представляющий ландшафт. Ширина каждого столбца равна 1. Необходимо вычислить, сколько воды может быть задержано в ландшафте после дождя.</p>

  <p>Необходимо написать функцию, которая на вход принимает массив из n неотрицательных целых чисел, представляющий ландшафт, и возвращает количество воды, которое может быть задержано в ландшафте после дождя.</p>
</article>


<!-- 3. Стэк -->
<article class="article">
  <div class="anchor" id="t3"></div>
  <h3>3. Стэк</h3>
</article>


<!-- 3.1 Проверка правильности скобочной последовательности -->
<article class="article">
  <div class="anchor" id="t3_1"></div>
  <h3>3.1 Проверка правильности скобочной последовательности</h3>

  <p><a href="https://leetcode.com/problems/valid-parentheses/">https://leetcode.com/problems/valid-parentheses/</a></p>

  <p>Дана строка `s`, состоящая из символов `'('`, `')'`, `'{'`, `'}'`, `'['` и `']'`. Необходимо определить, является ли входная строка правильной скобочной последовательностью.</p>

  <p>Скобочная последовательность считается правильной, если:</p>

  <p>- Каждая открывающая скобка закрывается соответствующей ей закрывающей скобкой того же типа.</p>
  <p>- Открывающие скобки должны быть закрыты в правильном порядке.</p>
  <p>- Каждая закрывающая скобка имеет соответствующую ей открывающую скобку того же типа.</p>
</article>


<!-- 3.2 Дневные температуры -->
<article class="article">
  <div class="anchor" id="t3_2"></div>
  <h3>3.2 Дневные температуры</h3>

  <p><a href="https://leetcode.com/problems/daily-temperatures/">https://leetcode.com/problems/daily-temperatures/</a></p>

  <p>Дан массив целых чисел temperatures, представляющий ежедневные температуры, вернуть массив ответов answer, такой что answer[i] это количество дней, которые необходимо ждать после i-го дня, чтобы получить более теплую температуру. Если нет будущего дня, на который это возможно, то для этого случая answer[i] == 0.</p>
</article>


<!-- 3.3 Минимальный стэк -->
<article class="article">
  <div class="anchor" id="t3_3"></div>
  <h3>3.3 Минимальный стэк</h3>

  <p><a href="https://leetcode.com/problems/min-stack/">https://leetcode.com/problems/min-stack/</a></p>

  <p>Необходимо создать стек, который поддерживает операции добавления, удаления, получения верхнего элемента и получения минимального элемента за константное время.</p>

  <p>Необходимо реализовать класс MinStack со следующими методами:</p>

  <p>- MinStack() - конструктор класса;</p>
  <p>- void push(int val) - добавляет элемент val на вершину стека;</p>
  <p>- void pop() - удаляет элемент, находящийся на вершине стека;</p>
  <p>- int top() - возвращает верхний элемент стека;</p>
  <p>- int getMin() - возвращает минимальный элемент стека.</p>

  <p>Все методы должны работать за O(1) время.</p>
</article>


<!-- 3.4 Вычислить арифметическое выражение в обратной польской записи -->
<article class="article">
  <div class="anchor" id="t3_4"></div>
  <h3>3.4 Вычислить арифметическое выражение в обратной польской записи</h3>

  <p><a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/">https://leetcode.com/problems/evaluate-reverse-polish-notation/</a></p>

  <p>Дан массив строк `tokens`, который представляет арифметическое выражение в обратной польской записи.</p>

  <p>Необходимо вычислить выражение и вернуть целое число, которое представляет его значение.</p>

  <p>Обратите внимание на следующее:</p>

  <p>- Допустимые операторы: `+`, ``, `` и `/`.</p>
  <p>- Каждый операнд может быть целым числом или другим выражением.</p>
  <p>- Деление между двумя целыми числами всегда округляется в сторону нуля.</p>
  <p>- Не будет деления на ноль.</p>
  <p>- Ввод представляет собой допустимое арифметическое выражение в обратной польской записи.</p>
  <p>- Ответ и все промежуточные вычисления могут быть представлены в 32-битном целом числе.</p>
</article>


<!-- 3.5 Генерация правильных скобочных последовательностей -->
<article class="article">
  <div class="anchor" id="t3_5"></div>
  <h3>3.5 Генерация правильных скобочных последовательностей</h3>

  <p><a href="https://leetcode.com/problems/generate-parentheses/">https://leetcode.com/problems/generate-parentheses/</a></p>

  <p>Дано n пар скобок. Напишите функцию, которая генерирует все возможные комбинации правильных скобочных последовательностей.</p>

  <h4>Объяснение</h4>
  <p>Необходимо написать функцию `generate_parentheses(n: int) -> List[str]`, которая будет принимать на вход целое число `n` - количество пар скобок, и возвращать список строк - все возможные правильные скобочные последовательности.</p>

  <h4>Подробное объяснение</h4>
  <p>Правильная скобочная последовательность - это последовательность скобок, которая удовлетворяет следующим условиям:</p>
  <p>1. Количество открывающих и закрывающих скобок совпадает.</p>
  <p>2. Скобки расположены таким образом, что каждая открывающая скобка имеет соответствующую закрывающую скобку, и наоборот.</p>
  <p>Например, для `n=3` возможны следующие правильные скобочные последовательности:</p>
  <code>"((()))"</code>
  <code>"(()())"</code>
  <code>"(())()"</code>
  <code>"()(())"</code>
  <code>"()()()"</code>
</article>


<!-- 3.6 Количество автомобильных флотов -->
<article class="article">
  <div class="anchor" id="t3_6"></div>
  <h3>3.6 Количество автомобильных флотов</h3>

  <p><a href="https://leetcode.com/problems/car-fleet/">https://leetcode.com/problems/car-fleet/</a></p>

  <p>Даны два массива целых чисел `position` и `speed`, оба длиной `n`, где `position[i]` - это позиция `i`-ой машины, а `speed[i]` - скорость `i`-ой машины (в милях в час). Все `n` машин движутся в одном направлении по однополосной дороге к некоторому пункту назначения на расстоянии `target` миль.</p>

  <p>Машина никогда не может обогнать другую машину впереди, но может догнать ее и ехать бампером к бамперу с той же скоростью. Быстрейшая машина замедлит ход до скорости самой медленной машины. Расстояние между этими двумя автомобилями игнорируется (т. е. предполагается, что они имеют одинаковую позицию).</p>

  <p>Автомобильный флот - это какое-либо непустое множество машин, движущихся на одной позиции и со скоростью. Обратите внимание, что одиночная машина также является автомобильным флотом.</p>

  <p>Если машина догоняет автомобильный флот прямо в точке назначения, ее все равно считают одним автомобильным флотом.</p>

  <p>Необходимо вернуть количество автомобильных флотов, которые прибудут в пункт назначения.</p>
</article>


<!-- 3.7 Нахождение площади наибольшего прямоугольника в гистограмме -->
<article class="article">
  <div class="anchor" id="t3_7"></div>
  <h3>3.7 Нахождение площади наибольшего прямоугольника в гистограмме</h3>

  <p><a href="https://leetcode.com/problems/largest-rectangle-in-histogram/">https://leetcode.com/problems/largest-rectangle-in-histogram/</a></p>

  <p>Дан массив целых чисел `heights`, который представляет высоту столбцов гистограммы, где ширина каждого столбца равна 1. Требуется найти площадь наибольшего прямоугольника в гистограмме.</p>

  <h4>Входные данные:</h4>
  <p>массив целых чисел `heights`, где 1 &lt;= len(heights) &lt;= $10^4$ и 0 &lt;= heights[i] &lt;= $10^4$  .</p>

  <h4>Выходные данные:</h4>
  <p>целое число - площадь наибольшего прямоугольника в гистограмме.</p>
</article>


<!-- 4. Метод скользящего окна -->
<article class="article">
  <div class="anchor" id="t4"></div>
  <h3>4. Метод скользящего окна</h3>
</article>


<!-- 4.1 Лучшее время для покупки и продажи акций -->
<article class="article">
  <div class="anchor" id="t4_1"></div>
  <h3>4.1 Лучшее время для покупки и продажи акций</h3>

  <p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">https://leetcode.com/problems/best-time-to-buy-and-sell-stock/</a></p>

  <p>Дан массив цен на акции, где prices[i] - цена акции в i-й день.
    Вы хотите максимизировать свою прибыль, выбрав один день для покупки одной акции и выбрав другой день в будущем для продажи этой акции. Необходимо найти максимальную прибыль, которую можно получить от покупки одной акции в любой день и продажи ее в другой день. Если прибыль получить невозможно, то вернуть 0.</p>
</article>


<!-- 4.2 Перестановка в строке -->
<article class="article">
  <div class="anchor" id="t4_2"></div>
  <h3>4.2 Перестановка в строке</h3>

  <p><a href="https://leetcode.com/problems/permutation-in-string/">https://leetcode.com/problems/permutation-in-string/</a></p>

  <p>Даны две строки s1 и s2. Необходимо написать программу, которая вернет `True`, если вторая строка s2 содержит перестановку s1, и `False` в противном случае. Другими словами, необходимо вернуть `True`, если хотя бы одна перестановка s1 является подстрокой s2.</p>
</article>


<!-- 4.3 Самая длинная повторяющаяся замена символа -->
<article class="article">
  <div class="anchor" id="t4_3"></div>
  <h3>4.3 Самая длинная повторяющаяся замена символа</h3>

  <p><a href="https://leetcode.com/problems/longest-repeating-character-replacement/">https://leetcode.com/problems/longest-repeating-character-replacement/</a></p>

  <p>Дана строка s и целое число k. Вы можете выбрать любой символ строки и изменить его на любой другой символ в верхнем регистре английского алфавита. Вы можете выполнить эту операцию не более k раз.</p>

  <p>Вернуть длину самой длинной подстроки, содержащей ту же букву, которую вы можете получить после выполнения вышеуказанных операций.</p>

  <p>- Строка s содержит только буквы английского алфавита в нижнем регистре.</p>
  <p>- 1 &lt;= s.length &lt;= 10^5</p>
  <p>- 0 &lt;= k &lt;= s.length</p>
</article>


<!-- 4.4 Самая длинная подстрока без повторяющихся символов -->
<article class="article">
  <div class="anchor" id="t4_4"></div>
  <h3>4.4 Самая длинная подстрока без повторяющихся символов</h3>

  <p><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">https://leetcode.com/problems/longest-substring-without-repeating-characters/</a></p>

  <p>Дана строка s. Необходимо найти длину самой длинной подстроки без повторяющихся символов.</p>
</article>


<!-- 4.5 Максимальное количество скользящих окон -->
<article class="article">
  <div class="anchor" id="t4_5"></div>
  <h3>4.5 Максимальное количество скользящих окон</h3>

  <p><a href="https://leetcode.com/problems/sliding-window-maximum/">https://leetcode.com/problems/sliding-window-maximum/</a></p>

  <p>Дан массив целых чисел nums, имеется скользящее окно размера k, которое движется с самого левого края массива в самый правый. Вы можете видеть только k чисел в окне. Каждый раз, когда скользящее окно движется вправо на одну позицию, нужно вернуть максимальное значение в текущем окне.</p>

  <p>Напишем функцию `max_sliding_window(nums: List[int], k: int) -> List[int]`, которая принимает массив целых чисел `nums` и размер скользящего окна `k`, и возвращает список максимальных значений для каждого окна, двигающегося на одну позицию вправо.</p>
</article>


<!-- 4.6 Минимальная подстрока окна -->
<article class="article">
  <div class="anchor" id="t4_6"></div>
  <h3>4.6 Минимальная подстрока окна</h3>

  <p><a href="https://leetcode.com/problems/minimum-window-substring/">https://leetcode.com/problems/minimum-window-substring/</a></p>

  <p>Даны две строки s и t длинами m и n соответственно. Необходимо найти минимальную подстроку s, которая содержит все символы из t (включая повторяющиеся символы). Если такой подстроки не существует, вернуть пустую строку "".</p>

  <p>Тестовые примеры будут сгенерированы таким образом, что ответ будет единственным.</p>

  <p>Для решения задачи необходимо написать функцию с именем `min_window_substring(s: str, t: str) -> str`, которая принимает на вход две строки s и t, и возвращает минимальную подстроку, содержащую все символы из t. Если такой подстроки не существует, вернуть пустую строку.</p>
</article>


<!-- 5. Связный список -->
<article class="article">
  <div class="anchor" id="t5"></div>
  <h3>5. Связный список</h3>
</article>


<!-- 5.1 Цикл в связном списке -->
<article class="article">
  <div class="anchor" id="t5_1"></div>
  <h3>5.1 Цикл в связном списке</h3>

  <p><a href="https://leetcode.com/problems/linked-list-cycle/">https://leetcode.com/problems/linked-list-cycle/</a></p>

  <p>Дано: head - начало связного списка.</p>

  <p>Нужно определить, есть ли цикл в связном списке. Цикл в связном списке есть, если существует узел в списке, к которому можно вернуться, последовательно следуя указателям на следующий узел. Внутренне, pos используется для обозначения индекса узла, к которому подключен указатель на хвост. Обратите внимание, что pos не передается в качестве параметра.</p>

  <p>Функция должна вернуть True, если в связном списке есть цикл. В противном случае, вернуть False.</p>

  <p>Например, у нас есть связный список 1 -> 2 -> 3 -> 4 -> 2, то это означает, что есть цикл в связном списке, так как узел со значением 2 может быть достигнут снова, последовательно переходя по указателям на следующий узел.</p>

  <details>
    <summary>Решение</summary>
    <p>Для решения этой задачи можно использовать алгоритм "быстрый заяц и медленная черепаха" (Floyd's cycle-finding algorithm). Алгоритм заключается в том, чтобы использовать два указателя, один быстрый (быстрый заяц), который двигается по списку на два узла за одну итерацию, и один медленный (медленная черепаха), который двигается на один узел за итерацию. Если в связном списке есть цикл, то быстрый указатель рано или поздно догонит медленный указатель.</p>

    <h4>Пример</h4>
    <p>Допустим, у нас есть связный список 1 -> 2 -> 3 -> 4 -> 2. Медленный указатель начинает с узла 1, а быстрый указатель начинает с узла 2. На первой итерации медленный указатель двигается на узел 2, а быстрый указатель двигается на узел 4. На второй итерации медленный указатель перемещается на узел 3, а быстрый указатель перемещается на узел 2. На третьей итерации медленный указатель перемещается на узел 4, а быстрый указатель перемещается на узел 4. Медленный указатель и быстрый указатель встречаются на узле 4, что означает, что в связном списке есть цикл.</p>
  </details>
</article>


<!-- 5.2 Объединить два отсортированных списка -->
<article class="article">
  <div class="anchor" id="t5_2"></div>
  <h3>5.2 Объединить два отсортированных списка</h3>

  <p><a href="https://leetcode.com/problems/merge-two-sorted-lists/">https://leetcode.com/problems/merge-two-sorted-lists/</a></p>

  <p>Даны начала двух отсортированных связных списков list1 и list2.</p>

  <p>Необходимо объединить эти два списка в один отсортированный список, соединив узлы первых двух списков.</p>

  <p>Вернуть начало объединенного связного списка.</p>

  <p>- Начала двух связных списков list1 и list2 не пустые.</p>
</article>


<!-- 5.3 Обратный связный список -->
<article class="article">
  <div class="anchor" id="t5_3"></div>
  <h3>5.3 Обратный связный список</h3>

  <p><a href="https://leetcode.com/problems/reverse-linked-list/">https://leetcode.com/problems/reverse-linked-list/</a></p>

  <p>Дано начало односвязного списка. Необходимо перевернуть список и вернуть его перевернутый вид.</p>

  <p>Например, если дан список 1 -> 2 -> 3 -> 4 -> 5, то после переворота он станет 5 -> 4 -> 3 -> 2 -> 1.</p>
</article>


<!-- 5.4 Least Recently Used (LRU) кэш -->
<article class="article">
  <div class="anchor" id="t5_4"></div>
  <h3>5.4 Least Recently Used (LRU) кэш</h3>

  <p><a href="https://leetcode.com/problems/lru-cache/">https://leetcode.com/problems/lru-cache/</a></p>

  <p>Необходимо реализовать структуру данных, которая соответствует ограничениям LRU-кэша.</p>

  <p>Необходимо реализовать класс LRUCache с методами:</p>

  <p>- LRUCache(capacity) - конструктор класса, инициализирующий кэш с размером capacity.</p>
  <p>- get(key) - возвращает значение ключа, если ключ существует, иначе возвращает -1.</p>
  <p>- put(key, value) - обновляет значение ключа, если ключ существует. В противном случае добавляет пару ключ-значение в кэш. Если количество ключей превышает capacity, удаляет из кэша наименее используемый ключ.</p>

  <p>Функции get и put должны иметь временную сложность O(1) в среднем.</p>

  <h4>Подробное описание</h4>

  <p>LRU-кэш - это особый тип кэша, в котором элементы, к которым дольше всего не было обращений, удаляются из кэша, когда он заполнен.</p>

  <p>В данной задаче необходимо реализовать класс LRUCache, который будет иметь методы get и put, работающие за O(1) в среднем.</p>

  <p>Метод get должен возвращать значение ключа, если он существует в кэше, иначе -1.</p>

  <p>Метод put должен обновлять значение ключа, если ключ уже существует в кэше, или добавлять новую пару ключ-значение, если ключа еще нет в кэше. Если после добавления новой пары количество ключей в кэше превышает заданный размер capacity, необходимо удалить из кэша наименее используемый ключ. Метод put также должен работать за O(1) в среднем.</p>
</article>


<!-- 5.5 Найдите повторяющееся число -->
<article class="article">
  <div class="anchor" id="t5_5"></div>
  <h3>5.5 Найдите повторяющееся число</h3>

  <p><a href="https://leetcode.com/problems/find-the-duplicate-number/">https://leetcode.com/problems/find-the-duplicate-number/</a></p>

  <p>Дан массив `nums` из `n + 1` целых чисел, где каждое число находится в диапазоне от `1` до `n` включительно. В массиве есть только одно повторяющееся число, найдите его и верните.</p>

  <p>Необходимо решить задачу, не изменяя массив `nums` и используя только константное дополнительное пространство.</p>
</article>


<!-- 5.6 Сложите два числа -->
<article class="article">
  <div class="anchor" id="t5_6"></div>
  <h3>5.6 Сложите два числа</h3>

  <p><a href="https://leetcode.com/problems/add-two-numbers/">https://leetcode.com/problems/add-two-numbers/</a></p>

  <p>Дано два не пустых связанных списка, представляющих два неотрицательных целых числа. Цифры хранятся в обратном порядке, и каждый из их узлов содержит одну цифру. Сложите два числа и верните сумму в виде связанного списка.</p>

  <p>Можно предположить, что два числа не содержат ведущего нуля, кроме числа 0.</p>
</article>


<!-- 5.7 Скопировать список со случайным указателем -->
<article class="article">
  <div class="anchor" id="t5_7"></div>
  <h3>5.7 Скопировать список со случайным указателем</h3>

  <p><a href="https://leetcode.com/problems/copy-list-with-random-pointer/">https://leetcode.com/problems/copy-list-with-random-pointer/</a></p>

  <p>Дан связный список длины n, каждый узел которого содержит дополнительный случайный указатель, который может указывать на любой узел в списке или null.</p>

  <p>Постройте глубокую копию списка. Глубокая копия должна состоять ровно из n новых узлов, где каждый новый узел имеет свое значение, установленное в значение соответствующего исходного узла. Как указатель на следующий, так и случайный указатель новых узлов должны указывать на новые узлы в скопированном списке таким образом, что указатели в исходном списке и скопированном списке представляют одно и то же состояние списка. Ни один из указателей в новом списке не должен указывать на узлы в исходном списке.</p>

  <p>Например, если в исходном списке есть два узла X и Y, где X.random --> Y, то для соответствующих двух узлов x и y в скопированном списке x.random --> y.</p>

  <p>Вернуть голову скопированного связного списка.</p>

  <p>Связный список представлен вводом / выводом в виде списка n узлов. Каждый узел представлен в виде пары [val, random_index], где:</p>

  <p>val: целое число, представляющее Node.val
random_index: индекс узла (от 0 до n-1), на который указывает случайный указатель, или null, если он не указывает на какой-либо узел.</p>

  <p>Ваш код будет получать только голову исходного связного списка.</p>

  <h4>Примеры:</h4>
  <code>Входные данные: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</code>
  <code>Выходные данные: [[7,null],[13,0],[11,4],[10,2],[1,0]]</code>
  <code>Входные данные: head = [[1,1],[2,1]]</code>
  <code>Выходные данные: [[1,1],[2,1]]</code>
</article>


<!-- 5.8 Удалить N-й узел из конца списка -->
<article class="article">
  <div class="anchor" id="t5_8"></div>
  <h3>5.8 Удалить N-й узел из конца списка</h3>

  <p><a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/">https://leetcode.com/problems/remove-nth-node-from-end-of-list/</a></p>

  <p>Дано начало связного списка. Необходимо удалить n-ый элемент с конца списка и вернуть его начало.</p>

  <p>Для решения задачи необходимо реализовать функцию `remove_nth_from_end(head: ListNode, n: int) -> ListNode`, где:</p>

  <p>- `head` - начало связного списка, где `ListNode` - класс элемента связного списка, содержащий следующие поля:</p>
  <p>- `val` - значение текущего элемента связного списка;</p>
  <p>- `next` - указатель на следующий элемент связного списка;</p>
  <p>- `n` - номер элемента, который необходимо удалить с конца списка.</p>
</article>


<!-- 5.9 Изменить порядок в списке -->
<article class="article">
  <div class="anchor" id="t5_9"></div>
  <h3>5.9 Изменить порядок в списке</h3>

  <p><a href="https://leetcode.com/problems/reorder-list/">https://leetcode.com/problems/reorder-list/</a></p>

  <p>Дана голова односвязного списка, который можно представить в виде:</p>
  <code>L0 → L1 → … → Ln - 1 → Ln</code>

  <p>Необходимо переупорядочить элементы списка в следующем порядке:</p>
  <code>L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …</code>

  <p>Значения в узлах списка изменять нельзя. Можно изменять только сами узлы.</p>
</article>


<!-- 5.10 Обратные узлы в k-группе -->
<article class="article">
  <div class="anchor" id="t5_10"></div>
  <h3>5.10 Обратные узлы в k-группе</h3>

  <p><a href="https://leetcode.com/problems/reverse-nodes-in-k-group/">https://leetcode.com/problems/reverse-nodes-in-k-group/</a></p>

  <p>Дано начало связанного списка. Реверсируйте узлы связанного списка по k элементов и верните измененный список.</p>
  <p>k - положительное целое число и не превышает длину связанного списка. Если количество узлов в списке не кратно k, то оставшиеся узлы в конце должны остаться без изменений.</p>
  <p>Вы не можете изменять значения узлов в списке, только сами узлы могут быть изменены.</p>

  <h4>Объянение</h4>
  <p>Для решения данной задачи необходимо реализовать функцию, которая принимает на вход начало связанного списка и число k. Функция должна реверсировать узлы списка по k элементов и вернуть измененный список.</p>

  <h4>Примеры</h4>
  <p>Пример 1:</p>
  <code>Вход: head = [1,2,3,4,5], k = 2</code>
  <code>Выход: [2,1,4,3,5]</code>

  <p>Пример 2:</p>
  <code>Вход: head = [1,2,3,4,5], k = 3</code>
  <code>Выход: [3,2,1,4,5]</code>
</article>


<!-- 5.11 Объединить k отсортированных списков -->
<article class="article">
  <div class="anchor" id="t5_11"></div>
  <h3>5.11 Объединить k отсортированных списков</h3>

  <p><a href="https://leetcode.com/problems/merge-k-sorted-lists/">https://leetcode.com/problems/merge-k-sorted-lists/</a></p>

  <p>Дан массив lists состоящий из k связных списков, каждый из которых отсортирован по возрастанию. Необходимо объединить все связные списки в один отсортированный связный список и вернуть его.</p>

  <h4>Пример</h4>
  <p>Входные данные:</p>
  <code>lists = [[1,4,5],[1,3,4],[2,6]]</code>
  <p>Результат:</p>
  <code>[1,1,2,3,4,4,5,6]</code>
</article>


<!-- 6. Деревья -->
<article class="article">
  <div class="anchor" id="t6"></div>
  <h3>6. Деревья</h3>
</article>


<!-- 6.1 Поиск поддерева в бинарном дереве -->
<article class="article">
  <div class="anchor" id="t6_1"></div>
  <h3>6.1 Поиск поддерева в бинарном дереве</h3>

  <p><a href="https://leetcode.com/problems/subtree-of-another-tree/">https://leetcode.com/problems/subtree-of-another-tree/</a></p>

  <p>Даны корни двух бинарных деревьев `root` и `subRoot`. Необходимо вернуть `true`, если в дереве `root` есть поддерево с такой же структурой и значениями узлов как в `subRoot`, и `false` в противном случае.</p>

  <p>Поддерево бинарного дерева - это дерево, состоящее из узла в дереве и всех его потомков. Дерево `tree` также может рассматриваться как поддерево самого себя.</p>
</article>

