<h1>Алгоритмы сортировки</h1>


<!-- Содержание -->
<div class="article">
  <h2>Сортировка</h2>
  <ol>
    <li><a href="#sort-bubble">Сортировка пузырьком (Bubble Sort)</a></li>
    <li><a href="#sort-cocktail">Сортировка перемешиванием (шейкерная сортировка) (Cocktail sort)</a></li>
    <li><a href="#sort-comb">Сортировка расчёской (Comb sort)</a></li>
    <li><a href="#sort-insertion">Сортировка вставками (Insertion Sort)</a></li>
    <li><a href="#sort-selection">Сортировка выбором (Selection sort)</a></li>
    <li><a href="#sort-shell">Сортировка Шелла (Shell Sort)</a></li>
    <li><a href="#sort-count">Сортировка подсчетом (Counting Sort)</a></li>
    <li><a href="#sort-merge">Сортировка слиянием (Merge Sort)</a></li>
    <li><a href="#sort-heap">Пирамидальная сортировка (сортировка кучей) (HeapSort)</a></li>
    <li><a href="#sort-quick">Быстрая сортировка Хоара (Quick Sort)</a></li>
    <li><a href="#sort-gnome">Гномья сортировка (Gnome Sort)</a></li>
  </ol>
</div>


<!-- 1. Сортировка пузырьком (Bubble Sort) -->
<article class="article">
  <div class="anchor" id="sort-bubble"></div>
  <h3>1. Сортировка пузырьком (Bubble Sort)</h3>
  <p><strong>Сортировка пузырьком (Bubble Sort)</strong> — это простой алгоритм сортировки, который последовательно сравнивает соседние элементы массива и меняет их местами, если они находятся в неправильном порядке. Этот процесс повторяется до тех пор, пока массив не будет полностью отсортирован.</p>
  <p>Вот пример реализации сортировки пузырьком на языке JavaScript:</p>
<pre>
function bubbleSort(arr) {
  let n = arr.length;
  let swapped;
  do {
    swapped = false;
    for (let i = 0; i &lt; n - 1; i++) {
      if (arr[i] > arr[i + 1]) {
        // Меняем элементы местами
        let temp = arr[i];
        arr[i] = arr[i + 1];
        arr[i + 1] = temp;
        swapped = true;
      }
    }
    // Уменьшаем n, так как самый большой элемент уже на своем месте
    n--;
  } while (swapped);
  return arr;
}

// Пример использования:
let array = [64, 34, 25, 12, 22, 11, 90];
console.log("Неотсортированный массив:", array);
let sortedArray = bubbleSort(array);
console.log("Отсортированный массив:", sortedArray);
</pre>
  <p>Как это работает:</p>
  <ol>
    <li>Алгоритм проходит по массиву и сравнивает каждую пару соседних элементов.</li>
    <li>Если элементы находятся в неправильном порядке (например, arr[i] > arr[i + 1]), они меняются местами.</li>
    <li>Этот процесс повторяется до тех пор, пока не будет выполнено ни одного обмена за полный проход по массиву, что означает, что массив отсортирован.</li>
    <li>После каждого прохода самый большой элемент "всплывает" в конец массива, поэтому количество сравниваемых элементов можно уменьшить на 1 после каждого прохода.</li>
  </ol>
  <p>Временная сложность:</p>
  <p>В худшем и среднем случае: O(n²), где n — количество элементов в массиве.</p>
  <p>В лучшем случае (если массив уже отсортирован): O(n).</p>
  <p>Сортировка пузырьком не является самым эффективным алгоритмом для больших массивов, но она проста в реализации и понимании.</p>
</article>


<!-- 2. Сортировка перемешиванием (шейкерная сортировка) (Cocktail sort) -->
<article class="article">
  <div class="anchor" id="sort-cocktail"></div>
  <h3>2. Сортировка перемешиванием (шейкерная сортировка) (Cocktail sort)</h3>
  <p>Шейкерная сортировка отличается от пузырьковой тем, что она двунаправленная: алгоритм перемещается не строго слева направо, а сначала слева направо, затем справа налево.</p>
  <p>Начинаем мы точно так же, как и в пузырьковой сортировке, и “выдавливаем наверх” максимальный элемент. После этого, разворачиваемся и “толкаем вниз” минимальный из оставшийся элементов.</p>
  <p>Оказавшись в начале массива, на своих местах будет уже 2 элемента - первый и последний. Остановимся когда дойдем до середины массива. Таким образом сделаем в 2 раза меньше итераций внешнего цикла. За счет этого скорость шейкерной сортировки будет немного выше, чем у обычного пузырька.</p>
  <p>Начнем с небольшого рефакторинга и вынесем функцию обмена наружу. Назовем ее swap</p>
<pre>function swap(arr, i, j) {
  let temp = arr[j];
  arr[j] = arr[i];
  arr[i] = temp;
}

function cocktailSort(arr) {
  let left = 0;
  let right = arr.length - 1;
  let isSwap = false;
  while(left &lt; right) {
    for (let i = left; i &lt; right; i++) {
      if (arr[i] &gt; arr[i + 1]) {
        swap(arr, i, i + 1);
        isSwap = true;
      }
    }
    if (!isSwap) {
      return arr;
    }
    isSwap = false;
    right--;
    for (let i = right; i &gt; left; i--) {
      if (arr[i] &lt; arr[i - 1]) {
        swap(arr, i, i - 1);
        isSwap = true;
      }
    }
    if (!isSwap) {
      return arr;
    }
    isSwap = false;
    left++;
  }
  return arr;
}</pre>
</article>


<!-- 3. Сортировка расчёской (Comb sort) -->
<article class="article">
  <div class="anchor" id="sort-sort"></div>
  <h3>3. Сортировка расчёской (Comb sort)</h3>
  <p>Сортировка расчёской — улучшение сортировки пузырьком. Её идея состоит в том, чтобы «устранить» элементы с небольшими значения в конце массива, которые замедляют работу алгоритма. Если при пузырьковой и шейкерной сортировках при переборе массива сравниваются соседние элементы, то при «расчёсывании» сначала берётся достаточно большое расстояние между сравниваемыми значениями, а потом оно сужается вплоть до минимального.</p>
  <p>Первоначальный разрыв нужно выбирать не случайным образом, а с учётом специальной величины — фактора уменьшения, оптимальное значение которого равно 1,247. Сначала расстояние между элементами будет равняться размеру массива, поделённому на 1,247. После каждого прохода расстояние делится на фактор уменьшения и таким образом получается новое значение. В конце концов оно сужается до минимального значения - единицы, и массив просто досортировывается обычным "пузырьком".</p>
<pre>// исходный массив
  var arr = [3,14,1,7,9,8,11,6,4,2]

  // получаем длину массива
  const l = arr.length;

  // оптимальное число для вычисления шага сравнения
  const factor = 1.247;

  // получаем точный шаг сравнения
  let gapFactor = l / factor;

  // пока шаг больше единицы
  while (gapFactor &gt; 1) {
      // округляем шаг до целого
      const gap = Math.round(gapFactor);
      // и организуем цикл как в пузырьковой сортировке
      for (let i = 0, j = gap; j &lt; l; i++, j++) {
          // если сначала идёт большое число
          if (arr[i] &gt; arr[j]) {
              // меняем их местами
              [arr[i], arr[j]] = [arr[j], arr[i]];
          }

          // выводим текущее состояние массива в консоль
          // это необязательный шаг, он здесь для наглядности
          console.log(arr);
      }
      // в конце цикла рассчитываем новый шаг
      gapFactor = gapFactor / factor;
  }</pre>
  <p>Расчёска лучше пузырьковой сортировки, потому что в ней намного меньше операций перестановки. Именно перестановка занимает основное время процессора. В самом худшем случае алгоритм сортировки расчёской будет работать так же, как и пузырьковая, а в среднем — алгоритм работает быстрее пузырьковой.</p>
</article>


<!-- 4. Сортировка вставками (Insertion Sort) -->
<article class="article">
  <div class="anchor" id="sort-insertion"></div>
  <h3>4. Сортировка вставками (Insertion Sort)</h3>
  <p>При сортировке вставками массив постепенно перебирается слева направо. При этом каждый последующий элемент размещается так, чтобы он оказался между ближайшими элементами с минимальным и максимальным значением.</p>
<pre>function insertionSort(inputArr) {
  let n = inputArr.length;
  for (let i = 1; i &lt; n; i++) {

  // выбираем первый элемент в неотсортированном массиве
  let current = inputArr[i];

  // последний элемент отсортированного массива
  let j = i-1;
  while ((j &gt; -1) && (current &lt; inputArr[j])) {
  inputArr[j+1] = inputArr[j];
  j--;
  }
  inputArr[j+1] = current;
  }
  return inputArr;
}</pre>
  <p>Итерация начинается со второго элемента. Считаем отсортированным по умолчанию первый элемент. Для каждой итерации мы отслеживаем current элемент. Каждый current элемент будет первым элементом несортированного массива - и каждый элемент перед ним будет принадлежать отсортированному массиву.</p>
  <p>Через в while цикла, мы проходим отсортированный массив и сдвиг элементы вправо, открывая пространство для current элемента должны быть вставлено.</p>
  <p>Как только мы найдем для него подходящее место, current элемент вставляется во вновь открытый слот. Этот процесс повторяется для каждой итерации, пока массив не будет отсортирован.</p>
</article>


<!-- 5. Сортировка выбором (Selection sort) -->
<article class="article">
  <div class="anchor" id="sort-selection"></div>
  <h3>5. Сортировка выбором (Selection sort)</h3>
  <p>Сортировка выбором начинается с поиска наименьшего элемента в списке и обмена его с первым элементом (таким образом, наименьший элемент помещается в окончательную позицию в отсортированном массиве). Затем мы сканируем массив, начиная со второго элемента, в поисках наименьшего среди оставшихся n-1 элементов и обмениваем найденный наименьший элемент со вторым, т.е. помещаем второй наименьший элемент в окончательную позицию в отсортированном массиве. В общем случае, при i-ом проходе по списку (0 &lt;= i &lt;= n-2) алгоритм ищет наименьший элемент среди последних n-i элементов и обменивает его с A[ i ]. После выполнения n-1 проходов список оказывается отсортирован.</p>
  <p>После каждой итерации необходимо проверять на один элемент меньше, пока не будет отсортирован весь массив или список.</p>
<pre>function selectionSort(arr) {
  for(let i = 0; i &lt; arr.length - 1; i++) {
    // Пусть в начальном индексе наименьшее число
    let min = i;
    // Сравним его со всеми числами справа и найдем наименьшее
    for(let j = i + 1; j &lt; arr.length; j++) {
      if(arr[j] &lt; arr[min]) {
        min = j;
      }
    }
    if (min !== i) {
      // Заменяем элементы
      let tmp = arr[i];
      arr[i] = arr[min];
      arr[min] = tmp;
    }
  }
  return arr;
}</pre>
</article>


<!-- 6. Сортировка Шелла (Shell Sort) -->
<article class="article">
  <div class="anchor" id="sort-shell"></div>
  <h3>6. Сортировка Шелла (Shell Sort)</h3>

<pre>function ShellSort(A)
  {
      var n = A.length, i = Math.floor(n/2);
      while (i &gt; 0)
       { for (var j = 0; j &lt; n; j++)
          { var k = j, t = A[j];
            while (k &gt;= i && A[k-i] > t)
             { A[k] = A[k-i]; k -= i; }
            A[k] = t;
          }
        i = (i==2) ? 1 : Math.floor(i*5/11);
       }
      return A;
  }</pre>
</article>


<!-- 7. Сортировка подсчетом (Counting Sort) -->
<article class="article">
  <div class="anchor" id="sort-count"></div>
  <h3>7. Сортировка подсчетом (Counting Sort)</h3>

  <p>Вначале для каждого элемента массива подсчитывается количество элементов, меньших, чем он, и на основе этой информации текущий элемент помещается в соответствующее место отсортированного массива. </p>
<pre>function SimpleCountingSort(A) {
  var n = A.length, Count = [], B = [];
  for (var i = 0; i &lt; n; i++) Count[ i ] = 0;
  for (var i = 0; i &lt; n-1; i++)
    { for (var j = i+1; j &lt; n; j++)
      { if (A[ i ] &lt; A[j]) Count[j]++;
        else Count[ i ]++;
      }
    }
  for (var i = 0; i &lt; n; i++) B[Count[ i ]] = A[ i ];
  return B;
}</pre>
</article>


<!-- 8. Сортировка слиянием (Merge Sort) -->
<article class="article">
  <div class="anchor" id="sort-merge"></div>
  <h3>8. Сортировка слиянием (Merge Sort)</h3>

  <p>Сложность линейно-логарифмическая O(N*logN). logN разбиений на половины. Итерация по массиву при каждом разбиении.</p>
  <p>Для реализации сортировки понадобится вспомогательный массив - это еще O(N) по памяти.</p>
  <p>Сортировка слиянием использует принцип - разделяй и властвуй. Тот же самый принцип реализует бинарный поиск. Мы делим массив на две группы, потом каждую группу на две группы и так далее. Пока у нас не останутся пары. Берем первую пару и сравниваем элементы между собой и меняем их порядок. То же самое со второй парой. Потом эти две пары объединяем в четверку элементов, сравниваем и меняем порядок. И так далее.</p>
<pre>function Merge(a,low,mid,high) {    //Вспомогательная функция.
  var b = new Array(high+1-low), h, i, j = mid+1, k, h = low, i = 0;
  while (h &lt;= mid && j &lt;= high ) {
    if (a[h] &lt;= a[j]) {
      b[ i ]=a[h]; h++;
    } else {
      b[ i ]=a[j]; j++;
    }
    i++;
  }
  if (h &gt; mid) {
    for (k = j; k &lt;= high; k++) {
      b[ i ]=a[k]; i++;
    }
  } else {
    for (k = h; k &lt;= mid; k++) {
      b[ i ]=a[k]; i++;
    }
  }
  for (k=0; k&lt;=high-low; k++) {
    a[k+low]=b[k];
  }
  return a;
}

function MergeSort(A) {     //Функция сортировки слиянияем.
  function merge_sort(a,low,high) {
    if (low &lt; high) {
      var mid = Math.floor((low+high)/2);
      merge_sort(a, low, mid);
      merge_sort(a, mid+1, high);
      Merge(a, low, mid, high);
    }
  }
  var n = A.length;
  merge_sort(A, 0, n-1);
  return A;
}</pre>
</article>


<!-- 9. Пирамидальная сортировка (сортировка кучей) (HeapSort) -->
<article class="article">
  <div class="anchor" id="sort-heap"></div>
  <h3>9. Пирамидальная сортировка (сортировка кучей) (HeapSort)</h3>

<pre>function HeapSort(A) {
  if (A.length == 0) return [];
  var n = A.length, i = Math.floor(n/2), j, k, t;
  while (true)
  { if (i &gt; 0) t = A[--i];
    else { n--;
            if (n == 0) return A;
            t = A[n];  A[n] = A[0];
          }
    j = i;  k = j*2+1;
    while (k &lt; n)
      { if (k+1 &lt; n && A[k+1] &gt; A[k]) k++;
        if (A[k] &gt; t)
        { A[j] = A[k];  j = k;  k = j*2+1; }
        else break;
      }
    A[j] = t;
  }
}</pre>
</article>


<!-- 10. Быстрая сортировка Хоара (Quick Sort) -->
<article class="article">
  <div class="anchor" id="sort-quick"></div>
  <h3>10. Быстрая сортировка Хоара (Quick Sort)</h3>

<pre>function QuickSort(A) {
  if (A.length == 0) return [];
  var a = [], b = [], p = A[0];
  for (var i = 1; i &lt; A.length; i++)
    { if (A[ i ] &lt; p) a[a.length] = A[ i ];
      else b[b.length] = A[ i ];
    }
  return QuickSort(a).concat( p,QuickSort(b) );
}</pre>
</article>


<!-- 11. Гномья сортировка (Gnome Sort) -->
<article class="article">
  <div class="anchor" id="sort-gnome"></div>
  <h3>11. Гномья сортировка (Gnome Sort)</h3>

  <p>Гномья сортировка (англ. Gnome sort) — алгоритм сортировки, похожий на сортировку вставками, но в отличие от последней перед вставкой на нужное место происходит серия обменов, как в сортировке пузырьком.</p>

<pre>function GnomeSort(A) {
  var n = A.length, i = 1, j = 2;
  while (i &lt; n)
    { if (A[i-1] &lt; A[ i ]){ i = j; j++; }
      else
        { var t = A[i-1]; A[i-1] = A[ i ]; A[ i ] = t;
          i--;
          if (i == 0){ i = j; j++; }
        }
    }
  return A;
}</pre>
</article>
