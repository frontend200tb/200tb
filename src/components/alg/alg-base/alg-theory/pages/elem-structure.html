<h1>Структуры данных</h1>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p><a href="#links">links</a></p>
  <p><a href="#struct">Структуры данных</a></p>
  <ol>
    <li><a href="#array">Массив (Array)</a></li>
    <li><a href="#dynamic-array">Динамический массив (Dynamic array)</a></li>
    <li><a href="#queue">Очередь (Queue)</a></li>
    <li><a href="#stack">Стек (Stack)</a></li>
    <li><a href="#deck">Дек (Deck)</a></li>
    <li><a href="#linked-list">Связанный список (Linked list)</a></li>
    <li><a href="#set">Множество (Set)</a></li>
    <li><a href="#map">Карта (Map). Ассоциативный массив, словарь</a></li>
    <li><a href="#hash-tables">Хэш-таблицы (Hash-tables)</a></li>
    <li><a href="#graph">Граф (Graph)</a></li>
    <li><a href="#binary-search-tree">Двоичное дерево поиска (Binary search tree)</a></li>
    <li><a href="#trie">Префиксное дерево (Trie)</a></li>
    <li><a href="#binary-heap">Двоичная куча (Binary heap)</a></li>
  </ol>
  <p><a href="#struct-js">Структуры данных в JS</a></p>
</article>


<!-- links -->
<article class="article">
  <div class="anchor" id="links"></div>
  <h2>links</h2>

  <p><a href="https://practicum.yandex.ru/blog/10-osnovnyh-struktur-dannyh/">10 структур данных, которые должен знать каждый разработчик</a> (Сергей Савельев, Лена Шпрингер 2022.08.10 5 мин)</p>
  <p><a href="https://blog.skillfactory.ru/glossary/struktura-dannyh/">Структура данных</a> (2023.03.25)</p>
</article>


<!-- Структуры данных -->
<article class="article">
  <div class="anchor" id="struct"></div>
  <h2>Структуры данных</h2>

  <p>Структура данных — это способ организации информации для более эффективного использования. В программировании структурой обычно называют набор данных, связанных определённым образом. Например, массив — это структура.</p>
  <p>Со структурой можно работать: добавлять данные, извлекать их и обрабатывать, например изменять, анализировать, сортировать. Для каждой структуры данных — свои алгоритмы. Работа программиста — правильно выбирать уже написанные готовые либо писать свои.</p>
  <p>Главное свойство структур данных в том, что у любой единицы данных должно быть чёткое место, по которому её можно найти. Как определяется это место и как происходит поиск, зависит от конкретной структуры.</p>
  <p>Характеристики структур данных следующие:</p>
  <ul>
    <li>Данные в памяти представлены определённым образом, который однозначно позволяет определить структуру.</li>
    <li>Чаще всего внутрь структуры можно добавить элемент или извлечь оттуда. Это свойство не постоянное — бывают структуры, которые нельзя изменять после создания.</li>
    <li>Существуют алгоритмы, которые позволяют взаимодействовать с этой структурой.</li>
  </ul>
  <p>При этом данных необязательно должно быть много. Массив из одного элемента — уже структура данных.</p>

  <h3>Зачем нужны структуры данных</h3>
  <p>Структуры нужны, чтобы упорядочивать, искать, анализировать и использовать данные с применением алгоритмов программирования.</p>
  <p>Фактически использование структур данных в программировании начинается ещё с задания переменной. Формат переменной — определённая структура данных, так как в память переменная записывается конкретным способом. Но на практике программисты работают с другими структурами, которые объединяют в себе разные переменные и типы данных. Далее приведем описание и классификацию основных структур данных, чтобы было удобнее в них разобраться.</p>
  <p>Структуру данных для работы выбирают в зависимости от задачи. Если нужно что-то простое, подойдёт обычный массив. Когда требуется создать очередь или историю запросов, выбирают связный список или очередь. Если нужен поиск и сортировка, поможет двоичное дерево. Именно поэтому важно знать все типы данных в программировании, чтобы подбирать оптимальный в любой ситуации.</p>
  </article>


<!-- array -->
<article class="article">
  <div class="anchor" id="array"></div>
  <h3>1. Массив (Array)</h3>

  <p>Одна из самых простых структур данных, которая встречается чаще всего. Именно на массивах основаны многие другие структуры данных: списки, стеки, очереди.</p>
  <p>Для простоты восприятия можно считать, что массив — это таблица. Каждый его элемент имеет индекс — «адрес», по которому этот элемент можно извлечь. В большинстве языков программирования индексы начинаются с нуля. То есть первый элемент массива имеет индекс не [1], а [0]. Данные в массиве можно просматривать, сортировать и изменять с помощью специальных операций.</p>
  <p>Массивы бывают двух видов:</p>
  <ul>
    <li>Одномерные. У каждого элемента только один индекс. Можно представить это как строку с данными, где одного номера достаточно, чтобы чётко определить положение каждой переменной.</li>
    <li>Многомерные. У каждого элемента два или больше индексов. По сути, это комбинация из нескольких одномерных массивов, то есть вложенная структура.</li>
  </ul>
  <p>Основное отличие между одномерным и многомерным массивом ― их размерность и способ организации данных. Одномерный массив ― простая линейная структура данных, многомерный ― более сложная структура данных с несколькими измерениями</p>

  <h3>Как применяют массивы:</h3>
  <ul>
    <li>В качестве блоков для более сложных структур данных. Массивы предусмотрены в синтаксисе большинства языков программирования, и на их основе удобно строить другие структуры.</li>
    <li>Для хранения несложных данных небольших объёмов.</li>
    <li>Для сортировки данных.</li>
  </ul>
</article>


<!-- dynamic-array -->
<article class="article">
  <div class="anchor" id="dynamic-array"></div>
  <h3>2. Динамический массив (Dynamic array)</h3>

  <p>В классическом массиве размер задан заранее — мы точно знаем, сколько в нём индексов. А динамический массив — это тот, у которого размер может изменяться. При его создании задаётся максимальная величина и количество заполненных элементов. При добавлении новых элементов они сначала заполняются до максимальной величины, а при превышении сразу создаётся новый массив, с большей максимальной величиной.</p>
  <p>Элементы в динамический массив можно добавлять без ограничений и куда угодно. Однако, если добавлять их в середину, остальные придётся сдвигать, что занимает много времени. Поэтому лучше всего динамический массив работает при добавлении элементов в конце.</p>

  <h3>Как применяют динамические массивы:</h3>
  <ul>
    <li>В качестве блоков для структур данных.</li>
    <li>Для хранения неопределённого количества элементов.</li>
  </ul>
</article>


<!-- queue -->
<article class="article">
  <div class="anchor" id="queue"></div>
  <h3>3. Очередь (Queue)</h3>

  <p>Этот вид структуры представляет собой ряд данных, как и стек. Но в отличие от него она работает по принципу FIFO — First In, First Out (англ. «первым пришёл — первым ушёл»). Данные добавляют в конец, а извлекают из начала.</p>
  <p>В этой структуре данных всегда работают только с первым элементом. Остальные в это время «ждут своей очереди»</p>
  <p>Бывают неклассические, двусторонние очереди. В них можно добавлять элементы и извлекать их из начала и конца структуры. Элементы посередине недоступны.</p>

  <h3>Как применяют очереди:</h3>
  <ul>
    <li>Для реализации очередей, например на доступ к определённому ресурсу.</li>
    <li>Для управления потоками в многопоточных средах.</li>
    <li>Для генерации значений.</li>
    <li>Для создания буферов.</li>
  </ul>
</article>


<!-- stack -->
<article class="article">
  <div class="anchor" id="stack"></div>
  <h3>4. Стек (Stack)</h3>

  <p>Эта структура данных позволяет добавлять и удалять элементы только из начала. Она работает по принципу LIFO — Last In, First Out (англ. «последним пришёл — первым ушёл»). Последний добавленный в стек элемент должен будет покинуть его раньше остальных.</p>
  <p>Просмотреть стек можно целиком, а работать — только с вершиной. Для этого надо удалить или добавить последний элемент</p>

  <h3>Как применяют стеки:</h3>
  <ul>
    <li>Для реализации рекурсии.</li>
    <li>Для вычислений постфиксных значений.</li>
    <li>Для временного хранения данных, например истории запросов или изменений.</li>
  </ul>
</article>


<!-- deck -->
<article class="article">
  <div class="anchor" id="deck"></div>
  <h3>5. Дек (Deck)</h3>

  <p>Деками называют двусторонние очереди: они объединяют возможности и очереди, и стека. Такие структуры данных могут работать и по принципу FIFO, и по принципу LIFO. Доступ к элементам возможен с любого конца.</p>
  <p><strong>Операции.</strong> Можно сказать, что деки объединяют в себе операции, характерные для очередей и стеков. В каком-то смысле эти структуры данных напоминают массивы и приближены к ним по функциональности.</p>
  <p><strong>Применение.</strong> Деки используют, когда важно обеспечить доступ и к первым, и к последним элементам. Например, при оптимизации выполнения процессов.</p>
</article>


<!-- linked-list -->
<article class="article">
  <div class="anchor" id="linked-list"></div>
  <h3>6. Связный список (Linked list)</h3>

  <p>Ещё одна базовая структура данных, которую, как и массивы, используют для реализации других структур. Связный список — это группа из узлов. В каждом узле содержатся:</p>
  <ul>
    <li>Данные.</li>
    <li>Указатель или ссылка на следующий узел.</li>
    <li>В некоторых списках — ещё и ссылка на предыдущий узел.</li>
  </ul>
  <p>В итоге получается список, у которого есть чёткая последовательность элементов. При этом сами элементы более разрозненны, чем в массиве, поскольку хранятся отдельно. Быстро перемещаться между элементами списка помогают указатели.</p>

  <h3>Как применяют связные списки:</h3>
  <ul>
    <li>Для построения более сложных структур данных.</li>
    <li>Для реализации файловых систем.</li>
    <li>Для формирования хэш-таблиц.</li>
    <li>Для выделения памяти в динамических структурах данных.</li>
  </ul>
</article>


<!-- set -->
<article class="article">
  <div class="anchor" id="set"></div>
  <h3>7. Множество (Set)</h3>

  <p>В отличие от предыдущих базовых структур, во множестве данные не упорядочены. Они хранятся группой, их нельзя структурировать и в некоторых случаях нельзя сортировать. Зато с ними можно работать как с классическими математическими множествами: объединять, искать пересечения, вычислять разность и смотреть, является ли одно множество подмножеством другого.</p>
  <p>Обычно во множество помещают объекты, у которых есть что-то общее. Важны свойства объектов, а их порядок значения не имеет</p>

  <h3>Как применяют множества:</h3>
  <ul>
    <li>Для поддержания множества уникальных элементов.</li>
    <li>Для хранения данных, которые не нужно сортировать.</li>
    <li>Для сравнения, объединения наборов данных и других операций с ними.</li>
  </ul>
</article>


<!-- map -->
<article class="article">
  <div class="anchor" id="map"></div>
  <h3>8. Карта (Map). Ассоциативный массив, словарь</h3>

  <p>Её ещё называют ассоциативным массивом или словарём. Данные здесь хранятся в паре «ключ/значение», причем каждый ключ уникален, а вот значения могут повторяться. То есть определённому уникальному ключу всегда соответствует конкретное значение.</p>
  <p>Зная ключ, данные в Map можно искать быстрее, чем в других структурах</p>

  <h3>Как применяют Карту:</h3>
  <ul>
    <li>Для быстрого поиска данных.</li>
    <li>Для создания баз, в которых нужно хранить уникальное соответствие между двумя множествами значений. Их помещают в ключ, и структура проверяет, чтобы ключ не повторялся.</li>
  </ul>
  <p>Частный случай map — это hash-map, или хэш-таблица. В ней есть ключи и значения, а для их реализации добавляются индексы. Специальная хэш-функция позволяет по ключу вычислить индекс, чтобы найти нужные данные.</p>
</article>


<!-- hash-tables -->
<article class="article">
  <div class="anchor" id="hash-tables"></div>
  <h3>9. Хэш-таблицы (Hash-tables)</h3>

  <p>Эта структура данных похожа на ассоциативный массив и иногда реализуется через него. Разница в том, что ключ для каждого значения задается автоматически с помощью специальной формулы — хэш-формулы. Эта формула применяется к самому значению — в результате генерируется ключ, основанный на нем.</p>
  <p>С помощью хэш-таблицы можно генерировать ключи автоматически, например, в ситуациях, когда их название не должно нести полезной нагрузки. Это удобнее и быстрее, чем словарь, если речь идет о больших объемах данных. Кроме того, использование хэшей позволяет шифровать информацию — правда, одной таблицы для этого недостаточно.</p>
  <p>При работе с хэш-таблицами важно избегать коллизий — ситуаций, когда применение формулы к разным значениям дает одинаковые ключи. Чтобы такого не было, нужно грамотно подбирать формулу для каждого случая. Также существуют специальные стратегии для предотвращения коллизий.</p>
  <p><strong>Операции.</strong> В таблицу можно добавить элемент, удалить или найти по тому или иному признаку. При ее создании также можно и нужно задать формулу, по которой будут генерироваться хэши.</p>
  <p><strong>Применение.</strong> Хэш-таблицы используются для хранения больших объемов информации, в базах данных, а также для создания кэшей или при построении более сложных структур. Чаще всего таблицы используют, когда нужен быстрый доступ к информации.</p>
</article>


<!-- graph -->
<article class="article">
  <div class="anchor" id="graph"></div>
  <h3>10. Граф (Graph)</h3>

  <p>Граф — это более общий случай дерева. Иногда деревья называют ациклическими графами. Отличий у этих структур данных два:</p>
  <ul>
    <li>В графе возможны циклы, то есть «ребёнок» может быть «родителем» для того же элемента.</li>
    <li>Рёбра тоже могут нести смысловую нагрузку, то есть нужно сохранять их значения.</li>
  </ul>
  <p>Графы бывают ориентированные и неориентированные. У первых рёбра между узлами имеют направление, так что порядок элементов важен. У вторых направлений нет, и элементы можно читать и обходить в любом порядке.</p>
  <p>У ориентированных графов важен порядок элементов, у неориентированных ― элементы можно менять местами</p>
  <p>Графы часто представляют в виде матрицы смежности.</p>

  <h3>Как применяют графы:</h3>
  <ul>
    <li>Для хранения информации, связанной друг с другом сложными соотношениями.</li>
    <li>Для анализа соотносящейся друг с другом информации.</li>
    <li>Для построения маршрута из точки А в точку Б.</li>
  </ul>
</article>


<!-- binary-search-tree -->
<article class="article">
  <div class="anchor" id="binary-search-tree"></div>
  <h3>11. Двоичное дерево поиска (Binary search tree)</h3>

  <p>Дерево — это структура, данные в которой лежат в узлах. У каждого узла могут быть один или несколько дочерних и только один родитель, то есть они расходятся, как ветви дерева:</p>
  <p>Деревья бывают разных типов, но наиболее распространены двоичные деревья поиска. У них есть следующие особенности:</p>
  <ul>
    <li>У каждого узла не больше двух дочерних.</li>
    <li>Если новое значение меньше, оно становится левым дочерним либо дочерним левого дочернего.</li>
    <li>Если значение больше, оно становится правым дочерним или дочерним правого дочернего.</li>
  </ul>

  <h3>Как применяют двоичные деревья:</h3>
  <ul>
    <li>Для быстрого поиска данных.</li>
    <li>Для хранения данных в отсортированном виде с возможностью быстро их добавлять и удалять.</li>
  </ul>
</article>


<!-- trie -->
<article class="article">
  <div class="anchor" id="trie"></div>
  <h3>12. Префиксное дерево (Trie)</h3>

  <p>Другие названия этой структуры данных — Бор и нагруженное дерево. Данные в нём хранятся последовательно: каждый узел — это префикс, по которому находятся следующие узлы.</p>

  <h3>Как применяют префиксные деревья:</h3>
  <ul>
    <li>Для хранения данных, которые нужно выдавать по цепочке. Например, слова для функции автозаполнения в телефоне: в зависимости от одной набранной буквы дерево выдаёт следующие.</li>
    <li>Для хранения данных, у которых есть повторяющиеся участки. Например IP-адресов.</li>
  </ul>
</article>


<!-- binary-heap -->
<article class="article">
  <div class="anchor" id="binary-heap"></div>
  <h3>13. Двоичная куча (Binary heap)</h3>

  <p>Двоичные кучи — двоичные деревья, заполненные целиком. У каждого узла два потомка. Потомки в зависимости от типа дерева должны быть строго больше предков или меньше либо равны им.</p>
</article>


<!-- Структуры данных в JS -->
<article class="article">
  <div class="anchor" id="struct-js"></div>
  <h2>Структуры данных в JS</h2>

  <h4>Основные структуры в JS</h4>
  <ol>
    <li>Array</li>
    <li>Object</li>
    <li>Map</li>
    <li>Set</li>
    <li>DOM дерево</li>
  </ol>

  <h4>Array</h4>
  <p>Массив удобен для хранения данных которые потом нужно итерировать.</p>
  <ul>
    <li>взятие по интексу - O(1)</li>
    <li>pop - O(1)</li>
    <li>push - амортизированное O(1)</li>
    <li>shift/unshift - O(N)</li>
    <li>sort - O(N*logN)</li>
    <li>find/includes/indexOf - O(N)</li>
  </ul>

  <h4>Object</h4>
  <p>Объект работает на хэш-функции. Объект удобен когда нужно быстро получить данные по ключу, либо удалить эти данные.</p>
  <ul>
    <li>взятие по ключу - амортизированное O(1)</li>
    <li>запись - амортизированное O(1)</li>
    <li>удаление - амортизированное O(1)</li>
    <li>итерация Object.entries/Object.keys/Object.values - O(N)</li>
  </ul>

  <h4>Map</h4>
  <p>Map появился в es6. Это как у объекта пары "ключ: значение". Итерация по Map это константная сложность. А основные операции работают по спецификации es6 лучше чем за O(N). Если Map реализован в виде объекта это будет амортизированное O(1). Если Map реализован в виде бинарного дерева это будет O(logN). Будет ли в конкретной реализации хеш-таблицы или бинарное дерево решают разработчики браузеров.</p>
  <ul>
    <li>set - амортизированное O(1) или O(logN)</li>
    <li>delete - амортизированное O(1) или O(logN)</li>
    <li>get/has - амортизированное O(1) или O(logN)</li>
    <li>entries/keys/values - O(N)</li>
  </ul>

  <h4>Set</h4>
  <p>Set появился в es6. Это коллекция уникальных значений. Работает точно так же как и Map. Отличается тем что в Map есть ключ и значение, а в Set есть только значение.</p>
  <ul>
    <li>add - амортизированное O(1) или O(logN)</li>
    <li>delete - амортизированное O(1) или O(logN)</li>
    <li>has - амортизированное O(1) или O(logN)</li>
    <li>entries/values - O(N)</li>
  </ul>

  <h4>DOM дерево</h4>
  <p>Слабым местом этой структуры является поиск по классу или по селектору. Сложность такого поиска O(N), где N это количество узлов дерева.</p>
  <ul>
    <li>appendChild, insertBefore - O(1)</li>
    <li>removeChild - O(1)</li>
    <li>getElementById - O(1)</li>
    <li>getElementsByClassName - O(N)</li>
    <li>querySelector/querySelectorAll - O(N)</li>
  </ul>
</article>


