<h1>Задачи квалификации чемпионата по програм­мированию 2019 среди фронтенд-разработчиков</h1>


<!-- Содержание -->
<div class="article">
  <h2>Содержание</h2>
  <p><a href="#links">links</a></p>
  <p>Задачи квалификации чемпионата по програм­мированию 2019 среди фронтенд-разработчиков</p>
  <ol>
    <li><a href="#a">A. Аннигилируй это</a></li>
    <li><a href="#b">B. БЭМ</a></li>
    <li><a href="#c">C. Фабрика клонов</a></li>
    <li><a href="#d">D. Автоматизируй это</a></li>
    <li><a href="#e">E. Пандемия вируса</a></li>
    <li><a href="#f">F. Задача Framework-часов</a></li>
  </ol>
</div>


<!-- links -->
<article class="article">
  <div class="anchor" id="links"></div>
  <h2>Links</h2>

  <p><a href="https://yandex.ru/cup/frontend/analysis/">https://yandex.ru/cup/frontend/analysis/</a></p>
  <p><a href="https://contest.yandex.ru/contest/19380/problems/">Отправить решение задачи на платформе Яндекс.Контест</a></p>
</article>


<!-- A. Аннигилируй это -->
<article class="article">
  <div class="anchor" id="a"></div>
  <h2>A. Аннигилируй это</h2>

  <p>Авторы: Максим Сысоев, Константин Петряев</p>

  <p>Первая задача — разминочная. Каждому участнику доставался один из четырёх вариантов задачи, похожих между собой. Мы предложили не только текстовое условие, но и «плохое» рекурсивное решение. Нужно было переделать код (написать жадный алгоритм, который выдавал самое быстрое решение), убрав рекурсию и разные глупости вроде лишних операций и вычислений.</p>

  <h4>Условие</h4>
  <p>Вы устроились работать в лабораторию по изучению антиматерии, где проводят различные опыты. Ваш отдел изучает процессы, которые происходят при объединении материи и антиматерии. Вам необходимо провести серию опытов над некоторым количеством молекул.</p>
  <p>Соседний отдел разработал аппарат, который превращает материю в антиматерию на небольшое время. Он пригодится вам в проведении опытов, в которых используется следующий алгоритм:</p>
  <ol>
    <li>Находим 2 самых тяжёлых молекулы.</li>
    <li>Одну из них превращаем в антиматерию.</li>
    <li>Объединяем их. При этом, если вес одинаковый, они аннигилируются. Если же вес различается, то мы получаем новую молекулу, вес которой равен разнице весов предыдущих двух. Сама получившаяся молекула является материей.</li>
    <li>Если осталась одна молекула — нужно выяснить её вес. Если же молекул много — возвращаемся к пункту 1.</li>
  </ol>
  <p>Вам необходимо узнать, молекула какого веса останется в конце опыта, это знание нужно учёным другого отдела.</p>
  <p>Предыдущий разработчик набросал код, который занимался этими расчётами, однако код не может закончить расчёты в случае, когда опыт проводится на большом количестве молекул. Вам необходимо усовершенствовать код, чтобы он работал за приемлемое время.</p>

  <h4>Код, доставшийся вам в «наследство»</h4>
  <p>В качестве входных данных у вас будет массив с весами молекул. В качестве выходных данных необходимо вернуть число, которое обозначает вес последней молекулы. Если молекул не останется, то необходимо вернуть 0.</p>
<pre>var findLatestWeight = function(weights, i = weights.length - 1) {
  const cur = weights.length - 1 === i;

  if (i === 0) return weights[0];

  weights.sort((a, b) => a - b);
  weights[i - 1] = (weights[i] === weights[i-1]) ? 0 : weights[i] - weights[i-1];

  return findLatestWeight(weights, i - 1);
}</pre>

  <details>
    <summary>Пример и примечания</summary>
    <h4>Пример</h4>
    <code>Вход: [2,7,4,1,8,1]</code>
    <code>Выход: 1</code>
    <p>Берём молекулы с весом 7 и 8, превращаем 7 в антимолекулу и сталкиваем её с молекулой весом 8. Остаётся молекула весом 1. Веса оставшихся молекул стали [2,4,1,1,1]. Берём молекулы с весом 2 и 4, превращаем 2 в антимолекулу и сталкиваем её с молекулой весом 4. Остаётся молекула весом 2. Веса оставшихся молекул стали [2,1,1,1]. Берем молекулы с весом 2 и 1, превращаем 1 в антимолекулу и сталкиваем её с молекулой весом 2. Остаётся молекула весом 1. Веса оставшихся молекул стали [1,1,1]. Берем молекулы с весом 1 и 1, превращаем одну из них в антимолекулу и сталкиваем ее со второй. Они аннигилируются. Веса оставшихся молекул [1]. Осталась одна молекула. Результат — 1.</p>

    <h4>Примечания</h4>
    <p>В качестве решения предоставьте файл, который экспортирует исправленный вариант функции findLatestWeight:</p>
<pre>function findLatestWeight(weights) {
  // ...
}

module.exports = findLatestWeight;</pre>
  <p>Решение будет запускаться в Node.js 12.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <h4>Решение</h4>
    <p>В предоставленном «плохом» решении есть сразу несколько проблем. Первая — наличие рекурсии. Как заявлено в условии, мы будем обрабатывать большие массивы чисел, что сразу исключает рекурсивное решение.</p>
<pre>var findLatestWeight = function(weights) {
  let i = weights.length - 1;
  do {
    if (i === 0) return weights[0] || 0;

    weights.sort((a, b) => a - b);
    weights[i-1] = (weights[i]=== weights[i-1]) ? 0 : weights[i]-weights[i-1];

    i--;
  } while (true);
}</pre>
    <p>Развернуть рекурсию здесь достаточно просто, однако возникает другая проблема — происходит постоянная пересортировка (от меньших к большим) и работа с концом массива. В результате мы получаем уменьшение предпоследнего элемента в массиве. Но после этого мы не обрезаем массив, и если в функцию был передан массив из миллиона элементов, то мы до самого конца будем заниматься его пересортировкой.</p>
    <p>Вариант решения этой проблемы — попробовать постоянно обрезать массив.</p>
<pre>var findLatestWeight = function(weights) {
  let i = weights.length - 1;
  do {
    if (i === 0) return weights[0] || 0;

    weights.sort((a, b) => a - b);
    weights[i-1] = (weights[i]=== weights[i-1]) ? 0 : weights[i]-weights[i-1];
    weights.length = i; // &lt;--- вот так
    i--;
  } while (true);
}</pre>
    <p>Неплохо, но нам необходимо также избавиться от сортировки, которая сама по себе является дорогой операцией. По большому счёту, нас в любой момент времени будут интересовать 2 самых больших члена массива. То есть это поиск двух максимумов, что делается в один проход достаточно просто. Для удобства вынесем такой поиск в отдельную функцию.</p>
<pre>const maximumTwo = (arr) => {
  let max1 = arr[0];
  let max2 = arr[1];
  let max1I = 0;
  let max2I = 1;
  for(let i = 2; i &lt; arr.length; i++) {
    if (arr[i] &gt; max1) {
      if (max1 &gt; max2) {
        max2 = arr[i];
        max2I = i;
      } else {
        max1 = arr[i];
        max1I = i;
      }
    } else if (arr[i] &gt; max2) {
      max2 = arr[i];
      max2I = i;
    }
  }

  if (max1 > max2) return [max2, max1, max2I, max1I];
  return [max1, max2, max1I, max2I];
};</pre>
    <p>А саму функцию поиска поменяем следующим образом:</p>
<pre>const fn = function(weights) {
  if (weights.length &lt;= 1) {
    return weights[0];
  }

  do {
    const [x, y, xI, yI] =  maximumTwo(weights);
    if (x === 0) {
      return y;
    }

    weights[xI] = 0;
    weights[yI] = y - x;

  } while(true);
};</pre>
    <p>Таким образом, мы всегда будем обнулять меньший из двух элементов, а больший превращать в разницу между ними. Мы избавились от сортировки и получили вместо нее один линейный проход.</p>
    <p>Из замеченных нами частых ошибок — участники брали максимальный элемент, умножали его на –1 и складывали со вторым по величине камнем. В результате получалось отрицательное число, которое потом использовалось в вычислениях «как есть». Кроме того, в задаче есть ментальная ловушка, связанная с тем, что можно попробовать оставить уникальные по весу камни и вычислить разницу из них. Однако этот подход не даёт верного результата.</p>
  </details>
</article>


<!-- B. БЭМ -->
<article class="article">
  <div class="anchor" id="b"></div>
  <h2>B. БЭМ</h2>

  <p>Авторы: Евгений Мищенко, Владимир Гриненко @tadatuta</p>
  
  <h4>Условие</h4>
  <p>Верстальщик Александр участвует в множестве проектов с использованием БЭМ-методологии. Он даже создал удобный плагин для любимой IDE, который позволяет ему писать имена классов в сокращённой записи и разворачивать их в полную. Но проблема в том, что для каждого проекта люди устанавливают разные разделители между блоком, элементом и модификатором (block__mod__val—elem, block–mod–val___elem), и ему приходится каждый раз править это в своём плагине вручную. Помогите Александру написать модуль, который будет на основании класса определять разделитель для сущностей. Правило для разделителей — произвольное количество символов (не буквы). Примеры возможных нотаций (модификаторы для блока во входящих данных могут быть без значения):</p>
<pre>block_mod__elem // Считаем, что модификатор идёт первым
block_mod_mod__elem
block__elem_mod_mod</pre>

  <h4>Уточнения:</h4>
  <ul>
    <li>Классы в проектах пишут только маленькими буквами.</li>
    <li>На вход модуля подаётся строка с валидным CSS-классом.</li>
  </ul>
  
  <h4>Модуль должен вернуть ответ вида:</h4>
<pre>{
  mod: "_", // разделитель для модификатора
  elem: "__", // разделитель для элемента
}</pre>
  
  <h4>Оформить модуль необходимо как commonJS-модуль:</h4>
<pre>module.exports = function(str) {

}</pre>
  
  <details>
    <summary>Решение</summary>
    <h4>Решение</h4>
    <p>На вторую задачу отводилось примерно 20 минут. С её помощью мы хотели проверить у участников знание регулярных выражений.</p>
    <p>Из условия мы узнаём, что на вход в функцию будет приходить строка, содержащая валидный CSS-класс с дополнительными ограничениями, в которой буквенные последовательности разделены произвольными последовательностями из небуквенных символов. Наша задача — найти разделители и понять их семантику.</p>
    <p>Первой частью имени класса всегда будет название блока. Это последовательность из одной или более букв. Запишем соответствующее регулярное выражение: </p>
    <code>[a-z]+/</code>
    <p>Аналогичные выражения потребуются нам для поиска остальных частей: имени модификатора и его значения либо имени элемента с соответствующими модификатором и значением.</p>
    <p>Для поиска разделителей нам нужны небуквенные последовательности, подойдет выражение:</p>
    <code>[^a-z]+</code>
    <p>Соберём вместе и зададим группы, значения которых будем использовать:</p>
    <code>let [, mod, elem ] = str.match(/[a-z]+(?:([^a-z]+)[a-z]+(?:\1)?[a-z]+)([^a-z]+)[a-z]+(?:\2)?[a-z]+/);</code>
    <p>Теперь нужно убедиться, что мы правильно определили семантику найденных групп. Можно воспользоваться тем, что встретиться дважды может только модификатор.</p>
    <p>Напишем функцию, которая будет принимать исходную строку и найденный разделитель, чтобы посчитать количество вхождений:</p>
    <code>const substringCount = (source, substr) => (source.match(new RegExp('[a-z]' + substr + '[a-z]', 'g')) || []).length;</code>
    <p>Если окажется, что разделитель elem встречается дважды, а mod — один раз, то на самом деле все наоборот. Итоговое решение:</p>
<pre>module.exports = function(str) {
  let [, mod, elem ] = str.match(/[a-z]+(?:([^a-z]+)[a-z]+(?:\1)?[a-z]+)([^a-z]+)[a-z]+(?:\2)?[a-z]+/);
  const substringCount = (source, substr) => (source.match(new RegExp('[a-z]' + substr + '[a-z]', 'g')) || []).length;

  if (substringCount(str, elem) === 2 && substringCount(str, mod) === 1) {
    [mod, elem] = [elem, mod];
  }

  return { mod, elem };
}</pre>
  </details>
</article>


<!-- C. Фабрика клонов -->
<article class="article">
  <div class="anchor" id="c"></div>
  <h2>C. Фабрика клонов</h2>
  
  <p>Авторы: Дмитрий Андриянов @dima117, Алексей Гусев</p>


  <h4>Условие</h4>  
  <p>За окном 2319 год. Корпорации клонируют успешных сотрудников, чтобы они выполняли сложные задачи.</p>
  <p>На производстве клонов решили маркировать новые «изделия» с помощью татуировки с баркодом на плече — чтобы отличать клонов между собой.</p>
  <p>Помогите сотрудникам фабрики написать функцию, которая будет отрисовывать баркод с информацией о клоне.</p>

  <h4>Формат информации о клоне</h4>
  <p>Информация о клоне хранится в следующем виде:</p>
<pre>type CloneInfo = {
  /**
    * Пол клона — строка 'male' или 'female'
    */
  sex: string;
  /**
    * Идентификатор клона — строка из маленьких и больших
    * латинских букв и цифр, строго 10 символов
    */
  id: string;
  /**
    * Имя клона — строка из маленьких и больших
    * латинских букв и пробелов (от 0 до 26 символов)
    */
  name: string;
}</pre>

  <h4>Алгоритм отрисовки баркода</h4>
  <p>Баркоды, которые используют на фабрике клонов, выглядят так:</p>
  <p>Баркод имеет фиксированный размер — 148 на 156 пикселей. По периметру баркода находятся чёрная и белая рамки по 3 пикселя шириной каждая. Внутри рамок находится контент баркода, состоящий из 18 строк по 17 чёрных или белых квадратов в строке. Размер каждого квадрата — 8 на 8 пикселей.</p>
  <p>Белые квадраты в контенте кодируют 0, чёрные — 1.</p>
  <p>Алгоритм формирования контента баркода</p>
  <p>На пересечении первой строки и первого столбца контента отрисовывается квадрат, кодирующий пол клона. Значение female кодируется нулём (белый цвет), male — единицей (чёрный цвет).</p>
  <p>Далее из полей id и name формируется строка вида &lt;id&gt;&lt;name&gt;. Поле name дополняется пробелами в конце до 26 символов.</p>
  <p>Полученная строка конвертируется в байтовый массив — каждому символу строки ставится соответствующий ASCII-код (число от 0 до 255).</p>
  <p>Затем каждый элемент полученного массива переводится в двоичную запись (восемь символов 0 или 1) и кодируется последовательностью из восьми квадратов (0 — белый квардрат, 1 — чёрный квадрат). Квадраты отрисовываются в контенте баркода последовательно и построчно.</p>
  <p>В последней строке контента находится контрольная информация.</p>

  <h4>Алгоритм подсчёта контрольной информации</h4>
  <p>Каждый квадрат в строке контрольной информации определяет чётность суммы значений контента в соответствующем столбце. Если сумма нулей и единиц в столбце чётная, то в контрольной информации рисуется белый квадрат, в противном случае — чёрный.</p>

  <details>
    <summary>Формат решения и примеры</summary>
    <h4>Формат решения</h4>
    <p>Загружаемое вами решение должно содержать функцию renderBarcode:</p>
<pre>/**
  * Отрисовать баркод для татуировки клона в element
  * @param cloneInfo {CloneInfo} — информация о клоне
  * @param element {HTMLDivElement} — div с фиксированным размером
  *     148x156 пикселей, в который будет отрисовываться баркод
  */
function renderBarcode(cloneInfo, element) {
  // ваш код
}</source lang="javascript"></pre>

    <p>Решение будет запускаться в браузере Google Chrome 77.</p>

    <h4>Пример 1</h4>
    <p>Информация о клоне:</p>
<pre>{
  "sex": "male",
  "id": "c5j818dyo5",
  "name": "Oleg Vladimirovich"
}</pre>

    <h4>Баркод:</h4>

    <h2>Пример 2</h2>
    <p>Информация о клоне:</p>
<pre>{
  "sex": "female",
  "id": "0owrgqqwfw",
  "name": "Dazdraperma Petrovna"
}</pre>

    <h4>Баркод:</h4>
  </details>

  <details>
    <summary>Решение</summary>
    <h4>Решение</h4>
    <p>Требовалось правильно сформировать бинарное представление данных, посчитать для него контрольную сумму и отрисовать эти данные в верстке. Давайте попробуем сделать это максимально просто и в лоб — без оптимизаций кода.</p>
    <p>Начнём с бинарного представления. Для начала объявим вспомогательные функции:</p>
<pre>// переводит символ в ASCII-код
function charToByte(char) {
  return char.charCodeAt(0);
}

// переводит байт в строку из 0 и 1 (в двоичную систему счисления с незначащими нулями)
function byteToString(byte) {
  return byte.toString(2).padStart(8, '0');
}</pre>

    <p>Cформируем из исходных данных строку, состоящую из нулей и единиц:</p>
<pre>let dataString =
  (cloneInfo.sex === 'female' ? '0' : '1') +
  cloneInfo.id.split('').map(charToByte).map(byteToString).join('') +
  cloneInfo.name.padEnd(26, ' ').split('').map(charToByte).map(byteToString).join('');</pre>

    <p>Затем напишем вёрстку и стили для нашего баркода:</p>
<pre>// Идентификатор для блока, где будет находиться «контент» баркода.
// В принципе, вёрстку можно целиком строить через DOM API без использования innerHTML, и тогда идентификатор не потребуется.
// Если же реализовывать в лоб, случайный идентификатор защитит нас от того, что два баркода на странице «перемешаются».
// Это было очень частой ошибкой у участников чемпионата — многие не учитывали, что функция отрисовки баркода может вызываться несколько раз.
const contentElId = 'content-' + Math.random();
element.style.display = 'flex';
element.innerHTML = `
  &lt;style&gt;
    .barcode {
      border: 3px solid black;
      box-sizing: border-box;
    }

    .content {
      margin-top: 3px;
      margin-left: 3px;
      width: 136px;
      height: 144px;
      display: flex;
      flex-wrap: wrap;
    }

    .content__bit {
      width: 8px;
      height: 8px;
    }

    .content__bit_one {
      background: black;
    }
    &lt;/style&gt;

    &lt;div class="content" id="${contentElId}"&gt;&lt;/div&gt;
`;

const contentDiv = document.getElementById(contentElId);
element.className += ' barcode';</pre>

    <p>Отрендерим бинарные данные в вёрстке:</p>
<pre>dataString
  .split('')
  .forEach((bit) => {
	const bitDiv = document.createElement('div');
	bitDiv.className = 'content__bit content__bit_' + (bit === '0' ? 'zero' : 'one');
	contentDiv.appendChild(bitDiv);
  });</pre>

    <p>Осталось посчитать и отобразить контрольную сумму. Это можно сделать так:</p>
<pre>for (let i = 0; i &lt; 17; i++) {
  // суммируем столбец
  let sum = 0;
  for (let j = i; j &lt; 17 ** 2; j += 17) {
	sum += parseInt(dataString[j], 2);
  }
  const check = 0;
  const bitDiv = document.createElement('div');
  // рисуем квадрат контрольной суммы для столбца
  bitDiv.className = 'content__bit content__bit_' + (sum % 2 === 0 ? 'zero' : 'one');
  contentDiv.appendChild(bitDiv);
}</pre>
  </details>
</article>


<!-- D. Автоматизируй это -->
<article class="article">
  <div class="anchor" id="d"></div>
  <h2>D. Автоматизируй это</h2>

  <p>Авторы: Владимир Русов, Дмитрий Канатников</p>
  <p>В каждом из вариантов квалификации была задача, где в качестве входных данных предлагалась HTML-страничка с таблицей или списком. У задач этой серии была разная легенда, но все они сводились к тому, что надо привести страницу к формату, похожему на Markdown. Разберём решение одной из задач.</p>

  <h4>Условие</h4>
  <p>На государственном портале предоставления услуг сделали возможность подавать заявление на получение документов полностью автоматически, для этого надо только заполнить таблицу с персональными данными.</p>
  <p>Эти данные затем передаются на проверку в несколько инстанций, включая МВД. После начала тестирования выяснилось, что МВД принимает данные в формате Markdown, а Госуслуги пользуются HTML-форматом. Помогите написать скрипт миграции одного формата в другой, чтобы ребята поскорее запустились.</p>
  <p>Вам нужно написать функцию, которая на вход принимает HTML-таблицу и преобразует ее в Markdown-подобную разметку.</p>
  <p>В качестве решения этого задания отправьте файл .js, в котором объявлена функция solution:</p>
<pre>function solution(input) {
  // ...
}</pre>

  <details>
    <summary>Формат входных/выходных данных и примечания</summary>
    <h4>Формат входных данных</h4>
    <p>HTML-таблица приходит в виде строки:</p>
<pre><table>
  <colgroup>
    <col align="right" />
    <col />
    <col align="center" />
  </colgroup>
  <thead>
    <tr>
      <td>Command         </td>
      <td>Description     </td>
      <th>Is implemented  </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>git status</th>
      <td>List all new or modified    files</td>
      <th>Yes</th>
    </tr>
    <tr>
      <th>git diff</th>
      <td>Show file differences that haven't been staged</td>
      <td>No</td>
    </tr>
  </tbody>
</table></pre>

    <p>В таблице могут содержаться теги colgroup, thead и tbody в фиксированном порядке. Все эти теги опциональны, но всегда будет присутствовать как минимум thead либо tbody.</p>
    <ul>
      <li>colgroup содержит теги col, у которых может быть опциональный атрибут align с одним из трёх значений (left|center|right)</li>
      <li>thead и tbody содержат 1 или более tr</li>
      <li>tr, в свою очередь, содержат как td, так и th</li>
      <li>В таблице всегда будет хотя бы одна строка. — В строке всегда будет хотя бы одна ячейка. — В ячейке всегда присутствует хотя бы один не-whitespace символ.</li>
      <li>Количество элементов th/td в строках всегда совпадает между всеми строками и с количеством элементов col в colgroup, при наличии colgroup.</li>
      <li>Пробелы и переносы строк в исходном HTML могут встречаться в любом месте, не нарушающем валидность HTML.</li>
    </ul>

    <h4>Формат выходных данных</h4>
    <p>На выходе должна получиться строка с Markdown-разметкой:</p>
    <code>| Command | Description | **Is implemented** |</code>
    <code>| ---: | :--- | :---: |</code>
    <code>| **git status** | List all new or modified files | **Yes** |</code>
    <code>| **git diff** | Show file differences that haven't been staged | No |</code>

    <ul>
      <li>Первая встретившаяся строка в таблице должна всегда превращаться в строку-заголовок в Markdown-разметке.</li>
      <li>Все остальные строки идут в тело таблицы.</li>
      <li>Разделитель заголовка выводится всегда.</li>
      <li>Содержимое td вставляется как есть, содержимое th как **bold**.</li>
      <li>Между содержимым ячейки в markdown-разметке и разделителями ячеек (|) всегда один пробел.</li>
      <li>Пробелы по краям содержимого тегов td и th должны быть удалены.</li>
      <li>Переносы строк в содержимом ячеек должны быть удалены.</li>
      <li>Более одного пробела подряд в содержимом ячеек должны быть заменены одним пробелом.</li>
      <li>За выравнивание в ячейках столбцов Markdown-таблицы отвечает форматирование разделителя заголовка:</li>
    </ul>

    <code>| :--- | значит выравнивание по левому краю</code>
    <code>| :---: | значит выравнивание по центру</code>
    <code>| ---: | значит выравнивание по правому краю</code>

    <p>При отсутствии заданного в теге col атрибута align выравнивание должно быть задано влево.</p>

    <h4>Примечания</h4>
    <ul>
      <li>Для перевода строки нужно использовать символ \n.</li>
      <li>Решение будет проверяться в браузерном окружении (Chrome 78) с доступом к объектам document и window.</li>
      <li>Можно использовать синтаксис до es2018 включительно.</li>
    </ul>
  </details>

  <details>
    <summary>Решение</summary>
    <h4>Решение</h4>
    <p>Задача решается простым обходом DOM-дерева таблицы. Поддержка DOM-дерева реализована на уровне браузера, является его неотъемлемой частью, поэтому проблем не возникнет. Для решения задачи достаточно транслировать DOM-дерево из HTML в Markdown-разметку.</p>
    <p>Рассмотрев примеры, можно заметить, что преобразование осуществляется достаточно просто. Ниже — код, который является телом функции solution(input).</p>
    <p>Для начала нам понадобится преобразовать строку из HTML в DOM-дерево:</p>
<pre>const div = document.createElement('div');
div.innerHTML = input;
const table = div.firstChild;</pre>

    <p>Получив DOM-дерево, мы можем просто по нему пройти и обработать данные из разных DOM-узлов. Для этого достаточно рекурсивно обходить последовательноть children различных DOM-элементов:</p>
<pre>const processors = {
  'colgroup': processColgroup,
  'thead': processThead,
  'tbody': processTbody,
};

for (let child of table.children) {
  processors[child.tagName.toLowerCase()](child);
}</pre>

    <p>Из тегов colgroup и col нам интересно узнать выравнивание колонок таблицы:</p>
<pre>const alignments = [];
const defaultAlign = 'left';

const processColgroup = (colgroup) => {
  alignments.push(...Array(...colgroup.children).map(col => {
    return col.align || defaultAlign;
  }));
};</pre>

    <p>В тегах thead, tbody и tr нас интересуют только дочерние элементы:</p>
<pre>const rows = [];

const processThead = (thead) => {
  rows.push(...Array(...thead.children).map(processTr));
};

const processTbody = (tbody) => {
  rows.push(...Array(...tbody.children).map(processTr));
};

const processTr = (tr) => {
  return Array(...tr.children).map(processCell);
};</pre>

    <p>Важно не забыть, что по условию td и th форматируются по-разному:</p>
<pre>const processCell = (cell) => {
  const tag = cell.tagName.toLowerCase();
  const content = clearString(cell.innerHTML);

  return {
    'td': content,
    'th': `**${content}**`,
  }[tag];
};</pre>

    <p>Для работы с тестовым содержимым DOM необходимо выполнить требования, о которых сказано в условии:</p>
<pre>const clearLineBreaks = (str) => str.replace(/\r?\n|\r/g, '');
const clearSpaces = (str) => str.replace(/\s+/g, ' ');
const clearString = (str) => clearSpaces(clearLineBreaks(str)).trim();</pre>

    <p>После того, как мы обошли DOM-дерево, основная часть нашей таблицы оказалась записана в массив rows:</p>
<pre>[

 ["Command","Description","**Is implemented**"],

 ["**git status**","List all new or modified files","**Yes**"],

 ["**git diff**","Show file differences that haven't been staged","No"]

]</pre>

    <p>Информация о выравнивании колонок оказалась в массиве alignments:</p>
    <code>["right","left","center"]</code>

    <p>Важно вспомнить, что информация о выравнивании колонок может отсутствовать во входных данных:</p>
<pre>const updateAlignments = () => {
	if (alignments.length &gt; 0) return;
	alignments.push(...rows[0].map(x => defaultAlign));
};

updateAlignments();</pre>

    <p>Преобразуем alignments в конечный вид:</p>
<pre>const alignmentsContents = alignments.map(align => {
  return {
    'left': ' :--- ',
    'center': ' :---: ',
    'right': ' ---: '
  }[align];
});
const delimiter = `|${alignmentsContents.join('|')}|`;</pre>

    <p>Пример значения delimiter:</p>
    <code>"| ---: | :--- | :---: |"</code>

    <p>Завершающим этапом будет формирование Markdown-строки, содержащей все данные, прочитанные из HTML:</p>
<pre>const lineEnd = '\n';

rows.forEach((row, i) => {
  if (i &gt; 0) markdown += lineEnd;

  const mdRow = `| ${row.join(' | ')} |`;
  markdown += mdRow;

  if (i === 0) {
    markdown += lineEnd;
    markdown += delimiter;
  }
});

return markdown;</pre>

    <p>Конструкция return означает, что весь приведённый код был телом функции solution(input). В результате работы этой функции мы получим желаемый Markdown-код таблицы, показанный в примере выходных данных из условия задачи.</p>
  </details>
</article>


<!-- E. Пандемия вируса -->
<article class="article">
  <div class="anchor" id="e"></div>
  <h2>E. Пандемия вируса</h2>
  
  <p>Авторы: Андрей Мокроусов, Иван Петухов</p>

  <p>Всемирная Организация Здравоохранения опубликовала доклад о признаках надвигающейся пандемии нового вируса, который угрожает фронтенд-разработчикам. Известно, что вирус никак не проявляет себя до тех пор, пока носитель не увидит JS-код, содержащий некоторое выражение. Как только заражённый увидел это выражение, он теряет способность писать код на JS и начинает непроизвольно писать код на Фортране.</p>
  <p>В докладе упоминается, что вирус активируется от взгляда на использование первого аргумента функции, передаваемой аргументом в вызов функции Z.y.n, то есть заражённым нельзя показывать выражение, подобное Z.y.n(function(a, b, c){console.log(a)}).</p>
  <p>Чтобы не потерять случайно всех своих фронтендеров, в компании AST & Co решили проверить, содержит ли их код упомянутое выражение. Помогите инженерам компании написать такую проверку.</p>
  <p>Про код в компании AST & Co известно, что:</p>
  <ul>
    <li>он написан на ES3,</li>
    <li>обращение к свойствам объекта возможно как через точку, так и через скобки (a.b и a['b']),</li>
    <li>часть выражения может быть сохранена в переменной, но никогда не передаётся в функцию параметром (a(x) — запрещено),</li>
    <li>нет функций, которые возвращают часть искомого выражения,</li>
    <li>нет свойств объектов или элементов массивов, которые содержат часть выражения,</li>
    <li>при обращении к свойству объекта название свойства может быть взято из переменной (a[x], x — переменная),</li>
    <li>переменные получают свои значения при декларации и не переписываются, т. е. в коде не будет подобного var a = x; a = y; и var a = b = 1.</li>
  </ul>

  <details>
    <summary>Формат решения и примечания</summary>
    <h4>Формат решения</h4>
    <p>Проверка должна быть оформлена в виде CommonJS-модуля, который экспортирует функцию, принимающую на вход абстрактное синтаксическое дерево (ast) проверяемого кода.</p>
    <p>Функция должна вернуть массив из ast-узлов, которые соответствуют местам использования первого параметра callback-функции, передаваемой аргументом в Z.y.n. Порядок элементов в массиве не важен, дубли не допускаются.</p>
<pre>module.exports = function (ast) {
  ...
  return [...];
}
</pre>

    <h4>Примечания</h4>
    <p>Следующий код можно взять за основу для обхода дерева.</p>
<pre>/**
 * Функция обхода дерева. Выполняет обход дерева в глубину,
 * передавая в callback-функции onNodeEnter (до посещения потомков)
 * и onNodeLeave (после посещения потомков) каждый узел дерева
 * и текущую область видимости (смотри определение Scope ниже).
 *
 * @param      {object}    ast                              Исходное ast.
 * @param      {Function}  [onNodeEnter=(node, scope)=>{}]  Вызывается для каждого узла до посещения потомков.
 * @param      {Function}  [onNodeLeave=(node, scope)=>{}]  Вызывается для каждого узла после посещения потомков.
 */
function traverse(
    ast,
    onNodeEnter = (node, scope) => {},
    onNodeLeave = (node, scope) => {}
) {
    const rootScope = new Scope(ast);

    _inner(ast, rootScope);

    /**
     * Определение области видимости узла.
     * Может либо вернуть текущий scope, либо создать новый.
     *
     * @param      {object}  astNode       ast-узел.
     * @param      {Scope}   currentScope  Текущая область видимости.
     * @return     {Scope}   Область видимости для внутренних узлов astNode.
     */
    function resolveScope(astNode, currentScope) {
        let isFunctionExpression = ast.type === 'FunctionExpression',
            isFunctionDeclaration = ast.type === 'FunctionDeclaration';

        if (!isFunctionExpression &&
            !isFunctionDeclaration) {
            // Новые области видимости порождают только функции.
            return currentScope;
        }

        // Каждая функция порождает новую область видимости.
        const newScope = new Scope(ast, currentScope);

        ast.params.forEach(param => {
            // Параметры функции доступны внутри функции.
            newScope.add(param.name);
        });

        if (isFunctionDeclaration) {
            // Имя функции при декларации доступно снаружи функции.
            currentScope.add(ast.id.name);
        } else {
            // Имя функции-выражения доступно только внутри неё.
            newScope.add(ast.id.name);
        }

        return newScope;
    }

    /**
     * Рекурсивная функция обхода ast.
     *
     * @param      {object}  astNode  Текущий ast-узел.
     * @param      {Scope}  scope     Область видимости для текущего ast-узла.
     */
    function _inner(astNode, scope) {
        if (Array.isArray(astNode)) {
            astNode.forEach(node => {
                /* Рекурсивный обход элементов списков.
                 * Списками являются, например, параметры функций.
                 */
                _inner(node, scope);
            });
        } else if (astNode && typeof astNode === 'object') {
            onNodeEnter(astNode, scope);

            const innerScope = resolveScope(astNode, scope),
                keys = Object.keys(astNode).filter(key => {
                    // loc - служебное свойство, а не ast-узел.
                    return key !== 'loc' &&
                        astNode[key] && typeof astNode[key] === 'object';
                });

            keys.forEach(key => {
                // Обход всех потомков.
                _inner(astNode[key], innerScope);
            });

            onNodeLeave(astNode, scope);
        }
    }
}

/**
 * Представление области видимости.
 *
 * @class      Scope (name)
 * @param      {object}  astNode      ast-узел, породивший эту область видимости.
 * @param      {object}  parentScope  Родительская область видимости.
 */
function Scope(astNode, parentScope) {
    this._node = astNode;
    this._parent = parentScope;
    this._vars = new Set();
}

Scope.prototype = {
    /**
     * Добавление имени переменной в область видимости.
     *
     * @param      {string}  name    Имя переменной.
     */
    add(name) {
        this._vars.add(name);
    },
    /**
     * Была ли определена переменная с таким именем.
     *
     * @param      {string}   name    Имя переменной.
     * @return     {boolean}  Встречалась ли переменная с таким именем в доступных областях видимости.
     */
    isDefined(name) {
        return this._vars.has(name) || (this._parent && this._parent.isDefined(name));
    }
};</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <h4>Решение</h4>

    <p>Сначала разберёмся с ограничениями.</p>
    <p>— он написан на ES3</p>
    <p>Значит, при обходе дерева могут встретится только самые базовые конструкции языка. Например, для манипуляций с массивами доступны только циклы.</p>
    <p>— обращение к свойствам объекта возможно как через точку, так и через скобки (a.b и a['b'])</p>
    <p>То есть нужно искать не только Z.y.n, но и Z['y'].n, Z.y['n'] и Z['y']['n'].</p>
    <p>— часть выражения может быть сохранена в переменной, но никогда не передаётся в функцию параметром (a(x) — запрещено)</p>
    <p>Этот пункт сразу делает задачу в несколько раз сложнее, потому что придётся отслеживать значения переменных и области видимостей. Например, нужно будет назодить такой код: var x = Z.y; x.n(...).</p>
    <p>— нет функций, которые возвращают часть искомого выражения,</p>
    <p>— нет свойств объектов или элементов массивов, которые содержат часть выражения,</p>
    <p>— переменные получают свои значения при декларации и не переписываются, т.е. в коде не будет подобного </p>
    <code>var a = x; a = y и var a = b = 1</code>

    <p>Эти пункты (как и запрет на передачу выражения в функции) упрощают задачу, но учитывать значения переменных и области видимости всё-таки придётся.</p>
    <p>— при обращении к свойству объекта, название свойства может быть взято из переменной (a[x], x — переменная)</p>
    <p>Этот пункт окрывает ещё один способ обращения к свойствам объекта, за которым нужно следить: var x = 'y'; Z[x].n(...).</p>
    <p>Cтановится понятен примерный план решения:</p>
    <ol>
      <li>Обойти всё дерево, собрав информацию о значениях переменных, которые они получают при декларации.</li>
      <li>Найти искомую конструкцию, учитывая информацию из предыдущего пункта.</li>
    </ol>
    <p>Код, который дан в примечании задачи, может сэкономить немного времени в самом скучном месте — обходе дерева и сборе информации о названиях и параметрах функций. Поэтому возьмём его и начнём с пункта 2.</p>

    <h4>Поиск выражения</h4>
    <p>Разобьём поиск на две части: сначала найдём Z.y.n(function(a, b, c){...}), затем — использование первого аргумента внутри функции.</p>
    <p>Первая часть соответствует FunctionExpression — первому и единственному параметру в CallExpression, у которого callee — MemberExpression. Причём имя property — n, а object (ещё один MemberExpression с object и property под именем y) — Z.</p>
    <p>Вторая часть соответствует любому обращению к первому аргументу, потому что единственное допустимое действие — перезапись — запрещено условием. Обращение к первому аргументу — это Identifier с тем же именем, который встретился где угодно кроме MemberExpression и ObjectLiteral в качестве свойства (x.a и var x = {a: ...} соответственно).</p>

<pre>+++ b/traverse.js
@@ -120,3 +120,59 @@ Scope.prototype = {
        return this._vars.has(name) || (this._parent && this._parent.isDefined(name));
    }
  };
+
+module.exports = function (ast) {
+    var result = [];
+
+    traverse(ast, (node, scope) => {
+        if (node.type !== 'CallExpression') {
+            return;
+        }
+        let args = node.arguments;
+        if (args.length !== 1 ||
+            args[0].type !== 'FunctionExpression') {
+            return;
+        }
+        let callee = node.callee;
+        if (callee.type !== 'MemberExpression') {
+            return;
+        }
+        let property = callee.property,
+            object = callee.object;
+        if (property.name !== 'n') {
+            return;
+        }
+        if (object.type !== 'MemberExpression') {
+            return;
+        }
+        property = object.property;
+        object = object.object;
+        if (property.name !== 'y') {
+            return;
+        }
+        if (object.type !== 'Identifier' ||
+            object.name !== 'Z') {
+            return;
+        }
+
+        checkFunction(args[0]);
+    });
+
+    function checkFunction(ast) {
+        let firstArg = ast.params[0];
+        if (!firstArg) {
+            return;
+        }
+
+        traverse(ast.body, (node, scope) => {
+            if (node.type !== 'Identifier') {
+                return;
+            }
+            if (node.name === firstArg.name) {
+                result.push(node);
+            }
+        });
+    }
+
+    return result;
+};</pre>
 
    <p>По последнему вызову traverse видно, что при обходе требуется информация о родителях, чтобы корректно отфильтровать идентификаторы в MemberExpression и ObjectProperty. Добавляем:</p>
<pre>--- a/traverse.js
+++ b/traverse.js
@@ -60,16 +60,16 @@ function traverse(
      * @param      {object}  astNode  Текущий ast-узел
      * @param      {Scope}  scope     Область видимости для текущего ast-узла
      */
-    function _inner(astNode, scope) {
+    function _inner(astNode, scope, parent) {
          if (Array.isArray(astNode)) {
              astNode.forEach(node => {
                  /* Рекурсивный обход элементов списков.
                  * Списками являются, например, параметры функций
                  */
-                _inner(node, scope);
+                _inner(node, scope, parent);
              });
          } else if (astNode && typeof astNode === 'object') {
-            onNodeEnter(astNode, scope);
+            onNodeEnter(astNode, scope, parent);

              const innerScope = resolveScope(astNode, scope),
                  keys = Object.keys(astNode).filter(key => {
@@ -80,10 +80,10 @@ function traverse(

              keys.forEach(key => {
                  // Обход всех потомков
-                _inner(astNode[key], innerScope);
+                _inner(astNode[key], innerScope, astNode);
              });

-            onNodeLeave(astNode, scope);
+            onNodeLeave(astNode, scope, parent);
          }
      }
  }
@@ -164,10 +164,22 @@ module.exports = function (ast) {
              return;
          }

-        traverse(ast.body, (node, scope) => {
+        traverse(ast.body, (node, scope, parent) => {
              if (node.type !== 'Identifier') {
                  return;
              }
+            if (!parent) {
+                return;
+            }
+            if (parent.type === 'MemberExpression' &&
+                parent.computed === false &&
+                parent.property === node) {
+                return;
+            }
+            if (parent.type === 'ObjectProperty' &&
+                parent.key === node) {
+                return;
+            }
              if (node.name === firstArg.name) {
                  result.push(node);
              }</pre>

    <p>Нужно учесть и обращение к свойствам объектов через скобки. Создадим функцию getPropName:</p>
<pre>--- a/traverse.js
+++ b/traverse.js
@@ -121,6 +121,18 @@ Scope.prototype = {
      }
  };

+function getPropName(node) {
+    let prop = node.property;
+
+    if (!node.computed) {
+        return prop.name;
+    }
+
+    if (prop.type === 'StringLiteral') {
+        return prop.value;
+    }
+}
+
  module.exports = function (ast) {
      var result = [];

@@ -137,17 +149,17 @@ module.exports = function (ast) {
          if (callee.type !== 'MemberExpression') {
              return;
          }
-        let property = callee.property,
+        let property = getPropName(callee),
              object = callee.object;
-        if (property.name !== 'n') {
+        if (property !== 'n') {
              return;
          }
          if (object.type !== 'MemberExpression') {
              return;
          }
-        property = object.property;
+        property = getPropName(object);
          object = object.object;
-        if (property.name !== 'y') {
+        if (property !== 'y') {
              return;
          }
          if (object.type !== 'Identifier' ||</pre>

    <p>Этот код всё ещё содержит недостатки: он никак не использует области видимости и переменые. Однако он хотя бы проходит первые три теста. Теперь переходим к пункту 1.</p>
    <h4>Улучшение Scope</h4>    
    <p>Нужно добавить в Scope сбор информации о переменных и их значениях. Кроме того, нужно сделать так, чтобы собранная информация не терялась между вызовами traverse:</p>  
<pre>--- a/traverse.js
+++ b/traverse.js
@@ -1,3 +1,12 @@
+const scopeStorage = new Map();
+
+function getScopeFor(ast, outerScope) {
+    if (!scopeStorage.has(ast)) {
+        scopeStorage.set(ast, new Scope(ast, outerScope));
+    }
+
+    return scopeStorage.get(ast);
+}
  /**
  * Функция обхода дерева. Выполняет обход дерева в глубину,
  * передавая в callback-функции onNodeEnter (до посещения потомков).
@@ -13,7 +22,7 @@ function traverse(
      onNodeEnter = (node, scope) => {},
      onNodeLeave = (node, scope) => {}
  ) {
-    const rootScope = new Scope(ast);
+    const rootScope = getScopeFor(ast);

      _inner(ast, rootScope);

@@ -36,19 +45,19 @@ function traverse(
          }

          // Каждая функция порождает новую область видимости.
-        const newScope = new Scope(ast, currentScope);
+        const newScope = getScopeFor(ast, currentScope);

          ast.params.forEach(param => {
              // Параметры функции доступны внутри функции.
-            newScope.add(param.name);
+            newScope.add(param.name, param);
          });

          if (isFunctionDeclaration) {
              // Имя функции при декларации доступно снаружи функции.
-            currentScope.add(ast.id.name);
+            currentScope.add(ast.id.name, ast);
          } else if (ast.id) {
              // Имя функции-выражения доступно только внутри неё.
-            newScope.add(ast.id.name);
+            newScope.add(ast.id.name, ast);
          }

          return newScope;
@@ -98,7 +107,7 @@ function traverse(
  function Scope(astNode, parentScope) {
      this._node = astNode;
      this._parent = parentScope;
-    this._vars = new Set();
+    this._vars = new Map();
  }

  Scope.prototype = {
@@ -107,8 +116,24 @@ Scope.prototype = {
      *
      * @param      {string}  name    имя переменной
      */
-    add(name) {
-        this._vars.add(name);
+    add(name, value) {
+        this._vars.set(name, {
+            value: value,
+            scope: this
+        });
+    },
+    resolve(node) {
+        if (!node) {
+            return node;
+        }
+        if (node.type === 'Identifier') {
+            let value = this._vars.get(node.name);
+            if (value) {
+                return value;
+            }
+            value = (this._parent && this._parent.resolve(node));
+            return value;
+        }
      },
      /**
      * Была ли определена переменная с таким именем.
@@ -136,6 +161,12 @@ function getPropName(node) {
  module.exports = function (ast) {
      var result = [];

+    traverse(ast, (node, scope) => {
+        if (node.type === 'VariableDeclarator') {
+            scope.add(node.id.name, node.init);
+        }
+    });
+
      traverse(ast, (node, scope) => {
          if (node.type !== 'CallExpression') {
              return;</pre>
          
    <h4>Использование Scope</h4>      
    <p>Теперь добавим использование знаний о переменных. Каждая часть выражения может быть помещена в переменную, поэтому будем обращаться к Scope после после каждой части. Заметьте, что сам Scope тоже может меняться, поскольку значения переменных привязаны к своей области видимости:</p>    
<pre>--- a/traverse.js
+++ b/traverse.js
@@ -146,13 +146,17 @@ Scope.prototype = {
      }
  };

-function getPropName(node) {
+function getPropName(node, scope) {
      let prop = node.property;

      if (!node.computed) {
          return prop.name;
      }

+    let resolved = scope.resolve(prop);
+    if (resolved) {
+        prop = resolved.value;
+    }
      if (prop.type === 'StringLiteral') {
          return prop.value;
      }
@@ -177,22 +181,43 @@ module.exports = function (ast) {
              return;
          }
          let callee = node.callee;
+
+        let resolved = scope.resolve(callee);
+        if (resolved) {
+            callee = resolved.value;
+            scope = resolved.scope;
+        }
+
          if (callee.type !== 'MemberExpression') {
              return;
          }
-        let property = getPropName(callee),
+        let property = getPropName(callee, scope),
              object = callee.object;
          if (property !== 'n') {
              return;
          }
+
+        resolved = scope.resolve(object);
+        if (resolved) {
+            object = resolved.value;
+            scope = resolved.scope;
+        }
+
          if (object.type !== 'MemberExpression') {
              return;
          }
-        property = getPropName(object);
+        property = getPropName(object, scope);
          object = object.object;
          if (property !== 'y') {
              return;
          }
+
+        resolved = scope.resolve(object);
+        if (resolved) {
+            object = resolved.value;
+            scope = resolved.scope;
+        }
+
          if (object.type !== 'Identifier' ||
              object.name !== 'Z') {
              return;</pre>
              
    <h4>Последние улучшения</h4>     
    <p>Самое время ещё раз посмотреть на весь код: решение проходит только пять тестов из девяти. Можно выделить три проблемы:</p>     
    <ul>
      <li>Нет проверки, что Z — это необходимый нам глобальный объект, а не какая-то переменная.</li>
      <li>Нет проверки, что в функции нашлось использование именно аргумента нужной функции, а не вложенной переменной с тем же именем.</li>
      <li>Получение значения переменной происходит только один раз, хотя условием не запрещены цепочки вида
        <code>var a = 'x', b = a</code>
      </li>
    </ul>

    <p>Исправляем эти три пункта, и решение готово.</p>          
<pre>--- a/traverse.js
+++ b/traverse.js
@@ -128,10 +128,23 @@ Scope.prototype = {
          }
          if (node.type === 'Identifier') {
              let value = this._vars.get(node.name);
-            if (value) {
-                return value;
+            if (!value) {
+                if (this._parent) {
+                    value = this._parent.resolve(node);
+                } else {
+                    // Это глобальный scope, поэтому node —
+                    // необъявленная глобальная переменная.
+                    this.add(node.name, node);
+                    return this.resolve(node);
+                }
+            }
+            if (!value) {
+                return;
+            }
+            if (value.value.type === 'Identifier' &&
+                value.value !== node) {
+                return value.scope.resolve(value.value) || value;
              }
-            value = (this._parent && this._parent.resolve(node));
              return value;
          }
      },
@@ -165,12 +178,15 @@ function getPropName(node, scope) {
  module.exports = function (ast) {
      var result = [];

+
      traverse(ast, (node, scope) => {
          if (node.type === 'VariableDeclarator') {
              scope.add(node.id.name, node.init);
          }
      });

+    let rootScope = getScopeFor(ast);
+
      traverse(ast, (node, scope) => {
          if (node.type !== 'CallExpression') {
              return;
@@ -213,9 +229,10 @@ module.exports = function (ast) {
          }

          resolved = scope.resolve(object);
+        let zScope;
          if (resolved) {
              object = resolved.value;
-            scope = resolved.scope;
+            zScope = resolved.scope;
          }

          if (object.type !== 'Identifier' ||
@@ -223,6 +240,10 @@ module.exports = function (ast) {
              return;
          }

+        if (zScope && zScope !== rootScope) {
+            return;
+        }
+
          checkFunction(args[0]);
      });

@@ -232,7 +253,10 @@ module.exports = function (ast) {
              return;
          }

-        traverse(ast.body, (node, scope, parent) => {
+        traverse(ast, (node, scope, parent) => {
+            if (parent === ast) {
+                return;
+            }
              if (node.type !== 'Identifier') {
                  return;
              }
@@ -248,7 +272,9 @@ module.exports = function (ast) {
                  parent.key === node) {
                  return;
              }
-            if (node.name === firstArg.name) {
+
+            let resolved = scope.resolve(node);
+            if (resolved && resolved.value === firstArg) {
                  result.push(node);
              }
          });</pre>

    <p>Полный код решения:</p>
<pre>const scopeStorage = new Map();

function getScopeFor(ast, outerScope) {
    if (!scopeStorage.has(ast)) {
        scopeStorage.set(ast, new Scope(ast, outerScope));
    }

    return scopeStorage.get(ast);
}
/**
  * Функция обхода дерева. Выполняет обход дерева в глубину,
  * передаваяв callback-функции onNodeEnter (до посещения потомков)
  * и onNodeLeave (после посещения потомков) каждый узел дерева
  * и текущую область видимости (смотри определение Scope ниже)
  *
  * @param      {object}    ast                              Исходное ast
  * @param      {Function}  [onNodeEnter=(node, scope)=>{}]  Вызывается для каждого узла до посещения потомков
  * @param      {Function}  [onNodeLeave=(node, scope)=>{}]  Вызывается для каждого узла после посещения потомков
  */
function traverse(
    ast,
    onNodeEnter = (node, scope) => {},
    onNodeLeave = (node, scope) => {}
) {
    const rootScope = getScopeFor(ast);

    _inner(ast, rootScope);

    /**
      * Определение области видимости узла.
      * Может либо вернуть текущий scope, либо создать новый
      *
      * @param      {object}  ast       ast-узел
      * @param      {Scope}   currentScope  текущая область видимости
      * @return     {Scope}   область видимости для внутренних узлов astNode
      */
    function resolveScope(ast, currentScope) {
        let isFunctionExpression = ast.type === 'FunctionExpression',
            isFunctionDeclaration = ast.type === 'FunctionDeclaration';

        if (!isFunctionExpression &&
            !isFunctionDeclaration) {
            // Новые области видимости порждают только функции
            return currentScope;
        }

        // каждая функция порождает новую область видимости
        const newScope = getScopeFor(ast, currentScope);

        ast.params.forEach(param => {
            // параметры функции доступны внутри функции
            newScope.add(param.name, param);
        });

        if (isFunctionDeclaration) {
            // имя функции при декларации доступно снаружи функции
            currentScope.add(ast.id.name, ast);
        } else if (ast.id) {
            // имя функции-выражения доступно только внутри неё
            newScope.add(ast.id.name, ast);
        }

        return newScope;
    }

    /**
      * Рекурсивная функция обхода ast
      *
      * @param      {object}  astNode  Текущий ast-узел
      * @param      {Scope}  scope     Область видимости для текущего ast-узла
      */
    function _inner(astNode, scope, parent) {
        if (Array.isArray(astNode)) {
            astNode.forEach(node => {
                /* Рекурсивный обход элементов списков.
                  * Списками являются, например, параметры функций
                  */
                _inner(node, scope, parent);
            });
        } else if (astNode && typeof astNode === 'object') {
            onNodeEnter(astNode, scope, parent);

            const innerScope = resolveScope(astNode, scope),
                keys = Object.keys(astNode).filter(key => {
                    // loc - служебное свойство, а не ast-узел
                    return key !== 'loc' &&
                        astNode[key] && typeof astNode[key] === 'object';
                });

            keys.forEach(key => {
                // Обход всех потомков
                _inner(astNode[key], innerScope, astNode);
            });

            onNodeLeave(astNode, scope, parent);
        }
    }
}

/**
  * Представление области видимости
  *
  * @class      Scope (name)
  * @param      {object}  astNode      ast-узел, породивший эту область видимости
  * @param      {object}  parentScope  Родительская область видимости
  */
function Scope(astNode, parentScope) {
    this._node = astNode;
    this._parent = parentScope;
    this._vars = new Map();
}

Scope.prototype = {
    /**
      * Добавление имени переменной в область видимости
      *
      * @param      {string}  name    имя переменной
      */
    add(name, value) {
        this._vars.set(name, {
            value: value,
            scope: this
        });
    },
    resolve(node) {
        if (!node) {
            return node;
        }
        if (node.type === 'Identifier') {
            let value = this._vars.get(node.name);
            if (!value) {
                if (this._parent) {
                    value = this._parent.resolve(node);
                } else {
                    // Это глобальный scope, поэтому node -
                    // необъявленная глобальная переменная
                    this.add(node.name, node);
                    return this.resolve(node);
                }
            }
            if (!value) {
                return;
            }
            if (value.value.type === 'Identifier' &&
                value.value !== node) {
                return value.scope.resolve(value.value) || value;
            }
            return value;
        }
    },
    /**
      * Была ли определена переменная с таким именем.
      *
      * @param      {string}   name    имя переменной
      * @return     {boolean}  Встречалась ли переменная с таким именем в доступных областях видимости
      */
    isDefined(name) {
        return this._vars.has(name) || (this._parent && this._parent.isDefined(name));
    }
};

function getPropName(node, scope) {
    let prop = node.property;

    if (!node.computed) {
        return prop.name;
    }

    let resolved = scope.resolve(prop);
    if (resolved) {
        prop = resolved.value;
    }
    if (prop.type === 'StringLiteral') {
        return prop.value;
    }
}

module.exports = function (ast) {
    var result = [];


    traverse(ast, (node, scope) => {
        if (node.type === 'VariableDeclarator') {
            scope.add(node.id.name, node.init);
        }
    });

    let rootScope = getScopeFor(ast);

    traverse(ast, (node, scope) => {
        if (node.type !== 'CallExpression') {
            return;
        }
        let args = node.arguments;
        if (args.length !== 1 ||
            args[0].type !== 'FunctionExpression') {
            return;
        }
        let callee = node.callee;

        let resolved = scope.resolve(callee);
        if (resolved) {
            callee = resolved.value;
            scope = resolved.scope;
        }

        if (callee.type !== 'MemberExpression') {
            return;
        }
        let property = getPropName(callee, scope),
            object = callee.object;
        if (property !== 'n') {
            return;
        }

        resolved = scope.resolve(object);
        if (resolved) {
            object = resolved.value;
            scope = resolved.scope;
        }

        if (object.type !== 'MemberExpression') {
            return;
        }
        property = getPropName(object, scope);
        object = object.object;
        if (property !== 'y') {
            return;
        }

        resolved = scope.resolve(object);
        let zScope;
        if (resolved) {
            object = resolved.value;
            zScope = resolved.scope;
        }

        if (object.type !== 'Identifier' ||
            object.name !== 'Z') {
            return;
        }

        if (zScope && zScope !== rootScope) {
            return;
        }

        checkFunction(args[0]);
    });

    function checkFunction(ast) {
        let firstArg = ast.params[0];
        if (!firstArg) {
            return;
        }

        traverse(ast, (node, scope, parent) => {
            if (parent === ast) {
                return;
            }
            if (node.type !== 'Identifier') {
                return;
            }
            if (!parent) {
                return;
            }
            if (parent.type === 'MemberExpression' &&
                parent.computed === false &&
                parent.property === node) {
                return;
            }
            if (parent.type === 'ObjectProperty' &&
                parent.key === node) {
                return;
            }

            let resolved = scope.resolve(node);
            if (resolved && resolved.value === firstArg) {
                result.push(node);
            }
        });
    }

    return result;
};</pre>
  </details>
</article>


<!-- F. Задача Framework-часов -->
<article class="article">
  <div class="anchor" id="f"></div>
  <h2>F. Задача Framework-часов</h2>
  
  <p>Авторы: Дмитрий Андриянов, Алексей Бережной @collapsus</p>
  <p>Участникам нужно было написать приложение для необычной предметной области при помощи готового фреймворка с не очень удобным API. Мы хотели дать участникам только базовую часть документации фреймворка — чтобы узнать подробности, требовалось прочитать его код. В качестве предметной области мы выбрали управление стрелочными часами.</p>

  <h4>Условие</h4>
  <p>Степан работает галактическим коллектором — собирает долги за ЖКХ по всей галактической Империи. Степану нравится его работа. Она дает возможность побывать в таких местах, куда в другой ситуации он никогда бы не попал. Море впечатлений и новых знакомств!</p>
  <p>Степану приходится часто перелетать с одной планеты на другую. Планеты вращаются по разным орбитам, поэтому на каждой планете собственный счёт времени. Секунды везде текут одинаково, но на разных планетах разное количество секунд в минуте, минут в часе, часов в сутках (но сутки всегда равны двум оборотам часовой стрелки). Также считается, что в прошлом была Точка начала отсчёта времени, в которой время на всех планетах было равно 0 (0 часов, 0 минут, 0 секунд).</p>
  <p>Пожалуйста, сделайте для Степана часы, которые могут переключаться между временем разных планет. Для этого вы можете использовать JavaScript и JS-фреймворк под названием Framework.</p>
  <p>Часы должны иметь три стрелки: часовую, минутную и секундную. В аргументах конструктора приходят параметры времени для планет и текущее время (количество секунд, прошедших от точки отсчета). Часы должны иметь кнопку переключения (циклического) между временем планет. При переводе стрелок можно двигать их по часовой стрелке или против неё (по наикратчайшему пути).</p>
  <p>При включении часов все стрелки указывают на значение 0. Необходимо кратчайшим путем перевести стрелки в положение, соответствующее указанному времени (параметр time) на первой планете из списка.</p>

  <details>
    <summary>Пример кода прошивки часов</summary>
<pre>const ONE_SECOND_DEGREES = 6;
const ONE_SECOND_FACTOR = 1 / Framework.SPEED * ONE_SECOND_DEGREES;

class MyClock extends Framework.Clock {
    constructor() {
        super();

        this.arrows.push(new Framework.Arrow("seconds", {
            color: "red"
        }));

        this.arrows.push(new Framework.Arrow("minutes", {
            weight: 3,
            length: 80
        }));

        this.arrows.push(new Framework.Arrow("hours", {
            weight: 3,
            length: 60
        }));

        this.buttons.push(new Framework.Button("A", () => {
            alert("A");
        }));

        this.tick = 0;
    }

    onBeforeTick() {
        const [arrow] = this.arrows;

        this.tick++;

        arrow.rotateFactor = this.tick % 10 ? 0 : ONE_SECOND_FACTOR;

        console.log("before: " + arrow.pos);
    }

    onAfterTick() {
        const [arrow] = this.arrows;

        console.log("after: " + arrow.pos);
    }
}</pre>
  </details>

  <p>Что мы узнали о фреймворке:</p>
  <ul>
    <li>часы — это класс, унаследованный от базового,</li>
    <li>у часов есть стрелки и кнопки,</li>
    <li>есть валик, к которому прикреплены стрелки; через небольшие промежутки времени (100 мс) валик проворачивается по часовой стрелке на определенный угол; можно управлять стрелками, меняя коэффициент вращения стрелки относительно валика.</li>
  </ul>

  <details>
    <summary>Решение</summary>
    <h4>Решение</h4>
    <p>Итак, на разных планетах время считается по-разному, но есть «Точка начала отсчёта времени», в результате чего количество секунд одинаково. Будем оперировать этой величиной, актуализируя её каждый тик, а затем пересчитывать время конкретной планеты, вычислять положение стрелок и перемещать их из текущего состояния в целевое.</p>
    <p>В исходной версии прошивки есть три стрелки: секундная, минутная и часовая. Секундная движется в соответствии с условиями задачи. Необходимо, чтобы минутная и часовая стрелки тоже двигалась, и нужно добавить кнопку переключения между временами планет с соответствующим поведением.</p>
    <p>Посмотрим исходный код фреймворка и для удобства определим константу:</p>
    <code>const TPS = 1000 / Framework.INTERVAL; // тиков в секунду</code>
    <p>Реализуем функцию пересчёта тиков в положение секундной/минутной/часовой стрелок в градусах для конкретной планеты.</p>
<pre>function getTarget(ticks, planet) {
  const { h, m, s } = planet; // временные параметры планеты
  const ts = Math.floor(ticks / TPS); // всего секунд

  const ss = ts % s * 360 / s;
  const mm = Math.floor(ts / s) % m * 360 / m;
  const hh = Math.floor(ts / (s * m)) % h * 360 / h;

  return { hh, mm, ss };
}</pre>

    <p>Фреймворк реализован так, что у нас есть единственный способ управления движением стрелок — это задавать коэффициент вращения rotateFactor. Для этого напишем вспомогательную функцию getRotateFactor, которая будет считать коэффициент вращения, получая текущее положение стрелки и то положение, к которому нужно прийти. У функции будет два режима:</p>
    <ol>
      <li>нормальный ход времени,</li>
      <li>перевод стрелок.</li>
    </ol>

    <p>Во втором режиме стрелки могут двигаться в обратную сторону. Режим передадим дополнительным параметром.</p>
<pre>function getRotateFactor(pos, target, forward = true) {
  let angle = target - pos; // на какой угол надо изменить положение стрелки

  if (forward) {
    // в случае обычного хода стрелок
    angle &lt; 0 && (angle += 360); // при прохождении круга количество градусов меняется от 0 до 360 (а 360 превращается в 0), нужно это учитывать
  } else {
    // в случае перевода двигаем стрелки по кратчайшему пути
    Math.abs(angle) &gt; 180 && (angle -= Math.sign(angle) * 360)
  }

  return angle / Framework.SPEED;
}</pre>

    <p>Из кода фреймворка мы узнаём, что есть ограничение MAX_SPEED на скорость перемещения стрелки. Нужно это учесть в функции getRotateFactor.</p>
<pre>const MAX_FACTOR = Framework.MAX_SPEED / Framework.SPEED;

function getRotateFactor(pos, target, forward = true) {
  let angle = target - pos;

  if (forward) {
    angle &lt; 0 && (angle += 360);
  } else {
      Math.abs(angle) &gt; 180 && (angle -= Math.sign(angle) * 360)
  }

  const factor = angle / Framework.SPEED;
  // если желаемый коэффициент превышает максимально допустимый, берём максимально допустимый
  return Math.abs(factor) > MAX_FACTOR ? Math.sign(factor) * MAX_FACTOR : factor;
}</pre>

    <p>Задаём обработчик для кнопки переключения между планетами:</p>
<pre>buttonAHandler() {
    // циклически переключаемся между планетами
    this.pos = (this.pos + 1) % this.planets.length;
    // переходим в режим перевода стрелок
    this.forward = false;
  }</pre>

    <p>Таким образом, при каждом тике происходит следующее:</p>
<pre>onBeforeTick() {
    const [sec, min, hour] = this.arrows;
    const time = ++this.ticks;
    const planet = this.planets[this.pos];

    // высчитываем положение стрелок к которому хотим прийти
    const target = getTarget(time, planet);
    // задаём каждой стрелке коэффициент вращения
    sec.rotateFactor = getRotateFactor(sec.pos, target.ss, this.forward);
    min.rotateFactor = getRotateFactor(min.pos, target.mm, this.forward);
    hour.rotateFactor = getRotateFactor(hour.pos, target.hh, this.forward);

    // выходим из режима перевода стрелок только тогда, когда все стрелки достигли желаемой позиции
    !sec.rotateFactor && !min.rotateFactor && !hour.rotateFactor && (this.forward = true);
  }</pre>

    <h4>Полный код решения:</h4>
<pre>const TPS = 1000 / Framework.INTERVAL;
const MAX_FACTOR = Framework.MAX_SPEED / Framework.SPEED;

function getTarget(ticks, planet) {
    const { h, m, s } = planet;
    const ts = Math.floor(ticks / TPS); // total seconds

    const ss = ts % s * 360 / s;
    const mm = Math.floor(ts / s) % m * 360 / m;
    const hh = Math.floor(ts / (s * m)) % h * 360 / h;

    return { hh, mm, ss };
}

function getRotateFactor(pos, target, forward = true) {
    let angle = target - pos;

    if (forward) {
        angle &lt; 0 && (angle += 360);
    } else {
        Math.abs(angle) &gt; 180 && (angle -= Math.sign(angle) * 360)
    }

    const factor = angle / Framework.SPEED;

    return Math.abs(factor) &gt; MAX_FACTOR ? Math.sign(factor) * MAX_FACTOR : factor;
}

class MyClock extends Clock {

    // planets - параметры планет
    // [ { h: 4, m: 20, s: 10 }, ... ]
    constructor({ planets, time }) {
        super();

        this.arrows.push(new Arrow('seconds', {
            color: 'red'
        }));
        this.arrows.push(new Arrow('minutes', {
            weight: 3,
            length: 80
        }));
        this.arrows.push(new Arrow('hours', {
            weight: 3,
            length: 60
        }));

        this.buttons.push(new Button('Switch', this.buttonAHandler.bind(this)));

        this.planets = planets;
        this.ticks = time * TPS;
        this.pos = 0;
        this.forward = false;
    }

    onBeforeTick() {
        const [sec, min, hour] = this.arrows;
        const time = ++this.ticks;
        const planet = this.planets[this.pos];

        const target = getTarget(time, planet);
        sec.rotateFactor = getRotateFactor(sec.pos, target.ss, this.forward);
        min.rotateFactor = getRotateFactor(min.pos, target.mm, this.forward);
        hour.rotateFactor = getRotateFactor(hour.pos, target.hh, this.forward);

        !sec.rotateFactor && !min.rotateFactor && !hour.rotateFactor && (this.forward = true);
    }

    buttonAHandler() {
        this.pos = (this.pos + 1) % this.planets.length;
        this.forward = false;
    }
}</pre>
    
    <h4>Тестирование</h4>
    <p>Задание проверялось автотестами. В них мы сделали заглушку для генератора тиков и передавали её в параметрах конструктора. Таким образом, вместо того, чтобы генерировать тики по таймеру, мы генерировали нужное количество тиков в коде теста и затем проверяли состояние стрелок.</p>
    <p>Мы проверяли несколько ситуаций: стандартное движение стрелок, дискретность движения, перевод стрелок, превышение максимальной скорости, направление движения стрелок при переводе (условия, связанные с направлением, были разными в разных вариантах задачи).</p>

    <h4>Вывод</h4>
    <p>Задача получилась довольно сложной. Участникам нужно было разобраться в необычной предметной области и незнакомом фреймворке. Часть условий были скрыты — например, максимальная скорость и возможность обратного хода. Узнать о них можно было только из кода фреймворка.</p>
    <p>По нашей оценке, задача должна была занять около часа. Полностью её решили всего четыре человека, а больше нуля баллов (пройдя не все тесты) набрали 18 участников.</p>
  </details>
</article>














