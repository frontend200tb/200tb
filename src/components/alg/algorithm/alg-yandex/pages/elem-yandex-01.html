<h1>Задачи на алгоритмических собеседованиях в Яндекс</h1>


<!-- Ссылки -->
<article class="article">
  <h2>Ссылки</h2>
  <p><a href="https://www.youtube.com/@atlzgamer/streams">youtube Федор Алексеев</a></p>
  <p><a href="https://yandex.ru/cup/algorithm/analysis/">yandex.ru Задачи разминочного раунда Яндекс.Алго­ритма-2018</a></p>
  <p><a href="https://ru.hexlet.io/blog/posts/grokaem-algoritmy-gayd-po-algoritmam-dlya-teh-komu-slozhno-reshat-zadachi">ru.hexlet.io Грокаем алгоритмы</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p><a href="#task-1">1. Поиск двух чисел в массиве с определённой разницей</a></p>
  <p><a href="#task-2">2. Поиск двух чисел в массиве с определённой суммой</a></p>
  <p><a href="#task-3">3. Поиск всех комбинаций чисел, сумма которых равна 10</a></p>
  <p><a href="#task-4">4. Пересечение массивов чисел. Сколько минут работают все кассы одновременно</a></p>
  <p><a href="#task-5">5. Проверить число Фибоначчи</a></p>
  <p><a href="#task-6">6. Шахматная доска. Количество пар ладей, которые бьют друг друга</a></p>
  <p><a href="#task-7">7. Словарь с текстом и ударной буквой</a></p>
  <p><a href="#task-8">8. Свернуть числа в диапазоны</a></p>
  <p><a href="#task-9">9. Длина максимальной уникальной последовательности</a></p>
  <p><a href="#task-10">10. Длина наибольшей уникальной подстроки</a></p>
  <p><a href="#task-11">11. Найти удаленное число из последовательности</a></p>
  <p><a href="#task-12">12. Поиск соствного авиабилета</a></p>
  <p><a href="#task-13">13. В массиве дубликатов найти число не дубликат</a></p>
  <p><a href="#task-14">14. Даются q запросов, прибавить 1 к элементам массива по запросу</a></p>
  <p><a href="#task-15">15. Монотонный подотрезок максимальной длины</a></p>
  <p><a href="#task-16">16. Восстановить маршрут поездки по билетам</a></p>
  <p><a href="#task-17">17. Когда все сотрудники работают одновременно</a></p>
  <p><a href="#task-18">18. Скобочная последовательность</a></p>
</article>


<!-- 1. Поиск двух чисел в массиве с определённой разницей -->
<article class="article">
  <div class="anchor" id="task-1"></div>
  <h2>1. Поиск двух чисел в массиве с определённой разницей</h2>

  <h4>Задача у Федора Алексеева. Описание</h4>
  <p>Дан массив интов и число k >= 0. Найти количество пар элементов, разница которых >= k.</p>

  <h4>Пример</h4>
  <code>[1,2,3],2 // 1</code>
  <code>[1,1,2,2,3,3],2 // 4</code>

  <details>
    <summary>Решение</summary>
  <p>Решение я нашел сам и протестировал в ноде</p>
  <ol>
    <li>Отсортировать массив по возрастанию</li>
    <li>Объявить переменную для количества пар и присвоить значение 0</li>
    <li>Объявить левый указатель и присвоить значение 0</li>
    <li>Объявить правый указатель и присвоить значение длины массива -1</li>
    <li>Создать внешний цикл пока правый указатель больше левого делай внутренний цикл
      <ol>
        <li>Создать внутренний цикл пока разница элементов по этим указателям >= k увеличивать количество пар на 1 и увеличивать левый указатель на 1</li>
        <li>Левый указатель вернем в 0, а правый уменьшим на 1</li>
      </ol>
    </li>
    <li>Вернуть количество пар</li>
  </ol>
<pre>function findPairs(num, k) {
  let numSort = num.toSorted((a, b) => a - b);
  let pairs = 0;
  let left = 0;
  let right = numSort.length - 1;
  while (right &gt; left) {
    while (numSort[right] - numSort[left] >= k) {
      pairs++;
      left++;
    }
    left = 0;
    right--;
  }
  return pairs;
}</pre>
  </details>
</article>


<!-- 2. Поиск двух чисел в массиве с определённой суммой -->
<article class="article">
  <div class="anchor" id="task-2"></div>
  <h2>2. Поиск двух чисел в массиве с определённой суммой</h2>

  <h4>Задача с Тренировки по алгоритмам 5.0. Описание</h4>

  <p>В массиве целых чисел найти пару элементов, сумма которых ближе всего к целевому значению (или равна).</p>

  <h4>Пример</h4>
  <code>Вход: nums = [10, 15, 3, 7], k = 17</code>
  <code>Выход: 10, 7</code>

  <h4>Решение 1. Неэффективное</h4>
  <p>Можно за O(n^2). Перебрать каждый с каждым элементом и найти решение. Это нам не подходит. Нужен более эффективный алгоритм</p>
</article>


<!-- 3. Поиск всех комбинаций чисел, сумма которых равна 10 -->
<article class="article">
  <div class="anchor" id="task-3"></div>
  <h2>3. Поиск всех комбинаций чисел, сумма которых равна 10</h2>

  <p>Написать функцию, которая из входящено массива выберет все комбинации чисел, сумма которых будет равна 10</p>
  <p>Не существует более эффективного решения чем полный перебор. Полный перебор всех сочетаний имеет экспоненциальную сложность O(2^N).</p>
</article>


<!-- 4. Пересечение массивов чисел. Сколько минут работают все кассы одновременно -->
<article class="article">
  <div class="anchor" id="task-4"></div>
  <h2>4. Пересечение массивов чисел. Сколько минут работают все кассы одновременно</h2>

  <h4>Задача с Тренировки по алгоритмам 5.0. Описание</h4>
  <p>На вокзале билеты продаются в N кассах. Каждая касса работает без перерыва определенный промежуток времени по фиксированному расписанию (одному и тому же каждый день). Требуется определить, сколько минут в течение суток работают все кассы одновременно.</p>

  <h4>Пример</h4>
  <code>N = 3</code>
  <code>01:00 23:00</code>
  <code>12:00 12:00</code>
  <code>22:00 02:00</code>
  <code>Ответ: 120 (с 22:00 до 23:00 и с 01:00 до 02:00)</code>

  <details>
    <summary>Решение</summary>
  </details>
</article>


<!-- 5. Проверить число Фибоначчи -->
<article class="article">
  <div class="anchor" id="task-5"></div>
  <h2>5. Проверить число Фибоначчи</h2>

  <h4>Задача с Тренировки по алгоритмам 5.0. Описание</h4>

  <p>Проверить, является ли длинное число (до 5000 цифр) числом Фибоначчи.</p>

  <p>С такими большими числами нужно использовать остаток от деления, чтобы записывать их в словарь. Найдем все числа Фибоначчи на 40000 шагах и запишем их в три словаря, по остаткам от деления на три разных числа. Потом будем проверять длинное число есть ли оно сразу в трех словарях по его остатку от деления на эти же три разных числа. Если в словарях такого числа нет, то оно точно не число Фибоначчи. Если во всех трех словарях такое число есть, то это число Фибоначчи с большой долей вероятности.</p>
</article>


<!-- 6. Шахматная доска. Количество пар ладей, которые бьют друг друга -->
<article class="article">
  <div class="anchor" id="task-6"></div>
  <h2>6. Шахматная доска. Количество пар ладей, которые бьют друг друга</h2>

  <h4>Задача с Тренировки по алгоритмам 5.0. Описание</h4>
  <p>На шахматной доске N*N находятся M ладей (ладья бьет клетки на той же горизонтали или вертикали до ближайшей занятой). Определите, сколько пар ладей бьют друг друга.</p>
  <p>Ладьи задаются парой чисел i и j, обозначающих координаты клетки.</p>
  <code>1 &lt;= N &lt;= 10^9, 0 &lt;= M &lt;= 2*10^5</code>

  <h4>Решение</h4>
  <p>Перебрать каждую ладью и посомтреть сколько ладей стоит с ней на одной горизонтали или вертикали не реально. Тем более что между ладьями может стоят еще третья ладья. Воспользуемся комбинаторикой. Пусть у нас на одной линии (горизонтали или вертикали) стоит k ладей. Тогда k-1 пара ладьей бьют друг друга. Таким образом надо посчитать количество ладьей в каждой горизонтали и вертикали. Массив размера милиард на милиард мы не сделаем. Поэтому создадим два словаря. Один для горизонталей, второй для вертикалей.</p>
  <p>Для каждой занятой горизонтали и вертикали будем хранить количество ладей на них. Количество пар в горизонтали (вертикали) равно количество ладей минус 1. Суммируем это количество пар для всех горизонталей и вертикалей.</p>
</article>


<!-- 7. Словарь с текстом и ударной буквой -->
<article class="article">
  <div class="anchor" id="task-7"></div>
  <h2>7. Словарь с текстом и ударной буквой</h2>

  <h4>Задача с Тренировки по алгоритмам 5.0. Описание</h4>
  <p>Есть словарь, где в каждом слове выделена ударная буква, также задан текст.</p>
  <p>Для каждого слова словаря проверить, что ударение ровно одно и слово с таким ударением есть в словаре.</p>
  <p>Если слова нет в словаре, но в нем ровно одно ударение - будем считать его правильным</p>

  <h4>Пример</h4>
  <p>Есть слова в словаре Ab, Abc, aBc</p>
  <code>Ab // true</code>
  <code>aB // false</code>
  <code>aBc // true</code>
  <code>abC // false</code>
  <code>aBC // false слово сдвумя ударениями</code>
  <code>abF // true слово с одним ударением и его нет в словаре</code>

  <h4>Решение</h4>
  <p>Создадим два словаря: с ударением и без ударения</p>
  <p>Если слово без ударения есть в словаре слов без ударений - проверяем точное вхождение этого слова в словарь с ударением</p>
  <p>Иначе просто проверяем, что в нем ровно одно ударение</p>
  <p>Тут два варианта решения задачи - через Множества и через Словари.</p>
</article>


<!-- 8. Свернуть числа в диапазоны -->
<article class="article">
  <div class="anchor" id="task-8"></div>
  <h2>8. Свернуть числа в диапазоны</h2>

  <p>Дан список целых чисел, повторяющихся элементов в списке нет. Нужно преобразовать это множество в строку, сворачивая соседние по числовому ряду числа в диапазоны.</p>

  <h4>Пример 1</h4>
  <code>Input: [1,4,5,2,3,9,8,11,0]</code>
  <code>Output: "0-5,8-9,11"</code>

  <h4>Пример 2</h4>
  <code>Input: [1,4,3,2]</code>
  <code>Output: "1-4"</code>

  <h4>Пример 3</h4>
  <code>Input: [1,4]</code>
  <code>Output: "1,4"</code>

  <details>
    <summary>Решение за O(NlogN)</summary>
<pre>function enroll(nums) {
  // отсортируем входной массив
  let snums = nums.sort((a,b) => a - b);
  let result = [];
  // если массив пустой то в результат
  // попадет пустая строка
  let prev = snums[0] ?? '';
  let start = prev;
  let count = 1;

  for (let i = 1; i &lt; snums.length; i++) {
    const next = snums[i];
    if (next - prev === 1) {
      prev = next;
      count++;
    } else if (count === 1) {
      result.push(start);
      prev = next;
      start = prev;
    } else {
      result.push(`${start}-${prev}`);
      prev = next;
      start = prev;
      count = 1;
    }
  }
  if (count === 1) {
    result.push(start);
  } else {
    result.push(`${start}-${prev}`);
  }

  return result.join(',');
}</pre>
  </details>
</article>


<!-- 9. Длина максимальной уникальной последовательности -->
<article class="article">
  <div class="anchor" id="task-9"></div>
  <h3>9. Длина максимальной уникальной последовательности</h3>

  <p>Написать функцию, которая на вход принимает массив целых чисел и должна вернуть длину максимального непрерывного подмассива, в котором нет повторяющихся элементов</p>

  <details>
    <summary>Ответ</summary>
<pre>function maxLenght(nums) {
  let result = 0;
  let arr = [];

  for (let i = 0; i &lt; nums.length; i++) {
    if (arr.indexOf(nums[i]) !== -1) {
      result = Math.max(result, arr.length);
      arr = arr.slice(arr.indexOf(nums[i]) + 1);
      arr.push(nums[i]);
    } else {
      arr.push(nums[i]);
    }
  }

  return result;
}</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <ol>
      <li>Заведем переменную result для хранения результата
        <code>let result = 0;</code>
      </li>
      <li>Заведем массив arr для хранения последовательности уникальных чисел
        <code>let arr = [];</code>
      </li>
      <li>В цикле пройдем по входному массиву nums
        <code>for (let i = 0; i &lt; nums.length; i++) {}</code>
      </li>
      <li>Если очередное число есть в массиве arr, то обновляем переменную result и меняем уникальный массив arr. Оставляем все числа после найденного и добавляем очередное число</li>
      <li>Если очередного числа нет в массиве arr, то добавляем очередное число</li>
    </ol>
  </details>
</article>


<!-- 10. Длина наибольшей уникальной подстроки -->
<article class="article">
  <div class="anchor" id="task-10"></div>
  <h3>10. Длина наибольшей уникальной подстроки</h3>

  <p>На вход подается строка. Нужно определить длину наибольшей подстроки, которая не содержит повторяющиеся символы</p>

  <h4>Пример</h4>
  <code>'abcabcbb' // 3</code>

  <details>
    <summary>Ответ</summary>
<pre>function length(str) {
  let result = 0;
  let cur = [];

  for (let i = 0; i &lt; str.length; i++) {
    if (cur.indexOf(str[i]) === -1) {
      cur.push(str[i]);
    } else {
      result = Math.max(result, cur.length);
      cur = cur.slice(cur.indexOf(str[i]) + 1);
      cur.push(str[i]);
    }
  }
  result = Math.max(result, cur.length);

  return result;
}</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <ol>
      <li>Заведем переменную result для хранения результата
        <code>let result = 0;</code>
      </li>
      <li>Заведем массив cur для хранения символов текущей подстроки
        <code>let cur = [];</code>
      </li>
      <li>В цикле пройдем по входной строке
        <code>for (let i = 0; i &lt; str.length; i++) {}</code>
      </li>
      <li>Если очередной буквы нет в массиве cur, то добавляем ее</li>
      <li>Если очередная буква есть в массиве cur,  то обновляем переменную result и меняем массив cur. Оставляем все буквы после найденной и добавляем очередную букву</li>
    </ol>
  </details>
</article>


<!-- 11. Найти удаленное число из последовательности -->
<article class="article">
  <div class="anchor" id="task-11"></div>
  <h2>11. Найти удаленное число из последовательности</h2>

  <h4>Поиск одного пропущенного числа</h4>
  <p>На вход приходит массив, который содержит числа от 1 до n. Но числа случайным образом перемешали и одно число удалили. Найти удаленное число.</p>
  
  <h4>Пример</h4>
  <code>Input: [4,2,5,1]</code>
  <code>Output: 3</code>

  <details>
    <summary>Решение</summary>
    <ol>
      <li>Создадим новый массив res с длиной на 2 больше чем nums, добавляя память для нулевого и пропущенного элемента. Заполним новый массив значением false
        <code>const res = Array(nums.length + 2).fill(false);</code>
      </li>
      <li>Цмклом пройдем по входному массиву nums и для каждого числа запишем в такой же индекс нового массива res значение true</li>
      <li>Найдем индекс элемента массива arr, начиная с первого у которого значение false</li>
    </ol>
<pre>function getMissNumber(nums) {
  const res = Array(nums.length + 2).fill(false);

  for (i = 0; i &lt; nums.length; i++) {
    res[nums[i]] = true;
  }

  const first = res.indexOf(false, 1);

  return first;
}

const w1 = [4,2,5,8,1,3,6];

console.log(getMissNumber(w1));  // 7</pre>
  </details>

  <h4>Поиск двух пропущенных чисел</h4>
  <p>Усложним задачу. Найти два пропущенных числа.</p>

  <details>
    <summary>Решение</summary>
  <ol>
    <li>Создадим новый массив res с длиной на 3 больше чем nums, добавляя память для нулевого и двух пропущенных элементов. Заполним новый массив значением false
      <code>const res = Array(nums.length + 3).fill(false);</code>
    </li>
    <li>Цмклом пройдем по входному массиву nums и для каждого числа запишем в такой же индекс нового массива res значение true</li>
    <li>Найдем индекс элемента массива arr, начиная с первого у которого значение false. Это первый пропущенный номер</li>
    <li>Найдем индекс элемента массива arr, начиная с первого пропущенного у которого значение false. Это второй пропущенный номер</li>
  </ol>
  </details>
</article>


<!-- 12. Поиск соствного авиабилета -->
<article class="article">
  <div class="anchor" id="task-12"></div>
  <h3>12. Поиск соствного авиабилета</h3>

  <p>Задача про асинхронность, помисы. У нас есть асинхронная функция
  <code>function fetchFlights(from) {}</code>
  которая принимает город и возвращает массив городов куда можно перелететь из этого города.
  </p>
  <p>Надо написать функцию findPath(), которая принимает начальную и конечную точку и функцию получения городов fetchFlights(). Возвращает промис, который станет reject если в город невозможно долететь из данного города, или станет resolve и вернет маршрут от одного города до другого</p>
  <p>Известно что маршрут если есть, то только один и нет никаких петель. То есть каждый город маршрута будет только один раз.</p>

  <h4>Пример</h4>
  <code>graph = {A: [B, D], B: [C, N, Z], D: [E, F], F: [S]}</code>
  <code>findPath('A', 'N', fetchFlights) // Promise.resolve(['A', 'B', 'N'])</code>
  <code>findPath('A', 'S', fetchFlights) // Promise.resolve(['A', 'D', 'F', 'S'])</code>
  <code>findPath('B', 'S', fetchFlights) // Promise.reject(new Error('No way'))</code>

  <details>
    <summary>Решение</summary>
    <p>Пока придумал решение только если маршрут из двух городов</p>
<pre>function fetchFlights(from) {
  const graph = {A: ['B', 'D'], B: ['C', 'N', 'Z'], D: ['E', 'F'], F: ['S']};
  return graph[from]
}

function findPath (from, to, fetchFlights) {
  const result = [from];

  while (true) {
    const dest = fetchFlights(from);
    const town = dest.filter(town => to === town);
    result.push(...town);

    break;
  }


  if (result.length === 1) {
    return Promise.resolve('No way');
  } else {
    return Promise.resolve(result);
  }
}


console.log(findPath('A', 'B', fetchFlights)); //Promise { [ 'A', 'B' ] }
console.log(findPath('A', 'C', fetchFlights)); // Promise { 'No way' }</pre>
  </details>
</article>


<!-- 13. В массиве дубликатов найти число не дубликат -->
<article class="article">
  <div class="anchor" id="task-13"></div>
  <h3>13. В массиве дубликатов найти число не дубликат</h3>

  <p>К нам приходит массив целых чисел, в котором каждое число встречается 2 раза и лишь одно число встречается 1 раз. Найти это число.</p>

  <details>
    <summary>Решение с сортировкой за O(NlogN)</summary>
    <p>Отсортировать массив. После этого в цикле пройтись по отсортированному массиву. У каждого элемента будет одинаковый сосед справа, а у нужного числа нет.</p>
    <p>Отдельно обработаем случай если элемент последний или такого элемента нет. Если такого элемента нет, то возвращаем null</p>
<pre>function findNum(nums) {
  nums.sort((a, b) => a -b);
  let elem = nums[0];

  for (let i = 0; i &lt; nums.length - 1; i += 2) {
    if (nums[i] !== nums[i + 1]) {
      return nums[i];
    }
  }

  if (nums.length % 2 === 1) {
    return nums.at(-1);
  } else {
    return null;
  }
  
}</pre>
  </details>

  <details>
    <summary>Решение со словарем за O(N) по времени и O(N) по памяти</summary>
    <p>Создадим пустой словарь. Циклом пройдем по массиву. Если элемета нет в словаре, то записываем его в словарь. Если элемент есть в словаре, то удаляем его из словаря. Проверяем длину словаря. Если равна 1, то остался только нужный элемент. Если нет, то такого элемента нет и возвращаем null</p>
<pre>function findNum(nums) {
  let dict = {};

  for (let i = 0; i &lt; nums.length; i += 1) {
    if (!dict[nums[i]]) {
      dict[nums[i]] = true;
    } else {
      delete dict[nums[i]];
    }
  }

  if (Object.keys(dict).length === 1) {
    return Object.keys(dict)[0];
  } else {
    return null;
  }
}</pre>
  </details>

  <details>
    <summary>Решение за O(N) по времени и O(1) по памяти</summary>
    <p>Если ко всем числам использовать операцию исключающего или, то дубликаты в итоге дадут ноль, а останется только нужное число</p>
<pre>function findNum(nums) {

  const result = nums.reduce((acc, next) => {
    return acc ^ next;
  })

  return result === 0 ? null: result;
}</pre>
  </details>
</article>


<!-- 14. Даются q запросов, прибавить 1 к элементам массива по запросу -->
<article class="article">
  <div class="anchor" id="task-14"></div>
  <h3>14. Даются q запросов, прибавить 1 к элементам массива по запросу</h3>

  <p>Дан массив nums длины n и число q. После даются q запросов, каждый запрос это два числа l и r (1 &le; l &le; r &le; n), вы должны прибавить к числам nums[l], nums[l+1], ..., nums[r] единицу. В конце вывести массив nums</p>

  <h4>Пример</h4>
  <code>nums = [5,1,3,2,4,0], q = [[2,4]] // [5,1,4,3,5,0]</code>
  <code>nums = [5,1,3,2,4,0], q = [[0,1],[4,5]] // [6,2,3,2,5,1]</code>

  <details>
    <summary>Решение</summary>
    <p>Циклом пройдем по всем запросам q. Для каждого запроса цикром пройдем от l до r. Для каждого элемента массива nums от l до r увеличим его значение на 1.</p>
<pre>function addOne(nums, q) {
  for (let i = 0; i &lt; q.length; i++) {
    for (j = q[i][0]; j &lt;= q[i][1]; j++) {
      nums[j] += 1;
    }
  }

  return nums
}</pre>
  </details>
</article>


<!-- 15. Монотонный подотрезок максимальной длины -->
<article class="article">
  <div class="anchor" id="task-15"></div>
  <h3>15. Монотонный подотрезок максимальной длины</h3>

  <p>Дан массив чисел a1, a2, ... , an. Найти монотонный подотрезок ( то есть строго убывающий или строго возрастающий) максимальной длины и вернуть пару индексов его начала и конца</p>

  <h4>Пример</h4>
  <code>[2, 7, 5, 4, 4, 3] // [1, 3]</code>
  <code>[2, 7, 5, 6, 7, 8] // [2, 5]</code>

  <details>
    <summary>Решение</summary>
<pre>function findMax(nums) {
  if (nums.length === 0) return null;

  let curInc = [0, 0];
  let curDec = [0, 0];
  let max = [0, 0];

  for (let i = 1; i &lt; nums.length; i++) {
    if (nums[i] > nums[i-1]) {
      // increase
      curInc[1] += 1;
      if (max[1] - max[0] &lt; curDec[1] - curDec[0]) max = curDec;
      curDec = [i, i];
    } else if (nums[i-1] &gt; nums[i]) {
      // decrease
      curDec[1] += 1;
      if (max[1] - max[0] &lt; curInc[1] - curInc[0]) max = curInc;
      curInc = [i, i];
    } else {
      if (max[1] - max[0] &lt; curInc[1] - curInc[0]) max = curInc;
      if (max[1] - max[0] &lt; curDec[1] - curDec[0]) max = curDec;
      curInc = [i, i];
      curDec = [i, i];
    }
    //console.log('max', max)
  }
  if (max[1] - max[0] &lt; curInc[1] - curInc[0]) max = curInc;
  if (max[1] - max[0] &lt; curDec[1] - curDec[0]) max = curDec;

  return max;
}

console.log(findMax([2, 7, 5, 4, 4, 3])); // [1, 3]
console.log(findMax([2, 7, 5, 6, 7, 8])); // [2, 5]
console.log(findMax([5])); // [0,0]
console.log(findMax([])); // null
</pre>
  </details>
</article>


<!-- 16. Восстановить маршрут поездки по билетам -->
<article class="article">
  <div class="anchor" id="task-16"></div>
  <h3>16. Восстановить маршрут поездки по билетам</h3>

  <p>На вход приходит массив объектов, каждый с двумя свойствами - from и to. Это билеты. Необходимо отсортировать их в порядке от начального города до конечного</p>

  <h4>input</h4>
<pre>[
  { from: 'Петербутр', to: 'Минск' },
  { from: 'Киев', to: 'Новосибирск' },
  { from: 'Череповец', to: 'Москва' },
  { from: 'Минск', to: 'Киев' },
  { from: 'Москва', to: 'Петербург' }
]</pre>

  <h4>input</h4>
<pre>[
  { from: 'Череповец', to: 'Москва' },
  { from: 'Москва', to: 'Петербург' },
  { from: 'Петербутр', to: 'Минск' },
  { from: 'Минск', to: 'Киев' },
  { from: 'Киев', to: 'Новосибирск' }
]</pre>

  <details>
    <summary>Решение</summary>
    <ol>
      <li>Создадим объект fromCities где ключами будут города отправления а значением билеты с отправлением из этих городов</li>
      <li>Создадим объект toCities где ключами будут города назначения а значением билеты с назначением в этих городах</li>
      <li>Первый город маршрута будет ключ из первого объекта, которого нет во втором.</li>
      <li>Циклом пройдем по всем билетам и будем добавлять в маршрут билеты, начиная с первого города маршрута. Следующим городом отправления выбирается город назначения в добавленном билете.</li>
    </ol>
<pre>function getRoute(input) {
  const fromCities = {};
  const toCities = {};

  input.forEach(elem => {
    fromCities[elem.from] = elem;
    toCities[elem.to] = elem;
  })

  let start = '';
  
  for (let city in fromCities) {
    if (!toCities[city]) {
      start = city;
    }
  }
  
  const route = [];

  for (let i = 0; i &lt; input.length; i++) {
    route.push(fromCities[start]);
    start = fromCities[start].to;
  }

  return route;
}</pre>
  </details>
</article>


<!-- 17. Когда все сотрудники работают одновременно -->
<article class="article">
  <div class="anchor" id="task-17"></div>
  <h3>17. Когда все сотрудники работают одновременно</h3>

  <p>Дан список отсутствий работников на рабочем месте, например [9,10] - с 9:00 до 10:00. Требуется вывести диапазоны часов, когда все работники были на местах. Рабочий день: 9-18ч.</p>

  <h4>Пример</h4>
  <code>input: [[9,10],[15,17],[14,16]]</code>
  <code>output: [[10,14],[17,18]]</code>

  <details>
    <summary>Решение</summary>

    <ol>
      <li>Циклом пройдем по входному массиву и занесем все часы, в которые работники отсутствуют, в структуру данных Set. Заметим, что если это [9,10] то в 9 часов он отсутствовал, а в 10 часов уже былл на работе.
        <code>const absTimesSet = new Set(input.flatMap(...))</code>
      </li>
      <li>Создадим указатель на первый час, когда все были на работе
        <code>let left = 9;</code>
      </li>
      <li>Создадим пустой массив для записи результата
        <code>const result = [];</code>
      </li>
      <li>Циклом пройдем по всем рабочим часам от 9 до 18. Проверим, если тукущий час есть в наборе absTimesSet то запишем в массив диапазон от left до текущего часа. После этого left присвоим i + 1, то есть left будет указывать на следующий час.</li>
      <li>Отдельно обработаем случай, когда в последний час все были на работе</li>
    </ol>
<pre>function getClock(input) {
  const absTimesSet = new Set(input.flatMap(times => {
    let time = [];
    for (let i = times[0]; i &lt; times[1]; i++) {
      time.push(i);
    }
    return time;
  }));

  let left = 9;
  const result = [];

  for (let i = 9; i &lt;= 18; i++) {
    if (absTimesSet.has(i)) {
      if (left !== i) {
        result.push([left, i]);
      }
      left = i + 1;
    }
  }

  if (left !== 18) {
    result.push([left, 18]);
  }      

  return result;
}</pre>
  </details>
</article>


<!-- 18. Скобочная последовательность -->
<article class="article">
  <div class="anchor" id="task-18"></div>
  <h3>18. Скобочная последовательность</h3>

  <p>На вход подается скобочная последовательность. Надо определить правильная она или нет</p>

  <h4>Примеры</h4>
  <code>'' // true</code>
  <code>'()' // true</code>
  <code>')()('' // false</code>
  <code>'((()))' // true</code>

  <details>
    <summary>Ответ</summary>
<pre>function brackets(str) {
  let stack = [];
  let open = '(';

  for (let i = 0; i &lt; str.length; i++) {
    if (str[i] === open) {
      stack.push(str[i]);
    } else if (stack.at(-1) === open) {
      stack.pop();
    } else {
      return false;
    }
  }
 
  if (stack.length > 0) {
    return false;
  }

  return true;
}</pre>
  </details>
</article>

