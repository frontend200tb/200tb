<h1>Тренировки по алгоритмам 1.0 (2021.06.30)</h1>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>
  <ol>
    <li>
      <a href="#l1">Лекция №1. Сложность, тестирование, особые случаи</a>
      <ol>
        <li>
          <a href="#l1-tema-1">Тема 1. Сложность алгоритмов</a>
          <ul>
            <li><a href="#l1-task-1">Задача 1. Самый частый символ</a></li>
          </ul>
        </li>
        <li>
          <a href="#l1-tema-2">Тема 2. Особые случаи</a>
          <ul>
            <li><a href="#l1-task-2">Задача 2. Сумма последовательности</a></li>
            <li><a href="#l1-task-3">Задача 3. Максимум последовательности</a></li>
          </ul>
        </li>
        <li>
          <a href="#l1-tema-3">Тема 3. Тестирование</a>
          <ul>
            <li><a href="#l1-task-4">Задача 4. Квадратное уравнение</a>
          </ul>
        </li>          
      </ol>
    </li>
    <li>
      <a href="#l2">Лекция №2. Линейный поиск</a>
      <ol>
        <li>
          <a href="#l2-tema-1">Тема 1. Классические задачи линейного поиска</a>
          <ul>
            <li><a href="#l2-task-1">Задача 1. Найти первое вхождение</a></li>
            <li><a href="#l2-task-2">Задача 2. Найти последнее вхождение</a></li>
            <li><a href="#l2-task-3">Задача 3. Найти максимальное число</a></li>
            <li><a href="#l2-task-4">Задача 4. Найти максимальное и второе по величине число</a></li>
            <li><a href="#l2-task-5">Задача 5. Найти минимальное четное число</a></li>
          </ul>          
        </li>
        <li>
          <a href="#l2-tema-2">Тема 2. Два прохода</a>
          <ul>
            <li><a href="#l2-task-6">Задача 6. Самые короткие слова</a></li>
            <li><a href="#l2-task-7">Задача 7. Сколько воды осталось на острове после сильного дождя</a></li>
          </ul>
        </li>          
        <li><a href="#l2-tema-3">Тема 3. Задача с собеседования. RLE сжатие строки</a> </li>
      </ol>
    </li>
    <li>
      <a href="#l3">Лекция №3. Множества</a>
          <ol>
            <li>
              <a href="#l3-tema-1">Тема 1. Как устроено множество</a>
              <ul>
                <li><a href="#l3-task-1">Задача 1. Написать свое множество</a></li>
              </ul>
            </li>
            <li><a href="#l3-tema-2">Тема 2. Амортизированная сложность</a></li>
            <li>
              <a href="#l3-tema-3">Тема 3. Примеры задач</a>
              <ul>
                <li><a href="#l3-task-2">Задача 2. Найти два числа с заданной суммой</a></li>
                <li><a href="#l3-task-3">Задача 3. Входит ли в словарь слово, возможно с пропущеной буквой</a></li>
              </ul>
            </li>
          </ol>
    </li>
    <li>
      <a href="#l4">Лекция №4. Словари и сортировка подсчетом</a>
      <ol>
        <li>
          <a href="#l4-tema-1">Тема 1. Сортировка подсчетом</a>
          <ul>
            <li><a href="#l4-task">Задача. Сортировка последовательности из K различных чисел</a></li>
            <li><a href="#l4-task-1">Задача 1. Можно ли получить число из другого перестановкой цифр</a></li>
          </ul>
        </li>
        <li>
          <a href="#l4-tema-2">Тема 2. Словари</a>
          <ul>
            <li><a href="#l4-task-2">Задача 2. Сколько пар ладей бьют друг друга</a></li>
            <li><a href="#l4-task-3">Задача 3. Гистограмма Hello, world!</a></li>
          </ul>
        </li>
        <li>
          <a href="#l4-tema-3">Тема 3. Задел под оптимизацию</a>
          <ul>
            <li><a href="#l4-task-4">Задада 4. Сгруппировать слова по общим буквам</a></li>
          </ul>
        </li>
      </ol>
    </li>
    <li>
      <a href="#dzl12">Разбор ДЗ по лекции 1 и 2</a>
      <ol>
        <li><a href="#dzl1-1">Занятие 1. Узник замка Иф</a></li>
        <li><a href="#dzl1-2">Занятие 1. Метро</a></li>
        <li><a href="#dzl1-3">Занятие 1. Скорая помощь</a></li>
        <li><a href="#dzl2-1">Занятие 2. Симметричная последовательность</a></li>
        <li><a href="#dzl2-2">Занятие 2. Наибольшее произведение трех чисел</a></li>
        <li><a href="#dzl2-3">Занятие 2. Сапер</a></li>
        <li><a href="#dzl2-4">Занятие 2. Треугольник Максима</a></li>
      </ol>
    </li>
    <li>
      <a href="#l5">Лекция 5. Префиксные суммы и два указателя</a>
      <ol>
        <li><a href="#l5-1">Префиксные суммы</a></li>
        <li><a href="#l5-task-1">Задача 1. Сколько нулей на полуинтервале</a></li>
        <li><a href="#l5-task-2">Задача 2. Найти количество отрезков с нулевой суммой</a></li>
        <li><a href="#l5-2">Два указателя</a></li>
        <li><a href="#l5-task-3">Задача 3. Сколько пар чисел в разности больше определенного числа</a></li>
        <li><a href="#l5-task-4">Задача 4. Суммарный профессионализм команды</a></li>
        <li><a href="#l5-task-5">Задача 5. Два отсортированных массива слить в один</a></li>
      </ol>
    </li>
    <li>
      <a href="#l6">Лекция 6. Бинарный поиск</a>
      <ol>
        <li><a href="#l6-1">Бинарный поиск</a></li>
        <li><a href="#l6-task-1">Задача 1. Не менее трети родителей от общего числа</a></li>
        <li><a href="#l6-task-2">Задача 2. Сколько дней нужно чтобы решить N задач на leetcode</a></li>
        <li><a href="#l6-task-3">Задача 3. Максимальная длина стороны стикера для доски</a></li>
        <li><a href="#l6-task-4">Задача 4. Первое число, которое больше или равно заданному</a></li>
        <li><a href="#l6-task-5">Задача 5. Сколько раз число в ходит в последовательность</a></li>
        <li><a href="#l6-task-6">Задача 6. Размер аннуитентного ежемесячного платежа</a></li>
        <li><a href="#l6-task-7">Задача 7. Момент времени когда расстояние между велосипедистами минимально</a></li>
      </ol>
    </li>
    <li>
      <a href="#l34">Разбор ДЗ по лекции 3 и 4</a>
      <ol>
        <li><a href="#l3-1">Занятие 3. Черепахи</a></li>
        <li><a href="#l3-2">Занятие 3. Пробежки по Манхэттену</a></li>
        <li><a href="#l4-1">Занятие 4. Расшифровка письменности Майя</a></li>
        <li><a href="#l4-2">Занятие 4. Контрольная по ударениям</a></li>
        <li><a href="#l4-3">Занятие 4. Дополнительная проверка на списывание</a></li>
      </ol>
    </li>
    <li>
      <a href="#l7">Лекция 7. Сортировка событий</a>
      <ol>
        <li><a href="#l7-1">Сортировка событий</a></li>
        <li><a href="#l7-task-1">Задача 1. Максимальное количество человек было на сайте одновременно</a></li>
        <li><a href="#l7-task-2">Задача 2. Суммарное время посетителей на сайте</a></li>
        <li><a href="#l7-task-3">Задача 3. Какие показания счетчика увидел начальник</a></li>
        <li><a href="#l7-2">События на круге</a></li>
        <li><a href="#l7-task-4">Задача 4. Когда были заняты все парковочные места</a></li>
        <li><a href="#l7-task-5">Задача 5. Минимальное количество автомобилей, которые заняли все места</a></li>
        <li><a href="#l7-task-6">Задача 6. Номера минимального количества автомобилей, которые заняли все места</a></li>
      </ol>
    </li>
    <li>
      <a href="#l8">Лекция 8. Деревья</a>
      <ol>
        <li><a href="#l8-1">Собственный менеджер памяти</a></li>
        <li><a href="#l8-2">Бинарное дерево поиска</a></li>
        <li><a href="#l8-3">Обход деревьев</a></li>
      </ol>
    </li>
    <li>
      <a href="#l56">Разбор ДЗ по лекции 5 и 6</a>
      <ol>
        <li><a href="#l5-1">Занятие 5. Счет в гипершашках</a></li>
        <li><a href="#l5-2">Занятие 5. Робот</a></li>
        <li><a href="#l5-3">Занятие 5. Треугольники</a></li>
        <li><a href="#l6-1">Занятие 6. Субботник</a></li>
        <li><a href="#l6-2">Занятие 6. Медиана объединения</a></li>
      </ol>
    </li>
    <li>
      <a href="#l78">Разбор ДЗ по лекции 7 и 8</a>
      <ol>
        <li><a href="#l7-1">Занятие 7. Реклама</a></li>
        <li><a href="#l7-2">Занятие 7. Охрана</a></li>
        <li><a href="#l7-3">Занятие 7. Автобусы</a></li>
        <li><a href="#l7-4">Занятие 7. НГУ-стройка</a></li>
      </ol>
    </li>
  </ol>
</article>


<!-- Лекция №1. Сложность, тестирование, особые случаи -->
<article class="article">
  <div class="anchor" id="l1"></div>
  <h2>Лекция №1. Сложность, тестирование, особые случаи</h2>

  <p>Здравствуйте, меня зовут Михаил Густокашин. Я преподаю на факультете компьютерных наук в высшей школе экономики. Предмет про алгоритмы и структуры данных. Я не работаю в Яндексе, не провожу собеседования.</p>

  <h4>Чего хотят на алгоритмическом собеседовании?</h4>
  <ol>
    <li>Умения писать работаюдий код</li>
    <li>Умения тестировать свой код</li>
    <li>Умения писать эффективный код</li>
  </ol>

  <p>Задача на собеседовании обычно похожа на олимпиадную задачу по информатике, но на собеседовании задачи обычно простые. Если умеете решать олимпиадные задачи, то алгоритмическую секцию пройдете достаточно легко.</p> 
  
  <h4>Как этого достичь?</h4>
  <ol>
    <li>Написать 10 000 строк работающего, эффективного и протестированного кода</li>
    <li>Найти задачи для тренировок можно на leetcode.com, codeforces.com и т.п.</li>
    <li>Наш курс поможет правильно подходить к решению задач</li>
  </ol>

  <h4>План занятий</h4>
  <ol>
    <li>Сложность, тестирование, особые случаи</li>
    <li>Ллинейный поиск</li>
    <li>Множества</li>
    <li>Словари и сортировка подсчетом</li>
    <li>Префиксные суммы и два указателя</li>
    <li>Бинарный поиск</li>
    <li>Сортировака событий</li>
    <li>Деревья</li>
  </ol>

  <h4>Как устроены занятия</h4>
  <ol>
    <li>Две лекции в неделю - по понедельникам и средам</li>
    <li>К каждой лекции - контест, примерно на 10 задач</li>
    <li>Разбор задач по пятницам</li>
  </ol>

  <h4>Содержание сегодняшней лекции</h4>
  <ol>
    <li>Сложность алгоритмов</li>
    <li>Особые случаи</li>
    <li>Тестирование</li>
  </ol>
</article>


<!-- Тема 1. Сложность алгоритмов -->
<article class="article">
  <div class="anchor" id="l1-tema-1"></div>
  <h3>Тема 1. Сложность алгоритмов</h3>

  <h4>Что такое сложность?</h4>
  <ol>
    <li>Сложность алгоритма - порядок количества действий, которые выполняет алгоритм</li>
    <li>Например, в программе два вложенных цикла, каждый от 1 до N, тогда сложность составляет O(N^2)</li>
    <li>100*N = O(N), 2*N = O(N). Здесь 100 и 2 - константы, не зависящие от размера входных данных. Константы не так сильно влияют на скорость работы алгоритма при больших параметрах</li>
    <li>Еще бывает "пространственная сложность" - сколько дополнительной памяти требует алгоритм. Пространственная сложность не может быть больше временной, потому что чтобы положить значение в ячейку памяти на это тоже требуется время.</li>
  </ol>

  <p>На собеседовании хотят решение задачи с наименьшей асимптотической сложностью. Посмотрим на примерах и все станет понятно.</p>
</article>


<!-- Задача 1. Самый частый символ -->
<article class="article">
  <div class="anchor" id="l1-task-1"></div>
  <h3>Задача 1. Самый частый символ</h3>

  <p>Дана строка (в кодировке UTF-8). Найти самый часто встречающийся в ней символ. Если несколько символов встречаются одинаково часто, то можно вывести любой.</p>
  <p>Пусть длина строки равна n, число различных символов в строке равно k.</p>

  <h4>Решение 1. С вложенным циклом. O(n^2)</h4>
  <p>Переберем все позиции и для каждой позиции в строке еще раз переберем все позиции и в случае совпадения прибавим к счетчику единицу.</p>

  <details>
    <summary>Решение</summary>
    <ol>
      <li>Заведем строковую переменную для хранения результата
        <code>let result = '';</code>
      </li>
      <li>Заведем переменную для счетчика количества одинаковых символов
        <code>let max = 0;</code>
      </li>
      <li>В цикле переберем все символы в строке
        <code>for (i = 0; i &lt; str.length; i++) {}</code>
      </li>
      <li>Установим для каждого символа в строке счетчик равный нулю
        <code>let counter = 0;</code>
      </li>
      <li>Во вложенном цикле переберем все символы в строке
        <code>for (j = 0; j &lt; str.length; j++) {}</code>
      </li>
      <li>Если символ совпадает, то увеличим счетчик на 1
        <code>if (str[i] === str[j]) counter++;</code>
      </li>
      <li>Когда выйдем из вложенного цикла, сравним счетчик и максимум. Если счетчик больше максимума, то запишем в результат новый символ и обновим максимум</li>
    </ol>

<pre>function findChar(str) {
  let result = '';
  let max = 0;
  for (i = 0; i &lt; str.length; i++) {
    let counter = 0;
    for (j = 0; j &lt; str.length; j++) {
      if (str[i] === str[j]) {
        counter++;
      }
    }
    if (counter &gt; max) {
      result = str[i];
      max = counter;
    }
  }
  return result;
}</pre>
  </details>

  <h4>Решение 2. С вложенным циклом. O(n*k)</h4>
  <p>Переберем все символы, встречающиеся в строке, а затем переберем все позиции и в случае совпадения прибавим к счетчику единицу.</p>

  <details>
    <summary>Решение</summary>
    <ol>
      <li>Заведем строковую переменную для хранения результата
        <code>let result = '';</code>
      </li>
      <li>Заведем переменную для счетчика количества одинаковых символов
        <code>let max = 0;</code>
      </li>
      <li>В цикле переберем все символы в наборе уникальных значений, созданного из строки
        <code>for (char of new Set(str)) {}</code>
      </li>
      <li>Установим для каждого символа в строке счетчик равный нулю
        <code>let counter = 0;</code>
      </li>
      <li>Во вложенном цикле переберем все символы в строке
        <code>for (j = 0; j &lt; str.length; j++) {}</code>
      </li>
      <li>Если символ совпадает, то увеличим счетчик на 1
        <code>if (char === str[j]) counter++;</code>
      </li>
      <li>Когда выйдем из вложенного цикла, сравним счетчик и максимум. Если счетчик больше максимума, то запишем в результат новый символ и обновим максимум</li>
    </ol>
<pre>function findChar(str) {
  let result = '';
  let max = 0;
  for (char of new Set(str)) {
    let counter = 0;
    for (j = 0; j &lt; str.length; j++) {
      if (char === str[j]) {
        counter++;
      }
    }
    if (counter &gt; max) {
      result = char;
      max = counter;
    }
  }
  return result;
}</pre>
  </details>

  <h4>Решение 3. Со словарем. O(n+k) = O(n)</h4>
  <p>Заведем словарь, где ключом является символ, а значением - сколько раз он встретился. Если символ встретился впервые - создаем элемент словаря с ключом, совпадающим с этим символом и значением ноль. Прибавляем к элементу словаря с ключом, совпадающим с этим символом, единицу. Проходимся по всей строке - это n операций.</p>
  
  <h4>Решение Михаила</h4>
  <p>Потом проходимся по всем ключам в словаре - это k операций. Это у Михаила.</p>

  <details>
    <summary>Решение Михаила</summary>
<pre>function findChar(str) {
  let result = '';
  max = 0;
  let dic = {};
  for (let i = 0; i &lt; str.length; i++) {
    if (!dic[str[i]]) {
      dic[str[i]] = 0;
    }
    dic[str[i]]++;
  }
  for (key in dic) {
    if (dic[key] &gt; max) {
      max = dic[key];
      result = key;
    }
  }
  return result;
}</pre>
  </details>

  <h4>Решение 3. Со словарем. O(n)</h4>
  <p>А я придумал алгоритм за O(n) без k. Проходимся только по строке, где сразу обновляем максимум и новый результат - это n операций.</p>

  <details>
    <summary>Мое решение</summary>
<pre>function findChar(str) {
  let result = '';
  max = 0;
  let dic = {};
  for (let i = 0; i &lt; str.length; i++) {
    if (dic[str[i]]) {
      dic[str[i]]++;
    } else {
      dic[str[i]] = 1;
    }
    if (dic[str[i]] &gt; max) {
      max = dic[str[i]];
      result = str[i];
    }
  }
  return result;
}</pre>
  </details>
</article>


<!-- Тема 2. Особые случаи -->
<article class="article">
  <div class="anchor" id="l1-tema-2"></div>
  <h3>Тема 2. Особые случаи</h3>

  <p>Вернемся к задаче 1 и удалим вторую строку</p>
  <code>let result = '';</code>
  <p>Это инициализация переменной, которая будет возвращена в результате. Если убрать эту строку, то может произойти особый случай, когда к нам ничего не пришло и мы пытаемся вывести переменную которую создаем в цикле, который не разу не выполнился. Произойдет runTimeError - ошибка времени выполнения. Запись этой строки гарантирует возврат значения из функции. Это и есть обработка особого случая.</p>
  <p>Если в задаче 1 удалить другую строку</p>
  <code>max = dic[key];</code>
  <p>То как искать такую ошибку? Надо прокрутить решение в голове на реальных входных данных, например на строке 'aab'.</p>
</article>


<!-- Задача 2. Сумма последовательности -->
<article class="article">
  <div class="anchor" id="l1-task-2"></div>
  <h3>Задача 2. Сумма последовательности</h3>

  <p>Дан массив чисел. Найти их сумму.</p>

  <details>
    <summary>Решение</summary>
  <p>Мы помним, что пустые строки, последовательности, массивы это страшная вещь и мы стараемся их сразу обработать чтобы ничего не сломалось. Пишем, если длина массива 0 то сразу возвращаем 0, иначе просуммируем все числа.</p>
<pre>function sum(nums) {
  if (nums.length === 0) {
    return 0;
  } else {
    let result = nums[0];
    for (let i = 1; i &lt; nums.length; i++) {
      result += nums[i];
    }
    return result;
  }
}</pre>

  <p>Но в данном случае это уже было лишнее. Потому что if можно убрать и сразу инициализировать результат нулем.</p>

<pre>function sum(nums) {
  let result = 0;
  for (let i = 0; i &lt; nums.length; i++) {
    result += nums[i];
  }
  return result;
}</pre>
  </details>
</article>


<!-- Задача 3. Максимум последовательности -->
<article class="article">
  <div class="anchor" id="l1-task-3"></div>
  <h3>Задача 3. Максимум последовательности</h3>

  <p>Дан массив чисел. Найти максимальное число.</p>

  <details>
    <summary>Решение</summary>
    <p>Мы помним, что для нахождения суммы последовательности мы сначала в результат записывали 0, а потом вычисляли сумму.</p>
<pre>function max(nums) {
  let result = 0;
  for (let i = 0; i &lt; nums.length; i++) {
    if (nums[i] &gt; result) {
      result = nums[i];
    }
  }
  return result;
}</pre>
    <p>Это будет работать, пока не возникнет ситуация, когда все числа будут отрицательные. Мы выведем 0, которого даже нет в последовательности. Поэтому обработаем этот случай, если последовательность пустая, то выведем, например, пустую строку.</p>
<pre>function max(nums) {
  if (nums.length === 0) {
    return '';
  } else {
    let result = nums[0];
    for (let i = 1; i &lt; nums.length; i++) {
      if (nums[i] &gt; result) {
        result = nums[i];
      }
    }
    return result;
  }
}</pre>
  </details>
</article>


<!-- Тема 3. Тестирование -->
<article class="article">
  <div class="anchor" id="l1-tema-3"></div>
  <h3>Тема 3. Тестирование</h3>

  <h4>Что нужно тестировать?</h4>
  <ol>
    <li>Тесты из условия (если есть)</li>
    <li>Общие случаи</li>
    <li>Особые случаи</li>
  </ol>

  <p>Программу после сдачи могут проверять автоматические тесты, или если писали код на листочке, то ее будет проверять собеседующий. Поставьте себе челендж всегда все сдавать с первой попытки. Это круто и это значит что вы все тщательно протестировали.</p>

  <p>Посмотрим какие тесты нужно сделать к задаче про максимум последовательности.</p>
  <code>[1,3,2]; // общий случай, максимум в середине</code>
  <code>[1,2,3]; // краевой случай, максимум на последнем месте</code>
  <code>[3,2,1]; // краевой случай, максимум на первом месте</code>
  <code>[1,1,1]; // все элементы одинаковые</code>
  <code>[1]; // всего один элемент</code>
  <code> // нет ни одного элемента</code>
  <code>[-1,-2,-3]; // все числа отрицательные</code>

  <h4>Советы по составлению тестов</h4>
  <ol>
    <li>Если есть примеры - реши их руками и сверь ответ. Если не совпадает, то либо правильных ответов может быть несколько, либо ты неправильно понял задачу</li>
    <li>Сначала составь несколько примеров и реши задачу руками, чтобы лучше понять условие и чтобы потом было с чем сравнить</li>
    <li>Проверь последовательность из одного элемента и пустую</li>
    <li>"Краевые эффекты" - проверь, что программа работает корректно в начале и конце последовательности, сделай тесты, чтобы ответ находился на первом и на последнем месте в последовательности</li>
    <li>Составь покрытие всех ветвлений, так чтобы был тест, который входит в каждый if и else</li>
    <li>Подбери тесты чтобы е было ни одного вхождения в цикл</li>
    <li>Один тест - одна возможная ошибка</li>
  </ol>
</article>


<!-- Задача 4. Квадратное уравнение -->
<article class="article">
  <div class="anchor" id="l1-task-4"></div>
  <h3>Задача 4. Квадратное уравнение</h3>

  <h4>Покрытие тестами</h4>
  <p>Задача. Даны три целых числа a,b,c. Найдите все корни уравнения ax^2+bx+c=0 и выведите их в порядке возрастания</p>
  <p>Дискриминант d равен</p>
  <code>d = b^2-4ac</code>
  <p>корни квадратного уравнения x1 и x2 равны</p>
  <code>x1 = (-b - sqrt(d))/2a</code>
  <code>x2 = (-b + sqrt(d))/2a</code>

  <details>
    <summary>Решение 1</summary>
<pre>let d = b**2 - 4*a*c;
let x1 = (-b - Math.sqrt(d))/2*a;
let x2 = (-b + Math.sqrt(d))/2*a;
</pre>
    <p>Решение выдает неправильный результат, потому что мы неправильно переписали формулу. 2*a нужно взять в скобочки.</p>
  </details>

  <details>
    <summary>Решение 2</summary>
<pre>let d = b**2 - 4*a*c;
let x1 = (-b - Math.sqrt(d))/(2*a);
let x2 = (-b + Math.sqrt(d))/(2*a);
</pre>
    <p>Это решение имеет недостатки. Если дискриминант равен нулю то существует только один корень. А у нас получится два корня, которые равны друг другу.</p>
  </details>

  <details>
    <summary>Решение 3</summary>
    <p>Учтем случай когда дискриминант равен 0.</p>
<pre>let d = b**2 - 4*a*c;
if (d === 0) {
  let x1 = -b/(2*a);
} else {
  let x1 = -b - Math.sqrt(d)/(2*a);
  let x2 = -b + Math.sqrt(d)/(2*a);
}</pre>
    <p>Если дискриминант меньше нуля то программа выдаст ошибку, поскольку нельзя взять корень из отрицательного числа и это значит что уравнение не имеет корней.</p>
    <p>В квадратном уравнении слева стоит функция, которая представляет собой параболу. А справа 0 это значение x при котором парабола пересекает ось x. Парабола может пересекать в двух местах, касаться своей нижней точкой или не пересекать, а лежать выше оси x.</p>
  </details>

  <details>
    <summary>Решение 4</summary>
<pre>let d = b**2 - 4*a*c;
if (d === 0) {
  let x1 = -b/(2*a);
} else if (d &gt; 0) {
  let x1 = -b - Math.sqrt(d)/(2*a);
  let x2 = -b + Math.sqrt(d)/(2*a);
}</pre>
    <p>Если ввести 0,1,1 то ответ должен быть -1, а программа выдает ошибку. При а = 0 выражение 0x^2 = 0 и это уже не квадратное уравнение, а линейное уравнение.</p>
  </details>

  <details>
    <summary>Решение 5</summary>
    <p>Если a=0 то это уже линейное уравнение. Обработаем этот случай. Будет один корень x1 = -c/b</p>
<pre>if (a === 0) {
  let x1 = -c/b;
} else {
  let d = b**2 - 4*a*c;
  if (d === 0) {
    let x1 = -b/(2*a);
  } else if (d &gt; 0) {
    let x1 = -b - Math.sqrt(d)/(2*a);
    let x2 = -b + Math.sqrt(d)/(2*a);
  }
}
</pre>
    <p>Если ввести 0,0,1 то программа выдает ошибку. Потому что b=0 и мы получаем деление на 0.</p>
  </details>

  <details>
    <summary>Решение 6</summary>
    <p>Обработаем случай когда b=0</p>
<pre>if (a === 0) {
  if (b !== 0) {
    let x1 = -c/b;
  }
} else {
  let d = b**2 - 4*a*c;
  if (d === 0) {
    let x1 = -b/(2*a);
  } else if (d &gt; 0) {
    let x1 = -b - Math.sqrt(d)/(2*a);
    let x2 = -b + Math.sqrt(d)/(2*a);
  }
}
</pre>
    <p>Если ввести 0,0,0 то при любом x уравнение будет равно 0. А у нас ничего не выводится.</p>
  </details>

  <details>
    <summary>Решение 7</summary>
    <p>Обработаем случай когда b=0 и c=0</p>
<pre>if (a === 0) {
  if (b !== 0) {
    let x1 = -c/b;
  }
  if (b === 0 && c === 0) {
    return 'при любом x';
  }
} else {
  let d = b**2 - 4*a*c;
  if (d === 0) {
    let x1 = -b/(2*a);
  } else if (d &gt; 0) {
    let x1 = -b - Math.sqrt(d)/(2*a);
    let x2 = -b + Math.sqrt(d)/(2*a);
  }
}
</pre>
    <p>Если ввести -5,4,1 то ответ должен быть -0.2, 1.0, а мы выводим 1.0, -0.2. То есть корни выводятся в неправильном порядке. Это происходит что мы делим на отрицательное число 2*a.</p>
  </details>

  <details>
    <summary>Решение 8</summary>
    <p>Обработаем случай когда a меньше 0</p>
<pre>if (a === 0) {
  if (b !== 0) {
    let x1 = -c/b;
  }
  if (b === 0 && c === 0) {
    return 'при любом x';
  }
} else {
  let d = b**2 - 4*a*c;
  if (d === 0) {
    let x1 = -b/(2*a);
  } else if (d &gt; 0) {
    let x1 = -b - Math.sqrt(d)/(2*a);
    let x2 = -b + Math.sqrt(d)/(2*a);
    if (x1 &gt; x2) {
      let temp = x2;
      x2 = x1;
      x1 = temp;
    }
  }
}
</pre>
    <p>Итого получилось 8 попыток для решения задачи на квадратное уравнение. Программа полностью состоит из заплаток.</p>
  </details>
</article>


<!-- Лекция №2. Линейный поиск -->
<article class="article">
  <div class="anchor" id="l2"></div>
  <h2>Лекция №2. Линейный поиск</h2>

  <p>Линейный поиск - это совсем несложный алгоритм. Поэтому будем в основном рассматривать его на примере разных задач.</p>

  <h4>Содержание сегодняшней лекции</h4>
  <ol>
    <li>Классические задачи линейного поиска</li>
    <li>Два прохода</li>
    <li>Задача с собеседования</li>
  </ol>
</article>


<!-- Тема 1. Классические задачи линейного поиска -->
<article class="article">
  <div class="anchor" id="l2-tema-1"></div>
  <h3>Тема 1. Классические задачи линейного поиска</h3>

  <h4>Что такое линейный поиск?</h4>
  <ol>
    <li>Линейный поиск - способ поиска, когда перебираются все элементы</li>
    <li>Сложность линейного поиска - линейная O(N)</li>
    <li>Обычно ищут "подходящий" элемент или "наиболее подходящий" элемент</li>
  </ol>
</article>


<!-- Задача 1. Найти первое вхождение -->
<article class="article">
  <div class="anchor" id="l2-task-1"></div>
  <h2>Задача 1. Найти первое вхождение</h2>

  <p>Дана последовательность чисел длиной N. Найти первое (левое) вхождение положительного числа X в нее или вывести -1, если число X не встречалось.</p>

  <details>
    <summary>Решение</summary>
  <p>Сначала положим в ответ -1. Это значит что мы еще не встретили число X. Затем будем перебирать все элементы. Если текущий элемент равен X и ответ равен -1, запишем в ответ текущую позицию. Проверка result === -1 нужна для того чтобы запомнилось именно первое вхождение.</p>
<pre>function findX(nums, x) {
  let result = -1;
  for (let i = 1; i &lt; nums.length; i++) {
    if (nums[i] === x && result === -1) {
      result = i;
    }
  }
  return result;
}</pre>
  </details>
</article>


<!-- Задача 2. Найти последнее вхождение -->
<article class="article">
  <div class="anchor" id="l2-task-2"></div>
  <h2>Задача 2. Найти последнее вхождение</h2>

  <p>Дана последовательность чисел длиной N. Найти последнее (правое) вхождение числа X в нее или вывести -1, если число X не встречалось.</p>

  <details>
    <summary>Решение</summary>
  <p>Сначала положим в ответ -1. Это значит что мы еще не встретили число X. Затем будем перебирать все элементы. Если текущий элемент равен X - запишем в ответ текущую позицию. Зпомнится именно последнее вхождение. Здесь может быть много присваиваний, но на асимптотическую сложность это не повлияет.</p>
<pre>function findX(nums, x) {
  let result = -1;
  for (let i = 1; i &lt; nums.length; i++) {
    if (nums[i] === x) {
      result = i;
    }
  }
  return result;
}</pre>
  </details>

  <p>Можно было использовать решение предыдущей задачи с той разницей, что в цикле идти от последнего элемента к первому.</p>
</article>


<!-- Задача 3. Найти максимальное число -->
<article class="article">
  <div class="anchor" id="l2-task-3"></div>
  <h2>Задача 3. Найти максимальное число</h2>

  <p>Дана последовательность чисел длиной N (N больше 0). Найти максимальное число в последовательности. Последовательность гарантированно не пустая.</p>

  <details>
    <summary>Решение</summary>
    <p>Сначала положим в ответ нулевой элемент последовательности (он точно существует), затем будем перебирать все элементы. Если текущий элемент больше ответа - запишем в ответ текущий элемент. Цикл начинаем со второго элемента, поскольку первый мы уже записали в ответ и его сравнивать с ответом не нужно. Это нам сэкономит одну операцию.</p>
<pre>function findMax(nums) {
  let result = nums[0];
  for (let i = 1; i &lt; nums.length; i++) {
    if (nums[i] &gt; result) {
      result = nums[i];
    }
  }
  return result;
}</pre>
  </details>

  <h2>Задача 3. Найти максимальное значение (например, из строк)</h2>
  <p>Написанное решение будет работать и для строк. Сравнение чисел это быстрая операция. Но сравнение строк уже медленная, потому что строки сравниваются по символьно в лексикографическом порядке и сложность каждого сравнения O(k), где k длина строки. Чем отличается алфавитный порядок от лексикографического? В алфавитном порядке не отличаются большие и маленькие буквы, а в лексикографическом - отличаются.</p>
  <p>Чем плох этот алгоритм для строк? У нас каждый раз, когда строка больше результата, будет происходить копирование в переменную. Если каждая следующая строка больше предыдущей, то на каждом шаге будет происходить копирование в переменную. На некоторых языках, например в питоне, строка это ссылочный тип и копирование будет происходить быстро, потому что копироваться будет только ссылка. На других языках строка это не ссылочный тип и она будет копироваться вся целиком.</p>
  <p>Как избавиться от этой проблемы? Если объект тяжелый и вы кладете этот объект в переменную, то это может занимать не O(1). Это может занимать O от размера объекта.</p>

  <details>
    <summary>Решение</summary>
    <p>В этом случае нам нужно запоминать не значение, а индекс. Это более универсальное значение. Мы находим и значение и индекс максимального элемента.</p>
<pre>function findMax(nums) {
  let max = 0;
  for (let i = 1; i &lt; nums.length; i++) {
    if (nums[i] &gt; nums[max]) {
      max = i;
    }
  }
  return nums[max];
}</pre>
  <p>Но обращение по индексу сложнее чем обращение к переменной, поэтому для сравнения чисел такое подход хуже чем первый вариант.</p>
  </details>
</article>


<!-- Задача 4. Найти максимальное и второе по величине число -->
<article class="article">
  <div class="anchor" id="l2-task-4"></div>
  <h2>Задача 4. Найти максимальное и второе по величине число</h2>

  <p>Дана последовательность чисел длиной N (N больше 1)</p>
  <p>Найти максимальное число и второе по величине число (такое, которое будет максимальным, если вычеркнуть из последовательности одно максмальное число).</p>

  <details>
    <summary>Решение</summary>
    <p>Заведем две переменные для первого и второго максимума. Возьмем первые два числа из последовательности и запишем большее из них в переменную для первого максимума, а меньшее - для второго. Пройдем по последовательности. Если очередное число больше первого максимума, то запишем во второй максимум значение первого, а в первый - текущее число. Если только больше второго, запишем текущее число во второй максимум.</p>
<pre>function find2Max(nums) {
  let max1 = Math.max(nums[0], nums[1]);
  let max2 = Math.min(nums[0], nums[1]);

  for (let i = 2; i &lt; nums.length; i++) {
    if (nums[i] &gt; max1) {
      max2 = max1;
      max1 = nums[i];
    } else if (nums[i] &gt; max2) {
      max2 = nums[i]
    }
  }

  return [max1, max2];
}</pre>
  </details>
</article>


<!-- Задача 5. Найти минимальное четное число -->
<article class="article">
  <div class="anchor" id="l2-task-5"></div>
  <h2>Задача 5. Найти минимальное четное число</h2>

  <p>Дана последовательность чисел длиной N</p>
  <p>Найти минимальное четное число в последовательности или вывести -1, если такого не существует.</p>

  <details>
    <summary>Решение</summary>
    <p>В переменную для ответа положим -1. Если очередное число четное, а ответ равен -1 или ответ больше текущего числа, то запишем в ответ текущее число.</p>
<pre>function findEvenMin(nums) {
  let min = -1;
  for (let i = 0; i &lt; nums.length; i++) {
    if (nums[i] % 2 === 0 && (min === -1 || nums[i] &lt; min)) {
      min = nums[i];
    }
  }
  return min;
}</pre>
  </details>
</article>


<!-- Тема 2. Два прохода -->
<article class="article">
  <div class="anchor" id="l2-tema-2"></div>
  <h2>Тема 2. Два прохода</h2>

  <p>В таких задачах нужно два раза пройти по последовательности.</p>
</article>


<!-- Задача 6. Самые короткие слова -->
<article class="article">
  <div class="anchor" id="l2-task-6"></div>
  <h2>Задача 6. Самые короткие слова</h2>

  <p>Дана последовательность слов</p>
  <p>Вывксти все самые короткие слова через пробел</p>

  <details>
    <summary>Решение в два прохода</summary>
    <p>Линейное решение за два прохода. Сложность O(2N) = O(N).</p>
    <p>В первом проходе по последовательности мы ищем длину самого короткого слова. Во втором проходе добавляем в массив все слова с минимальной длиной. В результат выводим строку, созданную из массива с пробелом между словами.</p>
    <p>Решение с добавлением слов в строку вместо массива было бы не оптимальным. Потому что операция добавления новых слов в строку на самом деле создает новую строку, в которую сначала копирует все содержимое старой строки и уже потом добавляет новое слово.</p>
<pre>function shortWords(strs) {
  let minlen = strs[0].length;
  for (let i = 1; i &lt; strs.length; i++) {
    if (strs[i].length &lt; minlen) {
      minlen = strs[i].length;
    }
  }
  let result = [];
  for (let i = 0; i &lt; strs.length; i++) {
    if (strs[i].length === minlen) {
      result.push(strs[i]);
    }
  }
  return result.join(' ');
}</pre>
  </details>
</article>


<!-- Задача 7. Сколько воды осталось на острове после сильного дождя -->
<article class="article">
  <div class="anchor" id="l2-task-7"></div>
  <h2>Задача 7. Сколько воды осталось на острове после сильного дождя</h2>

  <p>Задача со школьной олимпиады. Игра PitCraft происходит в двумерном мире, который состоит из блоков размером 1 на 1 метр. Остров игрока представляет собой набор столбцов различной высоты, состоящих из блоков камня и окруженный морем. Над островом прошел сильный дождь, который заполнил водой все низины, а не поместившаяся в них вода стекла в море, не увеличив его уровень</p>
  <p>По ландшафту острова определите, сколько блоков воды осталось после дождя в низинах на острове.</p>
<pre>
    #
  #~#
#~###~~#
#~###~~#
#########
</pre>

  <details>
    <summary>Решение</summary>
    <p>К нам на вход приходит массив высот столбцов. Пусть на каждый столбец мы льем воду и тогда эта вода будет сливаться в соседний столбец если высота соседнего столбца меньше. Если рассматривать каждый кубик и пытаться слить с него воду направо и налево, то это очень медленное решение. Попробуем найти что-то побыстрее.</p>
    <p>Нужно пройти во высотам и найти вершину - максимальную высоту через которую вода уже не перельется. Когда вода заполнит все впадины, то слева от вершины все ступеньки будут на подъем, а справа - на спуск. Разделим задачу на две половины - до вершины и после.</p>
    <p>Присвоим переменной результата 0 кубиков воды. Будем идти слева до вершины и присвоим переменной текущего максимума высоту первого столбика. Если следующий столбик ниже, то находим разницу высот и добавляем в результат. Если выше, то обновляем текущий максимум и идем дальше до вершины.</p>
    <p>Вторую половину задачи после вершины мы будем искать так же, но проходиться по последовательности будем с последнего столбика назад к вершине.</p>
    <p>Как быть если максимумов будет несколько? Ничего плохого не произойдет. Между максимумами тоже все заполнится водой. Можно выбрать любой максимум.</p>
    <p>Сложность решения линейная O(N). За два прохода. Первый проход ищем максимум. Второй проход добавляем количество воды к результату.</p>
<pre>function water(h) {
  let maxPos = 0;

  // первый проход ищем максимум
  for (let i = 1; i &lt; h.length; i++) {
    if (h[i] &gt; h[maxPos]) {
      maxPos = i;
    }
  }

  let result = 0;
  let nowMax = 0;

  // второй проход добавляем количество воды к результату
  // слева до вершины
  for (let i = 0; i &lt; maxPos; i++) {
    if (h[i] &gt; nowMax) {
      nowMax = h[i];
    }
    result += nowMax - h[i];
  }

  nowMax = 0;

  // справа до вершины
  for (let i = h.length - 1; i &gt; maxPos; i--) {
    if (h[i] &gt; nowMax) {
      nowMax = h[i];
    }
    result += nowMax - h[i];
  }

  return result;
}</pre>
  </details>
</article>


<!-- Тема 3. Задача с собеседования. RLE сжатие строки -->
<article class="article">
  <div class="anchor" id="l2-tema-3"></div>
  <h2>Тема 3. Задача с собеседования. RLE сжатие строки</h2>

  <p>Дана строка (возможно, пустая), состоящая из букв A-Z: AAAABBBCCXYZDDDD</p>
  <p>Нужно написать функцию RLE, которая на выходе даст строку вида: A4B3C2XYZD4. И сгенерирует ошибку, если на вход пришла невалидная строка</p>
  <p>Пояснения: Если символ встречается 1 раз, он остается без изменений. Если символ повторяется более 1 раза подряд, он пишется один раз и к нему добавляется количество повторений.</p>

  <p>Для начала решим более простую задачу. Сложно считать сколько раз эти символы встречаются.</p>

  <h4>Упрощение задачи</h4>
  <p>Дана строка (возможно, пустая), состоящая из букв A-Z: AAAABBBCCXYZDDDD</p>
  <p>Нужно написать функцию, которая на выходе даст строку вида ABCXYZD</p>

  <details>
    <summary>Решение упрощенной задачи</summary>
    <p>Запишем первый символ в переменную lastChar и создадим пустой массив result. Пройдемся по строке и будем сравнивать текущий символом с lastChar, если не совпадает то lastChar добавляем в массив result, а текущий символ записываем в lastChar. Когда выйдем из цикла lastChar добавляем в массив result.</p>
<pre>function rleEasy(s) {
  let lastChar = s[0];
  let result = [];
  for (let i = 1; i &lt; s.length; i++) {
    if (s[i] !== lastChar) {
      result.push(lastChar);
      lastChar = s[i];
    }
  }
  result.push(lastChar);
  return result.join('');
}</pre>
  </details>

  <p>Теперь нужно положить в ответ не только символ, но и количество идущих подряд символов. Для этого нужно запоминать позицию, где начался символ и встречая следующий символ эту позицию обновлять.</p>

  <details>
    <summary>Решение RLE сжатие строки</summary>
    <p>Добавим счетчик одинаковых букв. Если следующая буква такая же, то счетчик будет прибавлять 1. Если следующая буква другая, то записываем в массив с ответом предыдущую букву, потом записываем счетчик (если он больше 1), потом запоминаем следующую букву и сбрасываем счетчик в 1.</p>
<pre>function rle(s) {
  let lastChar = s[0];
  let result = [];
  let count = 1;
  for (let i = 1; i &lt; s.length; i++) {
    if (s[i] !== lastChar) {
      result.push(lastChar);
      if (count &gt; 1) {
        result.push(count);
      }
      lastChar = s[i];
      count = 1;
    } else {
      count++;
    }
  }
  result.push(lastChar);
  result.push(count);
  return result.join('');
}</pre>
  </details>
</article>


<!-- Лекция №3. Множества -->
<article class="article">
  <div class="anchor" id="l3"></div>
  <h2>Лекция №3. Множества</h2>

  <h4>Содержание сегодняшней лекции</h4>
  <ol>
    <li>Как устроено множество</li>
    <li>Амортизированная сложность</li>
    <li>Примеры задач</li>
  </ol>
</article>


<!-- Тема 1. Как устроено множество -->
<article class="article">
  <div class="anchor" id="l3-tema-1"></div>
  <h3>Тема 1. Как устроено множество</h3>

  <p>В множестве каждый элемент либо есть либо нет. Все элементы могут располагаться в любом порядке.</p>

  <h4>Что должно уметь делать множество</h4>
  <ol>
    <li>Добавлять элемент</li>
    <li>Проверять наличие элемента</li>
    <li>Удалять элемент</li>
  </ol>

  <p>Могут быть и вспомогатльные операции - узнать количество элементов в множестве, проверить пустое оно или нет. Для двух множеств могут быть объединения, пересечения.</p>

  <h4>Как устроено множество</h4>
  <ol>
    <li>Придумаем какую-нибудь функцию, которая сопоставляет каждому элементу какое-либо небольшое число</li>
    <li>Вычислим функцию от элемента</li>
    <li>Положим элемент в список с номером, равным значению функции</li>
  </ol>

  <h4>Пример функции добавления для чисел</h4>
  <ol>
    <li>Функция - последняя цифра числа X. F(X) = X & 10</li>
    <li>Вычислим функцию от элемента</li>
    <li>Положим элемент в список с номером, равным значению функции</li>
  </ol>

  <p>Если два элемента (например 137 и 17) имеют одинаковую последнюю цифру, то они попадут в список под номером 7. Это называется коллизия.</p> 
  <p>Для решения коллизии для каждого числа заведем список. Сначала все списки пусты. Добавляем число в список, номер которого вычисляет хеш-функция.</p>
  <p>Если есть множество N в котором лежит K элементов, то мы можем перебрать все элементы за O(N+K). Мы будем идти по всем спискам от 0 до N. Если списук пустой, то переходим к следующему списку. Если список не пустой, то вложенном циклом проходим по всем его элементам.</p>

  <h4>Добавление элемента в множество</h4>
  <p>Когда надо добавить элемент в множество, то мы считаем для него хеш-функцию и добавляем его в нужный список.</p>

  <h4>Поиск элемента в множестве</h4>
  <p>Когда надо найти элемент в множестве, то мы считаем для него хеш-функцию и ищем его в нужном списке. Ищем обычным линейным поиском, который проходит по всем элементам списка.</p>  
  
  <h4>Удаление элемента из множества</h4>
  <p>Когда надо удалить элемент из множества, то вначале его надо найти. Делаем то же самое, что и при поиске элемента. Если в списке нет других элементов, то просто удаляем его и список становится пуст. Если есть еще элементы, то копируем последний элемент на место удаляемого и удаляем последний элемент.</p>
  <p>Поиск занял O(K/N) в среднем, а удаление найденного элемента O(1).</p>
</article>


<!-- Задача 1. Написать свое множество -->
<article class="article">
  <div class="anchor" id="l3-task-1"></div>
  <h2>Задача 1. Написать свое множество</h2>

  <p>Создадим пустой массив mySet на setSize элементов. В каждый элемент пустого массива mySet также положим пустой массив.</p> 
  <p>Создадим три функции - add() добавление одного элемента в множество, find() поиск элемента в множестве, del() удаление элемента из множества.</p>
  <p>При добавлении числа в можество будем вычислять хеш-функцию. То есть искать остаток от деления числа на размер множества. Хеш-функция вернет нам индекс элемента массива. По этому индексу находится вложенный массив, куда мы добавим новый элемент в конец.</p>
  <p>При поиске числа в множестве будем вычислять хеш-функцию. Получим индекс элемента.Прохойдем линейным поиском по всем элементам вложенного массива и вернем true если он там есть.</p>
  <p>При удалении числа из множества сначала находим его. Записываем на его место последний элемент во вложенном массиве и удаляем последний элемент.</p>
  <p>Мы получили мультимножество. В которое один и тот же элемент может входить несколько раз. Это не множество уникальных значений. При добавлении мы не проверяем элемент на уникальность, есть ли он уже в этом множестве.</p>
  <p>При поиске будет искаться первый элемент, если их несколько. При удалении будет удаляться первый элемент, если их несколько.</p>
  <p>Если нужно сделать множество уникальных элемнтов, то при добавлении элемента в множество надо сделать проверку есть ли такой элемент в множестве. Если есть то новый элемент не добавлять.</p>

  <details>
    <summary>Решение</summary>
<pre>let setSize = 10;
  let mySet = [];

  for (let i = 0; i &lt; setSize; i++) {
    mySet[i] = [];
  }

  function add(x) {
    mySet[x % setSize].push(x);
  }

  function find(x) {
    let nowSet = mySet[x % setSize];
    for (let i = 0; i &lt; nowSet.length; i++) {
      if (x === nowSet[i]) {
        return true;
      }
    }
    return false;
  }

  function del(x) {
   let nowSet = mySet[x % setSize];
   for (let i = 0; i &lt; nowSet.length; i++) {
      if (x === nowSet[i]) {
        nowSet[i] = nowSet[nowSet.length - 1];
        nowSet.pop();
      }
   }
  }</pre>
  </details>

  <h4>Термины</h4>
  <ul>
    <li>F(X) = X % setsize - хеш-функция</li>
    <li>mySet (список списков) - хеш-таблица</li>
    <li>Совпадение значений хеш-функции для разных параметров - коллизия</li>
  </ul>

  <h4>Что можно хранить в множестве эффективно</h4>
  <ul>
    <li>Вообще говоря хранить можно что угодно - в компьютере все состоит из чисел</li>
    <li>Эффективно - только неизменяемые объекты</li>
    <li>Для неизменяемых объектов можно посчитать значение хеш-функции при их создании</li>
    <li>Хеш-функция должна давать равномерное распределение</li>
  </ul>
</article>


<!-- Тема 2. Амортизированная сложность -->
<article class="article">
  <div class="anchor" id="l3-tema-2"></div>
  <h3>Тема 2. Амортизированная сложность</h3>

  <h4>Проблемы с хеш-таблицей</h4>
  <ul>
    <li>Слишком большой размер - ест много памяти O(N)</li>
    <li>Слишком маленький размер - большой коэффициент заполнения и медленный поиск и удаление O(K/N)</li>
    <li>Хочется иметь разумный баланс, например, коэффициент заполнения не больше единицы (K &le; N). Тогда все операции в среднем будут занимать O(1).</li>
  </ul>

  <p>Мы хотим чтобы в множестве хранилось не больше элементов, чем его размер. А точнее чтобы каждый список внутри множества имел только один элемент.</p>

  <h4>Решение проблемы с хеш-таблицей</h4>
  <ul>
    <li>Когда таблица наполнится - увеличим ее размер вдвое и перестроим.</li>
  </ul>

  <p>Найдем сложность добавления N элементов в хэш-таблицу.</p> 
  <ul>
    <li>Возьмем таблицу с начальным размером 1.</li>
    <li>Будем добавлять N = 2^P элементов, т.е. P = logN. Таблица расширяется вдвое, поэтому удобно работать со степенями двойки (число элементов).</li>
    <li>Только на P шагах (когда размер таблицы равен очередной степени двойки) может произойти перестроение таблицы за O(N).</li>
  </ul>  
  <code>1 + 2 + 4 + 8 + ... + 2^P = 2^(P+1) - 1 = 2N - 1 = O(N)</code>

  <h4>Амортизированная сложность</h4>
  <ul>
    <li>Амортизированная сложность - среднее время выполнения операции (условно)</li>
    <li>У нас амортизированная сложность операции O(1) - всего было N операций и суммарно на это ушло O(N)</li>
    <li>В худжем случае отдельная операция выполняется за O(N) - может не подходить для систем реального времени</li>
  </ul>
</article>


<!-- Тема 3. Примеры задач -->
<article class="article">
  <div class="anchor" id="l3-tema-3"></div>
  <h2>Тема 3. Примеры задач</h2>
</article>


<!-- Задача 2. Найти два числа с заданной суммой -->
<article class="article">
  <div class="anchor" id="l3-task-2"></div>
  <h2>Задача 2. Найти два числа с заданной суммой</h2>

  <p>Дана последовательность положительных чисел длиной N и число X.</p>
  <p>Найти два различных числа A и B из последовательности, чтобы A + B = X, или вернуть пару 0, 0, если такой пары чисел нет.</p>

  <details>
    <summary>Решение 1. O(N^2)</summary>
    <p>В цикле пройдем по последовательности чисел. Для каждого числа во вложенном цикле пройдем опять по последовательности чисел. Найдем пару чисел которые в сумме дадут число X. Вложенный цикл начинается не с нуля, а со следующего числа, на котором работает внешний цикл. Это нужно для того чтобы числа были разные и не складывать два раза одинаковые пары чисел.</p>
<pre>function pairSum(nums, x) {
  for (let i = 0; i &lt; nums.length - 1; i++) {
    for (let j = i + 1; j &lt; nums.length; j++) {
      if (nums[i] + nums[j] === x) {
        return [nums[i], nums[j]];
      }
    }
  }
  return [0,0];
}</pre>
  </details>

  <details>
    <summary>Решение 2. O(N)</summary>
    <p>Будем хранить все уже обработанные числа в множестве. Если очередное число now, а x - now есть в множестве, то мы нашли слагаемые.</p>
<pre>function pairSum(nums, x) {
  let setNums = new Set();
  for (let i = 0; i &lt; nums.length; i++) {
    if (setNums.has(x - nums[i])) {
      return [x - nums[i], nums[i]];
    }
    setNums.add(nums[i]);
  }
  return [0,0];
}</pre>
  </details>
</article>


<!-- Задача 3. Входит ли в словарь слово, возможно с пропущеной буквой -->
<article class="article">
  <div class="anchor" id="l3-task-3"></div>
  <h2>Задача 3. Входит ли в словарь слово, возможно с пропущеной буквой</h2>

  <p>Дан словарь из N слов, длина каждого не превосходит K.</p>
  <p>В записи каждого из M слов текста (каждое длиной до K) может быть пропущена одна буква. Для каждого слова сказать, входит ли оно (возможно, с одной пропущенной буквой) в словарь.</p>

  <details>
    <summary>Решение за O(NK + M)</summary>
    <p>Выбросим из каждого слова словаря по одной букве всеми возможными способами за O(NK) и положим получившиеся слова в словарь. Тогда для каждого слова из K букв мы получим еще K новых слов.</p>
    <p>Например для слова abcd добавим в словарь 5 новых слов: abcd, abc, abd, acd, bcd.</p>
   <p>Для каждого слова из текста просто проверим, есть ли оно в словаре за O(1).</p>
   <p>Принимая во внимание сложность создания строки (нового слова). Сложность решения будет O(NK^2 + M)</p>
   <p>Создадим словарь из всех слов. Потом пройдем по каждому слову в словаре и создадим все слова с одной пропущенной буквой для этого слова.</p>
<pre>function wordInDict(dict, word) {
  let newDict = new Set(dict);
  for (let i = 0; i &lt; dict.length; i++) {
    for (let j = 0; j &lt; dict[i].length; j++) {
      newDict.add(dict[i].slice(0,j) + dict[i].slice(j+1));
    }
  }
  if (newDict.has(word)) {
    return true;
  }
  return false;
}</pre>
  </details>
</article>


<!-- Лекция №4. Словари и сортировка подсчетом -->
<article class="article">
  <div class="anchor" id="train-4"></div>
  <h2>Лекция №4. Словари и сортировка подсчетом</h2>

  <p>Это самая практически полезная лекция. Очень много задач и на практике очень часто встречаются словари.</p>

  <h4>Содержание сегодняшней лекции</h4>
  <ol>
    <li>Сортировка подсчетом</li>
    <li>Словари</li>
    <li>Задел под оптимизацию</li>
  </ol>
</article>


<!-- Тема 1. Сортировка подсчетом -->
<article class="article">
  <div class="anchor" id="l4-tema-1"></div>
  <h2>Тема 1. Сортировка подсчетом</h2>

  <h4>Что такое сортировка подсчетом</h4>
  <ul>
    <li>Пусть необходимо отсортировать массив из N целых чисел, каждое от 0 до K</li>
    <li>Обычная сортировка займет O(NlogN)</li>
    <li>Будем считать количество вхождений каждого числа, а затем выводить каждое число столько раз, сколько оно встречалось. Это займет O(N+K) и O(K) дополнительной папяти</li>
    <li>Интервал значений можно сдвинуть, чтобы он был не от 0 до K, а от минимального до максимального значения в массиве.</li>
  </ul>
  <p>K это разница между максимальным и минимальным значением. K должно быть небольшим.</p>

  <h4>Отсортировать последовательность школьных оценок</h4>
  <p>Например, это школьные оценки от 1 до 5 и нужно их упорядочить. Для таких задач, где не много разных значений мы не будем пользоваться стандартной сортировкой за O(NlogN).</p> 
  <p>Каждый раз когда встречаем оценку, будем увеличивать счетчик этих оценок на 1. Для этого заведем массив с индексами от 1 до 5. В программировании массивы начинаются с нулевого элемента. Тогда пусть в массиве будет еще один элемент - нулевой, который нигде не будет использоваться, зато вы ничего не напутаете с индексами.</p>
  <p>Сначала заполним массив нулями. Пусть есть последовательность оценок</p>
  <code>5,4,5,3,2,1,5</code>
  <p>Будем идти по последователности и увеличивать на 1 элемент массива с индексом равным оценке. Когда массив будет заполнен, пройдем теперь по массиву и будем выводить индекс столько раз скольо записано в его ячейке.</p>
  <code>1,2,3,4,5,5,5</code>
</article>


<!-- Задача. Сортировка последовательности из K различных чисел -->
<article class="article">
  <div class="anchor" id="l4-task"></div>
  <h2>Задача. Сортировка последовательности из K различных чисел</h2>

  <details>
    <summary>Сортировка подсчетом</summary>
    <p>Пусть в последовательности из N чисел есть K различных чисел.</p>
    <ol>
      <li>Найдем минимальное и максимальное из чисел. Сложность O(2N).</li>
      <li>Создадим массив длиной K и заполним его нулями. Сложность O(K).</li>
      <li>Пройдем в цикле по исходной последовательности и для каждого числа будем увеличивать на 1 значение в соответствующей ячейке массива длиной K. Сложность O(N).</li>
      <li>Создадим пустой массив для записи результата</li>
      <li>Пройдем в цикле по массиву длиной K и для каждого числа будем записывать его в результат столько раз, какое значение стоит в массиве.</li>
    </ol>
<pre>function sortCount(nums) {
  let min = Math.min(...nums);
  let max = Math.max(...nums);
  let k = max - min + 1;
  let countArr = new Array(k).fill(0);

  for (let i = 0; i &lt; nums.length; i++) {
    countArr[nums[i] - min] += 1;
  }

  let count = 0;
  let newNums= [];
  for (let i = 0; i &lt; k; i++) {
    for (j = 0; j &lt; countArr[i]; j++) {
      newNums[count] = i + min;
      count++;
    }
  }
  return newNums;
}</pre>
  </details>
</article>


<!-- Задача 1. Можно ли получить число из другого перестановкой цифр -->
<article class="article">
  <div class="anchor" id="l4-task-1"></div>
  <h2>Задача 1. Можно ли получить число из другого перестановкой цифр</h2>

  <p>Дано два числа X и Y без ведущих нулей.</p>
  <p>Необходимо проверить, можно ли получить первое из второго перестановкой цифр.</p>

  <details>
    <summary>Решение</summary>
    <p>Посчитаем количество вхождений каждой цифры в каждое из чисел и сравним. Цифры будем постепенно добывать из числа справа с помощью остатка от деления на 10 и деления нацело на 10. Количество цифр будем записывать в массив из 10 элементов от 0 до 9. Сделаем это для первого числа и для второго. Сравним полученные массивы поэлементно.</p>
<pre>function compare(x, y) {
  function count(num) {
    let arr = new Array(10).fill(0);
    while (num &gt; 0) {
      let d = num % 10;
      arr[d]++;
      num = Math.floor(num / 10);
    }
    return arr;
  }

  let dx = count(x);
  let dy = count(y);
  for (let i = 0; i &lt; 10; i++) {
    if (dx[i] !== dy[i]) {
      return false;
    }
  }
  return true;
}</pre>
  </details>
</article>


<!-- Тема 2. Словари -->
<article class="article">
  <div class="anchor" id="l4-tema-2"></div>
  <h2>Тема 2. Словари</h2>

  <p>Словари более универсальны. Но в некоторых ситуациях работают хуже чем сортировка подсчетом.</p>
  <p>Словари позволяют по ключу узнавать значение.</p>

  <h4>Как реализованы словари</h4>
  <ul>
    <li>Словарь - он как множество, но к каждому ключу приписано значение</li>
    <li>Искать по значению в словаре нельзя</li>
    <li>Константа в сложности словарей заметно больше, чем у массивов. Происходит расширение время от времени, считается хеш-функция. Поэтому где можно - лучше использовать сортировку подсчетом</li>
    <li>Сортировку подсчетом неразумно использовать, если данные разреженные</li>
  </ul>
</article>


<!-- Задача 2. Сколько пар ладей бьют друг друга -->
<article class="article">
  <div class="anchor" id="l4-task-2"></div>
  <h2>Задача 2. Сколько пар ладей бьют друг друга</h2>

  <p>На шахматной доске NxN нажодятся M ладей (ладья бьет клетки на той же горизонтали или вертикали до ближайшей занятой)</p>
  <p>Определите, сколько пар ладей бьют друг друга. Ладьи задаются парой чисел I и J, обозначающих координаты клетки</p>
  <code>1 &lt;= N &lt;= 10^9, 0 &lt;= M &lt;= 2 * 10^5</code>

  <details>
    <summary>Решение за O(M)</summary>
    <p>Для каждой занятой горизонтали и вертикали будем хранить количество ладей на них. Количество пар в горизонтали (вертикали) равно количеству ладей минус 1. Суммируем это количество пар для всех горизонталей и вертикалей.</p>
<pre>function count(coord) {
  // создадим два словаря
  // для горизонталей
  let row = {};
  // для вертикалей
  let col = {};
  // пройдем по всем координатам
  for (let i = 0; i &lt; coord.length; i++) {
    // заполним словарь горизонталей
    if (!row[coord[i][0]]) {
      row[coord[i][0]] = 0;
    }
    row[coord[i][0]]++;
    // заполним словарь вертикалей
    if (!col[coord[i][1]]) {
      col[coord[i][1]] = 0;
    }
    col[coord[i][1]]++;
  }
  // найдем пары на горизонталях
  let pairsRow = 0;
  for (let key in row) {
    pairsRow += row[key] -1;
  }
  // найдем пары на вертикалях
  let pairsCol = 0;
  for (let key in col) {
    pairsCol += col[key] -1;
  }
  return pairsRow + pairsCol;
}</pre>

  <p>Тест</p>
  <code>let w1 = [[2,7],[2,4],[4,7],[5,4]];</code>
  <code>console.log(count(w1)); // 3</code>
  </details>

  <p>На олимпиадах встречаются задачи где нужно посчитать количество пар ферзей. Это то же самое. Только нужно учитывать что ферзь бьет еще и по диагонали. Все клетки на каждой диагонали направленной слева-направо вверх имеют одинаковую разницу координат i-j (номер строки минус номер столбца). Все клетки на каждой диагонали направленной слева-направо вниз имеют одинаковую сумму i+j (номер строки плюс номер столбца).</p>
</article>


<!-- Задача 3. Гистограмма Hello, world! -->
<article class="article">
  <div class="anchor" id="l4-task-3"></div>
  <h2>Задача 3. Гистограмма Hello, world!</h2>

  <p>Дана строка S</p>
  <p>Выведите гистограмму как в примере (коды символов отсортированы)</p>
  <code>S = Hello, world!</code>
<pre>
      #
      ##
##########
 !,Hdelorw
</pre>

  <details>
    <summary>Решение</summary>
    <p>Для каждого символа в словаре посчитаем, сколько раз он встречался. Найдем самый частый символ и переберем количество от этого числа до 1. Пройдем по всем отсортированным ключам и если количество больше счетчика - выведем #</p>
    <p>Заведем словарь. Ключами будут символы в строке, а значениями - сколько раз они встречаются. Пройдем по строке, если символ еще не встречался, то создаем в словаре такой ключ со значением ноль. Потом в любом случае прибавляем 1.</p>
    <p>Потом нужно отсортировать все ключи в словаре и занести в счетчик максимальное значение. В цикле от максимального значения счетчика до 1 пройтись по словоарю и вывести построчно гистограмму.</p>
<pre>function hist(str) {
  // создадим словарь
  let dict = {};
  // максимальное число одинаковых букв
  let max = 0;
  // пройдем по символам в строке
  for (let i = 0; i &lt; str.length; i++) {
    // заполним словарь
    if (!dict[str[i]]) {
      dict[str[i]] = 0;
    }
    dict[str[i]]++;
    // находим максимум
    max = Math.max(max, dict[str[i]]);
  }
  // отсортируем ключи объекта
  let sortedKeys = Object.keys(dict).sort();
  // переменная для вывода строки на экран
  let result = [];
  // начиная с верхней строки и до нижней
  for (let i = max; i &gt; 0; i--) {
    // смотрим для каждого ключа
    sortedKeys.forEach(key =&gt; {
      // есть ли он в этой строке
      if (dict[key] &gt;= i) {
        // если есть добавляем #
        result.push('#');
      } else {
        // если нет добавляем пробел
        result.push(' ');
      }
    })
    // добавляем символ переноса строки
    result.push('\n');
  }
  // добавляем строку из отсортированных символов
  result.push(sortedKeys.join(''));
  console.log(result.join(''));
}</pre>

    <p>Тест</p>
    <code>let w1 = 'Hello, world!';</code>
    <code>hist(w1);</code>
<pre>
      #
      ##
##########
 !,Hdelorw
</pre>
    </details>
</article>


<!-- Тема 3. Задел под оптимизацию -->
<article class="article">
  <div class="anchor" id="l4-tema-3"></div>
  <h3>Тема 3. Задел под оптимизацию</h3>

  <p>Преждевременная оптимизация - страшный грех. Например нужно за неделю написать код, который решает бизнес задачу. Но на самых быстрых алгоритмах такой код можно написать только за месяц. А решать задачу нужно уже сейчас. Поэтому выбирают решение попроще, не самое быстрое и эффективное, но которое позволит решить задачу уже сейчас.</p>
  <p>Но если вы знаете как сделать лучше, но на это уже не остается времени, то неплохо оставить задел, чтобы в следующий раз при похожей проблеме можно было быстренько переделать эту тормозящую часть.</p>

  <h4>Всегда ли асимптотическое решение лучше?</h4>
  <p>2*N log N или 1000*N?</p>
  <p>Допустим, мы придумали два решения. Сложность одного O(N), другого - O(NlogN). Тоже классно, но похуже. Только подозрительно большая константа у линейного алгоритма. Найдем N при котором линейный алгоритм будет работать лучше. При N больше чем 2 в 500 степени, линейный алгоритм станет работать лучше. Но 2^500 примерно в 10^70 раз больше количества атомов во вселенной. В реальности разница констант в 500 раз все же случается редко.</p>

  <h4>Некоторые другие критерии качества алгоритма</h4>
  <ol>
    <li>Потребление памяти</li>
    <li>Время на реализацию. В промышленной разработке время на реализацию всегда ограничено. Поэтому всегда приходится отказываться от тех идей, которые не успеете реализовать.</li>
    <li>Сложность поддержки. Код читают гораздо чаще чем пишут. Поэтому надо писать так чтобы было легко читать и через месяц и больше.</li>
    <li>Возможность распараллеливания. Некоторые алгоритмы последовательно опираются на данные, подсчитанные на предыдущем шаге, а некоторые можно распараллелить.</li>
    <li>Необходимая квалификация сотрудника. Может оказаться что имея много  денег, вы не можете найти на рынке достаточное количество квалифицированных сотрудников, которые могут реализовать и поддерживать ваши самые новые и классные алгоритмы.</li>
    <li>Стоимость оборудования. Можно купить железо, которое будет быстрее обрабатывать ваши алгоритмы. Но все равно можно упереться в какойто момент, когда уже физически железо быстрее работать не может.</li>
  </ol>

  <p></p>
</article>


<!-- Задада 4. Сгруппировать слова по общим буквам -->
<article class="article">
  <div class="anchor" id="l4-task-4"></div>
  <h2>Задада 4. Сгруппировать слова по общим буквам</h2>

  <p>Дан массив слов. Нужно слова состоящие из одинаковых букв сгруппировать в подмассивы.</p>
  <code>Ввод ['eat', 'tea', 'tan', 'ate', 'nat', 'bat']</code>
  <code>Вывод [['ate', 'eat', 'tea'], ['nat', 'tan'], ['bat']]</code>

  <details>
    <summary>Решение 1</summary>
    <p>Отсортируем в каждом слове буквы и это будет выступать в роли ключа, а значением будет список слов</p>
<pre>function group(words) {
  let groups = {};
  words.forEach(word => {
    let key = word.split('').sort();
    if (!groups[key]) {
      groups[key] = [];
    }
    groups[key].push(word)
  });
  let result = [];
  for (let k in groups) {
    result.push(groups[k]);
  }

  return result;
}</pre>
    <p>Вдруг слово будет длинное (N)? Сортировка займет O(NlogN). Количество различных букв в слове K&lt;=N, можем посчитать количество каждой за O(N) и отсортировать за O(KlogK), теоретически.</p>
    <p>Но мы думаем: сейчас времени не хватает, осталось 2 минуты, я не успеваю это переделать. Но можно сделать задел на будущее.</p>

    <h4>Задел для возможных оптимизаций</h4>
    <p>Вынесем отдельно в функцию подсчет ключа. Будет тормозить - посмотрим на профилировщике где, и если долго считается ключ - легко поправим на что-то более эффективное.</p>
<pre>function group(words) {
  // функция подсчета ключа
  function getKey(word) {
    return word.split('').sort();
  }
  
  let groups = {};
  words.forEach(word => {
    let key = getKey(word);
    if (!groups[key]) {
      groups[key] = [];
    }
    groups[key].push(word)
  });
  let result = [];
  for (let k in groups) {
    result.push(groups[k]);
  }

  return result;
}</pre>

    <h4>Оптимизация</h4>
    <p>Изменим функцию подсчета ключа. Создадим словарь. Пройдемся по буквам в слове. Сделаем сортировку подсчетом. Это будет работать за O(KlogK) при K&lt;=N. Сомнительная оптимизация. В среднем хуже чем было.</p>
<pre>function group(words) {
  // функция подсчета ключа
  function getKey(word) {
    let count = {};
    for (i = 0; i &lt; word.length; i++) {
      if(!count[word[i]]) {
        count[word[i]] = 0;
      }
      count[word[i]]++;
    }
    let lst = [];
    let sortedCount = Object.keys(count).sort();
    sortedCount.forEach(sym =&gt; {
      lst.push(sym);

    })
    return lst.sort();
  }

  let groups = {};
  words.forEach(word => {
    let key = getKey(word);
    if (!groups[key]) {
      groups[key] = [];
    }
    groups[key].push(word)
  });
  let result = [];
  for (let k in groups) {
    result.push(groups[k]);
  }

  return result;
}</pre>

    <p>Если такую оптимизацию не выносить в отдельную функцию, а делать в основном коде. То будет очень трудно понять что там вообще происходит.</p>
  </details>
</article>


<!-- Разбор ДЗ по лекции 1 и 2 -->
<article class="article">
  <div class="anchor" id="dzl12"></div>
  <h2>Разбор ДЗ по лекции 1 и 2</h2>
</article>


<!-- Занятие 1. Узник замка Иф -->
<article class="article">
  <div class="anchor" id="dzl1-1"></div>
  <h2>Занятие 1. Узник замка Иф</h2>

  <p>За многие годы заточения узник замка Иф проделал в стене прямоугольное отверстие размером D на E. Замок Иф сложен из кирпичей, рамзером A на B на C. Определите, сможет ли узник выбрасывать кирпичи в море через это отверстие, если стороны кирпича должны быть параллельны сторонам отверстия.</p>

  <details>
    <summary>Решение</summary>
    <p>Можно перебрать все возможные способы и проверить пролезет ли кирпич в отверстие. Но это будет неэффективно.</p> 
    <p></p>Давайте сначала упорядочим стороны кирпича от меньшей к большей A,B,C и отверстия - D,E. Тогда получим меньшую сторону кирпича А и меньшую сторону отверстия D. Нам нужно чтобы было A меньше D, и В меньше Е. Самую длинную сторону кирпича А ни с чем сравнивать не надо.
    <p>Кирпич пройдет в отверстие если A &le; D и B &le; E.</p>
    <p>Чтобы упорядочить два числа, просто сравним их. Чтобы упорядочить три числа напишем сортировку пузырьком.</p>
<pre>function uznik([a,b,c,d,e]) {
  // функция сортировки
  function sort2(n1, n2) {
    if (n1 > n2) {
      return [n2, n1];
    }
    return [n1, n2];
  }

  // сортируем стороны
  [a, b] = sort2(a, b);
  [b, c] = sort2(b, c);
  [a, b] = sort2(a, b);
  [d, e] = sort2(d, e);

  if (d &gt;= a && e &gt;=b) {
    return true;
  }
  return false;
}</pre>

    <p>Тест</p>
    <code>let w1 = [5,4,3,3,4];</code>
    <code>console.log(uznik(w1)); // true</code>
  </details>
</article>


<!-- Занятие 1. Метро -->
<article class="article">
  <div class="anchor" id="dzl1-2"></div>
  <h2>Занятие 1. Метро</h2>

  <p>На некоторых кросс-платформенных станциях метро (как, например, "Третьяковская") на разные стороны платформы приходят поезда разных направлений. Таня договорилась встретиться с подругой на такой станции, но поскольку подруга приехала из другого часового пояса, то из-за джетлага сильно проспала, и Тане пришлось долго ее ждать. Поезда всегда ходят точно по расписанию, и Таня знает, что поезд стоит на платформе ровно одну минуту, а интервал между поездами (время, в течение которого поезда у платформы нет) составляет a минут для поездов на первом пути и b минут для поездов на втором пути. То есть на первый путь приезжает поезд и стоит одну минуту, затем в течение a минут поезда у платформы нет, затем в течение одной минуты у платформы стоит следующий поезд и т.д.</p>
  <p>Пока Таня стояла на платформе, она насчитала n поездов на первом пути и m поездов на втором пути. Определите минимальное и максимальное время, которое Таня могла провести на платформе, или сообщите, что она точно сбилась со счета.</p>
  <p>Все поезда, которые видела Таня, она наблюдала в течение всей минуты, то есть Таня не приходит и не уходит с платформы посередине той минуты, когда поезд стоит на платформе.</p>

  <details>
    <summary>Решение</summary>
    <p>Если Таня на первом пути видела 3 поезда, то минимум времени это время стоянки трех поездов и два интервала между поездами. Максимум времени это если к минимуму прибавить еще два интервала между поездами</p>
    <code>min1 = a*(n-1)+n</code>
    <code>max1 = a*(n-1)+n+2a</code>

    <p>То же самое для второго пути</p>
    <code>min2 = b*(m-1)+m</code>
    <code>max2 = b*(m-1)+m+2b</code>

    <p>Для определения минимального времени, проведенного Таней найдем максимум из минимумов, для максимального - найдем минимум из максимумов. Если максимальное время окажется меньше минимального, то Таня сбилась со счета.</p>
<pre>function metro([a,b,n,m]) {
  min1 = (a + 1) * (n - 1) + 1;
  max1 = (a + 1) * (n - 1) + 1 + 2 * a;
  min2 = (b + 1) * (m - 1) + 1;
  max2 = (b + 1) * (m - 1) + 1 + 2 * b;

  min = Math.max(min1, min2);
  max = Math.min(max1, max2);

  if (max &lt; min) {
    return -1;
  }
  return [min, max];
}</pre>

    <p>Тест</p>
    <code>let w1 = [2,4,5,2];</code>
    <code>console.log(metro(w1)); // [ 13, 14 ]</code>
    <code>let w2 = [2,4,5,5];</code>
    <code>console.log(metro(w2)); // -1</code>
  </details>
</article>


<!-- Занятие 1. Скорая помощь -->
<article class="article">
  <div class="anchor" id="dzl1-3"></div>
  <h2>Занятие 1. Скорая помощь</h2>

  <p>Бригада скорой помощи выехала по вызову в один из отдаленных районов. К сожалению, когда диспетчер получил вызов, он успел записать только адрес дома и номер квартиры K1, а затем связь прервалась. Однако он вспомнил, что по этому же адресу дома некоторое время назад скороя помощь выезжала в квартиру K2, которая расположена в подъезде P2 на этаже N2. Известно, что в доме M этажей и количество квартир на каждой лестничной площадке одинаково. Напишите программу, которая вычисляет номер подъезда P1 и номер этажа N1 квартиры K1</p>
  <p>Числа до 10^6</p>

  <p>Числа до миллиона мы можем перебрать за линейное время, но не за квадрат. Мы не можем перебирать и номер квартиры и номер этажа. Выберем что-то одно. Будем перебирать количество квартир на одной лестничной площадке K. Если мы знаем количество квартир на одной лестничной площадке, мы можем проверить какое количество квартир подходит для P2, N2. И зная это посчитать для квартиры с номером K1 номер подъезда и номер этажа.</p>

  <p>Нарисуем подъезды один над другим. Начиная с первого подъезда. Первый этаж первого подъезда будет первым этажем на таком рисунке. Если в доме M этажей, то первый этаж второго подъезда будет M+1 этажем на таком рисунке. Если число подъездов P, то последний этаж последнего подъезда будет M*P этажем.</p>

  <p>Итак, мы перебираем количество квартир на лестничной полщадке. Мы знаем в каком подъезде P2 и на каком этаже N2 находится квартира K2. Поделим K2 на количество квартир на этаже и определим на каком этаже находится квартира K2. Если подошло с тем, что мы знаем, то считаем для квартиры K1 зная ее номер и количество квартир на этаже, номер этажа и номер подъезда.</p>
</article>


<!-- Занятие 2. Симметричная последовательность -->
<article class="article">
  <div class="anchor" id="dzl2-1"></div>
  <h2>Занятие 2. Симметричная последовательность</h2>

  <p>Последовательность чисел назовем симметричной, если она одинаково читается как слева направо, так и справа налево. Например, следующие последовательности являются симметричными:</p>
  <code>123454321</code>
  <code>12122121</code>
  <p>Вашей программе будет дана последовательность чисел. Требуется определить, какое минимальное количество и каких чисел надо приписать в конец последовательности, чтобы она стала симметричной</p>
  <p>Длина последовательности до 100</p>

  <details>
    <summary>Решение</summary>
    <p>Это ограничение говорит нам о том, что можно решать за O(N^2). Но есть алгоритм, который решает за линейное время используя префикс функции.</p>
  </details>
</article>


<!-- Занятие 2. Наибольшее произведение трех чисел -->
<article class="article">
  <div class="anchor" id="dzl2-2"></div>
  <h2>Занятие 2. Наибольшее произведение трех чисел</h2>

  <p>В данном списке из n&lt;=10^5 целых чисел найдите три числа, произведение которых максимально</p>
  <p>Решение должно иметь сложность O(n), где n - размер списка</p>
  <p>Выведите три искомых числа в любом порядке</p>

  <details>
    <summary>Решение</summary>
    <p>Посмотрим, когда произведение трех чисел будет максимально? Если все числа положительные, тогда произведение трех максимальных чисел будет максимально. Если есть отрицательные числа, то максимальным может оказаться произведение двух минимальных отрицательных и одного максимального положительного.</p>
    <p>Нам нужно отсортировать числа так чтобы три максимальных стояли справа, а два минимальных слева. Остальные числа сортировать не нужно.</p>
    <p>У нас есть массив. Возьмем из него случайное число x и поставим числа меньше x слева, а числа больше x справа от x.</p>
  </details>
</article>


<!-- Занятие 2. Сапер -->
<article class="article">
  <div class="anchor" id="dzl2-3"></div>
  <h2>Занятие 2. Сапер</h2>

  <p>Вам необходимо построить поле для игры "Сапер" по его конфигурации - размерам и координатам расставленых мин</p>
  <p>Вкратце напомним правила построения поля для игры "Сапер"</p>
  <ul>
    <li>Поле состоит из клеток с минами и пустых клеток</li>
    <li>Клетки с миной обозначаются символом *</li>
    <li>Пустые клетки содержат число k(i,j), 0&lt;=k(i,j)&lt;=8 количество мин на соседних клетках. Соседними клетками являются восемь клеток, имеющих смежный угол или сторону</li>
  </ul>

  <details>
    <summary>Решение</summary>
    <p>Проблема задачи в том, чтобы для клетки с координатами i и j найти все 8 соседние клетки. Для одной клетки можно написать 8 if-ов и это будет работать. Но если клеток много, то такое решение будет очень медленное и можно придумать более эффективное решение. Решение этих проблем - это массив сдвигов.</p>
    <code>di = [1,1,1,0,-1,-1,-1,0]</code>
    <code>dj = [1,0,-1,-1,-1,0,1,1]</code>
    <p>Получаем восемь клеток с координатами начиная от правого верхнего угла от нашей клетки и по часовой стрелке, вокруг нее 8 клеток.</p>
    <code>первая соседняя клетка [i+di[0],j+dj[0]</code>
    <code>вторая соседняя клетка [i+di[1],j+dj[1]</code>
    <code>восьмая соседняя клетка [i+di[7],j+dj[7]</code>
    <p>Вторая проблема - это клетки у края или в углу. Для них некоторые соседи выходят за границы игрового поля. Решение этой проблемы - создание рамки шириной в 1 клетку вокруг игрового поля, чтобы для крайних клеток соседи тоже существовали.</p>
  </details>
</article>


<!-- Занятие 2. Треугольник Максима -->
<article class="article">
  <div class="anchor" id="dzl2-4"></div>
  <h2>Занятие 2. Треугольник Максима</h2>

  <p>С детства Максим был неплохим музыкантом и мастером на все руки. Недавно он самостоятельно сделал несложный перкуссионный музыкальный инструмент - треугольник. Ему нужно узнать, какова частота звука, издаваемого его инструментом</p>
  <p>У Максима есть профессиональный музыкальный тюнер, с помощью которого можно проигрывать ноту с заданной частотой. Максим действует следующим образом: он включает на тюнере ноты с разными частотами и для каждой ноты на слух определяет, ближе или дальше она к издаваемому треугольником звуку, чем предыдущая нота. Поскольку слух у Максима абсолютный, он определяет это всегда верно.</p>
  <p>Вам Максим показал запись, в которой приведена последовательность частот, выставляемых им на тюнере, и про каждую ноту, начиная со второй, записано - ближе или дальше она к звуку треугольника, чем предыдущая нота. Заранее известно, что частота звучания треугольника Максима составляет не менее 30 Герц и не более 4000 Герц</p>
  <p>Требуется написать программу, которая определяет, в каком интервале может находиться частота звучания треугольника.</p>

  <details>
    <summary>Решение</summary>
    <p>Частота треугольника находится между левой границей в 30 Герц и правой границей в 4000 Герц. После второго измерения нам нужно обработать 4 варианта</p>
    <ol>
      <li>вторая частота ниже первой и она ближе к частоте треугольника чем первая. нужно менять правую границу на середину между первой и второй частотой</li>
      <li>вторая частота ниже первой и она дальше к частоте треугольника чем первая. нужно менять левую границу на середину между первой и второй частотой</li>
      <li>вторая частота выше первой и она ближе к частоте треугольника чем первая. нужно менять левую границу на середину между первой и второй частотой</li>
      <li>вторая частота выше первой и она дальше к частоте треугольника чем первая. нужно менять правую границу на середину между первой и второй частотой</li>
    </ol>
    <p></p>
  </details>
</article>


<!-- Лекция 5. Префиксные суммы и два указателя -->
<article class="article">
  <div class="anchor" id="l5"></div>
  <h2>Лекция 5. Префиксные суммы и два указателя</h2>
</article>


<!-- Префиксные суммы -->
<article class="article">
  <div class="anchor" id="l5-1"></div>
  <h2>Префиксные суммы</h2>

  <p>Этот метод позволяет решать задачи вида - сколько событий произошло за определенный интервал времени.</p>
  <p>Что такое префиксные суммы</p>
  <ul>
    <li>Пусть у нас есть массив nums из N чисел и необходимо отвечать на запросы "Чему равна сумма элементов на полуинтервале [L,R)"</li>
    <li>Подсчитаем массив prefixsum длиной N+1, где prefixsum[k] будет хранить сумму всех чисел из nums с индексами от 0 до k-1</li>
  </ul>
<pre>
Индекс     0  1  2   3   4   5   6
num        5  3  8   1   4   6
prefixsum  0  5  8  16  17  21  27
</pre>

  <p>Построение массива префиксных сумм</p>
  <ul>
    <li>Массив можно построить за O(N):
      <code>prefixsum[i] = prefixsum[i-1] + nums[i-1]</code>
    </li>
    <li>Не забыть про отличие размера!</li>
    <li>Переполнение!</li>
  </ul>

  <p>Ответ на запрос суммы на отрезке</p>
  <code>Ответ за O(1): sum(L,R) = prefixsum[R] - prefixsum[L]</code>
  <code>Найдем sum(2,5) = prefixsum[5] - prefixsum[2] = 21 - 8 = 13</code>

  <h4>Реализация RSQ (Range Sum Query - запрос суммы на отрезке) через префиксные суммы</h4>
<pre>function makePrefixSum(nums) {
  let p = [0];
  for (let i = 1; i &lt; nums.length; i++) {
    p[i] = p[i-1] + nums[i-1];
  }
  return p;
}

function rsq(l, r) {
  return prefixSum[r] - prefixSum[l];
}</pre>
    
  <p>Тест</p>
  <code>let w1 = [2,4,5,2,6,9,2];</code>
  <code>let prefixSum = makePrefixSum(w1);</code>
  <code>console.log(rsq(1, 3)); // 9</code>
</article>


<!-- Задача 1. Сколько нулей на полуинтервале -->
<article class="article">
  <div class="anchor" id="l5-task-1"></div>
  <h2>Задача 1. Сколько нулей на полуинтервале</h2>

  <p>Дана последовательность чисел длиной N и M запросов</p>
  <p>Запросы: "Сколько нулей на полуинтервале [L,R)"</p>

  <details>
    <summary>Решение за O(NM)</summary>
    <p>Для каждого запроса перебираем все числа от L до R (не включительно) и считаем количество нулей. В худшем случае каждый запрос за O(N)</p>
<pre>function countZero(nums, l, r) {
  let count = 0;
  for (let i = l; i &lt; r; i++) {
    if (nums[i] === 0) {
      count++;
    }
  }
  return count;
}</pre>

    <p>Тест</p>
    <code>let w1 = [1,1,0,0,0,1,2];</code>
    <code>console.log(countZero(w1, 2, 5)); // 3</code>
  </details>

  <details>
    <summary>Решение за O(N+M)</summary>
    <p>Применим идею префиксных сумм для быстрого ответа на запрос. Для каждого префикса посчитаем количество нулей на нем (prefixzeroes). Тогда ответ на запрос на полуинтервале [L,R):</p>
    <code>prefixzeroes[R] - prefixzeroes[L]</code>
<pre>
nums         1 0 1 1 0 0 1
prefixzeroes 0 0 1 1 1 2 3 3</pre>

<pre>function makePrefixZeroes(nums) {
  let p = [0];
  for (let i = 1; i &lt; nums.length; i++) {
    if (nums[i-1] === 0) {
      p[i] = p[i-1] + 1;
    } else {
      p[i] = p[i-1];
    }
  }
  return p;
}

function countZero(l,r) {
  return prefixzeroes[r] - prefixzeroes[l];
}

let w1 = [1,1,0,0,0,1,2];
let prefixzeroes = makePrefixZeroes(w1);

console.log(countZero(1, 6));</pre>
  </details>
</article>


<!-- Задача 2. Найти количество отрезков с нулевой суммой -->
<article class="article">
  <div class="anchor" id="l5-task-2"></div>
  <h2>Задача 2. Найти количество отрезков с нулевой суммой</h2>

  <p>Дана последовательность чисел длиной N</p>
  <p>Необходимо найти количество отрезков с нулевой суммой</p>
  <p>Примечание: если элемент равен 0, то этот элемент тоже отрезок с нулевой суммой</p>

  <details>
    <summary>Решение за O(N^3)</summary>
    <p>Переберем начало и конец отрезка и просто просуммируем все его элементы</p>
<pre>
указатели         L         R
индексы    0  1   2  3   4  5   6  7
массив    [4, 3, -1, 0, -3, 5, -2, 0]
</pre>
    <p>Переберем все отрезки. Для этого левый указатель пройдется по всему массиву от 0 до N. Сложность O(N). Правый указатель пройдется по всему массиву от L до N. Сложность O(N). Просуммируем элементы каждого отрезка. Сложность O(N). Итого сложность алгоритма O(N^3).</p>
<pre>function countRange(nums) {
  let result = 0;
  for (let i = 0; i &lt; nums.length; i++) {
    for (let j = i; j &lt; nums.length; j++) {
      rangeSum = 0;
      for (let k = i; k &lt; j + 1; k ++) {
        rangeSum += nums[k];
      }
      if (rangeSum === 0) {
        result++;
      }
    }
  }
  return result;
}


let w1 = [4, 3, -3, 0];
let w2 = [4, 3, -3, 0, -4, 5, -2, -3];

console.log(countRange(w1)); // 2
console.log(countRange(w2)); // 5</pre>
  </details>

  <details>
    <summary>Решение за O(N^2)</summary>
    <p>Переберем начало и будем двигать конец, суммируя элементы</p>
<pre>function countRange(nums) {
  let result = 0;
  for (let i = 0; i &lt; nums.length; i++) {
    rangeSum = 0;
    for (let j = i; j &lt; nums.length; j++) {
      rangeSum += nums[j];
      if (rangeSum === 0) {
        result++;
      }
    }
  }
  return result;
}


let w1 = [4, 3, -3, 0];
let w2 = [4, 3, -3, 0, -4, 5, -2, -3];

console.log(countRange(w1)); // 3
console.log(countRange(w2)); // 6</pre>
  </details>

  <details>
    <summary>Решение за O(N)</summary>
    <p>Насчитаем префиксные суммы. Одинаковые префиксные суммы означают, что сумма на отрезке с началом и концом в позициях, на которых достигаются одинаковые префиксные суммы, будет равна нулю</p>
<pre>function countPrefixSums(nums) {
  let dict = {0: 1};
  let nowsum = 0;
  for (let i = 0; i &lt; nums.length; i++) {
    nowsum += nums[i];
    if (!dict[nowsum]) {
      dict[nowsum] = 0;
    }
    dict[nowsum]++;
  }
  console.log(dict)
  return dict;
}

function countRange(p) {
  let count = 0;
  for (let key in p) {
    let sum = p[key];
    count += sum*(sum-1)/2;
  }
  return count;
}


let w1 = [4, 3, -3, 0];
let w2 = [4, 3, -3, 0, -4, 5, -2, -3];

let p = countPrefixSums(w1);

console.log(countRange(p)); // 3</pre>
  </details>
</article>


<!-- Два указателя -->
<article class="article">
  <div class="anchor" id="l5-2"></div>
  <h2>Два указателя</h2>
</article>


<!-- Задача 3. Сколько пар чисел в разности больше определенного числа -->
<article class="article">
  <div class="anchor" id="l5-task-3"></div>
  <h2>Задача 3. Сколько пар чисел в разности больше определенного числа</h2>

  <p>Дана отсортированная последовательность чисел длиной N и число K</p>
  <p>Необходимо найти количество пар чисел A, B, таких что B - A > K</p>
  <p>Пример</p>
  <code>Вход [1,3,7,8], 4</code>
  <code>Выход 3</code>

  <details>
    <summary>Решение за O(N^2)</summary>
    <p>Переберем все пары чисел и для каждой проверим условие</p>
<pre>function countPairs(nums, k) {
  let result = 0;
  for (let i = 0; i &lt; nums.length; i++) {
    for (let j = i; j &lt; nums.length; j++) {
      if (nums[j] - nums[i] > k) {
        result++;
      }
    }
  }
  return result;
}

let w1 = [1,3,7,8];

console.log(countPairs(w1, 4)); // 3</pre>
  </details>

  <details>
    <summary>Решение за O(N)</summary>
    <p>Возьмем наименьшее число и найдем для него первое подходящее большее. Все еще большие числа точно подходят. Возьмем в качестве меньшего числа следующее, а указатель первого подходящего будем двигать начиная с той позиции, где он находится сейчас</p>
  </details>
</article>


<!-- Задача 4. Суммарный профессионализм команды -->
<article class="article">
  <div class="anchor" id="l5-task-4"></div>
  <h2>Задача 4. Суммарный профессионализм команды</h2>

  <p>Игрок в футбол обладает одной числовой характеристикой - профессионализмом. Команда называется сплоченной, если профессионализм любого игрока не превосходит суммарный профессионализм любых двух игроков из команды. Команда может состоять из любого количества игроков. Дана отсортированная последоваельность чисел длиной N - профессионализм игроков.</p>
  <p>Найти максимальный суммарный профессионализм сплоченной команды</p>

  <details>
    <summary>Решение</summary>
    <p>Решение методом двух указателей.</p> 
    <p>Правый указатель на самого сильного игрока сначала будет равен 0. Девым указателем будем идти от нуля до правого и проверять что правый указатель не вышел за диапазон последовательности и левый и правый указатель стали равны или сумма двух самых слабых игроков больше или равна самому сильному игроку. Увеличим правый указатель на 1 и повторим.</p>
<pre>function bestSum(nums) {
  let result = 0;
  let nowsum = 0;
  let right = 0;
  for (let left = 0; left &lt; nums.length - 1; left++) {
    while ((right &lt; nums.length) && (right === left || nums[left] + nums[left+1] &gt;= nums[right])) {
      nowsum += nums[right];
      right++;
    }
    result = Math.max(result, nowsum);
    nowsum -= nums[left];
  }
  return result;
}

let w1 = [1,3,5,7,8];

console.log(bestSum(w1)); // 23</pre>
  </details>
</article>


<!-- Задача 5. Два отсортированных массива слить в один -->
<article class="article">
  <div class="anchor" id="l5-task-5"></div>
  <h2>Задача 5. Два отсортированных массива слить в один</h2>

  <p>Даны две отсортированные последовательности чисел длиной N и M соответственно</p>
  <p>Необходимо слить их в одну отсортированную последовательность</p>

  <details>
    <summary>Решение</summary>
    <p>Поставим два указателя на начало каждой из последовательностей. Выберем тот, который указывает на меньшее число, запишем это число в результат и сдвинем указатель</p>
<pre>function mergeNums(nums1, nums2) {
  let result = [];
  let p1 = 0;
  let p2 = 0;
  while (result.length &lt; nums1.length + nums2.length) {
    if (nums1[p1] &lt; nums2[p2]) {
      result.push(nums1[p1]);
      p1++;
      if (p1 === nums1.length) {
        result = result.concat(nums2.slice(p2))
        break;
      }      
    } else {
      result.push(nums2[p2]);
      p2++;
      if (p2 === nums2.length) {
        result = result.concat(nums1.slice(p1))
        break;
      }      
    }
  }
  return result;
}

let w1 = [1,3,5,7,8,10];
let w2 = [2,2,4];

console.log(mergeNums(w1,w2));</pre>
  </details>
</article>


<!-- Лекция 6. Бинарный поиск -->
<article class="article">
  <div class="anchor" id="l6"></div>
  <h2>Лекция 6. Бинарный поиск</h2>

  <p>Содержание сегодняшней лекции</p>
  <ol>
    <li>Бинарный поиск</li>
    <li>Задача из жизни</li>
    <li>Тернарный поиск (которого нет)</li>
  </ol>
</article>


<!-- Бинарный поиск -->
<article class="article">
  <div class="anchor" id="l6-1"></div>
  <h2>Бинарный поиск</h2>

  <p>Что такое бинарный поиск вы уже знаете, потому что совершали его много раз, когда искали слово в словаре! Сначала открываем словарь в середине, затем в той половине где есть буква, на которую начинается слово. На каждом шагу уменьшается область поиска вдвое. Поэтому поиск бинарный.</p>

  <h4>Левый и правый бинарный поиск</h4>
  <p>Левый бинпоиск - ищем первое подходяще значение, когда слева от него все значения не подходят под условие поиска</p>
  <p>Правый бинпоиск - ищем последнее подходящее значение, когда справа от него все значения не подходят под условие поиска</p>
  <p>Бинарный поиск по отсортированной последовательности использует два указателя: левый - на первый элемент, правый - на последний элемент. Сравниваем элемент в середине последовательности, если нам нужен больше, то левый указатель ставим на средний элемент, иначе правый. И так до тех пор пока не найдем нужный элемент или два указателя станут равны друг другу.</p>
</article>


<!-- Задача 1. Не менее трети родителей от общего числа -->
<article class="article">
  <div class="anchor" id="l6-task-1"></div>
  <h2>Задача 1. Не менее трети родителей от общего числа</h2>

  <p>В управляющий совет школы входят родители, учителя и учащиеся школы, причем родителей должно быть не менее одной трети от общего числа членов совета. В настоящий момент в совет входит N человек, из них K родителей</p>
  <p>Определите, сколько родителей нужно дополнительно ввести в совет, чтобы их число стало не менее одной трети от числа членов совета.</p>

  <details>
    <summary>Решение</summary>
    <p>Будем искать минимальное количество родителей, которых нужно добавить бинарным поиском. Не забываем, что новые родители добавляются к общему числу членов совета. Не используем деление. L = 0, R = N</p>
  </details>
</article>


<!-- Задача 2. Сколько дней нужно чтобы решить N задач на leetcode -->
<article class="article">
  <div class="anchor" id="l6-task-2"></div>
  <h2>Задача 2. Сколько дней нужно чтобы решить N задач на leetcode</h2>

  <p>Юра решил подготовиться к собеседованию в Яндекс. Он выбрал на сайте leetcode N задач. В первый день Юра решил K задач, а в каждый следующий день Юра решал на одну задачу больше, чем в предыдущий день.</p>
  <p>Определите, сколько дней уйдет у Юры на подготовку к собеседованию.</p>

  <details>
    <summary>Решение</summary>
    <p>Будем искать минимальное количество дней, достаточное для решения не менее N задач бинарным поиском. Нам понадобится формула арифметической прогрессии. L = 0, R = N</p>
  </details>
</article>


<!-- Задача 3. Максимальная длина стороны стикера для доски -->
<article class="article">
  <div class="anchor" id="l6-task-3"></div>
  <h2>Задача 3. Максимальная длина стороны стикера для доски</h2>

  <p>Михаил читает лекции по алгоритмам. За кадром стоит доска размером W*H сантиметров. Михаилу нужно разместить на доске N квадратных стикеров со шпаргалками, при этом длина стороны стикера в сантиметрах должна быть целым числом</p>
  <p>Определите максимальную длину стороны стикера, чтобы все стикеры поместились на доске.</p>

  <details>
    <summary>Решение</summary>
    <p>Будем искать максимальную сторону стикера бинарным поиском. Пока стикеры маленькие, все хорошо, начиная с какого-то момента они становятся большими и уже не влезают на доску. Будем перебирать размер стикеров. Делить длину доски на количество стикеров и получать количество стикеров в одном ряду. Потом будем делить высоту доски на количество стикеров и получать количество рядов. Потом посчитаем сколько стикеров поместится на доску и сравним с нужным числом N.</p>
  </details>
</article>


<!-- Задача 4. Первое число, которое больше или равно заданному -->
<article class="article">
  <div class="anchor" id="l6-task-4"></div>
  <h2>Задача 4. Первое число, которое больше или равно заданному</h2>

  <p>Задана отсортированная по неубыванию последовательность из N чисел и число X.</p>
  <p>Необходимо определить индекс первого числа в последовательности, которое больше либо равно X. Если такого числа нет, то вернуть число N</p>

  <details>
    <summary>Решение</summary>
    <p>Воспользуемся левым бинпоиском для поиска первого подходящего числа. В случае, если бинпоиск сошелся к числу, меньшему X вернем N</p>
  </details>
</article>


<!-- Задача 5. Сколько раз число в ходит в последовательность -->
<article class="article">
  <div class="anchor" id="l6-task-5"></div>
  <h2>Задача 5. Сколько раз число в ходит в последовательность</h2>

  <p>Задана отсортированная по неубыванию последовательность из N чисел и число X</p>
  <p>Необходимо определить сколько раз число X входит в последовательность</p>

  <details>
    <summary>Решение</summary>
    <p>Найдем одним левым бинпоиском первое число больше либо равное X, а вторым левым бинпоиском - число строго большее X. Разность индексов и будет количеством вхождений.</p>
  </details>
</article>


<!-- Задача 6. Размер аннуитентного ежемесячного платежа -->
<article class="article">
  <div class="anchor" id="l6-task-6"></div>
  <h2>Задача 6. Размер аннуитентного ежемесячного платежа</h2>

  <p>Задана процентная ставка по кредиту X% годовых, срок кредитования N месяцев и сумма кредита M рублей</p>
  <p>Необходимо рассчитать размер аннуитентного ежемесячного платежа</p>

  <details>
    <summary>Решение подзадачи о ежемесячном проценте</summary>
    <p>Ежемесячный процент не равен X/12! Подберем его бинпоиском.</p>
  </details>

  <details>
    <summary>Решение задачи о размере платежа</summary>
    <p>Будем перебирать сумму платежа бинпоиском, а в качестве проверки моделировать процесс ежемесячной выплаты, уменьшая тело кредита на разницу между суммой платежа и ежемесячным процентом</p>
  </details>
</article>


<!-- Задача 7. Момент времени когда расстояние между велосипедистами минимально -->
<article class="article">
  <div class="anchor" id="l6-task-7"></div>
  <h2>Задача 7. Момент времени когда расстояние между велосипедистами минимально</h2>

  <p>Велосипедисты, участвующие в шоссейной гонке, в некоторый момент времени, который называется начальным, оказались в точках, удаленных от места старта на x1,x2,...,xn метров(n - общее количество велосипедистов, не превосходит 100 000). Каждый велосипедист двигается со своей постоянной скоростью v1,v2,...,vn метров в секунду. Все велосипедисты двигаются в одну сторону. Репортер, освещающий ход соревнований, хочет определить момент времени, в который расстояние между лидирующим в гонке велосипедистом и замыкающим гонку велосипедистом станет минимальным, чтобы с вертолета сфотографировать сразу всех участников велогонки.</p>
  <p>Необходимо найти момент времени, когда расстояние станет минимальным</p>

  <details>
    <summary>Решение</summary>
    <p>Определим функцию dist(t), которая будет за O(N) определять расстояние между лидером и замыкающим в момент времени t. Если dist(t+epsilon) > dist(t), то функция растет и надо сдвинуть левую границу поиска, иначе - правую.</p>
  </details>
</article>


<!-- Разбор ДЗ по лекции 3 и 4 -->
<article class="article">
  <div class="anchor" id="l34"></div>
  <h2>Разбор ДЗ по лекции 3 и 4</h2>
</article>


<!-- Занятие 3. Черепахи -->
<article class="article">
  <div class="anchor" id="l3-1"></div>
  <h2>Занятие 3. Черепахи</h2>

  <p>Широко известна следующая задача для младших школьников. Три черепахи ползут по дороге. Одна черепаха говорит: "Впереди меня две черепахи". Другая черепаха говорит: "Позади меня две черепахи". Третья черепаха говорит: "Впереди меня две черепахи и позади меня две черепахи". Как такое может быть? Ответ: третья черепаха врет!</p>
  <p>По дороге одна за другой движутся N черепах. Каждая черепаха говорит фразу вида: "Впереди меня ai черепах, а позади меня bi черепах." Ваша задача определить, сколько самое большое количество черепах могут говорить правду.</p>

  <details>
    <summary>Решение</summary>
    <p>Если черепаха называет отрицательное число, то это неправда. Проверяем числа на отрицательность. В сумме всех черепах N. Поэтому проверяем, что ai + bi = N - 1. Если две черепахи сказали одно и то же, то говорит правду только одна. Поэтому делаем множество из всех ответов ai и смотрим чтобы они не повторялись.</p>
<pre>function cherepaha(n, a, b) {
  let setA = new Set();
  for (let i = 0; i &lt; n; i++) {
    if (a[i] >=0 && b[i] >= 0 && a[i] + b [i] === n - 1) {
      setA.add(a[i]);
    }
  }
  return setA.size;
}

let n1 = 6;
let w1 = [1,-3,0,3,4,1];
let w2 = [4,3,5,-1,1,4];

console.log(cherepaha(n1, w1,w2)); // 3</pre>
  </details>
</article>


<!-- Занятие 3. Пробежки по Манхэттену -->
<article class="article">
  <div class="anchor" id="l3-2"></div>
  <h2>Занятие 3. Пробежки по Манхэттену</h2>

  <p>Дороги Нью-Манхэттена устроены следующим образом. С юга на север через каждые сто метров проходит авеню, с запада на восток через каждые сто метров проходит улица. Авеню и улицы нумеруются целыми числами. Меньшие номера соответствуют западным авеню и южным улицам. Таким образом, можно построить прямоугольную систему координат так, чтобы точка (x,y) лежала на пересечении x-ой авеню и y-ой улицы. Легко заметить, что для того, чтобы в Нью-Манхэттене дойти от точки (x1,y1) до точки (x2,y2) нужно пройти |x2-x1| + |y2-y1| кварталов. Эта величина называется манхэттенским расстоянием между точками (x1,y1) и (x2,y2)</p>
  <p>Миша живет в Нью-Манхэттене и каждое утро делает пробежку по городу. Он выбегает из своего дома, который находится в точке (0,0) и бежит по случайному маршруту. Каждую минуту миша либо остается на том же перекрестке, что и минуту назад, или перемещается на один квартал в любом направлении. Чтобы не заблудиться Миша берет с собой навигатор, который каждые t минут говорит Мише, в какой точке он находится. К сожалению, навигатор показывает не точное положение Миши, он может показать любую из точек, манхэттенское расстояние от которых до Миши не превышает d.</p>
  <p>Через t*n минут от начала пробежки, получив n-е сообщение от навигатора, Миша решил что пора бежать домой. Для этого он хочет понять, в каких точках он может находиться. Помогите Мише сделать это.</p>
</article>


<!-- Занятие 4. Расшифровка письменности Майя -->
<article class="article">
  <div class="anchor" id="l4-1"></div>
  <h2>Занятие 4. Расшифровка письменности Майя</h2>

  <p>Одна из проблем расшифровки письменности Майа заключается в определении этого порядка. Рисуя значки некоторого слова, писатели Майя иногда выбирали позиции для значков, исходя скорее из эстетических взглядов, а не определенных правил. Это привело к тому, что, хотя звуки для многих значков известны, археологи не всегда уверены, как должно произноситься записанное слово.</p>
  <p>Археологи ищут некоторое слово W. Они знают значки для него, но не знают все возможные способы их расположения. Поскольку они знают, что Вы приедете на |O|'06, они просят Вас о помощи. Они дадут Вам g значков в надписи, которую они изучают, в порядке их появления. Помогите им, подститав количество возможных появлений слова W.</p>
  <p>Задание. Напишите программу, которая по значкам слова W и по последовательности S значков надписи подсчитывает количество всех возможных вхождений слова W в S, то есть количество всех различных позиций идущих подряд g значков в последовательности S, которые являются какой-либо перестановкой значков слова W.</p>

  <details>
    <summary>Решение</summary>
    <p>Неверным решением было бы брать строку S, брать в ней первые W символов для слова, сортировать их. Потом сдвигаться в строке S на один символ и опять брать W символов, сортировать их и т.д.</p>
    <p>Хорошая идея это посчитать сколько раз каждая буква входит в слово W. Для этого создадим словарь dictW для букв из слова W. Дальше методом окна выбираем в начале предложения S слово длиной W.length, создаем для него словарь dictS и сравниваем его со словарем dictW. Если совпадают то это будет вхождение слова W в предложение S.</p>
    <p>Далее сдвигаем окно на 1 символ. Изменим словарь dictS так что уберем из него первый символ предыдущего слова и добавим один новый символ. Сравним словари dictS и dictW, если совпадают, то увеличим счетчик вхождения слов на 1.</p>  
  </details>
</article>


<!-- Занятие 4. Контрольная по ударениям -->
<article class="article">
  <div class="anchor" id="l4-2"></div>
  <h2>Занятие 4. Контрольная по ударениям</h2>

  <p>Учительница задала Пете домашнее задание - в заданном тексте расставить ударения в словах, после чего поручила Васе проверить это домашнее задание. Вася очень плохо знаком с данной темой, поэтому он нашел словарь, в котором указано, как ставятся ударения в словах. К сожалению, в этом словаре присутствуют не все слова. Вася решил, что в словах, которых нет в словаре, он будет считать, что Петя поставил ударения правильно, если в этом слове Петей поставлено ровно одно ударение. Оказалось, что в некоторых словах ударение может быть поставлено больше, чем одним способом. Вася решил, что в этом случае если то, как Петя поставил ударение, соответствует одному из приведенных в словаре вариантов, он будет засчитывать это как правильную расстановку ударения, а если не соответствует, то как ошибку.</p>
  <p>Вам дан словарь, которым пользовался Вася и домашнее заданее, сделанное Петей. Ваша задача - определить количество ошибок, которое в этом задании насчитает Вася.</p>
  <p>Пример</p>
  <code>Словарь cAnnot, cannOt, fOund, pAge.</code>
  <code>Предложение thE pAge cAnnot be found</code>
  <code>Вывод 2</code>

  <details>
    <summary>Решение</summary>
    <p>Создадим словарь dictLower[key, value] с ключами из маленьких букв, в котором будем ранить Set со всеми ударениями. Set(stress) это набор слов с ударениями. К нам приходит очередное слова в тексте. Мы делаем все его буквы маленькими. Дальше возможны два варианта.</p>
    <p>Вариант 1. Если оно есть в словаре, то мы проверяем, что слово с ударением входит в набор слов с ударениями для этого слова.</p>
    <p>Вариант 2. Если его нет в словаре, то мы должны проверить что у него всего одно ударение.</p>
  </details>
</article>


<!-- Занятие 4. Дополнительная проверка на списывание -->
<article class="article">
  <div class="anchor" id="l4-3"></div>
  <h2>Занятие 4. Дополнительная проверка на списывание</h2>

  <p>В первой строке вводятся число n - количество ключевых слов в языке (0 &lt;= n &lt;= 50) и два слова C и D, каждое из которых равно либо "yes", либо "no". Слово C равно "yes", если идентификаторы и ключевые слова в языке чувствительны к регистру символов, и "no", если нет. Слово D равно "yes", если идентификаторы в языке могут начинаться с цифры, и "no", если нет.</p>
  <p>Следующие n строк содержат по одному слову, состоящему из букв латинского алфавита и символов подчеркивания - ключевые слова. Все ключевые слова непусты, различны, при этом, если язык не чувствителен к регистру, то различны и без учета регистра. Длина каждого ключевого слова не превышает 50 символов.</p>
  <p>Далее до конца входных данных идет текст программы. Он содержит только символы с ASCII-кодами от 32 до 126 и переводы строки.</p>
  <p>Размер входных данных не превышает 10 килобайт. В программе есть хотя бы один идентификатор.</p>
  <p>Выведите идентификатор, встречающийся в программе максимальное число раз. Если таких идентификаторов несколько, следует вывести тот, который встречается в первый раз раньше. Если язык во входных данных не чувствителен к регистру, то можно выводить идентификатор в любом регистре.</p>

  <details>
    <summary>Решение</summary>
    <p>Алгоритм решения может быть таким:</p>
    <ol>
      <li>Создать множество ключевых слов</li>
      <li>Создать две булевые переменные для чувствительности к регистру и возможности начинать идентификатор с цифры</li>
      <li>Создать словарь для количества вхождений идентификаторов и их первых позиций</li>
      <li>Создать счетчик слов</li>
      <li>Пройтись по всем строчкам текста</li>
      <li>Для каждой строки заменить все вхождения символов (кроме букв, цифр и подчеркивания) на пробелы</li>
      <li>Нарезать строку на слова</li>
      <li>Для каждого слова проверить, не ключевое ли оно (с учетом регистра)</li>
      <li>Если не ключевое, то проверить что корректное (не число и не начинается с цифры, если этого нельзя)</li>
      <li>Если все ОК, то увеличить счетчик слов на 1, а если встретилось впервые, то запомнить позицию</li>
      <li>Пройтись по всему словарю со счетчиками, выбрать максимальное количество вхождений, если есть равные, то которое встречалось раньше</li>
    </ol>
  </details>
</article>


<!-- Лекция 7. Сортировка событий -->
<article class="article">
  <div class="anchor" id="l7"></div>
  <h2>Лекция 7. Сортировка событий</h2>

  <h4>Содержание сегодняшней лекции</h4>
  <ol>
    <li>Сортировка событий</li>
    <li>События на круге</li>
    <li>Два прохода</li>
  </ol>
</article>


<!-- Сортировка событий -->
<article class="article">
  <div class="anchor" id="l7-1"></div>
  <h2>Сортировка событий</h2>

  <p>Что такое сортировка событий</p>
  <ul>
    <li>Пусть есть некоторые отрезки во времени (например, отрезок когда человек находился на сайте, т.е. известно его время входа и выхода</li>
    <li>Что-то интересное происходит только в те моменты, когда человек приходит или уходит - события</li>
    <li>Надо что-нибудь посчитать</li>
  </ul>
</article>


<!-- Задача 1. Максимальное количество человек было на сайте одновременно -->
<article class="article">
  <div class="anchor" id="l7-task-1"></div>
  <h2>Задача 1. Максимальное количество человек было на сайте одновременно</h2>

  <p>Сайт посетило N человек, для каждого известно время входа на сайт In[i] и время выхода с сайта Out[i]. Считается, что человек был на сайте с момента In[i] по Out[i] включительно.</p>
  <p>Определите, какое максимальное количество человек было на сайте одновременно</p>

  <details>
    <summary>Решение</summary>
    <p>Создадим на каждого человека два события: вход и выход. Каждое событие - пара, в которой первое число - время, а второе - тип события. Событие "вход на сайт" должно происходить раньше "выхода с сайта".</p>
    <p>Сначала будем сортировать события по времени, потом по типу. Когда одновременно случаются два собития, когда один человек пришел и один ушел, то считаем что сначала новый человек пришел, а уже потом старый человек ушел.</p>
    <p>Заводим счетчик. Когда человек пришел, прибавляем к счетчику 1, когда ушел - вычитаем 1.</p>
    <p>Напишем функцию maxVisitors, она получает на вход количество людей и два массива: со временем входа и временем выхода.</p>
<pre>function maxVisitors(n, tin, tout) {
  let events = [];
  for (let i = 0; i &lt; n; i++) {
    events.push([tin[i], -1]);
    events.push([tout[i], 1]);
  }
  events.sort();
  let online = 0;
  let maxOnline = 0;
  for (let ev of events) {
    if (ev[1] === -1) {
      online++;
    } else {
      online--;
    }
    maxOnline = Math.max(online, maxOnline);
  }
  return maxOnline;
}

let w1 = 4; 
let w2 = [1,2,3,4]; 
let w3 = [3,4,5,6];

console.log(maxVisitors(w1,w2,w3));</pre>
  </details>
</article>


<!-- Задача 2. Суммарное время посетителей на сайте -->
<article class="article">
  <div class="anchor" id="l7-task-2"></div>
  <h2>Задача 2. Суммарное время посетителей на сайте</h2>

  <p>Сайт посетило N человек, для каждого известно время входа на сайт In[i] и время выхода с сайта Out[i]. Считается, что человек был на сайте с момента In[i] по Out[i] включительно.</p>
  <p>Определите, какое суммарное время на сайте был хотя бы один человек.</p>

  <details>
    <summary>Решение</summary>
    <p>Если мы пришли в событие с положительным счетчиком количества людей, то между этим и предыдущим событием на сайте кто-то был. Прибавим к ответу время между текущим и предыдущим событием.</p>
<pre>function timeVisitors(n, tin, tout) {
  let events = [];
  for (let i = 0; i &lt; n; i++) {
    events.push([tin[i], -1]);
    events.push([tout[i], 1]);
  }
  events.sort();
  let online = 0;
  let time = 0;
  for (let i = 0; i &lt; events.length; i++) {
    if (online > 0) {
      time += events[i][0] - events[i-1][0];
    }
    if (events[i][1] === -1) {
      online++;
    } else {
      online--;
    }
  }
  return time;
}


let w1 = 4; 
let w2 = [1,2,5,6]; 
let w3 = [3,3,6,7];

console.log(timeVisitors(w1,w2,w3));</pre>
  </details>
</article>


<!-- Задача 3. Какие показания счетчика увидел начальник -->
<article class="article">
  <div class="anchor" id="l7-task-3"></div>
  <h2>Задача 3. Какие показания счетчика увидел начальник</h2>

  <p>Сайт посетило N человек, для каждого извествно время входа на сайт In[i] и время выхода с сайта Out[i]. Считается, что человек был на сайте с момента In[i] по Out[i] включительно. Начальник заходил на сайт M раз в моменты времени Boss[i] и смотрел, сколько людей сейчас онлайн. Поседения сайта начальником упорядочены по возрастанию времени</p>
  <p>Определите, какие показания счетчика людей онлайн увидел начальник.</p>

  <details>
    <summary>Решение</summary>
    <p>Создадим третий тип события - "вход начальника" и при наступлении такого события будем сохранять текущее значение счетчика посетителей.</p>
<pre>function countVisitors(n, tin, tout, m, tboss) {
  let events = [];
  for (let i = 0; i &lt; n; i++) {
    events.push([tin[i], -1]);
    events.push([tout[i], 1]);
  }
  for (let i = 0; i &lt; m; i++) {
    events.push([tboss[i], 0]);
  }
  events.sort();
  let online = 0;
  let count = [];
  for (let i = 0; i &lt; events.length; i++) {
    if (events[i][1] === -1) {
      online++;
    } else if (events[i][1] === 1) {
      online--;
    } else {
      count.push(online);
    }
  }
  return count;
}


let w1 = 4; 
let w2 = [1,2,5,6]; 
let w3 = [3,3,6,7];
let w4 = 3;
let w5 = [2,3,4];

console.log(countVisitors(w1,w2,w3,w4,w5));</pre>
  </details>
</article>


<!-- События на круге -->
<article class="article">
  <div class="anchor" id="l7-2"></div>
  <h2>События на круге</h2>

  <p>Что такое события на круге</p>
  <ul>
    <li>Самый доступный пример - ежедневно происходящие события</li>
    <li>Круг - это сутки</li>
    <li>Идея: разрезать отрезки, проходящие через полночь, на два</li>
  </ul>
</article>


<!-- Задача 4. Когда были заняты все парковочные места -->
<article class="article">
  <div class="anchor" id="l7-task-4"></div>
  <h2>Задача 4. Когда были заняты все парковочные места</h2>

  <p>На парковке в торговом центре N мест (занумерованных от 1 до N). За день в ТЦ приезжало M автомобилей, при этом некоторые из них длинные и занимали несколько подряд идущих парковочных мест. Для каждого автомобиля известно время приезда и отъезда, а также два числа - с какого по какое парковочные места он занимал. Если в какой-то момент времени один автомобиль уехал с парковочного места, то место считается освободившимся и в тот же момент времени на его место может встать другой.</p>
  <p>Необходимо определить, был ли момент, в который были заняты все парковочные места.</p>

  <details>
    <summary>Решение</summary>
    <p>События - приезд и отъезд автомобиля (причем отъезд должен происходить раньше). Будем поддерживать количество занятых мест и если после очередного события счетчик равен N, то такие моменты были.</p> 
    <p>На каждую машину будем прибавлять или вычитать количество парковочных мест, которые она заняла. Никогда две машины не стоят на одних и тех же парковочных местах, поэтому мы можем не поддерживать множество занятых парковочных мест. Можно смотреть сколько в сумме занято мест.</p>
    <p>Завести счетчик. Каждый раз когда машина приехала - прибавлять количество мест, которые она заняла. Не важно на какие конкретно места встала машина, мы знаем что они не пересекаются. Если счетчик станет равен N - общему количеству мест, то были моменты когда все места на парковке заняты.</p>
    <p>Машина car описывается временем приезда timein, временем отъезда timeout, с какого места placefrom по какое место placeto она заняла.</p>
<pre>function isFull(cars, n) {
  let events = [];
  for (let car of cars) {
    [timein, timeout, placefrom, placeto] = car;
    events.push([timein, 1, placeto - placefrom + 1]);
    events.push([timeout, -1, placeto - placefrom + 1]);
  }
  events.sort();
  let occuped = 0;
  for (let i = 0; i &lt; events.length; i++) {
    if (events[i][1] === -1) {
      occuped -= events[i][2];
    } else if (events[i][1] === 1) {
      occuped += events[i][2];
    } 
    if (occuped === n) {
      return true;
    }
  }
  return false;
}


let w1 = [[1,3,1,2],[2,4,2,3]]; 
let w2 = 2; 

console.log(isFull(w1,w2));</pre>
  </details>
</article>


<!-- Задача 5. Минимальное количество автомобилей, которые заняли все места -->
<article class="article">
  <div class="anchor" id="l7-task-5"></div>
  <h2>Задача 5. Минимальное количество автомобилей, которые заняли все места</h2>

  <p>На парковке в торговом центре N мест (занумерованных от 1 до N). За день в ТЦ приезжало M автомобилей, при этом некоторые из них длинные и занимали несколько подряд идущих парковочных мест. Для каждого автомобиля известно время приезда и отъезда, а также два числа - с какого по какое парковочные места он занимал. Если в какой-то момент времени один автомобиль уехал с парковочного места, то место считается освободившимся и в тот же момент времени на его место может встать другой.</p>
  <p>Необходимо определить, был ли момент, в который были заняты все парковочные места и определить минимальное количество автомобилей которые заняли все места. Если такого момента не было - вернуть M + 1.</p>
  <p>В прошлой задаче мы доходили до первого раза когда занята вся парковка и возвращали true. Возможно несколько моментов когда занята вся парковка, при этом каждый раз количество автомобилей может быть разным.</p>

  <details>
    <summary>Решение</summary>
    <p>Добавим еще один счетчик на количество автомобилей и будем обновлять минимальное количество автомобилей когда заняты все места.</p>
    <p>Теперь у нас будет два счетчика - счетчик количества мест, к которому мы будем добавлять длину машины и счетчик количества машин, к которому мы будем добавлять 1.</p>
<pre>function minCars(cars, n) {
  let events = [];
  for (let car of cars) {
    [timein, timeout, placefrom, placeto] = car;
    events.push([timein, 1, placeto - placefrom + 1]);
    events.push([timeout, -1, placeto - placefrom + 1]);
  }
  events.sort();
  let occuped = 0;
  let nowcars = 0;
  let mincars = cars.length + 1;
  for (let i = 0; i &lt; events.length; i++) {
    if (events[i][1] === -1) {
      occuped -= events[i][2];
      nowcars--;
    } else if (events[i][1] === 1) {
      occuped += events[i][2];
      nowcars++;
    } 
    if (occuped === n) {
      mincars = Math.min(mincars, nowcars);
    }
  }
  return mincars;
}


let w1 = [[1,3,1,2],[2,4,2,3]]; 
let w2 = 2; 

console.log(minCars(w1,w2));</pre>
  </details>
</article>


<!-- Задача 6. Номера минимального количества автомобилей, которые заняли все места -->
<article class="article">
  <div class="anchor" id="l7-task-6"></div>
  <h2>Задача 6. Номера минимального количества автомобилей, которые заняли все места</h2>

  <p>На парковке в торговом центре N мест (занумерованных от 1 до N). За день в ТЦ приезжало M автомобилей, при этом некоторые из них длинные и занимали несколько подряд идущих парковочных мест. Для каждого автомобиля известно время приезда и отъезда, а также два числа - с какого по какое парковочные места он занимал. Если в какой-то момент времени один автомобиль уехал с парковочного места, то место считается освободившимся и в тот же момент времени на его место может встать другой.</p>
  <p>Необходимо определить, был ли момент, в который были заняты все парковочные места и определить минимальное количество автомобилей которые заняли все места, а также номера этих автомобилей (в том порядке, как они перечисляются в списке). Если парковка никогда не была занята полностью вернуть пустой список</p>

  <details>
    <summary>Решение (неэффективное). O(N^2)</summary>
    <p>Добавим в событие номер автомобиля в списке. При обновлении минимума просто копируем текущее состояние в ответ</p>
<pre>function carsNumbers(cars, n) {
  let events = [];
  for (let i = 0; i &lt; cars.length; i++) {
    [timein, timeout, placefrom, placeto] = cars[i];
    events.push([timein, 1, placeto - placefrom + 1, i]);
    events.push([timeout, -1, placeto - placefrom + 1, i]);
  }
  events.sort();
  let occuped = 0;
  let nowcars = 0;
  let mincars = cars.length + 1;
  let carnums = {};
  let bestcarnums;
  for (let i = 0; i &lt; events.length; i++) {
    if (events[i][1] === -1) {
      occuped -= events[i][2];
      nowcars--;
      delete carnums[events[i][3]];
    } else if (events[i][1] === 1) {
      occuped += events[i][2];
      nowcars++;
      carnums[events[i][3]] = 1;
    } 
    if (occuped === n && nowcars &lt; mincars) {
      mincars = nowcars;
      bestcarnums = carnums;
    }
  }
  return bestcarnums;
}


let w1 = [[1,3,1,2],[2,4,2,3]]; 
let w2 = 2; 

console.log(carsNumbers(w1,w2));</pre>
    <p>Сложность O(N^2)</p>
  </details>

  <details>
    <summary>Решение (эффективное). O(N*logN)</summary>
    <p>За первый проход посчитаем минимальное количество машин. На втором проходе мы идем по всем событиям. Когда парковка занята полностью и число машин равно минимальному, которое мы узнали на первом проходе, мы возвращаем текущее состояние множества. Какие машины сейчас стоят, те мы возвращаем в качестве ответа. Ни одного копирования множества здесь не происходит. Сложность O(N*logN)</p>
<pre>function carsNumbers(cars, n) {
  let events = [];
  for (let i = 0; i &lt; cars.length; i++) {
    [timein, timeout, placefrom, placeto] = cars[i];
    events.push([timein, 1, placeto - placefrom + 1, i]);
    events.push([timeout, -1, placeto - placefrom + 1, i]);
  }
  events.sort();
  let occuped = 0;
  let nowcars = 0;
  let mincars = cars.length + 1;
  // первый проход
  for (let i = 0; i &lt; events.length; i++) {
    if (events[i][1] === -1) {
      occuped -= events[i][2];
      nowcars--;
    } else if (events[i][1] === 1) {
      occuped += events[i][2];
      nowcars++;
    } 
    if (occuped === n && nowcars &lt; mincars) {
      // минимальное количество
      mincars = nowcars;
    }
  }
  nowcars = 0;
  let carnums = {};
  // второй проход
  for (let i = 0; i &lt; events.length; i++) {
    if (events[i][1] === -1) {
      occuped -= events[i][2];
      nowcars--;
      delete carnums[events[i][3]];
    } else if (events[i][1] === 1) {
      occuped += events[i][2];
      nowcars++;
      carnums[events[i][3]] = 1;
    } 
    if (occuped === n && nowcars === mincars) {
      return Object.keys(carnums);
    }
  }
  return [];
}


let w1 = [[1,3,1,2],[2,4,2,3]]; 
let w2 = 2; 

console.log(carsNumbers(w1,w2));</pre>
  </details>
</article>


<!-- Лекция 8. Деревья -->
<article class="article">
  <div class="anchor" id="l8"></div>
  <h2>Лекция 8. Деревья</h2>
  
  <h4>Содержание сегодняшней лекции</h4>
  <ol>
    <li>Собственный менеджер памяти</li>
    <li>Бинарное дерево поиска</li>
    <li>Обход деревьев</li>
  </ol>
</article>


<!-- Собственный менеджер памяти -->
<article class="article">
  <div class="anchor" id="l8-1"></div>
  <h2>Собственный менеджер памяти</h2>

  <p>Менеджмент памяти</p>
  <ul>
    <li>У нас есть заранее неизвестное количество структур с двумя ссылками на другие структуры</li>
    <li>Мы знаем заранее, какое максимальное количество структур может существовать одновременно</li>
    <li>Хотим научиться выделять и освобождать память</li>
  </ul>

  <details>
    <summary>Код менеджера памяти</summary>
<pre>function initMemory(maxN) {
  memory = [];
  for (let i = 0; i &lt; maxN.length; i++) {
    memory.push([0, i + 1, 0])
  }
  return [memory, 0];
}

function newNode(memstruct) {
  [memory, firstFree] = memstruct;
  memstruct[1] = memory[firstfree][1];
  return firstfree;
}

function delNode(memstruct, index) {
  [memory, firstFree] = memstruct;
  memory[index][1] = firstFree;
  memstruct[1] = index;
}</pre>
  </details>
</article>


<!-- Бинарное дерево поиска -->
<article class="article">
  <div class="anchor" id="l8-2"></div>
  <h2>Бинарное дерево поиска</h2>

  <p>Что такое бинарное дерево поиска</p>
  <ul>
    <li>У каждого узла ключ и два сынка - левый и правый</li>
    <li>В левом поддереве ключи меньше, а в правом - больше</li>
    <li>Если ключи поступают в случайном порядке, и равномерно распределяются в правой и левой части дерева, то глубина дерева будет O(logN)</li>
    <li>В худшем случае, если приходит возрастающая последовательность, которая добавляется только в правые ветки, глубина дерева будет O(N)</li>
  </ul>

  <p>Из одних и тех же элементов можно составить разные деревья. Зависит от того в каком порядке их добавляем. Обычно корнем дерева становится элемент, который добавляют первым. Любое поддерево можно обрабатывать как дерево, используя рекурсию.</p>

  <h4>Поиск в дереве элемента с ключом 4</h4>
  <p>Сначала смотрим на корень дерева. Сравниваем его с числом, которое нужно найти. Если оно совпало, то это будет ответ. Если 4 меньше чем корень, то переходим в левого потомка и дальше ищем там. Если больше, то переходим в правого потомка.</p>

  <h4>Добавление элемента с ключом 9</h4>
  <p>Добавление элемента очень похоже на поиск. Сначала посмотрим есть ли такой элемент в дереве. Начнем опять с корня. Видим, что 9 больше чем корень и идем вправо. Сравниваем и видим что 9 меньше правого сына. Идем в лево. А там пусто. Добавим сюда 9.</p>

  <h4>Удаление элемента с ключом 4</h4>
  <p>Удаление из дерева это одна из самых сложных операций практически в любой структуре. Сначала найдем элемент с ключом 4.</p>
  <p>Если это лист, то есть у него нет своих потомков,то в его родителе удалим ссылку на него.</p>
  <p>Если у удаляемого элемента есть только один потомок,то у его родителя меняем указатель с элемента 4 на его единственного сына.</p>   
  <p>Если у удаляемого элемента 2 ребенка, то есть несколько способов. Рассмотрим один из них. Заменим элемент 4 на первое число, которое больше его. Для этого идем в правое поддерево и ищем в нем самый левый элемент. Там найдем из всех больших чисел самое маленькое число. Если это лист, то есть у него нет потомком, то поставим его на место удаляемого элемента. Если у него один правый сын, то самое маленькое число ставим на мето удаляемого, а правого сына на его место.</p>
  <p>Второй способ это найти самое большое число из левого поддерева и поставить его на место удаляемого элемента</p>

  <details>
    <summary>Реализация поиска</summary>
<pre>function find(memstruct, root, x) {
  let key = memstruct[0][root][0];
  if (x === key) {
    return root;
  } else if (x &lt; key) {
    let left = memstruct[0][root][1];
    // нет такого узла
    if (left === -1) {
      return -1;
    } else {
      // рекурсивно ищем в левом поддереве
      return find(memstruct, left, x);
    }
  } else if (x &gt; key) {
    let right = memstruct[0][root][2];
    // нет такого узла
    if (right === -1) {
      return -1;
    } else {
      // рекурсивно ищем в правом поддереве
      return find(memstruct, right, x);      
    }
  }
}</pre>
  </details>

  <details>
    <summary>Реализация добавления</summary>
    <p>Сначала ищем этот узел. Если его нет, то ставим туда новый элемент.</p>
<pre>function createNode(memstruct, key) {
  let index = newnode(memstruct);
  memstruct[0][index][0] = key;
  memstruct[0][index][1] = -1;
  memstruct[0][index][2] = -1;
  return index;
}

function add(memstruct, root, x) {
  let key = memstruct[0][root][0];
  if (x &lt; key) {
    let left = memstruct[0][root][1];
    // если нет такого узла
    if (left === -1) {
      // создаем здесь новый узел
      memstruct[0][root][1] = createNode(memstruct, x);
    } else {
      // если есть такой узел
      // рекурсивно ищем в левом поддереве
      return add(memstruct, left, x);
    }
  } else if (x &gt; key) {
    let right = memstruct[0][root][2];
    // если нет такого узла
    if (right === -1) {
      // создаем здесь новый узел
      memstruct[0][root][2] = createNode(memstruct, x);
    } else {
      // если есть такой узел
      // рекурсивно ищем в правом поддереве
      return add(memstruct, right, x);      
    }
  }
}</pre>
  </details>

  <h4>Представление дерева в программе</h4>
  <p>Можно взять массив из трех элементов. Первый элемент key это корень дерева. Второй элемент left это массив из трех элементов, представляющий левое поддерево. Третий элемент right это массив из трех элементов, представляющий правое поддерево.</p>
  <code>[key, left, right]</code>
  <code>[5, [2, null, [3, null, null], [7, null, [8, null, null]]]</code>
</article>


<!-- Обход деревьев -->
<article class="article">
  <div class="anchor" id="l8-3"></div>
  <h2>Обход деревьев</h2>

  <p>Поиск элемента в хэш-таблице был за O(1), а в дереве в лучшем случае за O(logN), в худшем - O(N). Но в дереве элементы упорядочены, а в множестве - нет. Поэтому мы можем получить отсортированную последовательность всех узлов дерева. Для этого надо сделать рекурсивный обход дерева. Сначала идем влево до крайнего элемента, потом печатаем себя, потом заходим вправо и все повторяется.</p>
  <p>Если при добавлении элементов с дерево, одно поддерево становится значительно больше другого, то можно применить балансировку. То есть перестроить дерево выбрав в качестве корня другой элемент.</p>

  <h4>Не бинарные деревья</h4>
  <ul>
    <li>У узлов дерева может быть и больше двух сыновей, тогда их нужно хранить списком</li>
    <li>Примеры: дерево каталогов и файлов, DOM-дерево, дерево классов в программе</li>
    <li>Обходим так же как бинарное, просто запуская рекурсивную функцию для всех детей</li>
  </ul>

  <h4>Сериализация дерева Хаффмана</h4>
  <ul>
    <li>Алгоритм Хаффмана позволяет сопоставить более часто встречающимся символам более короткий код</li>
    <li>Каждый раз берем два самых редко встречающихся символа и объединяем их в один узел</li>
    <li>Строим бинарное дерево, кладем буквы в листья. Переход в левого сына кодируется числом 0, в правого 1, а код символа - это все ребра на пути от корня до листа</li>
    <li>В примере буква "а" встречается 4 раза, буква "б" - 3 раза, а "в" и "г" по одному разу</li>
  </ul>
</article>


<!-- Разбор ДЗ по лекции 5 и 6 -->
<article class="article">
  <div class="anchor" id="l56"></div>
  <h2>Разбор ДЗ по лекции 5 и 6</h2>
</article>


<!-- Занятие 5. Счет в гипершашках -->
<article class="article">
  <div class="anchor" id="l5-1"></div>
  <h2>Занятие 5. Счет в гипершашках</h2>

  <p>В каждой игре в гипершашки участвует три игрока. По ходу игры каждый из игроков набирает некоторое положительное целое число баллов. Если после окончания игры первый игрок набрал a баллов, второй - b, а третий - c, то говорят, что игра закончилась со счетом a:b:c.</p>
  <p>Андрей знает, что правила игры гипершашек устроены таким образом, что в результате игры баллы любых двух игроков различаются не более чем в k раз.</p>
  <p>После матча Андрей показывает его результат, размещая три карточки с очками игроков на специальное табло. Для этого у него есть набор из n карточек, на которых написаны числа x1, x2, ... , xn. Числа на карточках могут повторяться. Чтобы выяснить, насколько он готов к чемпионату, Андрей хочет понять, сколько различных вариантов счета он сможет показать на табло, используя имеющиеся карточки</p>
  <code>3 &lt;= n &lt;= 100000, 1 &lt;= k &lt;= 10^9, 1 &lt;= xi &lt;= 10^9</code>

  <details>
    <summary>Решение</summary>
    <p>Сначала посчитаем для каждой карточки сколько раз она встречается. Создадим словарь, в котором для каждой карточки сохраним сколько раз она встречалась.</p>

    <h4>Пример</h4>
    <code>1,1,2,3,4 // {1:2, 2:1, 3:2}</code>
    <code>k = 2 // баллы могут отличаться не более чем в 2 раза</code>
    <p>Тогда мы получим 6 вариантов счета, который можно показать с помощью этих карточек:</p>
    <code>1:1:2, 1:2:1, 2:1:1, 2:3:3, 3:2:3, 3:3:2</code>

    <p>Нужно упорядочить ключи в этом словаре. Теперь применим метод двух указателей. Левый указатель показывает на самый левый ключ, а правый двигается от него вправо до упора. До упора - это значит до того числа, которое больше числа под левым указателем в k раз. Потом сдвигаем левый указатель на один вправо.</p>
    <p>Длина отрезка R-L это количество ключей, которые можно использовать.</p>
  </details>
</article>


<!-- Занятие 5. Робот -->
<article class="article">
  <div class="anchor" id="l5-2"></div>
  <h2>Занятие 5. Робот</h2>

  <p>В процессе сборки двигателя могут встречаться операции 26 типов, которые обозначаются строчными буквами латинского алфавита. Процесс сборки состоит из N операций.</p>
  <p>Предполагается использовать робота один раз для выполнения части подряд идущих операций из процесса сборки.</p>
  <p>Память робота состоит из K ячеек, каждая из которых содержит одну операцию. Операции выполняются последовательно, начиная с первой, в том порядке, в котором они расположены в памяти. Выполнив последнюю из них, робот продолжает работу с первой. Робота можно остановить после любой операции. Использование робота экономически целесообразно, если он выполнит хотя бы K + 1 операцию.</p>
  <p>Требуется написать программу, которая по заданному процессу сборки определит количество экономически целесообразных способов использования робота</p>
  <p>N &lt;= 200000</p>
</article>


<!-- Занятие 5. Треугольники -->
<article class="article">
  <div class="anchor" id="l5-3"></div>
  <h2>Занятие 5. Треугольники</h2>

  <p>Петя достаточно давно занимается в математическом кружке, поэтому он уже успел узнать не только правила выполнения простейших операций, но и такое достаточно сложное понятие как симметрия. Для того, чтобы получше изучить симметрию, Петя решил начать с наиболее простых геометрических фигур - треугольников. Он скоро понял, что осевой симметрией обладают так называемые равнобедренные треугольники. Поэтому теперь Петя ищет везде такие треугольники.</p>
  <p>Напомним, что треугольник называется равнобедренным, если его площадь положительна, и у него есть хотя бы две равные стороны.</p>
  <p>Недавно Петя, зайдя в класс, увидел, что на доске нарисовано n точек. Разумеется, он сразу задумался, сколько существует троек из этих точек, которые являются вершинами равнобедренных треугольников.</p>
  <p>Требуется написать программу, решающую указанную задачу</p>
  <p>3 &lt;= n &lt;= 1500</p>

  <details>
    <summary>Решение за O(N^2)</summary>
    <p>Для каждой точки переберем расстояния для других точек чтобы определить, сколько равнобедренных треугольников можно построить из этой вершины.</p>
  </details>
</article>


<!-- Занятие 6. Субботник -->
<article class="article">
  <div class="anchor" id="l6-1"></div>
  <h2>Занятие 6. Субботник</h2>

  <p>В классе учатся N человек. Классный руководитель получил указание направить на субботник R бригад по C человек в каждой.</p>
  <p>Все бригады на субботнике будут заниматься переноской бревен. Каждое бревно одновременно несут все члены одной бригады. При этом бревно нести тем удобнее, чем менее различается рост членов этой бригады.</p>
  <p>Числом неудобства бригады будем называть разность между ростом самого высокого и низкого членов этой бригады (если в бригаде только один человек, то эта разница равна 0). Классный руководитель решил сформировать бригады так, чтобы максимальное из чисел неудобства сформированных бригад было минимально. Помогите ему в этом.</p>
  <p>1 &lt;= R*C &lt;= N &lt;= 100000</p>
</article>


<!-- Занятие 6. Медиана объединения -->
<article class="article">
  <div class="anchor" id="l6-2"></div>
  <h2>Занятие 6. Медиана объединения</h2>

  <p>Дано N упорядоченных по неубыванию последовательностей целых чисел (т.е. каждый следующий элемент больше либо равен предыдущему), в каждой из последовательностей ровно L элементов. Для каждых двух последовательностей выполняют следующую операцию: объединяют их элементы (в объединенной последовательности каждое число будет идти столько раз, сколько раз оно встречалось суммарно в последовательностях), упорядочивают их по неубыванию и смотрят, какой элемент в этой последовательности из 2L элементом окажется на месте номер L (этот элемент называют левой медианой).</p>
  <p>Напишите программу, которая для каждой пары последовательностей выведет левую медиану их объединения.</p>
  <p>2 &lt;= N &lt;= 200, 1 &lt;= L &lt;= 50000</p>
</article>


<!-- Разбор ДЗ по лекции 7 и 8 -->
<article class="article">
  <div class="anchor" id="l78"></div>
  <h2>Разбор ДЗ по лекции 7 и 8</h2>
</article>


<!-- Занятие 7. Реклама -->
<article class="article">
  <div class="anchor" id="l7-1"></div>
  <h2>Занятие 7. Реклама</h2>

  <p>Фирма NNN решила транслировать свой рекламный ролик в супермаркете XXX. Однако денег, запланированных на рекламную компанию, хватило лишь на две трансляции ролика в течение одного рабочего дня.</p>
  <p>Фирма NNN собрала информацию о времени прихода и времени ухода каждого покупателя в некоторый день. Менеджер по рекламе предположил, что и на следующий день покупатели будут приходить и уходить ровно в те же моменты времени.</p>
  <p>Помогите ему определить моменты времени, когда нужно включить трансляцию рекламных роликов, чтобы как можно большее количество покупателей прослушало ролик от начала до конца хотя бы один раз. Ролик длится ровно 5 единиц времени. Трансляции роликов не должны пересекаться, то есть начало второй трансляции должно быть хотя бы на 5 единиц времени позже, чем начало первой.</p>
  <p>1 &lt;= n &lt;= 2000</p>

  <details>
    <summary>Решение</summary>
    <p>Ролики можно включать в 2 момента - когда человек только пришел или за 5 минут до ухода. На временной шкале, где можно расположить длительности времени всех покупателей, схлопнем длительность ролика до одной точки, чтобы он не растягивался на 5 минут и будем также рассматривать только два события - когда человек только пришел и за 5 минут до ухода.</p>
    <p>Всех людей которые пробыли в магазине меньше 5 минут надо вычеркнуть - у них нет шанса прослушать ролик целиком. Теперь двигаясь во времени слева направо во все моменты когда происходит событие будем включатьролик и считать сколько человек его просмотрят.</p>
  </details>
</article>


<!-- Занятие 7. Охрана -->
<article class="article">
  <div class="anchor" id="l7-2"></div>
  <h2>Занятие 7. Охрана</h2>

  <p>На секретной военной базе работает N охранников. Сутки поделены на 10000 равных промежутков времени, и исзвествно когда каждый охранник приходит на дежурство и уходит с него. Например, если охранник приходит в 5, а уходит в 8, то значит, что он был в 6,7,8 промежуток (а в 5-й нет)</p>
  <p>Укажите, верно ли что для данного набора охранников, объект охраняется в любой момент времени хотя бы одним охранником и удаление любого из них проводит к появлению промежутка времени, когда объект не охраняется.</p>
  <p>N &lt;= 10000, K &lt;= 100</p>
</article>


<!-- Занятие 7. Автобусы -->
<article class="article">
  <div class="anchor" id="l7-3"></div>
  <h2>Занятие 7. Автобусы</h2>

  <p>Автобусная сеть страны охватывает N городов, занумерованных целыми числами от 1 до N.</p>
  <p>Идеальное расписание содержит M ежедневных рейсов, i-й рейс начинается в городе F[i[ в момент времени X[i] и заканчивается в некотором другом городе G[i] в момент времени Y[i]. Продолжительность каждого рейса ненулевая и строго меньше 24 часов. Рейс i выполняется одним из автобусов, находящихся в момент времени X[i] в городе F[i].</p>
  <p>Предполагается, что расписание будет действовать неограниченное время, поэтому может оказаться так, что его невозможно обслужить никаким конечным числом автобусов.</p>
  <p>Определите наименьшее количество новых автобусов, достаточное для обеспечения движения по расписанию в течение неограниченного периода времени.</p>
  <p>N, M &lt;= 100000</p>

  <details>
    <summary>Решение</summary>
    <p>Для каждого города посчитаем баланс автобусов приезжающих и уезжающих в течение суток. Если в город приезжает 10 автобусов, а уезжает 9, то в этом городе за бесконечное время скопится бесконечное количество автобусов. И никаким количеством автобусов мы обслужить это расписание не сможем.</p>
    <p>Создаем переменную balance для каждого города. Если автобус приезжает то balance увеличиваем на 1, если уезжает - уменьшаем на 1. Для всех городов баланс должен быть нулевой - сколько приехало, столько и уехало.</p>
    <p>Условие при котором невозможно обслужить расписание мы определили. Теперь необходимо посчитать количество автобусов. Для каждого города заведем количество автобусов, которые в нем находятся на определенный момент. В начале суток в каждом городе находится 0 автобусов. Событие происходит в момент когда автобус приехал или автобус уехал из города. Каждый рейс порождает два события - откуда и во сколько автобус уехал и куда и во сколько автобус приехал.</p>
    <p>Если в городе i происходит событие автобус приехал, то countbus[i] увеличиваем на 1. Если в городе i происходит событие автобус уехал, а в городе было 0 автобусов, то ничего не делаем. Значит там автобус заранее стоял специально и это его первый рейс. Если же countbus[i] был больше нуля, то вычитаем 1.</p>
    <p>Для чего мы делаем такие странные вещи? Для того чтобы посмотреть что будет в полночь в первые сутки. И уже никогда countbus не будет равен нулю во всех городах. В полночь смотрим сколько автобусов в каждом городе. И некоторое количество автобусов находятся в пути в полночь. Для этого посчитаем количество рейсов у которых время выезда из города больше чем время приезда.</p>
    <p>Наконец, мы складываем количество автобусов, которые находятся в городах и количество автобусов, которые находятся в рейсе и получаем ответ на нашу задачу.</p>
  </details>
</article>


<!-- Занятие 7. НГУ-стройка -->
<article class="article">
  <div class="anchor" id="l7-4"></div>
  <h2>Занятие 7. НГУ-стройка</h2>

  <p>Требуется написать программу, которая позволяет выбрать минимальное число блоков, которые будучи установленными на указанных подрядчиками местах, образуют перекрытие, либо определить, что это сделать невозможно. Высота, на которой образуется перекрытие, не имеет значения.</p>
  <p>N &lt;= 100000</p>

  <details>
    <summary>Решение</summary>
    <p>Сведем задачу к двумерной. У нас есть три измерения x,y,z. Мы можем сократить до x,z. В этом случае считаем что к нам приходят не кубики, а прямоугольники. По условиям задачи они не пересекаются. Эта задача стала аналогичной задаче про парковку.</p>
    <p>Каждый прямоугольник породит два события - что он начался вдоль оси z и что он закончился. Нужно определить было ли хоть раз что слой по оси x полностью закрылся. Если на одной высоте есть прямоугольники которые там заканчиваются и начинаются, то пусть сначала прямоугольник заканчивается, а потом начинается другой прямоугольник.</p>
    <p>Поддерживаем суммарную длину sum прямоугольников вдоль оси x. Когда прямоугольник приходит суммарная длина увеличивается на его длину, когда он уходит - уменьшается. И при каждом событии сравниваем суммарную длину с шириной нашего стакана. И если заполнится полностью то ответ - да, это возможно.</p>
    <p>Чтобы посчитать число блоков, заведем счетчик, который будет увеличиваться когда блок начался и уменьшаться когда блок закончился. И каждый раз когда полностью покрыт весь стакан, мы сравнивае количество блоков и выбираем минимальное.</p>
    <p>Теперь осталось определить номера этих блоков. Сделаем два прохода. За первый проход посчитаем минимальное количество прямоугольников которые образуют целый слой. А на втором проходе смотрели где появляются эти два минимальных блока и выводили их номера.</p>
    <p>Как только мы решили все предыдущие задачи на плоскости, переведем нашу задачу обратно в трехмерную. Вместо длины будем считать площадь. В остальном задача такая же.</p>
  </details>
</article>




