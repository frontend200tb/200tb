<h1>Тренировки по алгоритмам 5.0 (2024.03.29) от Яндекс (Михаил Густокашин)</h1>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>
  <ol>
    <li>
      <a href="#l1">Лекция №1. Сложность, тестирование, особые случаи</a>
      <ol>
        <li>
          <a href="#l1-tema-1">Тема 1. Сложность алгоритмов</a>
          <ul>
            <li><a href="#l1-task-1">Задача 1. Самый частый символ</a></li>
          </ul>
        </li>
        <li>
          <a href="#l1-tema-2">Тема 2. Особые случаи</a>
          <ul>
            <li><a href="#l1-task-2">Задача 2. Сумма последовательности</a></li>
            <li><a href="#l1-task-3">Задача 3. Максимум последовательности</a></li>
          </ul>
        </li>
        <li>
          <a href="#l1-tema-3">Тема 3. Тестирование</a>
        </li>          
      </ol>
    </li>
    <li>
      <a href="#l2">Лекция №2. Линейный поиск</a>
      <ol>
        <li>
          <a href="#l2-tema-1">Тема 1. Классические задачи линейного поиска</a>
          <ul>
            <li><a href="#l2-task-1">Задача 1. Найти первое вхождение</a></li>
            <li><a href="#l2-task-2">Задача 2. Найти последнее вхождение</a></li>
            <li><a href="#l2-task-3">Задача 3. Найти максимальное число</a></li>
            <li><a href="#l2-task-4">Задача 4. Найти максимальное и второе по величине число</a></li>
            <li><a href="#l2-task-5">Задача 5. Найти минимальное четное число</a></li>
          </ul>          
        </li>
        <li>
          <a href="#l2-tema-2">Тема 2. Два прохода</a>
          <ul>
            <li><a href="#l2-task-6">Задача 6. Самые короткие слова</a></li>
            <li><a href="#l2-task-7">Задача 7. Сколько воды осталось на острове после сильного дождя</a></li>
          </ul>
        </li>          
        <li><a href="#l2-tema-3">Тема 3. Задача с собеседования. RLE сжатие строки</a> </li>
      </ol>
    </li>
  </ol>
</article>


<!-- Лекция №1. Сложность, тестирование, особые случаи -->
<article class="article">
  <div class="anchor" id="l1"></div>
  <h2>Лекция №1. Сложность, тестирование, особые случаи</h2>

  <p>Здравствуйте, меня зовут Михаил Густокашин. Я преподаю алгоритмы и структуры данных на факультете компьютерных наук в высшей школе экономики. А сейчас у нас тренировки по алгоритмам уже пятый сезон. И сейчас я расскажу что нас ждет и как все будет устроено.</p>

  <p>Чего хотят на алгоритмическом собеседовании (и в реальной жизни)?</p>
  <ol>
    <li>Умения писать работаюдий код</li>
    <li>Умения тестировать свой код</li>
    <li>Умения писать эффективный код</li>
  </ol>
  
  <h4>Как этого достичь?</h4>
  <ol>
    <li>Написать 10 000 строк работающего, эффективного и протестированного кода</li>
    <li>Кроме тренировок можно найти задачи на coderun.yandex.ru, leetcode.com, codeforces.com и т.п.</li>
    <li>Наш курс поможет правильно подходить к решению задач</li>
  </ol>

  <h4>План занятий</h4>
  <ol>
    <li>Сложность, тестирование, особые случаи</li>
    <li>Ллинейный поиск</li>
    <li>Множества и словари</li>
    <li>Бинарный поиск</li>
  </ol>

  <h4>Рейтинг</h4>
  <ol>
    <li>К каждому занчтию - домашнее задание с 10 задачами и дедлайном до разбора</li>
    <li>На разборе смотрим решение некоторых задач, в том числе с кодом</li>
    <li>Кто решил больше задач - тот и молодец, штраф не учитывается</li>
  </ol>

  <h4>Бонусы</h4>
  <ol>
    <li>Знания и умения!</li>
    <li>Собеседование по алгоритмам в прямом эфире + его разбор (дважды)</li>
    <li>Персональные тренировки для топ-200 участников</li>
    <li>Пробные алгоритмические собеседования для топ-200 участников с зачетом при отборе</li>
  </ol>

  <h4>Содержание сегодняшней лекции</h4>
  <ol>
    <li>Сложность алгоритмов</li>
    <li>Особые случаи</li>
    <li>Тестирование</li>
  </ol>
</article>


<!-- Тема 1. Сложность алгоритмов -->
<article class="article">
  <div class="anchor" id="l1-tema-1"></div>
  <h3>Тема 1. Сложность алгоритмов</h3>

  <h4>RAM машина (упрощенно)</h4>
  <ol>
    <li>Чтение/запись/инициализация ячейки памяти стоит одну операцию</li>
    <li>Можно выполнять арифметические и логические операции с одной ячейкой памяти, а также переходы</li>
    <li>Похоже на компьютер</li>
  </ol>
  
  <h4>Сложность алгоритма</h4>
  <ol>
    <li>Сложность алгоритма - порядок количества действий в зависимости от размера входных данных</li>
    <li>Чато применяют О-нотацию - нестрогая оценка сверху</li>
    <li>Суть: хотим понимать во сколько раз замедлится наша программа при увеличении размера входных данных</li>
  </ol>

  <h4>Примеры расчета сложности</h4>
  <ol>
    <li>У нас есть реализация алгоритма в виде программы. При размере входных данных N время работы программы было измерено и составило T. Данные увеличились в 10 раз</li>
    <li>Если сложность O(N) - замедление в 10 раз, O(NlogN) - примерно в 30 раз, O(N^2) - в 100 раз, O(N^3) - в 1000 раз, O(1) - нет замедления.</li>
  </ol>

  <h4>Замечание про константу</h4>
  <ul>
    <li>То во сколько раз замедлится программа не зависит от константы (количества элементарных операций, не зависящих от размера входных данных)</li>
  </ul>

  <p>Может быть разное замедление в разных частях программы. Мы должны учитывать самый худший случай.</p>
</article>


<!-- Задача 1. Самый частый символ -->
<article class="article">
  <div class="anchor" id="l1-task-1"></div>
  <h3>Задача 1. Самый частый символ</h3>
  <p>Дана строка (в кодировке UTF-8), найти самый часто встречающийся в ней символ. Если таких символов несколько - найти любой.</p>

  <p>Решение 1. O(n^2)</p>
  <p>Переберем все позиции и для каждой позиции в строке еще раз переберем все позиции и в случае совпадения прибавим к счетчику единицу. Найдем максимальное значение счетчика.</p>

  <p>Решение 2. O(n*k)</p>
  <p>Переберем все символы, встречающиеся в строке, а затем переберем все позиции и в случае совпадения прибавим к счетчику единицу. Найдем максимальное значение счетчика.</p>

  <p>Решение 3. O(n+k) = O(n)</p>
  <p>Заведем словарь, где ключом является символ, а значением - сколько раз он встретился. Если символ встретился впервые - создаем элемент словаря с ключом, совпадающим с этим символом и значением ноль. Прибавляем к элементу словаря с ключом, совпадающим с этим символом, единицу</p>
</article>


<!-- Тема 2. Особые случаи -->
<article class="article">
  <div class="anchor" id="l1-tema-2"></div>
  <h3>Тема 2. Особые случаи</h3>
</article>


<!-- Задача 2. Сумма последовательности -->
<article class="article">
  <div class="anchor" id="l1-task-2"></div>
  <h3>Задача 2. Сумма последовательности</h3>

  <p>Дан массив чисел. Найти их сумму.</p>

  <details>
    <summary>Решение</summary>
  <p>Мы помним, что пустые строки, последовательности, массивы это страшная вещь и мы стараемся их сразу обработать чтобы ничего не сломалось. Пишем, если длина массива 0 то сразу возвращаем 0, иначе просуммируем все числа.</p>
<pre>function sum(nums) {
  if (nums.length === 0) {
    return 0;
  } else {
    let result = nums[0];
    for (let i = 1; i &lt; nums.length; i++) {
      result += nums[i];
    }
    return result;
  }
}</pre>

  <p>Но в данном случае это уже было лишнее. Потому что if можно убрать и сразу инициализировать результат нулем.</p>

<pre>function sum(nums) {
  let result = 0;
  for (let i = 0; i &lt; nums.length; i++) {
    result += nums[i];
  }
  return result;
}</pre>
  </details>
</article>


<!-- Задача 3. Максимум последовательности -->
<article class="article">
  <div class="anchor" id="l1-task-3"></div>
  <h3>Задача 3. Максимум последовательности</h3>
  <p>Найти максимальный элемент в массиве.</p>

  <p>Решение.</p>
  <p>Сначала нужно в ответ положить нулевой элемент массива. Потом пройтись по всем элементам массива и сравнивая их с ответом, присвоивать ответу большее значение. В конце надо вернуть ответ.</p>

  <details>
    <summary>Решение</summary>
    <p>Мы помним, что для нахождения суммы последовательности мы сначала в результат записывали 0, а потом вычисляли сумму.</p>
<pre>function max(nums) {
  let result = 0;
  for (let i = 0; i &lt; nums.length; i++) {
    if (nums[i] &gt; result) {
      result = nums[i];
    }
  }
  return result;
}</pre>
    <p>Это будет работать, пока не возникнет ситуация, когда все числа будут отрицательные. Мы выведем 0, которого даже нет в последовательности. Поэтому обработаем этот случай, если последовательность пустая, то выведем, например, пустую строку.</p>
<pre>function max(nums) {
  if (nums.length === 0) {
    return '';
  } else {
    let result = nums[0];
    for (let i = 1; i &lt; nums.length; i++) {
      if (nums[i] &gt; result) {
        result = nums[i];
      }
    }
    return result;
  }
}</pre>
  </details>
</article>


<!-- Тема 3. Тестирование -->
<article class="article">
  <div class="anchor" id="l1-tema-3"></div>
  <h3>Тема 3. Тестирование</h3>

  <h4>Что нужно тестировать?</h4>
  <ol>
    <li>Тесты из условия (если есть)</li>
    <li>Общие случаи</li>
    <li>Особые случаи</li>
  </ol>
</article>


<!-- Лекция №2. Линейный поиск -->
<article class="article">
  <div class="anchor" id="l2"></div>
  <h2>Лекция №2. Линейный поиск</h2>

  <h3>Задача 3. Второй по величине элемент</h3>
  <p>Найти второе по величине число (такое, которое будет максимальным, если вычеркнуть из последовательности одно максимальное число)</p>

  <p>Решение.</p>
  <p>Заведем две переменные max для максимального числа и max2 для второго по величине числа. Сравним первые два числа и запишем одно в max, другое в max2. Проходим по всем числам и сначала сравниваем число now с первым максимумом. Если now больше max, то max записываем в max2, а now записываем в max, при этом предыдущее значение max2 теряется. Если now меньше max, то сравниваем now со вторым максимумом. Если now больше max2, то записываем now в max2, при этом предыдущее значение max2 также теряется.</p>

  <h3>Задача 4. Минимальное четное число</h3>
  <p>Найти минимальное четное число в последовательности, вывести -1, если ни одного четного нет.</p>

  <p>Решение.</p>
  <p>Сначала положим в ответ -1. Если четного числа не будет, то вернется -1, как и нужно из условия задачи. Проходим по всем числам и сначала проверяем что число четное (остаток от деления на 2 равен 0) и в ответе лежит -1 или это число меньше чем в ответе. Тогда присваиваем ответу новое число.</p>

  <h3>Задача 5. Поиск минимума и максимума одновременно</h3>
  <p>Найти одновременно минимум и максимум, используя как можно меньше сравнений.</p>

  <p>Решение 1.</p>
  <p>Два раза проходим по всем числам. Первый раз ищем минимум. Второй раз ищем максимум. Это займет 2n операций.</p>

  <p>Решение 2.</p>
  <p>Разобьем все числа по парам. Сравнивая числа в каждой паре выбираем меньшее и большее из двух чисел. Это можно сделать за одно сравнение. Эта операция займет n/2 сравнений. Теперь минимум будем искать среди минимальных элементов, а максимум среди ма. Это два линейных поиска по n/2 элементам. Таким образом для решения мы затратим 3n/2 операций, что на n/2 операций меньше чем в первом решении.</p>

  <h3>Задача 5. Барьерный элемент</h3>
  <p>Найти индекс вхождения числа x в последовательность или вывести n (длину последовательности), если не нашлось</p>

  <p>Решение</p>
  <p>Записываем в конец последовательности элемент x, который надо найти. Проходим по массиву и если элемент встретится, то выводим его индекс. Если изначално элемента в массиве не было, то вернется индекс последнего элемента (равный длине начального массива), в который мы положили x. Это идея барьерного элемента, когда мы заранее задаем некий барьер и обходимся обычным линейным поиском без каких либо булевых переменных и лишних проверок. Мы приделали барьер на который линейный поиск напорится и выведет нужное число.</p>

  <h3>Задача 6. Соседние элементы в двумерных массивах</h3>
  <p>Найти соседние элементы в двумерном массиве из n на n элементов</p>

  <p>Решение.</p>
  <p>Будем использовать массив сдвигов. Для крайнев случаев, когда клетка прижата к краю или в углу мы можем выйти за пределы массива. А чтобы не выйти за пределы массива будем использовать барьерный метод. Создаем новый двумерный массив, который на 2 больше по каждому измерению и заполняем его рамочку значением барьера, например -1. А исходный массив будет внутри нового массива с барьером. Теперь когда мы проверяем крайние клетки, вместо того чтобы смотреть существует ли массив в соседней клетке, мы можем проверить на наличие в клетке барьерного чилса. И если в клетке барьерное число, то мы ее не анализируем. Например, надо найти клетку, которая больше всех своих соседей. Тогда клетки с -1 не участвуют в сравнениях.</p>

  <h3>Задача 7. Сапер</h3>
  <p>Даны координаты мин на поле, вывести поле для игры в сапер. Мины пометить звездочкой, а в поле без мин вывести число, равное количеству мин в соседних 8 клетках.</p>

  <p>Решение.</p>

  <h3>Задача 8. pitcraft</h3>
  <p>Остров игрока представляет собой набор столбцов различной высоты, состоящих из блоков камня и окруженный морем. Над островом прошел сильный дождь, который заполнил водой все низины. Определите, сколько блоков воды осталось после дождя в низинах на острове.</p>

  <p>Решение.</p>
  <p>Если вершина одна, то выбираем вершину. Слева от нее вода будет стекать в море, заполняя собой все впадины. И справа от нее вода будет стекать в море заполняя собой все впадины. Если вершин несколько, то между ними останется вода во впадинах, а слева и справа вода будет стекать в море.</p>

  <h3>Задача 9. RLE</h3>
  <p>Дана строка (возможно, пустая), состоящая из букв A-Z. Нужно сжать строку. Если буква встречается более одного раза подряд, то рядом с буквой писать число сколько раз она встречается подряд. Написать функцию RLE, которая на выходе даст строку вида - буква и цифра, означающая сколько букв подряд идет, затем следующая буква и т.д.</p>
  <p>Пример, на входе AAAABBBCCXYZDDDD. на выходе A4B3C2XYZD4</p>

  <p>Решение.</p>

  <h3>Задача 10. Газон</h3>
  <p>Трава пострижена в прямоугольнике с углами (x1, y1) и (x2, y2). В каждой целой точке растет пучок травы. Круговой дождеватель установлен в (x3, y3), радиус r. Сколько пучков пострижено и полито?</p>

  <p>Решение 1. Неэффективное. Перебрать все пучки травы</p>
  <p>Постриженые пучки травы находятся в прямоугольнике, а политые в круге. Надо найти пересечение этих фигур. И в этом пересечении будут пучки, которые и пострижены и политы. Проверим что точка лежит внутри прямоугольника, то есть х координата лежит между x1 и x2, а y координата лежит между y1 и y2. Проверим что точка лежит внутри круга по теореме Пифагора. (x - x3)^2 + (y - y3)^2 должно быть меньше или равно r^2.</p>

  <p>Решение 2. Чуть лучше. Перебрать пучки травы только внутри прямоугольника</p>
  <p>Мы будем знать что наши пучки все пострижены и будем проверять только то что они политы или нет. В худшем случае, когда весь участок пострижен, это не даст нам ускорения. Но в среднем случае даст.</p>

  <p>Решение 3. Правильное.</p>
  <p>Если прямоуголькик и круг не пересакаются, то возвращаем 0. Если пересекаются, то находим максимум левого x прямоуголькика и левого x круга, затем находим минимум между правого x прямоугольника и правого x круга. Между этими значениями будут x координаты нужных пучков. Находим минимум верхнего y прямоугольника и верхнего y круга, затем находим максимум нижнего y прямоугольника и нижнего y круга. Между этими значениями будут y координаты нужных пучков.</p>

  <h3>Задача 11. Покраска деревьев</h3>
  <p>Вася красит деревья с номерами [P - V, P + V]. Маша красит деревья с номерами [M - Q, M + Q]. Сколько деревьев они покрасят?</p>

  <p>Решение.</p>
  <p>Ключевые идеи.</p>
  <ol>
    <li>Заводить множества или списки нельзя - большие входные данные</li>
    <li>Если отрезки пересекаются - берем длину от максимума из левых границ до максимума из правых границ</li>
    <li>Если отрезки не пересекаются - берем сумму длин отрезков</li>
    <li>Как проверить пересечение?</li>
  </ol>

  <h3>Задача 12. Футбольный комментатор</h3>
  <p>Известен счет в домашнем и гостевом матче. В случае равного голов у команд побеждает та, у которой больше голов в гостях. Сколько голов надо забить первой команде во втором матче чтобы победить?</p>
</article>





