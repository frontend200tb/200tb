<h1>Яндекс Frontend Weekend Offer 18-19 мая 2024</h1>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>
  <p><a href="#links">links</a></p>
  <ol>
    <li>
      Отборочный контест
      <ol>
        <li><a href="#b">B. Сборочная линия</a></li>
      </ol>
    </li>
    <li>
      Секция 1. Платформа
      <ol>
        <li><a href="#task1">Задача 1. Убрать falsy значения</a></li>
        <li><a href="#task2">Задача 2. Три асинхронные функции выполнить по порядку</a></li>
      </ol>
    </li>
    <li>
      Секция 2. Технические навыки
      <ol>
        <li><a href="#task3">Задача 3. Эффект постепенного вывода текста</a></li>
        <li><a href="#task4">Задача 4. Калькулятор выражений в обратной польской нотации</a></li>
      </ol>
    </li>
  </ol>
</article>


<!-- links -->
<article class="article">
  <div class="anchor" id="b"></div>
  <h2>links</h2>

  <p><a href="https://habr.com/ru/articles/435084/">https://habr.com/ru/articles/435084/</a> Как работать с async/await в циклах JavaScript</p>
</article>


<!-- B. Сборочная линия -->
<article class="article">
  <div class="anchor" id="b"></div>
  <h2>B. Сборочная линия</h2>

  <p>Ограничение времени	10 секунд</p>
  <p>Ограничение памяти	1024.0 Мб</p>
  <p>Ввод	input.json</p>
  <p>Вывод	output.json</p>
  <p>Вы устроились на продвинутый сборочный цех айти-разнорабочим, чтобы стать помощником главного инженера.</p>
  <p>Задача цеха — автоматизированно выполнять предоставленные клиентами заказы по сборке.</p>
  <p>В цеху есть N линий сборки, работающих одновременно. Каждая линия сборки работает беспрерывно до тех пор, пока есть актуальные задачи на сегодня. Задачи по сборке цех принимает каждый день, но все задачи поступившие во время рабочего дня, откладываются на следующий. У задач может быть приоритетность, она учитывается при распределении задач на линиях сборки, задача с самым большим приоритетом — идет первой в работу (если есть 2 задачи с одинаковым приоритетом, будет выполнена сначала первая добавленная).</p>
  <p>Сейчас распределение заказов между линиями сборки выполняет планировщица Зинаида, непревзойденный мастер, но она скоро выходит на пенсию. Ваш новый начальник хочет чтобы завод продолжил работать также оптимально и понял, что это отличный момент для автоматизации. Звучит как идеальная задача для новичка. Вам поручили сделать новую программу для управления сборочными линиями, которая также будет ежедневно генерировать список отчетов о проделанной работе для каждой линии сборки.</p>

  <h4>Формат ввода</h4>
  <p>Необходимо реализовать класс AssemblyLineScheduler. Конструктор получает n (1 ≤ n ≤ 1024) — количество сборочных линий.</p>
  <p>Заказы добавляются методом appendJob. В рамках одного теста может быть не более 10^5 вызовов этого метода.</p>
  <p>У заказа есть уникальный строковый идентификатор id (1 ≤ id.length ≤ 10), приоритет priority (1 ≤ priority ≤ 10^9) и метод execute, запускающий его исполнение. Этот метод возвращает promise, который который будет resolved или rejected через время t мс (1 ≤ t ≤ 1024). Resolved, если контроль качества пройден и rejected в противном случае.</p>
  <p>В начале каждого дня вызывается метод start. Он должен исполнить пул заказов предыдущего дня и вернуть статистику использования каждой линии - сколько времени линия была загружена (в мс), какие задачи исполнила, сколько из них прошли контроль качества и сколько не прошли. В рамках одного теста метод start будет вызван p раз (1 ≤ p ≤ 10).</p>

  <details>
    <summary>Код условия</summary>
<pre>/**
* @typedef Job
* @property {string} id Уникальный идентификатор задачи, 1 ≤ id.length ≤ 10.
* @property {number} priority Приоритет задачи, 1 ≤ priority ≤ 10^9. Чем выше число, тем выше приоритет.
* @property {() => Promise<undefined>} execute Функция, выполняющая задание.
* Может быть resolved или rejected через длительное время.
*/

/**
* @typedef JobReport
* @property {number} qcPassed Общее количество выполненных успешно задач.
* @property {number} qcFailed Общее количество невыполненных задач.
* @property {string[]} jobIds Идентификаторы взятых в работу заказов.
* @property {number} timeSpent Количество проведённых в работе миллисекунд.
*/

class AssemblyLineScheduler {
  /**
  * @param {number} n Число сборочных линий, 1 ≤ n ≤ 1024
  */
  constructor(n) {}

  /**
  * Добавляет задачу в пул задач следующего дня.
  * В рамках одного теста может быть не более 10^5 вызовов этого метода.
  * @param {Job} job
  */
  appendJob(job) {}

  /**
  * Запускает обработку задач из пула и выдаёт список отчётов.
  * В рамках одного теста может быть не более 10 вызовов этого метода.
  * @returns {Promise<JobReport[]>}
  */
  start() {}
}

module.exports = { AssemblyLineScheduler };</pre>
  </details>

  <h4>Формат вывода</h4>
  <p>В результате решения могут быть обозначены следующие вердикты:</p>
  <ul>
    <li>OK — верный ответ.</li>
    <li>WrongAnswer (WA) — неправильный ответ.</li>
    <li>TimeLimitExceeded (TL) — превышено максимальное время выполнения проверки задачи.</li>
    <li>MemoryLimitExceeded (ML) — превышено ограничение на оперативную память.</li>
    <li>RuntimeError (RE) — программа завершила работу с ненулевым кодом возврата или тип возвращаемых данных не соответствует ожидаемому (проверьте, что результат start соответствует сигнатуре в jsdoc).</li>
    <li>Crash — запуск программы завершился ошибкой.</li>
  </ul>

  <h4>Пример</h4>

  <details>
    <summary>Ввод</summary>
<pre>{
  "linesCount": 3,
  "jobsBatches": [
    [
      {
        "id": "1",
        "priority": 344327634,
        "time": 69,
        "resolve": false,
        "async": false
      },
      {
        "id": "2",
        "priority": 439182113,
        "time": 68,
        "resolve": false,
        "async": false
      },
      {
        "id": "3",
        "priority": 267746535,
        "time": 83,
        "resolve": true,
        "async": false
      },
      {
        "id": "4",
        "priority": 412201989,
        "time": 61,
        "resolve": true,
        "async": false
      },
      {
        "id": "5",
        "priority": 211178799,
        "time": 94,
        "resolve": true,
        "async": false
      }
    ]
  ]
}</pre>
  </details>

  <details>
    <summary>Вывод</summary>
<pre>[
  [
    [0,1,["1"],69],
    [2,0,["4","3"],144],
    [1,1,["2","5"],162]
  ]
]</pre>
  </details>

  <h4>Примечания</h4>
  <p>Для измерения времени используйте Date.now() — в тестах будет использована библиотека @sinonjs/fake-timers, которая обеспечит измерение времени без погрешности. Версия Node.js, используемая при запуске кода, — 20.10.0.</p>

  <details>
    <summary>Примерный код теста:</summary>
<pre>const { AssemblyLineScheduler } = require('./solution');

(async () => {
  const generateJob = () =>
    function () {
      return new Promise((resolve, reject) => {
        setTimeout(() => {
          Math.random() &gt; 0.8 ? resolve() : reject();
        }, 1 + Math.floor(Math.random() * 100));
      });
    };

  const scheduler = new AssemblyLineScheduler(3);
  const reports = [];
  for (let day = 0; day &lt; 2; day += 1) {
    for (let i = 0; i &lt; 10; i += 1) {
      // это лишь примерный код, задачи могут также быть добавлены прямо во время работы (в процессе исполнения start асинхронно)
      scheduler.appendJob({
        id: String(i),
        priority: 10,
        execute: generateJob(),
      });

    }

    reports.push(await scheduler.start());
  }

  console.log(JSON.stringify(reports, null, 4));
})();</pre>
  </details>

  <details>
    <summary>Ответ</summary>
<pre>class AssemblyLineScheduler {

  constructor(n) {
    this.n = n;
    this.jobs = [];
  }

  appendJob(job) {
    this.jobs.push(job);
  }

  async start() {
    this.lines = [];
    console.log('Начало дня')
    this.jobs.sort((a,b) => a.priority - b.priority);

    for (let i = 0; i &lt; this.n; i++) {
      this.lines[i] = [0,0,[],0];
    }

    // выполнить одну задачу на одной линии
    async function runTask(task, line) {
      let time1 = Date.now();
      await task.execute().then(() => {
        console.log('fulfilled');
        line[0]++;
      }).catch(() => {
        console.log('rejected');
        line[1]++;
      }).finally(() => {
        line[2].push(task['id']);
        let time2 = Date.now();
        let time = time2 - time1;
        line[3] += time;
        console.log('Время выполнения', time)
      })
    }

    const runJobs = async () => {
      return Promise.allSettled(this.lines.map(async (line) => {
        if (this.jobs.length) {
          const task = this.jobs.pop();
          await runTask(task, line).then(async () => {
            while (this.jobs.length) {
              const task = this.jobs.pop();
              await runTask(task, line);
            }
          });
        }
      }))
    }

    await runJobs()
      for (let i = 0; i &lt; this.n; i++) {
        console.log(`Конец дня, выполнено на ${i} линии`, this.lines[i])
      }
    
    return this.lines;
  }
}

module.exports = { AssemblyLineScheduler };
</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Разобьем задачу на шаги</p>
    <ol>
      <li>
        <p>Для решения нужно написать class AssemblyLineScheduler и экспортировать его из модуля</p>
<pre>class AssemblyLineScheduler {}
module.exports = { AssemblyLineScheduler };</pre>
      </li>
      <li>
        <p>В классе нужно реализовать три метода</p>
        <ul>
          <li>constructor() {}</li>
          <li>appendJob() {}</li>
          <li>start() {}</li>
        </ul>
<pre>class AssemblyLineScheduler {}
  constructor() {}
  appendJob() {}
  start() {}
module.exports = { AssemblyLineScheduler };</pre>
      </li>
      <li>
        <p>Метод constructor() принимает один параметр n (число линий сборки) и возвращает (неявно) объект (экземпляр класса) с двумя свойствами - n (число линий сборки), jobs (пустой массив задач).</p>
<pre>constructor(n) {
  this.n = n;
  this.jobs = [];
}</pre>
      </li>
      <li>
        <p>Метод appendJob() принимает один параметр job (задача), это объект, содержащий</p>
        <ol>
          <li>поле id (строка с номером задачи)</li>
          <li>поле priority (целое число, приоритет задачи). Чем выше тем важнее</li>
          <li>метод execute(). Не принимает параметры, возвращает Promise в состоянии pending, который перейдет в состояние fulfilled или rejected через случайное количество миллисекунд</li>
        </ol>
        <p>Метод appendJob() добавляет задачу в массив задач.</p>
<pre>appendJob(job) {
  this.jobs.push(job);
}</pre>
      </li>
      <li>
        <p>Метод start() должен распределить все задачи по линиям сборки и когда все задачи выполнятся вернуть статистику использования каждой линии. Это массив, в котором содержится n массивов со статистикой о работе на каждой сборочной линии. Каждый из n массивов содержит четыре элемента</p>
        <ol>
          <li>Сколько задач прошли контроль качества</li>
          <li>Сколько задач не прошли контроль качества</li>
          <li>массив с id номерами выполненных задач</li>
          <li>время выполнения работ на этой линии</li>
        </ol>
      </li>
      <li>
        <p>Обнулим массив со статистикой использования каждой линии</p>
        <code>this.lines = [];</code>
      </li>
      <li>
        <p>Отсортируем задачи по приоритету от меньшего приоритета к большему, чтобы можно было доставать задачи из конца массива. Тем самым будет уменьшаться массив задач.</p>
<pre>this.jobs.sort((a,b) => a.priority - b.priority);</pre>
      </li>
      <li>
        <p>В массив со статистикой использования каждой линии запишем начальный результат, до выполнения задач</p>
<pre>for (let i = 0; i &lt; this.n; i++) {
  this.lines[i] = [0,0,[],0];
}</pre>
      </li>
      <li>
        <p>Напишем асинхронную (async) функцию runTask(), которая будет принимать одну задачу и отчет по одной линии. Функция runTask() будет ждать (await) выполнения задачи и результат добавлять в отчет по линии. Если выполнится успешно (fulfilled), то увеличим счетчик успешно выполненных задач. Если выполнится неуспешно (rejected), то увеличим счетчик неуспешно выполненных задач. При любом результате (finally) добавим номер задачи в массив с номерами задач. А также замерим время выполнения задачи и прибавим к времени выполнения задач на линии.</p>
<pre>async function runTask(task, line) {
  let time1 = Date.now();
  await task.execute().then(() => {
    // fulfilled, число выполненных задач
    line[0]++;
  }).catch(() => {
    // rejected, число невыполненных задач
    line[1]++;
  }).finally(() => {
    // id задач
    line[2].push(task['id']);
    let time2 = Date.now();
    let time = time2 - time1;
    // время выполнения всех задач
    line[3] += time;
  })
}</pre>
      <li>
        <p>Напишем асинхронную (async) стрелочную (чтобы не потерять контекст this) функцию runJobs(), которая ничего не принимает.</p>
        <p>Функция runJobs() должна вернуть промис (Promise.allSettled()), который выполнится, когда все задачи на всех линиях будут выполнены.</p>
        <p>Она распределит задачи из массива задач по линиям сборки, а когда задача на линии завершится, то будет добавлять туда следующую задачу.</p>
        <p>Распределение задач по линиям. Для массива со статистикой выполним метод map, который для каждой линии выполнит асинхронную callback-функцию, которая будет ждать выполнение всех задач на линии. Метод map вернет новый массив с промисами по каждой линии.</p>
        <p>Напишем реализацию callback-функции. Если (if) массив задач (this.jobs) не пустой, брать (this.jobs.push()) из него задачу, передавать вместе с отчетом по линии в функцию runTask() и ждать ее выполнения. Когда функция runTask() выполнит первую задачу, в цикле (whie) пока массив задач (this.jobs) не пустой, брать (this.jobs.push()) следующую задачу, передавать ее в функцию runTask() и ждать ее выполнения.</p>
        <p>Функция runJobs() вернет Promise.allSettled в состоянии pending, который принимает массив промисов по каждой линии сборки, который выполнится, когда выполнятся все асинхронные задачи на каждой линии сборки.</p>
<pre>const runJobs = async () => {
  return Promise.allSettled(this.lines.map(async (line) => {
    if (this.jobs.length) {
      const task = this.jobs.pop();
      await runTask(task, line).then(async () => {
        while (this.jobs.length) {
          const task = this.jobs.pop();
          await runTask(task, line);
        }
      });
    }
  }))
}</pre>
      </li>
      <li>
        <p>У меня программа не отрабатывала как надо. Первая линия забирала себе первую задачу, после завершения забирала следующую, и так весь массив задач делала только одна линия. Я наше статью на хабре и воспользовался ей, чтобы все линии могли забрать себе по одной задаче, а потом уже добавлять новые асинхронно.</p>
        <h4>1. Не дожидаться результата выполнения</h4>
        <p>Мы можем определить анонимную функцию как асинхронную:</p>
<pre>async function processArray(array) {
  array.forEach(async (item) => {
    await func(item);
  })
  console.log('Done!');
}</pre>
        <p>Но forEach не будет дожидаться выполнения завершения задачи. forEach — синхронная операция. Она просто запустит задачи и пойдет дальше.</p>
      </li>
      <li>
        <p>Мы должны сделать метод start() асинхронный (async), чтобы запустить функцию runJobs() и подождать (await) ее выполнения. Она выполнится когда выполнятся все промисы в массиве, переданном в метод Promise.allSettled. При этом промис перейдет из состояния pending в состояние fulfilled.</p>
      </li>
      <li>После того как отработают все задачи из массива задач, метод start() перейдет к строчке
        <code>return this.lines;</code>
        <p>И вернет массив со статистикой использования каждой линии</p>
      </li>
  </details>
</article>


<!-- Задача 1. Убрать falsy значения -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h2>Задача 1. Убрать falsy значения</h2>

  <p>Необходимо написать функцию, которая на вход принимает объект с максимальной глубиной вложенности 2 и убирает из него все falsy значения</p>
  <p>falsy значение - это такое значение value, для которого Boolean(value) === false считаем, что obj - результат выполнения JSON.parse, то есть plain object</p>

  <h4>Примеры</h4>
  <code>[null, 0, false, 1] // [1]</code>
  <code>{ 'a': null, 'b': [false, 1] } // { 'b': [1] }</code>
  <code>[null, 0, 5, [0], [false, 16]] // [5, [], [16]]</code>

  <details>
    <summary>Ответ</summary>
<pre>function filterFalsy(obj) {
  if (Array.isArray(obj)) {
    // обрабатываем массив
    let result = [];
    filterResult = obj.filter(elem => Boolean(elem) );

    result = filterResult.map(elem => {
      if (Array.isArray(elem)) {
        let innerResult = elem.filter(innerElem => {
          return Boolean(innerElem);
        })
        return innerResult;
      } else if (typeof elem === 'object' && elem !== null) {
        let innerResult = {};
        for (let key in elem) {
          if (Boolean(elem[key])) {
            innerResult[key] = elem[key];
          }
        }
        return innerResult;
      } else {
        return elem;
      }
    })

    return result;

  } else {
    // обрабатываем объект
    let result = {};

    for (let key in obj) {
      if (Array.isArray(obj[key])) {
        let innerResult = obj[key].filter(innerElem => {
          return Boolean(innerElem);
        });
        result[key] = innerResult;
      } else if (typeof obj[key] === 'object' && obj[key] !== null) {
          let innerObj = {};
        for (let innerKey in obj[key]) {
          if (Boolean(obj[key][innerKey])) {
            innerObj[innerKey] = obj[key][innerKey];
          }
        }
        result[key] = innerObj;
      } else {
        if (Boolean(obj[key])) {
          result[key] = obj[key];
        };
      }
    }

    return result;
  }
}</pre>
  </details>
</article>


<!-- Задача 2. Три асинхронные функции выполнить по порядку -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h2>Задача 2. Три асинхронные функции выполнить по порядку</h2>

  <p>Даны 3 асинхронные функции со случайным setTimeout. Нужно написать код, который выведет в консоль:</p>
<pre>A
B
C</pre>

<pre>function foo(callback) {
  setTimeout(function() {
      callback('A');
  }, Math.random()*100);
}

function bar(callback) {
  setTimeout(function() {
      callback('B');
  }, Math.random()*100);
}

function baz(callback) {
  setTimeout(function() {
      callback('C');
  }, Math.random()*100);
}</pre>

  <details>
    <summary>Ответ</summary>
<pre>let a = new Promise((res, rej) => {
  foo(res);
})

let b = new Promise((res, rej) => {
  bar(res);
})

let c = new Promise((res, rej) => {
  baz(res);
})

let result = Promise.allSettled([
  a,b,c //
]);

result.then(arr => arr.forEach(elem => console.log(elem.value)));</pre>
  </details>
</article>


<!-- Задача 3. Эффект постепенного вывода текста -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h2>Задача 3. Эффект постепенного вывода текста</h2>

  <p>Нужно сделать эффект постепенного вывода текста.</p>
  <p>Пример: https://yastatic.net/s3/taxi-front/tasks/task-matrix.html</p>
  <p>Напишите функцию typeWriter(delay, outputChar), возвращающую функцию writeText(text). writeText(text) далее вызывается несколько раз в разные моменты времени и должна вызывать outputChar поочерёдно для каждого символа строки text с задержкой в delay миллисекунд.</p>
<pre>writeText('ab')
writeText('CD')     writeText('ef')               writeText('xy')
           │                   │                             │
           ▼         250ms     ▼            750ms            ▼
           ├───────┬───────┬───┴───┬───────┬───────┬─────────┼───────┐
           ▲ 100ms ▲ 100ms ▲ 100ms ▲ 100ms ▲ 100ms ▲  500ms  ▲ 100ms ▲
           │       │       │       │       │       │         │       │
outputChar('a')    'b'     'C'     'D'     'e'     'f'       'x'     'y'</pre>

  <code>type OutputChar = (char: string) => void;</code>
  <code>type WriteText = (text: string) => void;</code>
  <code>function typeWriter(delay: number, outputText: OutputChar): WriteText;</code>
  
  <h4>Дополнительно:</h4>
  <p>Решение должно быть линейным по сложности и «отпускать» ссылку на строку сразу же после того, как последний символ строки был выведен.</p>
  
<pre>outputChar('a') 0: a
100ms
outputChar('b') 100: b
...
outputChar('y') 1100: y</pre>

<pre>function runTest() {
  console.clear();

  let start = Date.now();

  function outputChar(char) {
      console.log(`${Date.now() - start}: ${char}`);
  }

  const writeText = typeWriter(100, outputChar);
  writeText('ab');
  writeText('CD');
  setTimeout(() => writeText('ef'), 250);
  setTimeout(() => writeText('xy'), 1000);
}

runTest();</pre>

  <details>
    <summary>Ответ</summary>
<pre>function typeWriter(delay, outputChar) {
  let lastPromise = Promise.resolve();

  return function f(str) {
      let arr = str.split('');

      let arrP = arr.map(elem => {
          return function innerF() {
              return new Promise((res, rej) => {
                  outputChar(elem);
                  setTimeout(() => {
                      res();
                  }, delay)
              })
          }
      })

      for (let elem of arrP) {
          lastPromise = lastPromise.then(() => elem())
      }
  }
}</pre>
  </details>
</article>


<!-- Задача 4. Калькулятор выражений в обратной польской нотации -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h2>Задача 4. Калькулятор выражений в обратной польской нотации</h2>

  <p>Написать калькулятор выражений в обратной польской нотации.</p>
  <h4>Польская нотация:</h4> 
  <ol>
    <li>Выражение состоит из операндов: чисел и знаков операций +, -, *, /</li>
    <li>Выражение читается слева направо</li>
    <li>Операнды в выражении разделяются пробелами</li>
    <li>Когда в выражении встречается знак операции, выполняется соответствующая операция
  *   над двумя последними встретившимися перед ним операндами в порядке их записи</li>
    <li>Результатом вычисления выражения становится результат последней вычисленной операции</li>
  </ol>
  <p>Нужно вернуть результат вычисления или сообщение об ошибке.</p>

<pre>console.clear()
check('7 2 * 3 +', 17)
check('7 2 3 * -', 1)
check('7 2 3 1 + * -', -1)
check('7 2 3 1 + * - 0 +', -1)
check('11 -12 -', 23)
check('7 2 3 1 * - - 3 5 + -', 0)
check('1 1 + +', 'Error in Syntax')
check('1 2 2 *', 'Error in Syntax')
check('1 b + c -', 'Error in Operands')

console.log(`Tests finished`);

function check(example, expected) {
  const input = calc(example)
  console.assert(
      input === expected,
      `Test case %o: expected %o, but got %o`,
      example, expected, input
  );
}</pre>

  <details>
    <summary>Ответ</summary>
<pre>const OPERATIONS = {
  '+': (a, b) => a + b,
  '-': (a, b) => a - b,
  '/': (a, b) => a / b,
  '*': (a, b) => a * b,
}

function calc(str) {
  let arr = str.split(' ');
  const stack = [];

  for (let i = 0; i &lt; arr.length; i++) {
      if (arr[i] in OPERATIONS) {
          if (stack.length &lt; 2) {
              return 'Error in Syntax';
          }
          let first = stack.pop();
          let second = stack.pop();
          let result = OPERATIONS[arr[i]](second, first);
          stack.push(result);
      } else {
          if (!Number.isNaN(+arr[i])) {
              stack.push(+arr[i])
          } else {
              return 'Error in Operands';
          }
      }
  }

  if (stack.length &gt; 1) {
      return 'Error in Syntax';
  }
  return stack.pop();
}</pre>
  </details>
</article>


