<article class="article">
  <a href="https://codeforces.com/contest/1669" target="_blank">Codeforces 1669 Round 784 (Div. 4) 2022-04-17</a>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

      <a href="#task1">Задача A. Дивизон?</a>
  <br><a href="#task2">Задача B. Тройка</a>
  <br><a href="#task3">Задача C. Чётные и нечётные инкременты</a>
  <br><a href="#task4">Задача D. Разноцветная печать</a>
  <br><a href="#task5">Задача E. Двухбуквенные строки</a>
  <br><a href="#task6">Задача F. Съедая конфеты</a>
  <br><a href="#task7">Задача G. Падение</a>
  <br><a href="#task8">Задача H. Максимальный AND</a>
</article>


<!-- Задача A. Дивизон -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Дивизон</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>На Codeforces пользователи разделены на 4
  дивизиона по их рейтингу:</p>

  <ol>
    <li>Для 1-го дивизиона: 1900 ≤ rating</li>
    <li>Для 2-го ивизиона: 1600 ≤ rating ≤ 1899</li>
    <li>Для 3-го дивизиона: 1400 ≤ rating ≤ 1599</li>
    <li>Для 4-го дивизиона: rating ≤ 1399</li>
  </ol>

  <p> Учитывая rating, выведите, к какому дивизиону относится rating</p>

  <h4>Входные данные</h4>
  <p>Первая строка ввода содержит целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных в тесте.</p>
  <p>Описание каждого набора состоит из одной строки, содержащей одно целое число rating (-5000 ≤ rating ≤ 5000).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите единственную строку, содержащую дивизион в формате «Division X», где X
  — целое число от 1 до 4, представляющее дивизион для соответствующего рейтинга.</p>

  <details>
    <summary>Пример</summary>
  <h4></h4>
<pre>
7
-789
1299
1300
1399
1400
1679
2300
</pre>
<pre>
Division 4
Division 4
Division 4
Division 4
Division 3
Division 2
Division 1
</pre>
  <p>Для наборов входных данных 1-4 соответствующие оценки составляют -789, 1299, 1300, 1399, поэтому все они находятся в дивизионе 4.</p>

  <p>Для пятого набора соответствующая оценка составляет 1400, поэтому он находится в дивизионе 3.</p>

  <p>Для шестого набора соответствующий рейтинг составляет 1679, поэтому он находится в дивизионе 2.</p>

  <p>Для седьмого набора соответствующий рейтинг составляет 2300, поэтому он находится в дивизионе 1.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1669/problem/A" target="_blank">Задача 1669А</a>
      <br><a href="https://codeforces.com/contest/1669" target="_blank">Codeforces Round 784 (Div. 4) 2022-04-19</a>
    </div>

    <h4>Идея решения:</h4>
    <ol>
      <li>Для каждого набора входных данных проверяем, в какой диапазон попадает рейтинг.</li>
      <li>В зависимости от диапазона выводим соответствующий дивизион.</li>
    </ol>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int t;
  cin >> t;

  // решение и вывод результата
  for (int test = 0; test &lt; t; test++) {
    int raiting;
    cin >> raiting;
    if (raiting >= 1900) {
      cout &lt;&lt; "Division 1\n";
    } else if (raiting >= 1600) {
      cout &lt;&lt; "Division 2\n";
    } else if (raiting >= 1400) {
      cout &lt;&lt; "Division 3\n";
    } else {
      cout &lt;&lt; "Division 4\n";
    }
  }

}
</pre>
  </details>
</article>


<!-- Задача B. Тройка -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Тройка</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам задан массив a из n элементов. Найдите любое число, которое встречается в этом массиве хотя бы три раза, или выведите -1, если таких чисел нет.</p>

  <h4>Входные данные</h4>
  <p>В первой строке задано целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>
  <p>Первая строка набора входных данных содержит одно целое число n (1 ≤ n ≤ 2⋅10⁵) — количество элементов в массиве.</p>
  <p>Вторая строка набора входных данных содержит n целых чисел a₁, a₂, ... , aₙ (1 ≤ aᵢ ≤ n) — элементы массива.</p>
  <p>Гарантируется, что сумма n по всем наборам входных данных не превосходит 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите любое целое число, которое встречается в массиве хотя бы три раза, или -1, если такого числа нет.</p>

  <details>
    <summary>Пример</summary>
<pre>
7
1
1
3
2 2 2
7
2 2 3 3 4 2 2
8
1 4 3 4 3 2 4 1
9
1 1 1 2 2 2 3 3 3
5
1 5 2 4 3
4
4 4 4 4
</pre>
<pre>
-1
2
2
4
3
-1
4
</pre>
  <p>В первом наборе входных данных в массиве всего один элемент, поэтому не существует числа, которое встречается хотя бы три раза. Следовательно, ответ равен -1.</p>
  <p>Во втором наборе входных данных все три элемента массива равны 2, поэтому 2 встречается трижды. Следовательно, в качестве ответа надо вывести 2.</p>
  <p>В третьем наборе входных данных 2 встречается четыре раза, поэтому 2 — ответ.</p>
  <p>В четвертом наборе входных данных 4 встречается три раза, поэтому 4 — ответ.</p>
  <p>В пятом наборе входных данных каждое из чисел 1, 2 и 3 встречается хотя бы три раза, поэтому любое из них может быть ответом.</p>
  <p>В шестом наборе входных данных все элементы массива различны, поэтому ни одно число не встречается хотя бы три раза, и ответ равен -1.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1669/problem/B" target="_blank">Задача 1669B</a>
      <br><a href="https://codeforces.com/contest/1669" target="_blank">Codeforces Round 784 (Div. 4) 2022-04-19</a>
    </div>

<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int t;
  cin >> t;

  for (int test = 0; test &lt; t; test++) {
    int n;
    cin >> n;
    int len = n + 1;
    int* Arr;
    Arr = new int[len];
    for (int i = 0; i &lt;= n; i++) {
      Arr[i] = 0;
    }
    int tmp;
    for (int i = 0; i &lt; n; i++) {
      cin >> tmp;
      Arr[tmp]++;
    }
    int res = -1;
    for (int i = 0; i &lt;= n; i++) {
      if (Arr[i] >= 3) {
        res = i;
      }
    }

    cout &lt;&lt; res &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача C. Чётные и нечётные инкременты -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Чётные и нечётные инкременты</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Дан массив a=[a1,a2,…,an], состоящий из n положительных целых чисел. Вы можете делать с ним два вида операций:</p>
  <ol>
    <li>Прибавить 1 к каждому элементу с нечётным индексом. То есть произойдут следующие присвоения: a1:=a1+1,a3:=a3+1,a5:=a5+1,….</li>
    <li>Прибавить 1 к каждому элементу с чётным индексом. То есть произойдут следующие присвоения: a2:=a2+1,a4:=a4+1,a6:=a6+1,….</li>
  </ol>
  <p>Определите, возможно ли после какого-либо количества операций сделать так, чтобы после них массив содержал только чётные или только нечётные числа. Другими словами, определите, можете ли вы сделать так, чтобы все элементы массива имели одинаковую четность после какого-либо количества операций.</p>

  <p>Обратите внимание, что вы можете выполнять операции обоих типов любое количество раз (в том числе ни одного). Операции разных типов могут выполняться разное количество раз.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит целое число t (1 ≤ t ≤ 100) — количество наборов входных данных в тесте.</p>

  <p>Первая строка каждого набора содержит единственное целое число n (2 ≤ n ≤ 50) — длину массива.</p>

  <p>Вторая строка каждого набора содержит n целых чисел a1,a2,…,an (1 ≤ ai ≤ 10³) — элементы массива.</p>

  <p>Обратите внимание, что после выполнения операций элементы массива могут стать больше, чем 10³.</p>

  <h4>Выходные данные</h4>
  <p>Выведите t строк, каждая из которых содержит ответ на соответствующий набор входных данных. В качестве ответа выведите «YES», если после некоторого количества операций возможно сделать так, чтобы массив содержал только чётные или только нечётные числа, и «NO» иначе.</p>

  <p>Вы можете выводить ответ в любом регистре (например, строки «yEs», «yes», «Yes» и «YES» будут распознаны как положительный ответ).</p>

  <details>
    <summary>Пример</summary>
  <h4></h4>
<pre>
4
3
1 2 1
4
2 2 2 3
4
2 2 2 2
5
1000 1 1000 1 1000
</pre>
<pre>
YES
NO
YES
YES
</pre>
  <p>В первом примере мы можем увеличить элементы на чётных позициях, после чего получим массив [1,3,1], содержащий только нечётные числа, так что ответ «YES».</p>
  <p>Во втором примере можно показать, что после любого количества операций мы не сможем привести все элементы к одной чётности, так что ответ «NO».</p>
  <p>В третьем примере все элементы уже одной чётности и ответ «YES».</p>
  <p>В четвёртом примере мы можем применить одну операцию и увеличить элементы на нечётных позициях на 1, после чего получим массив [1001,1,1001,1,1001], все элементы которого нечётные, так что ответ «YES».</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Заметим, что массив будет содержать только четные или только нечетные числа только в том случае, если изначально четность всех нечетных элементов одинакова и четность всех четных элементов одинакова.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
// условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // длина массива
    cin >> n;
    vector&lt;int&gt; A(n + 1);
    for (int i = 1; i &lt;= n; i++) {
      cin >> A[i];
    }

    // решение
    bool res = true;
    int k1 = A[1] % 2; // четность нечетных элементов
    int k2 = A[2] % 2; // четность четных элементов

    for (int i = 3; res && i &lt;= n; i += 2) {
      if (k1 != A[i] % 2)
        res = false;
    }

    for (int i = 4; res && i &lt;= n; i += 2) {
      if (k2 != A[i] % 2)
        res = false;
    }

    // вывод результата
    if (res) {
      cout &lt;&lt; "YES\n";
    } else {
      cout &lt;&lt; "NO\n";
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача D. Разноцветная печать -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Разноцветная печать</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам дан ряд из n клеток, изначально каждая клетка белого цвета. С помощью печати, вы можете покрасить любые две соседние клетки так, что одна из них становится красной, а другая синей. Печать можно поворачивать, то есть вы можете покрасить клетки обоими способами: как BR, так и RB.</p>

  <p>Во время каждого применения печати она должна находиться над заданными n клетками (то есть она не может частично находится вне этих клеток). На одну и ту же клетку печать может быть применена многократно. Каждое следующее применение печати перекрашивает обе клетки, которые под печатью.</p>

  <p>Например, один из способов сделать рисунок BRBBW выглядит так: WWWWW→WWRB–––W→BR–––RBW→BRB–––BW. Здесь W, R, и B обозначают белую, красную, и синюю клетки, соответственно, а клетки, к которым приложили печать подчёркнуты.</p>

  <p>Дан конечный рисунок. Возможно ли сделать его, использовав печать ноль или больше раз?</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора содержит единственное целое число n (1 ≤ n ≤ 10⁵) — длина рисунка.</p>

  <p>Вторая строка каждого набора содержит строку s — рисунок, который нужно получить. Гарантируется, что длина s равна n и s состоит только из символов W, R, и B, обозначающие белую, красную, и синюю клетки, соответственно.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превосходит 10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Выведите t строк, каждая из которых содержит ответ на соответствующий набор входных данных. В качестве ответа выведите «YES», если возможно получить рисунок, используя печать, и «NO» иначе.</p>

  <p>Вы можете выводить ответ в любом регистре (например, строки «yEs», «yes», «Yes» и «YES» будут распознаны как положительный ответ).</p>

  <details>
    <summary>Пример</summary>
<pre>
12
5
BRBBW
1
B
2
WB
2
RW
3
BRB
3
RBB
7
WWWWWWW
9
RBWBWRRBW
10
BRBRBRBRRB
12
BBBRWWRRRWBR
10
BRBRBRBRBW
5
RBWBW
</pre>
<pre>
  YES
  NO
  NO
  NO
  YES
  YES
  YES
  NO
  YES
  NO
  YES
  NO
</pre>
  <p>Первый пример разобран в условии.</p>
  <p>Во втором, третьем и четвёртом примерах невозможно покрасить одну клетку, так что ответ «NO».</p>
  <p>В пятом примере можно поркасить следующим образом: WWW→WRB–––→BR–––B.</p>
  <p>В шестом примере можно поркасить следующим образом: WWW→WRB–––→RB–––B.</p>
  <p>В седьмом примере печать не нужно использовать вовсе.</p>
  </details>
</article>


<!-- Задача E. Двухбуквенные строки -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Двухбуквенные строки</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Даны n строк, каждая имеет длину 2 и состоит из строчных латинских букв от 'a' до 'k'. Выведите количество пар индексов (i,j) таких, что i &lt; j и i-я строка с j-й строкой различаются ровно в одной позиции.</p>

  <p>Другими словами найдите количество пар (i,j) (i &lt; j) таких, что i-я строка с j-й строкой различаются ровно в одной позиции p (1 ≤ p ≤ 2), то есть s<sub>ip</sub>≠s<sub>jp</sub>.</p>

  <p>Ответ может не влезать в 32-разрядный целочисленный тип, поэтому вам следует использовать 64-разрядные целые числа, такие как long long в C++, чтобы избежать переполнения целочисленного типа.</p>

  <h4>Входные данные</h4>
  <p></p>Первая строка входных данных содержит целое число t (1 ≤ t ≤ 100) — количество наборов входных данных.

  <p>Далее идут описания наборов входных данных.</p>

  <p>Первая строка каждого набора содержит одно целое число n (1 ≤ n ≤ 10⁵) — количество строк.</p>

  <p>Далее следуют n строк, i-я из которых содержит единственную строку si длины 2, состоящую из строчных латинских букв от 'a' до 'k'.</p>

  <p>Гарантируется что сумма n по всем наборам не превосходит 10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора выведите единственное число — количество пар (i,j) (i &lt; j) таких, что i-я строка с j-й строкой различаются ровно в одной позиции p (1 ≤ p ≤ 2), то есть s<sub>ip</sub>≠s<sub>jp</sub>.</p>

  <p>Пожалуйста, обратите внимание, что ответ для некоторых тестовых примеров не будет помещаться в 32-разрядный целочисленный тип, поэтому вы должны использовать по крайней мере 64-разрядный целочисленный тип в вашем языке программирования (например, long long для C++).</p>

  <details>
    <summary>Пример</summary>
<pre>
4
6
ab
cb
db
aa
cc
ef
7
aa
bb
cc
ac
ca
bb
aa
4
kk
kk
ab
ab
5
jf
jf
jk
jk
jk
</pre>
<pre>
5
6
0
6
</pre>
  <p>В первом примере ровно в одной позиции различаются следующие пары: («ab», «cb»), («ab», «db»), («ab», «aa»), («cb», «db») and («cb», «cc»).</p>
  <p>Во втором примере ровно в одной позиции различаются следующие пары: («aa», «ac»), («aa», «ca»), («cc», «ac»), («cc», «ca»), («ac», «aa») and («ca», «aa»).</p>
  <p>В третьем примере нет пар, удовлетворяющих условиям.</p>
  </details>
</article>


<!-- Задача F. Съедая конфеты -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Съедая конфеты</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Есть n конфет разложенных слева направо на столе, конфеты пронумерованы слева направо. Вес i-й конфеты равняется w<sub>i</sub>. Алиса и Боб едят конфеты.</p>

  <p>Алиса может съесть любое количество конфет слева (она ест их подряд и не может пропускать конфеты).</p>

  <p>Боб может съесть любое количество конфет справа (он ест их подряд и не может пропускать конфеты).</p>

  <p>Если Алиса съела конфету, то Боб уже не сможет её съесть (и наоборот).</p>

  <p>Они хотят поделить конфеты честно. Поэтому суммарные веса съеденных ими конфет должны быть равны. Какое наибольшее суммарное количество конфет они могут съесть в таком случае?</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит целое число t (1≤t≤10<sup>4</sup>) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора содержит единственное целое число n (1≤n≤2⋅10<sup>5</sup>) — количество конфет на столе.</p>

  <p>Вторая строка каждого набора содержит n чисел w<sub>1</sub>,w<sub>2</sub>,…,w<sub>n</sub> (1≤w<sub>i</sub>≤10<sup>4</sup>) — веса конфет от самой левой до самой парвой.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превосходит 2⋅10<sup>5</sup>.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора выведите единственное число — максимальное количество, которое могут съесть Алиса и Боб, соблюдая условие.</p>

  <details>
    <summary>Пример</summary>
<pre>
4
3
10 20 10
6
2 1 4 2 4 1
5
1 2 4 8 16
9
7 3 20 5 15 1 11 8 10
</pre>
<pre>
2
6
0
7
</pre>
  <p>В первом примере Алиса съест одну конфету слева, а Боб съест одну конфету справа. Нет лучшего способа съесть набор конфет одинакового веса. Ответ 2, так как они съедят суммарно две конфеты.</p>

  <p>Во втором примере Алиса съест первые три конфеты слева (суммарным весом 7), а Боб съест первые три конфеты справа (суммарным весом 7). Они не могут съесть больше конфет, так как все конфеты съедены. Ответ равен 6, так как они съели суммарно шесть конфет.</p>

  <p>В третьем примере Алиса и Боб не могут съесть наборы конфет одинакового ненулевого веса, поэтому ответ равен 0.</p>

  <p>В четвертом примере Алиса съест конфеты весом [7,3,20], а Боб съест конфеты весом [10,8,11,1], каждый из них съест набор конфет суммарным весом 30. Лучшего способа съесть конфеты нет, поэтому ответ 7.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1669/problem/E" target="_blank">Задача 1669E</a>
      <br><a href="https://codeforces.com/contest/1669" target="_blank">Codeforces Round 784 (Div. 4) 2022-04-19</a>
    </div>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ускорение ввода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n;
    cin >> n;
    vector&lt;int&gt; A(n);
    for (int i = 0; i &lt; n; i++) {
      cin >> A[i];
    }

    // решение
    int res = 0;
    int l = 0, r = n - 1;
    int wl = 0, wr = 0;
    int cnt = 0;

    while (r >= l) {
      if (wl &lt;= wr) {
        wl += A[l];
        l++;
      } else {
        wr += A[r];
        r--;
      }
      cnt++;
      if (wl == wr) {
        res = cnt;
      }
    }

    // вывод результата
    cout &lt;&lt; res &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача G. Падение -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Падение</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Дана матрица из n строк и m столбцов, каждая ячейка которой имеет один из трех типов:</p>
  <ol>
    <li>Пустая ячейка (обозначается как «.»).</li>
    <li>Камень (обозначается как «*»).</li>
    <li>Препятствие (обозначается как строчная буква латинского алфавита «o»).</li>
  </ol>
  <p>Каждый камень начинает падать, пока не окажется на полу (в нижней строке матрицы), в ячейке над препятствием, или в ячейке над другим камнем, который уже закончил падение. (Другими словами, все камни начинают падать и падают, пока под ними пустые ячейки.)</p>

  <p>Просимулируйте процесс и выведите состояние матрицы после того, как все камни закончат падать.</p>

  <h4>Входные данные</h4>
  <p>В первой строке задано целое число t (1 ≤ t ≤ 100) — количество наборов входных данных. Далее следуют сами наборы входных данных.</p>

  <p>В первой строке каждого набора входных данных заданы два целых числа n и m (1 ≤ n, m ≤ 50) — количество строк и столбцов в матрице.</p>

  <p>Затем следуют n строк, каждая из которых содержит m символов. Каждый из этих символов — «.», «*» или «o» (пустая клетка, камень и препятствие соответственно).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите матрицу из n строк и m столбцов, описывающую результат процесса.</p>

  <p>Не обязательно выводить новую строку после каждого набора входных данных; в примерах из условия она выводится для наглядности.</p>

  <details>
    <summary>Пример</summary>
<pre>
3
6 10
.*.*....*.
.*.......*
...o....o.
.*.*....*.
..........
.o......o*
2 9
...***ooo
.*o.*o.*o
5 5
*****
*....
*****
....*
*****
</pre>
<pre>
..........
...*....*.
.*.o....o.
.*........
.*......**
.o.*....o*

....**ooo
.*o**o.*o

.....
*...*
*****
*****
*****
</pre>
  </details>
</article>


<!-- Задача H. Максимальный AND -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Максимальный AND</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Пусть AND обозначает побитовую операцию И, а OR обозначает побитовую операцию ИЛИ.</p>

  <p>Вам дан массив a длины n и неотрицательное целое число k. Вы можете выполнить не более чем k операций над массивом следующего типа:</p>
  <ul>
    <li>Выбрать индекс i (1 ≤ i ≤ n) и заменить ai на ai OR 2<sup>j</sup>, где j - любое целое число от 0 до 30 включительно. Другими словами, в операции можно выбрать индекс i (1 ≤ i ≤ n) и установить j-й бит ai в 1 (0 ≤ j ≤ 30).</li>
  </ul>

  <p>Выведите максимально возможное значение a1 AND a2 AND … AND an после выполнения не более чем k операций.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит одно целое число t (1 ≤ t ≤ 100) — количество наборов входных данных в тесте. Далее следует описание наборов.</p>

  <p>Первая строка каждого набора содержит целые числа n и k (1 ≤ n ≤ 2⋅10⁵, 0 ≤ k ≤ 10⁹).</p>

  <p>Затем следует единственная строка, содержащая n целых чисел, описывающих массив a (0 ≤ ai &lt; 2³¹).</p>

  <p>Гарантируется, что сумма n по всем наборам не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите единственную строку, содержащую максимально возможное AND значение a1 AND a2 AND … AND an после выполнения не более чем k операций.</p>

  <details>
    <summary>Пример</summary>
<pre>
4
3 2
2 1 1
7 0
4 6 6 28 6 6 12
1 30
0
4 4
3 1 3 1
</pre>
<pre>
2
4
2147483646
1073741825
</pre>
  <p>Для первого набора мы можем установить бит 1 (2¹) последних 2-х элементов с помощью 2-х операций, получив таким образом массив [2, 3, 3], значение AND которого равно 2.</p>
  <p>Для второго набора мы не можем выполнить никаких операций, поэтому ответом будет только AND всего массива, равное 4.</p>
  </details>
</article>
