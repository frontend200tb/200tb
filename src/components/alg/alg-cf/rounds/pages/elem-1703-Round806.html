<article class="article">
  <a href="https://codeforces.com/contest/1703" target="_blank">Codeforces 1703 Round 806 (Div. 4) 2022-07-12</a>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

      <a href="#task1">Задача A. YES или YES?</a>
  <br><a href="#task2">Задача B. ICPC шарики</a>
  <br><a href="#task3">Задача C. Шифр</a>
  <br><a href="#task4">Задача D. Двойные строки</a>
  <br><a href="#task5">Задача E. Симметричная решётка</a>
  <br><a href="#task6">Задача F. Очередная задача про пары, удовлетворяющие неравенству</a>
  <br><a href="#task7">Задача G. Хороший ключ, плохой ключ</a>
</article>


<!-- Задача A. YES или YES? -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. YES или YES?</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Дана строка s длины 3, состоящая из строчных и заглавных букв латинского алфавита. Ваша задача состоит в том, чтобы определить, равняется ли она строке «YES» (без кавычек), где каждая буква может быть как заглавной, так и строчной. Например, «yES», «Yes» и «yes» все являются допустимыми.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно целое число t (1 ≤ t ≤ 10³) — количество наборов входных данных. Далее следует описание каждого набора.</p>

  <p>Единственная строка каждого набора входных данных содержит строку s длины три. Каждый символ s является строчной или заглавной буквой латинского алфавита.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите «YES» (без кавычек) если s удовлетворяет условию, и «NO» в противном случае.</p>

  <p>Вы можете выводить «Yes» и «No» в любом регистре (например, строки «yES», «yes» и «Yes» будут распознаны как правильный ответ).</p>

  <details>
    <summary>Пример</summary>
<pre>
10
YES
yES
yes
Yes
YeS
Noo
orZ
yEz
Yas
XES
</pre>
<pre>
YES
YES
YES
YES
YES
NO
NO
NO
NO
NO
</pre>
  <p>Первые пять наборов входных данных содержат строки «YES», «yES», «yes», «Yes», «YeS». Все они равны строке «YES», где каждый символ либо заглавный, либо строчный.</p>
  </details>
</article>


<!-- Задача B. ICPC шарики -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. ICPC шарики</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Во время соревнования ICPC шарики распределяются между командами следующим образом:</p>
  <ul>
    <li>Когда команда решает задачу, она получает один шарик.</li>
    <li>Первая команда, решившая определённую задачу, получает дополнительный шарик.</li>
  </ul>
  <p>Всего в соревновании 26 задач, проиндексированных A, B, C, ..., Z. Вам известен порядок, в котором решались задачи во время соревнования, обозначенный строкой s, где i-й символ строки обозначает, что задача с индексом si была решена одной из команд. Гарантируется, что никакая команда не может решить одну и ту же задачу дважды.</p>
  <p>Посчитайте, какое суммарное количество шариков получили команды за время соревнования. Обратите внимание, что некоторые задачи могут быть не решены ни одной из команд.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно целое число t (1 ≤ t ≤ 100) — количество наборов входных данных. Далее следует описание наборов.</p>

  <p>Первая строка каждого набора входных данных содержит число n
   (1 ≤ n ≤ 50) — длину строки.</p>

  <p>Вторая строка каждого набора содержит строку s длины n, состоящую из заглавных букв латинского алфавита, обозначающую порядок, в котором решались задачи.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно число — суммарное количество шариков, полученных командами за время соревнования.</p>

  <details>
    <summary>Пример</summary>
<pre>
6
3
ABA
1
A
3
ORZ
5
BAAAA
4
BKPT
10
CODEFORCES
</pre>
<pre>
5
2
6
7
8
17
</pre>
  <p>В первом наборе входных данных были разданы 5 шаров:</p>
  <ul>
    <li>Была решена задача A. Решившая её команда получила 2 шара: один за решение задачи, второй за то, что она решила задачу A первой.</li>
    <li>Была решена задача B. Решившая её команда получила 2 шара: один за решение задачи, второй за то, что она решила задачу B
 первой.</li>
    <li>Была решена задача A. Решившая её команда получила 1 шар за решение задачи. Обратите внимание, что эта команда не получила дополнительный шарик, так как она не является первой командой, решившей задачу A.</li>
  </ul>
  <p>Суммарно команды получили 2+2+1=5 шариков.Во втором наборе входных данных была решена только одна задача. Решившая её команда получила 2 шара: один за решение задачи, второй за то, что она решила задачу A первой.</p>
  </details>
</article>


<!-- Задача C. Шифр -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Шифр</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Лука имеет шифр, представляющий собой последовательность из n колёсиков, каждое с написанной на нём цифрой ai. Известно, что он прокрутил i-е колёсико bi раз. Каждое колёсико может крутиться:</p>
  <ul>
    <li>вверх (обозначено символом U): прокрутка вверх увеличивает значение на i-м колёсике на 1. После прокрутки 9 вверх, значение становится равным 0.</li>
    <li>вниз (обозначено символом D): прокрутка вниз уменьшает значение на i-м колёсике на 1. После прокрутки 0 вниз, значение становится равным 9.</li>
  </ul>
  <p>Пример для n=4. Текущая последовательность цифр: 0 0 0 0.</p>
  <p>Лука знает конечные значения колёсиков и последовательность совершённых прокруток для каждого из них. Помогите ему восстановить изначальную последовательность цифр, чтобы взломать шифр!</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит число t (1 ≤ t ≤ 100) — количество наборов входных данных.</p>
  <p>Первая строка каждого набора содержит число n (1 ≤ n ≤ 100) — количество колёсиков.</p>

  <p>Вторая строка содержит n чисел ai (0 ≤ ai ≤ 9) — значение на i-м колёсике после всех прокруток.</p>

  <p>Далее следуют n строк, i-я из которых содержит число bi (1 ≤ bi ≤ 10) и bi символов, каждый из которых является либо U, либо D — количество совершённых прокруток i-го колёсика и описание прокруток соответственно. Символы U и D означают прокрутку вверх и вниз соответственно.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора выведите n разделённых пробелом цифр  — изначальные значения на колёсиках шифра.</p>

  <details>
    <summary>Пример</summary>
<pre>
3
3
9 3 1
3 DDD
4 UDUU
2 DU
2
0 9
9 DDDDDDDDD
9 UUUUUUUUU
5
0 5 9 8 3
10 UUUUUUUUUU
3 UUD
8 UUDUUDDD
10 UUDUUDUDDU
4 UUUU
</pre>
<pre>
2 1 1
9 0
0 4 9 6 9
</pre>
  <p>В первом наборе можно показать, что изначальным шифром являлось [2,1,1]. В таком случае колёсики были прокручены следующим образом:</p>
  <ul>
    <li>Первое колёсико: 2→D1→D0→D9.</li>
    <li>Второе колёсико: 1→U2→D1→U2→U3.</li>
    <li>Третье колёсико: 1→D0→U1.</li>
  </ul>
  <p>Получившаяся последовательность [9,3,1] совпадает с заданной во входных данных.</p>
  </details>
</article>


<!-- Задача D. Двойные строки -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Двойные строки</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам даны n строк s1,s2,…,sn длины не более 8.</p>

  <p>Для каждой строки si, проверьте, существуют ли такие sj и sk, что si=sj+sk. То есть определите, является ли si конкатенацией sj и sk. Обратите внимание, что j может быть равным k.</p>

  <p>Напомним, что конкатенацией строк s и t называется строка s+t=s1s2…spt1t2…tq, где p и q длины строк s и t соответственно. Например, конкатенация строк «code» и «forces» равна «codeforces».</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора содержит число n (1 ≤ n ≤ 10⁵) — количество строк.</p>

  <p>Затем следуют n строк, i-я из которых содержит непустую строку si длины не более 8, состоящую из строчных английских букв. Среди заданных n строк могут быть одинаковые.</p>

  <p>Сумма n по всем наборам не превосходит 10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора выведите бинарную строку длины n. i-й бит строки должен равняться 1 если существуют две строки sj и sk таких, чтобы si=sj+sk, или же 0 в противном случае. Обратите внимание, что j может совпадать с k.</p>

  <details>
    <summary>Пример</summary>
<pre>
3
5
abab
ab
abc
abacb
c
3
x
xx
xxx
8
codeforc
es
codes
cod
forc
forces
e
code
</pre>
<pre>
10100
011
10100101
</pre>
  <p>В первом наборе мы имеем следующее:</p>
  <ul>
    <li>s1=s2+s2, так как abab=ab+ab. Помните, что j может совпадать с k.</li>
    <li>s2 не может быть представлена как конкатенация никаких двух строк.</li>
    <li>s3=s2+s5, так как abc=ab+c.</li>
    <li>s4 не может быть представлена как конкатенация никаких двух строк.</li>
    <li>s5 не может быть представлена как конкатенация никаких двух строк.</li>
  </ul>
  <p>Так как только s1 и s3 удовлетворяют условиям, то только первый и третий биты в ответе будут равняться 1, поэтому ответ — 10100.</p>
  </details>
</article>


<!-- Задача E. Симметричная решётка -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Симметричная решётка</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам дана квадратная матрица из n строк и n столбцов. В каждой ячейке содержится одно число: 0 или 1.</p>

  <p>За одну операцию вы можете выбрать любую ячейку матрицы и инвертировать её значение (0→1 или 1→0).</p>

  <p>Найдите за какое минимальное число операций можно получить квадрат который не меняется при поворотах на 0°, 90°, 180° и 270°.</p>

  <p>На картинке ниже показан пример всех поворотов одной матрицы.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно целое число t (1 ≤ t ≤ 100) — количество наборов входных данных. Далее следует описание наборов.</p>

  <p>Первая строка каждого набора входных данных содержит число n (1≤n≤100) — размер матрицы.</p>

  <p>Следующие n строк каждого набора входных данных содержат строку длины n, состоящую из значений a<sub>i,j</sub> (0 ≤ a<sub>i,j</sub> ≤ 1) — числа, записанные в каждой ячейке.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно число — минимальное количество операций необходимое чтобы получить квадратную матрицу, которая не меняется при поворотах на 0°, 90°, 180° и 270°.</p>

  <details>
    <summary>Пример</summary>
<pre>
5
3
010
110
010
1
0
5
11100
11011
01011
10011
11000
5
01000
10101
01010
00010
01001
5
11001
00000
11111
10110
01111
</pre>
<pre>
1
0
9
7
6
</pre>
  <p>В первом наборе входных данных, мы можем применить одну операцию чтобы сделать матрицу симметричной</p>
<pre>
0 1 0
1 1 1
0 1 0
</pre>
  <p>Теперь, любой поворот не меняет данную матрицу.</p>
  <p>Во втором наборе входных данных, нет необходимости применять ни одной операции, любые допустимые повороты и так не меняют её.</p>
  </details>
</article>


<!-- Задача F. Очередная задача про пары, удовлетворяющие неравенству -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Очередная задача про пары, удовлетворяющие неравенству</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам дан массив целых чисел a1,a2,…an. Найдите число пар индексов 1 ≤ i, j ≤ n таких, что ai &lt; i &lt; aj &lt; j.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно целое число t (1 ≤ t ≤ 1000) — количество наборов входных данных. Далее следует их описание.</p>

  <p>Первая строка каждого набора содержит число n (2 ≤ n ≤ 2⋅10⁵) — длину массива.</p>

  <p>Вторая строка каждого набора содержит n целых чисел a1, a2, …, an (0 ≤ ai ≤ 10⁹) — элементы массива.</p>

  <p>Гарантируется, что сумма n по всем наборам не превосходит 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно число — количество пар индексов, удовлетворяющих неравенству из условия.</p>

  <p>Пожалуйста, обратите внимание, что ответ для некоторых тестовых примеров может не поместиться в 32-разрядный целочисленный тип, поэтому вы должны использовать по крайней мере 64-разрядный целочисленный тип в вашем языке программирования (например, long long для C++).</p>

  <details>
    <summary>Пример</summary>
<pre>
5
8
1 1 2 3 8 2 1 4
2
1 2
10
0 2 1 6 3 4 1 2 8 3
2
1 1000000000
3
0 1000000000 2
</pre>
<pre>
3
0
10
0
1
</pre>
  <p>В первом наборе входных данных пары (i,j) = {(2,4),(2,8),(3,8)}.</p>
  <ul>
    <li>Пара (2,4) подходит, потому что a2=1, a4=3 и 1 &lt; 2 &lt; 3 &lt; 4.</li>
    <li>Пара (2,8) подходит, потому что a2=1, a8=4 и 1 &lt; 2 &lt; 4 &lt; 8.</li>
    <li>Пара (3,8) подходит, потому что a3=2, a8=4 и 2 &lt; 3 &lt; 4 &lt; 8.</li>
  </ul>
  </details>
</article>


<!-- Задача G. Хороший ключ, плохой ключ -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Хороший ключ, плохой ключ</h3>

  <div><i>Ограничение по времени 3с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У вас есть n сундуков. i-й сундук содержит ai монет. Вы должны открыть все n сундуков по порядку, начиная с сундука 1, заканчивая сундуком n.</p>

  <p>Также существуют два вида ключей, которые вы можете использовать для открытия каждого сундука:</p>
  <ul>
    <li>хороший ключ, который стоит k монет;</li>
    <li>плохой ключ, который бесплатен, но уменьшит вдвое количество монет в каждом неоткрытом сундуке, включая сундук, который собираются им открыть. Уменьшаясь вдвое, количество монет округляется вниз до ближайшего целого числа для каждого из сундуков. Иными словами, если используется плохой ключ, чтобы открыть сундук i, количества монет в сундуках изменятся следующим образом: ai=⌊ai/2⌋, ai+1=⌊a<sub>i+1</sub>/2⌋,…,an=⌊an/2⌋;</li>
    <li>любой ключ (и хороший и плохой) ломается после использования, то есть является одноразовым.</li>
  </ul>
  <p>Вам необходимо использовать n ключей, по одному на каждый сундук. Изначально у вас нет ключей и монет. Если вы хотите использовать хороший ключ, то его надо купить.</p>

  <p>В процессе вы можете уходить в минус — например, если у вас есть 1 монета, вы можете купить хороший ключ за k=3 монеты, и у вас станет -2 монеты.</p>

  <p>Найдите максимальное количество монет, которое вы сможете получить в итоге после открытия всех n сундуков по порядку от 1 до n.</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержится одно целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>В первой строке каждого набора содержатся два целых числа n и k (1 ≤ n ≤ 10⁵, 0 ≤ k ≤ 10⁹) — количество сундуков и стоимость хорошего ключа соответственно.</p>

  <p>Вторая строка каждого набора содержит n чисел ai (0 ≤ ai ≤ 10⁹)  — количество монет в каждом из сундуков.</p>

  <p>Гарантируется, что сумма n по всем наборам не превосходит 10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора выведите одно число  — максимальное количество монет, которое вы сможете получить после открытия сундуков с 1 по n.</p>

  <p>Пожалуйста, обратите внимание, что ответ для некоторых наборов входных данных может не поместиться в 32-разрядный целочисленный тип, поэтому вы должны использовать по крайней мере 64-разрядный целочисленный тип в вашем языке программирования (например, long long для C++).</p>

  <details>
    <summary>Пример</summary>
<pre>
5
4 5
10 10 3 1
1 2
1
3 12
10 10 29
12 51
5 74 89 45 18 69 67 67 11 96 23 59
2 57
85 60
</pre>
<pre>
11
0
13
60
58
</pre>
  <p>В первом наборе одна из возможных стратегий следующая:</p>
  <ul>
    <li>Купить хороший ключ за 5 монет, и открыть сундук 1, получив 10 монет. Ваш баланс станет 0+10-5=5 монет.</li>
    <li>Купить хороший ключ за 5 монет, и открыть сундук 2, получив 10 монет. Ваш баланс станет 5+10-5=10 монет.</li>
    <li>Использовать плохой ключ, и открыть им сундук 3. В результате использования плохого ключа, количество монет в сундуке 3 становится ⌊3/2⌋=1, и количество монет в сундуке 4 становится ⌊1/2⌋=0. Ваш баланс станет 10+1=11.</li>
    <li>Использовать плохой ключ, и открыть им сундук 4. В результате использования плохого ключа, количество монет в сундуке 4 станет ⌊0/2⌋=0. Ваш баланс станет 11+0=11.</li>
  </ul>
  <p>После открытия всех сундуков, у вас останется 11 монет. Можно доказать, что получить больше монет невозможно.</p>
  </details>
</article>
