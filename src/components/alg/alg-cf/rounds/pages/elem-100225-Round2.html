<article class="article">
  <a href="https://codeforces.com/contest/2" target="_blank">Codeforces 2 Round 2 Beta 2010-02-25</a>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

      <a href="#task1">Задача A. Победитель</a>
  <br><a href="#task2">Задача B. Наименее круглый путь</a>
  <br><a href="#task3">Задача C. Задача комментатора</a>
</article>


<!-- Задача A. Победитель -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Победитель</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Победитель популярной в Берляндии карточной игры «Берлоггинг» определяется по следующим правилам. Если на момент окончания игры существует только один игрок, набравший максимальное количество очков, то он и становится победителем.</p>

  <p>Ситуация осложняется, если таких игроков несколько. Каждый кон игры некоторый игрок выигрывает или проигрывает некоторое количество очков. В записи о ходе игры это обозначается строкой «name score», где name это имя игрока, а score целое число обозначающее количество заработанных очков данным игроком. Если score — отрицательное число, это обозначает, что игрок проиграл в этом коне. Так вот, если на конец игры несколько игроков набрали максимум очков (пусть это число равно m), то выигрывает тот из них, кто первым набрал как минимум m очков. Перед началом игры у каждого игрока 0 очков. Гарантируется, что на момент окончания игры хотя бы у одного игрока положительное число очков.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое число n (1 ≤ n ≤ 1000), n — количество конов сыгранной игры. Далее в n строках идут описания конов, в формате «name score» в хронологическом порядке, где name это строка из строчных букв латинского алфавита длины от 1 до 32, а score это целое число от -1000 до 1000 включительно.</p>

  <h4>Выходные данные</h4>
  <p>Выведите имя победителя игры «Берлоггинг».</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
3
mike 3
andrew 5
mike 2
</pre>
    <code>andrew</code>

    <h4>Пример 2</h4>
<pre>
3
andrew 3
andrew 2
mike 5
</pre>
    <code>andrew</code>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;map&gt;

using namespace std;

int main() {
  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // ввод данных
  int n; // число конов игры
  cin >> n;
  // массив всех конов по порядку
  vector&lt;pair&lt;string, int&gt; &gt; A(n);

  // словарь всех игроков
  map&lt;string, int&gt; B;
  string name; // имя игрока
  int score; // число очков
  for (int i = 0; i &lt; n; i++) {
    cin >> name;
    cin >> score;
    A[i] = make_pair(name, score);
    B[name] += score;
  }

  // решение

  int cnt = 0;
  int cnt_max = 0;
  // найдем максимальное число очков
  for (const auto& name : B) {
    cnt = name.second;
    if (cnt > cnt_max) {
      cnt_max = cnt;
    }
  }

  // словарь победителей
  map&lt;string, int&gt; win;
  // соберем игроков с максимальным числом очков
  for (const auto& name : B) {
    cnt = name.second;
    if (cnt == cnt_max) {
      win[name.first] = 0;
    }
  }

  // победитель
  string win_name;
  if (win.size() == 1) {
    win_name = win.begin()->first;
  } else {
    bool is_finded = false;
    for (int i = 0; !is_finded && i &lt; n; i++) {
      if (win.find(A[i].first) != win.end()) {
        win[A[i].first] += A[i].second;
        if (win[A[i].first] >= cnt_max) {
          win_name = A[i].first;
          is_finded = true;
        }
      }
    }
  }

  // вывод результата
  cout &lt;&lt; win_name;
}
</pre>
  </details>
</article>


<!-- Задача B. Наименее круглый путь -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Наименее круглый путь</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Задана квадратная матрица n x n, состоящая из неотрицательных целых чисел. Вам надо найти такой путь на ней, который</p>
  <ol>
    <li>начинается в левой верхней ячейке матрицы;</li>
    <li>каждой следующей ячейкой имеет правую или нижнюю от текущей;</li>
    <li>заканчивается в правой нижней клетке.</li>
  </ol>

  <p>Кроме того, если перемножить все числа вдоль пути и посмотреть на получившиеся произведение, то это число должно быть как можно менее «круглым». Иными словами оно должно заканчиваться на наименьшее возможное количество нулей.</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержится целое число n (2 ≤ n ≤ 1000), n — размер заданной матрицы. Далее в n строках содержатся элементы матрицы (целые неотрицательные числа, не превосходящие 10⁹).</p>

  <h4>Выходные данные</h4>
  <p>В первую строку выведите искомое наименьшее количество концевых нулей в произведении чисел вдоль пути. Во вторую выведите сам путь.</p>

  <details>
    <summary>Пример</summary>
<pre>
3
1 2 3
4 5 6
7 8 9
</pre>
<pre>
0
DDRR
</pre>
  </details>
</article>


<!-- Задача C. Задача комментатора -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Задача комментатора</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Олимпиада в Беркувере в самом разгаре. Здесь у каждого свои задачи — спортсмены борются за медали, а комментаторы за наиболее удобные места ведения репортажей. Сегодня основные спортивные мероприятия пройдут на трех круглых стадионах и задача комментатора выбрать оптимальную точку наблюдения, то есть такую из которой видны все три стадиона. Так как все состязания одинаково важны — то и стадионы должны быть видны из этой точки под одинаковым углом. Если таких точек несколько, то более предпочтительной является та, из которой угол обзора каждого стадиона максимален.</p>

  <p>Помогите известному в Берляндии комментатору Г. Берниеву найти оптимальную точку наблюдения. Учтите, что стадионы не загораживают друг друга — комментатор может видеть легко наблюдать один стадион сквозь другой.</p>

  <h4>Входные данные</h4>
  <p>Входные данные состоят из трех строк, каждая из которых описывает положение одного стадиона. Строки имеют формат x, y, r, где (x,y) — это координаты центра стадиона (-10³ ≤ x, y ≤ 10³), а r (1 ≤ r ≤ 10³) — это его радиус. Все числа во входных данных целые. Стадионы не пересекаются, а их центры не лежат на одной прямой.</p>

  <h4>Выходные данные</h4>
  <p>Выведите координаты искомой точки с пятью знаками после десятичной точки. Если решения не существует, то программа не должны выводить что либо. Иными словами она должны оставить выходные данные пустыми.</p>

  <details>
    <summary>Пример</summary>
<pre>
0 0 10
60 0 10
30 30 10
</pre>
    <code>30.00000 0.00000</code>
  </details>
</article>

