<article class="article">
  <a href="https://codeforces.com/contest/1742" target="_blank">Codeforces 1742 Round 827 (Div. 4) 2022-10-13</a>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

      <a href="#task1">Задача A. Сумма</a>
  <br><a href="#task2">Задача B. Возрастающий</a>
  <br><a href="#task3">Задача C. Полосы</a>
  <br><a href="#task4">Задача D. Взаимно простые</a>
  <br><a href="#task5">Задача E. Scuza</a>
  <br><a href="#task6">Задача F. Меньше</a>
  <br><a href="#task7">Задача G. Оррэй</a>
</article>


<!-- Задача A. Сумма -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Сумма</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам даны три целых числа a, b и c. Определите, является ли одно из них суммой двух других.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит число t (1 ≤ t ≤ 9261) — количество наборов входных данных. Описание каждого набора состоит из 3 чисел a, b, c (0 ≤ a, b, c ≤ 20).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора выведите «YES», если одно из чисел равно сумме двух других, и «NO» в противном случае. Вы можете вывести ответ в любом регистре (например, строки «YEs», «Yes», «Yes» и «YES» будут считаться как положительный ответ).</p>

  <details>
    <summary>Пример</summary>
<pre>
7
1 4 3
2 5 8
9 11 20
0 0 0
20 20 20
4 12 3
15 7 8
</pre>
<pre>
YES
NO
YES
YES
NO
NO
YES
</pre>
  <p>Примечание. В первом наборе 1+3=4. Во втором наборе ни одно из чисел не является суммой двух других. В третьем наборе 9+11=20.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1742/problem/A" target="_blank">Задача 1742А</a>
      <br><a href="https://codeforces.com/contest/1742" target="_blank">Codeforces Round 827 (Div. 4) 2022-10-13</a>
    </div>

    <p>Для каждого набора входных данных проверяем три условия: a = b + c, b = a + c, c = a + b</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int t;
  cin >> t;

  for (int test = 0; test &lt; t; test++) {
    int a, b, c;
    cin >> a >> b >> c;

    // решение и вывод результата
    if (a == b + c || b == a + c || c == a + b) {
      cout &lt;&lt; "YES" &lt;&lt; '\n';
    } else {
      cout &lt;&lt; "NO" &lt;&lt; '\n';
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача B. Возрастающий -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Возрастающий</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам дан массив a из n целых положительных чисел. Определите, можно ли, переставив элементы, сделать массив строго возрастающим. Другими словами, определите, можно ли переставить элементы так, чтобы выполнялось условие a₁ &lt; a₂ &lt; ⋯ &lt; aₙ.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит число t (1 ≤ t ≤ 100) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора содержит число n (1 ≤ n ≤ 100) — количество элементов в массиве.</p>

  <p>Вторая строка каждого набора содержит n чисел aᵢ (1 ≤ aᵢ ≤ 10⁹) — элементы массива.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора выведите «YES» (без скобок), если массив удовлетворяет условию, и «NO» (без скобок) в противном случае.</p>

  <p>Вы можете вывести ответ в любом регистре (например, строки «YEs», «Yes», «Yes» и «YES» будут считаться как положительный ответ).</p>

  <details>
    <summary>Пример</summary>
<pre>
3
4
1 1 1 1
5
8 7 1 3 4
1
5
</pre>
<pre>
NO
YES
YES
</pre>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;set&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // размер массива
    cin >> n;

    // решение
    set&lt;int&gt; st;
    for (int i = 0; i &lt; n; i++) {
      int x; // следующее число
      cin >> x;
      st.insert(x);
    }

    // вывод результата
    if (st.size() == n) {
      cout &lt;&lt; "YES";
    } else {
      cout &lt;&lt; "NO";
    }
    cout &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача C. Полосы -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Полосы</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В матрице размером 8x8 некоторые строки были покрашены в красный цвет и некоторые столбцы — в синий в некотором порядке. Покраски проводились последовательно, одна за другой. Когда осуществлялась очередная покраска она красила все клетки, по которым проходила.</p>

  <p>Определите, какой цвет был использован последним.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит число t (1 ≤ t ≤ 4000) — количество наборов входных данных. Далее следует описание наборов. Перед каждым набором находится пустая строка.</p>

  <p>Каждый набор состоит из 8 строк, каждая из которых содержит 8 символов. Каждым из этих символов является либо 'R', либо 'B', либо '.', обозначая красный квадрат, синий квадрат и неокрашенный квадрат, соответственно.</p>

  <p>Гарантируется, что заданное поле получено из бесцветного путем рисования красных строк и синих столбцов.</p>

  <p>Как минимум одна покраска была осуществлена.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора выведите 'R', если последней покрашенной полосой была красная, и 'B', если последней покрашенной полосой была синяя без кавычек).</p>

  <details>
    <summary>Пример</summary>
<pre>
4

....B...
....B...
....B...
RRRRRRRR
....B...
....B...
....B...
....B...

RRRRRRRB
B......B
B......B
B......B
B......B
B......B
B......B
RRRRRRRB

RRRRRRBB
.B.B..BB
RRRRRRBB
.B.B..BB
.B.B..BB
RRRRRRBB
.B.B..BB
.B.B..BB

........
........
........
RRRRRRRR
........
........
........
........
</pre>
<pre>
R
B
B
R
</pre>
  </details>
</article>


<!-- Задача D. Взаимно простые -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Взаимно простые</h3>

  <div><i>Ограничение по времени 3с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Дан массив из n целых положительных чисел a1,a2,…,an (1 ≤ ai ≤ 1000). Выведите максимальное значение i+j такое, что ai и aj взаимно простые†, или -1, если таких i и j не существует.</p>

  <p>Например, рассмотрим массив [1,3,5,2,4,7,7]. Максимальное значение i+j, которое можно получить, равно 5+7, так как a5=4 и a7=7 являются взаимно простые.</p>

  <p>† Два целых числа p и q являются взаимно простыми, если единственное положительное целое число, которое является делителем их обоих, равно 1 (их наибольший общий делитель равен 1).</p>

  <h4>Входные данные</h4>
  <p>Входные данные состоят из нескольких наборов. Первая строка содержит целое число t (1 ≤ t ≤ 10) — количество наборов. Далее следует их описание.</p>

  <p>Первая строка каждого набора содержит целое число n (2 ≤ n ≤ 2⋅10⁵) — количество элементов в массиве.</p>

  <p>Следующая строка содержит n разделенных пробелами положительных чисел a1, a2,..., an (1 ≤ ai ≤ 1000) — элементы массива.</p>

  <p>Гарантируется, что сумма n по всем тестовым случаям не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора выведите одно целое число  — максимальное значение i+j, такое, что i и j удовлетворяют условию, что ai и aj взаимно просты, или выведите -1, если не существует таких i и j.</p>

  <details>
    <summary>Пример</summary>
<pre>
6
3
3 2 1
7
1 3 5 2 4 7 7
5
1 2 3 4 5
3
2 2 4
6
5 4 3 15 12 16
5
1 2 2 3 6
</pre>
<pre>
6
12
9
-1
10
7
</pre>
  <p>Для первого примера можно выбрать i=j=3, при этом сумма индексов равна 6, так как 1 и 1 - взаимно простые.</p>
  <p>Для второго примера можно выбрать i=7 и j=5, при этом сумма индексов равна 7+5=12, так как 7 и 4 являются взаимно простыми.</p>
  </details>
</article>


<!-- Задача E. Scuza -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Scuza</h3>

  <div><i>Ограничение по времени 3с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У Тимура есть лестница с n ступеньками. Ступенька i выше предыдущей на ai метров. Первая ступенька на a1 метр выше земли, а земля находится на высоте 0 метров.</p>

  <p>У Тимура есть q запросов, каждый из которых обозначается целым числом k1,…,kq. Для каждого запроса ki выведите максимально возможную высоту, на которую Тимур может подняться, поднимаясь по ступенькам, если длина его ног ki. Тимур может подняться на j-ю ступеньку только в том случае, если длина его ног не меньше aj. Другими словами, ki≥aj для каждой ступеньки j.</p>

  <p>Обратите внимание, что вы должны ответить на каждый вопрос независимо.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно целое число t (1 ≤ t ≤ 100) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора содержит два целых числа n,q (1 ≤ n, q ≤ 2⋅10⁵) — количество ступенек и количество запросов, соответственно.</p>

  <p>Вторая строка каждого набора содержит n целых чисел (1 ≤ ai ≤ 10⁹) — разницы в высотах ступенек.</p>

  <p>Третья строка каждого теста содержит q целых чисел (0 ≤ ki ≤ 10⁹) — числа для каждого запроса.</p>

  <p>Гарантируется, что сумма n не превышают 2⋅10⁵, сумма q не превышают 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора выведите q целых чисел - ответ на каждый запрос.</p>

  <p>Обратите внимание, что ответ на некоторые запросы не помещается в 32-битный целочисленный тип, поэтому вы должны использовать как минимум 64-битный целочисленный тип в вашем языке программирования (например, long long для C++).</p>

  <details>
    <summary>Пример</summary>
<pre>
3
4 5
1 2 1 5
1 2 4 9 10
2 2
1 1
0 1
3 1
1000000000 1000000000 1000000000
1000000000
</pre>
<pre>
1 4 4 9 9
0 2
3000000000
</pre>
  <p>Рассмотрим первый пример, изображенный в условии.</p>
  <ul>
    <li>Если длина ног Тимура 1, то он может подняться только на ступеньку 1, поэтому максимальная высота, на которую он может забраться это 1 метр.</li>
    <li>Если длина ног Тимура 2 или 4, то он может подняться только по ступенькам 1, 2 и 3, поэтому максимальная высота, на которую он может забраться это 1+2+1=4 метра.</li>
    <li>Если длина ног Тимура составляет 9 или 10, то он может подняться по всей лестнице, так максимальная высота, на которую он может забраться это 1+2+1+5=9 метров.</li>
  </ul>
  <p>В первом вопросе второго тестового примера у Тимура нет ног, поэтому он не может подняться даже на одну ступеньку. :(</p>
  </details>
</article>


<!-- Задача F. Меньше -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Меньше</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У Альперена есть две строки, s и t, которые обе изначально равны «a».</p>

  <p>Он выполнит q операций двух видов над данными строками:</p>
  <ul>
    <li>1 k x — Добавить строку x ровно k раз в конец строки s. Другими словами, s:=s+x+⋯+x (k times).</li>
    <li>2 k x — Добавить строку x ровно k раз в конец строки t. Другими словами, t:=t+x+⋯+x (k times).</li>
  </ul>

  <p>После каждой операции определите, можно ли переставить символы s
  и t так, чтобы s была лексикографически меньше †, чем t.</p>

  <p>Обратите внимание, что строки изменяются после выполнения каждой операции и не возвращаются в исходное состояние.</p>

  <p>† Проще говоря, лексикографический порядок - это порядок, в котором слова перечислены в словаре. Формальное определение таково: строка p лексикографически меньше строки q, если существует позиция i такая, что pi &lt; qi, и для всех j &lt; i, pj=qj. Если такой позиции i не существует, то p лексикографически меньше q, если длина p меньше длины q. Например, abdc &lt; abe и abc &lt; abcd, где мы пишем p &lt; q, если p лексикографически меньше q.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора содержит целое число q (1 ≤ q ≤ 10⁵) — количество операций, которые будет выполнять Alperen.</p>

  <p>Затем следуют q строк, каждая из которых содержит два положительных целых числа d и k (1 ≤ d ≤ 2; 1 ≤ k ≤ 10⁵) и непустую строку x, состоящую из строчных английских букв — тип операции, количество раз, которое мы будем добавлять к строке x и строку, которую нужно добавить соответственно.</p>

  <p>Гарантируется, что сумма q по всем наборам не превышает 10⁵ и что сумма длин всех строк x из входных данных не превышает 5⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждой операции выведите «YES», если возможно расположить элементы в обеих строках таким образом, что s будет лексикографически меньше t и «NO» в противном случае.</p>

  <details>
    <summary>Пример</summary>
<pre>
3
5
2 1 aa
1 2 a
2 3 a
1 2 b
2 3 abca
2
1 5 mihai
2 2 buiucani
3
1 5 b
2 3 a
2 4 paiu
</pre>
<pre>
YES
NO
YES
NO
YES
NO
YES
NO
NO
YES
</pre>
  <p>В первом примере строки изначально являются s=«a» и t=«a».</p>

  <p>После первой операции строка t становится «aaa». Поскольку «a» уже лексикографически меньше, чем «aaa», ответом на эту операцию должно быть «YES».</p>

  <p>После второй операции строка s становится «aaa», а поскольку t также равна «aaa», мы не можем переставить символы s так, чтобы она была лексикографически меньше t, поэтому ответ «NO».</p>

  <p>После третьей операции строка t становится «aaaaaa», а s уже лексикографически меньше нее, поэтому ответом будет «YES».</p>

  <p>После четвертой операции s становится «aaabb» и нет способа сделать ее лексикографически меньше, чем «aaaaaa», поэтому ответ «NO».</p>

  <p>После пятой операции строка t становится «aaaaaaabcaabcaabca», и мы можем переставить символы в строках так: «bbaaa» и «caaaaaabcaabcaabaa», так что s будет лексикографически меньше t, поэтому мы должны ответить «YES».</p>
  </details>
</article>


<!-- Задача G. Оррэй -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Оррэй</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам дан массив a, состоящий из n неотрицательных целых чисел.</p>

  <p>Определим массив префиксного ИЛИ b как массив bi=a1 OR a2 OR … OR ai, где OR представляет собой битовую операцию ИЛИ. Другими словами, массив b формируется путем вычисления OR каждого префикса a.</p>

  <p>Вас попросили переставить элементы массива a
   таким образом, чтобы массив префиксных OR был лексикографически максимальным.</p>

  <p>Массив x лексикографически больше массива y, если в первой позиции, где x и y отличаются, xi>yi.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит одно целое число t
   (1 ≤ t ≤ 100) — количество наборов входных данных. Далее следует описание наборов.</p>

  <p>Первая строка каждого набора содержит одно целое число n  (1 ≤ n ≤ 2⋅10⁵) — количество элементов в массиве a.</p>

  <p>Вторая строка каждого набора содержит n неотрицательных целых чисел a1,…,an (0 ≤ ai ≤ 10⁹).</p>

  <p>Гарантируется, что сумма n по всем наборам не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора выведите n целых чисел — любую перестановку массива a, при которой получается лексикографически максимальный массив префиксных OR.</p>

  <details>
    <summary>Пример</summary>
<pre>
5
4
1 2 4 8
7
5 1 2 3 4 5 5
2
1 101
6
2 3 4 2 3 4
8
1 4 2 3 4 5 7 1
</pre>
<pre>
8 4 2 1
5 2 1 3 4 5 5
101 1
4 3 2 2 3 4
7 1 4 2 3 4 5 1
</pre>
  </details>
</article>
