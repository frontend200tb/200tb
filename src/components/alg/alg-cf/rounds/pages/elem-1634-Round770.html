<article class="article">
  <a href="https://codeforces.com/contest/1634" target="_blank">Codeforces 1634 Round 770 (Div. 2) 2022-02-06</a>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

      <a href="#task1">Задача A. Разворачивай и конкатенируй</a>
  <br><a href="#task2">Задача B. Гадание на массиве</a>
  <br><a href="#task3">Задача C. ОКЕЯ</a>
  <br><a href="#task4">Задача D. В поисках нуля</a>
  <br><a href="#task5">Задача E. Честный делёж</a>
  <br><a href="#task6">Задача F. Прибавления Фибоначчи</a>
</article>


<!-- Задача A. Разворачивай и конкатенируй -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Разворачивай и конкатенируй</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам дана строка s длины n и число k. Обозначим за rev(s) развёрнутую строку s (т.е. rev(s)=s<sub>n</sub>s<sub>n-1</sub>...s<sub>1</sub>). Вы можете выполнять два типа операций:</p>
  <ul>
    <li>заменить строку s на s+rev(s)</li>
    <li>заменить строку s на rev(s)+s</li>
  </ul>

  <p>После выполнения ровно k операций (возможно, различных) над строкой, какое количество различных строк вы можете получить из начальной строки s?</p>

  <p>Мы обозначили конкатенацию строк s и t как s+t. Другими словами, s+t = s₁s₂...sₙt₁t₂...tₘ, где n и m - длины строк s и t соответственно.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит число t (1 ≤ t ≤ 100) — количество наборов входных данных.</p>

  <p>В следующих 2⋅t строках вводится t наборов входных данных:</p>

  <p>Первая строка каждого набора содержит два числа n и k (1 ≤ n ≤ 100, 0 ≤ k ≤ 1000).</p>

  <p>Вторая строка каждого набора содержит одну строку s длины n, состоящую из строчных латинских букв.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных в отдельной строке выведите количество различных строк, которые вы можете получить после применения ровно k операций.</p>

  <p>Можно показать, что при данных ограничениях ответ не превосходит 10⁹.</p>

  <details>
    <summary>Пример</summary>
<pre>
4
3 2
aab
3 3
aab
7 1
abacaba
2 0
ab
</pre>
<pre>
2
2
1
1
</pre>
  <p>Рассмотрим первый набор входных данных:</p>
  <p>После первой операции строка s может стать либо aabbaa, либо baaaab. После второй операции s может принимать только такие 2 значения: aabbaaaabbaa и baaaabbaaaab.</p>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

bool isPalindrome(string str) {
  int pl = 0;
  int pr = str.size() - 1;
  while (pr > pl) {
    if (str[pl] != str[pr]) {
      return false;
    }
    pl++;
    pr--;
  }
  return true;
}

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n, k;
    cin >> n >> k;
    string s;
    cin >> s;

    // решение
    int res = 0;
    if (k == 0 || isPalindrome(s)) {
      res = 1;
    } else {
      res = 2;
    }

    // вывод результата
    cout &lt;&lt; res &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача B. Гадание на массиве -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Гадание на массиве</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Ваши друзья Алиса и Боб практикуют гадания.</p>

  <p>Гадание производится следующим образом: есть хорошо всем известный массив a из n неотрицательных целых чисел, пронумерованных от 1 до n. Клиент выбирает некоторое неотрицательное число d, а затем последовательно применяет одну из двух операций для каждого i=1,2,…,n, в возрастающем порядке i. Возможные операции таковы:</p>
  <ul>
    <li>текущее число d заменяется на d+aᵢ</li>
    <li>текущее число d заменяется на d⊕aᵢ (здесь и далее ⊕ обозначает побитовое исключающее или)</li>
  </ul>
  <p>Обратите внимание, что выбранная операция может быть разной для разных i и разных клиентов.</p>

  <p>Однажды Алиса выбрала d=x, а Боб выбрал d=x+3. Каждый из них сходил к гадалке и в конце концов получил какое-то число. Заметьте, что Алиса и Боб выбирают операции независимо, иначе говоря, для каких-то i они могли выбирать как одну операцию, так и разные.</p>

  <p>Вы каким-то образом узнали, что то ли Алиса, то ли Боб в итоге получили число y, но кто именно — неизвестно. Ваша задача — зная числа, с которых начали Алиса и Боб, узнать, кто же из них получил в итоге число y. Гарантируется, что на тестах жюри ровно один из ваших друзей мог получить y.</p>

  <h4>Взломы</h4>
  <p>Вы не можете делать взломы по этой задаче.</p>

  <h4>Входные данные</h4>
  <p>В первой строке дано число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных. В следующих 2⋅t строках даны наборы входных данных.</p>

  <p>Первая строка набора содержит три числа n, x, y (1 ≤ n ≤ 10⁵, 0 ≤ x ≤ 10⁹, 0 ≤ y ≤ 10¹⁵) — длина массива a, начальное число Алисы (число Боба равно x+3) и число, которое получил один из друзей в результате.</p>

  <p>Вторая строка набора содержит n чисел — массив a (0 ≤ aᵢ ≤ 10⁹).</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превосходит 10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите «Alice» или «Bob» (без кавычек) — кто из друзей мог получить из своего начального числа число y.</p>

  <details>
    <summary>Пример</summary>
<pre>
4
1 7 9
2
2 0 2
1 3
4 0 1
1 2 3 4
2 1000000000 3000000000
1000000000 1000000000
</pre>
<pre>
Alice
Alice
Bob
Alice
</pre>
  <p>В первом наборе входных данных Алиса могла получить 9 с помощью следующих операций: 7+2=9.</p>
  <p>Во втором наборе Алиса могла получить 2 с помощью таких операций: (0+1)⊕3=2.</p>
  <p>В третьем наборе Боб изначально имел число x+3=0+3=3. Тогда он мог получить 1 таким образом: (((3+1)+2)⊕3)⊕4=1.</p>
  </details>
</article>


<!-- Задача C. ОКЕЯ -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. ОКЕЯ</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вы работаете в известном универмаге, который использует передовые технологии и машинный труд — а, иначе говоря, роботов!</p>

  <p>Отдел, в котором вы работаете, продает n⋅k товаров. Первый товар стоит 1 доллар, второй — 2 доллара, и так далее: i-й товар стоит i долларов. Товары расположены на полках и образуют прямоугольную сетку: на каждой из n полок расположено по k товаров. Мы будем обозначать цену j-го товара (считая слева направо) на i-й полке за a<sub>i,j</sub>, 1 ≤ i ≤ n, 1 ≤ j ≤ k.</p>

  <p>Время от времени роботы задумываются над следующим вопросом: какое среднее арифметическое цен товаров a<sub>i,l</sub>,a<sub>i,l+1</sub>,…,a<sub>i,r</sub> для некоторой полки i и индексов l ≤ r? К сожалению, старые роботы умеют работать только с целыми числами, и если средняя цена оказывается нецелым числом, они ломаются.</p>

  <p>Вы заботитесь о благосостоянии роботов и потому хотите упорядочить товары так, чтобы роботы не могли сломаться. Формально, вы хотите найти такой двумерный массив a, что:</p>
  <ul>
    <li>Каждое число от 1 до n⋅k (включительно) встречается в массиве ровно один раз.</li>
    <li>Для всех i,l,r средняя цена товаров с l-го по r-й на i-й полке — целое число.</li>
  </ul>

  <p>Выясните, возможно ли такое расположение товаров, и если да, приведите любой подходящий пример.</p>

  <h4>Входные данные</h4>
  <p>В первой строке дано одно число t (1 ≤ t ≤ 500) — количество наборов входных данных.</p>

  <p>Первая и единственная строка каждого набора содержит два числа n и k (1 ≤ n, k ≤ 500) — количество полок и длина каждой из них соответственно.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превосходит 500, и сумма k по всем наборам не превосходит 500.</p>

  <h4>Выходные данные</h4>
  <p>Выведите ответ для каждого набора входных данных:</p>

  <p>Если подходящая расстановка существуют, выведите «YES» в отдельной строке. Далее в n строках выведите по k чисел — цены товаров на каждой из полок. Каждое число от 1 до n⋅k должно встречаться ровно один раз.</p>

  <p>Если ответа не существует, то выведите единственное слово «NO» в отдельной строке.</p>

  <details>
    <summary>Пример</summary>
<pre>
4
1 1
2 2
3 3
3 1
</pre>
<pre>
YES
1
YES
1 3
2 4
NO
YES
1
2
3
</pre>
  </details>
</article>


<!-- Задача D. В поисках нуля -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. В поисках нуля</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Это интерактивная задача.</p>

  <p>Мы загадали массив a1, a2, …, an (0 ≤ ai ≤ 10⁹) и спрятали в нём один ноль! Более формально, среди чисел массива ровно одно значение равно нулю.</p>

  <p>Ваша задача — найти, под каким индексом спрятан ноль, то есть найти такое i, что ai=0.</p>

  <p>Для этого вы можете сделать некоторое количество запросов следующего вида. По трём различным индексам i,j,k вы можете узнать значение выражения max(ai,aj,ak)-min(ai,aj,ak). Другими словами, мы сообщим вам разность между максимальным и минимальным числом среди ai, aj и ak.</p>

  <p>Вы можете сделать не более 2⋅n-2 таких запросов, после чего у вас будет две попытки угадать, под каким индексом спрятан ноль. Формально, вы должны сообщить нам два числа i и j, и ваш ответ будет считаться правильным, если ai=0 или aj=0.</p>

  <p>Сможете ли вы угадать, где мы спрятали ноль?</p>

  <p>Обратите внимание, что в каждом тесте массив фиксирован и не изменяется во время игры. Иными словами, интерактор не адаптивен.</p>

  <h4>Входные данные</h4>
  <p>Каждый тест содержит несколько наборов входных данных. Первая строка содержит единственное число t (1≤t≤500). Далее следует описание наборов.</p>

  <p>В первой и единственной строке каждого набора входных данных записано целое число n (4≤n≤1000) — длина загаданного массива.</p>

  <p>Гарантируется, что сумма n по всем наборам не превосходит 3000.</p>

  <h4>Протокол взаимодействия</h4>
  <p>Взаимодействие начинается со считывания n в начале каждого набора входных данных.</p>

  <p>Чтобы задать запрос, выведите «? i j k» (без кавычек, 1≤i,j,k≤n, индексы должны быть различны). Затем вы должны считать ответ, который будет равен max(ai,aj,ak)-min(ai,aj,ak).</p>

  <p>Ответ -1 означает, что ваша программа сделала некорректный запрос. Ваша программа должна немедленно завершиться после прочтения ответа -1, и вы получите вердикт Неправильный ответ. В противном случае вы можете получить любой вердикт, так как программа продолжит чтение из закрытого потока. Обратите внимание, что если запрос корректный, ответ на него никогда не будет равен -1, так как max(ai,aj,ak)-min(ai,aj,ak)≥0.</p>

  <p>Чтобы дать ответ, выведите «! i j» (без кавычек). Вывод одного и того же индекса дважды (то есть i=j) разрешен. Заметьте, что вывод ответа не считается одним из 2⋅n-2 запросов. После этого ваша программа должна продолжить обработку следующих наборов входных данных, либо завершиться, если наборов не осталось.</p>

  <p>После вывода каждого запроса не забудьте вывести перевод строки и сбросить буфер вывода. В противном случае вы получите вердикт Решение «зависло». Для сброса буфера используйте:</p>
  <ul>
    <li>fflush(stdout) или cout.flush() в C++;</li>
    <li>System.out.flush() в Java;</li>
    <li>flush(output) в Pascal;</li>
    <li>stdout.flush() в Python;</li>
    <li>смотрите документацию для других языков.</li>
  </ul>

  <h4>Взломы</h4>

  <p>Первая строка должна содержать целое число t (1 ≤ t ≤ 500) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных должна содержать целое число n (4 ≤ n ≤ 1000) — длину загаданного массива.</p>

  <p>Вторая строка каждого набора должна содержать n целых чисел, разделенных пробелами — a1,a2,…,an (0 ≤ ai ≤ 10⁹). Также в этом массиве должен быть ровно один ноль.</p>

  <p>Сумма n по всем наборам не должна превосходить 3000.</p>

  <details>
    <summary>Пример</summary>
<pre>
1

4

2

3

3

2
</pre>
<pre>


? 1 2 3

? 2 3 4

? 3 4 1

? 4 1 2

! 2 3
</pre>
  <p>Массив из теста из примера: [1,2,0,3].</p>
  </details>
</article>


<!-- Задача E. Честный делёж -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Честный делёж</h3>

  <div><i>Ограничение по времени 1.5с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам дано m массивов целых положительных чисел, длина каждого массива чётна.</p>

  <p>От вас требуется составить два равных мультимножества L
  и R так, чтобы каждый элемент каждого массива попал ровно в одно мультимножество. Кроме того, для каждого из m массивов ровно половина его элементов должна попасть в L, а остальные — в R.</p>

  <p>Приведите пример такого разбиения или определите, что такого разбиения не существует.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое число m (1 ≤ m ≤ 10⁵) — количество массивов.</p>

  <p>В следующих 2⋅m строках даны описания массивов.</p>

  <p>В описании каждого массива первая строка содержит чётное число n (2 ≤ n ≤ 2⋅10⁵) — длина массива. Во второй строке через пробел перечислены n
  целых чисел a1,a2,…,an (1 ≤ ai ≤ 10⁹) — элементы массива.</p>

  <p>Гарантируется, что сумма n по всем массивам не превосходит 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>В случае если ответ существует выведите «YES», а затем выведите m
  строк.</p>

  <p>В каждой строке для каждого элемента выведите букву «L» или «R» (обязательно заглавную, без пробелов) — в какое мультимножество должен попасть данный элемент.</p>

  <p>Если ответа не существует, в единственной строке выведите «NO».</p>

  <details>
    <summary>Пример</summary>
<pre>
3
2
1 2
4
1 2 3 3
6
1 1 2 2 3 3
</pre>
<pre>
YES
RL
LRLR
RLLRRL
</pre>
  <p>В первом массиве первый элемент мы добавляем в R, а второй в L. Сейчас L={2}, а R={1}.</p>
  <p>Во втором массиве первый и третий элемент мы добавляем в L, а остальные в R. Сейчас L={1,2,3} и R={1,2,3}.</p>
  <p>В третьем массиве элементы 2, 3 и 6 мы добавляем в L, а на остальных — в R. В итоге L=R={1,1,2,2,3,3}.</p>
  </details>
</article>


<!-- Задача F. Прибавления Фибоначчи -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Прибавления Фибоначчи</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Прибавление Фибоначчи — это операция на массиве X целых чисел, параметризованная индексами l и r. При применении этой операции к X<sub>l</sub> прибавляется F<sub>1</sub>, к X<sub>l+1</sub> прибавляется F<sub>2</sub>, и так далее, вплоть до числа X<sub>r</sub>, которое увеличивается на F<sub>r-l+1</sub>.</p>

  <p>Здесь Fi — это i-е число Фибоначчи (F1=1, F2=1, Fi=Fi-1+Fi-2 для i>2), и все операции производятся по модулю MOD.</p>

  <p>Вам даны массивы A и B одинаковой длины. Мы просим вас применить к этим массивам несколько операций прибавления Фибоначчи с разными параметрами. После каждой операции вы должны сообщить, равны ли массивы A и B (по модулю MOD).</p>

  <h4>Входные данные</h4>
  <p>В первой строке вводится 3 числа n, q и MOD (1 ≤ n, q ≤ 3⋅10⁵, 1 ≤ MOD ≤ 10⁹+7) — длина массивов, количество операций и модуль, по которому выполняются все операции.</p>

  <p>Во второй строке находится n чисел — массив A (0 ≤ Ai &lt; MOD).</p>

  <p>В третей строке находится n чисел — массив B (0 ≤ Bi &lt; MOD).</p>

  <p>В последующих q строках находится символ c и два числа l и r (1 ≤ l ≤ r ≤ n) — параметры операции. Символ c, равный «A», означает, что прибавление Фибоначчи нужно применить к массиву A, равный «B» — к массиву B.</p>

  <h4>Выходные данные</h4>
  <p>После каждой операции выведите «YES» (без кавычек), если массивы равны, и «NO» иначе. Ответ можно выводить в любом регистре.</p>

  <details>
    <summary>Примеры</summary>
  <h4>Пример 1</h4>
<pre>
3 5 3
2 2 1
0 0 0
A 1 3
A 1 3
B 1 1
B 2 2
A 3 3
</pre>
<pre>
YES
NO
NO
NO
YES
</pre>

  <h4>Пример 2</h4>
<pre>
5 3 10
2 5 0 3 5
3 5 8 2 5
B 2 3
B 3 4
A 1 2
</pre>
<pre>
NO
NO
YES
</pre>
  <p>Пояснение к тесту из условия:</p>
  <ul>
    <li>Изначально A=[2,2,1], B=[0,0,0].</li>
    <li>После операции «A 1 3»: A=[0,0,0], B=[0,0,0] (сложение производится по модулю 3).</li>
    <li>После операции «A 1 3»: A=[1,1,2], B=[0,0,0].</li>
    <li>После операции «B 1 1»: A=[1,1,2], B=[1,0,0].</li>
    <li>После операции «B 2 2»: A=[1,1,2], B=[1,1,0].</li>
    <li>После операции «A 3 3»: A=[1,1,0], B=[1,1,0].</li>
  </ul>
  </details>
</article>

