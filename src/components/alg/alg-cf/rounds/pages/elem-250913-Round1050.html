<article class="article">
  <a href="https://codeforces.com/contest/2148" target="_blank">Codeforces 2148 Round 1050 (Div. 4) 2025-09-13</a>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

      <a href="#task1">Задача A. Возвышенная последовательность</a>
  <br><a href="#task2">Задача B. Лазеры</a>
  <br><a href="#task3">Задача C. Тест на выносливость</a>
  <br><a href="#task4">Задача D. Уничтожение полей одуванчиков</a>
  <br><a href="#task5">Задача E. Разделение</a>
  <br><a href="#task6">Задача F. Гравити Фолз</a>
  <br><a href="#task7">Задача G. Последнее желание фермера Джона</a>
</article>


<!-- Задача A. Возвышенная последовательность -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Возвышенная последовательность</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int x; // целое число
    int n; // длина последовательности
    cin >> x >> n;

    // решение и вывод результата
    if (n % 2 == 0) {
      cout &lt;&lt; 0 &lt;&lt; '\n';
    } else {
      cout &lt;&lt; x &lt;&lt; '\n';
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача B. Лазеры -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Лазеры</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // число горизонтальных лазеров
    int m; // число вертикальных лазеров
    int x, y; // координаты конечной точки
    cin >> n >> m >> x >> y;
    int tmp;

    // нам не важны координаты лазеров,
    // потому что мы должны пересечь их все
    // поэтому просто считываем их во временную переменную
    for (int i = 0; i &lt; n + m; i++) {
      cin >> tmp;
    }

    // решение и вывод результата
    cout &lt;&lt; n + m &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача C. Тест на выносливость -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Тест на выносливость</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);
  cout.tie(0);

  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // число требований
    int m; // число минут
    cin >> n >> m;

    vector&lt;int&gt; A(n+1);
    // A[i] - минута команды i
    vector&lt;int&gt; B(n+1);
    // B[i] - на какой стороне надо находиться в минуту A[i]
    for (int i = 1; i &lt;= n; i++) {
      cin >> A[i] >> B[i];
    }

    // решение
    bool side = 0; // на какоей стороне зала Фермер Джон
    int cnt = 0; // число баллов
    int minute = 0; // текущая минута

    // переберем все команды
    for (int i = 1; i &lt;= n; i++) {
      if ( (A[i] - minute) % 2 == 0) {
        // если до следующей команды четное число минут
        if (side == B[i]) {
          // если ФД уже на той стороне на которую должен попасть
          // добавляем все минуты
          cnt += A[i] - minute;
        } else {
          // если ФД на другой стороне
          // одну минуту придется подождать
          cnt += A[i] - minute - 1;
          side = !side;
        }
      } else {
        // если до следующей команды нечетное число минут
        if (side == B[i]) {
          // если ФД уже на той стороне на которую должен попасть
          // одну минуту придется подождать
          cnt += A[i] - minute - 1;
        } else {
          // если ФД на другой стороне
          // добавляем все минуты
          cnt += A[i] - minute;
          side = !side;
        }
      }
      minute = A[i];
    }

    // если еще остались минуты
    cnt += m - A[n];

    // вывод результата
    cout &lt;&lt; cnt &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача D. Уничтожение полей одуванчиков -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Уничтожение полей одуванчиков</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <details>
    <summary>Решение</summary>
    <h4>Пример 2</h4>
<pre>
1
8
1 3 5 7 9 11 13 15
</pre>
    <code>48</code>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);
  cout.tie(0);

  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // число полей
    cin >> n;

    vector&lt;long long&gt; A; // поля с четным числом одуванчиков
    // A[i] - число одуванчиков на i-м поле
    vector&lt;long long&gt; B; // поля с нечетным числом одуванчиков
    // B[i] - число одуванчиков на i-м поле
    long long in; // число одуванчиков на следующем поле
    for (int i = 0; i &lt; n; i++) {
      cin >> in;
      if (in % 2 == 0) {
        A.push_back(in);
      } else {
        B.push_back(in);
      }
    }

    // решение
    bool mode = 0;
    // состояние газонокосилки
    // 0 - выключенная
    // 1 - включенная
    long long cnt = 0; // число срезанных одуванчиков

    // отсортируем поля B, потому что газонокосилка
    // на одном поле будет включаться, на другом выключаться
    // пусть выключалается на полях с минимальным числом одуванчиков
    sort(B.begin(), B.end());

    // сначала нужно включить газонокасилку
    // для этого надо посетить поле B с макс числом одуванчиков
    if (B.size() > 0) {
      cnt += B[B.size() - 1];
      mode = !mode;
    }

    // пока газонокосилка включена срежем все одуванчики на полях A
    for (int i = 0; mode && i &lt; A.size(); i++) {
      cnt += A[i];
    }

    // метод двух указателей
    int p1 = 0;
    int p2 = B.size() - 2;
    while (p2 >= p1) {
      if (mode) {
        p1++;
      } else {
        cnt += B[p2--];
      }
      mode = !mode;
    }

    // вывод результата
    cout &lt;&lt; cnt &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача E. Разделение -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Разделение</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;map&gt;

using namespace std;

int main() {
  // ускорение ввода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // длина массива
    int k; // число мультимножеств
    cin >> n >> k;
    vector&lt;int&gt; A(n);
    for (int i = 0; i &lt; n; i++) {
      cin >> A[i];
    }

    // решение
    long long cnt = 0; // число потрясающих подмассивов
    bool flag = true; // можно собрать подмассив
    map&lt;int, int&gt; Freq;
    pair&lt;int, int&gt; tmp;

    // сохраним массив в частотный словарь
    for (int i = 0; i &lt; n; i++) {
      if (Freq.find(A[i]) == Freq.end()) {
        tmp.first = A[i];
        tmp.second = 1;
        Freq.insert(tmp);
      } else {
        Freq[A[i]]++;
      }
    }

    // макс число одинаковых элементов в подмассиве
    vector&lt;int&gt; Count_el_ok(n + 1);

    // чтобы можно было создать потрясающий подмассив
    // каждое число в массиве должно встречаться
    // число раз которое делится на k
    for (auto el : Freq) {
      if (el.second % k != 0) {
        flag = false;
      }
      Count_el_ok[el.first] = el.second / k;
    }

    vector&lt;long long&gt; Buf(n + 1);
    // метод двух указателей
    int l = 0;
    for (int r = 0; flag && r &lt; n; r++) {
      Buf[A[r]]++;
      while (Buf[A[r]] > Count_el_ok[A[r]]) {
        Buf[A[l]]--;
        l++;
      }
      cnt += r - l + 1;
    }

    // вывод результата
    cout &lt;&lt; cnt &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача F. Гравити Фолз -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Гравити Фолз</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ускорение ввода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // число массивов
    cin >> n;
    int k = 0; // длина массива, для каждого разная
    int k_max = 0; // максимальная длина массива

    vector&lt;vector&lt;int&gt; &gt; A(n);
    for (int i = 0; i &lt; n; i++) {
      cin >> k;
      if (k > k_max) {
        k_max = k;
      }
      A[i].resize(k);
      for (int j = 0; j &lt; k; j++) {
        cin >> A[i][j];
      }
    }

    // решение
    vector&lt;int&gt; Res;
    bool flag = true;

    while (flag) {
      flag = false;
      vector&lt;vector&lt;int&gt; &gt; Buf;
      vector&lt;int&gt; H;
      for (int i = 0; i &lt; n; i++) {
        if (A[i].size() > Res.size()) {
          Buf.push_back(H);
          for (int j = Res.size(); j &lt; A[i].size(); j++) {
            Buf[Buf.size() - 1].push_back(A[i][j]);
          }
        }
      }
      if (Buf.size() != 0) {
        flag = true;
        sort(Buf.begin(), Buf.end());
        for (int i = 0; i &lt; Buf[0].size(); i++) {
          Res.push_back(Buf[0][i]);
        }
      }
    }


    // вывод результата
    for (int i = 0; i &lt; Res.size(); i++) {
      cout &lt;&lt; Res[i] &lt;&lt; ' ';
    }
    cout &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача G. Последнее желание фермера Джона -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Последнее желание фермера Джона</h3>

  <div><i>Ограничение по времени 3с
  <br>Ограничение по памяти 256мб</i></div>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;set&gt;

using namespace std;
using ll = long long;
const int NMAX = 2 * 1e5 + 10;
int lp[NMAX];

void f() {
  // с помощью решета эратосфена найдем для каждого i, число p[i], которое будет содержать минимальный простой делитель числа i
  for (int i = 2; i &lt; NMAX; i++) {
    if (lp[i] == 0) {
      lp[i] = i;
      for (int j = i; j &lt; NMAX; j += i) {
        if (lp[j] == 0) {
          lp[j] = i;
        }
      }
    }
  }
}
void solve() {
  ll n;
  cin >> n;
  vector&lt;int&gt; ar(n);
  map&lt;pair&lt;int, int&gt;, int&gt; sl;
  for (int i = 0; i &lt; n; i++) {
    cin >> ar[i];
  }
  int maxi = 0;
  bool pflag = false;
  set&lt;pair&lt;int, int&gt; &gt; hh;
  // про GCD удобно думать про функцию с точки зрения простых делителей, то есть если мы знаем разложение двух чисел на простые множители и в первом числе простое число p входит в степени a1, а во второе в степени в a2, то в GCD оно будет входить в степени min(a1,a2)

  // тогда верен следующий факт, GCD на следующем префиксе стал меньше  степень какого-то простого делителя изменилась в нем(повыситься она не могла)
  // тогда пусть у нас есть какое то p^t которое встречается в k числах, мы можем поставить их все на префиксе, а дальше поставить какое то число, где p встречается в более меньшей степени и это нам подойдет так как GCD уменьшится


  // заметим что нам выгодно брать число p^t которое встречается в как можно большем колиечстве чисел, за исключением случая, когда оно встречается во всех числах, потому что тогда не будет момента, когда оно исчезнет

  for (int i = 0; i &lt; n; i++) {
    while (ar[i] != 1) {
      // быстро разложим число на простые множиели за O(количество простых множителей) с помощью массива lp
      int st = 0;
      int pr = lp[ar[i]];
      while (pr == lp[ar[i]]) {
        st++;
        ar[i] /= lp[ar[i]];
      }
      // далее обновивм в словаре для каждой пары p^t(храним ее как (p,t)) сколько раз она встречается(более того если встречается пара p^t, то мы будет считать что встретились и все меньшие пары p^0, p^1, ... , p^t-1, так как с помощью p^t, можно образовывать и такие цепочки тоже)
      for (int j = 0; j &lt;= st; j++) {
        sl[{pr, j}]++;
        if (sl[{pr, j}] != (i + 1)) {
          maxi = max(sl[{pr, j}], maxi);
        } else {
          hh.insert({ pr, j });
        }
      }
      // отдельно заведем set пар hh, который будет хранить те пары которые встретились настолько много раз, чтомы не можем их использовать на данном шаге(то есть i + 1 раз)
      // заметим что их будет не очень много так как это могут быть только степени простых делителей числа ar[0])
    }
    // обновим также ответ из set'а пар с максимальными значениями
    for (auto c : hh) {
      if (sl[{c.first, c.second}] != (i + 1)) {
        maxi = max(sl[{c.first, c.second}], maxi);
      }
    }
    cout &lt;&lt; maxi &lt;&lt; ' ';
  }
  cout &lt;&lt; '\n';
}

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(0);
  cout.tie(0);
  int t;
  cin >> t;
  f();
  //   t=1;
  while (t--) {
    solve();
  }
  return 0;
}
</pre>
  </details>
</article>

