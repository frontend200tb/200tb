<article class="article">
  <a href="https://codeforces.com/contest/1692" target="_blank">Codeforces 1692 Round 799 (Div. 4) 2022-06-14</a>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

      <a href="#task1">Задача A. Марафон</a>
  <br><a href="#task2">Задача B. Все различные</a>
  <br><a href="#task3">Задача C. Где слон?</a>
  <br><a href="#task4">Задача D. Часы</a>
  <br><a href="#task5">Задача E. Двоичный дек</a>
  <br><a href="#task6">Задача F. 3-Сумма</a>
  <br><a href="#task7">Задача G. 2^Сортировка</a>
  <br><a href="#task8">Задача H. Азартные игры</a>
</article>


<!-- Задача A. Марафон -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Марафон</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Тимур и три других человека участвуют в марафоне. Вам даны 4 различных целых числа a, b, c, d.</p>

  <p>Значение a соответствует расстоянию, которое пробежал Тимур, значения b, c, d соответствуют расстояниям, которые пробежали три других участника.</p>

  <p>Выведите число участников, пробежавших большее расстояние, чем Тимур.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных в тесте.</p>

  <p>Далее следуют описания наборов, каждое из них содержит ровно четыре различных целых числа a, b, c, d (0 ≤ a, b, c, d ≤ 10⁴).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора данных выведите единственное число — количество участников, пробежавших большее расстояние, чем Тимур.</p>

  <details>
    <summary>Пример</summary>
<pre>
4
2 3 4 1
10000 0 1 2
500 600 400 300
0 9999 10000 9998
</pre>
<pre>
2
0
1
3
</pre>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1692/problem/A" target="_blank">Задача 1692A</a>
      <br><a href="https://codeforces.com/contest/1692" target="_blank">Codeforces Round 799 (Div. 4) 2022-06-14</a>
    </div>

<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int a, b, c, d;
    cin >> a >> b >> c >> d;

    // решение
    int res = 0;
    if (b > a) res++;
    if (c > a) res++;
    if (d > a) res++;

    // вывод результата
    cout &lt;&lt; res &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача B. Все различные -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Все различные</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У Sho есть массив a состоящий из n целых чисел. За одну операцию Sho может выбрать два различных индекса i и j, после чего удалить из массива элементы ai и aj.</p>

  <p>Например, для массива [2,3,4,2,5] Sho может выбрать индексы 1 и 3 и удалить соответствующие элементы из массива. После этой операции массив будет выглядеть так: [3,2,5]. Заметьте, что после любой операции длина массива уменьшится на два.</p>

  <p>После нескольких операций у Sho остался массив, содержащий только различные числа. Также, он применил операции таким образом, что длина оставшегося массива максимальна из всех возможных.</p>

  <p>Более формально, после всех операций массив Sho удовлетворяет двум следующим критериям:</p>
  <ul>
    <li>В массиве не существует таких пар индексов, что i &lt; j и ai = aj.</li>
    <li>Длина массива a максимальна.</li>
  </ul>

  <p>Выведите длину оставшегося у Sho массива.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит целое число t (1 ≤ t ≤ 10³) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора данных содержит единственное число n (1 ≤ n ≤ 50) — длину начального массива.</p>

  <p>Вторая строка каждого набора данных содержит n целых чисел ai (1 ≤ ai ≤ 10⁴) — элементы начального массива.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора данных выведите единственное число — длину оставшегося массива. Помните, что в оставшемся массиве все элементы различны, а его длина максимальна.</p>

  <details>
    <summary>Пример</summary>
<pre>
4
6
2 2 2 3 3 3
5
9 1 9 9 1
4
15 16 16 15
4
10 100 1000 10000
</pre>
<pre>
2
1
2
4
</pre>
  <p>В первом наборе данных Sho может сделать следующие операции:</p>
  <ol>
    <li>Выбрать индексы 1 и 5. Тогда массив станет [2,2,2,3,3,3]→[2,2,3,3].</li>
    <li>Выбрать индексы 1 и 4. Тогда массив станет [2,2,3,3]→[2,3].</li>
  </ol>
  <p>Финальный массив имеет длину 2, так что ответом является 2. Можно доказать, что Sho не может получить массив большей длины. Во втором наборе данных Sho может сделать следующие операции:</p>
  <ol>
    <li>Выбрать индексы 3 и 4. Тогда массив станет [9,1,9,9,1]→[9,1,1].</li>
    <li>Выбрать индексы 1 и 3. Тогда массив станет [9,1,1]→[1].</li>
  </ol>
  <p>Финальный массив имеет длину 1, так что ответом является 1. Можно доказать, что Sho не может получить массив большей длины.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1692/problem/B" target="_blank">Задача 1692B</a>
      <br><a href="https://codeforces.com/contest/1692" target="_blank">Codeforces Round 799 (Div. 4) 2022-06-14</a>
    </div>

<pre>
#include &lt;iostream&gt;
#include &lt;set&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // длина массива
    cin >> n;
    set&lt;int&gt; A;
    int in;
    for (int i = 0; i &lt; n; i++) {
      cin >> in;
      A.insert(in);
    }

    // решение
    int res = 0;
    int m = A.size();

    if (m == n) {
      res = m;
    } else if ((n - m) % 2 == 0) {
      res = m;
    } else {
      res = m - 1;
    }

    // вывод результата
    cout &lt;&lt; res &lt;&lt; '\n';
  }

}
</pre>
  </details>
</article>


<!-- Задача C. Где слон? -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Где слон?</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У Михая есть шахматная доска размером 8x8, у которой ряды пронумерованы от 1 до 8 сверху вниз и столбцы пронумерованы от 1 до 8 слева направо.</p>

  <p>Михай поставил ровно одного слона на свою шахматную доску. Слон не находится на краях доски. (другими словами, ряд и столбец позиции слона находятся между 2 и 7 включительно.)</p>

  <p>Слон атакует по всем направлениям по диагонали, без ограничения на дистанцию на которой он атакует. Обратите внимание, что клетка на которой расположен слон тоже считается атакованной.</p>
  <p>Пример слона на доске. Атакованные клетки отмечены красным.</p>
  <p>Михай отметил все атакованные клетки, но забыл где находится слон. Помогите Михаю найти позицию слона!</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит единственное число t (1 ≤ t ≤ 36) — количество наборов входных данных. Далее следуют описание наборов. Перед каждым набором во входных данных записана пустая строка.</p>

  <p>Каждый набор состоит из 8 строк, в каждой по 8 символов. Каждый символ является или '#' или '.', обозначая атакованную клетку, или не атакованную соответственно.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора выведите два числа r и c (2≤r,c≤7) — ряд и столбец, на которых располагается слон.</p>

  <p>Гарантируется, что входные данные даны таким образом, что всегда существует единственное расположение слона, не находящееся на краях доски.</p>

  <details>
    <summary>Пример</summary>
<pre>
3

.....#..
#...#...
.#.#....
..#.....
.#.#....
#...#...
.....#..
......#.

#.#.....
.#......
#.#.....
...#....
....#...
.....#..
......#.
.......#

.#.....#
..#...#.
...#.#..
....#...
...#.#..
..#...#.
.#.....#
#.......
</pre>
<pre>
4 3
2 2
4 5
</pre>
  <p>Первый пример показан в условии. Так как слон находится на пересечении ряда 4 и столбца 3, правильным ответом является 4 3.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1692/problem/C" target="_blank">Задача 1692C</a>
      <br><a href="https://codeforces.com/contest/1692" target="_blank">Codeforces Round 799 (Div. 4) 2022-06-14</a>
    </div>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

typedef long long ll;

int main() {
  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    vector&lt;vector&lt;char&gt; &gt; A(9, vector&lt;char&gt;(9));
    for (int i = 1; i &lt;= 8; i++) {
      for (int j = 1; j &lt;= 8; j++) {
        cin >> A[i][j];
      }
    }

    // решение
    int x = 0;
    int y = 0;
    for (int i = 2; i &lt; 8; i++) {
      for (int j = 2; j &lt; 8; j++) {
        if (A[i][j] == '#' && A[i - 1][j - 1] == '#' && A[i - 1][j + 1] == '#') {
          x = i;
          y = j;
        }
      }
    }

    // вывод результата
    cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\n';
  }

}
</pre>
  </details>
</article>


<!-- Задача D. Часы -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Часы</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У Виктора есть 24-часовые часы, показывающие время в формате «HH:MM» (00 ≤ HH ≤ 23, 00 ≤ MM ≤ 59). Он будет смотреть на часы каждые x минут, начиная со времени s.</p>

  <p>Посчитайте как много различных палиндромов Виктор увидит, смотря на часы каждые x минут, начиная с момента времени s.</p>

  <p>Например, если Виктор начнет смотреть на часы в 03:12 и затем будет смотреть на них каждые 360 минут (то есть каждые 6 часов), то он увидит на часах 03:12, 09:12, 15:12, 21:12, 03:12, и далее время будет повторяться. В этом случае время 21:12 будет единственным палиндромом, который Виктор увидит, так что ответом будет 1.</p>

  <p>Палиндромом является строка, которая читается с конца так же, как и с начала. Например, времена 12:21, 05:50, 11:11 являются палиндромами, а 13:13, 22:10, 02:22 — нет.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит единственное число t (1 ≤ t ≤ 100) — количество наборов входных данных. Далее следуют описания наборов.</p>

  <p>Единственная строка каждого набора входных данных содержит строку s длиной 5 символов в формате «HH:MM», где «HH» может быть от «00» до «23» и «MM» может быть от «00» до «59» (и «HH», и «MM» содержат ровно два символа), а так же число x (1 ≤ x ≤ 1440) — количество минут, между моментами времени, когда Виктор смотрит на часы.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора выведите единственное число  — количество различных палиндромов, которые увидит Виктор, если будет смотреть на часы каждые x минут, начиная со времени s.</p>

  <details>
    <summary>Пример</summary>
<pre>
6
03:12 360
00:00 1
13:22 2
15:15 10
11:11 1440
22:30 27
</pre>
<pre>
1
16
10
0
1
1
</pre>
  <p>Первый пример объяснён в условии.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1692/problem/D" target="_blank">Задача 1692D</a>
      <br><a href="https://codeforces.com/contest/1692" target="_blank">Codeforces Round 799 (Div. 4) 2022-06-14</a>
    </div>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

using namespace std;

// добавляем время
pair&lt;int, int&gt; addTime(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b) {
  int min = a.second + b.second;
  a.second = min % 60;
  a.first = (a.first + b.first + min / 60) % 24;

  return a;
}

// проверяем на палиндром
bool isPalindrome(pair&lt;int, int&gt; t) {
  int t1 = t.first / 10;
  int t2 = t.first % 10;
  int t3 = t.second / 10;
  int t4 = t.second % 10;
  if (t1 != t4 || t2 != t3) {
    return false;
  }
  return true;
}

int main() {
  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    string s; // начальное время
    cin >> s;
    int x; // число минут
    cin >> x;

    // решение
    int res = 0;

    int h_start = stoi(s.substr(0, 2));
    int m_start = stoi(s.substr(3, 2));
    pair&lt;int, int&gt; time_start = make_pair(h_start, m_start);

    int h_step = x / 60;
    int m_step = x % 60;
    pair&lt;int, int&gt; time_step = make_pair(h_step, m_step);

    // проверяем на палиндром начальное время
    pair&lt;int, int&gt; time = time_start;
      if (isPalindrome(time)) {
        res++;
      }
      time = addTime(time, time_step);

    // пока время не начнет повторяться
    while (time.first != time_start.first || time.second != time_start.second) {
      if (isPalindrome(time)) {
        res++;
      }
      time = addTime(time, time_step);
    }

    // вывод результата
    cout &lt;&lt; res &lt;&lt; '\n';
  }

}
</pre>
  </details>
</article>


<!-- Задача E. Двоичный дек -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Двоичный дек</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У Славика есть массив длины n, состоящий только из нулей и единиц. За одну операцию он может удалить либо первый, либо последний элемент массива.</p>

  <p>Какое минимальное число операций нужно совершить Славику, чтобы сумма оставшихся элементов в массиве равнялась в точности s после совершения всех операций? В случае, если число s не может быть получено как сумма элементов массива после любого числа операций, выведите «-1».</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит единственное число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора содержит два числа n и s (1 ≤ n, s ≤ 2⋅10⁵) — длина массива и необходимая сумма элементов.</p>

  <p>Вторая строка каждого набора содержит n целых чисел aᵢ (0 ≤ aᵢ ≤ 1) — элементы массива.</p>

  <p>Гарантируется что сумма n по всем наборам данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите единственное число — минимальное количество операций, необходимое чтобы сумма всех элементов массива равнялась s. Выведите «-1», если получить массив с суммой элементов s невозможно.</p>

  <details>
    <summary>Пример</summary>
<pre>
7
3 1
1 0 0
3 1
1 1 0
9 3
0 1 0 1 1 1 0 0 1
6 4
1 1 1 1 1 1
5 1
0 0 1 1 0
16 2
1 1 0 0 1 0 0 1 1 0 0 0 0 0 1 1
6 3
1 0 1 0 0 0
</pre>
<pre>
0
1
3
2
2
7
-1
</pre>
  <p>В первом наборе сумма элементов во всем массиве уже равна 1, поэтому никаких операций больше не требуется.</p>
  <p>Во втором наборе сумма элементов равна 2, а нам нужна сумма 1, поэтому мы можем удалить из массива первый элемент, после чего массив превратится в [1,0], сумма элементов которого будет равна 1.</p>
  <p>В третьем наборе сумма элементов массива изначально равна 5, а нам нужна сумма 3. Мы можем получить такую сумму удалив первые 2 элемента, после чего удалив последний элемент, сделав всего 3 операции. Массив станет [0,1,1,1,0,0], сумма элементов которого будет 3.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1692/problem/E" target="_blank">Задача 1692E</a>
      <br><a href="https://codeforces.com/contest/1692" target="_blank">Codeforces Round 799 (Div. 4) 2022-06-14</a>
    </div>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);

  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // длина массива
    int s; // необходимая сумма элементов
    cin >> n >> s;
    vector&lt;int&gt; A(n);
    for (int i = 0; i &lt; n; i++) {
      cin >> A[i];
    }

    // решение
    int sum = 0;

    // посчитаем сумму
    for (int i = 0; i &lt; n; i++) {
      sum += A[i];
    }

    int res = n;

    if (s > sum) {
      res = -1;
    } else if (s == sum) {
      res = 0;
    } else {
      // значит сумма массива больше чем необходимая сумма
      // соберем второй массив в котором будут номера элементов с единицей
      vector&lt;int&gt; B;
      for (int i = 0; i &lt; n; i++) {
        if (A[i] == 1) {
          B.push_back(i);
        }
      }

      // пройдем скользящим окном размером s по второму массиву
      // когда окно начинается с левой единицы
      // считаем сколько элементов нужно убрать справа
      int cur_sum = n - B[s];
      res = min(res, cur_sum);

      // считаем сколько элементов нужно убрать слева и справа
      int end = sum - s;
      for (int i = 1; i &lt; end; i++) {
        cur_sum = B[i - 1] + 1 + n - B[i + s];
        res = min(res, cur_sum);
      }

      // когда окно заканчивается правой единицей
      // считаем сколько элементов нужно убрать слева
      cur_sum = B[end - 1] + 1;
      res = min(res, cur_sum);
    }

    // вывод результата
    cout &lt;&lt; res &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача F. 3-Сумма -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. 3-Сумма</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам дан массив a, состоящий из n положительных целых чисел. Cуществуют ли три различных индекса i, j, k таких, чтобы сумма ai+aj+ak заканчивается цифрой 3?</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит единственное число t (1 ≤ t ≤ 1000) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора содержит целое число n (3 ≤ n ≤ 2⋅10⁵) — длину массива.</p>

  <p>Вторая строка каждого набора содержит n целых чисел a1, a2, …, an (1 ≤ ai ≤ 10⁹) — элементы массива.</p>

  <p>Сумма n по всем наборам данных не превосходит 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Выведите t строк, каждая из которых содержит ответ на соответствующий набор данных. Выведите «YES», если в массиве существуют три различных индекса i, j, k, удовлетворяющих ограничениям описанным в условиях, или «NO» в противном случае.</p>

  <p>Вы можете выводить ответ в любом регистре (например, вывод «yEs», «yes», «Yes» и «YES» всё ещё будет считаться корректным).</p>

  <details>
    <summary>Пример</summary>
<pre>
6
4
20 22 19 84
4
1 11 1 2022
4
1100 1100 1100 1111
5
12 34 56 78 90
4
1 9 8 4
6
16 38 94 25 18 99
</pre>
<pre>
YES
YES
NO
NO
YES
YES
</pre>
  <p>В первом наборе Вы можете выбрать i=1, j=4, k=3. Тогда a1+a4+a3=20+84+19=123, эта сумма заканчивается цифрой 3.</p>

  <p>Во втором наборе Вы можете выбрать i=1, j=2, k=3. Тогда a1+a2+a3=1+11+1=13, эта сумма заканчивается цифрой 3.</p>

  <p>Можно доказать, что в третьем наборе не существует таких i, j, k, удовлетворяющих условиям. Отметьте что i=4, j=4, k=4 не является корректным решением, несмотря на то, что a4+a4+a4=1111+1111+1111=3333, т.е. заканчивается цифрой 3, индексы должны быть различны.</p>

  <p>Можно доказать, что в четвертом наборе не существует i, j, k, удовлетворяющих условиям.</p>

  <p>В пятом наборе Вы можете выбрать i=4, j=3, k=1. Тогда a4+a3+a1=4+8+1=13, а их сумма заканчивается цифрой 3.</p>

  <p>В шестом наборе Вы можете выбрать i=1, j=2, k=6. Тогда a1+a2+a6=16+38+99=153, а их сумма заканчивается цифрой 3.</p>
  </details>
</article>


<!-- Задача G. 2^Сортировка -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. 2^Сортировка</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам дан массив a длины n и число k. Посчитайте количество подмассивов [ai,…,ai+k] (здесь 1 ≤ i ≤ n-k) длины k+1 удовлетворяющих следующим условиям:</p>
  <ul>
    <li>Если умножить первый элемент подмассива на 2⁰, второй на 2¹, ..., и (k+1)-й элемент на 2k, то этот подмассив будет строго возрастающим.</li>
  </ul>
  <p>Более формально, найдите количество индексов 1 ≤ i ≤ n-k таких, что удовлетворяется k неравенств:</p>
  <code>2⁰⋅ai &lt; 2¹⋅ai+1 &lt; 2²⋅ai+2 &lt; ⋯ &lt; 2ᵏ⋅ai+k.</code>

  <h4>Входные данные</h4>
  <p>Первая строка содержит единственное число t (1 ≤ t ≤ 1000) — количество наборов входных данных.</p>

  <p>В первой строке каждого набора содержатся два целых числа n, k (3 ≤ n ≤ 2⋅10⁵, 1 ≤ k &lt; n).</p>

  <p>Во второй строке каждого набора содержатся n чисел a1,a2,…,an (1 ≤ ai ≤ 10⁹) — элементы массива.</p>

  <p>Сумма n по всем наборам не превосходит 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора выведите единственное число — количество индексов, удовлетворяющих условиям.</p>

  <details>
    <summary>Пример</summary>
<pre>
6
4 2
20 22 19 84
5 1
9 5 3 2 1
5 2
9 5 3 2 1
7 2
22 12 16 4 3 22 12
7 3
22 12 16 4 3 22 12
9 3
3 9 12 3 9 12 3 9 12
</pre>
<pre>
2
3
2
3
1
0
</pre>
  <p>В первом наборе оба подмассива удовлетворяют условиям:</p>
  <ul>
    <li>i=1 : помассив [a1,a2,a3]=[20,22,19], и 1⋅20 &lt; 2⋅22 &lt; 4⋅19.</li>
    <li>i=2 : подмассив [a2,a3,a4]=[22,19,84], и 1⋅22 &lt; 2⋅19 &lt; 4⋅84.</li>
  </ul>
  <p>Во втором наборе три подмассива удовлетворяют условиям:</p>
  <ul>
    <li>i=1 : подмассив [a1,a2]=[9,5], и 1⋅9 &lt; 2⋅5.</li>
    <li>i=2 : подмассив [a2,a3]=[5,3], и 1⋅5 &lt; 2⋅3.</li>
    <li>i=3 : подмассив [a3,a4]=[3,2], и 1⋅3 &lt; 2⋅2.</li>
    <li>i=4 : подмассив [a4,a5]=[2,1], но 1⋅2=2⋅1, так что этот подмассив не удовлетворяет условиям.</li>
  </ul>
  </details>
</article>


<!-- Задача H. Азартные игры -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Азартные игры</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Мариан пришёл в казино. Игры в казино проходят следующим образом.</p>

  <p>Перед каждым раундом игрок выбирает число от 1 до 10⁹. После этого бросается игральная кость с 10⁹ сторонами, и выпадает случайное число от 1 до 10⁹. Если игрок угадал выпавшее число, количество его денег удваивается, в противном случае количество его денег уменьшается вдвое.</p>

  <p>Мариан умеет предсказывать будущее, поэтому он знает все числа x1,x2,…,xn которые выпадут на игральной кости в следующих n раундах.</p>

  <p>Мариан хочет выбрать три числа a, l, r (l ≤ r). Он будет играть r-l+1 раунд (раунды с номерами от l до r). В каждом из этих раундов он будет загадывать одно и тоже число a. На старте (перед раундом l) у него 1 доллар.</p>

  <p>Мариан просит вас найти такие a, l и r (1 ≤ a ≤ 10⁹, 1 ≤ l ≤ r ≤ n) таких, что в конце игры у него будет максимальная сумма денег.</p>

  <p>Заметьте, что при проигрыше или выигрыше (т.е. уменьшении или увеличении количества денег вдвое) количество денег не округляется. Все операции деления/умножения проводятся с бесконечной точностью. Например, во время игры Мариан может иметь количество денег, равное 1/1024, 1/128, 1/2, 1, 2, 4, и т.д. (любое значение 2ᵗ, где t — целое число любого знака).</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит одно целое число t (1 ≤ t ≤ 100) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора содержит целое число n (1 ≤ n ≤ 2⋅10⁵) — количество раундов в игре.</p>

  <p>Вторая строка каждого набора содержит n целых чисел x1,x2,…,xn (1 ≤ xi ≤ 10⁹), где xi — число, которое выпадет на игральной кости в i-м раунде.</p>

  <p>Гарантируется, что сумма n по всем наборам не превосходит 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора выведите три числа — a, l, и r таких, что выигрыш Мариана в казино будет максимальным. Если существует несколько различных ответов, вы можете вывести любой из них.</p>

  <details>
    <summary>Пример</summary>
<pre>
4
5
4 4 3 4 4
5
11 1 11 1 11
1
1000000000
10
8 8 8 9 9 6 6 9 6 6
</pre>
<pre>
4 1 5
1 2 2
1000000000 1 1
6 6 10
</pre>
  <p>В первом наборе лучшим выбором будет a=4, l=1, r=5. Игра пройдёт следующим образом:</p>
  <ul>
    <li>Мариан начинает игру с одним долларом.</li>
    <li>После первого раунда у Мариана будет 2 доллара, так как он угадал выпавшее число.</li>
    <li>После второго раунда у Мариана будет 4 доллара, так как он вновь угадал выпавшее число.</li>
    <li>После третьего раунда у Мариана будет 2 доллара, так как он загадал 4, а выпало число 3.</li>
    <li>После четвертого раунда у Мариана вновь будет 4 доллара.</li>
    <li>В последнем раунде Мариан закончит с 8 долларами, так как он вновь угадал выпавшее число.</li>
  </ul>
  <p>Для второго набора есть много подходящих ответов, однако можно доказать что Мариан не может закончить играть с более чем 2 долларами, так что любой выбор l=r с подходящим a будет приемлемым.</p>
  </details>
</article>
