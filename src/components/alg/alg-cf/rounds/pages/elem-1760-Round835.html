<article class="article">
  <a href="https://codeforces.com/contest/1760" target="_blank">Codeforces 1760 Round 835 (Div. 4) 2022-11-21</a>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

      <a href="#task1">Задача A. По середине</a>
  <br><a href="#task2">Задача B. Любимая задача Atilla</a>
  <br><a href="#task3">Задача C. Преимущество</a>
  <br><a href="#task4">Задача D. Долины с трудностями</a>
  <br><a href="#task5">Задача E. Бинарные инверсии</a>
  <br><a href="#task6">Задача F. Квесты</a>
  <br><a href="#task7">Задача G. Любимая задача SlavicG-а</a>
</article>


<!-- Задача A. По середине -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. По середине</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Даны три различных целых числа a, b, и c. Найдите среднее из них. Другими словами, найдите среди заданных трёх чисел число не являющееся ни минимумом, ни максимумом.</p>

  <p>Например, средним число среди 5,2,6 будет 5, так как минимумом является 2, а максимумом 6.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно число t (1 ≤ t ≤ 6840) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора содержит три различных целых числа a, b, c (1 ≤ a, b, c ≤ 20).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора выведите одно целое число — среднее среди трёх данных чисел.</p>

  <details>
    <summary>Пример 1</summary>
<pre>
9
5 2 6
14 3 4
20 2 1
1 2 3
11 19 12
10 8 20
6 20 3
4 1 3
19 8 4
</pre>
<pre>
5
4
2
2
12
10
6
3
8
</pre>
  </details>
</article>


<!-- Задача B. Любимая задача Atilla -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Любимая задача Atilla</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Для того чтобы написать строку, Atilla должен сначала выучить все буквы, которые содержатся в строке.</p>

  <p>Он хочет написать сообщение s. Он просит вас узнать минимальный размер алфавита, который ему предстоит выучить, чтобы он смог написать эту всю эту строку.</p>

  <p>Алфавит размером x (1 ≤ x ≤ 26) содержит только первые x латинских букв. Например, алфавит размера 4 содержит только символы a, b, c и d.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно целое число t (1 ≤ t ≤ 1000) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора содержит одно целое число n (1 ≤ n ≤ 100) — длину заданной строки.</p>

  <p>Затем следует строка s длиной n, состоящая из строчных латинских букв.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора выведите одно целое число — минимальный размер алфавита, необходимого для того, чтобы Atilla смог написать строку s.</p>

  <details>
    <summary>Примеры</summary>
<pre>
5
1
a
4
down
10
codeforces
3
bcf
5
zzzzz
</pre>
<pre>
1
23
19
6
26
</pre>
    <p>Для первого набора нужен только символ a, поэтому достаточно алфавита размером 1, который содержит только a.</p>

    <p>Для второго набора нужны символы d, o, w, n. Минимальный размер алфавита, который содержит их все, равен 23 (такой алфавит можно представить в виде строки abcdefghijklmnopqrstuvw).</p>
  </details>
</article>


<!-- Задача C. Преимущество -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Преимущество</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В соревновании участвуют n участников, причем участник i имеет силу si.</p>

  <p>Каждый участник хочет узнать, какое преимущество он имеет перед лучшим участником соревнования помимо него самого. Другими словами, каждый участник i хочет знать разность между si и sj, где j — сильнейший участник соревнования, не считая i. Обратите внимание, что разность может быть отрицательной.</p>

  <p>Поэтому они просят вас о помощи! Для каждого i (1 ≤ i ≤ n) выведите разность между si и максимальной силой участника, отличного от i.</p>

  <h4>Входные данные</h4>
  <p>Входные данные состоят из нескольких наборов входных данных. Первая строка содержит целое число t (1 ≤ t ≤ 1000) — количество наборов. Далее следуют их описания.</p>

  <p>Первая строка каждого набора содержит целое число n (2 ≤ n ≤ 2⋅10⁵) — длину массива.</p>

  <p>Следующая строка содержит n положительных целых чисел s1, s2, ..., sn (1 ≤ si ≤ 10⁹) — силы участников.</p>

  <p>Гарантируется, что сумма n по всем наборам не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора выведите n целых чисел, разделенных пробелами. Для каждого i (1 ≤ i ≤ n) выведите разность между si и максимальной силой любого другого участника.</p>

  <details>
    <summary>Пример</summary>
<pre>
5
4
4 7 3 5
2
1 2
5
1 2 3 4 5
3
4 9 4
4
4 4 4 4
</pre>
<pre>
-3 2 -4 -2
-1 1
-4 -3 -2 -1 1
-5 5 -5
0 0 0 0
</pre>
    <p>Для первого примера:</p>
    <ul>
      <li>Первый участник имеет силу 4, а максимальная сила среди остальных участников соревнования равна 7, поэтому ответ для первого участника равен: 4-7=-3.</li>
      <li>Второй участник имеет силу 7, а максимальная сила среди остальных участников соревнования равна 5, поэтому ответ для второго участника: 7-5=2.</li>
      <li>Третий участник имеет силу 3, а максимальная сила среди остальных участников соревнования равна 7, поэтому ответ для третьего участника: 3-7=-4.</li>
      <li>Четвертый участник имеет силу 5, а максимальная сила среди остальных участников соревнования равна 7, поэтому ответ для четвертого участника: 5-7=-2.</li>
    </ul>
  </details>
</article>


<!-- Задача D. Долины с трудностями -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Долины с трудностями</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам дан массив a[0…n-1] из n целых чисел. Этот массив называется «долиной», если существует ровно один подмассив a[l…r] такой, что:</p>
  <ul>
    <li>0≤l≤r≤n-1,</li>
    <li>al=al+1=al+2=⋯=ar,</li>
    <li>l=0 или al-1>al,</li>
    <li>r=n-1 или ar &lt; ar+1.</li>
  </ul>
  <p>Вот три примера:</p>

  <p>На первом изображении показан массив [3,2,2,1,2,2,3], он является долиной, потому что только подмассив с индексами l=r=3 удовлетворяет условию.</p>

  <p>На втором изображении показан массив [1,1,1,2,3,3,4,5,6,6,6], он является долиной, потому что только подмассив с индексами l=0,r=2  удовлетворяет условию.</p>

  <p>На третьем изображении показан массив [1,2,3,4,3,2,1], он не является долиной, потому что два подмассива l=r=0 и l=r=6 удовлетворяют условию.</p>

  <p>Определите, является ли данный массив долиной или нет.</p>

  <p>Обратите внимание, что мы считаем массив индексированным с 0.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора содержит одно целое число n (1 ≤ n ≤ 2⋅10⁵) — длину массива.</p>

  <p>Вторая строка каждого набора содержит n целых чисел ai (1 ≤ ai ≤ 10⁹) — элементы массива.</p>

  <p>Гарантируется, что сумма n по всем наборам не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора выведите «YES» (без кавычек), если массив является долиной, и «NO» (без кавычек) в противном случае.</p>

  <p>Вы можете вывести ответ в любом случае (например, строки «YEs», «Yes», «Yes» и «YES» будут распознаны как положительный ответ).</p>

  <details>
    <summary>Пример 1</summary>
<pre>
6
7
3 2 2 1 2 2 3
11
1 1 1 2 3 3 4 5 6 6 6
7
1 2 3 4 3 2 1
7
9 7 4 6 9 9 10
1
1000000000
8
9 4 4 5 9 4 9 10
</pre>
<pre>
YES
YES
NO
YES
YES
NO
</pre>
    <p>Первые три набора входных данных примера разобраны в условии.</p>
  </details>
</article>


<!-- Задача E. Бинарные инверсии -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Бинарные инверсии</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам дан бинарный массив† длины n. Вам можете выполнить над ним следующую операцию не более одного раза. Операция заключается в следующем — вы можете выбрать любой элемент и инвертировать его: превратить 0 в 1 или наоборот.</p>

  <p>Какое максимальное количество инверсий ‡ может иметь массив после выполнения не более одной операции?</p>

  <p>† Бинарный массив — это массив, состоящий только из нулей и единиц.</p>

  <p>‡ Количество инверсий в массиве — это количество пар индексов i, j
  таких, что i &lt; j и ai > aj.</p>

  <h4>Входные данные</h4>
  <p>Входные данные состоят из нескольких наборов. Первая строка содержит целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных в тесте. Далее следуют их описания.</p>

  <p>Первая строка каждого набора содержит целое число n (1 ≤ n ≤ 2⋅10⁵) — длину массива.</p>

  <p>Следующая строка содержит n целых положительных чисел a1, a2,..., an (0 ≤ ai ≤ 1) — элементы массива.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора выведите одно целое число  — максимальное количество инверсий, которое может быть у массива после выполнения не более одной операции.</p>

  <details>
    <summary>Пример 1</summary>
<pre>
5
4
1 0 1 0
6
0 1 0 0 1 0
2
0 0
8
1 0 1 1 0 0 0 1
3
1 1 1
</pre>
<pre>
3
7
1
13
2
</pre>
    <p>В первом примере инверсии изначально формируются парами индексов (1,2), (1,4), (3,4), что в сумме составляет 3, что уже является максимально возможным значением.</p>
    <p>Во втором примере инверсии изначально образованы парами индексов (2,3), (2,4), (2,6), (5,6), в сумме четыре. Но, применив операцию над первым элементом, массив становится 1,1,0,0,1,0, где инверсии уже образованы парами индексов (1,3), (1,4), (1,6), (2,3), (2,4), (2,6), (5,6), что в сумме составляет 7 инверсий, что является максимально возможным.</p>
  </details>
</article>


<!-- Задача F. Квесты -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Квесты</h3>

  <div><i>Ограничение по времени 3с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У вас есть возможность выполнять n квестов. Если вы выполняете i-й квест, вы получаете ai монет. Вы можете выполнить не больше одного квеста в день.</p>

  <p>Однако, после того как вы выполнили квест, вы не можете выполнить его снова в течение следующих k дней. (Например, если k=2 и вы выполняете 1-й квест в 1-й день, тогда вы не сможете выполнить этот квест снова во 2-й или в 3-й день, но сможете его выполнить в 4-й день.)</p>

  <p>Заданы два целых числа c и d. Найдите максимальный k такой, что возможно получить как минимум c монет за d дней. Если таких k не существует, выведите Impossible. Если k может быть бесконечно большим, выведите Infinity.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора содержит три целых числа n, c, d (2 ≤ n ≤ 2⋅10⁵; 1 ≤ c ≤ 10¹⁶; 1 ≤ d ≤ 2⋅10⁵) — количество квестов, количество необходимых монет и количество дней.</p>

  <p>Вторая строка каждого набора содержит n целых чисел a1, a2, …, an (1 ≤ ai ≤ 10⁹) — награды за квесты.</p>

  <p>Гарантируется что сумма n по всем наборам входных данных не превосходит 2⋅10⁵, а сумма d по всем наборам входных данных не превосходит 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите:</p>
  <ul>
    <li>если таких k не существует, выведите Impossible;</li>
    <li>если k может быть бесконечно большим, выведите Infinity;</li>
    <li>иначе, выведите одно целое число — максимальный k такой что возможно получить как минимум c монет в течение d дней.</li>
  </ul>

  <details>
    <summary>Пример 1</summary>
<pre>
6
2 5 4
1 2
2 20 10
100 10
3 100 3
7 2 6
4 20 3
4 5 6 7
4 100000000000 2022
8217734 927368 26389746 627896974
2 20 4
5 1
</pre>
<pre>
2
Infinity
Impossible
1
12
0
</pre>
    <p>В первом тесте, один из способов получить 5 монет за 4 дня с k=2 состоит в следующем:</p>
    <ul>
      <li>день 1: выполнить квест 2, и получить 2 монеты;</li>
      <li>день 2: выполнить квест 1, и получить 1 монету;</li>
      <li>день 3: ничего не делать;</li>
      <li>день 4: выполнить квест 2, и получить 2 монеты.</li>
    </ul>
    <p>Суммарно мы получили 2+1+2=5 монет.</p>
    <p>Во втором тесте, мы можем получить более 20 монет в первый день, выполнив лишь только первый квест. Выполнив первый квест, мы сразу получим 100 монет, значит значение k может быть бесконечно большим, так как нам никогда не понадобится выполнить ещё один квест.</p>
    <p>В третьем тесте, что бы мы не делали, мы не можем получить 100  монет за 3 дня.</p>
  </details>
</article>


<!-- Задача G. Любимая задача SlavicG-а -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Любимая задача SlavicG-а</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам задано взвешенное дерево с n вершинами. Деревом называется неориентированный связный граф без циклов. Дерево является взвешенным, если каждому его ребру сопоставлено число — его вес. Дерево неориентировано, не содержит корня.</p>

  <p>Так как деревья слишком скучны, вы решили повеселить себя игрой на дереве.</p>

  <p>За один ход вы можете переместиться из вершины в любого его соседа (такую вершину, в которую есть ребро из текущей).</p>

  <p>Вы начинаете игру, имея значение переменной x равное 0. Когда вы перемещаетесь по ребру i, то x изменяет своё значение на x XOR wi (где — wi вес i-го ребра).</p>

  <p>Ваша задача пройти от вершины a до вершины b, но вы имеете право входить в вершину b только если x после этого станет равно 0. Другими словами, вы можете пройти по ребру i, которое ведёт в b тогда и только тогда, когда x XOR wi=0. Как только вы попадаете b, то игра заканчивается вашей победой.</p>

  <p>Есть дополнительное правило — не более одного раза за игру вы можете воспользоваться телепортом. Он перемещает вас мгновенно в любую вершину (отличную от b). Вы можете использовать телепорт из любой вершины (даже из a).</p>

  <p>Выведите «YES», если вы можете попасть в b из a. Выведите «NO» в противном случае.</p>

  <p>Операция XOR обозначает битовое исключающее ИЛИ.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит единственное целое число t (1 ≤ t ≤ 1000) — количество наборов входных данных в тесте.</p>

  <p>Первая строка каждого набора входных данных содержит три целых числа n, a и b (2 ≤ n ≤ 10⁵), (1 ≤ a, b ≤ n; a ≠ b) — количество вершин, а также начальную и конечную вершина, соответственно.</p>

  <p>Каждая из следующих n-1 строк задает ребро дерева. Ребро i задано тремя целыми числами ui, vi и wi — метками вершин, которые оно соединяет (1 ≤ ui, vi ≤ n; ui ≠ vi; 1 ≤ wi ≤ 10⁹) и своим весом.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превосходит 10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите «YES», если вы можете достичь вершины b, и «NO» в противном случае.</p>

  <details>
    <summary>Пример 1</summary>
<pre>
3
5 1 4
1 3 1
2 3 2
4 3 3
3 5 1
2 1 2
1 2 2
6 2 3
1 2 1
2 3 1
3 4 1
4 5 3
5 6 5
</pre>
<pre>
YES
NO
YES
</pre>
    <p>Для первого набора входных данных мы можем перейти от вершины 1  в вершину 3 , при этом x изменится с 0 на 1. Затем мы перейдем из 3 в 2, при этом x станет равным 3. Теперь мы можем телепортироваться в узел 3 и переместиться из узла 3 в узел 4, достигнув узла b, так как в итоге x стало равно 0. Поэтому ответ равен «YES».</p>
    <p>Во втором наборе входных данных пример у нас нет ходов, так как мы не можем телепортироваться к узлу b, а единственный ход, который у нас есть — это добраться до узла 2, что невозможно, поскольку x не будет равно 0. Таким образом, ответ равен «NO».</p>
  </details>
</article>
