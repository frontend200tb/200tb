<article class="article">
  <a href="https://codeforces.com/contest/2121" target="_blank">Codeforces 2121 Round 1032 (Div.3) 2025-06-17</a>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

      <a href="#task1">Задача A. Письмо домой</a>
  <br><a href="#task2">Задача B. Выше облаков</a>
  <br><a href="#task3">Задача C. Тем, кто с нами</a>
  <br><a href="#task4">Задача D. 1709</a>
  <br><a href="#task5">Задача E. Спонсор твоих проблем</a>
  <br><a href="#task6">Задача F. Ямакаси</a>
  <br><a href="#task7">Задача G. Гэнгста</a>
  <br><a href="#task8">Задача H. Ice Baby</a>
</article>


<!-- Задача A. Письмо домой -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Письмо домой</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам даны массив различных целых чисел x1, x2, …, xn и целое число s.</p>

  <p>Изначально вы находитесь в позиции pos=s на оси X. За один шаг вы можете сделать ровно одно из следующих двух действий:</p>
  <ul>
    <li>Из позиции pos перейти в позицию pos+1.</li>
    <li>Из позиции pos перейти в позицию pos-1.</li>
  </ul>

  <p>Последовательность шагов будем считать успешной, если за всё время пути вы посетили каждую позицию xi на оси X хотя бы один раз. Обратите внимание, что начальная позиция pos=s также считается посещённой.</p>

  <p>Ваша задача определить наименьшее количество шагов в какой-либо успешной последовательности шагов.</p>

  <h4>Входные данные</h4>
  <p>Каждый тест состоит из нескольких наборов входных данных. Первая строка содержит единственное целое число t (1≤t≤1000) — количество наборов входных данных. Далее следует их описание.</p>

  <p>Первая строка каждого набора входных данных содержит два целых числа n и s (1≤n≤10, 1≤s≤100) — количество позиций, которые необходимо посетить, и стартовая позиция.</p>

  <p>Вторая строка каждого набора входных данных содержит n целых чисел x1, x2, …, xn (1 ≤ xi ≤ 100). Гарантируется, что для всех 1 ≤ i &lt; n верно, что x<sub>i</sub> &lt; x<sub>i+1</sub>.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите наименьшее количество шагов в какой-либо успешной последовательности шагов.</p>

  <details>
    <summary>Пример</summary>
<pre>
12
1 1
1
1 2
1
1 1
2
2 1
2 3
2 2
1 3
2 3
1 2
3 1
1 2 3
3 2
1 3 4
3 3
1 2 3
4 3
1 2 3 10
5 5
1 2 3 6 7
6 6
1 2 3 9 10 11
</pre>
<pre>
0
1
1
2
3
2
2
4
2
11
8
15
</pre>
  <p>В первом наборе входных данных можно не делать никаких шагов, тогда единственной посещённой позицией будет 1.</p>
  <p>Во втором наборе входных данных можно проделать следующий путь: 2→1. Количество шагов равно 1.</p>
  <p>В третьем наборе входных данных можно проделать следующий путь: 1→2. Количество шагов равно 1.</p>
  <p>В пятом наборе входных данных можно проделать следующий путь: 2→1→2→3. Количество шагов равно 3.</p>
  </details>
</article>


<!-- Задача B. Выше облаков -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Выше облаков</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам дана строка s длины n, состоящая из строчных букв латинского алфавита. Определите, существуют ли три непустые строки a, b и c такие, что:</p>
  <ul>
    <li>a+b+c=s, то есть конкатенация∗ строк a, b и c равна s.</li>
    <li>Строка b является подстрокой† строки a+c, то есть конкатенации строк a и c.</li>
  </ul>

  <p>* Конкатенацией строк a и b называется строка a+b=a1a2…apb1b2…bq, где p и q длины строк a и b соответственно. Например, конкатенация строк «code» и «forces» равна «codeforces».</p>

  <p>† Строка a является подстрокой строки b, если a может быть получена из b удалением нескольких (возможно, ни одного или всех) символов с начала и нескольких (возможно, ни одного или всех) символов с конца.</p>

  <h4>Входные данные</h4>
  <p>Каждый тест состоит из нескольких наборов входных данных. Первая строка содержит единственное целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных. Далее следуют их описания.</p>

  <p>Первая строка каждого набора входных данных содержит единственное целое число n (3 ≤ n ≤ 10⁵) — длина строки s.</p>

  <p>Вторая строка каждого набора входных данных содержит строку s длины n, состоящую из строчных букв латинского алфавита.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превосходит 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите «Yes», если существует три непустые строки a, b и c, удовлетворяющие условиям, и «No» иначе.</p>

  <p>Вы можете вывести ответ в любом регистре (верхнем или нижнем). Например, строки «yEs», «yes», «Yes» и «YES» будут распознаны как положительные ответы.</p>

  <details>
    <summary>Пример</summary>
<pre>
12
3
aaa
3
aba
3
aab
4
abca
4
abba
4
aabb
5
abaca
5
abcda
5
abcba
6
abcbbf
6
abcdaa
3
abb
</pre>
<pre>
Yes
No
Yes
No
Yes
Yes
Yes
No
Yes
Yes
Yes
Yes
</pre>
  <p>В первом наборе входных данных существуют единственные непустые строки a, b и c такие, что a+b+c=s. Это строки a= «a», b= «a» и c= «a». Конкатенация строк a и c равна a+c=«aa». Строка b является подстрокой этой строки.</p>
  <p>В шестом наборе входных данных можно выбрать a=«a», b=«ab» и c=«b». Конкатенация строк a и c равна a+c=«ab». Строка b является подстрокой этой строки.</p>
  <p>В седьмом наборе входных данных можно выбрать a=«ab», b=«a» и c=«ca». Конкатенация строк a и c равна a+c=«abca». Строка b является подстрокой этой строки.</p>
  </details>
</article>


<!-- Задача C. Тем, кто с нами -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Тем, кто с нами</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам дана матрица целых чисел из n строк и m столбцов. Ячейка на пересечении i-й строки и j-го столбца содержит число aij.</p>

  <p>Вы можете ровно один раз сделать следующее:</p>
  <ul>
    <li>Выбрать два числа 1≤r≤n и 1≤c≤m.</li>
    <li>Для всех ячеек матрицы (i,j), таких, что i=r или j=c, уменьшить aij на единицу.</li>
  </ul>

  <p>Вам нужно найти минимальное максимальное значение в матрице a
  после проведения ровно одной такой операции.</p>

  <h4>Входные данные</h4>
  <p>Каждый тест состоит из нескольких наборов входных данных. Первая строка содержит единственное целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных. Далее следует их описание.</p>

  <p>Первая строка каждого набора входных данных содержит два целых числа n и m (1 ≤ n⋅m ≤ 10⁵) — количество строк и столбцов матрицы.</p>

  <p>В следующих n строках каждого набора входных данных описывается матрица a. В i-й строке содержится m целых чисел ai1,ai2,…,aim (1 ≤ aij ≤ 100) — элементы в i-й строке матрицы.</p>

  <p>Гарантируется, что сумма n⋅m по всем наборам входных данных не превосходит 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите минимальное максимальное значение в матрице a после проведения ровно одной операции.</p>

  <details>
    <summary>Пример</summary>
<pre>
10
1 1
1
1 2
1 2
2 1
2
1
2 2
4 2
3 4
3 4
1 2 3 2
3 2 1 3
2 1 3 2
4 3
1 5 1
3 1 3
5 5 5
3 5 1
4 4
1 3 3 2
2 3 2 2
1 2 2 1
3 3 2 3
2 2
2 2
1 2
3 2
1 2
2 1
1 2
3 3
2 1 1
1 2 1
1 1 2
</pre>
<pre>
0
1
1
3
2
4
3
1
1
2
</pre>
  <p>В первых трёх наборах входных данных можно выбрать r=1 и c=1.</p>
  <p>В четвёртом наборе входных данных можно выбрать r=1 и c=2.</p>
  <p>В пятом наборе входных данных можно выбрать r=2 и c=3.</p>
  <p>В шестом наборе входных данных можно выбрать r=3 и c=2.</p>
  </details>
</article>


<!-- Задача D. 1709 -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. 1709</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам даны два массива целых чисел a1,a2,…,an и b1,b2,…,bn. Гарантируется, что каждое целое число от 1 до 2⋅n встречается ровно в одном массиве.</p>

  <p>Вам нужно сделать некоторое количество операций (возможно, ноль), чтобы выполнялись оба следующих условия:</p>
  <ul>
    <li>Для каждого 1 ≤ i &lt; n верно, что ai &lt; ai+1 и bi &lt; bi+1.</li>
    <li>Для каждого 1≤i≤n верно, что ai &lt; bi.</li>
  </ul>

  <p>Во время каждой операции вы можете сделать ровно одно из трёх следующих действий:</p>
  <ol>
    <li>Выбрать индекс 1 ≤ i &lt; n и поменять местами значения ai и ai+1.</li>
    <li>Выбрать индекс 1 ≤ i &lt; n и поменять местами значения bi и bi+1.</li>
    <li>Выбрать индекс 1 ≤ i ≤ n и поменять местами значения ai и bi.</li>
  </ol>

  <p>Вам не нужно минимизировать количество операций, но нужно, чтобы их число было не более 1709. Найдите любую последовательность операций, чтобы выполнить оба условия.</p>

  <h4>Входные данные</h4>
  <p>Каждый тест состоит из нескольких наборов входных данных. Первая строка содержит единственное целое число t (1≤t≤100) — количество наборов входных данных. Далее следует их описание.</p>

  <p>Первая строка каждого набора входных данных содержит одно целое число n (1≤n≤40) — длина массивов a и b.</p>

  <p>Вторая строка каждого набора входных данных содержит n целых чисел a1,a2,…,an (1≤ai≤2⋅n).</p>

  <p>Третья строка каждого набора входных данных содержит n целых чисел b1,b2,…,bn (1≤bi≤2⋅n).</p>

  <p>Гарантируется, что каждое целое число от 1 до 2⋅n встречается либо в массиве a, либо в массиве b.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите последовательность операций.</p>

  <p>В первой строке для каждого набора входных данных выведите количество операций k. Обратите внимание, что 0≤k≤1709.</p>

  <p>В следующих k строках для каждого набора входных данных выведите сами операции:</p>
  <ul>
    <li>Если вы хотите поменять местами значения ai и ai+1, то выведите два целых числа 1 и i. Обратите внимание, что 1 ≤ i &lt; n.</li>
    <li>Если вы хотите поменять местами значения bi и bi+1, то выведите два целых числа 2 и i. Обратите внимание, что 1 ≤ i &lt; n.</li>
    <li>Если вы хотите поменять местами значения ai и bi, то выведите два целых числа 3 и i. Обратите внимание, что 1 ≤ i ≤ n.</li>
  </ul>

  <p>Можно показать, что при данных ограничениях ответ всегда существует.</p>

  <details>
    <summary>Пример</summary>
<pre>
6
1
1
2
1
2
1
2
1 3
4 2
2
1 4
3 2
3
6 5 4
3 2 1
3
5 3 4
2 6 1
</pre>
<pre>
0
1
3 1
1
2 1
1
3 2
9
3 1
3 2
3 3
1 1
2 1
2 2
1 2
1 1
2 1
6
2 2
1 1
1 2
2 1
3 1
3 2
</pre>
  <p>В первом наборе входных данных a1 &lt; b1, поэтому можно не применять операции.</p>
  <p>Во втором наборе входных данных a1>b1. После применения операции эти значения поменяются местами.</p>
  <p>В третьем наборе входных данных после применения операции a=[1,3] и b=[2,4].</p>
  <p>В четвёртом наборе входных данных после применения операции a=[1,2] и b=[3,4].</p>
  </details>
</article>


<!-- Задача E. Спонсор твоих проблем -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Спонсор твоих проблем</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Для двух целых чисел a и b определим f(a,b) как количество разрядов в десятичной записи чисел a и b, на которых стоят одинаковые цифры. Например, f(12,21)=0, f(31,37)=1, f(19891,18981)=2, f(54321,24361)=3.</p>

  <p>Вам даны два целых числа l и r одинаковой длины в десятичной записи. Рассмотрим все целые числа l≤x≤r. Ваша задача найти наименьшее значение f(l,x)+f(x,r).</p>

  <h4>Входные данные</h4>
  <p>Каждый тест состоит из нескольких наборов входных данных. Первая строка содержит единственное целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных. Далее следует их описание.</p>

  <p>В единственной строке каждого набора входных данных содержится два целых числа l и r (1 ≤ l ≤ r &lt; 10⁹).</p>

  <p>Гарантируется, что числа l и r одинаковой длины в десятичной записи, а также без лидирующих нулей.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите наименьшее значение f(l,x)+f(x,r) среди всех целых значений l ≤ x ≤ r.</p>

  <details>
    <summary>Пример</summary>
<pre>
14
1 1
2 3
4 6
15 16
17 19
199 201
899 999
1990 2001
6309 6409
12345 12501
19987 20093
746814 747932
900990999 900991010
999999999 999999999
</pre>
<pre>
2
1
0
3
2
2
1
3
3
4
3
5
12
18
</pre>
  <p>В первом наборе входных данных можно выбрать x=1. Тогда f(1,1)+f(1,1)=1+1=2.</p>
  <p>Во втором наборе входных данных можно выбрать x=2. Тогда f(2,2)+f(2,3)=1+0=1.</p>
  <p>В третьем наборе входных данных можно выбрать x=5. Тогда f(4,5)+f(5,6)=0+0=0.</p>
  <p>В четвертом наборе входных данных можно выбрать x=15. Тогда f(15,15)+f(15,16)=2+1=3.</p>
  <p>В пятом наборе входных данных можно выбрать x=18. Тогда f(17,18)+f(18,19)=1+1=2.</p>
  <p>В шестом наборе входных данных можно выбрать x=200. Тогда f(199,200)+f(200,201)=0+2=2.</p>
  <p>В седьмом наборе входных данных можно выбрать x=900. Тогда f(899,900)+f(900,999)=0+1=1.</p>
  <p>В восьмом наборе входных данных можно выбрать x=1992. Тогда f(1990,1992)+f(1992,2001)=3+0=3.</p>
  </details>
</article>


<!-- Задача F. Ямакаси -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Ямакаси</h3>

  <div><i>Ограничение по времени 3с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам даны массив целых чисел a1,a2,…,an и два целых числа s и x. Посчитайте количество подотрезков массива с суммой чисел, равной s, и максимальным значением, равным x.</p>

  <p>Более формально, посчитайте количество пар 1 ≤ l ≤ r ≤ n таких, что:</p>
  <ul>
    <li>al+al+1+…+ar=s.</li>
    <li>max(al,al+1,…,ar)=x.</li>
  </ul>

  <h4>Входные данные</h4>
  <p>Каждый тест состоит из нескольких наборов входных данных. Первая строка содержит единственное целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных. Далее следует их описание.</p>

  <p>Первая строка каждого набора входных данных содержит три целых числа n, s и x (1 ≤ n ≤ 2⋅10⁵, -2⋅10¹⁴ ≤ s ≤ 2⋅10¹⁴, -10⁹ ≤ x ≤ 10⁹).</p>

  <p>Вторая строка каждого набора входных данных содержит n целых чисел a1, a2, …, an (-10⁹ ≤ ai ≤ 10⁹).</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превосходит 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите количество подотрезков массива с суммой чисел, равной s, и максимальным значением, равным x.</p>

  <details>
    <summary>Пример</summary>
<pre>
9
1 0 0
0
1 -2 -1
-2
3 -1 -1
-1 1 -1
6 -3 -2
-1 -1 -1 -2 -1 -1
8 3 2
2 2 -1 -2 3 -1 2 2
9 6 3
1 2 3 1 2 3 1 2 3
13 7 3
0 -1 3 3 3 -2 1 2 2 3 -1 0 3
2 -2 -1
-2 -1
2 -2 -1
-1 -2
</pre>
<pre>
1
0
2
0
2
7
8
0
0
</pre>
  <p>В первом наборе входных данных подходит подотрезок l=1, r=1.</p>
  <p>В третьем наборе входных данных подходят подотрезки l=1, r=1 и l=3, r=3.</p>
  <p>В пятом наборе входных данных подходят подотрезки l=1, r=3 и l=6, r=8.</p>
  <p>В шестом наборе входных данных подходят подотрезки, для которых r=l+2.</p>
  <p>В седьмом наборе входных данных подходят следующие подотрезки:</p>
  <ul>
    <li>l=1, r=7.</li>
    <li>l=2, r=7.</li>
    <li>l=3, r=6.</li>
    <li>l=4, r=8.</li>
    <li>l=7, r=11.</li>
    <li>l=7, r=12.</li>
    <li>l=8, r=10.</li>
    <li>l=9, r=13.</li>
  </ul>
  </details>
</article>


<!-- Задача G. Гэнгста -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Гэнгста</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам дана бинарная строка s1s2…sn длины n. Строка s называется бинарной, если состоит только из нулей и единиц.</p>

  <p>Для строки p зададим функцию f(p), равную наибольшему количеству вхождений какого-либо символа в строку p. Например, f(00110)=3, f(01)=1.</p>

  <p>Вам нужно найти сумму f(slsl+1…sr) для всех пар 1≤l≤r≤n.</p>

  <h4>Входные данные</h4>
  <p>Каждый тест состоит из нескольких наборов входных данных. В первой строке находится одно целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных. Далее следует описание наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит одно целое число n (1 ≤ n ≤ 2⋅10⁵) — длину бинарной строки.</p>

  <p>Вторая строка каждого набора входных данных содержит строку длины n, состоящую из 0 и 1 — бинарную строку s.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превосходит 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите сумму f(slsl+1…sr) для всех пар 1≤l≤r≤n.</p>

  <details>
    <summary>Пример</summary>
<pre>
6
1
0
2
01
4
0110
6
110001
8
10011100
11
01011011100
</pre>
<pre>
1
3
14
40
78
190
</pre>
  <p>В первом наборе входных данных у строки s есть одна подстрока, и значение f(0)=1.</p>
  <p>Во втором наборе входных данных все подстроки строки s равны 0, 01, 1. И ответ равен 1+1+1=3 соответственно.</p>
  <p>В третьем наборе входных данных все подстроки строки s равны 0, 01, 011, 0110, 1, 11, 110, 1, 10, 0. И ответ равен 1+1+2+2+1+2+2+1+1+1=14 соответственно.</p>
  </details>
</article>


<!-- Задача H. Ice Baby -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Ice Baby</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 512мб</i></div>

  <p>Наибольшая неубывающая подпоследовательность массива целых чисел a1,a2,…,an — это самая длинная последовательность индексов 1 ≤ i1 &lt; i2 &lt; … &lt; ik ≤ n, такая что ai1 ≤ ai2 ≤ … ≤ aik. Длина последовательности определяется как количество элементов последовательности. Например, длина наибольшей неубывающей подпоследовательности массива a=[3,1,4,1,2] равна 3.</p>

  <p>Вам даны два массива целых чисел l1,l2,…,ln и r1,r2,…,rn. Для каждого 1≤k≤n решите следующую задачу:</p>
  <ul>
    <li>Рассмотрим все массивы целых чисел a длины k, такие что для каждого 1≤i≤k верно, что li≤ai≤ri. Найдите максимальную длину наибольшей неубывающей подпоследовательности среди всех таких массивов.</li>
  </ul>

  <h4>Входные данные</h4>
  <p>Каждый тест состоит из нескольких наборов входных данных. Первая строка содержит единственное целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных. Далее следует их описание.</p>

  <p>Первая строка каждого набора входных данных содержит единственное целое число n (1 ≤ n ≤ 2⋅10⁵) — длина массивов l и r.</p>

  <p>Следующие n строк каждого набора входных данных содержат два целых числа li и ri (1 ≤ li ≤ ri ≤ 10⁹).</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превосходит 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите n целых чисел: для каждого k от 1 до n выведите максимальную длину наибольшей неубывающей подпоследовательности среди всех подходящих массивов.</p>

  <details>
    <summary>Пример</summary>
<pre>
6
1
1 1
2
3 4
1 2
4
4 5
3 4
1 3
3 3
8
6 8
4 6
3 5
5 5
3 4
1 3
2 4
3 3
5
1 2
6 8
4 5
2 3
3 3
11
35 120
66 229
41 266
98 164
55 153
125 174
139 237
30 72
138 212
109 123
174 196
</pre>
<pre>
1
1 1
1 2 2 3
1 2 2 3 3 3 4 5
1 2 2 2 3
1 2 3 4 5 6 7 7 8 8 9
</pre>
  <p>В первом наборе входных данных возможен только массив a=[1]. У этого массива длина наибольшей неубывающей подпоследовательности равна 1.</p>
  <p>Во втором наборе входных данных для k=2 как бы мы ни выбирали значения a1 и a2, всегда будет выполняться условие, что a1>a2. Поэтому ответ для k=2 будет равен 1.</p>
  <p>В третьем наборе входных данных для k=4 можно выбрать массив a=[5,3,3,3]. Длина наибольшей неубывающей подпоследовательности у этого массива равна 3.</p>
  <p>В четвертом наборе входных данных для k=8 можно выбрать массив a=[7,5,3,5,3,3,3,3]. Длина наибольшей неубывающей подпоследовательности у этого массива равна 5.</p>
  <p>В пятом наборе входных данных для k=5 можно выбрать массив a=[2,8,5,3,3]. Длина наибольшей неубывающей подпоследовательности у этого массива равна 3.</p>
  </details>
</article>

