<article class="article">
  <a href="https://codeforces.com/contest/2072" target="_blank">Codeforces 2072 Round 1006 (Div.3) 2025-02-25</a>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

      <a href="#task1">Задача A. Новый мир, новый я, новый массив</a>
  <br><a href="#task2">Задача B. Будучи казначеем в прошлом, я помогаю гоблинам обманывать людей</a>
  <br><a href="#task3">Задача C. Создание ключей от хранИЛИщ стало моим основным навыком</a>
  <br><a href="#task4">Задача D. Для магов нет ничего сложного в экзамене, но я его не осилил</a>
  <br><a href="#task5">Задача E. Тебе же нравится герой, который бьёт по площади двойным уроном?</a>
  <br><a href="#task6">Задача F. Прощай, жизнь банкира, здравствуй, жизнь мага</a>
  <br><a href="#task7">Задача G. Переворачивая числа 300 лет, сам того не заметив, посчитал сумму</a>
</article>


<!-- Задача A. Новый мир, новый я, новый массив -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Новый мир, новый я, новый массив</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Нацуме Акито только что очнулся в новом мире и сразу же получил первый квест! Система выдала ему массив a из n нулей, число k и число p.</p>

  <p>За одну операцию Акито выбирает такие числа i и x, что 1 ≤ i ≤ n и -p ≤ x ≤ p, и делает присвоение aᵢ = x.</p>

  <p>Акито еще не до конца разобрался с управлением новым телом, поэтому помогите ему вычислить минимальное количество операций, необходимых для того, чтобы сделать сумму всех элементов в массиве равной k, или скажите, что это невозможно.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит одно целое число t (1 ≤ t ≤ 1000) — количество наборов данных.</p>

  <p>Единственная строка каждого набора содержит три целых числа n, k, p (1 ≤ n ≤ 50, -2500 ≤ k ≤ 2500, 1 ≤ p ≤ 50) — длину массива, необходимую сумму и границу отрезка, на числа из которого можно заменять.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора данных требуется вывести минимальное количество операций для достижения итоговой суммы k в массиве, либо -1, если достичь суммы k невозможно.</p>

  <details>
    <summary>Пример</summary>
<pre>
8
21 100 10
9 -420 42
5 -7 2
13 37 7
10 0 49
1 10 9
7 -7 7
20 31 1
</pre>
<pre>
10
-1
4
6
0
-1
1
-1
</pre>
  <p>В пятом примере сумма в массиве изначально равна нулю, а значит, можно не делать ни одной операции.</p>

  <p>В шестом примере максимальная сумма в массиве, которую мы можем получить, равна 9 (в единственный элемент присвоить число 9), а значит, сумму 10 нельзя получить никакими операциями.</p>

  <p>В седьмом примере нужно сделать единственную операцию a3 = -7.</p>
  </details>
</article>


<!-- Задача B. Будучи казначеем в прошлом, я помогаю гоблинам обманывать людей -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Будучи казначеем в прошлом, я помогаю гоблинам обманывать людей</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>После выполнения первого квеста Акито вышел из начальной пещеры. Через некоторое время он набрел на гоблинскую деревню.</p>

  <p>Так как жить Акито негде, он захотел узнать цену жилья. Всем известно, что числа гоблины записывают в виде строки из символов '-' и '_', а значением, записанным строкой s, числа является количество различных подпоследовательностей∗ строки s, равных строке «-_-» (это очень похоже на лица гоблинов).</p>

  <p>Например, строка s=«-_--_-» обозначает число 6, так как имеет 6 подпоследовательностей «-_-»:</p>
  <ol>
    <li>s1+s2+s3</li>
    <li>s1+s2+s4</li>
    <li>s1+s2+s6</li>
    <li>s1+s5+s6</li>
    <li>s3+s5+s6</li>
    <li>s4+s5+s6</li>
  </ol>

  <p>Сначала гоблины в ответ на вопрос Акито написали случайную строку-число s, но потом поняли, что хотят взять с странника как можно больше золота. Для этого они просят вас переставить символы в строке s так, чтобы значение числа, записанного строкой s, было максимально.</p>

  <p>* Подпоследовательностью строки a назовем строку b, которую можно получить, удалив из a несколько (возможно, 0) символов. Подпоследовательности считаются различными, если для их получения были удалены различные множества индексов.</p>

  <h4>Входные данные</h4>
  <p>В первой строке дано число t (1 ≤ t ≤ 10⁴) — количество наборов данных.</p>

  <p>В первой строке каждого набора данных дано одно число n (1 ≤ n ≤ 2⋅10⁵) — длина строки, которую написали гоблины.</p>

  <p>Во второй строке каждого набора данных дана строка s длины n, состоящая только из символов '-' и '_' — строка, которую записали гоблины.</p>

  <p>Гарантируется, что сумма n по всем наборам данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора данных требуется вывести одно число — максимальное количество подпоследовательностей, равных строке «-_-», если оптимально переставить символы в строке s.</p>

  <details>
    <summary>Пример</summary>
<pre>
8
3
--_
5
__-__
9
--__-_---
4
_--_
10
_-_-_-_-_-
7
_------
1
-
2
_-
</pre>
<pre>
1
0
27
2
30
9
0
0
</pre>
  <p>В первом наборе данных выгодно переставить символы так, чтобы получилась строка «-_-». Это единственная строка из трех символов, которая имеет хотя бы одну подпоследовательность «-_-».</p>

  <p>Во втором наборе данных есть только один символ «-», а для подпоследовательности «-_-» нужно хотя бы два. Это значит, что для любой перестановки символов ответ будет 0.</p>

  <p>В седьмом и восьмом наборах длина строки n &lt; 3, а значит, подпоследовательностей длины 3 не существует.</p>
  </details>
</article>


<!-- Задача C. Создание ключей от хранИЛИщ стало моим основным навыком -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Создание ключей от хранИЛИщ стало моим основным навыком</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>
   <p>Акито все еще негде жить, а за комнатушку везде берут свою цену. По этой причине Акито решил устроиться в банк создателем ключей к хранилищам.</p>

  <p>В этом магическом мире все по-другому. Например, ключом от хранилища с кодом (n,x) является массив a длины n такой, что:</p>
  <ul>
    <li>a1 | a2 | a3 | … | an=x, где a | b — битовое «ИЛИ» чисел a и b.</li>
    <li>MEX({a1,a2,a3,…,an})* максимален среди всех таких массивов.</li>
  </ul>

  <p>Акито исправно выполнял свою работу несколько часов, но вдруг у него заболела голова. Подмените его на часик, для данных n
   и x создайте любой ключ к хранилищу с кодом (n,x).</p>

  <p>* MEX(S) — минимальное неотрицательное целое число z такое, что z не содержится в множестве S и все 0 ≤ y &lt; z содержатся в S.</p>

  <h4>Входные данные</h4>
  <p>В первой строке вводится число t (1 ≤ t ≤ 10⁴) — количество наборов данных.</p>

  <p>В единственной строке каждого набора данных вводятся два числа n
   и x (1 ≤ n ≤ 2⋅10⁵, 0 ≤ x &lt; 2³⁰) — длина массива и нужное значение битового «ИЛИ».</p>

  <p>Гарантируется, что сумма n по всем наборам данных не превосходит 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора требуется вывести n целых чисел aᵢ (0 ≤ aᵢ &lt; 2³⁰) — элементы массива-ключа, который удовлетворяет всем условиям.</p>

  <p>Если существует несколько подходящих массивов, выведите любой из них.</p>

  <details>
    <summary>Пример</summary>
<pre>
9
1 69
7 7
5 7
7 3
8 7
3 52
9 11
6 15
2 3
</pre>
<pre>
69
6 0 3 4 1 2 5
4 1 3 0 2
0 1 2 3 2 1 0
7 0 6 1 5 2 4 3
0 52 0
0 1 8 3 0 9 11 2 10
4 0 3 8 1 2
0 3
</pre>
  </details>
</article>


<!-- Задача D. Для магов нет ничего сложного в экзамене, но я его не осилил -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Для магов нет ничего сложного в экзамене, но я его не осилил</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Акито надоело быть простым ключником в банке, поэтому он решил поступить в Магическую Академию и стать лучшим магом этого мира! Однако для поступления требовалось решить единственную задачу на экзамене, с которой амбициозный герой никак не может справиться.</p>

  <p>В задаче ему давался массив a длины n. Требовалось минимизировать количество инверсий∗ в массиве после применения заклинания ровно один раз. Заклинание было простым, для применения Акито должен выбрать два числа l и r такие, что 1≤l≤r≤n и выполнить циклический сдвиг подотрезка с l по r на один влево.</p>

  <p>Более формально, Акито выбирает подотрезок массива [l,r]
   и меняет массив следующим образом:</p>
  <ul>
    <li>Из изначального массива [a1,a2,…,al-1,al,al+1,…,ar-1,ar,ar+1,…,an-1,an] он получает массив [a1,a2,…,al-1,al+1,al+2,…,ar-1,ar,al,ar+1,…,an-1,an].</li>
  </ul>

  <p>Акито не терпится начать обучение, но он все еще не сдал экзамен. Помогите ему поступить и решите задачу!</p>

  <p>* Инверсией в массиве b длины m называют пару индексов (i,j), где 1 ≤ i &lt; j ≤ m и bi > bj. Например, в массиве b=[3,1,4,1,5] инверсиями будут являться пары индексов (1,2), (1,4), (3,4).</p>

  <h4>Входные данные</h4>
  <p>В первой строке ввода дано число t (1 ≤ t ≤ 10⁴) — количество наборов данных.</p>

  <p>В первой строке каждого набора данных дано число n (1 ≤ n ≤ 2000) — длина массива a.</p>

  <p>Во второй строке каждого набора данных даны n чисел aᵢ (1 ≤ aᵢ ≤ 2000) — элементы массива a.</p>

  <p>Гарантируется, что сумма n² по всем наборам данных не превышает 4⋅10⁶.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора данных выводится два числа l и r (1 ≤ l ≤ r ≤ n) — границы подотрезка, который нужно выбрать, чтобы после применения заклинания количество инверсий в массиве стало минимальным.</p>

  <p>Если подходящих пар границ несколько, вы можете вывести любую из них.</p>

  <details>
    <summary>Пример</summary>
<pre>
9
7
1 4 3 2 5 3 3
6
1 4 3 2 5 3
8
7 6 5 8 4 3 2 1
10
1 1 1 5 1 1 5 6 7 8
2
1337 69
4
2 1 2 1
3
998 244 353
3
1 2 1
9
1 1 2 3 5 8 13 21 34
</pre>
<pre>
2 7
2 4
1 8
4 6
1 2
1 4
1 3
2 3
5 5
</pre>
  <p>В первом примере массив [1,4,3,2,5,3,3] превратится в массив [1,3,2,5,3,3,4]. Инверсии в нем — это (2,3), (4,5), (4,6) и (4,7). Можно показать, что меньше 4 инверсий получить нельзя.</p>

  <p>Во втором примере массив [1,4,3,2,5,3] превратится в [1,3,2,4,5,3]. Инверсии в нем — это (2,3), (4,6) и (5,6). Также подойдут l=2 и r=6, тогда массив превратится в [1,3,2,5,3,4], в нем также 3 инверсии — (2,3), (4,5) и (4,6). Можно показать, что меньше 3 инверсий получить нельзя.</p>

  <p>В четвертом примере выбор l=4 и r=6 превращает массив в [1,1,1,1,1,5,5,6,7,8]. Он отсортирован, а значит, и инверсий в нем нет.</p>

  <p>В последнем примере массив изначально отсортирован, поэтому любая операция над отрезком длины хотя бы 2 только увеличит количество инверсий.</p>
  </details>
</article>


<!-- Задача E. Тебе же нравится герой, который бьёт по площади двойным уроном? -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Тебе же нравится герой, который бьёт по площади двойным уроном?</h3>

  <div><i>Ограничение по времени 3с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Акито решил изучить новое мощное заклинание. Так как оно обладает неизмеримой силой, оно, конечно, требует много места и тщательной подготовки. Для этого Акито вышел в поле. Представим поле в виде декартовой системы координат.</p>

  <p>Для заклинания Акито нужно расставить 0 ≤ n ≤ 500 посохов в различных целочисленных координатах поля так, что будет существовать ровно k пар (i,j) таких, что 1 ≤ i &lt; j ≤ n и ρ(i,j) = d(i,j).</p>

  <p>Здесь, для двух точек с целочисленными координатами a=(xa, ya) и b=(xb, yb), ρ(a, b) = √(xa-xb)² + (ya-yb)² и d(a, b) = |xa-xb|+|ya-yb|.</p>

  <h4>Входные данные</h4>
  <p>В первой строке ввода задано одно число t (1 ≤ t ≤ 1000) — количество наборов данных.</p>

  <p>В единственной строке каждого набора данных задано одно число k (0 ≤ k ≤ 10⁵) — количество пар посохов, для которых должно выполняться равенство ρ(i,j) = d(i,j).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора данных в первой строке вывода требуется вывести число n (0 ≤ n ≤ 500) — количество расставленных посохов.</p>

  <p>В следующих n строках выводятся пары целых чисел xᵢ, yᵢ (-10⁹ ≤ xᵢ, yᵢ ≤ 10⁹) — координаты i-го посоха. Точки, в которых стоят посохи, должны быть различны.</p>

  <details>
    <summary>Пример</summary>
<pre>
3
0
2
5
</pre>
<pre>
6
69 52
4 20
789 9308706
1337 1337
-1234 -5678
23456178 707
10
-236 -346262358
273568 6435267
2365437 31441367
246574 -45642372
-236 56
4743623 -192892
10408080 -8173135
-237415357 31441367
-78125638 278
56 143231
5
1 1
2 1
1 5
3 5
1 10
</pre>
  </details>
</article>


<!-- Задача F. Прощай, жизнь банкира, здравствуй, жизнь мага -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Прощай, жизнь банкира, здравствуй, жизнь мага</h3>

  <div><i>Ограничение по времени 3с
  <br>Ограничение по памяти 256мб</i></div>

  <p>На город надвигаются монстры, и для защиты от них Акито должен создать защитное поле вокруг города. Защитные поля, как всем известно, бывают различных уровней. Акито выбрал поле n-го уровня. Чтобы возвести поле, необходима особая фраза, которая является n-й строчкой Великого Магического Треугольника, представимого в виде двумерного массива. Назовем этот массив T.</p>

  <p>Треугольник задается следующим образом:</p>
  <ul>
    <li>В i-й строке i чисел.</li>
    <li>Единственное число в первой строке — k.</li>
    <li>Пусть j-й элемент i-й строки обозначается как T<sub>i,j</sub>. Тогда
      <code>T<sub>i,j</sub> = T<sub>i-1,j-1</sub> ⊕ T<sub>i-1,j</sub>, если 1 &lt; j &lt; i</code>
      <code>T<sub>i,j</sub> = T<sub>i-1,j</sub>, если j=1</code>
      <code>T<sub>i,j</sub> = T<sub>i-1,j-1</sub>, если j=i</code>
    где a⊕b — побитовое исключающее «ИЛИ»(XOR) чисел a и b.</li>
  </ul>
  <p>Помогите Акито, найдите числа в n-й строке бесконечного треугольника, пока монстры не добрались до города.</p>

  <h4>Входные данные</h4>
  <p>В первой строке дано число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>В единственной строке каждого набора данных даны два числа n и k (1 ≤ n ≤ 10⁶, 1 ≤ k &lt; 2³¹) — номер строки, которая необходима Акито, и число в первой строке Великого Магического Треугольника соответственно.</p>

  <p>Гарантируется, что сумма n по всем наборам данных не превышает 10⁶.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора данных требуется вывести n чисел — элементы n-й строки Великого Магического Треугольника.</p>

  <details>
    <summary>Пример</summary>
<pre>
5
1 5
2 10
3 16
9 1
1 52
</pre>
<pre>
5
10 10
16 0 16
1 0 0 0 0 0 0 0 1
52
</pre>
  <p>В первом примере первая строка Великого Магического Треугольника [5] по определению.</p>

  <p>Во втором примере T<sub>2,1</sub> = T<sub>1,1</sub> = 10 и T<sub>2,2</sub> = T<sub>1,1</sub> = 10.</p>
  </details>
</article>


<!-- Задача G. Переворачивая числа 300 лет, сам того не заметив, посчитал сумму -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Переворачивая числа 300 лет, сам того не заметив, посчитал сумму</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>После трехсот лет фарма слизней Акито наконец выбил магическое число n. Дойдя до торговца, он хотел обменять число на золото, однако торговец дал герою квест.</p>

  <p>Торговец сказал, что для квеста потребуется навык rev(n,p), который Акито, по счастливой случайности, недавно изучил. rev(n,p) представляет собой следующую процедуру.</p>
  <ol>
    <li>Запишем число n в p-ичной системе счисления, пусть это запись n=n<sub>ℓ−1</sub>…n<sub>1</sub>n<sub>0</sub>, где ℓ — длина p-ичной записи числа n.</li>
    <li>Развернем p-ичную запись, пусть это m=n<sub>0</sub>n<sub>1</sub>…n<sub>ℓ−1</sub>.</li>
    <li>Перевести число m в десятичную систему счисления и вернуть как результат.</li>
  </ol>

  <p>Квест торговца заключался в подсчете суммы x=∑rev(n,p) от p=2 до k. Так как это число может быть довольно большим, то требуется найти лишь остаток от деления x на 10⁹+7. Торговец также сообщил, что предыдущий странник считал эту сумму триста лет и так и не кончил с ней. Но вы же поможете Акито справиться быстрее, ведь так?</p>

  <h4>Входные данные</h4>
  <p>В первой строке дано число t (1 ≤ t ≤ 5000) — количество наборов данных.</p>

  <p>В единственной строке каждого набора данных даны два числа n и k (1 ≤ n ≤ 3⋅10⁵, 2 ≤ k ≤ 10¹⁸) — магическое число и верхняя граница суммирования.</p>

  <p>Обратите внимание, что сумма n по наборам данных не ограничена.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора данных требуется вывести одно число — остаток от деления x=∑rev(n,p) от p=2 до k на 10⁹+7.</p>

  <details>
    <summary>Пример</summary>
<pre>
12
3 2
42 52
1 10
4 4
16 2
69 69
9 3
19 84
9982 44353
100000 1000000007
17 30
777 1000000000000000000
</pre>
<pre>
3
7594
9
6
1
33471
10
2006
120792461
584502117
775
46058362
</pre>
  <p>В третьем наборе данных n=1. Единица в любой системе счисления представляется одной цифрой, а значит rev(1,p)=1 для любого p≥2. Тогда x=∑(p=2 до k)1=∑(p=2 до 10)1=10-2+1=9.</p>

  <p>В четвертом наборе данных x=rev(4,2)+rev(4,3)+rev(4,4). Посчитаем каждое слагаемое:</p>
  <ul>
    <li>4=100₂→rev(4,2)=001₂=1</li>
    <li>4=11₃→rev(4,3)=11₃=4</li>
    <li>4=10₄→rev(4,4)=01₄=1</li>
  </ul>
  <p>Значит x=1+4+1=6.</p>
  <p>В седьмом наборе данных x=rev(9,2)+rev(9,3). Посчитаем каждое слагаемое:</p>
  <ul>
    <li>9=1001₂→rev(9,2)=1001₂=9</li>
    <li>9=100₃→rev(9,3)=001₃=1</li>
  </ul>
  <p>Значит x=9+1=10.</p>
  </details>
</article>

