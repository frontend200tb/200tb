<!-- Задача B. Пары чисел -->
<div><i>Ограничение по времени 1с
<br>Ограничение по памяти 256мб</i></div>

<p>Допустим, мы имеем пару чисел (a, b). Мы можем получить новую пару чисел вида (a + b, b) или (a, a + b) из данной. Назовем такое действие шагом.</p>

<p>Пусть начальная пара чисел — (1,1). Ваша задача — найти число k, наименьшее количество шагов, необходимых чтобы получить из (1,1) пару, в которой хотя бы одно число равно n.</p>

<h4>Входные данные</h4>
<p>Входные данные содержат единственное целое число n (1 ≤ n ≤ 10⁶).</p>

<h4>Выходные данные</h4>
<p>Выведите единственное число k.</p>

<details>
  <summary>Примеры</summary>
  <h4>Пример 1</h4>
  <code>5</code>
  <code>3</code>

  <h4>Пример 2</h4>
  <code>1</code>
  <code>0</code>
  <p>Из пары (1,1) можно за три хода получить пару, содержащую 5: (1,1) → (1,2) → (3,2) → (5,2).</p>
</details>

<details>
  <summary>Решение</summary>

  <div>
    <a href="https://codeforces.com/contest/134/problem/B" target="_blank">Задача 134B</a>
    <br><a href="https://codeforces.com/contest/134" target="_blank">Codeforces Testing Round 3 2011-11-30</a>
  </div>

  <p>Нужно из пары (1,1) получить пару (x,n). Возможен переход (a,b) -> (a+b,b) и (a, a+b). При сложении мы должны выбрать из двух вариантов какие числа складывать.</p>
  <p>Попробуем решить обратную задачу, т.е. из пары (x,n) получим пару (1,1). Возможен переход (x,y) -> (x,y-x) и (x-y,y). При переходе у нас должно получиться натуральное число, т.е. целое число больше нуля. При вычитании у нас остается только один вариант, во втором результат будет меньше нуля.</p>
  <p>Перебираем все пары и смотрим за какое количество шагов мы из пары (x,n) придем к паре (1,1). Выберем минимальное количество шагов.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

long long cnt;

long long gcd(long long a, long long b) {
  if (b == 0) {
    if (a != 1) {
      cnt += 1'000'000;
    }
    cnt += a - 1;
    return a;
  } else {
    cnt += a / b;
    return gcd(b, a % b);
  }
}

int main() {
  long long n;
  cin >> n;
  long long min_count = 10'000'000;
  for (long long i = 1; i &lt; n; i++) {
    cnt = 0;
    gcd(n, i);
    min_count = min(min_count, cnt);
  }
  if (min_count == 10'000'000) {
    cout &lt;&lt; 0;
    return 0;
  }

  cout &lt;&lt; min_count - 1;
}
</pre>
</details>
