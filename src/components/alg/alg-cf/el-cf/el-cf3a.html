<!-- Задача A. Кратчайший путь короля -->
<div><i>Ограничение по времени 1с
<br>Ограничение по памяти 64мб</i></div>

<p>Одинокий король остался совсем один на шахматной доске. Несмотря на одиночество, он вовсе не унывает — ведь ему еще надо сделать так много дел государственной важности. Например, ему надо совершить официальный визит в клетку t. Так как король не привык терять попусту время, он хочет добраться от своего местоположения s до клетки t за наименьшее число ходов. Помогите ему это сделать.</p>

<p>Король за один ход может переместиться на любую клетку, которая по стороне или углу граничит с текущей (их в общем случае 8).</p>

<h4>Входные данные</h4>
<p>В первой строке входных данных заданы шахматные координаты клетки s, а во второй — клетки t.</p>

<p>Шахматные координаты состоят из двух символов, один из которых это строчная буква латинского алфавита (от a до h), а второй — цифра от 1 до 8.</p>

<h4>Выходные данные</h4>
<p>В первую строку выведите n — минимальное число ходов короля. Далее в n строк выведите сами ходы. Каждый ход описывается одной из восьми строк: L, R, U, D, LU, LD, RU или RD.</p>

<p>L, R, U, D, соответственно, означают ходы влево, вправо, вверх и вниз (согласно рисунку), двухбуквенные обозначения соответствуют диагональным ходам. Если решений несколько, выведите любое.</p>

<details>
  <summary>Пример</summary>
<pre>
a8
h1
</pre>
<pre>
7
RD
RD
RD
RD
RD
RD
RD
</pre>
</details>

<details>
  <summary>Решение</summary>

  <div>
    <a href="https://codeforces.com/contest/3/problem/A" target="_blank">Задача 3A</a>
    <br><a href="https://codeforces.com/contest/3" target="_blank">Codeforces Beta Round 3 2010-03-07</a>
  </div>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  string s; // начальная клетка
  string t; // конечная клетка
  cin >> s >> t;

  // решение
  // достанем из строки координаты клетки
  char let = s[0];
  char dig = s[1];
  char let2 = t[0];
  char dig2 = t[1];


  // в задаче надо найти минимальное число ходов
  // короля из начальной в конечную клетку
  int step = 0;
  vector&lt;string&gt; Steps;

  while (let != let2 || dig != dig2) {

    if (let == let2 && dig2 > dig) {
      dig++;
      step++;
      Steps.push_back("U");
    }

    if (let2 > let && dig2 > dig) {
      let++;
      dig++;
      step++;
      Steps.push_back("RU");
    }

    if (let2 > let && dig2 == dig) {
      let++;
      step++;
      Steps.push_back("R");
    }

    if (let2 > let && dig > dig2) {
      let++;
      dig--;
      step++;
      Steps.push_back("RD");
    }

    if (let == let2 && dig > dig2) {
      dig--;
      step++;
      Steps.push_back("D");
    }

    if (let > let2 && dig > dig2) {
      let--;
      dig--;
      step++;
      Steps.push_back("LD");
    }

    if (let > let2 && dig == dig2) {
      let--;
      step++;
      Steps.push_back("L");
    }

    if (let > let2 && dig2 > dig) {
      let--;
      dig++;
      step++;
      Steps.push_back("LU");
    }

  }

  // вывод результата
  cout &lt;&lt; step &lt;&lt; '\n';
  for (int i = 0; i &lt; Steps.size(); i++) {
    cout &lt;&lt; Steps[i] &lt;&lt; '\n';
  }
}
</pre>
</details>
