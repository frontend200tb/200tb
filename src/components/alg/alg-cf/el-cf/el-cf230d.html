<!-- Задача D. Планеты -->
<div><i>Ограничение по времени 2с
<br>Ограничение по памяти 256мб</i></div>

<p>Гоа'улд Апофис снова захватил команду Джека О'Нила! Сам Джек смог спастись, но к тому времени корабль Апофиса уже совершил прыжок в гиперпространство. Однако Джек знает, на какой планете высадится Апофис. Чтобы спасти друзей, Джеку предстоит несколько раз пройти через звездные врата, чтобы попасть на эту планету.</p>

<p>Всего в галактике находится n планет, пронумерованных числами от 1 до n. Джек находится на планете с номером 1, а Апофис высадится на планете с номером n. Между некоторыми парами планет можно перемещаться через звездные врата (перемещение возможно в обоих направлениях); перемещение занимает положительное и, возможно, для разных пар планет неодинаковое количество секунд. Джек начинает свое путешествие в момент времени 0.</p>

<p>Может оказаться, что на планету, где сейчас находится Джек, через звездные врата прибывают другие путешественники, в этом случае Джек должен подождать ровно 1 секунду, прежде чем сам сможет воспользоваться звездными вратами. То есть, если в момент времени t на планету прибывает другой путешественник, то Джек может пройти через врата только в момент времени t + 1, если только в момент времени t + 1 на ту же планету не прибывают еще путешественники.</p>

<p>Зная информацию о времени перемещения между планетами, а также о моментах времени, когда Джек не сможет пользоваться звездными вратами на конкретных планетах, определите наименьшее время, за которое он сможет попасть на планету с номером n.</p>

<h4>Входные данные</h4>
<p>Первая строка содержит два целых числа, разделенные пробелом: n (2 ≤ n ≤ 10⁵), количество планет в галактике, и m (0 ≤ m ≤ 10⁵), количество пар планет, между которыми можно перемещаться сквозь звездные врата. Далее следуют m строк, в каждой из них содержится три целых числа: i-ая строка содержит номера планет aᵢ и bᵢ (1 ≤ aᵢ, bᵢ ≤ n, aᵢ ≠ bᵢ), между которыми есть связь через звездные врата, и целочисленное время (в секундах) перемещения между этими планетами cᵢ (1 ≤ cᵢ ≤ 10⁴). Гарантируется, что между любой парой планет существует не более одного перехода, образованного звездными вратами.</p>

<p>Далее следуют n строк: i-тая строка содержит целое число kᵢ (0 ≤ kᵢ ≤ 10⁵), которое обозначает количество моментов времени, в которые на планету с номером i прибывают другие путешественники. Далее через пробел следуют kᵢ упорядоченных по возрастанию различных целых чисел t<sub>ij</sub> (0 ≤ t<sub>ij</sub> &lt; 10⁹). Число t<sub>ij</sub> обозначает, что в момент времени t<sub>ij</sub> (в секундах) на планету i прибывает другой путешественник. Гарантируется, что сумма всех kᵢ не превышает 10⁵.</p>

<h4>Выходные данные</h4>
<p>Выведите единственное число — наименьшее количество времени, которое понадобится Джеку, чтобы попасть с планеты 1 на планету n. Если Джек не сможет попасть на планету n ни за какое время, выведите число -1.</p>

<details>
  <summary>Примеры</summary>
<h4>Пример 1</h4>
<pre>
4 6
1 2 2
1 3 3
1 4 8
2 3 4
2 4 5
3 4 3
0
1 3
2 3 4
0
</pre>
<code>7</code>

<h4>Пример 2</h4>
<pre>
3 1
1 2 3
0
1 3
0
</pre>
<code>-1</code>
<p>В первом примере у Джека три выбора, куда переместиться с планеты 1. Если он переместится сразу на планету 4, то потратит 8 секунд. Если он переместится на планету 3, то потратит 3 секунды, но, поскольку в моменты времени 3 и 4 на планету 3 прибывают другие путешественники, то он сможет отправиться на планету 4 только в момент времени 5, затратив в сумме 8 секунд. Если же Джек переместится на планету 2, а потом на планету 4, то потратит в сумме всего лишь 2 + 5 = 7 секунд.</p>
<p>Во втором примере с планеты 1 на планету 3 нельзя попасть, перемещаясь через звездные врата.</p>
</details>

<details>
  <summary>Решение</summary>

  <div>
    <a href="https://codeforces.com/contest/230/problem/D" target="_blank">Задача 230D</a>
    <br><a href="https://codeforces.com/contest/230" target="_blank">Codeforces Round 142 (Div. 2) 2012-10-01</a>
  </div>

<pre>
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

using namespace std;

const int maxn = 100000, maxm = 100000;

vector&lt;pair&lt;int, int&gt; &gt; edges[maxn];
vector&lt;int&gt; times[maxn];

int dist[maxn];

struct compar {
  bool operator ()(int v1, int v2) const {
    if (dist[v1] != dist[v2]) {
      return dist[v1] &lt; dist[v2];
    } else {
      return v1 &lt; v2;
    }
  }
};

int main() {
  ios_base::sync_with_stdio(false); cin.tie(NULL);

  int n, m; cin >> n >> m;

  for (int i = 0; i &lt; m; i++) {
    int a, b, c; cin >> a >> b >> c;
    edges[a-1].push_back(make_pair(b-1, c));
    edges[b-1].push_back(make_pair(a-1, c));
  }
  for (int i = 0; i &lt; n; i++) {
    int k; cin >> k;

    times[i].resize(k);
    for (int j = 0; j &lt; k; j++) {
      cin >> times[i][j];
    }
  }

  fill_n(dist+1, n-1, INT_MAX);

  set&lt;int, compar&gt; q;
  for (int i = 0; i &lt; n; i++) {
    q.insert(i);
  }

  while (!q.empty()) {
    int v = *q.begin(); q.erase(q.begin());
    if (v == n-1 || dist[v] == INT_MAX) {
      break;
    }

    vector&lt;int&gt;::const_iterator ti(
      lower_bound(times[v].begin(), times[v].end(), dist[v]));
    while (ti != times[v].end() && dist[v] == *ti) {
      dist[v]++;
      ++ti;
    }

    for (int i = 0; i &lt; (int)edges[v].size(); i++) {
      const pair&lt;int, int&gt;& p = edges[v][i];

      set&lt;int, compar&gt;::iterator qi(q.find(p.first));
      if (qi != q.end()) {
        if (dist[v] + p.second &lt; dist[p.first]) {
          q.erase(qi);
          dist[p.first] = dist[v] + p.second;
          q.insert(p.first);
        }
      }
    }
  }

  cout &lt;&lt; (dist[n-1] &lt; INT_MAX ? dist[n-1] : -1) &lt;&lt; '\n';
}
</pre>
</details>
