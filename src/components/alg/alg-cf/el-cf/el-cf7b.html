<!-- Задача B. Менеджер памяти -->
<div><i>Ограничение по времени 1с
<br>Ограничение по памяти 64мб</i></div>

<p>До релиза первой национальной операционной системы BerlOS осталось совсем чуть-чуть. В ней не готовы всего несколько компонентов — менеджер памяти в том числе. По задумке разработчиков, в первой версии он будет очень прост и прямолинеен. Менеджер памяти будет поддерживать три операции:</p>
<ul>
  <li>alloc n — выделить n байт памяти и вернуть идентификатор выделенного блока x;</li>
  <li>erase x — удалить блок с идентификатором x;</li>
  <li>defragment — дефрагментировать свободную память, переместив все блоки максимально к началу памяти, сохранив их относительный порядок.</li>
</ul>

<p>Модель памяти в данном случае очень проста. Память представляет собой последовательность m байт, условно пронумерованных от первого до m-го.</p>

<p>Первая операция alloc n принимает в качестве единственного параметра размер блока памяти, который предстоит выделить. При обработке этой операции в памяти выбирается свободный блок из n байт, идущих подряд. Если таких блоков несколько, то выбирается ближайший к началу памяти (первому байту). Все эти байты помечаются использованными, и менеджер возвращает 32-битное целое знаковое число, являющееся идентификатором этого блока. Если свободный блок такого размера найти невозможно, то функция возвращает специальное значение NULL.</p>

<p>Вторая операция erase x принимает в качестве параметра идентификатор некоторого блока. Она возвращает память системе, помечая байты этого блока свободными для последующего использования. В том случае, если этому идентификатору не соответствует ранее выделенный блок, который еще не был удален, то функция возвращает специальное значение ILLEGAL_ERASE_ARGUMENT.</p>

<p>Последняя операция defragment не имеет аргументов и просто перемещает занятые участки памяти вплотную к ее началу, не меняя их относительный порядок. Таким образом, после этой операции вся свободная память образует один непрерывный участок, который идет следом за использованной памятью.</p>

<p>В текущей реализации требуется использовать в качестве идентификаторов последовательные целые числа от 1. Каждый успешный вызов alloc должен возвращать очередное число. Неудачные вызовы alloc не оказывают влияния на описанную нумерацию.</p>

<p>Ваша задача состоит в том, чтобы написать реализацию менеджера памяти. Для каждой команды alloc нужно выводить возвращаемое значение. Также следует выводить ILLEGAL_ERASE_ARGUMENT для всех неудачных вызовов erase.</p>

<h4>Входные данные</h4>
<p>В первой строке входных данных содержатся два целых положительных числа t и m (1 ≤ t ≤ 100; 1 ≤ m ≤ 100), где t — количество операций, заданных менеджеру памяти на исполнение, а m — размер доступной памяти в байтах. Далее в t строках заданы сами операции. Первая операция задается строкой alloc n (1 ≤ n ≤ 100), где n целое число. Вторая задается строкой erase x, где x произвольное 32-битное целое знаковое число. Третья операция задается строкой defragment.</p>

<h4>Выходные данные</h4>
<p>Выведите последовательность строк. Каждая строка должна содержать либо результат работы операции alloc, либо ILLEGAL_ERASE_ARGUMENT как результат неудачного выполнения операции erase. Вывод следует осуществлять в порядке совершения операций. Реализация alloc должна возвращать в качестве идентификаторов выделенных блоков целые числа, начиная с 1.</p>

<details>
  <summary>Примеры</summary>
  <h4>Пример 1</h4>
<pre>
6 10
alloc 5
alloc 3
erase 1
alloc 6
defragment
alloc 6
</pre>
<pre>
1
2
NULL
3
</pre>
</details>
