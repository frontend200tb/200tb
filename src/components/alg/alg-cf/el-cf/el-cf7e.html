<!-- Задача E. Проверка макросов -->
<div><i>Ограничение по времени 3с
<br>Ограничение по памяти 256мб</i></div>

<p>Большинство программистов на C/C++ знают об отличных возможностях, предоставляемых директивами препроцессора #define, но также многим известны и проблемы, возникающие при их неаккуратном использовании.</p>

<p>В данной задаче мы рассматриваем следующую модель конструкций #define (также называемых макросами). Каждый макрос имеет свои имя и значение. Объявляется он следующим образом:</p>

<code>#define имя_макроса значение_макроса</code>

<p>После этого объявления везде, где в программе встречается слово "имя_макроса" (как отдельный токен, т.е. как подстрока, окружённая неалфавитными символами), оно заменяется на "значение_макроса". В "значение_макроса" в рамках нашей модели может быть записано только какое-либо арифметическое выражение, содержащее переменные, четыре арифметических операции, скобки, а также имя ранее объявленных макросов (в этом случае замена производится по цепочке). Процесс замены макросов на их значения называется подстановкой.</p>

<p>Одна из основных проблем, возникающих при использовании макросов — когда после выполнения подстановки получается арифметическое выражение, в котором из-за разных приоритетов операций может неожиданно измениться порядок вычисления.</p>

<p>Рассмотрим это на следующем примере. Определим такую конструкцию #define:</p>

<code>#define sum x + y</code>

<p>и пусть далее в программе считается выражение "2 * sum". После подстановки макроса получится выражение "2 * x + y", вместо интуитивно ожидаемого "2 * (x + y)".</p>

<p>Определим "подозрительной" ситуацию, когда после выполнения подстановки макроса порядок вычислений меняется, выходя за пределы какого-либо макроса. Соответственно, Ваша задача — по набору определений #define и заданному выражению определить, является это выражение подозрительным или нет.</p>

<p>Определим это более формально. Выполним обычную подстановку макросов в заданном выражении. Кроме того, выполним "безопасную" подстановку макросов в выражение: окружив значение каждого макроса скобками; после этого, пользуясь арифметическими правилами раскрытия скобок, можно опустить некоторые скобки. Если при этом можно получить выражение, полностью совпадающее с результатом обычной подстановки (посимвольно, но игнорируя пробелы), то это выражение и система макросов считаются корректными, иначе — подозрительными.</p>

<p>Примечание. В этом критерии операция деления рассматривается с математической точки зрения, а не в смысле языка C++ (в котором под ним подразумевается деление нацело). Например, в выражении "a*(b/c)" мы можем опустить скобки и получить выражение "a*b/c".</p>

<h4>Входные данные</h4>
<p>В первой строке записано единственное число n (0 ≤ n ≤ 100) — число конструкций #define в рассматриваемой программе.</p>

<p>Далее идут n строк, в каждой из которых записана ровно одна конструкция #define. Каждая конструкция имеет вид:</p>

<code>#define name expression</code>

<p>где</p>
<ul>
  <li>name — имя макроса,</li>
  <li>expression — выражение, на которое будет заменяться данный макрос. Выражение — это непустая строка, составленная из чисел, названий переменных, имён ранее объявленных макросов, круглых скобок и знаков операций +-*/. Гарантируется, что выражение (до и после подстановки макросов) является корректным арифметическим выражением, в котором отсутствуют унарные операции. В выражении содержатся только целые неотрицательные числа, не превосходящие 10⁹.</li>
</ul>

<p>Все имена (имена конструкций #define и имена их аргументов) являются строками из латинских символов, чувствительными к регистру. Гарантируется, что имя любой переменной отлично от имени любой конструкции #define.</p>

<p>Далее, в последней строке записано некоторое выражение expression, для которого и требуется выполнить проверку. Это выражение непусто и удовлетворяет тем же ограничениям, что и выражения в конструкциях #define.</p>

<p>Во входных строках может присутствовать произвольное число пробелов в любом месте, если только эти пробелы не разрывают слово "define" или имена конструкций или переменных. В частности, до и после символа "#" может стоять произвольное число пробелов.</p>

<p>Длина любой строки входного файла не превосходит 100 символов.</p>

<h4>Выходные данные</h4>
<p>Выведите строку "OK", если выражение корректно с точки зрения критерия, описанного в условии, иначе выведите "Suspicious".</p>

<details>
  <summary>Примеры</summary>
  <h4>Пример 1</h4>
<pre>
1
#define sum x + y
1 * sum
</pre>
  <code>Suspicious</code>

  <h4>Пример 2</h4>
<pre>
1
#define sum  (x + y)
sum - sum
</pre>
  <code>OK</code>

  <h4>Пример 3</h4>
<pre>
4
#define sum  x + y
#define mul  a * b
#define div  a / b
#define expr sum + mul * div * mul
expr
</pre>
  <code>OK</code>

  <h4>Пример 4</h4>
<pre>
3
#define SumSafe   (a+b)
#define DivUnsafe  a/b
#define DenominatorUnsafe  a*b
((SumSafe) + DivUnsafe/DivUnsafe + x/DenominatorUnsafe)
</pre>
  <code>Suspicious</code>
</details>
