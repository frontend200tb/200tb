<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contests" target="_blank">Codeforces ЯрГУ. Школьники</a></p>
  <p><a href="https://vk.com/sportprog_yarsu" target="_blank">vk.com/sportprog_yarsu</a></p>
  <p><a href="https://vkvideo.ru/@sportprog_yarsu" target="_blank">vkvideo.ru/@sportprog_yarsu</a></p>
</article>


<article class="article">
  <h1>Занятие 9. Базовые алгоритмы #2. Два указателя</h1>
  <p>Конспект видео от 2024.11.09</p>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contest/565018" target="_blank">Codeforces Контест 565018</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
        <a href="#p1">Два указателя</a>
    <br><a href="#t1">Задача 1. Слияние</a>
    <br><a href="#t2">Задача 2. Поддержка отрезка</a>
  </p>
  <p>
        <a href="#task1">Задача A. Книги</a>
    <br><a href="#task2">Задача B. Министерство правды</a>
    <br><a href="#task3">Задача C. Правый минус левый</a>
    <br><a href="#task4">Задача D. Сбалансированная команда</a>
    <br><a href="#task5">Задача E. Сумма чисел в массиве</a>
    <br><a href="#task6">Задача F. Любимая последовательность</a>
    <br><a href="#task7">Задача G. Сережа и Дима</a>
    <br><a href="#task8">Задача H. Три части массива</a>
    <br><a href="#task9">Задача I. Бал в БерлГУ</a>
    <br><a href="#task10">Задача J. Точки на прямой</a>
    <br><a href="#task11">Задача K. Съедая конфеты</a>
    <br><a href="#task12">Задача L. Несекретный шифр</a>
    <br><a href="#task13">Задача M. Олимпиада</a>
    <br><a href="#task14">Задача N. Сдвиги</a>
    <br><a href="#task15">Задача O. Прибавляй не прибавляй</a>
    <br><a href="#task16">Задача P. Кефа и компания</a>
    <br><a href="#task17">Задача Q. Медианное сглаживание</a>
    <br><a href="#task18">Задача R. Оденьте их скорее</a>
  </p>
</article>


<!-- Два указателя -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Два указателя</h3>

  <h4>Метод двух указателей</h4>
  <p>Метод двух указателей - выжный метод, который часто используется в спортивном программировании</p>
  <p>Метод используется для отслеживания элементов в массиве, позиций или поддержания некоторого условия по задаче</p>
  <p>Сам метод лучше обозначать как метод k указателей или метод конечного количества указателей</p>

  <h4>Применение</h4>
  <p>Использование метода двух указателей не заканчивается применением решений задачи слияния и поддержки хороших отрезков. Приведем еще несколько способов применения алгоритма</p>
  <ol>
    <li>Движение двух указателей в одном направлении на массиве с фиксированным шагом</li>
    <li>Движение двух указателей друг к другу с концов массива</li>
    <li>Подсчет величин на хороших отрезках</li>
    <li>Нахождение отрезка с наименьшим разбросом элементов</li>
    <li>Подсчет хороших отрезков</li>
  </ol>
</article>


<!-- Задача 1. Слияние -->
<article class="article">
  <div class="anchor" id="t1"></div>
  <h3>Задача 1. Слияние</h3>

  <p>Даны два отсортированных массива, необходимо объединить их в один отсортированный массив</p>
  <p>Наивное решение: объединить два массива в один и отсортировать. Сложность по времени O(NlogN)</p>

  <details>
    <summary>Решение</summary>
    <p>Решим эту задачу поэтапно.</p>
    <p>Для начала определим какой элемент должен быть в позициии C[0]. Поскольу массивы A и B отсортированны, то наименьший элемент из A[0] и B[0] должен быть перенесен в C[0].</p>
    <p>Для определения какой элемент должен быть в C[1] мы будем выбирать из двух текущих минимальных оставшихся элементов массива A и B.</p>
    <p>Процесс выбора будет повторяться до тех пор, пока один из массивов A, B полностью не будет перенесен в массив C.</p>
    <p>Создадим 3 указателя, которые будут хранить индексы и указывать на элементы массивов A, B, C. Мы будем сдвигать указатели в массивах для отслеживания необходимых нам элементов.</p>
    <p>Сложность O(n)</p>
<pre>
int u1 = 0, u2 = 0, u3 = 0;

while (u1 &lt; A.size() && u2 &lt; B.size()) {
  if (A[u1] &lt; B[u2]) {
    C[u3] = A[u1];
    u1++;
    u3++;
  } else {
    C[u3] = B[u2];
    u2++;
    u3++;
  }
}

while (u1 &lt; A.size()) {
  c[u3] = A[u1];
  u1++;
  u3++;
}

while (u2 &lt; B.size()) {
  c[u3] = B[u2];
  u2++;
  u3++;
}
</pre>
  </details>
</article>


<!-- Задача 2. Поддержка отрезка -->
<article class="article">
  <div class="anchor" id="t2"></div>
  <h3>Задача 2. Поддержка отрезка</h3>

  <p>Рассмотрим задачу о поддержании длины "хорошего" отрезка в массиве. Дан массив, определить максимальную длину "хорошего" подмассива. Например, максимальный подмассив в котором нет нулей.</p>
  <p>Наивное решение этой задачи является for for for, с трудоемкостью O(n<sup>3</sup>), где мы перебираем границы всех вариантов отрезков и перепроверяем условие хорошести на отрезке</p>

  <details>
    <summary>Решение за O(n<sup>3</sup>)</summary>
<pre>
int max_size = 0;
bool flag = true;
for (int i = 0; i &lt; n; i++) {
  for (int j = i; j &lt; n; j++) {
    flag = true;
    for (int k = i; k &lt;= j; k++) {
      if (A[k] == 0) {
        flag = false;
      }
    }
    if (flag && max_size &lt; j - i + 1)
    max_sie = j - i + 1;
  }
}
</pre>
  </details>
  <p>В каждой задаче понятие "хороший" индивидуально.</p>
  <p>Пусть у нас есть дополнительные ограничения. Если отрезок хороший, то любой его подотрезок тоже хороший. Если отрезок плохой, то любой его подотрезок либо плохой, либо хороший</p>
  <p>Заведем два указателя l и r и поставим их на первый элемент. Есть два варианта. Первый элемент или хороший или нет. Если первый элемент хороший, в цикле будем двигать правый указатель вправо и проверять отрезок все еще хороший или нет. Если все еще хороший, то дальше двигаем правый указатель вправо. Если уже плохой, или первый элемент был плохой, то двигаем левый указатель вправо до тех пор, пока не найдем хороший элемент или отрезок.</p>
  <p>Рассмотрим два алгоритма поиска максимальной длины хорошего отрезка - школьный и студенческий. У них одинаковая сложность O(n).</p>
  <p>Школьный алгоритм: двигаем вправо на 1 левую или правую границу отрезка.</p>
<pre>
while (r &lt; n) {
  if (отрезок хороший) {
    r++;
  } else {
    l++;
  }
}
</pre>
  <p>Студенческий алгоритм: всегда двигаем правую границу, поэтому создадим ее как счетчик в цикле.</p>
<pre>
for (int r = 0; r &lt; n; r++) {
  ... // какие-то действия
  while (отрезок плохой) {
    l++;
  }
}
</pre>
</article>


<!-- Задача A. Книги -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Книги</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Когда у Валеры появляется свободное время, он идет в библиотеку и читает книги. Вот и сегодня у него появилось t свободных минут для чтения. Поэтому Валера взял n книг в библиотеке и для каждой книги оценил: какое время потребуется, чтобы ее прочитать. Пронумеруем книги целыми числами от 1 до n. Для прочтения i-той книги Валере требуется a<sub>i</sub> минут.</p>

  <p>Валера решил, что он выберет произвольную книгу с номером i и будет читать книги друг за другом, начиная с этой книги. Другими словами, сначала он прочитает книгу c номером i, затем книгу с номером i + 1, затем книгу с номером i + 2 и так далее. Он продолжает этот процесс до тех пор, пока либо не закончится его свободное время, либо не прочитает книгу с номером n. Каждую книгу Валера читает целиком, то есть он не читает книгу, которую не успеет дочитать до конца из-за нехватки свободного времени.</p>

  <p>Посчитайте максимальное количество книг, которое Валера сможет прочитать.</p>

  <h4>Входные данные</h4>
  <p>В первой строке заданы два целых числа n и t (1≤ n ≤ 10<sup>5</sup>; 1 ≤ t ≤ 10<sup>9</sup>) — количество книг и количество свободных минут у Валеры соответственно. Во второй строке задана последовательность из n целых чисел a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> (1 ≤ a<sub>i</sub> ≤ 10<sup>4</sup>), в которой число a<sub>i</sub> обозначает количество минут, которое требуется для прочтения i-ой книги.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное целое число — максимальное количество книг, которое Валера сможет прочитать.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
4 5
3 1 2 1
</pre>
    <code>3</code>

    <h4>Пример 2</h4>
<pre>
3 3
2 2 3
</pre>
    <code>1</code>
  </details>

  <h4>Решение за O(n<sup>2</sup>)</h4>
    <p>Начнем с первой книги. Будем добавлять книги пока время их прочтения &le; t минут. Заведем два указателя left и right. Сделаем цикл в цикле. В первом цикле проходим по left от 0 до n - 1. Во вложенном цикле проходим по right от left до n - 1 и делаем проверку накопленной суммы. Можно придумать более быстрое решение.</p>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/279/problem/B" target="_blank">Задача 279B</a>
      <br><a href="https://codeforces.com/contest/279" target="_blank">Codeforces Round 171 (Div. 2) 2013-03-04</a>
    </div>

    <p>В одном цикле будем сдвигать правую границу и делать проверку. Если проверка не прошла, то сдвигаем левую границу.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ввод данных
  int n; // числол книг
  int t; // число минут
  cin >> n >> t;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  int sum = 0;
  int res = 0;
  int l = 0;

  for (int r = 0; r &lt; n; r++) {
    sum += A[r];
    while (sum > t) {
      sum -= A[l];
      l++;
    }
    res = max(res, r - l + 1);
  }

  //вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача B. Министерство правды -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Министерство правды</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Андрей работает в министерстве правды. Его работа состоит в том, чтобы изменять статьи в газетах и журналах таким образом, чтобы они восхваляли партию и Большого Брата.</p>

  <p>Недавно Большой Брат решил, что было бы неплохо, если бы все слова во всех статьях читались бы одинаково как справа налево, так и слева направо. По его мнению, это должно серьезно облегчить чтение статей, ведь если случайно прочитать слово задом наперед, его смысл не изменится.</p>

  <p>Андрей тратит одну секунду, чтобы стереть одну букву в слове и написать вместо нее новую. Ему осталось изменить всего лишь одно слово, после чего он выполнит план и сможет пойти домой. Разумеется, ему надо потратить на это как можно меньше времени. Правда, он пока не совсем понимает, какое именно слово должно получиться после замены. Помогите ему в этом.</p>

  <h4>Входные данные</h4>
  <p>В единственной строке записано слово, которое надо изменить Андрею. Оно состоит из строчных латинских букв и имеет длину от 1 до 200000.</p>

  <h4>Выходные данные</h4>
  <p>Выведите слово, которое должно получиться у Андрея в результате. Если существует несколько возможных таких слов, выведите любое.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>abccabd</code>
    <code>abacaba</code>

    <h4>Пример 2</h4>
    <code>wasitadogoracatiate</code>
    <code>wasitacaroracatisaw</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/gym/100187/problem/L" target="_blank">Задача 100187L</a>
      <br><a href="https://codeforces.com/gym/100187" target="_blank">2013, VI Самарская областная межвузовская олимпиада по программированию 2013-04-27</a>
    </div>

    <p>Паттерн два указателя с двух сторон. Заведем левый и правый указатели. Пока левый указатель меньше правого, сравниваем буквы. Если буквы совпадают, то двигаем левый указатель вправо, правый влево. Если буквы не совпадают, то в правый указатель пишем букву из левого указателя и двигаем их.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  string s;
  cin >> s;

  // решение
  int pl = 0, pr = s.size() - 1;
  while (pl &lt; pr) {
    if (s[pl] != s[pr]) {
      s[pr] = s[pl];
    }
    pl++;
    pr--;
  }

  // вывод результата
  cout &lt;&lt; s;
}
</pre>
  </details>
</article>


<!-- Задача C. Правый минус левый -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Правый минус левый</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Найдите в заданном массиве пару элементов, что правый минус левый — максимально. Более формально, найти такую пару индексов i и j, что i&lt;j, и a[j]-a[i] максимальное.</p>

  <h4>Входные данные</h4>
  <p>В первой строке вводится N — количество элементов в массиве. (2≤N≤10<sup>5</sup>) Во второй строке вводится N чисел через пробел — заданный массив. Каждый элемент массива не превосходит 1000 по абсолютной величине.</p>

  <h4>Выходные данные</h4>
  <p>Выведите 2 пару индексов i и j через пробел, что i&lt;j, и a[j]-a[i] максимальное. Если ответов несколько выведите такой, где j наименьшее. Если и таких несколько, то такой где i наименьший.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
6
3 4 1 3 5 7
</pre>
    <code>3 6</code>

    <h4>Пример 2</h4>
<pre>
6
3 4 7 3 5 1
</pre>
    <code>1 3</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Начнем с предположения, что максимальная разница — это разница между вторым и первым элементами. Запомним эти индексы (1 и 2). Будем поддерживать индекс min_index, который указывает на минимальный элемент в пройденной части массива. Для каждого следующего элемента вычисляем разницу с этим минимальным элементом. Если текущая разница больше максимальной найденной, обновляем максимальную разницу и сохраняем индексы. При обновлении максимальной разницы всегда выбираем пару с наименьшим j, а при равенстве — с наименьшим i.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;

  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  int best_i = 0;
  int best_j = 1;
  int max_dif = A[best_j] - A[best_i];
  int min_index = 0;
  for (int j = 1; j &lt; n; ++j) {
    if (A[j] - A[min_index] > max_dif) {
      max_dif = A[j] - A[min_index];
      best_i = min_index;
      best_j = j;
    } else if (A[j] - A[min_index] == max_dif) {
      if (j &lt; best_j) {
        best_j = j;
        best_i = min_index;
      } else if (j == best_j && min_index &lt; best_i) {
        best_i = min_index;
      }
    }

    if (A[j] &lt; A[min_index]) {
      min_index = j;
    }
  }

  // вывод результата
  cout &lt;&lt; best_i + 1 &lt;&lt; ' ' &lt;&lt; best_j + 1;
}
</pre>
  </details>
</article>


<!-- Задача D. Сбалансированная команда -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Сбалансированная команда</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вы — университетский тренер. Всего в университете под Вашим надзором n студентов, умение программировать i-го студента равно a<sub>i</sub>.</p>

  <p>Вы хотите составить команду для нового соревнования по программированию. Как Вы знаете, чем больше студентов на соревновании — тем больше шансов победить! Поэтому Вы хотите составить максимальную по количеству студентов команду. Но Вы также знаете, что команда должна быть сбалансированной. Это означает, что умение программировать каждой пары студентов в команде должно отличаться не более, чем на 5.</p>

  <p>Ваша задача — найти максимально возможное количество студентов в сбалансированной команде.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит одно целое число n (1≤n≤2⋅10<sup>5</sup>) — количество студентов.</p>

  <p>Вторая строка входных данных содержит n целых чисел a<sub>1</sub>,a<sub>2</sub>,…,a<sub>n</sub> (1≤a<sub>i</sub>≤10<sup>9</sup>), где a<sub>i</sub> означает умение i-го студента программировать.</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно целое число — максимально возможное количество студентов в сбалансированной команде.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
6
1 10 17 12 15 2
</pre>
  <code>3</code>
    <p>В первом тестовом примере Вы можете создать команду с умениями [12,17,15].</p>

    <h4>Пример 2</h4>
<pre>
10
1337 1337 1337 1337 1337 1337 1337 1337 1337 1337
</pre>
    <code>10</code>
    <p>Во втором тестовом примере Вы можете взять всех студентов в команду, потому что их умения программировать равны.</p>

    <h4>Пример 3</h4>
<pre>
6
1 1000 10000 10 100 1000000000
</pre>
    <code>1</code>
    <p>В третьем тестовом примере Вы можете создать команду, состоящую из одного студента (и не можете создать команду, состоящую хотя бы из двух студентов).</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1133/problem/C" target="_blank">Задача 1133C</a>
      <br><a href="https://codeforces.com/contest/1133" target="_blank">Codeforces Round 544 (Div. 3) 2019-03-07</a>
    </div>

    <p>Отсортируем массив по возрастанию. Будем отслеживать максимальную длиину отрезка, в котором крайний правый элемент и крайний левый элемент отличаются не больше чем на 5.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  sort(A.begin(), A.end());
  int l = 0;
  int r = 0;
  int res = 1;
  while (r &lt; A.size()) {
    if (A[r] - A[l] &lt;= 5) {
      res = max(res, r - l + 1);
      r++;
    } else {
      l++;
    }
  }

  //вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача E. Сумма чисел в массиве -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Сумма чисел в массиве</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В одномерном массиве, заполненном произвольными целыми числами, за один проход найдите непрерывный кусок, сумма чисел в котором максимальна.</p>

  <p>Примечание. Фактически требуется найти такие i и j (i≤j), что сумма всех элементов массива от a<sub>i</sub> до a<sub>j</sub> включительно будет максимальна.</p>

  <h4>Входные данные</h4>
  <p>На вход программе сначала подается натуральное n&le;100000  — количество элементов в массиве. Далее, по одному в строке расположены сами элементы массива — целые числа, по модулю не превосходящие 30000.</p>

  <h4>Выходные данные</h4>
  <p>Выдайте пару искомых значений индексов. Если таких пар несколько, то j  должно быть минимально возможным, а при равных j  значение i должно быть максимально возможным.</p>

  <details>
    <summary>Пример</summary>
<pre>
5
-1
2
3
-2
2
</pre>
    <code>2 3</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Будем использовать булевский флаг, который определит крайний случай, когда все элементы отрицательные. Если все элементы отрицательные, то максимальный из них это и будет ответ</p>
    <p>Заведем два указателя l и r. Будем поддерживать отрезок пока он хороший. Пусть отрезок хороший если он больше нуля. Увеличиваем r пока отрезок хороший. Увеличиваем l если отрезок стал плохим.</p>
    <p>В этой задаче мы отступаем от правила, что все элементы внутри хорошего отрезка могут быть только хорошими. В этой задаче мы допускаем плохие элементы внутри хорошего отрезка.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;
  vector&lt;long long&gt; A(n + 1);
  bool flag = false;
  for (int i = 1; i &lt;= n; i++) {
    cin >> A[i];
    if (A[i] > 0) {
      flag = true;
    }
  }

  // решение и вывод результата
  if (flag == false) {
    int id = 1;
    int el = -1e7; // -10 000 000
    for (int i = 1; i &lt;= n; i++) {
      if (A[i] > el) {
        id = i;
        el = A[i];
      }
    }
    cout &lt;&lt; id &lt;&lt; " " &lt;&lt; id;
  } else {
    long long max_sum = -1;
    long long sum = 0;
    long long l = 1;
    // границы оптимального ответа
    int left = 0, right = 0;

    for (int r = 1; r &lt;= n; r++) {
      sum += A[r];
      while (sum &lt;= 0 && l &lt;= r) {
        sum -= A[l];
        l++;
      }
      if (sum > max_sum) {
        max_sum = sum;
        left = l;
        right = r;
      }
    }
    cout &lt;&lt; left &lt;&lt; " " &lt;&lt; right;
  }
}
</pre>
  </details>
</article>


<!-- Задача F. Любимая последовательность -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Любимая последовательность</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У Поликарпа есть любимая последовательность a[1…n], которая состоит из n целых чисел. Он выписал ее на доску следующим образом:</p>
  <ul>
    <li>максимально слева (в начале доски) он написал число a<sub>1</sub>;</li>
    <li>максимально справа (в конце доски) он написал число a<sub>2</sub>;</li>
    <li>потом максимально слева (но правее, чем a<sub>1</sub>) он написал число a<sub>3</sub>;</li>
    <li>потом максимально справа (но левее, чем a<sub>2</sub>) он написал число a<sub>4</sub>;</li>
    <li>Поликарп продолжил действовать также, пока не выписал на доску всю последовательность.</li>
  </ul>

  <p>Вот что будет изображено после четырёх действий (конечно, если n≥4).</p>
  <code>a<sub>1</sub> a<sub>3</sub> ... a<sub>4</sub> a<sub>2</sub></code>
  <p>Например, если n=7 и a=[3,1,4,1,5,9,2], то Поликарп выпишет на доску последовательность [3,4,5,2,9,1,1].</p>
  <p>Вы увидели последовательность на доске и теперь хотите узнать, какая была любимая последовательность Поликарпа.</p>

  <h4>Входные данные</h4>
  <p>В первой строке находится одно целое число t (1≤t≤300) — количество наборов входных данных. Далее следуют t наборов входных данных.</p>

  <p>В первой строке каждого набора входных данных находится целое число n (1≤n≤300) — длина последовательности, записанной на доске.</p>

  <p>В следующей строке находятся n целых чисел b<sub>1</sub>,b<sub>2</sub>,…,b<sub>n</sub> (1≤b<sub>i</sub>≤10<sup>9</sup>) — последовательность на доске.</p>

  <h4>Выходные данные</h4>
  <p>Выведите t ответов на наборы входных данных. Каждый ответ — это последовательность a, которую Поликарп выписывал на доску.</p>

  <details>
    <summary>Пример</summary>
<pre>
6
7
3 4 5 2 9 1 1
4
9 2 7 1
11
8 4 3 1 2 7 8 7 9 4 2
1
42
2
11 7
8
1 1 1 1 1 1 1 1
</pre>
<pre>
3 1 4 1 5 9 2
9 1 2 7
8 2 4 4 3 9 1 7 2 8 7
42
11 7
1 1 1 1 1 1 1 1
</pre>
    <p>В первом наборе входных данных последовательность a совпадает с последовательностью из условия. Состояния доски после каждого шага выглядят так:</p>
    <code>[3]⇒[3,1]⇒[3,4,1]⇒[3,4,1,1]⇒[3,4,5,1,1]⇒[3,4,5,9,1,1]⇒[3,4,5,2,9,1,1].</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1462/problem/A" target="_blank">Задача 1462A</a>
      <br><a href="https://codeforces.com/contest/1462" target="_blank">Codeforces Round 690 (Div. 3) 2020-12-15</a>
    </div>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n;
    cin >> n;
    vector&lt;int&gt; B(n + 1, 0);
    for (int i = 1; i &lt;= n; i++) {
      cin >> B[i];
    }

    // решение
    vector&lt;int&gt; A;
    int left = 1, right = n;

    while (right > left) {
      A.push_back(B[left]);
      A.push_back(B[right]);
      left++;
      right--;
    }

    if (left == right) {
      A.push_back(B[left]);
    }

    // вывод результата
    for (int i = 0; i &lt; A.size(); i++) {
      cout &lt;&lt; A[i] &lt;&lt; ' ';
    }
    cout &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача G. Сережа и Дима -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Сережа и Дима</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Сережа и Дима играют в игру. Правила игры очень просты. Перед игроками лежат в ряд n карточек. На каждой карточке написано число, причем все числа на карточках различны. Игроки ходят по очереди, первый ходит Сережа. На свой ход можно забрать себе одну карточку: либо самую левую карточку из ряда, либо самую правую. Игра заканчивается, когда в ряду не осталось карточек. Выигрывает тот, у кого в конце игры сумма чисел на взятых карточках больше.</p>

  <p>Сережа и Дима действуют жадно. На своем ходе, каждый из них из двух карточек выбирает ту, на которой написано большее число.</p>

  <p>Инна — подруга Сережи и Димы. Она знает какую стратегию используют ребята, поэтому хочет по изначальному состоянию игры определить, какой в конце игры будет счет. Помогите ей.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое число n (1 ≤ n ≤ 1000) — количество карточек на столе. Во второй строке через пробел перечислены числа, записанные на карточках, в порядке слева направо. Числа на карточках — различные целые числа от 1 до 1000.</p>

  <h4>Выходные данные</h4>
  <p>Выведите в единственной строке два целых числа. Первое число — это количество очков у Сережи в конце игры, второе — количество очков у Димы в конце игры.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
4
4 1 2 10
</pre>
    <code>12 5</code>
    <p>В первом тесте Сережа возьмет карточки с числами 10 и 2, таким образом сумма Сережи 12. Дима возьмет все остальные карточки с суммой 5.</p>

    <h4>Пример 2</h4>
<pre>
7
1 2 3 4 5 6 7
</pre>
    <code>16 12</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/381/problem/A" target="_blank">Задача 381A</a>
      <br><a href="https://codeforces.com/contest/381" target="_blank">Codeforces Round 223 (Div. 2) 2014-01-12</a>
    </div>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ускорение ввода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);

  // ввод данных
  int n;
  cin >> n;

  vector&lt;int&gt; A(n + 1);
  for (int i = 1; i &lt;= n; i++) {
    cin >> A[i];
  }

  // решение
  int s = 0, d = 0;
  int l = 1, r = n;

  while (r > l) {
    if (A[r] > A[l]) {
      s += A[r];
      r--;
    } else {
      s += A[l];
      l++;
    }
    if (A[r] > A[l]) {
      d += A[r];
      r--;
    } else {
      d += A[l];
      l++;
    }
  }

  if (r == l) {
    s += A[r];
  }

  // вывод результата
  cout &lt;&lt; s &lt;&lt; ' ' &lt;&lt; d;
}
</pre>
  </details>
</article>


<!-- Задача H. Три части массива -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Три части массива</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Задан массив d<sub>1</sub>,d<sub>2</sub>,…,d<sub>n</sub>, состоящий из n целых чисел.</p>

  <p>Ваша задача — разделить этот массив на три части (некоторые из которых могут быть пустыми) таким образом, что каждый элемент массива принадлежит ровно одной из частей, и каждая часть образует последовательный непрерывный подотрезок (возможно, пустой) изначального массива.</p>

  <p>Пусть сумма элементов первой части равна sum<sub>1</sub>, сумма элементов второй части равна sum<sub>2</sub> и сумма элементов третьей части равна sum<sub>3</sub>. Среди всех возможных разбиений массива вам нужно выбрать такое, что sum<sub>1</sub>=sum<sub>3</sub> и sum<sub>1</sub> является максимально возможной.</p>

  <p>Более формально, если первая часть массива содержит a элементов, вторая часть массива содержит b элементов и третья часть массива содержит c элементов, тогда:</p>
  <code>sum<sub>1</sub>=∑d<sub>i</sub> (1≤i≤a),</code>
  <code>sum<sub>2</sub>=∑d<sub>i</sub> (a+1≤i≤a+b),</code>
  <code>sum<sub>3</sub>=∑d<sub>i</sub> (a+b+1≤i≤a+b+c).</code>
  <p>Сумма пустого массива равна 0.</p>

  <p>Ваша задача найти такое разбиение массива, что sum<sub>1</sub>=sum<sub>3</sub> и sum<sub>1</sub> является максимально возможной.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит одно целое число n  (1≤n≤2⋅10<sup>5</sup>) — количество элементов массива d.</p>

  <p>Вторая строка входных данных содержит n целых чисел d<sub>1</sub>,d<sub>2</sub>,…,d<sub>n</sub> (1≤d<sub>i</sub>≤10<sup>9</sup>) — элементы массива d.</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно целое число — максимально возможное значение sum<sub>1</sub>, удовлетворяющее условию sum<sub>1</sub>=sum<sub>3</sub>.</p>

  <p>Очевидно, всегда существует хотя бы один способ разбить массив нужным образом (если a=c=0 и b=n).</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
5
1 3 1 1 4
</pre>
    <code>5</code>
    <p>В первом тестовом примере только одно возможное разбиение, которое максимизирует sum<sub>1</sub> : [1,3,1],[ ],[1,4].</p>

    <h4>Пример 2</h4>
<pre>
5
1 3 2 1 4
</pre>
    <code>4</code>
    <p>Во втором тестовом примере существует единственный способ набрать sum<sub>1</sub>=4 : [1,3],[2,1],[4].</p>
  </details>

  <h4>Пример 3</h4>
<pre>
3
4 1 2
</pre>
  <code>0</code>
  <p>В третьем тестовом примере есть только один способ разделить массив: [ ],[4,1,2],[ ].</p>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1006/problem/C" target="_blank">Задача 1006C</a>
      <br><a href="https://codeforces.com/contest/1006" target="_blank">Codeforces Round 498 (Div. 3) 2018-07-16</a>
    </div>
   <p>Создадим два дополнительных массива B и C для префикс-функций, B слева направо, C справа налево. Будем идти двумя указателями с двух сторон пока они не пересекутся или пока не найдем элементы на которых сумма элементов справа будет равна сумме элементов слева.</p>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;
  vector&lt;long long&gt; A(n + 2), B(n + 2), C(n + 2);
  for (int i = 1; i &lt;= n; i++) {
    cin >> A[i];
  }

  // решение
  // собираем префикс-функцию слева направо
  for (int i = 1; i &lt;= n; i++) {
    B[i] = B[i - 1] + A[i];
  }

  // собираем префикс-функцию справа налево
  for (int i = n; i >= 1; i--) {
    C[i] = C[i + 1] + A[i];
  }
  int r = n + 1; // правый указатель
  long long res = 0;
  for (int l = 0; l &lt; r; l++) {
    while (B[l] > C[r]) {
      r--;
    }
    if (l &lt; r) {
      if (B[l] == C[r]) {
        res = B[l];
      }
    }
  }

  //вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача I. Бал в БерлГУ -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача I. Бал в БерлГУ</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>По случаю 100500-летия Берляндского государственного университета совсем скоро состоится бал! Уже n юношей и m девушек во всю репетируют вальс, менуэт, полонез и кадриль.</p>

  <p>Известно, что на бал будут приглашены несколько пар юноша-девушка, причем уровень умений танцевать партнеров в каждой паре должен отличаться не более чем на единицу.</p>

  <p>Для каждого юноши известен уровень его умения танцевать. Аналогично, для каждой девушки известен уровень ее умения танцевать. Напишите программу, которая определит наибольшее количество пар, которое можно образовать из n юношей и m девушек.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое число n (1 ≤ n ≤ 100) — количество юношей. Вторая строка содержит последовательность a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> (1 ≤ a<sub>i</sub> ≤ 100), где a<sub>i</sub> — умение танцевать i-го юноши.</p>

  <p>Аналогично, третья строка содержит целое m (1 ≤ m ≤ 100) – количество девушек. В четвертой строке содержится последовательность b<sub>1</sub>, b<sub>2</sub>, ..., b<sub>m</sub> (1 ≤ b<sub>j</sub> ≤ 100), где b<sub>j</sub> — умение танцевать j-й девушки.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное число — искомое максимальное возможное количество пар.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
4
1 4 6 2
5
5 1 5 7 9
</pre>
    <code>3</code>

    <h4>Пример 2</h4>
<pre>
4
1 2 3 4
4
10 11 12 13
</pre>
    <code>0</code>

    <h4>Пример 3</h4>
<pre>
5
1 1 1 1 1
3
1 2 3
</pre>
    <code>2</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/489/problem/B" target="_blank">Задача 489B</a>
      <br><a href="https://codeforces.com/contest/489" target="_blank">Codeforces Round 277.5 (Div. 2) 2014-11-17</a>
    </div>

    <p>Отсортируем оба массива и пойдем указателями выбирая элементы, оторые отличаются не более чем на 1.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ускорение ввода и вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

  // ввод данных

  // юноши
  int n;
  cin >> n;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // девушки
  int m;
  cin >> m;
  vector&lt;int&gt; B(m);
  for (int i = 0; i &lt; m; i++) {
    cin >> B[i];
  }

  // решение
  int res = 0;
  sort(A.begin(), A.end());
  sort(B.begin(), B.end());
  int p1 = 0, p2 = 0;

  while (p1 &lt; n && p2 &lt; m) {
    if (abs(A[p1] - B[p2]) &lt; 2) {
      res++;
      p1++;
      p2++;
    } else if (A[p1] >= B[p2]) {
      p2++;
    } else {
      p1++;
    }
  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача J. Точки на прямой -->
<article class="article">
  <div class="anchor" id="task10"></div>
  <h3>Задача J. Точки на прямой</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Маленький Петя очень любит точки. Недавно мама подарила ему n точек, лежащих на прямой OX. Пете стало интересно, сколькими способами он может выбрать три различные точки так, чтобы расстояние между двумя самыми удаленными из выбранных точек не превышало d.</p>

  <p>Обратите внимание, что порядок точек внутри выбранной тройки значения не имеет.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит два целых числа: n и d (1 ≤ n ≤ 10<sup>5</sup>; 1 ≤ d ≤ 10<sup>9</sup>). Следующая строка содержит n целых чисел x<sub>1</sub>, x<sub>2</sub>, ..., x<sub>n</sub>, по модулю не превосходящих 10<sup>9</sup> — x-координаты точек, подаренных Пете.</p>

  <p>Гарантируется, что координаты точек во входных данных строго возрастают.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное целое число — количество троек точек, в которых расстояние между двумя самыми удаленными точками не превосходит d.</p>

  <p>Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
4 3
1 2 3 4
</pre>
    <code>4</code>
    <p>В первом примере нам подходит любая тройка различных точек.</p>

    <h4>Пример 2</h4>
<pre>
4 2
-3 -2 -1 0
</pre>
    <code>2</code>
    <p>Во втором примере нам подходят всего 2 тройки: {-3, -2, -1} и {-2, -1, 0}.</p>

    <h4>Пример 3</h4>
<pre>
5 19
1 10 20 30 50
</pre>
    <code>1</code>
    <p>В третьем примере нам подходит одна тройка: {1, 10, 20}.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/251/problem/A" target="_blank">Задача 251A</a>
      <br><a href="https://codeforces.com/contest/251" target="_blank">Codeforces Round 153 (Div. 1) 2012-12-06</a>
    </div>

    <p>Точки приходят к нам в отсортированном порядке. Будем идти двумя указателями и поддерживать отрезок длинны A[r] - A[l] &lt;= d. Определим сколько хороших точек на отрезке по формуле</p>
    <code>(r - l - 1) * (r - l - 2) / 2</code>
    <p>Новые тройки точек считаем по левой границе. Каждый раз сдвигая левую границу, находим новые тройки точек</p>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  int n, d;
  cin >> n >> d;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  long long res = 0;
  vector&lt;long long&gt; B(n);
  long long l = 0;
  for (int r = 0; r &lt; n; r++) {
    while (l != n - 1 && A[l + 1] - A[r] &lt;= d) {
      l++;
    }
    B[r] = (l - r) * (l - r - 1) / 2;
  }
  for (int i = 0; i &lt; n; i++) {
    res += B[i];
  }

  //вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача K. Съедая конфеты -->
<article class="article">
  <div class="anchor" id="task11"></div>
  <h3>Задача K. Съедая конфеты</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Есть n конфет разложенных слева направо на столе, конфеты пронумерованы слева направо. Вес i-й конфеты равняется w<sub>i</sub>. Алиса и Боб едят конфеты.</p>

  <p>Алиса может съесть любое количество конфет слева (она ест их подряд и не может пропускать конфеты).</p>

  <p>Боб может съесть любое количество конфет справа (он ест их подряд и не может пропускать конфеты).</p>

  <p>Если Алиса съела конфету, то Боб уже не сможет её съесть (и наоборот).</p>

  <p>Они хотят поделить конфеты честно. Поэтому суммарные веса съеденных ими конфет должны быть равны. Какое наибольшее суммарное количество конфет они могут съесть в таком случае?</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит целое число t (1≤t≤10<sup>4</sup>) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора содержит единственное целое число n (1≤n≤2⋅10<sup>5</sup>) — количество конфет на столе.</p>

  <p>Вторая строка каждого набора содержит n чисел w<sub>1</sub>,w<sub>2</sub>,…,w<sub>n</sub> (1≤w<sub>i</sub>≤10<sup>4</sup>) — веса конфет от самой левой до самой парвой.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превосходит 2⋅10<sup>5</sup>.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора выведите единственное число — максимальное количество, которое могут съесть Алиса и Боб, соблюдая условие.</p>

  <details>
    <summary>Пример</summary>
<pre>
4
3
10 20 10
6
2 1 4 2 4 1
5
1 2 4 8 16
9
7 3 20 5 15 1 11 8 10
</pre>
<pre>
2
6
0
7
</pre>
    <p>В первом примере Алиса съест одну конфету слева, а Боб съест одну конфету справа. Нет лучшего способа съесть набор конфет одинакового веса. Ответ 2, так как они съедят суммарно две конфеты.</p>

    <p>Во втором примере Алиса съест первые три конфеты слева (суммарным весом 7), а Боб съест первые три конфеты справа (суммарным весом 7). Они не могут съесть больше конфет, так как все конфеты съедены. Ответ равен 6, так как они съели суммарно шесть конфет.</p>

    <p>В третьем примере Алиса и Боб не могут съесть наборы конфет одинакового ненулевого веса, поэтому ответ равен 0.</p>

    <p>В четвертом примере Алиса съест конфеты весом [7,3,20], а Боб съест конфеты весом [10,8,11,1], каждый из них съест набор конфет суммарным весом 30. Лучшего способа съесть конфеты нет, поэтому ответ 7.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1669/problem/E" target="_blank">Задача 1669E</a>
      <br><a href="https://codeforces.com/contest/1669" target="_blank">Codeforces Round 784 (Div. 4) 2022-04-19</a>
    </div>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ускорение ввода и вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n;
    cin >> n;
    vector&lt;int&gt; A(n);
    for (int i = 0; i &lt; n; i++) {
      cin >> A[i];
    }

    // решение
    int res = 0;
    int l = 0, r = n - 1;
    int wl = 0, wr = 0;
    int cnt = 0;

    while (r >= l) {
      if (wl &lt;= wr) {
        wl += A[l];
        l++;
      } else {
        wr += A[r];
        r--;
      }
      cnt++;
      if (wl == wr) {
        res = cnt;
      }
    }

    // вывод результата
    cout &lt;&lt; res &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача L. Несекретный шифр -->
<article class="article">
  <div class="anchor" id="task12"></div>
  <h3>Задача L. Несекретный шифр</h3>

  <div><i>Ограничение по времени 3с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Берляндия в ходе войны с Флатландией начинает перехватывать инициативу. Чтобы изгнать противника с родной земли, берляндцам нужно точно знать, сколько еще флатландских солдат осталось в резерве врага. К счастью, утром разведчики взяли «языка», у которого было секретное зашифрованное сообщение с нужной берляндцам информацией.</p>

  <p>У пойманного нашли массив целых положительных чисел. Берляндская разведка уже давно знает шифр флатландцев: чтобы передать сообщение, в котором фигурирует число m, враги используют такой массив чисел a, что количество его подмассивов, в которых есть хотя бы k одинаковых чисел, равно m. Число k давно известно всей берляндской армии, поэтому генерал Туристов снова попросил ефрейтора Васю выполнить несложное задание: расшифровать сообщение флатландцев.</p>

  <p>Помогите Васе, по заданному массиву чисел a и числу k, найдите количество подмассивов массива чисел a, в которых есть хотя бы k одинаковых чисел.</p>

  <p>Подмассивом a[i... j] (1 ≤ i ≤ j ≤ n) массива a = (a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub>) называется массив, составленный из последовательных его элементов, начиная с i-го и заканчивая j-м: a[i... j] = (a<sub>i</sub>, a<sub>i+1</sub>, ..., a<sub>j</sub>).</p>

  <h4>Входные данные</h4>
  <p>В первой строке через пробел записаны два целых числа n, k (1 ≤ k ≤ n ≤ 4·10<sup>5</sup>) — количество чисел в массиве и требуемое количество одинаковых чисел в подмассивах, соответственно.</p>

  <p>Во второй строке через пробел записаны n целых чисел a<sub>i</sub> (1 ≤ a<sub>i</sub> ≤ 10<sup>9</sup>) — элементы массива.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное число — количество подмассивов массива a таких, что в них есть как минимум k одинаковых чисел.</p>

  <p>Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
4 2
1 2 1 2
</pre>
    <code>3</code>
    <p>В первом примере существует три подмассива, содержащих хотя бы два одинаковых числа: (1,2,1), (2,1,2) и (1,2,1,2).</p>

    <h4>Пример 2</h4>
<pre>
5 3
1 2 1 1 3
</pre>
    <code>2</code>
    <p>Во втором примере существует два подмассива, содержащих три одинаковых числа: (1,2,1,1,3) и (1,2,1,1).</p>

  <h4>Пример 3</h4>
<pre>
3 1
1 1 1
</pre>
    <code>6</code>
    <p>В третьем примере любой подмассив содержит хотя бы 1 число. Всего их 6: (1), (1), (1), (1,1), (1,1) и (1,1,1).</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/190/problem/D" target="_blank">Задача 190D</a>
      <br><a href="https://codeforces.com/contest/190" target="_blank">Codeforces Round 120 (Div. 2) 2012-05-15</a>
    </div>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unordered_map&gt;

using namespace std;

int main() {
  // ускорение ввода и вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

  // ввод данных
  int n, k;
  cin >> n >> k;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  long long res = 0;
  int p1 = 0;
  unordered_map&lt;int, int&gt; Cnt;

  for (int p2 = p1; p2 &lt; n; p2++) {
    Cnt[A[p2]]++;
    while (Cnt[A[p2]] >= k) {
      res += n - p2;
      Cnt[A[p1]]--;
      p1++;
    }
  }

  // вывод результата
  cout &lt;&lt; res &lt;&lt; '\n';
}
</pre>
  </details>
</article>


<!-- Задача M. Олимпиада -->
<article class="article">
  <div class="anchor" id="task13"></div>
  <h3>Задача M. Олимпиада</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Мальчик Вася участвовал в олимпиаде. Учитель мальчика знает, что Вася получил за оба тура олимпиады в сумме не меньше, чем x баллов. У учителя есть результаты первого тура и результаты второго тура олимпиады, но вот беда — в результатах указаны лишь баллы, без фамилий. Учителю необходимо знать, на что Вася может рассчитывать.</p>

  <p>Помогите учителю Васи, найдите два числа — наилучшее и наихудшее место, которое мог занять Вася. Учтите, что в итоговой таблице участники сортируются по сумме баллов за оба тура (у участника на первом месте больше всего баллов). Если два (или более) участника получили одинаковое количество баллов, жюри может им назначить места по своему усмотрению. Гарантируется, что каждый участник олимпиады участвовал в обоих турах олимпиады.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записаны через пробел два целых числа n, x (1 ≤ n ≤ 10<sup>5</sup>; 0 ≤ x ≤ 2·10<sup>5</sup>) — количество участников олимпиады и минимальное количество набранных Васей баллов.</p>

  <p>Во второй строке записаны n целых чисел через пробел: a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> (0 ≤ a<sub>i</sub> ≤ 10<sup>5</sup>) — баллы участников в первом туре.</p>

  <p>В третьей строке записаны n целых чисел через пробел: b<sub>1</sub>, b<sub>2</sub>, ..., b<sub>n</sub> (0 ≤ b<sub>i</sub> ≤ 10<sup>5</sup>) — баллы участников во втором туре.</p>

  <p>Баллы участников заданы в произвольном порядке. Гарантируется, что Вася присутствовал на олимпиаде — существуют два целых числа i, j (1 ≤ i, j ≤ n) такие, что a<sub>i</sub> + b<sub>j</sub> ≥ x.</p>

  <h4>Выходные данные</h4>
  <p>Выведите через пробел два целых числа — наилучшее и наихудшее место из тех, что мог занять Вася на олимпиаде.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
5 2
1 1 1 1 1
1 1 1 1 1
</pre>
    <code>1 5</code>
    <p>В первом тестовом примере в любом случае все 5 участников набирают по 2 балла. В зависимости от решения жюри, Васе могут присудить как первое (наилучшее) место, так и последнее (наихудшее), пятое.</p>

    <h4>Пример 2</h4>
<pre>
6 7
4 3 5 6 4 4
8 6 0 4 3 4
</pre>
    <code>1 5</code>
    <p>Во втором тестовом примере в лучшем для Васи случае он снова выигрывает: он может набрать 12 баллов и стать абсолютным победителем, если итоговая таблица будет выглядеть так — {4:8, 6:4, 3:6, 4:4, 4:3, 5:0}.</p>

    <p>В этой таблице все участники расположены по убыванию количества баллов, и для участника показано, сколько баллов он набрал в первом и во втором туре.</p>

    <p>В худшем случае, он может занять пятое место, если таблица выглядит так — {4:8, 4:6, 6:4, 5:4, 4:3, 3:0}, а он набрал в первом и втором турах 4 и 3 балла соответственно.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/222/problem/D" target="_blank">Задача 222D</a>
      <br><a href="https://codeforces.com/contest/222" target="_blank">Codeforces Round 137 (Div. 2) 2012-05-15</a>
    </div>

    <p>Комбинировать баллы из первого и второго тура можно любым образом. Наилучшее место всегда будет первое. Чтобы найти наихудшее место, нужно найти количество участников, набравших менее чем x баллов.</p>

  <h4>Пример 1</h4>
<pre>
6 8
1 2 3 4 5 6
1 2 3 4 5 6
</pre>
  <code>1 5</code>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ускорение ввода и вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

  // ввод данных
  int n, x;
  cin >> n >> x;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }
  vector&lt;int&gt; B(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> B[i];
  }

  // решение
  int min = n;
  int max = 1;
  int p1 = 0, p2 = n - 1;
  sort(A.begin(), A.end());
  sort(B.begin(), B.end());

  while (p1 &lt; n && p2 >= 0) {
    if (A[p1] + B[p2] &lt; x) {
      p1++;
      min--;
    } else {
      p1++;
      p2--;
    }
  }

  // вывод результата
  cout &lt;&lt; max &lt;&lt; ' ' &lt;&lt; min;
}
</pre>
  </details>
</article>


<!-- Задача N. Сдвиги -->
<article class="article">
  <div class="anchor" id="task14"></div>
  <h3>Задача N. Сдвиги</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам дана таблица размером n строк на m столбцов. В каждой ячейке таблицы записано число 0 или 1. За один ход можно выбрать какую-то из строк таблицы и циклически сдвинуть значения в ней на одну ячейку либо влево, либо вправо.</p>

  <p>Циклически сдвинуть строку таблицы на одну ячейку вправо означает переместить значение каждой ячейки этой строки, кроме последней, в соседнюю ячейку справа, а значение последней ячейки переместить в первую ячейку. Аналогичным образом, но в обратную сторону выполняется циклический сдвиг строки таблицы влево. Например, если циклически сдвинуть строку «00110» на одну ячейку вправо — получится строка «00011», если же сдвинуть строку «00110» на одну ячейку влево — получится строка «01100».</p>

  <p>Определите, за какое наименьшее количество ходов можно добиться того, что в каком-то из столбцов таблицы будут только единицы.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит два целых числа, разделенные пробелом: n (1 ≤ n ≤ 100) — количество строк в таблице и m (1 ≤ m ≤ 10<sup>4</sup>) — количество столбцов в таблице. Далее следуют n строк, каждая из которых содержит по m символов «0» или «1»: j-тый символ i-той строки описывает содержимое ячейки в i-той строке и j-ом столбце таблицы.</p>

  <p>Гарантируется, что в описании таблицы не встречается никаких символов кроме «0» и «1».</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное число: наименьшее количество ходов, за которое можно в каком-то из столбцов таблицы получить только единицы. Если этого сделать нельзя, выведите -1.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
3 6
101010
000100
100000
</pre>
    <code>3</code>
    <p>В первом примере один из способов достижения цели с наименьшим количеством шагов таков: циклически сдвинем вторую строку один раз вправо, а третью — два раза влево. Тогда предпоследний столбец таблицы будет содержать только единицы.</p>

    <h4>Пример 2</h4>
<pre>
2 3
111
000
</pre>
    <code>-1</code>
    <p>Во втором примере строки нельзя сдвинуть так, чтобы образовался столбец, содержащий только единицы.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/230/problem/C" target="_blank">Задача 230C</a>
      <br><a href="https://codeforces.com/contest/230" target="_blank">Codeforces Round 142 (Div. 2) 2012-10-01</a>
    </div>

  <h4>Пример 3</h4>
  <pre>
  1 1
  0
  </pre>
    <code>-1</code>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;


int main() {
  // ускорение ввода и вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

  // ввод данных
  int n, m;
  cin >> n >> m;
  vector&lt;string&gt; A(n);

  // считываем массив
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  long long res = 1e18;

  for (int i = 0; i &lt; n; i++) {
    // счетчик единиц в строке
    int cnt1 = 0;
    for (int j = 0; j &lt; m; j++) {

      // для каждой 1 в строке
      if (A[i][j] == '1') {
        cnt1++;
        long long resi = 0;

        // проходим по всем строкам
        for (int k = 0; k &lt; n; k++) {
          // счетчик нулей в строке
          int cnt0 = 0;
          int l = j, r = j;

          // поиск ближайшей 1 в каждой строке
          while (A[k][l] != '1' && A[k][r] != '1') {
            // проверка что в строке все 0
            cnt0++;
            if (cnt0 == m / 2 + 1) {
              cout &lt;&lt; -1;
              return 0;
            }

            resi++;
            if (l == 0) {
              l = m - 1;
            } else {
              l--;
            }
            if (r == m - 1) {
              r = 0;
            } else {
              r++;
            }
          }
        }
        res = min(res, resi);
      }

    }
    if (cnt1 == 0) {
      cout &lt;&lt; -1;
      return 0;
    }

  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача O. Прибавляй не прибавляй -->
<article class="article">
  <div class="anchor" id="task15"></div>
  <h3>Задача O. Прибавляй не прибавляй</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>На листке бумаги записан массив из n чисел a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub>. Вам необходимо найти число, которое встречается в этом массиве наибольшее количество раз.</p>

  <p>Однако, прежде чем искать такое число, Вам разрешается выполнить не более k операций следующего вида — выбрать произвольный элемент массива и прибавить к нему 1. Другими словами, не более k раз разрешается увеличить на 1 некоторое число из массива (один элемент массива разрешается увеличивать несколько раз).</p>

  <p>Вам необходимо найти максимальное количество вхождений некоторого числа в массив после выполнения не более k разрешенных операций. Если таких чисел несколько, требуется найти минимальное.</p>

  <h4>Входные данные</h4>
  <p>В первой строке заданы два целых числа n и k (1 ≤ n ≤ 10<sup>5</sup>; 0 ≤ k ≤ 10<sup>9</sup>) — количество элементов в массиве и количество операций, которое разрешается выполнить, соответственно.</p>

  <p>В третьей строке задана последовательность из n целых чисел a<sub>1</sub>, a<sub>2</sub>,..., a<sub>n</sub> (|a<sub>i</sub>| ≤ 10<sup>9</sup>) — исходный массив. Числа в строках разделены одиночными пробелами.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите два числа — максимальное количество вхождений некоторого числа в массив после выполнения не более k разрешенных операций, а также минимальное число, для которого достигается выведенный максимум. Выведенные числа разделяйте пробельными символами.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
5 3
6 3 4 0 2
</pre>
    <code>3 4</code>
    <p>В первом примере нужно один раз увеличить второй элемент массива и дважды увеличить пятый элемент массива. Таким образом, получим последовательность 6, 4, 4, 0, 4, в которой число 4 встречается 3 раза.</p>

  <h4>Пример 2</h4>
<pre>
3 4
5 5 5
</pre>
    <code>3 5</code>
    <p>Во втором примере не нужно выполнять ни одной операции, либо увеличить каждый элемент на единицу. В первом случае получим массив 5, 5, 5, во втором — 6, 6, 6. В обоих случаях максимальное количество вхождений равно 3. В случае равенства требуется найти минимальное число. Поэтому нужно выбрать первый вариант, так как число 5 меньше числа 6.</p>

    <h4>Пример 3</h4>
<pre>
5 3
3 1 2 2 1
</pre>
    <code>4 2</code>
    <p>В третьем примере нужно один раз увеличить второй элемент массива и один раз увеличить пятый элемент массива. Таким образом, получим последовательность 3, 2, 2, 2, 2, в которой число 2 встречается 4 раза.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/231/problem/C" target="_blank">Задача 231C</a>
      <br><a href="https://codeforces.com/contest/231" target="_blank">Codeforces Round 143 (Div. 2) 2012-10-07</a>
    </div>

    <p>Отсортируем массив. Постараемся получить каждое число, прибавляя к соседним меньшим числам единицу не более k раз. Выберем число с максимальным вхождением. Если их несколько то выберем минимальное из них.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

bool comp(int a, int b) {
  return a > b;
}

int main() {
  // ускорение ввода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);

  // ввод данных
  int n, k;
  cin >> n >> k;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  sort(A.begin(), A.end(), comp);
  int cur_k = 0;
  int cnt = 0; // макс число вхождений
  int cur_cnt = 1;
  int pr = 0;
  int num = A[pr]; // мин число

  // проходим по числам от большего к меньшему
  for (int pl = 0; pl &lt; n; pl++) {
    int cur_num = A[pl];
    cur_cnt--;
    if (pl) {
      int dif = A[pl - 1] - A[pl];
      cur_k -= dif * cur_cnt;
    }

    while (k >= cur_k && pr &lt; n) {
      cur_k += A[pl] - A[pr];
      if (k >= cur_k) {
        pr++;
        cur_cnt++;
      }
    }

    if (cur_k > k) {
      cur_k -= A[pl] - A[pr];
    }

    if (cur_cnt >= cnt) {
      cnt = cur_cnt;
      num = cur_num;
    }
  }

  // вывод результата
  cout &lt;&lt; cnt &lt;&lt; ' ' &lt;&lt; num;
}
</pre>
  </details>
</article>


<!-- Задача P. Кефа и компания -->
<article class="article">
  <div class="anchor" id="task16"></div>
  <h3>Задача P. Кефа и компания</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Кефа хочет отметить свой первый крупный заработок походом в ресторан. Однако ему нужна компания.</p>

  <p>У Кефы есть n друзей, каждый из которых согласится пойти в ресторан, если Кефа попросит. Каждый друг характеризуется количеством денег у него и степенью дружбы с Кефой. Наш попугай не хочет, чтобы какой-то друг почувствовал себя бедным по сравнению с кем-то другим в компании (Кефа не в счет). Друг чувствует себя бедным, если в компании есть кто-то, у кого денег хотя бы на d единиц больше, чем у него. Также Кефа хочет, чтобы суммарная степень дружбы членов компании была максимальной. Помогите ему пригласить оптимальную компанию!</p>

  <h4>Входные данные</h4>
  <p>Первая строка ввода содержит два целых числа, разделенных пробелом, n и d (1 ≤ n ≤ 10<sup>5</sup>, 1 ≤ d ≤ 10<sup>9</sup>) — количество друзей у Кефы и минимальная разница денег, приводящая к тому, что человек чувствует себя бедным.</p>

  <p>В последующих n строках даны описания друзей Кефы, в (i + 1)-й строке содержится описание i-го друга вида m<sub>i</sub>, s<sub>i</sub> (0 ≤ m<sub>i</sub>, s<sub>i</sub> ≤ 10<sup>9</sup>) — количество денег и степень дружбы с Кефой соответственно.</p>

  <h4>Выходные данные</h4>
  <p>Выведите максимальную суммарную степень дружбы, которой можно добиться.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
4 5
75 5
0 100
150 20
75 1
</pre>
    <code>100</code>
    <p>В первом тесте из условия выгоднее всего сформировать компанию только из второго друга. При всех других вариантах суммарная степень дружбы будет меньше.</p>

    <h4>Пример 2</h4>
<pre>
5 100
0 7
11 32
99 10
46 8
87 54
</pre>
    <code>111</code>
    <p>Во втором тесте из условия мы можем взять всех друзей.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/580/problem/B" target="_blank">Задача 580B</a>
      <br><a href="https://codeforces.com/contest/580" target="_blank">Codeforces Round 321 (Div. 2) 2015-09-22</a>
    </div>

    <p>Метод скользящего окна с переменной шириной.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

bool compare(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b) {
  return a.first &lt; b.first;
}

int main() {
  // ввод данных
  int n, d;
  cin >> n >> d;
  vector&lt;pair&lt;int, int&gt; &gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i].first >> A[i].second;
  }

  // решение
  long long cnt = 0, res = 0;
  int pl = 0, pr = 0;
  sort(A.begin(), A.end(), compare);

  while (pl &lt; n) {
    while ( (pr &lt; n) && (abs(A[pr].first - A[pl].first) &lt; d) ) {
      cnt += A[pr].second;
      pr++;
    }
    res = max(res, cnt);
    cnt -= A[pl].second;
    pl++;
  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача Q. Медианное сглаживание -->
<article class="article">
  <div class="anchor" id="task17"></div>
  <h3>Задача Q. Медианное сглаживание</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Школьник Вася очень любит читать книжки по программированию и математике. Недавно он прочёл в энциклопедии статью, в которой рассказывалось о методе медианного сглаживания и его многочисленных применениях в науке и технике. Идея метода Васе очень понравилась, и он решил опробовать его на практике.</p>

  <p>При использовании простейшего варианта медианного сглаживания по последовательности чисел a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> строится новая последовательность чисел b<sub>1</sub>, b<sub>2</sub>, ..., b<sub>n</sub> по следующему алгоритму:</p>
  <ul>
    <li>b<sub>1</sub> = a<sub>1</sub>, b<sub>n</sub> = a<sub>n</sub>, то есть первое и последнее число новой последовательности совпадают с соответствующими числами исходной последовательности.</li>
    <li>При i = 2, ..., n - 1 значение bi полагается равным медиане трёх значений a<sub>i-1</sub>, a<sub>i</sub> и a<sub>i+1</sub>.</li>
  </ul>

  <p>Напомним, что медианой набора из трех чисел называется число, которое окажется на втором месте, если три числа выписать в порядке неубывания. Например, медианой набора 5, 1, 2 является число 2, а медианой набора 1, 0, 1 — число 1.</p>

  <p>Чтобы не усложнять себе задачу, Вася решил применять метод только к последовательностям, состоящим из нулей и единиц.</p>

  <p>Проделав нехитрую процедуру один раз, Вася посмотрел на получившуюся последовательность и подумал: что будет, если снова применить к ней алгоритм, а потом применить его к следующему результату и так далее? Рассмотрев пару примеров, Вася обнаружил, что через несколько применений медианного сглаживания последовательность может перестать изменяться. Будем говорить, что последовательность стабильна, если она не изменяется при применении к ней медианного сглаживания.</p>

  <p>Васе стало интересно, всегда ли последовательность рано или поздно становится стабильной. Он просит вас написать программу, которая по заданной последовательности нулей и единиц определит, становится ли она когда-нибудь стабильной, и если да, то сколько раз для этого нужно применить к ней метод медианного сглаживания.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных находится одно целое число n (3 ≤ n ≤ 500000) — число элементов в рассматриваемой последовательности.</p>

  <p>В следующей строке находится исходная последовательность чисел a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub>, состоящая только из нулей и единиц.</p>

  <h4>Выходные данные</h4>
  <p>В случае, если последовательность никогда не станет стабильной, выведите одно число - 1.</p>

  <p>В противном случае в первой строке выведите одно число — минимальное число раз, которое нужно применить алгоритм медианного сглаживания, прежде чем последовательность станет стабильной. Во второй строке выведите n чисел через пробел — саму итоговую последовательность.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
4
0 0 1 1
</pre>
<pre>
0
0 0 1 1
</pre>

    <h4>Пример 2</h4>
<pre>
5
0 1 0 1 0
</pre>
<pre>
2
0 0 0 0 0
</pre>
    <p>Во втором примере стабилизация наступает через два шага: 01010 -> 00100 -> 00000, а последовательность 00000, как нетрудно заметить, является стабильной.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/591/problem/C" target="_blank">Задача 591C</a>
      <br><a href="https://codeforces.com/contest/591" target="_blank">Codeforces Round 327 (Div. 2) 2015-10-24</a>
    </div>

    <p>Для решения задачи медианного сглаживания с использованием метода двух указателей, мы можем оптимизировать процесс, отслеживая только изменяющиеся участки последовательности. Это позволит сократить количество операций на каждом шаге.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

  bool v[500001];
  int n, l = 0, r, ans = 0;
  cin >> n >> v[0];
  for (int i = 1; i &lt;= n; i++) {
    if (i == n)
      v[n] = v[n - 1];
    else
      cin >> v[i];
    if (v[i] == v[i - 1])
      if (l == i - 1)
        l++;
      else {
        r = i - 1;
        for (int j = 1; l + j &lt;= r - j; j += 2) {
          v[l + j] = v[l];
          v[r - j] = v[r];
        }
        ans = max(ans, (r - l) / 2);
        l = i;
      }
  }

  // вывод результата
  cout &lt;&lt; ans &lt;&lt; '\n';
  for (int i = 0; i &lt; n; i++)
    cout &lt;&lt; v[i] &lt;&lt; ' ';
  cout &lt;&lt; '\n';
}
</pre>
  </details>
</article>


<!-- Задача R. Оденьте их скорее -->
<article class="article">
  <div class="anchor" id="task18"></div>
  <h3>Задача R. Оденьте их скорее</h3>

  <div><i>Ограничение по времени 3с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В Двумерном королевстве наступили тяжелые времена... Сегодня утром Трехмерное королевство объявило войну Двумерному и в ходе этого (возможно, вооруженного) конфликта решится, кому же все-таки принадлежит прямая.</p>

  <p>В Двумерном королевстве есть постоянная армия, состоящая из n человек. Каждый боец прошел специальную регистрацию и указал желаемый размер бронежилета: i-ый боец указал размер a<sub>i</sub>. Известно, что бойцы люди неприхотливые, поэтому штаб считает, что им комфортно носить любые бронежилеты с размерами от a<sub>i</sub> - x до a<sub>i</sub> + y включительно (числа x, y ≥ 0 заданы).</p>

  <p>В распоряжении армии Двумерного королевства есть m бронежилетов, размер j-го бронежилета равен b<sub>j</sub>. Помогите мобилизовать армию Двумерного королевства — оденьте наибольшее возможное количество бойцов армии в бронежилеты. Каждый бронежилет разрешается использовать только один раз. i-ый боец может надеть j-ый бронежилет, если a<sub>i</sub> - x ≤ b<sub>j</sub> ≤ a<sub>i</sub> + y.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных записаны четыре целых числа n, m, x и y (1 ≤ n, m ≤ 10<sup>5</sup>, 0 ≤ x, y ≤ 10<sup>9</sup>) — количество бойцов, количество бронежилетов и два числа, характеризующие неприхотливость бойцов, соответственно.</p>

  <p>Во второй строке записаны в неубывающем порядке n разделенных единичными пробелами целых чисел a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> (1 ≤ a<sub>i</sub> ≤ 10<sup>9</sup>) — желаемые размеры бронежилетов.</p>

  <p>В третьей строке записаны в неубывающем порядке m разделенных единичными пробелами целых чисел b<sub>1</sub>, b<sub>2</sub>, ..., b<sub>m</sub> (1 ≤ b<sub>j</sub> ≤ 10<sup>9</sup>) — размеры имеющихся в наличии бронежилетов.</p>

  <h4>Выходные данные</h4>
  <p>В первой строке выведите единственное целое число k — максимальное количество одетых в бронежилеты бойцов.</p>

  <p>В следующих k строках выведите k пар, по одной паре в строке в формате «u<sub>i</sub> v<sub>i</sub>» (без кавычек). Пара (u<sub>i</sub>, v<sub>i</sub>) означает, что боец с номером u<sub>i</sub> должен быть одет в бронежилет номер v<sub>i</sub>. Бойцы и бронежилеты нумеруются, начиная с единицы, в том порядке, в котором они заданы во входных данных. Все номера бойцов в парах должны быть попарно различны, все номера бронежилетов в парах также должны быть попарно различны. Пары можно выводить в любом порядке.</p>

  <p>Если существует несколько оптимальных ответов, разрешается вывести любой.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
5 3 0 0
1 2 3 3 4
1 3 5
</pre>
<pre>
2
1 1
3 2
</pre>
  <p>В первом примере требуется точное совпадение размеров бронежилетов: первый боец получает первый бронежилет (размер 1), а третий — второй бронежилет (размер 3). В этом примере возможен другой ответ, в котором второй бронежилет достается не третьему, а четвертому бойцу.</p>

    <h4>Пример 2</h4>
<pre>
3 3 2 2
1 5 9
3 5 7
</pre>
<pre>
3
1 1
2 2
3 3
</pre>
    <p>Во втором примере размер бронежилета должен отличаться от пожеланий бойца не больше чем на 2 размера, и одеть можно всех бойцов.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/161/problem/A" target="_blank">Задача 161A</a>
      <br><a href="https://codeforces.com/contest/161" target="_blank">VK Cup 2012 Раунд 1 2012-03-11</a>
    </div>

    <p>Пройдем по бронижилетам и для каждого бронижилета постараемся найти бойца.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  int n, m, x, y;
  cin >> n >> m >> x >> y;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }
  vector&lt;int&gt; B(m);
  for (int i = 0; i &lt; m; i++) {
    cin >> B[i];
  }

  // решение
  int res = 0;
  vector&lt;int&gt; QA;
  vector&lt;int&gt; QB;
  int p1 = 0;

  for (int p2 = 0; p2 &lt; m && p1 &lt; n; p2++) {

    while (n > p1 && B[p2] > A[p1] + y) {
      p1++;
    }

    if (n > p1 && (B[p2] >= A[p1] - x) && (A[p1] + y >= B[p2]) ) {
      res++;
      QA.push_back(p1+1);
      QB.push_back(p2+1);
      p1++;
    }
  }

  // вывод результата
  cout &lt;&lt; res &lt;&lt; '\n';
  for (int i = 0; i &lt; res; i++) {
    cout &lt;&lt; QA[i] &lt;&lt; ' ' &lt;&lt; QB[i] &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>

