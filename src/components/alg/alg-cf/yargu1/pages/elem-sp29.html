<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contests" target="_blank">Codeforces ЯрГУ. Школьники</a></p>
  <p><a href="https://vk.com/sportprog_yarsu" target="_blank">vk.com/sportprog_yarsu</a></p>
  <p><a href="https://vkvideo.ru/@sportprog_yarsu" target="_blank">vkvideo.ru/@sportprog_yarsu</a></p>
</article>


<article class="article">
  <h1>Занятие 29 Структуры данных #3. Дерево отрезков</h1>
  <p>Конспект видео от 2025.04.19</p>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contest/604876" target="_blank">Codeforces Контест 604876</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
        <a href="#p1">Задача поиска на отрезке</a>
    <br><a href="#p2">Дерево отрезков</a>
    <br><a href="#p3">Задача поиска на отрезке. Варианты</a>
    <br><a href="#p4">Дерево отрезков для определения максимума</a>
    <br><a href="#p5">Поиск k-го нуля</a>
  </p>
  <p>
        <a href="#task1">Задача A. Максимизация пересечений (простая версия)</a>
    <br><a href="#task2">Задача B. Максимизация пересечений (сложная версия)</a>
    <br><a href="#task3">Задача C. Задача о клике</a>
    <br><a href="#task4">Задача D. Валера и запросы</a>
    <br><a href="#task5">Задача E. Range Update Point Query</a>
    <br><a href="#task6">Задача F. Дерево отрезков. Сумма</a>
    <br><a href="#task7">Задача G. Дерево отрезков. Минимум</a>
    <br><a href="#task8">Задача H. Сумма на отрезке</a>
    <br><a href="#task9">Задача I. Запрос изменения на отрезке</a>
    <br><a href="#task10">Задача J. Восстановление массива</a>
    <br><a href="#task11">Задача K. Экзамен</a>
    <br><a href="#task12">Задача L. Шакти</a>
    <br><a href="#task13">Задача M. Наибольший общий делитель</a>
    <br><a href="#task14">Задача N. НОД на подотрезках с изменением элемента</a>
    <br><a href="#task15">Задача O. битдождь</a>
  </p>
</article>


<!-- Задача поиска на отрезке -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Задача поиска на отрезке</h3>

  <p>Поставим перед собой известную задачу:</p>

  <p>Дан целочисленный массив A длины n. Необходимо найти сумму элементов массива с позиции l до позиции r.</p>
  <code>a1, a2, a3, ... , an</code>
  <code>result = al + ... + ar</code>

  <p>Если запрос единственный, то мы можем посчитать сумму элементов через цикл. Если запросов много нам может помочь префикс функция.</p>

  <p>Пусть у нас есть усложнение задачи в виде добавления двух типов операций.</p>
  <ol>
    <li>Мы задаем вопрос найти сумму элементов с позиции l до r.</li>
    <li>Мы хотим изменить один элемент под номером id на другую величину.</li>
  </ol>
  <p>В таком случае обработка запросов при помощи алгоритмов префикс функций не выгоден ведь при изменении одного элемента в массиве меняется огромное количество элементов в массиве префиксов.</p>

  <h4>Варианты решения проблемы:</h4>
  <ol>
    <li>SQRT декомпозиция</li>
    <li>Дерево Фенвика</li>
    <li>Дерево отрезков</li>
  </ol>
</article>


<!-- Дерево отрезков -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>Дерево отрезков</h3>

  <p>Дерево отрезков — это структура данных, которая позволяет эффективно (т.е. за асимптотику O(log n)) реализовать операции следующего вида: нахождение суммы/минимума элементов массива в заданном отрезке (a[l . . . r], где l и r поступают на вход алгоритма), при этом дополнительно возможно изменение элементов массива: как изменение значения одного элемента, так и изменение элементов на целом подотрезке массива.</p>

  <p>Реализация дерева отрезков:</p>
  <ol>
    <li>На массиве</li>
    <li>На матрице</li>
    <li>Через собственную структуру на узлах</li>
    <li>Реализации без лишнего выделения памяти</li>
  </ol>

  <p>Реализуем вариант дерева отрезков на массиве со спец. свойствами.</p>
  <ol>
    <li>Наш исходный массив мы хотим хранить нумерацию элементов с 0 до n-1.</li>
    <li>Весь начальный массив мы хотим хранить в листьях. Для удобства реализации мы хотим, чтобы количество листьев равнялось 2ᶻ и выполнялось условие n ≤ 2ᶻ.</li>
    <li>Нейтральный элемент для сложения 0. Ячейки, которые будут создаваться лишними, будут хранить в себе значение нейтрального элемента. Для операции умножения нейтральный элемент может быть 1, для НОД пометка со значением -1.</li>
    <li>Корень нашего дерева будет иметь номер в массиве равным 1.</li>
    <li>Для каждой вершины строго определяем нумерацию их сыновей. Если номер вершины равняется i то номер левого сына 2 * i и правого сына 2 * i+1.</li>
  </ol>

  <p>Массив A имеет длину 6 и хранит в себе набор элементов {4,1,4,2,5,3}:</p>

  <p>Ряд красивых вещей:</p>
  <ol>
    <li>Нумерация элементов левой ветки дерева 2ⁱ</li>
    <li>Номер первого листа равняется 8 или 2ᶻ</li>
    <li>Количество листьев равняется 8 или 2ᶻ</li>
  </ol>

  <p>Разделим реализацию дерева отрезков на 4 части:</p>
  <ol>
    <li>Инициализация дерева</li>
    <li>Update 1 элемента в дереве</li>
    <li>Поиск ответа на отрезке</li>
    <li>Обработка запросов задачи</li>
  </ol>

  <h4>Инициализация дерева</h4>

  <p>Для инициализации дерева необходимо определить количество элементов в нем, количество листьев и номер первого листа. Обычно для определения количества элементов всегда берут величину с запасом 4 * n или 8 * n.</p>
<pre>
int n;
cin >> n;
vector&lt;long long&gt; Tree_sum(n * 4);
int number_left_list = 1;
int count_list  1;

while (count_list &lt; n) {
  count_list *= 2;
  number_left_list *= 2;
}

int q;
char type;
int l, r, id, c;
</pre>

  <h4>Update 1 элемента в дереве</h4>

  <p>Для обновления одного элемента необходимо определить номер листа,   которому соответствует номер из запроса. Далее обновить все элементы в   дереве которые зависят от листа. (пробег от листа к корню)</p>

  <p>Для обновления одного элемента необходимо определить номер листа,   которому соответствует номер из запроса. Далее обновить все элементы в   дереве которые зависят от листа. (пробег от листа к корню)</p>

<pre>
void update_tree_sum(vector&lt;long long&gt; &Tree_sum,
  int number_list, long long data) {
  Tree_sum[number_list] = data;
  while (number_list > 1) {
    number_list /= 2;
    Tree_sum[number_list] = Tree_sum[number_list * 2] +
    Tree_sum[number_list * 2 + 1];
  }
}
</pre>

  <h4>Поиск ответа на отрезке</h4>

  <p>Пусть у нас есть запрос поиск суммы с 1 по 5 элемент a1 + a2 + a3 + a4 + a5</p>

  <p>При использовании ДО у нас есть несколько вариантов сбора ответа:</p>
  <ol>
    <li>Пробежаться по листьям T8 + T9 + T10 + T11 + T12</li>
    <li>Собрать часть ответа через ”большие ячейки” T4 + T5 + T12</li>
    <li>Использовать хранение ДО по максимуму T2 + T12</li>
  </ol>

  <p>Будем бежать от корня к листам и смотреть на ячейку является ли она частью ответа, не является частью ответа или частично является ответом.</p>

  <p>Реализация</p>
<pre>
long long Sum(vector&lt;long long&gt; Tree_sum,
  int id, int l, int r, int find_l, int find_r) {

  // если все элементы хорошие
  if (find_l &lt;= l && r &lt;= find_r) {
    // возвращаем сумму всех элементов
    return Tree_sum[id];
  }

  // если все элементы плохие
  if (r &lt;= find_l || find_r &lt;= l) {
    // возвращаем нейтральный элемент
    return 0;
  }

  // если есть хорошие и плохие элементы
  int mid = (l + r) / 2;
  // считаем сумму левого потомка
  long long sum1 = Sum(Tree_sum, id * 2, l, mid, find_l, find_r);
  // считаем сумму правого потомка
  long long sum2 = Sum(Tree_sum, id * 2 + 1, mid, r, find_l, find_r);
  return sum1 + sum2;
}
</pre>

  <h4>Обработка запросов задачи</h4>

  <p>Реализация:</p>
<pre>
cin >> q;
for (int i = 0; i &lt; q; i++) {
  cin >> type;
  // запрос на вывод суммы
  if (type == '?') {
    cin >> l >> r;
    l--;
    cout &lt;&lt; Sum(Tree_sum, 1, 0, count_list, l, r) &lt;&lt; '\n';
  // запрос на обновление элемента
  } else {
    cin >> id >> c;
    id--;
    update_tree_sum(Tree_sum, number_left_list + id, c);
  }
}
</pre>

  <h4>Дерево отрезков</h4>

  <p>Усложнения:</p>
  <ol>
    <li>Другие операции не только сложение</li>
    <li>Более сложные пробеги по дереву отрезков. Например, со специальной проверкой сыновей или только одного из них</li>
    <li>Массовые операции, так называемое проталкивание</li>
    <li>Многомерные деревья</li>
  </ol>
</article>


<!-- Задача поиска на отрезке. Варианты -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>Задача поиска на отрезке. Варианты</h3>

  <p>Имеется массив a, состоящий из n (n ≥ 100000) элементов. Требуеся выполнять 2 операции.</p>
  <ol>
    <li>Найти результат некоторой ассоциативной операции среди элементов с a<sub>l</sub> по a<sub>r</sub>.</li>
    <li>Изменить элемент a<sub>pos</sub></li>
  </ol>

  <p>Примеры ассоциативной операции: максимум, минимум, сумма, произведение, НОД, НОК. Все эти задачи решаются одинаково. Для решения этих задач подходит дерево отрезков и еще несколько структур данных. Дерево отрезков - самое простое в реализации, поэтому в этих задачах применяют именно его.</p>

  <h4>Дерево отрезков</h4>

  <p>Дерево отрезков это бинарное дерево, которое строится определенным образом.</p>
</article>


<!-- Дерево отрезков для определения максимума -->
<article class="article">
  <div class="anchor" id="p4"></div>
  <h3>Дерево отрезков для определения максимума</h3>

  <p>Имеется массив a, состоящий из n (n ≥ 100000) элементов. Требуеся выполнять 2 операции.</p>
  <ol>
    <li>Найти максимальный среди элементов с a<sub>l</sub> по a<sub>r</sub>.</li>
    <li>Изменить элемент a<sub>pos</sub></li>
  </ol>

  <p>Отвечать на каждый запрос надо уметь за O(logN) времени.</p>

  <p>Построим дерево отрезков. Возьмем массив из 8 элементов. Очень удобно иметь бинарное дерево с количеством элементов на нижнем уровне, равном степени двойки.</p>
  <code>3 1 4 1 5 9 2 6</code>
  <p>У каждой пары соседних элементов будут свои родители. Если мы строим дерево для максимума, то родителем двух элементов будет максимальный их детей.</p>
<pre>
  3      4      9      6
 / \    / \    / \    / \
3   1  4   1  5   9  2   6
</pre>
  <p>Для каждой полученной пары будут свои родители, равные максимальному из детей</p>
<pre>
     4             9
    /  \          /  \
  3      4      9      6
 / \    / \    / \    / \
3   1  4   1  5   9  2   6
</pre>
  <p>Корень дерева будет максимум из двух его ветвей и максимум всего массива.</p>
<pre>
             9
         /      \
      4            9
    /  \          /  \
  3      4      9      6
 / \    / \    / \    / \
3   1  4   1  5   9  2   6
</pre>
  <p>Такая структура дает сложность поиска по времени O(logN)</p>
  <p>Для 8 элементов мы получили 15 вершин. Для k элементов получим 2*k - 1 вершин. Потребление памяти будет линейное O(N).</p>
  <p>Мы будем работать не с отрезками массива, а с полуинтервалами. Листья это полуинтервалы, с числом элементов равным 1. Над ними полуинтервалы длины 2, над ними - длины 4, на самом верху полуинтервал длины 8, который содержит ответ для всего массива целиком.</p>
<pre>
                       9
                     [0,8)
                 /            \
           4                       9
         [0,4)                   [4,8)
       /       \              /        \
     3           4          9            6
   [0,2)       [2,4)      [4,6)        [6,8)
    / \         / \        / \          / \
  3     1     4     1    5      9     2     6
[0,1) [1,2) [2,3) [3,4) [4,5) [5,6) [6,7) [7,8)
</pre>

  <h4>Оценка требуемой памяти</h4>

  <p>Пусть N = 2<sup>k</sup>. Если это не так, дополним размер массива до ближайшей степени двойки. Всего в массиве будет k+1 слой. В k-ом слое будет 2<sup>k</sup> вершин, в k-1 слое будет 2<sup>k-1</sup> вершин, ... , в 0-м слое будет 1 вершина.</p>
  <code>2<sup>k</sup> + 2<sup>k-1</sup> + ... + 1 = 2<sup>k</sup> * (1 - 1/2<sup>k+1</sup>) / (1 - 1/2) = 2<sup>k+1</sup> * (1-1/2<sup>k+1</sup>) = 2<sup>k+1</sup> - 1</code>
  <p>Потребуется дополнительно 2N - 1 ячеек памяти.</p>

  <h4>Дополнение массива</h4>

  <p>Дополним массив из n элементов до ближайшей степени двойки. Из массива длины n сделаем массив длины k.</p>
<pre>
int n;
cin >> n;
vector&lt;int&gt; a(n);
for (int i = 0; i &lt; n; i++) {
  cin >> a[i];
}

int k = 1;
while (k &lt; n) {
  k *= 2;
}

// 0 .. n-1 -> 0 .. k-1
for (int i = n; i &lt; k; i++) {
  a.push_back(-INF);
}
</pre>
  <p>Добавляем всегда нейтральный элемент. Поскольку мы строим дерево отрезков для поиска максимума, то нейтральный элемент это -INF, который не влияет на максимум.</p>

  <h4>Если не хотим дополнять до ближайшей степени двойки, то объявляем массив на 4N ячеек памяти.</h4>

  <p>В худшем случае массив имеет 2<sup>k</sup>+1 элемент и до степени двойки нам надо добавить еще 2<sup>k</sup>-1 элемент. Получим размер массива равный 2<sup>k+1</sup> тогда размер дерева отрезков будет 2<sup>k+2</sup>-1</p>. Получается что размер дерева отрезков 2<sup>k+2</sup>-1</p> относительно размера изначального массива 2<sup>k</sup>+1 примерно в 4 раза больше.
  <code>4*N = 4*(2<sup>k</sup>+1) = 2<sup>k+2</sup>+4</code>
  <p>Получим, что 2<sup>k+2</sup>+4 это гарантированно больше, чем 2<sup>k+2</sup>-1</p>

  <h4>Нумерация вершин</h4>

  <p>Нумерация вершин идет сверху вниз, слева направо</p>
<pre>
                      0
                /            \
          1                       2
      /       \              /        \
   3           4          5            6
  / \         / \        / \          / \
7     8     9    10    11   12      13   14
</pre>
  <p>При такой нумерации вершин, если вершина имеет номер i, то ее дети будут иметь номера 2i+1 и 2i+2</p>

  <h4>Построение дерева отрезков. Рекурсивный метод</h4>

  <p>Как и в сортировке слиянием, мы будем доходить до листьев, потом подниматься от листьев вверх и записывать информацию в предках.</p>

  <h4>Построение и запросы</h4>

  <p>Основные принципы:</p>
  <ol>
    <li>Где я? В какой вершине я нахожусь и за какой отрезок она отвечает? Раздать детям</li>
    <li>Вызываться от детей</li>
    <li>Пересчитать себя</li>
  </ol>
  <p>Когда нужно найти значение, то мы пересчитываться не будем, но возможно будем вызываться от детей.</p>
  <p>Когда нужно изменить значение, то мы всегда будем пересчитываться и вызываться от детей.</p>
  <p>Построение начинаем с корня. Такое построение называется построением сверху.</p>

  <h4>Построение сверху</h4>

  <ol>
    <li>Спустимся от корня до листьев</li>
    <li>Лист соответствует одному элементу массива</li>
    <li>Пересчитываем значение для каждого листа</li>
    <li>Вернемся к родителю, пересчитаем его</li>
  </ol>
  <p>Как понять что мы находимся в листе? Лист это вершина, которая отвечает за отрезок [l,l+1) длины 1. У отрезка длины 1 разница между правой и левой границей равно 1.</p>
  <code>r - l = l + 1 - l = 1</code>
<pre>
vector&lt;int&gt; t(4*MAXN), a;
void build(int v, int l, int r) {

  if (r-l == 1) {
    // если зашли в лист
    t[v] = a[l];

  } else {
    int m = (l+r) / 2;
    build(2*v + 1, l, m);
    build(2*v + 2, m, r);
    t[v] = max(t[2*v + 1], t[2*v + 2]);
  }
}
</pre>
  <p>Массив a это начальный массив с элементами. Массив t это дерево отрезков размером, достаточным для хранения этого дерева. Рекурсивная функция build принимает три параметра: v это номер вершины, l и r это границы отрезка, за который эта вершина отвечает. Так как мы запускаемся от корня, у нас будет нулевая вершина, которая отвечает за полуинтервал [0, r), то есть весь массив.</p>
  <p>Внутри функции build мы определяем, если мы находимся в листе, то в t[v] записываем элемент массива a[l]. Иначе, мы находимся не в листе, а на отрезке. Делим этот отрезок пополам и рекурсивно вызываем функцию build от левого ребенка и от правого ребенка.</p>
  <p>Первый раз запускаем функцию build с параметрами 0, 0, n потому что мы передаем ей полное дерево, то есть корень в качестве вершины и границы, которые охватывают весь массив.</p>
  <code>build(0, 0, n);</code>

  <p>Обработаем запрос. Пусть необходимо найти значение максимума на отрезке [1,4] с левой и правой границей включительно. Мы этот отрезок можем превратить в полуинтервал [1,5).</p>
<pre>
                       9
                     [0,8)
                 /            \
           4                       9
         [0,4)                   [4,8)
       /       \              /        \
     3           4          9            6
   [0,2)       [2,4)      [4,6)        [6,8)
    / \         / \        / \          / \
  3     1     4     1    5      9     2     6
[0,1) [1,2) [2,3) [3,4) [4,5) [5,6) [6,7) [7,8)
</pre>
  <p>Запускаемся от корня дерева и выбираем полуинтервалы, которые содержат вершины из нашего полуинтервала. Нам будут встречаться полуинтервалы трех видов:</p>
  <ol>
    <li>Не пересекаются. Дальше не идем. Возвращаем нейтральный элемент. Для поиска максимума это -INF</li>
    <li>Пересекаются частично. Переходим в детей</li>
    <li>Пересекаются полностью. Дальше не идем. Вернем ответ туда откуда нас вызвали</li>
  </ol>
  <ul>
    <li>0 слой: [0,8) пересекается с [1,5). Переходим в детей [0,4) и [4,8)</li>
    <li>1 слой: [0,4), [4,8) пересекаются с [1,5). Переходим в детей [0,2), [2,4), [4,6), [6,8)</li>
    <li>2 слой: [0,2), [4,6) пересекаются с [1,5). Переходим в листья [0,1), [1,2), [4,5), [5,6). [2,4) входит полностью в [1,5). Возвращаем значение вершины [2,4). [6,8) не пересекается с [1,5) поэтому дальше не идем</li>
    <li>3 слой: [1,2), [4,5) входят полностью в [1,5). Возвращаем значения вершин [1,2), [4,5). [0,1), [5,6) не пересекается с [1,5) поэтому дальше не идем</li>
  </ul>

  <h4>Поиск максимума</h4>
<pre>
int get_max(int v, int l, int r, int a, int b) {

  if (b &lt;= l || r &lt;= a) {
    // если отрезки не пересекаются
    // возвращаем нейтральный элемент
    return -INF;
  }

  if (a &lt;= l && r &lt;= b) {
    // если отрезок из вершины полностью
    // внутри заданного отрезка
    // возвращаем значение вершины
    return t[v];
  }

  int m = (l+r) / 2;
  int max_l = get_max(2*v + 1, l, m, a, b);
  int max_r = get_max(2*v + 1, m, r, a, b);
  return max(max_l, max_r);
}
</pre>
  <p>Дополнительно в функцию поиска максимума get_max() передаем границы исходного массива [a,b).</p>
  <code>get_max(0, 0, n, l, r);</code>

  <h4>Изменение элемента</h4>
  <p>Сначала находим вершину в которой нужно поменять значение, затем во всех родителях пересчитываем значение. Поскольку значение элемента изменяет лист, то сначала мы спустимся от корня к листу за O(logN). Затем поднимемся обратно также за O(logN).</p>
  <p>Алгоритм изменения элемента</p>
  <ul>
    <li>Находим лист, которому соответствует данный элемент</li>
    <li>Проталкиваем информацию предкам</li>
  </ul>
<pre>
void update(int v, int l, int r, int pos, int val) {

  if (pos &lt; l || pos >= r) {
    return ;
  }

  if (r - l == 1) {
    t[v] = val;
  } else {
    int m = (l + r) / 2;
    update(2*v + 1, l, m, pos, val);
    update(2*v + 2, m, r, pos, val);
    t[v] = max(t[2*v + 1], t[2*v + 2]);
  }
}
</pre>
  <p>Если pos не попадает в полуинтервал [l,r) то мы там ничего не меняем. Если pos попал в лист, то это тот лист который нам нужен и мы записываем в него новое значение. Если в лист не попали, то делим отрезок на две половины.</p>
  <code>update(0, 0, n, pos, val);</code>
</article>


<!-- Поиск k-го нуля -->
<article class="article">
  <div class="anchor" id="p5"></div>
  <h3>Поиск k-го нуля</h3>

  <p>Дан массив из N чисел. Найти позицию k-го нуля. Пример:</p>
  <code>1 0 2 0 3 0</code>
  <p>3-й ноль = 5. 4-й ноль = -1</p>
  <p>Как решать? Превратим наш массив в массив из единиц и нулей. a[i] = 1 если элемент был равен 0, a[i] = 0 если элемент не был равен 0.</p>
  <code>1 0 2 0 3 0 -> 0 1 0 1 0 1</code>
  <p>Тогда на вопрос сколько в массиве нулей, мы ответим если найдем сумму всех элементов массива. Общее количество нулей в массиве - суммарное число единиц. Составим дерево отрезков для сумм на измененном массиве.</p>
  <p>Найдем k-й по счету лист, который равен 1. Спустимся к нему, используя информацию в вершинах дерева. Для этого будем сравнивать k со значением в левом сыне (суммарное число нулей в нем).</p>
  <ol>
    <li>k ≤ t[2*v + 1] -> k-й ноль в левом сыне.</li>
    <li>k > t[2*v + 1] -> k-й ноль в правом сыне. Причем там он (k - t[2*v + 1])-й ноль</li>
    <li></li>
  </ol>
  <p>Реализация</p>
<pre>
vector&lt;int&gt; t(4*MAXN), a;
void build(int v, int l, int r) {
  if (r - l == 1) {
    t[v] = (a[l] == 0);
  } else {
    int m = (l + r) / 2;
    build(2*v + 1, l, m);
    build(2*v + 2, m, r);
    t[v] = t[2*v + 1] + t[2*v + 2];
  }
}
</pre>

  <p>Реализация изменения значения</p>
<pre>
void update(int v, int l, int r, int pos, int val) {

  if (pos &lt; l || pos >= r) {
    return ;
  }

  if (r - l == 1) {
    t[v] = (val == 0);
  } else {
    int m = (l + r) / 2;
    update(2*v + 1, l, m, pos, val);
    update(2*v + 2, m, r, pos, val);
    t[v] = t[2*v + 1] + t[2*v + 2];
  }
}
</pre>

  <p>Поиск k-го нуля</p>
<pre>
int get_kth(int v, int l, int r, int k) {

  if (k > t[v]) {
    return -1;
  }

  if (r - l == 1) {
    return l;
  }

  int m = (l + r) / 2;
  if (k &lt;= t[v*2 + 1]) {
    return get_kth(2*v + 1, l, m, k);
  } else {
    return get_kth(2*v + 2, mm, r, k - t[v*2 + 1]);
  }
}
</pre>
  <code>Вызов get_kth(0, 0, n, k);</code>
</article>


<!-- Задача A. Максимизация пересечений (простая версия) -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Максимизация пересечений (простая версия)</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Единственная разница между двумя версиями состоит в том, что в этой версии n≤1000 и сумма значений n по всем наборам входных данных теста не превосходит 1000.</p>
  <p>Терминал — это ряд без промежутков из n равных отрезков, пронумерованных от 1 до n по порядку. Есть два терминала, один над другим.</p>
  <p>Вам дан массив a длины n. Для всех i=1,2,…,n должен быть прямой провод из некоторой точки на отрезке i верхнего терминала в некоторую точку на отрезке a<sub>i</sub> нижнего терминала. Например, на следующих рисунках показаны два возможных соединения, при n=7 и a=[4,1,4,6,7,7,5].</p>
  <p>Пересечение происходит, когда два провода имеют общую точку. На картинке выше пересечения обведены красным.</p>
  <p>Какое максимальное количество пересечений может быть при оптимальном размещении проводов?</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 1000) — количество наборов входных данных.</p>
  <p>Первая строка каждого набора содержит целое число n (1 ≤ n ≤ 1000) — длина массива.</p>
  <p>Вторая строка каждого набора содержит n целых чисел a₁,a₂, .. , aₙ (1 ≤ aᵢ ≤ n) — элементы массива.</p>
  <p>Сумма n по всем наборам входных данных не превосходит 1000.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора выведите единственное целое число — максимальное количество пересечений, при оптимальном расположении проводов.</p>

  <details>
    <summary>Пример</summary>
<pre>
4
7
4 1 4 6 7 7 5
2
2 1
1
1
3
2 2 2
</pre>
<pre>
6
1
0
3
</pre>
    <p>Первый пример показан на втором рисунке в условии.</p>
    <p>Во втором примере при единственно возможном соединении появляется пересечение двух проводов, поэтому ответ равен 1.</p>
    <p>В третьем тестовом примере единственно возможное соединение состоит из одного провода, поэтому ответ равен 0.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <ul>
      <li>У нас есть два терминала: верхний и нижний.</li>
      <li>Каждый провод соединяет отрезок i на верхнем терминале с отрезком a[i] на нижнем терминале.</li>
      <li>Пересечение проводов происходит, если два провода имеют общую точку.</li>
      <li>Нам нужно найти максимальное количество пересечений при оптимальном расположении проводов.</li>
    </ul>
    <p>Максимальное количество пересечений достигается, когда провода расположены таким образом, что их порядок на нижнем терминале является обратным к порядку на верхнем терминале. То есть, если провода на верхнем терминале идут в порядке 1, 2, 3, ..., n, то на нижнем терминале они должны идти в порядке a[1], a[2], ..., a[n], и количество пересечений будет равно количеству инверсий в массиве a.</p>

    <p>Однако, если в массиве a есть повторяющиеся элементы (например, a = [2, 2, 2]), то провода, идущие в один и тот же отрезок на нижнем терминале, не пересекаются. Поэтому для таких случаев нужно учитывать, что провода, идущие в один и тот же отрезок, можно расположить так, чтобы они не пересекались.</p>

    <p>Подсчитаем количество инверсий в массиве a. Это даст нам количество пересечений, если все провода идут в разные отрезки на нижнем терминале.</p>

    <p>Если в массиве есть повторяющиеся элементы, то для каждого повторяющегося элемента x добавим количество способов расположить провода, идущие в x, так, чтобы они не пересекались. Это количество равно количеству сочетаний из k по 2, где k — количество вхождений x в массив a.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;algorithm&gt;

using namespace std;

// Функция для подсчета инверсий с использованием сортировки слиянием
long long mergeAndCount(vector&lt;int&gt;& arr, vector&lt;int&gt;& temp, int left, int mid, int right) {
  int i = left;
  int j = mid + 1;
  int k = left;
  long long invCount = 0;

  while (i &lt;= mid && j &lt;= right) {
    if (arr[i] &lt;= arr[j]) {
      temp[k++] = arr[i++];
    } else {
      temp[k++] = arr[j++];
      invCount += (mid - i + 1);
    }
  }

  while (i &lt;= mid) {
    temp[k++] = arr[i++];
  }

  while (j &lt;= right) {
    temp[k++] = arr[j++];
  }

  for (i = left; i &lt;= right; i++) {
    arr[i] = temp[i];
  }

  return invCount;
}

long long countInversions(vector&lt;int&gt;& arr, vector&lt;int&gt;& temp, int left, int right) {
  long long invCount = 0;
  if (left &lt; right) {
    int mid = (left + right) / 2;
    invCount += countInversions(arr, temp, left, mid);
    invCount += countInversions(arr, temp, mid + 1, right);
    invCount += mergeAndCount(arr, temp, left, mid, right);
  }
  return invCount;
}

long long countInversions(vector&lt;int&gt;& arr) {
  vector&lt;int&gt; temp(arr.size());
  return countInversions(arr, temp, 0, arr.size() - 1);
}

int main() {
  int t;
  cin >> t;
  while (t--) {
    int n;
    cin >> n;
    vector&lt;int&gt; a(n);
    for (int i = 0; i &lt; n; i++) {
      cin >> a[i];
    }

    // Подсчет инверсий
    long long invCount = countInversions(a);

    // Подсчет повторяющихся элементов
    map&lt;int, int&gt; freq;
    for (int x : a) {
      freq[x]++;
    }

    // Добавляем количество пересечений для повторяющихся элементов
    for (auto& [x, cnt] : freq) {
      if (cnt >= 2) {
        invCount += (long long)cnt * (cnt - 1) / 2;
      }
    }

    cout &lt;&lt; invCount &lt;&lt; endl;
  }
  return 0;
}
</pre>
  </details>
</article>


<!-- Задача B. Максимизация пересечений (сложная версия) -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Максимизация пересечений (сложная версия)</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Единственная разница между двумя версиями состоит в том, что в этой версии n ≤ 2 * 10⁵ и сумма значений n по всем наборам входных данных теста не превосходит 2 * 10⁵.</p>
  <p>Терминал — это ряд без промежутков из n равных отрезков, пронумерованных от 1 до n по порядку. Есть два терминала, один над другим.</p>
  <p>Вам дан массив a длины n. Для всех i=1,2,…,n должен быть прямой провод из некоторой точки на отрезке i верхнего терминала в некоторую точку на отрезке a<sub>i</sub> нижнего терминала. Например, на следующих рисунках показаны два возможных соединения, при n=7 и a=[4,1,4,6,7,7,5].</p>
  <p>Пересечение происходит, когда два провода имеют общую точку. На картинке выше пересечения обведены красным.</p>
  <p>Какое максимальное количество пересечений может быть при оптимальном размещении проводов?</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 1000) — количество наборов входных данных.</p>
  <p>Первая строка каждого набора содержит целое число n (1 ≤ n ≤ 2 * 10⁵) — длина массива.</p>
  <p>Вторая строка каждого набора содержит n целых чисел a₁,a₂, .. , aₙ (1 ≤ aᵢ ≤ n) — элементы массива.</p>
  <p>Сумма n по всем наборам входных данных не превосходит 2 * 10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора выведите единственное целое число — максимальное количество пересечений, при оптимальном расположении проводов.</p>

  <details>
    <summary>Пример</summary>
<pre>
4
7
4 1 4 6 7 7 5
2
2 1
1
1
3
2 2 2
</pre>
<pre>
6
1
0
3
</pre>
    <p>Первый пример показан на втором рисунке в условии.</p>
    <p>Во втором примере при единственно возможном соединении появляется пересечение двух проводов, поэтому ответ равен 1.</p>
    <p>В третьем тестовом примере единственно возможное соединение состоит из одного провода, поэтому ответ равен 0.</p>
  </details>
</article>


<!-- Задача C. Задача о клике -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Задача о клике</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Задача о клике — одна из самых известных NP-полных задач. После некоторых оговорок она формулируется следующим образом. Рассмотрим неориентированный граф G. Требуется найти такое подмножество вершин C максимального размера, что любые две из них соединены ребром в графе G. Звучит просто, не правда ли? К текущему моменту не известен алгоритм, который находит решение этой задачи за полиномиальное время от размера графа. Однако, как и в случае многих других NP-полных задач, задача о клике оказывается проще, если рассмотреть граф специфического вида.</p>

  <p>Рассмотрим n различных точек на прямой. Пусть i-я точка имеет координату xi и вес wi. Образуем граф G, вершинами которого являются эти точки, а рёбрами соединены в точности те пары точек (i, j), для которых расстояние между этими точками не меньше суммы их весов, формально говоря: |xi - xj| ≥ wi + wj.</p>

  <p>Найдите размер максимальной клики в таком графе.</p>

  <h4>Входные данные</h4>
  <p>В первой строке задано число n (1 ≤ n ≤ 200 000) — количество точек.</p>

  <p>В каждой из последующих n строк следуют по два числа xi, wi (0 ≤ xi ≤ 10⁹, 1 ≤ wi ≤ 10⁹) — координата и вес очередной точки. Все координаты xi различны.</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно число — количество вершин в максимальной клике образованного графа.</p>

  <details>
    <summary>Пример</summary>
<pre>
4
2 3
3 1
6 1
0 2
</pre>
    <code>3</code>

    <p>Если вы вдруг умеете решать эту задачу, не используя специфические свойства графа, представленного в условии задачи, то вам полагается приз в миллион доллларов!</p>
    <p>Изображение к тесту из условия:</p>
  </details>
</article>


<!-- Задача D. Валера и запросы -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Валера и запросы</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 512мб</i></div>

  <p>Валера очень любит отрезки. Недавно он придумал одну интересную задачу.</p>

  <p>На координатной прямой есть n отрезков, i-й отрезок начинается в позиции li и заканчивается в позиции ri (будем обозначать его [li, ri]). Требуется обработать m запросов, каждый из которых состоит из числа cnti и набора cnti координат точек, расположенных на координатной прямой. Ответом на запрос является количество таких отрезков, что каждый из них содержит хотя бы одну точку из набора. Отрезок [l, r] содержит точку q, если l ≤ q ≤ r.</p>

  <p>Решение этой задачи Валере показалось слишком сложным. Поэтому он обратился за помощью к вам. Помогите Валере.</p>

  <h4>Входные данные</h4>
  <p>В первой строке задано два целых числа n, m (1 ≤ n, m ≤ 3·10⁵) — количество отрезков на координатной прямой и количество запросов.</p>

  <p>В следующих n строках задано описание отрезков. Строка номер i содержит два целых положительных числа li, ri (1 ≤ li ≤ ri ≤ 10⁶) — границы i-го отрезка.</p>

  <p>В следующих m строках содержится описание запросов по одному на строке. Каждая строка начинается с целого числа cnti (1 ≤ cnti ≤ 3·10⁵) — количество точек в i-м запросе. Далее в строке идут cnti различных целых положительных чисел p1, p2, ..., pcnti (1 ≤ p1 &lt; p2 &lt; ... &lt; pcnti ≤ 106) — координаты точек в i-м запросе.</p>

  <p>Гарантируется, что суммарное количество точек во всех запросах не превосходит 3·10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Выведите m целых неотрицательных чисел, где i-e число — ответ на i-й запрос.</p>

  <details>
    <summary>Пример</summary>
<pre>
3 3
1 3
4 5
6 7
3 1 4 7
2 4 5
1 8
</pre>
<pre>
3
1
0
</pre>
  </details>
</article>


<!-- Задача E. Range Update Point Query -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Range Update Point Query</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Дан массив a1,a2,…,an, вам нужно обработать суммарно q запросов и обновлений следующих типов:</p>
  <ol>
    <li>l r — для каждого индекса i такого, что l ≤ i ≤ r, заменить значение ai на сумму цифр в ai.</li>
    <li>x — вывести ax.</li>
  </ol>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 1000) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит два целых числа n и q (1 ≤ n, q ≤ 2⋅10⁵) — размер массива и количество запросов соответственно.</p>

  <p>Вторая строка каждого набора входных данных содержит n целых чисел a1, a2, ... , an (1 ≤ ai ≤ 10⁹).</p>

  <p>Следующие q строк каждого набора входных данных содержат запросы следующих видов:</p>
  <ol>
    <li>l r (1 ≤ l ≤ r ≤ n) — означает, что для каждого индекса i такого, что l≤i≤r, вам следует заменить значение ai на сумму его цифр.</li>
    <li>x (1 ≤ x ≤ n) — означает, что вы должны вывести ax.</li>
  </ol>

  <p>Гарантируется, что существует хотя бы один запрос второго типа.</p>

  <p>Сумма n по всем наборам входных данных не превосходит 2⋅10⁵.</p>

  <p>Сумма q по всем наборам входных данных не превосходит 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите ответы на запросы второго типа, в том порядке, в котором они заданы в тесте.</p>

  <details>
    <summary>Пример</summary>
<pre>
3
5 8
1 420 69 1434 2023
1 2 3
2 2
2 3
2 4
1 2 5
2 1
2 3
2 5
2 3
9999 1000
1 1 2
2 1
2 2
1 1
1
2 1
</pre>
<pre>
6
15
1434
1
6
7
36
1
1
</pre>

    <p>В первом наборе входных данных происходят следующие изменения:</p>
    <ul>
      <li>Изначально a=[1,420,69,1434,2023].</li>
      <li>Операция применяется с l=2, r=3, получаем [1,6,15,1434,2023].</li>
      <li>Запрошены значения с x=2, x=3, и x=4, выводим 6, 15, и 1434.</li>
      <li>Операция применяется с l=2, r=5, получаем [1,6,6,12,7].</li>
      <li>Запрошены значения с x=1, x=3, и x=5, выводим 1, 6, и 7.</li>
    </ul>
  </details>
</article>


<!-- Задача F. Дерево отрезков. Сумма -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Дерево отрезков. Сумма</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Высший Разум собирал контест. К сожалению, контест был тренировочный, поэтому интересные условия писать он не хотел. Но внезапно проснулся Дмитрий Сергеевич, и исправил сие недоразумение.</p>

  <p>Изначально у вас есть N задач, и ни у одной из них нет легенды. Затем происходит одно из двух событий:</p>
  <ol>
    <li>Некто заставляет Дмитрия Сергеевича написать C легенд к задаче с номером i.</li>
    <li>Высший Разум интересуется, сколько легенд суммарно у задач с номерами с L по R. Естественно, этим подсчётом занимается Дмитрий Сергеевич.</li>
  </ol>

  <p>Дмитрий Сергеевич очень ленив, и поэтому просит вашей помощи. Помогите Дмитрию Сергеевичу ответить на все вопросы Высшего Разума.</p>

  <h4>Входные данные</h4>
  <p>В первой строке вам даны два числа - N и M (1 ≤ N ≤ 10⁶, 1 ≤ M ≤ 10⁵) - количество задач и действий Дмитрия Сергеевича. В следующих M строках даны параметры событий:</p>
  <ol>
    <li>+ i C - Необходимо добавить С легенд к задаче с номером i.</li>
    <li>? L R - Необходимо найти суммарное количество легенд у задач с номерами с L по R.</li>
  </ol>

  <h4>Выходные данные</h4>
  <p>На каждый запрос второго типа вам надо в отдельной строке вывести единственное число - суммарное количество легенд в задачах с номерами с L по R.</p>

  <details>
    <summary>Пример</summary>
<pre>
7 7
+ 3 5
+ 4 -9
+ 2 0
? 1 7
? 2 3
+ 5 5
? 4 7
</pre>
<pre>
-4
5
-4
</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Напишем функцию update() и функцию SUM(). Вектор Tree передаем в них по ссылке.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

void update(vector&lt;long long&gt;& Tree,
  int number_list, int data) {
  // увеличим элемент
  Tree[number_list] += data;
  // идем от листа к корню
  while (number_list != 1) {
    number_list /= 2;
    Tree[number_list] = Tree[number_list * 2] +
      Tree[number_list * 2 + 1];
   }
}

long long SUM(vector&lt;long long&gt;& Tree,
  int id, int l, int r,
  int find_l, int find_r) {
  if (find_l &lt;= l && r &lt;= find_r) {
    return Tree[id];
  }
  if (r &lt;= find_l || find_r &lt;= l) {
    return 0;
  }
  int mid = l + (r - l) / 2;
  long long sum1 = SUM(Tree, id * 2, l, mid, find_l, find_r);
  long long sum2 = SUM(Tree, id * 2 + 1, mid, r, find_l, find_r);
  return sum1 + sum2;
}

int main() {
  // ускорение ввода и вывода
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

  // ввод данных
  int n, k;
  cin >> n >> k;

  // решение
  vector&lt;long long&gt; Tree(4 * n);
  int number_left_list = 1;
  int count_list = 1;

  while (count_list &lt; n) {
    count_list *= 2;
    number_left_list *= 2;
  }

  char type;
  int l, r;
  int id, info;

  // обработка запросов
  while (k--) {
    cin >> type;
    if (type == '+') {
      cin >> id >> info;
      id--;
      update(Tree, number_left_list + id, info);
    } else {
      cin >> l >> r;
      l--;
      // вывод результата
      cout &lt;&lt; SUM(Tree, 1, 0, count_list, l, r) &lt;&lt; '\n';
    }
  }
}
</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Напишем функцию update() и функцию SUM(). Вектор Tree создадим глобально, чтобы не передавать его в функции.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

vector&lt;long long&gt; Tree(4'000'000);

void update(int number_list, int data) {
  // увеличим элемент
  Tree[number_list] += data;
  // идем от листа к корню
  while (number_list != 1) {
    number_list /= 2;
    Tree[number_list] = Tree[number_list * 2] +
      Tree[number_list * 2 + 1];
   }
}

long long SUM(int id, int l, int r, int find_l, int find_r) {
  if (find_l &lt;= l && r &lt;= find_r) {
    return Tree[id];
  }
  if (r &lt;= find_l || find_r &lt;= l) {
    return 0;
  }
  int mid = l + (r - l) / 2;
  long long sum1 = SUM(id * 2, l, mid, find_l, find_r);
  long long sum2 = SUM(id * 2 + 1, mid, r, find_l, find_r);
  return sum1 + sum2;
}

int main() {
  // ускорение ввода и вывода
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

  // ввод данных
  int n, k;
  cin >> n >> k;

  // решение
  int number_left_list = 1;
  int count_list = 1;

  while (count_list &lt; n) {
    count_list *= 2;
    number_left_list *= 2;
  }

  char type;
  int l, r;
  int id, info;

  // обработка запросов
  while (k--) {
    cin >> type;
    if (type == '+') {
      cin >> id >> info;
      id--;
      update(number_left_list + id, info);
    } else {
      cin >> l >> r;
      l--;
      // вывод результата
      cout &lt;&lt; SUM(1, 0, count_list, l, r) &lt;&lt; '\n';
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача G. Дерево отрезков. Минимум -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Дерево отрезков. Минимум</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>В этой задаче вам надо реализовать структуру данных, которая поддерживает следующие операции:</p>
  <ol>
    <li>Вывести на экран минимум на отрезке подряд идущих чисел.</li>
    <li>Прибавить к одному из чисел массива число.</li>
  </ol>

  <h4>Входные данные</h4>
  <p>В первой строке вам дано два числа N и M (1 ≤ N, M ≤ 10⁵) - количество чисел в массиве и запросов соответственно. В следующей строке идут N чисел - изначальные числа массива. Каждое из них не превосходит 10⁵. Далее идут M строк - запросы. Каждый запрос имеет следующий вид:</p>
  <ol>
    <li>? L R - запрос на нахождение минимума на отрезке с L по R. (1 ≤ L ≤ R ≤ N)</li>
    <li>+ i C - запрос на прибавление числа C к i-ому элементу массива. С ≤ 10⁷.</li>
  </ol>

  <h4>Выходные данные</h4>
  <p>На каждый запрос первого типа вам надо вывести в отдельной строке единственное число - минимальное число на отрезке с L по R.</p>

  <details>
    <summary>Пример</summary>
<pre>
5 7
2 5 6 5 2
+ 2 7
? 2 4
? 1 5
+ 2 5
+ 2 -8
? 1 3
? 2 5
</pre>
<pre>
5
2
2
2
</pre>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

void update(vector&lt;long long&gt; &Tree,
  int number_list, int data) {
  // увеличим элемент
  Tree[number_list] += data;
  // идем от листа к корню
  while (number_list != 1) {
    number_list /= 2;
    Tree[number_list] = min(Tree[number_list * 2],
      Tree[number_list * 2 + 1]);
   }
}

long long MIN(vector&lt;long long&gt; &Tree,
  int id, int l, int r, int find_l, int find_r) {
  if (find_l &lt;= l && r &lt;= find_r) {
    return Tree[id];
  }
  if (r &lt;= find_l || find_r &lt;= l) {
    return 1e15;
  }
  int mid = l + (r - l) / 2;
  long long min1 = MIN(Tree, id * 2, l, mid, find_l, find_r);
  long long min2 = MIN(Tree, id * 2 + 1, mid, r, find_l, find_r);
  return min(min1, min2);
}

int main() {
  // ускорение ввода и вывода
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

  // ввод данных
  int n, k;
  cin >> n >> k;

  // решение
  vector&lt;long long&gt; Tree(4 * n, 1e15);
  int number_left_list = 1;
  int count_list = 1;

  while (count_list &lt; n) {
    count_list *= 2;
    number_left_list *= 2;
  }

  for (int i = 0; i &lt; n; i++) {
    int tmp;
    cin >> tmp;
    Tree[number_left_list + i] = 0;
    update(Tree, number_left_list + i, tmp);
  }

  char type;
  int l, r;
  int id, info;

  // обработка запросов
  while (k--) {
    cin >> type;
    if (type == '+') {
      cin >> id >> info;
      id--;
      update(Tree, number_left_list + id, info);
    } else {
      cin >> l >> r;
      l--;
      // вывод результата
      cout &lt;&lt; MIN(Tree, 1, 0, count_list, l, r) &lt;&lt; '\n';
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача H. Сумма на отрезке -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Сумма на отрезке</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Входной файл sum.in</p>
  <p>Выходной файл sum.out</p>

  <p>Дан массив из N элементов, нужно научиться находить сумму чисел на отрезке.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входного файла содержит два целых числа N и K - число чисел в массиве и количество запросов. (1 ≤ N ≤ 100 000), (0 ≤ K ≤ 100 000). Следующие K строк содержат запросы</p>
  <ol>
    <li>A i x - присвоить i-му элементу массива значение x (1 ≤ i ≤ n, 0 ≤ x ≤ 10⁹)</li>
    <li>Q l r - найти сумму чисел в массиве на позициях от l до r (1 ≤ l ≤ r ≤ n)</li>
  </ol>
  <p>Изначально в массиве живут нули.</p>

  <h4>Выходные данные</h4>
  <p>На каждый запрос вида Q lr нужно вывести единственное число - сумму на отрезке.</p>

  <details>
    <summary>Пример</summary>
<pre>
5 9
A 2 2
A 3 1
A 4 2
Q 1 1
Q 2 2
Q 3 3
Q 4 4
Q 5 5
Q 1 5
</pre>
<pre>
0
2
1
2
0
5
</pre>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;vector&gt;

using namespace std;

void update(vector&lt;long long&gt;& Tree,
  int number_list, int data) {
  // присвоим новый элемент
  Tree[number_list] = data;
  // идем от листа к корню
  while (number_list != 1) {
    number_list /= 2;
    Tree[number_list] = Tree[number_list * 2] +
      Tree[number_list * 2 + 1];
   }
}

long long SUM(vector&lt;long long&gt;& Tree,
  int id, int l, int r,
  int find_l, int find_r) {
  // 1 случай. Все ячейки хорошие
  if (find_l &lt;= l && r &lt;= find_r) {
    return Tree[id];
  }
  // 2 случай. Все ячейки плохие
  if (r &lt;= find_l || find_r &lt;= l) {
    return 0;
  }
  // 3 случай. Есть хорошие и плохие ячейки
  // Делим диапазон пополам и проверяем рекурсивно
  int mid = l + (r - l) / 2;
  long long sum1 = SUM(Tree, id * 2, l, mid, find_l, find_r);
  long long sum2 = SUM(Tree, id * 2 + 1, mid, r, find_l, find_r);
  return sum1 + sum2;
}

int main() {
  // ускорение ввода
  ios::sync_with_stdio(false);

  // открыть файлы для работы
  ifstream fin("sum.in");
  ofstream fout("sum.out");

  // ввод данных
  int n, k;
  fin >> n >> k;

  // решение
  vector&lt;long long&gt; Tree(4 * n);
  int number_left_list = 1;
  int count_list = 1;

  while (count_list &lt; n) {
    count_list *= 2;
    number_left_list *= 2;
  }

  char type;
  int l, r;
  int id, info;

  // обработка запросов
  while (k--) {
    fin >> type;
    // запрос на добавление
    if (type == 'A') {
      fin >> id >> info;
      id--;
      update(Tree, number_left_list + id, info);
    } else {
      fin >> l >> r;
      l--;
      // вывод результата
      fout &lt;&lt; SUM(Tree, 1, 0, count_list, l, r) &lt;&lt; '\n';
    }
  }

  // закрыть файлы
  fin.close();
  fin.close();
}
</pre>
  </details>
</article>


<!-- Задача I. Запрос изменения на отрезке -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача I. Запрос изменения на отрезке</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Входной файл rvq.in</p>
  <p>Выходной файл rvq.out</p>

  <p>В начальный момент времени последовательность a<sub>n</sub> задана следующей формулой</p>
  <code>a<sub>n</sub> = n² mod 12345 + n³ mod 23456</code>
  <p>Требуется много раз отвечать на запросы следующего вида</p>
  <ul>
    <li>найти разность между максимальным и минимальным значением среди элементов a<sub>i</sub>, a<sub>i+1</sub>, ... , a<sub>j</sub></li>
    <li>присвоить элементу a<sub>i</sub> значение j</li>
  </ul>

  <h4>Формат входного файла</h4>
  <p>Первая строка входного файла содержит натуральное число k - количество запросов (k ≤ 100000). Следующие k строк содержат запросы, по одному на строке. Запрос номер i описывается двумя целыми числами xi, yi.</p>
  <p>Если xi > 0, то требуется найти разность между максимальным и минимальным значением среди элементов a<sub>xi</sub> ... y<sub>yi</sub>/ При этом 1 ≤ xi ≤ yi ≤ 100000</p>
  <p>Если xi &lt; 0, то требуется присвоить элементу a<sub>|xi|</sub> значение yi. При этом -100000 ≤ xi ≤ -1 и |yi| ≤ 100000.</p>

  <h4>Формат выходного файла</h4>
  <p>Для каждого запроса первого типа в выходной файл требуется вывести одну строку, содержащую разность между максимальным и минимальным значением на соответствующем отрезке.</p>

  <details>
    <summary>Пример</summary>
<pre>
7
1 3
2 4
-2 -100
1 5
8 9
-3 -101
2 3
</pre>
<pre>
34
68
250
234
1
</pre>
  </details>
</article>


<!-- Задача J. Восстановление массива -->
<article class="article">
  <div class="anchor" id="task10"></div>
  <h3>Задача J. Восстановление массива</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Входной файл rmq.in</p>
  <p>Выходной файл rmq.out</p>

  <p>Рассмотрим массив a[1..n]. Пусть Q(i,j) - ответ на запрос о нахождении минимума среди чисел a[i], ... , a[j]. Вам даны несколько запросов и ответы на них. Восстановите исходный массив.</p>

  <h4>Формат входного файла</h4>
  <p>Первая строка входного файла содержит число n - размер массива, и m - число запросов (1 ≤ n, m ≤ 100000). Следующие m строк содержат по три целых числа i, j, q, означающих, что Q(i,j) = q(1 ≤ i ≤ j ≤ n, -2³¹ ≤ q 2³¹ - 1).</p>

  <h4>Формат выходного файла</h4>
  <p>Если искомого массива не существует, выведите строку "inconsistent".</p>
  <p>В противном случае в первую строку выходного файла выведите "consistent". Во вторую строку выведите элементы массива. Элементами массива должны быть целые числа в интервале от -2³¹ до 2³¹-1 включительно. Если решений несколько, выведите любое.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
3 2
1 2 1
2 3 2
</pre>
<pre>
consistent
1 2 3
</pre>

    <h4>Пример 2</h4>
<pre>
3 3
1 2 1
1 1 2
2 3 2
</pre>
<pre>
inconsistent
</pre>
  </details>
</article>


<!-- Задача K. Экзамен -->
<article class="article">
  <div class="anchor" id="task11"></div>
  <h3>Задача K. Экзамен</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Входной файл exam.in</p>
  <p>Выходной файл exam.out</p>

  <p>На мат-мехе, в аудитории 00 стоит бесконечное количество парт, расставленных в ряд и пронумерованных натуральными числами. Сегодня в этой аудитории проходит экзамен по Линейному Анализу Жутких Уравнений. Время от времени приходят студенты. Каждый студент знает, за какую парту он хочет сесть, но на экзамене нельзя двум студентам сидеть вместе, поэтому, если парта занята, он занимает первую свободную парту с бОльшим номером (подальше от преподавателя).</p>
  <p>Кроме того, некоторые студенты не сдают экзамен и уходят. После этого за парту, которую занимал ушедший студент, может сесть вновь прибывший.</p>
  <p>Преподаватель знает, когда будут приходить студенты, и когда они будут уходить учить заново. Вам требуется по этой информации узнать, за какой партой будет сидеть каждый из студентов (чтобы заранее положить туда конспект).</p>

  <h4>Формат входного файла</h4>
  <p>Первая строка входного файла содержит натуральное число n - количество событий, происходящих в течение экзамена (n ≤ 100000).</p>
  <p>Следующие n строк содержат информацию об этих событиях. Число a > 0 обозначает, что пришел студент, желающий занять парту номер a (a ≤ 100000). Число a &lt; 0 обозначает, что студент освободил парту с номером a. (Гарантируется, что он за ней действительно сидел).</p>

  <h4>Формат выходного файла</h4>
  <p>Для каждого студента выведите одно натуральное число - номер парты, которую он займет.</p>

  <details>
    <summary>Пример</summary>
<pre>
6
5
5
5
-6
5
5
</pre>
<pre>
5
6
7
6
8
</pre>
  </details>

  <details>
    <summary>Решение через дерево отрезков</summary>
    <p>Создадим большое дерево отрезков с константным размером. Это дерево для подсчета минимума. Каждый лист это парта, в кторой или номер парты или 1e7. Номер парты это парта свободна, 1e7 это парта занята. Тогда каждая вершинка сверху будет определять минимальный номер свободной парты.</p>
    <p>Из условия задачи достаточно дерева с 200000 листами (100000 студентов и 100000 парт). Размер дерева в 4 раза больше числа листьев. Значит все дерево будет занимать 800000.</p>
    <p>Если приходит запрос -a, то студент освободил парту и мы должны сделать update для листа a и пробежаться от листа к корню и обновить минимумы.</p>
    <p>Если приходит запрос a, то нужно выбрать лист (определить за какую парту посадить студента). Если этот лист свободен, то печатаем его. Если лист занят, то рекурсивно идем к родителю, а из него в правого потомка. Потому что в левом потомке номер парты меньше чем нужно. Это нестандартное движение по дереву.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;vector&gt;

using namespace std;

vector&lt;int&gt; Tree(800'000, 1e7);
int BAD = 1e7;

void update(int number_list, int data) {
  Tree[number_list] = data;
  while (number_list != 1) {
    number_list /= 2;
    Tree[number_list] = min(Tree[number_list * 2],
      Tree[number_list * 2 + 1]);
  }
}

void Find_part(int number_left_list,
  int data, int& result) {
  int number_list = data + number_left_list;
  if (Tree[number_list] == data) {
    result = data;
    update(number_list, BAD);
  } else {
    result = BAD;
    int cur_id = number_list;
    while (number_list != 1) {
      number_list /= 2;
      // если пришел из левого сына
      if (number_list * 2 == cur_id) {
        // обновляем результат
        result = min(result, Tree[2 * number_list + 1]);
      }
      cur_id = number_list;
    }
    int number_new_list = number_left_list + result;
    update(number_new_list, BAD);
  }
}

int main() {
  // ускорение ввода и вывода
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

  // открыть файлы
  ifstream fin("exam.in");
  ofstream fout("exam.out");

  // решение
  int count_list = 1;
  int first_list = 1;

  while (count_list &lt; 200000) {
    count_list *= 2;
    first_list *= 2;
  }

  for (int i = 0; i &lt; count_list; i++) {
    update(first_list + i, i);
  }

  int n;
  fin >> n;
  int a;
  for (int i = 0; i &lt; n; i++) {
    fin >> a;
    if (a &lt; 0) {
      int number_list = first_list + (-a);
      update(number_list, -a);
    } else {
      int number_list = first_list + (-a);
      int result;
      Find_part(first_list, a, result);
      fout &lt;&lt; result &lt;&lt; '\n';
    }
  }
}
</pre>
  </details>

  <details>
    <summary>Решение через set</summary>
    <p>Вместо дерева отрезков, эту задачу можно решить через set.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;set&gt;

using namespace std;

int main() {
  // ускорение ввода и вывода
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

  // открыть файлы
  ifstream fin("exam.in");
  ofstream fout("exam.out");

  // ввод данных
  int n;
  fin >> n;

  // решение
  set&lt;int&gt; st;
  for (int i = 0; i &lt; 250000; i++) {
    // заносим в set свободные парты
    st.insert(i);
  }
  int a;
  for (int i = 0; i &lt; n; i++) {
    fin >> a;
    if (a &lt; 0) {
      // возвращаем парту и ее номер
      st.insert(-a);
    } else {
      fout &lt;&lt; *st.lower_bound(a) &lt;&lt; '\n';
      // занимаем парту и удаляем ее из st
      st.erase(st.lower_bound(a));
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача L. Шакти -->
<article class="article">
  <div class="anchor" id="task12"></div>
  <h3>Задача L. Шакти</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В мире «Героев Меча и Магии 3» есть огромное количество интересных персонажей: Сольмир, Лорд Хаарт, Уфретин, Ксерон, Сандро, Луна, Тазар, Крэг Хак, Кассиопея. Эта история будет посвящена лорду подземелий Шакти.</p>

  <p>С самого рождения Шакти слеп и ничего не видит, но это не помешало ему стать великим военачальником, стратегом, предводителем троглодитов. Каждый раз, готовясь перед сражением, Шакти проверяет построение своей армии. В армию Шакти входят n лучших троглодитов, каждый из которых имеет уникальный рост равный ai. Все троглодиты стоят в один ряд.</p>

  <p>В очередной раз перед боем Шакти делает перестроение своих солдат. Всего Шакти делает q перестроений, выбирая солдат, стоящих на позициях с li по ri включительно. Для перестроения Шакти наощупь определяет самого высокого и самого низкого троглодитов на отрезке и меняет их местами.</p>

  <p>Помогите Шакти определить итоговое построение армии троглодитов после всех перестановок.</p>

  <h4>Входные данные</h4>
  <p>В первой строке вам будет дано два целых числа n и q (1 ≤ n, q ≤ 10⁵) — количество солдат в армии Шакти и количество операций перестроений.</p>

  <p>Далее во второй строке перечислены ai (1 ≤ ai ≤ n) — роста воинов Шакти. Гарантируется, что для любых i≠j выполняется неравенство ai≠aj.</p>

  <p>В следующих q строках перечислены запросы Шакти: пара чисел li и ri (1 ≤ li ≤ ri ≤n) — отрезок, на котором следует сделать перестроение.</p>

  <h4>Выходные данные</h4>
  <p>Выведите n целых чисел  — росты воинов армии Шакти в шеренге по окончанию всех q перестановок.</p>

  <details>
    <summary>Пример</summary>
<pre>
5 3
1 2 3 4 5
2 4
1 3
1 5
</pre>
  <code>4 5 3 2 1 </code>
  </details>
</article>


<!-- Задача M. Наибольший общий делитель -->
<article class="article">
  <div class="anchor" id="task13"></div>
  <h3>Задача M. Наибольший общий делитель</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Наибольшим общим делителем непустого набора натуральных чисел A называется максимальное натуральное число d, такое что оно является одновременно делителем всех чисел множества A.</p>

  <p>Задан массив натуральных чисел [a1, a2, ... , an] и число k. Требуется выбрать в нем подмассив из k подряд идущих элементов [al, al+1, ... , al+k-1], чтобы их наибольший общий делитель был как можно больше, и вывести этот наибольший общий делитель.</p>

  <h4>Входные данные</h4>
  <p>Первая строка ввода содержит два целых числа n и k (2 ≤ n ≤ 500000, 2 ≤ k ≤ n).</p>

  <p>Вторая строка содержит n натуральных чисел a1, a2, ... , an (1 ≤ ai ≤ 10¹⁸).</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно натуральное число – максимальное возможное значение наибольшего общего делителя элементов подмассива длины k заданного массива.</p>

  <h4>Пример</h4>
<pre>
10 4
2 3 4 8 12 6 12 18 4 3
</pre>
  <code>6</code>
</article>


<!-- Задача N. НОД на подотрезках с изменением элемента -->
<article class="article">
  <div class="anchor" id="task14"></div>
  <h3>Задача N. НОД на подотрезках с изменением элемента</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Реализуйте эффективную структуру данных, позволяющую изменять элементы массивы и вычислять НОД нескольких подряд идущих элементов.</p>

  <h4>Входные данные</h4>
  <p>В первой строке вводится одно натуральное число N (1 ≤ N ≤ 100000) – количество чисел в массиве.</p>

  <p>Во второй строке вводятся N чисел от 0 до 100000 – элементы массива.</p>

  <p>В третьей строке вводится одно натуральное число M (1 ≤ M ≤ 30000) – количество запросов.</p>

  <p>Каждая из следующих M строк представляет собой описание запроса. Сначала вводится одна буква, кодирующая вид запроса (s – вычислить НОД, u – обновить значение элемента).</p>

  <p>Следом за s вводятся два числа – номера левой и правой границы отрезка.</p>

  <p>Следом за u вводятся два числа – номер элемента и его новое значение.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого запроса s выведите результат. Все числа выводите в одну строку через пробел.</p>

  <details>
    <summary>Пример</summary>
<pre>
5
2 8 4 16 12
5
s 1 5
s 4 5
u 3 32
s 2 5
s 3 3
</pre>
    <code>2 4 4 32</code>
  </details>
</article>


<!-- Задача O. битдождь -->
<article class="article">
  <div class="anchor" id="task15"></div>
  <h3>Задача O. битдождь</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Однажды в битляндии пошёл битдождь. Как не странно, вся битляндия состоит из N битов. Если биткапля падает на бит, она меняет его на противоположный. (то есть бит 0 изменится на 1 а 1 на 0). Битжительи постоянно задаются странным вопросом. На какой позиции стоит К-тая по порядку еденица? Помогите им!</p>

  <h4>Входные данные</h4>
  <p>Изначально вся битляндия покрыта нулями. Первая строка содержит два числа: N и Q - количество битов и количество запросов (1 ≤ Q, N ≤ 10⁵). В последующих Q строках записаны тесты. Они бывают двух видов: ? k - вывести порядковый номер к-той еденицы ! k - на к-тую позицию попала биткапля. (1 ≤ K ≤ N)</p>

  <h4>Выходные данные</h4>
  <p>На каждый запрос ? нужно вывести порядковый номер к-той еденицы. По одному запросу на строчку. Если к-той еденицы нет, следует вывести 0.</p>

  <details>
    <summary>Пример</summary>
<pre>
3 3
! 1
! 3
? 2
</pre>
    <code>3</code>
  </details>
</article>

