<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contests" target="_blank">Codeforces ЯрГУ. Школьники</a></p>
  <p><a href="https://vk.com/sportprog_yarsu" target="_blank">vk.com/sportprog_yarsu</a></p>
  <p><a href="https://vkvideo.ru/@sportprog_yarsu" target="_blank">vkvideo.ru/@sportprog_yarsu</a></p>
</article>


<article class="article">
  <h1>Занятие 17 Динамическое программирование #2. По состояниям</h1>
  <p>Конспект видео от 2025.01.18</p>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contest/582016" target="_blank">Codeforces Контест 582016</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
        <a href="#p1">Динамическое программирование #2. По состояниям</a>
    <br><a href="#p2">Задача 1. Кузнечик</a>
    <br><a href="#p3">Задача 2. Сумма цифр</a>
    <br><a href="#p4">Задача 3. Задача из университета</a>
    <br><a href="#p5">Задача 4. Хорошая строка из 0 и 1</a>
  </p>
  <p>
        <a href="#task1">Задача A. Миллиардная Функция Васи</a>
    <br><a href="#task2">Задача B. Счастливые билеты</a>
    <br><a href="#task3">Задача C. Числа</a>
    <br><a href="#task4">Задача D. Счастливые билетики по-ярославски</a>
    <br><a href="#task5">Задача E. Трискайдекафобия</a>
    <br><a href="#task6">Задача F. Трипростые числа</a>
    <br><a href="#task7">Задача G. Необычное развлечение</a>
    <br><a href="#task8">Задача H. Рекурсивные палиндромные разбиения</a>
    <br><a href="#task9">Задача I. Стрельба</a>
    <br><a href="#task10">Задача J. Перестановки и инверсии (сложная версия)</a>
    <br><a href="#task11">Задача K. Легионы Цезаря</a>
    <br><a href="#task12">Задача L. Булочки</a>
    <br><a href="#task13">Задача M. Наименее круглый путь</a>
    <br><a href="#task14">Задача N. Считаем прямоугольники</a>
    <br><a href="#task15">Задача O. Пирамида из банок</a>
  </p>
</article>


<!-- Динамическое программирование #2. По состояниям -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Динамическое программирование #2. По состояниям</h3>

  <p>ДП по состояниям — это раздел задач динамического программирования, в которых мы хотим сохранять информацию об объекте с учетом его состояния.</p>
  <p>Чаще всего для решения задач по ДП по состояниям требуется увеличение размерности объекта хранения.</p>
</article>


<!-- Задача 1. Кузнечик -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>Задача 1. Кузнечик</h3>

  <p>Кузнечик находится на кочке 0, ему необходимо добраться до кочки n. Кузнечик умеет прыгать на соседнюю кочку или через одну кочку вперед. Вместо кочек бывают лужи куда кузнечик прыгнуть не может. Сколькими способами кузнечик может добраться до кочки n за минимальное количество прыжков?</p>
  <p>Рассмотрим пример:</p>
  <p>11011110111 - 1 кочка, 0 лужа, n равняется 10.</p>
  <p>Кузнечик может прыгать на +1 и +2. Приведем несколько вариантов пути:</p>
  <code>0 - 1 - 3 - 4 - 5 - 6 - 8 - 9 - 10 самый длинный путь.</code>
  <code>0 - 1 - 3 - 5 - 6 - 8 - 10 один из коротких путей.</code>
  <p>Приведем обобщённое решение. Нам потребуется увеличить размерность объекта ДП из обычной задачи про кузнечика.</p>
  <p>Последовательно ответим на 5 вопросов ДП:</p>
  <ol>
    <li>Что храним? Создадим двумерный массив DP. В ячейке DP[i][j] будем хранить количество способов попасть кузнечику на кочку под номером j за i прыжков.</li>
    <li>Как считаем ячейку?
      <code>Если str[j]==1, тогда DP[i][j]=DP[i-1][j-1]+DP[i-1][j-2]</code>
      <code>Если str[j]==0, тогда DP[i][j]=0</code>
    </li>
    <li>Что является простейшим случаем? (база) Ситуация, когда кузнечик никуда не прыгал. Заполним первую строку в матрице.</li>
    <li>Как обходить объект ДП? Классический обход слева направо сверху вниз.</li>
    <li>Где хранится ответ на задачу? Ответ хранится в последнем столбце, необходимо будет найти первый элемент отличный от нуля.</li>
  </ol>
  <p>Будем заполнять матрицу по этапно. Строки матрицы это количество прыжков, которые уже сделал кузнечик. Столбцы матрицы это номера кочек, на которых может оказаться кузнечик.</p>
  <p>Первая строка это куда может попасть кузнечик за 0 прыжков. Первый столбец это за сколько прыжков кузнечик может попасть на 0 кочку. Для этого ему нажно сделать 0 прыжков, то есть один способ. Первая строчка это простейший случай, это база.</p>
  <p>Вторая строчка это куда мы можем попасть за 1 прыжок. Из-за того что в нашем примере второй кочки нет, то мы можем попасть только в первую кочку.</p>
  <p>Третья строчка. Из кочки 1 кузнечик может прыгнуть только на кочку 3, потому что кочки 2 нет.</p>
  <p>Четверная строчка. Из кочки 3 кузнечик может прыгнуть в кочки 4 и 5.</p>
<pre>
          0 1 2 3 4 5 6 7 8 9 10
0 прыжков 1 0 0 0 0 0 0 0 0 0 0
1 прыжок  0 1 0 0 0 0 0 0 0 0 0
2 прыжок  0 0 0 1 0 0 0 0 0 0 0
3 прыжок  0 0 0 0 1 1 0 0 0 0 0
4 прыжок  0 0 0 0 0 1 2 0 0 0 0
5 прыжок  0 0 0 0 0 0 1 0 2 0 0
6 прыжок  0 0 0 0 0 0 0 0 1 2 2
7 прыжок  0 0 0 0 0 0 0 0 0 1 3
8 прыжок  0 0 0 0 0 0 0 0 0 0 1
9 прыжок  0 0 0 0 0 0 0 0 0 0 0
</pre>
  <p>Из таблицы видно, что самый быстрый способ попасть на 10-ю кочку это за 6 прыжков.</p>
  <p>Сколько разных способов (не только кратчайших, а вообще всех) есть чтобы попасть на 10-ю кочку? Ответ: 6. Это сумма всех элементов в 10-м столбце.</p>
</article>


<!-- Задача 2. Сумма цифр -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>Задача 2. Сумма цифр</h3>

  <p>Сколько целых чисел длины n чья сумма цифр равняется k?</p>
  <p>Отмечу, что очень часто в таких задачах требуется вывести ответ по модулю, потому что ответ слишком большой, например 10⁹ + 7. Для удобства нам потребуется постоянно брать промежуточные вычисления по модулю.</p>
  <code>(a1 + a2 + a3 + a4 + ... + an) % mod</code>
  <p>Это требуется, чтобы не пользоваться длинной арифметикой.</p>
  <p>Последовательно ответим на 5 вопросов ДП:</p>
  <ol>
    <li>Что храним? Создадим двумерный массив DP. В ячейке DP[i][j] будем хранить количество чисел длины j чья сумма цифр равняется i.</li>
    <li>Как считаем ячейку? Заметим, что если у нас было число длины z с суммой цифр g и мы допишем к нему справа 5, то длина увеличится на 1, а сумма увеличится на 5. Это позволяет нам додуматься, что для подсчета ячейки DP[i][j] требуется собрать сумму 10 элементов из столбика ранее.</li>
    <li>Что является простейшим случаем? (база) Однозначные числа, в них сумма цифр очевидна.</li>
    <li>Как обходить объект ДП? Классический обход слева направо сверху вниз.</li>
    <li>Где хранится ответ на задачу? Ответ хранится в DP[k][n].</li>
  </ol>
<pre>
vector&lt;vector&lt;long long &gt; &gt; DP(10*n, vector&lt;long long&gt; (n + 1));
for (int i = 0; i &lt;= 9; i++) {
  DP[i][1] = 1;
}
for (int j = 2; j &lt;= n; j++) {
  for (int i = 0; i &lt; 10*n; i++) {
    for (int m = 0; m &lt;= 9; m++) {
      if (i - m >= 0) {
        DP[i][j] += DP[i - m][j - 1];
      }
    }
  }
}

cout &lt;&lt; DP[k][n];
</pre>
</article>


<!-- Задача 3. Задача из университета -->
<article class="article">
  <div class="anchor" id="p4"></div>
  <h3>Задача 3. Задача из университета</h3>

  <p>Студенты ЯрГУ математического факультета с направления ПМИ сдают на втором курсе предмет основы информатики. Для прохождения на экзамен им необходимо выполнить норматив по решению задач. Со всего потока примерно 75 человек. Для допуска на экзамен необходимо сдать 100 задач.</p>
  <p>Как проверить что человек решал самостоятельно задачи? Проверка студентов на понимание кода и алгоритмов не дает проверку на честность решения норматива.</p>
  <p>Программный способ проверки схожести посылок студентов:</p>
  <ul>
    <li>Скачивание посылок решений студентов с codeforces на локальный
компьютер</li>
    <li>Способы преобразования текстов (тривиальные подходы)</li>
    <li>Реализвация алгоритма на проверку схожести текстов (Алгоритм
Левенштейна)</li>
  </ul>
  <p>Плюсы:</p>
  <ul>
    <li>Не требуется большая ручная проверка посылок участников</li>
    <li>Скорость проверки</li>
    <li>Возможность модернизации программы</li>
  </ul>
  <p>Минусы:</p>
  <ul>
    <li>У каждого участника возможны потери посылок, даже если они делали всё самостоятельно</li>
    <li>Зная сам алгоритм и способ обработки информации, студенты могли изменять свой код так, чтобы их посылки считались корректными всегда</li>
  </ul>
  <p>Результаты по посылкам студентов:</p>
  <ul>
    <li>Вся проверка автоматизирована и занимает примерно 2 часа при полной проверке решения студентов по подготовленной базе решений</li>
    <li>Нормальным количеством потерянных посылок у студентов считается 3-10%</li>
    <li>Улучшенная версия программы способна утверждать кто с кем общается (дружит)</li>
    <li>Собрана статистика по студентам, выявлены характеристики и принципы написания кода</li>
  </ul>

  <h4>Алгоритм Левенштейна</h4>
  <p>Самая главная часть всей программы - это алгоритм проверка схожести кода. Любая программа - это всего лишь длинная строка, поэтому задача схожести кодов - это проверка на схожесть длинных строк. Существует классический алгоритм Левенштейна проверяющий сколько требуется сделать изменений в str1, чтобы получить str2.</p>
  <p>Действия, которые можно применять к строке:</p>
  <ul>
    <li>Добавить 1 символ в любое место в str1</li>
    <li>Удалить 1 символ в любом месте в str1</li>
    <li>Изменить любой 1 символ в str1</li>
  </ul>
  <p>В качестве результата алгоритм Левенштейна укажет, какое минимальное количество действий необходимо выполнить, чтобы из str1 получить str2.</p>
  <p>В качестве примера потребуется рассмотрим преобразование строки КОРЖИК в строку КОТИК.</p>
  <p>Последовательно ответим на 5 вопросов ДП:</p>
  <ol>
    <li>Что храним? Создадим двумерный массив DP. В ячейке DP[i][j] будем хранить количество изменений, чтобы изменить префикс str1 длины i в префикс str2 длины j.</li>
    <li>Как считаем ячейку? Если str1[i] == str2[j], тогда DP[i][j] = DP[i - 1][j - 1]. Если str1[i]! = str2[j], тогда
    <code>DP[i][j] = min(DP[i - 1][j - 1], min(DP[i][j - 1],DP[i - 1][j])) + 1.</code>
    </li>
    <li>Что является простейшим случаем? (база) Первый столбец и первая строка, преобразование пустой строки в str2 и из str1 в пустую строку.</li>
    <li>Как обходить объект ДП? Классический обход слева направо сверху вниз.</li>
    <li>Где хранится ответ на задачу? Ответ хранится в ячейке DP[str1.size()][str2.size()].</li>
  </ol>

<pre>
           к ко кот коти котик
        0  1  2  3   4    5
к       1  0  1  2   3    4
ко      2  1  0  1   2    3
кор     3  2  1  1   2    3
корж    4  3  2  2   2    3
коржи   5  4  3  3   2    3
коржик  6  5  4  4   3    2
</pre>

  <h4>Реализация алгоритма Левенштейна</h4>
<pre>
string str1, str2;
cin >> str1 >> str2;

vector&lt;vector&lt;int&gt; &gt; DP(str1.size() + 1, vector&lt;int&gt;(str2.size() + 1));
for (int i = 0; i &lt;= str1.size(); i++) {
  DP[i][0] = i;
}
for (int j = 0; j &lt;= str2.size(); j++) {
  DP[0][j] = j;
}
for (int i = 1; i &lt;= str1.size(); i++) {
  for (int j = 1; j &lt;= str2.size(); j++) {
    if (str1[i-1] = str2[j-1]) {
      DP[i][j] = DP[i-1][j-1];
    } else {
      DP[i][j] = min(DP[i-1][j-1], min(DP[i-1][j], DP[i][j-1])) + 1;
    }
  }
}
cout &lt;&lt; DP[str1.size()][str2.size()];
</pre>

<p>Самый главный минус классической реализации алгоритма Левенштейна - это необходимость создания двумерной матрицы. В первых реализациях собственного антиплагиата если текст участника был слишком большой посылка считалась перманентно не списанной в силу того, что ее нельзя было проверить.</p>
</article>


<!-- Задача 4. Хорошая строка из 0 и 1 -->
<article class="article">
  <div class="anchor" id="p5"></div>
  <h3>Задача 4. Хорошая строка из 0 и 1</h3>

  <p>Дана строка s, сотстоящая из нулей и единиц. И число k. Будем считать строку хорошей если число подряд идущих нулей в строке меньше k. Найти число строк s длины n, которые не содержат k подряд идущих нулей.</p>
  <p>Создадим два вектора B(n) и W(n). B[i] хранит число строк длины i которые заканчиваются на 1. W[i] хранит число строк длины i, которые заканчиваются на 0.</p>
  <p>Базовый случай: B[1] = 1, W[1] = 1</p>
  <p>Если бы не было условия про k подряд идущих нулей, то вектора B и W собирались так: B[i] = B[i-1] + W[i-1], W[i] = B[i-1] + W[i-1]</p>
  <p>Рассмотрим случай, когда k = 2, то есть нельзя допустить строку с двумя нулями подряд. Если мы хотим добавить в конец строки символ 1, то B[i] = B[i - 1] + W[i - 1]. Если мы хотим добавить в конец строки символ 0, то W[i] = B[i-1].</p>
  <p>Рассмотрим случай, когда k = 3, n = 6, то есть нельзя допустить строку с тремя нулями подряд.</p>
  <code>n = 1, B[1] = 1 (1), W[1] = 1 (0)</code>
  <code>n = 2, B[2] = 2 (01,11), W[2] = 2 (00,10)</code>
  <code>n = 3, B[3] = 4 (011,111,001,101), W[3] = 3 (010,110,100)</code>
  <code>n = 4, B[4] = 7 (0111,1111,0011,1011,0101,1101,1001), B[4] = B[3] + W[3], W[4] = 6 (0110,1110,0010,1010,0100,1100), W[4] = B[3] + W[3] - B[1]</code>
  <code>n = 5, B[5] = B[4] + W[4] = 13, W[5] = B[4] + W[4] - B[2]</code>
  <p>Если мы хотим добавить в конец строки символ 1, то B[i] = B[i - 1] + W[i - 1]. Если мы хотим добавить в конец строки символ 0, то W[i] = B[i-1].</p>
  <p>В общем случае, для k нулей, B[i] = B[i-1] + W[i-1], W[i] = B[i-1] + W[i-1] - B[i-k]</p>
</article>


<!-- Задача A. Миллиардная Функция Васи -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Миллиардная Функция Васи</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вася — начинающий математик — решил сделать вклад в развитие этой науки и прославиться на весь мир. Но как это сделать, когда самые интересные факты, типа теоремы Пифагора, давно уже доказаны? Правильно! Придумать что-то свое, оригинальное. Вот юный математик и придумал Теорию Функций Васи, посвященную изучению поведения этих самых функций. Функции Васи (ФВ) устроены довольно просто: значением N-й ФВ в точке S будет количество чисел от 1 до N, имеющих сумму цифр S. Вам, как крутым программистам, Вася поручил найти значения миллиардной ФВ (то есть ФВ с N = 10⁹), так как сам он с такой задачей не справится. А Вам слабо?</p>

  <h4>Входные данные</h4>
  <p>Целое число S (1 ≤ S ≤ 81).</p>

  <h4>Выходные данные</h4>
  <p>Значение миллиардной Функции Васи в точке S.</p>

  <details>
    <summary>Пример</summary>
    <code>1</code>
    <code>10</code>
  </details>
</article>


<!-- Задача B. Счастливые билеты -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Счастливые билеты</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Найти количество счастливых 2N-значных билетов. Напомним, что билет называют счастливым, если сумма его первых N цифр совпадает с суммой последних N цифр.</p>

  <h4>Входные данные</h4>
  <p>В единственной строке содержится число N (1 ≤ N ≤ 300).</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите количество счастливых билетов по модулю 10⁹ + 33.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>1</code>
    <code>10</code>

    <h4>Пример 2</h4>
    <code>2</code>
    <code>670</code>

    <h4>Пример 3</h4>
    <code>3</code>
    <code>55252</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>В задаче могут быть ведущие нули. Сначала найдем сумму цифр.Создадим массив DP, в DP[i][j] будем хранить количество чисел длиной j и с суммой i. В этом массиве будет 10n строк и n+1 столбцов. Реалицация цикл в цикле в цикле. Сложность O(N*10*N*10). Для каждого n-значного числа ответ хранится в последнем столбце.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  long long N;
  cin >> N;

  // решение
  long long mod = 1'000'000'033;
  vector&lt;vector&lt;long long&gt; &gt; DP(10*N, vector&lt;long long&gt;(N + 1));

  // заполним базовый случай, первый столбик
  for (int i = 0; i &lt; 10; i++) {
    DP[i][1] = 1;
  }

  // посчитаем сумму цифр
  for (int h = 2; h &lt;= N; h++) {
    for (int i = 0; i &lt; 10 * N; i++) {
      for (int k = 0; k &lt; 10; k++) {
        if (k + i &lt; DP.size()) {
          DP[k + i][h] = (DP[k + i][h] + DP[i][h - 1]) % mod;
        }
      }
    }
  }

  // теперь посчитаем сколько счастливых чисел
  long long sum = 0;
  for (int i = 0; i &lt; DP.size(); i++) {
    sum += (DP[i][N] * DP[i][N]) % mod;
  }
  sum = sum % mod;

  // вывод результата
  cout &lt;&lt; sum;
}
</pre>
  </details>
</article>


<!-- Задача C. Числа -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Числа</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 4мб</i></div>

  <p>Найдите количество N-значных чисел, цифры которых идут в неубывающем порядке (лидирующие нули допускаются)</p>

  <h4>Входные данные</h4>
  <p>В единственной строке содержится число N(1 ≤ N ≤ 10⁶)</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите ответ – количество требуемых чисел по модулю 10⁹ + 7</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>1</code>
    <code>10</code>

    <h4>Пример 2</h4>
    <code>2</code>
    <code>55</code>

    <h4>Пример 3</h4>
    <code>10</code>
    <code>92378</code>
  </details>
</article>


<!-- Задача D. Счастливые билетики по-ярославски -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Счастливые билетики по-ярославски</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Есть счастливые билетики по–московски, есть счастливые билетики по–питерски, но мало кто слышал про счастливые билетики по–ярославски. В ярославском общественном транспорте номера билетиков состоят из 2N цифр. Билетик называется счастливым, если ярославская сумма первых N цифр равна ярославской сумме последних N цифр. Требуется найти количество счастливых билетиков по–ярославски для заданного N. На первый взгляд, задача простая, но что же такое «ярославская сумма»? Для заданного числа k найдем сумму его цифр, если получившееся число состоит из двух и более цифр, то найдем сумму цифр этого числа и т. д., пока не получим число, состоящее из одной цифры. Такая сумма цифр называется «ярославской суммой цифр». Билетики нумеруются от 00 ... 000 до 99 ... 999.</p>

  <h4>Входные данные</h4>
  <p>D единственной строке записано натуральное число N (1 ≤ N ≤ 1000) – количество цифр на половине билета.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите число — количество счастливых билетиков по модулю 10⁹ + 7 (т.е. остаток от деления количества счастливых билетиков на 10⁹ + 7)</p>

  <details>
    <summary>Пример</summary>
    <code>1</code>
    <code>10</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Для начала решим легкую задачу, подсчитаем число билетов, у которых сумму цифр равна k, а число цифр равно n.</p>

    <h4>Динамика по слоям</h4>
    <p>Заметим, что ответ в ячейке j зависит только от слоя j-1. Поэтому нам не нужно хранить всю матрицу DP, а достаточно только обновлять два последних ее слоя - слой j  и слой j-1. Это сэкономит память.</p>
<pre>
int n;
cin >> n;
long long mod = 1e9 + 7;
vector&lt;long long&gt; A(1e4);
vector&lt;long long&gt; B(1e4);
vector&lt;long long&gt; C(1e4);

// база
A[0] = 1;

for (int h = 1; h &lt;= n; h++) {
  for (int i = 0; i &lt; 9900; i++) {
    for (int j = 0; j &lt;= 9; j++) {
      B[i+j] += A[i];
    }
  }
  for (int i = 0; i &lt; A.size(); i++) {
    A[1] = B[i] % mod;
    B[i] = 0;
  }
}
for (int i = 0; i &lt; 10000; i++) {
  long long cnt = A[i];
  long long z = 0, y = i;

  while (y >= 10) {
    while (y > 0) {
      z += y % 10;
      y /= 10;
    }
    y = z;
    z = 0;
  }

  C[y] = (C[y] + cnt) % mod;
}

long long res = 0;
for (int i = 0; i &lt; 10; i++) {
  res = (res + C[i] * C[i]) % mod;
}

cout &lt;&lt; res;
</pre>
  </details>
</article>


<!-- Задача E. Трискайдекафобия -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Трискайдекафобия</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Общество анонимных трискайдекафобов считает, что лотерейный билет, у которого сумма цифр серийного номера делится на 13, не приносит большие выигрыши, а, наоборот, вводит владельца этого билета в огромные убытки. В связи с этим общество решило скупить все такие билеты и уничтожить их.</p>

  <p>Требуется посчитать, сколько билетов нужно будет купить обществу трискайдекафобов, если известно, что лотерейные билеты имеют серийные номера от 0 до 10ⁿ - 1.</p>

  <h4>Входные данные</h4>
  <p>В единственной строке содержится число N (1 ≤ N ≤ 1000).</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите число плохих лотерейных билетов. Так как ответ может быть слишком большим, найдите его по модулю 1000000123.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>1</code>
    <code>1</code>

    <h4>Пример 2</h4>
    <code>2</code>
    <code>7</code>

    <h4>Пример 3</h4>
    <code>3</code>
    <code>79</code>
  </details>
</article>


<!-- Задача F. Трипростые числа -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Трипростые числа</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Отдых на море – это замечательно! Но вот программисту Паше ужасно скучно лежать на пляже в Турции. Настолько скучно, что Паша решил посчитать количество трехзначных простых чисел. Он так увлекся этим занятием, что начал изучать 3-простые числа. Так Паша называет числа, у которых <strong>любые 3 подряд идущие цифры</strong> образуют трехзначное простое число. Паша уже начал работу над теорией божественного происхождения таких чисел, когда какие-то хулиганы окатили Пашу холодной водой и стали кричать какие-то загадочные слова вроде «Sunstroke!», «Sonnenstich!» и «Colpo di sole!»</p>

  <h4>Входные данные</h4>
  <p>Ввод содержит целое число n (3 ≤ n ≤ 10000).</p>

  <h4>Выходные данные</h4>
  <p>Выведите количество n-значных 3-простых чисел, вычисленное по модулю 10⁹ + 9.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>3</code>
    <code>143</code>

    <h4>Пример 2</h4>
    <code>4</code>
    <code>204</code>

    <h4>Пример 3</h4>
    <code>5</code>
    <code>374</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Будем собирать матрицу DP размером 1000 x n. Например, ячеке на строчке 177 и столбце 5 будет количество 3-простых чисел длиной в 5 цифр, которые заканчиваются на 117.</p>
    <p>Это ответ на первый вопрос ДП - что мы храним? Храним массив в каждой ячейке DP[i][j] количество j-значных чисел, которые оканчиваются на число i.</p>
    <p>Второй вопрос ДП - как считать? Когда переходим в столбец j+1 мы добавляем в конец к нашему числу новую цифру и должны проверить будут ли число из трех последних цифр простым.</p>
    <p>Считаем слева направо, сверху вниз.</p>
    <p>Базой будут все трехзначные числа. Если число простое, то ставим в ячейку 1, если нет - 0.</p>
    <p>Ответ на задачу хранится в последнем столбце.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  int n;
  cin >> n;

  // решение
  long long mod = 1'000'000'009;
  vector&lt;int&gt; G(1000);

  // соберем решето эратосфена для всех 3-значных цифр
  for (int i = 100; i &lt; 1000; i++) {
    int k = 0;
    for (int j = 1; j &lt;= i; j++) {
      if (i % j == 0) {
        k++;
      }
    }
    if (k == 2) {
      G[i] = 1;
    }
  }
  // заполним базовый случай, третий столбик
  vector&lt;vector&lt;long long&gt; &gt; DP(1000, vector&lt;long long&gt;(n + 1));
  for (int i = 0; i &lt; 1000; i++) {
    DP[i][3] = G[i];
  }

  for (int i = 4; i &lt;= n; i++) {
    for (int j = 100; j &lt; 1000; j++) {
      for (int k = 0; k &lt; 10; k++) {
        // три последние цифры нового числа
        int tmp = j % 100 * 10 + k;
        // если это простое число
        if (G[tmp] == 1) {
          DP[tmp][i] = (DP[tmp][i] + DP[j][i - 1]) % mod;
        }
      }
    }
  }

  // собираем результат
  long long res = 0;
  for (int i = 100; i &lt; 1000; i++) {
    res = (res + DP[i][n]) % mod;
  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача G. Необычное развлечение -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Необычное развлечение</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Когда Георгию становится скучно на уроках математики, он развлекает себя следующим образом: берет натуральное число n и получает из него единицу с помощью последовательных делений без остатка. На каждом шагу Георгий делит текущее число на любой его натуральный делитель, отличный от единицы.</p>

  <p>Например, если n = 30, то существует несколько способов получить из него единицу. Например, 30 → 10 → 1 или 30 → 6 → 3 → 1, или 30 → 1. Всего это можно сделать 13 способами.</p>

  <p>Георгий просит вас помочь подсчитать количество способов, которыми он может получить из числа n единицу. Два способа n → x₁ → ... → xₖ → 1 и n → y₁ → ... → yₘ → 1 считаются различными, если k ≠ m или существует i такое, что xᵢ ≠ yᵢ.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано натуральное число n. (1 ≤ n ≤ 2⋅10⁹)</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное число — количество способов получить из числа n единицу по модулю (10⁹ + 7) (т. е. вывести остаток от деления количества способов получить единицу на 10⁹ + 7).</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>1</code>
    <code>1</code>

    <h4>Пример 2</h4>
    <code>9</code>
    <code>2</code>

    <h4>Пример 3</h4>
    <code>30</code>
    <code>13</code>

    <h4>Пример 4</h4>
    <code>4</code>
    <code>2</code>
  </details>
</article>


<!-- Задача H. Рекурсивные палиндромные разбиения -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Рекурсивные палиндромные разбиения</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Разбиением числа N называют набор положительных целых чисел, сумма которых равна N. Примеры разбиений:</p>
  <code>15=1+2+3+4+5=1+2+1+7+1+2+1</code>
  <p>Разбиение называют палиндромным, если оно одинаково читается как слева направо, так и справа налево. На примере сверху первое разбиение не является палиндромным, а второе таковым является. Если палиндромное разбиение содержит m чисел, то его левая и правая половины содержат по [m / 2] чисел (здесь [x] – целая часть числа). Если m нечетно, то одно число остается в центре палиндромного разбиения.</p>

  <p>Разбиение назовем рекурсивно палиндромным, если оно является палиндромным, а его левая половина либо пуста, либо является рекурсивно палиндромной. Так, например, разбиение числа 7=1+5+1 является рекурсивно палиндромным, а разбиение числа 9=1+2+3+2+1 – нет. Заметим, что у каждого числа есть как минимум два рекурсивно палиндромных разбиения – одно будет состоять только из единиц, а второе будет состоять из самого числа.</p>

  <p>Например, у числа 7 есть следующие рекурсивно палиндромные разбиения:</p>
  <code>7,1+5+1,2+3+2,1+1+3+1+1,3+1+3,1+1+1+1+1+1+1</code>

  <p>Напишите программу, которая по заданному числу N найдет количество его рекурсивно палиндромных разбиений.</p>

  <h4>Входные данные</h4>
  <p>В единственной строке содержится число N (1 ≤ N ≤ 10⁶).</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите число – количество рекурсивно палиндромных разбиений числа N. Так как это число может быть очень большим, выведите остаток от деления количества разбиений на 10⁹ + 7.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>7</code>
    <code>6</code>

    <h4>Пример 2</h4>
    <code>20</code>
    <code>60</code>
  </details>
</article>


<!-- Задача I. Стрельба -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача I. Стрельба</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Игорь и Ира решили определить главного в семье, для этого они проведут турнир по стрельбе из лука. Турнир проходит по простым правилам: каждый из участников делает по n выстрелов (сначала все свои выстрелы делает первый участник, потом второй). Мишень — круг, состоящий из k колец, за попадание в каждое из которых начисляется от 1 до k очков. Главным в семье будет тот, кто сможет набрать большее количество очков.</p>

  <p>Игорь уже произвел свои n выстрелов и набрал p очков, теперь очередь Иры. Она уже приноровилась к стрельбе из лука, и теперь всегда попадает в мишень, в отличие от Игоря. При выстреле Ира попадает в каждое кольцо с одинаковой вероятностью.</p>

  <p>Помогите Ире определить количество выигрышных комбинаций из n выстрелов.</p>

  <h4>Входные данные</h4>
  <p>В единственной строке записаны три целых числа n, k, p (1 ≤ n, k ≤ 300, 0 ≤ p ≤ k⋅n) — количество выстрелов, количество колец на мишени и количество очков, набранных Игорем.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите число — количество комбинаций из n выстрелов Иры в мишень, таких, что сумма набранных очков будет больше, чем p.</p>

  <p>Выведите ответ по модулю 1000000007(10⁹ + 7).</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>3 3 7</code>
    <code>4</code>
    <p>В первом тесте существуют следующие комбинации попаданий Ирой в мишень, при которых она набирает очков больше, чем Игорь. [2,3,3] сумма очков: 8; [3,2,3] сумма очков: 8;
    [3,3,2] сумма очков: 8; [3,3,3] сумма очков: 9;</p>

    <h4>Пример 2</h4>
    <code>5 5 6</code>
    <code>3119</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/gym/104454/problem/B" target="_blank">Задача B</a>
      <br><a href="https://codeforces.com/gym/104454" target="_blank">ICPC Central Russia Regional Contest, 2021</a>
    </div>

    <p>Динамический объект. Соберем матрицу DP из n+1 столбцов и n*k + 1 строк. Каждый столбец это количество выстрелов от 0 до n. Каждая строка это набранные очки от 0 (никуда не попала) до n*k (все выстрелы попали в максимальное количество очков).</p>
    <p>Что храним. В ячейке DP[i][j] храним количество способов которыми Ира может получить i очков за j выстрелов. Ставим 0 если невозможно получить i очков за j выстрелов.</p>
    <p>Как считаем ячейку. Надо определить позиции из которых можно придти в ячейку DP[i][j] за один выстрел. Это столбик j-1. Это строки от i-1 до i-k.</p>
    <p>База. Начинаем с DP[0][0]</p>
    <p>Как обходить. Слева направо, сверху вниз.</p>
    <p>Сложность O(n² * k²). Это количество ячеек n*(n*k), чтобы обойти каждую ячейку надо обойти еще k элементов. При наших входных параметрах это O(300⁴). Это плохо. Чтобы улучшить асимптотику, нужно мудро подойти к обходу матрицы. Между ячейками DP[i][j] и DP[i+1][j] огромное количество одинаковых элементов. Чтобы посчитать DP[i+1][j] нужно к результату DP[i][j] прибавить одну ячейку и убрать одну ячейку. Тогда сложность станет O(n*n*k).</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  long long n, k, p;
  cin >> n >> k >> p;

  // решение
  long long mod = 1e9 + 7;
  vector&lt;vector&lt;long long&gt; &gt; DP(n * k + 1, vector&lt;long long&gt;(n + 1));

  // база
  DP[0][0] = 1;

  // обход по столбцам
  // соберем префикс-сумму
  for (int h = 1; h &lt;= n; h++) {
    long long sum = 0;
    for (int i = h; i &lt;= h * k; i++) {
      sum += DP[i - 1][h - 1];
      if (i - k - 1 >= 0) {
        sum -= DP[i - k - 1][h - 1];
      }
      DP[i][h] = sum % mod;
    }
  }

  // соберем позиции в которых Ира выигрывает
  long long res = 0;
  for (int i = p + 1; i &lt;= n * k; i++) {
    res += DP[i][n];
  }

  // вывод результата
  cout &lt;&lt; res % mod;
}
</pre>
  </details>
</article>


<!-- Задача J. Перестановки и инверсии (сложная версия) -->
<article class="article">
  <div class="anchor" id="task10"></div>
  <h3>Задача J. Перестановки и инверсии (сложная версия)</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 128мб</i></div>

  <p>Норман очередной раз проснулся утром в холодном поту. Ему вновь и вновь снился сон про то, как он писал интернет-отбор на ВКОШП (Вселенская Крутая Олимпиада Школьников по Программированию), так и не решив задачу I «Операция «Перестановка»». Отогнав плохие мысли и поев блинчиков и выпив чаю, он отправился на олимпиаду по информатике. «Уж здесь-то я возьму своё!» – думал Норман, открывая список задач. И здесь он увидел задачу под номером 5. Его прошиб холодный пот. Еле сдерживая себя, Норман начал её решать. Решите её и вы.</p>

  <p>Перестановка – последовательность длины n различных целых чисел от 1 до n. Например, (4, 2, 1, 3) – перестановка. Инверсией перестановки p называется пара индексов (i, j), что i &lt; j и p[i] > p[j]. Например, (1, 2) – инверсия перестановки (4, 2, 1, 3), так как 1 &lt; 2, 4 > 2. Задана пара чисел n и t. Всё, что требуется – найти количество перестановок длины n, имеющих ровно t инверсий.</p>

  <h4>Входные данные</h4>
  <p>В единственной строке содержится пара целых чисел n и t (1 ≤ n ≤ 400, 1 ≤ t ≤ 100000)</p>

  <h4>Выходные данные</h4>
  <p>В первой строке выведите количество перестановок длины n, имеющих ровно t инверсий. Ответ следует выводить по модулю 10⁹ + 7.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>3 0</code>
    <code>1</code>

    <h4>Пример 2</h4>
    <code>3 1</code>
    <code>2</code>
  </details>
</article>


<!-- K. Легионы Цезаря -->
<article class="article">
  <div class="anchor" id="task11"></div>
  <h3>Задача K. Легионы Цезаря</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Знаменитый полководец Гай Юлий Цезарь любил выстраивать воинов своей армии в шеренгу. Всего в армии было n₁ пехотинцев и n₂ всадников. Цезарь считал, что расстановка не красивая, если где-то в строю стоит подряд строго больше k₁ пехотинцев или строго больше k₂ всадников. Найдите количество красивых расстановок воинов.</p>

  <p>Учтите, что в каждой расстановке должны присутствовать все n₁ + n₂ воинов. Все пехотинцы считаются неразличимыми между собой. Аналогично, все всадники считаются неразличимыми между собой.</p>

  <h4>Входные данные</h4>
  <p>В единственной строке через пробел записаны четыре целых числа n₁, n₂, k₁, k₂ (1 ≤ n₁, n₂ ≤ 100, 1 ≤ k₁, k₂ ≤ 10) — количество пехотинцев и всадников в армии, а также наибольшее допустимое количество стоящих подряд пехотинцев и всадников, соответственно.</p>

  <h4>Выходные данные</h4>
  <p>Выведите количество красивых расстановок войск по модулю 100000000 (10⁸), то есть количество таких расстановок, где подряд стоит не более k₁ пехотинцев и не более k₂ всадников.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>2 1 1 10</code>
    <code>1</code>

    <h4>Пример 2</h4>
    <code>2 3 1 2</code>
    <code>5</code>

    <h4>Пример 3</h4>
    <code>2 4 1 1</code>
    <code>0</code>
    <p>Обозначим пехотинца как 1, а всадника как 2.</p>
    <p>В первом примере единственное красивое построение: 121</p>
    <p>Во втором примере существует 5 красивых построений: 12122, 12212, 21212, 21221, 22121</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/118/problem/D" target="_blank">Задача D</a>
      <br><a href="https://codeforces.com/contest/118" target="_blank">Codeforces Beta Round 89 (Div. 2)</a>
    </div>

  </details>
</article>


<!-- L. Булочки -->
<article class="article">
  <div class="anchor" id="task12"></div>
  <h3>Задача L. Булочки</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Пекарь Лаврентий собирается испечь несколько булочек с начинкой на продажу.</p>

  <p>У Лаврентия есть n грамм теста, а так же m различных видов начинки. Виды начинки пронумерованы натуральными числами от 1 до m. Лаврентий знает, что i-го вида начинки у него осталось aᵢ грамм. Чтобы испечь одну булочку с i-ой начинкой, нужно ровно bᵢ грамм этой начинки и cᵢ грамм теста, а продать одну такую булочку можно за dᵢ тугриков.</p>

  <p>Кроме того, он может испечь булочки без начинки. На каждую такую булочку нужно c₀ грамм теста, а продать такую булочку можно за d₀ тугриков. Лаврентий может испечь любое количество булочек с различными начинками или без начинки, если для этого хватит теста и начинки. Все излишки, которые остались после выпечки, Лаврентий выкидывает.</p>

  <p>Определите какое максимальное количество тугриков Лаврентий может заработать.</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержатся 4 целых числа n, m, c₀ и d₀ (1 ≤ n ≤ 1000, 1 ≤ m ≤ 10, 1 ≤ c₀, d₀ ≤ 100). В каждой из последующих m строк содержится по 4 целых числа. В i-ой из них находятся числа aᵢ, bᵢ, cᵢ и dᵢ (1 ≤ aᵢ, bᵢ, cᵢ, dᵢ ≤ 100).</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное число — максимальное количество тугриков, которые Лаврентий может заработать.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
10 2 2 1
7 3 2 100
12 3 1 10
</pre>
    <code>241</code>

    <h4>Пример 2</h4>
<pre>
100 1 25 50
15 5 20 10
</pre>
    <code>200</code>
    <p>Чтобы получить наибольшее количество тугриков в первом примере, нужно испечь 2 булочки с начинкой 1, 4 булочки с начинкой 2 и одну булочку без начинки.</p>

    <p>Во втором примере имеет смысл испечь только 4 булочки без начинки.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/106/problem/C" target="_blank">Задача C</a>
      <br><a href="https://codeforces.com/contest/106" target="_blank">Codeforces Beta Round 82 (Div. 2)</a>
    </div>

  </details>

</article>


<!-- M. Наименее круглый путь -->
<article class="article">
  <div class="anchor" id="task13"></div>
  <h3>Задача M. Наименее круглый путь</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Задана квадратная матрица n x n, состоящая из неотрицательных целых чисел. Вам надо найти такой путь на ней, который</p>
  <ol>
    <li>начинается в левой верхней ячейке матрицы;</li>
    <li>каждой следующей ячейкой имеет правую или нижнюю от текущей;</li>
    <li>заканчивается в правой нижней клетке.</li>
  </ol>

  <p>Кроме того, если перемножить все числа вдоль пути и посмотреть на получившиеся произведение, то это число должно быть как можно менее «круглым». Иными словами оно должно заканчиваться на наименьшее возможное количество нулей.</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержится целое число n (2 ≤ n ≤ 1000), n — размер заданной матрицы. Далее в n строках содержатся элементы матрицы (целые неотрицательные числа, не превосходящие 10⁹).</p>

  <h4>Выходные данные</h4>
  <p>В первую строку выведите искомое наименьшее количество концевых нулей в произведении чисел вдоль пути. Во вторую выведите сам путь.</p>

  <details>
    <summary>Пример</summary>
<pre>
3
1 2 3
4 5 6
7 8 9
</pre>
<pre>
0
DDRR
</pre>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/2/problem/B" target="_blank">Задача B</a>
      <br><a href="https://codeforces.com/contest/2" target="_blank">Codeforces Beta Round 2</a>
    </div>

  </details>

</article>


<!-- N. Считаем прямоугольники -->
<article class="article">
  <div class="anchor" id="task14"></div>
  <h3>Задача N. Считаем прямоугольники</h3>

  <div><i>Ограничение по времени 6с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У вас есть n прямоугольников, i-й из них имеет высоту hᵢ и ширину wᵢ.</p>

  <p>Вам надо ответить на q запросов, которые задаются четырьмя числами: h<sub>s</sub> w<sub>s</sub> h<sub>b</sub> w<sub>b</sub>.</p>

  <p>Для каждого запроса выведите суммарную площадь всех таких прямоугольников, которые могут вместить в себя прямоугольник с высотой h<sub>s</sub> и шириной w<sub>s</sub> и при этом сами вмещаются в прямоугольник с высотой h<sub>b</sub> и шириной w<sub>b</sub>. Иными словами, выведите ∑hᵢ⋅wᵢ по всем i, что h<sub>s</sub> &lt; hᵢ &lt; h<sub>b</sub> и w<sub>s</sub> &lt; wᵢ &lt; w<sub>b</sub>.</p>

  <p>Обратите внимание, что если у прямоугольников одинаковая ширина или высота, то ни один из них не может вместить в себя другой. Также обратите внимание, что вы не можете вращать прямоугольники.</p>

  <p>Обратите внимание, что для некоторых наборов входных данных ответ не будет помещаться в 32-х битных целочисленный тип, вы должны использовать 64-битный целочисленный тип вашего языка (например, long long в C++).</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных записано целое число t (1 ≤ t ≤ 100) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит два целых числа n, q (1 ≤ n ≤ 10⁵; 1 ≤ q ≤ 10⁵) — количество прямоугольников и количество запросов.</p>

  <p>Затем следуют n строк, каждая содержит два целых числа hᵢ, wᵢ (1 ≤ hᵢ, wᵢ ≤ 1000) — высоту и ширину i-го прямоугольника.</p>

  <p>Затем в q строках заданы запросы, каждая строка содержит четыре целых числа h<sub>s</sub>, w<sub>s</sub>, h<sub>b</sub>, w<sub>b</sub> (1 ≤ h<sub>s</sub> &lt; h<sub>b</sub>, w<sub>s</sub> &lt; w<sub>b</sub> ≤ 1000) — описание запроса.</p>

  <p>Сумма значений q по всем набора входных данных не превосходит 10⁵. Сумма значений n по всем наборам входных данных не превосходит 10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите q строк, i-я должна содержать ответ на i-й запрос.</p>

  <details>
    <summary>Пример</summary>
<pre>
3
2 1
2 3
3 2
1 1 3 4
5 5
1 1
2 2
3 3
4 4
5 5
3 3 6 6
2 1 4 5
1 1 2 10
1 1 100 100
1 1 3 3
3 1
999 999
999 999
999 998
1 1 1000 1000
</pre>
<pre>
6
41
9
0
54
4
2993004
</pre>
    <p>В первом наборе входных данных только один запрос. Нам надо найти сумму площадей всех прямоугольников, которые вмещают прямоугольник 1x1 и сами вмещаются в прямоугольник 3x4.</p>

    <p>Нам подходит только прямоугольник 2x3, так как 1 &lt; 2 (сравниваем высоты) и 1 &lt; 3 (сравниваем ширины), то 1x1 помещается в него. Аналогично, 2 &lt; 3 (сравниваем высоты) и 3 &lt; 4 (сравниваем ширины), то есть он помещается в 3x4.</p>

    <p>Прямоугольник 3x2 слишком высок, чтобы поместиться в 3x4 rectangle.</p>

    <p>Суммарная площадь в ответа равна 2⋅3 = 6.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1722/problem/E" target="_blank">Задача 1722E</a>
      <br><a href="https://codeforces.com/contest/1722" target="_blank">Codeforces Round 817 (Div. 4)</a>
    </div>

  </details>

</article>


<!-- O. Пирамида из банок -->
<article class="article">
  <div class="anchor" id="task15"></div>
  <h3>Задача O. Пирамида из банок</h3>

  <div><i>Ограничение по времени 2.5с
  <br>Ограничение по памяти 256мб</i></div>

  <p>На ярмарке есть огромная пирамида из консервных банок с 2023 рядами, пронумерованными в стандартном порядке, как показано на рисунке.</p>

  <p>Если вначале попасть в банку с номером 9², то упадут все банки, покрашенные в красный цвет на рисунке выше.</p>

  <p>Вы бросаете мяч в пирамиду, и он попадает в одну банку с номером n². Это приводит к тому, что все банки, которые находятся над этой банкой, падают (то есть банка n² падает, затем падают банки, непосредственно находящиеся над n², затем банки, непосредственно находящиеся над этими банками, и так далее). Например, на рисунке выше показаны банки, которые упадут, если попасть в банку 9².</p>

  <p>Какова сумма номеров всех банок, которые упадут? Напомним, что n² = nxn.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 1000) — количество наборов входных данных.</p>

  <p>Единственная строка каждого набора входных данных содержит одно целое число n (1 ≤ n ≤ 10⁶) — это означает, что банка, в которую вы попали, имеет номер n².</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно целое число — сумму номеров всех банок, которые упадут.</p>

  <details>
    <summary>Пример</summary>
<pre>
10
9
1
2
3
4
5
6
10
1434
1000000
</pre>
<pre>
156
1
5
10
21
39
46
146
63145186
58116199242129511
</pre>
    <p>Первый набор входных данных изображен в условии. Сумма номеров, которые упадут, равна</p>
    <code>1²+2²+3²+5²+6²+9²=1+4+9+25+36+81=156.</code>

    <p>Во втором наборе входных данных упадет только банка с номером 1², поэтому ответ равен</p>
    <code>1²=1.</code>

    <p>В третьем наборе входных данных упадут банки с номерами 1² и 2², поэтому ответ равен</p>
    <code>1²+2²=1+4=5.</code>

    <p>В четвертом наборе входных данных упадут банки с номерами 1² и 3², поэтому ответ равен</p>
    <code>1²+3²=1+9=10.</code>

    <p>В пятом наборе входных данных упадут банки с номерами 1², 2² и 4², поэтому ответ равен</p>
    <code>1²+2²+4²=1+4+16=21.</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1829/problem/G" target="_blank">Задача 1829G</a>
      <br><a href="https://codeforces.com/contest/1829" target="_blank">Codeforces Round 871 (Div. 4)</a>
    </div>

  </details>

</article>

