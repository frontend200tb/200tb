<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contests" target="_blank">Codeforces ЯрГУ. Школьники</a></p>
  <p><a href="https://vk.com/sportprog_yarsu" target="_blank">vk.com/sportprog_yarsu</a></p>
  <p><a href="https://vkvideo.ru/@sportprog_yarsu" target="_blank">vkvideo.ru/@sportprog_yarsu</a></p>
</article>


<article class="article">
  <h1>Занятие 18 Базовые алгоритмы #6. Битовые операции</h1>
  <p>Конспект видео от 2025.01.25</p>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contest/583445" target="_blank">Codeforces Контест 583445</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
        <a href="#p1">Двоичные числа</a>
    <br><a href="#p2">Битовые операции</a>
    <br><a href="#p3">Битовые маски</a>
  </p>
  <p>
        <a href="#task1">Задача A. 2 в степени n</a>
    <br><a href="#task2">Задача B. Установить значение бита в 0</a>
    <br><a href="#task3">Задача C. Определить значение бита</a>
    <br><a href="#task4">Задача D. Инвертировать бит</a>
    <br><a href="#task5">Задача E. Вывести значение байта побитно</a>
    <br><a href="#task6">Задача F. XORиначчи</a>
    <br><a href="#task7">Задача G. Маленький xor</a>
    <br><a href="#task8">Задача H. Максимизируй AND</a>
    <br><a href="#task9">Задача I. Чашечные весы</a>
    <br><a href="#task10">Задача J. Комната отдыха</a>
    <br><a href="#task11">Задача K. Ваня и надпись</a>
    <br><a href="#task12">Задача L. Дима и плохой XOR</a>
    <br><a href="#task13">Задача M. Максимум и биты</a>
    <br><a href="#task14">Задача N. Биты</a>
    <br><a href="#task15">Задача O. Xor-подпоследовательность (простая версия)</a>
    <br><a href="#task16">Задача P. Составление тестов</a>
    <br><a href="#task17">Задача Q. Ксорить или не ксорить</a>
    <br><a href="#task18">Задача R. Максимальное И</a>
    <br><a href="#task19">Задача S. Крош и задача на битовые операции</a>
    <br><a href="#task20">Задача T. Даша и кошмары</a>
  </p>
</article>


<!-- Двоичные числа -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Двоичные числа</h3>

  <p>Любое число можно представить в двоичном виде.</p>
  <code>11<sub>10</sub> = 1011<sub>2</sub></code>
  <code>11 = 1*2³ + 0*2² + 1*2¹ + 1*2⁰</code>
  <code>a = bₙ*2ⁿ + ... + b₁*2¹ + b₀*2⁰</code>
  <p>Для числа int число двоичных разрядов 32. Для числа long long число двоичных разрядов 64.</p>
  <p>Чтобы перевести число  в двоичную запись</p>
  <code>a -> bₙ...b₂b₁b₀</code>
  <p>нужен vector&lt;int&gt; A, который собирается следующим образом</p>
<pre>
int n;
cin >> n;
int tmp = n;
vector&lt;int&gt; A;
while (tmp > 0) {
  A[i] = tmp % 2;
  tmp /= 2;
  i++;
}
</pre>

  <p>В общем виде перевести число из 10-чной системы в двоичную можно по формуле N = k*2 + b, где b это остаток</p>
<pre>
11 = 5*2 + 1
5  = 2*2 + 1
2  = 1*2 + 0
1  = 0*2 + 1
</pre>
  <p>Собрав все остатки получим 1101 число в двоичной системе</p>
  <p>Так же можно собрать число в троичной системе или любой другой N = k*3 + b</p>
</article>


<!-- Битовые операции -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>Битовые операции</h3>

  <p>Рассмотрим битовые операции на примере двух чисел a = 3, b = 5</p>
  <code>a = 3 = ... 0 0 1 1</code>
  <code>b = 5 = ... 0 1 0 1</code>

  <p>Операция & (битовое И). Возвращает 1 если оба бита равны 1, возвращает 0 в других случаях.</p>
  <code>a & b = ... 0 0 0 1 = 1</code>

  <p>Операция | (битовое ИЛИ). Возвращает 0 если оба бита равны 0, возвращает 1 в других случаях.</p>
  <code>a | b = ... 0 1 1 1 = 7</code>

  <p>Операция ^ (XOR, исключающее ИЛИ). Возвращает 1 если биты различны, возвращает 0 если одинаковые.</p>
  <code>a ^ b = ... 0 1 1 0 = 6</code>

  <p>Операция ~ (порязрядная инверсия). Возвращает 1 если бит равен 0, возвращает 0 если бит равен 1.</p>
<pre>
a = 3 = ... 0 0 0 1 1
~ a   = ... 1 1 1 0 0 = -4
</pre>

<pre>
b = 5 = ... 0 0 1 0 1
~ b   = ... 1 1 0 0 1 = -7
</pre>

<pre>
c = 9 = ... 0 1 0 0 1
~ c   = ... 1 0 1 1 0 = -10
</pre>

  <p>Числа со знаком, имеющие в старшем разряде 1, считаются отрицательными</p>

  <p>Рассмотрим операцию &lt;&lt; (порязрядный сдвиг влево). Освободившиеся разряды справа заполняются нулями.</p>
  <code>a &lt;&lt; k это то же самое что a*2ᵏ</code>
<pre>
a = 3   = ... 0 0 0 1 1

a &lt;&lt; 2  = ... 0 1 1 0 0 = 12
</pre>
  <p>Рассмотрим операцию &gt;&gt; (порязрядный сдвиг вправо). Освободившиеся разряды слева заполняются нулями.</p>
  <code>a &gt;&gt; k это a / 2ᵏ</code>
<pre>
b = 5   = ... 0 0 1 0 1

b &gt;&gt; 2  = ...0 0 0 0 1 = 1
</pre>

  <p>Операции сдвиг влево и вправо работают быстрее чем равные им умножение и деление. Например, нахождение середины в двоичном поиске</p>
  <code>mid = (left + right) / 2;</code>
  <code>mid = (left + right) >> 1;</code>

  <h4>Задача на операцию XOR</h4>
  <p>Есть последовательность, состоящая из n чисел, причем n это нечетное число. Все числа в последовательности содержатся 2 раза, кроме одного. Найти число, которое встречается толко один раз</p>
  <p>Решение. Если есть число A, то верно A XOR A = 0, поскольку соответствующие биты двух одинаковых чисел будут одинаковые. Выполним XOR на всех числах последовательности, в результате все парные числа дадут 0 и в ответе останется искомое число</p>
<pre>
int res = 0;
int a;
for (int i = 0; i &lt; n; i++) {
  cin >> a;
  res = res ^ a;
}
cout &lt;&lt; res;
</pre>

  <h4>Задача на двоичный сдвиг вправо</h4>
  <p>Есть целое число A. Необходимо найти остаток от деления числа A на число B, причем B = 2<sup>k</sup>.</p>
  <p>Пример. k = 5. Если представить A и B в двоичном виде, то A % B это пять последних цифр числа A</p>
  <code>A = 001011010111</code>
  <code>B = 000000100000</code>
  <code>A % B = 000000010111</code>
  <p>Теперь нам нужно достать 5 последних бит числа A. Пусть C = B - 1</p>
  <code>C = 000000011111</code>
  <p>Тогда A % B = A & C</p>
  <code>A & C = 000000010111</code>

</article>


<!-- Битовые маски -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>Битовые маски</h3>

  <p>Пусть есть n чисел (n ≤ 20) и нужно поделить их на две группы. Есть два способа. Первый способ рекурсия. Второй способ бит-маски. Переберем все числа от 0 до 2ⁿ - 1.</p>
<pre>
for (int i = 0; i &lt; (1 &lt;&lt; n); i++) {
  int mask = i;
  for (int j = 0; j &lt; n; j++) {
    Mask[i] = mask % 2;
    mask /= 2; // mask = mask >> 1
  }
}
</pre>
  <p>Этот алгоритм хорош при небольших n. При n = 20.</p>
  <code>2ⁿ = 2²⁰ ≈ 10⁶</code>
  <code>20 * 10⁶ = 2 * 10⁷</code>
</article>


<!-- Задача A. 2 в степени n -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. 2 в степени n</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Напишите программу, вычисляющую заданную степень числа 2, используя битовые операции.</p>

  <h4>Входные данные</h4>
  <p>Дано число n &lt; 64.</p>

  <h4>Выходные данные</h4>
  <p>Выведите число 2ⁿ, то есть число, у которого n-й бит равен 1, а остальные — нули.</p>

  <details>
    <summary>Пример</summary>
    <code>2</code>
    <code>4</code>
  </details>

  <details>
    <summary>Решение</summary>
    <h4>Пример 2</h4>
    <code>0</code>
    <code>1</code>

    <h4>Пример 3</h4>
    <code>10</code>
    <code>1024</code>
    <p>Вводится целое число от 0 до 63. Поскольку число может быть очень большое то будем работать с типом данных unsigned long long</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;

  // решение
  unsigned long long num = 1;
  unsigned long long res = 0;
  res = num &lt;&lt; n;

  // вывод результата
  cout &lt;&lt; res;

  return 0;
}
</pre>
  </details>
</article>


<!-- Задача B. Установить значение бита в 0 -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Установить значение бита в 0</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Напишите программу, устанавливающую значение определенного бита числа в 0.</p>

  <h4>Входные данные</h4>
  <p>Дано целое число A и натуральное число i.</p>

  <h4>Выходные данные</h4>
  <p>Выведите число, которое получается из числа A установкой значения i-го бита = 0.</p>

  <details>
    <summary>Пример</summary>
    <code>5 2</code>
    <code>1</code>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int a; // число
  int i; // номер бита
  cin >> a >> i;

  // решение
  int mask = 1 &lt;&lt; i;
  int res = a & (~mask);

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача C. Определить значение бита -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Определить значение бита</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Напишите программу, определяющую значение i-го бита числа.</p>

  <h4>Входные данные</h4>
  <p>Дано целое число A и целое неотрицательное число i.</p>

  <h4>Выходные данные</h4>
  <p>Выведите значение i-го бита числа A, то есть 0 или 1.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>5 1</code>
    <code>0</code>

    <h4>Пример 2</h4>
    <code>5 2</code>
    <code>1</code>
  </details>

  <details>
    <summary>Решение. Первый способ</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  long long A, i;
  cin >> A >> i;

  // решение
  vector&lt;int&gt; Bit(64);
  for (int j = 0; j &lt; 64; j++) {
    Bit[j] = A % 2;
    A /= 2;
  }

  // вывод результата
  cout &lt;&lt; Bit[i];
}
</pre>
  </details>

  <details>
    <summary>Решение. Второй способ</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {

  // ввод данных
  long long A, i;
  cin >> A >> i;

  // решение и вывод результата
  long long res = 1 &lt;&lt; i;
  if ( (A & res) != 0) {
    cout &lt;&lt; 1;
  } else {
    cout &lt;&lt; 0;
  }
}
</pre>
  </details>
</article>


<!-- Задача D. Инвертировать бит -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Инвертировать бит</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Напишите программу, которая инвертирует определенный бит в заданном числе (биты при этом нумеруются с 0, начиная с младших).</p>

  <h4>Входные данные</h4>
  <p>На вход приходит заданное число A и номер бита i.</p>

  <h4>Выходные данные</h4>
  <p>Выведите число, которое получается из числа A инвертированием i-го бита.</p>

  <details>
    <summary>Пример</summary>
    <code>5 2</code>
    <code>1</code>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;

using namespace std;

int main() {
  // ввод данных
  int a; // число
  int b; // номер бита
  cin >> a >> b;

  // решение
  int res = 0;
  int tmp = a;
  int i = 0;
  vector&lt;int&gt; A(32);

  // собираем двоичное число
  while (tmp > 0) {
    A[i] = tmp % 2;
    tmp /= 2;
    i++;
  }

  // инвертируем бит b
  A[b] = !A[b];

  // собираем двоичное число
  for (int i = 0; i &lt; A.size(); i++) {
    res += A[i] * pow(2, i);
  }

  // вывод результата
  cout &lt;&lt; res &lt;&lt; '\n';
}
</pre>
  </details>
</article>


<!-- Задача E. Вывести значение байта побитно -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Вывести значение байта побитно</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Напишите программу, выводящую все биты 8-битного числа</p>

  <h4>Входные данные</h4>
  <p>Дано число A (0 ≤ A ≤ 255).</p>

  <h4>Выходные данные</h4>
  <p>Выведите число A в битовой форме: 8 бит, старшие биты слева, младшие — справа</p>

  <details>
    <summary>Пример</summary>
    <code>1</code>
    <code>00000001</code>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;stack&gt;

using namespace std;

int main() {
  // ввод данных
  int a; // число от 0 до 255
  cin >> a;

  // решение
  // необходимо вывести значение байта побитно
  stack&lt;int&gt; byte;

  // разложим число на биты
  for (int i = 0; i &lt; 8; i++) {
    byte.push(a % 2);
    a /= 2;
  }

  // вывод результата
  for (int i = 0; i &lt; 8; i++) {
    cout &lt;&lt; byte.top();
    byte.pop();
  }
}
</pre>
  </details>
</article>


<!-- Задача F. XORиначчи -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. XORиначчи</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Дженгиз недавно узнал, что такое числа Фибоначчи, и сейчас он занимается изучением алгоритмов для их поиска. Вскоре ему стало скучно читать про них, и он придумал новый тип чисел, который он назвал числами XORиначчи. Он определил их следующим образом:</p>
  <ul>
    <li>f(0) = a;</li>
    <li>f(1) = b;</li>
    <li>f(n) = f(n-1) xor f(n-2) при n > 1, где xor обозначает операцию побитового исключающего ИЛИ.</li>
  </ul>

  <p>Вам даны три целых числа a, b и n, найдите f(n).</p>

  <p>Вам нужно решить T независимых тестовых примеров.</p>

  <h4>Входные данные</h4>
  <p>Ввод состоит из нескольких тестовых примеров.</p>
  <p>Первая строка ввода содержит целое число T (1 ≤ T ≤ 10³), количество тестовых примеров.</p>
  <p>Каждая из следующих T строк содержит три целых числа, разделенных пробелами: a, b и n (0 ≤ a, b, n ≤ 10⁹) соответственно.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого теста выведите f(n).</p>

  <details>
    <summary>Пример</summary>
<pre>
3
3 4 2
4 5 0
325 265 1231232
</pre>
<pre>
7
4
76
</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Посчитаем XORиначчи для f(0) = 3 и f(1) = 4</p>
    <code>f(2) = 011 ^ 100 = 111 = 7</code>
    <code>f(3) = 100 ^ 111 = 011 = 3</code>
    <code>f(4) = 111 ^ 011 = 100 = 4</code>
    <p>Пришли к тому что было в самом начале. Видим закономерность, что числа повторяются бесконечно. Повторяются первые три элемента f(0), f(1), f(2).</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int a; // первое число
    int b; // второе число
    int n; // номер числа, которое нужно найти
    cin >> a >> b >> n;

    // решение
    int c = a ^ b; // третье число

    // периодическия последовательность
    // a, b, c, a, b, c ...

    if (n % 3 == 0) {
      cout &lt;&lt; a &lt;&lt; '\n';
    } else if (n % 3 == 1) {
      cout &lt;&lt; b &lt;&lt; '\n';
    } else if (n % 3 == 2) {
      cout &lt;&lt; c &lt;&lt; '\n';
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача G. Маленький xor -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Маленький xor</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Маленький Петя очень любит массивы, состоящие из целых неотрицательных чисел. Недавно мама подарила ему один такой массив, состоящий из n элементов. Петя сразу решил найти в нем отрезок из подряд идущих элементов, такой что xor всех чисел из этого отрезка максимален. Помогите ему в этом.</p>

  <p>Под операцией xor подразумевается побитовое исключающее «ИЛИ», которое обозначается как «xor» в языке Pascal и «^» в C/C++/Java.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое число n (1 ≤ n ≤ 100) — количество элементов в массиве. Во второй строке записаны сами числа из массива, через пробел. Все числа целые, неотрицательные и строго меньше 2³⁰.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное целое число — искомый максимальный xor отрезка последовательных элементов.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
5
1 2 1 1 2
</pre>
    <code>3</code>

    <h4>Пример 2</h4>
<pre>
3
1 2 7
</pre>
    <code>7</code>

    <h4>Пример 3</h4>
<pre>
4
4 2 4 8
</pre>
    <code>14</code>
    <p>В первом примере одним из оптимальных отрезков является отрезок, состоящий из первого и второго элемента массива, если считать что элементы массива нумеруются начиная с единицы.</p>

    <p>Во втором примере оптимальный отрезок всего один, в нем содержится ровно один элемента массива (элемент номер три).</p>
  </details>
</article>


<!-- Задача H. Максимизируй AND -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Максимизируй AND</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Мальчик Петя недавно узнал в школе о новой для него операции & — операции побитового «И». Для того, чтобы понять, как устроена эта операция, рассмотрим пример. Например, мы хотим вычислить значение 14 & 10. Для этого запишем числа 14 и 11 в двоичной системе счисления: 12₁₀ = 1100₂, а 9₁₀ = 1001₂. Теперь для того, чтобы вычислить значение 12 & 9, нужно для каждой пары соответствующих битов вычислить их &: 1 & 1=1, 1 & 0=0, 0 & 0=0, 0 & 1=0. Таким образом, мы получаем ответ: 1000₂ = 8₁₀.</p>

  <p>Также Пете на день рождения, который был совсем недавно, подарили последовательность, состоящую из n целых чисел a₁, a₂, ... , aₙ. Пете хочется найти подотрезок этой последовательности с максимальной &-суммой.</p>

  <p>Подотрезком последовательности называется набор чисел a<sub>l</sub>, a<sub>l+1</sub>, ... ,a<sub>r</sub> для некоторых l и r, таких что 1 ≤ l ≤ r ≤ n.</p>

  <p>&-суммой подотрезка a<sub>l</sub>, a<sub>l+1</sub>, ... ,a<sub>r</sub> называется величина равная a<sub>l</sub> & a<sub>l+1</sub> & … & a<sub>r</sub>.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число n (1 ≤ n ≤ 10⁵).</p>

  <p>Вторая строка содержит n целых чисел a₁, a₂, ... , aₙ (1 ≤ ai ≤ 10⁹) — элементы последовательности a.</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно целое число — величину максимальной &-суммы среди всех подотрезков последовательности a.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
1
5
</pre>
    <code>5</code>

    <h4>Пример 2</h4>
<pre>
2
1000 7
</pre>
    <code>1000</code>
    <p>Последовательность из первого примера имеет только один подотрезок, который состоит ровно из одного элемента.</p>

    <p>Последовательность из второго примера имеет три подотрезка: [1000], [7] и [1000,7]. Значения &-сумм этих подотрезков равны 1000, 7 и 0, соответственно.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/gym/103720/problem/E" target="_blank">Задача E</a>
      <br><a href="https://codeforces.com/gym/103720/" target="_blank">VII Липецкая командная олимпиада школьников по программированию. Финал. 3-7 классы</a>
    </div>

  </details>

</article>


<!-- Задача I. Чашечные весы -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача I. Чашечные весы</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Алёша нашел на чердаке старинные чашечные весы и N
  красивых кованых гирь. Эти гири были разного веса, поэтому если их распределить между левой и правой чашами произвольным образом, то возникнет риск, что одна из сторон «перетянет» и весы опрокинутся. Алёша хочет определить оптимальное распределение гирь между левой и правой чашами весов. Также Алёша хочет использовать все гири. Помогите ему найти это оптимальное распределение гирь!</p>

  <h4>Входные данные</h4>
  <p>Сначала вводится число N (натуральное, не превышает 12), затем вводятся N чисел (натуральные, не превышают 1000) — веса гирь.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное число — наименьшую возможную разницу в суммарном весе гирь на левой и правой чашах весов. На каждой стороне может стоять любое количество гирь.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
3
1 2 3
</pre>
    <code>0</code>

    <h4>Пример 1</h4>
<pre>
5
1 2 3 3 10
</pre>
    <code>1</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Это задача на полный перебор. Нужно перебрать все возможные комбинации распределения весов на разные гири. Сложность O(2ⁿ). Чтобы решение зашло за 1 секунду, должно быть n ≤ 20.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  int n;
  cin >> n;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  vector&lt;int&gt; Mask(n);
  long long res = 1e9; // разница веса на весах
  long long sum_left, sum_right;

  // переберем все возможные варианты
  // распределения гирь от 0 до 2 в степени n
  for (int i = 0; i &lt; (1 &lt;&lt; n); i++) {
    int mask = i;

    // для каждого варианта заполним вектор масок
    // в маске 0 означает что гирька идет в левую кучку
    // 1 означает что гирька идет в правую кучку
    for (int j = 0; j &lt; n; j++) {
      Mask[j] = mask % 2; // mask & 1
      mask /= 2; // mask >> 1
    }

    sum_left = 0; // начальный вес левой кучки
    sum_right = 0; // начальный вес правой кучки

    // соберем суммы весов гирек
    // в левой и правой кучке
    for (int j = 0; j &lt; n; j++) {
      if (Mask[j] == 0) {
        sum_left += A[j];
      } else {
        sum_right += A[j];
      }
    }

    // обновляем результат
    // наша цель - собрать кучки с минимальной разницей
    if (abs(sum_left - sum_right) &lt; res) {
      res = abs(sum_left - sum_right);
    }
  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача J. Комната отдыха -->
<article class="article">
  <div class="anchor" id="task10"></div>
  <h3>Задача J. Комната отдыха</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>- О! Я не показал еще тебе комнату отдыха! Идем! - Саймон устремился вниз по лестнице, а Крис проследовал за ним. Ему уже порядком надоела эта "экскурсия", но, как ему казалось, они обошли уже практически все здание.</p>
  <p>В комнате корел неяркий свет, стены были задрапированы каким-то темным материалом. Крис остановился на пороге, но Саймон подтолкнул его, и он сделал пару шагов. Двер за ним закрылась. Несколько минут он стоял, не двигаясь. Наконец, глаза его привыкли к полумраку, и он повернулся к двери.</p>
  <p>- Мы уже пробовали открыть, и не только эту. Думаю, вполне очевидно, что пока мы не имели успеха в этом предприятии, - к Крису подошли двое, - Я - Боб, а это - Макс.</p>
  <p>- Мы тут уже третью неделю "гостим", - усмехнулся Макс, - Кормят, поят, работать предлагают, хотя не заставляют. Вот только выйти нельзя. Даже с этажа.</p>
  <p>Боб и Макс рассказали Крису, что двери комнат на этаже открываются не только личными электронными ключами сотрудников, но и "гостевыми" карточками. Карточки устроены довольно просто: на пластиковую основу нанесены контактные дорожки. Всего таких дорожек может быть 30, но не на всех присутствует напыление: кое-где есть просто очерченный прямоугольник. Когда очередная карточка попадала в руки Бобу или Максу "ввиду производственной необходимости", они запоминали ее "схему" и то, какую дверь она открывала, а потом записывали это.</p>
  <p>Выслушав их, Крис предположил, что чем ближе друг к другу расположены двери, тем меньше должно быть отличий между ключами. Однако это предположение нужно проверить. Для начала среди имеющихся у Боба и Макса схем необходимо отыскать две самые "похожые" карточки.</p>
  <p>Несколько более формально: каждую схему карточки рассмотрим как натуральное число, записанное в двоичной системе счисления. Критерием "похожести" двух карточек будем считать результат операции XOR между описывающими их числами. Таким образом, Ваша задача - найти пару карточек, для которых результат операции XOR между описывающими их числами минимален. Если таких пар несколько, выведите в качестве ответа любую из них.</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержится целое число N (2 ≤ N ≤ 3*10⁵) - количество карточек.</p>
  <p>Во второй строке содержится N натуральных чисел a₁, a₂, ..., aₙ через пробел, описывающих карточки (1 ≤ aᵢ ≤ 10⁹)</p>

  <h4>Выходные данные</h4>
  <p>В первой строке выведите через пробел номера двух карточек, XOR между числами на которых минимален. Если решений несколько, выведите любое из них</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
6
4 7 10 5 2 8
</pre>
    <code>1 4</code>

    <h4>Пример 2</h4>
<pre>
5
1 2 3 4 3
</pre>
    <code>3 5</code>
  </details>
</article>


<!-- Задача K. Ваня и надпись -->
<article class="article">
  <div class="anchor" id="task11"></div>
  <h3>Задача K. Ваня и надпись</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Ваня шёл по улице и увидел надпись «Hide&Seek». Поскольку Ваня — программист, ему сразу пришла идея воспользоваться операцией & (побитовое И) для этих двух слов в 64-ричной системе счисления (0..9A..Za..z-_) и получить новое слово. Теперь Ваня придумал некоторую строку s и задался вопросом, сколько существует различных пар слов длины |s| (длина строки s), побитовое И которых равно данному слову s? Поскольку ответ может быть очень большим, Ваня просит вас вычислить его по модулю 10⁹ + 7.</p>

  <p>Для перевода букв слова в 64-ричную систему счисления Ваня использует следующее соответствие знаков и чисел:</p>
  <ul>
    <li>цифрам от «0» до «9» соответствуют числа от 0 до 9;</li>
    <li>буквам от «A» до «Z» соответствуют числа от 10 до 35;</li>
    <li>буквам от «a» до «z» соответствуют числа от 36 до 61;</li>
    <li>символу «-» соответствует число 62;</li>
    <li>символу «_» соответствует число 63.</li>
  </ul>

  <h4>Входные данные</h4>
  <p>В единственной строке входных данных записано слово s (1 ≤ |s| ≤ 100 000), состоящее только из цифр, больших и маленьких букв английского алфавита, символов «-» и «_».</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное целое число — количество возможных пар слов, побитовое И которых равняется строке s, по модулю 10⁹ + 7.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>z</code>
    <code>3</code>

    <h4>Пример 2</h4>
    <code>V_V</code>
    <code>9</code>

    <h4>Пример 3</h4>
    <code>Codeforces</code>
    <code>130653412</code>
    <p>В первом примере возможны 3 варианта:</p>
    <ol>
      <li>z&_ = 61&63 = 61 = z</li>
      <li>_&z = 63&61 = 61 = z</li>
      <li>z&z = 61&61 = 61 = z</li>
    </ol>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/677/problem/C" target="_blank">Задача 677C</a>
      <br><a href="https://codeforces.com/contest/677" target="_blank">Codeforces Round 355 (Div. 2)</a>
    </div>

    <p>Буква z в этой кодировке равна 61. Представим ее в виде степеней двойки</p>
    <code>61₁₀ = 32 + 16 + 8 + 4 + 1 = 111101₂</code>
    <p>Нужно собрать битовую маску. Там где 1 должна быть тоже 1, там где 0 может быть любой символ.</p>
    <p>Задача решается за O(n³). Но мы воспользуемся ДП. Сократим постоянный перерасчет действующих пар. Сложность O(64*n)</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  string s;
  cin >> s;

  // решение
  string s1 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_";
  vector&lt;long long&gt; A(64);
  vector&lt;long long&gt; B(64);

  for (int i = 0; i &lt; 64; i++) {
    int mask = i;
    int count = 0;
    for (int j = 0; j &lt; 6; j++) {
      if (mask % 2 == 0) {
        count++;
      }
      mask /= 2; // mask >>= 1
    }
    A[i] = count;
    long long res = 1;
    for (int j = 0; j &lt; count; j++) {
      res *= 3;
    }
    B[i] = res;
  }

  long long result = 1;
  long long mod = 1e9 + 7;
  for (int i = 0; i &lt; s.size(); i++) {
    for (int j = 0; j &lt; 64; j++) {
      if (s[i] == s1[j]) {
        result = (result * B[j]) % mod;
      }
    }
  }

  // вывод результата
  cout &lt;&lt; result;
}
</pre>
  </details>
</article>


<!-- Задача L. Дима и плохой XOR -->
<article class="article">
  <div class="anchor" id="task12"></div>
  <h3>Задача L. Дима и плохой XOR</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У лицеиста Димы из Кремляндии есть таблица a размера nxm, заполненная целыми неотрицательными числами.</p>

  <p>Он хочет в каждой строке выбрать ровно одно число так, чтобы побитовое исключающее ИЛИ выбранных чисел было строго больше нуля. Помогите ему!</p>

  <p>Формально, он хочет выбрать последовательность чисел c₁, c₂, ... , cₙ (1 ≤ c<sub>j</sub> ≤ m) так, чтобы выполнялось неравенство a<sub>1,c1</sub> XOR a<sub>2,c2</sub> XOR ... XOR a<sub>n,cn</sub> > 0, где a<sub>i,j</sub> — элемент таблицы в i-й строке и j-м столбце.</p>

  <p>Здесь x XOR y обозначает операцию побитового исключающего ИЛИ чисел x и y.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записаны два целых числа n и m, разделенных пробелом (1 ≤ n, m ≤ 500) — количество строк и столбцов в матрице a.</p>

  <p>В следующих n строках записано по m целых чисел, разделенных пробелом: j-е число в i-й из этих строк обозначает j-й элемент i-й строки матрицы a, то есть a<sub>i,j</sub> (0 ≤ a<sub>i,j</sub> ≤ 1023).</p>

  <h4>Выходные данные</h4>
  <p>Если не существует способа выбрать в каждой строке таблицы одно число, чтобы их побитовое исключающее ИЛИ было строго больше нуля, выведите «NIE».</p>

  <p>В противном случае выведите «TAK», и в следующей строке выведите n целых чисел c₁, c₂, ... , cₙ, разделенных пробелами, (1 ≤ c<sub>j</sub> ≤ m), чтобы выполнялось неравенство a<sub>1,c1</sub> XOR a<sub>2,c2</sub> XOR ... XOR a<sub>n,cn</sub> > 0.</p>

  <p>Если существует более одного возможного ответа, вы можете вывести любой.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
3 2
0 0
0 0
0 0
</pre>
    <code>NIE</code>

    <h4>Пример 2</h4>
<pre>
2 3
7 7 7
7 7 10
</pre>
<pre>
TAK
1 3
</pre>
    <p>В первом примере все числа в матрице равны 0, поэтому невозможно выбрать в каждой строке таблицы по одному числу так, чтобы их побитовое исключающее ИЛИ было строго больше нуля.</p>

    <p>Во втором примере выбранные числа 7 (первое число в первой строке) и 10 (третье число во второй строке), 7 XOR 10 = 13, 13 больше чем 0, поэтому ответ найден.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1151/problem/B" target="_blank">Задача 1151B</a>
      <br><a href="https://codeforces.com/contest/1151" target="_blank">Codeforces Round 553 (Div. 2)</a>
    </div>

  </details>
</article>


<!-- Задача M. Максимум и биты -->
<article class="article">
  <div class="anchor" id="task13"></div>
  <h3>Задача M. Максимум и биты</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Андрей сидел в университете и принимал экзамен у первокурсников, когда страшное открытие поразило его. Он понял, что не умеет решать одну из задач, выданных студентам! А то и не одну!</p>

  <p>Задача имеет простой вид: удалите один элемент из массива, чтобы побитовое «И» оставшихся элементов было максимально. Если вы чего-то не поняли – читайте замечания ниже.</p>

  <p>Помогите Андрею решить эту задачу как можно быстрее!</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержится число N (2 ≤ N ≤ 10⁵) – размер массива. Во второй строке расположен сам массив a (0 ≤ aᵢ ≤ 10⁶).</p>

  <h4>Выходные данные</h4>
  <p>Выведите максимальное побитовое «И» после удаления ровно одного элемента.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
3
1 2 3
</pre>
    <code>2</code>

    <h4>Пример 2</h4>
<pre>
7
123 211 1390 121 984 184 911
</pre>
    <code>8</code>
    <p>Побитовое «И» — это бинарная операция, действие которой эквивалентно применению логического «И» к каждой паре битов, которые стоят на одинаковых позициях в двоичных представлениях операндов. Другими словами, если оба соответствующих бита операндов равны 1, результирующий двоичный разряд равен 1; если же хотя бы один бит из пары равен 0, результирующий двоичный разряд равен 0.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/gym/101641/problem/D" target="_blank">Задача D</a>
      <br><a href="https://codeforces.com/gym/101641" target="_blank">Личный чемпионат Самарского университета среди новичков 2017</a>
    </div>

  </details>

</article>


<!-- Задача N. Биты -->
<article class="article">
  <div class="anchor" id="task14"></div>
  <h3>Задача N. Биты</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Рудольф отправляется в замок. Перед тем, как попасть туда, сотрудники службы безопасности задали ему вопрос:</p>

  <p>Задано два числа a и b в двоичной системе счисления, их длина равна n. Сколько есть различных способов поменять местами два бита в числе a (только в a, не в b ) так, чтобы побитовое ИЛИ чисел изменилось? Другими словами, пусть c равно побитовому ИЛИ a и b, тогда вам нужно найти количество способов поменять местами два бита в a так, чтобы побитовое ИЛИ не было равно c.</p>

  <p>Обратите внимание, что числа могут содержать ведущие нули, так что длина каждого числа равна n.</p>

  <p>Побитовое ИЛИ — это бинарная операция. Результат — это такое число, в двоичном представлении которого в каждом разряде стоит единица, если единица находится в двоичной записи хотя бы одного из аргументов. Например, 01010₂ ИЛИ 10011₂ = 11011₂.</p>

  <p>К вашему удивлению, вы не Рудольф, и вам не нужно помогать ему… Вы — сотрудник службы безопасности! Пожалуйста, найдите количество способов поменять местами два бита в a так, чтобы побитовое ИЛИ изменилось.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно целое число n (2 ≤ n ≤ 10⁵) — количество битов в каждом числе.</p>

  <p>Вторая строка содержит число a длиной n в двоичной системе счисления.</p>

  <p>Третья строка содержит число b длиной n в двоичной системе счисления.</p>

  <h4>Выходные данные</h4>
  <p>Выведите количество возможных способов поменять местами два бита в a так, чтобы побитовое ИЛИ изменилось.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
5
01011
11001
</pre>
    <code>4</code>

    <h4>Пример 2</h4>
<pre>
6
011000
010011
</pre>
    <code>6</code>
    <p>В первом примере вы можете поменять местами биты с такими индексами: (1,4), (2,3), (3,4) и (3,5).</p>

    <p>Во втором примере вы можете поменять местами биты с такими индексами: (1,2), (1,3), (2,4), (3,4), (3,5) и (3,6).</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1017/problem/B" target="_blank">Задача B</a>
      <br><a href="https://codeforces.com/contest/1017" target="_blank">Codeforces Round 502 (в память о Leopoldo Taravilse, Div. 1 + Div. 2)</a>
    </div>

    <p>Требуется поменять местами два бита в первом числе. Если в первом числе менять местами биты, в которых 1, то побитовое ИЛИ a | b не изменится. Если в первом числе менять местами биты, значения которых равно 1 во втором числе, также не изменит результат. Остается только два варианта. Первый: меняем местами биты с 0 и 1 в первом числе, те же биты во втором числе так же равны 0 и 1. Второй: меняем местами биты с 0 и 1 в первом числе, те же биты во втором числе равны 1 и 0.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  int n; // число бит в числе
  cin >> n;
  string s1, s2; // два числа в двоичной системе
  cin >> s1 >> s2;

  // решение

  // подсчитаем число бит, в которых ...
  long long cnt00 = 0; // .. в первой строке 0, во второй 0
  long long cnt01 = 0; // .. в первой строке 0, во второй 1
  long long cnt10 = 0; // .. в первой строке 1, во второй 0
  long long cnt11 = 0; // .. в первой строке 1, во второй 1

  for (int i = 0; i &lt; s1.size(); i++) {
    if (s1[i] == '0' && s2[i] == '0') {
      cnt00++;
    }
    if (s1[i] == '0' && s2[i] == '1') {
      cnt01++;
    }
    if (s1[i] == '1' && s2[i] == '0') {
      cnt10++;
    }
    if (s1[i] == '1' && s2[i] == '1') {
      cnt11++;
    }
  }

  long long res = cnt00 * cnt11 + cnt01 * cnt10 + cnt00 * cnt10;

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача O. Xor-подпоследовательность (простая версия) -->
<article class="article">
  <div class="anchor" id="task15"></div>
  <h3>Задача O. Xor-подпоследовательность (простая версия)</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 512мб</i></div>

  <p>Это простая версия задачи. Единственное различие состоит в том, что в этой версии aᵢ ≤ 200.</p>

  <p>Дан массив из n целых чисел a₀, a₁, a₂, ... , a<sub>n-1</sub>. Бряп захотел найти в данном массиве самую длинную хорошую подпоследовательность.</p>

  <p>Массив b = [b₀, b₁, ... , b<sub>m-1</sub>], где 0 ≤ b₀ &lt; b₁ &lt; ... &lt; b<sub>m-1</sub> &lt; n, будем называть подпоследовательностью длины m массива a.</p>

  <p>Подпоследовательность b = [b₀, b₁, ..., b<sub>m-1</sub>] длины m называется хорошей, если выполняется следующее условие:</p>

  <p>Для любого целого числа p (0 ≤ p &lt; m-1) выполняется условие:</p>
  <code>a<sub>b<sub>p</sub> XOR b<sub>p+1</sub> &lt; a<sub>b<sub>p+1</sub> XOR b<sub>p</sub>.</code>

  <p>Здесь a XOR b обозначает побитовое исключающее ИЛИ чисел a и b. Например, 2 XOR 4 = 6, а 3 XOR 1 = 2.</p>

  <p>Так как Бряп не очень любознательная персона, он хочет знать лишь длину такой подпоследовательности. Помогите ему найти ответ на данную задачу.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит единственное целое число t
   (1 ≤ t ≤ 10⁵) — количество наборов входных данных. Далее следует описание наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит единственное целое число n (2 ≤ n ≤ 3⋅10⁵) — длина массива.</p>

  <p>Вторая строка каждого набора входных данных содержит n  целых чисел a₀, a₁, ... , a<sub>n-1</sub> (0 ≤ aᵢ ≤ 200) — элементы массива.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превосходит 3⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных единственное число — максимальную длину хорошей подпоследовательности.</p>

  <details>
    <summary>Пример</summary>
<pre>
3
2
1 2
5
5 2 4 3 1
10
3 8 8 2 9 1 6 2 8 3
</pre>
<pre>
2
3
6
</pre>
    <p>В первом наборе входных данных в качестве подпоследовательности мы можем выбрать оба элемента массива, так как 1 XOR 1 &lt; 2 XOR 0.</p>
    <p>Во втором наборе входных данных мы можем взять элементы с индексами 1, 2 и 4 (в 0-нумерации). Для них выполняется: 2 XOR 2 &lt; 4 XOR 1 и 4 XOR 4 &lt; 1 XOR 2.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1720/problem/D1" target="_blank">Задача 1720D1</a>
      <br><a href="https://codeforces.com/contest/1720" target="_blank">Codeforces Round 815 (Div. 2)</a>
    </div>

  </details>

</article>


<!-- Задача P. Составление тестов -->
<article class="article">
  <div class="anchor" id="task16"></div>
  <h3>Задача P. Составление тестов</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Подготавливая одну из задач этого контеста, жюри столкнулось с проблемой: существует довольно много неверных решений, против которых сложно подобрать тест. Жюри написало n тестов и m неверных решений, каждое из которых не проходит хотя бы один из этих тестов.</p>

  <p>Теперь жюри хочет минимизировать число тестов, так, чтобы любое из m решений не проходило хотя бы один тест из итогового набора. А помогать жюри в этом, разумеется, будут участники.</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержатся 2 целых числа через пробел: n и m (1 ≤ n ≤ 20, 1 ≤ m ≤ 60) – количество имеющихся у жюри тестов и неверных решений соответственно.</p>

  <p>Каждая из следующих n строк описывает i-ый тест и содержит сначала число k (1 ≤ k ≤ m) – количество решений, которые не проходят i-ый тест, а затем k различных целых чисел – номера этих решений. Решения нумеруются от 1 до m.</p>

  <p>Гарантируется, что каждое из m решений не проходит хотя бы один из n тестов.</p>

  <h4>Выходные данные</h4>
  <p>В первой строке выведите минимальное число тестов t, необходимое, чтобы ни одно из m неверных решений жюри не проходило хотя бы один из этих тестов.</p>

  <p>Во второй строке выведите t целых чисел – номера этих тестов.</p>

  <p>Если минимальных наборов тестов несколько, выведите любой.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
3 5
2 2 1
1 4
2 3 5
</pre>
<pre>
3
1 2 3
</pre>

    <h4>Пример 2</h4>
<pre>
3 3
3 1 2 3
3 2 3 1
3 3 1 2
</pre>
<pre>
1
1
</pre>

    <h4>Пример 3</h4>
<pre>
3 3
2 1 2
2 2 3
2 3 1
</pre>
<pre>
2
1 2
</pre>

    <h4>Пример 4</h4>
<pre>
3 3
2 2 3
1 1
2 1 3
</pre>
<pre>
2
1 2
</pre>
  </details>
</article>


<!-- Задача Q. Ксорить или не ксорить -->
<article class="article">
  <div class="anchor" id="task17"></div>
  <h3>Задача Q. Ксорить или не ксорить</h3>

  <div><i>Ограничение по времени 0.25с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам дана последовательность A<sub>1</sub>, A<sub>2</sub>, ... , A<sub>N</sub> неотрицательных целых чисел. Ваша задача – найти такую подпоследовательность A<sub>i1</sub>, A<sub>i2</sub>, ... , A<sub>ik</sub> (1 ≤ i<sub>1</sub> &lt; i<sub>2</sub> &lt; ⋯ &lt; i<sub>k</sub> ≤ N), что A<sub>i1</sub> XOR A<sub>i2</sub> XOR … XOR A<sub>ik</sub> будет принимать максимальное значение.</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержится число N (1 ≤ N ≤ 100) – количество чисел в последовательности.</p>

  <p>Во второй строке содержатся N чисел Aᵢ (0 ≤ Aᵢ ≤ 10¹⁸).</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите число – максимально возможное значение A<sub>i1</sub> XOR A<sub>i2</sub> XOR ... XOR A<sub>ik</sub></p>

  <details>
    <summary>Пример</summary>
<pre>
3
11 9 5
</pre>
    <code>14</code>
  </details>
</article>


<!-- Задача R. Максимальное И -->
<article class="article">
  <div class="anchor" id="task18"></div>
  <h3>Задача R. Максимальное И</h3>

  <div><i>Ограничение по времени 3с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам даны два массива a и b, состоящие из n целых чисел каждый.</p>

  <p>Определим функцию f(a,b) следующим образом:</p>
  <ul>
    <li>определим массив c размера n, где cᵢ = aᵢ XOR bᵢ (XOR обозначает операцию побитового исключающего ИЛИ);</li>
    <li>значением функции является c₁ & c₂ & ⋯ &cₙ (т.е. побитовое И всех элементов массива c).</li>
  </ul>

  <p>Найдите максимальное значение функции f(a,b), если вы можете переупорядочить элементы массива b произвольным образом (также можно оставить первоначальный порядок).</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора содержит одно целое число n
  (1 ≤ n ≤ 10⁵) — размеры массивов a и b.</p>

  <p>Вторая строка содержит n целых чисел a₁, a₂, ... , aₙ (0 ≤ aᵢ &lt; 2³⁰).</p>

  <p>Третья строка содержит n целых чисел b₁, b₂, ... , bₙ (0 ≤ bᵢ &lt; 2³⁰).</p>

  <p>Сумма n по всем наборам входных данных не превосходит 10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно целое число — максимальное значение функции f(a,b), если вы можете переупорядочить элементы массива b произвольным образом.</p>

  <details>
    <summary>Пример</summary>
<pre>
3
5
1 0 0 3 3
2 3 2 1 0
3
1 1 1
0 0 3
8
0 1 2 3 4 5 6 7
7 6 5 4 3 2 1 0
</pre>
<pre>
2
0
7
</pre>
  </details>
</article>


<!-- Задача S. Крош и задача на битовые операции -->
<article class="article">
  <div class="anchor" id="task19"></div>
  <h3>Задача S. Крош и задача на битовые операции</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У Кроша есть три числа a, b, c. Помогите ему посчитать количество массивов длиной n, AND элементов которых равен a, OR элементов которых равен b, XOR элементов которых равен c. Два массива считаются различными, если существует позиция, что в разных массивах на этой позиции стоят разные числа. Так как ответ может получиться большим, выведите его остаток от деления на 10⁹ + 7.</p>

  <h4>Входные данные</h4>
  <p>В первой строке дано количество элементов в массиве 1 ≤ n ≤ 10¹⁸. Во второй строке дано число a. В третьей строке дано число b. В четвертой строке дано число c. Эти числа записаны в двоичной системе счисления, их длины равны и не превосходят 10⁵. Гарантируется, что число b, обозначающее OR, начинается с 1. В числах a и c могут быть лидирующие нули.</p>

  <h4>Выходные данные</h4>
  <p>Выведите ответ на задачу по модулю 10⁹ + 7.</p>

  <details>
    <summary>Пример</summary>
<pre>
4
001
101
100
</pre>
    <code>8</code>
  </details>
</article>


<!-- Задача T. Даша и кошмары -->
<article class="article">
  <div class="anchor" id="task20"></div>
  <h3>Задача T. Даша и кошмары</h3>

  <div><i>Ограничение по времени 4с
  <br>Ограничение по памяти 512мб</i></div>

  <p>Отличница Даша учится в лучшем математическом лицее страны. Недавно таинственный незнакомец принёс в лицей n
  слов из маленьких латинских букв s₁, s₂, ... , sₙ. С того дня Дашу начали мучить кошмары.</p>

  <p>Рассмотрим некоторую пару целых чисел ⟨i,j⟩ (1 ≤ i ≤ j ≤ n). Кошмаром называется строка, для которой верно:</p>
  <ul>
    <li>Она получена склеиванием s<sub>i</sub>s<sub>j</sub>;</li>
    <li>Её длина нечётна;</li>
    <li>Количество различных букв, входящих в неё, ровно 25;</li>
    <li>Количество каждой отдельной буквы, входящей в неё, нечётно.</li>
  </ul>

  <p>Например, если s<sub>i</sub> = «abcdefg» и s<sub>j</sub> = «ijklmnopqrstuvwxyz», пара ⟨i,j⟩ образует кошмар.</p>

  <p>Даша знает, что кошмары исчезнут, если их посчитать. Кошмаров слишком много, поэтому Даше нужна ваша помощь. Посчитайте количество различных кошмаров.</p>

  <p>Кошмары считаются различными, если различны соответствующие им пары ⟨i,j⟩. Пары ⟨i₁, j₁⟩ и ⟨i₂, j₂⟩ считаются различными, если i₁≠i₂ или j₁≠j₂.</p>

  <h4>Входные данные</h4>
  <p>В первой строке дано единственное целое число n (1 ≤ n ≤ 2⋅10⁵) — количество слов.</p>

  <p>В следующих n строках записаны слова s₁, s₂, ... , sₙ, состоящие из маленьких латинских букв.</p>

  <p>Гарантируется, что суммарная длина слов не превосходит 5⋅10⁶.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное целое число — количество различных кошмаров.</p>

  <details>
    <summary>Пример</summary>
<pre>
10
ftl
abcdefghijklmnopqrstuvwxy
abcdeffghijkllmnopqrsttuvwxy
ffftl
aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyy
thedevid
bcdefghhiiiijklmnopqrsuwxyz
gorillasilverback
abcdefg
ijklmnopqrstuvwxyz
</pre>
    <code>5</code>

    <p>В первом тесте кошмары образуются парами ⟨1,3⟩, ⟨2,5⟩, ⟨3,4⟩, ⟨6,7⟩, ⟨9,10⟩.</p>
  </details>
</article>

