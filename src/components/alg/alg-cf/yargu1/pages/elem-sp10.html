<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contests" target="_blank">Codeforces ЯрГУ. Школьники</a></p>
  <p><a href="https://vk.com/sportprog_yarsu" target="_blank">vk.com/sportprog_yarsu</a></p>
  <p><a href="https://vkvideo.ru/@sportprog_yarsu" target="_blank">vkvideo.ru/@sportprog_yarsu</a></p>
</article>


<article class="article">
  <h1>Занятие 10. Базовые алгоритмы #3. Бинарный поиск на массиве</h1>
  <p>Конспект видео от 2024.11.16</p>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contest/567104" target="_blank">Codeforces Контест 567104</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
    <a href="#p1">Бинарный поиск на массиве</a>
  </p>
  <p>
        <a href="#task1">Задача A. Сложность двоичного поиска</a>
    <br><a href="#task2">Задача B. Сурен в поисках числа</a>
    <br><a href="#task3">Задача C. Таинство суммы</a>
    <br><a href="#task4">Задача D. Поиск в массиве</a>
    <br><a href="#task5">Задача E. Собственные числа Psych Up</a>
    <br><a href="#task6">Задача F. Количество вхождений</a>
    <br><a href="#task7">Задача G. Экзамен по истории</a>
    <br><a href="#task8">Задача H. Функция Хевисайда</a>
    <br><a href="#task9">Задача I. Модифицированный НОД</a>
    <br><a href="#task10">Задача J. Коровам - колокольчиков</a>
    <br><a href="#task11">Задача K. Про таблицу умножения</a>
    <br><a href="#task12">Задача L. Неквадратное уравнение</a>
    <br><a href="#task13">Задача M. Очередная задача на массиве</a>
    <br><a href="#task14">Задача N. Запросы на поедание конфет</a>
  </p>
</article>


<!-- Бинарный поиск на массиве -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Бинарный поиск на массиве</h3>

  <h4>Задача. Поиск числа в массиве</h4>
  <p>Дан массив целых чисел A длины n a<sub>1</sub>, a<sub>2</sub>, ... , a<sub>n</sub>. Задано q запросов, каждый запрос это проверка существует ли число b в массиве A.</p>

  <h4>Линейный поиск на массиве</h4>
  <p>Наивное решение задачи это посмотреть на каждый элемент, чтобы проверить равен ли он b. Каждый запрос обрабатывать линейным поиском.</p>
  <p><strong>Трудоемкость линейного поиска</strong> при n элементов и q запросах O(n * q).</p>

  <details>
    <summary>Решение за O(n * q)</summary>
<pre>
int q; // число запросов
int b; // число для поиска
cin >> q;
bool flag;

for (int j = 0; j &lt; q; j++) {
  flag = false;
  cin >> b;

  for (int i = 0; i &lt; A.size(); i++) {
    if (A[i] == b) {
      flag = true;
    }
  }

  if (flag) {
    cout &lt;&lt; "YES\n";
  } else {
    cout &lt;&lt; "NO\n";
  }
}
</pre>
  </details>

  <h4>Бинарный поиск на массиве</h4>
  <p>Оптимизируем решение. Попробуем искать значение в массиве быстрее чем за O(n). Для улучшения мы требуем, чтобы массив был упорядочен (по возрастанию). Алгоритм бинарного поиска основан на методе двух указателей. Нам потребуется два указателя left и right и переменная mid для нахождения середины.</p>
  <p>Ответ будет находиться между двумя указателями left и right это границы поиска.</p>
  <p>Разделим нашу область поиска на две равные части, для этого mid определим по формуле</p>
  <code>mid = (left + right) / 2</code>
  <p>Элемент, который мы ищем лежит в одной из частей. Элемент массива с индексом mid может принадлежать любой из частей.</p>
  <p>В силу того, что массив упорядочен (например, по возрастанию) мы можем сравнивать элемент под индексом mid со значением поиска и отвергнуть половину области поиска в которой ответа точно нет.</p>
  <p>Допустим A[mid] &lt; b, тогда в силу того что массив упорядочен по возрастанию все элементы</p>
  <code>A[left], A[left+1], ... , A[mid] &lt; b</code>
  <p>и в области [left, mid] ответа нет. Мы можем переместить границу left в mid</p>
  <p>Аналогичные рассуждения справедливы для границы right, если A[mid] > b.</p>

  <p>Последовательность действий алгоритма</p>
  <ol>
    <li>Находим середину области поиска</li>
    <li>Делаем сравнение элемента с индексом mid со значением поиска b</li>
    <li>В зависимости от результата сдвигаем, либо левую границу области поиска в середину, либо правую границу области поиска в середину</li>
    <li>Продолжаем выполнять движение границ области поиска до тех пор, пока границы не станут соседними значениями right - left > 1.</li>
    <li>Делаем дополнительную проверку элементов после окончания цикла while</li>
  </ol>
  <p>На каждой итерации область поиска уменьшается вдвое. Для поиска элемента при помощи бинарного поиска потребуется примерно log<sub>2</sub>(n) операций. Трудоемкость O(log<sub>2</sub>(n)).</p>
<pre>
while (right - left > 1) {
  mid = (right + left) / 2;
  if (A[mid] &lt; b) {
    left = mid;
  } else {
    right = mid;
  }
}
</pre>
  <p><strong>Трудоемкость бинарного поиска</strong> при n элементов и q запросах O(n*log<sub>2</sub>(n) + q*log<sub>2</sub>(n))</p>

  <p>Бинарный поиск на массиве можно реализовывать по-разному. Чуть ранее мы реализовывали версию бинарного поиска, в которой ответ искали в области включительно с границами [left, right]. Мы можем изменить область поиска элемента до полуинтервалов [left, right) это позволит меньше делать действий в дополнительной проверке элементов после цикла while, но усложняет выбор сдвига границ</p>

  <p><strong>Школьная</strong> версия - это реализация на отрезке, в которой ответ искали в области включительно с границами [left, right]</p>

  <details>
    <summary>Код (школьная версия)</summary>
<pre>
sort(A.begin(), A.end());
int q, b, left, right, mid;
cin >> q;

for (int j = 0; j &lt; q; j++) {
  cin >> b;
  left = 0;
  right = n - 1;

  while (right - left > 1) {
    mid = (right + left) / 2;
    if (A[mid] > b) {
      right = mid;
    } else {
      left = mid;
    }
  }

  if (A[left] == b || A[right] == b) {
    cout &lt;&lt; "YES\n";
  } else {
    cout &lt;&lt; "NO\n";
  }
}
</pre>
  </details>

  <p><strong>Студенческая</strong> версия - это реализация на полуинтервале [left, right).</p>

  <details>
    <summary>Код (студенческая версия)</summary>
<pre>
sort(A.begin(), A.end());
int q, b, left, right, mid;
cin >> q;

for (int j = 0; j &lt; q; j++) {
  cin >> b;
  left = 0;
  right = n;  // здесь отличие

  while (right - left > 1) {
    mid = (right + left) / 2;
    if (A[mid] >= b) { // здесь отличие
      right = mid;
    } else {
      left = mid;
    }
  }

  if (A[left] == b) { // здесь отличие
    cout &lt;&lt; "YES\n";
  } else {
    cout &lt;&lt; "NO\n";
  }
}
</pre>
  </details>

  <h4>Задача поиска числа</h4>

  <p>Если массив состоит из двух отсортированных частей, то можно два раза применить бинарный поиск. Сначала к одной части, а затем к другой.</p>

  <h4>Задача поиска числа и его количества</h4>

  <p>Рассмотрим небольшое усложнение задачи про поиск элементов в массиве.</p>
  <p>Пусть нас интересует не только существование элемента в массиве, но и количество.</p>
  <p>При помощи бинарного поиска мы можем определить первую и последнюю позицию в отсортированном массиве, где встречается элемент.</p>

  <h4>Задача определения количества элементов</h4>

  <p>На отсортированном массиве определить количество элементов, которые</p>
  <code>p ≤ A[i] ≤ q</code>
  <p>Эту задачу можно разбить на две подзадачи.</p>
  <p>Первая. Найдем такой элемент в массиве, что все элементы справа от него будут p ≤ A[i]. Эту задачу решит левосторонний бинарный поиск.</p>
<pre>
if (A[i] >= p) {
  right = mid;
} else {
  left = mid;
}
</pre>
  <p>Вторая. Найдем такой элемент в массиве, что все элементы слева от него будут A[i] ≤ q. Эту задачу решит правосторонний бинарный поиск.</p>
<pre>
if (A[i] &lt;= p) {
  left = mid;
} else {
  right = mid;
}
</pre>

  <h4>Решение задач</h4>

  <p>Задачи на бинарный поиск можно решать разными способами:</p>
  <ol>
    <li>Бинарным поиском</li>
    <li>Структурой данных set и map</li>
    <li>Функциями lower_bound() и upper_bound(). Они принимают три аргумента. Первый это указатель на нижнюю границу диапазона. Второй это указатель на верхнюю границу диапазона. Третий это значение, которое надо найти. lower_bound возвращает первое значение A[i] >= c. upper_bound возвращает первое значение A[i] > c.</li>
  </ol>
</article>


<!-- Задача A. Сложность двоичного поиска -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Сложность двоичного поиска</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вася загадал число от 1 до N. За какое наименьшее количество вопросов (на которые Вася отвечает "да" или "нет") Петя может угадать Васино число?</p>

  <h4>Входные данные</h4>
  <p>Вводится одно число N</p>

  <h4>Выходные данные</h4>
  <p>Выведите наименьшее количество вопросов, которого гарантированно хватит Пете, чтобы угадать Васино число.</p>

  <details>
    <summary>Пример</summary>
    <h4></h4>
    <code>5</code>
    <code>3</code>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;

  // решение
  int k = 1;
  int res = 0;
  while (n > k) {
    k *= 2;
    res++;
  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача B. Сурен в поисках числа -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Сурен в поисках числа</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Однажды к Сурену прибежала Анжелика и показала ему много чисел. К ним подошел Денис и начал спрашивать: есть ли среди показанных заданное число?</p>

  <p>Помогите Сурену ответить на вопросы Дениса.</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержатся 2 числa – количество чисел у Анжелики (1 ≤ N ≤ 10<sup>6</sup>) и количество вопросов Дениса (1 ≤ Q ≤ 10<sup>5</sup>).</p>

  <p>Во второй строке содержится массив чисел Анжелики, каждое число которого по модулю не превосходит 10<sup>9</sup>.</p>

  <p>Далее следуют Q строк в каждой из которых содержится число a<sub>i</sub> (|a<sub>i</sub>| ≤ 10<sup>9</sup>) – число которое называет Денис.</p>

  <h4>Выходные данные</h4>
  <p>На каждый запрос в отдельной необходимо вывести «YES», если загаданное Денисом число есть, и «NO» в противном случае.</p>

  <details>
    <summary>Пример</summary>
<pre>
2 5
6 5
2
1
7
9
7
</pre>
<pre>
NO
NO
NO
NO
NO
</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <h4>Пример 2</h4>
<pre>
2 5
6 5
6
5
1
2
3
</pre>
<pre>
YES
YES
NO
NO
NO
</pre>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ускорение ввода и вывода
  ios::sync_with_stdio(0);
  cin.tie(0);
  cout.tie(0);

  // ввод данных
  int n; // число чисел
  int q; // число запросов
  cin >> n >> q;

  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i]; // числа
  }

  vector&lt;int&gt; B(q);
  for (int i = 0; i &lt; q; i++) {
    cin >> B[i]; // запросы
  }

  // решение
  sort(A.begin(), A.end());

  // обработка запросов
  for (int i = 0; i &lt; q; i++) {
    int num = B[i];

    // бинарный поиск
    int left = 0;
    int right = n - 1;
    int mid;
    while (right - left > 1) {
      mid = (left + right) / 2;
      if (A[mid] > num) {
        right = mid;
      } else {
        left = mid;
      }
    }

    // вывод результата
    if (A[left] == num || A[right] == num) {
      cout &lt;&lt; "YES" &lt;&lt; '\n';
    } else {
      cout &lt;&lt; "NO" &lt;&lt; '\n';
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача C. Таинство суммы -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Таинство суммы</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 64мб</i></div>

  <p>— Брат мой, Магистр Ордена хочет узнать завтра о результатах наших многолетних изысканий. Он хочет видеть, ни много, ни мало, Суммирующую Машину! Даже более того: он хочет, чтобы наша Машина — всего лишь машина — продемонстрировала свое постижение Таинства Суммы настолько глубоко, насколько это возможно. Он хочет, чтобы Машина нашла каких-нибудь два числа, дающих в сумме священное число 10000 ! — Тс-с-с! Но это же безумство, граничащее с кощунством! Как Машина может ВЫЧИСЛИТЬ священное число? Двадцать семь лет мы работаем над ней, и смогли только лишь научить ее отвечать на вопрос: «Больше сумма двух введенных чисел, чем 10000, или меньше?». Но разве может смертный найти два таких числа, чтобы их сумма оказалась равна 10000 ?</p>

 <p>— И все же нам придется сделать это с помощью нашей Машины, пусть она и неспособна на это. Иначе у нас будут… ну, скажем так, крупные неприятности, если кипящее масло можно назвать таким словом. Впрочем, у меня есть идея. Помнишь, на той неделе мы ввели в Машину числа -7 и 13, она ответила, что их Сумма меньше 10000. Я не знаю, как это проверить, но нам ничего не остается, как доверять созданию наших рук. Что, если теперь мы возьмем число большее, чем -7 и снова запустим Машину? И будем так делать снова и снова, пока не найдем такое число, которое в сумме с 13 даст 10000 ! Надо только подготовить список возрастающих чисел.</p>

  <p>— Не верю я в эту идею… Давай лучше начнем с суммы, заведомо большей, чем Священное число и будем уменьшать одно из слагаемых, так у нас больше шансов избегнуть кипяще… крупных неприятностей. Так ни о чём и не договорившись, Братья разошлись по своим кельям. К следующему дню, каждый из них подготовил такой список чисел, который, по его мнению, мог бы их спасти… Смогут ли спасти их оба списка вместе?</p>

  <p>Ваша программа должна определять, можно ли из двух списков целых чисел выбрать по одному числу так, чтобы в сумме они составили 10000.</p>

  <h4>Входные данные</h4>
  <p>Состоят из двух списков — одного, потом другого. Формат каждого из этих списков таков: в первой строчке записано количество N<sub>i</sub> чисел в i-м списке, далее в N<sub>i</sub> строчках по одному числу в строке записаны сами списки. Выполняются неравенства 1 ≤ N<sub>i</sub> ≤ 50000, все элементы списков лежат в диапазоне от -32768 до 32767. Первый список упорядочен по возрастанию, второй - по убыванию.</p>

  <h4>Выходные данные</h4>
  <p>На выходе следует записать YES, если из списков можно выбрать по числу, которые в сумме дадут 10000 и NO в противном случае.</p>

  <details>
    <summary>Пример</summary>
<pre>
4
-175
19
19
10424
3
8951
-424
-788
</pre>
    <code>YES</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Первый массив отсортирован по возрастанию, поэтому в бинарный поиск будем передавать именно его.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

bool binarySearch(const vector&lt;int&gt;& C, int size, int target) {
  int left = 0, right = size;
  int mid = left + (right - left) / 2;
  while (right - left > 1) {
    if (C[mid] > target) {
      right = mid;
    } else {
      left = mid;
    }
    mid = left + (right - left) / 2;
  }
  if (C[left] == target) {
    return true;
  } else {
    return false;
  }
}

int main() {
  // ввод данных
  int n;
  cin >> n;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }
  int m;
  cin >> m;
  vector&lt;int&gt; B(m);
  for (int i = 0; i &lt; m; i++) {
    cin >> B[i];
  }

  // решение
  for (int i = 0; i &lt; m; i++) {
    int target = 10000 - B[i];
    if (binarySearch(A, n, target)) {
      cout &lt;&lt; "YES";
      return 0;
    }
  }

  // вывод результата
  cout &lt;&lt; "NO";
}
</pre>
  </details>
</article>


<!-- Задача D. Поиск в массиве -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Поиск в массиве</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам дан упорядоченный массив, состоящий только из целочисленных элементов, каждый из которых не превосходит 10<sup>9</sup> по абсолютной величине, все элементы массива различны. Происходит серия следующих запросов: требуется найти позицию, на которой находится заданный элемент.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных 2 числа: N (1 ≤ N ≤ 10<sup>5</sup>) - число элементов в массиве и M (1 ≤ M ≤ 10<sup>5</sup>) - количество запросов. В следующей строке вводится N чисел - элементы массива упорядоченные по возрастанию, каждый из которых не превосходит 10<sup>9</sup> по абсолютной величине, все элементы массива различны. В следующих M строках вводится единственное число - запрашиваемый элемент.</p>

  <h4>Выходные данные</h4>
  <p>Вам необходимо отвечать на каждый из M запросов по одному в строке - на какой позиции стоит запрашиваемый элемент. Если же такого элемента нет вывести -1.</p>

  <details>
    <summary>Пример</summary>
<pre>
3 5
1 3 4
1
2
3
4
5
</pre>
<pre>
1
-1
2
3
-1
</pre>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

// позиция в массиве, начиная с 1
int binarySearch(const vector&lt;int&gt;& C, int size, int target) {
  int left = 0, right = size;
  int mid = left + (right - left) / 2;
  while (right - left > 1) {
    if (C[mid] > target) {
      right = mid;
    } else {
      left = mid;
    }
    mid = left + (right - left) / 2;
  }
  if (C[left] == target) {
    return left + 1;
  } else {
    return -1;
  }
}

int main() {
  // ввод данных
  int n, m;
  cin >> n >> m;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }
  vector&lt;int&gt; Q(m);
  for (int i = 0; i &lt; m; i++) {
    cin >> Q[i];
  }

  // решение  и вывод результата
  for (int i = 0; i &lt; m; i++) {
    int target = Q[i];
    cout &lt;&lt; binarySearch(A, n, target) &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача E. Собственные числа Psych Up -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Собственные числа Psych Up</h3>

  <div><i>Ограничение по времени 0.5с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Шёл очередной контест Петрозаводских сборов. Игроки команды Psych Up быстро нашли простую задачу, и Федя сел за компьютер. Через пять минут решение было готово. Не тратя времени на тестирование, Федя отправил его на проверку и через несколько секунд получил вердикт Time Limit Exceeded. Федя скомкал условие задачи и вышел из класса, хлопнув дверью. Что-то шло не так, нужно было развеяться. По пути в туалет он услышал разговор авторов контеста. Паша обсуждал со своим другом решение той самой задачи. Федя смог разобрать из их разговора только слова «собственные числа». Федя подумал и решил, что у него, конечно же, есть собственные числа. Например, дата рождения, номер квартиры, оценка на последнем экзамене, количество поездок на соревнования. Но ведь контест командный. А что такое собственные числа команды? Естественно, что число является собственным для команды, если оно собственное для каждого из её участников. С такими радостными мыслями Федя направился назад в аудиторию.</p>

  <h4>Входные данные</h4>
  <p>Входные данные состоят из трёх блоков по две строки. Первая строка каждого блока содержит целое число n —количество собственных чисел очередного игрока (1 ≤ n ≤ 4000). Во второй строке блока записано n целых различных чисел в порядке возрастания — собственные числа очередного игрока. Все собственные числа — целые, положительные и не превосходят 10<sup>9</sup>.</p>

  <h4>Выходные данные</h4>
  <p>Выведите количество собственных чисел команды Psych Up.</p>

  <details>
    <summary>Пример</summary>
<pre>
5
13 20 22 43 146
4
13 22 43 146
5
13 43 67 89 146
</pre>
    <code>3</code>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

bool binarySearch(const vector&lt;int&gt;& C, int size, int target) {
  int left = 0, right = size;
  int mid = left + (right - left) / 2;
  while (right - left > 1) {
    if (C[mid] > target) {
      right = mid;
    } else {
      left = mid;
    }
    mid = left + (right - left) / 2;
  }
  if (C[left] == target) {
    return true;
  } else {
    return false;
  }
}

int main() {
  // ввод данных
  int n1;
  cin >> n1;
  vector&lt;int&gt; A(n1);
  for (int i = 0; i &lt; n1; i++) {
    cin >> A[i];
  }
  int n2;
  cin >> n2;
  vector&lt;int&gt; B(n2);
  for (int i = 0; i &lt; n2; i++) {
    cin >> B[i];
  }
  int n3;
  cin >> n3;
  vector&lt;int&gt; C(n3);
  for (int i = 0; i &lt; n3; i++) {
    cin >> C[i];
  }

  // решение
  int res = 0;
  for (int i = 0; i &lt; n1; i++) {
    int target = A[i];
    if ( binarySearch(B, n2, target) && binarySearch(C, n3, target) ) {
      res++;
    }
  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача F. Количество вхождений -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Количество вхождений</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Однажды Белг нашел на улице здоровенный массив размера n и решил его исследовать. К нему пришел его друг Валсотявс и решил проверить, насколько хорошо Белг изучил его, и начал ему задавать q вопросов следующего вида: он просил его найти число вхождений некоторого числа в этот массив. Но Белг не настолько хорошо изучил его, чтобы запомнить число вхождения любых чисел и отвечать на вопросы Валсотявса. Белг вспомнил о своём дипломе программиста, но давно этим не занимался, поэтому просит вас помочь ему написать программу, которая поможет ответить на все вопросы.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных заданы 2 числа: n и q (1 ≤ n, q ≤ 3 * 10<sup>5</sup>) - размер массива и число запросов соответственно. В следующей строке вводятся n целых чисел - массив который нашёл Белг, каждое число не превосходит 10<sup>9</sup> по абсолютной величине. В последующих q строках вводится по 1 числу - это то число, для которого надо найти его количество вхождений в массив.</p>

  <h4>Выходные данные</h4>
  <p>Выводить нужно ответы на запросы - по одному в строке - число вхождений запрашиваемого числа в заданный массив.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
10 5
1 2 3 3 4 4 4 5 6 7
4
3
2
1
0
</pre>
<pre>
3
2
1
1
0
</pre>
    <p>В первом тестовом примере - число 4 встречается 3 раза, число 3 - 2, 2 - встречается 1 раз, число 1 - тоже 1, а числа 0 нет в массиве, поэтому оно ни разу не встречается.</p>

    <h4>Пример 2</h4>
<pre>
10 3
4 5 1 2 3 4 7 4 4 0
4
3
6
</pre>
<pre>
4
1
0
</pre>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ввод данных
  int n, q;
  cin >> n >> q;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  sort(A.begin(), A.end());
  vector&lt;int&gt; B, C;
  B.push_back(A[0]);
  C.push_back(1);

  for (int i = 1; i &lt; n; i++) {
    if (A[i] == B[B.size() - 1]) {
      C[C.size() - 1]++;
    } else {
      B.push_back(A[i]);
      C.push_back(1);
    }
  }

  int x, left, right, mid;
  for (int i = 0; i &lt; q; i++) {
    cin >> x;
    left = 0; // [l,r)
    right = B.size();
    while (right - left > 1) {
      mid = (right + left) / 2;
      if (B[mid] > x) {
        right = mid;
      } else {
        left = mid;
      }
    } // [l, l+1)

    // вывод результата
    if (B[left] == x) {
      cout &lt;&lt; C[left] &lt;&lt; '\n';
    } else {
      cout &lt;&lt; 0 &lt;&lt; '\n';
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача G. Экзамен по истории -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Экзамен по истории</h3>

  <div><i>Ограничение по времени 1.5с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Будем справедливы: сессия ставит задачи не только студентам, но и преподавателям. Любой преподаватель обучает немалое количество студентов, а ведь каждого надо еще и проверить. Поэтому один из преподавателей решил принимать экзамен по истории по такой упрощённой процедуре: студент записывает все известные ему «исторические» даты (достаточно, чтобы он написал только года, но, конечно, мог объяснить, чем замечательна та или иная дата). Преподаватель же держит перед глазами список дат, которые студент должен знать. Для оценки знаний студента преподаватель подсчитывает количество чисел в списке студента, которые также есть в списке преподавателя. В зависимости от полученного числа и выставляется итоговая оценка. Вы должны оказать посильную помощь в автоматизации этого процесса, разработав программу для подсчёта количества совпадений в списках студента и преподавателя.</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержится число N — количество записей в списке преподавателя. 1 ≤ N ≤ 15000. Затем идет N строк, содержащих список преподавателя, по одной дате в строке. Записаны только года. Каждый год — целое число в пределах от 1 до 10<sup>9</sup>. Даты в этом списке отсортированы по неубыванию. В следующей после списка строке содержится число M — количество записей в списке студента, 1 ≤ M ≤ 10<sup>6</sup>. Затем также M строк с датами (записаны только года, каждый год — целое число в пределах от 1 до 10<sup>9</sup>). Этот список не отсортирован. В списке как студента, так и преподавателя даты могут повторяться.</p>

  <h4>Выходные данные</h4>
  <p>Вы должны вывести одно число — количество чисел во втором списке, которые также содержатся в первом.</p>

  <details>
    <summary>Пример</summary>
<pre>
2
1054
1492
4
1492
65536
1492
100
</pre>
    <code>2</code>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  // список преподавателя
  int n;
  cin >> n;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // список студента
  int m;
  cin >> m;
  vector&lt;int&gt; B(m);
  for (int i = 0; i &lt; m; i++) {
    cin >> B[i];
  }

  // решение
  int res = 0;
  for (int i = 0; i &lt; m; i++) {
    int tmp, left, right, mid;
    tmp = B[i];
    left = 0;
    right = n - 1;

    while (right - left > 1) {
      mid = (right + left) / 2;
      if (A[mid] > tmp) {
        right = mid;
      } else {
        left = mid;
      }
    }

    if (A[left] == tmp || A[right] == tmp) {
      res++;
    }
  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача H. Функция Хевисайда -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Функция Хевисайда</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Функцией Хевисайда называется кусочно-постоянная функция, равная нулю для отрицательных значений аргумента и единице — для неотрицательных:</p>
  <code>θ(x)={0, x &lt; 0 ; 1, x ⩾ 0}</code>

  <p>Дана функция</p>
  <code>f(x) = θ(s₁⋅x - a₁) + θ(s₂⋅x - a₂) + ⋯ + θ(sₙ⋅x - aₙ)</code>
  <p>, где sᵢ = ±1. Посчитайте ее значение в точках x<sub>1</sub>, x<sub>2</sub>, ..., x<sub>m</sub>.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано единственное целое число n (1 ≤ n ≤ 200000) — количество слагаемых в функции.</p>

  <p>В следующих n строках записано по два целых числа sᵢ и aᵢ (sᵢ = ±1, -10⁹ ≤ aᵢ ≤ 10⁹) — параметры i-ого слагаемого функции.</p>

  <p>В следующей строке записано единственное целое число m (1≤m≤200000) — количество значений аргумента, для которых нужно посчитать значение выражения.</p>

  <p>В последней строке записано m целых чисел x<sub>1</sub>, ..., x<sub>m</sub> (-10⁹ ≤ xᵢ ≤ 10⁹) — точки, в которых надо посчитать значение выражения.</p>

  <h4>Выходные данные</h4>
  <p>Выведите m строк. В i-ой строке выведите значение выражения f(xᵢ).</p>

  <details>
    <summary>Пример</summary>
<pre>
6
1 3
-1 2
1 9
-1 2
1 7
-1 2
8
0 12 2 8 4 -3 7 9
</pre>
<pre>
0
3
0
2
1
3
2
3
</pre>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/gym/100187/problem/M" target="_blank">Задача 100187M</a>
      <br><a href="https://codeforces.com/gym/100187" target="_blank">2013, VI Самарская областная межвузовская олимпиада по программированию 2013-04-27</a>
    </div>

<pre>
#include &lt;iostream>
#include &lt;vector>
#include &lt;algorithm>

using namespace std;

int main() {
  // ускорение ввода и вывода
  ios::sync_with_stdio(0);
  cin.tie(0);
  cout.tie(0);

  // ввод данных
  int n;
  cin >> n;
  vector&lt;int&gt; A, B;
  int s, a;
  for (int i = 0; i &lt; n; i++) {
    cin >> s >> a;
    if (s == 1) {
      A.push_back(a);
    } else {
      B.push_back(-a);
    }
  }
  int m;
  cin >> m;
  vector&lt;int&gt; X(m);
  for (int i = 0; i &lt; m; i++) {
    cin >> X[i];
  }

  // решение
  vector&lt;int&gt; res(m);
  sort(A.begin(), A.end());
  sort(B.begin(), B.end());

  for (int i = 0; i &lt; m; i++) {
    int x = X[i];
    int count1 = upper_bound(A.begin(), A.end(), x) - A.begin();
    int count2 = B.end() - lower_bound(B.begin(), B.end(), x);
    res[i] = count1 + count2;
  }

  // вывод результата
  for (int i = 0; i &lt; m; i++) {
    cout &lt;&lt; res[i] &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача I. Модифицированный НОД -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача I. Модифицированный НОД</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Что ж, вот еще одна математическая задача. Как известно, НОД — наибольший общий делитель. Найти НОД двух положительных целых чисел несложно.</p>

  <p>Общий делитель двух положительных чисел — это число на которое делятся оба этих числа.</p>

  <p>Но Вам дана более сложная задача. Требуется найти наибольший общий делитель d двух целых чисел a и b, принадлежащий отрезку целых чисел [low, high] (low ≤ high), то есть такой, что low ≤ d ≤ high.</p>

  <p>Может получиться, что в заданном отрезке нет общих делителей.</p>

  <p>Даны два целых числа a и b, далее следует n запросов. Каждый запрос — это некоторый отрезок [low, high]. Напишите программу, которая обработает все заданные запросы.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано два целых числа a и b, описанных выше (1 ≤ a, b ≤ 10<sup>9</sup>). Во второй строке содержится одно целое число n, количество запросов (1 ≤ n ≤ 10<sup>4</sup>). Далее следует n строк. Каждая строка содержит один запрос — два целых числа low и high (1 ≤ low ≤ high ≤ 10<sup>9</sup>).</p>

  <h4>Выходные данные</h4>
  <p>Выведите n строк, i-ая из них должна содержать ответ на i-ый запрос из входных данных. Если в данном отрезке общих делителей нет, выводите -1 в качестве ответа на запрос.</p>

  <details>
    <summary>Пример</summary>
<pre>
9 27
3
1 5
10 11
9 11
</pre>
<pre>
3
-1
9
</pre>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/75/problem/C" target="_blank">Задача 75C</a>
      <br><a href="https://codeforces.com/contest/75" target="_blank">Codeforces Beta Round 67 (Div. 2) 2011-04-13</a>
    </div>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

// наибольший общий делитель
long long gcd(long long a, long long b) {
  if (b == 0) {
    return a;
  } else {
    return gcd(b, a % b);
  }
}

int main() {
  // ввод данных
  long long a, b;
  cin >> a >> b;
  long long d = gcd(a, b);
  int t;
  cin >> t;

  // решение
  vector&lt;long long&gt; G;
  for (long long i = 1; i * i &lt;= d; i++) {
    if (d % i == 0) {
      G.push_back(i);
      if (d != i * i) {
        G.push_back(d / i);
      }
    }
  }
  sort(G.begin(), G.end());

  for (int test = 0; test &lt; t; test++) {
    int low, high;
    cin >> low >> high;
    int left = 0, right = G.size(), mid;
    while (right - left > 1) {
      mid = (left + right) / 2;
      if (G[mid] > high) {
        right = mid;
      } else {
        left = mid;
      }
    }


    // вывод результата
    if (G[left] >= low) {
      cout &lt;&lt; G[left] &lt;&lt; '\n';
    } else {
      cout &lt;&lt; "-1\n";
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача J. Коровам - колокольчиков -->
<article class="article">
  <div class="anchor" id="task10"></div>
  <h3>Задача J. Коровам - колокольчиков</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Кевин Сан хочет переместить свою драгоценную коллекцию из n колокольчиков (конечно же коровьих) из Мухоглинска в Эксетер, а там — представьте себе! — на полях растёт не кукуруза, а настоящая трава. Для переезда ему надо упаковать все свои колокольчики в k коробок фиксированного размера. Чтобы коллекция не пострадала в ходе перевозки, Кевин не собирается класть в одну коробку более двух колокольчиков. Так как Кевин хочет минимизировать расходы, требуется найти минимальный размер коробок, которые он может использовать для упаковки всей своей коллекции.</p>

  <p></p>Кевин — дотошный коллекционер, и он знает, что размер i-го колокольчика в его коллекции равен целому числу s<sub>i</sub>. Кевин хранит колокольчики упорядоченными, а именно s<sub>i-1</sub> ≤ s<sub>i</sub> для всех i > 1. Также Кевин великолепно упаковывает вещи, поэтому он может поместить один или два колокольчика в коробку размера s тогда и только тогда, когда сумма их размеров не превышает s. Используя информацию о коллекции Кевина, найдите минимальное s, такое что Кевин сможет упаковать все свои n колокольчиков в k коробок размера s.

  <h4>Входные данные</h4>
  <p>В первой строке входных данных находятся два числа n и k (1 ≤ n ≤ 2·k ≤ 100000), обозначающие количество колокольчиков и количество коробок соответственно.</p>

  <p>В следующей строке записано n целых чисел s<sub>1</sub>, s<sub>2</sub>, ..., s<sub>n</sub> (1 ≤ s<sub>i</sub> ≤ 1000000) — размеры колокольчиков в коллекции Кевина. Гарантируется, что s<sub>i</sub> следуют в порядке неубывания.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное целое число — минимальное s, такое что Кевин сможет упаковать все свои n колокольчиков в k коробок размера s.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
2 1
2 5
</pre>
    <code>7</code>
    <p>В первом примере Кевину придётся упаковать оба колокольчика в одну коробку.</p>

    <h4>Пример 2</h4>
<pre>
4 3
2 3 5 9
</pre>
    <code>9</code>
    <p>Во втором примере Кевин может упаковать колокольчики следующим образом: {2, 3}, {5} и {9}.</p>

    <h4>Пример 3</h4>
<pre>
3 2
3 5 7
</pre>
    <code>8</code>
    <p>В третьем примере оптимальное решение следующее: {3, 5} и {7}.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/604/problem/B" target="_blank">Задача 604B</a>
      <br><a href="https://codeforces.com/contest/604" target="_blank">Codeforces Round 334 (Div. 2) 2015-12-01</a>
    </div>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  int n, k;
  cin >> n >> k;
  vector&lt;int&gt; s(n);
  int max_s = 0;
  for (int i = 0; i &lt; n; i++) {
    cin >> s[i];
    max_s = max(max_s, s[i]);
  }

  // решение
  for (int i = 0; i &lt; n - k; i++) {
    max_s = max(max_s, s[i] + s[2 * (n - k) - 1 - i]);
  }

  // вывод результата
  cout &lt;&lt; max_s;
}
</pre>
  </details>
</article>


<!-- Задача K. Про таблицу умножения -->
<article class="article">
  <div class="anchor" id="task11"></div>
  <h3>Задача K. Про таблицу умножения</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Бизон-Чемпион не только обаятельный, но и очень умный.</p>

  <p>Пока одни учили обычную таблицу умножения, Бизон-Чемпион развлекался по-своему. Бизон-Чемпион рисовал таблицу умножения размера n x m, где элемент, стоящий на пересечении i-й строки и j-го столбца, равняется i·j (строки и столбцы таблицы нумеруются, начиная от единицы). Затем его спрашивали, какое число в этой таблице k-е по величине? Бизон-Чемпион отвечал всегда правильно и не задумываясь. Сможете ли вы повторить его успех?</p>

  <p>Рассмотрим описанную таблицу умножения. Если выписать все n·m чисел из этой таблицы в порядке неубывания, то число выписанное k-м называется k-м по величине.</p>

  <h4>Входные данные</h4>
  <p>В единственной строке содержатся целые числа n, m и k (1 ≤ n, m ≤ 5·10<sup>5</sup>; 1 ≤ k ≤ n·m).</p>

  <h4>Выходные данные</h4>
  <p>Выведите k-е по величине число в таблице умножения n x m.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>2 2 2</code>
    <code>2</code>

    <h4>Пример 2</h4>
    <code>2 3 4</code>
    <code>3</code>

    <h4>Пример 3</h4>
    <code>1 10 5</code>
    <code>5</code>

    <p>Таблица умножения 2 x 3 выглядит следующим образом:</p>
<pre>
1 2 3
2 4 6
</pre>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/448/problem/D" target="_blank">Задача 448D</a>
      <br><a href="https://codeforces.com/contest/448" target="_blank">Codeforces Round 256 (Div. 2) 2014-07-16</a>
    </div>

<pre>
#include &lt;iostream&gt;

using namespace std;

const int N = 1e6 + 6;

long long f(long long x, int n, int m) {
  long long res = 0;
  x--;
  for (int i = 1; i &lt;= n; i++) {
    res += min((long long)m, x / i);
  }

  return res;
}

int main() {
  // ввод данных
  int n, m;
  cin >> n >> m;
  long long k;
  cin >> k;

  // решение
  long long l = 1, r = 1LL * n * m + 1;

  while (l &lt; r) {
    long long x = (l + r) >> 1;

    if (f(x, n, m) &lt; k) {
      l = x + 1;
    } else {
      r = x;
    }
  }

  cout &lt;&lt; l - 1;
}
</pre>
  </details>
</article>


<!-- Задача L. Неквадратное уравнение -->
<article class="article">
  <div class="anchor" id="task12"></div>
  <h3>Задача L. Неквадратное уравнение</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Рассмотрим уравнение:</p>
  <code>x<sup>2</sup> + s(x)·x - n = 0,</code>

  <p>где x, n — целые положительные числа, s(x) — функция, равная сумме цифр числа x в десятичной системе счисления.</p>

  <p>Вам дано целое число n, найдите наименьший целый положительный корень уравнения x, или определите, что таких корней нет.</p>

  <h4>Входные данные</h4>
  <p>В единственной строке записано целое число n (1 ≤ n ≤ 10<sup>18</sup>) — параметр уравнения.</p>

  <p>Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.</p>

  <h4>Выходные данные</h4>
  <p>Выведите -1, если уравнение не имеет целых положительных корней. Иначе выведите такое наименьшее целое x (x > 0), что описанное в условии равенство выполняется.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>2</code>
    <code>1</code>
    <p>В первом тестовом примере x = 1 является наименьшим корнем. Так как s(1) = 1 и 1<sup>2</sup> + 1·1 - 2 = 0.</p>

    <h4>Пример 2</h4>
    <code>110</code>
    <code>10</code>
    <p>Во втором тестовом примере x = 10 является наименьшим корнем. Так как s(10) = 1 + 0 = 1 и 10<sup>2</sup> + 1·10 - 110 = 0.</p>

    <h4>Пример 3</h4>
    <code>4</code>
    <code>-1</code>
    <p>В третьем тестовом примере корней у уравнения нет.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/233/problem/B" target="_blank">Задача 233B</a>
      <br><a href="https://codeforces.com/contest/233" target="_blank">Codeforces Round 144 (Div. 2) 2012-10-11</a>
    </div>

<pre>
#include &lt;iostream&gt;
#include &lt;cmath&gt;

using namespace std;

long long sum(long long a) {
  long long c = 0;
  while (a > 0) {
    c += a % 10;
    a /= 10;
  }
  return c;
}

int main() {
  // ввод данных
  long long n;
  cin >> n;

  // решение
  long long r = (long long)sqrt(n);
  long long min_ans = -1;

  for (long long i = r - 100000; i &lt;= 100000 + r; i++) {
    long long x = i * i + sum(i) * i;
    if (x == n && i > 0) {
      min_ans = i;
      break;
    }
  }

  // вывод результата
  cout &lt;&lt; min_ans;
}
</pre>
  </details>
</article>


<!-- Задача M. Очередная задача на массиве -->
<article class="article">
  <div class="anchor" id="task13"></div>
  <h3>Задача M. Очередная задача на массиве</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Помимо теории чисел и строковых алгоритмов Профессор Ш. любит заниматься массивами, но не простыми, а отсортированными по неубыванию элементов. Сегодня Профессор Ш. придумал отличную задачу и делится её формулировкой с вами.</p>

  <p>Изначально имеется массив a, состоящий из N чисел, элементы которого расположены в порядке неубывания. К данному массиву можно применять запросы 2 типов:</p>
  <ol>
    <li>Сдвинуть массив циклически влево или вправо на k позиций.</li>
    <li>Проверить, есть ли в массиве число x. Если такое число есть, вывести его номер в массиве (возможно, измененном). Если число входит в массив несколько раз, следует вывести номер его первого вхождения в массив.</li>
  </ol>

  <p>Так как Профессор Ш. умеет работать только с отсортированными массивами, он не всегда умеет проверять, есть ли в массиве число x. Помогите Профессору – напишите программу, которая будет верно отвечать на запросы обоих типов.</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержится число N (1≤N≤2⋅10<sup>5</sup>) – количество элементов массива.</p>

  <p>Во второй строке содержатся N чисел a<sub>i</sub> (-10<sup>18</sup> ≤ a<sub>i</sub> ≤ 10<sup>18</sup>) – элементы массива a. Гарантируется, что изначально элементы массива отсортированы по неубыванию.</p>

  <p>В третьей строке содержится число Q (1 ≤ Q ≤ 3⋅10<sup>5</sup>) – количество запросов.</p>

  <p>В следующих Q строках содержатся запросы. Запросы задаются следующим образом:</p>
  <ol>
    <li>s k (1≤|k|&lt;N) – сдвинуть массив циклически на k позиций. Если число k отрицательное, то сдвиг осуществляется влево, в противном случае сдвиг должен быть осуществлён вправо.</li>
    <li>? x – проверить, есть ли в массиве число x.</li>
  </ol>

  <h4>Выходные данные</h4>
  <p>Для каждого запроса вида «? x» выведите в отдельной строке число – номер числа x в массиве. Если числа x в масиве нет, в отдельной строке выведите «-1». Считается, что элементы массива нумеруются с 1
  .</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
7
1 2 3 4 5 6 7
7
? 9
s 2
? 4
s -2
? 3
s -5
? 6
</pre>
<pre>
-1
6
3
1
</pre>

    <h4>Пример 2</h4>
<pre>
7
1 1 2 2 3 3 4
7
? 9
s 2
? 4
s -1
? 2
s -5
? 1
</pre>
<pre>
-1
2
4
4
</pre>
    <p>Рассмотрим первый пример.</p>
    <p>Изначально массив a=[1,2,3,4,5,6,7].</p>
    <ol>
      <li>Так как число 9 больше любого элемента массива a, выведем -1.</li>
      <li>После запроса s 2 нужно сдвинуть массив вправо на 2 позиции, он станет равен [6,7,1,2,3,4,5].</li>
      <li>Число 4 находится на позиции 6, поэтому выводим 6.</li>
      <li>После запроса s -2 массив примет исходный вид [1,2,3,4,5,6,7]</li>
      <li>Число 3 находится на позиции 3, поэтому выводим 3</li>
      <li>После запроса s -5 массив сдвигается на 5 позиций влево: [6,7,1,2,3,4,5]</li>
      <li>Число 6 находится на позиции 1, поэтому выводим 1.</li>
    </ol>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/gym/104454/problem/N" target="_blank">Задача N</a>
      <br><a href="https://codeforces.com/gym/104454" target="_blank">ICPC Central Russia Regional Contest, 2021</a>
    </div>

    <h4>Пример 3</h4>
<pre>
7
1 1 2 2 3 3 4
2
s -1
? 1
</pre>
<pre>
1
</pre>

    <p>Offset мы будем отслеживать по запросам.</p>
    <p>Для бинарного поиска первого и последнего вхождения будем использовать две функции goodFirst и goodLast. Функция goodFirst для поиска первого вхождения делит массив A на две части. Плохая часть для всех элементов меньше target и хорошая часть для всех элементов больше или равно target. Ответ будет в правом указателе. Функция goodLast для поиска последнего вхождения делит массив A на две части. Плохая часть для всех элементов больше target и хорошая часть для всех элементов меньше или равно target. Ответ будет в левом указателе.</p>
<pre>
bool goodFirst(vector&lt;long long&gt;& A, int i, long long target) {
  return A[i] >= target;
}
</pre>
<pre>
bool goodLast(vector&lt;long long&gt;& A, int i, long long target) {
  return A[i] &lt;= target;
}
</pre>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

bool goodFirst(vector&lt;long long&gt;& A, int i, long long target) {
  return A[i] >= target;
}

bool goodLast(vector&lt;long long&gt;& A, int i, long long target) {
  return A[i] &lt;= target;
}

int main() {
  // ускорение ввода и вывода
  ios::sync_with_stdio(0);
  cin.tie(0);
  cout.tie(0);

  // ввод данных
  int N;
  cin >> N;
  vector&lt;long long&gt; a(N);
  for (int i = 0; i &lt; N; ++i) {
    cin >> a[i];
  }
  int Q;
  cin >> Q;

  // решение
  int offset = 0;

  // принимаем запросы
  while (Q--) {
    char type; // тип запроса
    cin >> type;

    // запрос на сдвиг массива
    if (type == 's') {
      int k; // сдвиг на k позиций
      cin >> k;
      offset += k;
      offset = ((offset % N) + N) % N;
      //cout &lt;&lt; "offset " &lt;&lt; offset &lt;&lt; '\n';

    // запрос на бинарный поиск
    } else if (type == '?') {
      long long x; // искомое число
      cin >> x;

      int res = -1;
      // ответ будет в правом указателе
      int left1 = -1;   // за границами массива
      int right1 = N - 1;  // на последнем элементе массива
      int pos1 = -1;

      // бинарный поиск первого вхождения
      while (right1 - left1 > 1) {
        int mid = (left1 + right1) / 2;

        if (goodFirst(a, mid, x)) {
          right1 = mid;
        } else {
          left1 = mid;
        }
      }
      pos1 = (a[right1] == x) ? (right1 + offset) % N : -1;

      // ответ будет в левом указателе
      int left2 = 0;   // на первом элементе массива
      int right2 = N;  // за границами массива
      int pos2 = -1;

      // бинарный поиск последнего вхождения
      while (right2 - left2 > 1) {
        int mid = (left2 + right2) / 2;

        if (goodLast(a, mid, x)) {
          left2 = mid;
        } else {
          right2 = mid;
        }
      }
      pos2 = (a[left2] == x) ? (left2 + offset) % N : -1;

      if (pos1 > pos2) {
        res = 0;
      } else {
        res = pos1;
      }

      // вывод результата
      if (res != -1) {
        cout &lt;&lt; res + 1 &lt;&lt; '\n';
      } else {
        cout &lt;&lt; -1 &lt;&lt; '\n';
      }
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача N. Запросы на поедание конфет -->
<article class="article">
  <div class="anchor" id="task14"></div>
  <h3>Задача N. Запросы на поедание конфет</h3>

  <div><i>Ограничение по времени 3.5с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У Тимура есть n конфет. В i-й конфете количество сахара равно a<sub>i</sub>. Так, съев i-ю конфету, Тимур потребляет количество сахара, равное a<sub>i</sub>.</p>

  <p>Тимур задаст вам q запросов о своих конфетах. Для j-го запроса вы должны ответить, какое минимальное количество конфет ему нужно съесть, чтобы потребить количество сахара, большее или равное x<sub>j</sub>. Выведите -1, если невозможно получить такое количество. Другими словами, нужно вывести минимально возможное k такое, что, съев k конфет, Тимур получит количество сахара не менее x<sub>j</sub>, или сказать, что такого k не существует.</p>

  <p>Обратите внимание, что он не может съесть одну и ту же конфету дважды, а запросы не зависят друг от друга (Тимур может использовать одну и ту же конфету в разных запросах).</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит единственное целое число t (1≤t≤1000)  — количество наборов входных данных. Далее следуют описания наборов.</p>

  <p>Первая строка каждого набора содержит 2 целых числа n и q
  (1≤n,q≤1.5⋅10<sup>5</sup>) — количество конфет, которые есть у Тимура и количество запросов соответственно.</p>

  <p>Вторая строка каждого набора содержит n целых чисел a<sub>1</sub>,a<sub>2</sub>,…,a<sub>n</sub> (1≤a<sub>i</sub>≤10<sup>4</sup>) — количество сахара в каждой конфете соответственно.</p>

  <p>Затем следуют q строк.</p>

  <p>Каждая из q содержит единственное целое число x<sub>j</sub> (1≤x<sub>j</sub>≤2⋅10<sup>9</sup>) — количество сахара, которое хочет получить Тимур.</p>

  <p>Гарантируется, что сумма n и сумма q по всем наборам входных данных не превосходит 1.5⋅10<sup>5</sup>.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите q строк. В j-й строке выведите количество конфет, которое нужно съесть Тимуру, чтобы получить количество сахара, большее или равное x<sub>j</sub>. Выведите -1, если получить такое количество невозможно.</p>

  <details>
    <summary>Пример</summary>
<pre>
3
8 7
4 3 3 1 1 4 5 9
1
10
50
14
15
22
30
4 1
1 2 3 4
3
1 2
5
4
6
</pre>
<pre>
1
2
-1
2
3
4
8
1
1
-1
</pre>
    <p>В первом наборе входных данных примера:</p>
    <ul>
      <li>В первом запросе Тимур может съесть любую конфету, и он наберет нужное количество.</li>
      <li>Во втором запросе Тимур может получить количество не менее 10, съев 7-ю и 8-ю конфету, таким образом потребив количество сахара, равное 14.</li>
      <li>На третий запрос нет возможного ответа.</li>
      <li>В четвертом запросе Тимур может получить количество как минимум 14, съев 7-ю и 8-ю конфету, таким образом потребив количество сахара, равное 14.</li>
    </ul>

    <p>Во втором наборе входных данных примера:</p>
    <ul>
      <li>Для единственного запроса второго набора входных данных мы можем выбрать третью конфету, из которой Тимур получает количество сахара равное 3. Также можно получить тот же ответ, выбрав четвертую конфету.</li>
    </ul>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1676/problem/E" target="_blank">Задача 1676E</a>
      <br><a href="https://codeforces.com/contest/1676" target="_blank">Codeforces Round 790 (Div. 4) 2022-05-10</a>
    </div>

    <p>Создадим префикс-функцию идя по массиву в убывающем порядке</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ускорение ввода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n, q;
    cin >> n >> q;
    vector&lt;int&gt; A(n + 1);
    for (int i = 0; i &lt; n; i++) {
      cin >> A[i];
    }

    // решение
    sort(A.begin(), A.end());
    int uk = n;
    vector&lt;int&gt; Pref(n + 1);
    for (int i = 1; i &lt;= n; i++) {
      Pref[i] = Pref[i - 1] + A[uk];
      uk--;
    }

    int x, left, right, mid;
    for (int i = 0; i &lt; q; i++) {
      cin >> x;
      left = 0;
      right = n + 1;

      while (right - left > 1) {
        mid = (right + left) / 2;
        if (Pref[mid] &lt;= x) {
          left = mid;
        } else {
          right = mid;
        }
      }

      // вывод результата
      if (Pref[Pref.size() - 1] &lt; x) {
        cout &lt;&lt; "-1\n";
      } else if (Pref[left] >= x) {
        cout &lt;&lt; left &lt;&lt; "\n";
      } else {
        cout &lt;&lt; right &lt;&lt; "\n";
      }
    }
  }
}
</pre>
  </details>
</article>

