<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contests" target="_blank">Codeforces ЯрГУ. Школьники</a></p>
  <p><a href="https://vk.com/sportprog_yarsu" target="_blank">vk.com/sportprog_yarsu</a></p>
  <p><a href="https://vkvideo.ru/@sportprog_yarsu" target="_blank">vkvideo.ru/@sportprog_yarsu</a></p>
</article>


<article class="article">
  <h1>Занятие 5. Основы С++ #4. string</h1>
  <p>Конспект видео от 2024.10.12</p>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contest/557609" target="_blank">Codeforces Контест 557609</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
        <a href="#p1">string</a>
    <br><a href="#p2">Функции на символы</a>
    <br><a href="#p3">getline()</a>
  </p>
  <p>
        <a href="#task1">Задача A. Капитализация слова</a>
    <br><a href="#task2">Задача B. икортС</a>
    <br><a href="#task3">Задача C. Палиндром</a>
    <br><a href="#task4">Задача D. Слишком длинные слова</a>
    <br><a href="#task5">Задача E. Число вхождений</a>
    <br><a href="#task6">Задача F. Девушка или Юноша</a>
    <br><a href="#task7">Задача G. Панграмма</a>
    <br><a href="#task8">Задача H. Два массива и обмены</a>
    <br><a href="#task9">Задача I. Ночь в музее</a>
    <br><a href="#task10">Задача J. Дежавю</a>
    <br><a href="#task11">Задача K. Не просто красивые строки</a>
    <br><a href="#task12">Задача L. Пароли</a>
    <br><a href="#task13">Задача M. Подделка</a>
    <br><a href="#task14">Задача N. Чудесная раскраска - 1</a>
    <br><a href="#task15">Задача O. Интересный рассказ</a>
    <br><a href="#task16">Задача P. Самые похожие слова</a>
    <br><a href="#task17">Задача Q. Удали два символа</a>
  </p>
</article>


<!-- string -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>string</h3>

  <p>Подключим библиотеку</p>
  <code>#include &lt;string&gt;</code>

  <p><strong>string</strong> - это более удобная альтернатива строкам в стиле С, которую можно использовать в C++. Внутреннее устройство string похоже на вектор символов, мы можем изменять строку и ее размер.</p>
<pre>
string str1;                // пустая
string str2 = "123";        // строка 123
string str3 = str2 + "abc"; // строка 123abc
string str4("new str");     // строка new str
</pre>
  <code>cin >> str1;</code>

  <p>Создадим две строки</p>
  <code>string s1 = "abb";</code>
  <code>string s2 = "abc";</code>
  <p>Строки можно сравнить между собой</p>
  <code>"abc" > "abb";</code>
  <code>"123" &lt; "12";</code>

  <p>Строки можно объединять</p>
  <code>string s3 = s1 + s2;</code>
  <code>"abc" + "123"; // "abc123"</code>

  <p><strong>Подстрока</strong> это любое количество соседних символов строки.</p>
  <p><strong>Префикс</strong> это подстрока, содержащая первый символ.</p>
  <p><strong>Суффикс</strong> это подстрока , содержащая последний символ.</p>
  <p><strong>Палиндром</strong> - это строка, которая имеет одинаковые символы если ее читать с начала и с конца.</p>
  <p>Обращаться к отдельным символам в строке можно как к элементам массива
  <code>char c = str1[0]; // вернет первый символ строки</code>
  <p>Подстрока - это непрерывная последовательность символов внутри строки.</p>
  <p>Префикс - это непрерывная последовательность символов внутри строки в которой есть первый символ строки.</p>
  <p>Суффикс -  это непрерывная последовательность символов внутри строки, в которой есть последний символ строки.</p>
  <p>Вхождение строки — это подстрока в строке str1, которая полностью совпадает со строкой str2.</p>

  <ol>
    <li><strong>.size()</strong> возвращает размер строки;</li>
    <li><strong>.push_back(char)</strong> добавляет один символ в конец строки;</li>
    <li><strong>.pop_back()</strong> удаляет один символ в конце строки;</li>
    <li><strong>.empty()</strong> проверка на пустоту;</li>
    <li><strong>.back()</strong> возвращает значение последнего символа в строке;</li>
    <li><strong>.front()</strong> возвращает значение первого символа в строке;</li>
    <li><strong>.begin()</strong> возвращает итератор на первый элемент строки;</li>
    <li><strong>.end()</strong> возвращает итератор за последним элементом строки.</li>
    <li><strong>sort(str.begin(), str.end())</strong> сортирует символы в строке.</li>
    <li><strong>.append(str)</strong> добавить в конце строки строку str;</li>
    <li><strong>.substr(pos)</strong> возвращает подстроку с определенной позиции и до конца;</li>
    <li><strong>.substr(pos, count)</strong> возвращает подстроку длины count с позиции pos;</li>
    <li><strong>.resize(size)</strong> изменяет размер строки;</li>
    <li><strong>.find(str)</strong> находит позицию первого вхождения подстроки;</li>
    <li><strong>.rfind(str)</strong> находит позицию последнего вхождения подстроки;</li>
    <li><strong>.insert(pos, str)</strong> вставляет str в строку в позицию pos;</li>
    <li><strong>.erase(pos, count)</strong> удаляет из строки с позиции pos count символов.</li>
  </ol>

  <h4>.append(str) .resize(count)</h4>
<pre>
string str1 = "123";
string str2 = "abc";
str1.append(str2);  // 123abc
</pre>
  <p>Методом append() мы добавили в конец строки str1 строку str2.</p>

<pre>
string str1 = "abcdabc123abcfd";
str1.resize(5);
str1.resize(25);
</pre>
  <p>.resize(5) изменил длину строки до размера 5, отбросив лишние символы.</p>
  <p>.resize(25) дополнил строку символами '\0' до длины 25.</p>

  <h4>.substr()</h4>
<pre>
string str1 = "abcdabc123abcfd";
string str2 = str1.substr(3);    // dabc123abcfd
string str3 = str1.substr(3, 5); // dabc1
</pre>
  <p>str1.substr(3) выделил подстроку в строке str1 с позиции до ее окончания, после чего результат был присвоен в строку str2.</p>
  <p>str1.substr(3, 5) выделил подстроку длины 5 в строке str1, после чего результат был присвоен в строку str2.</p>

  <h4>.find() .rfind()</h4>
<pre>
string str1 = "abcdabc123abcfd";
string str2 = "abc";
int pos1 = str1.find(str2);  // 0
int pos2 = str1.rfind(str2); // 10
</pre>
  <p>В строке "abcdabc123abcfd", есть 3 позиции вхождения подстроки "abc".</p>
  <p>Методы find и rfind - поиск подстроки в строке, очень медленные. Они работают за O(N²). Для поиска они используют цикл в цикле. Перебирают первую строку и для каждого символа первой строки перебирают вторую строку.</p>
  <p>В спортивном программировании есть более быстрые методы: КМП (Кнута-Мориса-Прата) и Z-функция. Они работают за O(N).</p>

  <h4>.insert() .erase()</h4>
<pre>
string str1 = "abcdefgh";
string str2 = "123";
str1.insert(4, str2);  // abcd123efgh
str1.erase(6, 2);      // abcd12fgh
</pre>

  <h4>Конкатенация</h4>
  <p>Конкатенация строк — операция объединения двух или более строк для создания одной новой строки.</p>
  <p>Для конкатенации двух строк используется знак +.</p>
  <p>Пример: "значение1" + "значение2".</p>
<pre>
string str1 = "abcd";
string str2 = "1234";
string str3 = str1 + str2;
str1 += str2;
</pre>

  <h4>Сравнения</h4>
  <p>К строкам в языке С++ можно применять операции сравнения.</p>
  <code>&gt; >= &lt; &lt;= == !=</code>
  <p>Эти операции сравнивают два объекта string. Во всех операциях операнды сравниваются посимвольно до тех пор, пока не будет найдена пара соответствующих символов, которые содержат разные символы, или пока не будет достигнут конец одного или обоих операндов.</p>
<pre>
int n;
cin >> n;
vector&lt;string&gt; Arrstr(n);
for (int i = 0; i &lt; n; i++) {
  cin >> Arrstr[i];
}
sort(Arrstr.begin(), Arrstr.end());
</pre>

  <h4>Переводы из числа в строку и обратно</h4>
  <p><strong>stoi(str)</strong> принимает строку в качестве параметра и возвращает её значение в виде целого числа.</p>
<pre>
string s = "135";
int number = stoi(s);
cout &lt;&lt; number;
</pre>

  <p><strong>to_string(num)</strong> принимает число любого типа и возвращает его в виде строки.</p>
<pre>
int num = 135;
string res = to_string(num);
</pre>
</article>


<!-- Функции на символы -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>Функции на символы</h3>

  <ol>
    <li><strong>islower(c)</strong> проверяет, является ли c буквой нижнего регистра, по умолчанию от 'a' до 'z';</li>
    <li><strong>isupper(c)</strong> проверяет, является ли c буквой верхнего регистра;</li>
    <li><strong>isalpha(c)</strong> проверяет, является ли c алфавитным символом;</li>
    <li><strong>isdigit(c)</strong> проверяет, является ли c цифрой от '0' до '9';</li>
    <li><strong>isalnum(c)</strong> проверяет, является ли c алфавитно-цифровым символом;</li>
    <li><strong>tolower(c)</strong> возвращает символ c в нижнем регистре;</li>
    <li><strong>toupper(c)</strong> возвращает символ c в верхнем регистре.</li>
  </ol>
</article>


<!-- getline() -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>getline()</h3>

  <p>Функция cin считывает не всю строку, а только до первого пробельного символа. Пробельные символы ' ', '\t', '\n' нельзя считать функцией cin.</p>
  <code>string str1; // первый способ</code>
  <code>cin >> str1; // считывает до пробельного символа</code>
  <p>Строку содержащую пробельные символы надо считывать фуркцией getline</p>
  <p>Функция getline считывает всю строку до символа '\n'.</p>
  <p>Она позволяет считывать строки, включая пробелы, и сохранять их в переменных типа string.</p>
  <p>Первым аргументов функция getline принимает объект cin для считывания из входного потока. Кроме входного потока, можно считывать из файла, если первым аргументом будет указатель на файл.</p>
  <p>Вторым аргументом функция getline принимает имя строки, куда нужно записать считанную строку.</p>
  <code>getline(cin, str1); // считывает до '\n'</code>
  <p>Третий аргумент необязательный. Он указывает символ-разделитель. Если указан символ-разделитель, то функция getline будет считывать не до конца строки, а до символа-разделителя. Если требуется больше одного символа-разделителя, то их можно перечислять в двойных кавычках.</p>
  <code>string str2; // второй способ</code>
  <code>getline(cin, str2, ':'); // считывает до символа ':'</code>

  <p>Если нужно считать заданное число символов, например 256</p>
  <code>string str3; // третий способ</code>
  <code>cin.getline(str3, 256, ':');</code>
</article>


<!-- Задача A. Капитализация слова -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Капитализация слова</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Капитализация — это запись слова, в которой первая буква слова записывается как прописная буква. Ваша задача, вывести капитализацию заданного слова.</p>

  <p>Обратите внимание, что в капитализации все буквы слова кроме первой остаются не измененными.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано непустое слово. Слово состоит из строчных и прописных букв латинского алфавита. Длина заданного слова не превосходит 10³ букв.</p>

  <h4>Выходные данные</h4>
  <p>Выведите капитализацию слова.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>ApPLe</code>
    <code>ApPLe</code>

    <h4>Пример 2</h4>
    <code>konjac</code>
    <code>Konjac</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/281/problem/A" target="_blank">Задача 281A</a>
      <br><a href="https://codeforces.com/contest/281" target="_blank">Codeforces Round 172 (Div. 2) 2013-03-05</a>
    </div>

<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main() {
  // ввод данных
  string s;
  cin >> s;

  // решение
  s[0] = toupper(s[0]);

  // вывод результата
  cout &lt;&lt; s;
}
</pre>
  </details>
</article>


<!-- Задача B. икортС -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. икортС</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам дана строка S. Выведите реверс этой строки.</p>

  <p>Реверсом строки, называется строка которая получается при чтении исходной строки справа налево.</p>

  <p>Более формально, если S=s₁s₂...sₙ, то ее реверс это строка sₙsₙ₋₁...s₂s₁</p>
  <p>Просьба, в учебных целях, составьте строку в которой лежит реверс исходной и выведите его на экран, а не просто вывести строку справа налево с помощью цикла</p>

  <h4>Входные данные</h4>
  <p>Вводится строка S.</p>

  <h4>Выходные данные</h4>
  <p>Выведите реверс строки S</p>

  <details>
    <summary>Пример</summary>
    <code>hello</code>
    <code>olleh</code>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  string s;
  cin >> s;

  // решение
  string t;
  int si = s.size() - 1;
  for (int i = si; i >= 0; i--) {
    t.push_back(s[i]);
  }

  // вывод результата
  cout &lt;&lt; t;
}
</pre>
  </details>
</article>


<!-- Задача C. Палиндром -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Палиндром</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам дана строка S. Ваша задача определить, является ли она палиндромом.</p>

  <p>Палиндромом называется строка, которая читается одинаково в обе стороны.</p>

  <h4>Входные данные</h4>
  <p>Вводится строка S.</p>

  <h4>Выходные данные</h4>
  <p>Выведите Yes если введённая строка палиндром, иначе выведите No.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>abacaba</code>
    <code>Yes</code>

    <h4>Пример 2</h4>
    <code>abacada</code>
    <code>No</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Заведем два указателя. p1 на начало строки, p2 на конец строки. Будем сравнивать символы строки и сдвигать указатели друг к другу.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  string s;
  cin >> s;

  // решение
  int p1 = 0;
  int p2 = s.size() - 1;
  int si = s.size() - 1;
  string pal = "Yes";
  while (p2 > p1) {
    if (s[p1] != s[p2]) {
      pal = "No";
    }
    p1++;
    p2--;
  }

  // вывод результата
  cout &lt;&lt; pal;
}
</pre>
  </details>
</article>


<!-- Задача D. Слишком длинные слова -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Слишком длинные слова</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Иногда некоторые слова вроде «localization» или «internationalization» настолько длинны, что их весьма утомительно писать много раз в каком либо тексте.</p>

  <p>Будем считать слово слишком длинным, если его длина строго больше 10 символов. Все слишком длинные слова можно заменить специальной аббревиатурой.</p>

  <p>Эта аббревиатура строится следующим образом: записывается первая и последняя буква слова, а между ними — количество букв между первой и последней буквой (в десятичной системе счисления и без ведущих нулей).</p>

  <p>Таком образом, «localization» запишется как «l10n», а «internationalization» как «i18n».</p>

  <p>Вам предлагается автоматизировать процесс замены слов на аббревиатуры. При этом все слишком длинные слова должны быть заменены аббревиатурой, а слова, не являющиеся слишком длинными, должны остаться без изменений.</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержится целое число n (1 ≤ n ≤ 100). В каждой из последующих n строк содержится по одному слову. Все слова состоят из малых латинских букв и имеют длину от 1 до 100 символов.</p>

  <h4>Выходные данные</h4>
  <p>Выведите n строк. В i строке должен находиться результат замены i-го слова из входных данных.</p>

  <details>
    <summary>Пример</summary>
<pre>
4
word
localization
internationalization
pneumonoultramicroscopicsilicovolcanoconiosis
</pre>
<pre>
word
l10n
i18n
p43s
</pre>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/71/problem/A" target="_blank">Задача 71A</a>
      <br><a href="https://codeforces.com/contest/71" target="_blank">Codeforces Beta Round 65 (Div. 2) 2011-03-29</a>
    </div>

<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;

  // решение
  for (int i = 0; i &lt; n; i++) {
    string s;
    string t;
    cin >> s;
    if (s.size() > 10) {
      t = s[0] + to_string(s.size() - 2) + s[s.size() - 1];
      cout &lt;&lt; t &lt;&lt; '\n';
    } else {
      cout &lt;&lt; s &lt;&lt; '\n';
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача E. Число вхождений -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Число вхождений</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам даны строки S и T. Подсчитайте, пожалуйста, число вхождений строки T в строку S.</p>

  <h4>Входные данные</h4>
  <p>Вводятся 2 строки S и T.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное число — число вхождений строки T в строку S.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
abacaba
aba
</pre>
    <code>2</code>

  <h4>Пример 2</h4>
<pre>
ababaaba
aba
</pre>
    <code>3</code>

    <h4>Пример 3</h4>
<pre>
lolkekcheburek
keke
</pre>
    <code>0</code>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main() {
  // ввод данных
  string s, t;
  cin >> s >> t;

  // решение
  int res = 0;
  while (s.find(t) != string::npos) {
    res++;
    s = s.substr(s.find(t) + 1);
  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача F. Девушка или Юноша -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Девушка или Юноша</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В наши дни очень много парней ставят себе фотографии красивых девушек на аватарки на форумах. Из-за этого очень часто сложно определить пол пользователя на форуме. В прошлом году наш герой пообщался в чате на форуме с одной красоткой (как он думал). После этого наш герой и предполагаемая красотка стали общаться еще чаще и в конце концов стали парой в сети.</p>
  <p>Но вчера наш герой захотел увидеть свою красотку в реальной жизни и, каково же было его удивление, когда красоткой оказался здоровенный мужчина! Наш герой очень расстроился и теперь он, наверное, никогда больше не сможет полюбить. Сейчас к нему пришла в голову идея, как по имени пользователя определить его пол.</p>
  <p>Вот его метод: если количество различных символов в имени пользователя нечетное, тогда пользователь мужского пола, иначе — женского. Вам дана строка, обозначающая имя пользователя, помогите нашему герою определить по ней пол пользователя по описанному методу.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записана непустая строка, состоящая только из строчных букв латинского алфавита — имя пользователя. Эта строка состоит из не более чем 100 букв.</p>

  <h4>Выходные данные</h4>
  <p>Если пользователь оказался женского пола по методу нашего героя, выведите «CHAT WITH HER!» (без кавычек), иначе, выведите «IGNORE HIM!» (без кавычек).</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>wjmzbmr</code>
    <code>CHAT WITH HER!</code>
    <p>Рассмотрим первый тестовый пример. В этом примере в имени пользователя «wjmzbmr» 6 различных символов. Это символы: «w», «j», «m», «z», «b», «r». Таким образом по методу нашего героя «wjmzbmr» женского пола, то есть надо вывести «CHAT WITH HER!».</p>

    <h4>Пример 2</h4>
    <code>xiaodao</code>
    <code>IGNORE HIM!</code>

    <h4>Пример 3</h4>
    <code>sevenkplus</code>
    <code>CHAT WITH HER!</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/236/problem/A" target="_blank">Задача 236A</a>
      <br><a href="https://codeforces.com/contest/236" target="_blank">Codeforces Round 146 (Div. 2) 2012-10-20</a>
    </div>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

using namespace std;

int main() {
  // ввод данных
  string s;
  cin >> s;

  // решение
  vector&lt;int&gt; A(500);
  for (int i = 0; i &lt; s.size(); i++) {
    int tmp = s[i];
    A[tmp] = 1;
  }
  int res = 0;
  for (int i = 0; i &lt; 500; i++) {
    res += A[i];
  }

  // вывод результата
  if (res % 2 == 0) {
    cout &lt;&lt; "CHAT WITH HER!";
  }
  else {
    cout &lt;&lt; "IGNORE HIM!";
  }
}
</pre>
  </details>
</article>


<!-- Задача G. Панграмма -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Панграмма</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Слово или предложение на некотором языке называется панграммой, если в нем встречаются все символы алфавита этого языка хотя бы один раз. Панграммы часто используют в типографии для демонстрации шрифтов или тестирования средств вывода различных устройств.</p>

  <p>Вам дана строка, состоящая из маленьких и больших латинских букв. Проверьте, является ли эта строка панграммой. Считается, что строка содержит букву латинского алфавита, если эта буква встречается в верхнем или нижнем регистре.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано одно целое число n (1 ≤ n ≤ 100) — количество символов в строке.</p>

  <p>Во второй строке записана сама строка. Строка содержит исключительно строчные и заглавные латинские буквы.</p>

  <h4>Выходные данные</h4>
  <p>Выведите «YES», если строка является панграммой, и «NO» в противном случае.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
12
toosmallword
</pre>
    <code>NO</code>

    <h4>Пример 2</h4>
<pre>
35
TheQuickBrownFoxJumpsOverTheLazyDog
</pre>
    <code>YES</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/520/problem/A" target="_blank">Задача 520A</a>
      <br><a href="https://codeforces.com/contest/520" target="_blank">Codeforces Round 295 (Div. 2) 2015-03-02</a>
    </div>

    <p>Переведем символы строки в нижний регистр и запишем в вектор. Сделаем сортировку векторов. Буквы будут соседние если разница между ними равна 1. Посчитаем число букв в векторе. Если ровно 26, то это панграмма</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;
  string s;
  cin >> s;

  // решение
  string res = "NO";
  vector&lt;char&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    A[i] = tolower(s[i]);
  }
  sort(A.begin(), A.end());
  int count = 0;
  for (int i = 1; i &lt; n; i++) {
    if (A[i] - A[i - 1] == 1) {
      count++;
    }
  }
  if (count == 25) {
    res = "YES";
  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача H. Два массива и обмены -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Два массива и обмены</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам даны два массива a и b, оба состоят из n положительных (больших нуля) целых чисел. Также вам задано число k.</p>

  <p>За один ход вы можете выбрать два индекса i и j (1 ≤ i,j ≤ n) и поменять местами a<sub>i</sub> и b<sub>j</sub> (i.e. a<sub>i</sub> становится b<sub>j</sub> и наоборот). Заметьте, что i и j могут совпадать или отличаться (в частности, обмен a₂ с b₂ или обмен a₃ с b₉ оба считаются приемлемыми ходами).</p>

  <p>Ваша задача — назвать максимальную возможную сумму, которую вы можете получить в массиве a, если вы сделаете не более k таких ходов (обменов).</p>

  <p>Вам нужно ответить на t независимых наборов тестовых данных.</p>

  <h4>Входные данные</h4>
  <p>Первая строка теста содержит одно целое число t (1 ≤ t ≤ 200) — количество наборов тестовых данных. Затем следуют t наборов тестовых данных.</p>

  <p>Первая строка набора тестовых данных содержит два целых числа n и k (1 ≤ n ≤ 30;0 ≤ k ≤ n) — количество элементов в a и b и максимальное количество ходов, которое вы можете сделать. Вторая строка набора тестовых данных содержит n целых чисел a₁, a₂, ... , aₙ (1 ≤ aᵢ ≤ 30), где aᵢ — это i-й элемент в a. Третья строка набора тестовых данных содержит n целых чисел b₁, b₂, ... , bₙ (1 ≤ bᵢ ≤ 30), где bᵢ — это i-й элемент в b.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора тестовых данных выведите ответ на него — максимальную возможную сумму, которую вы можете получить в массиве a, если вы можете совершить не более k обменов.</p>

  <details>
    <summary>Пример</summary>
<pre>
5
2 1
1 2
3 4
5 5
5 5 6 6 5
1 2 5 4 3
5 3
1 2 3 4 5
10 9 10 10 9
4 0
2 2 4 3
2 4 2 3
4 4
1 2 2 1
4 4 5 4
</pre>
<pre>
6
27
39
11
17
</pre>
    <p>В первом наборе тестовых данных примера вы можете поменять местами a₁=1 и b₂=4 и тогда получите a=[4,2] и b=[3,1].</p>
    <p>Во втором наборе тестовых данных примера вам не нужно ничего менять.</p>
    <p>В третьем наборе тестовых данных примера вы можете поменять местами a₁=1 и b₁=10, a₃=3 и b₃=10 и a₂=2 и b₄=10, и получить a=[10,10,10,4,5] и b=[1,9,3,2,9].</p>
    <p>В четвертом наборе тестовых данных примера вы не можете ничего поменять.</p>
    <p>В пятом наборе тестовых данных примера вы можете поменять местами массивы a и b и получить a=[4,4,5,4] и b=[1,2,2,1].</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1353/problem/B" target="_blank">Задача 1353B</a>
      <br><a href="https://codeforces.com/contest/1353" target="_blank">Codeforces Round 642 (Div. 3) 2020-05-13</a>
    </div>

    <p>Отсортировать два массива. В цикле от 0 до k менять местами меньшие элементы массива A с большими элементами массива B если они больше.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n, k;
    cin >> n >> k;
    vector&lt;int&gt; A(n);
    vector&lt;int&gt; B(n);
    for (int i = 0; i &lt; n; i++) {
      cin >> A[i];
    }
    for (int i = 0; i &lt; n; i++) {
      cin >> B[i];
    }

    // решение
    sort(A.begin(), A.end());
    sort(B.begin(), B.end());
    for (int i = 0; i &lt; k; i++) {
      if (B[n - 1 - i] > A[i]) {
        A[i] = B[n - 1 - i];
      }
    }
    int res = 0;
    for (int i = 0; i &lt; n; i++) {
      res += A[i];
    }

    // вывод результата
    cout &lt;&lt; res &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача I. Ночь в музее -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача I. Ночь в музее</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Гриша, подобно персонажу известной кинокомедии, нашел себе ночную работу в музее естественной истории. В первую же смену ему выдали его главное орудие труда — эмбоссер — и приказали провести инвентаризацию всей экспозиции.</p>

  <p>Эмбоссер представляет собой устройство для «печати» текста на пластиковой ленте. Текст набирается последовательно, буква за буквой. В устройство входят колесо с нанесёнными по кругу строчными буквами английского алфавита, неподвижная засечка, которая указывает на текущую букву, и кнопка, печатающая выбранную букву. За одно действие можно повернуть колесо с алфавитом на одну букву влево либо вправо по циклу. Изначально засечка эмбоссера указывает на букву a. Остальные буквы расположены так, как показано на рисунке.</p>
<pre>
            pos 0
              |
            z a
        y         b
      x              c
    w                  d
  v                      e
 u                        f
t                          g
 s                        h
  r                      i
    q                  j
      p               k
        o          l
            n  m
</pre>
  <p>После внесения предмета в базу Гриша должен с помощью эмбоссера выдавить на пластиковой ленте название и прикрепить его к экспонату. Возвращать колесо обратно в позицию, соответствующую букве a, не требуется.</p>

  <p>Наш герой боится, что некоторые особо устрашающие экспонаты могут ожить и начать за ним свою охоту, поэтому он хочет как можно быстрее напечатать все названия. Помогите ему: для данного названия экспоната определите минимальное количество поворотов колеса, необходимое для его печати.</p>

  <h4>Входные данные</h4>
  <p>Единственная строка входных данных содержит название экспоната — строку, состоящую из не менее, чем одного, и не более, чем ста символов. Гарантируется, что строка состоит из строчных букв английского алфавита.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное целое число — минимальное количество поворотов колеса, за которое Гриша сможет напечатать название экспоната.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>zeus</code>
    <code>18</code>
    <p>Для набора слова из первого примера необходимо сделать следующую последовательность поворотов:</p>
    <ol>
      <li>от a до z (1 поворот против часовой стрелки),</li>
      <li>от z до e (5 поворотов по часовой стрелке),</li>
      <li>от e до u (10 поворотов против часовой стрелки),</li>
      <li>от u до s (2 поворотa против часовой стрелки).</li>
    </ol>
    <p>Итого потребуется 1 + 5 + 10 + 2 = 18 поворотов.</p>

    <h4>Пример 2</h4>
    <code>map</code>
    <code>35</code>

    <h4>Пример 3</h4>
    <code>ares</code>
    <code>34</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/731/problem/A" target="_blank">Задача 731A</a>
      <br><a href="https://codeforces.com/contest/731" target="_blank">Codeforces Round 376 (Div. 2) 2016-10-16</a>
    </div>

<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main() {
  // ввод данных
  string s;
  cin >> s;

  // решение
  int sum = 0;
  int pos = 0;
  for (int i = 0; i &lt; s.size(); i++) {
    if (pos + 'a' &lt;= s[i]) {
      sum += min((s[i] - 'a') - pos, pos + 26 - (s[i] - 'a'));
    } else {
      sum += min(pos - (s[i] - 'a'), 26 - pos + (s[i] - 'a'));
    }
    pos = s[i] - 'a';
  }

  // вывод результата
  cout &lt;&lt; sum;
}
</pre>
  </details>
</article>


<!-- Задача J. Дежавю -->
<article class="article">
  <div class="anchor" id="task10"></div>
  <h3>Задача J. Дежавю</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Палиндром — это строка, которая читается одинаково в обоих направлениях. Например, строки «z», «aa», «aba» и «abccba» — палиндромы, а «codeforces» и «ab» — нет. Вы ненавидите палиндромы, потому что они вызывают у вас дежавю.</p>

  <p>Дана строка s. Вы должны вставить ровно один символ 'a' в s. Если таким образом можно получить строку, которая не является палиндромом, вам нужно найти одну из них. В противном случае следует сообщить, что это невозможно.</p>

  <p>Например, предположим, что s=«cbabc». Вставив 'a', можно получить «acbabc», «cababc», «cbaabc», «cbabac», или «cbabca». Строка «cbaabc» — палиндром, и не подходит, поэтому вы должны вывести другую из вышеперечисленных строк.</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержится одно целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>
  <p>Единственная строка каждого набора входных данных содержит строку s, состоящую из строчных английских букв.</p>
  <p>Суммарная длина всех строк не превышает 3⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных, если нет решения, выведите «NO».</p>
  <p>В противном случае выведите «YES», а в следующей строке выведите строку длиной |s|+1. Если есть несколько решений, можно вывести любое из них.</p>
  <p>Вы можете выводить каждый символ «YES» и «NO» в любом регистре.</p>

  <details>
    <summary>Пример</summary>
<pre>
6
cbabc
ab
zza
ba
a
nutforajaroftuna
</pre>
<pre>
YES
cbabac
YES
aab
YES
zaza
YES
baa
NO
YES
nutforajarofatuna
</pre>
    <p>Первый набор входных данных описан в условии.</p>
    <p>Во втором наборе входных данных можно получить либо «aab», либо «aba». Но «aba» — это палиндром, поэтому «aab» — единственный правильный ответ.</p>
    <p>В третьем наборе входных данных «zaza» и «zzaa» — правильные ответы, а «azza» — нет.</p>
    <p>В четвертом наборе входных данных «baa» — единственный правильный ответ.</p>
    <p>В пятом наборе входных данных мы можем получить только «aa», что является палиндромом. Следовательно, ответ «NO».</p>
    <p>В шестом наборе входных данных «anutforajaroftuna» — палиндром, но вставка 'a' в любом другом месте подходит.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1504/problem/A" target="_blank">Задача 1504A</a>
      <br><a href="https://codeforces.com/contest/1504" target="_blank">Codeforces Round 712 (Div. 2) 2021-04-03</a>
    </div>

    <p>Нужно букву 'a' поставить в слове так, чтобы зеркальная ей буква была не 'a'. Пойдем от начала слова и будем проверять каждую букву, запомним индекс ai первой буквы которая будет не 'a' и поставим в строку букву 'a' на расстоянии ai от конца слова</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    string s;
    cin >> s;

    // решение
    int n = s.size();
    int ai = -1;
    char a = 'a';
    for (int i = 0; i &lt; n; i++) {
      if (s[i] != a && ai == -1) {
        ai = i; // индекс буквы 'a' с конца
      }
    }

    // вывод результата
    if (ai == -1) {
      cout &lt;&lt; "NO" &lt;&lt; '\n';
    } else {
      string res = s.substr(0, n - ai) + a + s.substr(n - ai, n);
      cout &lt;&lt; "YES" &lt;&lt; '\n' &lt;&lt; res &lt;&lt; '\n';
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача K. Не просто красивые строки -->
<article class="article">
  <div class="anchor" id="task11"></div>
  <h3>Задача K. Не просто красивые строки</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Назовем строку няшной, если ее буквы можно переупорядочить так, чтобы они образовывали ровно две подряд идущие непустые группы из одинаковых символов (при этом разным группам соответствуют разные буквы). Так, например, ababa является няшной (можно превратить ее в aaabb, где первые три буквы образуют одну группу из a, а оставшиеся — вторую группу из b), а cccc — нет, так как при любом разбиении на две последовательные группы буквы в разных группах будут совпадать. Для лучшего понимания условия ознакомьтесь с примерами.</p>

  <p>Вам дана строка s. Проверьте, можно ли разбить ее на две непустые непересекающиеся подпоследовательности, так что строки, соответствующие этим подпоследовательностям, будут няшными. Здесь под подпоследовательностью понимается произвольный набор индексов строки.</p>

  <h4>Входные данные</h4>
  <p>В единственной строке задана строка s (1 ≤ |s| ≤ 10⁵). Гарантируется, что она состоит только из маленьких латинских букв.</p>

  <h4>Выходные данные</h4>
  <p>Выведите «Yes», если строку можно разбить на две няшные строки (в контексте подпоследовательностей), и «No» в противном случае.</p>
  <p>Вы можете выводить каждую букву в любом регистре (строчную или заглавную).</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>ababa</code>
    <code>Yes</code>

    <h4>Пример 2</h4>
    <code>zzcxx</code>
    <code>Yes</code>
    <p>Во втором примере можно разбить zzcxx на подпоследовательности zc и zxx, каждая из которых является няшной.</p>

    <h4>Пример 3</h4>
    <code>yeee</code>
    <code>No</code>
    <p>В третьем примере ни одного подходящего разбиения не существует.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/955/problem/B" target="_blank">Задача 955B</a>
      <br><a href="https://codeforces.com/contest/955" target="_blank">Codeforces Round 471 (Div. 2) 2018-03-23</a>
    </div>

    <p>В строке должно быть не менее 4 букв. Если это 2 разные буквы, то каждой из них должно быть не меньше двух. Если это 3 разные буквы, то одной из них должно быть не меньше двух. Если это 4 разные буквы то подходит. Более 4 разных букв не может быть.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ввод данных
  string s;
  cin >> s;

  // решение
  bool res = 0;
  vector&lt;int&gt; A(256, 0);
  for (int i = 0; i &lt; s.size(); i++) {
    int tmp = s[i];
    A[tmp]++;
  }

  vector&lt;int&gt; B(0);
  for (int i = 0; i &lt; A.size(); i++) {
    if (A[i]) {
      B.push_back(A[i]);
    }
  }

  sort(B.begin(), B.end());
  if ( (B.size() == 2) && (B[0] > 1) ) {
    res = 1;;
  } else if ( (B.size() == 3) && (B[2] > 1) ) {
    res = 1;
  } else if (B.size() == 4) {
    res = 1;
  }

  if (s.size() &lt; 4) {
    res = 0;
  }

  // вывод результата
  if (res) {
    cout &lt;&lt; "Yes";
  } else {
    cout &lt;&lt; "No";
  }
}
</pre>
  </details>
</article>


<!-- Задача L. Пароли -->
<article class="article">
  <div class="anchor" id="task12"></div>
  <h3>Задача L. Пароли</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Ваня собирается зайти на свой любимый сайт Codehorses. Всего Ваня использует n различных паролей для сайтов, однако, какой именно пароль он указывал при регистрации на Codehorses, он не помнит.</p>

  <p>Ваня будет вводить пароли в порядке неубывания их длин, а пароли одинаковой длины — в произвольном порядке. Как только Ваня введет правильный пароль, он сразу окажется авторизован на сайте. Ваня не будет вводить один и тот же пароль несколько раз.</p>

  <p>На ввод любого пароля Ваня тратит одну секунду. Однако, если Ваня k раз введет неправильный пароль, то следующую попытку ввода он сможет совершить только через 5 секунд. Каждую попытку ввода Ваня совершает незамедлительно, то есть всегда, когда у него есть возможность вводить очередной пароль, Ваня этим занят.</p>

  <p>Сообщите, сколько секунд потребуется Ване, чтобы зайти на Codehorses, в лучшем для него случае (если он потратит минимально возможное количество секунд) и в худшем для него случае (если он потратит максимально возможное количество секунд).</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных содержится два целых числа n и k (1 ≤ n, k ≤ 100) — количество паролей Вани и количество неудачных попыток, после которых доступ к сайту блокируется на 5 секунд.</p>

  <p>В следующих n строках содержатся пароли, по одному в строке — различные непустые строки, состоящие из букв латинского алфавита и цифр. Длина каждого пароля не превосходит 100 символов.</p>

  <p>Заключительная строка входных данных содержит пароль Вани к Codehorses. Гарантируется, что пароль Вани к Codehorses совпадает с одним из n его паролей.</p>

  <h4>Выходные данные</h4>
  <p>Выведите два целых числа — время (в секундах), которое потребуется Ване для авторизации на Codehorses в лучшем для него случае и худшем для него случае соответственно.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
5 2
cba
abc
bb1
abC
ABC
abc
</pre>
    <code>1 15</code>
    <p>Рассмотрим первый тест. Так как все пароли одинаковой длины, Ваня может ввести правильный пароль как первым, так и последним. Если он вводит правильный пароль первым, то он тратит на это ровно 1 секунду. Следовательно, ответ в лучшем случае равен 1. Если же он вводит его последним, до этого он введёт остальные 4 пароля. Он потратит 2 секунды на ввод первых 2 неправильных паролей, после этого ему придется подождать 5 секунд, так как он ввёл 2 неправильных пароля. Потом он потратит ещё 2 секунды на ввод 2 неправильных паролей, опять подождёт 5 секунд и наконец введёт верный пароль, потратив на это ещё 1 секунду. Итого в худшем случае он сможет авторизоваться за 15 секунд.</p>

  <h4>Пример 2</h4>
<pre>
4 100
11
22
1
2
22
</pre>
    <code>3 4</code>
    <p>Рассмотрим второй тест. Как бы Ваня ни вводил пароли, он не сможет добиться того, чтобы доступ к сайту заблокировался. Так как необходимый пароль имеет длину 2, Ваня в любом случае введёт сначала все пароли длины 1, потратив на это 2 секунды. Затем, в лучшем случае, он сразу введёт необходимый пароль, и ответ в лучшем случае будет равен 3, а в худшем случае сначала введёт неверный пароль длины 2, и только потом верный, и потратит 4 секунды.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/721/problem/B" target="_blank">Задача 721B</a>
      <br><a href="https://codeforces.com/contest/721" target="_blank">Codeforces Round 374 (Div. 2) 2016-09-30</a>
    </div>

    <p>Отсортировать пароли. Минимальное число попыток это до первого пароля нужной длины. Максимальное число попыток это то последнего пароля нужной длины. Осталось учиесть что через каждые k попыток +5 секунд</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;

using namespace std;

bool compare(const string& s1, const string& s2) {
  return s1.length() &lt; s2.length();
}

int main() {
  // ввод данных
  int n, k;
  cin >> n >> k;
  vector&lt;string&gt; S;
  S.reserve(n);
  string tmp;
  for (int i = 0; i &lt; n; i++) {
    cin >> tmp;
    S.push_back(tmp);
  }
  string ans;
  cin >> ans;

  // решение
  sort(begin(S), end(S), compare);
  int num1 = 1, num2 = 0, i = 0;

  while ( (i &lt; n) && (S[i].length() &lt; ans.length()) ) {
    num1++;
    i++;
  }

  i = 0;
  while ( (i &lt; n) && (S[i].length() &lt;= ans.length()) ) {
    num2++;
    i++;
  }

  num1 += 5 * ( (num1 - 1) / k);
  num2 += 5 * ( (num2 - 1) / k);

  // вывод результата
  cout &lt;&lt; num1 &lt;&lt; ' ' &lt;&lt; num2;
}
</pre>
  </details>
</article>


<!-- Задача M. Подделка -->
<article class="article">
  <div class="anchor" id="task13"></div>
  <h3>Задача M. Подделка</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Студент Андрей весь семестр пропускал физкультуру в своем университете, и вот теперь настала пора получать по ней зачет. Разумеется, получить зачет честно Андрей не успевает, но он не сдается. Добыв в местной поликлинике пустой бланк справки, Андрей, зная почерк местного врача, решил подделать справку о болезни. И вот, когда большая часть уже написана, Андрей с ужасом понял, что подпись врача подделать невозможно. Или возможно?</p>

  <p>Для удобства Андрей мысленно представил подпись как клетчатое поле n*m, где каждая клетка либо заполнена чернилами, либо пуста. Ручка Андрея заполняет чернилами квадрат 3*3 без центральной клетки, если он полностью лежит внутри поля, как показано ниже.</p>
<pre>
xxx
x.x
xxx
</pre>
  <p>Определите, может ли Андрей нарисовать подпись врача на пустом листе бумаги n*m.</p>

  <h4>Входные данные</h4>
  <p>В первой строке даны 2 целых числа n и m (3 ≤ n, m ≤ 1000).</p>
  <p>Далее следуют n строк по m символов в каждой. Каждый из символов — либо «.», обозначающий пустую клетку, либо «#», обозначающий клетку с чернилами.</p>

  <h4>Выходные данные</h4>
  <p>Если Андрей может подделать подпись, выведите «YES». Иначе выведите «NO».</p>
  <p>Вы можете выводить каждую из букв в любом регистре (строчную или заглавную).</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
3 3
###
#.#
###
</pre>
    <code>YES</code>
    <p>В первом примере Андрей может покрасить границу квадрата с центром в  (2,2)</p>

    <h4>Пример 2</h4>
<pre>
3 3
###
###
###
</pre>
    <code>NO</code>
    <p>Во втором примере подпись невозможно подделать</p>

    <h4>Пример 3</h4>
<pre>
4 3
###
###
###
###
</pre>
    <code>YES</code>
    <p>В третьем примере Андрей может покрасить границы квадратов с центрами в (2,2) и (3,2)</p>

    <h4>Пример 4</h4>
<pre>
5 7
.......
.#####.
.#.#.#.
.#####.
.......
</pre>
    <code>YES</code>
    <p>В четвёртом примере Андрей может покрасить границы квадратов с центрами в (3,3) и (3,5)</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1059/problem/B" target="_blank">Задача 1059B</a>
      <br><a href="https://codeforces.com/contest/1059" target="_blank">Codeforces Round 514 (Div. 2) 2018-10-05</a>
    </div>

    <p>Сохраним входную матрицу в A, а матрицу для поддельной подписи будем создавать в CopyA. Потом проверим если матрицы совпадают, то выводим YES, иначе NO</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

using namespace std;

int main() {
  // ввод данных
  int n, m;
  cin >> n >> m;
  vector&lt;string&gt; A(n), CopyA(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
    CopyA[i] = A[i];
    for (int j = 0; j &lt; m; j++) {
      CopyA[i][j] = '.';
    }
  }

  // решение
  for (int i = 0; i &lt; n - 2; i++) {
    for (int j = 0; j &lt; m - 2; j++) {
      if (A[i][j] == '#' && A[i][j+1] == '#' &&
          A[i][j+2] == '#' && A[i+1][j] == '#' &&
          A[i+1][j+2] == '#' && A[i+2][j] == '#' &&
          A[i+2][j+1] == '#' && A[i+2][j+2] == '#') {
        CopyA[i][j] = '#';
        CopyA[i][j+1] = '#';
        CopyA[i][j+2] = '#';
        CopyA[i+1][j] = '#';
        CopyA[i+1][j+2] = '#';
        CopyA[i+2][j] = '#';
        CopyA[i+2][j+1] = '#';
        CopyA[i+2][j+2] = '#';
      }
    }
  }
  bool flag = false;
  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; m; j++) {
      if (A[i][j] != CopyA[i][j]) {
        flag = true;
      }
    }
  }

  // вывод результата
  if (flag) {
    cout &lt;&lt; "NO";
  } else {
    cout &lt;&lt; "YES";
  }
}
</pre>
  </details>
</article>


<!-- Задача N. Чудесная раскраска - 1 -->
<article class="article">
  <div class="anchor" id="task14"></div>
  <h3>Задача N. Чудесная раскраска - 1</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Это упрощенная версия задачи B2. Возможно, вы захотите сначала ознакомиться с B2 до того как приступить к решению B1.</p>

  <p>У Паши и Маши есть любимая строка s
  , состоящая из строчных букв латинского алфавита. Они захотели её раскрасить с помощью мелков двух цветов: красного и зелёного. Раскраска строки называется чудесной, если выполняются следующие условия:</p>
  <ol>
    <li>каждый символ строки либо закрашивается ровно в один цвет (красный или зелёный), либо не закрашивается вовсе;</li>
    <li>любые два символа, покрашенные в один цвет, различны;
  </li>
    <li>количество символов, покрашенных в красный цвет, совпадает с количеством символов, покрашенных в зелёный цвет;</li>
    <li>количество покрашенных символов при соблюдении первых трёх условий максимально возможно.</li>
  </ol>
  <p>Например, пусть строка s имеет вид «kzaaa». Одна из её возможных чудесных раскрасок изображена на рисунке.</p>
  <p>Паша и Маша хотят сами научиться делать чудесную раскраску строки. Поскольку они очень маленькие, им нужна помощь в виде подсказки. Помогите им найти k — количество красных (или зелёных, эти числа равны) букв в чудесной раскраске строки.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано одно целое число t (1 ≤ t ≤ 1000) — количество наборов входных данных. Далее следуют t наборов входных данных.</p>
  <p>Каждый набор входных данных состоит из одной непустой строки s, состоящей из строчных букв латинского алфавита. Количество символов в строке не превышает 50.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных в отдельной строке выведите одно целое неотрицательное число k — количество символов, которые будут покрашены в красный цвет.</p>

  <details>
    <summary>Пример</summary>
<pre>
5
kzaaa
codeforces
archive
y
xxxxxx
</pre>
<pre>
2
5
3
0
1
</pre>
    <p>В первом наборе входных данных содержится строка из условия. Одна из чудесных раскрасок представлена на рисунке. Чудесная раскраска, содержащая 3 и более красных букв, не существует, поскольку в таком случае общее количество раскрашенных символов превысит количество символов в строке.</p>
    <p>Строку из второго набора входных данных можно раскрасить следующим образом. Первые вхождения букв «c», «o», «e» покрасим в красный цвет, вторые — в зелёный. Буквы «d» и «f» покрасим в красный цвет, «r», «s» — в зелёный. Таким образом, каждый символ будет покрашен либо в красный цвет, либо в зелёный, следовательно, ответа лучше 5 не существует.</p>
    <p>В третьем наборе входных данных все буквы различны, поэтому в красный цвет можно покрасить любой набор символов, количество которых не превышает половину длины строки и является максимально возможным.</p>
    <p>В четвёртом наборе входных данных всего один символ, поэтому, если покрасить его в красный, мы не сможем покрасить какой-либо другой символ в зелёный цвет.</p>
    <p>В пятом наборе входных данных все буквы одинаковы, поэтому нельзя покрасить более одного символа в красный цвет.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1551/problem/B1" target="_blank">Задача 1551B1</a>
      <br><a href="https://codeforces.com/contest/1551" target="_blank">Codeforces Round 734 (Div. 3) 2021-07-23</a>
    </div>

    <p>Результат равен количеству различных символов, которых не более одного, поделить на 2. Плюс количество различных символов, которых 2 и более. Но не более половины строки.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    string s;
    cin >> s;

    // решение
    // количество символов алфавита
    vector&lt;int&gt; A(26, 0);
    int temp;
    for (int i = 0; i &lt; s.size(); i++) {
      A[s[i] - 'a']++;
    }
    int count1 = 0;
    int count2 = 0;
    for (int i = 0; i &lt; A.size(); i++) {
      if (A[i] == 1) {
        count1++;
      } else if (A[i] > 1) {
        count2++;
      }
    }
    int res = count1 / 2 + count2;
    res = min(res, ((int)s.size() / 2));

    // вывод результата
    cout &lt;&lt; res &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача O. Интересный рассказ -->
<article class="article">
  <div class="anchor" id="task15"></div>
  <h3>Задача O. Интересный рассказ</h3>

  <div><i>Ограничение по времени 4с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Стивен Квин хочет написать новый рассказ. Вы знаете, он очень необычный писатель — Стивен использует только буквы 'a', 'b', 'c', 'd' и 'e'!</p>

  <p>Чтобы написать рассказ, Стивен выписал n слов, состоящих из первых 5 строчных букв латинского алфавита. Из них он хочет выбрать максимальное количество слов таким образом, чтобы получился интересный рассказ.</p>

  <p>Рассказ представляет собой список слов, необязательно различных. Рассказ называется интересным, если существует буква, которая встречается во всех входящих в него словах большее количество раз, чем все остальные буквы латинского алфавита вместе взятые.</p>

  <p>Например, рассказ, состоящий из слов «bac», «aaada», «e», является интересным (буква «a» встречается в словах рассказа всего 5 раз, остальные — 4), а рассказ, состоящий из слов «aba», «abcde» — нет (не существует буквы, встречающейся во всех словах рассказа большее число раз, чем все остальные вместе взятые).</p>

  <p>Вам дан список из n слов. Выберите из этого списка максимальное количество слов так, чтобы они образовывали интересный рассказ. Если невозможно составить непустой интересный рассказ, выведите 0.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано одно целое число t (1 ≤ t ≤ 5000) — количество наборов входных данных. Далее следуют t наборов входных данных.</p>

  <p>Первая строка каждого набора данных содержит целое число n (1 ≤ n ≤ 2⋅10⁵) — количество слов. Далее следует n непустых строк — слов, состоящих из строчных букв латинского алфавита. Слова в списке не обязательно различны (иными словами, могут быть одинаковые слова). Слова состоят исключительно из букв 'a', 'b', 'c', 'd' и 'e'.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 2⋅10⁵ и что суммарное количество букв во всех словах, содержащихся в наборах входных данных, не превышает 4⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите максимальное количество слов из заданного списка, которые могут образовать интересный рассказ. Если невозможно составить непустой интересный рассказ, выведите 0.</p>

  <details>
    <summary>Пример</summary>
<pre>
6
3
bac
aaada
e
3
aba
abcde
aba
2
baba
baba
4
ab
ab
c
bc
5
cbdca
d
a
d
e
3
b
c
ca
</pre>
<pre>
3
2
0
2
3
2
</pre>
    <p>В первом наборе входных данных примера все 3 слова могут быть использованы одновременно, чтобы составить интересный рассказ. Рассказ будет иметь вид «bac aaada e».</p>
    <p>Во втором наборе входных данных примера 1-е и 3-е слова могут быть использованы для составления интересного рассказа. Рассказ будет иметь вид «aba aba». Заметим, что все три слова одновременно использовать нельзя.</p>
    <p>В третьем наборе входных данных примера автор не может составить непустой интересный рассказ. Поэтому ответ равен 0.</p>
    <p>В четвертом наборе входных данных примера 3-е и 4-е слова могут быть использованы для составления интересного рассказа. Рассказ будет иметь вид «c bc».</p>
  </details>

  <details>
    <summary>Тесты</summary>
<pre>
1
22
abe
ceacda
ced
ce
edcadc
adb
da
bad
ead
dad
bcd
ddca
deaa
ecc
cd
cae
aabee
aadea
bdcae
be
cddc
bceba
</pre>
  <code>5</code>
<pre>
1
43
a
d
bbc
a
dda
c
e
bb
cbd
c
dc
e
caab
d
c
e
e
bd
d
a
a
b
a
c
d
c
d
ba
e
c
ecdb
bdbd
d
e
cb
ac
ccd
cb
cda
da
bb
d
c
</pre>
  <code>19</code>
<pre>
1
5
eb
cddcee
eecbbc
ebadabe
aceeb
</pre>
  <code>0</code>
<pre>
1
20
ebadaeea
eeeeaa
ddbdadd
debbbacebe
badbbbbc
eeaadb
acadbe
bcdeb
ccececcdba
cacab
ba
edddbdd
bbaddcdab
ccdecaecccace
cdddbd
eac
accdedbbe
bcdea
aadeada
cacad
</pre>
  <code>5</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1551/problem/C" target="_blank">Задача 1551C</a>
      <br><a href="https://codeforces.com/contest/1551" target="_blank">Codeforces Round 734 (Div. 3) 2021-07-23</a>
    </div>

    <p>Сортировать слова по соотношению букв А (B,C,D,E) к другим буквам. Напишем функцию compare для такой сортировки. Для сравнения используем разницу между буквой A и остальными буквами в слове.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

bool compareA(string&, string&);
bool compareB(string&, string&);
bool compareC(string&, string&);
bool compareD(string&, string&);
bool compareE(string&, string&);
int count_word(vector&lt;string&gt;, char);

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    cin >> n;
    vector&lt;string&gt; S(0);
    string temp;
    for (int i = 0; i &lt; n; i++) {
      cin >> temp;
      S.push_back(temp);
    }

    // решение
    sort(S.begin(), S.end(), compareA);
    int resA = count_word(S, 'a');
    sort(S.begin(), S.end(), compareB);
    int resB = count_word(S, 'b');
    sort(S.begin(), S.end(), compareC);
    int resC = count_word(S, 'c');
    sort(S.begin(), S.end(), compareD);
    int resD = count_word(S, 'd');
    sort(S.begin(), S.end(), compareE);
    int resE = count_word(S, 'e');

    int res = max(max(max(resA, resB), max(resC, resD)), resE);

    // вывод результата
    cout &lt;&lt; res &lt;&lt; '\n';
  }
}

bool compareA(string &s1, string &s2) {
  int a1 = 0; // число букв 'a'
  int b1 = 0; // число других букв
  int d1;     // разница a1 - b1
  for (char ch : s1) {
    if (ch == 'a') {
      a1++;
    } else {
      b1++;
    }
  }
  d1 = a1 - b1;
  int a2 = 0, b2 = 0, d2;
  for (char ch : s2) {
    if (ch == 'a') {
      a2++;
    } else {
      b2++;
    }
  }
  d2 = a2 - b2;
  return d1 > d2;
}

bool compareB(string &s1, string &s2) {
  int a1 = 0; // число букв 'b'
  int b1 = 0; // число других букв
  int d1;     // разница a1 - b1
  for (char ch : s1) {
    if (ch == 'b') {
      a1++;
    } else {
      b1++;
    }
  }
  d1 = a1 - b1;
  int a2 = 0, b2 = 0, d2;
  for (char ch : s2) {
    if (ch == 'b') {
      a2++;
    } else {
      b2++;
    }
  }
  d2 = a2 - b2;
  return d1 > d2;
}

bool compareC(string &s1, string &s2) {
  int a1 = 0; // число букв 'c'
  int b1 = 0; // число других букв
  int d1;     // разница a1 - b1
  for (char ch : s1) {
    if (ch == 'c') {
      a1++;
    } else {
      b1++;
    }
  }
  d1 = a1 - b1;
  int a2 = 0, b2 = 0, d2;
  for (char ch : s2) {
    if (ch == 'c') {
      a2++;
    } else {
      b2++;
    }
  }
  d2 = a2 - b2;
  return d1 > d2;
}

bool compareD(string &s1, string &s2) {
  int a1 = 0; // число букв 'd'
  int b1 = 0; // число других букв
  int d1;     // разница a1 - b1
  for (char ch : s1) {
    if (ch == 'd') {
      a1++;
    } else {
      b1++;
    }
  }
  d1 = a1 - b1;
  int a2 = 0, b2 = 0, d2;
  for (char ch : s2) {
    if (ch == 'd') {
      a2++;
    } else {
      b2++;
    }
  }
  d2 = a2 - b2;
  return d1 > d2;
}

bool compareE(string &s1, string &s2) {
  int a1 = 0; // число букв 'e'
  int b1 = 0; // число других букв
  int d1;     // разница a1 - b1
  for (char ch : s1) {
    if (ch == 'e') {
      a1++;
    } else {
      b1++;
    }
  }
  d1 = a1 - b1;
  int a2 = 0, b2 = 0, d2;
  for (char ch : s2) {
    if (ch == 'e') {
      a2++;
    } else {
      b2++;
    }
  }
  d2 = a2 - b2;
  return d1 > d2;
}

int count_word(vector&lt;string&gt; s, char c) {
  int count_w = 0;
  int count_c = 0;
  int count_oth = 0;
  for (int i = 0; i &lt; s.size(); i++) {
    for (int j = 0; j &lt; s[i].size(); j++) {
      if (s[i][j] == c) {
        count_c++;
      } else {
        count_oth++;
      }
    }
    if (count_c > count_oth) {
      count_w++;
    } else {
      break;
    }
  }
  return count_w;
}
</pre>
  </details>
</article>


<!-- Задача P. Самые похожие слова -->
<article class="article">
  <div class="anchor" id="task16"></div>
  <h3>Задача P. Самые похожие слова</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам даны n слов одинаковой длины m, состоящие из строчных букв латинского алфавита, i-е слово обозначается sᵢ.</p>

  <p>За один ход вы можете выбрать любую позицию в любом отдельном слове и заменить букву в этой позиции на предыдущую или следующую букву в алфавитном порядке. Например:</p>
  <ul>
    <li>вы можете заменить 'e' на 'd' или на 'f';</li>
    <li>'a' может быть заменена только на 'b';</li>
    <li>'z' может быть заменена только на 'y'.</li>
  </ul>
  <p>Разница между двумя словами — это минимальное число ходов, необходимое для того, чтобы сделать их равными. Например, разница между «best» и «cost» составляет 1+10+0+0=11.</p>
  <p>Найдите минимальную разницу между sᵢ и s<sub>j</sub> такую, что (i &lt; j). Другими словами, найдите минимальную разницу по всем возможным парам из n
  слов.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит единственное целое число t (1≤t≤100) — количество наборов входных данных. Далее следуют описания наборов.</p>
  <p>Первая строка каждого набора содержит 2 целых числа n и m (2≤n≤50, 1≤m≤8) — количество слов и их длина соответственно.</p>
  <p>Затем следуют n строк, i-я из которых содержит слово s<sub>i</sub> длины m, состоящее из строчных латинских букв.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно целое число — минимальную разница среди всех возможных пар заданных строк.</p>

  <details>
    <summary>Пример</summary>
<pre>
6
2 4
best
cost
6 3
abb
zba
bef
cdu
ooo
zzz
2 7
aaabbbc
bbaezfe
3 2
ab
ab
ab
2 8
aaaaaaaa
zzzzzzzz
3 1
a
u
y
</pre>
<pre>
11
8
35
0
200
4
</pre>
    <p>Для второго набора входных данных можно показать, что наилучшей парой является («abb», «bef»), которая имеет разницу, равную 8, что можно получить следующим образом: заменить первый символ первой строки на 'b' за один ход, заменить второй символ второй строки на 'b' за 3 хода и заменить третий символ второй строки на 'b' за 4 хода, что в сумме дает 1+3+4=8 ходов.</p>
    <p>В третьем наборе существует только одна возможная пара, и можно показать, что минимальное количество ходов, необходимое для того, чтобы строки стали равными, равно 35.</p>
    <p>В четвертом наборе есть пара строк, которые уже равны, поэтому ответ равен 0.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1676/problem/C" target="_blank">Задача 1676C</a>
      <br><a href="https://codeforces.com/contest/1676" target="_blank">Codeforces Round 790 (Div. 4) 2022-05-10</a>
    </div>

    <p>Решение за O(n²). Цикл в цикле находим разницу между буквами по всем парам. Каждый раз определяя минимальную.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n, m;
    cin >> n; // число слов
    cin >> m; // число букв
    vector&lt;string&gt; A(0);
    string temp;
    for (int i = 0; i &lt; n; i++) {
      cin >> temp;
      A.push_back(temp);
    }

    // решение
    vector&lt;vector&lt;int&gt; &gt; B(n, vector&lt;int&gt;(m));
    // минимальная разница всех возможных пар
    int min_sum = m * 25;
    for (int k = 0; k &lt; n; k++) {
      // минимальная разница k-го слова
      int min_k = m * 25;
      for (int i = 0; i &lt; n; i++) {
        if (i == k) {
          continue;
        }
        int sumk = 0;
        for (int j = 0; j &lt; m; j++) {
          B[i][j] = abs(A[k][j] - A[i][j]);
          sumk += B[i][j];
        }
        min_k = min(min_k, sumk);
      }
      min_sum = min(min_sum, min_k);
    }

    // вывод результата
    cout &lt;&lt; min_sum &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача Q. Удали два символа -->
<article class="article">
  <div class="anchor" id="task17"></div>
  <h3>Задача Q. Удали два символа</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У Дмитрия есть строка s, состоящая из строчных латинских букв.</p>
  <p>Дмитрий решил удалить два подряд идущих символа из строки s и вам интересно, какое количество различных строк может получиться после такой операции.</p>
  <p>Например, у Дмитрия есть строка «aaabcc». Вы можете получить следующие различные строки: «abcc»(при удалении первых двух или второго и третьего символов), «aacc»(при удалении третьего и четвёртого символов),«aaac»(при удалении четвертого и пятого символов) и «aaab»(при удалении последних двух).</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит одно целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>
  <p>Далее следуют описания входных данных.</p>
  <p>Первая строка описания каждого набора входных данных содержит целое число n (3 ≤ n ≤ 2⋅10⁵).</p>
  <p>Вторая строка описания каждого набора входных данных содержит строку s длины n, состоящую из строчных латинских букв.</p>
  <p>Гарантируется, что сумма n по всем наборам входных данных не превосходит 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно целое число — количество различных строк, которые можно получить, удалив две подряд идущие буквы.</p>

  <details>
    <summary>Пример</summary>
<pre>
7
6
aaabcc
10
aaaaaaaaaa
6
abcdef
7
abacaba
6
cccfff
4
abba
5
ababa
</pre>
<pre>
4
1
5
3
3
3
1
</pre>
    <p>Первый пример разобран в условии.</p>
    <p>В третьем примере получатся следующие строки: «cdef», «adef», «abef», «abcf», «abcd».</p>
    <p>В седьмом примере при любом удалении получится строка «aba».</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1800/problem/D" target="_blank">Задача 1800D</a>
      <br><a href="https://codeforces.com/contest/1800" target="_blank">Codeforces Round 855 (Div. 3) 2023-03-02</a>
    </div>

    <p>Если в строке s есть одинаковые символы стоящие через 1 любой символ s[i] == s[i+2], то при удалении пары соседних символов (i и i+1) или (i+1 и i+2) приведет к одной и той же строке. Это единственное условие при котором получаются идентичные строки при удалении двух соседних символов. Осталось только подсчитать сколько есть таких вариантов, когда два одинаковых символа стоят через символ</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n;
    cin >> n;
    string s;
    cin >> s;

    // решение
    int res = 0;
    for (int i = 0; i &lt; s.size(); i++) {
      if (i + 2 &lt; s.size()) {
        if (s[i] == s[i + 2]) {
          res++;
        }
      }
    }

    // вывод результата
    cout &lt;&lt; s.size() - res - 1 &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>

