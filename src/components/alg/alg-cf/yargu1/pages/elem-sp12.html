<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contests" target="_blank">Codeforces ЯрГУ. Школьники</a></p>
  <p><a href="https://vk.com/sportprog_yarsu" target="_blank">vk.com/sportprog_yarsu</a></p>
  <p><a href="https://vkvideo.ru/@sportprog_yarsu" target="_blank">vkvideo.ru/@sportprog_yarsu</a></p>
</article>


<article class="article">
  <h1>Занятие 12. Структуры данных #1. stack, queue, deque</h1>
  <p>Конспект видео от 2024.11.30</p>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contest/570478" target="_blank">Codeforces Контест 570478</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
    <a href="#p1">Структуры данных #1. stack, queue, deque</a>
  </p>
  <p>
        <a href="#task1">Задача A. Последовательность</a>
    <br><a href="#task2">Задача B. Скобки Скобочки</a>
    <br><a href="#task3">Задача C. Скобочная последовательность</a>
    <br><a href="#task4">Задача D. Нужно больше деков</a>
    <br><a href="#task5">Задача E. Пробка в Цветочном городе</a>
    <br><a href="#task6">Задача F. Скобочки-2</a>
    <br><a href="#task7">Задача G. Модифицированный стек</a>
    <br><a href="#task8">Задача H. Модифицированная очередь - 2</a>
    <br><a href="#task9">Задача I. Настольный теннис</a>
    <br><a href="#task10">Задача J. Великое Лайнландское переселение</a>
    <br><a href="#task11">Задача K. Минимум на отрезке</a>
    <br><a href="#task12">Задача L. ПОЛИЗ</a>
    <br><a href="#task13">Задача M. Дикие обезьяны</a>
    <br><a href="#task14">Задача N. 38 попугаев</a>
    <br><a href="#task15">Задача O. Правильная скобочная подпоследовательность</a>
    <br><a href="#task16">Задача P. Гистограмма</a>
    <br><a href="#task17">Задача Q. Вежливые соседи</a>
    <br><a href="#task18">Задача R. Небоскрёбы (усложнённая версия)</a>
    <br><a href="#task19">Задача S. Майк и футы</a>
    <br><a href="#task20">Задача T. Две головы - лучше</a>
    <br><a href="#task21">Задача U. Последнее слово техники</a>
  </p>
</article>


<!-- Структуры данных #1. stack, queue, deque -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Структуры данных #1. stack, queue, deque</h3>

  <p><strong>Структура данных</strong> — это контейнер, который хранит данные в определенном макете/конструкции. Этот «макет/конструкция» позволяет структуре данных быть эффективной в некоторых операциях и неэффективной в других.</p>
  <p>Примеры из жизни: шкаф, ящик с инструментами, кладовка.</p>
  <p>Новые библиотеки:</p>
  <code>#include &lt;stack&gt;</code>
  <code>#include &lt;queue&gt;</code>
  <code>#include &lt;deque&gt;</code>

  <p><strong>Линейные</strong> структуры данных в области памяти идут друг за дружкой. Например: массивы, матрицы, deque ...</p>

  <p><strong>Нелинейные</strong> это деревовидные структуры данных и хеш-таблицы.</p>

  <p>Примеры структуры данных:</p>
  <ol>
    <li>Массивы</li>
    <li>Матрицы</li>
    <li>Связанные списки (не используется в <strong>спортпроге</strong>)</li>
    <li>stack</li>
    <li>queue</li>
    <li>set</li>
    <li>map</li>
    <li>Графы</li>
    <li>Деревья</li>
    <li>Хэш таблицы</li>
  </ol>

  <h4>Pair</h4>
  <p><strong>Pair</strong> это контейнер, который объединяет два элемента одного или разных типов данных. Он состоит из двух элементов: первого и второго (порядок должен быть фиксированным).</p>
  <p>Обращение к pair:</p>
<pre>
pair&lt;int, string&gt; my_p;
my_p.first = 10;
my_p.second = "123";
</pre>

  <p><strong>Pair</strong> может заменить классы/структуры при решении задач на олимпиадах:</p>
<pre>
pair&lt;pair&lt;int, string&gt;, pair&lt;int, int&gt; &gt; monster;

monster.first.second = "abcd";
monster.first.first = 10;
monster.second.first = 15;
</pre>

  <p><strong>Pair</strong> очень популярная в <strong>спортпроге</strong> потому что позволяет не использовать настоящую структуру. Работа с pair это ускорение написания кода.</p>
  <p>Мы можем сортировать структуры данных с <strong>pair</strong>. Например vector .</p>
<pre>
vector&lt;pair&lt;int, int&gt; &gt; A(n);
for (int i = 0; i &lt; n; i++) {
  cin >> A[i].first >> A[i].second;
}
sort(A.begin(), A.end());
</pre>

  <h4>struct</h4>
  <p><strong>struct</strong> создает структуру</p>
<pre>
struct point {
  int x, y;
};
point p1;
p1.x = 1;
p1.y = 2;
</pre>

  <h4>Stack</h4>
  <p><strong>Stack</strong> - структура данных, которая работает по принципу LIFO (last-in first-out или ”последний вошел — первым вышел”) — первым всегда извлекается последний добавленный элемент.</p>

  <p>Примеры: стопка книжек, стопка карт, подносы в столовой.</p>

  <p>Объявление stack:</p>
  <code>stack&lt;тип данных&gt; имя;</code>

  <ol>
    <li>.empty() Проверяет, является ли stack пустым. true/false</li>
    <li>.pop() Удаляет элемент из верхней части stack.</li>
    <li>.push(a) Добавляет элемент в верхнюю часть stack.</li>
    <li>.size() Возвращает количество элементов в контейнере stack.</li>
    <li>.top() Возвращает ссылку на элемент в верхней части stack.</li>
  </ol>

  <h4>Queue</h4>
  <p><strong>Queue</strong> - контейнер, который работает по принципу FIFO (first-in first-out или ”первый вошел — первым вышел”) — первым всегда извлекается первый добавленный элемент. То есть это контейнер, аналогичный стандартной очереди, которая часто встречается в нашей повседневной жизни.</p>
  <p>Самый яркий пример честной очереди это очередь в поликлинику ранним утром.</p>

  <ol>
    <li>.back() Возвращает ссылку на последний элемент в queue.</li>
    <li>.empty() Проверяет, является ли queue пустым. true/false</li>
    <li>.front() Возвращает ссылку на первый элемент в начале queue.</li>
    <li>.pop() Удаляет элемент из начала queue.</li>
    <li>.push(a) Добавляет элемент в конец queue.</li>
    <li>.size() Возвращает количество элементов в контейнере queue.</li>
  </ol>

  <h4>Deque</h4>
  <p><strong>Deque</strong> представляет двухстороннюю очередь, ее еще называют двухглавой змеей.  Мы можем так же обращаться по элементам при помощи операторов [].</p>
  <p>На <strong>deque</strong> реализована такая структура данных как <strong>vector</strong>. vector это как deque с урезанным функционалом.</p>
  <p>Пример: котопес.</p>

  <ol>
    <li>.empty() Проверяет, является ли deque пустым. true/false</li>
    <li>.size() Возвращает количество элементов в контейнере deque.</li>
    <li>.pop_back() Удаляет элемент в конце deque.</li>
    <li>.pop_front() Удаляет элемент в начале deque.</li>
    <li>.push_back(a) Добавляет элемент в конец deque.</li>
    <li>.push_front(a) Добавляет элемент в начало deque.</li>
    <li>.front() Возвращает ссылку на первый элемент в deque.</li>
    <li>.back() Возвращает ссылку на последний элемент в deque.</li>
    <li>.begin() Возвращает итератор, указывающий на первый элемент.</li>
    <li>.end() Возвращает итератор, указывающий за последним элементом.</li>
    <li>.rbegin() Возвращает итератор, указывающий на последний элементом.</li>
    <li>.rend() Возвращает итератор, указывающий перед первым элементом.</li>
  </ol>
<pre>
deque&lt;int&gt; deq;
int tmp n;
cin >> n;
for (int i = 0; i &lt; n; i++) {
  cin >> tmp;
  deq.push_back(tmp);
}
sort(deq.begin(), deq.end());
for (int i = 0; i &lt; n; i++) {
  cout &lt;&lt; deq[i] &lt;&lt; " ";
}
</pre>
</article>


<!-- Задача A. Последовательность -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Последовательность</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 16мб</i></div>

  <p>Дана последовательность чисел, завершающаяся нулем. Вывести четные числа в прямом порядке, нечетные - в обратном.</p>

  <details>
    <summary>Пример</summary>
    <code>13 2 4 21 45 67 23 46 20 1 0</code>
<pre>
2 4 46 20
1 23 67 45 21 13
</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Решим при помощи структур данных, но без вектора.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;

using namespace std;

int main() {
  // ввод данных
  stack&lt;int&gt; st;
  queue&lt;int&gt; q;
  int tmp = 1;

  // решение
  while (tmp != 0) {
    cin >> tmp;
    if (tmp != 0) {
      if (tmp % 2 == 0) {
        q.push(tmp);
      } else {
        st.push(tmp);
      }
    }
  }

  // вывод результата
  while (!q.empty()) {
    cout &lt;&lt; q.front() &lt;&lt; " ";
    q.pop();
  }
  cout &lt;&lt; '\n';
  while (st.size() > 0) {
    cout &lt;&lt; st.top() &lt;&lt; " ";
    st.pop();
  }
}
</pre>
  </details>
</article>


<!-- Задача B. Скобки Скобочки -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Скобки Скобочки</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 16мб</i></div>

  <p>Определить, является ли скобочная последовательность правильной.</p>

  <h4>Входные данные</h4>
  <p>Задана последовательность скобок, состоящая из скобок (, ) и [, ].</p>

  <h4>Выходные данные</h4>
  <p>Вывести Yes, если последовательность правильная, No - в противном случае.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>[()]</code>
    <code>Yes</code>

    <h4>Пример 2</h4>
    <code>([[]()])</code>
    <code>Yes</code>

    <h4>Пример 3</h4>
    <code>(([()([])]))[]</code>
    <code>Yes</code>

    <h4>Пример 4</h4>
    <code>((([)]))</code>
    <code>No</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Эта задача решается только через стек. Перебираем в цикле символы входной строки со скобками. Если стек пустой, то кладем символ в стек. Иначе проверяем, если символ - закрывающая скобка, а в стеке такая же открывающая, то удаляем последний символ из стека. Иначе кладем символ в стек.</p>
    <p>Когда цикл закончится, проверяем стек. Если он пуст, то на входе была правильная скобочная последовательность, иначе - неправильная</p>
<pre>
#include &lt;iostream&gt;
#include &lt;stack&gt;

using namespace std;

int main() {
  // ввод данных
  string s;
  cin >> s;

  // решение
  stack&lt;char&gt; st;
  for (int i = 0; i &lt; s.size(); i++) {
    if (st.size() == 0) {
      st.push(s[i]);
    } else {
      if (s[i] == ')' && st.top() == '(') {
        st.pop();
      } else if (s[i] == ']' && st.top() == '[') {
        st.pop();
      } else {
        st.push(s[i]);
      }
    }
  }

  // вывод результата
  if (st.empty() == true) {
    cout &lt;&lt; "Yes";
  } else {
    cout &lt;&lt; "No";
  }
}
</pre>
  </details>
</article>


<!-- Задача C. Скобочная последовательность -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Скобочная последовательность</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Правильная скобочная последовательность определяется следующим способом:</p>
  <ol>
    <li>пустая строка - правильная скобочная последовательность;</li>
    <li>если "s" - правильная скобочная последовательность, то "(s)" - тоже правильная скобочная последовательность;</li>
    <li>если "s" и "t" - правильные скобочные последовательности, то "st" - тоже правильная скобочная последовательность.</li>
  </ol>
  <p>Дана скобочная последовательность. Достройте ее до правильной, добавив в конец наименьшее возможное число символов. Если это сделать невозможно, выведите IMPOSSIBLE.</p>

  <h4>Входные данные</h4>
  <p>Во входных данных содержится единственная строка длиной от 1 до 200000 символов, состоящая только из скобок "(" и ")".</p>

  <h4>Выходные данные</h4>
  <p>Если невозможно достроить последовательность до правильной, добавив в ее конец некоторое количество символов, выведите IMPOSSIBLE. Иначе выведите правильную скобочную последовательность, полученную из исходной строки добавлением наименьшего числа символов в конец.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>(()</code>
    <code>(())</code>

    <h4>Пример 2</h4>
    <code>(()())</code>
    <code>(()())</code>

    <h4>Пример 3</h4>
    <code>())(()</code>
    <code>IMPOSSIBLE</code>

    <h4>Пример 4</h4>
    <code>(()(()(</code>
    <code>(()(()()))</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Эта задача решается только через стек. Перебираем в цикле символы входной строки со скобками. Если символ - открывающая скобка, то кладем символ в стек. Если символ - закрывающая скобка, проверяем не пустой ли стек, Если не пустой, то удаляем последний символ из стека. Иначе невозможно достроить последовательность, выводим IMPOSSIBLE и заканчиваем программу.</p>
    <p>Если последовательность закончилась, проверяем стек и добавляем в конец исходной последовательности столько закрывающих скобок, сколько открывающих скобок осталось в стеке. Выводим правильную скобочную последовательность.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;stack&gt;
#include &lt;string&gt;

using namespace std;

int main() {
  // ввод данных
  string s;
  cin >> s;

  // решение
  stack&lt;char&gt; st;
  for (int i = 0; i &lt; s.size(); i++) {
    if (s[i] == '(') {
      st.push(s[i]);
    } else if (s[i] == ')') {
      if (st.empty()) {
        cout &lt;&lt; "IMPOSSIBLE";
        return 0;
      } else {
        st.pop();
      }
    }
  }

  for (int i = 0; i &lt; st.size(); i++) {
    s.append(")");
  }

  // вывод результата
  cout &lt;&lt; s;
}
</pre>
  </details>
</article>


<!-- Задача D. Нужно больше деков -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Нужно больше деков</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Восьмиклассник Всеволод начал изучать программирование, и первое что ему в этом деле понравилось - структуры данных! Особенно ему понравился дек, а он, как известно, любит изобретать.</p>

  <p>Всеволод хочет иметь интерактивную программу для работы с деком целых чисел, и он её подробно описал. Вводится одна из следующих команд: "push_back" - добавить элемент в конец дека, "pop_back" - удалить элемент из конца дека, "push_front" - добавить элемент в начало дека, "pop_front" - удалить элемент из начала дека, "show_front" - вывести на экран элемент стоящий в начале дека, "show_back" - вывести на экран элемент стоящий в конце дека.</p>

  <p>Так же Всеволод не хочет, чтобы каждый раз, когда он пытается удалить или показать элемент из пустого дека, программа не завершалась с ошибкой, а вместо этого, при попытке совершить такую операцию, выводить на экран сообщение "DEQUE IS EMPTY!".</p>

  <p>Каждый раз когда вводится команда добавления элмента в дек, после команды надо ввести добавляемое значение (целое число не превосходящее 10<sup>5</sup> по абсолютной величине). Каждый раз когда вводится команда показа элемента, нужно вывести нужное значение либо сообщение об ошибке.</p>

  <p>Команды добавления и удаления элемента из дека ничего не должны выводить, за исключением, быть может, сообщения об ошибке.</p>

  <p>Ну и как любая программа, она должна когда-нибудь завершиться, для этого нужно будет воспользоваться командой "Bye".</p>

  <p>Всеволод готовится к олимпиаде по программированию, поэтому у него нет времени для написания этой программы. Помогите Всеволоду написать её (даже если ваше имя тоже Всеволод).</p>

  <h4>Входные данные</h4>
  <p>На вход подаются описанные выше команды (без кавычек) пока не введется команда завершения. Обратите внимание на регистр входных и выходных данных.</p>

  <h4>Выходные данные</h4>
  <p>Вывести результаты работы команд, каждый с новой строки (без кавычек).</p>

  <details>
    <summary>Пример</summary>
<pre>
push_back 1
push_back 2
push_front 3
show_front
pop_front
show_back
show_front
Bye
</pre>
<pre>
3
2
1
</pre>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;deque&gt;

using namespace std;

int main() {
  string in;
  deque&lt;int&gt; d;
  int num;

  do {
    cin >> in;
    if (in == "push_back") {
      cin >> num;
      d.push_back(num);
    } else if (in == "push_front") {
      cin >> num;
      d.push_front(num);
    } else if (in == "pop_back") {
      if (d.empty()) {
        cout &lt;&lt; "DEQUE IS EMPTY!" &lt;&lt; '\n';
      } else {
        d.pop_back();
      }
    } else if (in == "pop_front") {
      if (d.empty()) {
        cout &lt;&lt; "DEQUE IS EMPTY!" &lt;&lt; '\n';
      } else {
        d.pop_front();
      }
    } else if (in == "show_back") {
      if (d.empty()) {
        cout &lt;&lt; "DEQUE IS EMPTY!" &lt;&lt; '\n';
      } else {
        cout &lt;&lt; d.back() &lt;&lt; '\n';
      }
    } else if (in == "show_front") {
      if (d.empty()) {
        cout &lt;&lt; "DEQUE IS EMPTY!" &lt;&lt; '\n';
      } else {
        cout &lt;&lt; d.front() &lt;&lt; '\n';
      }
    }
  } while (in != "Bye");
}
</pre>
  </details>
</article>


<!-- Задача E. Пробка в Цветочном городе -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Пробка в Цветочном городе</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Вернувшись из Солнечного города, Незнайка рассказал всем своим друзьям, что у каждого коротышки может быть личный автомобиль. Тут же среди жителей Цветочного города нашлось так много желающих стать автомобилистами, что Винтику и Шпунтику пришлось наладить серийное производство автомобилей на газированной воде с сиропом. Теперь на перекрёстке улицы Колокольчиков и улицы Маргариток иногда возникают заторы из нескольких автомобилей.</p>

  <p>Улица Колокольчиков идёт с юга на север и имеет две полосы. Движение на ней правостороннее: по восточной полосе автомобили едут с юга на север, а по западной — с севера на юг. Улица Маргариток — однополосная и перпендикулярна улице Колокольчиков. По ней организовано одностороннее движение, имеющее разное направление от улицы Колокольчиков (см. рисунок).</p>

  <p>Вчера Незнайка шёл домой и увидел, что на улице Колокольчиков с разных сторон от перекрёстка с улицей Маргариток стоят автомобили. Кто-то из водителей хотел ехать прямо, кто-то налево или направо. Автомобиль способен проехать через перекрёсток за одну секунду, но если водитель совершает левый поворот, он должен сперва пропустить встречные автомобили, следующие прямо и направо. За сколько секунд все автомобили проехали перекрёсток, если считать, что новые автомобили за это время к перекрёстку не подъезжали?</p>

  <h4>Входные данные</h4>
  <p>В первой строке записана последовательность символов «F», «L» и «R», описывающая, куда хотели далее следовать водители автомобилей, подъехавших к перекрёстку с юга. «F» означает, что они ехали прямо, «L» — что поворачивали налево, «R» — что направо. Автомобили перечислены в порядке от самого близкого к перекрёстку до самого далёкого. Во второй строке в том же формате описаны автомобили, подъехавшие к перекрёстку с севера. Обе последовательности имеют длину от 1 до 1000.</p>

  <h4>Выходные данные</h4>
  <p>Выведите время в секундах, за которое все автомобили проехали перекрёсток.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
RLF
FF
</pre>
    <code>4</code>

    <h4>Пример 2</h4>
<pre>
L
L
</pre>
    <code>1</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Всего возможно четыре ситуации.</p>
    <ol>
      <li>С двух сторон едут прямо и направо. Тогда они проезжают за 1 секунду</li>
      <li>С одной стороны едут прямо и направо. Они проезают за 1 секунду. С другой стороны едут налево. Они ждут</li>
      <li>С одной стороны едут налево. Они ждут. С другой стороны едут прямо и направо. Они проезжают за 1 секунду.</li>
      <li>С двух сторон едут налево. Тогда они проезжают за 1 секунду</li>
    </ol>
<pre>
#include &lt;iostream&gt;
#include &lt;queue&gt;

using namespace std;

int main() {
  // ввод данных
  string kol; // машины на ул.Колокольчиков
  string mar; // машины на ул.Маргариток
  cin >> kol >> mar;

  // решение
  int s = 0; // время в секундах
  queue&lt;char&gt; K;
  queue&lt;char&gt; M;

  for (int i = 0; i &lt; kol.length(); i++) {
    K.push(kol[i]);
  }

  for (int i = 0; i &lt; mar.length(); i++) {
    M.push(mar[i]);
  }

  while (!K.empty() && !M.empty()) {
    char nextK = K.front();
    char nextM = M.front();

    if ((nextK == 'F' || nextK == 'R') && (nextM == 'F' || nextM == 'R')) {
      s++;
      K.pop();
      M.pop();
    } else if ((nextK == 'F' || nextK == 'R') && (nextM == 'L')) {
      s++;
      K.pop();
    } else if ((nextK == 'L') && (nextM == 'F' || nextM == 'R')) {
      s++;
      M.pop();
    } else if ((nextK == 'L') && (nextM == 'L')) {
      s++;
      K.pop();
      M.pop();
    }
  }

  s += K.size() + M.size();

  // вывод результата
  cout &lt;&lt; s;
}
</pre>
  </details>
</article>


<!-- Задача F. Скобочки-2 -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Скобочки-2</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 16мб</i></div>

  <p>Напомним, что называется правильной скобочной последовательностью:</p>
  <ol>
    <li>пустая строка является правильной скобочной последовательностью;</li>
    <li>если строка a — правильная скобочная последовательность, то строки (a), [a] — тоже правильные скобочные последовательности;</li>
    <li>если строки a и b — правильные скобочные последовательности, то строка ab — тоже правильная скобочная последовательность.</li>
  </ol>
  <p>Задана строка S, состоящая из квадратных и круглых скобок. Разрешается заменять квадратную открывающую скобку ([) на круглую открывающую (() и наоборот, а также квадратную закрывающую скобку (]) на круглую закрывающую ()) и наоборот.</p>

  <p>За одно действие разрешается изменить ровно один символ строки. Необходимо за минимальное число действий преобразовать S в правильную скобочную последовательность.</p>

  <h4>Входные данные</h4>
  <p>Дана строка S. Ее длина не превосходит 100 000 символов.</p>

  <h4>Выходные данные</h4>
  <p>Выведите искомое минимальное число действий или -1, если преобразовать S в правильную скобочную последовательность невозможно.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>(())[]</code>
    <code>0</code>

    <h4>Пример 2</h4>
    <code>[(])</code>
    <code>2</code>

    <h4>Пример 3</h4>
    <code>((]]]</code>
    <code>-1</code>
  </details>

  <details>
    <summary>Решение</summary>

  <h4>Пример 4</h4>
  <code>(([]]</code>
  <code>-1</code>

<pre>
#include &lt;iostream&gt;
#include &lt;stack&gt;
#include &lt;string&gt;

using namespace std;

int main() {
  // ввод данных
  string s;
  cin >> s;

  // решение
  stack&lt;char&gt; st;
  int cnt = 0;
  for (int i = 0; i &lt; s.size(); i++) {

    if (s[i] == '(' || s[i] == '[') {
      // открывающую скобку кладем в стек
      st.push(s[i]);

    } else if (s[i] == ')') {

      if (st.empty()) {
        // закрывающая скобка и стек пустой
        cout &lt;&lt; -1;
        return 0;
      } else {

        if (st.top() == '[') {
          // делаем одну замену скобки
          cnt++;
        }
        st.pop();
      }

    } else if (s[i] == ']') {

      if (st.empty()) {
        // закрывающая скобка и стек пустой
        cout &lt;&lt; -1;
        return 0;
      } else {

        if (st.top() == '(') {
          // делаем одну замену скобки
          cnt++;
        }
        st.pop();
      }
    }
  }

  // если были лишние открывающие скобки
  if (!st.empty()) {
    cout &lt;&lt; -1;
    return 0;
  }

  // вывод результата
  cout &lt;&lt; cnt;
}
</pre>
  </details>
</article>


<!-- Задача G. Модифицированный стек -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Модифицированный стек</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В этой задаче вам нужно написать программу которая будет поддерживать стек и обрабатывать запросы 3-х видов:</p>
  <ol>
    <li>ADD a - добавить число a в стек, a - не превосходит 10000 по абсолютной величине.</li>
    <li>POP - удалить верхнее число из стека, если стек пуст, то ничего не делать.</li>
    <li>MIN - вывести минимум в текущем стеке, а если стек пуст - вывести STACK IS EMPTY.</li>
  </ol>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных находится число T (1 ≤ T ≤ 2 * 10⁵) - число запросов В следующих T строках описан один из трёх вышеописанных запросов.</p>

  <h4>Выходные данные</h4>
  <p>Выводить нужно ответ на запрос MIN - вывести минимум в текущем стеке, а если стек пуст - вывести STACK IS EMPTY. Вывод на каждый запрос осуществлять в отдельной строке</p>

  <details>
    <summary>Пример</summary>
<pre>
10
ADD 5
ADD 3
ADD 4
MIN
POP
POP
MIN
POP
MIN
POP
</pre>
<pre>
3
5
STACK IS EMPTY
</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Решим задачу нахождения наименьшего элемента стека за O(1).</p>
    <p>Для запоминания минимального элемента в стеке обычный стек, в каждой ячейке которого записан один элемент, не подойдет. Нужен стек с двумя элементами в каждой ячейке. Для этого будем хранить в стеке не сами элементы, а пары. Первый элемент это текущее значение, а второй элемент это минимильное значение от этой ячейки и ниже.</p>
    <p>Нахождение минимума во всём стеке будет заключаться просто во взятии значения stack.top().second. При добавлении нового элемента в стек величина second будет равна min (stack.top().second, new_element). Удаление элемента из стека ничем не отличается от удаления из обычного стека, поскольку удаляемый элемент никак не мог повлиять на значения second для оставшихся элементов.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;stack&gt;

using namespace std;

int main() {
  // число запросов
  int q;
  cin >> q;

  pair&lt;int, int&gt; buf;
  stack&lt;pair&lt;int, int&gt; &gt;st;
  string s;
  int a; // добавляемое число

  // запросы
  while (q--) {

    // следующий запрос
    cin >> s;
    if (s == "ADD") {

      // добавление элемента
      cin >> a; // добавляемое число
      buf.first = a;
      if (st.empty()) {
        buf.second = a;
      } else {
        buf.second = min(a, st.top().second);
      }
      st.push(buf);
    }
    if (s == "POP") {

      // извлечение элемента
      if (!st.empty()) {
        st.pop();
      }
    }

    if (s == "MIN") {

      // нахождение минимума
      if (!st.empty()) {
        cout &lt;&lt; st.top().second &lt;&lt; '\n';
      } else {
        cout &lt;&lt; "STACK IS EMPTY\n";
      }
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача H. Модифицированная очередь - 2 -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Модифицированная очередь - 2</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В этой задаче вам нужно написать программу которая будет поддерживать очередь и обрабатывать запросы 3-х видов:</p>
  <ol>
    <li>ADD a - добавить число a в очередь, a - не превосходит 10000 по абсолютной величине.</li>
    <li>POP - удалить переднее число из очереди, если очередь пуста, то ничего не делать.</li>
    <li>MIN - вывести минимум в текущей очереди, а если очередь пуста - вывести QUEUE IS EMPTY.</li>
  </ol>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных находится число T (1 ≤ T ≤ 2 * 10<sup>5</sup>) - число запросов В следующих T строках описан один из трёх вышеописанных запросов.</p>

  <h4>Выходные данные</h4>
  <p>Выводить нужно ответ на запрос MIN - вывести минимум в текущей очереди, а если очередь пуста - вывести QUEUE IS EMPTY. Вывод на каждый запрос осуществлять в отдельной строке</p>

  <details>
    <summary>Пример</summary>
<pre>
10
ADD 10
MIN
POP
ADD 10
ADD 15
MIN
POP
MIN
POP
MIN
</pre>
<pre>
10
10
15
QUEUE IS EMPTY
</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Решим задачу нахождения наименьшего элемента очереди за O(1).</p>
    <p>Идея заключается в том, чтобы свести задачу к задаче на стеках, которая уже была нами решена. Научимся моделировать очередь с помощью двух стеков.</p>
    <p>Заведём два стека: st1 и st2; разумеется, имеются в виду стеки, модифицированные для нахождения минимума за O (1). Добавлять новые элементы будет всегда в стек st1, а извлекать элементы - только из стека st2. При этом, если при попытке извлечения элемента из стека st2 он оказался пустым, просто перенесём все элементы из стека st1 в стек st2 (при этом элементы в стеке st2 получатся уже в обратном порядке, что нам и нужно для извлечения элементов; стек st1 же станет пустым). Наконец, нахождение минимума в очереди будет фактически заключаться в нахождении минимума из минимума в стеке st1 и минимума в стеке st2.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;stack&gt;

using namespace std;

int main() {
  // число запросов
  int q;
  cin >> q;

  pair&lt;int, int&gt; buf;
  stack&lt;pair&lt;int, int&gt; &gt;st1, st2;
  string s;
  int a; // добавляемое число

  // запросы
  while (q--) {

    // следующий запрос
    cin >> s;

    if (s == "ADD") {

      // добавление элемента
      cin >> a; // добавляемое число
      buf.first = a;
      if (st1.empty()) {
        buf.second = a;
      } else {
        buf.second = min(a, st1.top().second);
      }
      st1.push(buf);
    }

    if (s == "POP") {

      // извлечение элемента
      if (st2.empty()) {

        // перенесем в st2 элементы из st1
        while (!st1.empty()) {
          buf.first = st1.top().first;
          if (st2.empty()) {
            buf.second = buf.first;
          } else {
            buf.second = min(buf.first, st2.top().second);
          }
          st2.push(buf);
          st1.pop();
        }
      }

      if (!st2.empty()) {
        st2.pop();
      }
    }

    if (s == "MIN") {

      // нахождение минимума
      if (st1.empty() && st2.empty()) {
        cout &lt;&lt; "QUEUE IS EMPTY\n";
      } else if (st1.empty()) {
        cout &lt;&lt; st2.top().second &lt;&lt; '\n';
      } else if (st2.empty()) {
        cout &lt;&lt; st1.top().second &lt;&lt; '\n';
      } else {
        cout &lt;&lt; min(st1.top().second, st2.top().second) &lt;&lt; '\n';
      }
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача I. Настольный теннис -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача I. Настольный теннис</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>К теннисному столу выстроилась очередь из n человек. Сначала первые двое играют партию в теннис. Потом проигравший встаёт в конец очереди, а победитель играет со следующим человеком из очереди, и так далее. Они играют до тех пор, пока кто-нибудь не выиграет в k партиях подряд. Этот игрок признаётся победителем.</p>

  <p>Про каждого из участников вы знаете его силу игры в теннис, и у всех игроков они различны. В партии всегда побеждает игрок с большей силой. Определите, кто станет победителем.</p>

  <h4>Входные данные</h4>
  <p>В первой строке находятся два числа, разделённые пробелом: n и k (2 ≤ n ≤ 500, 2 ≤ k ≤ 10¹²) — количество людей и количество побед подряд, после которого игрок становится победителем, соответственно.</p>

  <p>В следующей строке содержится n целых чисел a₁, a₂, ..., aₙ (1 ≤ aᵢ ≤ n), выражающих силу игроков. Гарантируется, что эта строка содержит перестановку, то есть все aᵢ различны.</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно число — силу победителя.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
2 2
1 2
</pre>
    <code>2</code>

    <h4>Пример 2</h4>
<pre>
4 2
3 1 2 4
</pre>
    <code>3</code>
    <p>Партии во втором примере: 3 играет с 1. 3 побеждает, 1 идет в конец очереди. 3 играет с 2. 3 побеждает. У него две победы подряд, он становится победителем.</p>

    <h4>Пример 3</h4>
<pre>
6 2
6 5 3 1 2 4
</pre>
    <code>6</code>

    <h4>Пример 4</h4>
<pre>
2 10000000000
2 1
</pre>
    <code>2</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/879/problem/B" target="_blank">Задача 879B</a>
      <br><a href="https://codeforces.com/contest/879" target="_blank">Codeforces Round 443 (Div. 2) 2017-10-26</a>
    </div>

    <p>Победитель станет известен, когда кто-то выиграет k партий подряд или когда все сыграют хотябы по одному разу, в этом случае победит сильнейший при любом даже очень большом k, потому что все остальные подряд победы будут за ним</p>
<pre>
#include &lt;iostream&gt;
#include &lt;queue&gt;

using namespace std;

int main() {
  // ввод данных
  int n; // число игроков
  long long k; // число побед подряд
  cin >> n >> k;

  int gamer1, gamer2; // игроки за столом
  // введем первых двух игроков
  // и сразу поставим их за стол
  cin >> gamer1 >> gamer2;

  int tmp;
  queue&lt;int&gt; q;

  // ставим сильного игрока на первое место
  // а слабого на второе
  if (gamer2 > gamer1) {
    tmp = gamer2;
    gamer2 = gamer1;
    gamer1 = tmp;
  }

  // заполним очередь игроками
  for (int i = 2; i &lt; n; i++) {
    cin >> tmp;
    q.push(tmp);
  }

  // решение
  int count_win = 0; // число побед подряд одного игрока
  int iter = 0; // число проигравших игроков

  // пока все не сыграют или пока кто-то не выиграет k раз подряд
  while (iter &lt; n && count_win &lt; k) {
    if (gamer1 > gamer2) {
      // ставим слабого игрока в конец очереди
      q.push(gamer2);
      // а на его место ставим следующего игрока из начала очереди
      gamer2 = q.front();
      q.pop();
      // увеличиваем число побед сильного игрока
      count_win++;
    } else {
      // ставим слабого игрока в конец очереди
      q.push(gamer1);
      gamer1 = gamer2;
      // а на его место ставим следующего игрока из начала очереди
      gamer2 = q.front();
      q.pop();
      // сильный игрок сменился и число его побед равно 1
      count_win = 1;
    }
    iter++;
  }

  // вывод результата
  cout &lt;&lt; gamer1;
}
</pre>
  </details>
</article>


<!-- Задача J. Великое Лайнландское переселение -->
<article class="article">
  <div class="anchor" id="task10"></div>
  <h3>Задача J. Великое Лайнландское переселение</h3>

  <div><i>Ограничение по времени 0.8с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Лайнландия представляет из себя одномерный мир, являющийся прямой, на котором располагаются N городов, последовательно пронумерованных от 0 до N-1. Направление в сторону от первого города к нулевому названо западным, а в обратную — восточным.</p>

  <p>Когда в Лайнландии неожиданно начался кризис, все были жители мира стали испытывать глубокое смятение. По всей Лайнландии стали ходить слухи, что на востоке живётся лучше, чем на западе.</p>

  <p>Так и началось Великое Лайнландское переселение. Обитатели мира целыми городами отправились на восток, покинув родные улицы, и двигались до тех пор, пока не приходили в город, в котором средняя цена проживания была меньше, чем в родном.</p>

  <h4>Входные данные</h4>
  <p>В первой строке дано одно число N ( 2≤N≤10<sup>5</sup>) — количество городов в Лайнландии. Во второй строке дано N чисел a<sub>i</sub> ( 0≤a<sub>i</sub>≤10<sup>9</sup>) — средняя цена проживания в городах с нулевого по (N-1)-ый соответственно.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого города в порядке с нулевого по (N-1)-ый выведите номер города, в который переселятся его изначальные жители. Если жители города не остановятся в каком-либо другом городе, отправившись в Восточное Бесконечное Ничто, выведите -1</p>

  <details>
    <summary>Пример</summary>
<pre>
10
1 2 3 2 1 4 2 5 3 1
</pre>
    <code>-1 4 3 4 -1 6 9 8 9 -1 </code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Задача сводится к поиску для каждого города первого города справа (восточнее) с меньшей ценой проживания. Это классическая задача типа "следующий меньший элемент".</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);

  // ввод данных
  int n; // число городов
  cin >> n;

  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i]; // цена проживания в городе i
  }

  // решение
  vector&lt;int&gt; Res(n, -1);
  stack&lt;pair&lt;int, int&gt; &gt; grad;
  pair&lt;int, int&gt; tmp = { n - 1, A[n - 1] };

  // добавить в стек самый восточный город
  grad.push(tmp);

  for (int i = n - 2; i >= 0; i--) {
    while (!grad.empty() && grad.top().second >= A[i]) {
      // пока цена проживания меньше или равна
      // цене в восточном городе
      // удалять восточный город
      grad.pop();
    }
    if (!grad.empty()) {
      // если на востоке есть
      // город дешевле
      Res[i] = grad.top().first;
    }
    // добавить текущий город в стек
    tmp = { i, A[i] };
    grad.push(tmp);
  }

  // вывод результата
  for (int i = 0; i &lt; n; i++) {
    cout &lt;&lt; Res[i] &lt;&lt; ' ';
  }
}
</pre>
  </details>
</article>


<!-- Задача K. Минимум на отрезке -->
<article class="article">
  <div class="anchor" id="task11"></div>
  <h3>Задача K. Минимум на отрезке</h3>

  <div><i>Ограничение по времени 0.5с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Рассмотрим последовательность целых чисел длины N. По ней с шагом 1 двигается «окно» длины K, то есть сначала в «окне» видно первые K чисел, на следующем шаге в «окне» уже будут находиться K чисел, начиная со второго, и так далее до конца последовательности. Требуется для каждого положения «окна» определить минимум в нём.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных содержатся два числа N и K (1≤N≤150000, 1≤K≤10000, K≤N) — длины последовательности и «окна», соответственно. На следующей строке находятся N чисел — сама последовательность.</p>

  <h4>Выходные данные</h4>
  <p>Выходые данные должны содержать N-K+1 строк — минимумы для каждого положения «окна».</p>

  <details>
    <summary>Пример</summary>
<pre>
7 3
1 3 2 4 5 3 1
</pre>
<pre>
1
2
2
3
1
</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Решим задачу нахождения минимума на отрезках за линейное время, т.е. O (N).</p>
    <p>Для этого достаточно завести очередь, модифицированную для нахождения минимума за O (1), что было рассмотрено нами в предыдущей задаче. Далее решение уже понятно: добавим в очередь первые K элементов массива, найдём в ней минимум и выведем его, затем добавим в очередь следующий элемент, и извлечём из неё первый элемент массива, снова выведем минимум, и т.д. Поскольку все операции с очередью выполняются в среднем за константное время, то и асимптотика всего алгоритма получится O (N).</p>
<pre>
#include &lt;iostream&gt;
#include &lt;stack&gt;

using namespace std;

int main() {
  // ввод данных
  int n, k;
  cin >> n >> k;

  // число сдвигов окна
  int q = n - k;

  pair&lt;int, int&gt; buf;
  stack&lt;pair&lt;int, int&gt; &gt;st1, st2;
  int a; // добавляемое число

  // добавим в очередь первые k элементов
  while (k--) {
    // добавление элемента
    cin >> a; // добавляемое число
    buf.first = a;
    if (st1.empty()) {
      buf.second = a;
    } else {
      buf.second = min(a, st1.top().second);
    }
    st1.push(buf);
  }

  // выведем минимум первых k элементов
  cout &lt;&lt; st1.top().second &lt;&lt; '\n';

  // сдвиги окна
  while (q--) {

    // добавление элемента в конец окна
    cin >> a; // добавляемое число
    buf.first = a;
    if (st1.empty()) {
      buf.second = a;
    } else {
      buf.second = min(a, st1.top().second);
    }
    st1.push(buf);

    // извлечение элемента из начала окна
    if (st2.empty()) {

      // перенесем в st2 элементы из st1
      while (!st1.empty()) {
        buf.first = st1.top().first;
        if (st2.empty()) {
          buf.second = buf.first;
        } else {
          buf.second = min(buf.first, st2.top().second);
        }
        st2.push(buf);
        st1.pop();
      }
    }

    if (!st2.empty()) {
      st2.pop();
    }

    // выведем минимум k элементов
    if (st1.empty()) {
      cout &lt;&lt; st2.top().second;
    } else if (st2.empty()) {
      cout &lt;&lt; st1.top().second;
    } else {
      cout &lt;&lt; min(st1.top().second, st2.top().second);
    }
    cout &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача L. ПОЛИЗ -->
<article class="article">
  <div class="anchor" id="task12"></div>
  <h3>Задача L. ПОЛИЗ</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Задано выражение в польской инверсной записи (ПОЛИЗ), в которой доступны операции +, -, *, /. Найти значение выражения с точностью до 4 знаков после запятой. О том что такое польская инверсная запись можно прочитать здесь:</p>

  <a href="http://ru.wikipedia.org/wiki/Обратная_польская_запись">http://ru.wikipedia.org/wiki/Обратная_польская_запись</a>

  <h4>Входные данные</h4>
  <p>Входные данные представляют собой строку - выражение в ПОЛИЗ.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите ответ - значение выражения с точностью до 4 знаков после запятой.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>4 3 2 * 4 * + 37 2 - 3 2 * 5 + / +</code>
    <code>31.1818181818181798803379933815</code>

    <h4>Пример 2</h4>
    <code>37 2 - 3 2 * 5 + / 3 2 * 4 * + 4 +</code>
    <code>31.1818181818181798803379933815</code>
    <p>Тесты из примеров соответствуют следующему выражению:</p>
    <code>4 + 3 * 2 * 4 + (37 - 2) / (3 * 2 + 5)</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Принимаем строки разделенные пробелом. Если пришел символ операции, то извлекаем из стека два последних числа, выполняем над ними операцию, результат возвращаем в стек. Если это не символ операции, то это число, добавляем число в стек. После выполнения всех операций в стеке останется одно число - ответ.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;stack&gt;
#include &lt;cctype&gt;
#include &lt;string&gt;

using namespace std;

int main() {
  // ввод строки
  string s;

  // решение
  stack&lt;double&gt; st;

  while (cin >> s) {
    if (s == "+") {
      double b = st.top();
      st.pop();
      double a = st.top();
      st.pop();
      double c = a + b;
      st.push(c);
    } else if (s == "-") {
      double b = st.top();
      st.pop();
      double a = st.top();
      st.pop();
      double c = a - b;
      st.push(c);
    } else if (s == "*") {
      double b = st.top();
      st.pop();
      double a = st.top();
      st.pop();
      double c = a * b;
      st.push(c);
    } else if (s == "/") {
      double b = st.top();
      st.pop();
      double a = st.top();
      st.pop();
      double c = a / b;
      st.push(c);
    } else {
      double a = stod(s);
      st.push(a);
    }
  }
  double res = st.top();

  // вывод результата
  cout &lt;&lt; fixed &lt;&lt; setprecision(6) &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача M. Дикие обезьяны -->
<article class="article">
  <div class="anchor" id="task13"></div>
  <h3>Задача M. Дикие обезьяны</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>А тем временем в Южной Варляндии полным ходом шли исследования реки Шамазонки и области Шамазонии. Особенно поразили ученых шамазонские обезьяны. Чтобы добыть себе плоды, висящие на верхушке деревьев, им приходится выполнять тщательно взбираться по лианам, которые в свою очередь работают как весы: если на одной из лиан висит обезьян больше, чем на другой, то обе ветви разорвутся и все обезьяны упадут вниз. Поэтому важно сохранять баланс между ветвями деревьев. Лианы дерева могут содержать ровно две подлианы, каждая из которых должна содержать одинаковое количество обезьян. В данной задаче лиана, содержащая две подлианы, будет обозначаться двумя квадратными скобками «[]», причём подлианы могут содержать ещё подлианы и т.д. Гарантируется, что в данной задаче вложенность лиан не достигает 25 уровней. По заданной конфигурации дерева определите минимальное количество обезьян, которое необходимо, чтобы лианы были сбалансированы и обезьяны смогли получить плоды с верхушки дерева.</p>

  <h4>Входные данные</h4>
  <p>В единственной строке ввода содержится строка S - конфигурация лиан. S может иметь длину от 0 до 150 символов.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите минимальное количество обезьян, чтобы сбалансировать лианы.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>[]</code>
    <code>2</code>

    <h4>Пример 2</h4>
    <code>[[][[]]]</code>
    <code>8</code>
    <p>Левый рисунок соответствует конфигурации и расположению обезьян в первом примере, правый - во втором.</p>
  </details>

  <details>
    <summary>Решение</summary>

  <h4>Пример 17</h4>
  <code>[[[][]][]]</code>
  <code>8</code>

  <h4>Пример 18</h4>
  <code>[[][[[[][]][]][]]]</code>
  <code>32</code>

  <h4>Пример 19</h4>
  <code>[[[[][]][]][[][]]]</code>
  <code>16</code>

  <h4>Пример 20</h4>
  <code>[[[[][]][]][]]</code>
  <code>16</code>

  <p>Найдем самую удаленную лиану, на ней будет сидеть 2 обезьяны, по одной на каждой подлиане. Для этого будем использовать счетчик level. Пробежим по строке, открывающая скобка level++, закрывающая скобка level--.</p>
  <p>На каждом уровне выше число обезьян удваивается.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;

using namespace std;

int main() {
// условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // ввод данных
  string s;
  cin >> s;

  // решение

  // найдем самую удаленную лиану,
  // на ней будет сидеть две обезьяны
  int level = 0; // текущий уровень
  int max_l = 0; // максимальный уровень
  for (char ch : s) {
    if (ch == '[') {
      level++;
      max_l = max(max_l, level);
    } else {
      level--;
    }
  }

  // на каждом уровне выше
  // число обезьян удваивается
  int res = pow(2, max_l);


  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача N. 38 попугаев -->
<article class="article">
  <div class="anchor" id="task14"></div>
  <h3>Задача N. 38 попугаев</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Как известно, длина удава составляет 5 мартышек, 2 слоненка или 38 попугаев и одно попугайское крылышко из-за того, что звери не могут использовать метрическую систему. Доктор Айболит решил проверить, можно ли подобрать единицу измерения среди животных, выстроившихся к нему в очередь на прием.</p>

  <p>Лечение занимает большую часть времени доктора, поэтому заниматься измерениями он может только в свободное время.</p>

  <p>Приходя на прием к доктору, звери выстраиваются в очередь. Когда пациент встает в очередь, помощник доктора измеряет его длину и заносит результат измерения в список. Прием ведется в порядке очереди. После окончания прием пациент из списка вычеркивается. Периодически Айболит смотрит в список и пытается определить, есть ли в списке такой зверь, которым можно измерить всех остальных (ещё не вычеркнутых зверей из списка) так, чтобы их длины оказались целыми числами.</p>

  <p>Напишите программу, которая поможет доктору Айболиту.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных содержится число N (1≤N≤10<sup>5</sup>) – количество действий со списком пациентов. В следующих N строках содержится описание действий со списком пациентов. Действия бывают 3 видов:</p>
  <ol>
    <li>«+ X» – в очередь добавляется новый пациент длиной X (1≤X≤10<sup>9</sup>)</li>
    <li>«–» – из очереди удаляется пациент</li>
    <li>«?» – есть ли в очереди такой пациент, длиной которого можно измерить всех зверей, стоящих в очереди. Гарантируется, что очередь не пуста.</li>
  </ol>

  <h4>Выходные данные</h4>
  <p>Для каждого запроса вида «?» выведите «N», если в списке зверей нет того, которым можно измерить длины всех остальных зверей. В противном случае выведите «Y» и длину зверя, которым можно измерить длины всех остальных зверей.</p>

  <h4>Система оценки</h4>
  <p>Баллы за каждую подзадачу начисляются только в случае, если все тесты для этой подзадачи и необходимых подзадач успешно пройдены.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
10
+4
+2
?
+3
?
-
-
?
+1
?
</pre>
<pre>
Y2
N
Y3
Y1
</pre>

    <h4>Пример 2</h4>
<pre>
2
+5
?
</pre>
<pre>
Y5
</pre>
  </details>

  <details>
    <summary>Решение</summary>

    <h4>Тест 11</h4>
    <code>8 +12 ? +18 ? +9 ? - ?</code>
    <code>Y12 N N Y9</code>

    <p>Только минимальное из чисел может быть делителем нескольких чисел, если это возможно.</p>
    <p>Заведем <strong>очередь (queue)</strong> для добавления и удаления из нее элементов.</p>
    <p>Заведем <strong>множество multiset</strong> для быстрого поиска минимума.</p>
    <p>При <strong>добавлении</strong> элемента. Сначала проверяем условие, если очередь пустая, то текущий НОД равен добавляемому элементу, если очередь не пустая и такого элемента нет в множестве, то пересчитываем текущий НОД с минимальным элементом и храним его. Потом элемент добавляем в очередь и в множество.</p>
    <p>При <strong>удалении</strong> элемента если очередь не пустая. Сначала удаляем элемент из очереди и из множества. Потом проверяем условие, если очередь не пустая и такого элемента больше нет в множестве и минимальный элемент не равен текущему НОД, то пересчитываем текущий НОД для всех элементов в множестве.</p>
    <p>При <strong>проверке</strong> на существующий делитель. Проверяем условие, если очередь не пустая и минимальный элемент в множестве равен текущему НОД, то выводим 'Y', иначе 'N'.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;set&gt;

using namespace std;

int gcd(int a, int b) {
  while (a != 0 && b != 0) {
    if (a > b) {
      a = a % b;
    } else {
      b = b % a;
    }
  }
  return a + b;
}

int main() {
  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // ввод данных
  int n; // число запросов
  cin >> n;

  // решение
  queue&lt;int&gt; q; // очередь
  multiset&lt;int&gt; m; // множество
  int current_gcd = 0;

  while (n--) {
    char d; // очередное действие
    cin >> d;

    if (d == '+') {
      // следующее число
      int x;
      cin >> x;

      if (q.empty()) {
        // если очередь пустая
        current_gcd = x;
      } else if (m.find(x) == m.end()) {
        // если элемента еще нет в множестве
        // пересчитываем gcd
        current_gcd = gcd(current_gcd, x);
      }

      q.push(x); // добавление в очередь
      m.insert(x); // добавление в множество
    }

    if (d == '-' && !q.empty()) {
      // удаление из непустой очереди
      int num = q.front();
      q.pop(); // удаление из очереди
      m.erase(m.find(num)); // удаление из множества

      // если очередь не пустая после удаления элемента
      // если такого элемента больше нет в множестве
      // и текущий НОД не равен минимальному элементу
      if (!q.empty() && m.find(num) == m.end() && *m.begin() != current_gcd) {
        // пересчитываем gcd
        current_gcd = 0;
        for (const auto& el : m) {
          current_gcd = gcd(current_gcd, el);
        }
      }

      // если очередь пустая после удаления элемента
      if (q.empty()) {
        current_gcd = 0;
      }
    }

    if (d == '?') {
      // вывод ответа
      if (!q.empty() && *m.begin() == current_gcd) {
        cout &lt;&lt; 'Y' &lt;&lt; current_gcd &lt;&lt; '\n';
      } else {
        cout &lt;&lt; "N\n";
      }
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача O. Правильная скобочная подпоследовательность -->
<article class="article">
  <div class="anchor" id="task15"></div>
  <h3>Задача O. Правильная скобочная подпоследовательность</h3>

  <div><i>Ограничение по времени 5с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Напомним, что скобочная последовательность называется правильной, если путем вставки в нее символов «+» и «1» можно получить из нее корректное математическое выражение. Например, последовательности «(())()», «()» и «(()(()))» — правильные, в то время как «)(», «(()» и «(()))(» — нет.</p>

  <p>Однажды Васе попалась скобочная последовательность. Он решил удалить из нее некоторые скобки так, чтобы последовательность стала правильной. Какую наибольшую длину может иметь получившаяся правильная скобочная последовательность?</p>

  <h4>Входные данные</h4>
  <p>В первой строке входного файла записана непустая строка, состоящая из символов «(» и «)». Её длина не превосходит 10<sup>6</sup>.</p>

  <h4>Выходные данные</h4>
  <p>Выведите длину наибольшей правильной скобочной подпоследовательности.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>(()))(</code>
    <code>4</code>

    <h4>Пример 2</h4>
    <code>((()())</code>
    <code>6</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/26/problem/B" target="_blank">Задача 26B</a>
      <br><a href="https://codeforces.com/contest/26" target="_blank">Codeforces Beta Round 26 (Codeforces format) 2010-08-16</a>
    </div>

<pre>
#include &lt;iostream&gt;
#include &lt;stack&gt;

using namespace std;

int main() {
  stack&lt;char&gt; St;
  char c;
  int cnt = 0;

  while (cin.get(c) && c != '\n') {
    if (c == '(') {
      St.push(c);
    } else {
      if (!St.empty()) {
        St.pop();
        cnt += 2;
      }
    }
  }

  // вывод результата
  cout &lt;&lt; cnt;
}
</pre>
  </details>
</article>


<!-- Задача P. Гистограмма -->
<article class="article">
  <div class="anchor" id="task16"></div>
  <h3>Задача P. Гистограмма</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Гистограмма является многоугольником, сформированным из последовательности прямоугольников, выровненных на общей базовой линии. Прямоугольники имеют равную ширину, но могут иметь различные высоты. Например, фигура слева показывает гистограмму, которая состоит из прямоугольников с высотами 2, 1, 4, 5, 1, 3, 3. Все прямоугольники на этом рисунке имеют ширину, равную 1.</p>

  <p>Обычно гистограммы используются для представления дискретных распределений, например, частоты символов в текстах. Отметьте, что порядок прямоугольников очень важен. Вычислите область самого большого прямоугольника в гистограмме, который также находится на общей базовой линии. На рисунке справа заштрихованная фигура является самым большим выровненным прямоугольником на изображенной гистограмме.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входного файла записано число N (0&lt;N≤10<sup>6</sup>) — количество прямоугольников гистограммы. Затем следует N целых чисел h<sub>1</sub> ... h<sub>n</sub>, где 0≤h<sub>i</sub>≤10<sup>9</sup>. Эти числа обозначают высоты прямоугольников гистограммы слева направо. Ширина каждого прямоугольника равна 1.</p>

  <h4>Выходные данные</h4>
  <p>Выведите площадь самого большого прямоугольника в гистограмме. Помните, что этот прямоугольник должен быть на общей базовой линии.</p>

  <details>
    <summary>Пример</summary>
    <code>7 2 1 4 5 1 3 3</code>
    <code>8</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Создадим стек для отслеживания индексов столбцов гистограммы. Стек поддерживается в порядке возрастания высот.</p>
    <p>Для каждого столбца мы проверяем, можно ли добавить его в стек (если его высота больше или равна высоте столбца на вершине стека). Если нет, мы извлекаем элементы из стека и вычисляем площадь прямоугольника как сумму извлеченных столбцов умноженную на высоту последнего извлеченного столбца (наименьшего из них по высоте).</p>
    <p>После обработки всех столбцов оставшиеся элементы в стеке обрабатываются аналогично, чтобы убедиться, что все возможные прямоугольники учтены.</p>
    <p>Этот подход эффективно находит максимальную площадь прямоугольника за линейное время, обрабатывая каждый столбец гистограммы не более двух раз (один раз при добавлении в стек и один раз при извлечении).</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

// условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // ввод данных
  int n; // число прямоугольников
  cin >> n;
  vector&lt;long long&gt; H(n);
  for (int i = 0; i &lt; n; ++i) {
    cin >> H[i]; // высоты прямоугольников
  }

  // решение
  long long res = 0; // максимальная площадь
  long long area = 0; // текущая площадь
  stack&lt;long long&gt; st; // стек для индексов столбцов
  long long i = 0; // индекс столбца в векторе H
  // для каждого столбца

  while (i &lt; n) {

    if (st.empty() || H[st.top()] &lt;= H[i]) {
      // если стек пуст или столбец
      // не меньше верхнего в стеке
      // добавляем столбец в стек
      st.push(i++);

    } else {
      // если столбец меньше верхнего в стеке
      // берем верхний индекс и удаляем из стека
      long long top = st.top();
      st.pop();

      // пересчитываем текущую площадь
      area = H[top] * (st.empty() ? i : i - st.top() - 1);
      if (area > res) {
        // если текущая площадь больше максимальной
        // обновляем максимальную площадь
        res = area;
      }
    }
  }

  // обрабатываем оставшиеся в стеке индексы
  while (!st.empty()) {
    // пока в стеке есть индексы
    // берем верхний индес и удаляем из стека
    long long top = st.top();
    st.pop();
    // пересчитываем текущую площадь
    area = H[top] * (st.empty() ? n : n - st.top() - 1);
    if (area > res) {
        // если текущая площадь больше максимальной
        // обновляем максимальную площадь
      res = area;
    }
  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача Q. Вежливые соседи -->
<article class="article">
  <div class="anchor" id="task17"></div>
  <h3>Задача Q. Вежливые соседи</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Игорь и Ира решили поехать на дачу, ведь там куча дел: прополоть и полить грядки, собрать урожай, окучить картошку, проверить сохранность забора, уточнить наличие ящиков для хранения урожая и много-много всего.</p>

  <p>Приехав на дачу, Игорь и Ира увидели, что никого из соседей не было. У Игоря и Иры все соседи на даче очень вежливые люди. Игорю стало интересно, кто из соседей уезжает с дачи каждый день, а кто остается ночевать. Для этого Игорь будет в течение дня записывать в блокнот следующие события:</p>
  <ul>
    <li>+ k – сосед из домика под номером k приехал на свою дачу.</li>
    <li>- k – сосед из домика под номером k сел в машину и собирается уехать.</li>
  </ul>

  <p>Дачные участки стоят вдоль узкой дороги и пронумерованы от 1 до N. Когда соседи приезжают на дачу, они всегда хотят встать рядом со своим участком k, ведь так гораздо удобней. Они могут это сделать только в том случае, если перед участками с 1-го по k-1-й не стоят машины. Если соседи не могут проехать к своему дому, тогда они оставляют свою машину на общей парковке перед дачами.</p>

  <p>Если сосед хочет уехать и его машина стоит на парковке, то он без проблем садится в машину и уезжает, если сосед хочет уехать и его машина стоит рядом с его участком, тогда он садится в машину и уезжает только в том случае, если на дороге не стоят машины перед участками с 1
   по k-1, иначе он сидит и ждет, как вежливый сосед, пока не уедут все машины, которые мешают, если этого не получилось, то он остается на даче.</p>

  <p>Соседи могут возвращаться и уезжать с дачи несколько раз.</p>

  <p>Помогите Игорю – определите, кто из соседей в конце дня остался ночевать на даче, кто – уехал домой, а кто из соседей вообще не приезжал на дачу.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит два целых числа N, M (1 ≤ N, M ≤ 10⁵) – количество соседей и количество записей.</p>

  <p>В следующих M строках содержатся записи в блокноте Игоря:</p>
  <ul>
    <li>+ k (1 ≤ k ≤ N) – на дачу с номером k приехал сосед.</li>
    <li>- k (1 ≤ k ≤ N) – с дачи номер k уезжает сосед.</li>
  </ul>

  <p>Гарантируется, что перед операцией '+' соседа нет ни на участке, ни в машине рядом с участком.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого i соседа выведите в i строке 'YES' (без кавычек), если сосед смог уехать домой, 'NO' (без кавычек), если сосед не уехал и остался ночевать на даче, '-1' (без кавычек) если сосед не приезжал на дачу.</p>

  <details>
    <summary>Пример</summary>
<pre>
5 7
+ 3
+ 4
+ 2
- 4
- 3
+ 1
- 1
</pre>
<pre>
YES
NO
NO
YES
-1
</pre>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/gym/104453/problem/J" target="_blank">Задача 104453J</a>
      <br><a href="https://codeforces.com/gym/104453" target="_blank">ICPC Central Russia Regional Qualyfing Round, 2021 2010-08-16</a>
    </div>

    <p>Решается методом стека с маркировкой. Каждого участника будем маркировать (надевать на него бейджик). Mark[i] = 0 если соседа не было на даче. Mark[i] = 1 если сосед приехал на дачу. Mark[i] = -1 если сосед уехал с дачи.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;stack&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  int n, m;
  cin >> n >> m;
  stack&lt;int&gt; st;
  st.push(n + 10); // несуществующий сосед
  vector&lt;int&gt; Pos(n + 11), Park(n + 11), Uch(n + 11), Mark(n + 11);
  char ch;
  int k;
  for (int i = 0; i &lt; m; i++) {
    cin >> ch >> k;

    // решение
    if (ch == '+') {
      Pos[k] = 1;
      Mark[k] = -1;
      if (st.top() &lt; k) {
        Park[k] = 1;
      } else {
        Uch[k] = 1;
        st.push(k);
      }
    } else {
      if (Park[k] == 1) {
        Mark[k] = 1;
        Park[k] = 0;
      } else {
        Uch[k] = -1;
        while (Uch[st.top()] == -1) {
          Uch[st.top()] = 0;
          Mark[st.top()] = 1;
          st.pop();
        }
      }
    }
  }

  // вывод результата
  for (int i = 1; i &lt;= n; i++) {
    if (Mark[i] == 0) {
      cout &lt;&lt; "-1\n";
    } else if (Mark[i] == 1) {
      cout &lt;&lt; "YES\n";
    } else {
      cout &lt;&lt; "NO\n";
    }
  }
}
</pre>
  </details>
</article>


<!-- R. Небоскрёбы (усложнённая версия) -->
<article class="article">
  <div class="anchor" id="task18"></div>
  <h3>Задача R. Небоскрёбы (усложнённая версия)</h3>

  <div><i>Ограничение по времени 3с
  <br>Ограничение по памяти 512мб</i></div>

  <p>Это более сложная версия задачи. В этой версии n≤500000</p>

  <p>В Берляндии активно застраивается окраина столицы. Компания «Kernel Panic» руководит постройкой жилого комплекса из небоскрёбов в Новой Берлскве. Все небоскрёбы строятся вдоль шоссе. Известно, что компания уже купила n участков возле шоссе и готовится возвести n небоскрёбов, по одному зданию на один участок.</p>

  <p>Архитекторы при планировании зданий должны учитывать несколько требований. Во-первых, поскольку земля на каждом участке имеет разные свойства, для каждого небоскрёба есть свое ограничение по количеству этажей, которое он может иметь. Во-вторых, согласно дизайн-коду города, недопустима ситуация, когда для какого-то небоскрёба сразу по обе стороны от него есть небоскрёбы выше него.</p>

  <p>Более формально, пронумеруем участки целыми числами от 1 до n. Тогда у небоскрёба на участке с номером i количество этажей a<sub>i</sub> не может быть больше m<sub>i</sub> (1 ≤ a<sub>i</sub> ≤ m<sub>i</sub>). Также не может быть, что на плане существуют два участка с номерами j и k, таких что j &lt; i &lt; k и a<sub>j</sub> > a<sub>i</sub> &lt; a<sub>k</sub>. Участки j и k не обязаны быть соседними с i.</p>

  <p>Компания хочет, чтобы суммарное количество этажей в построенных небоскрёбах было как можно больше. Помогите ей выбрать количество этажей для каждого небоскрёба оптимальным образом, то есть так, чтобы выполнялись все ограничения, а среди всех таких вариантов выберите один из планов, в котором суммарное количество этажей максимально возможно.</p>

  <h4>Входные данные</h4>
  <p>В первой строке задано одно целое число n (1 ≤ n ≤ 500000) — количество участков.</p>

  <p>Вторая строка содержит целые числа m<sub>1</sub>, m<sub>2</sub>, ... , m<sub>n</sub> (1 ≤ m<sub>i</sub> ≤ 10<sup>9</sup>) —максимально возможное количество этажей для небоскрёба на каждом участке.</p>

  <h4>Выходные данные</h4>
  <p>Выведите n чисел a<sub>i</sub> — количества этажей в плане для каждого небоскрёба, такие, что выполняются все ограничения, а суммарное количество этажей во всех небоскрёбах максимально возможное.</p>

  <p>Если возможно несколько ответов, выведите любой.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
5
1 2 3 2 1
</pre>
    <code>1 2 3 2 1</code>
    <p>В первом примере можно построить все небоскрёбы с максимально возможной высотой.</p>

    <h4>Пример 2</h4>
<pre>
3
10 6 8
</pre>
    <code>10 6 6</code>
    <p>Во втором примере придать максимальную высоту всем небоскрёбам нельзя, так как это нарушает ограничение дизайн-кода. Ответ [10,6,6]  является оптимальным. Обратите внимание, что ответ [6,6,8] также удовлетворяет всем ограничениям, но оптимальным не является.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1313/problem/C2" target="_blank">Задача 1313C2</a>
      <br><a href="https://codeforces.com/contest/1313" target="_blank">Codeforces Round 622 (Div. 2) 2020-02-23</a>
    </div>

    <p>Нам нужно создать последовательность, где нет ситуации, когда небоскрёб имеет соседей с обеих сторон, которые выше его. Это означает, что последовательность должна быть унимодальной (сначала возрастает, затем убывает).</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;

using namespace std;

// функция Sum возвращает вектор пар
// first - максимальная сумма этажей до текущей позиции
// second - индекс предыдущего меньшего элемента
vector&lt;pair&lt;long long, int&gt; &gt; Sum(const vector&lt;int&gt;& Et, int n) {
  vector&lt;pair&lt;long long, int&gt; &gt; Res(n);

  // стек пар возрастающих чисел
  // first - значение
  // second - индекс
  stack&lt;pair&lt;int, int&gt; &gt; st;
  st.push(make_pair(0, -1)); // базовый случай

  for (int i = 0; i &lt; n; i++) {
    // поддерживаем возрастающий порядок в стеке
    while (st.top().first >= Et[i]) {
      // достаем из стека элементы
      // которые больше или равны текущему
      st.pop();
    }

    // число домов, где Et[i] максимальное
    int i_max = i - st.top().second;

    // вклад текущего сегмента
    long long cur_seg = (long long)Et[i] * (i_max);

    // весь сегмент это сумма текущего и предыдущего
    long long seg = cur_seg + (st.top().second >= 0 ?
    Res[st.top().second].first : 0);

    // индекс предыдущего меньшего элемента
    int min_el_idx = st.top().second;

    // максимальная сумма
    Res[i] = make_pair(seg, min_el_idx);

    // добавляем текущий элемент в стек
    st.push(make_pair(Et[i], i));
  }

  return Res;
}

int main() {
  // ускорение ввода-вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // ввод данных
  int n;  // число домов
  cin >> n;
  vector&lt;int&gt; Et(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> Et[i]; // этажи
  }

  // решение

  // прямой проход находит оптимальную
  // возрастающую последовательность
  // t[i].first - максимальная сумма до позиции i
  // t[i].second -  индекс предыдущего меньшего элемента
  vector&lt;pair&lt;long long, int&gt; &gt; inc_pass = Sum(Et, n);

  // переворачиваем массив Et
  reverse(Et.begin(), Et.end());

  // обратный проход находит оптимальную
  // убывающую последовательность
  vector&lt;pair&lt;long long, int&gt; &gt; dec_pass = Sum(Et, n);

  // переворачиваем результат обратно
  reverse(dec_pass.begin(), dec_pass.end());

  // восстанавливаем исходный порядок Et
  reverse(Et.begin(), Et.end());

  // ищем индекс пика
  // inc_pass[i].first - сумма слева
  // dec_pass[i].first - сумма справа
  // вычитаем Et[i] чтобы избежать двойного учёта текущего элемента
  int ind = 0;
  for (int i = 0; i &lt; n; i++) {
    if (inc_pass[i].first + dec_pass[i].first - Et[i] >
        inc_pass[ind].first + dec_pass[ind].first - Et[ind]) {
      ind = i;
    }
  }

  // собираем результат
  vector&lt;int&gt; Res(n);

  // левая часть до пика
  for (int i = ind; i >= 0; i = inc_pass[i].second) {
    for (int j = i; j > inc_pass[i].second; j--) {
      Res[j] = Et[i];
    }
  }

  // подготовка к заполнению правой части
  // переворачиваем dec_pass
  reverse(dec_pass.begin(), dec_pass.end());
  // переворачиваем Et
  reverse(Et.begin(), Et.end());
  // новый индекс пика для перевернутого массива
  ind = n - 1 - ind;
  // переворачиваем частично заполненный результат
  reverse(Res.begin(), Res.end());

  // правая часть после пика
  for (int i = ind; i >= 0; i = dec_pass[i].second) {
    for (int j = i; j > dec_pass[i].second; j--) {
      Res[j] = Et[i];
    }
  }

  // переворачиваем полностью заполненный результат
  reverse(Res.begin(), Res.end());

  // вывод результата
  for (int i = 0; i &lt; n; i++) {
    cout &lt;&lt; Res[i] &lt;&lt; ' ';
  }
}
</pre>
  </details>
</article>


<!-- S. Майк и футы -->
<article class="article">
  <div class="anchor" id="task19"></div>
  <h3>Задача S. Майк и футы</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Майк — президент страны What-The-Fatherland. Помимо Майка, там живёт ещё n медведей. Все они стоят в ряд и пронумерованы от 1 до n слева направо. Рост i-го медведя составляет ровно ai футов.</p>

  <p>Назовём группой медеведей непустой непрерывный подотрезок этого ряда. Размер группы — это количество медведей в этой группе. Сила группы — это минимальная высота медведя в этой группе.</p>

  <p>Майку хочется знать для каждого x, такого что 1 ≤ x ≤ n, максимальную силу группы медведей размера x.</p>

  <h4>Входные данные</h4>
  <p>В первой строке ввода записано целое число n (1 ≤ n ≤ 2*10<sup>5</sup>), количество медведей.</p>

  <p>Во второй строке записано n целых чисел, разделенных пробелом, a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> (1 ≤ a<sub>i</sub> ≤ 10<sup>9</sup>) — высоты медведей.</p>

  <h4>Выходные данные</h4>
  <p>Выведите n целых чисел в одной строке. Для каждого x от 1 до n выведите максимальную силу среди всех групп размера x.</p>

  <details>
    <summary>Пример</summary>
<pre>
10
1 2 3 4 5 4 3 2 1 6
</pre>
    <code>6 4 4 3 3 2 2 1 1 1</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/547/problem/B" target="_blank">Задача 547B</a>
      <br><a href="https://codeforces.com/contest/547" target="_blank">Codeforces Round 305 (Div. 1) 2015-05-26</a>
    </div>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // ввод данных
  int n; // число медведей
  cin >> n;
  vector&lt;int&gt; A(n + 1);
  for (int i = 1; i &lt;= n; i++) {
    cin >> A[i]; // высота медведя
  }

  // решение
  vector&lt;int&gt; left(n + 1, 0);
  vector&lt;int&gt; right(n + 1, n + 1);
  stack&lt;int&gt; st;

  // находим ближайший меньший элемент слева для каждого элемента
  for (int i = 1; i &lt;= n; i++) {
    while (!st.empty() && A[st.top()] >= A[i]) {
      st.pop();
    }
    if (!st.empty()) {
      left[i] = st.top();
    } else {
      left[i] = 0; // нет меньшего элемента слева
    }
    st.push(i);
  }

  // очищаем стек для использования в следующем проходе
  while (!st.empty()) {
    st.pop();
  }

  // находим ближайший меньший элемент справа для каждого элемента
  for (int i = n; i > 0; i--) {
    while (!st.empty() && A[st.top()] >= A[i]) {
      st.pop();
    }
    if (!st.empty()) {
      right[i] = st.top();
    } else {
      right[i] = n + 1; // нет меньшего элемента справа
    }
    st.push(i);
  }

  vector&lt;int&gt; B(n + 1, 0);
  // для каждого элемента
  for (int i = 1; i &lt;= n; i++) {
    // находим длину отрезка, где он минимальный
    int len = right[i] - left[i] - 1;
    // обновляем ответ
    B[len] = max(B[len], A[i]);
  }

  // Проходим с конца, чтобы заполнить пропущенные значения
  for (int i = n - 1; i >= 1; i--) {
    B[i] = max(B[i], B[i + 1]);
  }

  // вывод результата
  for (int i = 1; i &lt;= n; i++) {
    cout &lt;&lt; B[i] &lt;&lt; ' ';
  }
}
</pre>
  </details>

</article>


<!-- T. Две головы - лучше -->
<article class="article">
  <div class="anchor" id="task20"></div>
  <h3>T. Две головы - лучше</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Ученый с мировым именем Иннокентий решил заняться теорией вычислимости и изобрел новый абстрактный исполнитель, представляющий собой ленту из n ячеек, в каждой из которых записана строчная латинская буква. По ленте ездят две головки, каждая из которых указывает на некоторую ячейку. Это устройство умеет исполнять следующие команды: перемещать заданную головку влево или вправо на одну ячейку, переворачивать ленту между головками, включая ячейки, на которые указывают головки, а также отвечать за запросы, на какой символ указывает заданная головка. Иннокентий попросил вас помочь ему проэмулировать работу этого устройства, потому что собственноручно написанная им программа работает слишком медленно.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записаны три целых числа через пробел: n, l и r (1 ≤ n ≤ 10<sup>5</sup>, 1 ≤ l &lt; r ≤ n) — количество ячеек ленты и начальные позиции левой и правой головок соответственно.</p>

  <p>Во второй строке записаны n строчных латинских букв — содержимое ячеек.</p>

  <p>В третьей строке записано единственное целое число m (1 ≤ m ≤ 3·10<sup>5</sup>) — количество запросов.</p>

  <p>Далее в m строках содержатся запросы следующего вида.</p>
  <ol>
    <li>S X Y — сдвинуть головку X в сторону Y, где X может принимать значения L для левой головки и R для правой головки, а Y может принимать значения L для сдвига влево и R для сдвига вправо.</li>
    <li>R — перевернуть ленту между головками, включая ячейки, на которые указывают головки.</li>
    <li>Q X — спросить, на какой символ указывает головка X, где X может принимать значения L для левой головки и R для правой головки.</li>
  </ol>

  <p>Гарантируется, что левая головка после любого запроса остается левее правой, а также что головки не выходят за пределы ленты.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите ответы на запросы последнего типа. На k-ой позиции выведите единственный строчный латинский символ c<sub>k</sub> — ответ на k-ый по порядку запрос вида «Q X».</p>

  <details>
    <summary>Пример</summary>
<pre>
11 2 6
abracadabra
12
Q L
Q R
R
Q L
Q R
S L R
S R R
Q L
Q R
R
Q L
Q R
</pre>
    <code>baabcddc</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/gym/100488/problem/L" target="_blank">Задача 100488L</a>
      <br><a href="https://codeforces.com/gym/100488" target="_blank">2014, Отборочный контест СГАУ на четвертьфинал ACM ICPC 2014-09-21</a>
    </div>

<pre>
#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;stack&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // ввод данных
  int n; // число ячеек
  int l; // левый указатель
  int r; // правый указатель
  cin >> n >> l >> r;

  list&lt;char&gt; Li; // двусвязный список
  char in;
  for (int i = 0; i &lt; n; i++) {
    cin >> in;
    Li.push_back(in);
  }

  int m; // число запросов
  cin >> m;

  // решение
  stack&lt;char&gt; L_st;
  stack&lt;char&gt; R_st;
  char tmp;

  // заполняем стек справа от правого указателя
  for (int i = r + 1; i &lt;= n; i++) {
    tmp = Li.back();
    Li.pop_back();
    R_st.push(tmp);
  }

  // заполняем стек слева от левого указателя
  for (int i = 1; i &lt; l; i++) {
    tmp = Li.front();
    Li.pop_front();
    L_st.push(tmp);
  }

  list&lt;char&gt; Res;
  char q; // запрос
  char X, Y; // указатель и направление
  bool reversed = false;

  while (m--) {
    cin >> q;

    // сдвинуть головку на один шаг
    if (q == 'S') {
      cin >> X >> Y;

      // левую головку
      if (X == 'L') {
        if (!reversed) {

          // влево
          if (Y == 'L') {
            tmp = L_st.top();
            L_st.pop();
            Li.push_front(tmp);
          }

          // вправо
          if (Y == 'R') {
            tmp = Li.front();
            Li.pop_front();
            L_st.push(tmp);
          }

        } else {

          if (Y == 'L') {
            tmp = L_st.top();
            L_st.pop();
            Li.push_back(tmp);
          }

          if (Y == 'R') {
            tmp = Li.back();
            Li.pop_back();
            L_st.push(tmp);
          }
        }

      }

      // правую головку
      if (X == 'R') {
        if (!reversed) {

          // влево
          if (Y == 'L') {
            tmp = Li.back();
            Li.pop_back();
            R_st.push(tmp);
          }

          // вправо
          if (Y == 'R') {
            tmp = R_st.top();
            R_st.pop();
            Li.push_back(tmp);
          }

        } else {

          if (Y == 'L') {
            tmp = Li.front();
            Li.pop_front();
            R_st.push(tmp);
          }

          if (Y == 'R') {
            tmp = R_st.top();
            R_st.pop();
            Li.push_front(tmp);
          }
        }
      }
    }

    // перевернуть ленту между головками
    if (q == 'R') {
      if (!reversed) {
        reversed = true;
      } else {
        reversed = false;
      }
    }

    // на какой символ указывает головка
    if (q == 'Q') {
      cin >> tmp;

      if (tmp == 'L') {
        if (!reversed) {
          Res.push_back(Li.front());
        } else {
          Res.push_back(Li.back());
        }
      }

      if (tmp == 'R') {
        if (!reversed) {
          Res.push_back(Li.back());
        } else {
          Res.push_back(Li.front());
        }
      }
    }

  }

  // вывод результата
  for (char ch : Res) {
    cout &lt;&lt; ch;
  }
}
</pre>
  </details>

</article>


<!-- U. Последнее слово техники -->
<article class="article">
  <div class="anchor" id="task21"></div>
  <h3>Задача U. Последнее слово техники</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Все знают, насколько бессмысленны открытия британских ученых. Все знают, как японские ученые любят огромных боевых человекоподобных роботов. В этой задаче речь пойдет о французских ученых, которые умудрились соединить в себе и то, и другое: недавно был выпущен робот "Рене Декарт", хоть не боевой, но огромный и совершенно бессмысленный.</p>
  <p>"Рене Декарт" умеет двигаться по массиву целых чисел и вставлять по разные стороны от себя новые элементы. Научное сообщество решило проверить, насколько эффективно новое творение французских ученых, поэтому заготовило q команд, которые роботу надлежит исполнить.</p>
  <p>Итак, в начале эксперимента "Рене Декарт" находился на позиции p массива из n целых чисел (1 &le; p &le; n). Ему могут подавать 5 видов команд</p>
  <ol>
    <li>print - вывести элемент массива, на котором он стоит</li>
    <li>moveLeft - переместиться на шаг влево, если там есть элемент</li>
    <li>moveRight - переместиться на шаг вправо, если там есть элемент</li>
    <li>insertLeft x - вставить слева от себя новый элемент x</li>
    <li>insertRight x - вставить справа от себя новый элемент x</li>
  </ol>
  <p>К сожалению, ученым не удается найти, к какому именно результату должно привести исполнение робором этой серии команд. Поэтому они обратились к вам.</p>
  <p>Вам нужно, зная последовательность команд, вывести правильные ответы на команды print.</p>

  <h4>Входные данные</h4>
  <p>В первой строке через пробел записаны два целых числа n и p (1 &le; n &le; 200000, 1 &le; p &le; n) - количество элементов в массиве в начальный момент времени и позиция в массиве, на которой в начальный момент времени находится робот.</p>
  <p>Во второй строке через пробел перечислены n целых чисел a<sub>i</sub>, ..., a<sub>n</sub> (-10<sup>9</sup> &le; a<sub>i</sub> &le; 10<sup>9</sup> - массив, на позиции p которого в начальный момент времени находится робот.</p>
  <p>В третьей строке записано целое число q (1 &le; q &le; 200000) - количество командр, которые должен исполнить робот.</p>
  <p>Каждая из следующих q строк содержит команду. Их описание дано выше. Значение элемента массива x в коммандах insertLeft и insertright находится в пределах от -10<sup>9</sup> до 10<sup>9</sup>.</p>

  <h4>Выходные данные</h4>
  <p>Для каждой команды типа print на отдельной строке выведите значение элемента массива, на котором в этот момент находится робот.</p>

  <details>
    <summary>Пример</summary>
<pre>
3 2
2 3 5
15
moveLeft
insertLeft 1
moveLeft
print
moveLeft
moveRight
print
moveRight
insertRight 4
moveRight
moveRight
print
moveRight
moveLeft
print
</pre>
<pre>
1
2
5
4
</pre>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/gym/100090/problem/J" target="_blank">Задача 100090J</a>
      <br><a href="https://codeforces.com/gym/100090" target="_blank">2012, Отборочный контест СГАУ на четвертьфинал ACM ICPC 2012-10-06</a>
    </div>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;list&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // ввод данных
  int n; // размер массива A
  int p; // начальная позиция робота
  cin >> n >> p;

  list&lt;int&gt; A; // двусвязный список
  int in = 0;
  for (int i = 1; i &lt;= n; i++) {
    cin >> in;
    A.push_back(in); // добавим элемент в конец списка
  }

  // поставим указатель на позицию p в списке
  auto posA = A.begin();
  for (int i = 1; i &lt; p; i++) {
    posA++;
  }

  int q; // число запросов
  cin >> q;

  while (q--) {
    string cmd; // следующая команда
    cin >> cmd;
    if (cmd == "print") { // печать элемента
      cout &lt;&lt; *posA &lt;&lt; '\n';
    } else if (cmd == "moveLeft") { // шаг влево
      if (posA != A.begin()) {
        posA--;
      }
    } else if (cmd == "moveRight") { // шаг вправо
      posA++;
      if (posA == A.end()) {
        posA--;
      }
    } else if (cmd == "insertLeft") { // вставка слева
      int x;
      cin >> x;
      A.insert(posA, x);
    } else if (cmd == "insertRight") { // вставка справа
      int x;
      cin >> x;
      A.emplace(next(posA), x);
    }
  }

}
</pre>
  </details>
</article>

