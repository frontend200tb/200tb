<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contests" target="_blank">Codeforces ЯрГУ. Школьники</a></p>
  <p><a href="https://vk.com/sportprog_yarsu" target="_blank">vk.com/sportprog_yarsu</a></p>
  <p><a href="https://vkvideo.ru/@sportprog_yarsu" target="_blank">vkvideo.ru/@sportprog_yarsu</a></p>
</article>


<article class="article">
  <h1>Занятие 23 Комбинаторика #1. Основы</h1>
  <p>Конспект видео от 2025.03.01</p>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contest/592220" target="_blank">Codeforces Контест 592220</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
    <a href="#p1">Комбинаторика #1. Основы</a>
  </p>
  <p>
        <a href="#task1">Задача A. Дальние родственники и торт</a>
    <br><a href="#task2">Задача B. Счастливые номера</a>
    <br><a href="#task3">Задача C. Очередь</a>
    <br><a href="#task4">Задача D. Отличные билеты</a>
    <br><a href="#task5">Задача E. Шахматы</a>
    <br><a href="#task6">Задача F. Включи и исключи</a>
    <br><a href="#task7">Задача G. Число сочетаний</a>
    <br><a href="#task8">Задача H. Число сочетаний - 2</a>
    <br><a href="#task9">Задача I. Сегодня в белом танце кружимся</a>
    <br><a href="#task10">Задача J. Домашнее задание</a>
    <br><a href="#task11">Задача K. Флаги</a>
    <br><a href="#task12">Задача L. Записная книжка</a>
    <br><a href="#task13">Задача M. Коля и Таня</a>
    <br><a href="#task14">Задача N. Весь мир театр</a>
    <br><a href="#task15">Задача O. Посчитайте массивы</a>
    <br><a href="#task16">Задача P. Прямоугольные треугольники</a>
    <br><a href="#task17">Задача Q. Умный дартс</a>
    <br><a href="#task18">Задача R. Два массива</a>
  </p>
</article>


<!-- Комбинаторика #1. Основы -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Комбинаторика #1. Основы</h3>

  <p>Комбинаторика - математический раздел, изучающий вопросы о том, сколько различных комбинаций, подчиненных тем или иным условиям, можно составить из заданных объектов.</p>
  <p>Задачи на комбинаторику в спортивном программировании обычно разделяются на два типа:</p>
  <ol>
    <li>Посчитать сложный объект и в качестве результата вывести некоторое число;</li>
    <li>Сгенерировать комбинаторный объект / или вывести все подходящие комбинаторные объекты.</li>
  </ol>
  <p>Основные комбинаторные объекты:</p>
  <ol>
    <li>Перестановка;</li>
    <li>Размещение;</li>
    <li>Сочетание;</li>
    <li>Перестановка с повторением;</li>
    <li>Размещение с повторением;</li>
    <li>Сочетание с повторением.</li>
  </ol>

  <h4>Перестановка</h4>

  <p>Перестановка n объектов/элементов — это способ их последовательного расположения с учётом порядка. Например, abc, bca и cab — это разные перестановки трёх букв.</p>
  <p>Перестановку n объектов ещё называют перестановкой длины n. Количество всех таких перестановок обозначается как Pn.</p>
  <code>Pn = n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1</code>

  <p>Перестановка n объектов это факториал от n.</p>
  <code>0! = 1</code>
  <code>1! = 1</code>
  <code>2! = 1 * 2 = 2</code>
  <code>3! = 1 * 2 * 3 = 6</code>
  <code>4! = 1 * 2 * 3 * 4 = 24</code>
  <p>Пример всех перестановок длины 4 из четырех чисел:</p>
<pre>
1234 1243 1324 1342 1423 1432
2134 2143 2314 2341 2413 2431
3124 3142 3214 3241 3412 3421
4123 4132 4213 4231 4312 4321
</pre>
  <p>Реализация на C++:</p>
<pre>
int main() {
  int n;
  cin >> n;

  long long res = 1;
  for (int i = 1; i &lt;= n; i++) {
    res *= i;
  }
  cout &lt;&lt; res &lt;&lt; '\n';
}

long long P(int n) {
  if (n > 0) {
    return n * P(n-1);
  } else {
    return 1;
  }
}
</pre>

  <h4>Размещение</h4>

  <p>Размещение из n по k — это упорядоченный набор из k различных элементов, взятых из некоторого множества с мощностью n, где k ≤ n. То есть некая перестановка k выбранных элементов из n.</p>
  <p>Пример задачи:</p>
  <p>Пусть у нас есть n различных шариков и k лунок. Мы хотим в каждую лунку положить ровно один шарик. Сколько существует различных вариантов распределения.</p>
  <p>Очевидно, что в первую лунку можно положить любой шарик из n во вторую лунку вариантов остается n - 1 и так далее до k лунки.</p>
  <code>A = n! / (n - k)!</code>

  <h4>Сочетание</h4>

  <p>Сочетание из n по k — это неупорядоченный набор из k различных  элементов, взятых из некоторого множества с мощностью n, где k ≤ n. То есть набор, для которого порядок выбора не имеет значения.</p>
  <code>C = A / k = n! / ((n - k)!*k!)</code>
  <code>C0 = 1, C1 = n, C2 = n*(n-1)/2</code>
  <p>Выпишем все сочетания из 6 по 3</p>
<pre>
123 124 125 126 134
135 136 145 146 156
234 235 236 245 246
256 345 346 356 456
</pre>
  <p>Программные способы нахождения числа сочетаний (плохой вариант):</p>
<pre>
int n, k;
cin >> n >> k;
long long res = 1;

for (int i = 1; i &lt;= n; i++) {
  res *= i;
}

for (int i = 1; i &lt;= k; i++) {
  res /= i;
}

for (int i = 1; i &lt;= n - k; i++) {
  res /= i;
}

cout &lt;&lt; res;
</pre>

  <p>Программные способы нахождения числа сочетаний (средний вариант):</p>
<pre>
int n, k;
cin >> n >> k;
long long res = 1;

for (int i = max(k, n - k) + 1; i &lt;= n; i++) {
  res *= i;
}

for (int i = 1; i &lt;= min(k, n - k); i++) {
  res /= i;
}

cout &lt;&lt; res;
</pre>
  <p>Если в задаче гарантируют, что число сочетаний помещается в тип данных int или long long, можно собирать специальным образом.</p>
  <code>C = n! / ((n-k)!*k!) = большая формула</code>
  <p>Программные способы нахождения числа сочетаний (хороший вариант):</p>
  <p>Level[i] это степень, в которое мы хотим возвести число i. Level[i] > 0 только в том случае если i является простым. Сложность O(n), хотя и кажется что цикл в цикле в цикле это O(n³)</p>
<pre>
vector&lt;int&gt; Level(n + 1);
for (int i = max(k, n - k) + 1; i &lt;= n; i++) {
  int tmp = i;
  for (int j = 2; j * j &lt;= tmp; j++) {
    while (tmp % j == 0) {
      tmp /= j;
      Level[j]++;
    }
  }
  if (tmp != 1) {
    Level[tmp]++;
  }
}

for (int i = 1; i &lt;= min(k, n - 1); i++) {
  int tmp = i;
  for (int j = 2; j * j &lt;= tmp; j++) {
    while (tmp % j == 0) {
      tmp /= j;
      Level[j]--;
    }
  }
  if (tmp != 1) {
    Level[tmp]--;
  }
}

for (int i = 1; i &lt;= n; i++) {
  while (Level[i] > 0) {
    res *= i;
    Level[i]--;
  }
}
</pre>

  <p>Есть способ подсчета сочетание через математический объект треугольник Паскаля. Каждая строка которого показывает биномиальные коэффициенты многочленов (a + b)ⁿ.</p>
  <p>Элементы треугольника получаются из суммы двух элементов строкой выше.</p>
  <p>Чтобы найти число сочетаний C<sub>n</sub><sup>k</sup> (C из n по k), надо взять n-ую строчку треугольника сверху и отсчитать k-ый элемент слева. В нем будет находиться ответ.</p>
<pre>
              1
            1    1
         1    2    1
      1     3    3   1
    1    4    6    4   1
  1   5    10   10   5   1
1   6   15   20   15   6   1
</pre>

  <p>Построим треугольник Паскаля.</p>
<pre>
int C[100][100];
for (int i = 0; i &lt; 100; i++) {
  C[i][0] = 1;
  C[i][1] = 1;
}
for (int i = 1; i &lt; 100; i++) {
  for (int j = 1; j &lt; i; j++) {
    C[i][j] = C[i-1][j] + C[i-1][j-1];
  }
}
</pre>

  <p>Программный способ нахождения чисел сочетаний через треугольник Паскаля (хороший вариант):</p>
<pre>
vector&lt;vector&lt;long long&gt; &gt; DP(n + 1, vector&long long&gt;(n + 1));
for (int i = 0; i &lt;= n; i++) {
  for (int j = 0; j &lt;= i; j++) {
    if (j == 0 || i == j) {
      DP[i][j] = 1;
    } else {
      DP[i][j] = DP[i - 1][j] + DP[i - 1][j - 1];
    }
  }
}
</pre>

  <h4>Перестановка с повторением</h4>

  <p>Поставим перед собой задачу:</p>
  <p>Пусть у нас есть n лунок и n шариков, некоторые из которых одинаковые. Мы можем положить один шарик в одну лунку и в одной лунке может находиться только один шарик. Вопрос какое количество различных распределений шариков по лункам существует?</p>
  <p>Если бы все шарики были различны, ответом на задачу была бы перестановка Pn. В случае, когда у нас есть повторы мы можем вычислить количество перестановок с повторениями.</p>
  <code>P(n1,n2,...,nh) = n! / (n1! * n2! * ... * nh!)</code>
  <code>n = n1 + n2 + ... + nh</code>

  <h4>Размещение с повторением</h4>

  <p>Поставим перед собой задачу:</p>
  <p>Пусть у нас есть бесконечное количество шариков красного, зеленого, голубого и других цветом. Всего раскрасок n. Пусть у нас есть k лунок, и мы хотим поместить в каждую лунку ровно один шарик любого цвета. Тогда очевидно, что в каждую лунку существует выбор из n цветов шариков.</p>
  <code>A = nᵏ</code>

  <h4>Сочетание с повторением</h4>
  <p>Сочетание с повторениями – это неупорядоченная (n,k)-выборка с повторениями. Общее количество сочетаний с повторениями:</p>
  <code>C = (n + k - 1)! / (k! * (n - 1)!)</code>
</article>


<!-- Задача A. Дальние родственники и торт -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Дальние родственники и торт</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Семья Доров готовится праздновать день рождения Фомы Дора, для этого члены семьи приготовили ему весьма своеобразный торт.</p>

  <p>Торт представляет собой квадрат n x n, состоящий из одинаковых квадратиков со стороной 1. Каждый квадрат либо пустой, либо содержит шоколадку. Члены семьи испекли торт и разложили на нём шоколадки. Они думают, что радость Фомы будет равна количеству пар клеток с шоколадками, расположенных в одной строке или в одном столбце. Теперь они пытаются вычислить, чему же будет равно это значение для данного торта.</p>

  <p>Обратите внимание, что каждая пара может быть посчитана не более чем один раз, поскольку две различные клетки не могут быть одновременно расположены в одной строке и в одном столбце.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных записано единственное целое число n (1 ≤ n ≤ 100) — длина стороны торта.</p>

  <p>Следующие n строк содержат по n символов, описывающих сам торт. Пустые клетки обозначаются символом «.», а клетки, содержащие шоколадку, задаются символом «C».</p>

  <h4>Выходные данные</h4>
  <p>Выведите, чему будет равна радость Фомы Дора, когда он увидит торт, то есть количество клеток с шоколадками, расположенных в одной строке или в одном столбце.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
3
.CC
C..
C.C
</pre>
    <code>4</code>

    <h4>Пример 2</h4>
<pre>
4
CC..
C..C
.CC.
.CC.
</pre>
    <code>9</code>
    <p>Пронумеруем строки сверху вниз, а столбцы слева направо. Тогда в одной строке расположены:</p>
    <ol>
      <li>(1, 2) и (1, 3)</li>
      <li>(3, 1) и (3, 3)</li>
    </ol>
    <p>В одном столбце расположены следующие клетки с шоколадками:</p>
    <ol>
      <li>(2, 1) и (3, 1)</li>
      <li>(1, 3) и (3, 3)</li>
    </ol>
  </details>
</article>


<!-- Задача B. Счастливые номера -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Счастливые номера</h3>

  <div><i>Ограничение по времени 0.5с
  <br>Ограничение по памяти 64мб</i></div>

  <p>В новом здании налоговой инспекции ИТ-града было решено номера всех кабинетов сделать счастливыми.</p>

  <p>Счастливым называется номер, состоящий только из цифр 7 и 8. Найдите максимальное количество кабинетов в новом здании налоговой инспекции, если на табличку с номером кабинета помещается не более чем n-значное число.</p>

  <h4>Входные данные</h4>
  <p>Единственная строка входных данных содержит одно целое число n (1 ≤ n ≤ 55) — максимальная длина числа, которое помещается на табличку.</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно целое число — максимальное количество кабинетов, которые можно занумеровать различными счастливыми номерами длины не более n.</p>

  <details>
    <summary>Пример</summary>
    <code>2</code>
    <code>6</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Счастливых номеров среди n значных чисел будет ровно 2ⁿ. Нам же нужно посчитать все счастливые номера среди чисел начиная от однозначных до n значных</p>
    <code>2ⁿ + 2ⁿ⁻¹ + ... + 2² + 2</code>
  </details>
</article>


<!-- Задача C. Очередь -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Очередь</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Сколькими способами можно выстроить в очередь выстроились N
  детей так, чтобы Влад и Азик не стояли рядом?</p>

  <h4>Входные данные</h4>
  <p>В единственной строке содержится число N (2 ≤ N ≤ 10⁶) – количество детей, выстроившихся в очередь.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите число – количество способов выстроить детей так, чтобы Влад и Азик не стояли рядом. Ответ следует выводить по модулю 10⁹+7.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>2</code>
    <code>0</code>

    <h4>Пример 2</h4>
    <code>3</code>
    <code>2</code>
  </details>
</article>


<!-- Задача D. Отличные билеты -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Отличные билеты</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Большинство студентов в Берляндии добираются до университета на общественном транспорте. Студенты математического факультета устали соревноваться, кто соберет больше счастливых билетов по-московски и по-питерски и придумали новый вид счастливого билета – счастливый билет по-берляндски. N-значный билет называется счастливым по-берляднски, если разность некоторых двух соседних цифр его номера равна 5. Так, например, билет с номером 05 является считается счастливым по-берляндски, а билет 0123 – нет. Студенты просят Вас узнать, сколько всего существует N-значных билетов, счастливых по-берляндски. Но так как это число может быть большим, они просят Вас найти их количество по модулю 10⁹ + 7 (то есть остаток от деления количества счастливых по-берляндски билетов на число 10⁹ + 7).</p>

  <h4>Входные данные</h4>
  <p>В единственной строке содержится целое число N (2 ≤ N ≤ 10⁹) – количество цифр в билете.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите ответ на задачу.</p>

  <h4>Система оценки</h4>
  <p>В этой задаче 20 тестов, каждый оценивается в 5 баллов. Тесты из условия оцениваются в 0 баллов.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>2</code>
    <code>10</code>

    <h4>Пример 2</h4>
    <code>4</code>
    <code>2710</code>
  </details>
</article>


<!-- Задача E. Шахматы -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Шахматы</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Недавно в городе Васюки в преддверии проведения междупланетного шахматного турнира открылся Всемирный шахматный центр (ВШЦ), в котором сражаются друг с другом лучшие шахматные умы Васюков и близлежащих городов.</p>

  <p>Недавно Васюки проездом посетил великий Маэстро, который к тому же являлся и математиком, а потому поставил васюкинскими гроссмейстерами такую задачу: на доске размером N x N стоит ладья. Он поставил на доску ладью, подвигал её так, чтобы она сделала ровно четыре хода и вернулась в исходную клетку, посетив при этом четыре различные клетки. Сколькими способами ладья могла совершить такое путешествие?</p>

  <p>На всякий случай напомним, что ладья может перемещаться по вертикали или горизонтали на любое расстояние, не выходя за границы доски.</p>

  <h4>Входные данные</h4>
  <p>В единственной строке содержится число N (2 ≤ N ≤ 60) - размер доски.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите число - количество способов, которыми ладья могла совершить описанное путешествие.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>2</code>
    <code>8</code>

    <h4>Пример 2</h4>
    <code>3</code>
    <code>72</code>
    <p>В первом примере на доске 4 клетки. Начально можно поставить ладью в любую из них, то есть у нас 4 комбинации. Чтобы сделать полный оборот за 4 хода и вернуться в начальную клетку, ладья может пойти по часовой стрелке или против, то есть всего два варианта. Значит всего способов 4 * 2 = 8.</p>
    <p>Во втором примере на доске 9 клеток. Начально ладью можно поставить 9ю способами. Рассмотрим как она может пойти. По горизонтали на любую из 2 клеток, потом по вертикали на любую из 2 клеток, затем вернуться на начальную клетку одним способом. То есть имеем (n-1) * (n - 1) * 1 * 1 комбинаций. Ладья также может начать с движения по вертикали. Это еще (n-1) * (n-1) * 1 * 1 комбинаций. Всего получим 9 * 2 * 2 + 9 * 2 * 2 = 72 комбинации. Мы вывели формулу для доски размером 3 на 3.</p>
    <code>P = 2 * (n * n * (n-1) * (n-1)) = 2 * n² * (n-1)²</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Если доска размером 4 на 4, то добавляются еще варианты, когда ладья ходит на 4 разные клетки только по своей горизонтали или вертикали.</p>
    <p>Придумаем и рассмотрим пример 3, когда на доске 8 на 8 клеток. Будем считать перемещения только по одной горизонтали. Можно ходить только на те клетки, которые еще не посещали. Первый ход можно сделать на 7 различных клеток. Второй ход на 6, третий на 5, а на четвертый ход мы обязаны вернуться в начальную клетку, то есть это единственный наш вариант. Получается 7 * 6 * 5 = 210. Мы вывели формулу</p>
    <code>P = (n-1) * (n-2) * (n-3)</code>
    <p>Учитывая что по одной вертикали можно сделать столько же комбинаций, напишем всю формулу целиком для доски размером 4 на 4 и более</p>
    <code>P = 2 * n² * (n-1)² + 2 * (n-1) * (n-2) * (n-3)</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  long long n;
  cin >> n;
  long long res;

  // начальная позиция ладьи
  long long start = n * n;

  // варианты хождения по кругу
  long long circle = 2 * (n - 1) * (n - 1);

  // варианты хождения по линии
  long long line = 2 * (n - 1) * (n - 2) * (n - 3);

  res = start * (circle + line);

  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача F. Включи и исключи -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Включи и исключи</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Найти количество чисел в пределах от 1 до N, которые либо делятся на A, либо делятся на B, либо делятся на C.</p>

  <h4>Входные данные</h4>
  <p>В единственной строке содержится число N (1 ≤ N ≤ 10¹⁰). Во второй строке содержатся числа A, B, C (1 ≤ A, B, C ≤ min(N, 10⁶)).</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите число – ответ на задачу.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
10
1 2 3
</pre>
    <code>10</code>

    <h4>Пример 2</h4>
<pre>
5
1 2 3
</pre>
    <code>5</code>

    <h4>Пример 3</h4>
<pre>
100
2 3 5
</pre>
    <code>74</code>
  </details>
</article>


<!-- Задача G. Число сочетаний -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Число сочетаний</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Числом сочетаний из n элементов по k (C<sub>n</sub><sup>k</sup>) — называется набор k элементов, выбранных из данных n элементов, причем наборы, отличающиеся только порядком следования элементов (но не составом), считаются одинаковыми. Требуется найти число сочетаний из n по k (C<sub>n</sub><sup>k</sup>). Так как оно может быть очень большим, вывести ответ по модулю 10⁹ + 7.</p>

  <h4>Входные данные</h4>
  <p>На ввод подаются числа n и k разделённые пробелом. 1 ≤ n ≤ 100, 0 ≤ k ≤ n</p>

  <h4>Выходные данные</h4>
  <p>Вывести число сочетаний из n по k (C<sub>n</sub><sup>k</sup>) по модулю 10⁹ + 7.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>4 1</code>
    <code>4</code>

    <h4>Пример 2</h4>
    <code>4 2</code>
    <code>6</code>

    <h4>Пример 3</h4>
    <code>8 3</code>
    <code>56</code>
  </details>
</article>


<!-- Задача H. Число сочетаний -2 -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Число сочетаний -2</h3>

  <div><i>Ограничение по времени 0.5с
  <br>Ограничение по памяти 128мб</i></div>
  <p>Числом сочетаний из n элементов по k (C<sub>n</sub><sup>k</sup>) — называется набор k элементов, выбранных из данных n элементов, причем наборы, отличающиеся только порядком следования элементов (но не составом), считаются одинаковыми. Требуется найти число сочетаний из n по k (C<sub>n</sub><sup>k</sup>). В данной задаче НЕ ТРЕБУЕТСЯ выводить ответ по модулю 10⁹ + 7, т.к. гарантируется что ответ не превысит значения 9 * 10¹⁸</p>

  <h4>Входные данные</h4>
  <p>На ввод подаются числа n и k разделённые пробелом. 1 ≤ n ≤ 10⁷, 0 ≤ k ≤ n</p>

  <h4>Выходные данные</h4>
  <p>Вывести число сочетаний из n по k (C<sub>n</sub><sup>k</sup>).</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>4 1</code>
    <code>4</code>

    <h4>Пример 2</h4>
    <code>4 2</code>
    <code>6</code>

    <h4>Пример 3</h4>
    <code>8 3</code>
    <code>56</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Зная треугольник Паскаля и ограничение, что ответ помещается в 9 * 10¹⁸, можно предположить что ответ расположенный в треугольнике Паскаля, будет находиться только в небольшой полоске около двух боковых сторон треугольника. Но треугольник Паскаля все равно не удастся построить, потому что он требует n² по памяти. А если у нас входные элементы до 10⁷, то 10¹⁴ нам уже не подойдет.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  long long n, k;
  cin >> n >> k;

  // решение
  vector&lt;long long&gt; Level(1e7);

  // для упрощения вычислений с факториалами
  int min_el = min(k, n - k);
  int max_el = max(k, n - k);

  // считаем числитель
  for (int i = max_el + 1; i &lt;= n; i++) {
    int tmp = i;
    for (long long j = 2; j * j &lt;= tmp; j++) {
      while (tmp % j == 0) {
        Level[j]++;
        tmp /= j;
      }
    }
    Level[tmp]++;
  }

  // считаем знаменатель
  for (int i = 1; i &lt;= min_el; i++) {
    int tmp = i;
    for (long long j = 2; j * j &lt;= tmp; j++) {
      while (tmp % j == 0) {
        Level[j]--;
        tmp /= j;
      }
    }
    Level[tmp]--;
  }

  long long ans = 1;
  for (int i = 1; i &lt; Level.size(); i++) {
    while (Level[i] > 0) {
      ans *= i;
      Level[i]--;
    }
  }

  // вывод результата
  cout &lt;&lt; ans;
}
</pre>
  </details>
</article>


<!-- Задача I. Сегодня в белом танце кружимся -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача I. Сегодня в белом танце кружимся</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>На танцплощадке собрались N юношей и N девушек. Сколькими способами они могут разбиться на пары для участия в очередном танце?</p>

  <h4>Входные данные</h4>
  <p>В единственной строке содержится число N (1 ≤ N ≤ 15) – количество юношей и девушек.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите число – количество способов.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>1</code>
    <code>1</code>

    <h4>Пример 2</h4>
    <code>2</code>
    <code>2</code>
  </details>
</article>


<!-- Задача J. Домашнее задание -->
<article class="article">
  <div class="anchor" id="task10"></div>
  <h3>Задача J. Домашнее задание</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Чтобы заставить зачетку работать на себя, нужно исправно выполнять домашние задания, считает первокурсник Никита. Но последнее домашнее задание по алгебре все никак не поддавалось. Нужно было вычислить значение следующих величин</p>
  <ol>
    <li>Количество подмножеств N элементного множества</li>
    <li>Сумма чисел, находящихся на N-м уровне треугольнике Паскаля.</li>
  </ol>
  <p>Треугольник Паскаля - бесконечная таблица биномиальных коэффициентов в виде треугольника. Для наглядности приведем несколько уровней треугольника Паскаля, начиная с нулевого</p>
<pre>
                           1
                        1      1
                     1     2     1
                  1     3      3    1
               1     4     6     4    1
            1     5     10    10    5    1
         1     6    15    20    15    6    1
       1    7     21   36    35    21   7    1
    1    8    28    56    70    56   28    7   1
  1    9    36    84   126   126   84   36   9    1
1   10   45   130   210   252   210  120  45   10   1
</pre>

  <h4>Входные данных</h4>
  <p>В единственной строке ввода содержится число N ( 0 ≤ N ≤ 30)</p>

  <h4>Выходгные денная</h4>
  <p>В единственной строке вывести число - ответ назадачу для заданного N</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>2</code>
    <code>4</code>

    <h4>Пример 2</h4>
    <code>2</code>
    <code>15</code>
  </details>
</article>


<!-- Задача K. Флаги -->
<article class="article">
  <div class="anchor" id="task11"></div>
  <h3>Задача K. Флаги</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Сколько существует различных K-цветных флагов с K вертикальными полосами одинаковой ширины, если можно использовать материю N цветов? (Флаг здесь считается просто полотнищем, не прикреплённым ни к древку, ни к чему другому.)</p>

  <h4>Входные данные</h4>
  <p>В единственной строке содержатся числа N и K (1 ≤ K ≤ N ≤ 15) – количество цветов на флаге и общее число цветов соответственно.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите число – количество различных флагов</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>1 1</code>
    <code>1</code>

    <h4>Пример 2</h4>
    <code>2 1</code>
    <code>2</code>


    <h4>Пример 3</h4>
    <code>6 2</code>
    <code>15</code>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  long long n, k;
  cin >> n >> k;

  // решение
  long long res = 1;
  bool flag = false;
  if (k > 1) {
    flag = true;
  }
  while (k > 0) {
    res *= n;
    k--;
    n--;
  }

  // вывод результата
  if (flag) {
    cout &lt;&lt; res / 2;
  } else {
    cout &lt;&lt; res;
  }
}
</pre>
  </details>
</article>


<!-- Задача L. Записная книжка -->
<article class="article">
  <div class="anchor" id="task12"></div>
  <h3>Задача L. Записная книжка</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Однажды маленький Вася нашел записную книжку мамы. В ней были записаны n имен ее друзей, каждое из которых необыкновенным образом было длиной ровно m букв. Пронумеруем имена от 1 до n в том порядке, в котором они записаны.</p>

  <p>Так как мамы не было дома, Вася решил поиграть с именами: он выбирал три целых числа i, j, k (1 ≤ i &lt; j ≤ n, 1 ≤ k ≤ m), и менял местами у имен с номерами i и j префиксы длиной ровно k символов. Например, если у имен «CBDAD» и «AABRD» поменять местами префиксы длиной 3, то получатся имена «AABAD» и «CBDRD».</p>

  <p>Вам интересно, сколько возможных различных имен могло быть записано на месте имени номер 1, если Васе разрешено делать любое количество описанных действий. Делая каждое действие, Вася выбирает числа i, j, k независимо от предыдущих ходов и исключительно по своему усмотрению. Искомое число может быть очень большим, поэтому необходимо найти только остаток от деления этого числа на 1000000007 (10⁹ + 7).</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных записаны два целых числа n и m (1 ≤ n, m ≤ 100) — количество имен и длина каждого имени соответственно. Далее в n строках расположены имена, каждое состоит ровно из m заглавных латинских букв.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное целое число — остаток от деления на 1000000007 (10⁹ + 7) количества различных имен, которые могли бы получиться на месте номер 1 после применений описанных действий.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
2 3
AAB
BAA
</pre>
    <code>4</code>

    <h4>Пример 2</h4>
<pre>
4 5
ABABA
BCGDG
AAAAA
YABSA
</pre>
    <code>216</code>
    <p>В первом примере Вася на месте имени номер 1 может получить следующие: «AAB», «AAA», «BAA» и «BAB».</p>
  </details>
</article>


<!-- Задача M. Коля и Таня -->
<article class="article">
  <div class="anchor" id="task13"></div>
  <h3>Задача M. Коля и Таня</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Коля любит рассаживать гномов по кругу и раздавать им монеты, а Таня любит изучать тройки гномов, сидящих в вершинах равностороннего треугольника.</p>

  <p>Более формально, в круге сидят 3n гномов. У каждого гнома может быть от 1 до 3 монет. Пронумеруем места в порядке следования по кругу числами от 0 до 3n - 1, пусть у гнома, сидящего на i месте, aᵢ монет. Тогда если существует целое число i (0 ≤ i &lt; n) такое, что a<sub>i</sub> + a<sub>i+n</sub> + a<sub>i+2n</sub> ≠ 6, то Таня остается довольна.</p>

  <p>Посчитайте количество способов выбрать aᵢ так, чтобы Таня осталась довольна. Так как способов раздачи монет может быть много, вычислите остаток от их деления на 10⁹ + 7. Два способа a и b считаются различными, если существует индекс i (0 ≤ i &lt; 3n) такой, что aᵢ ≠ bᵢ (то есть, какой-то гном получил разное количество монет в этих двух способах).</p>

  <h4>Входные данные</h4>
  <p>В единственной строке записано число n (1 ≤ n ≤ 10⁵) — треть количества гномов.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное число — остаток от деления количества вариантов раздачи монет, устраивающих Таню на 10⁹ + 7.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>1</code>
    <code>20</code>

    <h4>Пример 2</h4>
    <code>2</code>
    <code>680</code>
    <p>20 способов для для n = 1 (наверху каждого треугольника сидит гном с индексом 0, в правой нижней вершине - с индексом 1, в левой нижней - с индексом 2):</p>
  </details>
</article>


<!-- Задача N. Весь мир театр -->
<article class="article">
  <div class="anchor" id="task14"></div>
  <h3>Задача N. Весь мир театр</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В театральном кружке занимается n юношей и m девушек. Для постановки спектакля «Теория большого взрыва» им надо выбрать группу ровно из t актеров, которая содержит не менее 4 юношей и не менее одной девушки. Сколькими способами возможен выбор группы? Конечно, варианты отличающиеся только составом труппы считаются различными.</p>

  <p>Производите все вычисления в 64-битном типе: long long для С/С++, int64 для Delphi и long для Java.</p>

  <h4>Входные данные</h4>
  <p>Единственная строка входных данных содержит три целых числа n, m, t (4 ≤ n ≤ 30, 1 ≤ m ≤ 30, 5 ≤ t ≤ n + m).</p>

  <h4>Выходные данные</h4>
  <p>Выведите искомое количество способов.</p>

  <p>Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>5 2 5</code>
    <code>10</code>

    <h4>Пример 2</h4>
    <code>4 3 5</code>
    <code>3</code>
  </details>
</article>


<!-- Задача O. Посчитайте массивы -->
<article class="article">
  <div class="anchor" id="task15"></div>
  <h3>Задача O. Посчитайте массивы</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 512мб</i></div>

  <p>Посчитайте количество массивов, удовлетворяющих следующим условиям:</p>
  <ul>
    <li>каждый массив состоит из n элементов;</li>
    <li>каждый элемент — целое число от 1 до m;</li>
    <li>в каждом массиве есть ровно одна пара одинаковых элементов;</li>
    <li>в каждом массиве a существует такой индекс i, что массив строго возрастает до i-го элемента и строго убывает после него (формально, a<sub>j</sub> &lt; a<sub>j+1</sub>, если j &lt; i, и a<sub>j</sub> > a<sub>j+1</sub>, если j ≥ i).</li>
  </ul>

  <h4>Входные данные</h4>
  <p>В первой строке заданы два целых числа n и m (2 ≤ n ≤ m ≤ 2⋅10⁵).</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно целое число — количество массивов, удовлетворяющих всем вышеописанным условиям, взятое по модулю 998244353.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>3 4</code>
    <code>6</code>

    <h4>Пример 2</h4>
    <code>3 5</code>
    <code>10</code>

    <h4>Пример 3</h4>
    <code>42 1337</code>
    <code>806066790</code>

    <h4>Пример 4</h4>
    <code>100000 200000</code>
    <code>707899035</code>
    <p>Массивы из первого примера:</p>
    <ul>
      <li>[1,2,1];</li>
      <li>[1,3,1];</li>
      <li>[1,4,1];</li>
      <li>[2,3,2];</li>
      <li>[2,4,2];</li>
      <li>[3,4,3];</li>
    </ul>
  </details>
</article>


<!-- Задача P. Прямоугольные треугольники -->
<article class="article">
  <div class="anchor" id="task16"></div>
  <h3>Задача P. Прямоугольные треугольники</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Дано прямоугольное поле n x m, состоящее из точек ('.') и звездочек ('*'). Ваша задача — посчитать количество прямоугольных треугольников, у которых две стороны параллельны сторонам поля, а вершины находятся в центрах клеток, помеченных звездочками.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано два целых положительных числа n и m (1 ≤ n, m ≤ 1000). Следующие n строк содержат по m символов, описывающих поле. Гарантируется, что эти строки состоят только из '.' и '*'.</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно число — количество прямоугольных треугольников на поле. Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать поток cout (также вы можете использовать спецификатор %I64d).</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
2 2
**
*.
</pre>
    <code>1</code>

    <h4>Пример 2</h4>
<pre>
3 4
*..*
.**.
*.**
</pre>
    <code>9</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Если у вершина одна по горизонтали или вертикали, то с ней нельзя построить прямоугольный треугольник. Если у вершины есть еще одна вершина по горизонтали и одна по вертикали, то с ней можно построить один прямоугольный треугольник. Если у вершины есть еде одна по вертикали и две по горизонтали (или одна по горизонтали и две по вертикали), то с ней можно построить два прямоугольных треугольника.</p>
    <p>Нужно пройтись по всем вершинам и посчитать сколько у каждой соседей по горизонтали и по вертикали. Произведение всех соседей это сколько треугольников можо построить с этой вершиной в прямом угле.</p>
    <p>Решим задачу динамическим программированием за O(n²). Заранее посчитав сколько звездочек в каждой строке и каждом столбце.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  long long n, m;
  cin >> n >> m;

  vector&lt;string&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  vector&lt;long long&gt; Count_left(n);
  vector&lt;long long&gt; Count_up(m);
  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; m; j++) {
      if (A[i][j] == '*') {
        Count_left[i]++;
        Count_up[j]++;
      }
    }
  }

  long long res = 0;
  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; m; j++) {
      if (A[i][j] == '*') {
        res += (Count_left[i] - 1) * (Count_up[j] - 1);
      }
    }
  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача Q. Умный дартс -->
<article class="article">
  <div class="anchor" id="task17"></div>
  <h3>Задача Q. Умный дартс</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Умный дартс – это обычный дартс, но умный. Правила умного дартса очень просты: нужно выбить наибольшее количество очков. Но это же умный дартс, поэтому меткость здесь не играет особой роли, важно умение считать. Мишенью в этой игре является квадратное поле NxN квадратных ячеек. Ячейки бывают двух видов: одни приносят баллы, а другие не приносят баллы. При попадании в ячейку, начисляется не только балл за саму ячейку, но и за все ячейки, которые расположены на одной горизонтали и вертикали с данной(см. рис. ниже).</p>
<pre>
# * * * # *
* * * * * *
* * # * * #
* * * * * *
* # # * # *
* * * * * *
</pre>
  <p>Маленький мальчик Гоша хочет показаться окружающим очень умным, а потому хочет всегда выигрывать в умный дартс. А для этого он решил кидать дротик так, чтобы выбивать максимальное число очков. Но с программированием и математикой у него, увы не всё так хорошо, как с честолюбием. Поэтому он просит вас помочь ему.</p>

  <p>Вам необходимо написать программу, которая посчитает наибольшее возможное количество очков, которое можно получить за один выстрел.</p>

  <h4>Входные данные</h4>
  <p>Во входном файле в первой строке содержится число (1 ≤ N ≤ 2000) – размер поля. Далее в N строках описывается само поле для дартса. Ячейка, в которой стоит символ «*» – ячейка без очков, а ячейка, в которой стоит символ «#» – ячейка стоимостью в один балл.</p>

  <h4>Выходные данные</h4>
  <p>Вывести одно число – максимально возможное количество баллов.</p>

  <details>
    <summary>Пример</summary>
<pre>
6
#***#*
******
**#**#
******
*##*#*
******
</pre>
    <code>4</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Соберем два массива DP1 и DP2. DP1[i] хранит количество '#' в строке i, DP2[i] хранит количество '#' в столбце i.</p>
    <p>В ячейке [i][j] будем хранить DP1[j] + DP2[i] если A[i][j] = '*', и будем хранить DP1[j] + DP2[i] - 1 если A[i][j] = '#', чтобы не учитывать эту '#' два раза.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  int n;
  cin >> n;
  vector&lt;string&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  vector&lt;int&gt; DP1(n);
  vector&lt;int&gt; DP2(n);
  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; n; j++) {
      if (A[i][j] == '#') {
        DP1[i]++;
        DP2[j]++;
      }
    }
  }
  int res = 0;
  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; n; j++) {
      if (A[i][j] == '#') {
        res = max(res, DP1[i] + DP2[j] - 1);
      } else {
        res = max(res, DP1[i] + DP2[j]);
      }
    }
  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача R. Два массива -->
<article class="article">
  <div class="anchor" id="task18"></div>
  <h3>Задача R. Два массива</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам заданы два числа n и m. Посчитайте количество таких пар массивов (a,b), что:</p>
  <ul>
    <li>длина обоих массивов равна m;</li>
    <li>каждый элемент каждого массива — целое число от 1 до n (включительно);</li>
    <li>aᵢ ≤ bᵢ для любого индекса i от 1 до m;</li>
    <li>массив a отсортирован в порядке неубывания;</li>
    <li>массив b отсортирован в порядке невозрастания.</li>
  </ul>
  <p>Так как ответ может быть слишком большим, посчитайте его по модулю 10⁹+7.</p>

  <h4>Входные данные</h4>
  <p>Единственная строка содержит два числа n и m (1 ≤ n ≤ 1000, 1 ≤ m ≤ 10).</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно число – количество массивов a и b, удовлетворяющих условиям, описанным выше по модулю 10⁹+7.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>2 2</code>
    <code>5</code>

    <h4>Пример 2</h4>
    <code>10 1</code>
    <code>55</code>

    <h4>Пример 3</h4>
    <code>723 9</code>
    <code>157557417</code>
    <p>В первом тесте существуют 5 подходящих вариантов:</p>
    <ul>
      <li>a=[1,1],b=[2,2];</li>
      <li>a=[1,2],b=[2,2];</li>
      <li>a=[2,2],b=[2,2];</li>
      <li>a=[1,1],b=[2,1];</li>
      <li>a=[1,1],b=[1,1].</li>
    </ul>
  </details>
</article>

