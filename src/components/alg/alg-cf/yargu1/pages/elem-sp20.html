<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contests" target="_blank">Codeforces ЯрГУ. Школьники</a></p>
  <p><a href="https://vk.com/sportprog_yarsu" target="_blank">vk.com/sportprog_yarsu</a></p>
  <p><a href="https://vkvideo.ru/@sportprog_yarsu" target="_blank">vkvideo.ru/@sportprog_yarsu</a></p>
</article>


<article class="article">
  <h1>Занятие 20 Графы #2. BFS. Поиск в ширину</h1>
  <p>Конспект видео от 2025.02.08</p>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contest/586871" target="_blank">Codeforces Контест 586871</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
        <a href="#p1">Графы #2. BFS. Поиск в ширину</a>
    <br><a href="#p2">1 Поиск количества компонент связности</a>
    <br><a href="#p3">2 Проверка существования пути от вершины a к вершине b</a>
    <br><a href="#p4">3 Поиск кратчайшего пути от вершины start до вершины finish</a>
    <br><a href="#p5">4 Восстановление кратчайшего пути в неориентированном невзвешенном графе</a>
    <br><a href="#p6">5 Проверка графа на двудольность</a>
  </p>
  <p>
        <a href="#task1">Задача A. Путь</a>
    <br><a href="#task2">Задача B. Кратчайший путь</a>
    <br><a href="#task3">Задача C. Ребро на пути</a>
    <br><a href="#task4">Задача D. Вершина на пути</a>
    <br><a href="#task5">Задача E. Праздник</a>
    <br><a href="#task6">Задача F. Бейджик</a>
    <br><a href="#task7">Задача G. Диаметр графа</a>
    <br><a href="#task8">Задача H. Транспорт на Новый год</a>
    <br><a href="#task9">Задача I. Путешествие КORовьева</a>
    <br><a href="#task10">Задача J. Ярмарка</a>
    <br><a href="#task11">Задача K. Пасьянс</a>
    <br><a href="#task12">Задача L. Метро</a>
    <br><a href="#task13">Задача M. Брасс Бирмингем: монеты</a>
    <br><a href="#task14">Задача N. Брасс Бирмингем: пиво</a>
    <br><a href="#task15">Задача O. Непростительное заклятие (сложная версия)</a>
    <br><a href="#task16">Задача P. Непростительное заклятие (простая версия)</a>
  </p>
</article>


<!-- Графы #2. BFS. Поиск в ширину -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Графы #2. BFS. Поиск в ширину</h3>

  <p>Алгоритм «поиск в ширину, его обыденное название BFS (breadth-first search).</p>
  <p>Алгоритм BFS основан на трех принципах:</p>
  <ol>
    <li>обходим граф, посещая каждую вершину только один раз;</li>
    <li>используем структуры данных queue;</li>
    <li>обходим граф по удаленности от вершины start, или так называемый обход графа по слоям. Используем дополнительный vector&lt;int&gt; Mark, в котором отмечаем посещенные вершины</li>
  </ol>

  <p>При реализации алгоритма bfs будем выполнять последовательность действий:</p>
  <ol>
    <li>создаем очередь и добавляем в нее вершину start;</li>
    <li>вытаскиваем первую вершину x из очереди;</li>
    <li>рассматриваем все смежные вершины с x. Если смежная вершина не была помечена, добавляем ее в очередь и помечаем;</li>
    <li>повторяем действия до тех пор, пока очередь не окажется пустой.</li>
  </ol>

  <p>Алгоритм BFS применяется в задачах:</p>
  <ol>
    <li>поиск количества компонент связности;</li>
    <li>проверка существования пути от вершины a к вершине b (проверка, что вершины a и b из одной компоненты связности);</li>
    <li>поиск кратчайшего пути от вершины start до вершины finish в неориентированном невзвешенном графе;</li>
    <li>восстановление кратчайшего пути в неориентированном невзвешенном графе;</li>
    <li>проверка графа на двудольность;</li>
    <li>поиск мостов между вершинами a и b (определенное ребро на кратчайшем пути от a до b);</li>
    <li>поиск диаметра графа (дерева);</li>
    <li>поиск циклов (плохо).</li>
  </ol>
</article>


<!-- 1 Поиск количества компонент связности -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>1 Поиск количества компонент связности</h3>

  <p>Одной из самых простых задач является поиск количества компонент связности. Для ее решения воспользуемся алгоритмом BFS.</p>
  <p>При обходе BFS мы можем помечать вершины, в которых уже были. Для этого заведем дополнительный vector&lt;int&gt; Mark(n), где для каждой вершины от 1 до n будет хранится 0, если вершина еще не была посещена, или 1 если вершина уже посещена. Обойдем все вершины в графе. Если вершина x не была помечена, то добавим ее в очередь и пометим ее. Запустим алгоритм BFS из вершины x.</p>
  <p>Создадим переменную cnt_k для подсчета количества компонент связности.</p>
  <p>В аргументах функции bfs_number_comp передаем:</p>
  <ol>
    <li>vector&lt;vector&lt;int&gt; &gt; G — граф, представленный в виде списка смежности, где в каждой i строке каждая ячейка — это номер вершины, с которой смежна вершина с номером i;</li>
    <li>vector&lt;int&gt; Mark — вектор посещаемости. Mark[i] равняется 1, если до вершины с номером i построен путь, иначе равняется 0. Изначально каждая вершина считается не посещенной;</li>
    <li>start — вершина старта.</li>
  </ol>
  <p>Трудоемкость алгоритма O(m), где m — количество ребер.</p>

  <p><strong>Задача.</strong> На вход подается неориентированный граф из n вершин и m ребер, заданный списком ребер. Найти количество компонент связности.</p>
<pre>
int n; // число вершин
int m; // число ребер
cin >> n >> m;
int a, b; // две вершины одного ребра

// список смежности
vector&lt;vector&lt;int&gt; &gt; G(n + 1);

// ссписок ребер сохраним в список смежности
for (int i = 0; i &lt; m; i++) {
  cin >> a >> b;
  G[a].push_back(b);
  G[b].push_back(a);
}

vector&lt;int&gt; Mark(n + 1);
// Mark[i] = 0 если не посещали вершину
// Mark[i] = 1 если уже посетили вершину

int cnt_k = 0; // число компонент связности

// пройдем по всем вершинам
for (int i = 1; i &lt;= n; i++) {
  if (Mark[i] == 0) {

    // если вершина не была посещена
    // то мы нашли новую компоненту связности
    cnt_k++;

    // запускаем bfs чтобы пометить все вершины
    // в этой компоненте связности
    bfs(G, Mark, i);
  }
}

cout &lt;&lt; cnt_k; // выводим результат
</pre>

  <p>Реализация BFS через очередь для подсчета компонент связности.</p>
<pre>
void bfs(vector&lt;vector&lt;int&gt; &gt;& G,
         vector&lt;int&gt;& Mark, int start) {

  queue&lt;int&gt; q;
  q.push(start);
  Mark[start] = 1;
  int tmp;

  while (q.size() > 0) {
    tmp = q.front();
    q.pop();
    for (int i = 0; i &lt; G[tmp].size(); i++) {
      if (Mark[G[tmp][i]] == 0) {
        q.push(G[tmp][i]);
        Mark[G[tmp][i]] = 1;
      }
    }
  }
}
</pre>

  <p>Реализация BFS без очереди для подсчета компонент связности.</p>
<pre>
void bfs(vector&lt;vector&lt;int&gt; &gt;& G,
         vector&lt;int&gt;& Mark, int start) {

  vector&lt;int&gt; Arr;
  int uk = 0, tmp;
  Arr.push_back(start);
  Mark[start] = 1;

  while (uk &lt; Arr.size()) {
    tmp = Arr[uk];
    uk++;
    for (int i = 0; i &lt; G[tmp].size(); i++) {
      if (Mark[G[tmp][i]] == 0) {
        Mark[G[tmp][i]] = 1;
        Arr.push_back(G[tmp][i])
      }
    }
  }
}
</pre>
</article>


<!-- 2 Проверка существования пути от вершины a к вершине b -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>2 Проверка существования пути от вершины a к вершине b</h3>

  <p>Для поверки на запрос, существует ли путь от вершины a к вершине b, достаточно запустить функцию bfs из вершины a и проверить Mark[b]. Это неплохое решение задачи, однако, если запросов на проверку много, программа будет долго работать. Для решения задачи воспользуемся вспомогательной памятью для запоминания, в какой компоненте связности располагается каждая вершина графа.</p>

  <p>Создадим дополнительный vector&lt;int&gt; Color, где для каждой i вершины будем хранить номер компоненты связности, в которой располагается вершина i. Если Color[a] == Color[b], это будет означать, что вершины лежат в одной компоненте связности.</p>

  <p>Улучшим реализацию функции bfs. Добавим в аргументы функции:</p>
  <ol>
    <li>vector&lt;int&gt; Color — вектор номеров компонент связности. Color[i] равняется номеру цвета компоненты связности, в которой располагается вершина i;</li>
    <li>number_color — номер цвета компоненты связности.</li>
  </ol>

  <p><strong>Задача.</strong> На вход подается неориентированный граф из n вершин и m ребер, заданный списком ребер. Подается q запросов, в каждом запросе проверить существование пути от вершины a к вершине b.</p>
<pre>
int n; // число вершин
int m; // число ребер
cin >> n >> m;
int q; // число запросов
int a, b; // две вершины одного ребра

// список смежности
vector&lt;vector&lt;int&gt; &gt; G(n + 1);

// ссписок ребер сохраним в список смежности
for (int i = 0; i &lt; m; i++) {
  cin >> a >> b;
  G[a].push_back(b);
  G[b].push_back(a);
}

vector&lt;int&gt; Mark(n + 1);
// Mark[i] = 0 если не посещали вершину
// Mark[i] = 1 если уже посетили вершину

int cnt_k = 0; // номер компоненты связности
vector&lt;int&gt; Color(n + 1);

// пройдем по всем вершинам
for (int i = 1; i &lt;= n; i++) {
  if (Mark[i] == 0) {

    // если вершина не была посещена
    // то мы нашли новую компоненту связности
    cnt_k++;

    // запускаем bfs на этой вершине
    // чтобы раскрасить все соседние вершины
    bfs(G, Mark, Color, cnt_k, i);
  }
}

cin >> q;

while (q--) {
  int a, b;
  cin >> a >> b;
  if (Color[a] == Color[b]) {
    cout &lt;&lt; "Yes\n";
  } else {
    cout &lt;&lt; "No\n";
  }
}
</pre>

  <p>Реализация BFS через очередь для проверки существования пути из вершины a в вершину b.</p>
<pre>
void bfs(
     vector&lt;vector&lt;int&gt; &gt;& G,
     vector&lt;int&gt;& Mark,
     vector&lt;int&gt;& Color,
     int number_color,
     int start) {

  queue&lt;int&gt; q;
  q.push(start);
  Mark[start] = 1;
  Color[start] = number_color;
  int tmp;

  while (q.size() > 0) {
    tmp = q.front();
    q.pop();
    for (int i = 0; i &lt; G[tmp].size(); i++) {
      if (Mark[G[tmp][i]] == 0) {
        q.push(G[tmp][i]);
        Mark[G[tmp][i]] = 1;
        Color[G[tmp][i]] = number_color;
      }
    }
  }
}
</pre>
</article>


<!-- 3 Поиск кратчайшего пути от вершины start до вершины finish -->
<article class="article">
  <div class="anchor" id="p4"></div>
  <h3>3 Поиск кратчайшего пути от вершины start до вершины finish</h3>

  <p>Поставим перед собой задачу определить длину кратчайшего пути от вершины start в вершину finish в неориентированном не взвешенном графе.</p>
  <p>Для поиска длины кратчайшего пути улучшим реализацию функции bfs_number_comp. Добавим вспомогательный vector&lt;int&gt; Len, где в Len[i] будет храниться целое число, длина кратчайшего пути от вершины start до i вершины. Ответом на задачу будет значение Len[finish].</p>
  <p>Реализуем функцию bfs_path, дополнив функцию bfs_number_comp. Добавим в аргументы функции:</p>
  <ol>
    <li>vector&lt;int&gt; Len — вектор длин путей. Len[i] равняется длине кратчайшего пути от вершины start до вершины i.</li>
  </ol>

  <p><strong>Задача.</strong> На вход подается неориентированный граф из n вершин и m ребер, заданный списком ребер. Найти кратчайший путь от вершины start к вершине finish.</p>
<pre>
int n; // число вершин
int m; // число ребер
cin >> n >> m;
int a, b; // две вершины одного ребра

// список смежности
vector&lt;vector&lt;int&gt; &gt; G(n + 1);

// ссписок ребер сохраним в список смежности
for (int i = 0; i &lt; m; i++) {
  cin >> a >> b;
  G[a].push_back(b);
  G[b].push_back(a);
}

vector&lt;int&gt; Mark(n + 1);
// Mark[i] = 0 если не посещали вершину
// Mark[i] = 1 если уже посетили вершину

vector&lt;int&gt; Len(n + 1);
// Len[i] путь от вершины start до вершины i

bfs(G, Mark, Len, start);

if (Mark[finish] == 0) {
  cout &lt;&lt; -1; // вершина finish недостижима
} else {
  cout &lt;&lt; Len[finish];
}
</pre>

  <p>Реализация BFS через очередь для поиска кратчайшего пути из вершины start в вершину finish.</p>
<pre>
void bfs_path(
     vector&lt;vector&lt;int&gt; &gt;& G,
     vector&lt;int&gt;& Mark,
     vector&lt;int&gt;& Len,
     int start) {

  queue&lt;int&gt; q;
  q.push(start);
  Mark[start] = 1;
  Len[start] = 0;
  int tmp;

  while (q.size() > 0) {
    tmp = q.front();
    q.pop();
    for (int i = 0; i &lt; G[tmp].size(); i++) {
      if (Mark[G[tmp][i]] == 0) {
        Mark[G[tmp][i]] = 1;
        Len[G[tmp][i]] = 1 + Len[tmp];
        q.push(G[tmp][i]);
      }
    }
  }
}
</pre>
</article>


<!-- 4 Восстановление кратчайшего пути в неориентированном невзвешенном графе -->
<article class="article">
  <div class="anchor" id="p5"></div>
  <h3>4 Восстановление кратчайшего пути в неориентированном невзвешенном графе</h3>

  <p>В задачах иногда требуется не только определить длину кратчайшего пути, но и вывести сам кратчайший путь между парой вершин start и finish. Для вывода самого пути мы можем запомнить для каждой вершины x, из какой смежной вершины мы в нее прибыли.</p>
  <p>Создадим дополнительный vector&lt;int&gt; Putty, где в Putty[i] будет храниться номер смежной вершины, из которой мы при прибыли в вершину i.</p>

<pre>
void bfs_save_path(
     vector&lt;vector&lt;int&gt; &gt;& G,
     vector&lt;int&gt;& Mark,
     vector&lt;int&gt;& Len,
     vector&lt;int&gt; Putty,
     int start) {

  queue&lt;int&gt; q;
  q.push(start);
  Mark[start] = 1;
  Len[start] = 0;
  Putty[start] = start;
  int tmp;

  while (q.size() > 0) {
    tmp = q.front();
    q.pop();
    for (int i = 0; i &lt; G[tmp].size(); i++) {
      if (Mark[G[tmp][i]] == 0) {
        Mark[G[tmp][i]] = 1;
        Len[G[tmp][i]] = 1 + Len[tmp];
        Putty[G[tmp][i]] = tmp;
        q.push(G[tmp][i]);
      }
    }
  }
}
</pre>

  <p>Для восстановления пути из вершины start в вершину finish мы пройдем по Putty от вершины finish в вершину start. Таким образом, мы пройдем ребра в обратном порядке и сможем восстановить путь.</p>
<pre>
void find_path(
     vector&lt;int&gt; Putty,
     vector&lt;int&gt; Path,
     int start,
     int finish,
     int n) {

  Path.push_back(finish);
  int u = finish;

  while (u != Putty[u]) {
    Path.push_back(Putty[u]);
    u = Putty[u];
  }
  reverse(Path.begin(), Path.end());
}
</pre>
</article>


<!-- 5 Проверка графа на двудольность -->
<article class="article">
  <div class="anchor" id="p6"></div>
  <h3>5 Проверка графа на двудольность</h3>

  <p>Для проверки графа на двудольность мы должны покрасить его вершины в два цвета таким образом, чтобы любые две смежные вершины были покрашены в два разных цвета. Воспользуемся вспомогательным vector&lt;int&gt; Color, где в Color[i] будем запоминать, в какой цвет покрасили i вершину. Для проверки графа на двудольность потребуется проверить каждую компоненту связности, что она является двудольной, то есть в каждой компоненте связности потребуется запустить алгоритм bfs.</p>
  <p>Изменим реализацию функции bfs_color. Поменяем в ней способ использования vector&lt;int&gt; Color, добавим переменную flag для проверки на двудольность:</p>
  <ol>
    <li>vector&lt;int&gt; Color — вектор покраски вершин. Color[i] равняется цвету двудольности для вершины i 0 или 1;</li>
    <li>bool flag — флаг, проверяющий, что граф двудольный. Если flag равняется false, то граф не является двудольным, если true — граф двудольный.</li>
  </ol>
  <p>Изначально flag = true, то есть считаем что граф двудольный. Если найдем ребро, в котором две вершины покрашены одним цветом, то flag = false и граф не двудольный.</p>

  <p><strong>Задача.</strong> На вход подается неориентированный граф из n вершин и m ребер, заданный списком ребер. Определить является ли граф двудольным.</p>
<pre>
int n; // число вершин
int m; // число ребер
cin >> n >> m;
int a, b; // две вершины одного ребра

// список смежности
vector&lt;vector&lt;int&gt; &gt; G(n + 1);

// ссписок ребер сохраним в список смежности
for (int i = 0; i &lt; m; i++) {
  cin >> a >> b;
  G[a].push_back(b);
  G[b].push_back(a);
}

vector&lt;int&gt; Mark(n + 1);
// Mark[i] = 0 если не посещали вершину
// Mark[i] = 1 если уже посетили вершину

vector&lt;int&gt; Color(n + 1);
bool flag = true; // считаем что граф двудольный
queue&lt;int&gt; q;

// пройдем по всем вершинам
for (int i = 1; i &lt;= n; i++) {
  if (Mark[i] == 0) {
    // запускаем bfs
    bfs(G, Mark, Color, i);
  }
}

if (flag) {
  cout &lt;&lt; "YES\n";
} else {
  cout &lt;&lt; "NO\n";
}
</pre>

  <p>Реализация BFS через очередь для проверки графа на двудольность</p>
<pre>
void bfs(
     vector&lt;vrctor&lt;int&gt; &gt;& G,
     vector&lt;int&gt;& Mark,
     vector&lt;int&gt;& Color,
     bool& flag,
     int start) {

  queue&lt;int&gt; q;
  q.push(start);
  Mark[start] = 1;
  Color[start] = 1;
  int tmp;

  while (q.size() > 0) {
    tmp = q.front();
    q.pop();

    for (int i = 0; i &lt; G[tmp].size(); i++) {
      if (Mark[G[tmp][i]] == 0) {
        Mark[G[tmp][i]] = 1;
        Color[G[tmp][i]] = (Color[tmp] + 1) % 2;
        q.push(G[tmp][i]);
      } else if (Color[G[tmp][i]] == Color[tmp]) {
        flag = false;
      }
    }
  }
}
</pre>
</article>


<!-- Задача A. Путь -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Путь</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 16мб</i></div>

  <p>В неориентированном графе требуется найти длину кратчайшего пути между двумя вершинами.</p>

  <h4>Входные данные</h4>
  <p>Сначала записано число N - количество вершин в графе (1 ≤ N ≤ 100). Затем записана матрица смежности (0 обозначает отсутствие ребра, 1 - наличие ребра). Затем записаны номера двух вершин - начальной и конечной.</p>

  <h4>Выходные данные</h4>
  <p>Выведите длину кратчайшего пути. Если пути не существует, выведите одно число -1.</p>

  <details>
    <summary>Пример</summary>
<pre>
5
0 1 0 0 1
1 0 1 0 0
0 1 0 0 0
0 0 0 0 0
1 0 0 0 0
3 5
</pre>
    <code>3</code>
  </details>
</article>


<!-- Задача B. Кратчайший путь -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Кратчайший путь</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам дан неориентированный граф. Найдите кратчайший путь от вершины a до вершины b.</p>

  <h4>Входные данные</h4>
  <p>В первой строке целое число n (1 ≤ n ≤ 10³) - количество вершин. Далее на вход подается матрица смежности данного графа. И в последней строке записаны 2 числа - стартовая и конечная вершина соответственно (1 ≤ a ≤ n, 1 ≤ b ≤ n).</p>

  <h4>Выходные данные</h4>
  <p>Если пути между a и b нет, выведите единственное число -1. Иначе выведите в первой строке l - длину кратчайшего пути между этими двумя вершинами в рёбрах, а во второй строке выведите l + 1 число — вершины этого пути.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
6
001000
000000
100000
000000
000001
000010
1 2
</pre>
    <code>-1</code>

    <h4>Пример 2</h4>
<pre>
6
010011
101111
010111
011010
111101
111010
3 4
</pre>
<pre>
1
3 4
</pre>
  </details>
</article>


<!-- Задача C. Ребро на пути -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Ребро на пути</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам дан неориентированный граф, состоящий из n вершин и m ребер</p>
  <code>(1 ≤ n ≤ 1000, 1 ≤ m ≤ n⋅(n-1)/2)</code>
  <p>Вам необходимо ответить на t (1 ≤ t ≤ 2000) запросов, лежит ли ребро (a, b) на каком либо кратчайшем пути из вершины u в вершину v.</p>

  <h4>Входные данные</h4>
  <p>В первой строке вводится количество вершин и ребер графа. В последующих m строках вводится по одному ребру. Затем вводится число t количество запросов. Каждый запрос состоит из 4
  чисел в отдельной строке - номеров вершин u, v, a и b  соответственно.</p>

  <h4>Выходные данные</h4>
  <p>На каждый запрос вам необходимо вывести в отдельной строке "YES", если ребро (a,b) лежит на каком-нибудь кратчайшем пути между вершинами u и v и "NO" иначе.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
6 5
1 2
2 3
3 4
4 5
5 6
2
1 5 3 2
1 4 5 6
</pre>
<pre>
YES
NO
</pre>

    <h4>Пример 2</h4>
<pre>
6 6
1 2
2 3
3 4
4 5
5 6
1 6
4
1 5 3 2
1 5 6 1
1 4 1 2
1 5 3 2
</pre>
<pre>
NO
YES
YES
NO
  </details>
</pre>

  <details>
    <summary>Решение</summary>
    <p>Для того чтобы ребро (a,b) было на кратчайшем пути из u в v, необходимо чтобы длина пути (u,v) = (u,a) + 1 + (b,v), где 1 это ребро (a,b). Или (u,v) = (u,b) + 1 + (a,v).</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ускорение ввода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // ввод данных
  int n; // число вершин
  int m; // число ребер
  cin >> n >> m;
  int a, b; // две вершины одного ребра

  // список смежности
  vector&lt;vector&lt;int&gt; &gt; G(n + 1);

  // список ребер сохраним в список смежности
  for (int i = 0; i &lt; m; i++) {
    cin >> a >> b;
    G[a].push_back(b);
    G[b].push_back(a);
  }

  // решение
  // вектор длин это расстояние от начала до вершины i
  // изначально длина равна -1
  vector&lt;vector&lt;int&gt; &gt; Len(n + 1, vector&lt;int&gt;(n+1, -1));

  // запускаем BFS
  for (int i = 1; i &lt;= n; i++) {
    queue&lt;int&gt; q;
    q.push(i);
    Len[i][i] = 0;
    int tmp;

    while (q.size() > 0) {
      tmp = q.front();
      q.pop();

      for (int j = 0; j &lt; G[tmp].size(); j++) {
        if (Len[i][G[tmp][j]] == -1) {
          q.push(G[tmp][j]);
          Len[i][G[tmp][j]] = Len[i][tmp] + 1;
        }
      }
    }
  }

  // обрабатываем запросы
  int t;
  cin >> t;
  while (t--) {
    int u, v, a, b;
    cin >> u >> v >> a >> b;
    if (Len[u][v] == Len[u][a] + 1 + Len[b][v] ||
      Len[u][v] == Len[u][b] + 1 + Len[a][v]) {
      cout &lt;&lt; "YES\n";
    } else {
      cout &lt;&lt; "NO\n";
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача D. Вершина на пути -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Вершина на пути</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам дан неориентированный граф, состоящий из n вершин и m ребер</p>
  <code>(1 ≤ n ≤ 1000, 1 ≤ m ≤ n⋅(n-1)/2)</code>
  <p>Вам необходимо ответить на t (1≤t≤2000) запросов, лежит ли вершина k на каком либо кратчайшем пути из вершины u в вершину v.</p>

  <h4>Входные данные</h4>
  <p>В первой строке вводится количество вершин и ребер графа. В последующих m строках вводится по одному ребру. Затем вводится число t количество запросов. Каждый запрос состоит из 3
  чисел в отдельной строке - номеров вершин u, v и k соответственно.</p>

  <h4>Выходные данные</h4>
  <p>На каждый запрос вам необходимо вывести в отдельной строке "YES", если вершина k лежит на каком-нибудь кратчайшем пути между вершинами u и v и "NO" иначе.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
6 5
1 2
2 3
3 4
4 5
5 6
2
1 5 3
1 4 6
</pre>
<pre>
YES
NO
</pre>

    <h4>Пример 2</h4>
<pre>
6 6
1 2
2 3
3 4
4 5
5 6
1 6
4
1 5 3
1 5 6
1 4 6
1 5 2
</pre>
<pre>
NO
YES
YES
NO
</pre>
  </details>
</article>


<!-- Задача E. Праздник -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Праздник</h3>

  <div><i>Ограничение по времени 3с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В компании работает n сотрудников, пронумерованных от 1 до n. У каждого сотрудника либо нет руководителя, либо есть ровно один непосредственный руководитель — некоторый другой сотрудник с другим номером. Сотрудник A называется начальником другого сотрудника B, если выполняется хотя бы одно из двух условий:</p>
  <ul>
    <li>Сотрудник A — непосредственный руководитель сотрудника B.</li>
    <li>У сотрудника B есть непосредственный руководитель, сотрудник C, такой, что A является начальником сотрудника C.</li>
  </ul>

  <p>В структуре компании нет циклов. То есть никакой сотрудник не является начальником своего непосредственного руководителя.</p>

  <p>Сегодня компания собирается организовать праздник. Для этого необходимо разделить всех n сотрудников на несколько групп: каждый человек должен относиться ровно к одной группе. Более того, в каждой группе не должно быть таких двух сотрудников A и B, что A является начальником B.</p>

  <p>Ваша задача — найти наименьшее возможное количество таких групп.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число n (1 ≤ n ≤ 2000) — количество сотрудников.</p>

  <p>Следующие n строк содержат целые числа pᵢ (1 ≤ pᵢ ≤ n или pᵢ = -1). Каждое pᵢ обозначает непосредственного руководителя i-го сотрудника. Если pi равно -1, то i-ый сотрудник не имеет непосредственного руководителя.</p>

  <p>Гарантируется, что никакой сотрудник не является своим собственным непосредственным руководителем (pᵢ ≠ i). Также гарантируется, что структура компании не содержит циклов.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное целое число — минимальное количество групп, на которые можно разделить всех сотрудников.</p>

  <details>
    <summary>Пример</summary>
<pre>
5
-1
1
2
1
-1
</pre>
    <code>3</code>
    <p>В первом примере достаточно трех групп:</p>
    <ol>
      <li>Сотрудник 1</li>
      <li>Сотрудники 2 и 4</li>
      <li>Сотрудники 3 и 5</li>
    </ol>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Нужно разбить граф на компоненты связности. В каждой компоненте посчитеть максимальную удаленность узла от корня. В одной компоненте связности можно объединять людей в группы по уровням (нулевой, первый и т.д.) в которых нет начальников. Группы из разных компонент связности тоже можно объединять, т.к. они не являются начальниками друг друга. Ответ будет максимальная удаленность узла от корня.</p>
    <p>Из входных данных соберем список смежности. Создадим вектор векторов, в котором будем хранить человка и его подчиненного или -1 если подчиненного нет.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;

using namespace std;

void bfs(vector&lt;vector&lt;int&gt; &gt;& G,
  vector&lt;int&gt;& Mark,
  vector&lt;int&gt;& Len,
  int start) {
  queue&lt;int&gt; q;
  q.push(start);
  Mark[start] = 1;
  Len[start] = 0;
  while (q.size() > 0) {
    int tmp = q.front();
    q.pop();
    for (int i = 0; i &lt; G[tmp].size(); i++) {
      if (Mark[G[tmp][i]] == 0) {
        Mark[G[tmp][i]] = 1;
        Len[G[tmp][i]] = Len[tmp] + 1;
        q.push(G[tmp][i]);
      }
    }
  }
}

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  int n;
  cin >> n;
  vector&lt;vector&lt;int&gt; &gt; G(n + 1);
  vector&lt;int&gt; Root;
  int x, y;
  for (int i = 1; i &lt;= n; i++) {
    cin >> y;
    x = i;
    if (y == -1) {
      Root.push_back(i);
    } else {
      G[x].push_back(y);
      G[y].push_back(x);
    }
  }

  // решение
  vector&lt;int&gt; Mark(n + 1);
  vector&lt;int&gt; Len(n + 1);
  for (int i = 0; i &lt; Root.size(); i++) {
    bfs(G, Mark, Len, Root[i]);
  }
  int res = 0;
  for (int i = 1; i &lt;= n; i++) {
    res = max(res, Len[i]);
  }

  // вывод результата
  cout &lt;&lt; res + 1;
}
</pre>
  </details>
</article>


<!-- Задача F. Бейджик -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Бейджик</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Как вы, возможно, знаете в ЛКШ за плохое поведение ставят дырки в бейджик. Вот и сегодня один из суровых преподавателей поймал группу из n школьников за очередной проделкой. Пронумеруем для удобства школьников в этой группе от 1 до n.</p>

  <p>Преподаватель подошёл к школьнику a и поставил ему дырку в бейджик. Тот, правда, попытался оправдаться, что зачинщиком бы некоторый другой школьник pa.</p>

  <p>После этого преподаватель подошёл к школьнику pa и поставил дырку в бейджик и ему. Тот в ответ послал его к школьнику ppa.</p>

  <p>Так продолжалось некоторое время, но, так как количество школьников было конечно, то через некоторое время преподаватель пришёл к школьнику, которому он уже поставил дырку.</p>

  <p>После этого он поставил в бейдж этого школьника вторую дырку и счёл на этом свой долг выполненным.</p>

  <p>Вы не знаете с какого школьника a начал преподаватель. Но вы знаете все числа pi. Выясните для каждого возможного школьника a того школьника, которому была поставлена вторая дырка.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит одно целое число n (1 ≤ n ≤ 1000) — количество нашкодивших школьников.</p>

  <p>Вторая строка содержит n целых чисел p1, ..., pn (1 ≤ pi ≤ n), где pi это номер школьника, к которому посылает преподавателя школьник под номером i.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого школьника a от 1 до n выведите номер школьника, которому поставят две дырки, если преподаватель начнёт ставить дырки со школьника a.</p>

  <details>
    <summary>Примеры</summary>
  <h4>Пример 1</h4>
<pre>
3
2 3 2
</pre>
    <code>2 2 3</code>

    <h4>Пример 2</h4>
<pre>
3
1 2 3
</pre>
    <code>1 2 3</code>
    <p>В первом примере, если a=1, то преподаватель подойдёт к школьникам 1, 2, 3, 2, тем самым вторую дырку получит школьник 2.</p>

    <p>В первом примере, если a=2, то преподаватель подойдёт к школьникам 2, 3, 2 и школьник 2 получит вторую дырку в бейдж. Если a=3, то учитель подойдёт к школьникам 3, 2, 3, тем самым школьник 3 получит вторую дырку в бейджик.</p>

    <p>Во втором примере с какого бы школьника не начал преподаватель, этот же школьник и будет тем, кто получит вторую дырку в бейджике.</p>
  </details>
</article>


<!-- Задача G. Диаметр графа -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Диаметр графа</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>CQXYM хочет построить связный неориентированный граф на n
  вершинах с m ребер и диаметром, строго меньшим k-1.</p>

  <p>Также CQXYM не хочет, чтобы граф имел петли или кратные ребра (то есть каждое ребро соединяет две различные вершины, между любой парой вершин проведено не более чем одно ребро).</p>

  <p>Диаметр графа — это максимальное расстояние между любыми двумя его вершинами.</p>

  <p>Расстояние между двумя вершинами — наименьшее количество ребер в пути, концами которого являются эти вершины.</p>

  <p>CQXYM задается вопросом, можно ли построить такой граф.</p>

  <h4>Входные данные</h4>
  <p>Входные данные состоят из нескольких тестовых примеров.</p>

  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10⁵) — количество тестовых примеров. Ниже приводится описание тестовых случаев.</p>

  <p>Единственная для каждого тестового случая строка содержит три целых числа: n (1 ≤ n ≤ 10⁹), m, k (0 ≤ m, k ≤ 10⁹).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого тестового случая выведите YES, если построить граф возможно, и NO в противном случае. Вы можете выводить буквы в любом регистре (верхнем или нижнем).</p>

  <details>
    <summary>Пример</summary>
<pre>
5
1 0 3
4 5 3
4 6 3
5 4 1
2 1 1
</pre>
<pre>
YES
NO
YES
NO
NO
</pre>
    <p>В первом тестовом случае диаметр графа равен 0.</p>

    <p>Во втором случае диаметр графа может быть только 2.</p>

    <p>В третьем случае диаметр графа может быть только 1.</p>
  </details>
</article>


<!-- Задача H. Транспорт на Новый год -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Транспорт на Новый год</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Новый год приходит в Линейный мир! В этом мире есть n ячеек, пронумерованных целыми числами от 1 до n, уложенных в виде доски размером 1 x n. В ячейках живут люди. Однако, передвигаться между различными ячейками сложно, ведь выйти из ячейки — дело непростое. В то же время, люди хотят знакомиться с людьми, живущими в других ячейках.</p>

  <p>И вот, tncks0121 придумал систему транспорта для передвижения между ячейками, чтобы люди могли отпраздновать Новый год. Сперва он задумал n - 1 положительных целых чисел a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n-1</sub>. Для каждого целого числа i, где 1 ≤ i ≤ n - 1, выполняется условие 1 ≤ aᵢ ≤ n - i. Затем он создал n - 1 порталов, пронумерованных целыми числами от 1 до n - 1. Из них i-й (1 ≤ i ≤ n - 1) портал соединяет ячейку номер i и ячейку номер (i + aᵢ), т. е. с его помощью можно путешествовать из ячейки i в ячейку (i + aᵢ). К сожалению, портал не работает в обратную сторону, то есть нельзя пройти из ячейки (i + aᵢ) в ячейку i по i-му порталу. Легко заметить, что из-за условия 1 ≤ aᵢ ≤ n - i нельзя покинуть Линейный мир, пользуясь порталами.</p>

  <p>Я нахожусь в ячейке 1 и хочу пройти в ячейку t. Однако я не знаю, могу ли я там оказаться. Пожалуйста, определите, могу ли я пройти в ячейку t, пользуясь только построенной системой транспорта.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано два целых числа через пробел, n (3 ≤ n ≤ 3 x 10⁴) и t (2 ≤ t ≤ n) — количество ячеек и номер ячейки, в которую я хочу попасть.</p>

  <p>Во второй строке записано n - 1 целых чисел через пробел a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n-1</sub> (1 ≤ aᵢ ≤ n - i). Гарантируется, что пользуясь данной транспортной системой, покинуть Линейный мир нельзя.</p>

  <h4>Выходные данные</h4>
  <p>Если я могу дойти до ячейки t по данной транспортной системе, выведите "YES". В противном случае, выведите "NO".</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
8 4
1 2 1 2 1 2 1
</pre>
    <code>YES</code>

    <h4>Пример 2</h4>
<pre>
8 5
1 2 1 2 1 1 1
</pre>
    <code>NO</code>
    <p>В первом примере можно дойти до t, посетив следующие ячейки: 1, 2, 4.</p>

    <p>Во втором примере можно посетить лишь ячейки 1, 2, 4, 6, 7, 8; значит, мы не можем попасть в требуемую ячейку 5.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Транспорт везет из вершины 0 только вперед на определенное число ячеек. Поэтому мы можем попасть в какую-то ячейку, а можем не попасть, то есть проехать мимо нее.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  int n, t;
  cin >> n >> t;
  vector&lt;int&gt; G(n + 1);
  for (int i = 1; i &lt; n; i++) {
    cin >> G[i];
  }

  // решение
  bool flag = false;
  int start = 1;
  while (start != n) {
    start += G[start];
    if (start == t) {
      flag = true;
    }
  }

  // вывод результата
  if (flag) {
    cout &lt;&lt; "YES";
  } else {
    cout &lt;&lt; "NO";
  }
 }
</pre>
  </details>
</article>


<!-- Задача I. Путешествие КORовьева -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача I. Путешествие КORовьева</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Коровьев (или Фагот) — старший подчинённый Воланда. Поэтому ему вместе с котом Бегемотом часто приходится выполнять поручения мессира. Но, кажется, на этот раз им не обойтись без Вашей помощи!</p>

  <p>Воланд раздобыл карту города и хочет попасть в театр, где он будет демонстрировать сеансы чёрной магии с её полным разоблачением. На карте отмечены точки (дома), и их соединяют дороги. На дорогах написаны их протяжённости. Свита Воланда сейчас находится в одном из домов, отмеченных на карте. Театр тоже отмечен на карте.</p>

  <p>Воланд попросил Коровьева и Бегемота разработать самый короткий маршрут от дома до театра. Но не всё так просто, ведь Воланд — не обычный смертный и обладает сверхспособностями. Поэтому он считает длиной маршрута побитовый OR длин дорог на этом маршруте (о том, что такое побитовый OR читайте в примечании).</p>

  <p>Коровьев и Бегемот сами не справятся с такой сложной задачей, ведь на карте очень много домов и дорог. Они обратились за помощью к Вам. Помогите им! Напишите программу, которая будет решать эту задачу.</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержатся два натуральных числа — n и m (2 ≤ n ≤ 10⁵, 1 ≤ m ≤ 10⁵).</p>

  <p>Каждая из следующих m строк содержит 3 целых числа — pᵢ, qᵢ, wᵢ (1 ≤ pᵢ, qᵢ, ≤ n, 0 ≤ wᵢ ≤ 10⁹, pᵢ ≠ qᵢ), где pᵢ и qᵢ — вершины, соединяемые i-м ребром, а wᵢ — вес этого ребра. Гарантируется, что граф не содержит кратных ребер.</p>

  <p>Последняя строка содержит два натуральных числа — a и b (1 ≤ a, b ≤ n, a ≠ b) — вершины, между которыми требуется найти путь наименьшего веса (дом Воланда и театр).</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите целое число — наименьший вес по всем путям между a и b. Если между a и b не существует пути, то выведите «-1» (без кавычек)</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
3 3
1 2 5
1 3 1
2 3 5
1 2
</pre>
    <code>5</code>

    <h4>Пример 2</h4>
<pre>
5 3
3 5 6
1 4 7
2 4 6
1 3
</pre>
    <code>-1</code>
    <p>Побитовый OR двух чисел вычисляется следующим образом: cначала оба числа переводятся в двоичную систему счисления, затем одно записывается под другим. i-й бит результата будет равен единице, если i-й бит первого числа равен единице и/или i-й бит второго числа равен единице.</p>

    <p>Например, 10 OR 6 = 1010₂ OR 0110₂ = 1110₂ = 14.</p>

    <p>В большинстве языков программирования побитовый OR уже встроен. В языках C++, Python эта операция обозначается как |, в Pascal — это операция or, в Visual Basic — это операция Or.</p>
  </details>
</article>


<!-- Задача J. Ярмарка -->
<article class="article">
  <div class="anchor" id="task10"></div>
  <h3>Задача J. Ярмарка</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 512мб</i></div>

  <p>В Байтландии собираются провести ярмарку. В Байтландии n городов, которые соединены m двухсторонними дорогами, причём из любого города можно доехать до любого другого, передвигаясь только по дорогам.</p>

  <p>В Байтландии производят k
  различных товаров, причём каждый город специализируется на одном товаре. Чтобы ярмарка состоялась, на неё нужно привезти хотя бы s различных товаров. Чтобы привезти товары из города u в город v нужно потратить d(u,v) монет, где d(u,v) — длина кратчайшего пути между городами u и v. Длина пути — это количество дорог, которые входят в этот путь.</p>

  <p>Организаторы ярмарки оплатят перевозку товаров, однако они сами могут выбрать, производителей из каких городов пригласить на ярмарку. Теперь организаторы хотят для каждого из n городов посчитать, какое минимальное количество монет нужно потратить на перевозку товаров, чтобы провести ярмарку в этом городе.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записаны 4 целых числа n, m, k, s (1 ≤ n ≤ 10⁵, 0 ≤ m ≤ 10⁵, 1 ≤ s ≤ k ≤ min(n, 100)) — количество городов, количество дорог, количество различных товаров, количество различных товаров необходимых для проведения ярмарки.</p>

  <p>В следующей строке записаны n чисел a1, a2, ... ,an (1 ≤ ai ≤ k), где ai — номер товара, который производится в i-м городе. Гарантируется, что среди чисел ai встречаются все числа от 1 до k.</p>

  <p>В следующих m строках описываются дороги. Каждая дорога описывается парой u v городов, которые она соединяет (1 ≤ u,v ≤ n, u ≠ v). Гарантируется, что между любой парой городов не более одной дороги. Гарантируется, что можно доехать из любого города в любой, двигаясь только по дорогам.</p>

  <h4>Выходные данные</h4>
  <p>Выведите n чисел, i-е из которых — минимальное количество монет на перевозку товаров при проведении ярмарки в городе i. Разделяйте числа пробелами.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
5 5 4 3
1 2 4 3 2
1 2
2 3
3 4
4 1
4 5
</pre>
    <code>2 2 2 2 3</code>

    <h4>Пример 2</h4>
<pre>
7 6 3 2
1 2 3 3 2 2 1
1 2
2 3
3 4
2 5
5 6
6 7
</pre>
    <code>1 1 1 2 2 1 1</code>
    <p>Рассмотрим первый пример.</p>

    <p>Чтобы провести ярмарку в городе 1, можно привезти товары из городов 1 (0 монет), 2 (1 монета) и 4 (1 монета). Суммарное количество монет равно 2.</p>

    <p>Город 2: Товары из городов 2 (0), 1 (1), 3 (1). Сумма 2.</p>

    <p>Город 3: Товары из городов 3 (0), 2 (1), 4 (1). Сумма 2.</p>

    <p>Город 4: Товары из городов 4 (0), 1 (1), 5 (1). Сумма 2.</p>

    <p>Город 5: Товары из городов 5 (0), 4 (1), 3 (2). Сумма 3.</p>
  </details>
</article>


<!-- Задача K. Пасьянс -->
<article class="article">
  <div class="anchor" id="task11"></div>
  <h3>Задача K. Пасьянс</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Мальчик Вася хочет разложить древнерусский пасьянс под названием «Боян». Пасьянс раскладывается по следующим правилам:</p>
  <ul>
    <li>Колода из n карт тщательно перемешивается, после чего все n карт выкладываются на стол в ряд слева направо;</li>
    <li>Перед каждым ходом на столе лежат в ряд несколько стопок карт (изначально n стопок, в каждой стопке по одной карте). Пронумеруем эти стопки слева направо от 1 до x. За один ход разрешается целиком переместить стопку с наибольшим номером x (то есть самую правую из оставшихся) на стопку x - 1 (если такая существует) или на стопку x - 3 (если такая существует). При этом одну стопку можно переместить на другую, только если верхние карты этих стопок имеют одинаковые масти или достоинства. Заметим, что если стопка x перемещается на стопку y, верхняя карта стопки x становится верхней картой результирующей стопки. Также заметим, что после каждого хода общее количество стопок уменьшается на 1;</li>
    <li>Пасьянс считается разложенным, если все карты находятся в одной стопке.</li>
  </ul>
  <p>Вася уже перемешал карты и выложил их на стол, помогите ему понять, можно разложить пасьянс из этих карт или нет.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных записано единственное целое число n (1 ≤ n ≤ 52) — количество карт в колоде Васи. В следующей строке записано n строк через пробел c1, c2, ..., cn, где строка ci описывает i-ую выложенную на стол карту колоды. Каждая строка ci состоит ровно из двух символов, первый символ обозначает достоинство карты, второй — масть. Карты на столе пронумерованы слева направо.</p>

  <p>Достоинство карты описывается одним из символов: «2», «3», «4», «5», «6», «7», «8», «9», «T», «J», «Q», «K», «A». Масть карты описывается одним из символов: «S», «D», «H», «C».</p>

  <p>Не гарантируются, что в колоде присутствуют все возможные карты. Также карты в колоде Васи могут повторяться.</p>

  <h4>Выходные данные</h4>
  <p>Выведите в единственной строке ответ на задачу: строку «YES» (без кавычек), если разложить пасьянс возможно, строку «NO» (без кавычек) в противном случае.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
4
2S 2S 2C 2C
</pre>
    <code>YES</code>

    <h4>Пример 2</h4>
<pre>
2
3S 2C
</pre>
    <code>NO</code>
    <p>В первом примере можно действовать так:</p>
    <ul>
      <li>переложить 4-ую стопку на 1-ую;</li>
      <li>переложить 3-ую стопку на 2-ую;</li>
      <li>переложить 2-ую стопку на 1-ую.</li>
    </ul>
    <p>Во втором примере разложить пасьянс никак нельзя.</p>
  </details>
</article>


<!-- Задача L. Метро -->
<article class="article">
  <div class="anchor" id="task12"></div>
  <h3>Задача L. Метро</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Классическая для городов Берляндии схема метрополитена представляет собой набор n станций, соединенных n переездами, каждый из которых соединяет ровно две станции и не проходит через какие-либо другие. Кроме того, в классической схеме с каждой станции можно добраться до любой другой, двигаясь по переездам. Переезды можно использовать в обе стороны для перемещения. Между каждой парой станций — не более одного переезда.</p>

  <p>Недавно математики Берляндии доказали теорему, согласно которой в любой классической схеме существует кольцевая и притом ровно одна. Иными словами, в любой классической схеме можно найти единственный цикл из станций (в котором любые две соседние соединены переездом), и этот цикл не содержит никакую станцию более одного раза.</p>

  <p>Это открытие имело мощный социальный эффект — ведь теперь станции можно было сравнивать по принципу их удаления от кольцевой. Например, один житель мог сказать: «я живу в трех переездах от кольцевой», а другой ему ответить: «неудачник, а — я в одном». В интернете стали появляться приложения, предлагающие рассчитать удаленность станции от кольцевой (пошлите смс на короткий номер...).</p>

  <p>Правительство Берляндии решило положить конец этим беспорядкам и взять ситуацию в свои руки. Вам поручено написать программу, которая по схеме метрополитена города для каждой станции определит удаленность от кольцевой.</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержится целое число n (3 ≤ n ≤ 3000), n — количество станций (и одновременно переездов) в схеме метро. Далее в n строках содержатся описания переездов, по одному в строке. Каждая строка содержит пару целых чисел xᵢ, yᵢ (1 ≤ xᵢ, yᵢ ≤ n), и обозначает наличие переезда со станции xᵢ до станции yᵢ. Станции пронумерованы от 1 до n в произвольном порядке. Гарантируется, что xᵢ ≠ yᵢ и то, что между каждой парой станций не более одного переезда. Переезды можно использовать для перемещения в обе стороны. Гарантируется, что заданное описание представляет собой классическую схему метрополитена.</p>

  <h4>Выходные данные</h4>
  <p>Выведите n чисел. Числа разделяйте пробелами, i-ое из них должно быть равно удалению i-ой станции от кольцевой. Для станций на кольцевой выводите число 0.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
4
1 3
4 3
4 2
1 2
</pre>
    <code>0 0 0 0</code>

    <h4>Пример 2</h4>
<pre>
6
1 2
3 4
6 4
2 3
1 3
3 5
</pre>
    <code>0 0 0 1 1 2</code>
  </details>
</article>


<!-- Задача M. Брасс Бирмингем: монеты -->
<article class="article">
  <div class="anchor" id="task13"></div>
  <h3>Задача M. Брасс Бирмингем: монеты</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Сегодня Игорь и Ира вместе с друзьями — Сашей и Лешей — играют в новую настольную игру «Brass Birmingham».</p>

  <p>В каждом раунде игроки по очереди делают ходы. Во время хода игрок может построить производство в городах или дорогу, которая соединяет два города, либо выполнить действие. За все свои постройки игроки платят деньги, ведь в этой игре, как и в реальном мире, всё стоит денег. В конце своего хода игрок выстраивает башенку из потраченных монет и кладет её рядом со своей фигуркой в поле оплаты, а в конце раунда потраченные монеты возвращаются в банк.</p>

  <p>Игорь хочет как можно быстрее начать следующий раунд, поэтому решил оптимизировать процесс возвращения денег в банк. Так, за одну операцию он собирает монеты одного номинала со всех верхушек башенок. Сколько раз Игорю придется повторить эту операцию, чтобы начать новый раунд как можно быстрее?</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержится целое число n (1 ≤ n ≤ 30) — количество различных номиналов монет.</p>

  <p>Во второй строке содержатся четыре целых числа mᵢ (1 ≤ mᵢ ≤ 30, 1 ≤ i ≤ 4) — количество монет в башенке i -го игрока.</p>

  <p>В последующих четырёх строках содержится описание башенок каждого игрока. В i-й из них записано mᵢ целых чисел k<sub>ij</sub> (1 ≤ k<sub>ij</sub> ≤ n, 1 ≤ i ≤ 4, 1 ≤ j ≤ mᵢ) — номинал монеты с номером j. Монеты нумеруются снизу вверх.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите число — минимальное количество операций, необходимое Игорю, чтобы вернуть все монетки в банк.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
5
2 2 2 2
1 1
1 2
1 3
1 4
</pre>
    <code>4</code>

    <h4>Пример 2</h4>
<pre>
5
3 2 3 2
1 1 1
3 2
2 2 3
4 5
</pre>
    <code>6</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Необходимо собрать четырехмерную матрицу A[32][32][32][32]. Начальное состояние A[k1][k2][k3][k4]. Из начального состояния нужно попасть в конечное состояние A[0][0][0][0]. Найти минимальное число ходов.</p>
    <p>При решении динамическим программированием нужно идти от состояния A[0][0][0][0].</p>
    <p>Задавать четырехмерный вектор это не очень хорошая идея.</p>
    <code>&lt;vector&lt;vector&lt;vector&lt;vector&lt;int&gt; &gt; &gt; &gt; A;</code>
    <p>Потому что при создании вектора размером n, выделяется память размером 2n для оптимизации операций push_back, чтобы при добавлении элементов не нужно было перезаписывать весь вектор целиком. На хранение четырехмерного вектора выделяется в 16 раз больше памяти, чем на хранение четырехмерного массива.</p>
    <p>В этой задаче решение возможно только при n ≤ 32. Если больше то четырехмерные массивы это плохо. Заведем глобальный четырехмерный массив.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;

using namespace std;

int A[32][32][32][32];
vector&lt;int&gt; B1(32), B2(32), B3(32), B4(32);
queue&lt;pair&lt;pair&lt;int, int&gt;, pair&lt;int, int&gt; &gt; &gt; q;

// за один шаг из состояния t2 получим состояние t1
// t это номинал монеты
void stepA(pair&lt;pair&lt;int, int&gt;, pair&lt;int, int&gt; &gt;& t1,
  pair&lt;pair&lt;int, int&gt;, pair&lt;int, int&gt; &gt;& t2,
  int t) {

  while (B1[t1.first.first] == t) {
    t1.first.first--;
  }
  while (B2[t1.first.second] == t) {
    t1.first.second--;
  }
  while (B3[t1.second.first] == t) {
    t1.second.first--;
  }
  while (B4[t1.second.second] == t) {
    t1.second.second--;
  }

  if (A[t1.first.first][t1.first.second][t1.second.first][t1.second.second] == -1) {
    A[t1.first.first][t1.first.second][t1.second.first][t1.second.second] = 1 +
    A[t2.first.first][t2.first.second][t2.second.first][t2.second.second];
    q.push(t1);
  }
}

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // ввод данных
  int n; // число номиналов монет
  int m1; // число монет в первой башне
  int m2; // число монет во второй башне
  int m3; // число монет в третьей башне
  int m4; // число монет в четвертой башне
  cin >> n >> m1 >> m2 >> m3 >> m4;

  for (int i = 1; i &lt;= m1; i++) {
    cin >> B1[i];
  }
  for (int i = 1; i &lt;= m2; i++) {
    cin >> B2[i];
  }
  for (int i = 1; i &lt;= m3; i++) {
    cin >> B3[i];
  }
  for (int i = 1; i &lt;= m4; i++) {
    cin >> B4[i];
  }

  // решение
  // инициализация четырехмерной матрицы значением -1
  for (int i1 = 0; i1 &lt; 32; i1++) {
    for (int i2 = 0; i2 &lt; 32; i2++) {
      for (int i3 = 0; i3 &lt; 32; i3++) {
        for (int i4 = 0; i4 &lt; 32; i4++) {
          A[i1][i2][i3][i4] = -1;
        }
      }
    }
  }

  // создадим две структуры с башнями из монет
  pair&lt;pair&lt;int, int&gt;, pair&lt;int, int&gt; &gt; t1, t2;
  // инициализация структурs t1
  t1.first.first = m1;
  t1.first.second = m2;
  t1.second.first = m3;
  t1.second.second = m4;

  // начальная позиция
  A[t1.first.first][t1.first.second][t1.second.first][t1.second.second] = 0;
  q.push(t1);

  while (q.size() > 0) {
    t2 = q.front();
    q.pop();

    t1 = t2;
    if (t1.first.first > 0) {
      // первый столбик
      stepA(t1, t2, B1[t2.first.first]);
    }

    t1 = t2;
    if (t1.first.second > 0) {
      // второй столбик
      stepA(t1, t2, B2[t2.first.second]);
    }

    t1 = t2;
    if (t1.second.first > 0) {
      // третий столбик
      stepA(t1, t2, B3[t2.second.first]);
    }

    t1 = t2;
    if (t1.second.second > 0) {
      // четвертый столбик
      stepA(t1, t2, B4[t2.second.second]);
    }
  }

  // вывод результата
  cout &lt;&lt; A[0][0][0][0];
}
</pre>
  </details>
</article>


<!-- Задача N. Брасс Бирмингем: пиво -->
<article class="article">
  <div class="anchor" id="task14"></div>
  <h3>Задача N. Брасс Бирмингем: пиво</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Сегодня Игорь и Ира вместе с друзьями — Сашей и Лешей — решили поиграть в новую настольную игру «Brass Birmingham».</p>

  <p>В каждом раунде игроки делают ходы по очереди. Во время хода игрок может построить производство в городах, дорогу, соединяющую два города, либо выполнить действие.</p>

  <p>В свой ход Игорь хочет открыть как можно больше своих заводов. Для того, чтобы открыть один завод, игроку требуется перенести к заводу ровно один бочонок «пива», ведь без бочонка «пива» не получится торжественно открыть предприятие. Таким образом, чем больше бочонков «пива» Игорь подвезёт, тем больше заводов он сможет открыть.</p>

  <p>Бочонки «пива» располагаются на пивоварнях, ранее построенных игроками. На каждой пивоварне располагается ровно один бочонок «пива».</p>

  <p>Для открытия заводов Игорь хочет использовать свои бочонки «пива», которые он заготовил ранее. Если их окажется недостаточно, то Игорю придется использовать бочонки «пива» других игроков.</p>

  <p>Правила игры гласят, что бочонки «пива» со своих пивоварен можно использовать без ограничений. Если же игрок хочет перенести бочонок «пива» с чужой пивоварни для построения своего завода, то данное действие можно сделать, только если завод и пивоварня находятся в одном городе, либо между пивоварней и заводом существует путь по дорогам.</p>

  <p>Какое количество своих и чужих бочонков «пива» использует Игорь?</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое число N (2 ≤ N ≤ 10⁵) — количество городов в игре.</p>

  <p>Во второй строке записано целое число M (1 ≤ M ≤ 10⁵) — количество заводов, которые хочет открыть Игорь.</p>

  <p>В третьей строке записано M целых чисел mᵢ (1 ≤ mᵢ ≤N) — города, в которых Игорь хочет открыть заводы. В одном городе может быть несколько заводов.</p>

  <p>В четвертой строке записано целое число K (1 ≤ K ≤ 10⁵) — количество пивоварен Игоря.</p>

  <p>В пятой строке записано K целых чисел kᵢ (1 ≤ kᵢ ≤ N) — города, в которых располагаются пивоварни Игоря. В одном городе может быть несколько пивоварен Игоря.</p>

  <p>В шестой строке записано целое число L (1 ≤ L ≤ 10⁵) — количество пивоварен других игроков.</p>

  <p>В седьмой строке записано L целых чисел lᵢ (1 ≤ lᵢ ≤ N) — города, в которых располагаются пивоварни других игроков. В одном городе может быть несколько пивоварен других игроков.</p>

  <p>В восьмой строке записано целое число G (1 ≤ G ≤ 10⁵) — количество уже построенных дорог.</p>

  <p>В следующих G строках записаны пары целых чисел aᵢ, bᵢ (1 ≤ aᵢ, bᵢ ≤ N) — города, которые соединяются дорогой с номером i.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите два целых числа, разделенных пробелом: количество своих и количество чужих бочонков «пива», которое потребуются Игорю.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
8
4
1 4 3 2
2
2 8
4
8 7 6 5
4
1 2
2 3
4 3
4 5
</pre>
    <code>2 1</code>

    <h4>Пример 2</h4>
<pre>
6
5
2 3 5 2 5
2
1 2
8
2 2 1 6 4 1 2 3
9
4 3
5 2
4 6
1 2
5 6
6 5
1 2
3 4
6 1
</pre>
    <code>2 3</code>
  </details>
</article>


<!-- Задача O. Непростительное заклятие (сложная версия) -->
<article class="article">
  <div class="anchor" id="task15"></div>
  <h3>Задача O. Непростительное заклятие (сложная версия)</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Это сложная версия задачи. В этой версии нет дополнительных ограничений на число k.</p>

  <p>Верховный чародей Визенгамота однажды поймал злого волшебника Drahyrt, но злой волшебник вернулся и хочет отомстить верховному чародею. Поэтому он украл у его ученика Гарри заклинание s.</p>

  <p>Заклинание — это строка длины n, состоящая из строчных латинских букв.</p>

  <p>Drahyrt хочет заменить заклинание на непростительное заклятие — строку t.</p>

  <p>Drahyrt с помощью древней магии может менять местами буквы на расстоянии k или k+1 в заклинании сколько угодно раз. Другими словами, Drahyrt может поменять буквы на позициях i и j в заклинании s если |i-j|=k или |i-j|=k+1.</p>

  <p>Например, если k=3,s= «talant» и t= «atltna», то Drahyrt может действовать следующим образом:</p>
  <ul>
    <li>поменять местами буквы на позициях 1 и 4, получив заклинание «aaltnt».</li>
    <li>поменять местами буквы на позициях 2 и 6, получив заклинание «atltna».</li>
  </ul>

  <p>Вам даны заклинания s и t. Может ли Drahyrt изменить заклинание s на t?</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных дано единственное целое число T (1 ≤ T ≤ 10⁴) — количество наборов входных данных в тесте.</p>

  <p>Далее следуют описания наборов входных данных.</p>

  <p>В первой строке содержится два целых числа n,k (1 ≤ n ≤ 2⋅10⁵, 1 ≤ k ≤ 2⋅10⁵) — длина заклинаний и число k такое, что Drahyrt может менять буквы в заклинании на расстоянии k или k+1.</p>

  <p>Во второй строке дано заклинание s — строка длины n, состоящая из строчных латинских букв.</p>

  <p>В третьей строке дано заклинание t — строка длины n, состоящая из строчных латинских букв.</p>

  <p>Гарантируется, что сумма значений n по всем наборам входных данных не превосходит 2⋅10⁵. Обратите внимание, что ограничений на сумму значений k по всем наборам входных данных нет.</p>

  <h5>Выходные данные</h5>
  <p>Для каждого набора входных данных выведите в отдельной строке «YES» если Drahyrt может изменить заклинание s на t и «NO» иначе.</p>

  <p>Вы можете выводить ответ в любом регистре (например, строки «yEs», «yes», «Yes» и «YES» будут распознаны как положительный ответ).</p>

  <details>
    <summary>Пример</summary>
<pre>
7
6 3
talant
atltna
7 1
abacaba
aaaabbc
12 6
abracadabraa
avadakedavra
5 3
accio
cicao
5 4
lumos
molus
4 3
uwjt
twju
4 3
kvpx
vxpk
</pre>
<pre>
YES
YES
NO
YES
NO
YES
NO
</pre>

    <p>Первый пример разобран в условии.</p>

    <p>Во втором примере можно менять соседние буквы местами, так что можем отсортировать строку например с помощью сортировки пузырьком.</p>

    <p>В третьем примере можно показать, что из строки s невозможно получить строку t меняя местами буквы на расстоянии 6 или 7.</p>

    <p>В четвертом примере подходит например следующая последовательность преобразований:</p>
    <code>«accio» → «aocic» → «cocia» → «iocca» → «aocci» → «aicco» → «cicao».</code>

    <p>В пятом примере можно показать, что невозможно получить из строки s строку t.</p>

    <p>В шестом примере достаточно поменять местами две крайние буквы.</p>
  </details>
</article>


<!-- Задача P. Непростительное заклятие (простая версия) -->
<article class="article">
  <div class="anchor" id="task16"></div>
  <h3>Задача P. Непростительное заклятие (простая версия)</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Это простая версия задачи. В этой версии k всегда равно 3.</p>

  <p>Верховный чародей Визенгамота однажды поймал злого волшебника Drahyrt, но злой волшебник вернулся и хочет отомстить верховному чародею. Поэтому он украл у его ученика Гарри заклинание s.</p>

  <p>Заклинание — это строка длины n, состоящая из строчных латинских букв.</p>

  <p>Drahyrt хочет заменить заклинание на непростительное заклятие — строку t.</p>

  <p>Drahyrt с помощью древней магии может менять местами буквы на расстоянии k или k+1 в заклинании сколько угодно раз. В этой версии задачи можно менять буквы на расстоянии 3 или 4. Другими словами, Drahyrt может поменять буквы на позициях i и j в заклинании s если |i-j|=3 или |i-j|=4.</p>

  <p>Например, если s= «talant» и t= «atltna», то Drahyrt может действовать следующим образом:</p>
  <ul>
    <li>поменять местами буквы на позициях 1 и 4, получив заклинание «aaltnt».</li>
    <li>поменять местами буквы на позициях 2 и 6, получив заклинание «atltna».</li>
  </ul>

  <p>Вам даны заклинания s и t. Может ли Drahyrt изменить заклинание s на t?</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных дано единственное целое число T (1 ≤ T ≤ 10⁴) — количество наборов входных данных в тесте.</p>

  <p>Далее следуют описания наборов входных данных.</p>

  <p>В первой строке содержится два целых числа n,k (1 ≤ n ≤ 2⋅10⁵, k=3) — длина заклинаний и число k такое, что Drahyrt может менять буквы в заклинании на расстоянии k
  или k+1.</p>

  <p>Во второй строке дано заклинание s — строка длины n, состоящая из строчных латинских букв.</p>

  <p>В третьей строке дано заклинание t — строка длины n, состоящая из строчных латинских букв.</p>

  <p>Гарантируется, что сумма значений n по всем наборам входных данных не превосходит 2⋅10⁵. Обратите внимание, что ограничений на сумму значений k по всем наборам входных данных нет.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите в отдельной строке «YES» если Drahyrt может изменить заклинание s на t и «NO» иначе.</p>

  <p>Вы можете выводить ответ в любом регистре (например, строки «yEs», «yes», «Yes» и «YES» будут распознаны как положительный ответ).</p>

  <details>
    <summary>Пример</summary>
<pre>
7
6 3
talant
atltna
7 3
abacaba
aaaabbc
12 3
abracadabraa
avadakedavra
5 3
accio
cicao
5 3
lumos
molus
4 3
uwjt
twju
4 3
kvpx
vxpk
</pre>
<pre>
YES
YES
NO
YES
NO
YES
NO
</pre>
    <p>Первый пример разобран в условии.</p>

    <p>Во втором примере можно действовать следующим образом:</p>
    <ol>
      <li>Поменять местами буквы на позициях 2 и 5 (расстояние 3), тогда получим заклинание «aaacbba».</li>
      <li>Поменять местами буквы на позициях 4 и 7 (расстояние 3), тогда получим заклинание «aaaabbc».</li>
    </ol>

    <p>В третьем примере можно показать, что из строки s невозможно получить строку t меняя местами буквы на расстоянии 3 или 4.</p>

    <p>В четвертом примере подходит например следующая последовательность преобразований:</p>
    <code>«accio» → «aocic» → «cocia» → «iocca» → «aocci» → «aicco» → «cicao».</code>

    <p>В пятом примере можно показать, что невозможно получить из строки s строку t.</p>

    <p>В шестом примере достаточно поменять местами две крайние буквы.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Решение будет зависить от длины строки n. Рассмотрим четыре случая.</p>
    <ol>
      <li>Если длина строки n ≥ 6, то все символы можно менять как угодно.</li>
      <li>Если n = 5, то символы с индексами 0,1,3,4 можно менять как угодно, а символ с индексом 2 должен совпасть у обеих строк.</li>
      <li>При n = 4 можем менять только 1 с 4.</li>
      <li>При n &lt; 4 строки должны полностью совпасть.</li>
    </ol>
    <p>Возможно не работает</p>
<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  int test;
  cin >> test;

  while (test--) {
    int n, k;
    cin >> n >> k;
    string s, t;
    cin >> s >> t;

    // 1 случай
    if (n >= 6) {
      sort(s.begin(), s.end());
      sort(t.begin(), t.end());
      if (s == t) {
        cout &lt;&lt; "YES\n";
      } else {
        cout &lt;&lt; "NO\n";
      }

    // 2 случай
    } else if (n == 5) {
      string buf1, buf2;
      buf1 = s[0] + s[1] + s[3] + s[4];
      buf2 = t[0] + t[1] + t[3] + t[4];
      sort(buf1.begin(), buf1.end());
      sort(buf2.begin(), buf2.end());
      if ( (s[2] == t[2]) && (buf1 == buf2) ) {
        cout &lt;&lt; "YES\n";
      } else {
        cout &lt;&lt; "NO\n";
      }

    // 3 случай
    } else if (n == 4) {
      string buf1, buf2;
      buf1 = s[0] + s[3];
      buf2 = t[0] + t[3];
      sort(buf1.begin(), buf1.end());
      sort(buf2.begin(), buf2.end());
      if ( (s[1] == t[1]) && (s[2] == t[2]) && (buf1 == buf2) ) {
        cout &lt;&lt; "YES\n";
      } else {
        cout &lt;&lt; "NO\n";
      }

    // 4 случай
    } else {
      if (s == t) {
        cout &lt;&lt; "YES\n";
      } else {
        cout &lt;&lt; "NO\n";
      }
    }
  }
}
</pre>
  </details>
</article>

