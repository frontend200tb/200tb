<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contests" target="_blank">Codeforces ЯрГУ. Школьники</a></p>
  <p><a href="https://vk.com/sportprog_yarsu" target="_blank">vk.com/sportprog_yarsu</a></p>
  <p><a href="https://vkvideo.ru/@sportprog_yarsu" target="_blank">vkvideo.ru/@sportprog_yarsu</a></p>
</article>


<article class="article">
  <h1>Занятие 15. Базовые алгоритмы #5. Вещественный бинарный поиск</h1>
  <p>Конспект видео от 2024.12.21</p>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contest/574668" target="_blank">Codeforces Контест 574668</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
        <a href="#p1">Базовые алгоритмы #5. Вещественный бинарный поиск</a>
    <br><a href="#p2">Вещественный бинарный поиск</a>
    <br><a href="#p3">Задача 1. Нахождение корня у функции f(x) = 0</a>
    <br><a href="#p4">Тернарный поиск</a>
    <br><a href="#p5">Задача 2. Нахождение минимума функции на отрезке</a>
    <br><a href="#p6">Вещественный бинарный поиск по ответу</a>
  </p>
  <p>
        <a href="#task1">Задача A. Кубический корень</a>
    <br><a href="#task2">Задача B. Самое первое уравнение</a>
    <br><a href="#task3">Задача C. Квадратный корень и квадратный квадрат</a>
    <br><a href="#task4">Задача D. Кубическое уравнение</a>
    <br><a href="#task5">Задача E. Загадочные резисторы</a>
    <br><a href="#task6">Задача F. Обмен энергией</a>
    <br><a href="#task7">Задача G. Лемминги</a>
    <br><a href="#task8">Задача H. Место встречи изменить нельзя</a>
    <br><a href="#task9">Задача I. Заповедник</a>
    <br><a href="#task10">Задача J. Ваня и компьютерная игра</a>
    <br><a href="#task11">Задача K. Сотовая связь</a>
    <br><a href="#task12">Задача L. Эклеры</a>
    <br><a href="#task13">Задача M. Полёт</a>
    <br><a href="#task14">Задача N. Собрание на прямой</a>
  </p>
</article>


<!-- Базовые алгоритмы #5. Вещественный бинарный поиск -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Базовые алгоритмы #5. Вещественный бинарный поиск</h3>

  <h4>Вывод вещественных чисел</h4>
  <p>Иногда в задачах требуют выводить вещественные числа, и утверждают, что требуют точность 4 знака, 6 знаков и более после запятой.</p>
  <p>Это означает, что тестирующая система проверит ваш ответ с ответом членов жюри по некоторой точности, а именно:</p>
  <code>|answer_jury - answer_your| &lt; eps</code>
  <p>где eps это точность ответа. Например 0.0001.</p>
  <p>Новая библиотека:</p>
  <code>#include &lt;iomanip&gt;</code>

  <p>Без библиотеки <strong>iomanip</strong>, cout пытается вывести вещественное число в сокращенном виде. Библиотека <strong>iomanip</strong> позволяет <strong>зафиксировать точность</strong> вывода и <strong>указать количество знаков после запятой</strong> для вывода функцией cout.</p>
  <p>Пример:</p>
  <code>double a = 0.765765765765765;</code>
  <code>cout &lt;&lt; a &lt;&lt; '\n'; // 0.765766</code>
  <code>cout &lt;&lt; fixed &lt;&lt; setprecision(8) &lt;&lt; a &lt;&lt; '\n'; // 0.76576577</code>

  <p>Кроме того, без библиотеки <strong>iomanip</strong> cout может вывести вещественное число в <strong>экспоненциальной форме</strong>, если она будет короче <strong>десятичной формы</strong>, но тестирующая система воспринимает эту форму не как <strong>число</strong>, а как <strong>строку</strong>. Библиотека <strong>iomanip</strong> позволяет задать только <strong>десятичную форму</strong> для вывода.</p>
  <code>double b = 0.00005;</code>
  <code>cout &lt;&lt; b &lt;&lt; '\n'; // 5e-05</code>
  <code>cout &lt;&lt; fixed &lt;&lt; setprecision(6) &lt;&lt; b &lt;&lt; '\n'; // 0.000050</code>

  <p>Если в задаче требуют вывести n знака после запятой, всегда выводите больше знаков, чтобы улучшить ответ.</p>
  <p>В олимпиадном программировании вещественные числа это всегда плохо. Появляется погрешность в вещественной части, от которой не возможно избавиться. И погрешность после каждого вычисления будет только накапливаться. Если есть возможность решайте все в целых числах.</p>

  <div class="anchor" id="p2"></div>
  <h4>Вещественный бинарный поиск</h4>

  <p>Рассмотрим задачу, нахождения корня у функции f(x) = 0. Например, это многочлен. В большинстве задач по спортивному программированию функции непрерывны. То есть у них нет точек разрыва или области неопределенности. Конечно, у таких функций можно попытаться найти честное математическое решение, но это сложно и долго, поэтому стараются находить приблизительный ответ с заданной точностью.</p>

  <div class="anchor" id="p3"></div>
  <h4>Задача 1. Нахождение корня у функции f(x) = 0</h4>

  <p>Пусть известно, что функция непрерывна, но искать ответ по-честному тяжело. Пусть известно, что при значении left и right функция f(x) принимает разные знаки. Тогда мы можем прибегнуть к вещественному бинарному поиску.</p>
<pre>
double left = 0; // левая граница
double right = 1e6; // правая граница
double mid; // середина
double eps = 0.000001; // точность

// вещественный бинарный поиск
while (right - left > eps) {
  mid = (left + right) / 2;
  if (f(mid)) {
    left = mid;
  } else {
    right = mid;
  }
}

cout &lt;&lt; fixed &lt;&lt; setprecision(8) &lt;&lt; left;
</pre>
  <p>В <strong>бинарном поиске</strong> ответ лежит либо в левой границе left, либо в правой границе right. Где left и right показывают на два разных элемента в массиве и нужно определить в каком из них лежит ответ. В <strong>вещественном бинарном поиске</strong> ответом является любое число в диапазоне от left до right. Поскольку ответ проверяется с некоторой точностью, мы можем добиться того, чтобы весь диапазон был близок к результату членов жюри. Если от вас требуют точность ответа 4 знака после запятой, переменную eps можно сделать с запасом меньше 10⁻⁶.</p>
  <p>Варианты ответов:</p>
  <code>left</code>
  <code>right</code>
  <code>(left+right)/2</code>


  <div class="anchor" id="p4"></div>
  <h4>Тернарный поиск</h4>

  <p>Тернарный поиск применяется когда нужно найти локальный минимум или локальный максимум функции. Алгоритм схож с бинарным поиском, однако вместо нахождения середины отрезка и отсечения половины, мы будем искать трети отрезка и отсечения одного из трех подотрезков. Отрезок, в котором точно находится ответ делят на три части двумя точками разбиения mid_left и mid_right. Рассмотрим задачу нахождения минимума у функции на отрезке от left до right.</p>

  <div class="anchor" id="p5"></div>
  <h4>Задача 2. Нахождение минимума у функции на отрезке от left до right</h4>

  <p>В качестве примера возьмем функцию f1(x) = x² - 5x. Определить сразу при каком значении x будет минимальное значение трудно. Бывает, что функция имеет очень сложный вид.</p>
  <p>Для решения задачи прибегнем к алгоритму тернарный поиск.</p>
  <code>mid_left = left + (right - left)/3,</code>
  <code>mid_right = left + (right - left)/3 * 2.</code>
  <p>На каждой итерации мы будем удалять треть отрезка, где ответа нет.</p>
<pre>
double left = 0;
double right = 1e6;
double mid_left, mid_right, eps = 0.000001;
while (right - left > eps) {
  mid_left = left + (right - left) / 3;
  mid_right = left + (right - left) / 3 * 2;
  if (f1(mid_left) > f1(mid_right)) {
    left = mid_left;
  } else {
    right = mid_right;
  }
}
cout &lt;&lt; fixed &lt;&lt; setprecission(8) &lt;&lt; left;
</pre>
  <p>Так же справедливо, что любое число в диапазоне от left до right является ответом на задачу.</p>

  <div class="anchor" id="p6"></div>
  <h4>Вещественный бинарный поиск по ответу</h4>

  <p>Вещественный бинарный поиск по ответу применяется, если:</p>
  <ol>
    <li>Ответ на задачу можно найти математически, но формулу необходимо долго и трудно выводить.</li>
    <li>Мы можем построить булевскую специальную функцию.</li>
    <li>Ответ на задачу будет находится в месте перехода.</li>
  </ol>
  <p>Последовательность действий алгоритма</p>
  <ol>
    <li>Определяем булевскую функцию, как именно она выглядит (примерный график);</li>
    <li>Определяем границы области поиска, таким образом, чтобы в f(left) f(right) значения булевской функции были разные;</li>
    <li>Находим середину области поиска;</li>
    <li>Определяем значение булевской функции от значения mid.</li>
    <li>В зависимости от результата сдвигаем, либо левую границу области поиска в середину, либо правую границу области поиска в середину;</li>
    <li>Продолжаем выполнять движение границ области поиска до тех пор, пока границы не станут близки по значению right - left > eps;</li>
    <li>Делаем дополнительную проверку элементов после окончания цикла while. Ответ на задачу находится в одной из границ.</li>
  </ol>
</article>


<!-- Задача A. Кубический корень -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Кубический корень</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>На вход подаётся число X, найти его кубический корень. То есть такое число P, что P³ = X.</p>

  <h4>Входные данные</h4>
  <p>Одно число X (-10⁹ &lt; X &lt; 10⁹)</p>

  <h4>Выходные данные</h4>
  <p>Выведите кубический корень от X. Допустимая погрешность - 6 знаков.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>3</code>
    <code>1.44224957030740830177251154964</code>

    <h4>Пример 2</h4>
    <code>1</code>
    <code>1</code>

    <h4>Пример 3</h4>
    <code>1000</code>
    <code>10</code>

    <h4>Пример 4</h4>
    <code>27</code>
    <code>3</code>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;

using namespace std;

// возведение в 3 степень
double formula(double y) {
  return y * y * y;
}

int main() {
  // ввод данных
  int x; // число
  cin >> x;
  double eps = 1e-8;

  // решение
  // в задаче надо найти кубический корень числа x
  double left = 0;
  double right = 1e6;
  double mid;

  // вещественный бинарный поиск
  while (right - left > eps) {
    mid = left + (right - left) / 2;
    if (formula(mid) &lt; x) {
      left = mid;
    } else {
      right = mid;
    }
  }

  // вывод результата
  cout &lt;&lt; fixed &lt;&lt; setprecision(8) &lt;&lt; left;
}
</pre>
  </details>
</article>


<!-- Задача B. Самое первое уравнение -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Самое первое уравнение</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам дано уравнение x = sqrtⁿ(c) корень степени n, необходимо найти x.</p>

  <h4>Входные данные</h4>
  <p>В единственной строке через пробел даны числа n и C (1 ≤ n ≤ 30, -10⁹ ≤ C ≤ 10⁹).</p>

  <h4>Выходные данные</h4>
  <p>Вывести число x - решение данного уравнения. Гарантируется что существует решение уравнения. Ответ вывести с точностью до 6 знаков после запятой.</p>

  <details>
    <summary>Пример</summary>
    <code>2 2</code>
    <code>1.414214</code>
  </details>

  <details>
    <summary>Решение</summary>
    <h4>Пример 2</h4>
    <code>3 8</code>
    <code>2</code>

    <h4>Пример 3</h4>
    <code>3 -27</code>
    <code>3</code>

<pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;

using namespace std;

// возведение в степень n
long double formula(int n, long double mid) {
  long double res = 1;
  while (n--) {
    res *= mid;
  }
  return res;
}

int main() {
  // ввод данных
  int n; // степень корня
  int c; // число
  cin >> n >> c;
  long double eps = 1e-8;

  // решение
  bool flag = false;
  if (c &lt; 0) {
    flag = true;
    c = -c;
  }

  // в задаче надо найти корень степени n числа c
  long double left = 0;
  long double right = c;
  long double mid;

  // вещественный бинарный поиск
  while (right - left > eps) {
    mid = left + (right - left) / 2;
    if (formula(n, mid) &lt; c) {
      left = mid;
    } else {
      right = mid;
    }
  }

  if (flag && n % 2 == 1) {
    right = -right;
  }

  // вывод результата
  cout &lt;&lt; fixed &lt;&lt; setprecision(8) &lt;&lt; right;
}
</pre>
  </details>
</article>


<!-- Задача C. Квадратный корень и квадратный квадрат -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Квадратный корень и квадратный квадрат</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Найдите такое число x, что x² + sqrt(x) = c , с точностью не менее 6 знаков после точки.</p>

  <h4>Входные данные</h4>
  <p>В единственной строке содержится вещественное число 1.0 ≤ C ≤ 10¹⁰.</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно число — искомый x с точностью не менее 6 знаков после запятой.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>2.0000000000</code>
    <code>1.000000000000000</code>

    <h4>Пример 2</h4>
    <code>18.0000000000</code>
    <code>4.000000000000000</code>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;

using namespace std;

typedef long long ll;
typedef long double ld;

ld eps = 1e-8;

ld formula(ld);
ld sqrt2(ld);

int main() {
  // ввод данных
  ld c; // число
  cin >> c;

  // решение
  // в задаче надо найти такой x, что x * x + sqrt(x) = c
  ld left = 0;
  ld right = 1e6;
  ld mid;

  // вещественный бинарный поиск
  while (right - left > eps) {
    mid = left + (right - left) / 2;
    if (formula(mid) &lt; c) {
      left = mid;
    } else {
      right = mid;
    }
  }

  // вывод результата
  cout &lt;&lt; fixed &lt;&lt; setprecision(8) &lt;&lt; right;
}

// вычисление формулы
ld formula(ld x) {
  ld res = x * x + sqrt2(x);
  return res;
}

// вычисление квадратного корня
ld sqrt2(ld y) {
  ld left = 0;
  ld right = 1e6;
  ld mid;

  // вещественный бинарный поиск
  while (right - left > eps) {
    mid = left + (right - left) / 2;
    if (mid * mid &lt; y) {
      left = mid;
    } else {
      right = mid;
    }
  }

  return right;
}
</pre>
  </details>
</article>


<!-- Задача D. Кубическое уравнение -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Кубическое уравнение</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Дано кубическое уравнение a * x³ + b * x² + c * x + d = 0. Известно, что у этого уравнения ровно один корень. Требуется его найти.</p>

  <h4>Входные данные</h4>
  <p>Во входных данных через пробел записаны четыре целых числа: -1000 &lt; a, b, c, d &lt; 1000.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственный корень уравнения с точностью не менее 4 знаков после десятичной точки.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>1 -3 3 -1</code>
    <code>1.00000062275372525455452432652</code>

    <h4>Пример 2</h4>
    <code>-1 -6 -12 -7</code>
    <code>-1</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>График кубической функции f(x) это непрерывная линия с двумя перегибами и может иметь до трех корней (точек где функция равна нулю). В условии уравнение имеет ровно один корень, значит с одной стороны от корня функция больше нуля, а с другой стороны меньше нуля. Зададим границы для вещественного бинарного поиска left и right. Найдем середину mid. Если знак функции больше нуля то сдвигаем правую границу, иначе левую. Будем двигать границы до тех пор, пока разница между ними не будет достаточно мала, чтобы можно было вывести ответ на задачу.</p>
    <p>При отрицательных a левая часть функции больше нуля, а правая - меньше. Если поделить обе части уравнения на a, то мы упростим выражение и гарантируем, что левая часть функции меньше нуля, а правая часть - больше.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;

using namespace std;

double formula(int b, int c, int d, double m) {
  return m * m * m + b * m * m + c * m + d;
}

int main() {
  // ввод данных
  double a, b, c, d;
  cin >> a >> b >> c >> d;

  // решение
  // в задаче надо вычислить корень уравнения
  // a * x * x * x + b * x * x + c * x + d = 0

  // a ≠ 0. Упростим уравнение
  b = b / a;
  c = c / a;
  d = d / a;
  a = 1;

  double left = -10000;
  double right = 10000;
  double mid;
  double eps = 1e-8;

  // вещественный бинарный поиск
  while (right - left > eps) {
    mid = (left + right) / 2;
    if (formula(b, c, d, mid) &lt; 0) {
      left = mid;
    } else {
      right = mid;
    }
  }

  // вывод результата
  cout &lt;&lt; fixed &lt;&lt; setprecision(8) &lt;&lt; left;
}
</pre>
  </details>
</article>


<!-- Задача E. Загадочные резисторы -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Загадочные резисторы</h3>

  <div><i>Ограничение по времени 0.4с
  <br>Ограничение по памяти 64мб</i></div>

  <p>При ремонте электронной платы Вася обнаружил, что плата уже была в ремонте, и один из резисторов на ней заменен на странную конструкцию. Конструкция состояла из k последовательно соединенных звеньев, а каждое звено — из двух параллельно соединенных резисторов.</p>

  <p>Причем, в каждом звене, кроме обычного резистора с ясно читаемым номиналом, присутствовал резистор со странной, нестандартной маркировкой. Осмотрев нестандартные резисторы, Вася пришел к выводу, что все они одинаковые, но определить их номинал не смог. Общее сопротивление всей цепи оказалось равным R Ом. Выписав для каждого звена цепи номинал известного резистора, Вася получил ряд целых чисел r₁, r₂, ..., rₖ.</p>

  <p>Помогите Васе — напишите программу, которая по общему сопротивлению цепи R и известным номиналам r₁, r₂, ..., rₖ вычислит номинал загадочных резисторов.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит два целых числа k (1 ≤ k ≤ 1000) и R (1 ≤ R ≤ 100000), разделенных пробелом. Вторая строка содержит k целых чисел, разделенных пробелами: r₁, r₂, ..., rₖ (1 ≤ rᵢ ≤ 100000; 2R ≤ r₁ + r₂ + ... + rₖ).</p>

  <h4>Выходные данные</h4>
  <p>Программа должна вывести единственное число — предполагаемый номинал загадочных резисторов. Номинал должен быть выведен с точность до 10⁻⁶.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
3 11
3 12 30
</pre>
    <code>6.00000000</code>

    <h4>Пример 2</h4>
<pre>
7 110
15 60 6 45 20 120 70
</pre>
    <code>30.00000000</code>
    <p>Напомним, что при соединении двух резисторов с номиналами R₁ и R₂ общее сопротивление R вычисляется как R = R₁ + R₂ для последовательного соединения и как 1/R=1/R₁+1/R₂ для параллельного.</p>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;iomanip&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // ввод данных
  int k; // число звеньев
  cin >> k;
  long double r; // общее сопротивление цепи
  cin >> r;
  vector&lt;long double&gt; A(k);
  for (int i = 0; i &lt; k; i++) {
    cin >> A[i];
  }

  // решение
  long double left = 1e-8;
  long double right = 1e5;

  // вещественный бинарный поиск
  while (right - left > 1e-8) {
    long double mid = (right + left) / 2;
    long double sum = 0; // вспомогательная сумма
    for (int i = 0; i &lt; k; i++) {
      sum += A[i] * mid / (A[i] + mid);
    }
    if (sum &lt; r) {
      left = mid;
    } else {
      right = mid;
    }
  }

  // вывод результата
  cout &lt;&lt; fixed &lt;&lt; setprecision(8) &lt;&lt; left;
}
</pre>
  </details>
</article>


<!-- Задача F. Обмен энергией -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Обмен энергией</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Как известно, сейчас на планете энергетический кризис. Маленький Петя недоволен этим и собирается спасти мир. Для этого ему нужно чтобы в каждом накопителе было одинаковое число энергии. Изначально в каждом накопителе находится некое количество энергии: в i-ом накопителе находится aᵢ единиц энергии. Энергию можно передавать между накопителями, причем каждый раз при передаче x единиц энергии (x не обязательно целое) ровно k процентов рассеивается. То есть если с одного накопителя передавалось на другой x единиц, то в первом стало на x единиц меньше энергии, а в другом — на x - (xk)/100 больше единиц.</p>

  <p>Ваша задача — помочь Пете найти, какое наибольшее равное количество энергии может остаться в накопителях после обменов энергией.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входного файла находятся два целых числа n и k (1 ≤ n ≤ 10000, 0 ≤ k ≤ 99) — количество накопителей и процент энергии, который рассеивается при передаче.</p>

  <p>В следующей строке находятся n целых чисел a₁, a₂, ... , aₙ — запас энергии в первом, втором, ..., n-ом накопителе соответственно (0 ≤ aᵢ ≤ 1000, 1 ≤ i ≤ n).</p>

  <h4>Выходные данные</h4>
  <p>Выведите максимальное возможное количество энергии, которое может остаться в каждом из накопителей после перераспределения энергии.</p>

  <p>Абсолютная или относительная погрешность ответа не должна превышать 10⁻⁶.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
3 50
4 2 1
</pre>
    <code>2.000000000</code>

    <h4>Пример 2</h4>
<pre>
2 90
1 11
</pre>
    <code>1.909090909</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/68/problem/B" target="_blank">Задача 68B</a>
      <br><a href="https://codeforces.com/contest/68" target="_blank">Codeforces Beta Round 62 2011-03-18</a>
    </div>

    <p>Построим булевскую функцию. Сделать так что все батарейки будут иметь заряд 0 возможно. Сделать так что все батарейки будут иметь заряд 1000 невозможно. Это будут левая и правая границы бинарного поиска. Будем делать вещественный бинарный поиск по ответу. Проверим что в mid это количество энергии равное во всех батарейках. Тогда если у батарейки больше энергии чем в mid, то она должна отдать энергию. Если меньше  - то принять энергию. Если сумма отдаваемой энергии больше чем принимаемой, то сдвигаем правую границу влево. И наоборот.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  long long n; // число накопителей
  long long k; // процент рассеивания
  cin >> n >> k;
  vector&lt;long long&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i]; // запас энергии
  }

  // решение
  // преобразуем вещественные числа в целые
  // используя заданный масштаб
  long long mult = 1000000; // зададим масштаб
  for (int i = 0; i &lt; n; i++) {
    A[i] *= mult;
  }

  double left = 0, right = 1e9, mid; // левая, правая и середина
  double sum_p, sum_m; // сумма положительных и отрицательных
  double eps = 0.00001; // точность

  // вещественный бинарный поиск
  while (right - left > eps) {
    mid = (left + right) / 2;
    sum_p = 0;
    sum_m = 0;

    for (int i = 0; i &lt; n; i++) {
      if (A[i] > mid) {
        sum_p += A[i] - mid;
      } else {
        sum_m += mid - A[i];
      }
    }

    if (sum_p - sum_p * k / 100 > sum_m) {
      left = mid;
    } else {
      right = mid;
    }
  }

  // вывод результата
  cout &lt;&lt; fixed &lt;&lt; setprecision(8) &lt;&lt; left / mult;
}
</pre>
  </details>
</article>


<!-- Задача G. Лемминги -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Лемминги</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Как известно, лемминги любят прыгать. Для очередного эффектного группового прыжка n леммингов собрались у высокой скалы, на которой расположены k удобных уступов. Первый уступ расположен на высоте h метров, второй — на высоте 2h, и так далее (i-ый на высоте i·h метров). Лемминги собираются прыгать на закате, до которого осталось не так много времени.</p>

  <p>Каждый лемминг характеризуется скоростью подъёма vᵢ метров в минуту и массой mᵢ. Это означает, что i-й лемминг может взобраться на j-й уступ за время (j*h)/vᵢ минут.</p>

  <p>Чтобы прыжок получился красивым, более тяжелые лемминги должны прыгать с более высоких уступов: если лемминг массой mᵢ прыгает с уступа i, а лемминг массой m<sub>j</sub> прыгает с уступа j (для i &lt; j), то должно выполняться неравенство mᵢ ≤ m<sub>j</sub>.</p>

  <p>Так как леммингов n, а уступов всего k (k ≤ n), то из n леммингов предстоит выбрать k, которые примут участие в прыжке. Выбранных леммингов нужно распределить по уступам с 1 по k по одному леммингу на уступ. Лемминги должны быть упорядочены в порядке неубывания массы с возрастанием высоты уступа. Кроме того, каждый лемминг должен успеть подняться на свой уступ, то есть время его подъёма не должно превышать t минут. Лемминги карабкаются на свои уступы все одновременно и не мешают друг другу.</p>

  <p>Определите способ организовать прыжок леммингов таким образом, чтобы время t было минимально.</p>

  <h4>Входные данные</h4>
  <p>В первой строке через пробел заданы целые числа n, k и h (1 ≤ k ≤ n ≤ 10⁵, 1 ≤ h ≤ 10⁴) — общее количество леммингов, количество уступов и расстояние между соседними уступами.</p>

  <p>Во второй строке через пробел записаны n целых чисел m₁, m₂, ..., mₙ (1 ≤ mᵢ ≤ 10⁹), где mᵢ — масса i-го лемминга.</p>

  <p>В третьей строке через пробел записаны n целых чисел v₁, v₂, ..., vₙ (1 ≤ vᵢ ≤ 10⁹), где vᵢ — скорость i-го лемминга.</p>

  <h4>Выходные данные</h4>
  <p>Выведите k различных чисел от 1 до n — номера леммингов, которые отправятся на уступы на высотах h, 2h, ..., kh, соответственно, при оптимальном способе организации прыжка. Если существует несколько способов выбрать леммингов, выведите любой.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
5 3 2
1 2 3 2 1
1 2 1 2 10
</pre>
    <code>5 2 4</code>

    <h4>Пример 2</h4>
<pre>
5 3 10
3 4 3 2 1
5 4 3 2 1
</pre>
    <code>4 3 1</code>
    <p>Рассмотрим первый тестовый пример. Пятый лемминг со скоростью 10 забирается на уступ на высоте 2 за 1/5 минуты; второй лемминг со скоростью 2 забирается на уступ на высоте 4 за 2 минуты; четвертый лемминг со скоростью 2 забирается на уступ на высоте 6 за 3 минуты. Все лемминги успевают занять свои места за 3 минуты.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/163/problem/B" target="_blank">Задача 163B</a>
      <br><a href="https://codeforces.com/contest/163" target="_blank">VK Cup 2012 Раунд 2 2012-03-25</a>
    </div>

<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

const int maxN = 1e5;
int n, k, h;
int m[maxN], v[maxN], Pos[maxN], Res[maxN];

bool comp(int i, int j) {
  pair&lt;int, int&gt; pi = make_pair(m[i], v[i]);
  pair&lt;int, int&gt; pj = make_pair(m[j], v[j]);
  return pi &lt; pj;
}

bool solve(double time) {
  int x = 1;
  for (int i = 0; i &lt; n; i++)
  {
    if (v[Pos[i]] * time >= (double)x * h)
    {
      Res[x - 1] = Pos[i];
      x++;
    }
  }
  return x > k;
}


int main() {
  // ускорение ввода-вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // ввод данных
  cin >> n >> k >> h;
  for (int i = 0; i &lt; n; i++) {
    cin >> m[i];
  }
  for (int i = 0; i &lt; n; i++) {
    cin >> v[i];
  }

  // решение
  for (int i = 0; i &lt; n; i++) {
    Pos[i] = i;
  }
  sort(Pos, Pos + n, comp);

  double left = 0;
  double right = 1e9;
  double mid;

  // вещественный бинарный поиск
  for (int i = 0; i &lt; 1000; i++) {
    mid = left + (right - left) / 2;
    if (solve(mid)) {
      right = mid;
    } else {
      left = mid;
    }
  }

  solve(right);

  // вывод результата
  for (int i = 0; i &lt; k; i++) {
    cout &lt;&lt; Res[i] + 1 &lt;&lt; ' ';
  }
}
</pre>
  </details>
</article>


<!-- Задача H. Место встречи изменить нельзя -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Место встречи изменить нельзя</h3>

  <div><i>Ограничение по времени 5с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Главная улица в Байтсити имеет вид длинной прямой с юга на север. Для удобства ориентирования на прямой введены координаты, измеряемые в метрах от самого южного дома в сторону севера.</p>

  <p>В некоторых точках улицы сейчас находятся n друзей, причём i-й из них находится в точке с координатой xᵢ метров и может передвигаться с максимальной скоростью vᵢ метров в секунду в любом из двух направлений вдоль улицы — на юг или на север.</p>

  <p>Перед вами стоит задача определить минимальное время, за которое все n друзей смогут встретиться в одной точке на главной улице. Обратите внимание, что точка, в которой встретятся друзья, не обязана иметь целочисленную координату.</p>

  <h4>Входные данные</h4>
  <p>В первой строке находится единственное целое число n (2 ≤ n ≤ 60000) — количество друзей.</p>

  <p>Во второй строке находятся n целых чисел x₁, x₂, ..., xₙ (1 ≤ xᵢ ≤ 10⁹) — текущие координаты друзей в метрах.</p>

  <p>В третьей строке находятся n целых чисел v₁, v₂, ..., vₙ (1 ≤ vᵢ ≤ 10⁹) — максимальные скорости друзей в метрах в секунду.</p>

  <h4>Выходные данные</h4>
  <p>Выведите минимальное время (в секундах), за которое все n человек смогут встретиться в одной точке.</p>

  <p>Ваш ответ будет считаться правильным, если его абсолютная или относительная погрешность не превышает 10⁻⁶. Формально, пусть ваш ответ равен a, а ответ жюри — b. Ваш ответ будет считаться правильным, если |a-b|/max(1,b) ≤ 10⁻⁶.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
3
7 1 3
1 2 1
</pre>
    <code>2.000000000000</code>

    <h4>Пример 2</h4>
<pre>
4
5 10 3 2
2 3 2 4
</pre>
    <code>1.400000000000</code>
    <p>В первом примере все друзья могут встретиться в точке 5 через 2 секунды. Для этого первый друг должен идти все время со своей максимальной скоростью на юг, а второй и третий должны идти со своими максимальными скоростями на север.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/780/problem/B" target="_blank">Задача 780B</a>
      <br><a href="https://codeforces.com/contest/780" target="_blank">Технокубок 2017 - Финал (только для онсайт-финалистов) 2017-03-05</a>
    </div>

    <p>Бинарным поиском будем искать время, за которое все люди будут пересекаться в одной точке. Зафиксировав время, для каждого человека мы можем определить на сколько он может уйти влево и насколько он может уйти вправо. Будем смотреть что все получившиеся отрезки пересекаются хотя бы в одной точке.</p>
    <p>Ищем самую правую точку из всех левых сдвигов. Ищем самую левую точку из всех правых сдвигов. Если левая точка больше или равна правой, то все отрезки пересекаются.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  int n;
  cin >> n;
  vector&lt;long double&gt; A(n);
  vector&lt;long double&gt; B(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }
  for (int i = 0; i &lt; n; i++) {
    cin >> B[i];
  }

  // решение
  long double time_l = 0;
  long double time_r = 1e9;
  long double time_mid;
  while (time_r - time_l > 0.00000001) {
    time_mid = (time_l + time_r) / 2;
    long double tmp_left = 1e9;
    long double tmp_right = -1e9;
    for (int i = 0; i &lt; n; i++) {
      tmp_left = min(tmp_left, A[i] + time_mid * B[i]);
      tmp_right = max(tmp_right, A[i] - time_mid * B[i]);
    }
    if (tmp_left >= tmp_right) {
      time_r = time_mid;
    } else {
      time_l = time_mid;
    }
  }

  // вывод результата
  // формат языка Си
  printf("%.8lf", time_mid);
  // формат языка C++
  // cout &lt;&lt; fixed &lt;&lt; setprecision(8) &lt;&lt; time_mid;
}
</pre>
  </details>
</article>


<!-- Задача I. Заповедник -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача I. Заповедник</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В лесу, который мы представляем как плоскость, живут n редких животных. Животное номер i имеет логово в точке (xᵢ,yᵢ). В целях защиты этих животных было решено создать заповедник, имеющий форму круга, в котором должны находиться все логова редких животных.</p>

  <p>Также через лес протекает единственная река, из которой пьют все животные, в связи с чем она должна иметь хотя бы одну общую точку с заповедником. С другой стороны, по реке постоянно ходят корабли, чему может помешать наличие более чем одной общей точки реки и заповедника. Таким образом, необходимо, чтобы заповедник и река имели ровно одну общую точку.</p>

  <p>Для вашего удобства ученые уже сделали преобразование координат такое, что теперь река задана уравнением y=0. Определите, возможно ли построить заповедник и найдите минимальный радиус заповедника, удовлетворяющего заданным условиям.</p>

  <h4>Входные данные</h4>
  <p>В первой строке дано целое число n (1 ≤ n ≤ 10⁵) — количество животных.</p>

  <p>В каждой из следующих n строк находятся два целых числа xᵢ, yᵢ (-10⁷ ≤ xᵢ, yᵢ ≤ 10⁷) — координаты логова i-го животного. Гарантируется, что yᵢ ≠ 0, а также, что никакие два расположения логова не совпадают.</p>

  <h4>Выходные данные</h4>
  <p>Если заповедник невозможно построить, выведите -1. Иначе выведите одно вещественное число — минимальный радиус заповедника. Ваш ответ будет засчитан, если абсолютная или относительная погрешность вашего ответа не превышает 10⁻⁶.</p>

  <p>Формально, пусть ваш ответ равен a, а ответ жюри равен b. Ваш ответ будет зачтен, если |a-b|/max(1,|b|) ≤ 10⁻⁶.</p>

  <details>
    <summary>Примеры</summary>
  <h4>Пример 1</h4>
<pre>
1
0 1
</pre>
  <code>0.5</code>
  <p>В первом примере оптимально построить заповедник радиуса 0.5 с центром в точке (0, 0.5).</p>

  <h4>Пример 2</h4>
<pre>
3
0 1
0 2
0 -3
</pre>
  <code>-1</code>
  <p>Во втором примере невозможно построить заповедник.</p>

  <h4>Пример 3</h4>
<pre>
2
0 1
1 1
</pre>
  <code>0.625</code>
  <p>В третьем примере оптимально построить заповедник радиуса 5/8 с центром в точке (1/2, 5/8).</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1059/problem/D" target="_blank">Задача 1059D</a>
      <br><a href="https://codeforces.com/contest/1059" target="_blank">Codeforces Round 514 (Div. 2) 2018-10-05</a>
    </div>

    <p>Чтобы прямая (река) и окружность (заповедник) имели ровно одну точку соприкосновения, прамая должна касаться окружности. Если радиус окружности равен 0, то точно невозможно построить окружность, в которую входят все домики. Если радиус окружности равен 2*10⁷, то окружность можно построить, только если все точки лежат с одной стороны от реки. Тернарным поиском будем искать точку, в которой находится центр заповедника.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  int n, h1 = 0, h2 = 0;
  cin >> n;;
  vector&lt;pair&lt;long double, long double&gt; &gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i].first >> A[i].second;
    if (A[i].second > 0) {
      h1++;
    } else {
      h2++;
    }
  }

  // решение
  if (h1 != 0 && h2 != 0) {
    cout &lt;&lt; -1;
    return 0;
  }
  for (int i = 0; i &lt; n; i++) {
    A[i].second = abs(A[i].second);
  }
  sort(A.begin(), A.end());
  long double left_t, right_t, mid_t_left, mid_t_right;
  left_t = A[0].first - 1;
  right_t = A[n - 1].first + 1;
  long double tmp = 0, res1, res2;

  // тернарный поиск
  while (right_t - left_t > 0.000001) {
    mid_t_left = (right_t - left_t) / 3 + left_t;
    mid_t_right = (right_t - left_t) / 3 * 2 + left_t;

    tmp = 0;
    for (int i = 0; i &lt; n; i++) {
      tmp = max(tmp, ((A[i].first - mid_t_left) * (A[i].first - mid_t_left) +
            A[i].second * A[i].second) / (2 * A[i].second));
    }
    res1 = tmp;

    tmp = 0;
    for (int i = 0; i &lt; n; i++) {
      tmp = max(tmp, (
        (A[i].first - mid_t_right) * (A[i].first - mid_t_right) +
        A[i].second * A[i].second) / (2 * A[i].second)
      );
    }
    res2 = tmp;
    if (res1 > res2) {
      left_t = mid_t_left;
    } else {
      right_t = mid_t_right;
    }
  }

  // вывод результата
  cout &lt;&lt; fixed &lt;&lt; setprecision(8) &lt;&lt; res2;
}
</pre>
  </details>
</article>


<!-- Задача J. Ваня и компьютерная игра -->
<article class="article">
  <div class="anchor" id="task10"></div>
  <h3>Задача J. Ваня и компьютерная игра</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Ваня с другом Вовой играют в компьютерную игру, для прохождения уровня им нужно победить n монстров. Персонаж Вани наносит удары со скоростью x ударов за секунду, а персонаж Вовы — со скоростью y ударов за секунду. Каждый из персонажей тратит фиксированное время на замах, после которого наносится удар (время на замах составляет 1 / x секунды для первого персонажа и 1 / y секунды для второго). i-й монстр умирает после получения ai ударов.</p>

  <p>Ване с Вовой стало интересно, кто нанесет последний удар каждому из монстров. Если Ваня с Вовой одновременно наносят последний удар, то считается, что последний удар нанесли оба из них.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано три целых числа n, x, y (1 ≤ n ≤ 10⁵, 1 ≤ x, y ≤ 10⁶) — количество монстров, скорость атаки Вани и Вовы соответственно.</p>

  <p>В следующих n строках записаны целые числа aᵢ (1 ≤ aᵢ ≤ 10⁹) — количество ударов, необходимое, чтобы победить i-го монстра.</p>

  <h4>Выходные данные</h4>
  <p>Выведите n строк. В i-й строке требуется вывести слово «Vanya», если последний удар по i-му монстру был нанесён Ваней, «Vova», если Вовой, либо «Both», если удар был нанесен ребятами одновременно.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
4 3 2
1
2
3
4
</pre>
<pre>
Vanya
Vova
Vanya
Both
</pre>
    <p>В первом примере первый удар наносит Ваня в момент времени 1 / 3, второй удар наносит Вова в момент времени 1 / 2, третий удар наносит Ваня в момент времени 2 / 3, четвертый и пятый удар Ваня и Вова наносят одновременно в момент времени 1.</p>

    <h4>Пример 2</h4>
<pre>
2 1 1
1
2
</pre>
<pre>
Both
Both
</pre>
    <p>Во втором примере Ваня и Вова одновременно наносят первый и второй удар в момент времени 1.</p>
  </details>

  <details>
    <summary>Мое решение на C++</summary>

    <div>
      <a href="https://codeforces.com/contest/492/problem/D" target="_blank">Задача 492D</a>
      <br><a href="https://codeforces.com/contest/492" target="_blank">Codeforces Round 280 (Div. 2) 2014-12-01</a>
    </div>

    <h4>Тест 3</h4>
<pre>
7 5 20
26
27
28
29
30
31
32
</pre>
<pre>
Vova
Vova
Vova
Both
Both
Vova
Vova
</pre>

<h4>Тест 19</h4>
<pre>
5 999998 1000000
999997
999998
999999
1000000
1000001
</pre>
<pre>
Vova
Both
Both
Vova
Vanya
</pre>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;

using namespace std;

int main() {
  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // ввод данных
  int n; // число монстров
  int x; // число ударов в секунду Вани
  int y; // число ударов в секунду Вовы
  cin >> n >> x >> y;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i]; // число ударов чтобы убить i-го монстра
  }

  // решение
  double eps = 1e-12;
  string res;
  int hs = x + y; // всего ударов за 1 секунду

  // поскольку у Вани и Вовы целое число ударов в секунду
  // и время на замах обратно числу ударов, то можно
  // рассматривать только последнюю секунду, в которую умрет монстр

  // пусть Ваня всегда бьет быстрее
  bool reversed = false;
  if (x &lt; y) {
    int tmp = x;
    x = y;
    y = tmp;
    reversed = true;
  }

  double tx = 1.0 / x; // время на замах Вани
  double ty = 1.0 / y; // время на замах Вовы

  // для каждого монстра найдем кто нанесет последний удар
  for (int i = 0; i &lt; n; i++) {

    // число ударов чтобы убить монстра
    int hits_to_die = A[i] % hs;

    // подсчитаем сколько ударов нанесет Ваня и сколько Вова
    int cnt_x; // число ударов Вани
    double time_x; // время cnt_x удара Вани
    int cnt_x1; // следующий удар, которого Ваня уже не сделает
    double time_x1; // время cnt_x1 удара Вани

    int cnt_y; // число ударов Вовы за время time_x
    double time_y; // время cnt_y удара Вовы

    // находим момент времени, когда будет нанесено hits_to_die ударов
    int left = 0; // ни один удар не нанесен
    int right = hs + 1; // все удары нанесены
    int mid;

    // вещественный бинарный поиск
    while (right - left > 1) {
      mid = left + (right - left) / 2;
      // Ваня нанесет mid ударов со скоростью 1/x
      cnt_x = mid; // число ударов Вани
      time_x = cnt_x * tx; // врема последнего удара Вани
      cnt_y = time_x * y; // число ударов Вовы за время time_x
      time_y = cnt_y * ty;

      if (fabs(time_x - time_y) &lt; eps) {
        cnt_y = cnt_y - 1;
      }

      if (cnt_x + cnt_y &lt;= hits_to_die) {
        left = mid;
      } else {
        right = mid;
      }
    }

    // числа ударов должно хватить, чтобы убить монстра
    cnt_x = left;
    time_x = cnt_x * tx;
    cnt_y = time_x * y;
    time_y = cnt_y * ty;

    if (fabs(time_x - time_y) &lt; eps){
      res = "Both";
    } else if (cnt_y == hits_to_die - cnt_x) {
      if (time_x > time_y) {
        if (!reversed) {
          res = "Vanya";
        } else {
          res = "Vova";
        }
      } else if (time_y > time_x) {
        if (!reversed) {
          res = "Vova";
        } else {
          res = "Vanya";
        }
      }
    }

    // поскольку Вова бьет медленнее, он может нанести еще один
    // удар до следующего удара Вани
    int cnt_y1; // следующий удар, который Вова возможно сделает
    double time_y1; // время cnt_y1 удара Вовы

    cnt_x1 = cnt_x + 1;
    time_x1 = cnt_x1 * tx;
    cnt_y1 = cnt_y + 1;
    time_y1 = cnt_y1 * ty;

    if (fabs(time_x - time_y1) &lt; eps) {
      res = "Both";
    } else if (cnt_y1 == hits_to_die - cnt_x) {
      if (time_x > time_y1) {
        if (!reversed) {
          res = "Vanya";
        } else {
          res = "Vova";
        }
      } else if (time_y1 > time_x) {
        if (!reversed) {
          res = "Vova";
        } else {
          res = "Vanya";
        }
      }
    }

    // гарантированно они одновременно убьют монстра если
    if (x == y || hits_to_die == 0 || hits_to_die == hs-1) {
      res = "Both";
    }

    // вывод результата
    cout &lt;&lt; res &lt;&lt; '\n';
  }
}
</pre>
  </details>

  <details>
    <summary>Решение с codeforces</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

using namespace std;

int n,x,y,i,t,cntx,cnty;
vector &lt;int&gt; rez;

int main() {
    scanf("%d%d%d",&n,&x,&y);
    cntx = cnty = 0;
    while (cntx &lt; x||cnty &lt; y)
    {
        if ((long long)(cntx+1)*y > (long long)(cnty+1)*x)
        {
            cnty++;
            rez.push_back(2);
        }
        else
        if ((long long)(cntx+1)*y &lt; (long long)(cnty+1)*x)
        {
            cntx++;
            rez.push_back(1);
        } else
        {
            cntx++;
            cnty++;
            rez.push_back(3);
            rez.push_back(3);
        }
    }
    for (i = 0; i &lt; n; i++)
    {
        scanf("%d",&t);
        t--;
        int tmp = rez[t%(x+y)];
        if (tmp == 1)
            printf("Vanya\n");
        else if (tmp == 2)
            printf("Vova\n");
        else
            printf("Both\n");
    }
    return 0;
}
</pre>
  </details>
</article>


<!-- Задача K. Сотовая связь -->
<article class="article">
  <div class="anchor" id="task11"></div>
  <h3>Задача K. Сотовая связь</h3>

  <div><i>Ограничение по времени 3с
  <br>Ограничение по памяти 256мб</i></div>

  <p>На прямой заданы n точек — позиции населенных пунктов, а также m точек — позиции вышек сотовой связи. Все вышки работают одинаково, они обеспечивают сотовой связью все населенные пункты, которые удалены от нее не более чем на r.</p>

  <p>Перед вами стоит задача определить минимальное r, чтобы каждый населенный пункт был обеспечен сотовой связью. Иными словами надо найти наименьшее r такое, что для каждого города найдется хотя бы одна вышка на расстоянии не более чем r.</p>

  <p>Если r = 0, то вышка обеспечивает сотовой связью только ту точку, где она расположена. Одна вышка может обеспечивать сотовой связью любое количество населенных пунктов, при условии, что все они расположены от неё на расстоянии не более чем r.</p>

  <h4>Входные данные</h4>
  <p>В первой строке следует два целых положительных числа n и m (1 ≤ n, m ≤ 10⁵) — количество населенных пунктов и количество вышек.</p>

  <p>Во второй строке следует последовательность из n целых чисел a₁, a₂, ..., aₙ ( -10⁹ ≤ aᵢ ≤ 10⁹) — координаты населенных пунктов. Допустимо, что в одной точке может быть несколько населенных пунктов. Все координаты населенных пунктов заданы в порядке неубывания.</p>

  <p>В третьей строке следует последовательность из m целых чисел b₁, b₂, ..., bₘ ( - 10⁹ ≤ b<sub>j</sub> ≤ 10⁹) — координаты вышек сотовой связи. Допустимо, что в одной точке может быть несколько вышек. Все координаты вышек заданы в порядке неубывания.</p>

  <h4>Выходные данные</h4>
  <p>Выведите минимальное число r такое, что каждый населенный пункт будет обеспечен сотовой связью.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
3 2
-2 2 4
-3 0
</pre>
    <code>4</code>

    <h4>Пример 2</h4>
<pre>
5 3
1 5 10 14 17
4 11 15
</pre>
    <code>3</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/702/problem/C" target="_blank">Задача 702C</a>
      <br><a href="https://codeforces.com/contest/702" target="_blank">Educational Codeforces Round 15 2016-07-29</a>
    </div>

    <h4>Пример 3</h4>
<pre>
1 1
10
10
</pre>
    <code>0</code>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;

using namespace std;

vector&lt;int&gt; A;
vector&lt;int&gt; B;

bool isConnect(int k) {
  bool flag = true;
  int near = 1; // номер ближайшей вышки
  // для каждого города
  for (int i = 1; flag && i &lt; A.size(); i++) {
    flag = false;

    //ищем вышку не далее чем на расстоянии k
    for (int j = near; !flag && j &lt; B.size(); j++) {
      if (k >= abs(A[i] - B[j])) {
        flag = true;
        near = j;
      }
    }
  }
  return flag;
}

int main() {
  // ускорение ввода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);

  // ввод данных
  int n; // число городов
  int m; // число вышек
  cin >> n >> m;

  A.resize(n + 1);
  for (int i = 1; i &lt;= n; i++) {
    cin >> A[i];
  }

  B.resize(m + 1);
  for (int i = 1; i &lt;= m; i++) {
    cin >> B[i];
  }

  // решение
  int left = -1;
  int right = 2e9;
  int mid;

  // бинарный поиск
  while (right - left > 1) {
    mid = left + (right - left) / 2;
    if (isConnect(mid)) {
      right = mid;
    } else {
      left = mid;
    }
  }

  // вывод результата
  cout &lt;&lt; right;
}
</pre>
  </details>
</article>


<!-- Задача L. Эклеры -->
<article class="article">
  <div class="anchor" id="task12"></div>
  <h3>Задача L. Эклеры</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>После успешной сдачи всех зачетов Вася купил себе в подарок коробку, содержащую n сладких эклеров. Вася решил каждое утро есть некоторое одинаковое число эклеров, пока они все не закончатся. Однако сосед Васи, Петя, заметил принесенную Васей коробку и тоже решил насладиться вкусом эклеров.</p>

  <p>Теперь процесс поедания эклеров выглядит следующим образом: сначала Вася выбирает число k, одинаковое для всех дней. Затем утром он съедает k эклеров из коробки (или доедает все эклеры, если их осталось меньше k), после этого Петя вечером съедает 10% оставшихся эклеров. Если эклеры еще не закончились, то на следующий день Вася опять съедает k эклеров, а Петя — 10% от оставшихся и так далее.</p>

  <p>Если число эклеров не делится на 10, то Петя округляет «свою» долю в меньшую сторону, например, если в коробке было 97 эклеров, то Петя съест только 9 из них. В частности, если в коробке уже меньше 10 эклеров, то Петя не будет их есть вообще.</p>

  <p>Определите, какое наименьшее число k может выбрать Вася такое, что он съест не менее половины от всех n эклеров, которые были в коробке изначально. Заметьте, что число k должно быть натуральным.</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержится натуральное число n (1 ≤ n ≤ 10¹⁸) — изначальное количество эклеров.</p>

  <h4>Выходные данные</h4>
  <p>Вывести единственное число — наименьшее значение k, удовлетворяющее Васю.</p>

  <details>
    <summary>Пример</summary>
    <code>68</code>
    <code>3</code>
    <p>В примере количество эклеров при k = 3 будет изменяться следующим образом (первым ест Вася):</p>
    <code>68→65→59→56→51→48→44→41→37→34→31→28→26→23→21→18→17→14→13→10→9→6→6→3→3→0</code>
    <p>Итого, Вася съест 39 эклеров, а Петя — 29.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/991/problem/C" target="_blank">Задача 991C</a>
      <br><a href="https://codeforces.com/contest/991" target="_blank">Codeforces Round 491 (Div. 2) 2018-06-23</a>
    </div>

  </details>

</article>


<!-- Задача M. Полёт -->
<article class="article">
  <div class="anchor" id="task13"></div>
  <h3>Задача M. Полёт</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Наташа собирается на ракете полететь на Марс и вернуться на Землю. Также по пути на Марс она приземлится ещё на n - 2 планетах. Формально: пронумеруем все планеты от 1 до n. 1 — Земля, n — Марс. Наташа собирается сделать ровно n полётов: 1→2→... n→1.</p>

  <p>Перелёт с планеты x
  на планету y
  состоит из двух фаз: взлёт с планеты x и приземление на планету y. Таким образом, полный маршрут поездки выглядит следующим образом: 1-я планета → взлёт с 1-й планеты → торможение ко 2-й планете → 2-я планета → взлёт со 2-й планеты → ... → торможение к n-й планете → n-я планета → взлёт с n-й планеты → торможение к 1-й планете → 1-я планета.</p>

  <p>Масса ракеты вместе с полезным грузом (но без топлива) равна m тоннам. Но Наташа не знает, сколько топлива нужно загрузить в ракету. К сожалению, топливо можно загрузить только на Земле, так что, если на какой-то другой планете топливо закончится, то Наташа не сможет вернуться домой. Топливо нужно для взлёта с каждой планеты и для торможения перед каждой планетой. Известно, что 1 тонна топлива может поднять с i-й планеты aᵢ тонн груза или затормозить перед i-й планетой bᵢ тонн груза.</p>

  <p>Например, если масса ракеты составляет 9 тонн, масса топлива 3 тонны, а коэффициент при взлёте равен 8 (aᵢ = 8), то при взлёте сгорит 1.5 тоны топлива (так как 1.5⋅8 = 9 + 3). Новая масса топлива после взлёта будет равна 1.5 тоннам.</p>

  <p>Обратите внимание, что можно использовать нецелый объём топлива при взлёте или посадке. Также, изначальное количество топлива может быть тоже нецелым.</p>

  <p>Помогите Наташе посчитать, какую минимальную массу топлива нужно загрузить в ракету. Учтите, что, с одной стороны, ракета должна везти с помощью топлива не только полезный груз, но и само топливо, а, с другой стороны, топливо, которое сгорело раньше, везти не нужно. Считайте, что ракета мгновенно тормозит и мгновенно разгоняется.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно целое число n (2 ≤ n ≤ 1000) — количество планет.</p>

  <p>Вторая строка содержит одно целое число m (1 ≤ m ≤ 1000) — масса полезного груза.</p>

  <p>Третья строка содержит n целых чисел a₁ ,a₂ , ... , aₙ (1 ≤ aᵢ ≤ 1000). Где aᵢ — это масса ракеты, которую может поднять одна тонна топлива при взлёте.</p>

  <p>Четвёртая строка содержит n целых чисел b₁, b₂, ... , bₙ (1 ≤ bᵢ ≤ 1000). Где bᵢ — это масса ракеты, которую может опустить одна тонна топлива при посадке.</p>

  <p>Гарантируется, что если Наташа может совершить полёт, то для этого ей понадобится не более 10⁹ тонн топлива.</p>

  <h4>Выходные данные</h4>
  <p>Если Наташа сможет долететь до Марса через (n - 2) планеты и вернуться на Землю, выведите минимальную массу топлива (в тоннах), которое Наташа должна взять. В противном случае выведите в одно число -1.</p>

  <p>Гарантируется, что если Наташа может совершить полёт, то для этого ей понадобится не более 10⁹ тонн топлива.</p>

  <p>Ответ будет считаться правильным, если его абсолютная или относительная погрешность не превышает 10⁻⁶. Формально, пусть ваш ответ равен p, а ответ жюри равен q. Ваш ответ будет зачтен, если |p-q|max(1,|q|) ≤ 10⁻⁶.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
2
12
11 8
7 5
</pre>
    <code>10.0000000000</code>

    <h4>Пример 2</h4>
<pre>
3
1
1 4 1
2 5 3
</pre>
    <code>-1</code>

    <h4>Пример 3</h4>
<pre>
6
2
4 6 3 3 5 6
2 6 3 6 5 3
</pre>
  <code>85.4800000000</code>
  <p>Рассмотрим первый пример.</p>

    <p>Сначала масса ракеты с топливом — 22 тонны.</p>
    <il>
      <li>При взлёте с Земли одна тонна топлива может поднять 11 тонн груза, поэтому для подъёма 22 тонн понадобится потратить 2 тонны топлива. Останется 20 тонн ракеты с топливом.</li>
      <li>При посадке на Марс одна тонна топлива может затормозить 5 тонн груза, поэтому для торможения 20 тонн понадобится потратить 4 тонны топлива. Останется 16 тонн ракеты с топливом.</li>
      <li>При взлёте с Марса одна тонна топлива может поднять 8 тонн груза, поэтому для подъёма 16 тонн понадобится потратить 2 тонны топлива. Останется 14 тонн ракеты с топливом.</li>
      <li>При посадке на Землю одна тонна топлива может затормозить 7 тонн груза, поэтому для торможения 14 тонн понадобится потратить 2 тонны топлива. Останется 12 тонн, то есть только ракета.</li>
    </il>
    <p>Во втором примере ракета даже не сможет взлететь с Земли.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1011/problem/C" target="_blank">Задача 1011C</a>
      <br><a href="https://codeforces.com/contest/1011" target="_blank">Codeforces Round 499 (Div. 2) 2018-07-26</a>
    </div>

  </details>

</article>


<!-- Задача N. Собрание на прямой -->
<article class="article">
  <div class="anchor" id="task14"></div>
  <h3>Задача N. Собрание на прямой</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>n людей живут на координатной прямой, i-й человек живет в точке xᵢ (1 ≤ i ≤ n). Они хотят выбрать точку x0 для встречи. i-й человек потратит |xᵢ-x₀| минут, чтобы добраться до места встречи. Также i-му человеку требуется tᵢ минут чтобы одеться, поэтому суммарно ему нужно tᵢ+|xᵢ-x₀| минут чтобы добраться до места встречи.</p>

  <p>Здесь |y| обозначает модуль числа y.</p>

  <p>Эти люди просят вас выбрать позицию x₀, которая минимизирует время, через которое все n людей доберутся до места встречи.</p>

  <h4>Входные данные</h4>
  <p>В первой строке задано единственное целое число t (1 ≤ t ≤ 10³) — количество наборов входных данных. Затем следуют сами наборы входных данных.</p>

  <p>Каждый набор входных данных состоит из трех строк.</p>

  <p>В первой строке задано единственное целое число n (1 ≤ n ≤ 10⁵) — количество людей.</p>

  <p>Во второй строке заданы n целых чисел x₁, x₂, ..., xₙ (0 ≤ xᵢ ≤ 10⁸) — позиции людей.</p>

  <p>В третьей строке заданы n целых чисел t₁, t₂, ... , tₙ (0 ≤ tᵢ ≤ 10⁸), где tᵢ это время, которое нужно i-му человеку, чтобы одеться.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превосходит 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите единственное вещественное число — оптимальная позиция x₀. Можно показать, что существует единственная оптимальная позиция x₀.</p>

  <p>Ваш ответ будет считаться правильным, если его абсолютная или относительная ошибка не превосходит 10⁻⁶. Формально, пусть ваш ответ равен a, а ответ жюри равен b. Ваш ответ будет зачтен, если |a-b|max(1,|b|)≤10⁻⁶.</p>

  <details>
    <summary>Пример</summary>
<pre>
7
1
0
3
2
3 1
0 0
2
1 4
0 0
3
1 2 3
0 0 0
3
1 2 3
4 1 2
3
3 3 3
5 3 3
6
5 4 7 2 10 4
3 2 5 1 4 6
</pre>
<pre>
0
2
2.5
2
1
3
6
</pre>
    <p>В 1-м наборе входных данных есть только один человек, поэтому целесообразно выбрать место встречи в его позиции. Тогда он доберется до него за 3 минуты, которые нужны ему, чтобы одеться.</p>
    <p>Во 2-м наборе входных данных есть 2 человека, которым не нужно время, чтобы одеться. Чтобы добраться до позиции 2, каждому из них потребуется по одной минуте.</p>
    <p>В 5-м наборе входных данных 1-му человеку нужно 4 минуты, чтобы добраться до позиции 1 (4 минуты, чтобы одеться, и 0 минут на сам путь); 2-му человеку нужно 2 минуты, чтобы добраться до позиции 1 (1 минута, чтобы одеться, и 1 минута на сам путь); 3-му человеку нужно 4 минуты, чтобы добраться до позиции 1 (2 минуты, чтобы одеться, и 2 минуты на сам путь).</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1730/problem/B" target="_blank">Задача 1730B</a>
      <br><a href="https://codeforces.com/contest/1730" target="_blank">Codeforces Round 823 (Div. 2) 2022-09-25</a>
    </div>

  </details>

</article>

