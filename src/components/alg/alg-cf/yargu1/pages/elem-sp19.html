<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contests" target="_blank">Codeforces ЯрГУ. Школьники</a></p>
  <p><a href="https://vk.com/sportprog_yarsu" target="_blank">vk.com/sportprog_yarsu</a></p>
  <p><a href="https://vkvideo.ru/@sportprog_yarsu" target="_blank">vkvideo.ru/@sportprog_yarsu</a></p>
</article>


<article class="article">
  <h1>Занятие 19 Графы #1. Базовые понятия теории графов</h1>
  <p>Конспект видео от 2025.02.01</p>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contest/585202" target="_blank">Codeforces Контест 585202</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
        <a href="#p1">Графы #1. Базовые понятия теории графов</a>
    <br><a href="#p2">Способы хранения графов</a>
  </p>
  <p>
        <a href="#task1">Задача A. Светофорчики</a>
    <br><a href="#task2">Задача B. Дороги</a>
    <br><a href="#task3">Задача C. Цветной дождь</a>
    <br><a href="#task4">Задача D. Любовный треугольник</a>
    <br><a href="#task5">Задача E. Матрицу в список</a>
    <br><a href="#task6">Задача F. Список в матрицу</a>
    <br><a href="#task7">Задача G. Список рёбер</a>
    <br><a href="#task8">Задача H. Метро</a>
    <br><a href="#task9">Задача I. Шнурки и шестиклассники</a>
    <br><a href="#task10">Задача J. Топология сети</a>
    <br><a href="#task11">Задача K. Дорожная сеть</a>
    <br><a href="#task12">Задача L. Маршруты</a>
    <br><a href="#task13">Задача M. Брасс Бирмингем: дороги</a>
    <br><a href="#task14">Задача N. Вечная зима</a>
  </p>
</article>


<!-- Графы #1. Базовые понятия теории графов -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Графы #1. Базовые понятия теории графов</h3>

  <h4>Неориентированные графы</h4>

  <p><strong>Определение 1.</strong> <strong>Неориентированным графом</strong> называется упорядоченная пара двух множеств G = (V, E), где 0 &lt; |V| &lt; ∞, а E — подмножество    всевозможных неупорядоченных пар различных двух вершин из V.   Приведем примеры неориентированных графов: Pic 1. Неориентированные графы 1. с числовым обозначением вершин, 2. с буквенным обозначением вершин.</p>
  <p>На рис. 1 представлены диаграммы специального вида, которые состоят из объектов двух видов:</p>
  <ol>
    <li>из кружочков (вершин);</li>
    <li>отрезков или линий, которые соединяют пары вершин (ребра).</li>
  </ol>
  <p>Таким образом:</p>
  <ol>
    <li>граф (на рис. 1 a) содержит 6 вершин, пронумерованных от 1 до 6, и 5 ребер;</li>
    <li>граф (на рис. 1 b) содержит 5 вершин, пронумерованных от a до e, и 5 ребер.</li>
  </ol>

  <p><strong>Заметка 1.</strong> Отметим, что рисунки — это лишь изображения (портреты) графов. Сами же графы — это формальные понятия, выраженные на языке теории множеств.</p>
  <p><strong>Определение 2.</strong> Две вершины x, y <strong>смежны</strong> тогда и только тогда, когда (x, y) ∈ E.</p>
  <p><strong>Определение 3.</strong> Вершина x и ребро (a, b) <strong>инцидентны</strong> тогда и только тогда, когда x = a или x = b.</p>
  <p><strong>Определение 4.</strong> <strong>Степенью вершины </strong>x (обозначается как d(x) или deg(x)) называется число рёбер, инцидентных x:</p>
  <code>d(x) = |{(x, y) : (x, y) ∈ E}|.</code>
  <p>Вершина со степенью, равной 0, называется <strong>изолированной</strong>.</p>
  <p><strong>Определение 5.</strong> <strong>Петля</strong> — ребро имеющее вид (x, x).</p>
  <p><strong>Определение 6.</strong> <strong>Кратные ребра</strong> — это ребра, соединяющие одну и ту же пару вершин (x, y).</p>
  <p><strong>Определение 7.</strong> <strong>Кратность ребра</strong> — это количество ребер в графе G, соединяющих пару вершин (x, y).</p>

  <p><strong>Лемма 1 (лемма о рукопожатиях).</strong> Сумма степеней вершин графа равняется удвоенному количесву ребер:</p>
  <code>Σd(x) = 2m, (x∈V)</code>
  <p>где m — количество рёбер графа.</p>
  <p><strong>Лемма 2.</strong> В произвольном графе обязательно найдутся две вершины одинаковой степени.</p>

  <p><strong>Определение 8.</strong> <strong>Путь</strong> — это последовательность вершин p = (x0, x1, ..., xk), где для всех i (0 ≤ i &lt; k) верно (xi, xi+1) ∈ E.</p>
  <p><strong>Определение 9.</strong> <strong>Длина пути</strong> — количество рёбер, входящих в путь (на 1 меньше количества вершин в пути).</p>
  <p><strong>Определение 10.</strong> <strong>Простой путь</strong> — это путь, в котором все вершины различны.</p>
  <p><strong>Определение 11.</strong> <strong>Цикл</strong> — такой путь, длина которого не менее 1 и который начинается и заканчивается в одной и той же вершине (то есть x0 = xk).</p>
  <p><strong>Определение 12.</strong> <strong>Простой цикл</strong> — это цикл, в котором все вершины различны (кроме начальной и конечной вершины x0 = xk).</p>
  <p><strong>Определение 13.</strong> Вершина y <strong>достижима</strong> из вершины x тогда и только тогда, когда существует путь из x в y.</p>
  <p><strong>Определение 14.</strong> <strong>Компонента связности</strong> — максимальный по включению связный подграф графа.</p>
  <p><strong>Определение 15.</strong> <strong>Мост</strong> — ребро (x, y), при удалении которого количество компонент связности увеличивается.</p>
  <p><strong>Определение 16.</strong> <strong>Связный граф</strong> — такой, что из любой вершины достижима любая другая.</p>
  <p><strong>Определение 17.</strong> <strong>Дерево</strong> — связный ациклический граф.</p>

  <p><strong>Теорема 1.</strong> Пусть G — неориентированный граф, тогда любая пара из трёх утверждений следует третье (и истинность любой пары фактов — критерий того, что G является деревом):</p>
  <ol>
    <li>n = m + 1 (n — количество вершин, m — количество рёбер),</li>
    <li>G — связный граф,</li>
    <li>G — ациклический (не содержит простых циклов).</li>
  </ol>
  <p><strong>Определение 18.</strong> <strong>Лес</strong> — это такой граф, каждая компонента связности которого является деревом. Количество компонент связности леса равно n - m.</p>

  <h4>Ориентированные графы</h4>

  <p>В ориентированном графе появляется направление у ребра, это крайне важное отличие от неориентированного графа. Если в неориентированном графе по ребру (a, b) можно было передвигаться как из вершины a в вершину b, так и в обратном направлении, то в ориентированном графе движение только из a в b. Направление строго фиксируется порядком записи вершин в ребре (a, b).</p>
  <p>Пример ориентированного графа. Граф на рис. 2 состоит из 8 вершин и 11 ребер: (1, 2), (1, 3), (1, 7), (3, 1), (3, 6), (3, 5), (4, 1), (4, 5), (5, 4), (6, 5), (7, 4).</p>
  <p><strong>Определение 19.</strong> <strong>Ориентированный граф</strong> — это упорядоченная пара двух множеств G = (V,E), где 0 ≤ |V| ≤ ∞, E ⊆ V2 (то есть E ⊆ {(x, y)|x, y ∈ V}). Ориентированный граф можно называть <strong>орграфом</strong>.</p>
  <p><strong>Определение 20.</strong> <strong>Дуга</strong> — это ребро (a, b), имеющее направление. Из вершины a можно перейти в вершину b по дуге (a, b), однако переход из вершины b в вершину a по ребру (a, b) запрещен.</p>
  <p><strong>Определение 21.</strong> Вершина x и дуга (a, b) <strong>инцидентны</strong> тогда и только тогда, когда x = a или x = b.</p>
  <p><strong>Определение 22.</strong> <strong>Степень исхода вершины</strong> — количество исходящих дуг:</p>
  <code>d+(x) = |{(x, y) : (x, y) ∈ E}|.</code>
  <p><strong>Определение 23.</strong> <strong>Степень входа вершины</strong> — количество входящих дуг:</p>
  <code>d-(x) = |{(y, x) : (y, x) ∈ E}|.</code>
  <p>В графе на рис. 2 у вершины 1 степень исхода 3, степень входа 2.</p>
  <p><strong>Определение 24.</strong> <strong>Путь</strong> — это последовательность вершин p=(x0, x1, ..., xk), где для всех i (0 ≤ i &lt; k) верно (xi, xi+1) ∈ E.</p>
  <p><strong>Определение 25.</strong> Вершина y <strong>достижима</strong> из вершины x тогда и только тогда, когда существует путь из x в y.</p>
  <p><strong>Определение 26.</strong> Орграф называется <strong>сильно связным</strong>, если из любой вершины достижима любая другая вершина. Компонента сильной связности — максимальный по включению сильно связный подграф.</p>

  <h4>Классы графов</h4>

  <p>Приведем оценку для количества вершин и ребер в графе. Очевидно, что в графе не может быть отрицательного количества ребер. Допустим, в нашем графе n вершин, нет петель и нет кратных ребер, а любая вершина инцидентна с любой другой вершиной. Количество ребер m будет равняться</p>
  <code>m = n(n - 1)/2.</code>
  <p>Следовательно, для любого графа без петель и кратных ребер верно неравенство на количество ребер m:</p>
  <code>0 ≤ m ≤ n(n - 1)/2.</code>
  <p><strong>Определение 27</strong>. <strong>Пустой граф</strong> — это граф без рёбер</p>
  <code>m = 0</code>
  <p>Иногда такие графы называются вполне несвязными. Пустой граф из n вершин обозначается символом Oₙ.</p>
  <p><strong>Определение 28.</strong> <strong>Полный граф</strong> — это граф c максимальным количеством рёбер</p>
  <code>m = n * (n - 1) / 2</code>
  <p>Полный граф из n вершин обозначается символом Kₙ. Например, K₂ — отрезок, а K₃ — треугольник.</p>
  <p><strong>Определение 29.</strong> <strong>Регулярный граф</strong> — это граф, у которого все степени вершин равны. В k-регулярном графе все степени равны k. Например:</p>
  <ul>
    <li>0-регулярные графы — пустые;</li>
    <li>1-регулярные графы содержат чётное число вершин, представляющие собой набор отрезков;</li>
    <li>2-регулярные графы — объединения непересекающихся циклов;</li>
    <li>(n - 1)-регулярные графы — полные графы.</li>
  </ul>
  <p><strong>Определение 30.</strong> Граф называется <strong>двудольным</strong>, если все его вершины можно разместить в двух не пересекающихся множествах, так что любое ребро графа будет соединять вершины из двух разных множеств.</p>
</article>


<!-- Способы хранения графов -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>Способы хранения графов</h3>

  <p>Существуют три классических способа задания графа:</p>
  <ol>
    <li>матрица смежности,</li>
    <li>список смежности,</li>
    <li>список ребер.</li>
  </ol>
  <p>Разные способы хранения графа удобны в разных ситуациях. Рассмотрим каждый из них на примере графа, представленного рис. 3. Pic 3. Неориентированный граф.</p>

  <h4>Матрица смежности</h4>

  <p>Классическое представление графа — это матрица смежности, популярный и простой в реализации способ хранения графа, который имеет свои недостатки.</p>
  <p><strong>Определение 31.</strong> <strong>Матрица смежности</strong> — это квадратная матрица n x n (n — количество вершин), состоящая из нулей и единиц, где на пересечении i-й строки и j-го столбца находится 1 тогда и только тогда, когда вершина j смежная с вершиной i.</p>
  <p>Пример задания матрицы смежности в неориентированном графе, изображенном на рис. 3:</p>
<pre>
0 1 0 0 1 0 1
1 0 1 0 0 0 0
0 1 0 1 1 0 0
0 0 1 0 0 0 0
1 0 1 0 0 1 1
0 0 0 0 1 0 0
1 0 0 0 1 0 0
</pre>

  <p>Основные недостатки такого представления:</p>
  <ol>
    <li>Занимает O(n²) памяти, поскольку для каждой вершины хранится существование ребра для всех остальных вершин. Например, если в графе 10⁵ вершин и порядка 10⁵ ребер, то такое представление займет 10¹⁰ ячеек памяти.</li>
    <li>Перечисление всех смежных вершин занимает O(n) времени, даже если степень вершины маленькая.</li>
  </ol>
  <p>На вход подается неориентированный граф из n вершин и m ребер, заданный списком ребер. Сохраним его в матрицу смежности</p>
<pre>
int n; // число вершин
int m; // число ребер
cin >> n >> m;
int a, b; // две вершины одного ребра

// матрица смежности
vector&lt;vector&lt;int&gt; &gt; G(n + 1, vector&lt;int&gt;(n + 1));

// список ребер сохраним в матрицу смежности
for (int i = 0; i &lt; m; i++) {
  cin >> a >> b;
  G[a][b] = 1;
  G[b][a] = 1;
}
</pre>

  <h4>Списки смежности</h4>

  <p>Поскольку чаще всего в задачах граф достаточно разреженный, выгодно использовать списки смежности.</p>
  <p><strong>Определение 32.</strong> <strong>Список смежности</strong> — это неравномерная матрица из порядка 2 x m элементов (m — количество ребер), в i-ой строке которой перечислены смежные вершины к i-ой вершине.</p>
  <p>Пример задания списка смежности в неориентированном графе по рис. 3:</p>
<pre>
1 : 2 5 7;
2 : 1 3;
3 : 2 4 5;
4 : 3;
5 : 1 3 6 7;
6 : 5;
7 : 1 5.
</pre>

  <p>Список смежности в C++ удобно хранить в виде вектора векторов целых чисел (т. е. как vector&lt;vector&lt;int&gt; &gt;). Иногда в качестве внешнего вектора используется массив. Размер внешнего вектора — количество вершин графа n, а i-я ячейка содержит список (вектор) всех вершин, которые смежны с i-й. Такое представление графа значительно более компактно (занимает O(n + m) единиц памяти).</p>

  <p>На вход подается неориентированный граф из n вершин и m ребер в виде списка ребер. Сохраним его в список смежности G:</p>
<pre>
int n; // число вершин
int m; // число ребер
cin >> n >> m;
int a, b; // две вершины одного ребра

// список смежности
vector&lt;vector&lt;int&gt; &gt; G(n + 1);

// список ребер сохраним в список смежности
for (int i = 0; i &lt; m; i++) {
  cin >> a >> b;
  G[a].push_back(b);
  G[b].push_back(a);
}
</pre>

  <p>На вход подается неориентированный граф из n вершин в виде матрицы смежности. Сохраним его в список смежности G:</p>
<pre>
int n; // число вершин
cin >> n;
int in;

// список смежности
vector&lt;vector&lt;int&gt; &gt; G(n + 1);

// матрицу смежности сохраним в список смежности
for (int i = 1; i &lt;= n; i++) {
  for (int j = 1; j &lt;= n; j++) {
    cin >> in;
    if (in == 1) {
      G[i].push_back(j);
    }
  }
}
</pre>

  <h4>Список ребер</h4>

  <p>Самый непопулярный способ хранения графа при решении задач, однако крайне удобный способ задать граф в задачах в качестве входных данных.</p>
  <p><strong>Определение 33.</strong> <strong>Список ребер</strong> — это массив пар элементов размера m (m — количество ребер), состоящий из пар целых чисел (xᵢ, yᵢ), где xᵢ и yᵢ — номера вершин, соединенных ребром (xᵢ, yᵢ).</p>
  <p>Пример задания списка ребер в неориентированном графе по рис. 3:</p>
  <code>(1, 2), (1, 5), (1, 7), (2, 3), (3, 4), (3, 5), (5, 6), (5, 7)</code>

  <p>Данный метод имеет огромные недостатки при обработке графа.</p>
  <ol>
    <li>Для поиска всех смежных вершин для вершины x потребуется линейный проход по всему списку ребер, что займет O(m) действий.</li>
    <li>Поиск любого ребра занимает порядка O(m) операций.</li>
  </ol>

  <p>На вход подается неориентированный граф из n вершин и m ребер в виде списка ребер. Сохраним его в список ребер G:</p>
<pre>
int n; // число вершин
int m; // число ребер
cin >> n >> m;
vector&lt;pair&lt;int, int&gt; &gt; G(m);

for (int i = 0; i &lt; m; i++) {
  cin >> G[i].first >> G[i].second;
}
</pre>

  <h4>Хранение взвешенного графа</h4>

  <p>Отметим, что в ряде задач ребра графа имеют собственный вес, который учитывается при решении задачи. Например, для прохода по ребру необходимо заплатить монетки или потратить время для прохождения ребра. Время и количество монеток являются весом ребра.</p>
  <p>Данное усложнение немного изменяет способы хранения графа. Чаще всего такие графы задаются следующим образом. В качестве входных параметров дается n, m — количество вершин и ребер в графе. Далее следует список ребер в формате троек xᵢ, yᵢ, wᵢ — xᵢ, yᵢ номера вершин соединенных i ребром, wᵢ вес i ребра.</p>
  <p>Pic 4. Неориентированный взвешенный граф.</p>

  <p><strong>Определение 34.</strong> Матрица смежности (во взвешенном графе) — это квадратная матрица n x n (n — количество вершин), где на пересечении i-й строки и j-го столбца находится wᵢ тогда и только тогда, когда вершина j смежная с вершиной i и имеет вес, равный wᵢ, иначе помечается несуществующим весом (-1).</p>
  <p>Представим граф с рис. 4 в виде матрицы смежности:</p>
<pre>
-1  6  6 -1  3 -1
 6 -1  5 -1 -1 -1
 6  5 -1  5  7 -1
-1 -1  5 -1 -1 -1
 3  1  7 -1 -1  1
-1 -1 -1 -1  1 -1
</pre>

  <p><strong>Определение 35.</strong> Список смежности — это неравномерная матрица из порядка 2 x m элементов (m — количество ребер), в i-ой строке располагается список пар элементов, вес ребра и номер смежной вершины.</p>
  <p>Представим граф с рис. 4 в виде списка смежности:</p>
<pre>
1 : (6, 2), (6, 3), (3, 5);
2 : (6, 1), (5, 3);
3 : (6, 1), (5, 2), (5, 4), (7, 5);
4 : (5, 3);
5 : (3, 1), (7, 3), (1, 6);
6 : (1, 5).
</pre>

  <p>Приведем реализацию инициализации списка смежности для неориентированного взвешенного графа:</p>
<pre>
int n, m;
cin >> n >> m;
vector&lt;vector&lt;pair&lt;int, int&gt; &gt; &gt; G(n + 1);

int x, y, w;
pair&lt;int, int&gt; tmp;

for (int i = 0; i &lt; m; i++) {
  cin >> x >> y >> w;
  tmp.first = w;
  tmp.second = x;
  G[y].push_back(tmp);
  tmp.second = y;
  G[x].push_back(tmp);
}
</pre>
</article>


<!-- Задача A. Светофорчики -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Светофорчики</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 16мб</i></div>

  <p>В подземелье M тоннелей и N перекрестков, каждый тоннель соединяет какие-то два перекрестка. Мышиный король решил поставить по светофору в каждом тоннеле перед каждым перекрестком. Напишите программу, которая посчитает, сколько светофоров должно быть установлено на каждом из перекрестков. Перекрестки пронумерованы числами от 1 до N.</p>

  <h4>Входные данные</h4>
  <p>Записано два числа N и M (0 &lt; N ≤ 100, 0 ≤ M ≤ N * (N - 1) / 2). В следующих M строках записаны по два числа i и j (1 ≤ i, j ≤ N), которые означают, что перекрестки i и j соединены тоннелем. Можно считать, что любые два перекрестка соединены не более, чем одним тоннелем. Нет тоннелей от перекрестка i до него самого.</p>

  <h4>Выходные данные</h4>
  <p>Вывести N чисел: k-ое число означает количество светофоров на k-ом перекрестке.</p>

  <details>
    <summary>Пример</summary>
<pre>
7 10
5 1
3 2
7 1
5 2
7 4
6 5
6 4
7 5
2 1
5 3
</pre>
    <code>3 3 2 2 5 2 3</code>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // ввод данных
  int n; // число перекрестков
  int m; // число тонелей
  cin >> n >> m;

  // переведем список ребер в список смежности
  vector&lt;vector&lt;int&gt; &gt; G(n + 1);
  for (int i = 0; i &lt; m; i++) {
    int x, y;
    cin >> x >> y;
    G[x].push_back(y);
    G[y].push_back(x);
  }

  // решение
  vector&lt;int&gt; Res(n + 1);

  // посчитаем количество светофоров на каждом перекрестке
  for (int i = 1; i &lt;= n; i++) {
    Res[i] = G[i].size();
  }


  // вывод результата
  for (int i = 1; i &lt;= n; i++) {
    cout &lt;&lt; Res[i] &lt;&lt; ' ';
  }
}
</pre>
  </details>
</article>


<!-- Задача B. Дороги -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Дороги</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 16мб</i></div>

  <p>В галактике «Milky Way» на планете «Snowflake» есть N городов, некоторые из которых соединены дорогами. Император галактики «Milky Way» решил провести инвентаризацию дорог на планете «Snowflake». Но, как оказалось, он не силен в математике, поэтому он просит вас сосчитать количество дорог. Требуется написать программу, помогающую императору сосчитать количество дорог на планете «Snowflake».</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано число N (0 ≤ N ≤ 100). В следующих N строках записано по N чисел, каждое из которых является единичкой или ноликом. Причем, если в позиции (i, j) квадратной матрицы стоит единичка, то i-ый и j-ый города соединены дорогами, а если нолик, то не соединены.</p>

  <h4>Выходные данные</h4>
  <p>Необходимо вывести число, определяющее количество дорог на планете «Snowflake».</p>

  <details>
    <summary>Пример</summary>
<pre>
5
0 1 0 0 0
1 0 1 1 0
0 1 0 0 0
0 1 0 0 0
0 0 0 0 0
</pre>
    <code>3</code>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // ввод данных
  int n; // число городов
  cin >> n;

  int cnt1 = 0; // число единичек
  int tmp;

  // считаем число единичек
  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; n; j++) {
      cin >> tmp;
      if (tmp == 1) {
        cnt1++;
      }
    }
  }

  // одна дорога соединяет две единички
  // поэтому поделим число единичек на два
  int res = cnt1 / 2; // число дорог

  // вывод результата
  cout &lt;&lt; res &lt;&lt; ' ';
}
</pre>
  </details>
</article>


<!-- Задача C. Цветной дождь -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Цветной дождь</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 16мб</i></div>

  <p>В Банановой республике очень много холмов, соединенных мостами. На химическом заводе произошла авария, в результате чего испарилось экспериментальное удобрение "зован". На следующий день выпал цветной дождь, причем он прошел только над холмами. В некоторых местах падали красные капли, в некоторых - синие, а в остальных - зеленые, в результате чего холмы стали соответствующего цвета. Президенту Банановой республики это понравилось, но ему захотелось покрасить мосты между вершинами холмов так, чтобы мосты были покрашены в цвет холмов, которые они соединяют. К сожалению, если холмы разного цвета, то покрасить мост таким образом не удастся. Посчитайте количество таких "плохих" мостов.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано N (0 &lt; N ≤ 100) - число холмов. Далее идет матрица смежности, описывающая наличие мостов между холмами (1-мост есть, 0-нет). Предпоследняя строка пустая, а в последней строке записано N чисел, обозначающих цвет холмов: 1 - красный; 2 - синий; 3 - зеленый.</p>

  <h4>Выходные данные</h4>
  <p>Вывести количество "плохих" мостов.</p>

  <details>
    <summary>Пример</summary>
<pre>
7
0 1 0 0 0 1 1
1 0 1 0 0 0 0
0 1 0 0 1 1 0
0 0 0 0 0 0 0
0 0 1 0 0 1 0
1 0 1 0 1 0 0
1 0 0 0 0 0 0

1 1 1 1 1 3 3
</pre>
    <code>4</code>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  int n;
  cin >> n;

  vector&lt;vector&lt;int&gt; &gt; G(n + 1, vector&lt;int&gt;(n + 1));
  for (int i = 1; i &lt;= n; i++) {
    for (int j = 1; j &lt;= n; j++) {
      cin >> G[i][j];
    }
  }

  vector&lt;int&gt; Color(n + 1);
  for (int i = 1; i &lt;= n; i++) {
    cin >> Color[i];
  }

  // решение
  int res = 0;
  for (int i = 1; i &lt;= n; i++) {
    for (int j = i + 1; j &lt;= n; j++) {
      if (G[i][j] == 1) {
        if (Color[i] != Color[j]) {
          res++;
        }
      }
    }
  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача D. Любовный треугольник -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Любовный треугольник</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Как известно, нет самолетов-мужчин и самолетов-женщин. Однако, каждому самолету на Земле нравится какой-то один другой самолет. Всего на Земле n самолетов, пронумерованных от 1 до n, при этом самолету номер i нравится самолет fᵢ, где 1 ≤ fᵢ ≤ n, а также fᵢ ≠ i.</p>

  <p>Назовем любовным треугольником ситуацию, когда самолету A нравится самолет B, самолету B нравится самолет C, а самолету C нравится самолет A. Проверьте, есть ли на Земле хотя бы один любовный треугольник.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно целое число n (2 ≤ n ≤ 5000) — число самолетов.</p>

  <p>Вторая строка содержит n целых чисел f₁, f₂, ..., fₙ (1 ≤ fᵢ ≤ n, fᵢ ≠ i), что означает, что i-му самолету нравится fᵢ-й.</p>

  <h4>Выходные данные</h4>
  <p>Выведите «YES», если на Земле есть любовный треугольник из самолетов. Иначе выведите «NO».</p>

  <p>Каждую букву можно выводить в любом регистре: строчную или заглавную.</p>

  <details>
    <summary>Примеры</summary>
  <h4>Пример 1</h4>
<pre>
5
2 4 5 1 3
</pre>
    <code>YES</code>

    <h4>Пример 2</h4>
<pre>
5
5 5 5 5 1
</pre>
    <code>NO</code>
    <p>В первом примере самолету 2 нравится самолет 4, самолету 4 нравится самолет 1, а самолету 1 нравится самолет 2, поэтому это любовный треугольник.</p>

    <p>Во втором примере любовных треугольников нет.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Задача на ориентированный граф. Показано кто на кого ссылается. Будем искать циклы длины 3. Проверим что 1 → 2 → 3 → 1</p>
    <code>G[G[G[i]]] == i</code>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // ввод данных
  int n; // число самолетов
  cin >> n;

  vector&lt;int&gt; G(n + 1);
  for (int i = 1; i &lt;= n; i++) {
    cin >> G[i];
    // самолету i нравится самолет G[i]
  }

  // решение
  bool flag = false;
  for (int i = 0; i &lt;= n; i++) {
    if (G[i] != i && G[G[G[i]]] == i) {
      flag = true;
    }
  }

  // вывод результата
  if (flag == true) {
    cout &lt;&lt; "YES";
  } else {
    cout &lt;&lt; "NO";
  }
}
</pre>
  </details>
</article>


<!-- Задача E. Матрицу в список -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Матрицу в список</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Неориентированный граф с N вершинами задан матрицей смежности. Выведите его список смежности.</p>

  <h4>Входные данные</h4>
  <p>В первой строке вводится 1 натуральное число N — число вершин в графе (1 ≤ N ≤ 1000). В следующих N строках описан граф матрицей смежности: на пересечении i-й строки и j-го столбца будет стоять единица, если существует ребро из вершины с номером i в вершину с номером j, и ноль в противном случае.</p>

  <h4>Выходные данные</h4>
  <p>Выведите список смежности заданного графа: вывод должен состоять из N строк, в i-й строке должны быть перечислены номера вершин (в возрастающем порядке) с которыми смежна вершина номер i.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
4
0 1 0 1
1 0 1 0
0 1 0 1
1 0 1 0
</pre>
<pre>
2 4
1 3
2 4
1 3
</pre>

    <h4>Пример 2</h4>
<pre>
6
0 0 1 1 0 0
0 0 0 0 1 1
1 0 0 1 0 0
1 0 1 0 0 0
0 1 0 0 0 1
0 1 0 0 1 0
</pre>
<pre>
3 4
5 6
1 4
1 3
2 6
2 5
</pre>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);
  cout.tie(0);

  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // ввод данных
  int n; // число вершин
  cin >> n;
  int tmp;

  vector&lt;vector&lt;int&gt; &gt; G(n + 1); // список смежности

  // переведем матрицу смежности в список смежности
  for (int i = 1; i &lt;= n; i++) {
    for (int j = 1; j &lt;= n; j++) {
      cin >> tmp;
      if (tmp == 1) {
        G[i].push_back(j);
      }
    }
  }

  // вывод результата
  for (int i = 1; i &lt;= n; i++) {
    for (int j = 0; j &lt; G[i].size(); j++) {
      cout &lt;&lt; G[i][j] &lt;&lt; ' ';
    }
    cout &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача F. Список в матрицу -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Список в матрицу</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Неориентированный граф с N вершинами и M ребрами задан списком рёбер. Выведите его матрицу смежности.</p>

  <h4>Входные данные</h4>
  <p>В первой строке вводится 2 целых числа N и M — число вершин и рёбер в графе (1 ≤ N ≤ 1000, 0 ≤ M ≤ n⋅(n-1)/2)</p>

  <h4>Выходные данные</h4>
  <p>Выведите матрицу смежности графа: на пересечении i-й строки и j-го столбца должна стоять единица, если существует ребро из вершины с номером i в вершину с номером j, и ноль в противном случае.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
4 4
1 2
2 3
3 4
4 1
</pre>
<pre>
0 1 0 1
1 0 1 0
0 1 0 1
1 0 1 0
</pre>

    <h4>Пример 2</h4>
<pre>
6 6
1 3
4 3
5 2
1 4
6 5
2 6
</pre>
<pre>
0 0 1 1 0 0
0 0 0 0 1 1
1 0 0 1 0 0
1 0 1 0 0 0
0 1 0 0 0 1
0 1 0 0 1 0
  </details>
</pre>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  int n; // число вершин
  int m; // число ребер
  cin >> n >> m;

  vector&lt;vector&lt;int&gt; &gt; G(n + 1, vector&lt;int&gt;(n + 1));
  int x, y;
  for (int i = 1; i &lt; m; i++) {
    cin >> x >> y;

    // решение
    G[x][y] = 1;
    G[y][x] = 1;
  }

  // вывод результата
  for (int i = 1; i &lt;= n; i++) {
    for (int j = 1; j &lt;= n; j++) {
      cout &lt;&lt; G[i][j] &lt;&lt; ' ';
    }
    cout &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача G. Список рёбер -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Список рёбер</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам задан неориентированный граф без петель и кратных рёбер с n вершинами и m рёбрами. Ваша задача сохранить граф в виде списка рёбер, и отвечать на запросы - существует ли заданное ребро в списке рёбер.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных записаны 2 числа n и m (1 ≤ n, m ≤ 10⁵), в следующих m строках вводятся пары чисел - номера вершин, которые соединены ребром. В следующей строке задаётся число q (1 ≤ q ≤ 10⁵) - количество запросов, после чего в q строках перечисляются пары чисел обозначающие ребро соединяющее данные вершины, которые надо проверить - есть ли они в графе или нет.</p>

  <h4>Выходные данные</h4>
  <p>Вам необходимо отвечать на запросы по одному в каждой из q строк, в i-й строке ответ на i-й запрос - есть ли данное ребро в графе. Если оно есть - выводить "YES", иначе выводить "NO" (Вывод без кавычек)</p>

  <details>
    <summary>Пример</summary>
<pre>
5 5
1 2
3 4
5 3
2 3
1 5
6
1 4
3 2
1 5
5 4
2 4
3 4
</pre>
<pre>
NO
YES
YES
NO
NO
YES
</pre>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);
  cout.tie(0);

  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // ввод данных
  int n; // число вершин
  int m; // число ребер
  cin >> n >> m;

  int x, y; // вершины ребра
  // список смежности
  // число элементов равно числу вершин
  vector&lt;vector&lt;int&gt; &gt; G(n + 1);
  for (int i = 0; i &lt; m; i++) {
    cin >> x >> y;
    G[x].push_back(y);
    G[y].push_back(x);
  }

  int q; // число запросов
  cin >> q;

  while (q--) {
    cin >> x >> y;
    bool flag = false;
    for (int i = 0; i &lt; G[x].size(); i++) {
      if (G[x][i] == y) {
        flag = true;
      }
    }
    if (flag) {
      cout &lt;&lt; "YES\n";
    } else {
      cout &lt;&lt; "NO\n";
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача H. Метро -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Метро</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У Алисы сегодня день рождения, и она пригласила к себе в гости своего любимого друга Боба. Теперь перед Бобом встала непростая задача: доехать до дома Алисы.</p>

  <p>В городе, в котором живут Алиса и Боб, строится первая ветка метро. На этой ветке располагается n станций, пронумерованных от 1 до n. Боб живёт рядом со станцией номер 1, Алиса — со станцией номер s. Движение в метро двустороннее, то есть по первому пути поезда следуют от станции 1 до станции n, по второму — в обратном направлении. После того, как поезд доезжает до конечной станции по соответствующему пути, он сразу уезжает в депо, и ехать на нём дальше невозможно.</p>

  <p>Некоторые станции ещё не открылись или открылись неполностью: для каждой из станций и для каждого из путей известно, закрыта ли эта станция на этом пути или нет. Если станция закрыта по данному пути, то все поезда, следующие в ту сторону, проезжают мимо.</p>

  <p>Когда Боб узнал информацию об открытых и закрытых станциях метро, он обнаружил, что доехать до дома Алисы — не такая уж и простая задача. Помогите Бобу определить, сможет ли он доехать до её дома на метро, или же ему придётся срочно искать другие виды транспорта.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит два целых числа n и s (2 ≤ s ≤ n ≤ 1000) — количество станций метро и номер станции, у которой расположен дом Алисы. Боб живет на станции номер 1.</p>

  <p>Далее следует информация об открытых и закрытых станциях метро.</p>

  <p>Вторая строка содержит n целых чисел a₁ a₂, ... , aₙ (aᵢ = 0 или aᵢ = 1). Если aᵢ = 1, то i-я станция открыта по первому пути (то есть в сторону возрастания номеров станций). Иначе станция закрыта по первому пути.</p>

  <p>Третья строка содержит n целых чисел b₁, b₂, ... , bₙ (bᵢ = 0 или bᵢ = 1). Если bᵢ = 1, то i-я станция открыта по второму пути (то есть в сторону убывания номеров станций). Иначе станция закрыта по второму пути.</p>

  <h4>Выходные данные</h4>
  <p>Выведите «YES» (без кавычек), если Бобу удастся добраться до Алисы на метро, и «NO» (без кавычек) иначе.</p>

  <p>Вы можете выводить каждую букву в любом регистре (строчную или заглавную).</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
5 3
1 1 1 1 1
1 1 1 1 1
</pre>
    <code>YES</code>

    <h4>Пример 2</h4>
<pre>
5 4
1 0 0 0 1
0 1 1 1 1
</pre>
    <code>YES</code>

    <h4>Пример 3</h4>
<pre>
5 2
0 1 1 1 1
1 1 1 1 1
</pre>
  <code>NO</code>
    <p>В первом примере все станции открыты, поэтому Бобу следует просто доехать до станции номер 3.</p>

    <p>Во втором примере Бобу надо доехать до станции 5, после чего пересесть на второй путь и доехать до станции 4.</p>

    <p>В третьем примере Боб не может сесть на поезд, следующий в сторону дома Алисы.</p>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);
  cout.tie(0);

  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // ввод данных
  int n; // число станций метро
  int s; // станция Алисы
  cin >> n >> s;
  vector&lt;int&gt; A(n+1);
  for (int i = 1; i &lt;= n; i++) {
    cin >> A[i];
  }
  vector&lt;int&gt; B(n+1);
  for (int i = 1; i &lt;= n; i++) {
    cin >> B[i];
  }

  // решение
  bool flag = false;

  // Боб может ехать если его станция
  // (первая) открыта в прямом направлении
  if (A[1] == 1) {

    // если станция Алисы открыта в прямом направлении
    if (A[s] == 1) {
      flag = true;
    }

    // если станция Алисы открыта в обратном направлении
    // и можно сделать пересадку после станции Алисы
    if (B[s] == 1) {
      for (int i = s + 1; i &lt;= n; i++) {
        if (A[i] == 1 && B[i] == 1) {
          flag = true;
        }
      }
    }

  }

  // вывод результата
  if (flag) {
    cout &lt;&lt; "YES";
  } else {
    cout &lt;&lt; "NO";
  }
}
</pre>
  </details>
</article>


<!-- Задача I. Шнурки и шестиклассники -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача I. Шнурки и шестиклассники</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Аня и Маша ведут математический кружок у шестиклассников. Во время кружка шестиклассники ведут себя плохо. Они принесли на кружок много шнурков, и связались друг с другом. А именно, каждый шнурок связывает вместе двух шестиклассников. При этом, если два шестиклассника связаны шнурком, то шнурок связывает как первого со вторым, так и второго с первым.</p>

  <p>Чтобы навести порядок, Аня и Маша делают следующее. Сначала Аня для каждого шестиклассника находит, со сколькими другими шестиклассниками он связан шнурками. Если шестиклассник связан ровно с одним другим, Аня объявляет ему выговор. Потом Маша собирает в группу всех шестиклассников, которым Аня объявила выговор, и выгоняет вон из класса. Выгнанные шестиклассники отвязываются и уходят из класса, забирая с собой шнурки, которыми они были привязаны. Потом снова Аня для каждого шестиклассника находит, со сколькими другими шестиклассниками он связан, и так далее. И так они делают, пока Ане удается объявить хотя бы один выговор.</p>

  <p>Определите, сколько групп шестиклассников будут выгнаны из класса.</p>

  <h4>Входные данные</h4>
  <p>В первой строке даны два целых числа n и m — исходное число шестиклассников и шнурков (1 ≤ n ≤ 100, 0 ≤ m ≤ n*(n-1)/2). Шестиклассники пронумерованы числами от 1 до n, а шнурки — числами от 1 до m. В следующих m строках дано по два целых числа a и b — номера шестиклассников, связанных i-ым шнурком (1 ≤ a, b ≤ n, a ≠ b). Гарантируется, что никакие два шестиклассника не связаны более чем одним шнурком. Никакой шнурок не связывает шестиклассника с самим собой.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное число — количество групп шестиклассников, которые будут выгнаны из класса.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
3 3
1 2
2 3
3 1
</pre>
    <code>0</code>

    <h4>Пример 2</h4>
<pre>
6 3
1 2
2 3
3 4
</pre>
    <code>2</code>

    <h4>Пример 3</h4>
<pre>
6 5
1 4
2 4
3 4
5 4
6 4
</pre>
    <code>1</code>

    <p>В первом примере Ане с Машей не выгонят ни одной группы шестиклассников — в изначальной позиции все шестиклассники привязаны к двум другим шестиклассникам, и Ане не удастся сделать ни одного выговора.</p>

    <p>Во втором примере четыре шестиклассника связаны в цепочку, а еще два бегают отдельно. Сначала Аня с Машей выгонят двух крайних шестиклассников из цепочки (1 и 4), а затем — двух оставшихся из цепочки (2 и 3). При этом бегающие отдельно от остальных шестиклассники останутся в классе.</p>

    <p>В третьем примере Аня с Машей сразу же выгонят всех шестиклассников, кроме четвертого, и на этом процесс закончится. Правильный ответ — один.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Сложность O(n³). При n = 100 это приемлемо.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  int n, m;
  cin >> n >> m;

  // список смежности
  vector&lt;vector&lt;int&gt; &gt; G(n + 1);
  int x, y;
  for (int i = 0; i &lt; m; i++) {
    cin >> x >> y;
    G[x].push_back(y);
    G[y].push_back(x);
  }

  // решение
  int res = 0;
  vector&lt;int&gt; Mark(n + 1);
  vector&lt;int&gt; Level(n + 1);
  bool flag = true;

  while (flag) {
    flag = false;
    for (int i = 1; i &lt;= n; i++) {
      for (int j = 0; j &lt; G[i].size(); j++) {
        if (Mark[G[i][j]] == 0 && Mark[i] == 0) {
          Level[i]++;
        }
      }
    }
    for (int i = 1; i &lt;= n; i++) {
      if (Level[i] == 1) {
        if (flag == false) {
          res++;
        }
        flag = true;
        Mark[i] = 1;
      }
      Level[i] = 0;
    }
  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача J. Топология сети -->
<article class="article">
  <div class="anchor" id="task10"></div>
  <h3>Задача J. Топология сети</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В задаче используется упрощенная модель топологий сетей, внимательно прочтите условие задачи и используйте его как формальный документ при разработке решения.</p>

  <p>Поликарп продолжает работать системным администратором в некоторой большой корпорации. Компьютерная сеть этой корпорации состоит из n компьютеров, некоторые из которых соединены кабелем. Компьютеры пронумеруем целыми числами от 1 до n. Известно, что любые два компьютера соединены кабелем непосредственно или через другие компьютеры.</p>

  <p>Поликарп решил узнать топологию этой сети. Сетевая топология — это способ описания конфигурации сети, схема расположения и соединения сетевых устройств.</p>

  <p>Поликарп знает три основные топологии сети: шина, кольцо и звезда. Шина — это топология, которая представляет собой общий кабель, к которому подсоединены все компьютеры. Кольцо — топология, в которой каждый компьютер соединен кабелем только с двумя другими. Звезда — это топология, в которой все компьютеры сети присоединены к единому центральному узлу.</p>

  <p>Представим каждую из этих топологий сети в виде связного неориентированного графа. Под шиной будем понимать связный граф, являющийся единственным путем, то есть граф, в котором все вершины соединены с двумя другими, за исключением двух вершин, которые являются началом и концом пути. Под кольцом будем понимать связный граф, в котором все вершины соединены с двумя другими. Под звездой будем понимать связный граф, в котором выделена единственная центральная вершина, которая соединена со всеми остальными вершинами. Для лучшего понимания ознакомьтесь с рисунком.</p>

  <p>(1) — шина, (2) — кольцо, (3) — звезда</p>

  <p>Вам задан связный неориентированный граф, характеризующий компьютерную сеть корпорации, в которой работает Поликарп. Помогите ему узнать, к какой из данных топологий относится заданная компьютерная сеть. Если это невозможно определить, сообщите, что топология этой сети неизвестна.</p>

  <h4>Входные данные</h4>
  <p>В первой строке через пробел заданы два целых числа n и m (4 ≤ n ≤ 10⁵; 3 ≤ m ≤ 10⁵) — количество вершин и ребер в графе соответственно. Далее в m строках задано описание ребер графа. В i-той строке через пробел задана пара целых чисел xᵢ, yᵢ (1 ≤ xᵢ, yᵢ ≤ n) — номера вершин, которые соединяет i-ое ребро.</p>

  <p>Гарантируется, что заданный граф является связным. Между любыми двумя вершинами существует не более одного ребра. Ни одно ребро не соединяет вершину саму с собой.</p>

  <h4>Выходные данные</h4>
  <p>В единственную строку выведите название топологии сети, к которой относится заданный граф. Если ответом является шина, выведите «bus topology» (без кавычек), если ответом является кольцо, выведите «ring topology» (без кавычек), если ответом является звезда, выведите «star topology» (без кавычек). Если ни один из этих типов не подходит, выведите «unknown topology» (без кавычек).</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
4 3
1 2
2 3
3 4
</pre>
    <code>bus topology</code>

    <h4>Пример 2</h4>
<pre>
4 4
1 2
2 3
3 4
4 1
</pre>
    <code>ring topology</code>

    <h4>Пример 3</h4>
<pre>
4 3
1 2
1 3
1 4
</pre>
    <code>star topology</code>

    <h4>Пример 4</h4>
<pre>
4 4
1 2
2 3
3 1
1 4
</pre>
    <code>unknown topology</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/292/problem/B" target="_blank">Задача 292B</a>
      <br><a href="https://codeforces.com/contest/292" target="_blank">Чемпионат КРОК 2013 - Раунд 1 2013-04-15</a>
    </div>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);
  cout.tie(0);

  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // ввод данных
  int n; // число вершин
  int m; // число ребер
  cin >> n >> m;
  int a, b; // две вершины одного ребра

  // список смежности
  vector&lt;vector&lt;int&gt; &gt; G(n + 1);

  // список ребер сохраним в список смежности
  for (int i = 1; i &lt;= m; i++) {
    cin >> a >> b;
    G[a].push_back(b);
    G[b].push_back(a);
  }

  // решение
  string res;

  // посчитаем степень каждой вершины
  int st1 = 0; // число вершин со степенью 1
  int st2 = 0; // число вершин со степенью 2
  int st3 = 0; // число вершин со степенью 3 и более
  for (int i = 1; i &lt;= n; i++) {
    if (G[i].size() == 1) {
      st1++;
    }
    if (G[i].size() == 2) {
      st2++;
    }
    if (G[i].size() > 2) {
      st3++;
    }
  }

  // если у двух вершин степень 1
  // а у остальных степень 2
  // то это топология шина
  if (st1 == 2 && st2 == n - st1) {
    res = "bus topology";
  }

  // если у всех вершин степень 2
  // то это топология кольцо
  if (st2 == n) {
    res = "ring topology";
  }


  // если у одной вершины степень больше 2
  // а у остальных степень 1
  // то это топология звезда
  if (st3 == 1 && st1 == n - st3) {
    res = "star topology";
  }

  // вывод результата
  if (res.size()) {
    cout &lt;&lt; res;
  } else {
    cout &lt;&lt; "unknown topology";
  }
}
</pre>
  </details>
</article>


<!-- Задача K. Дорожная сеть -->
<article class="article">
  <div class="anchor" id="task11"></div>
  <h3>Задача K. Дорожная сеть</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>После столетий кровопролитных войн Берляндия и Бирляндия наконец объединяются! Жители этих стран устали воевать и решили жить дружно. Однако, процесс возвращения к нормальной мирной жизни будет трудным. Отчасти это обусловлено тем, что все дороги в обеих странах были разрушены во время войны. Поэтому на первом же заседании объединенного правительства было принято решение о скорейшем строительстве сети современных дорог. Каждая дорога будет соединять два города, и ездить по ней можно будет в обоих направлениях. По исторической случайности, в Берляндии и Бирляндии есть по n городов. При проектировании плана дорожной сети нужно учесть, что все города в пределах каждой из стран имеют различную значимость, которую можно обозначить целым числом от 1 до n. Таким образом, в объединенной стране будет два города значимости 1, два города значимости 2, и т.д. Для лучшего обеспечения более значимых городов дорогами было принято решение о том, что из города со значимостью k должны быть дороги ровно в k некоторых других городов. При этом не допускается, чтобы между парой городов было более одной дороги. Однако, возникли затруднения с разработкой плана дорог, отвечающего этому требованию. Вам требуется устранить эту проблему.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое число n (1 ≤ n ≤ 200) — количество городов в каждой из стран.</p>

  <h4>Выходные данные</h4>
  <p>В первой строке выведите общее количество дорог, которое будет построено в соответствии с требованиями к дорожной сети. Далее выведите сами дороги. Описание каждой дороги выводите в отдельной строке в формате «x y» (без кавычек), где x и y — номера городов, соединяемых дорогой (x≠y). Считайте, что города Берляндии пронумерованы от 1 до n в порядке возрастания значимости, а города Бирляндии — от n+1 до 2n, также в порядке возрастания значимости. Строки, содержащие информацию о дорогах, можно выводить в любом порядке. В случае, если решения не существует, выведите «-1» (без кавычек). Если решений несколько, выведите любое из них.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>1</code>
<pre>
1
1 2
</pre>

    <h4>Пример 2</h4>
    <code>2</code>
<pre>
3
1 2
2 4
3 4
</pre>
  </details>
</article>


<!-- Задача L. Маршруты -->
<article class="article">
  <div class="anchor" id="task12"></div>
  <h3>Задача L. Маршруты</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В Берляндии имеется N городов, причем некоторые из них соединены двусторонними дорогами. Никакая дорога не соединяет город с самим собой, и между парой городов не может быть более одной дороги. Коммивояжер Довлентий хочет выбрать маршрут, который проходит через четыре различных города, при этом он должен начинаться и заканчиваться в одном и том же городе, и соседние города маршрута должны быть соединены дорогами. Довлентий просит вас найти количество различных маршрутов, удовлетворяющих таким условиям, учитывая, что направление движения и выбор начального города не имеют значения. Например, маршруты 1→4→3→2→1, 1→2→3→4→1 и 2→3→4→1→2 считаются одинаковыми.</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержатся два целых числа N и M (4 ≤ N ≤ 400, 0 ≤ M ≤ N*(N-1)/2) — количество городов и дорог в Берляндии соответственно.</p>

  <p>В следующих M строках содержатся пары чисел u и v (1 ≤ u, v ≤ N) – пары городов, соединенных дорогами.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите число – количество различных маршрутов, удовлетворяющих условию задачи.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
4 4
1 2
2 3
3 4
4 1
</pre>
    <code>1</code>

    <h4>Пример 2</h4>
<pre>
4 6
1 2
2 3
3 4
4 1
1 3
2 4
</pre>
    <code>3</code>
  </details>
</article>


<!-- Задача M. Брасс Бирмингем: дороги -->
<article class="article">
  <div class="anchor" id="task13"></div>
  <h3>Задача M. Брасс Бирмингем: дороги</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Сегодня Игорь и Ира вместе с друзьями — Сашей и Лешей — решили поиграть в новую настольную игру «Brass Birmingham».</p>

  <p>В каждом раунде игроки делают ходы по очереди. Во время хода игрок может построить производство в городах, дорогу, соединяющую два города, либо выполнить действие.</p>

  <p>Игра закончилась поздней ночью, и пришло время подводить итоги. Игорю доверили посчитать количество очков за построение дорог. Каждая построенная игроком дорога приносит ему количество очков, равное суммарному числу предприятий, открытых в городах, соединяемых этой дорогой.</p>

  <p>К сожалению, Игорь случайно опрокинул игровое поле так, что все карточки перемешались. Огорчившись, он вспомнил, что во время игры записывал в блокнот действия каждого игрока. Помогите Игорю посчитать очки за дороги, полученные каждым игроком.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое число N (2 ≤ N ≤ 10⁵) — количество городов в игре.</p>

  <p>Далее для каждого из четырех игроков указано:</p>

  <p>В первой строке целые числа Mₖ, Gₖ (1 ≤ Mₖ, Gₖ ≤ 10⁴) — количество производств и количество дорог, построенных k-м игроком.</p>

  <p>В следующей строке Mₖ целых чисел mₖi (1 ≤ mₖᵢ ≤ N) — города, в которых располагаются производства k-го игрока.</p>

  <p>Далее Gₖ строк, в каждой из которых располагаются по два целых числа aₖᵢ, bₖᵢ (1 ≤ aₖᵢ, bₖᵢ ≤ N) — города, которые соединяются дорогой k-го игрока.</p>

  <h4>Выходные данные</h4>
  <p>Выведите 4 целых числа через пробел – количеств очков за дороги, которые получил каждый из игроков.</p>

  <details>
    <summary>Пример</summary>
<pre>
4
1 1
1
1 2
3 1
1 2 3
2 3
4 2
1 4 2 3
3 1
4 2
1 4
3
1 3
2 3
3 4
1 2
</pre>
    <code>5 5 9 20 </code>
  </details>
</article>


<!-- Задача N. Вечная зима -->
<article class="article">
  <div class="anchor" id="task14"></div>
  <h3>Задача N. Вечная зима</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Граф-снежинка генерируется из двух целых чисел x и y, которые больше 1, следующим образом:</p>
  <ul>
    <li>Начните с одной центральной вершины.</li>
    <li>Подключите x новых вершин к этой центральной вершине.</li>
    <li>Подключите y новых вершин к каждой из этих x вершин.</li>
  </ul>
  <p>Например, ниже приведен граф-снежинка для x=5 и y=3.</p>

  <p>Граф-снежинка выше имеет центральную вершину 15, затем x=5 вершин, подключенных к ней (3, 6, 7, 8 и 20), а затем y=3 вершины, подключенные к каждой из них.</p>

  <p>Для заданного графа-снежинки определите значения x и y.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно целое число t (1 ≤ t ≤ 1000) — количество наборов входных данных в тесте.</p>

  <p>Первая строка каждого набора входных данных содержит два целых числа n и m (2 ≤ n ≤ 200; 1 ≤ m ≤ min(1000, n*(n-1)/2)) — количество вершин и ребер в графе соответственно.</p>

  <p>Следующие m строк содержат по два целых числа u и v (1 ≤ u, v ≤ n, u ≠ v) — номера вершин, соединенных ребром. Граф не содержит кратных ребер и петель.</p>

  <p>Гарантируется, что этот граф является графом снежинки для некоторых целых чисел x и y, которые больше 1.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных на отдельной строке выведите значения x и y, в этом порядке, разделенные пробелом.</p>

  <details>
    <summary>Пример</summary>
<pre>
3
21 20
21 20
5 20
13 20
1 3
11 3
10 3
4 8
19 8
14 8
9 7
12 7
17 7
18 6
16 6
2 6
6 15
7 15
8 15
20 15
3 15
7 6
1 2
1 3
2 4
2 5
3 6
3 7
9 8
9 3
3 6
6 2
2 1
5 2
2 7
4 3
3 8
</pre>
<pre>
5 3
2 2
2 3
</pre>
    <p>Первый набор входных данных изображен в условии. Обратите внимание, что вывод 3 5 является неправильным, так как сначала должно быть выведено x, а затем y.</p>
  </details>
</article>

