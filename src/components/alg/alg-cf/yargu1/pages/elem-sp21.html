<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contests" target="_blank">Codeforces ЯрГУ. Школьники</a></p>
  <p><a href="https://vk.com/sportprog_yarsu" target="_blank">vk.com/sportprog_yarsu</a></p>
  <p><a href="https://vkvideo.ru/@sportprog_yarsu" target="_blank">vkvideo.ru/@sportprog_yarsu</a></p>
</article>


<article class="article">
  <h1>Занятие 21 Графы #3. DFS. Поиск в глубину</h1>
  <p>Конспект видео от 2025.02.15</p>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contest/588471" target="_blank">Codeforces Контест 588471</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
        <a href="#p1">Графы #3. DFS. Поиск в глубину</a>
    <br><a href="#p2">1 Поиск количества компонент связности</a>
    <br><a href="#p3">2 Проверка существования пути от вершины a к вершине b</a>
    <br><a href="#p4">3 Проверка графа на двудольность</a>
    <br><a href="#p5">4 Поиск циклов</a>
    <br><a href="#p6">5 Восстановление цикла</a>
    <br><a href="#p7">6 Проверка на предка</a>
  </p>
  <p>
        <a href="#task1">Задача A. Дерево</a>
    <br><a href="#task2">Задача B. Компоненты связности</a>
    <br><a href="#task3">Задача C. Скачки</a>
    <br><a href="#task4">Задача D. Цикл в графе</a>
    <br><a href="#task5">Задача E. NP-трудная задача</a>
    <br><a href="#task6">Задача F. Посчитай треугольники</a>
    <br><a href="#task7">Задача G. Предок</a>
    <br><a href="#task8">Задача H. Товарищ майор</a>
    <br><a href="#task9">Задача I. Вечеринка (лёгкая версия)</a>
    <br><a href="#task10">Задача J. Ктулху</a>
    <br><a href="#task11">Задача K. Распространение новостей</a>
    <br><a href="#task12">Задача L. Водоснабжение</a>
    <br><a href="#task13">Задача M. Укрепление мостов</a>
    <br><a href="#task14">Задача N. Вечеринка (сложная версия)</a>
    <br><a href="#task15">Задача O. Племя тив</a>
  </p>
</article>


<!-- Графы #3. DFS. Поиск в глубину -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Графы #3. DFS. Поиск в глубину</h3>

  <p>Алгоритм «поиск в глубину», его обыденное название DFS (depth-first search).</p>
  <p>Алгоритм DFS основан на трех принципах:</p>
  <ol>
    <li>обходим граф, посещая каждую вершину только один раз;</li>
    <li>используем структуру данных stack или рекурсивную функцию;</li>
    <li>обходим граф по соседям, если видим не помеченную смежную вершину, то переходим в смежную вершину. Используем дополнительный vector&lt;int&gt; Mark, в котором отмечаем посещенные вершины</li>
  </ol>

  <p>Алгоритм DFS применяется в задачах:</p>
  <ol>
    <li>поиск количества компонент связности;</li>
    <li>проверка существования пути от вершины a к вершине b (проверка, что вершины a и b из одной компоненты связности);</li>
    <li>поиск пути от вершины start до вершины finish;</li>
    <li>проверка графа на двудольность;</li>
    <li>поиск циклов;</li>
    <li>восстановление цикла;</li>
    <li>проверка на предка (упрощенная задача LCA);</li>
    <li>поиск кратчайшего пути в графе (плохо).</li>
  </ol>
</article>


<!-- 1 Поиск количества компонент связности -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>1 Поиск количества компонент связности</h3>

  <p>Одной из самых простых задач является поиск количества компонент связности. Для ее решения воспользуемся алгоритмом dfs. Приведем реализацию решения задачи двумя разными способами: dfs через рекурсию и dfs через stack.</p>
  <p>При обходе DFS мы можем помечать вершины, в которых уже были. Для этого заведем дополнительный vector&lt;int&gt; Mark(n), где для каждой вершины от 1 до n будет хранится 0, если вершина еще не была посещена, или 1 если вершина уже посещена. Обойдем все вершины в графе. Если вершина x не была помечена, то запустим алгоритм dfs из вершины x.</p>
  <p>Создадим переменную cnt_k для подсчета количества компонент связности.</p>
  <p>В аргументах функции dfs_number_comp передаем:</p>
  <ul>
    <li>vector&lt;vector&lt;int&gt; &gt; G — граф, представленный в виде списка смежности, где в каждой i строке каждая ячейка — это номер вершины, с которой смежная вершина с номером i;</li>
    <li>vector&lt;int&gt; Mark — вектор посещаемости. Mark[i] равняется 1, если до вершины с номером i построен путь, иначе равняется 0. Изначально каждая вершина считается не посещенной;</li>
    <li>tmp — вершина, которую мы рассматриваем сейчас.</li>
  </ul>

  <p>Трудоемкость алгоритма O(m), где m — количество ребер. Рекурсивная реализация алгоритма dfs считается классическим вариантом.</p>

  <p><strong>Задача.</strong> На вход подается неориентированный граф из n вершин и m ребер, заданный списком ребер. Найти количество компонент связности.</p>
<pre>
int n; // число вершин
int m; // число ребер
cin >> n >> m;
int a, b; // две вершины одного ребра

// список смежности
vector&lt;vector&lt;int&gt; &gt; G(n + 1);

// ссписок ребер сохраним в список смежности
for (int i = 0; i &lt; m; i++) {
  cin >> a >> b;
  G[a].push_back(b);
  G[b].push_back(a);
}

vector&lt;int&gt; Mark(n + 1);
// Mark[i] = 0 если не посещали вершину
// Mark[i] = 1 если уже посетили вершину

int cnt_k = 0; // число компонент связности

// пройдем по всем вершинам
for (int i = 1; i &lt;= n; i++) {
  if (Mark[i] == 0) {

    // если вершина не была посещена
    // то мы нашли новую компоненту связности
    cnt_k++;

    // запускаем dfs чтобы пометить все вершины
    // в этой компоненте связности
    dfs(G, Mark, i);
  }
}

cout &lt;&lt; cnt_k; // выводим результат
</pre>

  <p>Реализация DFS через рекурсию для подсчета компонент связности.</p>
<pre>
void dfs(vector&lt;vector&lt;int&gt; &gt;& G,
         vector&lt;int&gt;& Mark, int tmp;) {

  // помечаем вершину как пройденную
  Mark[tmp] = 1;

  // обходим всех ее соседей
  for (int i = 0; i &lt; G[tmp].size(); i++) {

    // если в вершине еще не были,
    // то запускаем для нее dfs
    if(Mark[G[tmp][i]] == 0) {
      dfs(G, Mark, G[tmp][i]);
    }
  }
}
</pre>

  <p>Реализация DFS через stack для подсчета компонент связности.</p>
<pre>
void dfs(vector&lt;vector&lt;int&gt; &gt;& G,
         vector&lt;int&gt;& Mark, int tmp) {

  stack&lt;int&gt; st;
  st.push(tmp);
  Mark[tmp] = 1;  // помечаем вершину
  int cur;
  bool flag = true;

  // пока стек не пустой
  // берем вершину из стека
  while (st.size() > 0) {
    flag = false;
    cur = st.top();

    // обходим всех ее соседей
    for (int i = G[cur].size() - 1; i >= 0; i--) {
      if (Mark[G[cur][i]] == 0) {
        Mark[G[cur][i]] = 1;
        st.push(G[cur][i]);
        flag = true;
        G[cur].pop_back();
        break;
      } else {
        G[cur].pop_back();
      }
    }

    if(flag == false) {
      st.pop();
    }
  }
}
</pre>
</article>


<!-- 2 Проверка существования пути от вершины a к вершине b -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>2 Проверка существования пути от вершины a к вершине b</h3>

  <p>Для поверки на запрос, лежат ли вершины a и b в одной компоненте связности, можно воспользоваться функцией dfs_number_comp. Это    неплохое решение задачи, однако, если запросов на проверку много, программа будет работать слишком долго. Для решения задачи воспользуемся вспомогательной памятью для запоминания, в какой компоненте связности располагается каждая вершина графа.</p>
  <p>Создадим дополнительный vector&lt;int&gt; Color, где для каждой i вершины будем хранить номер компоненты связности, в которой располагается вершина i.  Color[a] == Color[b] означает, что вершины лежат в одной компоненте связности.</p>
  <p>Улучшим реализацию функции dfs. Добавим в аргументы функции:</p>
  <ol>
    <li>vector&lt;int&gt; Color — вектор покраски компонент связности. Color[i] равняется номеру цвета компоненты связности, в которой располагается вершина i;</li>
    <li>number_color — номер цвета компоненты связности.</li>
  </ol>

  <p><strong>Задача.</strong> На вход подается неориентированный граф из n вершин и m ребер, заданный списком ребер. Подается q запросов, в каждом запросе проверить существование пути от вершины a к вершине b.</p>
<pre>
int n; // число вершин
int m; // число ребер
cin >> n >> m;
int q; // число запросов
int a, b; // две вершины одного ребра

// список смежности
vector&lt;vector&lt;int&gt; &gt; G(n + 1);

// ссписок ребер сохраним в список смежности
for (int i = 0; i &lt; m; i++) {
  cin >> a >> b;
  G[a].push_back(b);
  G[b].push_back(a);
}

vector&lt;int&gt; Mark(n + 1);
// Mark[i] = 0 если не посещали вершину
// Mark[i] = 1 если уже посетили вершину

int cnt_k = 0; // номер компоненты связности

vector&lt;int&gt; Color(n + 1);

// пройдем по всем вершинам
for (int i = 1; i &lt;= n; i++) {
  if (Mark[i] == 0) {

    // если вершина не была посещена
    // то мы нашли новую компоненту связности
    cnt_k++;

    // запускаем bfs на этой вершине
    // чтобы раскрасить все соседние вершины
    dfs(G, Mark, Color, cnt_k, i);
  }
}

cin >> q;

while (q--) {
  int a, b;
  cin >> a >> b;
  if (Color[a] == Color[b]) {
    cout &lt;&lt; "Yes\n";
  } else {
    cout &lt;&lt; "No\n";
  }
}
</pre>

<p>Реализация DFS через рекурсию для проверки существования пути из вершины a в вершину b.</p>
<pre>
void dfs(vector&lt;vector&lt;int&gt; &gt;& G,
  vector&lt;int&gt;& Mark,
  vector&lt;nt&gt;& Color,
  int number_color,
  int tmp) {

    Mark[tmp] = 1; // пометим вершину

    // номер компоненты связности для вершины tmp
    Color[tmp] = number_color;

    for (int i = ; i &lt; G[tmp].size(); i++) {
      if (Mark[G[tmp][i]] == 0) {
        dfs(G, Mark, Color, number_color, G[tmp][i]);
      }
    }
  }
</pre>
</article>


<!-- 3 Проверка графа на двудольность -->
<article class="article">
  <div class="anchor" id="p4"></div>
  <h3>3 Проверка графа на двудольность</h3>

  <p>Для проверки графа на двудольность мы должны покрасить его вершины в два цвета таким образом, чтобы любые две смежные вершины были покрашены в два разных цвета. Воспользуемся вспомогательным vector&lt;int&gt; Color, где в Color[i] будем запоминать, в какой цвет красили i вершину. Для проверки графа на двудольность потребуется проверить каждую компоненту связности, что она является двудольной, то есть в каждой компоненте связности потребуется запустить алгоритм dfs.</p>
  <p>Изменим реализацию функции dfs_color. Поменяем в ней способ использования vector&lt;int&gt; Color, добавим переменную flag для проверки на двудольность:</p>
  <ol>
    <li>vector&lt;int&gt; Color — вектор покраски вершин. Color[i] равняется цвету двудольности для вершины i 0 или 1;</li>
    <li>flag — флаг, проверяющий, что граф двудольный, если flag равняется false, то граф не является двудольным, если true — граф двудольный;</li>
    <li>x — вершина, из которой мы переходим по ребру (x, y);</li>
    <li>y — вершина, в которую мы переходим по ребру (x, y).</li>
  </ol>
<pre>
void dfs(vector&lt;vector&lt;int&gt; &gt;& G,
  vector&lt;int&gt;& Mark,
  vector&lt;int&gt;& Color,
  bool& flag,
  int y,
  int x) {

  Color[y] = (Color[x] + 1) % 2;
  Mark[y] = 1;

  for (int i = 0; i &lt; G[y].size(); i++) {
    if (Mark[G[y][i]] == 0) {
      dfs(G, Mark, Color, flag, G[y][i], y);
    } else if (Color[y] == Color[G[y][i]]) {
      flag = false;
    }
  }
}
</pre>
</article>


<!-- 4 Поиск циклов -->
<article class="article">
  <div class="anchor" id="p5"></div>
  <h3>4 Поиск циклов</h3>

  <p>Заведем переменную флаг, равную false, пока цикл не найден, присвоим ей true, когда найдем цикл.</p>
  <code>bool flag = false;</code>

  <p>Основная задача, для чего используют поиск в глубину при решении задач, — это задача на поиск циклов. В самой простой формулировке задача описывается так: дан неориентированный граф, необходимо определить, есть ли в нем цикл.</p>
  <p>В графе может быть огромное количество циклов, поэтому чаще всего требуется определить, существует ли цикл в графе. При самой реализации функции нужно помнить, что проход по ребру (x, y), (y, x) чаще всего не является циклом в задачах.</p>
  <p>Рассмотрим реализацию функции dfs_find_cycle. В аргументах функции dfs_find_cycle передаем:</p>
  <ol>
    <li>vector&lt;vector&lt;int&gt; &gt; G — граф, представленный в виде списка смежности, где в каждой i строке каждая ячейка — это номер вершины, с которой смежна вершина с номером i;</li>
    <li>vector&lt;int&gt; Mark — вектор посещаемости. Mark[i] равняется 1, если до вершины с номером i построен путь, иначе равняется 0. Изначально каждая вершина считается не посещенной;</li>
    <li>flag — флаг, проверяющий, что в графе есть цикл, если flag = true, то мы нашли цикл;</li>
    <li>x — вершина, из которой мы переходим по ребру (x, y);</li>
    <li>y — вершина, в которую мы переходим по ребру (x, y).</li>
  </ol>

  <p><strong>Задача.</strong> На вход подается неориентированный граф из n вершин и m ребер, заданный списком ребер. Есть ли в графе цикл?</p>
<pre>
int n; // число вершин
int m; // число ребер
cin >> n >> m;
int a, b; // две вершины одного ребра

// список смежности
vector&lt;vector&lt;int&gt; &gt; G(n + 1);

// список ребер сохраним в список смежности
for (int i = 0; i &lt; m; i++) {
  cin >> a >> b;
  G[a].push_back(b);
  G[b].push_back(a);
}

vector&lt;int&gt; Mark(n + 1);
// Mark[i] = 0 если не посещали вершину
// Mark[i] = 1 если уже посетили вершину

bool flag = false; // цикл не найден

for (int i = 1; i &lt;= n && flag == false; i++) {
  if (Mark[i] == 0) {
    dfs(G, Mark, flag, i, -1);
  }
}

if (flag) {
  cout &lt;&lt; "YES\n";
} else {
  cout &lt;&lt; "NO\n";
}
</pre>

  <p>Реализация рекурсивного DFS для поиска цикла.</p>
<pre>
void dfs_find_cycle(vector&lt;vector&lt;int&gt; &gt;& G,
  vector&lt;int&gt;& Mark, bool& flag, int y, int x) {

  Mark[y] = 1; // помечаем вершину в которую пришли

  for (int i = 0; i &lt; G[y].size() && flag == false; i++) {

    if (Mark[G[y][i]] == 0) {
      // если еще не были в соседней вершине,
      // то выполняем dfs на соседней вершине
      dfs_find_cycle(G, Mark, flag, G[y][i], y);

    } else if (G[y][i] != x) {
      // если в соседней вершине уже были,
      // но это не та вершина из которой только что пришли
      flag = true; // значит мы нашли цикл
    }
  }
}
</pre>
</article>


<!-- 5 Восстановление цикла -->
<article class="article">
  <div class="anchor" id="p6"></div>
  <h3>5 Восстановление цикла</h3>

  <p>Будем в стеке хранить часть до цикла и сам цикл.</p>
  <code>stack&lt;int&gt; st;</code>
  <p>Пока не найден цикл, при посещении вершины будем добавлять ее в стек. При выходе из вершины будем удалять ее из стека. Как только найдем цикл, стек замораживается.</p>

  <p>Рассмотрим задачу поиска и хранении цикла в неориентированном графе.</p>
<pre>
void dfs_find_cycle_save(vector&lt;vector&lt;int&gt; &gt;& G,
  vector&lt;int&gt;& Mark, stack&lt;int&gt;& st,
  bool& flag, int y, int x) {

  st.push(y); // вершину, в которую пришли, добавляем в стек
  Mark[y] = 1; // вершину, в которую пришли, помечаем как посещенную

  // проходим по всем смежным вершинам, пока не найден цикл
  for (int i = 0; i &lt; G[y].size() && flag == false; i++) {
    if (Mark[G[y][i]] == 0) {
      // если еще не были в вершине
      dfs_find_cycle_save(G, Mark, st, flag, G[y][i], y);
    } else if (G[y][i] != x) {
      // если уже были в вершине
      // и пришли не из нее
      flag = true; // найден цикл
      st.push(G[y][i]); // добавим ее повторно в стек
    }
  }

  // если цикла не было
  if (flag == false) {
    st.pop();
  }
}
</pre>

  <p>В результате функции dfs_find_cycle_save в stack будет храниться путь до цикла и сам цикл. Теперь наша новая задача — вытянуть сам цикл из stack.</p>
<pre>
void cycle_output(vector&lt;int&gt;& Res,
  stack&lt;int&gt;& st) {

  // вершина в которой закончился цикл
  int x = st.top(); // запомним ее
  st.pop(); // удалим ее из стека
  Res.push_back(x); // добавим ее в результат

  // достаем вершины из стека пока не найдем начало цикла
  while (x != st.top()) {
    Res.push_back(st.top()); // добавляем вершину в результат
    st.pop(); // удаляем вершину из стека
  }

  Res.push_back(x); // добавляем начало цикла в результат
  reverse(Res.begin(), Res.end());
}
</pre>
</article>


<!-- 6 Проверка на предка -->
<article class="article">
  <div class="anchor" id="p7"></div>
  <h3>6 Проверка на предка</h3>

  <p>При обходе DFS мы можем не только помечать вершины, в которых уже были, но и делать дополнительные действия. Заведем один счетчик time для всего графа, который будет считать время захода в вершину и время выхода из нее.</p>
  <p>Чтобы отмечат время, заведем vector&lt;int&gt; Time-in(n) для времени входа в каждую вершину и vector&lt;int&gt; Time_out(n) для времени выхода из каждой вершины.</p>
  <p>Пример обхода DFS слева направо. Слева от вершины - время входа, справа - время выхода.</p>
<pre>
                     (1) 1 (20)
                 /               \
                /                 \
      (2) 2 (11)                   (12) 7 (19)
       /    \                     /     |    \
      /      \                   /      |     \
(3) 3 (4) (5) 4 (10)   (13) 8 (14) (15) 9 (16) (17) 10 (18)
            /   \
           /     \
    (6) 5 (7)   (8) 6 (9)
</pre>

  <p>Вершина a является предком вершины b если время захода в вершину a меньше времени захода в вершину b, а время выхода из вершины a больше времени выхода из вершины b.</p>
  <code>Time_in[a] &lt; Time_in[b] && Time_out[a] > Time_out[b]</code>

  <p>Этот способ работает если в графе нет цикла, например, на дереве.</p>
  <p><strong>Задача.</strong> Является ли вершина a предком вершины b.</p>
<pre>
void dfs(vector&lt;vector&lt;int&gt; &gt;& G,
  vector&lt;int&gt;& Mark,
  vector&lt;int&gt;& Time_in, vector&lt;int&gt;& Time_out,
  int &time, int y, int x) {

  // при входе в вершину
  time++;
  Time_in[y] = time;
  Mark[y] = 1; // помечаем вершину в которую пришли

  for (int i = 0; i &lt; G[y].size(); i++) {
    if (Mark[G[y][i]] == 0) {
      // если еще не были в соседней вершине,
      // то выполняем dfs на соседней вершине
      dfs(G, Mark, Time_in, Time_out, time, G[y][i], y);
    }
  }

  // при выходе из вершины
  time++;
  Time_out[y] = time
}
</pre>
</article>


<!-- Задача A. Дерево -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Дерево</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 16мб</i></div>

  <p>Неориентированный граф без петель и кратных ребер задан матрицей смежности. Требуется определить, является ли этот граф деревом.</p>

  <h4>Входные данные</h4>
  <p>Сначала записано число N - количество вершин графа (от 1 до 100). Далее записана матрица смежности размером N x N, в которой 1 обозначает наличие ребра, 0 - его отсутствие. Матрица симметрична относительно главной диагонали.</p>

  <h4>Выходные данные</h4>
  <p>Выведите сообщение YES, если граф является деревом, и NO в противном случае.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
3
0 1 0
1 0 1
0 1 0
</pre>
    <code>YES</code>

    <h4>Пример 2</h4>
<pre>
4
0 1 1 1
1 0 0 0
1 0 0 1
1 0 1 0
</pre>
    <code>NO</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Граф является деревом тогда и только тогда, когда:</p>
    <ol>
      <li>Граф связный.</li>
      <li>Граф содержит n вершин и n – 1 ребро.</li>
      <li>Граф не содержит циклов.</li>
    </ol>
    <p>Достаточно проверить что выполняется 2 требования из 3, поскольку третье всегда вытекает из двух других.</p>

    <h4>Первый вариант решения</h4>

    <p>Проверим что граф имеет ровно 1 компоненту связности и число вершин на 1 больше чем число ребер (n = m + 1)</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

void dfs(vector&lt;vector&lt;int&gt; &gt;& G,
         vector&lt;int&gt;& Mark, int x) {

  Mark[x] = 1; // помечаем вершину в которую пришли

  for (int i = 0; i &lt; G[x].size(); i++) {
    if (Mark[G[x][i]] == 0) {
      dfs(G, Mark, G[x][i]);
    }
  }
}

int main() {
  // ускорение ввода-вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // ввод данных
  int n; // число вершин
  cin >> n;
  int in;
  vector&lt;vector&lt;int&gt; &gt; G(n + 1); // список смежности
  int cnt1 = 0; // число единиц в матрице смежности

  // переведем матрицу смежности в список смежности
  for (int i = 1; i &lt;= n; i++) {
    for (int j = 1; j &lt;= n; j++) {
      cin >> in;
      if (in == 1) {
        cnt1++;
        G[i].push_back(j);
      }
    }
  }

  // решение
  int m = cnt1 / 2; // число ребер
  int cnt_k = 0; // число компонент связности
  vector&lt;int&gt; Mark(n + 1); // посещенные вершины

  // пройдем по всем вершинам
  for (int i = 1; i &lt;= n; i++) {
    if (Mark[i] == 0) {
      cnt_k++;
      dfs(G, Mark, i);
    }
  }

  // вывод результата
  if (cnt_k == 1 && n == m + 1) {
    cout &lt;&lt; "YES\n";
  } else {
    cout &lt;&lt; "NO\n";
  }
}
</pre>

    <h4>Второй вариант решения</h4>

    <p>Проверим что граф имеет ровно 1 компоненту связности и не имеет циклов</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

void dfs(vector&lt;vector&lt;int&gt; &gt;& G,
         vector&lt;int&gt;& Mark,
         bool& flag, int y, int x) {

  Mark[y] = 1; // помечаем вершину в которую пришли

  for (int i = 0; i &lt; G[y].size() && flag == false; i++) {
    if (Mark[G[y][i]] == 0) {
      dfs(G, Mark, flag, G[y][i], y);
    } else if (G[y][i] != x) {
      flag = true;
    }
  }
}

int main() {
  // ускорение ввода-вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // ввод данных
  int n; // число вершин
  cin >> n;
  int in;
  vector&lt;vector&lt;int&gt; &gt; G(n + 1); // список смежности

  // переведем матрицу смежности в список смежности
  for (int i = 1; i &lt;= n; i++) {
    for (int j = 1; j &lt;= n; j++) {
      cin >> in;
      if (in == 1) {
        G[i].push_back(j);
      }
    }
  }

  // решение
  bool flag = false; // циклов не было
  int cnt_k = 0; // число компонент связности
  vector&lt;int&gt; Mark(n + 1); // посещенные вершины

  // пройдем по всем вершинам
  for (int i = 1; i &lt;= n; i++) {
    if (Mark[i] == 0) {
      cnt_k++;
      dfs(G, Mark, flag, i, -1);
    }
  }

  // вывод результата
  if (cnt_k == 1 && flag == false) {
    cout &lt;&lt; "YES\n";
  } else {
    cout &lt;&lt; "NO\n";
  }
}
</pre>
  </details>
</article>


<!-- Задача B. Компоненты связности -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Компоненты связности</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Дан неориентированный граф. Необходимо посчитать количество его компонент связности и вывести их.</p>

  <h4>Входные данные</h4>
  <p>Во входном файле записано 1 число - количество вершин в графе (1 ≤ n ≤ 10³). В следующих строчках записана матрица смежности данного графа.</p>

  <h4>Выходные данные</h4>
  <p>В первой строчке выходного файла выведите количество компонент связности. Далее выведите сами компоненты связности в следующем формате: в первой строке количество вершин в компоненте, во второй - сами вершины в произвольном порядке.</p>

  <details>
    <summary>Пример</summary>
<pre>
6
001000
000000
100000
000000
000001
000010
</pre>
<pre>
4
2
1 3
1
2
1
4
2
5 6
</pre>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

void dfs(vector&lt;vector&lt;int&gt; &gt;& G,
  vector&lt;int&gt;& Mark,
  vector&lt;int&gt;& Res,
  int x) {
  Mark[x] = 1;
  Res.push_back(x);
  for (int i = 0; i &lt; G[x].size(); i++) {
    if (Mark[G[x][i]] == 0) {
      dfs(G, Mark, Res, G[x][i]);
    }
  }
}

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // ввод данных
  int n; // число вершин
  cin >> n;
  vector&lt;vector&lt;int&gt; &gt; G(n); // список смежности

  // переведем матрицу смежности в список смежности
  for (int i = 0; i &lt; n; i++) {
    string s;
    cin >> s;
    for (int j = 0; j &lt; s.size(); j++) {
      if (s[j] == '1') {
        G[i].push_back(j);
      }
    }
  }

  // решение
  vector&lt;int&gt; Mark(n);
  vector&lt;int&gt; Mark_res(n);
  vector&lt;int&gt; Res;
  vector&lt;int&gt; Buf;
  int cnt = 0;
  for (int i = 0; i &lt; n; i++) {
    if (Mark[i] == 0) {
      dfs(G, Mark, Buf, i);
      cnt++;
    }
  }

  // вывод результата
  cout &lt;&lt; cnt &lt;&lt; '\n';
  for (int i = 0; i &lt; n; i++) {
    if (Mark_res[i] == 0) {
      dfs(G, Mark_res, Res, i);
      cout &lt;&lt; Res.size() &lt;&lt; "\n";
      for (int j = Res.size() - 1; j >= 0; j--) {
        cout &lt;&lt; Res[j] + 1 &lt;&lt; " ";
        Res.pop_back();
      }
      cout &lt;&lt; '\n';
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача C. Скачки -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Скачки</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 16мб</i></div>

  <p>Иван Иванович любит ходить на скачки, надеясь на них заработать кругленькую сумму. Ему приглянулась лошадь с номером K, и он решил проверить, сможет ли она выиграть у всех остальных лошадей. Иван Иванович раздобыл информацию, в которой для некоторых пар лошадей сообщается, какая из этих лошадей быстрее. Также он узнал, что у всех лошадей разные скорости.</p>

  <p>Требуется написать программу, которая поможет Ивану Ивановичу точно определить может ли выиграть выбранная им лошадь.</p>

  <h4>Входные данные</h4>
  <p>В первой строке даны два целых числа N(1 ≤ N ≤ 100) и K(1 ≤ K ≤ N), где N – количество лошадей, принимающих участие в скачках, K – номер лошади, на которую хочет сделать ставку Иван Иванович. Следующие строки содержат по два числа X и Y (1 ≤ X, Y ≤ N), обозначающие, что лошадь с номером X быстрее лошади с номером Y. Пары X и Y не повторяются. Набор данных завершается строкой, содержащей единственный нуль. Эту строку обрабатывать не надо.</p>

  <p>Гарантируется, что информация, раздобытая Иваном Ивановичем, корректна.</p>

  <h4>Выходные данные</h4>
  <p>Нужно вывести слово «Yes», если Иван Иванович уверен в своем выигрыше и «No» в противном случае.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
3 1
1 2
1 3
0
</pre>
    <code>Yes</code>

    <h4>Пример 2</h4>
<pre>
3 2
2 3
0
</pre>
    <code>No</code>

    <h4>Пример 3</h4>
<pre>
4 2
3 1
2 3
0
</pre>
    <code>No</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Нужно собрать <strong>ориентированный</strong> граф, где вершины это лошади, ребро соединяет двух лошадей, направление ребра это направление от быстрой к медленной лошади.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

void dfs(vector&lt;vector&lt;int&gt; &gt;& G,
  vector&lt;int&gt;& Mark, int x) {

  Mark[x] = 1;

  for (int i = 0; i &lt; G[x].size(); i++) {
    if (Mark[G[x][i]] == 0) {
      dfs(G, Mark, G[x][i]);
    }
  }
}

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // ввод данных
  int n; // число лошадей
  int k; // номер выбранной лошади
  cin >> n >> k;
  int a, b; // две вершины одного ребра
  vector&lt;vector&lt;int&gt; &gt; G(n + 1); // список смежности

  // переведем список ребер в список смежности
  cin >> a;
  while (a != 0) {
    cin >> b;
    G[a].push_back(b);
    cin >> a;
  }

  // решение
  vector&lt;int&gt; Mark(n + 1);
  bool flag = true; // выбранная лошадь победит

  dfs(G, Mark, k);

  // проверяем остались ли непосещенные лошади
  // которые могут обогнать нашу лошадь
  for (int i = 1; i &lt;= n; i++) {
    if (Mark[i] == 0) {
      flag = false;
    }
  }

  // вывод результата
  if (flag) {
    cout &lt;&lt; "Yes\n";
  } else {
    cout &lt;&lt; "No\n";
  }
}
</pre>
  </details>
</article>


<!-- Задача D. Цикл в графе -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Цикл в графе</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам дан произвольный неориентированный граф без петель и кратных ребёр с n вершинами и m ребрами. Ваша задача определить, есть ли в графе цикл.</p>

  <h4>Входные данные</h4>
  <p>В первой строке вводится 2 целых числа n m — число вершин и ребер соответственно (1 ≤ n ≤ 10⁵, 0 ≤ m ≤ 2⋅10⁵).</p>

  <p>В следующих m строках вводятся пары чисел uᵢ и vᵢ — номера вершин между которыми проведено ребро</p>

  <h4>Выходные данные</h4>
  <p>Выведите «YES», если в графе есть цикл, иначе выведите «NO». (без кавычек)</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
4 3
1 2
2 3
3 4
</pre>
    <code>NO</code>

    <h4>Пример 2</h4>
<pre>
4 4
1 2
2 3
3 4
2 4
</pre>
    <code>YES</code>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

void dfs(vector&lt;vector&lt;int&gt; &gt;& G,
  vector&lt;int&gt;& Mark, bool& flag, int y, int x) {

  Mark[y] = 1;

  for (int i = 0; i &lt; G[y].size() && flag == false; i++) {
    if (Mark[G[y][i]] == 0) {
      dfs(G, Mark, flag, G[y][i], y);
    } else if (G[y][i] != x) {
      flag = true;
    }
  }
}

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // ввод данных
  int n; // число вершин
  int m; // число ребер
  cin >> n >> m;
  int a, b; // две вершины одного ребра
  vector&lt;vector&lt;int&gt; &gt; G(n + 1); // список смежности

  // переведем список ребер в список смежности
  for (int i = 0; i &lt; m; i++) {
    cin >> a >> b;
    G[a].push_back(b);
    G[b].push_back(a);
  }

  // решение
  vector&lt;int&gt; Mark(n + 1);
  bool flag = false; // флаг, циклов нет

  for (int i = 1; i &lt;= n; i++) {
    for (int j = 0; j &lt; G[i].size(); j++) {
      if (Mark[i] == 0) {
        dfs(G, Mark, flag, G[i][j], i);
      }
    }
  }

  // вывод результата
  if (flag) {
    cout &lt;&lt; "YES\n";
  } else {
    cout &lt;&lt; "NO\n";
  }
}
</pre>
  </details>
</article>


<!-- Задача E. NP-трудная задача -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. NP-трудная задача</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Недавно Пари и Арий узнали про NP-трудные задачи, особенно им понравилась задача о минимальном вершинном покрытии.</p>

  <p>Пусть нам дан некоторый граф G. Подмножество A его вершин называется вершинным покрытием, если для любого ребра uv хотя бы один его конец лежит в множестве, то есть выполнено  или  (или оба условия).</p>

  <p>Пари и Арий выиграли на командной олимпиаде чудесный неориентированный граф, и теперь каждый хочет забрать себе множество его вершин, являющееся вершинным покрытием.</p>

  <p>Они отдали свой граф вам и попросили выбрать два непересекающихся множества вершин A и B, таких что и A и B являются вершинным покрытием, или определить, что сделать это невозможно. Каждая вершина может быть отдана только одному из друзей (а некоторые и вовсе можно не отдавать никому).</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных записаны два числа n и m (2 ≤ n ≤ 100000, 1 ≤ n, m ≤ 100000) — количество вершин и количество рёбер в выигранном друзьями графе.</p>

  <p>В каждой из следующих m строк записана пара чисел uᵢ и vᵢ (1 ≤ uᵢ, vᵢ ≤ n), означающая ненаправленное ребро между вершинами uᵢ и vᵢ. Гарантируется, что в графе отсутствуют петли и кратные рёбра.</p>

  <h4>Выходные данные</h4>
  <p>Если невозможно поделить граф между Пари и Арием, как они этого хотят, то выведите «-1» (без кавычек).</p>

  <p>Если же существуют два непересекающихся вершинных покрытия, то выведите их описания. Каждое описание состоит из двух строк. Первая строка должна содержать единственное число k — количество вершин в данном вершинном покрытии, а вторая строка должна содержать k чисел — индексы вершин в покрытии. Обратите внимание, что поскольку m ≥ 1, никакое вершинное покрытие не может быть пустым.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
4 2
1 2
2 3
</pre>
<pre>
1
2
2
1 3
</pre>

    <h4>Пример 2</h4>
<pre>
3 3
1 2
2 3
1 3
</pre>
<pre>
-1
</pre>
    <p>В первом примере можно отдать Арию вершину номер 2, а Пари вершины с номерами 1 и 3. Вершину 4 можно оставить себе (а можно тоже кому-нибудь отдать).</p>

    <p>Во втором примере не существует способа раздать вершины так, чтобы удовлетворить и Пари, и Ария.</p>
  </details>
</article>


<!-- Задача F. Посчитай треугольники -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Посчитай треугольники</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Неориентированный граф на n вершинах (1 ≤ n ≤ 1000) задан своей матрицей смежности. Вам необходимо найти количество циклов длины 3.</p>

  <h4>Входные данные</h4>
  <p>В первой строке вводится число n — количество вершин в графе. Далее в n строках вводится матрица смежности графа.</p>

  <h4>Выходные данные</h4>
  <p>Выведите количество циклов длины 3.</p>

  <details>
    <summary>Пример</summary>
<pre>
3
0 1 1
1 0 1
1 1 0
</pre>
    <code>1</code>
  </details>
</article>


<!-- Задача G. Предок -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Предок</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 128мб</i></div>
  <div>Ввод: ancestor.in</div>
  <div>Вывод: ancestor.out</div>

  <p>Напишите программу, которая для двух вершин дерева определяет, является ли одна из них предком другой.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входного файла содержит число n (1 ≤ n ≤ 10⁵) – количество вершин в дереве.</p>

  <p>Во второй строке содержатся n чисел, i-е число из которых определяет номер непосредственного родителя вершины с номером i. Если это число равно нулю, то вершина является корнем дерева.</p>

  <p>В третьей строке находится число m (1 ≤ m ≤ 10⁵) – количество запросов. Каждая из следующих m строк содержит два различных числа a и b.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого из m запросов выведите в отдельной строке число 1, если вершина a является предком вершины b, и 0 в противном случае.</p>

  <details>
    <summary>Пример</summary>
<pre>
6
0 1 1 2 2 3
5
4 1
1 4
3 6
2 6
6 5
</pre>
<pre>
0
1
1
0
0
</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Будем подсчитывать время входа в вершину timein и время выхода из вершины timeout. Если</p>
    <code>timein[a] &lt;= timein[b] && timeout[b] &lt;= timeout[a]</code>
    <p>то вершина a является предком вершины b.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

void dfs(vector&lt;vector&lt;int&gt; &gt;& G,
  vector&lt;int&gt;& Time_in,
  vector&lt;int&gt;& Time_out,
  int& time,
  int pos) {
  time++;
  Time_in[pos] = time;
  for (int i = 0; i &lt; G[pos].size(); i++) {
    dfs(G, Time_in, Time_out, time, G[pos][i]);
  }
  time++;
  Time_out[pos] = time;
}

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // работа с файлами
  freopen("ancestor.in", "rt", stdin);
  freopen("ancestor.out", "wt", stdout);

  // ввод данных
  int n, start, tmp;
  cin >> n;
  vector&lt;vector&lt;int&gt; &gt; G(n + 1);
  for (int i = 1; i &lt;= n; i++) {
    cin >> tmp;
    if (tmp == 0) {
      start = i;
    } else {
    G[tmp].push_back(i);
    }
  }

  vector&lt;int&gt; Time_in(n + 1), Time_out(n + 1);
  int time = 0;
  dfs(G, Time_in, Time_out, time, start);
  int m;
  cin >> m;
  int a, b;
  while (m--) {
    cin >> a >> b;
    if (Time_in[a] &lt; Time_in[b] && Time_out[b] &lt; Time_out[a]) {
      cout &lt;&lt; 1 &lt;&lt; '\n';
    } else {
      cout &lt;&lt; 0 &lt;&lt; '\n';
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача H. Товарищ майор -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Товарищ майор</h3>

  <div><i>Ограничение по времени 0.3с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Товарищ майор занимается раскрытием преступлений, совершенных преступными сообществами. Для этого он внимательно изучает материалы дел, в которых находит следы связей между преступниками. Если от одного преступника до другого можно дойти следуя этим связям, то все кто участвует в такой цепочке, составляют одно преступное сообщество.</p>

  <p>Учтите, что один преступник не может сам по себе составлять преступное сообщество.</p>

  <p>За каждое раскрытое преступное сообщество Товарищ майор получает звездочку на погоны. Сколько звездочек он получит после изучения всех материалов?</p>

  <h4>Входные данные</h4>
  <p>В первой строке через пробел задаются числа 1 &lt; N ≤ 100 — количество преступников, на которых есть какие-то данные и 1 ≤ M ≤ N² — количество связей в изучаемых материалах.</p>

  <p>Далее следуют M строк, в каждой из которых записана пара чисел (xᵢ,yᵢ), 0 ≤ xᵢ, yᵢ &lt; N, которые задают что в материалах задокументирована связь между преступником xᵢ и yᵢ.</p>

  <h4>Выходные данные</h4>
  <p>Единственное целое число, равное количеству звездочек, которые получит Товарищ майор.</p>

  <details>
    <summary>Пример</summary>
<pre>
10 4
1 2
1 3
0 2
0 1
</pre>
    <code>1</code>
  </details>
</article>


<!-- Задача I. Вечеринка (лёгкая версия) -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача I. Вечеринка (лёгкая версия)</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В честь проведения второго турнира ABBYY Cup Умный Бобер решил устроить вечеринку. У Бобра много знакомых, и некоторые из них дружат друг с другом, а некоторые друг другу не нравятся. Чтобы вечеринка удалась на славу, Умный Бобер хочет пригласить только тех своих знакомых, которые дружат, и не приглашать тех, кто не нравится друг другу. Отношения дружбы и антипатии симметричны.</p>

  <p>Более формально, для каждого приглашенного человека должны выполняться следующие условия:</p>
  <ul>
    <li>все его друзья должны быть также приглашены на вечеринку;</li>
    <li>среди приглашенных не должно быть людей, которые ему не нравятся;</li>
    <li>все приглашенные на вечеринку должны быть связаны с ним дружбой напрямую или через цепь общих друзей произвольной длины. Будем говорить, что люди a<sub>1</sub> и a<sub>p</sub> связаны цепью общих друзей, если существует последовательность людей a<sub>2</sub>, a<sub>3</sub>, ... , a<sub>p-1</sub> такая, что все пары людей a<sub>i</sub> и a<sub>i+1</sub> (1 ≤ i &lt; p) — друзья.</li>
  </ul>

  <p>Помогите Бобру определить максимальное количество знакомых, которых он сможет пригласить.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных записано целое число n
   — количество знакомых Бобра.</p>

  <p>Во второй строке записано целое число k (0 ≤ k ≤ min(10⁵, n⋅(n-1)/2)) — количество пар друзей. В следующих k строках через пробел записаны пары чисел uᵢ, vᵢ (1 ≤ uᵢ, vᵢ ≤ n, uᵢ ≠ vᵢ) — номера людей, которые входят в i-ую пару друзей.</p>

  <p>В следующей строке записано число m (0 ≤ m ≤ min(10⁵, n⋅(n-1)/2)) — количество пар людей, которые друг другу не нравятся. В следующих m строках перечислены пары таких людей в том же формате, что и пары друзей.</p>

  <p>Каждая пара людей упоминается во входных данных не более одного раза (0≤k+m≤n⋅(n-1)2). В частности, два человека не могут быть друзьями и одновременно не нравиться друг другу.</p>

  <p>Ограничения на входные данные: 2 ≤ n ≤ 14</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное число — максимальное количество людей, которых Бобер сможет пригласить на вечеринку. Если группу людей, удовлетворяющую всем требованиям, выбрать невозможно, выведите 0.</p>

  <details>
    <summary>Пример</summary>
<pre>
9
8
1 2
1 3
2 3
4 5
6 7
7 8
8 9
9 6
2
1 6
7 9
</pre>
    <code>3</code>
    <p>Под условия задачи подходят две группы людей: 1,2,3 и 4,5, при этом ответом будет размер наибольшей из этих групп. Группа 6,7,8,9 не подходит, так как в ней есть люди 7 и 9, которые не нравятся друг другу. Группа 1,2,3,4,5 также не подходит, так как не все ее члены связаны цепью общих друзей (например, люди 2 и 5 не связаны).</p>
  </details>
</article>


<!-- Задача J. Ктулху -->
<article class="article">
  <div class="anchor" id="task10"></div>
  <h3>Задача J. Ктулху</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>...И пошел старик к синему морю; видит, на море черная буря. Стал он кликать золотую рыбку, но, увы, появился лишь Ктулху...</p>

  <p>А на другом конце земного шара Пентагон уже вовсю собирает данные, прогнозирует поведение монстра и готовит сверхсекретное супероружие. Из-за высокой сейсмической активности и плохих погодных условий до сих пор не удалось сделать качественные фотоснимки со спутников. Результатом первичного анализа объекта оказался неориентированный граф c n вершинами и m ребрами. Теперь лучшим умам мира предстоит определить, можно ли считать этот граф Ктулху или нет.</p>

  <p>Для простоты предположим, что Ктулху из космоса выглядит как некоторое сферическое тело, к которому прикреплены отростки-щупальца. Формально, Ктулху назовем такой неориентированный граф, который может быть представлен как набор из трех или более корневых деревьев, корни которых соединены простым циклом.</p>

  <p>Гарантируется, что граф не содержит кратных ребер и петель.</p>

  <h4>Входные данные</h4>
  <p>В первой строке даны два целых числа — количество вершин n и количество ребер m графа (1 ≤ n ≤ 100, 0 ≤ m ≤ n*(n-1)/2).</p>

  <p>В каждой из последующих m строк записаны пары целых чисел x и y, которые обозначают существование ребра между вершинами x и y в графе (1 ≤ x, y ≤ n, x ≠ y). Гарантируется, что граф не содержит кратных ребер и петель.</p>

  <h4>Выходные данные</h4>
  <p>Выведите «NO», если граф не является Ктулху, и «FHTAGN!» в противном случае.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
6 6
6 3
6 4
5 1
2 5
1 4
5 4
</pre>
    <code>FHTAGN!</code>

    <h4>Пример 2</h4>
<pre>
6 5
5 6
4 6
3 1
5 1
1 2
</pre>
    <code>NO</code>
    <p>Простым циклом назовем множество из v вершин, которые можно пронумеровать так, что будут существовать ребра только между вершинами с номерами 1 и 2, 2 и 3, ..., v-1 и v, v и 1.</p>

    <p>Дерево — связный неориентированный граф из n вершин и n-1 ребер (n > 0).</p>

    <p>Корневое дерево — дерево, в котором выделена одна вершина, корень.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Мы должны найти как минимум три корневых дерева, вершины которого соединены в одном простом цикле. Мы должны проверить следующие два условия. 1. Граф должен быть связанным, то есть из любой вершины можно попасть в любую вершину. 2. В графе должен быть цикл с тремя или более элементами.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;

using namespace std;

void dfs(vector&lt;vector&lt;int&gt; &gt;& G,
  vector&lt;int&gt;& Mark,
  bool& flag,
  int pos,
  int last_pos) {
  Mark[pos] = 1;
  for (int i = 0; i &lt; G[pos].size() && flag == false; i++) {
    if (Mark[G[pos][i]] == 0) {
      dfs(G, Mark, flag, G[pos][i], pos);
    } else {
      if (G[pos][i] != last_pos) {
        flag = true;
      }
    }
  }
}

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  int n, m;
  cin >> n >> m;
  vector&lt;vector&lt;int&gt; &gt; G(n + 1);
  int x, y;
  for (int i = 0; i &lt; m; i++) {
    cin >> x >> y;
    G[x].push_back(y);
    G[y].push_back(x);
  }

  // решение
  vector&lt;int&gt; Mark(n + 1);
  vector&lt;int&gt; Mark_queue(n + 1);
  bool flag = false;
  dfs(G, Mark, flag, 1, 0);
  queue&lt;int&gt; q;
  q.push(1);
  Mark_queue[1] = 1;
  while (q.size() > 0) {
    int tmp = q.front();
    q.pop();
    for (int i = 0; i &lt; G[tmp].size(); i++) {
      if (Mark_queue[G[tmp][i]] == 0) {
        Mark_queue[G[tmp][i]] = 1;
        q.push(G[tmp][i]);
      }
    }
  }

  int count = 0;
  for (int i = 1; i &lt;= n; i++) {
    count += Mark_queue[i];
  }

  // вывод результата
  if (flag == true && count == n && n == m) {
    cout &lt;&lt; "FHTANG!";
  } else {
    cout &lt;&lt; "NO";
  }
}
</pre>
  </details>
</article>


<!-- Задача K. Распространение новостей -->
<article class="article">
  <div class="anchor" id="task11"></div>
  <h3>Задача K. Распространение новостей</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В некоторой социальной сети зарегистрированы n пользователей. Они общаются между собой в m группах. Давайте рассмотрим процесс распространения новостей между пользователями.</p>

  <p>Изначально какой-нибудь пользователь x узнает новость из какого-то внешнего источника. Затем этот пользователь отправляет новость всем своим друзьям (два пользователя считаются друзьями, если они оба принадлежат к какой-нибудь группе). Друзья продолжают отправлять новость своим друзьям, и так далее. Процесс заканчивается, когда не останется ни одной пары друзей, в которой один пользователь знает новость, а другой — нет.</p>

  <p>Для каждого пользователя x определите, сколько пользователей в конечном итоге узнает новость, если x начнет ее распространять.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записаны два целых числа n и m (1 ≤ n, m ≤ 5⋅10⁵) — the количество пользователей и групп, соответственно.</p>

  <p>Затем следуют m строк, каждая из которых описывает группу. i-я строка начинается целым числом kᵢ (0 ≤ kᵢ ≤ n) — количество пользователей в i-й группе. Затем следуют kᵢ различных чисел, обозначающих пользователей, принадлежащих к i-й группе.</p>

  <p>Гарантируется, что ∑(i=1 до m)ki ≤ 5⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Выведите n целых чисел. i-е из них должно быть равно количеству пользователей, которые узнают новость, если пользователь i начнет ее распространять.</p>

  <details>
    <summary>Пример</summary>
<pre>
7 5
3 2 5 4
0
2 1 2
1 1
2 6 7
</pre>
    <code>4 4 1 4 4 2 2</code>
  </details>
</article>


<!-- Задача L. Водоснабжение -->
<article class="article">
  <div class="anchor" id="task12"></div>
  <h3>Задача L. Водоснабжение</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Корпуса общежития German University in Cairo (GUC) пронумерованы числами от 1 до n. Для обеспечения водоснабжения под землей корпуса соединены трубами. Все трубы — направленные, то есть вода может течь только в определенном направлении, и не может течь в обратном. Также для каждой трубы известен ее диаметр, он обозначает объем воды, который может выдержать эта труба. Для каждого корпуса имеется не более, чем одна входящая в него труба, и не более, чем одна исходящая из него труба.</p>

  <p>С началом нового семестра, студент Лулу, проживающий в общежитии, хочет установить баки с запасами воды и краны для экстренного слива воды. Бак нужно установить в каждый корпус, который имеет выходящую из него трубу и не имеет входящей. Кран нужно установить во всех корпусах, где есть входящая труба, но нет выходящей. Таким образом получится, что вода из любого корпуса с баком сможет дойти до корпуса с краном.</p>

  <p>Чтобы трубы не лопнули на вторую неделю, как это произошло в прошлом семестре, Лулу должен принять во внимание диаметр труб. Объем воды, которая протекает от корпуса с баком до корпуса с краном, не должен превосходить того, что могут выдержать трубы. Однако, выбрав пару корпусов, где будут установлены бак и кран, Лулу хочет, чтобы объем воды, протекающей между этими двумя корпусами, был максимально возможным.</p>

  <h4>Входные данные</h4>
  <p>В первой строке через пробел записано два целых числа n и p (1 ≤ n ≤ 1000, 0 ≤ p ≤ n) — количество корпусов и количество труб.</p>

  <p>Затем следуют p строк — описание p труб, i-ая строка содержит три целых числа aᵢ bᵢ dᵢ. Она задает трубу диаметра dᵢ выходящую из корпуса aᵢ и ведущую в корпус bᵢ (1 ≤ aᵢ, bᵢ ≤ n, aᵢ ≠ bᵢ, 1 ≤ dᵢ ≤ 10⁶).</p>

  <p>Гарантируется, что для каждого корпуса имеется не более одной входящей трубы, и не более одной исходящей трубы.</p>

  <h4>Выходные данные</h4>
  <p>На первой строке выведите t — количество пар корпусов, где нужно установить бак и слив.</p>

  <p>На следующих t строках выведите по три числа: tankᵢ, tapᵢ, и diameterᵢ, где tankᵢ ≠ tapᵢ (1 ≤ i ≤ t). Здесь tankᵢ и tapᵢ — номера корпусов, где будут установлены бак и слив, соответственно, а diameterᵢ — максимально возможный объем воды, который можно пропустить. Все эти t строк должны быть упорядочены в порядке возрастания tankᵢ.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
3 2
1 2 10
2 3 20
</pre>
<pre>
1
1 3 10
</pre>

    <h4>Пример 2</h4>
<pre>
3 3
1 2 20
2 3 10
3 1 5
</pre>
<pre>
0
</pre>

    <h4>Пример 3</h4>
<pre>
4 2
1 2 60
3 4 50
</pre>
<pre>
2
1 2 60
3 4 50
</pre>
  </details>
</article>


<!-- Задача M. Укрепление мостов -->
<article class="article">
  <div class="anchor" id="task13"></div>
  <h3>Задача M. Укрепление мостов</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Байтландия готовится к военным учениям. Это очень важное мероприятие, даже министр обороны Байтландии контролирует организацию учений на месте. Министр обороны обеспокоен тем, как же пройдут учения танков.</p>

  <p>Байтландия состоит из островов, некоторые из которых соединены мостами. Каждый мост соединяет два различных острова, любые два острова соединены напрямую не более чем одним мостом. Байтландцы очень экономный народ, поэтому на каждый остров ведут не более двух мостов.</p>

  <p>План мероприятия еще не готов, но известно, что план учений танков будет таким: танки должны будут проехать с одного острова на другой, пользуясь некоторыми мостами, причем не важно, какими именно мостами будут пользоваться танки. В Байтландии много мостов, которые были построены много лет назад и для танков совершенно не предназначены. Поэтому министр обороны решил укрепить некоторые мосты. А конкретно, он хочет укрепить несколько мостов так, чтобы вне зависимости от плана учений, выполнялось условие: если была возможность переехать с острова u на остров v, то после укрепления некоторых мостов можно переехать с острова u на остров v по укрепленным мостам. При этом укрепление моста — дорогая операция, поэтому министр хочет укрепить минимальное число мостов.</p>

  <p>Министр обороны Байтландии хочет знать, сколько существует различных способов укрепления минимального числа мостов. Два способа считаются различными, если существует мост, который укреплен в одном из способов и не укреплен в другом. Помогите министру обороны найти ответ на волнующий его долгое время вопрос. Поскольку ответ может быть довольно большим, выведите его по модулю 10⁹+7.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входного файла заданы два целых числа n и m (1 ≤ n ≤ 10⁵, 0 ≤ m ≤ 10⁵) — количество островов и количество мостов в Байтландии соответственно. В следующих m строках заданы мосты, по одному в строке. Каждый мост задан двумя целыми числами: vᵢ и uᵢ (1 ≤ vᵢ, uᵢ ≤ n, vᵢ ≠ uᵢ) — номера островов, которые соединяет мост с номером i.</p>

  <p>Гарантируется, что каждый мост задан во входном файле не более одного раза.</p>

  <p>Гарантируется, что из каждого острова выходят не более чем два моста.</p>

  <h4>Выходные данные</h4>
  <p>В выходной файл выведите единственное число: остаток от деления количества способов укрепления мостов на число 10⁹+7.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
5 4
1 2
2 3
1 3
4 5
</pre>
    <code>3</code>

    <h4>Пример 2</h4>
<pre>
2 1
1 2
</pre>
    <code>1</code>
    <p>В первом примере существует три способа укрепления мостов: укрепить мосты с номерами {1,2,4}, либо {1,3,4}, либо {2,3,4}.</p>
  </details>
</article>


<!-- Задача N. Вечеринка (сложная версия) -->
<article class="article">
  <div class="anchor" id="task14"></div>
  <h3>Задача N. Вечеринка (сложная версия)</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В честь проведения второго турнира ABBYY Cup Умный Бобер решил устроить вечеринку. У Бобра много знакомых, и некоторые из них дружат друг с другом, а некоторые друг другу не нравятся. Чтобы вечеринка удалась на славу, Умный Бобер хочет пригласить только тех своих знакомых, которые дружат, и не приглашать тех, кто не нравится друг другу. Отношения дружбы и антипатии симметричны.</p>

  <p>Более формально, для каждого приглашенного человека должны выполняться следующие условия:</p>
  <ul>
    <li>все его друзья должны быть также приглашены на вечеринку;</li>
    <li>среди приглашенных не должно быть людей, которые ему не нравятся;</li>
    <li>все приглашенные на вечеринку должны быть связаны с ним дружбой напрямую или через цепь общих друзей произвольной длины. Будем говорить, что люди a<sub>1</sub> и a<sub>p</sub> связаны цепью общих друзей, если существует последовательность людей a<sub>2</sub>, a<sub>3</sub>, ... , a<sub>p-1</sub> такая, что все пары людей a<sub>i</sub> и a<sub>i+1</sub> (1 ≤ i &lt; p) — друзья.</li>
  </ul>

  <p>Помогите Бобру определить максимальное количество знакомых, которых он сможет пригласить.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных записано целое число n — количество знакомых Бобра.</p>

  <p>Во второй строке записано целое число k (0 ≤ k ≤ min(10⁵, n⋅(n-1)/2)) — количество пар друзей. В следующих k строках через пробел записаны пары чисел uᵢ, vᵢ (1 ≤ uᵢ, vᵢ ≤ n, uᵢ ≠ vᵢ) — номера людей, которые входят в i-ую пару друзей.</p>

  <p>В следующей строке записано число m (0 ≤ m ≤ min(10⁵, n⋅(n-1)/2)) — количество пар людей, которые друг другу не нравятся. В следующих m строках перечислены пары таких людей в том же формате, что и пары друзей.</p>

  <p>Каждая пара людей упоминается во входных данных не более одного раза (0≤k+m≤n⋅(n-1)/2). В частности, два человека не могут быть друзьями и одновременно не нравиться друг другу.</p>

  <p>Ограничения на входные данные: 2≤n≤2000</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное число — максимальное количество людей, которых Бобер сможет пригласить на вечеринку. Если группу людей, удовлетворяющую всем требованиям, выбрать невозможно, выведите 0.</p>

  <details>
    <summary>Пример</summary>
<pre>
9
8
1 2
1 3
2 3
4 5
6 7
7 8
8 9
9 6
2
1 6
7 9
</pre>
    <code>3</code>
    <p>Под условия задачи подходят две группы людей: 1,2,3 и 4,5, при этом ответом будет размер наибольшей из этих групп. Группа 6,7,8,9 не подходит, так как в ней есть люди 7 и 9, которые не нравятся друг другу. Группа 1,2,3,4,5 также не подходит, так как не все ее члены связаны цепью общих друзей (например, люди 2 и 5 не связаны).</p>
  </details>
</article>


<!-- Задача O. Племя тив -->
<article class="article">
  <div class="anchor" id="task15"></div>
  <h3>Задача O. Племя тив</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Каждый год профессор Иванов ездит в Африку с целью изучить племена, которые там проживают. В этом году он ездил в гости к племени тив. Профессор довольно быстро научился понимать их язык, выучил многие их обряды, однако, он никак не мог понять записанные цифрами тив числа. Как и мы, члены племени используют позиционную систему счисления с основанием 10. Но цифры в племени тив обозначают символами, не похожими на обычные цифры от 0 до 9.</p>

  <p>Профессор обозначил эти символы буквами от 'a' до 'j', но не может понять, какой цифре соответствует какой символ. Тогда вождь племени дал ему список из n неотрицательных чисел, записанных без ведущих нулей, и сказал, что числа в нем отсортированы строго по возрастанию.</p>

  <p>Помогите профессору восстановить по этому списку какое-нибудь соответствие символов цифрам.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входного файла дано одно натуральное числа n (2 ≤ n ≤ 10) — количество слов в списке. Следующие n строк содержат выданные вождем числа племени тив, по одному числу в строке. Длина каждого числа не превышает 9.</p>

  <h4>Выходные данные</h4>
  <p>В первой строке файла выведите «Yes», если ответ существует, в этом случае в следующей строке выведите цифры, которые соответствуют символам, обозначенным 'a'..'j', в этом порядке. Если существует несколько ответов, то выведете любой из них.</p>

  <p>Если профессор понял что-то неправильно, и ответа не существует, выведете «No».</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
4
a
da
dd
cc
</pre>
<pre>
Yes
1 0 3 2 4 5 6 7 8 9
</pre>

    <h4>Пример 2</h4>
<pre>
4
a
j
jb
ac
</pre>
<pre>
No
</pre>
  </details>
</article>

