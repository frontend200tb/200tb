<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contests" target="_blank">Codeforces ЯрГУ. Школьники</a></p>
  <p><a href="https://vk.com/sportprog_yarsu" target="_blank">vk.com/sportprog_yarsu</a></p>
  <p><a href="https://vkvideo.ru/@sportprog_yarsu" target="_blank">vkvideo.ru/@sportprog_yarsu</a></p>
</article>


<article class="article">
  <h1>Занятие 16 Динамическое программирование #1. Основы</h1>
  <p>Конспект видео от 2025.01.11</p>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contest/580161" target="_blank">Codeforces Контест 580161</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
        <a href="#p1">Динамическое программирование #1. Основы</a>
    <br><a href="#p2">Задача 1. Кузнечик</a>
    <br><a href="#p3">Задача 2. Супер Кузнечик</a>
    <br><a href="#p4">Задача 3. Мутант Кузнечик</a>
    <br><a href="#p5">Задача 4. Белка</a>
  </p>
  <p>
        <a href="#task1">Задача A. Максимальная подпоследовательность</a>
    <br><a href="#task2">Задача B. Минимальный путь в таблице</a>
    <br><a href="#task3">Задача C. Конструктор</a>
    <br><a href="#task4">Задача D. Прогулки под дождем</a>
    <br><a href="#task5">Задача E. Компьютерная игра</a>
    <br><a href="#task6">Задача F. Дорога домой</a>
    <br><a href="#task7">Задача G. Разрежь ленточку</a>
    <br><a href="#task8">Задача H. Двоичная последовательность</a>
    <br><a href="#task9">Задача I. Пицца</a>
    <br><a href="#task10">Задача J. Без двух нулей подряд</a>
    <br><a href="#task11">Задача K. Только вправо или вниз</a>
    <br><a href="#task12">Задача L. Умный дартс</a>
    <br><a href="#task13">Задача M. Суммы</a>
    <br><a href="#task14">Задача N. Гангстеры</a>
    <br><a href="#task15">Задача O. КузнечиК</a>
  </p>
</article>


<!-- Динамическое программирование #1. Основы -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Динамическое программирование #1. Основы</h3>

  <p>Динамическое программирование - это система решения заданий, которая предполагает, что большая проблема будет разбита на более мелкие задачи, которые более понятные в решении (способ решения сложных задач путём разбиения их на более простые подзадачи).</p>
  <p>От маленького к большому. От частного к общему.</p>

  <p>Основные типы задач, которые считаются ДП:</p>
  <ul>
    <li>Посчитать количество</li>
    <li>Посчитать лучший вариант</li>
    <li>Сохранить способ получения ответа (хранение пути)</li>
  </ul>

  <p>Сравнение рекурсии с динамическим программированием</p>
  <ul>
    <li>Рекурсия #### -> ## + ## -> # + # + # + #</li>
    <li>Дин. прог. # + # + # + # -> ## + ## -> ####</li>
  </ul>

  <p>5 главных вопросов для любого алгоритма динамическим
программированием:</p>
  <ol>
    <li>Что храним?</li>
    <li>Как считаем ячейку?</li>
    <li>Что является простейшим случаем? (база)</li>
    <li>Как обходить объект ДП?</li>
    <li>Где хранится ответ на задачу?</li>
  </ol>

  <p>Примеры ответов на 5 главных вопросов ДП для нахождения чисел Фибоначчи</p>
  <ol>
    <li>vector&lt;int&gt; A(n+1)</li>
    <li>A[i] = A[i-1] + A[i-2]</li>
    <li>A[1] = 1, A[2] = 1</li>
    <li>for (int i = 3; i &lt= n; i++) {} (слева направо)</li>
    <li>A[n] (ответ хранится в последней ячейке массива)</li>
  </ol>
</article>


<!-- Задача 1. Кузнечик -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>Задача 1. Кузнечик</h3>

  <p>Кузнечик находится на кочке 0, ему необходимо добраться до кочки n. Кузнечик умеет прыгать на соседнюю кочку или через одну кочку вперед. Сколькими способами кузнечик может добраться до кочки n?</p>

  <p>Последовательно ответим на 5 вопросов ДП:</p>
  <ol>
    <li>Что храним?
      <p>Создадим одномерный массив DP, в котором в ячейке DP[i] будем хранить количество способов добраться до i кочки.</p></li>
    <li>Как считаем ячейку?
      <p>Кузнечик может сделать шаг +1 и шаг +2 из ячейки i. Придумаем правило перехода в i ячейку за один прыжок.</p>
      <code>DP[i] = DP[i - 1] + DP[i - 2].</code>
    </li>
    <li>Что является простейшим случаем? (база)
      <p>В нашем правиле для подсчета i элемента необходимо ссылаться на i - 1 и i - 2. По нашему правилу мы можем собрать все элементы начиная со 2 элемента. 0 и 1 элемент необходимо вбить руками:</p>
      <code>DP[0] = 1, DP[1] = 1.</code>
    </li>
    <li>Как обходить объект ДП?
      <p>Мы можем начинать наши расчеты со 2 элемента и до n. Потребуется цикл for(i=2,...,n).</p>
    </li>
    <li>Где хранится ответ на задачу?
      <p>Ответ хранится в последней ячейке DP[n].</p>
    </li>
  </ol>

  <details>
    <summary>Решение</summary>
<pre>
int n;
cin >> n;
vector&lt;int&gt; DP(n + 1);
DP[0] = 1;
DP[1] = 1;

for (int i = 2; i &lt;= n; i++) {
  DP[i] = DP[i - 1] + DP[i - 2];
}

cout &lt;&lt; DP[n];
</pre>
  </details>
</article>


<!-- Задача 2. Супер Кузнечик -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>Задача 2. Супер Кузнечик</h3>

  <p>Модифицируем условие задачи про кузнечика. Пусть у нас супер кузнечик.</p>
  <p>Кузнечик находится на кочке 0, ему необходимо добраться до кочки n. Кузнечик умеет прыгать на соседнюю кочку, через одну кочку или через две кочки вперед. Сколькими способами кузнечик может добраться до кочки n? </p>
  <p>На сколько сильно изменятся ответы на вопросы?</p>
  <ol>
    <li>Что храним?</li>
    <li>Как считаем ячейку?</li>
    <li>Что является простейшим случаем? (база)</li>
    <li>Как обходить объект ДП?</li>
    <li>Где хранится ответ на задачу?</li>
  </ol>

  <details>
    <summary>Решение</summary>
<pre>
int n;
cin >> n;
vector&lt;int&gt; DP(n + 1);
DP[0] = 1;
DP[1] = 1;
DP[2] = 2;

for (int i = 3; i &lt;= n; i++) {
  DP[i] = DP[i - 1] + DP[i - 2] + DP[i - 3];
}

cout &lt;&lt; DP[n];
</pre>
  </details>
</article>


<!-- Задача 3. Мутант Кузнечик -->
<article class="article">
  <div class="anchor" id="p4"></div>
  <h3>Задача 3. Мутант Кузнечик</h3>

  <p>Усложним условие задачи. Пусть у нас мутант кузнечик и он может прыгать на +1, +2, +3, ... , +k.</p>
  <p>На сколько сильно изменятся ответы на вопросы?</p>
  <ol>
    <li>Что храним?</li>
    <li>Как считаем ячейку?</li>
    <li>Что является простейшим случаем? (база)</li>
    <li>Как обходить объект ДП?</li>
    <li>Где хранится ответ на задачу?</li>
  </ol>
  <p>Изменится правило подсчета для ячейки. Нужен будет цикл от 0 до k чтобы подсчитать все случаи.</p>
  <p>Изменится определение простейших случаев. Нам придется использовать цикл for чтобы описать все простейшие случаи от 0 до k.</p>
  <p>Изменится правило обхода объекта ДП. Начинать обход будем с позиции k.</p>

  <details>
    <summary>Решение</summary>
<pre>
int n;
cin >> n;
vector&lt;int&gt; DP(n + 1);
DP[0] = 1;

for (int i = 1; i &lt;= n; i++) {
  for (int j = 1; j &lt;= k; j++) {
    if (i - j >= 1) {
      DP[i] += DP[i - j];
    }
  }
}

cout &lt;&lt; DP[n];
</pre>
  </details>

  <p>Чтобы не обходить k элементов внутренним циклом, заметим, что при сдвига окна из k элеметов на 1 вправо, в окно добавляется один элемент и из окна удаляется один элемент.</p>

  <details>
    <summary>Решение</summary>
<pre>
int n;
cin >> n;
vector&lt;int&gt; DP(n + 1);
DP[0] = 1;
long long sum = 0;

for (int i = 2; i &lt;= n; i++) {
  sum += A[i-1];
  if (i - k - 1 >= 1) {
    sum -= A[i - k - 1];
  }
  A[i] = sumж
}

cout &lt;&lt; DP[n];
</pre>

</article>


<!-- Задача 4. Белка -->
<article class="article">
  <div class="anchor" id="p5"></div>
  <h3>Задача 4. Белка</h3>

  <p>Пусть у нас есть поле A размером n x m. В каждой ячейке лежат орехи a<sub>ij</sub>. Белка находися в верхнем левом углу и умеет двигаться только вправо и вниз. Белка хочет попасть в нижний правый угол. Необходимо определить максимальное количество собранных орехов белкой. Помогите белке.</p>
  <p>Это задача из ЕГЭ по информатике и у нее есть куча продолжений, про робота, который бегает в лабиринте, про самолет, который должен двигаться по полю и тд.</p>

  <p>Последовательно ответим на 5 вопросов ДП:</p>
  <ol>
    <li>Что храним?
      <p>Создадим матрицу DP, в ячейке DP[i][j] будем хранить
максимальное количество орехов, которое может собрать белка если остановится в ячейке [i][j].</p>
    </li>
    <li>Как считаем ячейку?
      <p>Белка может двигаться вправо и вниз, тогда в ячейку [i][j] можно попасть только слева и сверху исходя из этого придумаем правило.</p>
      <code>DP[i][j] = max(DP[i - 1][j], DP[i][j - 1]) + A[i][j].</code>
    </li>
    <li>Что является простейшим случаем? (база)
      <p>В нашем правиле для подсчета i элемента необходимо ссылаться на соседа сверху и соседа слева. Нам потребуется в качестве базы указать все элементы первой строки и первого столбца. Потому что для первой строки нет соседей сверху, а для первого столбца нет соседей слева.</p>
    </li>
    <li>Как обходить объект ДП?
      <p>Мы можем начинать наши расчеты со 2 столбца 2 строки. Потребуется конструкция цикл в цикле. Отметим, что движение по матрице может быть разнообразным, от построчного до зигзагообразного.</p>
    </li>
    <li>Где хранится ответ на задачу?
      <p>Ответ хранится в ячейке DP[n][m].</p>
    </li>
  </ol>
  <p>Для каждой ячейки ищется ответ методом префикс-суммы.</p>

  <details>
    <summary>Решение</summary>
<pre>
// входные данные
int n, m;
cin >> n >> m;
vector&lt;vector&lt;int&gt; &gt; A(n + 1, vector&lt;int&gt;(m + 1));
vector&lt;vector&lt;int&gt; &gt; DP(n + 1, vector&lt;int&gt;(m + 1));
for (int i = 1; i &lt;= n; i++) {
  for (int j = 1; j &lt;= m; j++) {
    cin >> A[i][j];
  }
}

// базовый случай
// перенос первой ячейки
DP[1][1] = A[1][1];
// заполнение первого столбца
for (int i = 2; i &lt;= n; i++) {
  DP[i][1] = DP[i - 1][1] + A[i][1];
}
// заполнение первой строки
for (int j = 2; j &lt;= m; j++) {
  DP[1][j] = DP[1][j - 1] + A[1][j];
}

// обход объектов ДП
for (int i = 2; i &lt;= n; i++) {
  for (int j = 2; j &lt;= m; j++) {
    DP[i][j] = max(DP[i - 1][j], DP[i][j - 1]) + A[i][j];
  }
}

// вывод результата
cout &lt;&lt; DP[n][m];
</pre>
  </details>

  <p>Задачу можно усложнить. Например, требуется вывести оптимальный путь белки. Тогда потребуется дополнительная память для хранения пути и способ его восстановления.</p>
</article>


<!-- Задача A. Максимальная подпоследовательность -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Максимальная подпоследовательность</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 16мб</i></div>

  <p>Дана числовая последовательность, требуется найти длину наибольшей возрастающей подпоследовательности.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано число N - длина последовательности (1 ≤ N ≤ 1000). Во второй строке записана сама последовательность (через пробел). Числа последовательности - целые числа, не превосходящие 10000 по модулю.</p>

  <h4>Выходные данные</h4>
  <p>Требуется вывести наибольшую длину возрастающей подпоследовательности.</p>

  <details>
    <summary>Пример</summary>
<pre>
6
3 29 5 5 28 6
</pre>
  <code>3</code>
    <p>В этой задаче <strong>подпоследовательность</strong> это не идущие подряд числа, между ними могут быть другие чилса, не входящие в данную подпоследовательность.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Создадим массив DP. В ячейке DP[i] будем хранить длину подпоследовательности, которая заканчивается элементом входной последовательности A[i].</p>
    <p>Будем проверять сможем ли мы к этой подпоследовательности справа подставить элемент A[j] такой что A[j] > A[i]. Если сможем, то максимальную подпоследовательность можно продлить до элемента j. И она будет оставаться возрастающей. В векторе DP будут все длины максимальных подпоследовательностей.</p>
    <p>Есть алгоритм НВП (наилучшая возрастающая подпоследовательность), но это отдельная тема, которую мы разберем потом.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  vector&lt;int&gt; DP(n, 1);
  for (int j = 0; j &lt; n; j++) {
    for (int i = 0; i &lt; j; i++) {
      if (A[i] &lt; A[j]) {
        DP[j] = max(DP[j], DP[i] + 1);
      }
    }
  }

  int res = 0;
  for (int i = 0; i &lt; n; i++) {
    res = max(res, DP[i]);
  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача B. Минимальный путь в таблице -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Минимальный путь в таблице</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 16мб</i></div>

  <p>В прямоугольной таблице NxM (в каждой клетке которой записано некоторое число) в начале игрок находится в левой верхней клетке. За один ход ему разрешается перемещаться в соседнюю клетку либо вправо, либо вниз (влево и вверх перемещаться запрещено). При проходе через клетку с игрока берут столько у.е., какое число записано в этой клетке (деньги берут также за первую и последнюю клетки его пути).</p>

  <p>Требуется найти минимальную сумму у.е., заплатив которую игрок может попасть в правый нижний угол.</p>

  <h4>Входные данные</h4>
  <p>Задано два числа N и M - размеры таблицы (1 ≤ N ≤ 20, 1 ≤ M ≤ 20). Затем идет N строк по M чисел в каждой - размеры штрафов в у.е. за прохождение через соответствующие клетки (числа от 0 до 100).</p>

  <h4>Выходные данные</h4>
  <p>Выведите минимальную сумму, потратив которую можно попасть в правый нижний угол.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
3 4
1 1 1 1
5 2 2 100
9 4 2 1
</pre>
    <code>8</code>

    <h4>Пример 2</h4>
<pre>
5 5
1 1 1 1 1
3 100 100 100 100
1 1 1 1 1
2 2 2 2 1
1 1 1 1 1
</pre>
    <code>11</code>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
// условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // ввод данных
  int n, m; // размер таблицы
  cin >> n >> m;
  vector&lt;vector&lt;int&gt; &gt; A(n, vector&lt;int&gt; (m));
  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; m; j++) {
      cin >> A[i][j];
    }
  }

  // решение
  // создадим матрицу для хранения минимальной
  // стоимости прохода к каждой ячейки
  vector&lt;vector&lt;int&gt; &gt; DP(n, vector&lt;int&gt; (m));

  // базовый случай
  // перенос первой ячейки
  DP[0][0] = A[0][0];
  // заполнение первого столбца
  for (int i = 1; i &lt; n; i++) {
    DP[i][0] = DP[i - 1][0] + A[i][0];
  }
  // заполнение первой строки
  for (int j = 1; j &lt; m; j++) {
    DP[0][j] = DP[0][j - 1] + A[0][j];
  }

  // обход объектов ДП
  for (int i = 1; i &lt; n; i++) {
    for (int j = 1; j &lt; m; j++) {
      DP[i][j] = min(DP[i - 1][j], DP[i][j - 1]) + A[i][j];
    }
  }

  // вывод результата
  cout &lt;&lt; DP[n - 1][m - 1];
}
</pre>
  </details>

  <h4>Дополнительно</h4>
  <p>Чтобы восстановить путь, по которому мы собрали минимальную сумму, создадим еще одну матрицу C. Ячейка C[i][j] будет содержать либо 1, либо 2. Если мы пришли в ячейку C[i][j] слева, то запишем в нее 1, если сверху, то запишем в нее 2. Когда дойдем от ячейки [0][0] до [n],m], то можем потом собрать весь путь в обратном порядке.</p>
</article>


<!-- Задача C. Конструктор -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Конструктор</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Определить можно ли с использованием только операций «прибавить 3» и «прибавить 5» получить из числа 1 число N (1 ≤ N ≤ 10⁶). Разумеется, само число 1 получить можно, просто не применяя никаких операций.</p>

  <h4>Входные данные</h4>
  <p>Вводится число N.</p>

  <h4>Выходные данные</h4>
  <p>Выведите слово YES, если число N можно получить из числа 1, или NO – в противном случае.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>1</code>
    <code>YES</code>

    <h4>Пример 2</h4>
    <code>5</code>
    <code>NO</code>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int n;
  cin >> n;

  bool flag = true;

  switch (n) {
    case 2:
    case 3:
    case 5:
    case 8:
      flag = false;
  }

  if (flag) {
    cout &lt;&lt; "YES";
  } else {
    cout &lt;&lt; "NO";
  }
}
</pre>
  </details>
</article>


<!-- Задача D. Прогулки под дождем -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Прогулки под дождем</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В Берляндии оппозиционеры собираются устроить массовые гуляния по бульвару. Бульвар состоит из n расположенных в ряд плиток, пронумерованных от 1 до n cправа налево. Прогулка оппозиционеров должна начаться на плитке номер 1 и закончиться на плитке номер n. В ходе прогулки разрешается перемещаться справа налево между соседними в ряду плитками, а также перепрыгивать через одну плитку. Более формально, с плитки номер i (i &lt; n - 1) можно попасть на плитку номер i + 1 или на плитку номер i + 2 (с плитки номер n - 1 можно попасть только на плитку номер n). Можно считать, что все перемещения оппозиционеров происходят мгновенно.</p>

  <p>Для того, чтобы сорвать оппозиционную акцию, берляндский кровавый режим организовал дождь. Плитки на бульваре плохого качества и они быстро разрушаются под дождем. Известно, что i-тая плитка приходит в негодность после aᵢ дней дождя (в день aᵢ плитка еще не разрушена, а в день aᵢ + 1 уже разрушена). Конечно же, никому не разрешается ходить по разрушенным плиткам! Поэтому прогулка оппозиционеров считается сорванной, если либо разрушена плитка номер 1, либо разрушена плитка номер n, либо невозможно дойти с плитки номер 1 до плитки номер n, двигаясь по неразрушенным плиткам.</p>

  <p>Оппозиционеры хотят собрать побольше единомышленников для своей прогулки. Поэтому чем больше времени у них есть на сборы, тем лучше. Помогите оппозиционерам узнать, сколько у них еще осталось времени, и скажите, в течение скольких дней прогулка с плитки номер 1 на плитку номер n будет возможной.</p>

  <h4>Входные данные</h4>
  <p>В первой строке задано целое число n (1 ≤ n ≤ 10³) — длина бульвара в плитках.</p>

  <p>Во второй строке заданы n целых чисел aᵢ, разделенных пробелом,  — количество дней, через которое i-тая плитка разрушится (1 ≤ aᵢ ≤ 10³).</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно число — искомое количество дней.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
4
10 3 5 10
</pre>
    <code>5</code>

    <h4>Пример 2</h4>
<pre>
5
10 2 8 3 5
</pre>
    <code>5</code>
    <p>В первом примере после третьего дня будет разрушена вторая плитка, и единственным оставшимся маршрутом для гуляний будет 1 → 3 → 4. После пятого дня между первой и последней плиткой будет промежуток в две плитки, который уже невозможно перепрыгнуть.</p>

    <p>Во втором примере до пятого дня включительно будет доступен путь 1 → 3 → 5. На шестой день будет разрушена последняя плитка, и прогулка будет сорвана.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/192/problem/B" target="_blank">Задача 192B</a>
      <br><a href="https://codeforces.com/contest/192" target="_blank">Codeforces Round 121 (Div. 2) 2012-05-26</a>
    </div>

  </details>

</article>


<!-- Задача E. Компьютерная игра -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Компьютерная игра</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 16мб</i></div>

  <p>Вы можете вспомнить хоть одного своего знакомого до двадцатилетнего возраста, который в детстве не играл в компьютерные игры? Если да, то может быть вы и сами не знакомы с этим развлечением? Впрочем, трудностей при решении этой задачи это создать не должно.</p>

  <p>Во многих старых играх с двумерной графикой можно столкнуться с подобной ситуацией. Какой-нибудь герой прыгает по платформам (или островкам), которые висят в воздухе. Он должен перебраться от одного края экрана до другого. При этом при прыжке с одной платформы на соседнюю, у героя уходит |y₂ - y₁| единиц энергии, где y₁ и y₂ – высоты, на которых расположены эти платформы. Кроме того, у героя есть суперприем, который позволяет перескочить через платформу, но на это затрачивается 3 * |y₃ - y₁| единиц энергии. Конечно же, энергию следует расходовать максимально экономно.</p>

  <p>Предположим, что вам известны координаты всех платформ в порядке от левого края до правого. Сможете ли вы найти, какое минимальное количество энергии потребуется герою, чтобы добраться с первой платформы до последней?</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано количество платформ n (1 ≤ n ≤ 30000). Вторая строка содержит n натуральных чисел, не превосходящих 30000 – высоты, на которых располагаются платформы.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное число – минимальное количество энергии, которую должен потратить игрок на преодоление платформ (конечно же в предположении, что cheat-коды использовать нельзя).</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
3
1 5 10
</pre>
    <code>9</code>

    <h4>Пример 2</h4>
<pre>
3
1 5 2
</pre>
    <code>3</code>
  </details>
</article>


<!-- Задача F. Дорога домой -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Дорога домой</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Волонтёрша Юля каждый день возвращается из Ярославского государственного университета домой в Брагино на автобусе. Раньше она садилась в автобус на остановке у университета и ехала до остановки около своего дома. Однако постоянные пробки приводили к тому, что время, за которое она добиралась домой, было неприемлемо большим. Тогда Юля решила часть пути проходить пешком. Юля может пройти пешком от университета до любой из остановок по пути следования маршрута, сесть там на автобус, а затем сойти с автобуса на любой другой остановке и пройти оставшуюся часть пути до дома пешком. Иными словами, сесть в автобус Юля может не более одного раза. Заметим, что Юля может как сесть на автобус сразу у университета, так и сойти с автобуса сразу у дома, либо вообще не садиться в автобус. На прямолинейном маршруте от университета, до дома есть N + 1остановка, причем университет имеет номер 0, а остановка у Юлиного дома имеет номер N. Про каждый отрезок маршрута между двумя последовательными остановками Юля знает, за сколько минут его проезжает автобус, и за сколько минут она пройдет его пешком. Автобусы ходят настолько часто (собственно, это одна из причин пробок), что их никогда не приходится ждать, т.е. подойдя к остановке, Юля может в этот же момент времени заскочить в автобус. Юля молодая и спортивная девушка, поэтому она мгновенно входит в автобус и выходит из него. Время стоянки автобуса на остановке настолько мало, что им тоже можно пренебречь.</p>

  <p>Напишите программу, которая вычисляет наименьшее время, которое может пройти от момента прихода Юли на остановку у университета до ее появления на остановке у дома, если она будет действовать оптимально.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных записано целое число N (1 ≤ N ≤ 100000) — количество отрезков маршрута между соседними остановками. Во второй строке записано N целых чисел Aᵢ (1 ≤ Aᵢ ≤ 360, 1 ≤ i ≤ N), где Aᵢ обозначает время, за которое автобус проезжает отрезок маршрута от остановки i - 1 до остановки i. В третьей строке записано N целых чисел Bᵢ (1 ≤ Bᵢ ≤ 360, 1 ≤ i ≤ N), где Bᵢ обозначает время, за которое Юля проходит отрезок маршрута от остановки i - 1 до остановки i.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное число — ответ на задачу.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
4
1 3 1 1
2 1 2 2
</pre>
    <code>5</code>

    <h4>Пример 2</h4>
<pre>
3
1 2 5
2 9 4
</pre>
    <code>7</code>

    <h4>Пример 3</h4>
<pre>
3
3 7 8
1 2 5
</pre>
    <code>8</code>
  </details>

  <details>
    <summary>Решение</summary>
    <h4>Пример 4. Сначала пешком, потом на автобусе</h4>
<pre>
6
5 5 5 1 1 1
2 2 2 4 4 4
</pre>
  <code>9</code>

    <h4>Пример 5. Сначала на автобусе, потом пешком</h4>
<pre>
6
3 2 2 4 4 4
5 5 5 1 1 1
</pre>
  <code>10</code>

    <h4>Пример 6. Сначала пешком, потом на автобусе, потом пешком</h4>
<pre>
6
5 5 1 2 4 4
2 2 5 5 2 2
</pre>
  <code>11</code>

    <h4>Пример 7</h4>
<pre>
9
5 5 1 1 5 1 1 5 5
1 1 5 5 1 5 5 1 1
</pre>
  <code>13</code>

  <h4>Пример 8</h4>
<pre>
55
195 51 83 36 251 252 1 31 34 137 328 71 356 4 318 143 115 3 333 352 273 16 78 124 354 151 233 107 136 3 118 129 316 297 103 158 196 20 203 117 159 215 269 134 74 86 122 220 263 214 151 215 273 224 9
163 194 210 235 8 245 125 332 240 212 184 182 164 130 220 127 7 34 22 196 209 31 96 289 189 330 57 355 347 55 336 303 55 360 221 351 65 265 360 108 179 226 95 111 214 120 52 78 301 164 141 173 328 290 123
</pre>
  <code>8758</code>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;

  // время на автобусе
  vector&lt;int&gt; A(n + 1);
  for (int i = 1; i &lt;= n; i++) {
    cin >> A[i];
  }

  // время пешком
  vector&lt;int&gt; B(n + 1);
  for (int i = 1; i &lt;= n; i++) {
    cin >> B[i];
  }

  // решение
  // префиксная сумма на автобусе
  vector&lt;int&gt; prefA(n + 1, 0);
  for (int i = 1; i &lt;= n; i++) {
    prefA[i] = prefA[i - 1] + A[i];
  }

  // суффиксная сумма на автобусе
  vector&lt;int&gt; sufA(n + 2, 0);
  for (int i = n; i > 0; i--) {
    sufA[i] = sufA[i + 1] + A[i];
  }

  // префиксная сумма пешком
  vector&lt;int&gt; prefB(n + 1, 0);
  for (int i = 1; i &lt;= n; i++) {
    prefB[i] = prefB[i - 1] + B[i];
  }

  // суффиксная сумма пешком
  vector&lt;int&gt; sufB(n + 2, 0);
  for (int i = n; i > 0; i--) {
    sufB[i] = sufB[i + 1] + B[i];
  }

  // разница во времени
  vector&lt;int&gt; Dif(n + 1);
  for (int i = 1; i &lt;= n; i++) {
    Dif[i] = A[i] - B[i];
  }
  // префикс разницы
  vector&lt;int&gt; prefD(n + 1, 0);
  for (int i = 1; i &lt;= n; i++) {
    prefD[i] = prefD[i - 1] + Dif[i];
  }

  // пусть ответ это минимальное из
  // времени на автобусе или пешком
  int res = min(prefA[n], prefB[n]);

  // метод двух указателей
  // левый указатель left
  // правый указатель right
  //       left      right
  //   1    2    3    4    5    6
  // .____.____.____.____.____.____.

  // собираем вектор отрезков, на которых
  // вермя на автобусе меньше чем пешком
  vector&lt;pair&lt;int, int&gt; &gt; NegA;
  pair&lt;int, int&gt; tmp;
  for (int left = 1; left &lt;= n; left++) {
    int right = left;
    while (right &lt;= n && Dif[right] &lt; 0) {
      right++;
    }
    if (right > left) {
      tmp.first = left;
      tmp.second = right - 1;
      NegA.push_back(tmp);
      left = right;
    }
  }

  // собираем соседние выгодные отрезки вместе
  // ищем максимальный выгодный отрезок
  int cur, next;
  for (int left = 0; left &lt; NegA.size(); left++) {
    int right = left;
    tmp.first = NegA[left].first;
    tmp.second = NegA[right].second;
    cur = prefB[tmp.first - 1] + (prefA[tmp.second] - prefA[tmp.first - 1]) + sufB[tmp.second + 1];
    right++;

    while (right &lt; NegA.size()) {
      tmp.second = NegA[right].second;
      next = prefB[tmp.first - 1] + (prefA[tmp.second] - prefA[tmp.first - 1]) + sufB[tmp.second + 1];
      if (next &lt; cur) {
        cur = next;
      }
      right++;
    }

    res = min(res, cur);
  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача G. Разрежь ленточку -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Разрежь ленточку</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У Поликарпа есть ленточка длины n. Он хочет разрезать ее так, чтобы выполнялись два условия:</p>
  <ol>
    <li>После разрезания, каждый кусочек ленточки должен быть длины a, b или c.</li>
    <li>Количество кусочков ленточки после разрезания должно быть как можно больше.</li>
  </ol>

  <p>Помогите Поликарпу, найдите количество кусочков ленточки после требуемого разрезания.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано через пробел четыре целых числа n, a, b и c (1 ≤ n, a, b, c ≤ 4000) — длина исходной ленточки и разрешенные длины кусочков ленточки после разрезания, соответственно. Числа a, b и c могут совпадать.</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно число — максимально возможное количество кусочков ленточки. Гарантируется, что существует хотя бы одно корректное разрезание ленточки.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>5 5 3 2</code>
    <code>2</code>

    <h4>Пример 2</h4>
    <code>7 5 5 2</code>
    <code>2</code>

    <p>В первом тестовом примере нужно разрезать ленточку на два кусочка: один из них длины 2, второй длины 3.</p>

    <p>Во втором примере нужно разрезать ленточку на два кусочка: один из них длины 5, второй длины 2.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/189/problem/A" target="_blank">Задача 189A</a>
      <br><a href="https://codeforces.com/contest/189" target="_blank">Codeforces Round 119 (Div. 2) 2012-05-10</a>
    </div>

    <p>Создадим большой массив DP. В DP[i] будем хранить максимальное количество лент, на которое можно порезать ленту длины i.</p>
    <p>В DP[i] можно придти только тремя способами - из ячеек DP[i-a], DP[i-b], DP[i-c]. Максимум из этих трех ячеек плюс один надо положить в DP[i].</p>
    <p>Базовые случаи DP[a] = 1, DP[b] = 1, DP[c] = 1.</p>
    <p>Способ обхода объекта ДП. Нужно пройти от начала до конца в цикле от 0 до n и собрать результат. Если какую-то длину K невозможно разрезать на ленточки, то DP[K] = 0.</p>
    <p>Ответ на задачу будет храниться в DP[n].</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  int n;  // длина ленточки
  int a, b, c; // длины кусочков
  cin >> n >> a >> b >> c;

  // решение
  // создадим объект ДП
  vector&lt;int&gt; DP(10000);

  // базовый случай
  DP[a] = 1;
  DP[b] = 1;
  DP[c] = 1;

  // обход объекта ДП
  for (int i = 1; i &lt;= n; i++) {
    if (i - a > 0) {
      if (DP[i] &lt; DP[i - a] + 1 && DP[i - a] != 0) {
          DP[i] = DP[i - a] + 1;
      }
    }
    if (i - b > 0) {
      if (DP[i] &lt; DP[i - b] + 1 && DP[i - b] != 0) {
          DP[i] = DP[i - b] + 1;
      }
    }
    if (i - c > 0) {
      if (DP[i] &lt; DP[i - c] + 1 && DP[i - c] != 0) {
          DP[i] = DP[i - c] + 1;
      }
    }
  }

  // вывод результата
  cout &lt;&lt; DP[n];
}
</pre>
  </details>
</article>


<!-- Задача H. Двоичная последовательность -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Двоичная последовательность</h3>

  <div><i>Ограничение по времени 0.5с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Рассмотрим все последовательности длиной N (0 &lt; N &lt; 44), состоящие только из 0 и 1, в которых никакие две единицы не соседствуют (110 не является правильной последовательностью длины 3, 0101 является правильной последовательностью длины 4). Напишите программу, которая найдёт последовательность, находящуюся на K-м месте (0 &lt; K &lt; 10⁹) в лексикографически упорядоченном по возрастанию списке заданных последовательностей.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит два положительных числа — N и K.</p>

  <h4>Выходные данные</h4>
  <p>Выведите найденную последовательность или -1, если число K больше количества правильных последовательностей.</p>

  <details>
    <summary>Пример</summary>
    <code>3 1</code>
    <code>000</code>
  </details>
</article>


<!-- Задача I. Пицца -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача I. Пицца</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 16мб</i></div>

  <p>Пицца – любимое лакомство Васи, он постоянно покупает и с удовольствием употребляет различные сорта этого великолепного блюда. Однажды, в очередной раз, разрезая круглую пиццу на несколько частей, Вася задумался: на какое максимальное количество частей можно разрезать пиццу за N прямых разрезов?</p>

  <p>Помогите Васе решить эту задачу, определив максимальное число не обязательно равных кусков, которые может получить Вася, разрезая пиццу таким образом.</p>

  <h4>Входные данные</h4>
  <p>Вход содержит натуральное число N – число прямых разрезов пиццы (N ≤ 1000).</p>

  <h4>Выходные данные</h4>
  <p>Выведите ответ на задачу - единственное число.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>2</code>
    <code>4</code>

    <h4>Пример 2</h4>
    <code>3</code>
    <code>7</code>
  </details>
</article>


<!-- Задача J. Без двух нулей подряд -->
<article class="article">
  <div class="anchor" id="task10"></div>
  <h3>Задача J. Без двух нулей подряд</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 16мб</i></div>

  <p>Требуется вычислить количество N-значных чисел в системе счисления с основанием K, таких что их запись не содержит двух подряд идущих нулей.</p>

  <h4>Входные данные</h4>
  <p>Даны два натуральных числа N и K в десятичной системе счисления (2 ≤ K ≤ 10; 2 ≤ N; 4 ≤ N + K ≤ 18).</p>

  <h4>Выходные данные</h4>
  <p>Необходимо вывести целое число в десятичной записи – ответ на задачу.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>2 10</code>
    <code>90</code>
    <p>Двузначные числа в десятичной системе счисления это все числа от 10 до 99, так как в их записи не может быть двух нулей подряд. Вего таких чисел ровно 90.</p>

    <h4>Пример 2</h4>
    <code>4 2</code>
    <code>5</code>
    <p>Четырехзначные числа в двоичной системе счисления без двух нулей подряд это 1111, 1110, 1101, 1011, 1010. Таких чисел ровно 5.</p>

    <h4>Пример 3</h4>
    <code>6 3</code>
    <code>328</code>
    <p>В этой задаче число не начинается с 0. Т.е. 11 это двузначное число, а 01 это однозначное.</p>
  </details>

  <details>
    <summary>Решение</summary>
      <p>Создадим два одномерных массива DP0 и DP1. DP0[i] хранит количество последовательностей длины i которые оканчиваются на 0. DP1[i] хранит количество последовательностей длины i которые оканчиваются не на 0. Если в конце последовательности стоял не 0, то при увеличении последовательности на 1 вконце можно поставить любую цифру, даже 0. Если в конце последовательности стоял 0, то при увеличении последовательности на 1 вконце можно поставить любую цифру кроме 0, потому что иначе появятся два подряд идущих нуля.</p>
      <code>DP0[i] = DP1[i-1];</code>
      <code>DP1[i] = (DP0[i-1] + DP1[i-1]) * (k-1);</code>
      <p>Базовые случаи. DP0[1] = 0 не существует однозначных чисел, заканчивающихся на 0. DP1[1] = k - 1 количество однозначных чисел, которые не заканчиваются на 0.</p>
      <p>Ответ DP0[n] + DP1[n]</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  long long n, k;
  cin >> n >> k;

  // решение
  vector&lt;long long&gt; DP0(n + 1);
  vector&lt;long long&gt; DP1(n + 1);
  DP0[1] = 0;
  DP1[1] = k - 1;
  for (int i = 2; i &lt;= n; i++) {
    DP0[i] = DP1[i - 1];
    DP1[i] = (DP0[i - 1] + DP1[i - 1]) * (k - 1);
  }

  // вывод результата
  cout &lt;&lt; DP0[n] + DP1[n];
}
</pre>
  </details>
</article>


<!-- Задача K. Только вправо или вниз -->
<article class="article">
  <div class="anchor" id="task11"></div>
  <h3>Задача K. Только вправо или вниз</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 16мб</i></div>

  <p>Игровое поле NxM заполняется целыми числами, одно неотрицательное целое число в каждой клетке. Цель игры состоит в том, чтобы пройти по любому разрешенному пути от верхнего левого угла до правого нижнего. Целое число в каждой клетке указывает, какой длины шаг должен быть из текущей клетки. Все шаги могут быть или направо или вниз. Если в результате какого-либо шага игрок покидает пределы поля, такой шаг запрещается.</p>

  <p>Требуется написать программу, которая определит число различных вариантов путей от верхнего левого угла до правого нижнего.</p>

  <h4>Входные данные</h4>
  <p>В первой строке даны размеры поля N (1 ≤ N ≤ 70) и M (1 ≤ M ≤ 70). В последующих N строках входного файла, каждая из которых описывает отдельную строку игрового поля, записаны через пробел по M целых чисел – длины шагов из клеток данной строки.</p>

  <h4>Выходные данные</h4>
  <p>Вывод должен содержать одно число - число различных вариантов путей от верхнего левого угла до правого нижнего. Для каждого поля будет менее чем 2³¹ различных путей.</p>

  <details>
    <summary>Пример</summary>
<pre>
3 4
2 1 1 2
3 2 1 44
3 1 1 0
</pre>
    <code>3</code>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
// условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // ввод данных
  int n, m; // размер поля
  cin >> n >> m;
  vector&lt;vector&lt;long long&gt; &gt; A(n + 1, vector&lt;long long&gt; (m + 1));
  for (int i = 1; i &lt;= n; i++) {
    for (int j = 1; j &lt;= m; j++) {
      cin >> A[i][j];
    }
  }

  // решение
  // создадим объект ДП для хранения
  // количества вариантов пути
  vector&lt;vector&lt;long long&gt; &gt; DP(n + 1, vector&lt;long long&gt; (m + 1));

  // базовый случай
  DP[1][1] = 1;

  // обход объектов ДП
  for (int i = 1; i &lt;= n; i++) {
    for (int j = 1; j &lt;= m; j++) {
      if (A[i][j] != 0) {
        if (j + A[i][j] &lt;= m) {
          DP[i][j + A[i][j]] += DP[i][j];
        }
        if (i + A[i][j] &lt;= n) {
          DP[i + A[i][j]][j] += DP[i][j];
        }
      }
    }
  }

  // вывод результата
  cout &lt;&lt; DP[n][m];
}
</pre>
  </details>
</article>


<!-- Задача L. Умный дартс -->
<article class="article">
  <div class="anchor" id="task12"></div>
  <h3>Задача L. Умный дартс</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Умный дартс – это обычный дартс, но умный. Правила умного дартса очень просты: нужно выбить наибольшее количество очков. Но это же умный дартс, поэтому меткость здесь не играет особой роли, важно умение считать. Мишенью в этой игре является квадратное поле NxN квадратных ячеек. Ячейки бывают двух видов: одни приносят баллы, а другие не приносят баллы. При попадании в ячейку, начисляется не только балл за саму ячейку, но и за все ячейки, которые расположены на одной горизонтали и вертикали с данной(см. рис. ниже).</p>
<pre>
# * * * # *
* * * * * *
* * # * * #
* * * * * *
* # # * # *
* * * * * *
</pre>
  <p>Маленький мальчик Гоша хочет показаться окружающим очень умным, а потому хочет всегда выигрывать в умный дартс. А для этого он решил кидать дротик так, чтобы выбивать максимальное число очков. Но с программированием и математикой у него, увы не всё так хорошо, как с честолюбием. Поэтому он просит вас помочь ему.</p>

  <p>Вам необходимо написать программу, которая посчитает наибольшее возможное количество очков, которое можно получить за один выстрел.</p>

  <h4>Входные данные</h4>
  <p>Во входном файле в первой строке содержится число (1 ≤ N ≤ 2000) – размер поля. Далее в N строках описывается само поле для дартса. Ячейка, в которой стоит символ «*» – ячейка без очков, а ячейка, в которой стоит символ «#» – ячейка стоимостью в один балл.</p>

  <h4>Выходные данные</h4>
  <p>Вывести одно число – максимально возможное количество баллов.</p>

  <details>
    <summary>Пример</summary>
<pre>
6
#***#*
******
**#**#
******
*##*#*
******
</pre>
    <code>4</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Соберем два массива DP1 и DP2. DP1[i] хранит количество '#' в строке i, DP2[i] хранит количество '#' в столбце i.</p>
    <p>В ячейке [i][j] будем хранить DP1[j] + DP2[i] если A[i][j] = '*', и будем хранить DP1[j] + DP2[i] - 1 если A[i][j] = '#', чтобы не учитывать эту '#' два раза.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  int n;
  cin >> n;
  vector&lt;string&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  vector&lt;int&gt; DP1(n);
  vector&lt;int&gt; DP2(n);
  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; n; j++) {
      if (A[i][j] == '#') {
        DP1[i]++;
        DP2[j]++;
      }
    }
  }
  int res = 0;
  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; n; j++) {
      if (A[i][j] == '#') {
        res = max(res, DP1[i] + DP2[j] - 1);
      } else {
        res = max(res, DP1[i] + DP2[j]);
      }
    }
  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача M. Суммы -->
<article class="article">
  <div class="anchor" id="task13"></div>
  <h3>Задача M. Суммы</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>
  <p>Дано N целых чисел A₁, A₂, …, Aₙ. Требуется найти количество различных значений сумм вида k₁⋅A₁ + k₂⋅A₂ + ... + kₙ⋅Aₙ.</p>

  <h4>Входные данные</h4>
  <p>Ввод в первой строке содержит число N, во второй — A₁, A₂, ... , Aₙ через пробел. Ограничения: все числа целые, 1 ≤ N ≤ 500, 0 ≤ Aᵢ ≤ 100, 0 ≤ kᵢ ≤ 1.</p>

  <h4>Выходные данные</h4>
  <p>Выведите количество различных значений сумм.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
3
1 1 2
</pre>
    <code>5</code>

    <h4>Пример 2</h4>
<pre>
3
1 3 2
</pre>
    <code>7</code>

    <h4>Пример 3</h4>
<pre>
5
49 100 98 49 0
</pre>
    <code>10</code>
  </details>
</article>


<!-- Задача N. Гангстеры -->
<article class="article">
  <div class="anchor" id="task14"></div>
  <h3>Задача N. Гангстеры</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 32мб</i></div>

  <p>N гангстеров собираются в ресторан. i-й гангстер приходит в момент времени Tᵢ и имеет богатство Pᵢ. Дверь ресторана имеет K + 1 степень открытости, они обозначаются целыми числами из интервала [0, K]. Степень открытости двери может изменяться на единицу в единицу времени, то есть дверь может открыться на единицу, закрыться на единицу или остаться в том же состоянии. В начальный момент времени дверь закрыта (степень открытости 0). i-й гангстер заходит в ресторан, только если дверь открыта специально для него, то есть когда степень открытости двери соответствует его полноте Sᵢ. Если в момент, когда гангстер подходит к ресторану, степень открытости двери меньше его полноты, он уходит и больше не возвращается. Ресторан работает в интервале времени [0, T].</p>

  <p>Требуется собрать гангстеров с максимальным суммарным богатством в ресторане, открывая и закрывая дверь соответствующим образом.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных находятся числа N, K, T, во второй - T₁, T₂, ..., Tₙ, в третьей - P₁, P₂, ..., Pₙ. в четвёртой - S₁, S₂, ..., Sₙ. Числа в строках разделены пробелами. Ограничения:1 ≤ N ≤ 100, 1 ≤ K ≤ 100, 1 ≤ T ≤ 30000, 0 ≤ Tᵢ ≤ T, 1 ≤ Pᵢ ≤ 300, 1 ≤ Sᵢ ≤ K.</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно число - максимальное суммарное богатство гангстеров, попавших в ресторан. Если зайти не удалось никому, вывести 0.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
4 10 20
10 16 8 16
10 11 15 1
10 7 1 8
</pre>
    <code>26</code>

    <h4>Пример 2</h4>
<pre>
2 17 100
5 0
50 33
6 1
</pre>
    <code>0</code>
  </details>
</article>


<!-- Задача O. КузнечиК -->
<article class="article">
  <div class="anchor" id="task15"></div>
  <h3>Задача O. КузнечиК</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Перед клетчатой полоской длины n сидит кузнечик. Каждая клетка является либо занятой, либо свободной. Кузнечик умеет прыгать на 1, 2, ... , k клеток вперед. Найдите количество различных путей, которыми он может добраться до последней клетки, не заходя в занятые.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано два целых числа n, k (1 ≤ k ≤ n ≤ 5⋅10⁵).</p>

  <p>Во второй строке записана строка длины n, состоящая только из нулей и единиц. Ноль обозначает свободную клетку, а единица - занятую.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное число - количество способов добраться до последней клетки. Поскольку это число может быть очень большим, выведите его по модулю 10⁹ + 7.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
8 3
01100010
</pre>
    <code>3</code>

    <h4>Пример 2</h4>
<pre>
8 3
00000001
</pre>
    <code>0</code>

    <h4>Пример 3</h4>
<pre>
8 4
00111000
</pre>
    <code>4</code>
  </details>
</article>
