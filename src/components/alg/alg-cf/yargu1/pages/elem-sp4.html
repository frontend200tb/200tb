<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contests" target="_blank">Codeforces ЯрГУ. Школьники</a></p>
  <p><a href="https://vk.com/sportprog_yarsu" target="_blank">vk.com/sportprog_yarsu</a></p>
  <p><a href="https://vkvideo.ru/@sportprog_yarsu" target="_blank">vkvideo.ru/@sportprog_yarsu</a></p>
</article>


<article class="article">
  <h1>Занятие 4. Основы С++ #3. vector, cmath</h1>
  <p>Конспект видео от 2024.10.05</p>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contest/555156" target="_blank">Codeforces Контест 555156</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
        <a href="#p1">vector</a>
    <br><a href="#p2">cmath</a>
    <br><a href="#p3">algorithm</a>
    <br><a href="#p4">Матрицы</a>
  </p>
  <p>
        <a href="#task1">Задача A. Последовательность</a>
    <br><a href="#task2">Задача B. Газировкопитие</a>
    <br><a href="#task3">Задача C. Конфеты и две сестры</a>
    <br><a href="#task4">Задача D. Сделай возрастающую</a>
    <br><a href="#task5">Задача E. Праздник равенства</a>
    <br><a href="#task6">Задача F. Формирование команд</a>
    <br><a href="#task7">Задача G. Задача о делимости</a>
    <br><a href="#task8">Задача H. Четный массив</a>
    <br><a href="#task9">Задача I. Сумма круглых чисел</a>
    <br><a href="#task10">Задача J. Скучные квартиры</a>
    <br><a href="#task11">Задача K. Точки на прямой</a>
    <br><a href="#task12">Задача L. Смена направления</a>
    <br><a href="#task13">Задача M. Виталий и ночь</a>
    <br><a href="#task14">Задача N. Николай и перестановка</a>
    <br><a href="#task15">Задача O. X-сумма</a>
    <br><a href="#task16">Задача P. Переключение гравитации</a>
  </p>
</article>


<!-- vector -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>vector</h3>

  <h4>Новые библиотеки</h4>
<pre>
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
</pre>
  <p>Библиотека vector это класс контейнер. В стандартной библиотеке C++ vector (std::vector) называется динамический массив, обеспечивающий быстрое добавление новых элементов в конец и меняющий свой размер при необходимости.</p>
  <p>В библиотеках cmath и algorithm определены математические функции и алгоритмы помогающие решать задачи.</p>

<pre>
int n;
cin >> n;
vector&lt;int&gt; V1;
vector&lt;int&gt; V2(n);
vector&lt;int&gt; V3(n, 5);
</pre>
  <p>V1 пустой vector, в нем нет элементов</p>
  <p>V2 vector, в котором задан размер длины n</p>
  <p>V3 vector, в котором задан размер длины n и каждый элемент равняется 5</p>

  <code>vector&lt;тип&gt; имя(размер);</code>

  <p>Нумерация элементов в vector начинается с 0.</p>
  <p>Все элементы в vector&lt;int&gt; изначально заполнены 0.</p>
  <p>Имя вектора задается по правилам переменных.</p>

  <p>Вектор это динамический массив, длину которого можно изменять во время выполнения программы.</p>
  <p>Создадим вектор целых чисел, изначально пустой</p>
  <code>vector&lt;int&gt; A;</code>
  <p>Создадим вектор целых чисел, содержащий n элементов, изначально равных нулю</p>
  <code>vector&lt;int&gt; A(n);</code>
  <p>Создадим вектор целых чисел, содержащий 10 элементов, изначально равных 5</p>
  <code>vector&lt;int&gt; A(10, 5);</code>
  <p>Создадим двумерный вектор целых чисел, изначально пустой</p>
  <code>vector&lt;vector&lt;int&gt; &gt; A;</code>
  <p>Создадим двумерный вектор целых чисел, содержащий n пустых векторов</p>
  <code>vector&lt;vector&lt;int&gt; &gt; A(n);</code>
  <p>Создадим двумерный вектор целых чисел, содержащий n векторов, по m элементов, изначально равных нулю</p>
  <code>vector&lt;vector&lt;int&gt; &gt; A(n, vector&lt;int&gt; (m));</code>
  <p>Создадим трехерный вектор целых чисел, содержащий n векторов, по m векторов</p>
  <code>vector&lt;vector&lt;vector&lt;int&gt; &gt; &gt; A(n, vector&lt;vector&lt;int&gt; &gt; (m));</code>

  <p>Метод в С++ — это функция, которая принадлежит классу. Она может выполнять какие-либо действия над данными (свойствами) класса.</p>
<pre>
    4   1     3   2
0 0 0 [ 0 0 0 0 ] 0 0
</pre>
  <ol>
    <li><strong>.begin()</strong>	возвращает итератор, указывающий на первый элемент в векторе.</li>
    <li><strong>.end()</strong> возвращает итератор, указывающий за последним элементом вектора или конец вектора.</li>
    <li><strong>.rbegin()</strong> возвращает итератор, указывающий на последний элемент вектора.</li>
    <li><strong>.rend()</strong> возвращает итератор, указывающий перед первым элементом вектора.</li>
    <li><strong>.size()</strong> возвращает целое число размер вектора;</li>
    <li><strong>.empty()</strong> возвращает true если вектор пустой, либо false;</li>
    <li><strong>.clear()</strong> удаляет все элементы вектора;</li>
    <li><strong>.back()</strong> возвращает значение последнего элемента;</li>
    <li><strong>.front()</strong> возвращает значение первого элемента.</li>
    <li><strong>.push_back(arg)</strong> добавляет в конец вектора новый элемент со значением arg;</li>
    <li><strong>.pop_back()</strong> удаляет последний элемент вектора;</li>
    <li><strong>.push_front(arg)</strong> добавляет в начало вектора новый элемент со значением arg;</li>
    <li><strong>.pop_front()</strong> удаляет первый элемент вектора;</li>
    <li><strong>.insert(pos, arg)</strong> добавление элемента в vector в заданную позицию итератором;</li>
    <li><strong>.erase(pos1, pos2)</strong> удаление элементов от позиции pos1 до pos2, заданных итератором.</li>
  </ol>

<pre>
int n, tmp, sum = 0;
cin >> n;
vector&lt;int&gt; Vec;
for (int i = 0; i &lt; n; i++) {
  cin >> tmp;
  Vec.push_back(tmp * tmp);
}
for (int i = 0; i &lt; Vec.size(); i++) {
  sum += Vec[i];
}
cout &lt;&lt; sum;
</pre>
</article>


<!-- cmath -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>cmath</h3>

  <ol>
    <li><strong>abs(arg)</strong> возвращает число по абсолютной величине;</li>
    <li><strong>sqrt(arg)</strong> возвращает корень от числа;</li>
    <li><strong>pow(arg1, arg2)</strong> возвращает число arg1 в степени arg2;</li>
    <li><strong>exp(arg)</strong> возвращает экспоненту в степени arg;</li>
    <li><strong>log(arg)</strong>	возвращает натуральный логарифм от arg;</li>
    <li><strong>log10(arg)</strong> возвращает логарифм по основанию 10 от arg;</li>
    <li><strong>round(arg)</strong>	возвращает правильное математическое округление;</li>
    <li><strong>ceil(arg)</strong> возвращает округление в большую сторону;</li>
    <li><strong>floor(arg)</strong>	возвращает округление в меньшую сторону.</li>
    <li><strong>sin(arg)</strong>	возвращает синус от аргумента;	</li>
    <li><strong>cos(arg)</strong>	возвращает косинус от аргумента;</li>
    <li><strong>tan(arg)</strong>	возвращает тангенс от аргумента.</li>
    <li><strong>asin(arg)</strong> возвращает арксинус от аргумента;</li>
    <li><strong>acos(arg)</strong> возвращает арккосинус от аргумента;</li>
    <li><strong>atan(arg)</strong> возвращает арктангенс от аргумента. Результат от (-pi / 2) до (pi / 2)</li>
    <li><strong>atan2(arg)</strong> возвращает арктангенс от аргумента. Результат от -pi до pi</li>
  </ol>
  <p>Arg передается как радианы, не градус!</p>
  <p>Переведем grad градусов в arg радиан</p>
  <code>int arg = (grad / 180) * pi;</code>
  <p>В библиотеке нет котангенса, но его можно выразить через тангенс</p>
  <code>int cotan = 1 / tan(arg);</code>

<pre>
int a1 = abs(-100);      // 100
int a2 = abs(99);        // 99
double a3 = sqrt(25);    // 5
double a4 = sqrt(30);    // 5.47723
double a5 = pow(2, 10);  // 1024
double a6 = pow(7, 3.3); // 614.927
</pre>
<pre>
int a1 = round(7.4);   // 7
int a2 = round(7.8);   // 8
int a3 = ceil(7.4);    // 8
int a4 = ceil(7.8);    // 8
int a5 = floor(7.4);   // 7
int a6 = floor(7.8);   // 7
</pre>
</article>


<!-- algorithm -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>algorithm</h3>

  <ol>
    <li><strong>min(arg1, arg2)</strong> 	возвращает минимальный элемент из arg1 и arg2;</li>
    <li><strong>max(arg1, arg2)</strong>		возвращает максимальный элемент из arg1 и arg2;</li>
    <li><strong>swap(arg1, arg2)</strong>	меняет местами значения в переменных из arg1 и arg2;</li>
    <li><strong>sort(po1, pos2)</strong> 	упорядочивает элементы в указанном диапазоне по не убыванию элементов или согласно критерию упорядочивания, заданному функцией.</li>
    <li><strong>find(pos1, pos2, arg)</strong>	находит позицию первого вхождения элемента с заданным значением в диапазон. Если элемент не будет найден значение будет равно .end();</li>
    <li><strong>count(pos1, pos2, arg)</strong>	возвращает количество элементов в диапазоне равных значению arg.</li>
  </ol>
<pre>
int n;
cin >> n;
vector&lt;int&gt; Vec(n);
for (int i = 0; i &lt; n; i++) {
  cin >> Vec[i];
}
int res = count(Vec.begin(), Vec.end(), 10);
cout &lt;&lt; res;
</pre>
<pre>
int n, tmp;
cin >> n;
vector&lt;int&gt; Vec(n);
for (int i = 0; i &lt; n; i++) {
  cin >> tmp;
  Vec[i] = tmp;
}
cout &lt;&lt; find(Vec.begin(), Vec.end(), 10) - Vec.begin();
</pre>
  <p>Если элемента равного 10 не будет, ответ будет равен значению параметра n.</p>

<pre>
int n;
cin >> n;
vector&lt;int&gt; Vec(n);
for (int i = 0; i &lt; n; i++) {
  cin >> Vec[i];
}
sort(Vec.begin(), Vec.end());
for (int i = 0; i &lt; n; i++) {
  cout &lt;&lt; Vec[i] &lt;&lt; " ";
}
</pre>
</article>


<!-- Матрицы -->
<article class="article">
  <div class="anchor" id="p4"></div>
  <h3>Матрицы</h3>

  <h4>Задание матрицы через массивы:</h4>
  <p>Статическое создание матрицы</p>
  <code>int Matrix1[100][100];</code>

  <p>Динамическое создание матрицы</p>
<pre>
int **Matrix2;
int n, m;
cin >> n >> m;
Matrix2 = new int* [n];
for (int i = 0; i &lt; n; i++) {
  Matrix2[i] = new int[m];
}
</pre>

  <h4>Задание матрицы через vector:</h4>
<pre>
int n, m;
cin >> n >> m;
vector&lt;vector&lt;int&gt; &gt; Matr1;
vector&lt;vector&lt;int&gt; &gt; Matr2();
vector&lt;vector&lt;int&gt; &gt; Matr3(n, vector&lt;int&gt;(m));
vector&lt;vector&lt;int&gt; &gt; Matr4(n, vector&lt;int&gt;(m, 100));
</pre>
<pre>
int n, m;
cin >> n >> m;
vector&lt;vector&lt;int&gt; &gt; Matr(n, vector&lt;int&gt;(m));
for (int i = 0; i &lt; n; i++) {
  for (int j = 0; j &lt; m; j++) {
    cin >> Matr[i][j];
  }
}
</pre>
</article>


<!-- Задача A. Последовательность -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Последовательность</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 16мб</i></div>

  <p>Дана последовательность чисел, завершающаяся нулем. Вывести четные числа в прямом порядке, нечетные - в обратном.</p>

  <details>
    <summary>Пример</summary>
    <code>13 2 4 21 45 67 23 46 20 1 0</code>
<pre>
2 4 46 20
1 23 67 45 21 13
</pre>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  vector&lt;int&gt; A;
  int tmp = 1;
  while (tmp != 0) {
    cin >> tmp;
    if (tmp != 0) {
      A.push_back(tmp);
    }
  }

  // решение
  vector&lt;int&gt; B; // для четных чисел
  vector&lt;int&gt; C; // для нечетных чисел
  for (int i = 0; i &lt; A.size(); i++) {
    if (A[i] % 2 == 0) {
      B.push_back(A[i]);
    } else {
      C.push_back(A[i]);
    }
  }

  // вывод результата
  for (int i = 0; i &lt; B.size(); i++) {
    cout &lt;&lt; B[i] &lt;&lt; " "; // четные числа
  }
  cout &lt;&lt; '\n';
  for (int i = C.size() - 1; i >= 0; i--) {
    cout &lt;&lt; C[i] &lt;&lt; " "; // нечетные числа
  }
}
</pre>
  </details>
</article>


<!-- Задача B. Газировкопитие -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Газировкопитие</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В городе XXXводске очень холодно этой зимой! Чтобы согреться, компания из n друзей решила купить k бутылок газировки «Take-It-Light» объемом l миллилитров каждая. Также они купили c лаймов (каждый из который разрезали на d долек) и p граммов соли.</p>
  <p>Для одного тоста каждому из друзей требуется nl миллилитров газировки, одна долька лайма и np граммов соли. Друзья хотят сделать как можно больше тостов, при этом все должны выпить поровну. Сколько тостов получится сделать у каждого?</p>

  <h4>Входные данные</h4>
  <p>В первой и единственной строке записаны положительные целые числа n, k, l, c, d, p, nl, np, не превосходящие 1000 и не меньшие 1. Числа разделены ровно одним пробелом.</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно целое число — сколько тостов сможет сделать каждый из друзей.</p>

  <details>
    <summary>Примеры</summary>
  <h4>Пример 1</h4>
  <code>3 4 5 10 8 100 3 1</code>
  <code>2</code>
  <p>Всего газировки у друзей 4 * 5 = 20 мл, значит ее хватит на 20 / 3 = 6 тостов. Лаймов хватит на 10 * 8 = 80 тостов, соли же на 100 / 1 = 100. Однако в компании 3 друга поэтому ответ min(6, 80, 100) / 3 = 2.</p>

  <h4>Пример 2</h4>
  <code>5 100 10 1 19 90 4 3</code>
  <code>3</code>

  <h4>Пример 3</h4>
  <code>10 1000 1000 25 23 1 50 1</code>
  <code>0</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/151/problem/A" target="_blank">Задача 151A</a>
      <br><a href="https://codeforces.com/contest/151" target="_blank">Codeforces Round 107 (Div. 2) 2012-02-17</a>
    </div>

    <p>Посчитаем общий объем газировки, объем газировки для одного тоста, число тостов с газировкой. Посчитаем общее число долек, число долек для одного тоста, число тостов с дольками. Посчитаем общее число граммов соли, число граммов соли для одного тоста, число тостов с солью. Выберем минимальное число тостов.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ввод данных
  int n, k, l, c, d, p, nl, np;
  cin >> n >> k >> l >> c >> d >> p >> nl >> np;

  // решение
  int total_l = k * l; // общий объем газировки
  int tost_l = n * nl; // объем газировки для одного тоста
  int cnt_l = total_l / tost_l; // число тостов с газировкой

  int total_d = c * d; // общее число долек
  int tost_d = n;      // число долек для одного тоста
  int cnt_d = total_d / tost_d; // число тостов с дольками

  int total_p = p;     // общее число граммов соли
  int tost_p = n * np; // граммов соли для одного тоста
  int cnt_p = total_p / tost_p; // число тостов с солью

  int min1 = min(cnt_l, cnt_d);
  int min2 = min(min1, cnt_p);

  // вывод результата
  cout &lt;&lt; min2;
}
</pre>
  </details>
</article>


<!-- Задача C. Конфеты и две сестры -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Конфеты и две сестры</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В задаче речь пойдет о двух сёстрах — Алисе и Бетти. У вас есть n конфет. Вам хочется распределить все эти n конфет между сёстрами так, что:</p>
  <ul>
    <li>Алиса получит a (a > 0) конфет;</li>
    <li>Бетти получит b (b > 0) конфет;</li>
    <li>каждая сестра получит некоторое целое количество конфет;</li>
    <li>Алиса получит больше конфет, чем Бетти (то есть a > b);</li>
    <li>все конфеты будут отданы одной из двух сестёр (то есть a + b = n).</li>
  </ul>

  <p>Ваша задача — посчитать количество способов распределить n конфет между девочками так, как описано выше. Учтите, что конфеты неразличимы между собой.</p>

  <p>Формально, найдите количество способов представить n как сумму n = a + b, где a и b — положительные целые числа и a > b.</p>

  <p>Вам нужно ответить на t независимых наборов тестовых данных.</p>

  <h4>Входные данные</h4>
  <p>Первая строка теста содержит одно целое число t (1 ≤ t ≤ 10⁴) — количество наборов тестовых данных. Затем следуют t наборов тестовых данных.</p>
  <p>Единственная строка набора содержит одно целое число n (1 ≤ n ≤ 2⋅10⁹) — количество конфет, которое у вас есть.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора тестовых данных выведите ответ на него — количество способов распределить ровно n конфет между девочками так, как описано в условии задачи. Если не существует способа, удовлетворяющего всем условиям, выведите 0.</p>

  <details>
    <summary>Пример</summary>
<pre>
6
7
1
2
3
2000000000
763243547
</pre>
<pre>
3
0
0
1
999999999
381621773
</pre>
    <p>Для первого набора тестовых данных возможные 3 способа распределения конфет — это:</p>
    <ol>
      <li>a=6, b=1;</li>
      <li>a=5, b=2;</li>
      <li>a=4, b=3.</li>
    </ol>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1335/problem/A" target="_blank">Задача 1335A</a>
      <br><a href="https://codeforces.com/contest/1335" target="_blank">Codeforces Round 634 (Div. 3) 2020-04-12</a>
    </div>

    <p>Если конфет 1 или 2 то поделить их нельзя. Если конфет четное число, то есть n/2 - 1 способ, потому что их не может быть поровну. Если конфет нечетное число, то есть n/2 способов округленное вниз.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // число конфет
    cin >> n;

    // решение
    if (n &lt; 3) {
      cout &lt;&lt; "0\n";
    } else if (n % 2 == 0) {
      cout &lt;&lt; n / 2 - 1 &lt;&lt; "\n";
    } else {
      cout &lt;&lt; n / 2 &lt;&lt; "\n";
    }
  }

}
</pre>
  </details>
</article>


<!-- Задача D. Сделай возрастающую -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Сделай возрастающую</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Заданы n целых чисел a₁, a², ... , aₙ. Над ними можно совершать следующую операцию:</p>
  <p>выбрать произвольный элемент aᵢ (1 ≤ i ≤ n) и поделить его на 2 (округляем вниз). Другими словами, можно заменить любой выбранный элемент aᵢ на значение ⌊aᵢ/2⌋ (где ⌊x⌋ — округление вниз вещественного числа x).</p>
  <p>Выведите минимальное количество операций, которое необходимо совершить, чтобы последовательность чисел стала строго возрастающей (то есть, чтобы было выполнено условие a₁ &lt; a₂ &lt; ⋯ &lt; aₙ). Или определите, что такую последовательность получить невозможно. Обратите внимание на то, что элементы нельзя менять местами. Единственная возможная операция описана выше.</p>
  <p>Например, пусть n = 3 и задана последовательность чисел [3,6,5]. Тогда достаточно совершить над ней две операции:</p>
  <ol>
    <li>записать вместо числа a₂ = 6 число ⌊6/2⌋=3 и получить последовательность [3,3,5];
    </li>
    <li>затем записать вместо числа a₁ = 3 число ⌊3/2⌋=1 и получить последовательность [1,3,5].
    </li>
  </ol>
  <p>Полученная последовательность является строго возрастающей, так как 1 &lt; 3 &lt; 5.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано единственное число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных в тесте.</p>
  <p>Далее следуют описания наборов входных данных.</p>
  <p>В первой строке каждого набора входных данных содержится единственное целое число n (1 ≤ n ≤ 30).</p>
  <p>Во второй строке каждого набора входных данных записано ровно n целых чисел a₁, a₂, ... , aₙ (0 ≤ aᵢ ≤ 2⋅10⁹).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных в отдельной строке выведите единственное число — минимальное количество операций, которое нужно совершить над последовательностью, чтобы она стала строго возрастающей. Если строго возрастающую последовательность невозможно получить, то выведите «-1».</p>

  <details>
    <summary>Пример</summary>
<pre>
7
3
3 6 5
4
5 3 2 1
5
1 2 3 4 5
1
1000000000
4
2 8 7 5
5
8 26 5 21 10
2
5 14
</pre>
<pre>
2
-1
0
0
4
11
0
</pre>

    <p>Первый набор входных данных разобран в условии.</p>
    <p>Во втором наборе входных данных получить строго возрастающую последовательность невозможно.</p>
    <p>В третьем наборе входных данных последовательность уже является строго возрастающей.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1675/problem/B" target="_blank">Задача 1675B</a>
      <br><a href="https://codeforces.com/contest/1675" target="_blank">Codeforces Round 787 (Div. 3) 2022-05-03</a>
    </div>

    <p>Чтобы последовательность из чисел от 0 до 2млрд. была строго возрастающая, как минимум, надо чтобы каждое i-ое число в массиве было не меньше i. Начиная с n-2 элемента массива будем проверять, что он меньше n-1 элемента и не меньше числа n - 2. Если больше n-1 элемента то делим его на 2, если меньше числа n - 2 то возвращаем -1. Считаем число делений на 2 и выводим как результат.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n;
    cin >> n;
    vector&lt;int&gt; A(n);
    for (int i = 0; i &lt; A.size(); i++) {
      int tmp;
      cin >> tmp;
      A[i] = tmp;
    }

    // решение
    if (A[n-1] &lt; n-1) {
      cout &lt;&lt; "-1\n";
      continue; // к следующему тестовому случаю
    }

    int cnt = 0;
    bool is_bad = false;
    for (int i = n - 2; i >= 0; i--) {
      while (A[i] >= A[i + 1]) {
        A[i] /= 2;
        cnt++;
      }
      if (A[i] &lt; i) {
        cout &lt;&lt; "-1\n";
        is_bad = true;  // числа прохие
        break; // дальше можно не проверять
      }
    }

    if (is_bad == true) {
      continue; // к следующему тестовому случаю
    }

    // вывод результата
    cout &lt;&lt; cnt &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача E. Праздник равенства -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Праздник равенства</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В Берляндии наступил праздник равенства. В честь праздника король решил за счёт государственной казны уравнять благосостояние всех граждан Берляндии.</p>
  <p>Всего в Берляндии n граждан, благосостояние каждого из которых оценивается целым числом в aᵢ бурлей (бурль — денежная единица Берляндии).</p>
  <p>Вы — королевский казначей, которому требуется посчитать минимальные расходы королевства на подарок короля. Король может только давать деньги, а отбирать их он не имеет права.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных содержится целое число n (1 ≤ n ≤ 100) — количество граждан Королевства.</p>
  <p>Во второй строке содержатся n чисел a₁, a₂, ..., aₙ, где aᵢ (0 ≤ aᵢ ≤ 10⁶) — благосостояние i-го гражданина.</p>

  <h4>Выходные данные</h4>
  <p>В единственную строку выходных данных выведите выведите целое число S — минимальное количество бурлей, которое придётся потратить.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
5
0 1 2 3 4
</pre>
    <code>10</code>
    <p>В первом примере, если прибавить первому гражданину 4 бурля, второму 3, третьему 2 и четвёртому 1, то у всех граждан благосостояние станет равным 4.</p>

    <h4>Пример 2</h4>
<pre>
5
1 1 0 1 1
</pre>
    <code>1</code>
    <p>Во втором примере достаточно дать третьему гражданину один бурль.</p>

    <h4>Пример 3</h4>
<pre>
3
1 3 1
</pre>
    <code>4</code>
    <p>В третьем примере нужно отдать по два бурля первому и третьему гражданам, чтобы благосостояние всех граждан стало равным 3.</p>

    <h4>Пример 4</h4>
<pre>
1
12
</pre>
    <code>0</code>
    <p>В четвёртом примере можно никому ничего не давать, так как у всех граждан уже по 12 бурлей.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/758/problem/A" target="_blank">Задача 758A</a>
      <br><a href="https://codeforces.com/contest/758" target="_blank">Codeforces Round 392 (Div. 2) 2017-01-19</a>
    </div>

    <p>Нужно найти самого богатого человека, и состояние всех остальных доводить до этого значения.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;
  vector&lt;int&gt; A(n);
  int max_b = 0; // максимум бурлей
  for (int i = 0; i &lt; A.size(); i++) {
    int tmp;
    cin >> tmp;
    A[i] = tmp;
    max_b = max(max_b, A[i]);
  }

  // решение
  int res = 0;
  for (int i = 0; i &lt; A.size(); i++) {
    res += max_b - A[i];
  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача F. Формирование команд -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Формирование команд</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В университете учатся n студентов. Количество студентов четно. Умение i-го студента программировать равно aᵢ.</p>
  <p>Тренер хочет сформировать n/2 команд. Каждая команда должна состоять ровно из двух студентов, а каждый студент должен принадлежать ровно одной команде. Два студента могут сформировать команду только тогда, когда их умение программировать одинаково (иначе они не смогут понять друг друга и не смогут сформировать команду).</p>
  <p>Студенты могут решать задачи, чтобы улучшать их умение программировать. Одна решенная задача увеличивает умение программировать на один.</p>
  <p>Тренер хочет знать, какое минимальное количество задач студентам необходимо решить, чтобы сформировать ровно n/2
  команд (то есть каждая пара студентов должна формировать команду). Ваша задача — найти это количество.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит одно целое число n (2 ≤ n ≤ 100) — количество студентов. Гарантируется, что n всегда является четным числом.</p>
  <p>Вторая строка входных данных содержит n целых чисел a₁, a₂, ... , aₙ (1 ≤ aᵢ ≤ 100), где aᵢ равно умению i-го студента программировать.</p>

 <h4>Выходные данные</h4>
  <p>Выведите одно целое число — минимальное количество задач, которое необходимо решить студентам, чтобы сформировать ровно n/2
  команд.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
6
5 10 2 3 14 5
</pre>
    <code>5</code>
    <p>В первом тестовом примере оптимальными будут команды: (3,4), (1,6) и (2,5), где числа в скобках являются номерами студентов. Тогда для того, чтобы сформировать первую команду, третий студент должен решить 1 задачу, чтобы сформировать вторую команду, никто не должен решать задачи, и чтобы сформировать третью команду, второй студент должен решить 4 задачи, таким образом ответ равен 1+4=5.</p>

    <h4>Пример 2</h4>
<pre>
2
1 100
</pre>
    <code>99</code>
    <p>Во втором тестовом примере первый студент должен решить 99 задач, чтобы сформировать команду со вторым.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1092/problem/B" target="_blank">Задача 1092B</a>
      <br><a href="https://codeforces.com/contest/1092" target="_blank">Codeforces Round 527 (Div. 3) 2018-12-18</a>
    </div>

    <p>Нужно отсортировать входной массив и объединять соседние элементы в одну команду. Разница между соседними элементами это количество задач, которые необходимо решить, чтобы попасть в команду.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  sort(A.begin(), A.end());
  int res = 0;
  for (int i = 0; i &lt; n; i += 2) {
    res += A[i + 1] - A[i];
  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача G. Задача о делимости -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Задача о делимости</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам даны два целых положительных числа a и b. За один ход вы можете увеличить a на 1 (заменить a на a+1). Ваша задача — найти минимальное количество ходов, которое необходимо сделать, чтобы получить значение a, которое делится на b без остатка. Возможно, вам придётся сделать 0
  ходов, так как a уже делится на b.</p>
  <p>Вам нужно ответить на t независимых наборов входных данных.</p>

  <h4>Входные данные</h4>
  <p>Первая строка теста содержит одно целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных. Затем следуют t наборов входных данных. Единственная строка каждого набора содержит два целых числа a
  и b (1 ≤ a, b ≤ 10⁹).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите ответ — минимальное количество ходов, которое нужно сделать, чтобы получить значение a, которое без остатка делилось бы на b.</p>

  <details>
    <summary>Пример</summary>
<pre>
5
10 4
13 9
100 13
123 456
92 46
</pre>
<pre>
2
5
4
333
0
</pre>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1328/problem/A" target="_blank">Задача 1328A</a>
      <br><a href="https://codeforces.com/contest/1328" target="_blank">Codeforces Round 629 (Div. 3) 2020-03-26</a>
    </div>

    <p>Если a делится на b без остатка то выводим 0. Если есть остаток от деления, то его нужно вычесть из b чтобы получить результат</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int a, b;
    cin >> a >> b;

    // решение
    int res = 0;
    if (a % b) {
      res = b - (a % b);
    }

    // вывод результата
    cout &lt;&lt; res &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача H. Четный массив -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Четный массив</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам дан массив a[0…n-1] длины n, который состоит из неотрицательных целых чисел. Обратите внимание: массив нумеруется с нуля.</p>
  <p>Назовём массив хорошим, если четность каждой позиции совпадает с четностью элемента в ней. Более формально, массив является хорошим, если для всех i (0 ≤ i ≤ n-1) выполнено равенство i mod 2 = a[i] mod 2, где x mod 2 — остаток от деления x на 2.</p>
  <p>Например, массивы [0,5,2,1] и [0,17,0,3] — хорошие, а массив [2,4,6,7] — плохой, потому что для i=1 четность i и a[i] различна: i mod 2 = 1 mod 2 = 1, но a [i] mod2 = 4 mod 2 = 0.</p>
  <p>За один ход вы можете взять любые два элемента массива и поменять их местами (эти элементы не обязательно соседние).</p>
  <p>Найдите минимальное количество ходов, за которое можно сделать массив a хорошим, либо укажите, что это сделать невозможно.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано одно целое число t (1 ≤ t ≤ 1000) — количество наборов тестовых данных в тесте. Далее следуют t наборов тестовых данных.</p>
  <p>Каждый набор начинается со строки, в которой записано целое число n (1 ≤ n ≤ 40) — размер массива a.</p>
  <p>Далее следует строка, содержащая n целых чисел a₀, a₁, ... , aₙ₋₁ (0 ≤ aᵢ ≤ 1000) — исходный массив.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора тестовых данных выведите одно целое число — минимальное количество ходов, за которое можно сделать заданный массив a
  хорошим, или -1, если это сделать невозможно.</p>

  <details>
    <summary>Пример</summary>
<pre>
4
4
3 2 7 6
3
3 2 6
1
7
7
4 9 2 1 18 3 0
</pre>
<pre>
2
1
-1
0
</pre>
    <p>В первом наборе тестовых данных в первый ход можно поменять местами элементы на позициях 0 и 1, а во второй ход поменять местами элементы на позициях 2 и 3.</p>
    <p>Во втором наборе тестовых данных в первый ход надо поменять местами элементы на позициях 0 и 1.</p>
    <p>В третьем наборе тестовых данных нельзя сделать массив хорошим.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1367/problem/B" target="_blank">Задача 1367B</a>
      <br><a href="https://codeforces.com/contest/1367" target="_blank">Codeforces Round 650 (Div. 3) 2020-06-15</a>
    </div>

    <p>Массив можно сделать хорошим если число четных элементов на нечетных местах равно числу нечетных элементов на четных местах в массиве. Надо вернуть это число (четных элементов на нечентных местах) Иначе массив сделать хорошим нельзя и мы возвращаем -1.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n;
    cin >> n;
    vector&lt;int&gt; A(n);
    int even = 0; // четный
    int odd = 0;  // нечетный

    for (int i = 0; i &lt; A.size(); i++) {
      int tmp;
      cin >> tmp;
      A[i] = tmp;

      // решение
      if (i % 2) {
        if (!(A[i] % 2)) {
          even++;
        }
      } else {
        if (A[i] % 2) {
          odd++;
        }
      }
    }

    // вывод результата
    if (even == odd) {
      cout &lt;&lt; even &lt;&lt; '\n';
    } else {
      cout &lt;&lt; "-1\n";
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача I. Сумма круглых чисел -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача I. Сумма круглых чисел</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Положительное целое число называется круглым, если оно имеет вид d00...0. Иными словами, положительное целое число является круглым, если все его цифры, кроме самой левой (старшей), равны нулю. В частности, все числа от 1 до 9 (включительно) являются круглыми.</p>
  <p>Например, следующие числа являются круглыми: 4000, 1, 9, 800, 90. Например, следующие числа не являются круглыми: 110, 707, 222, 1001.</p>
  <p>Вам задано целое положительное число n (1 ≤ n ≤ 10⁴). Представьте число n как сумму круглых чисел, используя минимальное количество слагаемых. Иными словами, вам надо разложить заданное число n
  в сумму наименьшего количества слагаемых, каждое из которых является круглым числом.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных в тесте. Далее следуют t наборов входных данных.</p>
  <p>Каждый набор представляет собой строку, в которой записано целое число n (1 ≤ n ≤ 10⁴).</p>

  <h4>Выходные данные</h4>
  <p>Выведите t ответов на наборы входных данных. Каждый ответ должен начинаться с целого числа k — минимального количества слагаемых. Далее должны следовать k слагаемых, каждое из которых является круглым числом, а их сумма равна n. Слагаемые можно выводить в любом порядке. Если ответов несколько, то выведите любой из них.</p>

  <details>
    <summary>Пример</summary>
<pre>
5
5009
7
9876
10000
10
</pre>
<pre>
2
5000 9
1
7
4
800 70 6 9000
1
10000
1
10
</pre>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1352/problem/A" target="_blank">Задача 1352A</a>
      <br><a href="https://codeforces.com/contest/1352" target="_blank">Codeforces Round 640 (Div. 4) 2020-05-09</a>
    </div>

    <p>Максимально возможное входное число содержит 5 цифр, поэтому для отевта заведем массив на 5 элементов. Если остаток от деления на 10 равен нулю, то увеличиваем счетчик нулей на 1, иначе записываем в массив остаток от деления с числом нулей из счетчика нулей, увеличиваем число нулей на 1 и число чисел в ответе на 1.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n;
    cin >> n;

    // решение
    int count = 0;  // число чисел в ответе
    int zeroes = 0; // число нулей в следующем числе
    int next = 0;   // следующее число
    vector&lt;int&gt; A(5, 0);
    while (n) {
      if (n % 10 == 0) {
        zeroes++;
      } else {
        next = (n % 10) * (int)pow(10, zeroes);
        A[count] = next;
        count++;
        zeroes++;
      }
      n /= 10;
    }

    // вывод результата
    cout &lt;&lt; count &lt;&lt; '\n';
    for (int i = 0; i &lt; count; i++) {
      cout &lt;&lt; A[i] &lt;&lt; " ";
    }
    cout &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача J. Скучные квартиры -->
<article class="article">
  <div class="anchor" id="task10"></div>
  <h3>Задача J. Скучные квартиры</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Есть дом, в котором расположены 10 000 квартир, пронумерованных от 1 до 10 000.</p>
  <p>Назовем номер квартиры скучным, если ее номер состоит из одинаковых цифр. Примерами скучных квартир являются 11,2,777,9999 и так далее.</p>
  <p>Наш герой очень наглый и он любит звонить в домофоны всех скучных квартир до тех пор, пока кто-то не ответит, в следующем порядке:</p>
  <ol>
    <li>сначала он обзванивает квартиры, состоящие из цифр 1, в возрастающем порядке (1,11,111,1111);</li>
    <li>затем он обзванивает квартиры, состоящие из цифр 2, в возрастающем порядке (2,22,222,2222);</li>
    <li>и так далее.</li>
  </ol>
  <p>Житель скучной квартиры x ответил на звонок. После этого наш герой перестал обзванивать кого-либо еще.</p>
  <p>Наш герой хочет знать, как много цифр он суммарно нажал. Ваша задача — помочь посчитать ему суммарное количество нажатых клавиш.</p>
  <p>Например, если житель квартиры 22 ответил, то наш герой звонил в квартиры с номерами 1,11,111,1111,2,22. Таким образом, суммарное количество нажатий равно 1+2+3+4+1+2=13.</p>
  <p>Вам нужно ответить на t независимых наборов тестовых данных.</p>

  <h4>Входные данные</h4>
  <p>Первая строка теста содержит одно целое число t (1 ≤ t ≤ 36) — количество наборов тестовых данных.</p>
  <p>Единственная строка набора тестовых данных содержит одно целое число x (1 ≤ x ≤ 9999) — номер квартиры, житель которой ответил на звонок. Гарантируется, что x состоит из одинаковых цифр.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора тестовых данных выведите ответ на него: как много цифр суммарно нажал наш герой.</p>

  <details>
    <summary>Пример</summary>
<pre>
4
22
9999
1
777
</pre>
<pre>
13
90
1
66
</pre>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1433/problem/A" target="_blank">Задача 1433A</a>
      <br><a href="https://codeforces.com/contest/1433" target="_blank">Codeforces Round 677 (Div. 3) 2020-10-20</a>
    </div>

    <p>Определяем последнюю цифру dig и количество цифр cnt в номере ответившей квартиры. Значит в 4 квартиры каждой предыдущей цифры уже звонили. Сумма цифр в этих 4 кварирах равна 1 + 2 + 3 + 4 = 10. Прибавим к этому цифры от 1 до cnt.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n;
    cin >> n;

    // решение
    int res = 0;
    int dig = n % 10; // цифра в номере
    int cnt = 0;      // количество цифр в номере
    while (n) {
      n /= 10;
      cnt++;
    }

    for (int i = 1; i &lt; dig; i++) {
      res += 10;
    }
    for (int i = 1; i &lt;= cnt; i++) {
      res += i;
    }

    // вывод результата
    cout &lt;&lt; res &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача K. Точки на прямой -->
<article class="article">
  <div class="anchor" id="task11"></div>
  <h3>Задача K. Точки на прямой</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Назовём диаметром мультимножества точек на прямой максимальное расстояние между двумя точками этого множества. Например, диаметр мультимножества {1, 3, 2, 1} равен 2.</p>
  <p>Диаметр мультимножества, состоящего из одной точки, равен 0.</p>
  <p>Даны n точек на прямой. Какое минимальное число точек необходимо убрать, чтобы диаметр мультимножества оставшихся точек не превосходил d?</p>

  <h4>Входные данные</h4>
  <p>В первой строке заданы два целых числа n и d (1 ≤ n ≤ 100, 0 ≤ d ≤ 100) — количество точек и ограничение на диаметр, соответственно.</p>
  <p>Во второй строке через пробел заданы n целых чисел (1 ≤ xᵢ ≤ 100) — координаты точек.</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно целое число — минимальное количество удалённых точек.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
3 1
2 1 4
</pre>
    <code>1</code>
    <p>В первом тестовом примере выгодно удалить точку с координатой 4. Оставшиеся точки будут иметь координаты 1 и 2, поэтому диаметр оставшегося мультимножества будет равен 2 - 1 = 1.</p>

    <h4>Пример 2</h4>
<pre>
3 0
7 7 7
</pre>
    <code>0</code>
    <p>Во втором тестовом примере диаметр равен 0, поэтому удалять точки не потребуется.</p>

    <h4>Пример 3</h4>
<pre>
6 3
1 3 4 6 9 10
</pre>
    <code>3</code>
    <p>В третьем тестовом примере выгодно удалить точки с координатами 1, 9 и 10. Оставшиеся точки будут иметь координаты 3, 4 и 6, поэтому диаметр будет равен 6 - 3 = 3.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/940/problem/A" target="_blank">Задача 940A</a>
      <br><a href="https://codeforces.com/contest/940" target="_blank">Codeforces Round 466 (Div. 2) 2018-02-24</a>
    </div>

    <p>Нужно отсортировать координаты точек, проверить расстояние между каждыми двумя точками. Это цикл в цикле. Выбрать максимальное расстояние, меньшее или равно заданному диаметру. </p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;

using namespace std;

int main() {
  // ввод данных
  int n, d;
  cin >> n >> d;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  sort(A.begin(), A.end());
  int res = 0;
  for (int i = 0; i &lt; n; i++) {
    for (int j = i; j &lt; n; j++) {
      if (A[j] - A[i] &lt;= d) {
        res = max(res, j - i + 1);
      }
    }
  }

  // вывод результата
  cout &lt;&lt; n - res;
}
</pre>
  </details>
</article>


<!-- Задача L. Смена направления -->
<article class="article">
  <div class="anchor" id="task12"></div>
  <h3>Задача L. Смена направления</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Дана сетка, состоящая из n строк и m столбцов. Строки и столбцы пронумерованы от 1 до n и от 1 до m соответственно. Пересечение a-й строки и b-го столбца обозначим за (a,b).</p>
  <p>Изначально вы находитесь в верхнем левом углу (1,1). Ваша цель — добраться до нижнего правого угла (n,m)</p>
  <p>Из клетки (a,b) вы можете двигаться в четырех направлениях: вверх в клетку (a-1,b), вниз в (a+1,b), влево в (a,b-1) или вправо в (a,b+1)</p>
  <p>Вам запрещается двигаться в одном направлении дважды подряд, вы не можете покидать пределы сетки. За какое минимальное количество шагов можно добраться до (n,m)?</p>

  <h4>Входные данные</h4>
  <p>Каждый тест состоит из нескольких наборов входных данных. Первая строка содержит одно целое число t (1 ≤ t ≤ 10³) — количество наборов входных данных. Далее следует описание наборов входных данных.</p>
  <p>Первая строка каждого набора содержит два целых числа n и m (1 ≤ n, m ≤ 10⁹) — размер сетки.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно целое число: -1, если нельзя добраться до (n,m) при заданных ограничениях, в ином случае — минимальное количество шагов.</p>

  <details>
    <summary>Пример</summary>
<pre>
6
1 1
2 1
1 3
4 2
4 6
10 5
</pre>
<pre>
0
1
-1
6
10
17
</pre>
  <p>1-й набор входных данных: n=1, m=1, изначально вы находитесь в (1,1), поэтому 0 шагов необходимо, чтобы добраться до (n,m)=(1,1).</p>
  <p>2-й набор: нужно сделать один шаг вниз, чтобы достичь (2,1).</p>
  <p>3-й набор: невозможно достичь (1,3), не сделав подряд два шага вправо или не покидая пределы сетки.</p>
  <p>4-й набор: оптимальная последовательность шагов выглядит например так: (1,1)→(1,2)→(2,2)→(2,1)→(3,1)→(3,2)→(4,2). Можно доказать, что это оптимальное решение. Таким образом, ответ равен 6.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1668/problem/A" target="_blank">Задача 1668A</a>
      <br><a href="https://codeforces.com/contest/1668" target="_blank">Codeforces Round 783 (Div. 2) 2022-04-14</a>
    </div>

    <p>Из двуx сторон n и m определяем длинную сторону. Меняем n и m так, чтобы в n была длинная сторона. Если короткая сторона 1, а длинная больше 2 то решения нет, возвращаем -1.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;cmath&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n, m;
    cin >> n >> m;

    // решение
    if (m > n) {
      int tmp = n;
      n = m;
      m = tmp;
    }

    if ((m == 1) && (n > 2)) {
      cout &lt;&lt; "-1\n";
      continue;  // переходим к следующему тесту
    }

    int res = 0;
    if ((n - m) % 2 == 0) {
      res = (m - 1) * 2 + (n - m) * 2;
    } else {
      res = (m - 1) * 2 + (n - m) * 2 - 1;
    }

    // вывод результата
    cout &lt;&lt; res &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача M. Виталий и ночь -->
<article class="article">
  <div class="anchor" id="task13"></div>
  <h3>Задача M. Виталий и ночь</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Как-то раз Виталий возвращался домой поздно ночью и заинтересовался вопросом: а сколько ещё людей не спит в это время? Для этого Виталий решил посмотреть, какие окна горят в доме, мимо которого он в этот момент проходил.</p>
  <p>Виталий видит перед собой n-этажный дом и 2·m окон на каждом этаже. Согласно планировке, на каждом этаже располагается m квартир, пронумерованных от 1 до m, и каждой из них принадлежит два последовательных окна на данном этаже. Если пронумеровать окна от 1 до 2·m слева направо, то j-й квартире i-го этажа принадлежат окна 2·j - 1 и 2·j в соответствующем ряду окон. Виталий считает, что люди в квартире не спят, если хотя бы в одном из окон этой квартиры горит свет.</p>
  <p>Используя информацию о свете в окнах данного дома, вы должны посчитать количество квартир, в которых, по мнению Виталия, жители не спят.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных следует два целых числа n и m (1 ≤ n, m ≤ 100) — количество этажей в доме и количество квартир на каждом этаже соответственно.</p>
  <p>Следующие n строк описывают этажы сверху вниз и содержат по 2·m символов каждая. Если в i-м окне данного этажа горит свет, то в i-й позиции находится символ '1', иначе там находится символ '0'.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственно целое число — количество квартир, в которых горит свет хотя бы в одном окне, то есть, по мнению Виталия, там кто-то не спит.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
2 2
0 0 0 1
1 0 1 1
</pre>
    <code>3</code>
    <p>В первом тестовом примере дом двухэтажный, по две квартиры на каждом этаже, то есть всего в нем 4 квартиры. Свет не горит только на втором этаже в левой квартире, так как в обеих комнатах этой квартиры свет выключен.</p>

    <h4>Пример 2</h4>
<pre>
1 3
1 1 0 1 0 0
</pre>
    <code>2</code>
    <p>Во втором тестовом примере дом одноэтажный, и на первом этаже есть три квартиры. Свет горит в самой левой квартире (в обоих окнах) и в средней квартире (в одном окне). В правой же квартире свет не горит.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/595/problem/A" target="_blank">Задача 595A</a>
      <br><a href="https://codeforces.com/contest/595" target="_blank">Codeforces Round 330 (Div. 2) 2015-11-08</a>
    </div>

    <p>К нам приходят два числа. n это число этажей, m это число квартир на этаже. В каждой квартире 2 соседних окна. Всего квартир в доме n * m. Мы можем принимать в цикле по два числа и проверять если одно из них равно 1 то в этой квартире горит свет и значит там не спят.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int n, m;
  cin >> n >> m;
  int w = n * m; // количесвто квартир в доме
  int res = 0, w1 = 0, w2 = 0;
  for (int i = 1; i &lt;= w; i++) {
    cin >> w1; // свет в 1 окне
    cin >> w2; // свет в 2 окне

    // решение
    if (w1 || w2) {
      res++;
    }
  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача N. Николай и перестановка -->
<article class="article">
  <div class="anchor" id="task14"></div>
  <h3>Задача N. Николай и перестановка</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У Николая есть массив a, состоящий из n различных целых чисел от 1 до n. Другими словами, массив Николая — это перестановка целых чисел от 1 до n.</p>
  <p>Николай решил, что будет лучше, если минимальный элемент его массива (то есть число 1) и максимальный элемент его массива (то есть число n) будут находиться как можно дальше друг от друга. Поэтому он решил ровно один раз поменять местами два каких-нибудь элемента таким образом, чтобы расстояние между минимальным и максимальным элементами стало максимально возможным. Расстоянием между двумя элементами называется модуль разности номеров позиций данных элементов.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных следует целое положительное число n (2 ≤ n ≤ 100) — количество элементов в массиве Николая.</p>
  <p>Во второй строке входных данных записаны различные целые числа a₁, a₂, ... , aₙ (1 ≤ aᵢ ≤ n), где aᵢ равно элементу, который находится в i-й позиции в массиве Николая.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное целое число — максимальное расстояние между минимальным и максимальным элементами в массиве Николая, которое может быть получено с помощью ровно одного обмена местами двух элементов массива.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
5
4 5 1 3 2
</pre>
    <code>3</code>
    <p>В первом примере оптимального ответа можно добиться поменяв местами 1 и 2.</p>

    <h4>Пример 2</h4>
<pre>
7
1 6 5 3 4 7 2
</pre>
    <code>6</code>
    <p>Во втором примере минимальный и максимальный элементы будут находиться в разных концах массива, если поменять местами 7 и 2.</p>

    <h4>Пример 3</h4>
<pre>
6
6 5 4 3 2 1
</pre>
    <code>5</code>
    <p>В третьем примере расстояние между минимальным и максимальным элементов уже максимально возможное, поэтому нужно сделать какой-нибудь ничего не значащий обмен, например 5 и 2.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/676/problem/A" target="_blank">Задача 676A</a>
      <br><a href="https://codeforces.com/contest/676" target="_blank">Codeforces Round 354 (Div. 2) 2016-05-24</a>
    </div>

    <p>Найти индексы минимального и максимального элемента. Выбрать индекс ближайший краю. Найти максимум от индекса до края.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;
  int a[100];
  int mini; // индекс минимума
  int maxi; // индекс максимума

  for (int i = 1; i &lt;= n; i++) {
    cin >> a[i];
    if (a[i] == 1) {
      mini = i;
    }
    if (a[i] == n) {
      maxi = i;
    }
  }

  // решение
  int mind; // от минимума до края
  int maxd; // от максимума от края
  mind = min(mini - 1, n - mini);
  maxd = min(maxi - 1, n - maxi);

  int res = 0;
  res = n - min(mind, maxd) - 1;

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача O. X-сумма -->
<article class="article">
  <div class="anchor" id="task15"></div>
  <h3>Задача O. X-сумма</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Дедушка Тимура подарил ему шахматную доску, чтобы он попрактиковался. Эта доска a состоит из n строк и m столбцов. На каждой клетке написано неотрицательное целое число.</p>
  <p>Задача Тимура поставить слона так, чтобы сумма на клетках, атакованных им, была максимальна. Слон атакует во всех направлениях по диагонали. Расстояние, на которое атакует слон, не ограничено. Обратите внимание, что клетка, в которой стоит слон, также считается атакованной. Помогите ему найти максимальную сумму, которую он может получить.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит число t (1 ≤ t ≤ 1000) — количество наборов входных данных в тесте. Далее следуют описания самих наборов.</p>
  <p>Первая строка каждого набора содержит два числа n и m (1 ≤ n ≤ 200, 1 ≤ m ≤ 200).</p>
  <p>Следующие n строк содержат по m целых чисел, j-й элемент i-й строки a<sub>ij</sub> — это число, записанное в j-й клетке i-й строки (0 ≤ a<sub>ij</sub> ≤ 10⁶)</p>
 <p>Гарантируется, что сумма n⋅m по всем наборам не превосходит 4⋅10⁴.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно число — максимальную сумму по всем возможным размещениям слона.</p>

  <details>
    <summary>Пример</summary>
<pre>
4
4 4
1 2 2 1
2 4 2 4
2 2 3 1
2 4 2 4
2 1
1
0
3 3
1 1 1
1 1 1
1 1 1
3 3
0 1 1
1 0 1
1 1 0
</pre>
<pre>
20
1
5
3
</pre>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1676/problem/D" target="_blank">Задача 1676D</a>
      <br><a href="https://codeforces.com/contest/1676" target="_blank">Codeforces Round 790 (Div. 4) 2022-05-10</a>
    </div>

    <p>Создадим массив B размером такой же как входной массив A. В клетку B[i] будем записывать сумму из клеток массива A на диагоналях которой она находится.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n, m;
    cin >> n >> m;

    vector&lt;vector&lt;int&gt; &gt; A(n, vector&lt;int&gt;(m));
    for (int i = 0; i &lt; n; i++) {
      for (int j = 0; j &lt; m; j++) {
        cin >> A[i][j];
      }
    }

  // решение
    vector&lt;vector&lt;int&gt; &gt; B(n, vector&lt;int&gt;(m));
    // смещение на одну клетку
    int x = 1;
    int res = 0;
    for (int i = 0; i &lt; n; i++) {
      for (int j = 0; j &lt; m; j++) {
        int sum = A[i][j];
        // влево вверх
        x = 1;
        while ((i - x >= 0) && (j - x >= 0)) {
          sum += A[i - x][j - x];
          x++;
        }
        // вправо вверх
        x = 1;
        while ((i - x >= 0) && (j + x &lt; m)) {
          sum += A[i - x][j + x];
          x++;
        }
        // вправо вниз
        x = 1;
        while ((i + x &lt; n) && (j + x &lt; m)) {
          sum += A[i + x][j + x];
          x++;
        }
        // влево вниз
        x = 1;
        while ((i + x &lt; n) && (j - x >= 0)) {
          sum += A[i + x][j - x];
          x++;
        }
        B[i][j] = sum;
        res = max(res, B[i][j]);
      }
    }

  // вывод результата
  cout &lt;&lt; res &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача P. Переключение гравитации -->
<article class="article">
  <div class="anchor" id="task16"></div>
  <h3>Задача P. Переключение гравитации</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Маленький Крис скучает на занятиях по физике (слишком просто), поэтому он смастерил необычную коробку для игрушек, чтобы занять себя. Необычность коробки заключается в том, что она может изменять гравитацию!</p>
  <p>В коробке находятся n столбиков игрушечных кубиков, расположенных в ряд: i-й столбик состоит из aᵢ кубиков. Изначально гравитация в коробке тянет все кубики вниз. Когда Крис переключает гравитацию, она начинает тянуть все кубики к правой стенке коробки. Рисунок показывает начальное и конечное расположение кубиков в коробке: кубики, изменившие свои позиции, выделены оранжевым цветом.</p>
<pre>
#          #
## # ->  ###
####    ####
</pre>
  <p>Вам дано изначальное расположение игрушечных кубиков в коробке. Найдите количество кубиков в каждом из n столбиков после переключения гравитации!</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных записано целое число n (1 ≤ n ≤ 100), количество столбиков в коробке. В следующей строке записано n целых чисел через пробел: i-е число aᵢ (1 ≤ aᵢ ≤ 100) обозначает количество кубиков в i-м столбике.</p>

  <h4>Выходные данные</h4>
  <p>Выведите n целых чисел через пробел: i-е число должно обозначать количество кубиков в i-м столбике после переключения гравитации.</p>

  <details>
    <summary>Примеры</summary>
  <h4>Пример 1</h4>
<pre>
4
3 2 1 2
</pre>
  <code>1 2 2 3</code>
  <p>Первый тестовый пример изображен на рисунке. Верхний кубик первого столбика падает на верх последнего столбика; верхний кубик второго столбика падает на верх третьего столбика; средний кубик первого столбика падает на верх второго столбика.</p>

  <h4>Пример 2</h4>
<pre>
3
2 3 8
</pre>
  <code>2 3 8</code>
<pre>
  #      #
  #      #
  #      #
  # ->   #
  #      #
 ##     ##
###    ###
###    ###
</pre>
  <p>Во втором тестовом примере переключение гравитации не меняет высоты столбиков.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/405/problem/A" target="_blank">Задача 405A</a>
      <br><a href="https://codeforces.com/contest/405" target="_blank">Codeforces Round 238 (Div. 2) 2014-03-21</a>
    </div>

    <p>Поскольку гравитация переключается вправо, то есть кубики падают на правую стенку, то достаточно входной массив отсортировать по возрастанию.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  sort(A.begin(), A.end());

  // вывод результата
  for (int i = 0; i &lt; n; i++) {
    cout &lt;&lt; A[i] &lt;&lt; ' ';
  }
}
</pre>
  </details>
</article>

