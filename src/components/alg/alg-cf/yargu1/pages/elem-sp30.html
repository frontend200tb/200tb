<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contests" target="_blank">Codeforces ЯрГУ. Школьники</a></p>
  <p><a href="https://vk.com/sportprog_yarsu" target="_blank">vk.com/sportprog_yarsu</a></p>
  <p><a href="https://vkvideo.ru/@sportprog_yarsu" target="_blank">vkvideo.ru/@sportprog_yarsu</a></p>
</article>


<article class="article">
  <h1>Занятие 30 Графы #6. CHM. Крускал</h1>
  <p>Конспект видео от 2025.04.26</p>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contest/606492" target="_blank">Codeforces Контест 606492</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
    <a href="#p1">Графы #6. CHM</a>
  </p>
  <p>
        <a href="#task1">Задача A. Компоненты связности</a>
    <br><a href="#task2">Задача B. Дереливо</a>
    <br><a href="#task3">Задача C. Крускал</a>
    <br><a href="#task4">Задача D. Лаксурк</a>
    <br><a href="#task5">Задача E. Сетевое подключение</a>
    <br><a href="#task6">Задача F. Чаепитие</a>
    <br><a href="#task7">Задача G. Пингвин-Авиа</a>
    <br><a href="#task8">Задача H. Паутина Ананси</a>
    <br><a href="#task9">Задача I. Перемешивание колоды</a>
    <br><a href="#task10">Задача J. Electrician</a>
    <br><a href="#task11">Задача K. Пчелыыыыыыыы</a>
    <br><a href="#task12">Задача L. Гы гы гы(гы гы)</a>
  </p>
</article>


<!-- Графы #6. CHM -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Графы #6. CHM</h3>

  <p>СНМ - Система непересекающихся множеств. Структура данных, которая поддерживает непересекающиеся множества на n элементах, а также выполняет два запроса:</p>
  <ol>
    <li>get(a) — вернуть идентификатор множества, в котором лежит элемент a;</li>
    <li>union(a, b) — объединить два множества, в одном из которых лежит a, а в другом лежит b.</li>
  </ol>
  <p>Основное применение алгоритма СНМ это построение минимальных остовных деревьев (алгоритм Крускала).</p>
  <p>Остовное дерево — это подграф связного графа, который содержит все его вершины и также представляет собой дерево.</p>
  <p>Минимальное остовное дерево — это подграф связного графа, который содержит все его вершины и также представляет собой дерево, чья сумма весов ребер минимально возможная.</p>
  <p>Поставим перед собой задачу:</p>
  <p>Пусть у нас есть n элементов (вершин), каждый из которых состоит в собственном множестве. Мы хотим делать две операции над нашими элементами:</p>
  <ol>
    <li>Проверить, что два элемента располагаются в одном множестве.</li>
    <li>Соединить две вершины ребром и тем самым объединить два множества в одно.</li>
  </ol>
  <p>Наивная реализация.</p>
  <p>Создадим дополнительный вектор Color, где Color[i] определяет в каком множестве располагается элемент i. Изначально все элементы помечены своим числом/цветом Color[i] = i.</p>
<pre>
int n;
cin >> n;
vector&lt;int&gt; Color(n + 1);
for (int i = 1; j &lt;= i++) {
  Color[i] = 1;
}
</pre>

  <p>Обработка событий:</p>
<pre>
int q, type, a, b;
cin >> q;
for (int i = 0; i &lt; q; i++) {
  cin >> type >> a >> b;
  if (type == 1) {
    if (Color[a] == Color[b]) {
      cout &lt;&lt; "Yes\n";
    } else {
      cout &lt;&lt; "No\n";
    }
  } else {
    int tmp = Color[a];
    for (int j = 1; j &lt;= n; j++) {
      if (tmp == Color[j]) {
        Color[j] = Color[b];
      }
    }
  }
}
</pre>
  <p>Провека элементов в одном множестве по трудоемкости O(1).</p>
  <p>Объединение множеств по трудоемкости O(n).</p>
  <p>Итоговая трудоемкость всей программы O(qn). К сожалению, в большинстве задач это TL.</p>

  <p>Придумаем оптимизацию хранения элементов внутри одного множества. Введем дополнительные параметры для каждого элемента:</p>
  <ol>
    <li>Количество подчиненных у элемента.</li>
    <li>Номер элемента непосредственного начальника.</li>
  </ol>
  <p>Самый главный начальник (корень или мама) в множестве ссылается сам на себя и все элементы множества ему подчиняются.</p>

  <p>Изменим смысл операций:</p>
  <ol>
    <li>Вместо проверки двух элементов в одном множестве, будем проверять что главные элементы множеств совпадают.</li>
    <li>Вместо соединения двух элементов a и b ребром, будем соединять корни множеств.</li>
  </ol>
  <p>Если упрощать смысл, то все действия проходят через главные элементы множеств. Трудоемкость алгоритма O(nlog₂n).</p>

  <p>Для оптимизации нам требуются vector Count_elem, Count_elem[i] хранит количество подчиненных у элемента i, и Putty, Putty[i] хранит непосредственного начальника для i элемента.</p>

<pre>
int n;
cin >> n;
vector&lt;int&gt; Count_elem(n + 1), Putty(n + 1);
for (int i = 1; i &lt;= n; i++) {
  Count_elem[i] = 1;
  Putty[i] = i;
}
</pre>

  <p>Важной оптимизацией алгоритма является правило объединения множеств.  Нам необходимо к большему множеству добавлять меньшее! (Добавление большинства к меньшинству неэффективно)</p>

<pre>
int q, type, a, b;
cin >> q;
for (int i = 0; i &lt; q; i++) {
  cin >> type >> a >> b;
  while (a != Putty[a]) {
    a = Putty[a];
  }
  while (b != Putty[b]) {
    b = Putty[b];
  }
  if (type == 1) {
    if (a == b) {
      cout &lt;&lt; "Yes\n";
    } else {
      cout &lt;&lt; "No\n"
    }
  } else {
    if (a != b) {
      if (Count_elem[a] > Count_elem[b]) {
        Count_elem[a] += Count_elem[b];
        Putty[b] = a;
      } else {
        Count_elem[b] += Count_elem[a];
        Putty[a] = b;
      }
    }
  }
}
</pre>

  <h4>Крускала</h4>

  <p>Задача:</p>
  <p>Пусть дан взвешенный неориентированный граф из n вершин и m ребер. Каждое ребро задается 3 числами ui, vi, wi - номера вершин и вес. Необходимо оставить такие ребра что выполняется два условия:</p>
  <ol>
    <li>Граф остается связным.</li>
    <li>Сумма ребер минимально возможная.</li>
  </ol>
</article>


<!-- Задача A. Компоненты связности -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Компоненты связности</h3>

  <div><i>Ограничение по времени 6с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Дан пустой граф из N вершин, в который по очереди добавляется M ребер. После каждого добавление требуется вывести количество компонент связности в графе. Вершины нумеруются от 1 до N.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит N и M. Следующие M строк содержат пары чисел (uᵢ, vᵢ), которые описывают пару соединяемых вершин. 1 ≤ N ≤ 10⁶, 1 ≤ M ≤ 10⁶, 1 ≤ uᵢ, vᵢ ≤ N.</p>

  <h4>Выходные данные</h4>
  <p>Вывести M строк, в каждой из которых записано число — количество компонент связности.</p>

  <details>
    <summary>Пример</summary>
<pre>
5 5
1 2
2 3
3 4
4 5
5 1
</pre>
<pre>
4
3
2
1
1
</pre>
  </details>
</article>


<!-- Задача B. Дереливо -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Дереливо</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У вас есть n вершин и список из m ребер. Назовем префиксом списка его первые k элементов. Найдите наибольший(по длине) префикс списка ребер, который образует лес(если взять в граф только эти ребра).</p>

  <h4>Входные данные</h4>
  <p>В первой строчке два числа n (1 ≤ n ≤ 5*10⁶) и m (1 ≤ m ≤ 10⁶). В следующих m строчках заданы ребра.</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно число - размер наибольшего префикса.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
7 9
1 2
2 3
1 4
7 5
7 6
4 7
1 2
1 4
2 7
</pre>
    <code>6</code>

    <h4>Пример 2</h4>
<pre>
3 3
1 2
1 1
1 2
</pre>
    <code>1</code>
  </details>
</article>


<!-- Задача C. Крускал -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Крускал</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Напишите Крускала, пожалуйста.</p>

  <p>Для заданного взвешенного неориентированного графа с N вершинами и M рёбрами найдите его минимальное остовное дерево.</p>

  <h4>Входные данные</h4>
  <p>В первой стоке даны 2 числа N и M - число вершин и рёбер в заданном графе. (2 ≤ N ≤ 2⋅10⁵, 1 ≤ M ≤ min(2⋅10⁵, N*(N-1)/2) ). В следующих M строках вводятся тройки чисел ui, vi, wi - обозначающее ребро из вершины uᵢ в vᵢ с весом wᵢ. Веса рёбер положительные и не превышают 10⁴</p>

  <h4>Выходные данные</h4>
  <p>В первой строке выходных данных выведите суммарный вес ребер в минимальном остовном дереве. В следующих N-1 строках выведите через пробел пары чисел uᵢ vᵢ - рёбра полученного дерева.</p>

  <p>Если ответов несколько - выведите любой.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
4 6
1 2 4
2 3 1
3 4 8
1 4 2
1 3 3
2 4 7
</pre>
<pre>
6
2 3
1 4
1 3
</pre>

    <h4>Пример 2</h4>
<pre>
3 2
1 2 1
2 3 2
</pre>
<pre>
3
1 2
2 3
</pre>

    <h4>Пример 3</h4>
<pre>
4 6
1 2 1
2 3 1
3 4 1
1 4 1
1 3 1
2 4 1
</pre>
<pre>
3
1 2
1 3
1 4
</pre>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ускорение ввода и вывода
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

  // ввод данных
  int n, m;
  cin >> n >> m;
  vector&lt;pair&lt;long long, pair&lt;int, int&gt; &gt; &gt; A(m);
  for (int i = 0; i &lt; m; i++) {
    cin >> A[i].second.first >> A[i].second.second >> A[i].first;
  }

  // решение
  sort(A.begin(), A.end());
  vector&lt;int> Putty(n + 1), Count_elem(n + 1);
  for (int i = 1; i &lt;= n; i++) {
    Count_elem[i] = 1;
    Putty[i] = i;
  }
  int sum = 0, elem1, elem2;
  vector&lt;pair&lt;int, int&gt; &gt; Res;

  for (int i = 0; i &lt; A.size(); i++) {
    elem1 = A[i].second.first;
    elem2 = A[i].second.second;

    while (elem1 != Putty[elem1]) {
      elem1 = Putty[elem1];
    }
    while (elem2 != Putty[elem2]) {
      elem2 = Putty[elem2];
    }

    if (elem1 != elem2) {
      sum += A[i].first;
      Res.push_back(A[i].second);
      if (Count_elem[elem1] > Count_elem[elem2]) {
        Count_elem[elem1] += Count_elem[elem2];
        Putty[elem2] = elem1;
      } else {
        Count_elem[elem2] += Count_elem[elem1];
        Putty[elem1] = elem2;
      }
    }
  }

  // вывод результата
  cout &lt;&lt; sum &lt;&lt; '\n';
  for (int i = 0; i &lt; Res.size(); i++) {
    cout &lt;&lt; Res[i].first &lt;&lt; " "
         &lt;&lt; Res[i].second &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача D. Лаксурк -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Лаксурк</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Для заданного взвешенного неориентированного графа с N вершинами и M рёбрами найдите его остовное дерево с минимальным произведением весов рёбер. Произведение рёбер выведите по модулю 10⁹+7, так как оно может быть очень большим.</p>

  <h4>Входные данные</h4>
  <p>В первой стоке даны 2 числа N и M - число вершин и рёбер в заданном графе. (2 ≤ N ≤ 2⋅10⁵, 1 ≤ M ≤ min(2⋅10⁵, N*(N-1)/2) ). В следующих M строках вводятся тройки чисел uᵢ, vᵢ, wᵢ - обозначающее ребро из вершины uᵢ в vᵢ с весом wᵢ. Веса рёбер положительные и не превышают 10⁴</p>

  <h4>Выходные данные</h4>
  <p>В первой строке выходных данных выведите произведение рёбер в остовном дереве с минимальным произведением весов рёбер. Произведение рёбер выведите по модулю 10⁹+7, так как оно может быть очень большим. В следующих N-1 строках выведите через пробел пары чисел uᵢ vᵢ - рёбра полученного дерева.</p>
  <p>Если ответов несколько - выведите любой.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
4 6
1 2 4
2 3 1
3 4 8
1 4 2
1 3 3
2 4 7
</pre>
<pre>
6
2 3
1 4
1 3
</pre>

    <h4>Пример 2</h4>
<pre>
3 2
1 2 1
2 3 2
</pre>
<pre>
2
1 2
2 3
</pre>

    <h4>Пример 3</h4>
<pre>
4 6
1 2 1
2 3 1
3 4 1
1 4 1
1 3 1
2 4 1
</pre>
<pre>
1
1 2
1 3
1 4
</pre>
  </details>
</article>


<!-- Задача E. Сетевое подключение -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Сетевое подключение</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Андрей работает системным администратором и планирует провести новую сеть в его компании. В компании N компьютеров (узлов), и любые два могут быть подключены друг к другу кабелем. Так как каждому работнику компании должен быть предоставлен доступ ко всей сети, то у любого узла должен быть доступ к любому другому через кабели (возможно через промежуточные узлы в сети).</p>

  <p>Чем короче длина кабеля, тем он дешевле, и важно составить такой план соединения узлов, чтобы максимальная длина одного кабеля была как можно меньше. Есть еще одна проблема: не любые два узла могут быть подключены кабелем в силу проблем совместимости узлов и геометрических ограничений постройки офисного здания. Андрей предоставит вам всю необходимую информацию о возможностях подключения двух узлов.</p>

  <p>Андрей просит вашей помощи составить такой план соединения узлов, что все перечисленные выше условия - выполняются.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит два числа: N - число узлов в сети (2 ≤ N ≤ 1000) и M - число возможных подключений в сети (1 ≤ M ≤ 15000). Все узлы пронумерованы от 1 до N. В последующих M строках содержится информация о возможных подключениях - номера двух узлов, которые могут быть соединены кабелем и длина кабеля, требуемая для их соединения. Длина — положительное целое число, которое не превышает 10⁶. Гарантируется, что никакие 2 узла нельзя соединить более чем 1 кабелем напрямую и узел не может быть подключен к самому себе. Также гарантируется что существует хотя бы 1 возможный способ соединить все узлы в одну сеть.</p>

  <h4>Выходные данные</h4>
  <p>В первой строке выведите длину самого длинного кабеля в вашем плане сетевого подключения (не забудьте, что эту величину необходимо минимизировать).</p>

  <p>Далее выведите свой план сети: сначала выведите число P - число кабелей которое используется, далее в следующих P строках выведите пары чисел через пробел - номера узлов соединенных кабелем.</p>

  <details>
    <summary>Пример</summary>
<pre>
4 6
1 2 1
1 3 1
1 4 2
2 3 1
3 4 1
2 4 1
</pre>
<pre>
1
4
1 2
1 3
2 3
3 4
</pre>
  </details>
</article>


<!-- Задача F. Чаепитие -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Чаепитие</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Долина Замков была вся освещена лучами полуденного солнца. На балконе одного из Замков можно было рассмотреть две фигуры — большую и маленькую. Дракон и Принцесса пили чай. Поскольку Дракон увлекался составлением чаёв, он был чрезвычайно рад, что Принцесса с удовольствием пьёт чай и охотно слушает его рассказы о том, как получился тот или иной напиток.</p>

  <p>Дракон всегда кладёт в чайник m чайных ложек ингредиентов, которые называет долями. При этом, если в рецепте записано «положить две доли чёрного цейлонского чая, добавить одну долю листьев смородины, одну долю цветков василька, а после положить ещё одну долю чёрного цейлонского чая и долю лепестков календулы», то он будет делать всё точно в таком порядке — поскольку совершенно уверен, что вкус чая зависит от порядка добавления ингредиентов.</p>

  <p>Дракон рассказал Принцессе, что когда-то давно один знакомый Рыцарь поделился с ним рецептом очень вкусного чая, и с тех пор он, Дракон, стал пробовать составлять новые чаи. В этом очень вкусном чае он попытался заменить некоторые ингредиенты другими, а когда результат ему вновь понравился — записал новый рецепт. Так он поступал много раз, каждый раз выбирая в качестве основы один из уже записанных рецептов.</p>

  <p>У Дракона своя система составления и записи рецепта чая. Он обозначил все используемые им ингредиенты строчными символами латинского алфавита (каждому ингредиенту соответствует свой символ). Таким образом, описание чая — это строка из m символов, записанных в том порядке, в котором соответствующие им ингредиенты перечислены в рецепте Дракона.</p>

  <p>При выборе обозначений Дракон полагал, что более похожие (с его точки зрения) ингредиенты должны быть обозначены более близко расположенными в алфавите символами. Действительно, заменить листья смородины листьями ежевики куда менее радикальное решение, чем заменить лепестки календулы корицей. Поэтому он определил «расстояние между рецептами» как максимальное (по абсолютной величине) расстояние между ингредиентами, указанными в рецептах на одинаковых позициях.</p>

  <p>Дракон записывает рецепт каждого чая на отдельном листке и хранит все эти листки в чайной шкатулке. Поэтому совершенно точно узнать, каким было максимальное расстояние между рецептами в процессе составления всех видов чая, уже не получится. Однако Дракон уверяет, что это максимальное расстояние было минимально возможным.</p>

  <p>Ваша задача — по заданным описаниям n видов чая определить минимальное значение максимально возможного расстояния между рецептами, которое могло возникнуть в ходе их составления.</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержатся целые числа n и m (2 ≤ n ≤ 1000, 1 ≤ m ≤ 30) — количество рецептов и количество ингредиентов в каждом рецепте.</p>

  <p>В каждой из следующих n строк содержится по одному рецепту — строке из m символов. Гарантируется, что все рецепты различны.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное целое число — минимальное значение максимально возможного расстояния между рецептами, которое могло возникнуть в ходе их составления.</p>

  <details>
    <summary>Пример</summary>
<pre>
5 2
fb
ga
ef
dc
fd
</pre>
  <code>2</code>

    <p>Поясним приведённый пример.</p>

    <p>Предположим, что рецептом самого вкусного чая был первый рецепт (fb). Несложно заметить, что расстояние до рецепта второго чая (ga) составляет единицу. Очевидно, что это минимально возможное расстояние между разными рецептами, и можно считать, что второй рецепт был получен непосредственно из первого.</p>

    <p>Четвёртый рецепт (dc) отстоит от первого рецепта на расстояние 2; также на расстояние 2 от четвёртого рецепта отстоит пятый рецепт (fd). Можно полагать, что Дракон взял за основу первый рецепт, получил из него четвёртый, а затем из четвёртого — пятый.</p>

    <p>Наконец, третий рецепт (ef) мог быть получен из пятого рецепта (fd); расстояние между ними составит 2.</p>

    <p>Таким образом, Дракон может получить все перечисленные рецепты чая таким образом, что расстояние между рецептами никогда не будет превосходить 2.</p>
  </details>
</article>


<!-- Задача G. Пингвин-Авиа -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Пингвин-Авиа</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Авиакомпания Пингвин-Авиа, как и многие другие антарктические авиакомпании, испытывает финансовые трудности в период мирового экономического кризиса. Жители Антарктиды теперь экономят на полётах и чаще пользуются поездами или вообще предпочитают сидеть дома. Руководство авиакомпании надеется, что летом поток клиентов возрастёт за счёт желающих отдохнуть на приморских курортах Антарктиды. Чтобы дотянуть до лета, было решено оптимизировать схему авиарейсов, временно сократив часть рейсов и, возможно, введя несколько новых.</p>

  <p>Директор Пингвин-Авиа считает, что после оптимизации схема полётов должна обладать следующими свойствами:</p>
  <ol>
    <li>Рейсами Пингвин-Авиа можно добраться из любого аэропорта Антарктиды до любого другого. Возможно, для этого придётся сделать несколько пересадок.</li>
    <li>Схема должна содержать минимальное число рейсов среди всех схем, отвечающих первому свойству.</li>
  </ol>

  <p>Но в Антарктиде не всё так просто. За отмену существующего рейса с авиакомпании взимается разовая неустойка в размере d антарктических долларов. Кроме того, чтобы получить слоты под новый рейс, надо дать взятку крёстному отцу антарктической мафии по прозвищу Белый медведь в размере a антарктических долларов.</p>

  <p>Помогите директору Пингвин-Авиа трансформировать существующее расписание полётов, потратив при этом наименьшую сумму денег, и вы получите за это проездной билет на все рейсы авиакомпании.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое число n — количество аэропортов в Антарктиде, 2 ≤ n ≤ 100. Во второй строке через пробел записаны целые числа d и a, 1 ≤ d, a ≤ 10⁶. В следующих n строках записана существующая схема полётов Пингвин-Авиа в виде матрицы размером n x n. В ячейке (i,j) матрицы стоит единица, если авиакомпания совершает рейс между аэропортами i и j. В противном случае в ячейке стоит нуль. Гарантируется, что матрица симметрична и на её диагонали стоят нули.</p>

  <h4>Выходные данные</h4>
  <p>В первой строке выведите наименьшую сумму денег, которую придётся потратить для оптимизации существующей схемы полётов. Во второй выведите 2 числа - количество новых рейсов и количество отмены старых.</p>

  <details>
    <summary>Пример</summary>
<pre>
6
2 3
011000
101000
110000
000011
000101
000110
</pre>
<pre>
7
1 2
</pre>
  </details>
</article>


<!-- Задача H. Паутина Ананси -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Паутина Ананси</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Усатый-Полосатый XIII решил отомстить Ананси за освобождение бабочек, разрушив дом Ананси — его паутину. Паутина состоит из N узлов, некоторые из которых соединены нитями. Будем говорить, что два узла принадлежат одному кусочку, если от одного узла до другого можно добраться по нитям паутины. Усатый-Полосатый уже решил, какие нити и в каком порядке он будет рвать, и теперь хочет узнать, на сколько кусочков будет распадаться паутина после каждого из его действий.</p>

  <h4>Входные данные</h4>
  <p>В первой строке через пробел записаны числа N и M — количество узлов и нитей в паутине (2 ≤ N ≤ 100000; 1 ≤ M ≤ 100000). В каждой из следующих M строк через пробел записаны два различных числа — номера узлов, которые соединяет очередная нить. Узлы занумерованы числами от 1 до N, нити занумерованы числами от 1 до M в том порядке, в котором они перечислены. Далее записано число Q — количество нитей, которое собирается порвать Усатый-Полосатый (1 ≤ Q ≤ M). В последней строке записаны номера этих нитей — различные числа, отделяемые друг от друга пробелом.</p>

  <h4>Выходные данные</h4>
  <p>Выведите через пробел Q чисел — число кусочков, из которых будет состоять паутина Ананси после каждого обрыва нити.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
4 4
1 2
2 3
1 3
3 4
3
2 4 3
</pre>
    <code>1 2 3</code>

    <h4>Пример 2</h4>
<pre>
3 1
1 2
1
1
</pre>
    <code>3</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>После каждого разрыва нити, количество компонент связности или остается прежним или увеличивается на 1. Но считать компоненты связности после каждого разрыва, это слишком долго. Вместо того чтобы разрывать нити, мы пойдем в обратном порядке и будем их объединять. Алгоритм СНМ не умеет разрывать ребра, зато он хорошо их объединяет.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ускорение ввода и вывода
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

  // ввод данных
  int n, m;
  cin >> n >> m;
  vector&lt;pair&lt;int, int&gt; &gt; A(m + 1);
  for (int i = 1; i &lt;= m; i++) {
    cin >> A[i].first >> A[i].second;
  }
  int q;
  cin >> q;

  // решение
  vector&lt;int&gt; B(q), Used(m + 1);
  for (int i = 0; i &lt; q; i++) {
    cin >> B[i];
    Used[B[i]] = 1;
  }
  vector&lt;int&gt; Count_elem(n + 1), Putty(n + 1);
  for (int i = 1; i &lt;= n; i++) {
    Count_elem[i] = 1;
    Putty[i] = i;
  }
  int count_comp = n;

  for (int i = 1; i &lt;= m; i++) {
    if (Used[i] == 0) {
      int h = A[i].first;
      int g = A[i].second;
      while (h != Putty[h]) {
        h = Putty[h];
      }
      while (g != Putty[g]) {
        g = Putty[h];
      }
      if (h != g) {
        count_comp--;
        if (Count_elem[h] > Count_elem[g]) {
          Count_elem[h] += Count_elem[g];
          Putty[g] = h;
        } else {
          Count_elem[g] += Count_elem[h];
          Putty[h] = g;
        }
      }
    }
  }

  vector&lt;int&gt; res;
  for (int i = q - 1; i >= 0; i--) {
    res.push_back(count_comp);
    int h = A[B[i]].first;
    int g = A[B[i]].second;
    while (h != Putty[h]) {
      h = Putty[h];
    }
    while (g != Putty[g]) {
      g = Putty[h];
    }
    if (h != g) {
      count_comp--;
      if (Count_elem[h] > Count_elem[g]) {
        Count_elem[h] += Count_elem[g];
        Putty[g] = h;
      } else {
        Count_elem[g] += Count_elem[h];
        Putty[h] = g;
      }
    }
  }

  // в векторе res хранится ответ
  // в обратном порядке

  // вывод результата
  for (int i = res.size() - 1; i >= 0; i--) {
    cout &lt;&lt; res[i] &lt;&lt; " ";
  }
}
</pre>
  </details>
</article>


<!-- Задача I. Перемешивание колоды -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача I. Перемешивание колоды</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Ученый с мировым именем Иннокентий продолжает свои инновационные эксперименты с колодами карт. Теперь у него есть колода из n карт и k шаффл-машин для перемешивания этой колоды. Как мы знаем, i-ая шаффл-машина характеризуется своими собственными числами pi, 1, pi, 2, ..., pi, n, такими, что если положить в нее n карт, занумерованных по порядку 1, 2, ..., n, и нажать на машине кнопку, то карты будут перемешаны таким образом, что образуется колода pi, 1, pi, 2, ..., pi, n, где числа pi, 1, pi, 2, ..., pi, n — это те же номера карт, но переставленные в некотором порядке шаффл-машиной.</p>

  <p>В начале эксперимента карты в колоде располагаются в порядке a1, a2, ..., an, т.е. на первом месте находится карта с номером a1, на втором — карта с номером a2, и т.д. Ученый хочет сделать так, чтобы карта с номером x была на первом месте. Он может использовать все свои шаффл-машины столько раз, сколько ему захочется. Выясните, получится ли у него добиться желаемого результата.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано единственное натуральное число n — количество карт в колоде Иннокентия.</p>

  <p>Во второй строке записаны n различных натуральных чисел a1, a2, ..., an (1 ≤ ai ≤ n) — первоначальное расположение карт в колоде.</p>

  <p>В третьей строке записано единственное натуральное число k — количество шаффл-машин, имеющихся у ученого.</p>

  <p>В каждой из следующих k строк записаны n различных натуральных чисел pi, 1, pi, 2, ..., pi, n (1 ≤ pi, j ≤ n), характеризующих соответствующие шаффл-машины.</p>

  <p>В последней строке записано единственное натуральное число x (1 ≤ x ≤ n) — номер карты, которую Иннокентий желает видеть на первом месте в колоде.</p>

  <p>Числа n и k удовлетворяют соотношению 1 ≤ n·k ≤ 200000.</p>

  <h4>Выходные данные</h4>
  <p>Выведите «YES», если ученый сможет добиться того, чтобы карта с номером x встала на первое место, и «NO» иначе.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
4
4 3 2 1
2
1 2 4 3
2 3 1 4
1
</pre>
    <code>YES</code>

    <h4>Пример 2</h4>
<pre>
4
4 3 2 1
2
1 2 4 3
2 1 3 4
1
</pre>
    <code>NO</code>
  </details>
</article>


<!-- Задача J. Electrician -->
<article class="article">
  <div class="anchor" id="task10"></div>
  <h3>Задача J. Electrician</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 64мб</i></div>

  <p>An electrician Vasya has got an assignment to solder n wires. His boss specified the requirements precisely, so for each wire Vasya knows exactly where its endpoints should be soldered to. Two identifiers aᵢ, bᵢ are given for each wire, meaning that one endpoint of the wire should be soldered to the place aᵢ, and the other endpoint should be soldered to the place bᵢ. It doesn't matter which endpoint will be soldered to which place. Also each wire has two more characteristics rᵢ and pᵢ, where rᵢ is its reliability and pᵢ is its cost.</p>

  <p>The only way for Vasya to express himself in such a rigorous constraints is to choose an order, and solder all wires in this order, one after another. As an experienced electrician Vasya knows what a short circuit is — it occurs when a scheme contains a cycle, in other words when there is more than one simple path over wires from one place to another. So, if a short circuit occurs after a wire is soldered, the least reliable wire in the cycle burns out (you may think that the least reliable wire disappears from the scheme). If there are several least reliable wires in the cycle, the one of them which was soldered earlier burns out. It is clear that after a wire burns out, the scheme doesn't have any cycles.</p>

  <p>When Vasya is done with soldering, he ends up with a scheme of soldered wires. So, he wants to solder all wires in such an order, that the total cost of wires in a resulting scheme will be as maximal as possible.</p>

  <h4>Input</h4>
  <p>The first line of input contains a single integer n (1 ≤ n ≤ 30000). Each of the following n lines contains four integer numbers aᵢ, bᵢ, rᵢ, pᵢ (1 ≤ aᵢ, bᵢ, rᵢ, pᵢ ≤ 10⁹; aᵢ ≠ bᵢ), where aᵢ and bᵢ are identifiers of the places for endpoints of i-th wire, rᵢ is the reliability of the wire, and pᵢ is the cost of the wire. There can be more than one wire between any pair of places.</p>

  <h4>Output</h4>
  <p>Print the required maximal total cost to the first line of output. Print the order of wires for soldering to the second line, delimiting wire indices with a single space.</p>

  <p>You may print any solution if there are many of them.</p>

  <details>
    <summary>Пример</summary>
<pre>
4
10 20 5 3
20 11 5 2
10 11 7 1
1 2 1 1
</pre>
<pre>
5
2 3 1 4
</pre>
    <p>In the sample test Vasya can choose any order with the only rule: the second wire should be soldered before the first one. If he violates the rule, the total cost will be 4 instead of 5.</p>
  </details>
</article>


<!-- Задача K. Пчелыыыыыыыы -->
<article class="article">
  <div class="anchor" id="task11"></div>
  <h3>Задача K. Пчелыыыыыыыы</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 1024мб</i></div>

  <p>У вас есть сотыыыыыыыы(табличка N x M из шестиугольников). Вам надо проложить систему медовых рек, соединяющие все ячейки. Разумеется, отрезок медовой речной системы может соединять только ячейки, граничащие по стороне. Чтобы пустить медовые реки, необходима валерьяна, а поскольку добывается она непосильным трудом аДмина и Влада, необходимо построить медовый канал так, чтобы для этого потребовалось как можно меньше валерьяны.</p>

  <p>Количество валерьяны, необходимое для заполнения канала между 2 соседними ячейками, вычисляется по довольно интересной формуле: (x1x2 + p1y1y2) mod p2, где x1; x2; y1; y2 — координаты первой и второй ячейки, а p1p2 - простые числа. Первая координата обозначает номер ряда, в котором находится ячейка, а вторая — номер ячейки в этом ряду. При этом соседними для ячейки (x; y) будут такие ячейки: (x; y - 1), (x; y + 1), (x - 1; y - 1), (x - 1; y), (x + 1; y), (x + 1; y + 1).</p>

  <h4>Входные данные</h4>
  <p>Входной файл состоит из 4 целых чисел N, M, p1 и p2 (1 ≤ N;M ≤ 2222; 1 ≤ p1; p2 ≤ 10⁹ + 9).</p>

  <h4>Выходные данные</h4>
  <p>Выведите сколько потребуется валерьяны.</p>

  <details>
    <summary>Пример</summary>
    <code>3 3 11 23</code>
    <code>28</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Нужно пройти по всей матрице, собрать все существующие ребра, запихнуть их в vector, посчитать их по формуле из условия задачи и построить минимальное остовное дерево.</p>
    <p>В оригинальной задаче СПбГУ, параметр p2 до 1000 и этим можно пользоваться. Можно не сортировать вектор A. Потому что это самая трудоемкая часть кода. Вектор ребер записываем в вектор векторов, где каждая ячейка отвечает за размер ребра. И в соответствующей строке располагаются все ребра нужной длины.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

// добавление ребра в вектор A
void Step(vector&lt;pair&lt;long long, pair&lt;pair&lt;int, int&gt;, pair&lt;int, int&gt; &gt; &gt; &gt; &A,
  pair&lt;int, int&gt; tmp_first, pair&lt;int, int&gt; tmp_second,
  long long p1, long long p2) {

  pair&lt;long long, pair&lt;pair&lt;int, int&gt;, pair&lt;int, int&gt; &gt; &gt; buf;
  long long value;

  value = (tmp_first.first * tmp_second.first +
    p1 * tmp_first.second * tmp_second.second) % p2;
  buf.first = value;
  buf.second.first = tmp_first;
  buf.second.second = tmp_second;
  A.push_back(buf);
}

int main() {
  // ускорение ввода и вывода
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

  // ввод данных
  long long n, m, p1, p2;
  cin >> n >> m >> p1 >> p2;

  // решение
  vector&lt;vector&lt;int&gt; &gt; G_count(n + 1, vector&lt;int&gt;(m + 1));
  vector&lt;vector&lt;pair&lt;int, int&gt; &gt; &gt; G_putty(n + 1, vector&lt;pair&lt;int, int&gt; &gt;(m + 1));

  for (int i = 1; i &lt;= n; i++) {
    for (int j = 1; j &lt;= m; j++) {
      G_count[i][j] = 1;
      G_putty[i][j] = make_pair(i, j);
    }
  }

  // A - ребра. вес ребра, координаты первой и второй вершины
  vector&lt;pair&lt;long long, pair&lt;pair&lt;int, int&gt;, pair&lt;int, int&gt; &gt; &gt; &gt; A;

  // каждая вершина имеет 6 ребер
  // проходя по вершинам будем учитывать только три
  // ребра - правое, нижнее левое и нижнее правое
  // соберем все ребра в векторе A
  for (int i = 1; i &lt;= n; i++) {
    for (int j = 1; j &lt;= m; j++) {
      // текущая вершина
      pair&lt;int, int&gt; tmp_first = make_pair(i, j);
      // соседняя вершина
      pair&lt;int, int&gt; tmp_second;

      // сосед справа
      tmp_second = make_pair(i, j + 1);
      // если сосед существует
      if (j != m) {
        Step(A, tmp_first, tmp_second, p1, p2);
      }

      // сосед снизу слева
      tmp_second = make_pair(i + 1, j);
      // если сосед существует
      if (i != n) {
        Step(A, tmp_first, tmp_second, p1, p2);
      }

      // сосед снизу справа
      tmp_second = make_pair(i + 1, j + 1);
      // если сосед существует
      if (i != n && j != m) {
        Step(A, tmp_first, tmp_second, p1, p2);
      }

    }
  }

  sort(A.begin(), A.end());
  long long result = 0;

  // алгоритм СНМ
  for (int i = 0; i &lt; A.size(); i++) {
    pair&lt;int, int&gt; tmp_first = A[i].second.first;
    pair&lt;int, int&gt; tmp_second = A[i].second.second;

    while (tmp_first != G_putty[tmp_first.first][tmp_first.second]) {
      tmp_first = G_putty[tmp_first.first][tmp_first.second];
    }

    while (tmp_second != G_putty[tmp_second.first][tmp_second.second]) {
      tmp_second = G_putty[tmp_second.first][tmp_second.second];
    }

    if (tmp_first != tmp_second) {
      result += A[i].first;
      if (G_count[tmp_first.first][tmp_first.second] >
        G_count[tmp_second.first][tmp_second.second]) {
        G_count[tmp_first.first][tmp_first.second] +=
          G_count[tmp_second.first][tmp_second.second];
        G_putty[tmp_second.first][tmp_second.second] = tmp_first;
      } else {
        G_count[tmp_second.first][tmp_second.second] +=
          G_count[tmp_first.first][tmp_first.second];
        G_putty[tmp_first.first][tmp_first.second] = tmp_second;

      }
    }
  }

  // вывод результата
  cout &lt;&lt; result;
}
</pre>
  </details>
</article>


<!-- Задача L. Гы гы гы(гы гы) -->
<article class="article">
  <div class="anchor" id="task12"></div>
  <h3>Задача L. Гы гы гы(гы гы)</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>ГыгыГЫгыЫЫггЫЫгыгыгы...</p>

  <p>Вам даны гы-граф из n гы-вершин и m гы-запросов. Гы-запросы бывают 3 гы-типов:</p>
  <ol>
    <li>Добавить гы-ребро между a гы-вершиной и b гы-вершиной.</li>
    <li>Проверить что от гы-вершины a до гы-вершины b есть гы-путь.</li>
    <li>Удалить последние k гы-ребер(если их меньше то удаляется все).</li>
  </ol>

  <p>После каждого гы-запроса 2 гы-типа выведите гы-ответ.</p>

  <h4>Входные данные</h4>
  <p>В первой строчке два числа n (1 ≤ n ≤ 5*10⁶) и m (1 ≤ 2*10⁵) - количество гы-вершин и гы-запросов. В следующих m гы-строчках находятся гы-запросы. Запросы имеют вид 1 a b - запрос первого типа, 2 a b - запрос второго типа, 3 k (1 ≤ k ≤ 10⁶) - запрос 3 типа.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого гы-запросы 2 гы-типа выведите в отдельной гы-строчке гы-ответ.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
4 9
1 1 2
1 2 3
1 3 4
2 1 4
3 2
2 1 4
1 1 4
3 100
2 1 4
</pre>
<pre>
Yes
No
No
</pre>

    <h4>Пример 2</h4>
<pre>
4 5
1 1 2
1 1 2
1 1 2
3 2
2 1 2
</pre>
<pre>
Yes
</pre>

    <h4>Пример 3</h4>
<pre>
4 12
1 1 2
1 3 4
1 1 3
2 1 3
2 2 3
2 1 4
2 2 4
3 1
2 1 3
2 2 3
2 1 4
2 2 4
</pre>
<pre>
Yes
Yes
Yes
Yes
No
No
No
No
</pre>
  </details>
</article>

