<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contests" target="_blank">Codeforces ЯрГУ. Школьники</a></p>
  <p><a href="https://vk.com/sportprog_yarsu" target="_blank">vk.com/sportprog_yarsu</a></p>
  <p><a href="https://vkvideo.ru/@sportprog_yarsu" target="_blank">vkvideo.ru/@sportprog_yarsu</a></p>
</article>


<article class="article">
  <h1>Занятие 22 Графы #4. Алгоритм Дейкстры</h1>
  <p>Конспект видео от 2025.02.22</p>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contest/590577" target="_blank">Codeforces Контест 590577</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
    <a href="#p1">Графы #4. Алгоритм Дейкстры</a>
  </p>
  <p>
        <a href="#task1">Задача A. Минимальная стоимость проезда</a>
    <br><a href="#task2">Задача B. Заправки</a>
    <br><a href="#task3">Задача C. Поездка в город</a>
    <br><a href="#task4">Задача D. Хороший день</a>
    <br><a href="#task5">Задача E. Алгоритм Дейкстры</a>
    <br><a href="#task6">Задача F. Дима и Влад едут Домой</a>
    <br><a href="#task7">Задача G. Везёт. Не везёт</a>
    <br><a href="#task8">Задача H. Дождь</a>
    <br><a href="#task9">Задача I. Ракетные шахты</a>
    <br><a href="#task10">Задача J. Волейбол</a>
    <br><a href="#task11">Задача K. Тайная лаборатория</a>
    <br><a href="#task12">Задача L. Дайте людям рому</a>
    <br><a href="#task13">Задача M. Дороги в Берляндии</a>
    <br><a href="#task14">Задача N. Егор и граф</a>
    <br><a href="#task15">Задача O. Jzzhu и города</a>
    <br><a href="#task16">Задача P. Планеты</a>
  </p>
</article>


<!-- Графы #4. Алгоритм Дейкстры -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Графы #4. Алгоритм Дейкстры</h3>

  <p>Алгоритм Дейкстры решает крайне популярную задачу: определить кратчайший путь между вершинами start и finish. При построении мы можем запоминать пути от вершины start до всех вершин для восстановления путей.</p>
  <p>Рис.: 1 Неориентированный взвешенный граф</p>

  <p>В качестве начальной вершины start возьмём вершину под номером 1, за вершину finish возьмём вершину 7, тогда кратчайший путь из вершины start в вершину finish будет иметь длину 9. Продемонстрируем кратчайший путь как набор последовательно посещенных вершин: 1 → 4 → 8 → 7. Отметим, что существует еще один кратчайший путь: 1 → 4 → 6 → 7.</p>
  <p>На рис. 1 мы видим изолированную вершину под номером 9. Алгоритм Дейкстра не посетит данную вершину.</p>
  <p>Алгоритм имеет две версии реализации с разными асимптотиками решения, которые подходят под разные ситуации. Рассмотрим каждую реализацию отдельно. Школьная версия работает за O(n² + m). Студенческая версия работает за O(mlog₂(m)) и использует структуру даных set.</p>

  <h4>Алгоритм Дейкстры O(n² + m)</h4>

  <p>Пусть у нас есть взвешенный граф, не имеющий ребер отрицательного веса, перед нами стоит задача найти кратчайший путь между вершиной start и finish.</p>
  <p>Найдем кратчайшие расстояния до всех достижимых вершин из вершины start. Будем находить кратчайшие расстояния постепенно, итерациями релаксации, за каждую итерацию релаксации будем находить кратчайший путь ровно до одной вершины:</p>
  <ol>
    <li>Будем искать в общем списке вершину, до которой еще не определяли кратчайший путь.</li>
    <li>Найдя нужную нам вершину, фиксируем, что мы ее посетили и записали до нее длину кратчайшего пути.</li>
    <li>Пересчитаем длину пути для всех ее смежных вершин.</li>
    <li>Повторяем итерации релаксации, пока находим новые вершины.</li>
  </ol>

  <p>Приведем реализацию алгоритма в виде функции dijkstra. В аргументах функции dijkstra передается:</p>
  <ul>
    <li>vector &lt;vector&lt;pair&lt;int, int&gt; &gt; &gt; G — граф, представленный в виде списка смежности, где в каждой i строке каждая ячейка — это пара чисел first — вес ребра, second — номер вершины, с которой соединена вершина с номером i;</li>
    <li>vector&lt;int&gt;Mark — вектор посещаемости. Mark[i] равняется 1, если
      до вершины с номером i построен путь, иначе равняется 0. Изначально каждая вершина считается не посещенной;</li>
    <li>vector&lt;int&gt;Dist — вектор длин путей, Dist[i] будет равняться длине кратчайшего пути до вершины i. Изначально каждая ячейка хранит величину, заведомо превосходящую длину кратчайшего пути, или так называемую недостижимую величину;</li>
    <li>n — количество вершин в графе;</li>
    <li>start — вершина старта.</li>
  </ul>
<pre>
void dijkstra(vector&lt;vector&lt;pair&lt;int, int&gt; &gt; &gt;& G,
  vector&lt;int&gt;& Mark,
  vector&lt;int&gt;& Dist,
  int n,
  int start) {
  for (int i = 1; i &lt;= n; i++) {
    Dist[i] = 1e9;
    Mark[i] = 0;
  }

  Dist[start] = 0;
  int u = 0; d;

  for (int relax = 1; relax &lt;= n && u != -1; relax++) {
    u = -1, d = 1e9;
    for (int i = 1; i &lt; n; i++) {
      if (Mark[i] == 0 && Dist[i] &lt; d) {
        u = i;
        d = Dist[i];
      }
    }
    if (u != -1) {
      Dist[u] = d, Mark[u] = 1;
      for (int i = 0; i &lt;= G[u].size(); i++) {
        Dist[G[u][i].second] = min(Dist[G[u][i].second], G[u][i].first + Dist[u]);
      }
    }
  }
}
</pre>

  <h4>Алгоритм Дейкстры O(mlog₂(m))</h4>

  <p>Чаще всего при решении задач на поиск кратчайшего пути можно улучшить реализацию при помощи структур данных set или map и получить улучшенную трудоемкость O(mlog₂(m)).</p>
  <p>Пусть задача остается точно такой же: у нас есть взвешенный граф, не имеющий ребер с отрицательным весом, и перед нами стоит задача найти кратчайший путь между вершиной start и finish.</p>
  <p>Мы уже знаем реализацию алгоритма Дейкстра с асимптотикой O(n²). Допустим, в задаче есть дополнительное ограничение на ребра, количество ребер m достаточно маленькое, или можно считать, что граф сильно разреженный, например количество ребер в 10 раз больше, чем количество вершин n. Тогда можно ускорить поиск ближайшей непомеченной вершины.</p>
  <p>Опишем алгоритм Дейкстры со структурой данных set&lt;pair&lt;int, int&gt; &gt; Dist_st, в котором будем хранить пары first — длина пути, second — номер вершины.</p>
  <ol>
    <li>Добавляем в set вершину старта с расстоянием, равным нулю.</li>
    <li>Вытаскиваем из set величину с самым маленьким расстоянием и  удаляем элемент из set.</li>
    <li>Проверяем, что вершина, до которой мы определили путь, не была ранее посещена.</li>
    <li>При нахождении не посещенной вершины добавляем в set новые пути к смежным вершинам.</li>
    <li>Повторяем действия 2 - 4, пока set не окажется пуст.</li>
  </ol>

  <p>Приведем реализацию алгоритма в виде функции dijkstra_optimized. В аргументах функции dijkstra_optimized передается:</p>
  <ul>
    <li>vector&lt;vector&lt;pair&lt;int, int&gt; &gt; &gt; G — граф, представленный в виде
      списка смежности, где в каждой i строке каждая ячейка — это пара
      чисел: first — вес ребра, second — номер вершины, с которой соединена
      вершина с номером i.</li>
    <li>vector&lt;int&gt;Mark — вектор посещаемости. Mark[i] равняется 1, если
      до вершины с номером i построен путь, иначе равняется 0. Изначально
      каждая вершина считается не посещенной.</li>
    <li>vector&lt;int&gt;Dist — вектор длин путей, Dist[i] будет равняться длине
      кратчайшего пути до вершины i. Изначально каждая ячейка хранит
      величину, заведомо превосходящую длину кратчайшего пути, или так
      называемую недостижимую величину.</li>
    <li>n — количество вершин в графе.</li>
    <li>start — вершина старта.</li>
  </ul>
<pre>
void dijkstra_optimized(
  vector&lt;vector&lt;pair&lt;int, int&gt; &gt; &gt;& G,
  vector&lt;int&gt;& Mark,
  vector&lt;int&gt;& Dist,
  int n,
  int start) {
  for (int i = 1; i &lt;= n; i++) {
    Dist[i] = 1e9;
    Mark[i] = 0;
  }

  set&lt;pair&lt;int, int&gt; &gt;Dist_st;
  pair&lt;int, int&gt; tmp1, tmp2;
  tmp1.first = 0;
  tmp1.second = start;
  Dist_st.insert(tmp1);

  while (Dist_st.size() > 0) {
    tmp1 = *Dist_st.begin();

    if (Mark[tmp1.second] == 0) {
      Dist[tmp1.second] = tmp1.first;
      Mark[tmp1.second] = 1;

      for (int i = 0; i &lt; G[tmp1.second].size(); i++) {
        tmp2.second = G[tmp1.second][i].second;
        tmp2.first = tmp1.first + G[tmp1.second][i].first;
        Dist_st.insert(tmp2);
      }
    }
  }
}
</pre>
  <p>В задачах, где требуется восстановить обратный путь, структура данных становится более сложной, поскольку нам потребуется запоминать вершины, создающие последнее ребро в пути. Мы можем переделать set для запоминания последнего ребра, например следующим образом set&lt;pair&lt;int, pair&lt;int, int&gt; &gt; &gt;, где first — длина пути, second.first — номер вершины, в которую направляется путь, second.second — вершина, из которой мы пришли в вершину second.first. Сам путь мы сможем восстановить при помощи vector&lt;int&gt;Putty.</p>
<pre>
void dijkstra_optimized_save_path(
  vector&lt;vector&lt;pair&lt;int, int&gt; &gt; &gt;& G,
  vector&lt;int&gt;& Mark,
  vector&lt;int&gt;& Dist,
  vector&lt;int&gt;& Putty,
  int n,
  int start) {
  for (int i = 1; i &lt;= n; i++) {
    Dist[i] = 1e9;
    Mark[i] = 0;
  }

  set&lt;pair&lt;int, int&gt; &gt;Dist_st;
  pair&lt;int, pair&lt;int, int&gt; &gt; tmp1, tmp2;
  tmp1.first = 0;
  tmp1.second.first = start;
  tmp1.second.second = start;
  Dist_st.insert(tmp1);

  while (Dist_st.size() > 0) {
    tmp1 = *Dist_st.begin();
    Dist_st.erase(Dist_st.begin());

    if (Mark[tmp1.second.first] == 0) {
      Dist[tmp1.second.first] = tmp1.first;
      Mark[tmp1.second.first] = 1;
      Putty[tmp1.second.first] = tmp1.second.second;

      for (int i = 0; i &lt; G[tmp1.second.first].size(); i++) {
        tmp2.second.first = G[tmp1.second.first][i].second;
        tmp2.second.second = tmp1.second.first;
        tmp2.first = tmp1.first + G[tmp1.second.first][i].first;
        Dist_st.insert(tmp2);
      }
    }
  }
}
</pre>

  <h4>Важное замечание</h4>
  <p>Если сравнивать две реализации алгоритма Дейкстры, то на первый взгляд кажется, что алгоритм с трудоемкостью O(mlog₂(m)) лучше, однако это не всегда правда. Поскольку трудоемкость в реализациях зависит от разных параметров O(n² + m) и O(mlog₂(m)), существуют варианты задач, где реализация со структурами данных set будет хуже. Например, в задаче, где граф является полным или почти полным асимптотика O(mlog₂(m)) превращается в O(n² log₂(n²)).</p>
</article>


<!-- Задача A. Минимальная стоимость проезда -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Минимальная стоимость проезда</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>На прямой ветке железной дороги расположено несколько станций. Задана стоимость проезда между любыми двумя станциями.</p>

  <p>Требуется написать программу нахождения минимальной стоимости проезда между крайними станциями. Двигаться по железной дороге можно только в одном направлении (от станции с меньшим номером до станции с большим номером).</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных находится натуральное число N, не большее 250. Всего на дороге расположено N+1 станций, пронумерованных от 0 до N. В следующих строках записано N * (N + 1) / 2 чисел, задающих стоимости проезда между станциями: сначала стоимость проезда от станции 0 до станций 1, 2, 3, …, N, затем от станции 1 до станций 2, 3, ... , N, ... , от станции N - 1 до станции N. Все стоимости проезда – неотрицательные целые числа, не превосходящие 10000.</p>

  <details>
    <summary>Пример</summary>
<pre>
3
7 10 20
4 8
2
</pre>
    <code>12</code>
  </details>
</article>


<!-- Задача B. Заправки -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Заправки</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>В стране N городов, некоторые из которых соединены между собой дорогами. Для того, чтобы проехать по одной дороге требуется один бак бензина. В каждом городе бак бензина имеет разную стоимость. Вам требуется добраться из первого города в N-ый, потратив как можно меньшее количество денег.</p>

  <h4>Входные данные</h4>
  <p>Во входных данных записано сначала число N (1 ≤ N ≤ 100), затем идет N чисел, i-ое из которых задает стоимость бензина в i-ом городе (все числа целые из диапазона от 0 до 100). Далее идет число M - количество дорог в стране, далее идет описание самих дорог. Каждая дорога задается двумя числами - номерами городов, которые она соединяет. Все дороги двухсторонние (то есть по ним можно ездить как в одну, так и в другую сторону); между двумя городами всегда существует не более одной дороги; не существует дорог, ведущих из города в себя.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите одно число - суммарную стоимость маршрута или -1, если добраться невозможно.</p>

  <details>
    <summary>Пример</summary>
<pre>
4
1 10 2 15
4
1 2
1 3
4 2
4 3
</pre>
    <code>3</code>
  </details>
</article>


<!-- Задача C. Поездка в город -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Поездка в город</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Однажды команда преподавателей ЛКШ решила съездить в другой город. Но для переезда от города к городу необходимо заплатить определенное количество рублей. Но преподаватели люди умные и выбрали такой путь, за который заплатят меньше всего денег. И теперь они спрашивают вас сколько они заплатили денег, чтобы доехать в другой город.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записаны n и m ( 1 ≤ n ≤ 10⁵, 1 ≤ m ≤ min(n*(n-1)/2, 10⁵) ) - количество городов и количество дорог. Далее в m строках записаны пары городов между которыми есть дороги и цена проезда по данной дороге (цена проезда не превосходит 10⁹. В последней строке записаны два числа s и k ( 1 ≤ s ≤ n, 1 ≤ k ≤ n). Нужно попасть из вершины s  в вершину k.</p>

  <h4>Выходные данные</h4>
  <p>Вам, в единственной строке необходимо вывести сколько денег заплатят преподаватели.</p>

  <details>
    <summary>Пример</summary>
<pre>
4 5
1 2 6
1 3 10
2 3 8
2 4 8
3 4 6
2 3
</pre>
    <code>8</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Условие n*(n-1)/2 означает что граф может быть полным и хранить максимальное количество ребер. Здесь полный граф реализуется только если количество ребер меньше чем 10⁵, а это возможно при n меньше чем 1000. Это означает что реализация алгоритма Декстры сложностью O(mlogm) тоже будет подходить для полного графа с небольшим количеством вершин.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  int n, m;
  cin >> n >> m;
  vector&lt;vector&lt;pair&lt;long long, int&gt; &gt; &gt; G(n + 1);
  vector&lt;int&gt; Mark(n + 1);
  vector&lt;int&gt; Dist(n + 1);
  long long a, b, w;
  pair&lt;long long, int&gt; tmp1, tmp2;

  // соберем список смежности
  for (int i = 0; i &lt; m; i++) {
    cin >> a >> b >> w;
    tmp1.first = w;
    tmp1.second = a;
    G[b].push_back(tmp1);
    tmp1.second = b;
    G[a].push_back(tmp1);
  }

  // инициализация
  int s, k;
  cin >> s >> k;
  set&lt;pair&lt;long long, int&gt; &gt; st;
  tmp1.first = 0;
  tmp1.second = s;
  st.insert(tmp1);

  // алгоритм Дейкстры
  while (st.size() > 0) {
    tmp1 = *st.begin();
    st.erase(st.begin());
    if (Mark[tmp1.second] == 0) {
      Mark[tmp1.second] = 1;
      Dist[tmp1.second] = tmp1.first;
      for (int i = 0; i &lt; G[tmp1.second].size(); i++) {
        tmp2 = G[tmp1.second][i];
        tmp2.first += tmp1.first;
        st.insert(tmp2);
      }
    }
  }

  cout &lt;&lt; Dist[k];
}
</pre>
  </details>
</article>


<!-- Задача D. Хороший день -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Хороший день</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Денис был дома в районе номер 1 решил пробежаться по районам Майкопа до магазинов, которые находятся в близлежайших районах. Посетив определенный район всегда попадает в определенную ситуацию, повышая свой уровень злости на некоторое значение. Денис хочет не очень сильно разозлиться, поэтому он просит вас найти оптимальный (т.е. минимальное повышение злости) путь до магазина.</p>

  <h4>Входные данные</h4>
  <p>В первой строке 1 ≤ n ≤ 10⁵ и 1 ≤ m ≤ 10⁵ - количество районов Майкопа и количество дорог соединяющие районы. Во второй строке записаны n чисел - i-е число показывает насколько поднимется уровень злости при посещении i-ого района. Далее в m строках перечислены дороги в следующем формате: номера городов через пробел которые соединяет 1 дорога. В следующей строке записано число 1 ≤ q ≤ 10⁵ - количество магазинов, которые планирует посетить Денис. Далее в строке записаны номера районов в которых эти магазины расположены.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке вывести q чисел - минимальный уровень злости уровень злости, который будет у Дениса при посещении соответствующего магазина.</p>

  <details>
    <summary>Пример</summary>
<pre>
11 33
345 42 933 271 998 643 256 848 839 249 803
1 2
1 3
1 4
1 5
1 6
1 7
1 8
1 9
1 10
1 11
2 3
2 6
2 10
3 5
3 9
3 10
4 5
4 7
4 8
4 9
4 10
5 6
5 7
5 9
6 7
6 11
7 8
7 9
7 10
8 9
8 10
9 10
10 11
3
6 7 2
</pre>
    <code>643 256 42</code>
    <p>Нельзя повторно посещать район.</p>
  </details>
</article>


<!-- Задача E. Алгоритм Дейкстры -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Алгоритм Дейкстры</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Задан неориентированный взвешенный граф, вершины которого пронумерованы от 1 до n. Ваша задача найти кратчайший путь из вершины 1 в вершину n.</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержатся целые числа n и m (2 ≤ n ≤ 10⁵, 0 ≤ m ≤ 10⁵), где n — количество вершин, а m — количество ребер в графе. Далее в m строках содержатся сами ребра, по одному в строке. Каждое ребро задается тремя числами aᵢ , bᵢ , wᵢ (1 ≤ aᵢ , bᵢ ≤ n, 1 ≤ wᵢ ≤ 10⁶), где aᵢ , bᵢ — это концы ребра, а wᵢ — его длина.</p>

  <p>Граф может содержать кратные ребра и петли.</p>

  <h4>Выходные данные</h4>
  <p>Выведите число -1 если пути нет или сам кратчайший путь, если он существует.</p>

  <details>
    <summary>Пример</summary>
<pre>
5 6
1 2 2
2 5 5
2 3 4
1 4 1
4 3 3
3 5 1
</pre>
    <code>1 4 3 5</code>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  int n, m;
  cin >> n >> m;
  vector&lt;vector&lt;pair&lt;long long, pair&lt;int, int&gt; &gt; &gt; &gt; G(n + 1);
  vector&lt;int&gt; Mark(n + 1);
  vector&lt;long long&gt; Dist(n + 1, 1e18);
  vector&lt;int&gt; Putty(n + 1);
  long long a, b, w;
  set&lt;pair&lt;long long, pair&lt;int, int&gt; &gt; &gt; st;
  pair&lt;long long, pair&lt;int, int&gt; &gt; tmp1, tmp2;

  // соберем список смежности
  for (int i = 0; i &lt; m; i++) {
    cin >> a >> b >> w;
    tmp1.first = w;
    tmp1.second.first = a;
    tmp1.second.second = b;
    G[b].push_back(tmp1);
    tmp1.second.first = b;
    tmp1.second.second = a;
    G[a].push_back(tmp1);
  }

  // пройдем по первой строке
  // и выполним инициализацию стека
  for (int i = 0; i &lt; G[1].size(); i++) {
    tmp1 = G[1][i];
    st.insert(tmp1);
  }
  Mark[1] = 1;
  Dist[1] = 0;

  // алгоритм Дейкстры
  // находит все пути от вершины start
  while (st.size() > 0) {
    tmp1 = *st.begin();
    st.erase(st.begin());
    if (Mark[tmp1.second.first] == 0) {
        Mark[tmp1.second.first] = 1;
        Dist[tmp1.second.first] = tmp1.first;
        Putty[tmp1.second.first] = tmp1.second.second;
        for (int i = 0; i &lt; G[tmp1.second.first].size(); i++) {
          tmp2 = G[tmp1.second.first][i];
          tmp2.first += tmp1.first;
          st.insert(tmp2);
        }
    }
  }

  // если от вершины start нет пути в вершину n
  if (Mark[n] == 0) {
    cout &lt;&lt; -1;
    return 0;
  }

  vector&lt;int> result;
  result.push_back(n);
  int buf = n;
  while (Putty[buf] != 0) {
    result.push_back(Putty[buf]);
    buf = Putty[buf];
  }

  for (int i = result.size() - 1; i >= 0; i--) {
    cout &lt;&lt; result[i] &lt;&lt; ' ';
  }
}
</pre>
  </details>
</article>


<!-- Задача F. Дима и Влад едут Домой -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Дима и Влад едут Домой</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Между некоторыми деревнями республики Валерьян ходят автобусы. Поскольку пассажиропотоки здесь не очень большие, то автобусы ходят всего несколько раз в день.</p>

  <p>Диме и Владу требуется добраться из деревни d в деревню v как можно быстрее (считается, что в момент времени 0 они находится в деревне d).</p>

  <h4>Входные данные</h4>
  <p>Сначала вводится число N – общее число деревень (1 ≤ N ≤ 1000), затем номера деревень d и v, за ними следует количество автобусных рейсов R (0 ≤ R ≤ 10000). Далее идут описания автобусных рейсов. Каждый рейс задается номером деревни отправления, временем отправления, деревней назначения и временем прибытия (все времена – целые от 0 до 10000). Если в момент t пассажир приезжает в какую-то деревню, то уехать из нее он может в любой момент времени, начиная с t.</p>

  <h4>Выходные данные</h4>
  <p>Выведите минимальное время, когда Дима и Влад могут оказаться в деревне v. Если они не смогут с помощью указанных автобусных рейсов добраться из d в v, выведите -1.</p>

  <details>
    <summary>Пример</summary>
<pre>
3 1 3 4
1 0 2 5
1 1 2 3
2 3 3 5
1 1 3 10
</pre>
    <code>5</code>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  int n, d, v, r;
  cin >> n >> d >> v >> r;
  vector&lt;int&gt; Mark(n + 1);
  vector&lt;int&gt; Time(n + 1, -1);
  pair&lt;int, int&gt; tmp1, tmp2;

  // номера вершин и время когда в них приходим
  set&lt;pair&lt;int, int&gt; &gt; st;

  // инициализация
  tmp1.first = 0;
  tmp1.second = d;
  st.insert(tmp1);

  int name1, time1, name2, time2;
  vector&lt;vector&lt;pair&lt;int, pair&lt;int, int&gt; &gt; &gt; &gt; G(n + 1);
  pair&lt;int, pair&lt;int, int&gt; &gt; buf;

  // соберем список смежности
  for (int i = 0; i &lt; r; i++) {
    cin >> name1 >> time1 >> name2 >> time2;
    buf.first = time1;
    buf.second.first = name2;
    buf.second.second = time2;
    G[name1].push_back(buf);
  }

  // алгоритм Дейкстры
  while (st.size() > 0) {
    tmp1 = *st.begin();
    st.erase(st.begin());
    if (Mark[tmp1.second] == 0 || Time[tmp1.second] > tmp1.first) {
      Time[tmp1.second] = tmp1.first;
      Mark[tmp1.second] = 1;
      // проходим по всем соседям
      for (int i = 0; i &lt; G[tmp1.second].size(); i++) {
        if (G[tmp1.second][i].first >= tmp1.first) {
          tmp2.first = G[tmp1.second][i].second.second;
          tmp2.second = G[tmp1.second][i].second.first;
          st.insert(tmp2);
        }
      }
    }
  }

  // если нельзя попасть в деревню
  if (Mark[v] == 0) {
    cout &lt;&lt; -1;
  } else {
    cout &lt;&lt; Time[v];
  }
}
</pre>
  </details>
</article>


<!-- Задача G. Везёт. Не везёт -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Везёт. Не везёт</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Недавно Домин заказал в интернет-магазине условие для одной из задач, и теперь ожидает его доставки по почте. Домин живет в стране, состоящей из n городов, причем между некоторыми городами u и v есть двустороннее почтовое сообщение, которое работает лишь в w-й день недели (всего в неделе 7 дней). Также доставку можно произвести из любого города в любой другой (возможно, через другие города). Посылка может быть отправлена утром из одного города по открытому сообщению и прибыть в другой к вечеру, или пролежать в почтовом отделении несколько дней, пока сообщение не заработает.</p>

  <p>Скоро важный контест, поэтому Домину стало интересно, когда он сможет добавить новую задачу. Помогите ему и найдите минимальное количество дней, необходимое для доставки посылки от склада условий до Домина. Домин начинает ожидать посылку с первого дня недели, и на следующее утро после того, когда посылка прибывает в его город, он сразу же бежит на почту забирать её.</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержатся 4 числа: n, m (2 ≤ n ≤ 10⁵, n - 1 ≤ m ≤ min(n*(n-1)/2, 2*10⁵)) — количество городов и сообщений, s и k (1 ≤ s, k ≤ n и s ≠ k) — номер города со складом и город, где живет Домин.</p>

  <p>В следующих m строках описываются почтовые сообщения, в каждой три числа: u, v, w (1 ≤ u, v ≤ n, u ≠ v и 1 ≤ w ≤ 7) — номера городов, между которыми есть сообщение и день, в который между городами u и v работает почтовое сообщение.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите минимальное количество дней ожидания посылки.</p>

  <details>
    <summary>Пример</summary>
<pre>
5 5 1 5
1 2 1
2 3 2
3 4 3
4 5 4
1 5 5
</pre>
    <code>4</code>
    <p>В первом примере ответ 4 дня, так как посылка, пройдя по пути 1 - 2 - 3 - 4 - 5, прибудет к вечеру четвертого дня недели и Домин заберет её утром пятого дня. А если она будет отправлена напрямую, то она прибудет к вечеру пятого дня, и Домин сможет забрать её утром шестого дня, то есть ждать её придется 5 дней.</p>
  </details>
</article>


<!-- Задача H. Дождь -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Дождь</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Игорь подал документы в аспирантуру своего любимого ВУЗа и решил немного прогуляться в парке.</p>

  <p>В парке растут n очень красивых деревьев, имеющих идеальную форму. Поскольку листовая крона деревьев очень густая, она не пропускает капли дождя. А сами листья при этом создают тень в виде круга, в центре которого расположен ствол дерева.</p>

  <p>Гуляя по парку, Игорь, как истинный математик, решил записать в свой блокнот информацию о деревьях в виде координат центра и радиуса тени дерева. За начало координат Игорь решил взять один из углов прямоугольной автобусной остановки, а координатные оси расположил параллельно ее сторонам. Когда все данные уже были записаны в блокнот, а Игорь шел в сторону остановки, начался сильный дождь. Игорь хочет добраться до остановки, пробежав под дождем как можно меньшее расстояние.</p>

  <p>Сможете ли вы определить это расстояние?</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано два целых числа x₁, y₁ (-10⁵ ≤ x₁, y₁ ≤ 10⁵) — координаты вершины прямоугольной остановки, противоположной вершине, выбранной в качестве начала координат.</p>

  <p>Во второй строке задано два целых числа x₂, y₂ (-10⁵ ≤ x₂, y₂ ≤ 10⁵) — координаты Игоря.</p>

  <p>В третьей строке записано число n (1 ≤ n ≤ 10³) — количество деревьев в парке.</p>

  <p>В каждой из последующих n строк записано по три целых числа aᵢ bᵢ, rᵢ (-10⁵ ≤ aᵢ, bᵢ ≤ 10⁵, 1 ≤ rᵢ ≤ 10⁵) — координаты и радиус кроны i-го дерева.</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно вещественное число с точностью до 4 знаков после запятой — минимальное расстояние, которое Игорю придется пройти под дождем.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
2 2
10 10
2
8 8 1
5 5 2
</pre>
    <code>5.31370850</code>

    <h4>Пример 2</h4>
<pre>
2 2
10 10
4
8 10 2
4 10 2
4 6 2
4 2 2
</pre>
    <code>0.00000000</code>

    <h4>Пример 3</h4>
<pre>
2 2
10 10
2
8 8 1
6 6 2
</pre>
    <code>5.48528137</code>
    <p>Гарантируется, что</p>
    <ul>
      <li>не существует двух деревьев, стволы которых расположены в одной точке;</li>
      <li>не существует дерева, расположенного внутри остановки;</li>
      <li>Игорь находится вне остановки.</li>
    </ul>
  </details>
</article>


<!-- Задача I. Ракетные шахты -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача I. Ракетные шахты</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Страна Берляндия состоит из n городов, пронумерованных целыми числами от 1 до n. Некоторые города соединены двунаправленными дорогами, каждая из которых имеет некоторую длину. Из каждого города существует путь в любой другой город по дорогам. Согласно Самым Секретным Документам, Берляндию охраняют Самые Секретные Ракеты. Точное местонахождение Самых Секретных Ракетных Шахт неизвестно, но Вася сумел достать информацию, в которой сказано, что все Шахты расположены точно на расстоянии l от столицы, которая находится в городе номер s.</p>

  <p>В документах дано формальное определение: в некотором месте, являющемся городом или точкой на дороге, находится Самая Секретная Ракетная Шахта тогда и только тогда, когда кратчайшее расстояние от этого места до столицы по дорогам страны в точности равно l.</p>

  <p>Вася хочет узнать, сколько именно ракетных шахт находится в Берляндии, чтобы затем продать эту информацию вражеским шпионам. Помогите Васе.</p>

  <h4>Входные данные</h4>
  <p>В первой строке находятся три целых числа n, m и s (2 ≤ n ≤ 10⁵, n - 1 ≤ m ≤ min(10⁵, n*(n-1)/2), 1 ≤ s ≤ n) — количество городов, дорог в стране и номер столицы соответственно. Далее в m строках даны описания дорог, каждая из которых описывается тремя целыми числами vᵢ, uᵢ, wᵢ (1 ≤ vᵢ, uᵢ ≤ n, vᵢ ≠ uᵢ, 1 ≤ wᵢ ≤ 1000), где vᵢ, uᵢ — номера городов, которые соединяет эта дорога, а wᵢ — ее длина. Последняя строка входных данных содержит целое число l (0 ≤ l ≤ 10⁹) — расстояние от столицы до ракетных шахт. Гарантируется, что:</p>
  <ul>
    <li>между любыми двумя городами существует не более одной дороги;</li>
    <li>каждая дорога соединяет два различных города;</li>
    <li>из каждого города существует хотя бы один путь в любой другой город по дорогам.</li>
  </ul>

  <h4>Выходные данные</h4>
  <p>Выведите единственное число — сколько Самых Секретных Ракетных Шахт находится в Берляндии.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
4 6 1
1 2 1
1 3 3
2 3 1
2 4 1
3 4 1
1 4 2
2
</pre>
    <code>3</code>

    <h4>Пример 2</h4>
<pre>
5 6 3
3 1 1
3 2 1
3 4 1
3 5 1
1 2 6
4 5 8
4
</pre>
    <code>3</code>
    <p>В первом примере шахты расположены в городах 3 и 4, а также на дороге (1, 3) на расстоянии 2 от города 1 (соответственно, на расстоянии 1 от города 3).</p>

    <p>Во втором примере одна из шахт расположена точно на середине дороги (1, 2), а еще две — на дороге (4, 5) на удалении 3 от города 4 в сторону города 5 и на удалении 3 от города 5 в сторону города 4.</p>
  </details>
</article>


<!-- Задача J. Волейбол -->
<article class="article">
  <div class="anchor" id="task10"></div>
  <h3>Задача J. Волейбол</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Петя очень любит волейбол. Однажды он опаздывал на волейбольный матч. Свою собственную машину Петя еще не купил, поэтому ему пришлось ехать на такси. В городе n перекрестков, некоторые из которых соединены двусторонними дорогами. Длина каждой дороги выражается некоторым натуральным числом метров, дороги могут иметь разные длины.</p>

  <p>Изначально на каждом перекрестке стоит ровно одно такси. Таксист с i-го перекрестка согласен проехать (возможно, через несколько других перекрестков) не более tᵢ метров и остановиться на каком-то другом перекрестке. Причем цена поездки не зависит от расстояния и равна ci бурлей. Посреди дороги такси останавливаться не могут. Каждое такси можно использовать не более 1 раза. В такси можно сесть только в перекрестке, где оно изначально расположено.</p>

  <p>Сейчас Петя находится на перекрестке x, а волейбольный стадион — на перекрестке y. Определите, какая минимальная сумма денег потребуется Пете чтобы доехать до стадиона.</p>

  <h4>Входные данные</h4>
  <p>В первой строке заданы два целых числа n и m (1 ≤ n ≤ 1000, 0 ≤ m ≤ 1000) — количество перекрестков и дорог в городе соответственно. Перекрестки нумеруются от 1 до n включительно. В следующей строке заданы два целых числа x и y (1 ≤ x, y ≤ n) — номер начального и конечного перекрестков соответственно. В последующих m строках содержится описание дорог. Каждая дорога описывается тройкой целых чисел uᵢ, vᵢ, wᵢ (1 ≤ uᵢ, vᵢ ≤ n, 1 ≤ wᵢ ≤ 10⁹) — соответственно начальный перекресток, конечный перекресток и длина. В следующих n строках заданы n пар целых чисел tᵢ и cᵢ (1 ≤ tᵢ, cᵢ ≤ 10⁹), описывающих таксиста, стоящего на i-ом перекрестке — максимальное расстояние, которое он может проехать, и цена за поездку. Дорога не может соединять перекресток сам с собой, но между парой перекрестков может быть больше одной дороги. Все числа в строках отделяются друг от друга ровно одним пробелом.</p>

  <h4>Выходные данные</h4>
  <p>Если Петя не может доехать на такси, выведите «-1» (без кавычек). Иначе выведите минимальную стоимость поездки.</p>

  <p>Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.</p>

  <details>
    <summary>Пример</summary>
<pre>
4 4
1 3
1 2 3
1 4 1
2 4 1
2 3 5
2 7
7 2
1 2
7 7
</pre>
    <code>9</code>
    <p>Оптимальный путь - поехать из перекрестка 1 к 2 (через 4), потом из 2 в 3. На это потратится 7+2=9 бурлей.</p>
  </details>
</article>


<!-- Задача K. Тайная лаборатория -->
<article class="article">
  <div class="anchor" id="task11"></div>
  <h3>Задача K. Тайная лаборатория</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Хиллия в опасности! Инопланетяне, называемые Думц, совершают набеги и похищают жителей планеты. Впрочем, почти все ждут скорого окончания войны, так как уверены, что элитные подразделения Корпуса Альфа, призванные защищать население, отлично справляются со своей задачей.</p>

  <p>Двадцатилетняя девушка Джейд, состоящая в повстанческой организации ИРИС, пробралась на секретный завод, принадлежащий Корпусу Альфа. Повстанцы уверены, что в помещении с номером n  можно запечатлеть на пленку важные улики, которые раскроют правду и положат конец войне.</p>

  <p>Корпус Альфа узнал о проникновении в их лабораторию, и через T  секунд все улики будут уничтожены. Поэтому Джейд должна успеть сделать все за это время. Проблема осложняется тем, что все переходы между помещениями являются защищенными: каждому переходу сопоставляется число s – уровень доступа. Пройти через переход с уровнем доступа s можно, лишь имея на руках код доступа с уровнем, большим или равным s.</p>

  <p>Повстанцы могут получить код любого уровня доступа, но, так как код более высокого уровня требует больших финансовых затрат, Джейд должна определить, какой минимальный уровень доступа ей необходим, чтобы добыть улики не позднее T.</p>

  <h4>Входные данные</h4>
  <p>В первой строке через пробел записаны два целых числа n и m (2 ≤ n ≤ 1000, 1 ≤ m ≤ 2000) – количество помещений в лаборатории и количество переходов между ними. Изначально Джейд находится в помещении с номером 1, а помещение, куда она должна попасть, имеет номер n.</p>

  <p>Следующие m строк описывают переходы между помещениями. Каждая из этих строк содержит 4 целых числа через пробел: xᵢ, yᵢ, dᵢ, sᵢ (1 ≤ xᵢ, yᵢ ≤ n, xᵢ ≠ yᵢ, 1 ≤ dᵢ ≤ 10⁶, 1 ≤ sᵢ ≤ 10⁶) – номера помещений, соединенных i-ым переходом, время, необходимое на прохождение перехода, и его уровень доступа. Никакой переход не описан более одного раза. По переходам можно двигаться в любом направлении, а, обладая максимальным доступом, можно добраться из любого помещения в любое другое.</p>

  <p>Последняя строка содержит число T (0 ≤ T ≤ 10⁹) – время, за которое Джейд должна успеть попасть в помещение с номером n.</p>

  <h4>Выходные данные</h4>
  <p>Если Джейд не сможет добраться до помещения с номером n
  , даже обладая максимальным уровнем доступа, выведите «NO» (без кавычек).</p>

  <p>Иначе в первой строке выведите «YES», а во второй — два целых числа через пробел: минимальный уровень доступа, обладая которым, можно добраться до помещения с номером n не более, чем за время T, и минимальное время, которое для этого необходимо.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
4 4
1 2 5 2
2 3 3 1
2 4 4 5
3 4 2 3
10
</pre>
<pre>
YES
3 10
</pre>

    <h4>Пример 2</h4>
<pre>
4 4
1 2 5 2
2 3 3 1
2 4 4 5
3 4 3 3
10
</pre>
<pre>
YES
5 9
</pre>

    <h4>Пример 3</h4>
<pre>
4 4
1 2 5 2
2 3 3 1
2 4 6 5
3 4 3 3
10
</pre>
<pre>
NO
</pre>
  </details>
</article>


<!-- Задача L. Дайте людям рому -->
<article class="article">
  <div class="anchor" id="task12"></div>
  <h3>Задача L. Дайте людям рому</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У трактирщика большие проблемы — в его погребе закончился весь ром. Поэтому он отправил своего помощника Игоря в город за бочкой рома.</p>

  <p>В силу ужасных погодных условий прямую дорогу из города в село, где находится трактир, занесло снегом. Теперь перед Игорем стоит сложная задача — вернуться обратно в трактир как можно быстрее, иначе трактирщика будет ждать участь пианиста и скрипача.</p>

  <p>Благо у Игоря есть карта. Все населенные пункты на ней пронумерованы, и Игорь в городе с номером s. Трактир же находится в населенном пункте с номером f. Кроме того на карте указаны все дороги. Каждая дорога соединяет два различных населенных пункта. Игорь знает, сколько минут потребуется проехать по каждой из дорог.</p>

  <p>Определите минимальное количество минут, которые потребуются Игорю, чтобы доехать до трактира.</p>

  <h4>Входные данные</h4>
  <p>В первой строке задано четыре целых натуральных числа n, m, s, f (2 ≤ n ≤ 10⁵, 1 ≤ m ≤ 10⁵, 1 ≤ s, f ≤ n) — количество городов, количество дорог на карте, номер города, где находится Игорь, и номер населенного пункта, в котором расположен трактир.</p>

  <p>Далее задано m строк, в каждой из которых записано три целых числа aᵢ, bᵢ, tᵢ (1 ≤ aᵢ, bᵢ ≤ n, 1 ≤ tᵢ ≤ 10⁹) — дорога, соединяющая города aᵢ и bᵢ, путь по которой составляет tᵢ минут.</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно целое число — минимальное количество минут, которое потребуется Игорю, либо «-1» (без кавычек), если это невозможно.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
2 2 1 2
1 2 10
1 2 20
</pre>
    <code>10</code>

    <h4>Пример 2</h4>
<pre>
5 7 1 5
1 2 10
1 3 20
2 4 30
3 4 5
4 5 15
1 5 50
3 5 25
</pre>
    <code>40</code>

    <h4>Пример 3</h4>
<pre>
3 1 1 3
1 2 20
</pre>
    <code>-1</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Решение такое же как у задачи C. Поездка в город. Нужно только немножко изменить пару строк под условие.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  int n, m, s, f;
  cin >> n >> m >> s >> f;
  vector&lt;vector&lt;pair&lt;long long, int&gt; &gt; &gt; G(n + 1);
  vector&lt;int&gt; Mark(n + 1);
  vector&lt;long long&gt; Dist(n + 1);
  long long a, b, w;
  pair&lt;long long, int&gt; tmp1, tmp2;

  // соберем список смежности
  for (int i = 0; i &lt; m; i++) {
    cin >> a >> b >> w;
    tmp1.first = w;
    tmp1.second = a;
    G[b].push_back(tmp1);
    tmp1.second = b;
    G[a].push_back(tmp1);
  }

  // инициализация
  set&lt;pair&lt;long long, int&gt; &gt; st;
  tmp1.first = 0;
  tmp1.second = s;
  st.insert(tmp1);

  // алгоритм Дейкстры
  while (st.size() > 0) {
    tmp1 = *st.begin();
    st.erase(st.begin());
    if (Mark[tmp1.second] == 0) {
      Mark[tmp1.second] = 1;
      Dist[tmp1.second] = tmp1.first;
      for (int i = 0; i &lt; G[tmp1.second].size(); i++) {
        tmp2 = G[tmp1.second][i];
        tmp2.first += tmp1.first;
        st.insert(tmp2);
      }
    }
  }

  // если нет пути из s в f
  if (Mark[f] == 0) {
    cout &lt;&lt; -1;
    return 0;
  }

  cout &lt;&lt; Dist[f];
}
</pre>
  </details>
</article>


<!-- Задача M. Дороги в Берляндии -->
<article class="article">
  <div class="anchor" id="task13"></div>
  <h3>Задача M. Дороги в Берляндии</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В Берляндии n городов, пронумерованных от 1 до n, некоторые из которых соединены двусторонними дорогами. Все дороги имеют длину — некоторое целое число от 1 до 1000. Известно, что из любого города можно доехать до любого другого по существующим дорогам. Так же для каждой пары городов известно кратчайшее расстояние между ними. Правительство Берляндии планирует построить k новых дорог. Для каждой запланированной дороги известна ее длина, и какие города она будет соединять. Чтобы контролировать правильность постройки новых дорог, после открытия очередной дороги правительство Берляндии хочет проверять сумму кратчайших расстояний между всеми парами городов. Помогите им — по заданной матрице кратчайших расстояний по старым дорогам и планам всех новых дорог, выясните, как будет меняться сумма кратчайших расстояний между всеми парами городов после постройки каждой дороги.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое число n (2 ≤ n ≤ 300) — число городов в Берляндии. Далее в n строках записано по n целых чисел — матрица кратчайших расстояний. j-ое число в i-ой строке — d<sub>i,j</sub>, кратчайшее расстояние между городами i и j. Гарантируется, что d<sub>i,i</sub> = 0, d<sub>i,j</sub> = d<sub>j,i</sub>, и заданная матрица является матрицей кратчайших расстояний для некоторого набора двусторонних дорог с целочисленной длиной от 1 до 1000, таким, что по этим дорогам можно доехать из любого города до любого другого.</p>

  <p>На следующей строке записано целое число k (1 ≤ k ≤ 300) — число запланированных дорог. В следующих k строках записаны описания запланированных дорог. Каждая дорога описывается тремя целыми числами aᵢ, bᵢ, cᵢ (1 ≤ aᵢ, bᵢ ≤ n, aᵢ ≠ bᵢ, 1 ≤ cᵢ ≤ 1000) — aᵢ и bᵢ — пара городов, которые соединяет дорога, cᵢ — длина дороги. Между парой городов может быть несколько дорог, но никакая дорога не соединяет город сам с собой.</p>

  <h4>Выходные данные</h4>
  <p>Выведите k целых чисел qᵢ (1 ≤ i ≤ k). qᵢ должно равняться сумме кратчайших расстояний между всеми парами городов после постройки дорог с номерами от 1 до i. Дороги нумеруются начиная с 1 в том порядке, в котором они даны во входных данных. Каждая пара городов учитывается в сумме один раз, т. е. имеются в виду неупорядоченные пары.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
2
0 5
5 0
1
1 2 3
</pre>
    <code>3</code>

    <h4>Пример 2</h4>
<pre>
3
0 4 5
4 0 9
5 9 0
2
2 3 8
1 2 1
</pre>
    <code>17 12</code>
  </details>
</article>


<!-- Задача N. Егор и граф -->
<article class="article">
  <div class="anchor" id="task14"></div>
  <h3>Задача N. Егор и граф</h3>

  <div><i>Ограничение по времени 3с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У Егора есть взвешенный ориентированный граф, состоящий из n вершин. В этом графе между любой парой различных вершин есть ребро в обоих направлениях. Егор любит играть с графом, и сейчас он придумал новую игру:</p>
  <ul>
    <li>Игра состоит из n шагов.</li>
    <li>На i-том шаге Егор удаляет из графа вершину номер xi. Удаляя вершину, Егор удаляет все ребра, которые входили в данную вершину и которые выходили из нее.</li>
    <li>Перед выполнением каждого шага, Егор хочет знать сумму длин кратчайших путей между всеми парами оставшихся вершин. Кратчайший путь может проходить через любую оставшуюся вершину. Другими словами, если обозначить как d(i, v, u) кратчайший путь между вершинами v и u в графе, который получился до удаления вершины xi, то Егор хочет знать значение следующей суммы: d(i, v, u).</li>
  </ul>

  <p>Помогите Егору, выведите значение искомой суммы перед каждым шагом.</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержится целое число n (1 ≤ n ≤ 500) — количество вершин в графе.</p>

  <p>В следующих n строках содержится по n целых чисел — матрица смежности графа: j-тое число в i-той строке a<sub>ij</sub> (1 ≤ a<sub>ij</sub> ≤ 10⁵, a<sub>ii</sub> = 0) обозначает вес ребра, ведущего из вершины i в вершину j.</p>

  <p>В следующей строке содержится n различных целых чисел: x₁, x₂, ..., xₙ (1 ≤ xᵢ ≤ n) — вершины, которые удаляет Егор.</p>

  <h4>Выходные данные</h4>
  <p>Выведите n целых чисел — i-тое число равно искомой сумме перед i-тым шагом.</p>

  <p>Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на C++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
1
0
1
</pre>
    <code>0</code>

    <h4>Пример 2</h4>
<pre>
2
0 5
4 0
1 2
</pre>
    <code>9 0</code>

    <h4>Пример 3</h4>
<pre>
4
0 3 1 1
6 0 400 1
2 4 0 1
1 1 1 0
4 1 2 3
</pre>
    <code>17 23 404 0</code>
  </details>
</article>


<!-- Задача O. Jzzhu и города -->
<article class="article">
  <div class="anchor" id="task15"></div>
  <h3>Задача O. Jzzhu и города</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Jzzhu — президент страны A. В его стране есть n городов, пронумерованных от 1 до n. Город 1 — столица A. Также есть m дорог, соединяющих города. По i-й дороге можно дойти из города ui в город vi (и наоборот), длина этой дороги равна xi. Более того, в стране есть k железнодорожных маршрутов. По i-му маршруту можно доехать от столицы страны до города si (и наоборот), длина этого маршрута равна yi.</p>

  <p>Jzzhu не хочет зря растрачивать государственный бюджет, поэтому он хочет закрыть некоторые железнодорожные маршруты. Пожалуйста, посчитайте для Jzzhu, какое максимальное количество железнодорожных маршрутов можно закрыть, если требуется выполнить следующее условие: длина кратчайшего пути из каждого города в столицу не должна измениться.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано три целых числа, n, m, k (2 ≤ n ≤ 10⁵; 1 ≤ m ≤ 3·10⁵; 1 ≤ k ≤ 10⁵).</p>

  <p>В каждой из следующих m строк записано три целых числа, uᵢ, vᵢ, xᵢ (1 ≤ uᵢ, vᵢ ≤ n; uᵢ ≠ vᵢ; 1 ≤ xᵢ ≤ 10⁹).</p>

  <p>В каждой из следующих k строк записано два целых числа, sᵢ и yᵢ (2 ≤ sᵢ ≤ n; 1 ≤ yᵢ ≤ 10⁹).</p>

  <p>Гарантируется, что существует по крайней мере один путь из каждого города в столицу. Обратите внимание, что между двумя городами может быть несколько дорог. Также может быть несколько железнодорожных маршрутов, ведущих из одного и того же города в столицу.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное целое число, обозначающее максимальное количество железнодорожных путей, которые можно закрыть.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
5 5 3
1 2 1
2 3 2
1 3 3
3 4 4
1 5 5
3 5
4 5
5 5
</pre>
    <code>2</code>

    <h4>Пример 2</h4>
<pre>
2 2 3
1 2 2
2 1 3
2 1
2 2
2 3
</pre>
    <code>2</code>
  </details>
</article>


<!-- Задача P. Планеты -->
<article class="article">
  <div class="anchor" id="task16"></div>
  <h3>Задача P. Планеты</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Гоа'улд Апофис снова захватил команду Джека О'Нила! Сам Джек смог спастись, но к тому времени корабль Апофиса уже совершил прыжок в гиперпространство. Однако Джек знает, на какой планете высадится Апофис. Чтобы спасти друзей, Джеку предстоит несколько раз пройти через звездные врата, чтобы попасть на эту планету.</p>

  <p>Всего в галактике находится n планет, пронумерованных числами от 1 до n. Джек находится на планете с номером 1, а Апофис высадится на планете с номером n. Между некоторыми парами планет можно перемещаться через звездные врата (перемещение возможно в обоих направлениях); перемещение занимает положительное и, возможно, для разных пар планет неодинаковое количество секунд. Джек начинает свое путешествие в момент времени 0.</p>

  <p>Может оказаться, что на планету, где сейчас находится Джек, через звездные врата прибывают другие путешественники, в этом случае Джек должен подождать ровно 1 секунду, прежде чем сам сможет воспользоваться звездными вратами. То есть, если в момент времени t на планету прибывает другой путешественник, то Джек может пройти через врата только в момент времени t + 1, если только в момент времени t + 1 на ту же планету не прибывают еще путешественники.</p>

  <p>Зная информацию о времени перемещения между планетами, а также о моментах времени, когда Джек не сможет пользоваться звездными вратами на конкретных планетах, определите наименьшее время, за которое он сможет попасть на планету с номером n.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит два целых числа, разделенные пробелом: n (2 ≤ n ≤ 10⁵), количество планет в галактике, и m (0 ≤ m ≤ 10⁵), количество пар планет, между которыми можно перемещаться сквозь звездные врата. Далее следуют m строк, в каждой из них содержится три целых числа: i-ая строка содержит номера планет aᵢ и bᵢ (1 ≤ aᵢ, bᵢ ≤ n, aᵢ ≠ bᵢ), между которыми есть связь через звездные врата, и целочисленное время (в секундах) перемещения между этими планетами cᵢ (1 ≤ cᵢ ≤ 10⁴). Гарантируется, что между любой парой планет существует не более одного перехода, образованного звездными вратами.</p>

  <p>Далее следуют n строк: i-тая строка содержит целое число kᵢ (0 ≤ kᵢ ≤ 10⁵), которое обозначает количество моментов времени, в которые на планету с номером i прибывают другие путешественники. Далее через пробел следуют kᵢ упорядоченных по возрастанию различных целых чисел t<sub>ij</sub> (0 ≤ t<sub>ij</sub> &lt; 10₉). Число t<sub>ij</sub> обозначает, что в момент времени t<sub>ij</sub> (в секундах) на планету i прибывает другой путешественник. Гарантируется, что сумма всех kᵢ не превышает 10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное число — наименьшее количество времени, которое понадобится Джеку, чтобы попасть с планеты 1 на планету n. Если Джек не сможет попасть на планету n ни за какое время, выведите число -1.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
4 6
1 2 2
1 3 3
1 4 8
2 3 4
2 4 5
3 4 3
0
1 3
2 3 4
0
</pre>
    <code>7</code>

    <h4>Пример 2</h4>
<pre>
3 1
1 2 3
0
1 3
0
</pre>
    <code>-1</code>
    <p>В первом примере у Джека три выбора, куда переместиться с планеты 1. Если он переместится сразу на планету 4, то потратит 8 секунд. Если он переместится на планету 3, то потратит 3 секунды, но, поскольку в моменты времени 3 и 4 на планету 3 прибывают другие путешественники, то он сможет отправиться на планету 4 только в момент времени 5, затратив в сумме 8 секунд. Если же Джек переместится на планету 2, а потом на планету 4, то потратит в сумме всего лишь 2 + 5 = 7 секунд.</p>

    <p>Во втором примере с планеты 1 на планету 3 нельзя попасть, перемещаясь через звездные врата.</p>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

using namespace std;

const int maxn = 100000, maxm = 100000;

vector&lt;pair&lt;int, int&gt; &gt; edges[maxn];
vector&lt;int&gt; times[maxn];

int dist[maxn];

struct compar {
  bool operator ()(int v1, int v2) const {
    if (dist[v1] != dist[v2]) {
      return dist[v1] &lt; dist[v2];
    } else {
      return v1 &lt; v2;
    }
  }
};

int main() {
  ios_base::sync_with_stdio(false); cin.tie(NULL);

  int n, m; cin >> n >> m;

  for (int i = 0; i &lt; m; i++) {
    int a, b, c; cin >> a >> b >> c;
    edges[a-1].push_back(make_pair(b-1, c));
    edges[b-1].push_back(make_pair(a-1, c));
  }

  for (int i = 0; i &lt; n; i++) {
    int k; cin >> k;

    times[i].resize(k);
    for (int j = 0; j &lt; k; j++) {
      cin >> times[i][j];
    }
  }

  fill_n(dist+1, n-1, INT_MAX);

  set&lt;int, compar&gt; q;
  for (int i = 0; i &lt; n; i++) {
    q.insert(i);
  }

  while (!q.empty()) {
    int v = *q.begin(); q.erase(q.begin());
    if (v == n-1 || dist[v] == INT_MAX) {
      break;
    }

    vector&lt;int&gt;::const_iterator ti(
      lower_bound(times[v].begin(), times[v].end(), dist[v]));
    while (ti != times[v].end() && dist[v] == *ti) {
      dist[v]++;
      ++ti;
    }

    for (int i = 0; i &lt; (int)edges[v].size(); i++) {
      const pair&lt;int, int&gt;& p = edges[v][i];

      set&lt;int, compar&gt;::iterator qi(q.find(p.first));
      if (qi != q.end()) {
        if (dist[v] + p.second &lt; dist[p.first]) {
          q.erase(qi);
          dist[p.first] = dist[v] + p.second;
          q.insert(p.first);
        }
      }
    }
  }

  cout &lt;&lt; (dist[n-1] &lt; INT_MAX ? dist[n-1] : -1) &lt;&lt; '\n';
}
</pre>
  </details>
</article>
