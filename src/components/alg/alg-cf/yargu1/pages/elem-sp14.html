<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contests" target="_blank">Codeforces ЯрГУ. Школьники</a></p>
  <p><a href="https://vk.com/sportprog_yarsu" target="_blank">vk.com/sportprog_yarsu</a></p>
  <p><a href="https://vkvideo.ru/@sportprog_yarsu" target="_blank">vkvideo.ru/@sportprog_yarsu</a></p>
</article>


<article class="article">
  <h1>Занятие 14. Структуры данных #2. set, map</h1>
  <p>Конспект видео от 2024.12.14</p>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contest/573635" target="_blank">Codeforces Контест 573635</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
    <a href="#p1">Структуры данных #2. set, map</a>
  </p>
  <p>
        <a href="#task1">Задача A. Система регистрации</a>
    <br><a href="#task2">Задача B. Список школ</a>
    <br><a href="#task3">Задача C. Простая теория множеств</a>
    <br><a href="#task4">Задача D. Старый идальго</a>
    <br><a href="#task5">Задача E. Т-простые числа</a>
    <br><a href="#task6">Задача F. Польшар и Игра</a>
    <br><a href="#task7">Задача G. Торжественный вечер</a>
    <br><a href="#task8">Задача H. Фото на память</a>
    <br><a href="#task9">Задача I. Испорченный массив</a>
    <br><a href="#task10">Задача J. После тренировки</a>
    <br><a href="#task11">Задача K. Запросы на поедание конфет</a>
    <br><a href="#task12">Задача L. Самый длинный страйк</a>
    <br><a href="#task13">Задача M. Странная сумма</a>
    <br><a href="#task14">Задача N. Мин-макс преобразование массива</a>
    <br><a href="#task15">Задача O. Игра в слова</a>
    <br><a href="#task16">Задача P. Список дел</a>
  </p>
</article>


<!-- Структуры данных #2. set, map -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Структуры данных #2. set, map</h3>

  <p><strong>Ассоциативные контейнеры (associative containers)</strong> представляют такие  контейнеры, где с каждым элементом ассоциирован некоторый ключ, и этот  ключ применяется для доступа к элементу в контейнере.</p>

  <p>В С++ ассоциативные контейнеры представлены множествами (set) и картами/словарями (map). Также существуют и multi-версии этих контейнеров, в которых допускаются повторы ключей. Эти структуры данных основаны на сбалансированных деревьях поиска.</p>

  <p>Новые библиотеки:</p>
  <code>#include &lt;set&gt;</code>
  <code>#include &lt;map&gt;</code>

  <h4>set</h4>
  <p>set - это контейнер, который автоматически сортирует добавляемые элементы в порядке возрастания. Но при добавлении одинаковых значений, set будет хранить только один его экземпляр. По другому его еще называют множеством.</p>
  <p>Два свойства set:</p>
  <ol>
    <li>Все элементы уникальны. Нет повторяющихся.</li>
    <li>Все элементы упорядочены по возрастанию.</li>
  </ol>
  <p>set&lt;тип данных&gt; имя;</p>
<pre>
set&lt;int&gt; st;
st.insert(10);
int tmp = *st.begin();
</pre>
  <p>Пример:</p>
  <code>1 2 3 4 1 2 9 7 12</code>
  <p>В set:</p>
  <code>1 2 3 4 7 9 12</code>

  <ol>
    <li>.empty() Проверяет, является ли set пустым. true/false</li>
    <li>.size() Возвращает количество элементов в set.</li>
    <li>.begin() Возвращает итератор на первый элемент.</li>
    <li>.end() Возвращает итератор за последним элементом.</li>
    <li>.rbegin() Возвращает итератор на последний элемент.</li>
    <li>.rend() Возвращает итератор перед первым элементом.</li>
    <li>.find(key) Возвращает итератор на элемент равный key. Если элемента нет возвращает итератор равный .end().</li>
    <li>.insert(a) Добавляет элемент a в set.</li>
    <li>.erase(a) Удаляет элемент из set по значению равному a. Перед удалением следует проверить, что элемент существует в set.</li>
    <li>.erase(iter) Удаляет элемент из set по итератору iter.</li>
    <li>.lower_bound(a) Возвращает итератор на первый элемент больший либо равный a. Если таких элементов нет, возвращает итератор равный итератору .end().</li>
    <li>.upper_bound(a) Возвращает итератор на первый элемент больший a. Если таких элементов нет, возвращает итератор равный итератору .end().</li>
  </ol>

  <p>Решение задачи экзамен по истории</p>
<pre>
int n, q, tmp, count = 0;
set&lt;int&gt; st;
cin >> n;
for (int i = 0; i &lt; n; i++) {
  cin >> tmp;
  st.insert(tmp);
}
cin >> q;
for (int i = 0; i &lt; q; i++) {
  cin >> tmp;
  if (st.find(tmp) != st.end()) {
    count++;
  }
}
cout &lt;&lt; count;
</pre>

  <h4>map</h4>
  <p>map - это отсортированный ассоциативный контейнер, содержащий пары «ключ-значение» с уникальными ключами. Но при добавлении одинаковых ключей, map будет хранить только один его экземпляр. По другому map еще называют словарем.</p>
  <p>Два свойства map:</p>
  <ol>
    <li>Все элементы по ключам уникальны. Нет повторяющихся ключей.</li>
    <li>Все элементы по ключам упорядочены по возрастанию.</li>
  </ol>
  <p>map&lt;тип данных1, тип данных2&gt; имя;</p>
<pre>
map&lt;int, int&gt; mp;
pair&lt;int, int&gt; tmp;
mp[10] = 1;
tmp = *mp.begin();
cout &lt;&lt; tmp.first &lt;&lt; " " &lt;&lt; tmp.second;
</pre>
  <ol>
    <li>.empty() Проверяет, является ли map пустым. true/false</li>
    <li>.size() Возвращает количество элементов в map.</li>
    <li>.begin() Возвращает итератор на первый элемент.</li>
    <li>.end() Возвращает итератор за последним элементом.</li>
    <li>.rbegin() Возвращает итератор на последний элемент.</li>
    <li>.rend() Возвращает итератор перед первым элементом.</li>
    <li>.find(key) Возвращает итератор на элемент с ключом равным key. Если элемента нет возвращает итератор равный .end().</li>
    <li>.insert(p) Добавляет элемент (pair) p в map.</li>
    <li>.erase(a) Удаляет элемент из map по ключу равному a. Перед удалением следует проверить, что ключ существует в map.</li>
    <li>.erase(iter) Удаляет элемент из map по итератору iter.</li>
    <li>.lower_bound(a) Возвращает итератор на первый элемент с ключом большим либо равным a. Если таких элементов нет, возвращает итератор равный итератору .end().</li>
    <li>.upper_bound(a) Возвращает итератор на первый элемент с ключом большим a. Если таких элементов нет, возвращает итератор равный итератору .end().</li>
  </ol>

  <h4>multiset</h4>
  <p>multiset - это контейнер, который автоматически сортирует добавляемые элементы в порядке возрастания. При добавлении одинаковых значений, multiset будет хранить все его экземпляры.</p>
  <p>Одно свойство multiset:</p>
  <ol>
    <li>Все элементы упорядочены по возрастанию.</li>
  </ol>
  <p>multiset<тип данных> имя;</p>
<pre>
multiset&lt;int&gt; st;
st.insert(10);
int tmp = *st.begin();
</pre>
  <p>Пример:</p>
  <code>1 2 3 4 1 2 9 7 12</code>
  <p>В multiset:</p>
  <code>1 1 2 2 3 4 7 9 12</code>
  <ol>
    <li>.empty() Проверяет, является ли multiset пустым. true/false</li>
    <li>.size() Возвращает количество элементов в multiset.</li>
    <li>.begin() Возвращает итератор на первый элемент.</li>
    <li>.end() Возвращает итератор за последним элементом.</li>
    <li>.rbegin() Возвращает итератор на последний элемент.</li>
    <li>.rend() Возвращает итератор перед первым элементом.</li>
    <li>.find(key) Возвращает итератор на элемент равный key. Если элемента нет возвращает итератор равный .end().</li>
    <li>.insert(a) Добавляет элемент a в multiset.</li>
    <li>.erase(a) Удаляет все элементы из multiset по значению равному a. Перед удалением следует проверить, что элемент существует в multiset.</li>
    <li>.erase(iter) Удаляет элемент из multiset по итератору iter.</li>
    <li>.lower_bound(a) Возвращает итератор на первый элемент больший либо равный a. Если таких элементов нет, возвращает итератор равный итератору .end().</li>
    <li>.upper_bound(a) Возвращает итератор на первый элемент больший a. Если таких элементов нет, возвращает итератор равный итератору .end().</li>
  </ol>

  <code>multiset&lt;int&gt; st:</code>
  <code>1 1 2 2 3 4 7 9 12</code>
  <code>st.erase(1):</code>
  <code>2 2 3 4 7 9 12</code>
  <code>st.erase(st.begin()):</code>
  <code>1 2 2 3 4 7 9 12</code>

  <h4>Метод count</h4>
  <p>В multiset и multimap есть метод count, который подсчитывает число одинаковых элементов. Его использовать в спортивном программировании нельзя, потому что он делает подсчет линейно, не используя никакие оптимизации. Он проходит от первого элемента и до последнего.</p>

  <h4>Разыменование указателя</h4>
  <p>Чтобы получить значение элемента, имея только указатель на него, надо перед указателем поставить оператор звездочка *. Эта операция называется разыменование указателя</p>
  <code>int tmp = *st.begin();</code>

  <h4>Итератор</h4>
  <p>Создадим множество</p>
  <code>set&lt;int&gt; st;</code>
  <p>Создадим итератор для множества</p>
  <code>set&lt;int&gt; :: iterator itst;</code>
  <p>Присвоим ему указатель на минимальный элемент в множестве.</p>
  <code>itst = st.begin();</code>
  <p>Выведем значение минимального элемента</p>
  <code>cout &lt;&lt; *itst;</code>
  <code>cout &lt;&lt; *st.begin();</code>

  <p>Создадим словарь</p>
  <code>map&lt;int, int&gt; mp;</code>
  <p>Создадим итератор для словаря</p>
  <code>map&lt;int, int&gt; :: iterator itmp;</code>
  <p>Присвоим ему указатель на минимальный ключ в словаре.</p>
  <code>itmp = mp.begin();</code>
  <p>Выведем минимальный ключ</p>
  <code>cout &lt;&lt; itmp -> first;</code>
  <code>cout &lt;&lt; *itmp.first;</code>

  <h4>Ускорение ввода/вывода</h4>
  <p>В задачах, где много вывода, можно получить TL только из-за того, что ввод
  (или вывод) занимает очень много времени. По умолчанию C++ использует
  синхронизацию с stdio, что может замедлять операции ввода-вывода. Вы
  можете отключить ее следующим образом:</p>
  <p>Команды ускорения:</p>
<pre>
ios::sync_with_stdio(0);
cin.tie(0);
</pre>
</article>


<!-- Задача A. Система регистрации -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Система регистрации</h3>

  <div><i>Ограничение по времени 5с
  <br>Ограничение по памяти 64мб</i></div>

  <p>В скором времени в Берляндии откроется новая почтовая служба "Берляндеск". Администрация сайта хочет запустить свой проект как можно быстрее, поэтому они попросили Вас о помощи. Вам предлагается реализовать прототип системы регистрации сайта.</p>

  <p>Система должна работать по следующему принципу. Каждый раз, когда новый пользователь хочет зарегистрироваться, он посылает системе запрос name со своим именем. Если данное имя не содержится в базе данных системы, то оно заносится туда и пользователю возвращается ответ OK, подтверждающий успешную регистрацию. Если же на сайте уже присутствует пользователь с именем name, то система формирует новое имя и выдает его пользователю в качестве подсказки, при этом подсказка также добавляется в базу данных. Новое имя формируется по следующему правилу. К name последовательно приписываются числа, начиная с единицы (name1, name2, ...), и среди них находят такое наименьшее i, что namei не содержится в базе данных сайта.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных задано число n (1 ≤ n ≤ 10⁵). Следующие n строк содержат запросы к системе. Каждый запрос представляет собой непустую строку длиной не более 32 символов, состоящую только из строчных букв латинского алфавита.</p>

  <h4>Выходные данные</h4>
  <p>В выходных данных должно содержаться n строк — ответы системы на запросы: ОК в случае успешной регистрации, или подсказку с новым именем, если запрашиваемое уже занято.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
4
abacaba
acaba
abacaba
acab
</pre>
<pre>
OK
OK
abacaba1
OK
</pre>

    <h4>Пример 2</h4>
<pre>
6
first
first
second
second
third
third
</pre>
<pre>
OK
first1
OK
second1
OK
third1
</pre>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/4/problem/C" target="_blank">Задача 4C</a>
      <br><a href="https://codeforces.com/contest/480" target="_blank">Codeforces Beta Round 4 (Дивизион 2) 2010-03-12</a>
    </div>

    <h4>Пример 3</h4>
<pre>
6
q
q
q
q
q
q
</pre>
<pre>
OK
q1
q2
q3
q4
q5
</pre>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;map&gt;

using namespace std;

int main() {
  // число запросов
  int q;
  cin >> q;

  // решение
  // база данных с уникальными ключами
  map&lt;string, int&gt; db;

  while (q--) {
    // следующее имя
    string name;
    cin >> name;
    auto ptr = db.find(name);
    if (ptr == db.end()) {

      // если такого имени нет
      // добавление в базу данных
      // 1 - число одинаковых имен
      pair&lt;string, int&gt; p = { name, 1 };
      db.insert(p);
      cout &lt;&lt; "OK\n";
    } else {

      // если такое имя уже есть
      int idx = ptr->second;
      string new_name = name + to_string(idx);
      pair&lt;string, int&gt; p = { new_name, 1 };
      // добавление в базу данных
      db.insert(p);
      cout &lt;&lt; new_name &lt;&lt; '\n';
      // обновим число одинаковых имен
      ptr->second = idx + 1;
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача B. Список школ -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача A. Список школ</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>При регистрации на портале интернет-олимпиады все участники заполняют регистрационную форму, где они указывают название школы, в которой они учатся. Разные участники могут по-разному писать название школы, например, «Физико-математическая школа №18», «ФМШ №18».</p>

  <p>Организаторам олимпиады предоставлена информация о названиях школ, которые написали регистрируемые участники олимпиады. Точно известно, что цифры в названии школы встречаются только в номере школы, а число в записи названия школы встречается ровно один раз и оно однозначно определяет номер школы. Номер школы является положительным целым числом и не может начинаться с нуля.</p>

  <p>Требуется написать программу для сайта интернет-олимпиады, которая поможет организаторам олимпиады получить следующую информацию: количество школ и номера школ, из которых зарегистрировалось не более пяти участников.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входного файла содержит одно целое число n (1 ≤ n ≤ 1000) -– количество названий школ, указанных всеми участниками при регистрации.</p>

  <p>Последующие n строк содержат названия школ, указанные всеми участниками. Название школы содержит только заглавные и строчные буквы латинского алфавита, цифры и пробелы, длина названия не превышает 100 символов.</p>

  <h4>Выходные данные</h4>
  <p>Первая строка выходного файла должна содержать одно число m – количество школ, от которых на олимпиаду зарегистрировалось от одного до пяти участников. Последующие m строк должны содержать только номера таких школ, при этом номера должны располагаться по одному в строке в произвольном порядке.</p>

  <details>
    <summary>Пример</summary>
<pre>
9
Physics and Mathematics School 18
9ya shkola imeni Pushkina
Lyceum 9
PaMS 18
Gymnasium 42
School 9
Shkola nomer 9
High school 9
School N 9
</pre>
<pre>
2
18
42
</pre>
    <p>В приведенном примере для участия в интернет-олимпиаде зарегистрировались: два ученика из школы с номером 18, один ученик из школы с номером 42 и шесть учеников из школы с номером 9. Таким образом, от 1 до 5 участников зарегистрировано от школ с номерами 18 и 42.</p>
  </details>

  <details>
    <summary>Решение с map</summary>
    <p>Номер школы это не целое число, а строка. Из входных строк необходимо вытащить номер школы как некоторую строку, состоящую из цифр.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  int n;
  cin >> n;
  string s, str;
  map&lt;string, int&gt; mp;
  for (int i = 0; i &lt; n + 1; i++) {
    getline(cin, s);
    str = "";
    for (int j = 0; j &lt; s.size(); j++) {
      if (s[j] >= '0' && s[j] &lt;= '9') {
        str += s[j];
      }
    }
    if (str != "") {
      // mp[str]++; // можно одной строчкой
      if (mp.find(str) != mp.end()) {
        mp[str]++;
      } else {
        mp[str] = 1;
      }
    }
  }
  vector&lt;string&gt; Result;
  while (mp.size() > 0) {
    if (mp.begin()->second &lt; 6) {
      Result.push_back(mp.begin()->first);
    }
    mp.erase(mp.begin());
  }

  // вывод результата
  cout &lt;&lt; Result.size() &lt;&lt; '\n';
  for (int i = 0; i &lt; Result.size(); i++) {
    cout &lt;&lt; Result[i] &lt;&lt; '\n';
  }
}
</pre>
  </details>

  <details>
    <summary>Решение без map</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  int n;
  cin >> n;
  string s, str;
  vector&lt;string&gt; Buf;
  for (int i = 0; i &lt; n + 1; i++) {
    getline(cin, s);
    str = "";
    for (int j = 0; j &lt; s.size(); j++) {
      if (s[j] >= '0' && s[j] &lt;= '9') {
        str += s[j];
      }
    }
    if (str != "") {
      Buf.push_back(str);
    }
  }

  sort(Buf.begin(), Buf.end());
  Buf.push_back("?????");
  string res = Buf[0];
  int count_res = 1;
  int count = 0;
  for (int i = 1; i &lt; Buf.size(); i++) {
    if (Buf[i] == res) {
      count_res++;
    } else {
        if (count_res &lt; 6) {
          count++;
        }
        res = Buf[i];
        count_res = 1;
    }
  }
  cout &lt;&lt; count &lt;&lt; '\n';

  res = Buf[0];
  count_res = 1;
  count = 0;
  for (int i = 1; i &lt; Buf.size(); i++) {
    if (Buf[i] == res) {
      count_res++;
    } else {
        if (count_res &lt; 6) {
          cout &lt;&lt; res &lt;&lt; '\n';
        }
        res = Buf[i];
        count_res = 1;
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача C. Простая теория множеств -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Простая теория множеств</h3>

  <div><i>Ограничение по времени 1.5с
  <br>Ограничение по памяти 128мб</i></div>

  <p>Напомним теорию множеств.</p>

  <p>Мощностью множества называется число элементов во множестве.</p>

  <p>Напоминаем также, что если в множество дважды положить один и тот же элемент, то он лежит в множестве в единственном экземпляре. (Например если в пустое множество A положить 3 — дважды, то множество A состоит из единственного элемента 3, и мощность этого множества 1).</p>

  <p>Пересечением двух множеств A и B, называется такое множество, все элементы которой принадлежат И множеству A И множеству B.</p>

  <p>Объединением двух множеств A и B, называется такое множество, все элементы которой принадлежат множеству A ЛИБО множеству B.</p>

  <p>Говорят, что если результатом вычитания множества B из множества A, называется такое множество A \ B, что все ее элементы принадлежат множеству A, но не принадлежат множеству B.</p>

  <p>Посмотрите на картинку, она может вам это лучше понять.</p>

  <p>Возможно вы вспомнили старое, а может вообще новое (а может и ничего не узнали). Не важно. Главное прочтите условие внимательно. Ваша задача проста. Вам дают 2 числовых множества. Найдите их пересечение, объединение и разность B из A.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных даны 2 числа n и m — количество элементов которые мы будем класть в первое и второе множество соответственно. (1 ≤ n, m ≤ 10⁵).</p>

  <p>Во второй строке входных данных перечислены элементы, которые мы кладем в первое множество, каждое разделяется пробелом.</p>

  <p>В третьей строке входных данных перечислены элементы, которые мы кладем во второе множество, каждый элемент разделяется пробелом.</p>

  <p>Гарантируется, что мы кладем в множества числа, не превосходящие по модулю 10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Выведите то что вас просят в следующем виде:</p>

  <p>В первой строке выведите INTERSECTION: p, где p мощность множества пересечения множеств.</p>

  <p>Во второй строке выведите p чисел — пересечение множеств (отсортированное), разделяя элементы пробелами.</p>

  <p>В третьей строке выведите UNION: d, где d мощность множества объединения множеств.</p>

  <p>В четвертой строке выведите d чисел — объединение множеств (отсортированное), разделяя элементы пробелами.</p>

  <p>В пятой строке выведите A SUBTRACT B: r, где r мощность множества полученного при вычитании второго множества из первого.</p>

  <p>В шестой строке выведите r чисел — разность множеств (отсортированное), разделяя элементы пробелами.</p>

  <details>
    <summary>Пример</summary>
<pre>
5 5
2 1 3 2 1
6 3 2 4 5
</pre>
<pre>
INTERSECTION: 2
2 3
UNION: 6
1 2 3 4 5 6
A SUBTRACT B: 1
1
</pre>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;set&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  int n; // кол-во в первом множестве
  int m; // кол-во во втором множестве
  cin >> n >> m;
  set&lt;int> A;
  set&lt;int> B;
  int in;
  for (int i = 0; i &lt; n; i++) {
    cin >> in;
    A.insert(in);
  }
  for (int i = 0; i &lt; m; i++) {
    cin >> in;
    B.insert(in);
  }

  // решение
  set&lt;int> Inter; // пересечение
  for (int p : A) {
    if (B.find(p) != B.end()) {
      Inter.insert(p);
    }
  }

  set&lt;int> Un; // объединение
  for (int p : A) {
    Un.insert(p);
  }
  for (int p : B) {
    Un.insert(p);
  }

  set&lt;int> Sub; // вычитание
  for (int p : A) {
    if (B.find(p) == B.end()) {
      Sub.insert(p);
    }
  }

  // вывод результата
  // мощность пересечения
  cout &lt;&lt; "INTERSECTION: " &lt;&lt; Inter.size() &lt;&lt; '\n';
  for (int p : Inter) {
    cout &lt;&lt; p &lt;&lt; ' ';
  }
  cout &lt;&lt; '\n';
  // мощность объединения
  cout &lt;&lt; "UNION: " &lt;&lt; Un.size() &lt;&lt; '\n';
  for (int p : Un) {
    cout &lt;&lt; p &lt;&lt; ' ';
  }
  cout &lt;&lt; '\n';
  // мощность вычитания
  cout &lt;&lt; "A SUBTRACT B: " &lt;&lt; Sub.size() &lt;&lt; '\n';
  for (int p : Sub) {
    cout &lt;&lt; p &lt;&lt; ' ';
  }
}
</pre>
  </details>
</article>


<!-- Задача D. Старый идальго -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Старый идальго</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Да, тяжелы рыцарские будни. Сколько невинных жизней приходится спасать, сколько жутких чудовищ уничтожить. Не стал исключением и Дон Кихот. Сегодня он решил добраться до дома своей прекрасной дамы Дульсинеи. Его путешествие можно представить как ряд из n клеток. Рыцарь находится в самой левой клетке (с номером 1), а Дульсинея, до которой он должен добраться – в самой правой (с номером n). Дон Кихот собирается пройти все клетки, при этом не возвращаясь обратно и не пропуская клеток.</p>

  <p>В каждой из остальных клеток находится либо прекрасная дама, либо чудовище. Каждое чудовище охраняет клад с золотыми монетами. Чудовище в клетке i охраняет Gᵢ золотых монет. Приходя в клетку с чудовищем, Дон Кихот может сделать выбор - убить дракона и забрать монеты либо пройти дальше.</p>

  <p>Если же рыцарь приходит в клетку с прекрасной дамой, она спрашивает, сколько чудовищ он истребил. Если это количество больше либо равно красоты дамы Bᵢ, то Дон Кихот обязан жениться на ней.</p>

  <p>Рыцарь хочет добраться до клетки n без приключений. Но при этом хочет собрать как можно больше золота. При этом, если он убьёт меньше драконов, чем требует красота Дульсинеи, то она с ним даже разговаривать не будет. Помогите рыцарю решить эту задачу.</p>

  <h4>Входные данные</h4>
  <p>В первой строке ввода содержится число n (1 &lt; n &lt; 200001) – количество клеток на поле. В следующих n - 1 строках заданы описания клеток 2, 3, ... , n.</p>

  <p>Если в клетке i находится дракон, то в i-й строке ввода содержится символ "d" и число Gᵢ (0 &lt; Gᵢ &lt; 10001) – количества золота у дракона.</p>

  <p>Если в клетке i находится прекрасная дама, то в i-й строке ввода содержится символ "p" и число Bᵢ (0 &lt; Bᵢ &lt; 200001) – красота дамы. Гарантируется, что в клетке с номером n находится Дульсинея.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите одно число – максимальное число золота, которое может получить Дон Кихот, либо -1, если он убьёт драконов меньше, чем красота Дульсинеи.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
6
d 10
d 12
p 2
d 1
p 2
</pre>
    <code>13</code>
    <p>В первом тестовом примере Дон Кихоту выгодно убить драконов в клетках 3 и 5.</p>

    <h4>Пример 2</h4>
<pre>
6
d 10
d 12
p 2
d 1
p 3
</pre>
    <code>-1</code>
    <p>Во втором тестовом примере Дон Кихот убьёт драконов в клетках 3 и 5, но так как он убил двух драконов, а красота Дульсинеи равна 3, и поэтому Дон Кихот потерпит неудачу.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Нам нужна такая структура данных, в которую мы можем быстро помещать элементы и быстро доставать самый маленький элемент. Возьмем для этого мультисет.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;set&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  int n; // число клеток
  cin >> n;
  char ch;
  int tmp; // число золота у дракона или красота дамы
  multiset&lt;int&gt; mst;

  // для каждой клетки
  for (int i = 2; i &lt;= n - 1; i++) {
    cin >> ch >> tmp;
    if (ch == 'd') {
      // если в клетке дракон
      mst.insert(tmp); // забираем его золото
    } else {
      // если в клетке дама
      while (mst.size() >= tmp) {
        // пока число убитых драконов больше чем красота дамы
        // не будем убивать драконов с наименьшим золотом
        mst.erase(mst.begin());
      }
    }
  }

  // ввод Дульсинеи
  cin >> ch >> tmp;
  int sum = 0;

  // решение и вывод результата
  if (mst.size() &lt; tmp) {
    // если число убитых драконов меньше красоты Дульсинеи
    cout &lt;&lt; -1;
  } else {
    while (mst.size() > 0) {
      sum += *mst.begin();
      mst.erase(mst.begin());
    }
    cout &lt;&lt; sum;
  }
}
</pre>
  </details>
</article>


<!-- Задача E. Т-простые числа -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Т-простые числа</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Известно, что простыми называются целые положительные числа, у которых ровно два различных положительных делителя. По аналогии назовем целое положительное число t Т-простым, если у t ровно три различных положительных делителя.</p>

  <p>Вам дан массив, состоящий из n целых положительных чисел. Для каждого из них определите, является ли оно Т-простым или нет.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит единственное целое число — количество чисел в массиве, n (1 ≤ n ≤ 10⁵). Следующая строка содержит n целых чисел xᵢ (1 ≤ xᵢ ≤ 10¹²), разделенных пробелами.</p>

  <p>Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.</p>

  <h4>Выходные данные</h4>
  <p>Выведите n строк: i-тая строка должна содержать «YES» (без кавычек), если число xᵢ является Т-простым, и «NO» (без кавычек), если не является.</p>

  <details>
    <summary>Пример</summary>
<pre>
3
4 5 6
</pre>
<pre>
YES
NO
NO
</pre>
    <p>В приведенном тесте даны три числа. Первое число 4 имеет ровно три делителя — 1, 2 и 4, поэтому ответ для этого числа — «YES». Второе число 5 имеет два делителя (1 и 5), а третье число 6 — четыре делителя (1, 2, 3, 6), поэтому ответ для них — «NO».</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/230/problem/B" target="_blank">Задача 230B</a>
      <br><a href="https://codeforces.com/contest/230" target="_blank">Codeforces Round 142 (Div. 2) 2012-10-01</a>
    </div>

    <p>Выпишем несколько примеров на маленьких числах, переберем их чтобы посмотреть как получаются T-простые числа.</p>
    <p>Число имеет ровно три делителя только если это квадрат простого числа - 4, 9, 25 ... Поэтому если число является квадратом простого чилса, то выводим YES, иначе NO. Поскольку во входных данных числа до 10¹², то мы найдем все простые числа до 10⁶, возведем их в квадрат и будем хранить в сете. Потом будем проверять если число есть в сете то оно T-простое.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;set&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  // T-простым числом будтет только квадрат простого числа
  set&lt;long long&gt; st;
  vector&lt;int&gt; A(1e6, 0);

  // соберем решето Эратосфена в векторе A
  for (long long i = 2; i &lt; A.size(); i++) {
    if (A[i] == 0) {
      st.insert(i * i); // квадраты простых чисел
      for (int j = 2 * i; j &lt; A.size(); j += i) {
        A[j] = 1;
      }
    }
  }

  // ввод данных
  int n; // число чисел
  cin >> n;
  long long tmp;

  for (int i = 0; i &lt; n; i++) {
    // следующее число
    cin >> tmp;

    // проверяем есть ли число в наборе T-простых чисел
    if (st.find(tmp) != st.end()) {
      //вывод результата
      cout &lt;&lt; "YES\n";
    } else {
      cout &lt;&lt; "NO\n";
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача F. Польшар и Игра -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Польшар и Игра</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Польшар играет со Врагошаром в некоторую игру. Правила просты. Игроки по очереди называют слова, называть слово, которое уже прозвучало, нельзя. Начинает Польшар. Проигрывает тот шар, который не может сказать ранее неназванного слова.</p>

  <p>Вам даны списки слов, известных Польшару и Врагошару. Определите, кто выиграет, если оба играют оптимально?</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит два целых числа n и m (1 ≤ n, m ≤ 10³) — число слов, которые знают Польшар и Врагошар соответственно.</p>

  <p>Затем следуют n строк, по одной в строке — слова, известные Польшару.</p>

  <p>Затем следуют m строк, по одной в строке — слова, известные Врагошару.</p>

  <p>Заметьте, что ни один из шаров не может знать слово больше одного раза (слова различны), но некоторые слова могут быть известны обоим игрокам.</p>

  <p>Каждое слово непустое и состоит из не более чем 500 строчных букв латинского алфавита.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите ответ: «YES», если выиграет Польшар, и «NO» иначе. Оба шара играют оптимально.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
5 1
polandball
is
a
cool
character
nope
</pre>
    <code>YES</code>
    <p>В первом примере Польшар знает намного больше слов и выиграет без труда.</p>

    <h4>Пример 2</h4>
<pre>
2 2
kremowka
wadowicka
kremowka
wiedenska
</pre>
    <code>YES</code>
    <p>Во втором примере если Польшар скажет вначале kremowka, то Врагошар не сможет использовать это слово. Единственное, что может сделать Врагошар — сказать wiedenska. Польшар скажет wadowicka и выиграет.</p>

    <h4>Пример 3</h4>
<pre>
1 2
a
a
b
</pre>
    <code>NO</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/755/problem/B" target="_blank">Задача 755B</a>
      <br><a href="https://codeforces.com/contest/755" target="_blank">8VC Venture Cup 2017 - Elimination Round 2017-01-15</a>
    </div>

<pre>
#include &lt;iostream&gt;
#include &lt;set&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  int n; // число слов Польшара
  int m; // число слов Врагошара
  cin >> n >> m;
  set&lt;string&gt; A; // слова Польшара
  set&lt;string&gt; B; // слова Врагошара
  string in;
  for (int i = 0; i &lt; n; i++) {
    cin >> in;
    A.insert(in);
  }
  for (int i = 0; i &lt; m; i++) {
    cin >> in;
    B.insert(in);
  }

  // решение
  string res = "YES";
  set&lt;string&gt; aAndB; // общие слова
  for (string p : A) {
    if (B.find(p) != B.end()) {
      aAndB.insert(p);
    }
  }

  set&lt;string&gt; uniqA; // слова только Польшара
  for (string p : A) {
    if (B.find(p) == B.end()) {
      uniqA.insert(p);
    }
  }

  set&lt;string&gt; uniqB; // слова только Врагошара
  for (string p : B) {
    if (A.find(p) == A.end()) {
      uniqB.insert(p);
    }
  }

  if (aAndB.size() % 2 == 0 && uniqB.size() >= uniqA.size()) {
    res = "NO";
  }
  if (aAndB.size() % 2 != 0 && uniqB.size() > uniqA.size()) {
    res = "NO";
  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача G. Торжественный вечер -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Торжественный вечер</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Конец июля — время, когда в Мармеладном замке проводится торжественный вечер! На него собираются гости со всего королевства, чтобы пообсуждать новейшие тенденции в мире сладостей. Однако обсуждаемая в этот вечер информация обладает некоторой долей секретности и, оказавшись в нехороших руках, может посеять раздор в королевстве Sweetland. Поэтому на вечер важно не пропустить незваных гостей.</p>

  <p>Мармеладный замок оборудован 26 входами, пронумероваными от A до Z. Про каждого гостя известно, через какой из входов он должен войти — это сделано из соображений безопасности. Дверь каждого входа открывают прямо перед проходом первого гостя через нее, и закрывают сразу после прохода последнего, который должен пройти через эту дверь. Никакие два гостя не приходят одновременно.</p>

  <p>Для того, чтобы через вход не смогли прошмыгнуть недоброжелатели, на открытый вход должен быть поставлен конфетный охранник. Таких в замке ровно k, поэтому если в какой-то конкретный момент открыты более чем k дверей, то некоторые из них будут без присмотра Обратите внимание, что охранник не может покинуть свой пост, пока соответствующая дверь открыта: он освобождается только после закрытия этой двери.</p>

  <p>У Сластены закралось подозрение, что на вечер все-таки могли проникнуть незваные гости. Помогите ей проверить, были ли в какой-то момент открыты более чем k дверей одновременно, если известен порядок, в котором в замок попали все приглашенные на вечер люди.</p>

  <h4>Входные данные</h4>
  <p>В первой строке даны два числа n и k — количество гостей на вечере и количество охранников (1 ≤ n ≤ 10⁶, 1 ≤ k ≤ 26).</p>

  <p>В следующей строке находятся n заглавных букв латинского алфавита s₁s₂ ... sₙ, где sᵢ — вход, через который в замок попал i-й гость.</p>

  <h4>Выходные данные</h4>
  <p>Выведите «YES», если хотя бы одна из дверей осталась без присмотра во время вечера, и «NO» в противном случае.</p>

  <p>Вы можете выводить каждую из букв в любом регистре (заглавную или строчную).</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
5 1
AABBB
</pre>
    <code>NO</code>
    <p>В первом примере дверь входа A открывается перед приходом первого гостя и закрывается после прихода второго гостя, а дверь входа B открывается перед приходом третьего гостя и закрывается после прихода пятого. Охранник спокойно может обслужить обе двери, потому что первая закроется раньше, чем откроется вторая.</p>

    <h4>Пример 2</h4>
<pre>
5 1
ABABB
</pre>
    <code>YES</code>
    <p>Во втором примере дверь B открывается перед приходом второго гостя, но единственный охранник не может покинуть дверь A, потому что третий гость должен через нее пройти.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/834/problem/B" target="_blank">Задача 834B</a>
      <br><a href="https://codeforces.com/contest/834" target="_blank">Codeforces Round 426 (Div. 2) 2017-07-30</a>
    </div>
<pre>
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  int n; // число гостей
  int k; // число охранников
  cin >> n >> k;

  string A;
  cin >> A;

  // решение
  string res = "NO";

  // последний вошедший в i-ю дверь
  map&lt;char, int&gt; Last;
  for (int guest = 0; guest &lt; n; guest++) {
    Last[A[guest]] = guest;
  }

  // открывается новая дверь - плюс охранник,
  // закрывается дверь - минус охранник
  int cnt = 0;
  int door = 0;
  set&lt;char&gt; Open;
  for (int guest = 0; guest &lt; n; guest++) {
    door = A[guest];
    if (Open.find(door) == Open.end()) {
      Open.insert(door);
      cnt++;
    }
    if (cnt > k) {
      res = "YES";
    }
    if (Last[door] == guest) {
      cnt--;
    }
  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача H. Фото на память -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Фото на память</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>На вечеринке встретились n друзей, они давно не собирались все вместе и поэтому решили сделать общее групповое фото.</p>

  <p>Упрощённо процесс фотографирования можно описать следующим образом. На фотографии каждый из друзей занимает прямоугольник из пикселей: i-й из них занимает прямоугольник ширины wᵢ пикселей и высоты hᵢ пикселей. На групповом фото все фотографируемые стоят в ряд, таким образом минимальный размер в пикселях фотографии, включающей всех друзей, составляет W x H, где W — суммарная ширина всех фотографируемых, а H — максимальная из высот всех фотографируемых.</p>

  <p>Как это обычно и бывает, друзья сфотографировались n раз — на j-й (1 ≤ j ≤ n) фотографии присутствовали все, кроме j-го из них, ведь он был фотографом.</p>

  <p>Выведите минимальный размер в пикселях каждого из сделанных фото.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое число n (2 ≤ n ≤ 200000) — количество друзей.</p>

  <p>Далее следует n строк: i-я из них содержит информацию об i-м из друзей. В строке содержится пара целых чисел wᵢ, hᵢ (1 ≤ wᵢ ≤ 10, 1 ≤ hᵢ ≤ 1000) — ширина и высота в пикселях соответствующего ему прямоугольника.</p>

  <h4>Выходные данные</h4>
  <p>Выведите n разделённых пробелами чисел b₁, b₂, ..., bₙ, где bᵢ — общее количество пикселей на минимальной фотографии, вмещающей всех друзей, кроме i-го из них.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
3
1 10
5 5
10 1
</pre>
    <code>75 110 60</code>

    <h4>Пример 2</h4>
<pre>
3
2 1
1 2
2 1
</pre>
    <code>6 4 6</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/522/problem/B" target="_blank">Задача 522B</a>
      <br><a href="https://codeforces.com/contest/522" target="_blank">VK Cup 2015 - Квалификация 1 2015-03-07</a>
    </div>
    <p>Посчитаем общую ширину всех друзей и при нахождении ширины фото без i-го друга, будем вычитать ширину i-го друга. Найдем самого высокого друга и запомним его высоту и номер. Найдем вторую после максимальной высоту друга. Высота всех фотографий будет равна высоте самого высокого друга, кроме фотографии, где нет самого высокого друга, ее высота вторая после максимальной.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  // ввод данных
  int n; // число друзей
  cin >> n;

  vector&lt;pair&lt;int, int&gt; &gt; A(n + 1);
  int w, h; // ширина и высота
  pair&lt;int, int&gt; tmp;
  long long wAll = 0;
  int h1 = 1; // первая высота
  int h2 = 2; // вторая высота
  int i_h1 = 1; // друг с высотой h1

  //
  for (int i = 1; i &lt;= n; i++) {
    cin >> w >> h;
    wAll += w;
    if (h > h1) {
      h2 = h1;
      h1 = h;
      i_h1 = i;
    } else if (h == h1) {
      h2 = h;
    } else if (h > h2) {
      h2 = h;
    }
    tmp = make_pair(w, h);
    A[i] = tmp;
  }

  vector&lt;long long&gt; Res(n + 1);
  // создаем результат
  for (int i = 1; i &lt;= n; i++) {
    if (i_h1 == i) {
      Res[i] = (wAll - A[i].first) * h2;
    } else {
      Res[i] = (wAll - A[i].first) * h1;
    }
  }

  // вывод результата
  for (int i = 1; i &lt;= n; i++) {
    cout &lt;&lt; Res[i] &lt;&lt; ' ';
  }
}
</pre>
  </details>
</article>


<!-- Задача I. Испорченный массив -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача I. Испорченный массив</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам дано число n и массив b₁, b₂, ... , bₙ₊₂, полученный согласно следующему алгоритму:</p>
  <ul>
    <li>был загадан некоторый массив a₁, a₂, ... , aₙ;</li>
    <li>массив a записали в массив b, т.е. bᵢ = aᵢ (1 ≤ i ≤ n);</li>
    <li>(n+1)-м элементом массива b записали сумму чисел в массиве a, т.е. bₙ₊₁ = a₁ + a₂ + ... + aₙ;</li>
    <li>(n+2)-м элементом массива b записали некоторое число x (1 ≤ x ≤ 10⁹), т.е. bₙ₊₂ = x;</li>
    <li>массив b был перемешан.</li>
  </ul>

  <p>Например, массив b=[2,3,7,12,2] мог быть получен следующими способами:</p>
  <ul>
    <li>a=[2,2,3] и x=12;</li>
    <li>a=[3,2,7] и x=2.</li>
  </ul>

  <p>Для заданного массива b найдите любой массив a, который мог быть загадан изначально.</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержится одно целое число t (1 ≤ t ≤ 10⁴). Далее следуют t наборов входных данных.</p>

  <p>Первая строка каждого набора содержит одно целое число n (1 ≤ n ≤ 2⋅10⁵).</p>

  <p>Вторая строка каждого набора содержит n + 2 целых числа b₁, b₂, ... , bₙ₊₂ (1 ≤ bᵢ ≤ 10⁹).</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превосходит 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите:</p>
  <ul>
    <li>«-1», если массив b не мог быть получен ни по какому массиву a;</li>
    <li>n целых чисел a₁, a₂, ... , aₙ, иначе.</li>
  </ul>

  <p>Если существует несколько массивов a, то можете выводить любой.</p>

  <details>
    <summary>Пример</summary>
<pre>
4
3
2 3 7 12 2
4
9 1 7 1 6 5
5
18 2 2 3 2 9 2
3
2 6 9 2 1
</pre>
<pre>
2 3 7
-1
2 2 2 3 9
1 2 6
</pre>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1512/problem/D" target="_blank">Задача 1512D</a>
      <br><a href="https://codeforces.com/contest/1512" target="_blank">Codeforces Round 713 (Div. 3) 2021-04-10</a>
    </div>

    <p>Сумма всех элементов B это удвоенная сумма всех элементов A + x. Тогда x = sumB - 2 * sumA. Соберем массив B в мультисет setB. Перебором найдем x и элемент равный sumA. Удалим их из мультисета и останутся только элементы массива A.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;set&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

  // условная компиляций
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // размер массива A
    cin >> n;

    int nb = n + 2;
    vector&lt;long long&gt; B(nb + 1);
    for (int i = 1; i &lt;= nb; i++) {
      cin >> B[i];
    }

    // решение
    long long x = 0; // добавленное число
    long long sumA = 0; // сумма массива A
    long long sumB = 0; // сумма массива B

    // соберем мультисет и
    // найдем сумму массива B
    multiset&lt;long long&gt; setB;
    for (int i = 1; i &lt;= nb; i++) {
      setB.insert(B[i]);
      sumB += B[i];
    }

    // найдем x , если он существует
    for (int i = 1; i &lt;= nb; i++) {
      if ((sumB - B[i]) % 2 == 0) {
        x = B[i];
        setB.erase(setB.find(x)); // удалить из мультисета
        if (setB.find((sumB - B[i]) / 2) != setB.end()) {
          sumA = (sumB - x) / 2;
          setB.erase(setB.find(sumA));
          break; // нашли решение, можно выйти
        } else {
          setB.insert(x); // вернуть в мультисет
        }
      }
    }

    // вывод результата
    if (x == 0 || sumA == 0) {
      cout &lt;&lt; -1 &lt;&lt; '\n';
    } else {
      for (int a : setB) {
        cout &lt;&lt; a &lt;&lt; ' ';
      }
      cout &lt;&lt; '\n';
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача J. После тренировки -->
<article class="article">
  <div class="anchor" id="task10"></div>
  <h3>Задача J. После тренировки</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>После тренировки одной из команд на чемпионате Европы по футболу Валерику поручили собрать мячи и разложить по корзинам. Всего на стадионе имеется n мячей и m корзин. Корзины расположены в ряд слева направо и пронумерованы, соответственно, числами от 1 до m. Мячи пронумерованы числами от 1 до n.</p>

  <p>Валерик решил раскладывать мячи в порядке увеличения их номеров по следующей схеме. Каждый новый мяч он будет класть в ту корзину, где меньше всего мячей. При этом если у него есть несколько вариантов, то Валерик выбирает корзину, которая ближе всего к середине. Это означает, что он выбирает ту корзину, для которой | (m+1)/2 - i| минимально, где i — номер корзины. Если при этом также есть несколько вариантов, тогда он выбирает корзину с минимальным номером.</p>

  <p>Выведите для каждого мяча номер корзины, в которую он отправится в соответствии со схемой Валерика.</p>

  <p>Обратите внимание, что мячи раскладываются по корзинам в порядке увеличения номеров мячей, то есть сначала первый мяч, потом второй мяч и так далее.</p>

  <h4>Входные данные</h4>
  <p>В первой строке через пробел записаны два целых числа n, m (1 ≤ n, m ≤ 10⁵) — количество мячей и корзин, соответственно.</p>

  <h4>Выходные данные</h4>
  <p>Выведите n чисел, по одному на каждой строке. В i-ой строке должен содержаться номер корзины, в которую попадет i-ый мяч.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>4 3</code>
<pre>
2
1
3
2
</pre>

    <h4>Пример 2</h4>
    <code>3 1</code>
<pre>
1
1
1
</pre>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/195/problem/B" target="_blank">Задача 195B</a>
      <br><a href="https://codeforces.com/contest/195" target="_blank">Codeforces Round 123 (Div. 2) 2012-06-10</a>
    </div>

    <h4>Тест 5</h4>
    <code>2 6</code>
<pre>
3
4
</pre>

    <h4>Тест 9</h4>
    <code>5 6</code>
<pre>
3
4
2
5
1
</pre>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

    // ввод данных
    int n; // число мячей
    int m; // число корзин
    cin >> n >> m;

    // решение
    int l = (m + 1) / 2;
    int r = l + 1;

    // индекс - номер мяча, значение - номер корзины
    vector&lt;int&gt; Res(n + 2, 0);

    // найдем корзину для первых m мячей
    int begin = 1;
    int end = min(n, m);

    // если m нечетно, то сначала положим мяч в среднюю корзину
    if (m % 2 == 1) {
      Res[1] = l;
      l--;
      begin++;
      end++;
    }

    for (int i = begin; i &lt; end; i += 2) {
      Res[i] = l;
      Res[i + 1] = r;
      l--;
      r++;
    }

    // если мячей нечетно, а корзин четно
    // и мячей меньше корзин
    // то остается последний мяч
    if (Res[end] == 0) {
      Res[end] = l;
    }

    // найдем корзину остальным мячам
    for (int i = m + 1; i &lt;= n; i++) {
      Res[i] = Res[i - m];
    }

    // вывод результата
    for (int i = 1; i &lt;= n; i++) {
      cout &lt;&lt; Res[i] &lt;&lt; '\n';
    }
}
</pre>
  </details>
</article>


<!-- Задача K. Запросы на поедание конфет -->
<article class="article">
  <div class="anchor" id="task11"></div>
  <h3>Задача K. Запросы на поедание конфет</h3>

  <div><i>Ограничение по времени 3.5с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У Тимура есть n конфет. В i-й конфете количество сахара равно aᵢ. Так, съев i-ю конфету, Тимур потребляет количество сахара, равное aᵢ.</p>

  <p>Тимур задаст вам q запросов о своих конфетах. Для j -го запроса вы должны ответить, какое минимальное количество конфет ему нужно съесть, чтобы потребить количество сахара, большее или равное x<sub>j</sub>. Выведите -1, если невозможно получить такое количество. Другими словами, нужно вывести минимально возможное k такое, что, съев k конфет, Тимур получит количество сахара не менее x<sub>j</sub>, или сказать, что такого k не существует.</p>

  <p>Обратите внимание, что он не может съесть одну и ту же конфету дважды, а запросы не зависят друг от друга (Тимур может использовать одну и ту же конфету в разных запросах).</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит единственное целое число t (1 ≤ t ≤ 1000)  — количество наборов входных данных. Далее следуют описания наборов.</p>

  <p>Первая строка каждого набора содержит 2 целых числа n и q (1 ≤ n, q ≤ 1.5⋅10⁵) — количество конфет, которые есть у Тимура и количество запросов соответственно.</p>

  <p>Вторая строка каждого набора содержит n целых чисел a₁, a₂, ... ,aₙ (1 ≤ aᵢ ≤ 10⁴) — количество сахара в каждой конфете соответственно.</p>

  <p>Затем следуют q строк.</p>

  <p>Каждая из q содержит единственное целое число x<sub>j</sub> (1 ≤ x<sub>j</sub> ≤ 2⋅10⁹) — количество сахара, которое хочет получить Тимур.</p>

  <p>Гарантируется, что сумма n и сумма q по всем наборам входных данных не превосходит 1.5⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите q строк. В j-й строке выведите количество конфет, которое нужно съесть Тимуру, чтобы получить количество сахара, большее или равное x<sub>j</sub>. Выведите -1, если получить такое количество невозможно.</p>

  <details>
    <summary>Пример</summary>
<pre>
3
8 7
4 3 3 1 1 4 5 9
1
10
50
14
15
22
30
4 1
1 2 3 4
3
1 2
5
4
6
</pre>
<pre>
1
2
-1
2
3
4
8
1
1
-1
</pre>

    <p>В первом наборе входных данных примера:</p>
    <ul>
      <li>В первом запросе Тимур может съесть любую конфету, и он наберет нужное количество.</li>
      <li>Во втором запросе Тимур может получить количество не менее 10, съев 7-ю и 8-ю конфету, таким образом потребив количество сахара, равное 14.</li>
      <li>На третий запрос нет возможного ответа.</li>
      <li>В четвертом запросе Тимур может получить количество как минимум 14, съев 7-ю и 8-ю конфету, таким образом потребив количество сахара, равное 14.</li>
    </ul>

    <p>Во втором наборе входных данных примера:</p>
    <p>Для единственного запроса второго набора входных данных мы можем выбрать третью конфету, из которой Тимур получает количество сахара равное 3. Также можно получить тот же ответ, выбрав четвертую конфету.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1676/problem/E" target="_blank">Задача 1676E</a>
      <br><a href="https://codeforces.com/contest/1676" target="_blank">Codeforces Round 790 (Div. 4) 2022-05-10</a>
    </div>

    <p>Выгодно съедать сначала конфеты с наибольшим количеством сахара, чтобы в итоге съесть меньше конфет. Мы эту задачу решали раньше бинарным поиском. Сейчас решим ее чере map и ее функцию lower_bound.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n, q;
    cin >> n >> q;
    vector&lt;long long&gt; A(n);
    for (int i = 0; i &lt; n; i++) {
      cin >> A[i];
    }

    // решение
    sort(A.begin(), A.end());
    pair&lt;long long, int&gt; tmp;
    map&lt;long long, int&gt; mp;
    tmp.first = 0;
    tmp.second = 0;
    for (int i = n - 1; i >= 0; i--) {
      tmp.first += A[i];
      tmp.second++;
      mp.insert(tmp);
    }
    for (int i = 0; i &lt; q; i++) {
      long long u;
      cin >> u;
      if (mp.lower_bound(u) == mp.end()) {
        cout &lt;&lt; "-1\n";
      } else {
        cout &lt;&lt; mp.lower_bound(u)->second &lt;&lt; '\n';
      }
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача L. Самый длинный страйк -->
<article class="article">
  <div class="anchor" id="task12"></div>
  <h3>Задача L. Самый длинный страйк</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Дан массив a длины n и целое число k, вам нужно найти два любых числа l и r (l ≤ r) таких, что:</p>
  <ul>
    <li>Для каждого x (l ≤ x ≤ r), x содержится в a хотя бы k раз (т.е. k или более элементов массива равны x).</li>
    <li>Значение r-l максимально среди возможных.</li>
  </ul>

  <p>Если не существует подходящих чисел, выведите -1.</p>

  <p>Например, если a=[11,11,12,13,13,14,14] и k=2, то:</p>
  <ul>
    <li>для l=12, r=14 первое условие не выполнено, так как 12 содержится менее k=2 раз.</li>
    <li>для l=13, r=14 первое условие выполнено, так как 13 содержится хотя бы k=2 раз в a и 14 содержится хотя бы k=2 раз в a.</li>
    <li>для l=11, r=11 первое условие выполнено, так как 11 содержится хотя бы k=2 раз в a.</li>
  </ul>

  <p>Пара l и r для которой выполнено первое условие и r-l максимально — это пара l=13, r=14.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит единственное целое число t (1 ≤ t ≤ 1000) — количество наборов входных данных. Затем следуют описания наборов.</p>

  <p>Первая строка каждого набора содержит целые числа n и k (1 ≤ n ≤ 2⋅10⁵, 1 ≤ k ≤ n) — длина массива a и минимальное количество раз, которое должно встретиться каждое число в диапазоне [l,r], соответственно.</p>

  <p>Затем следует единственная строка, состоящая из n целых чисел — элементов массива a (1 ≤ aᵢ ≤ 10⁹).</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превосходит 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите 2 числа, l и r которые удовлетворяют условиям, или «-1» если таких не существует.</p>

  <p>Если ответов может быть несколько, выведите любой.</p>

  <details>
    <summary>Пример</summary>
<pre>
4
7 2
11 11 12 13 13 14 14
5 1
6 3 5 2 1
6 4
4 3 4 3 3 4
14 2
1 1 2 2 2 3 3 3 3 4 4 4 4 4
</pre>
<pre>
13 14
1 3
-1
1 4
</pre>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1676/problem/F" target="_blank">Задача 1676F</a>
      <br><a href="https://codeforces.com/contest/1676" target="_blank">Codeforces Round 790 (Div. 4) 2022-05-10</a>
    </div>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;map&gt;

using namespace std;

int main() {
  // ускорение ввода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n, k;
    cin >> n >> k;
    vector&lt;int&gt; A(n); // входной массив
    map&lt;int, int&gt; Freq; // частотный словарь
    // соберем входной массив и частотный словарь
    for (int i = 0; i &lt; n; i++) {
      cin >> A[i];
      Freq[A[i]]++;
    }

    // соберем массив с числами которых >= k
    vector&lt;int&gt; B;
    for (auto p : Freq) {
      if (p.second >= k) {
        B.push_back(p.first);
      }
    }

    if (B.size() == 0) {
      // если чисел которых >= k нет
      cout &lt;&lt; -1 &lt;&lt; '\n';
    } else {
      int l = B[0];
      int r = B[0];
      int tmp = B[0];
      int maxlr = 0; // максимальное расстояние между l и r

      // найдем l и r
      for (int i = 1; i &lt; B.size(); i++) {

        // проверим что числа идут подряд
        if (B[i] - B[i - 1] == 1) {

          // если да, то двигаем правую границу
          if (B[i] - tmp > maxlr) {
            l = tmp;
            r = B[i];
            maxlr = B[i] - tmp;
          }
        } else {
          // если нет, то двигаем левую границу
          tmp = B[i];
        }
      }
      // вывод результата
      cout &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; '\n';
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача M. Странная сумма -->
<article class="article">
  <div class="anchor" id="task13"></div>
  <h3>Задача M. Странная сумма</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У Егора есть табличка n x m, где строки пронумерованы от 1 до n сверху вниз, а столбцы пронумерованы с 1 до m слева направо. Каждая клетка таблички покрашена в некоторый цвет, где цвета пронумерованы целыми числами от 1 до 10⁵.</p>

  <p>Будем обозначать клетку, которая находится на пересечении r-й строки и c-го столбца, как (r,c). Определим манхэттенское расстояние между клетками (r₁,c₁) и (r₂,c₂) как длину кратчайшего пути между этими клетками, в котором любые две соседние клетки имеют общую сторону. Например, в таблице 3 x 4 манхэттенское расстояние между клетками (1,2) и (3,3) равно 3, и один из кратчайших путей имеет вид (1,2)→(2,2)→(2,3)→(3,3). Обратите внимание, что путь может проходить по клеткам любого цвета.</p>

  <p>У Егора возникло желание посчитать сумму манхэттенских расстояний по всем парам клеток одного цвета. Помогите Егору — вычислите эту сумму.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входного файла содержит два целых числа n и m (1 ≤ n ≤ m, n⋅m ≤ 100000) — число строк и столбцов таблички.</p>

  <p>Следующие n строк описывают соответствующие строки таблицы. i-я строка содержит m чисел cᵢ₁, cᵢ₂, ... ,cᵢₘ (1 ≤ c<sub>ij</sub> ≤ 100000) — цвета клеток в i-м ряду таблицы.</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно число — искомую сумму.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
2 3
1 2 3
3 2 1
</pre>
    <code>7</code>
    <p>В первом примере есть три пары клеток с одинаковым цветом: в координатах (1,1) и (2,3), в координатах (1,2) и (2,2), в координатах (1,3) и (2,1). Соответствующие манхеттенские расстояния равны 3, 1 и 3, их сумма равна 7.</p>

    <h4>Пример 2</h4>
<pre>
3 4
1 1 2 2
2 1 1 2
2 2 1 1
</pre>
    <code>76</code>

    <h4>Пример 3</h4>
<pre>
4 4
1 1 2 3
2 1 1 2
3 1 2 1
1 1 2 1
</pre>
    <code>129</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1648/problem/A" target="_blank">Задача 1648A</a>
      <br><a href="https://codeforces.com/contest/1648" target="_blank">Codeforces Round 775 (Div. 1, по задачам Открытой олимпиады школьников по программированию) 2022-03-06</a>
    </div>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // ввод данных
  int n; // число строк
  int m; // число столбцов
  cin >> n >> m;
  map&lt;int, vector&lt;int&gt; &gt; FreqX, FreqY;
  int in; // цвет клетки

  // соберем отдельно частотный словарь
  // для X и Y координаты
  // ключ это цвет клетки
  // значение это координата клетки
  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; m; j++) {
      cin >> in;
      FreqX[in].push_back(i);
      FreqY[in].push_back(j);
    }
  }

  // решение
  long long resX = 0;

  // переберем координаты X
  for (auto [color, cell] : FreqX) {
    sort(cell.begin(), cell.end());
    long long s = 0;
    long long c = 0;
    for (auto i : cell) {
      resX += i * c - s;
      s += i;
      c++;
    }
  }

  long long resY = 0;

  // переберем координаты Y
  for (auto [color, cell] : FreqY) {
    sort(cell.begin(), cell.end());
    long long s = 0;
    long long c = 0;
    for (auto i : cell) {
      resY += i * c - s;
      s += i;
      c++;
    }
  }

  // вывод результата
  cout &lt;&lt; resX + resY;
}
</pre>
  </details>
</article>


<!-- Задача N. Мин-макс преобразование массива -->
<article class="article">
  <div class="anchor" id="task14"></div>
  <h3>Задача N. Мин-макс преобразование массива</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам задан отсортированный массив a₁, a₂, ... , aₙ. Вы решили получить из него массив b₁, b₂, ... , bₙ следующим образом:</p>
  <ol>
    <li>Создайте массив d, состоящий из n произвольных неотрицательных целых чисел.</li>
    <li>Присвойте bᵢ = aᵢ + dᵢ для каждого bᵢ.</li>
    <li>Отсортируйте массив b в порядке неубывания.</li>
  </ol>

  <p>Вам задан полученный в результате массив b. Посчитайте для каждого i, какое минимально и максимально возможное значение dᵢ вы можете выбрать так, чтобы было возможно получить массив b.</p>

  <p>Заметим, что минимальные (максимальные) dᵢ считаются независимо друг от друга, т. е. могут быть получены из разных подходящих массивов d.</p>

  <h4>Входные данные</h4>
  <p>В первой строке задано одно целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>В первой строке каждого набора задано одно целое число n (1 ≤ n ≤ 2⋅10⁵) — длина массивов a, b и d.</p>

  <p>Во второй строке каждого набора заданы n целых чисел a₁, a₂, ... ,aₙ (1 ≤ aᵢ ≤ 10⁹; aᵢ ≤ aᵢ₊₁) — массив a в порядке неубывания.</p>

  <p>В третьей строке заданы n целых чисел b₁, b₂, ... , bₙ (1 ≤ bᵢ ≤ 10⁹; bᵢ ≤ bᵢ₊₁) — массив b в порядке неубывания.</p>

  <p>Дополнительные ограничения на входные данные:</p>
  <ol>
    <li>существует хотя бы один способ выбрать массив d, состоящий из неотрицательных целых чисел, чтобы получить массив b из a;</li>
    <li>сумма n по всем наборам входных данных не превосходит 2⋅10⁵.</li>
  </ol>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите две строки. Во-первых, выведите n целых чисел d₁<sup>min</sup>, d₂<sup>min</sup>, ... , dₙ<sup>min</sup>, где dᵢ<sup>min</sup> — минимально возможное значение, которое можно прибавить к aᵢ.</p>

  <p>Во-вторых, выведите n целых чисел d₁<sup>max</sup>, d₂<sup>max</sup>, ... , dₙ<sup>max</sup>, где dᵢ<sup>max</sup> — максимально возможное значение, которое можно добавить к aᵢ.</p>

  <p>Все dᵢ<sup>min</sup> и dᵢ<sup>max</sup> считаются независимо друг от друга. Другими словами, для каждого i, dᵢ<sup>min</sup> — это просто минимальное значение среди всех возможных dᵢ.</p>

  <details>
    <summary>Пример</summary>
<pre>
4
3
2 3 5
7 11 13
1
1000
5000
4
1 2 3 4
1 2 3 4
4
10 20 30 40
22 33 33 55
</pre>
<pre>
5 4 2
11 10 8
4000
4000
0 0 0 0
0 0 0 0
12 2 3 15
23 13 3 15
</pre>
    <p>В первом наборе входных данных, для получения d₁<sup>min</sup> = 5 можно выбрать, например, d=[5,10,6]. Тогда b = [2+5,3+10,5+6] = [7,13,11] = [7,11,13].</p>

    <p>Для d₂<sup>min</sup> = 4 можно выбрать d = [9,4,8]. Тогда b = [2+9,3+4,5+8] = [11,7,13] = [7,11,13].</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1721/problem/C" target="_blank">Задача 1721C</a>
      <br><a href="https://codeforces.com/contest/1721" target="_blank">Educational Codeforces Round 134 (Rated for Div. 2) 2022-08-27</a>
    </div>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // длина массива
    cin >> n;
    vector&lt;int&gt; A(n);
    for (int i = 0; i &lt; n; i++) {
      cin >> A[i];
    }
    vector&lt;int&gt; B(n);
    for (int i = 0; i &lt; n; i++) {
      cin >> B[i];
    }

    // решение
    // соберем минимально возможные значения
    vector&lt;int&gt; Dmin;
    for (int i = 0, j = 0; i &lt; n; i++) {
      // значения меньше чем само число нам не подходят
      while (B[j] &lt; A[i]) {
        j++;
      }
      Dmin.push_back(B[j] - A[i]);
    }

    // соберем максимально возможные значения
    vector&lt;int&gt; Dmax;
    for (int i = 0, j = 0; i &lt; n; i++) {
      // значения меньше чем само число нам не подходят
      j = max(j, i);
      while (j + 1 &lt; n && A[j + 1] &lt;= B[j]) {
        j++;
      }
      Dmax.push_back(B[j] - A[i]);
    }

    // вывод результата
    for (int i = 0; i &lt; n; i++) {
      cout &lt;&lt; Dmin[i] &lt;&lt; ' ';
    }
    cout &lt;&lt; '\n';
    for (int i = 0; i &lt; n; i++) {
      cout &lt;&lt; Dmax[i] &lt;&lt; ' ';
    }
    cout &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача O. Игра в слова -->
<article class="article">
  <div class="anchor" id="task15"></div>
  <h3>Задача O. Игра в слова</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Три друга играют в игру. Каждый из них пишет n различных слов, каждое длины 3.</p>

  <p>После этого они считают очки по следующим правилам:</p>
  <ul>
    <li>если слово написано только одним игроком, то тот, кто его написал, получает 3 очка;</li>
    <li>если слово написано двумя игроками, то каждый из них получает по 1 очку;</li>
    <li>если слово написано всеми тремя игроками, то за него очки не начисляются.</li>
  </ul>

  <p>Выведите финальное количество очков у каждого игрока.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое число t (1≤t≤100) — количество наборов входных данных. Далее следуют описания наборов.</p>

  <p>Первая строка каждого набора содержит целое число n (1≤n≤1000) — количество слов, написанных каждым игроком.</p>

  <p>Следующие три строки содержат по n различных слов каждая — слова написанные каждым из игроков. Все эти слова состоят из 3 строчных букв латинского алфавита.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите через пробел три целых числа — количество очков у первого, второго и третьего из друзей. Выводите очки именно в таком порядке — i-м выводите количество очков у i-го из друзей.</p>

  <details>
    <summary>Пример</summary>
<pre>
3
1
abc
def
abc
3
orz for qaq
qaq orz for
cod for ces
5
iat roc hem ica lly
bac ter iol ogi sts
bac roc lly iol iat
</pre>
<pre>
1 3 1
2 2 6
9 11 5
</pre>
    <p>В первом наборе входных данных примера:</p>
    <ul>
      <li>слово abc было написано первым и третьим другом — они получают по 1 очку;</li>
      <li>слово def было написано только вторым другом — он получает 3 очка.</li>
    </ul>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1722/problem/C" target="_blank">Задача 1722C</a>
      <br><a href="https://codeforces.com/contest/1722" target="_blank">Codeforces Round 817 (Div. 4) 2022-08-30</a>
    </div>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;set&gt;

using namespace std;

int main() {
  // условная компиляция
  #ifdef _DEBUG
    freopen("input.txt", "rt", stdin);
    freopen("output.txt", "wt", stdout);
  #endif

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // число слов
    cin >> n;
    set&lt;string&gt; s1; // слова первого игрока
    for (int i = 0; i &lt; n; i++) {
      string x;
      cin >> x;
      s1.insert(x);
    }
    set&lt;string&gt; s2; // слова второго игрока
    for (int i = 0; i &lt; n; i++) {
      string x;
      cin >> x;
      s2.insert(x);
    }
    set&lt;string&gt; s3; // слова третьего игрока
    for (int i = 0; i &lt; n; i++) {
      string x;
      cin >> x;
      s3.insert(x);
    }

    // решение
    int score1 = 0;
    int score2 = 0;
    int score3 = 0;

    // пройдем по словам первого игрока
    for (string s : s1) {
      if (s2.find(s) == s2.end() && s3.find(s) == s3.end()) {
        score1 += 3;
      } else if (s2.find(s) != s2.end() && s3.find(s) != s3.end()) {
        // никто не получает очки
      } else {
        score1++;
      }
    }

    // пройдем по словам второго игрока
    for (string s : s2) {
      if (s1.find(s) == s1.end() && s3.find(s) == s3.end()) {
        score2 += 3;
      } else if (s1.find(s) != s1.end() && s3.find(s) != s3.end()) {
        // никто не получает очки
      } else {
        score2++;
      }
    }

    // пройдем по словам третьего игрока
    for (string s : s3) {
      if (s1.find(s) == s1.end() && s2.find(s) == s2.end()) {
        score3 += 3;
      } else if (s1.find(s) != s1.end() && s2.find(s) != s2.end()) {
        // никто не получает очки
      } else {
        score3++;
      }
    }

    // вывод результата
    cout &lt;&lt; score1 &lt;&lt; ' '
    &lt;&lt; score2 &lt;&lt; ' '
    &lt;&lt; score3 &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача P. Список дел -->
<article class="article">
  <div class="anchor" id="task16"></div>
  <h3>Задача P. Список дел</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Игорь хочет заняться самоорганизацией, поэтому он решил составить огромный список дел и план, которого он будет придерживаться k дней.</p>

  <p>В списке оказалось n дел. Занятие с номером i из этого списка Игорь посчитал необходимым повторять через aᵢ дней, чтобы выработалась привычка. Определившись со списком и периодичностью повторения дел, Игорь незамедлительно выполнил все дела из списка, чтобы в дальнейшем их только повторять. Поэтому он очень устал и совсем забыл составить план на следующие k дней.</p>

  <p>Помогите Игорю составить план, указав для каждого из последующих дней количество дел, которое Игорю необходимо будет выполнить.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записаны два целых числа n, k (1 ≤ n, k ≤ 10⁵) — количество дел в списке Игоря и количество дней, в течение которых Игорь хочет придерживаться плана.</p>

  <p>Во второй строке записаны n целых чисел aᵢ (0 ≤ aᵢ ≤ 10⁵, 1 ≤ i ≤ n) — количество дней, через которое необходимо повторить i-е дело.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите k чисел m<sub>j</sub>, разделенных пробелом. m<sub>j</sub> — количество дел, запланированных Игорем на j-й (1 ≤ j ≤ k) день.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
2 10
1 2
</pre>
    <code>0 1 1 1 0 2 0 1 1 1</code>

    <h4>Пример 2</h4>
<pre>
2 6
0 1
</pre>
    <code>1 2 1 2 1 2</code>

    <h4>Пример 3</h4>
<pre>
3 15
1 2 3
</pre>
    <code>0 1 1 2 0 2 0 2 1 1 0 3 0 1 1</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/gym/104454/problem/K" target="_blank">Задача K</a>
      <br><a href="https://codeforces.com/gym/104454" target="_blank">ICPC Central Russia Regional Contest, 2021</a>
    </div>

    <p>В нулевой день все задания выполнены. Дела которые выполняются через 0 дней нужно делать каждый день. Дела которые выполняются через 1 день, нужно делать с пропуском в 1 день и т.д. Давайти объединять в группы все дела, которые делаются через одинаковое число дней. Для этого возьмем структуру данных map&lt;int, int&gt;, где map.first это период задачи, а map.second это количество таких задач.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;map&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  int n; // число дел
  int m; // число дней
  cin >> n >> m;

  pair&lt;int, int&gt; tmp;
  map&lt;int, int&gt; mp; // список дел

  // пробежим по всем делам
  for (int i = 0; i &lt; n; i++) {

    // период повторения следующего дела
    cin >> tmp.first;
    tmp.first++;
    if (mp.find(tmp.first) == mp.end()) {
      // если в списке нет дел с таким периодом
      tmp.second = 1; // то это будет первое дело
      mp.insert(tmp); // добавим его в список
    } else {
      /*
      // 1й способ
      // удаление и добавление элемента
      pair&lt;int, int&gt; tmp2;
      tmp2 = *mp.find(tmp.first); // сохраняем значение элемента
      mp.erase(mp.find(tmp.first)); // удаляем элемент из map
      tmp2.second++; // изменяем значение элемента
      mp.insert(tmp2); // возвращаем элемент в map

      // 2й способ
      // изменение значения элемента
      mp[tmp.first]++;
      */

      // 3й способ
      // изменение через итератор
      mp.find(tmp.first)->second++;
    }
  }

  vector&lt;int&gt; Res(m + 1);
  while (mp.size() > 0) {
    tmp = *mp.begin();
    mp.erase(mp.begin());
    int uk = 0;
    while (uk &lt;= m) {
      Res[uk] += tmp.second;
      uk += tmp.first;
    }
  }

  for (int i = 1; i &lt;= m; i++) {
    cout &lt;&lt; Res[i] &lt;&lt; " ";
  }
}
</pre>
  </details>
</article>

