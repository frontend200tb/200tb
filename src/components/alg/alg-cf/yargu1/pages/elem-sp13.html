<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contests" target="_blank">Codeforces ЯрГУ. Школьники</a></p>
  <p><a href="https://vk.com/sportprog_yarsu" target="_blank">vk.com/sportprog_yarsu</a></p>
  <p><a href="https://vkvideo.ru/@sportprog_yarsu" target="_blank">vkvideo.ru/@sportprog_yarsu</a></p>
</article>


<article class="article">
  <h1>Занятие 13. Базовые алгоритмы #4. Бинарный поиск по ответу</h1>
  <p>Конспект видео от 2024.12.07</p>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contest/572133" target="_blank">Codeforces Контест 572133</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
    <a href="#p1">Бинарный поиск по ответу</a>
  </p>
  <p>
        <a href="#task1">Задача A. Провода</a>
    <br><a href="#task2">Задача B. Дипломы</a>
    <br><a href="#task3">Задача C. Ночная работа</a>
    <br><a href="#task4">Задача D. Факториал</a>
    <br><a href="#task5">Задача E. Ден и коровы</a>
    <br><a href="#task6">Задача F. Покраска забора</a>
    <br><a href="#task7">Задача G. Ярость Битвы</a>
    <br><a href="#task8">Задача H. Гамбургеры</a>
    <br><a href="#task9">Задача I. Шаги</a>
    <br><a href="#task10">Задача J. Осада Вальгаллы</a>
    <br><a href="#task11">Задача K. Сбалансированные кучки камней</a>
    <br><a href="#task12">Задача L. Обои</a>
    <br><a href="#task13">Задача M. Мафия</a>
    <br><a href="#task14">Задача N. Подземелье</a>
    <br><a href="#task15">Задача O. Лопаты и мечи</a>
    <br><a href="#task16">Задача P. Слежка за отрезками</a>
    <br><a href="#task17">Задача Q. Экзамены</a>
  </p>
</article>


<!-- Бинарный поиск по ответу -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Бинарный поиск по ответу</h3>

  <h4>Функции</h4>
  <p>Функция — это зависимость одной переменной величины от другой, то есть взаимосвязь между величинами. Обозначается y = f(x).</p>

  <p>За обозначением f(x) спрятана некоторая формула зависящая от x. Например:</p>
  <code>f(x) = sin(x) + 5 * x² - x³.</code>

  <p>Многомерная функция — это функция с более чем одним аргументом, причём все аргументы являются действительными переменными. Обозначается</p>
  <code>y = f(x₁, x₂), y = g(x₁, x₂, x₃), y = ϕ(x₁, x₂, ..., xₙ).</code>

  <h4>Кусочные функции</h4>
  <p>Кусочная функция — это функция, части которой заданы на определённом промежутке.</p>

  <p>Кусочно-заданная функция — функция одной переменной, определённая на множестве вещественных чисел, которая задана отдельной формулой (или другим способом задания функции) на каждом из интервалов, составляющих область её определения.</p>

  <p>Чтобы построить график кусочной функции, нужно каждый кусочек функции построить на выделенном для него участке, не залезая на соседние.</p>

  <h4>Пример</h4>
  <code>y = 9, при 5 ≤ x</code>
  <code>y = (x - 2)², при 2 ≤ x ≤ 5</code>
  <code>0, при x ≤ 2</code>

  <h4>Булевская функция</h4>
  <p>Булева функция — это функция, которая возвращает результат логического выражения на основе логических переменных, которые могут принимать только два значения: истину (1) или ложь (0).</p>

  <p>Рассмотрим в качестве примера функцию</p>
  <code>f(x) = 0.25x + 3 * sin(x).</code>

  <p>Зададим булевскую функцию:</p>
  <code>g(f(x)) = 1, при f(x) > 2</code>
  <code>g(f(x)) = 0, при f(x) ≤ 2</code>

  <p>Построим график для функции f(x) = 0.25x + 3 * sin(x).</p>
  <p>Выделим куски, где функция f(x) принимает значение больше 2 и меньше 2. Нарисуем функцию g(f(x)).</p>

  <h4>Булевская спец. функция</h4>
  <p>Для алгоритма бинарного поиска по ответу мы требуем специальных условий по булевской функции f(x):</p>
  <ol>
    <li>Функция монотонна. (переход из 0 в 1 или из 1 в 0, происходит один раз)</li>
    <li>Мы можем выделить границы left, right при которых значения функции f(x)
  будет разными f(left)! = f(right).</li>
  </ol>

  <h4>Бинарный поиск по ответу</h4>
  <p>Бинарный поиск по ответу применяется, если:</p>
  <ol>
    <li>Ответ на задачу можно найти математически, но формулу необходимо долго и трудно выводить.</li>
    <li>Мы можем построить булевскую специальную функцию.</li>
    <li>Ответ на задачу будет находится в месте перехода.</li>
  </ol>

  <h4>Последовательность действий алгоритма</h4>
  <ol>
    <li>Определяем булевскую функцию, как именно она выглядит (примерный график);</li>
    <li>Определяем границы области поиска, таким образом, чтобы в f(left) f(right) значения булевской функции были разные;</li>
    <li>Находим значение mid - середину области поиска;</li>
    <li>Определяем значение булевской функции от значения mid.</li>
    <li>В зависимости от результата сдвигаем, либо левую границу области поиска в середину, либо правую границу области поиска в середину;</li>
    <li>Продолжаем выполнять движение границ области поиска до тех пор, пока границы не станут соседними значениями right - left > 1;</li>
    <li>Делаем дополнительную проверку элементов после окончания цикла while. Ответ на задачу находится в одной из границ.</li>
  </ol>
</article>


<!-- Задача A. Провода -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Провода</h3>

  <div><i>Ограничение по времени 3с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Дано N отрезков провода длиной L₁, L₂, ..., Lₙ сантиметров. Требуется с помощью разрезания получить из них K равных отрезков как можно большей длины, выражающейся целым числом сантиметров. Если нельзя получить K отрезков длиной даже 1 см, вывести 0.</p>

  <h4>Входные данные</h4>
  <p>В первой строке находятся числа N и K. В следующей строке N целых чисел - L₁, L₂, ..., Lₙ</p>

  <p>Ограничения: 1 ≤ N ≤ 10³, 1 ≤ K ≤ 10⁴, 100 ≤ Lᵢ ≤ 10⁷, все числа целые.</p>

  <h4>Выходные данные</h4>
  <p>Вывести одно число - полученную длину отрезков.</p>

  <details>
    <summary>Пример</summary>
<pre>
3 6
100 200 300
</pre>
    <code>100</code>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // ввод данных
  int n; // число отрезков
  int k; // число одинаковых отрезков
  cin >> n >> k;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  long long max_l = A[0];

  // находим самый длинный отрезок
  for (int i = 1; i &lt; n; i++) {
    if (A[i] > max_l) {
      max_l = A[i];
    }
  }

  int left = 0;
  int right = max_l + 1;
  int mid;

  // бинарный поиск по ответу
  while (right - left > 1) {
    mid = left + (right - left) / 2;
    int total = 0;

    for (int i = 0; i &lt; n && total &lt; k; i++) {
      total += A[i] / mid;
    }

    if (total >= k) {
      left = mid;
    } else {
      right = mid;
    }
  }

  // вывод результата
  cout &lt;&lt; left;
}
</pre>
  </details>
</article>


<!-- Задача B. Дипломы -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Дипломы</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Когда Петя учился в школе, он часто участвовал в олимпиадах по информатике, математике и физике. Так как он был достаточно способным мальчиком и усердно учился, то на многих из этих олимпиад он получал дипломы. К окончанию школы у него накопилось n дипломов, причём, как оказалось, все они имели одинаковые размеры: w — в ширину и h — в высоту. Сейчас Петя учится в одном из лучших российских университетов и живёт в общежитии со своими одногруппниками. Он решил украсить свою комнату, повесив на одну из стен свои дипломы за школьные олимпиады. Так как к бетонной стене прикрепить дипломы достаточно трудно, то он решил купить специальную доску из пробкового дерева, чтобы прикрепить её к стене, а к ней — дипломы. Для того чтобы эта конструкция выглядела более красиво, Петя хочет, чтобы доска была квадратной и занимала как можно меньше места на стене. Каждый диплом должен быть размещён строго в прямоугольнике размером w на h. Дипломы запрещается поворачивать на 90 градусов. Прямоугольники, соответствующие различным дипломам, не должны иметь общих внутренних точек. Требуется написать программу, которая вычислит минимальный размер стороны доски, которая потребуется Пете для размещения всех своих дипломов.</p>

  <h4>Входные данные</h4>
  <p>Входной файл содержит три целых числа: w, h, n (1 ≤ w, h, n≤ 10⁹).</p>

  <h4>Выходные данные</h4>
  <p>В выходной файл необходимо вывести ответ на поставленную задачу.</p>
  <p>Подумайте, какой тип данных потребуется для хранения ответа.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>2 3 10</code>
    <code>9</code>

    <h4>Пример 2</h4>
    <code>1 1 1</code>
    <code>1</code>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ввод данных
  long long w; // ширина диплома
  long long h; // высота диплома
  long long n; // число дипломов
  cin >> w >> h >> n;

  // решение
  long long left = 0;
  long long right = max(w, h) * n;
  long long mid;

  // бинарный поиск по ответу
  while (right - left > 1) {
    mid = left + (right - left) / 2;

    // проверим сколько дипломов помещается
    // в квадрат со стороной mid
    long long cols = mid / w;
    long long rows = mid / h;
    long long m = cols * rows; // число поместившихся дипломов
    if (m >= n) {
      right = mid;
    } else {
      left = mid;
    }
  }

  // вывод результата
  cout &lt;&lt; right;
}
</pre>
  </details>
</article>


<!-- Задача C. Ночная работа -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Ночная работа</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Однажды Васе поручили очень важное задание — написать за ночь программу, которая состоит из n строк кода. Вася уже очень устал и поэтому работает по следующей схеме: сначала он пишет v строк кода, выпивает стакан чая, после чего пишет уже v/k строк, опять выпивает стакан чая, после пишет v / k² строк и так далее: v / k³, v / k⁴ , v / k⁵ , ...</p>

  <p>Под выражением a / b понимается целая часть от деления числа a на число b.</p>

  <p>Как только текущая величина v / kᵖ станет равной 0, Вася немедленно засыпает и просыпается только утром, когда программа должна быть уже полностью написана.</p>

  <p>Васе интересно, какое наименьшее допустимое значение может принимать величина v, чтобы успеть написать не менее n строк кода до того момента, как он заснет.</p>

  <h4>Входные данные</h4>
  <p>Входные данные состоят из двух целых чисел n и k, записанных через пробел — размер программы в строках и коэффициент уменьшения производительности, 1 ≤ n ≤ 10⁹, 2 ≤ k ≤ 10.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное целое число — минимальное значение величины v, при котором Вася успеет написать программу за ночь.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>7 2</code>
    <code>4</code>
    <p>В первом примере при v = 4 Вася будет печатать код следующим образом: сначала 4 строки, потом 2, потом 1, а затем Вася уснет. Таким образом, он успеет за ночь написать 4 + 2 + 1 = 7 строк, и задание будет выполнено.</p>

    <h4>Пример 2</h4>
    <code>59 9</code>
    <code>54</code>
    <p>Во втором примере при v = 54 Вася печатает код следующими порциями: 54, 6. В сумме 54 + 6 = 60, что даже больше, чем n = 59.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/165/problem/B" target="_blank">Задача 165B</a>
      <br><a href="https://codeforces.com/contest/165" target="_blank">Codeforces Round 112 (Div. 2) 2012-03-16</a>
    </div>

<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
// условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // ввод данных
  int n; // число строк
  int k; // коэффициент
  cin >> n >> k;

  // решение
  long long left = 1;
  long long right = n;
  long long mid;

  // бинарный поиск по ответу
  while (right - left > 1) {
    mid = left + (right - left) / 2;
    int s = 0;
    int tmp = mid;

    // число написанных строк кода
    while (tmp) {
      s += tmp;
      tmp /= k;
    }

    if (s >= n) {
      right = mid;
    } else {
      left = mid;
    }
  }

  // вывод результата
  cout &lt;&lt; right;
}
</pre>
  </details>
</article>


<!-- Задача D. Факториал -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Факториал</h3>

  <div><i>Ограничение по времени 0.25с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Ваша задача найти такое минимальное натуральное число N, что N! содержит ровно Q нулей в конце своей десятичной записи. Как вам известно, N!=1⋅2⋅3⋅...⋅N. Например, 5!=120, 120 оканчивается на 1   ноль.</p>

  <h4>Входные данные</h4>
  <p>На вход подается одно число Q. (0 ≤ Q ≤ 10⁸).</p>

  <h4>Выходные данные</h4>
  <p>Выведите «No solution», если такого N не существует, иначе выведите N.</p>

  <details>
    <summary>Пример</summary>
    <code>2</code>
    <code>10</code>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

// Функция для подсчёта количества нулей в конце N!
int countTrailingZeros(long long N) {
  int count = 0;
  for (long long divisor = 5; divisor &lt;= N; divisor *= 5) {
    count += N / divisor;
  }
  return count;
}

// Функция для нахождения минимального N,
// такого что N! имеет Q нулей в конце
long long findMinN(int Q) {
  if (Q == 0) {
    return 1;
  }

  long long low = 0;
  long long high = 5LL * 1e8; // Достаточно большое число
  long long answer = -1;

  while (low &lt;= high) {
    long long mid = (low + high) / 2;
    int zeros = countTrailingZeros(mid);

    if (zeros == Q) {
      answer = mid;
      high = mid - 1; // Ищем минимальное N
    } else if (zeros &lt; Q) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }

  return answer;
}

int main() {
  int Q;
  cin >> Q;

  long long res = findMinN(Q);

  if (res == -1) {
    cout &lt;&lt; "No solution";
  } else {
    cout &lt;&lt; res;
  }
}
</pre>
  </details>
</article>


<!-- Задача E. Ден и коровы -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Ден и коровы</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>У Дена много коров. Также он имеет множество стойл, которые расположены вдоль прямой. Он желает расставить коров в стойла таким образом, чтобы минимальное расстояние между любыми двумя коровами было как можно больше. Помогите Дену расставить коров.</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержатся два числа n и k (1 ≤ n ≤ 10⁵, 1 ≤ k ≤ n) - количество коров и стойл. Во второй строке записаны координаты стойл a₁ ... aₙ (1 ≤ aᵢ ≤ 10⁹).</p>

  <h4>Выходные данные</h4>
  <p>Вывести единственное число - максимальное минимальное расстояние между любыми 2 коровами.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
7 4
1 2 3 5 8 13 21
</pre>
    <code>5</code>

    <h4>Пример 2</h4>
<pre>
7 5
1 2 4 8 16 32 1000000000
</pre>
    <code>7</code>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

// условная компиляция
#ifdef _DEBUG
freopen("input.txt", "rt", stdin);
freopen("output.txt", "wt", stdout);
#endif

  // ввод данных
  int n; // число стойл
  int k; // число коров
  cin >> n >> k;

  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  sort(A.begin(), A.end());

  int left = 0;
  int right = A[n - 1] - A[0] + 1;

  // бинарный поиск по ответу
  while ( right - left > 1) {
    int mid = left + (right - left) / 2;
    // mid - расстояние между занятыми стойлами
    int cnt = 1; // число занятых стойл
    int stoilo = A[0]; // последнее занятое стойло

    for (int i = 1; i &lt; n; i++) {
      if (A[i] - stoilo >= mid) {
        cnt++;
        stoilo = A[i];
        if (cnt == k) {
          break;
        }
      }
    }

    if (cnt >= k) {
      left = mid;
    } else {
      right = mid;
    }
  }

  // вывод результата
  cout &lt;&lt; left;
}
</pre>
  </details>
</article>


<!-- Задача F. Покраска забора -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Покраска забора</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Том Сойер уговорил n своих друзей помочь ему в нелегком деле покраски забора, окружающего дом тетушки Полли. Забор представляет собой k последовательных досок, пронумерованных от 1 до k, причем после k-й доски опять идет первая.</p>

  <p>Друзья Тома очень привередливы, i-й друг согласен участвовать в покраске только в том случае, если ему дадут покрасить участок из ровно ai последовательных досок. Кисточка у Тома только одна, поэтому друзья будут красить по очереди и сразу весь отведенный им отрезок. Тому остается лишь выбрать порядок, в котором приглашать друзей, а также выбрать для каждого желаемое количество последовательных досок.</p>

  <p>При этом каждый из друзей Тома готов красить как еще неокрашенную доску забора, так и доску, которую уже покрасил один из его предшественников. Тем не менее, друзья получают больше удовольствия от покраски неокрашенной доски. Том хочет выбрать число x и распределить отрезки забора для покраски таким образом, чтобы каждый из его друзей покрасил хотя бы x неокрашенных досок. Том очень любит своих друзей и хочет, чтобы каждый из них получил от процесса покраски забора максимальное удовольствие, поэтому он пытается максимизировать x.</p>

  <p>Помогите Тому понять, сколько радости он сможет доставить своим друзьям.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит два целых числа n (1 ≤ n ≤ 10⁵) и k (1 ≤ k ≤ 10⁹). Следующая строка содержит n целых чисел — значения aᵢ (1 ≤ aᵢ ≤ k).</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно число — максимальное возможное значение x.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
2 100
5 10
</pre>
    <code>5</code>
    <p>В первом примере x = 5, так как один из друзей просто не хочет красить больше пяти досок. Он придет первым, покрасит свои пять, после чего еще 10 неокрашенных досок достанется второму другу Тома. Оставшиеся 85 досок Тому придется красить самому.</p>

    <h4>Пример 2</h4>
<pre>
4 10
7 8 3 5
</pre>
    <code>2</code>
    <p>Во втором примере достичь x = 2 можно, например, так. Сначала третий друг красит доски с 4 по 6 (3 неокрашенных доски). Затем четвертый друг красит доски с 1 по 5 (3 неокрашенных доски). Затем второй друг красит доски с 1 по 8 (2 неокрашенных доски). Наконец, первый друг красит доски с 6 по 10 и с 1 по 2 (2 неокрашенных доски, заметим, что забор идет по циклу и эти доски образуют последовательный отрезок).</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Отсортируем друзей по числу покрашенных досок. Чтобы каждый мог покрасить хотя бы x незакрашенных досок, то x должен быть не больше min(ai). Каждый следующий друг красит сначала уже закрашенные доски, потом x незакрашенных.</p>
    <p>Чтобы не выйти за границы типа данных, возьмем тип long long</p>

    <h4>Пример 2</h4>
<pre>
4 10
8 8 8 8
</pre>
    <code>0</code>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // ввод данных
  int n; // число друзей
  int k; // число досок
  cin >> n >> k;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i]; // сколько досок красит один друг
  }

  // решение
  sort(A.begin(), A.end());
  // чтобы каждый друг покрасил x неокрашенных досок,
  // x не может превышать min(ai)
  long long left = 0;
  long long right = A[0] + 1;

  // бинарный поиск по ответу
  while (right - left > 1) {
    long long mid = left + (right - left) / 2;
    long long sum = A[0]; // сумма покрашенных досок

    // добавляем к покрашенным доскам mid непокрашенных
    for (int i = 1; i &lt; n; i++) {
      // сумма не может быть меньше
      // уже покрашенных досок плюс новых mid непокрашенных
      if (sum + mid > A[i]) {
        sum = sum + mid;
      } else {
        sum = A[i];
      }
    }

    if (sum &lt;= k) {
      left = mid;
    } else {
      right = mid;
    }
  }

  // вывод результата
  cout &lt;&lt; left;
}
</pre>
  </details>
</article>


<!-- Задача G. Ярость Битвы -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Ярость Битвы</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Герой по имени Магина сражается с группой из n монстров с помощью легендарного топора, известного как Ярость Битвы. Каждый из монстров имеет aᵢ очков здоровья. Каждым ударом топора Магина уменьшает здоровье того, кого он ударил, на p очков, при этом уменьшая здоровье всех остальных монстров на q очков. Монстр умирает, когда у него остается 0 или менее очков здоровья. Магина хочет при каждом ударе выбирать цель таким образом, чтобы убить всех монстров за минимальное количество ударов. Требуется определить это количество.</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержатся три целых числа через пробел: n, p и q (1 ≤ n ≤ 200000, 1 ≤ q ≤ p ≤ 10⁹) — количество монстров, урон по цели и урон по всем остальным соответственно.</p>

  <p>Во второй строке содержатся n целых чисел через пробел: aᵢ (1 ≤ aᵢ ≤ 10⁹) — количество очков здоровья у каждого из монстров.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное целое число — минимальное количество ударов, за которое Магина сможет убить всех монстров.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
2 3 2
5 5
</pre>
    <code>2</code>

    <h4>Пример 1</h4>
<pre>
3 5 3
17 13 14
</pre>
    <code>5</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/gym/100247/problem/F" target="_blank">Задача 100247F</a>
      <br><a href="https://codeforces.com/gym/100247" target="_blank">2013, Отборочный контест СГАУ на четвертьфинал ACM ICPC 2013-10-12</a>
    </div>

    <p>Удар топором наносит точечный урон монстру по которому бьем и общий урон всем остальным монстрам. Разделим удар топором на две части - удар копьем это урон только одному монстру и удар мечем это урон всем остальным монстрам.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ввод данных
  int n; // число монстров
  long long p; // урон по цели
  long long q; // урон по всем остальным
  cin >> n >> p >> q;
  vector&lt;long long&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  long long l, r, mid, sum;
  vector&lt;long long&gt; Buf(n);
  sort(A.begin(), A.end());

  if (p == q && A[n - 1] % q != 0) {
    cout &lt;&lt; A[n - 1] / q + 1;
  } else if (p == q && A[n - 1] % q == 0) {
    cout &lt;&lt; A[n - 1] / q;
  } else {
    l = 0, r = 1e9 + 1;
    p = p - q;

    // бинарный поиск
    while (r - l > 1) {
      mid = (r + l) / 2;
      sum = 0;
      for (int i = 0; i &lt; n; i++) {
        if (A[i] - mid * q > 0) {
          Buf[i] = A[i] - mid * q;
        } else {
          Buf[i] = 0;
        }
      }
      for (int i = 0; i &lt; n; i++) {
        sum += Buf[i] / p;
        if (Buf[i] % p != 0) {
          sum++;
        }
      }
      if (sum > mid) {
        l = mid;
      } else {
        r = mid;
      }
    }

    // вывод результата
    cout &lt;&lt; r;
  }
}
</pre>
  </details>
</article>


<!-- Задача H. Гамбургеры -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Гамбургеры</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Поликарп очень любит гамбургеры, особенно приготовленные собственноручно. Поликарп считает, что существует только три достойных ингредиента для приготовления гамбургера: хлеб, колбаса и сыр. Рецепт своего знаменитого «гамбургера от Поликарпа» он записывает в виде строки из букв 'B' (хлеб), 'S' (колбаса) и 'C' (сыр). В рецепте ингредиенты перечисляются снизу вверх, например, рецепт «ВSCBS» обозначает гамбургер в котором снизу вверх идут: хлеб, колбаса, сыр, хлеб и снова колбаса.</p>

  <p>На кухне у Поликарпа в наличии n<sub>b</sub> кусочков хлеба, n<sub>s</sub> кусочков колбасы и n<sub>c</sub> кусочков сыра. Кроме того, в магазине неподалеку есть в продаже все три ингредиента по цене: p<sub>b</sub> рублей за кусок хлеба, p<sub>s</sub> — за кусок колбасы и p<sub>c</sub> — за кусочек сыра.</p>

  <p>У Поликарпа есть r рублей, которые он готов потратить в магазине. Какое наибольшее количество гамбургеров он сможет приготовить? Считается, что ломать или резать любой из кусочков (хлеба, колбасы, сыра) нельзя, а также что в магазине есть бесконечно много кусочков каждого из ингредиентов.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных содержится непустая строка, описывающая рецепт «гамбургера от Поликарпа». Длина строки не превосходит 100, строка содержит только буквы 'B' (прописная латинская B), 'S' (прописная латинская S) и 'C' (прописная латинская C).</p>

  <p>Вторая строка содержит три целых числа n<sub>b</sub>, n<sub>s</sub>, n<sub>c</sub> (1 ≤ n<sub>b</sub>, n<sub>s</sub>, n<sub>c</sub> ≤ 100) — количество кусочков хлеба, колбасы и сыра на кухне Поликарпа. Третья строка содержит три целых числа p<sub>b</sub>, p<sub>s</sub>, p<sub>c</sub> (1 ≤ p<sub>b</sub>, p<sub>s</sub>, p<sub>c</sub> ≤ 100) — цена одного кусочка хлеба, колбасы и сыра в магазине. Наконец, четвертая строка содержит целое число r (1 ≤ r ≤ 10¹²) — количество рублей у Поликарпа.</p>

  <p>Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.</p>

  <h4>Выходные данные</h4>
  <p>Выведите наибольшее количество гамбургеров, которое Поликарп может приготовить. Если он не может приготовить ни одного гамбургера, выведите 0.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
BBBSSC
6 4 1
1 2 3
4
</pre>
    <code>2</code>

    <h4>Пример 2</h4>
<pre>
BBC
1 10 1
1 10 1
21
</pre>
    <code>7</code>

    <h4>Пример 3</h4>
<pre>
BSC
1 1 1
1 1 3
1000000000000
</pre>
    <code>200000000001</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/371/problem/C" target="_blank">Задача 371C</a>
      <br><a href="https://codeforces.com/contest/371" target="_blank">Codeforces Round 218 (Div. 2) 2013-12-08</a>
    </div>

<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  string str;
  cin >> str;
  long long b, s, c;
  cin >> b >> s >> c;
  long long pb, ps, pc;
  cin >> pb >> ps >> pc;
  long long q;
  cin >> q;

  // решение
  long long l = 0;
  long long r = 1e14;
  long long mid;
  long long B = 0, S = 0, C = 0;
  for (int i = 0; i &lt; str.size(); i++) {
    if (str[i] == 'B') {
      B++;
    }
    if (str[i] == 'S') {
      S++;
    }
    if (str[i] == 'C') {
      C++;
    }
  }

  // бинарный поиск
  while (r - l > 1) {
    mid = (l + r) / 2;
    long long sum_mid = 0;
    if (B * mid > b) {
      sum_mid += (B * mid - b) * pb;
    }
    if (S * mid > s) {
      sum_mid += (S * mid - s) * ps;
    }
    if (C * mid > c) {
      sum_mid += (C * mid - c) * pc;
    }
    if (sum_mid &lt;= q) {
      l = mid;
    } else {
      r = mid;
    }
  }

  // вывод результата
  cout &lt;&lt; l;
}
</pre>
  </details>
</article>


<!-- Задача I. Шаги -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача I. Шаги</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Однажды Вася вышел во двор погулять, а там не оказалось его друзей, с которыми он обычно играл в салки. Мальчик не растерялся и решил поиграть в салки сам с собой. «Как он это сделал?» — спросите вы. Очень просто.</p>

  <p>Вася заметил, что двор представляет собой прямоугольное поле размером n * m клеток, а каждая клетка имеет координаты (x, y) (1 ≤ x ≤ n, 1 ≤ y ≤ m), где x — номер строки поля, y — номер столбца поля.</p>

  <p>Изначально, Вася стоит в клетке с координатами (x<sub>c</sub>, y<sub>c</sub>). Для игры у него заготовлен список из k векторов (dxᵢ, dyᵢ) ненулевой длины. Действие игры происходит следующим образом. Мальчик рассматривает все вектора в порядке от 1 до k, и по очереди выбирает каждый из них в качестве текущего. Выбрав вектор в качестве текущего, мальчик делает максимально возможное количество корректных шагов по направлению этого вектора (возможно, ноль шагов).</p>

  <p>Шагом называется одно перемещение из клетки, где сейчас стоит мальчик, в направлении текущего вектора. То есть, если Вася находится в клетке (x, y), а текущий вектор — (dx, dy), то за один шаг Вася перемещается в клетку (x + dx, y + dy). Шаг считается корректным, если, совершая этот шаг, мальчик не выходит за пределы двора.</p>

  <p>Вася шагал и шагал, шагал и шагал, до тех пор, пока вектора из его списка не закончились. Он так много шагал, что совершенно позабыл, сколько шагов он сделал. Помогите мальчику — посчитайте, сколько шагов он сделал.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных даны два целых числа n и m (1 ≤ n, m ≤ 10⁹) — размеры двора. Во второй строке записаны целые числа x<sub>c</sub> и y<sub>c</sub> — координаты начальной клетки (1 ≤ x<sub>c</sub> ≤ n, 1 ≤ y<sub>c</sub> ≤ m).</p>

  <p>В третьей строке задано целое число k (1 ≤ k ≤ 10⁴) — количество векторов. Далее идут k строк, в каждой из которых записаны два целых числа dxᵢ и dyᵢ (|dxᵢ|, |dyᵢ| ≤ 10⁹, |dx| + |dy| ≥ 1).</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное целое число — количество шагов, которые сделал Вася.</p>

  <p>Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
4 5
1 1
3
1 1
1 1
0 -2
</pre>
    <code>4</code>
    <p>В первом примере Вася изначально находится в клетке (1, 1) и делает 3 шага по первому вектору (1, 1) последовательно посещая клетки: (2, 2), (3, 3), (4, 4). Затем он делает 0 шагов по второму вектору (1, 1). И 1 шаг по третьему вектору (0, -2) и оказывается в клетке (4, 2). В итоге Вася сделает 4 шага.</p>

    <h4>Пример 2</h4>
<pre>
10 10
1 2
1
-1 0
</pre>
    <code>0</code>
    <p>Во втором примере Вася изначально находится в клетке (1, 2) и делает 0 шагов по вектору (-1, 0), так как клетка с координатами (0, 2) находится вне двора.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/152/problem/B" target="_blank">Задача 152B</a>
      <br><a href="https://codeforces.com/contest/371" target="_blank">Codeforces Round 108 (Div. 2) 2012-02-20</a>
    </div>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
// условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // ввод данных
  long long n, m; // размеры двора
  cin >> n >> m;
  long long x, y; // координаты начала
  cin >> x >> y;
  int k; // число векторов
  cin >> k;
  vector&lt;pair&lt;long long, long long&gt; &gt; A(k);
  long long dx, dy;
  for (int i = 0; i &lt; k; i++) {
    cin >> dx;
    cin >> dy;
    A[i] = pair(dx, dy);
  }

  // решение
  long long steps = 0;
  long long nm = max(n, m);
  for (int i = 0; i &lt; k; i++) {
    dx = A[i].first;
    dy = A[i].second;

    long long left = 0;
    long long right = nm;

    // бинарный поиск по ответу
    // проверим что мы можем передвинуться на mid шагов
    while (right - left > 1) {
      long long mid = left + (right - left) / 2;
      if ((x + mid * dx &lt;= n) && (y + mid * dy &lt;= m) &&
        (x + mid * dx > 0) && (y + mid * dy > 0)) {
        left = mid;
      } else {
        right = mid;
      }
    }

    // сделаем left шагов из вектора A[i]
    x += left * dx;
    y += left * dy;
    steps += left;;
  }

  // вывод результата
  cout &lt;&lt; steps;
}
</pre>
  </details>
</article>


<!-- Задача J. Осада Вальгаллы -->
<article class="article">
  <div class="anchor" id="task10"></div>
  <h3>Задача J. Осада Вальгаллы</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Ивар Бескостный — великий лидер. Он пытается захватить Каттегат, в данный момент находящийся под контролем Лагерты. Битва началась, и волны воинов Ивара гибнут одна за другой.</p>

  <p>У Ивара n воинов, он выставляет их вдоль прямой напротив главных ворот так, что i-й воин стоит сразу за (i-1)-м воином. Первый воин возглавляет атаку.</p>

  <p>Каждый атакующий воин может выдержать до aᵢ стрел, прежде чем он падёт, где aᵢ — сила i-го воина.</p>

  <p>Лагерта приказывает своим воинам выпустить kᵢ стрел в течение i-й минуты, стрелы одна за одной поражают первого всё ещё стоящего воина. После того, как все воины Ивара падут и стрелы, находящиеся в воздухе в данный момент, пролетят, Тор бьёт по земле своим молотом и все воины Ивара получают свои силы назад и возвращаются в битву. Другими словами, если все воины умрут в минуту t, в конце этой минуты t они все встанут и будут сражаться.</p>

  <p>Битва будет идти q минут. После каждой минуты вы должны сообщить Ивару, сколько из его воинов находится в строю.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит два целых числа n и q (1 ≤ n, q ≤ 200000) — число воинов Ивара и длительность боя в минутах.</p>

  <p>Вторая строка содержит n целых чисел a₁, a₂, ...,aₙ (1 ≤ aᵢ ≤ 10⁹), обозначающих силы воинов Ивара.</p>

  <p>Третья строка содержит q целых чисел k₁, k₂, ..., k<sub>q</sub> (1 ≤ kᵢ ≤ 10¹⁴), i-е из которых означает число стрел kᵢ, которое будет выпущено в воинов Ивара по приказу Лагерты в минуту i.</p>

  <h4>Выходные данные</h4>
  <p>Выведите q строк, i-я из которых содержит число воинов Ивара, находящихся в строю после i-й минуты.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
5 5
1 2 1 2 1
3 10 1 1 1
</pre>
<pre>
3
5
4
4
3
</pre>
    <p>В первом примере:</p>
    <ul>
      <li>после 1-й минуты 1-й и 2-й воины умрут.</li>
      <li>после 2-й минуты все воины умрут (а оставшиеся стрелы будут потрачены впустую), после чего их воскресят, поэтому ответ — 5, все воины живы.</li>
      <li>после 3-й минуты 1-й воин умирает.</li>
      <li>после 4-й минуты во 2-го воина попадут и его сила упадёт на 1.</li>
      <li>после 5-й минуты 2-й воин умрёт.</li>
    </ul>

    <h4>Пример 2</h4>
<pre>
4 4
1 2 3 4
9 1 10 6
</pre>
<pre>
1
4
4
1
</pre>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/975/problem/C" target="_blank">Задача 975C</a>
      <br><a href="https://codeforces.com/contest/975" target="_blank">Codeforces Round 478 (Div. 2) 2018-05-01</a>
    </div>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

// условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // ввод данных
  int n; // число воинов
  int q; // число минут
  cin >> n >> q;
  vector&lt;long long&gt; A(n+1);
  for (int i = 1; i &lt;= n; i++) {
    cin >> A[i]; // сила i-го воина
  }
  vector&lt;long long&gt; K(q+1);
  for (int i = 1; i &lt;= q; i++) {
    cin >> K[i]; // число стрел в i-ю минуту
  }

  // решение
  int cur_voin = 1; // текущий воин
  long long cur_sila = A[cur_voin]; // сила текущего воина

  // соберем префикс-сумму сил воинов
  vector&lt;long long&gt; Pref(n + 1);
  Pref[0] = 0;
  for (int i = 1; i &lt;= n; i++) {
    Pref[i] = Pref[i - 1] + A[i];
  }

  // для каждой минуты
  for (int i = 1; i &lt;= q; i++) {
    long long k = K[i]; // число стрел

    // пока есть стрелы
    while (k > 0) {

      if (cur_sila > k) {
        // если сила воина больше числа стрел
        // то воин выживает и его сила уменьшается
        cur_sila -= k;
        k = 0;
      } else if (k > Pref[n] - Pref[cur_voin] + cur_sila) {
        // если число стрел больше силы воина и всех следующих воинов
        // то все они погибают и встанут опять
        k = 0;
        cur_voin = 1;
        cur_sila = A[cur_voin];
      } else {
        // если стрелы убьют не всех воинов
        // то найдем до какого воина убьют воинов
        int left = cur_voin;
        int right = n + 1;

        // бинарный поиск по префикс-сумме
        while (right - left > 1) {
          int mid = left + (right - left) / 2;
          if (k > Pref[mid] - Pref[cur_voin] + cur_sila) {
            left = mid;
          } else {
            right = mid;
          }
        }

        k -= Pref[left] - Pref[cur_voin] + cur_sila;
        cur_voin = left;
        cur_sila = A[cur_voin];
        if (cur_voin &lt; n) {
          cur_voin++;
          cur_sila = A[cur_voin];
        } else {
          k = 0;
          cur_voin = 1;
          cur_sila = A[cur_voin];
        }
      }
    }

    // вывод результата
    cout &lt;&lt; n + 1 - cur_voin &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача K. Сбалансированные кучки камней -->
<article class="article">
  <div class="anchor" id="task11"></div>
  <h3>Задача K. Сбалансированные кучки камней</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В ряд находятся n кучек камней. В i-й кучке изначально hi камней. Вы хотите изменить число камней в кучках, выполнив следующий процесс один раз:</p>
  <ul>
    <li>Вы идете по кучкам от 3-й до n-й, в таком порядке.</li>
    <li>Пусть i — номер текущей кучки.</li>
    <li>Вы можете выбрать целое число d (0 ≤ 3⋅d ≤ hᵢ), переместить d камней из i-й кучки в (i-1)-ю кучку, и 2⋅d камней из i-й кучки в (i-2)-ю.</li>
    <li>Таким образом, hᵢ уменьшается на 3⋅d, hᵢ₋₁ увеличивается на d, и hᵢ₋₂ увеличивается на 2⋅d.</li>
    <li>Вы можете выбирать различные или одинаковые d для различных операций. Некоторые кучки могут стать пустыми, но они все еще считаются за кучки.</li>
  </ul>

  <p>Какое наибольшее число камней в наименьшей кучке может получиться после завершения процесса?</p>

  <h4>Входные данные</h4>
  <p>Во входных данных находятся несколько наборов входных данных. В первой строке находится одно целое число t (1 ≤ t ≤ 2⋅10⁵) — количество наборов входных данных. Далее следуют наборы входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит целое число n (3 ≤ n ≤ 2⋅10⁵).</p>

  <p>Вторая строка каждого набора содержит n целых чисел h₁, h₂, h₃, ...,hₙ (1 ≤ hᵢ ≤ 10⁹).</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превосходит 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите максимальное число камней, которое может содержать наименьшая по количеству камней кучка после завершения процесса.</p>

  <details>
    <summary>Пример</summary>
<pre>
4
4
1 2 10 100
4
100 100 100 1
5
5 1 1 1 8
6
1 2 3 4 5 6
</pre>
<pre>
7
1
1
3
</pre>
    <p>В первом примере изначально размеры кучек равны [1,2,10,100]. Мы можем перемещать камни следующим образом.</p>
    <ul>
      <li>переместить 3 и 6 камней с 3-й кучки на 2-ю и 1-ю кучки соответственно. Размеры кучек будут равны [7,5,1,100];</li>
      <li>Переместить 6 и 12 камней с последней кучки на 3-ю и 2-ю кучки соответственно. Размеры кучек будут равны [7,17,7,82].</li>
    </ul>

    <p>Во втором наборе размер последней кучки равен 1 и мы не можем его увеличить.</p>

    <p>В третьем наборе оптимально не перемещать никакие камни.</p>

    <p>В четвертом примере можно достичь состояния, в котором размеры кучек равны [3,5,3,4,3,3].</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1623/problem/C" target="_blank">Задача 1623C</a>
      <br><a href="https://codeforces.com/contest/1623" target="_blank">Codeforces Round 763 (Div. 2) 2021-12-28</a>
    </div>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

// условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // число кучек
    cin >> n;
    vector&lt;int&gt; A(n+1);
    for (int i = 1; i &lt;= n; i++) {
      cin >> A[i]; // число камней в кучке i
    }

    // решение
    int left = 1;
    int right = 1e9;

    // бинарный поиск по ответу
    while (right - left > 1) {
      int mid = left + (right - left) / 2;
      bool flag = true;
      vector&lt;int&gt; B(n+1);
      for (int i = 1; i &lt;= n; i++) {
        B[i] = A[i];
      }
      for (int i = n; i >= 3; i--) {
        if (B[i] >= mid) {
          B[i - 1] += min(A[i], B[i] - mid) / 3;
          B[i - 2] += min(A[i], B[i] - mid) / 3 * 2;
        } else {
          flag = false;
        }
      }
      if (B[1] &lt; mid || B[2] &lt; mid) {
        flag = false;
      }
      if (flag) {
        left = mid;
      } else {
        right = mid;
      }
    }

    // вывод результата
    cout &lt;&lt; left &lt;&lt; '\n';
  }

}
</pre>
  </details>
</article>


<!-- Задача L. Обои -->
<article class="article">
  <div class="anchor" id="task12"></div>
  <h3>Задача L. Обои</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Игорь и Ира решили поклеить новые обои в комнате, а то некрасиво жить с обоями от предыдущих жильцов. Сама комната представляет собой параллелепипед с шириной a, длиной b и высотой c. Окна и двери настолько узкие, что Игорь их не учитывает. Обои продаются в рулонах и для поклейки будут разрезаться только поперек.</p>

  <p>В магазине Ире понравились очень красивые обои шириною w и длиною h со сложным рисунком имеющим раппорт длины r. Все рулоны одинаковые и начинаются с одинакового рисунка.</p>

  <p>Игорь и Ира начнут клеить обои с начала рулона и первый кусок приклеят, состыковав его с потолком по ширине рулона. Помогите Игорю и Ире определить какое минимальное количество рулонов обоев им потребуется, если это невозможно сделать выведите -1.</p>

  <h4>Входные данные</h4>
  <p>На вход подается 6 целых положительных чисел a, b, c, h, w, r — длина, ширина, высота комнаты, длина, ширина одного рулона обоев и их раппорт (1 ≤ a, b, c, h, w, r ≤ 10⁶, h ≥ r).</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно целое число минимальное количество рулонов, необходимых для поклейки обоев.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>400 300 200 1000 100 100</code>
    <code>3</code>

    <h4>Пример 2</h4>
    <code>400 300 200 1000 120 100</code>
    <code>-1</code>
    <p>Раппорт на обоях (шаг рисунка) — это расстояние между повторяющимися элементами рисунка.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <h4>Тест 3</h4>
    <code>12 84 25 43 8 10</code>
    <code>18</code>

    <h4>Тест 4</h4>
    <code>63 32 55 35 2 25</code>
    <code>190</code>

<pre>
#include &lt;iostream&gt;

using namespace std;

typedef long long ll;

int main() {
  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // ввод данных
  int a; // ширина комнаты
  int b; // длина комнаты
  int c; // высота комнаты
  int h; // длина рулона
  int w; // ширина рулона
  int r; // раппорт рулона
  cin >> a >> b >> c >> h >> w >> r;

  // решение

  // периметр комнаты
  ll p = 2 * (a + b);

  // если нужно резать рулон по ширине то ответ -1
  if (p % w != 0) {
    cout &lt;&lt; -1;
    return 0;
  }

  // необходимое число полос на комнату
  ll strips = p / w;

  // режем полоску на повторяющиеся кусочки
  ll pieces_in_strip = c / r; // число повторяющихся кусочков в полоске
  ll rest_strip = c - pieces_in_strip * r; // размер остатка в полоске

  ll rest_in_strip = 0; // число остатков
  if (rest_strip > 0) {
    rest_in_strip = strips;
  }

  // необходимое число кусочков на комнату
  ll needed_pieces = pieces_in_strip * strips + rest_in_strip;

  // режем рулон на повторяющиеся кусочки
  ll pieces_in_roll = h / r; // число повторяющихся кусочков в рулоне
  ll rest_roll = h - pieces_in_roll * r; // размер остатка в рулоне

  // если размер остатка в рулоне больше или равен
  // размеру остатка в полоске то его тоже можно считать
  bool can_count_rest = false;
  if (rest_strip > 0 && rest_roll >= rest_strip) {
    can_count_rest = true;
  }

  ll left = 0;
  ll right = 1e15;

  // бинарный поиск по ответу
  while (right - left > 1) {
    ll mid = left + (right - left) / 2;

    // число повторяющихся кусочков из mid рулонов
    ll pieces_in_mid = mid * pieces_in_roll;

    // если полоски содержат остатки, не равные раппорту
    // и если остатки в рулоне больше остатков в полосках
    // тогда добавим число остатков в рулоне, которые закроют остатки полосок
    if (can_count_rest) {
      if (mid &lt;= strips) {
        pieces_in_mid += mid;
      } else {
        pieces_in_mid += strips;
      }
    }

    if (pieces_in_mid >= needed_pieces) {
      right = mid;
    } else {
      left = mid;
    }
  }

  // вывод результата
  cout &lt;&lt; right;
}
</pre>
  </details>
</article>


<!-- Задача M. Мафия -->
<article class="article">
  <div class="anchor" id="task13"></div>
  <h3>Задача M. Мафия</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Как-то раз собрались n друзей, чтобы сыграть в «Мафию». В каждом раунде игры «Мафия» должен быть назначен ведущий (кто-то один из ребят), остальные n - 1 человек принимают участие в игре. Для каждого человека известно, в каком количестве раундов он хочет принять участие как игрок, а не как ведущий: i-ый человек хочет сыграть aᵢ раундов. Какое минимальное количество раундов игры «Мафия» нужно сыграть, чтобы каждый человек сыграл как минимум столько раундов, сколько хочет?</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое число n (3 ≤ n ≤ 10⁵). Во второй строке через пробел записаны n целых чисел a₁, a₂, ..., aₙ (1 ≤ aᵢ ≤ 10⁹) — i-ое число в списке обозначает количество раундов, которое хочет сыграть i-ый человек.</p>

  <h4>Выходные данные</h4>
  <p>В единственную строку выведите целое число — минимальное количество раундов игры, которое нужно сыграть, чтобы i-ый человек сыграл как минимум aᵢ раундов.</p>

  <p>Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
3
3 2 2
</pre>
    <code>4</code>

    <h4>Пример 2</h4>
<pre>
4
2 2 2 2
</pre>
    <code>3</code>
  </details>

  <details>
    <summary>Решение с бинарным поиском</summary>

    <div>
      <a href="https://codeforces.com/contest/348/problem/A" target="_blank">Задача 348A</a>
      <br><a href="https://codeforces.com/contest/348" target="_blank">Codeforces Round 202 (Div. 1) 2013-09-27</a>
    </div>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ввод данных
  long long n;
  cin >> n;
  vector&lt;long long&gt; A(n);
  long long max1 = 0;
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
    max1 = max(max1, A[i]);
  }

  // решение
  long long left = max1;
  long long right = 3 * max1;
  long long mid = 0;

  // бинарный поиск по ответу
  while (right - left > 1) {
    mid = left + (right - left) / 2;
    long long count = mid;

    for (int i = 0; i &lt; n; i++) {
      count -= (mid - A[i]);
    }
    if (count &lt;= 0) {
      right = mid;
    } else {
      left = mid;
    }
  }
  mid = left;
  long long count = mid;

  for (int i = 0; i &lt; n; i++) {
    count -= (mid - A[i]);
  }

  // вывод результата
  if (count &lt;= 0) {
    cout &lt;&lt; left;
  } else {
    cout &lt;&lt; right;
  }
}
</pre>
  </details>

  <details>
    <summary>Решение без бинарного поиска</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;
  long long sum = 0, max1 = 0;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
    sum += A[i];
    if (A[i] > max1) {
      max1 = A[i];
    }
  }

  // решение
  int x = ceil(sum / (n - 1.0));

  // вывод результата
  if (x >= max1) {
    cout &lt;&lt; x;
  } else {
    cout &lt;&lt; max1;
  }
}
</pre>
  </details>
</article>


<!-- Задача N. Подземелье -->
<article class="article">
  <div class="anchor" id="task14"></div>
  <h3>Задача N. Подземелье</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вы играете в новую компьютерную игру, в которой необходимо сражаться с монстрами. В очередном подземелье вы встретили трех монстров; у одного из них a очков здоровья, у второго b очков здоровья, а у третьего — c.</p>

  <p>Для убийства монстров у вас есть пушка, которая наносит 1 единицу урона выбранному монстру. При этом каждый 7-й (т. е. выстрелы с номерами 7, 14, 21 и т. д.) выстрел пушки усиленный и наносит 1
  урона всем монстрам, а не только одному из них. Если текущее здоровье монстра равно 0, он не может быть целью обычного выстрела и не получает урона от усиленного выстрела.</p>

  <p>Вы хотите красиво пройти подземелье, а именно, убить всех монстров одним и тем же усиленным выстрелом (т. е. после очередного усиленного выстрела очки здоровья каждого из монстров должны впервые стать равными 0). Каждый выстрел должен попадать в монстра, т. е. вы не можете стрелять мимо цели.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одного целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Каждый набор входных данных состоит из единственной строки, которая содержит три целых числа a, b  и c (1 ≤ a, b,c ≤ 10⁸) — количество очков здоровья у каждого из монстров.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите YES, если можно убить всех монстров одним и тем же усиленным выстрелом. Иначе выведите NO. Каждую букву можно выводить в любом регистре (например, YES, Yes, yes, yEs будут распознаны как положительный ответ).</p>

  <details>
    <summary>Пример</summary>
<pre>
3
3 2 4
1 1 1
10 1 7
</pre>
<pre>
YES
NO
NO
</pre>
    <p>В первом примере вы можете действовать следующим образом:</p>
    <ul>
      <li>1-й выстрел в первого монстра,</li>
      <li>2-й выстрел во второго монстра,</li>
      <li>3-й выстрел в третьего монстра,</li>
      <li>4-й выстрел в первого монстра,</li>
      <li>5-й выстрел в третьего монстра,</li>
      <li>6-й выстрел в третьего монстра</li>
      <li>и 7-й усиленный выстрел убьет всех монстров.</li>
    </ul>
    <p>Во втором примере вы не можете убить монстров усиленным выстрелом, т. к. суммарное количество очков здоровья монстров равно 3, и вы убьете их за первые 3 выстрела.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1463/problem/A" target="_blank">Задача 1463A</a>
      <br><a href="https://codeforces.com/contest/1463" target="_blank">Educational Codeforces Round 100 (рейтинговый для Див. 2) 2020-12-17</a>
    </div>
    <p>Заметим, что за каждые 7 выстрелов мы наносим суммарно 9 единиц урона. Так как мы хотим убить всех монстров выстрелом кратным 7, то количество сделанных выстрелов равно 7k. При этом суммарно должно быть нанесено a+b+c единиц урона, отсюда k=a+b+c9 (если результат деления не целое число, то ответа не существует). Так как каждый монстр получит хотя бы k единиц урона (с усиленных выстрелов), то здоровье каждого монстра должно быть не меньше k. Если два вышеописанных условия выполняются, то оставшиеся выстрелы всегда можно распределить нужным образом.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int a, b, c; // здоровье монстров
    cin >> a >> b >> c;

    // решение
    bool maybe = true;

    // 7 выстрелов наносят 9 уронов здоровью
    // последний выстрел должен быть обязательно кратен 7
    if ((a + b + c) % 9 != 0) {
      maybe = false;
    }
    int k = (a + b + c) / 9;

    // каждый монстр должен вынести хотябы k выстрелов
    if (k > a || k > b || k > c) {
      maybe = false;
    }

    // вывод результата
    if (maybe) {
      cout &lt;&lt; "YES\n";
    } else {
      cout &lt;&lt; "NO\n";
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача O. Лопаты и мечи -->
<article class="article">
  <div class="anchor" id="task15"></div>
  <h3>Задача O. Лопаты и мечи</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Поликарп играет в известную компьютерную игру (мы не хотим упоминать ее название). В этой игре он может создавать инструменты двух видов — лопаты и мечи. На создание лопаты Поликарп тратит две палки и один алмаз; на создание меча Поликарп тратит два алмаза и одну палку.</p>

  <p>Каждый инструмент может быть продан за один изумруд. Как много изумрудов может заработать Поликарп, если у него есть a палок и b алмазов?</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит число t (1 ≤ t ≤ 1000) — количество наборов входных данных.</p>

  <p>Единственная строка каждого набора входных данных содержит два числа a и b (0 ≤ a, b ≤ 10⁹) — количество палок и алмазов соответственно.</p>

  <h4>Выходные данные</h4>
  <p>На каждый набор входных данных выведите число — максимальное количество изумрудов, которое может заработать Поликарп.</p>

  <details>
    <summary>Пример</summary>
<pre>
4
4 4
1000000000 0
7 15
8 7
</pre>
<pre>
2
0
7
5
</pre>
    <p>В первом наборе входных данных Поликарп может заработать два изумруда следующим образом: создать один меч и одну лопату.</p>
    <p>Во втором наборе входных данных у Поликарпа нет алмазов, а значит, он не сможет ничего создать.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1366/problem/A" target="_blank">Задача 1366A</a>
      <br><a href="https://codeforces.com/contest/1366" target="_blank">Educational Codeforces Round 89 (рейтинговый для Див. 2) 2020-06-11</a>
    </div>

    <p>Чтобы не выводить долго формулу будем использовать <strong>бинарный поиск по ответу</strong>. Придумаем функцию, которая равна 1 если можем заработать изумруды и 0 если не можем. 0 изумрудов всегда можно заработать, даже если не будет ни палок ни алмазов. Поэтому левая граница left = 0. Правая граница rigth = a + b, потому что столько изумрудов точно нельзя заработать. Найдем число изумрудов k такое, что k изумрудов мы можем заработать, а k + 1 уже нет.</p>
    <p>Для одного изумруда нужно 3 ресурса, из них 1 палка и 1 алмаз. Для k изумрудов нужно 3 * k ресурсов, из них k палок и k алмазов. Ответ будет в левом указателе left.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    long long a; // число палок
    long long b; // число алмазов
    cin >> a >> b;

    // решение
    long long left = 0;
    long long right = a + b;
    long long mid;

    // бинарный поиск
    while (right - left > 1) {
      mid = (right + left) / 2;

      // для каждого изумруда требуется 3 ресурса
      // их них 1 палка и 1 изумруд
      if ( (a + b >= 3 * mid) && (a >= mid) && (b >= mid) ) {
        left = mid;
      } else {
        right = mid;
      }
    }

    // вывод результата
    cout &lt;&lt; left &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача P. Слежка за отрезками -->
<article class="article">
  <div class="anchor" id="task16"></div>
  <h3>Задача P. Слежка за отрезками</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У вас есть массив a, состоящий из n нулей. Также, вам дан набор из m необязательно различных отрезков. Каждый отрезок задается двумя числами lᵢ и rᵢ (1 ≤ lᵢ ≤ rᵢ ≤ n) и представляет собой подмассив a<sub>l<sub>i</sub></sub>,a<sub>l<sub>i</sub>+1</sub>,…,a<sub>r<sub>i</sub></sub> массива a.</p>

  <p>Назовём отрезок lᵢ,rᵢ красивым, если количество единиц на этом отрезке строго больше, чем количество нулей. Например, если a=[1,0,1,0,1], тогда отрезок [1,5] является красивым (количество единиц равно 3, количество нулей равно 2), но отрезок [3,4] не является красивым (количество единиц равно 1, количество нулей равно 1).</p>

  <p>У вас также есть q изменений. Каждое изменение задано числом 1 ≤ x ≤ n, это означает, что вы должны присвоить элементу a<sub>x</sub> значение 1.</p>

  <p>Вы должны найти первое изменение, после которого хотя бы один из m заданных отрезков становится красивым, или сообщить, что ни один из них не является красивым после применения всех q изменений.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит два целых числа n и m (1 ≤ m ≤ n ≤ 10⁵) — размер массива a и количество отрезков соответственно.</p>

  <p>Далее следует m строк, состоящих из двух чисел lᵢ и rᵢ (1 ≤ lᵢ ≤ rᵢ ≤ n) — границы отрезков.</p>

  <p>В следующей строке дано целое число q (1 ≤ q ≤ n) — количество измений.</p>

  <p>В следующих q строках содержится по одному целому числу x (1 ≤ x ≤ n) — индекс элемента массива, который нужно приравнять к 1. Гарантируется, что все индексы в запросах различны.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно целое число — наименьший номер изменения, после которого хотя бы один из отрезков окажется красивым, или -1, если ни один отрезок не станет красивым.</p>

  <details>
    <summary>Пример</summary>
<pre>
6
5 5
1 2
4 5
1 5
1 3
2 4
5
5
3
1
2
4
4 2
1 1
4 4
2
2
3
5 2
1 5
1 5
4
2
1
3
4
5 2
1 5
1 3
5
4
1
2
3
5
5 5
1 5
1 5
1 5
1 5
1 4
3
1
4
3
3 2
2 2
1 3
3
2
3
1
</pre>
<pre>
3
-1
3
3
3
1
</pre>
    <p>В первом примере, после первых двух изменений не будет красивых отрезков, а после третьего изменения на отрезке [1;5] будет 3 единицы и 2 нуля, получается ответ 3.</p>
    <p>Во втором примере у нас не будет красивых отрезков.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1843/problem/E" target="_blank">Задача 1843E</a>
      <br><a href="https://codeforces.com/contest/1843" target="_blank">Codeforces Round 881 (Div. 3) 2023-06-20</a>
    </div>
    <p>Давайте воспользуемся бинарным поиском по ответу. Он будет работать, так как, если какой-то отрезок был хорошим, то после еще одного изменения он не перестанет быть хорошим, а если все отрезки были плохими, то, если убрать последнее изменение, они останутся плохими.</p>

    <p>Для проверки наличия хорошего отрезка для префикса изменений можно построить массив, полученный после этих изменений, а затем посчитать префиксные суммы за O(n). После этого, можно перебрать все отрезки и проверить за O(1) на отрезок, является ли он хорошим.</p>

    <p>Итоговая сложность: O((n+m)⋅log(q)).</p>

    <details>
      <summary>Тест 2</summary>
<pre>
1
5 5
1 5
2 4
1 5
1 5
1 4
5
3
2
5
1
4
</pre>
      <code>2</code>
    </details>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
// условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // длина массива
    int m; // число отрезков
    cin >> n >> m;

    int li;
    int ri;
    vector&lt;pair&lt;int, int&gt; &gt; B(m + 1); // массив отрезков
    B[0] = make_pair(0, 0);
    for (int i = 1; i &lt;= m; i++) {
      cin >> li;
      cin >> ri;
      B[i] = make_pair(li, ri);
    }

    int q; // число изменений
    cin >> q;
    vector&lt;int> X(q + 1); // массив изменений
    for (int i = 1; i &lt;= q; i++) {
      cin >> X[i];
    }

    // решение
    int res = -1;

    int left = 0;
    int right = q + 1;

    // бинарный поиск по ответу
    while (right - left > 1) {
      int mid = left + (right - left) / 2;

      // применим mid изменений
      vector&lt;int&gt; A(n + 1, 0); // массив нулей
      for (int i = 1; i &lt;= mid; i++) {
        A[X[i]] = 1;
      }

      // создадим массив префикс-сумм
      vector&lt;int&gt; Pref(n + 1);
      Pref[0] = 0;
      for (int i = 1; i &lt;= n; i++) {
        Pref[i] = Pref[i - 1] + A[i];
      }
      bool flag = false;

      // проверим каждый отрезок
      // является ли он хороший
      for (int i = 1; i &lt;= m; i++) {
        li = B[i].first;
        ri = B[i].second;
        int cnt_el = ri - li + 1; // число элементов в отрезке
        int cnt1 = Pref[ri] - Pref[li - 1]; // число единиц в отрезке
        int cnt0 = cnt_el - cnt1; // число нулей в отрезке

        // если найден красивый отрезок
        // поднимаем флаг
        if (cnt1 > cnt0) {
          flag = true;
        }
      }

      // если найден красивый отрезок
      // уменьшаем правую границу
      if (flag) {
        right = mid;
      } else {
        left = mid;
      }

    }

    // если правая граница не вышла из диапазона
    // то ответ найден и он в правой границе
    if (right &lt; q + 1) {
      res = right;
    }

    // вывод результата
    cout &lt;&lt; res &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача Q. Экзамены -->
<article class="article">
  <div class="anchor" id="task17"></div>
  <h3>Задача Q. Экзамены</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Студент Валера учится на первом курсе университета. Скоро у него сессия, и ему предстоит сдать ровно n экзаменов. Валера — умный парень, поэтому он сможет сдать любой экзамен с первого раза. Кроме того, он может сдавать несколько экзаменов в один день и в любом порядке.</p>

  <p>Согласно расписанию, экзамен по i-му предмету нужно сдать в день с номером aᵢ. Однако Валера договорился с каждым преподавателем, и преподаватель i-го предмета разрешил организовать досрочную сдачу своего экзамена в день bᵢ (bᵢ &lt; aᵢ). Таким образом, Валера может сдать экзамен по i-му предмету либо в день aᵢ, либо в день bᵢ. Все преподаватели ставят запись о сдаче экзамена в зачетную книжку в день фактической сдачи экзамена и датируют эту запись числом aᵢ.</p>

  <p>Валера считает, что будет достаточно странно, если записи в зачетной книжке будут идти не в порядке неубывания даты. Поэтому Валера просит вас помочь ему. Найдите минимально возможный номер дня, когда Валера сможет сдать последний экзамен, если он будет сдавать экзамены так, чтобы все записи в его зачетной книжке шли в порядке неубывания даты.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано единственное целое положительное число n (1 ≤ n ≤ 5000) — количество экзаменов, которые будет сдавать Валера.</p>

  <p>В каждой из следующих n строк записано по два целых положительных числа через пробел aᵢ и bᵢ (1 ≤ bᵢ &lt; aᵢ ≤ 10⁹) — дата сдачи по расписанию и досрочная дата сдачи i-го экзамена соответственно.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное целое число — минимально возможный номер дня, когда Валера сможет сдать последний экзамен, если он будет сдавать экзамены так, чтобы все записи в его зачетной книжке шли в порядке неубывания даты.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
3
5 2
3 1
4 2
</pre>
    <code>2</code>
    <p>В первом примере Валера сначала сдаст экзамен по второму предмету в первый день (в зачетную книжку заносится дата сдачи по расписанию, то есть 3). На следующий день сначала он сдаст экзамен по третьему предмету (будет добавлена запись, датированная днем 4), а после него в тот же день сдаст экзамен по первому предмету (в зачетную книжку отметка будет проставлена с днем 5). Таким образом, последний экзамен Валера сдаст во второй день, и даты в зачетной книжке будут идти в порядке неубывания: 3, 4, 5.</p>

    <h4>Пример 2</h4>
<pre>
3
6 1
5 2
4 3
</pre>
    <code>6</code>
    <p>Во втором примере Валера сначала сдаст экзамен по третьему предмету в четвертый день, после него экзамен по второму предмету в пятый день. После этого в шестой день Валера сдаст экзамен по первому предмету.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/480/problem/A" target="_blank">Задача 480A</a>
      <br><a href="https://codeforces.com/contest/480" target="_blank">Codeforces Round 274 (Div. 1) 2014-10-19</a>
    </div>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

    // ввод данных
    int n; // число экзаменов
    cin >> n;
    vector&lt;pair&lt;int, int&gt; &gt; A(n);
    for (int i = 0; i &lt; n; i++) {
      // дата сдачи по расписанию и досрочная сдача
      cin >> A[i].first >> A[i].second;
    }

    // решение
    sort(A.begin(), A.end());
    int day = 0;

    for (int i = 0; i &lt; n; i++) {
      if (day &lt;= A[i].second) {
        day = A[i].second;
      } else {
        day = A[i].first;
      }
    }

    // вывод результата
    cout &lt;&lt; day;
}
</pre>
  </details>
</article>

