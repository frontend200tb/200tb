<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contests" target="_blank">Codeforces ЯрГУ. Школьники</a></p>
  <p><a href="https://vk.com/sportprog_yarsu" target="_blank">vk.com/sportprog_yarsu</a></p>
  <p><a href="https://vkvideo.ru/@sportprog_yarsu" target="_blank">vkvideo.ru/@sportprog_yarsu</a></p>
</article>


<article class="article">
  <h1>Занятие 27 Графы #5. Обход в ширину на гридах</h1>
  <p>Конспект видео от 2025.04.05</p>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contest/601495" target="_blank">Codeforces Контест 601495</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
    <a href="#p1">Графы #5. Обход в ширину на гридах</a>
  </p>
  <p>
        <a href="#task1">Задача A. Ладья, слон и король</a>
    <br><a href="#task2">Задача B. Lines - 2</a>
    <br><a href="#task3">Задача C. Кратчайший путь коня</a>
    <br><a href="#task4">Задача D. Опять пожар</a>
    <br><a href="#task5">Задача E. Пешка туда-сюда</a>
    <br><a href="#task6">Задача F. Катание на Коньках</a>
    <br><a href="#task7">Задача G. Лиса и две точки</a>
    <br><a href="#task8">Задача H. Лабиринт</a>
    <br><a href="#task9">Задача I. Соединить</a>
    <br><a href="#task10">Задача J. Два лабиринта</a>
    <br><a href="#task11">Задача K. Сильно связный город</a>
    <br><a href="#task12">Задача L. Статуи</a>
    <br><a href="#task13">Задача M. Осенний парк</a>
    <br><a href="#task14">Задача N. Шахматный конь на бордюре</a>
    <br><a href="#task15">Задача O. Озера</a>
    <br><a href="#task16">Задача P. Пчелиная раскраска</a>
  </p>
</article>


<!-- Графы #5. Обход в ширину на гридах -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Графы #5. Обход в ширину на гридах</h3>

  <h4>Гриды</h4>

  <p>Грид-граф - это граф, рисунок которого, встроенный в евклидово пространство, образует правильную мозаику.</p>

  <p>Один из распространённых типов решетчатого графа — квадратный сетчатый граф. В нём вершины соответствуют точкам на плоскости с целочисленными координатами, а две вершины соединены ребром, когда соответствующие точки находятся на расстоянии. У каждой вершины ”одинаковое”количество соседей.</p>

  <p>Простыми словами, грид это таблица, но есть одно отличие. В таблице каждая клетка имеет квадратную форму. В гриде каждая клетка может иметь форму правильного многоугольника, например треугольник, квадрат или шестиугольник.</p>

  <p>Яркий пример задач на граф в виде гридов это шахматные задачи.</p>

  <p>Дана шахматная доска размером n x n на шахматной доске стоит конь в ячейке (x<sub>start</sub>, y<sub>start</sub>). Необходимо посчитать за какое минимальное количество ходом конь может добраться в ячейку (x<sub>finish</sub>, y<sub>finish</sub>). Это стандартная задача "найти кратчайший путь".</p>

  <p>Алгоритм решения задачи основан на классическом BFS/Дейкстра адаптированных на гриды.</p>

  <p>Графом в задаче является шахматная доска, где каждая вершина графа - это ячейка на доске, а ребро способы переходов коня из ячейки.</p>
  <p>Плохой способ решения это переписать весь грид в список смежности (вектор векторов) и решать классическую задачу на графах. Такое решение возможно, но есть более удобные решения.</p>

  <h4>Обрамление рамкой</h4>

  <p>Идея упрощения кода:</p>

  <p>Обрамление рамкой - увеличение матрицы графа для упрощения написания кода, при нахождении объекта около границы нам не требуется делать дополнительные проверки выхода за размер матрицы, потому что мы попадем на ”рамку”.</p>

  <p>В случае задачи с конем необходимо увеличить размер матрицы с каждой стороны на 2, чтобы не делать проверку выхода за границу шахматного поля.</p>

  <p>Начальная инициализация задачи про коня:</p>
<pre>
int n;
cin >> n;
int xstart, ystart, xfinish, yfinish;
cin >> xstart >> ystart >> xfinish >> yfinish;
xstart++;
ystart++;
xfinish++;
yfinish++;

// значение в рамке очень большое
vector&lt;vector&lt;int&gt; &gt; DP(n + 4, vector&lt;int&gt;(n + 4, 100000));

// значение в полях где конь еще не был -1
for (int i = 2; i &lt; n + 2; i++) {
  for (int j = 2; j &lt; n + 2; j++) {
    DP[i][j] = -1;
  }
}

// в поле в которой стоит конь изначально
// мы можем попасть за 0 шагов
DP[xstart][ystart] = 0;
</pre>

  <h4>Список соседей</h4>

  <p>Идея упрощения кода:</p>

  <p>Поскольку мы знаем точное количество соседей у каждой ячейки изначально и правило переходов жестко фиксированно, выгодно собрать отдельным массивом способы переходов или сделать так называемый ”список соседей”.</p>
<pre>
vector&lt;pair&lt;int, int&gt; &gt; Step;
Step.push_back(make_pair(1, 2));
Step.push_back(make_pair(1, -2));
Step.push_back(make_pair(-1, 2));
Step.push_back(make_pair(-1, -2));
Step.push_back(make_pair(2, 1));
Step.push_back(make_pair(2, -1));
Step.push_back(make_pair(-2, 1));
Step.push_back(make_pair(-2, -1));
</pre>

  <h4>Функция для просмотра соседей</h4>

  <p>Кусок main:</p>
<pre>
queue&lt;pair&lt;int, int&gt; &gt; q;
pair&lt;int, int&gt; tmp;
tmp.first = xstart;
tmp.second = ystart;

// кладем начальное положение коня в очередь
q.push(tmp);

while (q.size() > 0) {
  // достаем вершину из очереди
  tmp = q.front();
  q.pop();

  // делаем ходы конем из этой вершины
  // ко всем ее соседям
  Hod(DP, Step, q, tmp);
}

cout &lt;&lt; DP[xfinish][yfinish];
</pre>

  <p>Функция:</p>
<pre>
void Hod(vector&lt;vector&lt;int&gt; &gt; &DP,
  vector&lt;pair&lt;int, int&gt; &gt;& Step,
  queue&lt;pair&lt;int, int&gt; &gt; &Q,
  pair&lt;int, int&gt; pos) {
  pair&lt;int, int&gt; buf;

  for (int i = 0; i &lt; Step.size(); i++) {
    buf.first = pos.first + Step[i].first;
    buf.second = pos.second + Step[i].second;

    // если конь ходит в вершину, которую еще не посещал
    if (DP[buf.first][buf.second] == -1) {
      // записываем в вершину число ходов до нее
      DP[buf.first][buf.second] = DP[pos.first][pos.second] + 1;
      // добавляем вершину в очередь
      Q.push(buf);
    }
  }
}
</pre>

  <p>Если конь попал на рамку, то этот случай никак не обрабатывается. Идея рамки заключается в том, чтобы никак дополнительно не обрабатывать случай выхода коня за границы шахматного поля.</p>

  <h4>Странные гриды</h4>
  <p>Иногда в задачах встречаются таблица не в виде квадратной сетки, но и в  более изощрённых, например соты или треугольники:</p>
  <p>В принципе идея решения останется такой же, за исключением момента с соседями. Связь между ячейками становится более сложной.</p>
  <p>У шестиугольников шесть соседей. У треугольников три соседа.</p>
<pre>
грид А
# S S # #
 S P S # #
# S S # #
 # # # # #
</pre>
<pre>
грид Б
# S S # #
 S P S # #
  S S # #
   # # # #
</pre>
  <p>Список соседей ячейки (2,2):</p>
  <p>грид А (2,1),(2,3),(1,2),(1,3),(3,2),(3,3)</p>
  <p>грид Б (2,1),(2,3),(1,2),(1,3),(3,1),(3,2)</p>
</article>


<!-- Задача A. Ладья, слон и король -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Ладья, слон и король</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Маленький Петя учится играть в шахматы. Он уже выучил, как перемещаются король, ладья и слон. Напомним и вам правила перемещения этих шахматных фигур. Шахматная доска представляет собой 64 квадратных поля, выстроенных в таблицу 8 x 8. Поле обозначается парой целых чисел (r, c) — номером строки и номером столбца (в классическом варианте столбцы обозначаются буквами). Каждая фигура занимает ровно одно поле. Ход состоит в перемещении фигуры, причем фигуры перемещаются по следующим правилам:</p>
  <ul>
    <li>Ладья за один ход перемещается на произвольное количество клеток по горизонтали либо по вертикали.</li>
    <li>Слон за один ход перемещается на произвольное количество клеток по диагонали.</li>
    <li>Король за один ход перемещается на одно поле в любом направлении — горизонтально, вертикально, или по диагонали.</li>
  </ul>
  <p>Петя раздумывает над следующей задачей: за какое наименьшее количество ходов каждая из этих фигур может переместиться из поля (r₁, c₁) на поле (r₂, c₂)? При этом считается, что других фигур, кроме данной, на доске нет. Помогите ему в решении этой задачи.</p>

  <h4>Входные данные</h4>
  <p>Во входных данных записаны четыре целых числа r₁, c₁, r₂, c₂ (1 ≤ r₁, c₁, r₂, c₂ ≤ 8) — координаты стартового и конечного полей. Стартовое поле не совпадает с конечным.</p>

  <p>Можете считать, что строки шахматного поля нумеруются сверху вниз от 1 до 8, а столбцы слева направо от 1 до 8.</p>

  <h4>Выходные данные</h4>
  <p>Выведите три целых числа через пробел: наименьшее количество ходов, требуемых ладье, слону и королю (в таком порядке) для того, чтобы переместиться из поля (r₁, c₁) на поле (r₂, c₂). В случае, если какая-то из фигур не может совершить такое перемещение, выведите вместо соответствующего числа 0.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>4 3 1 6</code>
    <code>2 1 3</code>

    <h4>Пример 2</h4>
    <code>5 5 5 6</code>
    <code>1 0 1</code>
  </details>
</article>


<!-- Задача B. Lines - 2 -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Lines - 2</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 16мб</i></div>

  <p>В таблице из N строк и N столбцов некоторые клетки заняты шариками, другие свободны. Выбран шарик, который нужно переместить, и место, куда его нужно переместить. Выбранный шарик за один шаг перемещается в соседнюю по горизонтали или вертикали свободную клетку. Требуется выяснить, возможно ли переместить шарик из начальной клетки в заданную, и, если возможно, то найти путь из наименьшего количества шагов.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных находится число N, в следующих N строках - по N символов. Символом точки обозначена свободная клетка, латинской заглавной O - шарик, @ - исходное положение шарика, который должен двигаться, латинской заглавной X - конечное положение шарика. (2 ≤ N ≤ 250)</p>

  <h4>Выходные данные</h4>
  <p>Выведите в первой строке «Y» (без кавычек), если движение возможно, или «N» (без кавычек), если нет. Если движение возможно, то далее следует вывести N строк по N символов - как и на вводе, но буква X, а также все точки по пути следует заменить плюсами. Если решений несколько, выведите любое.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
5
....X
.OOOO
.....
OOOO.
@....
</pre>
<pre>
Y
+++++
+OOOO
+++++
OOOO+
@++++
</pre>

    <h4>Пример 2</h4>
<pre>
5
..X..
.....
OOOOO
.....
..@..
</pre>
<pre>
N
</pre>

    <h4>Пример 3</h4>
<pre>
5
...X.
.....
O.OOO
.....
....@
</pre>
<pre>
Y
.+++.
.+...
O+OOO
.++++
....@
</pre>
  </details>
</article>


<!-- Задача C. Кратчайший путь коня -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Кратчайший путь коня</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>
  <p>вводknight1.in</p>
  <p>выводknight1.out</p>

  <p>На шахматной доске размера 8x8 заданы две клетки. Соедините эти клетки кратчайшим путём коня</p>

  <h4>Входные данные</h4>
  <p>Программа получает на вход координаты двух клеток, каждая в отдельной строке. Координаты клеток задаются в виде буквы (от «a» до «h») цифры (от 1 до 8) без пробелов.</p>

  <h4>Выходные данные</h4>
  <p>Программа должна вывести путь коня, начинающийся и заканчивающийся в данных клетках и содержащий наименьшее число клеток.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
a1
h8
</pre>
<pre>
a1
b3
a5
b7
d8
f7
h8
</pre>
  </details>
</article>


<!-- Задача D. Опять пожар -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Опять пожар</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>После ужасающего лесного пожара в Берляндии была реализована программа восстановления леса, по которой были посажены N рядов по M деревьев в каждом, причем настолько ровно, что можно ввести систему координат, в которой j-тое дерево в i-м ряду будет иметь координаты (i, j). Но случилось ужасное, и едва окрепший лес загорелся. И теперь для составления плана эвакуации необходимо найти координаты дерева, которое загорится позже всех.</p>

  <p>Возгорание произошло в K точках одновременно, т.е. в начальный момент времени загорелось K деревьев. Каждую минуту огонь перекидывается со всех горящих деревьев на те деревья, которые еще не горят и расстояние от которых до ближайшего горящего дерева равно 1.</p>

  <p>Найдите дерево, которое загорится позже всех. Если таких деревьев несколько, выведите любое.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входного файла заданы два целых числа N, M (1 ≤ N, M ≤ 2000) — размеры леса. Деревья были посажены во всех точках вида (x, y) (1 ≤ x ≤ N, 1 ≤ y ≤ M), x и y — целые числа.</p>

  <p>Во второй строке задано одно целое число K (1 ≤ K ≤ 10) — количество деревьев, горящих в начальный момент времени.</p>

  <p>В третьей строке задано K пар целых чисел: x1, y1, x2, y2, ..., xk, yk (1 ≤ xi ≤ N, 1 ≤ yi ≤ M) — координаты точек возгорания. Гарантируется, что все точки возгорания различны.</p>

  <h4>Выходные данные</h4>
  <p>Выведите одну строку, содержащую два целых числа x и y, записанные через пробел, — координаты дерева, которое загорится последним. Если таких деревьев несколько, выведите любое из них.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
3 3
1
2 2
</pre>
    <code>1 1</code>

    <h4>Пример 2</h4>
<pre>
3 3
1
1 1
</pre>
    <code>3 3</code>

    <h4>Пример 2</h4>
<pre>
3 3
2
1 1 3 3
</pre>
    <code>2 2</code>
  </details>
</article>


<!-- Задача E. Пешка туда-сюда -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Пешка туда-сюда</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Для олимпиады по программированию жюри попросило инопланетянина Нибо составить задачу. Нибо очень обрадовался и решил придумать самую сложную задачу. Сначала он придумал задачу, в которой из одной клетки шахматной доски нужно пройти в другую клетку конём. Но великого Нибо огорчили, сказав, что такую задачу уже давно придумали. Инопланетянин не сдался и придумал новую задачу. Теперь в его задаче были конь и пешка туда-сюда, а шахматная доска превратилась в шаманскую. Шаманская доска состоит из N x N клеток. В шаманской доске есть три вида клеток: клетки, в которых фигура превращается в коня, клетки, в которых фигура превращается в пешку туда-сюда, и клетки, в которые нельзя ходить. Задаются координаты начальной клетки и конечной клетки. Необходимо за минимальное количество ходов пройти из начальной клетки в конечную. Гарантируется, что начальная и конечная клетки не являются клетками, в которые нельзя ходить. На рисунке изображено, как ходят конь и пешка туда-сюда.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано число N (1 ≤ N ≤ 100) — размеры доски. В следующих N строках записано по N символов – сама доска.</p>

  <p>Клетки доски делятся на 3 типа:</p>
  <ul>
    <li>«h» — фигура превращается в коня.</li>
    <li>«p» — фигура превращается в пешку туда-сюда.</li>
    <li>«x» — в эту клетку ходить нельзя.</li>
  </ul>
  <p>Затем записаны номера строки и столбца клетки, из которой начинается обход, а в следующей строке номера строки и столбца клетки, в которой обход заканчивается.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите число – минимальное количество шагов для достижения цели. Если добраться до конечной клетки нельзя, то выведите «–1» без кавычек.</p>

  <details>
    <summary>Пример</summary>
<pre>
3
phx
pxx
hhh
2 1
3 3
</pre>
    <code>3</code>
  </details>
</article>


<!-- Задача F. Катание на Коньках -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Катание на Коньках</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Байтек учится кататься на льду. Он новичок, и поэтому он передвигается следующим образом: сначала отталкивается от сугроба на север, восток, юг или запад — и катится до тех пор, пока не повстречает очередной сугроб. Байтек заметил, что таким образом он не сможет добраться от некоторых сугробов до некоторых других, какой бы ни была последовательность его движений. Теперь он хочет соорудить несколько дополнительных сугробов так, чтобы он мог добраться от любого сугроба до любого другого. Байтек попросил Вас найти наименьшее количество сугробов, которые ему потребуется соорудить.</p>

  <p>Мы предполагаем, что Байтек может сооружать сугробы только в точках с целочисленными координатами.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входного файла записано единственное целое число n (1 ≤ n ≤ 100) — количество сугробов. Каждая из следующих n строк содержит по два целых числа xᵢ и yᵢ (1 ≤ xᵢ, yᵢ ≤ 1000) — координаты i-ого сугроба.</p>

  <p>Обратите внимание, что направление на север совпадает с направлением оси Oy, таким образом, направление на восток совпадает с направлением оси Ox. Все сугробы расположены в различных точках.</p>

  <h4>Выходные данные</h4>
  <p>Выведите наименьшее количество сугробов, которые надо соорудить Байтеку для того, чтобы он мог добраться от любого сугроба до любого другого.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
2
2 1
1 2
</pre>
    <code>1</code>

    <h4>Пример 2</h4>
<pre>
2
2 1
4 1
</pre>
    <code>0</code>
  </details>

  <details>Решение</details>
  <p>Все сугробы, до которых можно добраться начиная движения от одного из этих сугробов, образуют компонент связности. Среди всех сугробов может быть несколько таких компонент связности. Чтобы объединить 2 компонента связности в один, нужно поставить ровно один сугроб на пересечении горизонтали и вертикали любых двух сугробов из разных компонент звязности. Чтобы объединить N компонет связности в один компонент нужно поставить ровно N-1 сугроб.</p>
  <p>По условию у нас n ≤ 100 сугробов. Мы можем сделать полный перебор, то есть цикл в цикле.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;

using namespace std;

int main() {
  // ускорение ввода
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  // ввод данных
  int n;
  cin >> n;
  vector&lt;pair&lt;int, int&gt; &gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i].first >> A[i].second;
  }

  // решение
  // отмечаем посещенные сугробы
  vector&lt;int&gt; Mark(n, 0);
  // количество компонент связности
  int cnt = 0;
  queue&lt;pair&lt;int, int&gt; &gt; q;
  pair&lt;int, int&gt; tmp;

  // bfs
  for (int i = 0; i &lt; n; i++) {
    if (Mark[i] == 0) {
      cnt++;
      tmp = A[i];
      q.push(tmp);
      Mark[i] = 1;

      while (q.size() > 0) {
        tmp = q.front();
        q.pop();

        // проходим по всем сугробам
        // потому что их меньше 100
        for (int j = 0; j &lt; n; j++) {
          if (Mark[j] == 0) {
            if (A[j].first == tmp.first || A[j].second == tmp.second) {
              Mark[j] = 1;
              q.push(A[j]);
            }
          }
        }
      }
    }
  }

  // вывод результата
  cout &lt;&lt; cnt - 1;
}
</pre>
</article>


<!-- Задача G. Лиса и две точки -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Лиса и две точки</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Лиса Ciel играет в мобильную игру-головоломку под названием «Две точки». Простейшие уровни играются на доске размера n x m ячеек, выглядящей примерно вот так:</p>

  <p>В каждой клетке нарисована точка, обозначенная некоторым цветом. Обозначим различные цвета различными заглавными буквами латинского алфавита.</p>

  <p>Задача игрока — найти цикл, состоящий из точек одного цвета. В качестве примера можно рассмотреть обведённые четыре синих точки на картинке. Формально говоря, мы называем последовательность точек d1, d2, ..., dk циклом тогда и только тогда, когда выполняются следующие условия:</p>
  <ol>
    <li>Это k различных точек: если i ≠ j, то di отличается от dj.</li>
    <li>k не менее 4.</li>
    <li>Все точки окрашены в один цвет.</li>
    <li>Для всех 1 ≤ i ≤ k - 1: di и di + 1 смежные. Также, dk и d1 тоже должны быть смежные. Ячейки x и y называются смежными, если у них есть общая сторона.</li>
  </ol>
  <p>Определите, есть ли на поле цикл.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано два целых числа, n и m (2 ≤ n, m ≤ 50), количество строк и столбцов доски.</p>

  <p>Затем следуют n строк, в каждой строке записана последовательность из m символов, обозначающих цвета точек в этой строке. Каждый символ является заглавной буквой латинского алфавита.</p>

  <h4>Выходные данные</h4>
  <p>Выведите «Yes», если существует цикл, и «No» в противном случае.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
3 4
AAAA
ABCA
AAAA
</pre>
    <code>Yes</code>

    <h4>Пример 2</h4>
<pre>
3 4
AAAA
ABCA
AADA
</pre>
    <code>No</code>

    <h4>Пример 3</h4>
<pre>
4 4
YYYR
BYBY
BBBY
BBBY
</pre>
    <code>Yes</code>

    <h4>Пример 4</h4>
<pre>
7 6
AAAAAB
ABBBAB
ABAAAB
ABABBB
ABAAAB
ABBBAB
AAAAAB
</pre>
    <code>Yes</code>

    <h4>Пример 5</h4>
<pre>
2 13
ABCDEFGHIJKLM
NOPQRSTUVWXYZ
</pre>
    <code>No</code>
    <p>В первом примере буквы 'A' формируют цикл.</p>

    <p>Во втором примере цикла не существует.</p>

    <p>Третий пример изображён на картинке выше ('Y' обозначает жёлтый, 'B' — синий, 'R' — красный).</p>
  </details>
</article>


<!-- Задача H. Лабиринт -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Лабиринт</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Павел обожает клетчатые лабиринты. Клетчатый лабиринт — это прямоугольный лабиринт размера n x m, где каждая клетка либо свободна, либо является стеной, а перемещаться из одной клетки в другую можно только в том случае, если они обе свободные и имеют общую сторону.</p>

  <p>Павел нарисовал клетчатый лабиринт, все свободные клетки которого образуют связную область, то есть из любой свободной клетки можно добраться до любой другой. Павлу не нравится, что в его лабиринте слишком мало стен. Он хочет превратить ровно k свободных клеток в стены таким образом, чтобы все оставшиеся свободные клетки по прежнему образовывали бы связную область. Помогите ему.</p>

  <h4>Входные данные</h4>
  <p>В первой строке находятся три целых числа n, m, k (1 ≤ n, m ≤ 500, 0 ≤ k &lt; s), где n и m — соответственно высота и ширина лабиринта, k — количество стен, которое Павел хочет добавить в лабиринт, а буквой s обозначено количество свободных клеток в исходном лабиринте.</p>

  <p>Далее следуют n строк по m символов каждая, задающие исходный лабиринт. Если символ в строке равен «.», то соответствующая клетка свободная, а если он равен «#», то эта клетка является стеной.</p>

  <h4>Выходные данные</h4>
  <p>Выведите n строк по m символов каждая: новый лабиринт, удовлетворяющий всем требованиям Павла. Пустые клетки, которые после преобразования стали стенами, обозначайте «X», а остальные клетки оставляйте без изменения (то есть «.» и «#»).</p>

  <p>Гарантируется, что решение существует. Если существует несколько решений, разрешается вывести любое.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
3 4 2
#..#
..#.
#...
</pre>
<pre>
#.X#
X.#.
#...
</pre>

    <h4>Пример 2</h4>
<pre>
5 4 5
#...
#.#.
.#..
...#
.#.#
</pre>
<pre>
#XXX
#X#.
X#..
...#
.#.#
</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <p>У нас есть лабиринт из стен '#' и проходов '.', где все проходы связаны. То есть имеется одна компонента связности. Нам нужно расставить дополнительно k стен 'X' так, чтобы все проходы остались в одной компоненте связности.</p>
    <p>Решение может иметь множество вариантов. Поэтому, начнем с любой вершины в проходе '.' и будем помечать все вершины, насколько они удалены от начальной вершины. Потом будем ставить новые стены 'X' в тех вершинах, которые наиболее удалены от начальной вершины. Когда мы поставим стену 'X' в самую удаленную вершину, то мы гарантируем, что все оставшиеся вершины останутся в одной компоненте связности. Последовательно расставим все k стен.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;

using namespace std;

int main() {
  // ускорение ввода
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  // ввод данных
  int n, m, k;
  cin >> n >> m >> k;
  vector&lt;string&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  // выберем начальную вершину
  // пусть это будет последняя вершина
  pair&lt;int, int&gt; pos;
  for (int i = 0; i &lt; A.size(); i++) {
    for (int j = 0; j &lt; A[i].size(); j++) {
      if (A[i][j] == '.') {
        pos.first = i;
        pos.second = j;
      }
    }
  }

  // вектор удаленности вершин
  // от начальной вершины
  vector&lt;pair&lt;int, int&gt; &gt; Len;
  Len.push_back(pos);
  vector&lt;pair&lt;int, int&gt; &gt; Step;
  Step.push_back(make_pair( 1,  0));
  Step.push_back(make_pair(-1,  0));
  Step.push_back(make_pair( 0,  1));
  Step.push_back(make_pair( 0, -1));

  queue&lt;pair&lt;int, int&gt; &gt; q;
  q.push(pos);
  vector&lt;vector&lt;int&gt; &gt; Mark(n, vector&lt;int&gt;(m));
  Mark[pos.first][pos.second] = 1;

  // bfs по всей компоненте связности
  while (q.size() > 0) {
    pair&lt;int, int&gt; tmp = q.front();
    q.pop();
    for (int i = 0; i &lt; Step.size(); i++) {

      // проверяем что не вышли за границы
      // это пример реализации без рамки
      if (tmp.first + Step[i].first >= 0 &&
          tmp.first + Step[i].first &lt; n &&
          tmp.second + Step[i].second >= 0 &&
          tmp.second + Step[i].second &lt; m) {
        pair&lt;int, int&gt; gg;
        gg.first = tmp.first + Step[i].first;
        gg.second = tmp.second + Step[i].second;

        // если вершина не посещена, и не стена
        // мы должны ее посетить
        // и пометить ее удаленность от начала
        if (Mark[gg.first][gg.second] == 0
            && A[gg.first][gg.second] == '.') {
          Mark[gg.first][gg.second] = 1;
          Len.push_back(gg);
          q.push(gg);
        }
      }
    }
  }

  int uk = Len.size();
  while (k > 0) {
    k--;
    uk--;
    A[Len[uk].first][Len[uk].second] = 'X';
  }

  // вывод результата
  for (int i = 0; i &lt; n; i++) {
    cout &lt;&lt; A[i] &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача I. Соединить -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача I. Соединить</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Алиса живет на плоской земле, которая может быть представлена как квадратная решетка n x n со строками и столбцами, пронумерованными от 1 до n. Обозначим клетку на пересечении строки r и столбца c упорядоченной парой (r,c). Каждая клетка решетки является либо землей, либо водой.</p>

  <p>Алиса живет на клетке, которая является землей, (r1,c1). Она хочет добраться до другой клетки, которая является землей, (r2,c2). В любой момент она может переместиться в одну из соседних с ней ячеек — в одном из четырех направлений (т.е. вверх, вниз, влево или вправо).</p>

  <p>К сожалению, Алиса не умеет плавать, и можно перемещаться только пешком (т.е. только по земле). В итоге путешествие Алисы может быть невозможно.</p>

  <p>Чтобы помочь Алисе, вы хотите создать не более одного туннеля между какими-то двумя земляными клетками. Туннель позволяет Алисе перемещаться между двумя его концами. Создание туннеля требует некоторых затрат: стоимость туннеля между клетками (rs,cs) и (rt,ct) равна (rs-rt)² + (cs-ct)².</p>

  <p>Таким образом, ваша задача — найти минимальную стоимость постройки не более одного туннеля так, чтобы Алиса смогла добраться от клетки (r1,c1) до клетки (r2,c2). Если постройка туннеля не обязательна, стоимость полагается равной 0.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно целое число n (1 ≤ n ≤ 50) — длину стороны квадратной решетки.</p>

  <p>Вторая строка содержит два целых числа, разделенных пробелами, r1 и c1 (1≤r1,c1≤n), обозначающих клетку, где находится Алиса.</p>

  <p>Третья строка строка содержит два целых числа, разделенных пробелами, r2 и c2 (1≤r2,c2≤n), обозначающих клетку, куда намерена попасть Алиса.</p>

  <p>Каждая из следующих n строк содержит строку из n символов. j-й символ i-й такой строки (1≤i,j≤n) это 0, если клетка (i,j) — земля, и 1, если клетка (i,j) — вода.</p>

  <p>Гарантируется, что и (r1,c1), и (r2,c2) это земля.</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно целое число — минимальную возможную стоимость постройки не более одного туннеля так, чтобы Алиса смогла добраться от клетки (r1,c1) до клетки (r2,c2).</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
5
1 1
5 5
00001
11111
00111
00110
00110
</pre>
    <code>10</code>

    <h4>Пример 2</h4>
<pre>
3
1 3
3 1
010
101
010
</pre>
    <code>8</code>
    <p>В первом примере должен быть построен туннель между клетками (1,4) и (4,5). Стоимость такого туннеля равна (1-4)²+(4-5)²=10, что является оптимальным. Таким образом, Алиса сможет дойти от (1,1) до (1,4), использовать туннель от (1,4) до (4,5), а затем дойти от (4,5) до (5,5).</p>
    <p>Во втором примере должен быть построен туннель между клетками (1,3) и (3,1). Стоимость такой постройки равна (1-3)²+(3-1)²=8.</p>
  </details>
</article>


<!-- Задача J. Два лабиринта -->
<article class="article">
  <div class="anchor" id="task10"></div>
  <h3>Задача J. Два лабиринта</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Лабиринт — это прямоугольная сетка, каждая из клеток которой либо свободна, либо является стеной, причем перемещаться можно только между смежными по стороне свободными клетками.</p>

  <p>Константин и Михаил — мировые лидеры по составлению лабиринтов. Они составили каждый по лабиринту размером n x m, и теперь обвиняют друг друга в плагиате. Они считают, что плагиат имел место, если существует путь из левой верхней клетки в правую нижнюю, являющийся кратчайшим в обоих лабиринтах. Разрешите их спор и скажите, имел ли место плагиат.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записаны два числа n и m (1 ≤ n, m ≤ 500) — размеры лабиринтов.</p>

  <p>В следующих n строках записан лабиринт, составленный Константином. Каждая из этих n строк состоит из m символов. Каждый из этих символов может быть равен либо «#», что обозначает стену, либо «.», что обозначает свободную клетку.</p>

  <p>Следующая строка оставлена пустой, а затем в n строках в аналогичном формате записан лабиринт, составленный Михаилом. Гарантируется, что в обоих лабиринтах левая верхняя и правая нижняя клетки — свободные.</p>

  <h4>Выходные данные</h4>
  <p>Выведите «YES», если существует путь из левой верхней клетки в правую нижнюю, являющийся кратчайшим в обоих лабиринтах. Иначе выведите «NO».</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
3 5
.....
.#.#.
.....


.....
#.#.#
.....
</pre>
    <code>NO</code>

    <h4>Пример 2</h4>
<pre>
3 5
.....
.#.##
.....


.....
##.#.
.....
</pre>
    <code>YES</code>
  </details>
</article>


<!-- Задача K. Сильно связный город -->
<article class="article">
  <div class="anchor" id="task11"></div>
  <h3>Задача K. Сильно связный город</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Рассмотрим город, в котором есть n горизонтальных улиц пересекаются с m вертикальными, формируя сетку размера (n - 1) x (m - 1). Чтобы снизить количество заторов, мэр города решил сделать каждую улицу односторонней. Это значит, что по каждой горизонтальной улице машины будут ехать либо только с запада на восток, либо только с востока на запад. Аналогично, по каждой вертикальной улице машины будут ехать либо только с севера на юг, либо только с юга на север. На любом перекрестке можно свернуть с вертикальной улицы на горизонтальную и наоборот.</p>

  <p>Мэр города получил несколько вариантов направления улиц. Ваша задача — проверить можно ли в данном варианте добраться от любого перекрестка до любого другого перекрестка, двигаясь по дорогам в указанном для них направлении.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано два целых числа n, m, (2 ≤ n, m ≤ 20), обозначающие соответственно количество горизонтальных и вертикальных улиц.</p>

  <p>Во второй строке записана строка длины n из символов '&lt;' и '>' — направления горизонтальных улиц. Если очередной символ этой строки равняется '&lt;', то соответствующая улица направлена с востока на запад, в противном случае улица направлена с запада на восток. Улицы приводятся в порядке с севера на юг.</p>

  <p>В третьей строке записана строка длины m из символов '^' и 'v' — направления вертикальных улиц. Если очередной символ равняется '^', то улица направлена с юга на север, в противном случае улица направлена с севера на юг. Улицы приводятся в порядке с запада на восток.</p>

  <h4>Выходные данные</h4>
  <p>Если указанная схема удовлетворяет требованиям, выведите в единственной строке "YES", в противном случае выведите в единственной строке "NO".</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
3 3
>&lt;>
v^v
</pre>
    <code>NO</code>

    <h4>Пример 2</h4>
<pre>
4 6
&lt;>&lt;>
v^v^v^
</pre>
    <code>YES</code>
    <p>Рисунок в условии соответствует второму примеру.</p>
  </details>
</article>


<!-- Задача L. Статуи -->
<article class="article">
  <div class="anchor" id="task12"></div>
  <h3>Задача L. Статуи</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В этой задаче Аня и Маша играют в игру с очень неприятным соперником. Аня и Маша находятся в двух противоположных клетках шахматной доски (размером 8 x 8): Аня — в верхней правой, а Маша — в нижней левой. Кроме них, на доске находятся несколько статуй. Каждая статуя занимает полностью ровно одну клетку. В клетке, в которой есть статуя, не может быть больше ничего и никого — ни другой статуи, ни Ани, ни Маши.</p>

  <p>Аня присутствует на доске в качестве статиста (она стоит и не двигается), а Маша принимает активное участие в игре. Ее цель — прийти в клетку к Ане. Маша и статуи делают ходы по очереди, первой ходит Маша. За один свой ход Маша может перейти в любую соседнюю по стороне или по диагонали клетку, в которой нет статуи, либо остаться в клетке, в которой она находится. Статуи на своем ходу все одновременно спускаются на одну клетку вниз, а те, которые были в нижнем ряду — сваливаются с доски и больше не появляются.</p>

  <p>В тот момент, когда одна из статуй оказывается в клетке, в которой находится Маша, статуи объявляются победителями. В тот момент, когда Маша приходит в клетку, в которой ее ждет Аня, Маша объявляется победительницей.</p>

  <p>Очевидно, что от статуй ничего не зависит, поэтому все зависит от Маши. Определите, кто из них выиграет, если Маша не сделает стратегической ошибки.</p>

  <h4>Входные данные</h4>
  <p>Даны 8 строк длины 8, описывающие изначальную позицию на доске. Первая строка отвечает за верхний ряд доски, вторая — за второй сверху, и так далее, последняя — за нижний. Каждый символ строки соответствует одной клетке доски в соответствующем ряду, причем символы идут в том же порядке, что и соответствующие им клетки. Если клетка пуста, соответствующий символ — «.». Если в клетке Маша — символ «M». Если в клетке Аня — символ «A». Если в клетке статуя — символ «S».</p>

  <p>Гарантируется, что последний символ первой строки — обязательно «A», первый символ последней строки — обязательно «M». Остальные символы — «.» или «S».</p>

  <h4>Выходные данные</h4>
  <p>Если выиграет Маша, выведите строку «WIN». Если выиграют статуи, выведите строку «LOSE».</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
.......A
........
........
........
........
........
........
M.......
</pre>
    <code>WIN</code>

    <h4>Пример 2</h4>
<pre>
.......A
........
........
........
........
........
SS......
M.......
</pre>
    <code>LOSE</code>

    <h4>Пример 3</h4>
<pre>
.......A
........
........
........
........
.S......
S.......
MS......
</pre>
    <code>LOSE</code>
  </details>
</article>


<!-- Задача M. Осенний парк -->
<article class="article">
  <div class="anchor" id="task13"></div>
  <h3>Задача M. Осенний парк</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Воскресенье, утро. Пора на олимпиаду. Вениамин взял пачку чистой бумаги, ручку, пару бутербродов — что еще понадобится? — и открыл картографический сайт чтобы посмотреть, куда и как ему добираться. Какая удача! На пути есть прекрасный парк, а Вениамин как раз любит гулять по паркам. Парк представляет собой прямоугольное поле, разбитое на квадратные клеточки, в каждой из которых либо газон с дорожками, либо какое-то препятствие (заросли кустарника, деревья, а то и вовсе какой-нибудь огороженный памятник).</p>

  <p>На олимпиаду нужно прийти вовремя, так что Вениамин не может позволить себе долго разгуливать по парку. Перемещение между двумя соседними по стороне клеточками парка занимает одну секунду. Вениамин не может устоять на месте, поэтому каждую секунду он перемещается в какую-либо соседнюю клеточку. Вениамин решил, что может позволить себе гулять лишние две секунды. Ваша задача: посчитать количество способов пройти через парк так, чтобы время прогулки было ровно на две секунды больше минимального.</p>

  <p>Вход в парк и выход из него — это некоторые выделенные различные клетки в парке, выходить за пределы парка запрещается, передвигаться можно только между соседними по ребру клетками. Вениамин должен гулять на две секунды дольше оптимального времени прохода от входа к выходу, поэтому он может в качестве промежуточной точки пути оказаться на входе или выходе. Поскольку ответ на задачу может быть довольно большим, от вас требуется остаток от деления количества путей на 10⁹+9.</p>

  <h4>Входные данные</h4>
  <p>В первой строке заданы два числа h и w: размеры парка. Следующие h строк содержат по w символов в каждой. Символ «.» означает, что в соответствующей клетке дорожка или газон, по которому можно ходить. Символ «#» означает препятствие. Символы «E» и «X» означают вход в парк и выход из него соответственно.</p>

  <p>Ограничения: 1 ≤ h ≤ 500, 1 ≤ w ≤ 500, символы «E» и «X» встречаются ровно по одному разу. Обратите внимание, что вход и выход не обязательно находятся на границе парка: например, клеткой входа может быть расположенный в парке вестибюль метро, из которого Вениамин собирается выходить на своем пути.</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно число: количество путей, которые длиннее кратчайшего ровно на две секунды. Если парк устроен так, что невозможно добраться от входа до выхода, то выведите ноль.</p>

  <details>
    <summary>Пример</summary>
<pre>
6 9
.........
..######X
..#......
.E..####.
..##...#.
.....#...
</pre>
    <code>15</code>
  </details>
</article>


<!-- Задача N. Шахматный конь на бордюре -->
<article class="article">
  <div class="anchor" id="task14"></div>
  <h3>Задача N. Шахматный конь на бордюре</h3>

  <div><i>Ограничение по времени 0.25с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Из клетчатого поля размером n строк и m столбцов (5≤n,m≤1000) вырезали внутреннюю часть размером (n-4) x (m-4) так, что по сторонам остались полоски шириной 2 клетки.</p>

  <p>На левой верхней клетке поля стоит шахматный конь. Можно ли, используя только узкие бордюры шириной 2 клетки, обойти конем вокруг выреза и вернуться на исходную клетку? И если да, то какое минимальное число ходов для этого необходимо (конь ходит по шахматным правилам)?</p>

  <p>Например, если есть поле 5x5 (вырезана клетка (3,3)), то конь может обойти вокруг выреза за 4 хода: (1,1)→(3,2)→(4,4)→(2,3)→(1,1).</p>

  <p>Примечание. В момент движения конь не может перескакивать через вырезанные клетки.</p>

  <h4>Входные данные</h4>
  <p>На вход подаются размеры поля в виде двух целых чисел n и m (5 ≤ n, m ≤ 1000), разделенных пробелом.</p>

  <h4>Выходные данные</h4>
  <p>Выведите 0, если обойти вокруг выреза нельзя, или минимально необходимое число ходов коня для такого обхода.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>5 5</code>
    <code>4</code>

    <h4>Пример 2</h4>
    <code>20 15</code>
    <code>30</code>

    <h4>Пример 3</h4>
    <code>1000 1000</code>
    <code>1996</code>

    <h4>Пример 4</h4>
    <code>5 6</code>
    <code>6</code>
  </details>
</article>


<!-- Задача O. Озера -->
<article class="article">
  <div class="anchor" id="task15"></div>
  <h3>Задача O. Озера</h3>

  <div><i>Ограничение по времени 3с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Дана сетка a размера n x m из неотрицательных целых чисел, где a<sub>i,j</sub> представляет глубину воды в i-й строке и j-м столбце.</p>

  <p>Озеро — это набор ячеек, таких что:</p>
  <ul>
    <li>Каждая ячейка в наборе имеет a<sub>i,j</sub> > 0</li>
    <li>Существует путь между любой парой ячеек в озере, двигаясь вверх, вниз, влево или вправо, несколько раз и не наступая на ячейку с a<sub>i,j</sub> = 0.</li>
  </ul>

  <p>Объем озера — это сумма глубин всех ячеек в озере.</p>

  <p>Найдите наибольший объем озера в сетке.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит одно целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных в тесте.</p>

  <p>Первая строка каждого набора содержит два целых числа n, m (1 ≤ n, m ≤ 1000) — размеры сетки.</p>

  <p>Затем следуют n строк, каждая из которых содержит m целых чисел a<sub>i,j</sub> (0 ≤ a<sub>i,j</sub> ≤ 1000) — глубина воды в каждой ячейке.</p>

  <p>Гарантируется, что сумма n⋅m по всем наборам не превышает 10⁶.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого теста выведите одно целое число — наибольший объем озера в сетке.</p>

  <details>
    <summary>Пример</summary>
<pre>
5
3 3
1 2 0
3 4 0
0 0 5
1 1
0
3 3
0 1 1
1 0 1
1 1 1
5 5
1 1 1 1 1
1 0 0 0 1
1 0 5 0 1
1 0 0 0 1
1 1 1 1 1
5 5
1 1 1 1 1
1 0 0 0 1
1 1 4 0 1
1 0 0 0 1
1 1 1 1 1
</pre>
<pre>
10
0
7
16
21
</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <p>В сетке размером n x m находятся несколько озер, разделенных между собой сушей. Суша это ячеки со значением 0. Озера это компоненты связности. Глубина озера это сумма глубин всех его ячеек. То есть нам надо найти компоненту связности с самой большой суммой чисел во всех его ячейках.</p>
    <p>Сразу сделаем вокруг сетки рамку из суши. Это нужно чтобы не проверять случаи выхода за границы сетки. Пройдем, начиная с первой (левой верхней) ячейки, по матрице и посчитаем количество компонент связности и сумму чисел в каждой компоненте.</p>
    <p>Послокльку размер сетки ≤ 1000, каждый элемент ≤ 1000, то нам хватит типа данных int.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;

using namespace std;

int Hod(vector&lt;vector&lt;int&gt; &gt; &G,
        vector&lt;pair&lt;int, int&gt; &gt; &Step,
        int x, int y) {
  queue&lt;pair&lt;int, int&gt; &gt; q;
  pair&lt;int, int&gt; tmp;
  tmp.first = x;
  tmp.second = y;
  q.push(tmp);
  int sum = G[x][y];
  G[x][y] = 0;

  // bfs
  while (q.size() > 0) {
    tmp = q.front();
    q.pop();
    for (int i = 0; i &lt; Step.size(); i++) {
      if (G[tmp.first + Step[i].first][tmp.second + Step[i].second] != 0) {
        sum += G[tmp.first + Step[i].first][tmp.second + Step[i].second];
        G[tmp.first + Step[i].first][tmp.second + Step[i].second] = 0;
        q.push(make_pair(tmp.first + Step[i].first, tmp.second + Step[i].second));
      }
    }
  }

  return sum;
}

int main() {
  // ускорение ввода
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n, m;
    cin >> n >> m;
    vector&lt;vector&lt;int&gt; &gt; G(n + 2, vector&lt;int&gt;(m + 2));
    for (int i = 1; i &lt;= n; i++) {
      for (int j = 1; j &lt;= m; j++) {
        cin >> G[i][j];
      }
    }

    // решение
    int res = 0;
    vector&lt;pair&lt;int, int&gt; &gt; Step;
    Step.push_back(make_pair( 1,  0));
    Step.push_back(make_pair(-1,  0));
    Step.push_back(make_pair( 0,  1));
    Step.push_back(make_pair( 0, -1));

    for (int i = 1; i &lt;= n; i++) {
      for (int j = 1; j &lt;= m; j++) {
        if (G[i][j] != 0) {
          res = max(res, Hod(G, Step, i, j));
        }
      }
    }

    // вывод результата
    cout &lt;&lt; res &lt;&lt; '\n';
  }
}
</pre>
  </details>

  <details>
    <summary>Некрасивое решение</summary>
    <p>Не используем функцию Hod(), все пишем в main(). Не используем вектор Step, для каждого шага пишем свой if. В этой задаче клетка это квадрат и имеет 4 соседей, значит пишем четыре if. Если в задаче будет клета это восьмиугольник и иметь 8 соседей, значит напишем восемь if.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;

using namespace std;

int main() {
  // ускорение ввода
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n, m;
    cin >> n >> m;
    vector&lt;vector&lt;int&gt; &gt; G(n + 2, vector&lt;int&gt;(m + 2));
    for (int i = 1; i &lt;= n; i++) {
      for (int j = 1; j &lt;= m; j++) {
        cin >> G[i][j];
      }
    }

    // решение
    int res = 0;

    for (int i = 1; i &lt;= n; i++) {
      for (int j = 1; j &lt;= m; j++) {
        if (G[i][j] != 0) {
          int buf = 0;
          queue&lt;pair&lt;int, int&gt; &gt; q;
          pair&lt;int, int&gt; tmp;
          tmp.first = i;
          tmp.second = j;
          q.push(tmp);
          buf += G[i][j];
          G[i][j] = 0;

          while (q.size() > 0) {
            tmp = q.front();
            q.pop();
            pair&lt;int, int&gt; tmp2;

            // шаг вправо
            tmp2.first = tmp.first + 1;
            tmp2.second = tmp.second;
            if (G[tmp2.first][tmp2.second] != 0) {
              buf += G[tmp2.first][tmp2.second];
              G[tmp2.first][tmp2.second] = 0;
              q.push(tmp2);
            }

            // шаг влево
            tmp2.first = tmp.first - 1;
            tmp2.second = tmp.second;
            if (G[tmp2.first][tmp2.second] != 0) {
              buf += G[tmp2.first][tmp2.second];
              G[tmp2.first][tmp2.second] = 0;
              q.push(tmp2);
            }

            // шаг вверх
            tmp2.first = tmp.first;
            tmp2.second = tmp.second + 1;
            if (G[tmp2.first][tmp2.second] != 0) {
              buf += G[tmp2.first][tmp2.second];
              G[tmp2.first][tmp2.second] = 0;
              q.push(tmp2);
            }

            // шаг вниз
            tmp2.first = tmp.first;
            tmp2.second = tmp.second - 1;
            if (G[tmp2.first][tmp2.second] != 0) {
              buf += G[tmp2.first][tmp2.second];
              G[tmp2.first][tmp2.second] = 0;
              q.push(tmp2);
            }
          }
          res = max(res, buf);
        }
      }
    }

    // вывод результата
    cout &lt;&lt; res &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача P. Пчелиная раскраска -->
<article class="article">
  <div class="anchor" id="task16"></div>
  <h3>Задача P. Пчелиная раскраска</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вероника очень хорошо рисует и разукрашивает раскраски. Игорь и Ира купили ей новую пчелиную раскраску.</p>

  <p>Раскраска состоит из n строк, в каждой из которых ровно m ячеек. Каждая ячейка является правильным шестиугольником, как соты у пчел и имеет не более 6 соседей. В качестве примера поле 5x5 выглядит следующим образом:</p>

  <p>Изначально в раскраске какие-то ячейки уже покрашены. Вероника хочет закрасить минимальное количество ячеек так, чтобы получилась непрерывная линия из закрашенных ячеек, которая соединит первую строку с n-й строкой.</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержатся два целых числа n, m (1 ≤ n, m ≤ 1000) — количество строк в раскраске и количество ячеек в каждой строке.</p>

  <p>Далее заданы n строк, в каждой строке ровно m символов и каждая строка состоит только из символов «.» и «#». Символ «.» обозначает, что ячейка не закрашена, «#»  — ячейка закрашена.</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно целое число – минимальное количество ячеек, которое необходимо закрасить, чтобы соединить первую строку с n-й строкой.</p>

  <details>
    <summary>Пример</summary>
<pre>
5 5
....#
.#...
.#...
...#.
.#...
</pre>
    <code>2</code>
  </details>
</article>

