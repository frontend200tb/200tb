<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contests" target="_blank">Codeforces ЯрГУ. Школьники</a></p>
  <p><a href="https://vk.com/sportprog_yarsu" target="_blank">vk.com/sportprog_yarsu</a></p>
  <p><a href="https://vkvideo.ru/@sportprog_yarsu" target="_blank">vkvideo.ru/@sportprog_yarsu</a></p>
</article>


<article class="article">
  <h1>Занятие 7. Основы С++ #6. Линейные алгоритмы</h1>
  <p>Конспект видео от 2024.10.26</p>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contest/561317" target="_blank">Codeforces Контест 561317</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
         <a href="#p">Линейные алгоритмы</a>
    <br><a href="#t1">Задача 1. Какого элемента нет</a>
    <br><a href="#t2">Задача 2. Максимальная сумма</a>
    <br><a href="#t3">Задача 3. Максимальная разница</a>
    <br><a href="#t4">Задача 4. Минимальный и максимальный</a>
    <br><a href="#t5">Задача 5. Пять максимумов</a>
    <br><a href="#t6">Задача 6. Частотный словарь</a>
  </p>
  <p>
        <a href="#task1">Задача A. Правый минус левый</a>
    <br><a href="#task2">Задача B. Клиппи и Мерлин грабят банк</a>
    <br><a href="#task3">Задача C. Сумма на подотрезке</a>
    <br><a href="#task4">Задача D. Пропажа числа</a>
    <br><a href="#task5">Задача E. Министерство правды</a>
    <br><a href="#task6">Задача F. Ётта</a>
    <br><a href="#task7">Задача G. Катя и красивое число</a>
    <br><a href="#task8">Задача H. Черви и ослы</a>
    <br><a href="#task9">Задача I. Четные, но не кратные шести</a>
    <br><a href="#task10">Задача J. Задача без легенды</a>
    <br><a href="#task11">Задача K. Двапалиндром</a>
    <br><a href="#task12">Задача L. Пилообразная последовательность</a>
    <br><a href="#task13">Задача M. Противоположности притягиваются</a>
    <br><a href="#task14">Задача N. Футбол</a>
    <br><a href="#task15">Задача O. Медиана Профессора Р.</a>
    <br><a href="#task16">Задача P. Сортировка подсчётом</a>
    <br><a href="#task17">Задача Q. Рамки для картин</a>
    <br><a href="#task18">Задача R. Веселая шутка</a>
    <br><a href="#task19">Задача S. LuoTianyi и шоу</a>
    <br><a href="#task20">Задача T. Конец света</a>
    <br><a href="#task21">Задача U. Мистер совершенство</a>
  </p>
</article>


<!-- Линейные алгоритмы -->
<article class="article">
  <div class="anchor" id="p"></div>
  <h3>Линейные алгоритмы</h3>

  <p>Линейным алгоритмом решаются задачи вида "найти максимальный и минимальный элемент на отрезке", "найти сумму элементов на отрезке"</p>

  <h4>Отладка</h4>
  <p>В Visual Studio для того чтобы найти баг, поможет Debug режим. Его можно выбрать в окошке между Debug и Release. Запустить отладку можно кнопкой</p>
  <code>Локальный отладчик Windows (Ctrl+F10)</code>
  <p>На сервере Codeforces всегда запускается в режиме Release. Запустить отладку в режиме Release можно из меню</p>
  <code>Отладка - Запуск без отладки (Ctrl+F5)</code>

  <h4>Использование файлов</h4>
  <p>Мы запускаем часть кода в Debug режиме. В Release он не будет виден, поэтому при запуске на сервере Codeforces не будет происходить подключение файлов</p>
<pre>
int main() {

#ifdef _DEBUG
  freopen("input1.txt", "rt", stdin);
  freopen("output1.txt", "wt", stdout);
#endif
}
</pre>
  <p>Добавим файлы <strong>input1.txt</strong> и <strong>output1.txt</strong> в проект.</p>
  <ol>
    <li>
      <p>В окне <strong>Обозреватель решений</strong> выбираем</p>
      <code>Исходный файл - Добавить - Создать элемент (Ctrl+Shift+A)</code>
    </li>
    <li>
      <p>В открывшемся окне <strong>Добавление нового элемента</strong> выбираем <strong>Файл C++ (.cpp)</strong>. Задаем имя файла <strong>input1.txt</strong>. Нажимаем <strong>Добавить</strong></p>
    </li>
    <li>
      <p>В окне <strong>Обозреватель решений</strong> создается текстовый файл</p>
      <code>Исходные файлы - input1.txt</code>
    </li>
    <li>Также создаем файл <strong>output2.txt</strong></li>
  </ol>

  <h4>freopen</h4>
  <p>Если при компиляции выдается предупреждение</p>
  <code>error C4996: 'freopen': This function or variable may be unsafe. Consider using freopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.</code>

  <p>Microsoft объявила ряд функций устаревшими (deprecated) - freopen, fopen, fscanf, chsize и т.д. Это связано с тем, что данные функции не проверяют возможности переполнения буфера. Например, может произойти запись за пределами выделенного буфера, что может привести к изменению значений других данных, затиранию информации на стеке - к трудно находимым ошибкам при выполнении программы. Для устранения этого недостатка были разработаны безопасные функции с суффиксом _s (freopen_s)</p>
  <p>Чтобы продолжать пользоваться старыми функциями, можно попробовать отключить сообщения с ошибкой C4996. Для этого объявите макросы <strong>перед заголовочными файлами</strong> стандартных библиотек. Мне помог первый макрос</p>
  <code>#define _CRT_SECURE_NO_WARNINGS</code>
  <code>#define _CRT_SECURE_NO_DEPRECATE</code>
  <code>#define _CRT_NONSTDC_NO_DEPRECATE</code>
</article>


<!-- Задача 1. Какого элемента нет -->
<article class="article">
  <div class="anchor" id="t1"></div>
  <h3>Задача 1. Какого элемента нет</h3>

  <p>Есть 99 уникальных чисел в диапазоне от 1 до 100. Какого числа не хватает, чтобы были все 100 чисел?</p>

  <h4>Решение</h4>
  <p>Посчитаем сумму всех чисел от 1 до 100. Это можно сделать по формуле Эйлера.</p>
  <code>sum100 = 100 * (100 + 1) / 2</code>
  <p>В цикле проходим по всем 99 входным числам и складываем их. Получаем сумму sum99. Разница между двумя суммами это и есть недостающее число.</p>
  <code>result = sum100 - sum99</code>

  <details>
    <summary>Решение</summary>
    <p>Чтобы быстрее было вводить 9 чисел. Сделаем задачу для 10 элементов</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int sum100, sum99 = 0;
  sum100 = 10 * (10 + 1) / 2;

  for (int i = 1; i &lt; 10; i++) {
    int n;
    cin >> n;
    sum99 += n;
  }

  cout &lt;&lt; sum100 - sum99;
}
</pre>
  </details>
</article>


<!-- Задача 2. Максимальная сумма -->
<article class="article">
  <div class="anchor" id="t2"></div>
  <h3>Задача 2. Максимальная сумма</h3>

  <p>Дан массив из n чисел. Дано число k. Найти максимальную сумму на отрезке из k элементов идущих подряд.</p>

  <h4>Решение</h4>
  <p>Заведем переменную sum и запишев в нее сумму первых k чисел. Заведем переменную sum_max для максимальной суммы и пусть пока она равна sum. В цикле пойдем от k до n, каждую итерацию считая новую сумму прибавляя один элемент справа и удаляя один элемент слева. Если получается сумма больше чем максимум, то обновляем максимум. Максимальную сумму запишем в ответ.</p>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  int n;
  cin >> n;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }
  int k;
  cin >> k;
  int sum = 0;

  // sum = a(0) + a(1) + ... + a(k-1)
  for (int i = 0; i &lt; k; i++) {
    sum += A[i];
  }
  int sum_max = sum;

  // sum = sum - a(0) + a(k)
  // sum = sum - a(1) + a(k+1)
  for (int i = k; i &lt; n; i++) {
    sum += A[i] - A[i - k];
    sum_max = max(sum, sum_max);
  }

  cout &lt;&lt; sum_max;
}
</pre>
  </details>
</article>


<!-- Задача 3. Максимальная разница -->
<article class="article">
  <div class="anchor" id="t3"></div>
  <h3>Задача 3. Максимальная разница</h3>

  <p>Дан массив из n чисел. Для всех индексов i &lt; j, найти максимальную разность a<sub>j</sub> - a<sub>i</sub></p>

  <h4>Решение</h4>
  <p>На каждом отрезке от 0 до j нужно найти минимальный элемент a<sub>i</sub>, тогда разность a<sub>j</sub> - a<sub>i</sub> будет максимальна</p>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  int n;
  cin >> n;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }
  int min_el = A[0];
  int res = -10000000;
  for (int j = 1; j &lt; n; j++) {
    if ((A[j] - min_el) > res) {
      res = A[j] - min_el;
    }
    min_el = min(A[j], min_el);
  }

  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача 4. Минимальный и максимальный -->
<article class="article">
  <div class="anchor" id="t4"></div>
  <h3>Задача 4. Минимальный и максимальный</h3>

  <p>Дан массив из 2n чисел, то есть с четной длиной. Определить минимальный и максимальный элемент.</p>

  <h4>Решение</h4>
  <p>Начальный массив длиной 2n с четным количеством элементов. Создадим два массива a_min и a_max длиной n каждый. Сравним элементы попарно. Меньшее число пойдет в массив a_min. Большее число - в a_max. Тогда минимальный элемент окажется в массиве a_min, а максимальный - в a_max.</p>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // входные данные
  int n;
  cin >> n;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  vector&lt;int&gt; a_min;
  vector&lt;int&gt; a_max;
  for (int i = 0; i &lt; n; i += 2) {
    if (A[i] > A[i+1]) {
      a_max.push_back(A[i]);
      a_min.push_back(A[i+1]);
    } else {
      a_max.push_back(A[i+1]);
      a_min.push_back(A[i]);
    }
  }
  int min_el = a_min[0];
  int max_el = a_max[0];
  for (int i = 0; i &lt; a_min.size(); i++) {
    min_el = min(min_el, a_min[i]);
    max_el = max(max_el, a_max[i]);
  }

  cout &lt;&lt; min_el &lt;&lt; ' ' &lt;&lt; max_el;
}
</pre>
  </details>
</article>


<!-- Задача 5. Пять максимумов -->
<article class="article">
  <div class="anchor" id="t5"></div>
  <h3>Задача 5. Пять максимумов</h3>

  <p>Дано n (n > 5) натуральных чисел. Найти пять максимумов.</p>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // входные данные
  int n;
  cin >> n;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  int max_el1 = 0;
  int max_el2 = 0;
  int max_el3 = 0;
  int max_el4 = 0;
  int max_el5 = 0;
  for (int i = 0; i &lt; n; i++) {
    if (max_el1 &lt;= A[i]) {
      max_el5 = max_el4;
      max_el4 = max_el3;
      max_el3 = max_el2;
      max_el2 = max_el1;
      max_el1 = A[i];
    } else if (max_el2 &lt;= A[i]) {
      max_el5 = max_el4;
      max_el4 = max_el3;
      max_el3 = max_el2;
      max_el2 = A[i];
    } else if (max_el3 &lt;= A[i]) {
      max_el5 = max_el4;
      max_el4 = max_el3;
      max_el3 = A[i];
    } else if (max_el4 &lt;= A[i]) {
      max_el5 = max_el4;
      max_el4 = A[i];
    } else if (max_el5 &lt;= A[i]) {
      max_el5 = A[i];
    }
  }

  // вывод результата
  cout &lt;&lt; max_el1 &lt;&lt; ' '
       &lt;&lt; max_el2 &lt;&lt; ' '
       &lt;&lt; max_el3 &lt;&lt; ' '
       &lt;&lt; max_el4 &lt;&lt; ' '
       &lt;&lt; max_el5;
}
</pre>
  </details>
</article>


<!-- Задача 6. Частотный словарь -->
<article class="article">
  <div class="anchor" id="t6"></div>
  <h3>Задача 6. Пять максимумов</h3>

  <p>Дано n целых чисел (0 &le; a<sub>i</sub> &lt; 1000). Отсортировать без применения метода sort.</p>

  <h4>Сортировка подсчетом (count sort)</h4>
  <p>Заедем массив размером 1001, потому что числа могут начинаться с нуля а заканчиваются 1000. Тогда ключем будет число, а значением - сколько раз оно встречается</p>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // входные данные
  int n;
  cin >> n;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  vector&lt;int&gt; Count_el(1001);
  for (int i = 0; i &lt; n; i++) {
    Count_el[A[i]]++;
  }

  // вывод результата
  for (int i = 0; i &lt;= 1000; i++) {
    while (Count_el[i] > 0) {
      cout &lt;&lt; i &lt;&lt; " ";
      Count_el[i]--;
    }
  }
}
</pre>
  </details>

  <p>Усложним задачу. Пусть числа начинаются не с 0 а с -1000 (-1000 &le; a<sub>i</sub> &le; 1000).</p>

  <h4>Count sort со сдвигом</h4>
  <p>Добавим в решение два изменение. Первое увеличим массив до нужного числа элементов. Второй сделаем сдвиг на 1000 при заполнении массива и обратный сдвиг на 1000 при выводе результата</p>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // входные данные
  int n;
  cin >> n;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  vector&lt;int&gt; Count_el(2001);
  for (int i = 0; i &lt; n; i++) {
    Count_el[A[i] + 1000]++;
  }

  // вывод результата
  for (int i = 0; i &lt;= 2000; i++) {
    while (Count_el[i] > 0) {
      cout &lt;&lt; i - 1000 &lt;&lt; " ";
      Count_el[i]--;
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача A. Правый минус левый -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Правый минус левый</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Найдите в заданном массиве пару элементов, что правый минус левый — максимально. Более формально, найти такую пару индексов i  и j, что i &lt; j, и a[j] - a[i] максимальное.</p>

  <h4>Входные данные</h4>
  <p>В первой строке вводится N — количество элементов в массиве. (2 ≤ N ≤ 10⁵) Во второй строке вводится N чисел через пробел — заданный массив. Каждый элемент массива не превосходит 1000 по абсолютной величине.</p>

  <h4>Выходные данные</h4>
  <p>Выведите 2 пару индексов i и j через пробел, что i &lt; j, и a[j] - a[i] максимальное. Если ответов несколько выведите такой, где j наименьшее. Если и таких несколько, то такой где i наименьший.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
6
3 4 1 3 5 7
</pre>
    <code>3 6</code>

    <h4>Пример 2</h4>
<pre>
6
3 4 7 3 5 1
</pre>
    <code>1 3</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Начнем с предположения, что максимальная разница — это разница между вторым и первым элементами. Запомним эти индексы (1 и 2). Будем поддерживать индекс min_index, который указывает на минимальный элемент в пройденной части массива. Для каждого следующего элемента вычисляем разницу с этим минимальным элементом. Если текущая разница больше максимальной найденной, обновляем максимальную разницу и сохраняем индексы. При обновлении максимальной разницы всегда выбираем пару с наименьшим j, а при равенстве — с наименьшим i.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;

  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  int best_i = 0;
  int best_j = 1;
  int max_dif = A[best_j] - A[best_i];
  int min_index = 0;
  for (int j = 1; j &lt; n; ++j) {
    if (A[j] - A[min_index] > max_dif) {
      max_dif = A[j] - A[min_index];
      best_i = min_index;
      best_j = j;
    } else if (A[j] - A[min_index] == max_dif) {
      if (j &lt; best_j) {
        best_j = j;
        best_i = min_index;
      } else if (j == best_j && min_index &lt; best_i) {
        best_i = min_index;
      }
    }

    if (A[j] &lt; A[min_index]) {
      min_index = j;
    }
  }

  // вывод результата
  cout &lt;&lt; best_i + 1 &lt;&lt; ' ' &lt;&lt; best_j + 1;
}
</pre>
  </details>
</article>


<!-- Задача B. Клиппи и Мерлин грабят банк -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Клиппи и Мерлин грабят банк</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Клиппи и Мерлин решили грабить банк «Документы», который представляет из себя N расположенных в ряд банковских ячеек, пронумерованных последовательно числами от 1 до N.</p>

  <p>С помощью своего друга Ровера, который работал в банке сторожевым псом, они добыли ключи от всех ячеек, а так же узнали, как много ценностей хранится в каждой ячейке.</p>

  <p>Чтобы не вызывать лишних подозрений, Клиппи и Мерлин решили ограбить всего две ячейки — по одной на каждого. Также, чтобы охрана банка не почуяла неладного, они решили работать далеко друг от друга — между ними должно быть не меньше K банковских ячеек.</p>

  <h4>Входные данные</h4>
  <p>В первой строке вводятся два числа — N (2 ≤ N ≤ 10⁵) и K (0 ≤ K &lt; N-1) соответственно. В второй строке вводятся N чисел aᵢ (0 ≤ aᵢ ≤ 10⁹) — стоимости хранимых ценностей в ячейках от 1 до N соответственно.</p>

  <h4>Выходные данные</h4>
  <p>Выведите два числа в возрастающем порядке — номера ячеек, которые нужно ограбить, чтобы суммарно украсть как можно более дорогие ценности, не вызвав при этом лишних подозрений. Если вариантов несколько выберите тот, в котором меньший номер вскрываемой ячейки был как можно ближе к единице, чтобы в экстренном случае покинуть банк как можно скорее. Если и таких вариантов несколько, выберите тот, в котором и больший номер вскрываемой ячейки был как можно меньше.</p>

  <details>
    <summary>Пример</summary>
<pre>
6 2
2 4 3 1 4 4
</pre>
    <code>2 5</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Заведем два указателя id1 на первого грабителя и id2 на второго грабителя. Поставим первого грабителя на первую ячейку id1 = 0</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  int n, k;
  cin >> n >> k;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  int id1 = 0, max1 = A[0];
  int res = -100000000;
  int id_res1, id_res2;
  for (int i = k + 1; i &lt; n; i++) {
    if (res &lt; A[id1] + A[i]) {
      res = A[id1] + A[i];
      id_res1 = id1;
      id_res2 = i;
    }
    if (A[i - k] > max1) {
      max1 = A[i - k];
      id1 = i - k;
    }
  }

  // вывод результата
  cout &lt;&lt; id_res1 + 1 &lt;&lt; " " &lt;&lt; id_res2 + 1;
}
</pre>
  </details>
</article>


<!-- Задача C. Сумма на подотрезке -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Сумма на подотрезке</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам дан массив длины n и число k. Найдите самую большую сумму k соседних элементов этого массива.</p>

  <h4>Входные данные</h4>
  <p>В первой строке вводятся числа n и k (1 ≤ n ≤ 10⁵, 1 ≤ k ≤ n). Во второй строке вводятся n элементов этого массива.</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно число — самую большую сумму k подряд идущих элементов этого массива.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
5 2
1 2 1 3 2
</pre>
    <code>5</code>

    <h4>Пример 2</h4>
<pre>
3 1
3 2 1
</pre>
    <code>3</code>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  int n, k;
  cin >> n >> k;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  long long sum = 0;
  for (int i = 0; i &lt; k; i++) {
    sum += A[i];
  }
  long long max_sum = sum;
  int pl = 0;
  int pr = k;
  while (pr &lt; n) {
    sum -= A[pl];
    sum += A[pr];
    if (sum > max_sum) {
      max_sum = sum;
    }
    pl++;
    pr++;
  }

  // вывод результата
  cout &lt;&lt; max_sum;
}
</pre>
  </details>
</article>


<!-- Задача D. Пропажа числа -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Пропажа числа</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Пете подарили массив на день рождения, в котором были записаны все числа от 1 до 100 по два раза. Ваня случайно уронил массив Пети и одно число потерялось. Помогите ребятам узнать, какое число потерялось.</p>

  <h4>Входные данные</h4>
  <p>На ввод подаётся массив Пети: 199 чисел от 1 до 100 разделенных пробелом, причём все числа, кроме одного, повторяются дважды.</p>

  <h4>Выходные данные</h4>
  <p>Выведите число, которое повторяется один раз.</p>

  <details>
    <summary>Решение</summary>
    <p>По формуле Гаусса для суммы чисел от 1 до n находим сумму всех чисел массива. Вычитаем сумму чисел на входе и получаем отсутствующее число.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // формула гаусса для суммы
  // чисел от 1 до n
  int gaus100 = 100 * 101 / 2;
  int sum = 2 * gaus100;
  int temp;
  for (int i = 0; i &lt; 199; i++) {
    cin >> temp;
    sum -= temp;
  }

  // вывод результата
  cout &lt;&lt; sum;
}
</pre>
  </details>
</article>


<!-- Задача E. Министерство правды -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Министерство правды</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Андрей работает в министерстве правды. Его работа состоит в том, чтобы изменять статьи в газетах и журналах таким образом, чтобы они восхваляли партию и Большого Брата.</p>

  <p>Недавно Большой Брат решил, что было бы неплохо, если бы все слова во всех статьях читались бы одинаково как справа налево, так и слева направо. По его мнению, это должно серьезно облегчить чтение статей, ведь если случайно прочитать слово задом наперед, его смысл не изменится.</p>

  <p>Андрей тратит одну секунду, чтобы стереть одну букву в слове и написать вместо нее новую. Ему осталось изменить всего лишь одно слово, после чего он выполнит план и сможет пойти домой. Разумеется, ему надо потратить на это как можно меньше времени. Правда, он пока не совсем понимает, какое именно слово должно получиться после замены. Помогите ему в этом.</p>

  <h4>Входные данные</h4>
  <p>В единственной строке записано слово, которое надо изменить Андрею. Оно состоит из строчных латинских букв и имеет длину от 1 до 200000.</p>

  <h4>Выходные данные</h4>
  <p>Выведите слово, которое должно получиться у Андрея в результате. Если существует несколько возможных таких слов, выведите любое.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>abccabd</code>
    <code>abcccba</code>

    <h4>Пример 2</h4>
    <code>wasitadogoracatiate</code>
    <code>wasitadogogodatisaw</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/gym/100187/problem/L" target="_blank">Задача 100187L</a>
      <br><a href="https://codeforces.com/gym/100187" target="_blank">2013, VI Самарская областная межвузовская олимпиада по программированию 2013-04-27</a>
    </div>

    <p>Паттерн два указателя с двух сторон. Заведем левый и правый указатели. Пока левый указатель меньше правого, сравниваем буквы. Если буквы совпадают, то двигаем левый указатель вправо, правый влево. Если буквы не совпадают, то в правый указатель пишем букву из левого указателя и двигаем их.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  string s;
  cin >> s;

  // решение
  int pl = 0, pr = s.size() - 1;
  while (pl &lt; pr) {
    if (s[pl] != s[pr]) {
      s[pr] = s[pl];
    }
    pl++;
    pr--;
  }

  // вывод результата
  cout &lt;&lt; s;
}
</pre>
  </details>
</article>


<!-- Задача F. Ётта -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Ётта</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 512мб</i></div>

  <p>Нияз с Ниязом в ожидании результатов олимпиады решили поиграть в Ётту. В этой игре участники выкладывают карточки в линии по определенным правилам. Карточки бывают четырех разных форм, цветов и достоинств. За выложенную линию игрок получает определенное количество очков.</p>

  <p>Ниязу обычные правила показались слишком сложными, и он предложил убрать у карточек цвет и форму, оставив лишь достоинство. А Ниязу такие правила показались слишком простыми, и он предложил увеличить количество различных достоинств карточек до 100.</p>

  <p>В модифицированных правилах линия считается корректной, если либо она состоит из карточек одного достоинства, либо все карточки в ней имеют различные достоинства. Если игрок выложил некорректную линию, то он получает -1 очков за невнимательность. За корректную линию начисляется количество очков равное сумме достоинств всех карточек в ней. При этом, если достоинство каждой следующей карточки на один больше предыдущей, то очки за такую линию умножаются на два.</p>

  <p>Но при этих правилах Ниязу сложно быстро посчитать очки за выложенную линию. Поэтому он просит Вас ему помочь и написать программу, которая по заданной линии из n карточек определяет количество очков за нее.</p>

  <h4>Входные данные</h4>
  <p>В первой строке задано целое число n — количество карточек на столе (2 ≤ n ≤ 100). В следующей строке задано n целых чисел aᵢ — достоинства карточек на столе (1 ≤ aᵢ ≤ 100). Числа aᵢ заданы в порядке неубывания (aᵢ ≤ aᵢ₊₁).</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное число — сколько очков получит игрок, выложивший данную линию.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
3
1 3 5
</pre>
    <code>9</code>

    <h4>Пример 2</h4>
<pre>
3
2 2 2
</pre>
    <code>6</code>

    <h4>Пример 3</h4>
<pre>
3
1 2 3
</pre>
    <code>12</code>

    <h4>Пример 4</h4>
<pre>
3
1 1 2
</pre>
    <code>-1</code>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;
  vector&lt;int&gt; A;
  int tmp;
  for (int i = 0; i &lt; n; i++) {
    cin >> tmp;
    A.push_back(tmp);
  }

  // решение
  int res = A[0];
  int flag1 = 0;
  int flag2 = 0;
  int cnt = 0;
  for (int i = 1; i &lt; n; i++) {
    if (A[i] == A[i - 1]) {
      if (flag2) {
        res = -1;
        break;
      }
      flag1 = 1;
      res += A[i];
    } else {
      if (flag1) {
        res = -1;
        break;
      }
      flag2 = 1;
      res += A[i];
      if (A[i] - A[i - 1] == 1) {
        cnt++;
      }
    }
  }

  if (cnt == n - 1) {
    res *= 2;
  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача G. Катя и красивое число -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Катя и красивое число</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Маленькой девочке Кате подарили на день рождения целое число. Катя считает красивостью числа количество замкнутых фигур, которые можно закрасить. Например, в числе 877 две замкнутые фигуры, а в числе 32520 только одна. Маленькая Катя еще плохо считает (умеет только до трех), поэтому просит вас помочь ей узнать, какая же красивость числа, которое ей подарили на день рождения.</p>

  <h4>Входные данные</h4>
  <p>В единственной строке входного файла дано целое неотрицательное число без лидирующих нулей. Количество цифр в числе не превосходит 10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное целое число - красивость подарка.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>877</code>
    <code>2</code>

    <h4>Пример 2</h4>
    <code>32520</code>
    <code>1</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/gym/100924/problem/G" target="_blank">Задача 100924G</a>
      <br><a href="https://codeforces.com/gym/100924" target="_blank">Мультипредметная личная олимпиада ЮФУ среди школьников 2016 2016-03-22</a>
    </div>

    <p>Цифры 0, 4, 6, 9 содержат одну замкнутую фигуру, а цифра 8 две.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  string s;
  cin >> s;

  // решение
  int res = 0;
  for (char c : s) {
    switch (c) {
      case '0':
      case '4':
      case '6':
      case '9': res += 1;
                break;
      case '8': res += 2;
                break;
    }
  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача H. Черви и ослы -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Черви и ослы</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>На прямой стоят n червей: i-ый червь находится в точке с координатой xᵢ, причём никакие два червя не находятся в одной точке.</p>

  <p>Маленький мальчик очень любит уничтожать червей. Для этого он использует оружие массового поражения «бетонный осёл». Каждое его применение создает копию бетонного осла шириной d, которая падает на прямую и уничтожает все живое на отрезке длины d. При этом края бетонного осла всегда будут находиться в точках с целыми координатами. Таким образом, каждая копия бетонного осла может уничтожить всех червей, которые расположены на некотором отрезке прямой [x, x + d].</p>

  <p>Помогите маленькому мальчику определить, за какое наименьшее число применений бетонного осла он сможет уничтожить всех червей.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записаны два целых числа n и d (1 ≤ n ≤ 10⁵, 1 ≤ d ≤ 10⁹) — количество червей, находящихся на прямой, и ширина бетонного осла.</p>

  <p>Во второй строке записано n целых чисел x₁, x₂, ..., xₙ ( - 10⁹ ≤ xᵢ ≤ 10⁹) — координаты точек на прямой, в которых расположены черви. Все координаты xᵢ различны и упорядочены по возрастанию.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное целое число — минимальное количество применений бетонного осла, необходимое для уничтожения всех червей.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
7 2
1 3 4 6 10 11 12
</pre>
    <code>3</code>

    <h4>Пример 2</h4>
<pre>
7 2
1 3 4 8 10 11 12
</pre>
    <code>4</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/gym/100853/problem/H" target="_blank">Задача 100853H</a>
      <br><a href="https://codeforces.com/gym/100853" target="_blank">Личный чемпионат СГАУ среди новичков 2015 2015-12-19</a>
    </div>

    <p>Положим бетонного осла одним концом на первый элемент, потом на следующий не накрытый элемент и т.д.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  int n, d;
  cin >> n >> d;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  int res = 0;
  int i = 0;
  while (i &lt; n) {
    int x = A[i];
    res++;
    while ( (i &lt; n) && (A[i] &lt;= x + d) ) {
      i++;
    }
  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача I. Четные, но не кратные шести -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача I. Четные, но не кратные шести</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Рассмотрим массив A размера N, в котором хранятся целые числа.</p>

  <p>Найдите количество подпоследовательностей длины K в этом массиве, которые состоят только из четных чисел, каждое из которых не кратно 6.</p>

  <p>Подпоследовательность формируется подряд идущими элементами массива.</p>

  <h4>Входные данные</h4>
  <p>В первой строке подаются два числа 2 &lt; N ⩽ 300000 и 1 ⩽ K ⩽ N. За ними следует одна строка, в которой перечислены N чисел массива A через пробел. Все числа неотрицательные и не превосходят 1000.</p>

  <h4>Выходные данные</h4>
  <p>Одно целое число, задающее количество искомых подпоследовательностей в массиве A.</p>

  <details>
    <summary>Пример</summary>
<pre>
6 3
2 4 6 2 4 8
</pre>
    <code>1</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Пример 2</p>
<pre>
8 3
2 4 2 4 2 4 2 4
</pre>
  <code>6</code>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  int n, k;
  cin >> n >> k;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  int count = 0;
  int lp = 0;  // левый указатель
  int rp = lp; // правый указатель

  while (rp &lt; n) {
    if (A[rp] % 2 == 0 && A[rp] % 6 != 0) {
      if (rp - lp + 1 == k) {
        count++;
        lp++;
      }
      rp++;
    } else {
      lp = rp + 1;
      rp = lp;
    }
  }

  // вывод результата
  cout &lt;&lt; count;
}
</pre>
  </details>
</article>


<!-- Задача J. Задача без легенды -->
<article class="article">
  <div class="anchor" id="task10"></div>
  <h3>Задача J. Задача без легенды</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Когда год за годом составляешь задачи, всё сложнее и сложнее придумываются условия задач, поэтому иногда приходится отбросить притворство и сообщить участникам напрямую, что от них требуется. Такая задача сейчас находится перед вами.</p>

  <p>Даны N чисел aᵢ, найти количество пар индексов (i,j)(i≠j), таких, что произведение aᵢ и a<sub>j</sub> делится на 14. Обратите внимание, что пары (i,j) и (j,i) являются одинаковыми.</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержится число N (1 ≤ N ≤ 2⋅10⁵) – количество чисел. Во второй строке содержатся N чисел aᵢ (1 ≤ aᵢ ≤ 10⁹) – сами числа.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите число – количество пар чисел, произведение которых делится на 14.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
2
2 7
</pre>
    <code>1</code>

    <h4>Пример 2</h4>
<pre>
5
1 14 5 7 2
</pre>
    <code>5</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Пример 3</p>
<pre>
2
14 14
</pre>
  <code>1</code>
    <p>Пример 4</p>
<pre>
3
14 14 14
</pre>
  <code>3</code>
    <p>Пример 5</p>
<pre>
4
14 14 14 14
</pre>
  <code>6</code>
    <p>Пример 6</p>
<pre>
5
2 2 7 7 7
</pre>
  <code>6</code>
    <p>Если пара чисел делится на 14 то это хорошая пара. Хорошая пара образуется только в двух случаях. Если число делится на 14, с любым числом оно образует хорошую пару. Если число делится на 2, то любое число, которое делится на 7 образует с ним хорошую пару. Линейным алгоритмом переберем все числа. Будем считать сколько чисел делятся на 14, сколько на 2 и сколько на 7.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  long long cnt = 0, cnt2 = 0, cnt7 = 0, cnt14 = 0;
  for (int i = 0; i &lt; n; i++) {
    if (A[i] % 14 == 0) {
      cnt14++;
    } else if (A[i] % 2 == 0) {
      cnt2++;
    } else if (A[i] % 7 == 0) {
      cnt7++;
    }
  }
  if (cnt14 == 1) {
    cnt += (n - 1) * cnt14;
  } else if (cnt14 > 1) {
    cnt += (n - 1) * cnt14 - (cnt14 - 1) * cnt14 / 2;
  }

  cnt += cnt2 * cnt7;

  // вывод результата
  cout &lt;&lt; cnt;
}
</pre>
  </details>
</article>


<!-- Задача K. Двапалиндром -->
<article class="article">
  <div class="anchor" id="task11"></div>
  <h3>Задача K. Двапалиндром</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Двапалиндром – это строка, которая является палиндромом, и каждая половина этой строки также является палиндромом. Напомним, что палиндром – это строка, которая читается одинаково в обоих направлениях. Кстати, самое длинное употребительное слово-палиндром в мире – saippuakauppias. Примером двапалиндрома может служить слово «abbaabba».</p>

  <p>Дана строка s четной длины, требуется превратить её в двапалиндром за минимальное количество изменений символов.</p>

  <h4>Входные данные</h4>
  <p>В единственной строке ввода содержится строка s длины не более 2000 символов.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите ответ на задачу – двапалиндром, полученный из исходной строки минимальным количеством изменений символов. Если существует несколько вариантов ответа, вывести любой.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>abcacbbd</code>
    <code>abbaabba</code>

    <h4>Пример 2</h4>
    <code>abccba</code>
    <code>abaaba</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Будем сравнивать 4 буквы на которые указывают 4 указателя. Вначале поставим два указателя на первую и последнюю букву первой половины слова, и два указателя на первую и последнюю букву второй половины слова. Если какая-то буква повторяется дважды, то выбираем ее, иначе все равно какую. Заменяем остальные буквы в указателях на выбранную.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  string s;
  cin >> s;

  // решение
  int pl = 0, pr = s.size() - 1;
  int pm1 = s.size() / 2 - 1, pm2 = pm1 + 1;
  char el;
  while (pl &lt;= pm1) {
    if (s[pr] == s[pm1] || s[pr] == s[pm2]) {
      el = s[pr];
    } else if (s[pm1] == s[pm2]) {
      el = s[pm1];
    } else {
      el = s[pl];
    }
    s[pl] = el;
    s[pm1] = el;
    s[pm2] = el;
    s[pr] = el;
    pl++;
    pm1--;
    pm2++;
    pr--;
  }

  // вывод результата
  cout &lt;&lt; s;
}
</pre>
  </details>
</article>


<!-- Задача L. Пилообразная последовательность -->
<article class="article">
  <div class="anchor" id="task12"></div>
  <h3>Задача L. Пилообразная последовательность</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 16мб</i></div>

  <p>Последовательность a₁, a₂, a₃, …, aₙ₋₁, aₙ называется пилообразной, если она удовлетворяет одному из следующих условий:</p>
  <ol>
    <li>a₁ &lt; a₂ > a₃ &lt; … > aₙ₋₁ &lt; aₙ</li>
    <li>a₁ > a₂ &lt; a₃ > … &lt; aₙ₋₁ > aₙ</li>
  </ol>

  <p>Дана числовая последовательность. Требуется определить длину самой длинной ее пилообразной непрерывной подпоследовательности.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано натуральное число N – количество элементов последовательности. Во второй строке файла через пробел записаны N элементов целочисленной последовательности {aᵢ}. Ограничения: N &lt; 10⁶, |aᵢ| &lt; 32000.</p>

  <h4>Выходные данные</h4>
  <p>В единственную строку нужно вывести одно целое число — длину самой длиной непрерывной пилообразной подпоследовательности.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
3
1 2 3
</pre>
    <code>2</code>

    <h4>Пример 2</h4>
<pre>
12
5 7 6 3 4 2 7 1 8 9 4 5
</pre>
    <code>7</code>

    <h4>Пример 3</h4>
<pre>
5
1 -2 3 -4 5
</pre>
    <code>5</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Будем отдельно считать длину плообразной последовательности для двух случаев: 1 когда в первой паре числа возрастают, 2 - убывают. Если в паре числа равны, то обе последователности прерываются.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  int res = 0;
  // первая пара возрастающая
  int cnt_inc = 1;
  // первая пара убывающая
  int cnt_dec = 1;

  for (int i = 1; i &lt; n; i++) {

    if (i % 2) { // 1,3,5,7..
      if (A[i] > A[i - 1]) {
        cnt_inc++;
        res = max(res, cnt_dec);
        cnt_dec = 1;
      } else if (A[i - 1] > A[i]) {
        cnt_dec++;
        res = max(res, cnt_inc);
        cnt_inc = 1;
      } else {
        res = max(res, cnt_dec);
        res = max(res, cnt_inc);
        cnt_dec = 1;
        cnt_inc = 1;
      }

    } else { // 2,4,6,8...
      if (A[i - 1] > A[i]) {
        cnt_inc++;
        res = max(res, cnt_dec);
        cnt_dec = 1;
      } else if (A[i] > A[i - 1]) {
        cnt_dec++;
        res = max(res, cnt_inc);
        cnt_inc = 1;
      } else {
        res = max(res, cnt_dec);
        res = max(res, cnt_inc);
        cnt_dec = 1;
        cnt_inc = 1;
      }
    }

  }
  res = max(res, cnt_dec);
  res = max(res, cnt_inc);

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача M. Противоположности притягиваются -->
<article class="article">
  <div class="anchor" id="task13"></div>
  <h3>Задача M. Противоположности притягиваются</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Всем известно, что противоположности притягиваются. Брачное агентство «Паросочетание» работает по этому признаку. Каждого зарегистрированного клиента сотрудники «Паросочетания» классифицировали по его интересам, i-ому клиенту было назначено число tᵢ ( - 10 ≤ tᵢ ≤ 10). Конечно, одно и то же число может быть назначено более чем одному клиенту.</p>

  <p>В качестве рекламы «Паросочетание» хочет опубликовать количество пар противоположных клиентов, то есть таких, у которых значение параметра t противоположно. Клиент может входить в пару произвольное количество раз. Помогите агентству и напишите программу, которая по заданной последовательности t₁, t₂, ..., tₙ найдет искомое количество. Например, если t = (1, - 1, 1, - 1), то любые два элемента tᵢ и t<sub>j</sub> образуют пару, если i и j имеют разную четность. Следовательно, в этом случае искомое количество равно 4.</p>

  <p>Конечно, клиент не может образовывать пару с самим собой.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных содержится целое число n (1 ≤ n ≤ 10⁵) — количество зарегистрированных клиентов «Паросочетания». Вторая строка содержит последовательность целых чисел t₁, t₂, ..., tₙ (-10 ≤ tᵢ ≤ 10), tᵢ — параметр i-го клиента, присвоенный по результатам анализа его интересов.</p>

  <h4>Выходные данные</h4>
  <p>Выведите количество пар клиентов с противоположными t. Числом, противоположным для x является число - x (0 противоположен сам себе). Пары, отличающиеся только порядком клиентов, считаются одинаковыми.</p>

  <p>Учтите, что ответ на задачу может быть довольно большим, поэтому необходимо использовать 64-битный целый тип для вычислений. Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
5
-3 3 0 0 3
</pre>
    <code>3</code>
    <p>В первом примере пары противоположных клиентов: (1,2), (1,5) и (3,4).</p>

    <h4>Пример 2</h4>
<pre>
3
0 0 0
</pre>
    <code>3</code>
    <p>Во втором примере любая пара клиентов — противоположна.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/131/problem/B" target="_blank">Задача 131B</a>
      <br><a href="https://codeforces.com/contest/131" target="_blank">Codeforces Beta Round 95 (Div. 2) 2011-11-25</a>
    </div>

    <p>Пример 3</p>
<pre>
5
0 1 2 2 3
</pre>
  <code>0</code>

    <p>Пример 4</p>
<pre>
6
-10 10 -10 10 -10 10
</pre>
  <code>9</code>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;

  // хеш-таблица для всех чисел от -10 до 10
  vector&lt;long long&gt; A(21,0);
  int tmp;

  // сразу заполняем хеш-таблицу со сдвигом 10
  for (int i = 0; i &lt; n; i++) {
    cin >> tmp;
    A[tmp+10]++;
  }

  // решение
  long long res = 0;

  // считаем пары для 0
  res += A[10] * (A[10] - 1) / 2;

  // считаем пары для остальных чисел
  for (int i = 0; i &lt; 10; i++) {
    res += A[i] * A[20 - i];
  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача N. Футбол -->
<article class="article">
  <div class="anchor" id="task14"></div>
  <h3>Задача N. Футбол</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Петя очень любит футбол. Однажды, глядя футбольный матч, он записывал на листе бумаги текущее положение игроков. Для простоты он изобразил ситуацию в виде строки из нулей и единиц. Ноль соответствует игрокам одной команды, единица — игрокам другой команды. Если есть как минимум 7 игроков некоторой команды, стоящих подряд, то эта ситуация считается опасной. Например, ситуация 00100110111111101 — опасная, а 11110111011101 — нет. Вам задана текущая ситуация. Определите, является ли она опасной.</p>

  <h4>Входные данные</h4>
  <p>В первой строке ввода задана непустая строка из символов «0» и «1», обозначающих игроков. Длина строки не превышает 100 символов. От каждой команды на поле присутствует хотя бы один игрок.</p>

  <h4>Выходные данные</h4>
  <p>Выведите «YES» если ситуация опасная. В противном случае выведите «NO».</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>001001</code>
    <code>NO</code>

    <h4>Пример 2</h4>
    <code>1000000001</code>
    <code>YES</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/96/problem/A" target="_blank">Задача 96A</a>
      <br><a href="https://codeforces.com/contest/96" target="_blank">Codeforces Beta Round 77 (Div. 2 Only) 2011-07-08</a>
    </div>

    <p>Линейным алгоритмам пройдем по символам строки. Если встретим подряд идущие 7 одинаковых символов, то это опасно, иначе нет.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  string s;
  cin >> s;

  // решение
  bool danger = false, c0 = false, c1 = false;
  int cnt;
  for (char c : s) {
    if (c == '0') {
      if (c0) {
        cnt++;
        if (cnt == 7) {
          danger = true;
          break;
        }
      } else {
        cnt = 1;
        c0 = true;
        c1 = false;
      }
    } else if (c == '1') {
      if (c1) {
        cnt++;
        if (cnt == 7) {
          danger = true;
          break;
        }
      } else {
        cnt = 1;
        c1 = true;
        c0 = false;
      }
    }
  }

  // вывод результата
  if (danger) {
    cout &lt;&lt; "YES";
  } else {
    cout &lt;&lt; "NO";
  }
}
</pre>
  </details>
</article>


<!-- Задача O. Медиана Профессора Р. -->
<article class="article">
  <div class="anchor" id="task15"></div>
  <h3>Задача O. Медиана Профессора Р.</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В математической статистике есть такое понятие, как медиана ряда чисел. Медианой ряда чисел называется число, стоящее посередине упорядоченного по возрастанию ряда чисел (в случае, если количество чисел нечётное). Если же количество чисел в ряду чётно, то медианой ряда является полусумма двух стоящих посередине чисел упорядоченного по возрастанию ряда.</p>

  <p>Но в Ярославском университете не дремлют и изобрели новое понятие – медиана профессора Р. Определим её. Медианой профессора Р. ряда чисел называют число из этого ряда, ближайшее к полусумме минимального и максимального, причем, если таких чисел несколько, из них выбирается минимальное по значению. Ваша задача – найти медиану Профессора Р. в заданном ряде чисел.</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержится единственное число n (1 ≤ n ≤ 10⁵) – число элементов.</p>

  <p>Во второй строке содержатся n целых чисел aᵢ, разделенных пробелом – элементы ряда чисел (|aᵢ| ≤ 2·10⁹).</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите значение медианы профессора Р. для заданного ряда чисел.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
5
1 1 1 1 1
</pre>
    <code>1</code>

    <h4>Пример 2</h4>
<pre>
3
1 2 3
</pre>
    <code>2</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Пример 3</p>
<pre>
4
1 2 3 4
</pre>
  <code>2</code>

    <p>Пример 4</p>
<pre>
6
1 2 5 6 7 8
</pre>
  <code>5</code>

    <p>Пример 5</p>
<pre>
6
1 2 5 6 7 9
</pre>
  <code>5</code>

    <p>Пример 6</p>
<pre>
6
1 1 1 1 1 9
</pre>
  <code>1</code>

    <p>Пример 7</p>
<pre>
6
5 5 5 5 6 9
</pre>
  <code>6</code>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;
  vector&lt;long long&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  sort(A.begin(), A.end());
  long long minA = A[0];
  long long maxA = A[n - 1];
  double midA = (minA + maxA) / 2.0;
  long long med = maxA;
  double delta, minDelta = med;
  for (int i = 0; i &lt; n; i++) {
    if (midA == A[i]) {
      med = A[i];
      break;
    } else {
      delta = abs(midA - A[i]);
      if (minDelta > delta) {
        minDelta = delta;
        med = A[i];
      }
    }
  }

  // вывод результата
  cout &lt;&lt; med;
}
</pre>
  </details>
</article>


<!-- Задача P. Сортировка подсчётом -->
<article class="article">
  <div class="anchor" id="task16"></div>
  <h3>Задача P. Сортировка подсчётом</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 512мб</i></div>

  <p>Напишите, пожалуйста, сортировку подсчетом.</p>

  <h4>Входные данные</h4>
  <p>На вход подаётся единственное число n (1 ≤ n ≤ 10⁶) - размер массива. Далее вводятся n неотрицательных чисел не превосходящих 10⁶ по своей величине - элементы массива.</p>

  <h4>Выходные данные</h4>
  <p>Выведите отсортированный по невозрастанию введенный массив.</p>

  <details>
    <summary>Пример</summary>
<pre>
3
2 1 3
</pre>
    <code>3 2 1 </code>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;
  int tmp;
  vector&lt;int&gt; A(1e6 + 1, 0);
  for (int i = 0; i &lt; n; i++) {
    cin >> tmp;
    A[tmp]++;
  }

  // вывод результата
  for (int i = 1e6; i >= 0; i--) {
    while (A[i] != 0) {
      cout &lt;&lt; i &lt;&lt; ' ';
      A[i]--;
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача Q. Рамки для картин -->
<article class="article">
  <div class="anchor" id="task17"></div>
  <h3>Задача Q. Рамки для картин</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Художник Николай собирается написать несколько новых картин. Николай уверен, что картины получатся настолько хороши, что каждую из них можно будет заключить в рамку и повесить на стену. Именно с рамок для будущих картин Николай и решил начать.</p>

  <p>У Николая есть n палочек с длинами a₁, a₂, ... aₙ. Ломать и склеивать палочки Николай не хочет. Чтобы получить рамку размера h x w, нужны две палочки длины h и две палочки длины w. В частности, для случая квадратной рамки (когда h = w), нужны четыре палочки одинаковой длины.</p>

  <p>Теперь Николай хочет собрать из имеющихся палочек как можно больше рамок для того, чтобы написать как можно больше картин под них. Помогите ему в этом нелегком деле. Учтите, что не обязательно использовать все имеющиеся палочки.</p>

  <h4>Входные данные</h4>
  <p>В первой строке находится целое число n (1 ≤ n ≤ 100) — количество палочек. Во второй строке находятся n целых чисел, разделенных пробелом. i-ое из них равно длине i-ой палочки aᵢ (1 ≤ aᵢ ≤ 100).</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно целое число — максимальное количество рамок, которые Николай сможет собрать для своих будущих картин.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
5
2 4 3 2 3
</pre>
    <code>1</code>

    <h4>Пример 2</h4>
<pre>
13
2 2 4 4 4 4 6 6 6 7 7 9 9
</pre>
    <code>3</code>

    <h4>Пример 3</h4>
<pre>
4
3 3 3 5
</pre>
    <code>0</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/127/problem/B" target="_blank">Задача 127B</a>
      <br><a href="https://codeforces.com/contest/127" target="_blank">Codeforces Beta Round 93 (Div. 2 Only) 2011-11-09</a>
    </div>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;
  int tmp;
  vector&lt;int&gt; A(101, 0);
  for (int i = 0; i &lt; n; i++) {
    cin >> tmp;
    A[tmp]++;
  }

  // Решение
  int res = 0;
  int cnt = 0;
  for (int i = 1; i &lt;= 100; i++) {
    while (A[i]>0) {
      cnt++;
      A[i]--;
      if (cnt == 4) {
        res++;
        cnt = 0;
      }
    }
    if (cnt == 1) {
      cnt = 0;
    }
    if (cnt == 3) {
      cnt = 2;
    }
  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача R. Веселая шутка -->
<article class="article">
  <div class="anchor" id="task18"></div>
  <h3>Задача R. Веселая шутка</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вот и прошли новогодние праздники. Для Деда Мороза и его коллег пришло время отдыха и приема гостей. Когда встречаются два «Новогодних Деда», то их помощники в честь такого знаменательного события вырезают из картона буквы имен гостя и хозяина, и вывешивают над парадным входом. Однажды ночью, когда все легли спать, кто-то снял все буквы имен наших персонажей. Затем он, возможно, перемешал эти буквы, и положил в одну кучку перед дверью.</p>

  <p>Наутро так и не удалось найти виновника беспорядка, но всех заинтересовал еще один вопрос: можно ли из букв, сложенных перед дверью, заново составить имена гостя и хозяина? То есть нужно проверить, что не останется лишних, и не придется вырезать дополнительные буквы.</p>

  <p>Помогите «Новогодним Дедам» и их друзьям разобраться с этой проблемой, если вам даны обе надписи, висевшие над парадной дверью вечером, и буквы в кучке, найденной перед парадной дверью утром.</p>

  <h4>Входные данные</h4>
  <p>Во входных данных три строки: в первой строке — имя гостя, во второй — имя хозяина резиденции, в третьей строке — буквы в кучке, найденной перед дверью утром. Все строки не пусты и состоят только из заглавных латинских букв. Длина каждой строки не превосходит 100.</p>

  <h4>Выходные данные</h4>
  <p>Выведите «YES» без кавычек, если из букв в кучке можно составить имена «Новогодних Дедов», и «NO» без кавычек в противном случае.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
SANTACLAUS
DEDMOROZ
SANTAMOROZDEDCLAUS
</pre>
    <code>YES</code>
    <p>В первом примере: из букв, записанных в последней строке можно составить имена, записанные в первых двух, и не останется лишних букв.</p>

    <h4>Пример 2</h4>
<pre>
PAPAINOEL
JOULUPUKKI
JOULNAPAOILELUPUKKI
</pre>
    <code>NO</code>
    <p>Во втором примере: в кучке не хватает буквы «P» и лишняя буква «L».</p>

    <h4>Пример 3</h4>
<pre>
BABBONATALE
FATHERCHRISTMAS
BABCHRISTMASBONATALLEFATHER
</pre>
    <code>NO</code>
    <p>В третьем примере: лишняя буква «L».</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/141/problem/A" target="_blank">Задача 141A</a>
      <br><a href="https://codeforces.com/contest/141A" target="_blank">Codeforces Round 101 (Div. 2) 2012-01-08</a>
    </div>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  string s1, s2, s3;
  cin >> s1 >> s2 >> s3;

  // решение
  vector&lt;int&gt; A(26);
  vector&lt;int&gt; B(26);
  for (int i = 0; i &lt; s1.size(); i++) {
    A[s1[i] - 'A']++;
  }
  for (int i = 0; i &lt; s2.size(); i++) {
    A[s2[i] - 'A']++;
  }
  for (int i = 0; i &lt; s3.size(); i++) {
    B[s3[i] - 'A']++;
  }
  bool flag = true;
  for (int i = 0; i &lt; 26; i++) {
    if (A[i] != B[i]) {
      flag = false;
    }
  }

  // вывод результата
  if (flag) {
    cout &lt;&lt; "YES";
  } else {
    cout &lt;&lt; "NO";
  }
}
</pre>
  </details>
</article>


<!-- Задача S. LuoTianyi и шоу -->
<article class="article">
  <div class="anchor" id="task19"></div>
  <h3>Задача S. LuoTianyi и шоу</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В шоу о VOCALOID принимают участие n человек. Они будут сидеть в ряду с сиденьями, пронумерованными от 1 до m слева направо.</p>

  <p>Все n людей приходят и садятся по порядку. Каждый человек занимает место одним из трёх способов:</p>
  <ol>
    <li>Сесть на соседнее слева место от самого левого человека, который уже сидит, или, если место 1 занятно, то покинуть шоу. Если сейчас никто не сидит, то занять место с номером m.</li>
    <li>Сесть на соседнее справа место от самого правого человека, который уже сидит, или, если место m занятно, то покинуть шоу. Если сейчас никто не сидит, то занять место с номером 1.</li>
    <li>Сесть на место с номером x<sub>i</sub>. Если это место занято, то покинуть шоу.</li>
  </ol>
  <p>Теперь вы хотите узнать, каково максимальное количество тех, кто может занять место, если вы можете впустить людей на шоу в любом порядке?</p>

  <h4>Входные данные</h4>
  <p>Каждый тест состоит из нескольких наборов входных данных. Первая строка содержит единственное целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных. Далее следует описание наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит два целых числа n и m (1 ≤ n, m ≤ 10⁵) — количество людей и количество мест.</p>

  <p>Вторая строка каждого набора входных данных содержит n
  целых чисел x₁, x₂, ... ,xₙ (-2 ≤ xᵢ ≤ m, xᵢ ≠ 0), i-е из которых описывает способ, как i-й человек занимает место:</p>
  <ol>
    <li>Если xᵢ = -1, то i-й человек занимает место первым способом.</li>
    <li>Если xᵢ = -2, то i-й человек занимает место вторым способом.</li>
    <li>Если xᵢ > 0, то i-й человек занимает место третьим способом, т.е. хочет сесть на место с номером xᵢ или покинуть шоу, если оно занято.</li>
  </ol>
  <p>Гарантируется, что сумма n и сумма m по всем наборам входных данных не превосходят 10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите единственное целое число — максимальное количество человек, которые могут занять место.</p>

  <details>
    <summary>Пример</summary>
<pre>
10
3 10
5 5 5
4 6
1 -2 -2 1
5 7
-1 -1 4 -2 -2
6 7
5 -2 -2 -2 -2 -2
6 6
-1 1 4 5 -1 4
6 8
-1 -1 -1 3 -1 -2
6 7
5 -1 -2 -2 -2 -2
3 1
-2 -2 1
2 5
5 -2
1 2
-1
</pre>
<pre>
1
3
5
6
5
5
5
1
2
1
</pre>
    <summary>Примечание к примеру</summary>
    <p><strong>В первом наборе</strong> входных данных все люди хотят занять место 5, поэтому только 1 человек сможет занять место.</p>

    <p><strong>Во втором наборе</strong> входных данных людей можно впустить в порядке 1,2,3,4, тогда все люди, кроме последнего, смогут занять место.</p>

    <p><strong>В третьем наборе</strong> входных данных мы можем впускать людей на шоу в таком порядке:</p>

    <p>Впустим третьего человека:</p>

    <p>–	–	–	3	–	–	–</p>
    <p>Впустим четвёртого человека:</p>

    <p>–	–	–	3	4	–	–</p>
    <p>Впустим пятого человека:</p>

    <p>–	–	–	3	4	5	–</p>
    <p>Впустим первого человека:</p>

    <p>–	–	1	3	4	5	–</p>
    <p>Впустим второго человека:</p>

    <p>–	2	1	3	4	5	–</p>
    <p>Таким образом, все 5 человек заняли места.</p>

    <p><strong>В пятом наборе</strong> входных данных мы можем впускать людей на шоу в таком порядке:</p>

    <p>Впустим четвёртого человека:</p>

    <p>–	–	–	–	4	–</p>
    <p>Впустим третьего человека:</p>

    <p>–	–	–	3	4	–</p>
    <p>Впустим шестого человека, он покинет шоу, потому что занимает место третьим способом и должен сесть на место 4, но оно уже занято:</p>

    <p>–	–	–	3	4	–</p>
    <p>Впустим пятого человека:</p>

    <p>–	–	5	3	4	–</p>
    <p>Впустим первого человека:</p>

    <p>–	1	5	3	4	–</p>
    <p>Впустим второго человека:</p>

    <p>2	1	5	3	4	–</p>
    <p>Таким образом, 5 человек заняли места.</p>

    <p><strong>В седьмом наборе</strong> входных данных мы можем впускать людей на шоу в таком порядке:</p>

    <p>Впустим третьего человека:</p>

    <p>3	–	–	–	–	–	–</p>
    <p>Впустим четвёртого человека:</p>

    <p>3	4	–	–	–	–	–</p>
    <p>Впустим пятого человека:</p>

    <p>3	4	5	–	–	–	–</p>
    <p>Впустим шестого человека:</p>

    <p>3	4	5	6	–	–	–</p>
    <p>Впустим первого человека:</p>

    <p>3	4	5	6	1	–	–</p>
    <p>Впустим второго человека, он покинет шоу, потому что занимает место первым способом, но место 1 занято:</p>

    <p>3	4	5	6	1	–	–</p>
    <p>Таким образом, 5 человек заняли места.</p>
  </details>

  <details>
    <summary>Ещё тесты</summary>

    <h4>Тест 2</h4>
<pre>
33
1 4
1
3 3
-1 -2 -2
5 2
1 -1 -2 -2 -1
4 3
-1 -1 -1 -2
3 1
-2 -2 1
2 5
5 -2
1 2
-1
5 4
2 3 -2 1 -2
4 5
2 -2 -2 -2
3 2
1 -2 -1
1 3
3
3 1
-2 1 1
2 5
2 -1
5 2
1 -1 -1 -2 2
5 5
-1 1 -2 -2 1
4 5
-2 2 -2 -1
3 4
-1 -2 -1
4 2
1 2 1 2
4 2
-2 -2 1 -2
5 2
2 2 -2 1 2
4 5
4 -1 -1 -1
1 4
-2
4 2
-1 -2 -1 -2
2 2
-2 2
4 1
-2 -2 -1 -1
4 3
-1 3 -2 -2
2 3
-1 -2
3 1
-2 1 -1
5 2
-1 -2 1 -2 -1
5 4
3 -2 -1 1 -2
5 2
-1 -2 2 -1 2
3 3
-2 1 -1
2 1
-1 -1
</pre>
<code>1 2 2 3 1 2 1 4 4 2 1 1 2 2 3 4 2 2 2 2 4 1 2 2 1 3 1 1 2 4 2 2 1</code>

    <h4>Тест 4</h4>
<pre>
1
100 120
-1 72 18 -1 5 -2 70 -1 -1 18 -2 33 93 -1 -2 -2 -2 -2 78 114 -2
65 -2 -1 74 48 16 70 63 -2 94 118 61 108 40 48 105 73 113 103
75 16 22 53 -1 62 47 -2 2 16 56 117 74 102 92 -1 79 98 28 120
72 113 31 43 -1 4 84 58 92 41 44 45 -1 67 -1 -2 -2 -2 35 45 -1
66 119 -1 84 -1 49 97 -2 84 103 10 -2 33 22 112 -1 38 118 65
</pre>
    <code>83</code>

    <h4>Тест</h4>
<pre>
2
6 6
2 5 -1 -1 -2 -2
8 10
2  9 -1 -1 -1 -2 -2 -2
</pre>
    <code>5 6</code>

    <h4>Тест</h4>
<pre>
2
7 5
3 -1 -1 -1 -2 -2 -2
8 6
3 -1 -1 -1 -2 -2 -2 -2
</pre>
    <code>5 6</code>
  </details>

  <details>
    <summary>Решение за O(n)</summary>

    <div>
      <a href="https://codeforces.com/contest/1824/problem/A" target="_blank">Задача 1824A</a>
      <br><a href="https://codeforces.com/contest/1824" target="_blank">Codeforces Round 872 (Div. 1) 2023-05-08</a>
    </div>

    <p>Посчитаем количество человек с первым способом cnt1, со вторым способом cnt2, с третьим способом cnt3.</p>
    <p>Если с третьим способом никого нет, то людей можно рассадить только первым или только вторым, выбираем из них максимум.</p>
    <p>Если с третьим способом кто-нибудь есть, то нужно рассмотреть четыре варианта и выбрать из них максимум. Каждый вариант это простой проход по циклу, поэтому <strong>сложность O(n)</strong></p>
    <p>1 вариант. начинаем сажать слева первым способом учитывая занятые места</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n, m;
    cin >> n >> m;

    // все места в зале
    // 1 - занято
    // 0 - свободно
    vector&lt;int&gt; A(m + 1, 0);

    int cnt1 = 0, cnt2 = 0, cnt3 = 0;
    int tmp;

    // заполняем входные данные
    for (int i = 0; i &lt; n; i++) {
      cin >> tmp;
      if (tmp == -1) {
        cnt1++;
      } else if (tmp == -2) {
        cnt2++;
      } else if (tmp &lt;= m && A[tmp] == 0) {
        A[tmp] = 1;
        cnt3++;
      }
    }

    // решение
    int res = 0;

    // если третим способом никого нет
    // то можно посадить только слева или справа
    // выберем из них максимум
    if (cnt3 == 0) {
      res = max(cnt1, cnt2);

      // результат не может быть больше числа мест
      res = min(res, m);

      // если третим способом кто-то есть
      // то рассмотрим 4 варианта
    } else {

      // 3 вариант
      // учитывая занятые места
      int cnt1a = cnt1;
      int res3 = 0;
      int res30 = 0;
      int prev = 0;
      int next = m + 1;
      for (int i = 1; i &lt;= m; i++) {
        // начинаем сажать слева первым способом
        if (A[i] == 0 && cnt1a > 0) {
          res3++;
          cnt1a--;
        }
        // предыдущее занятое место
        if (A[i] == 1 && cnt1a > 0) {
          res30 = res3;
          prev = i;
        }
        // следующее занятое место
        if (A[i] == 1 && cnt1a == 0) {
          next = i;
          break;
        }
      }
      int cnt2a = cnt2;
      int res31 = 0;
      for (int i = prev + 1; i &lt;= m; i++) {
        // начинаем сажать справа вторым способом
        if (A[i] == 0 && cnt2a > 0) {
          res31++;
          cnt2a--;
        }
      }
      cnt2a = cnt2;
      int res32 = 0;
      for (int i = next + 1; i &lt;= m; i++) {
        // начинаем сажать справа вторым способом
        if (A[i] == 0 && cnt2a > 0) {
          res32++;
          cnt2a--;
        }
      }
      res3 = cnt3 + max(res30 + res31, res3 + res32);

      // 4 вариант
      // учитывая занятые места
      cnt2a = cnt2;
      int res4 = 0;
      int res40 = 0;
      prev = m + 1;
      next = 0;
      for (int i = m; i > 0; i--) {
        // начинаем сажать справа вторым способом
        if (A[i] == 0 && cnt2a > 0) {
          res4++;
          cnt2a--;
        }
        // предыдущее занятое место
        if (A[i] == 1 && cnt2a > 0) {
          res40 = res4;
          prev = i;
        }
        // следующее занятое место
        if (A[i] == 1 && cnt2a == 0) {
          next = i;
          break;
        }
      }
      cnt1a = cnt1;
      int res41 = 0;
      for (int i = prev - 1; i > 0; i--) {
        // начинаем сажать слева первым способом
        if (A[i] == 0 && cnt1a > 0) {
          res41++;
          cnt1a--;
        }
      }
      cnt1a = cnt1;
      int res42 = 0;
      for (int i = next - 1; i > 0; i--) {
        // начинаем сажать слева первым способом
        if (A[i] == 0 && cnt1a > 0) {
          res42++;
          cnt1a--;
        }
      }
      res4 = cnt3 + max(res40 + res41, res4 + res42);

      res = max(res, max(res3, res4));
      res = min(res, m);
    }

    // вывод результата
    cout &lt;&lt; res &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача T. Конец света -->
<article class="article">
  <div class="anchor" id="task20"></div>
  <h3>Задача T. Конец света</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Через t единиц времени наступит конец света. В преддверии столь знаменательного события n людей подготовили m убежищ, в которых, как они думают, можно будет спастись. Однако каждое убежище вмещает в себя лишь k человек, а каждый человек за одну единицу времени проходит лишь одну единицу расстояния. К счастью, все люди и убежища находятся сейчас на одной прямой, что уменьшает путаницу и облегчает подсчеты.</p>

  <p>Вам дано расположение людей и убежищ на прямой. Выясните, какое максимальное количество людей смогут спрятаться в убежищах и думать, что им удастся спастись.</p>

  <h4>Входные данные</h4>
  <p>В первой строке через пробел записаны четыре целых числа n, m, k и t (1 ≤ n, m, k ≤ 200000, 1 ≤ t ≤ 10⁹) — количество людей, количество убежищ, вместимость одного убежища и время, оставшееся до конца света.</p>

  <p>Во второй строке записаны n целых чисел через пробел — координаты людей на прямой.</p>

  <p>В третьей строке записаны m целых чисел через пробел — координаты убежищ на прямой.</p>

  <p>Все координаты лежат в пределах от -10⁹ до 10⁹.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное целое число — максимальное количество людей, которые смогут спрятаться в убежищах и думать, что им удастся спастись.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
2 2 1 5
45 55
40 60
</pre>
    <code>2</code>

    <h4>Пример 2</h4>
<pre>
2 2 1 5
45 54
40 60
</pre>
    <code>1</code>

    <h4>Пример 3</h4>
<pre>
2 2 2 5
45 35
40 60
</pre>
    <code>2</code>

    <h4>Пример 4</h4>
<pre>
3 3 1 5
40 45 45
45 50 50
</pre>
    <code>3</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/gym/100187/problem/F" target="_blank">Задача 100187F</a>
      <br><a href="https://codeforces.com/gym/100187" target="_blank">2013, VI Самарская областная межвузовская олимпиада по программированию 2013-04-27</a>
    </div>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  int n, m, k;
  cin >> n >> m >> k;
  long long t;
  cin >> t;
  vector&lt;int&gt; A(n, 0);
  vector&lt;int&gt; B(m, 0);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }
  for (int i = 0; i &lt; m; i++) {
    cin >> B[i];
  }

  // решение
  int res = 0;
  int pA = 0;
  sort(A.begin(), A.end());
  sort(B.begin(), B.end());
  for (int i = 0; i &lt; m && pA &lt; n; i++) {
    for (int j = 0; j &lt; k && pA &lt; n; j++) {
      while (pA &lt; n && A[pA] &lt; B[i] - t) {
        pA++;
      }
      if (pA &lt; n && A[pA] &lt;= B[i] + t) {
        res++;
        pA++;
      }
    }
  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача U. Мистер совершенство -->
<article class="article">
  <div class="anchor" id="task21"></div>
  <h3>Задача U. Мистер совершенство</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Виктор хочет стать «Мистером совершенство». Для этого ему нужно овладеть определенным набором навыков. Более точно, есть 2 навыка, которыми ему нужно овладеть.</p>

  <p>У него также есть n книг. Чтение книги i занимает у него mᵢ минут и дает ему некоторые (возможно, ни одного) из двух необходимых навыков, представленных двоичной строкой длины 2.</p>

  <p>Какое минимальное количество времени потребуется, чтобы Виктор овладел обоими необходимыми навыками?</p>

  <h4>Входные данные</h4>
  <p>Входные данные состоят из нескольких наборов входных данных. Первая строка содержит целое число t (1 ≤ t ≤ 1000) — количество наборов случаев. Затем следует описание наборов.</p>

  <p>Первая строка каждого набора содержит целое число n (1 ≤ n ≤ 2⋅10⁵) — количество доступных книг.</p>

  <p>Затем следуют n строк. Строка i содержит положительное целое число mᵢ (1 ≤ mᵢ ≤ 2⋅10⁵) и двоичную строку длины 2, где sᵢ₁=1, если чтение книги i дает Виктору навык 1, и sᵢ₁=0  в противном случае, а sᵢ₂=1, если чтение книги i дает Виктору навык 2, и sᵢ₂=0 в противном случае.</p>

  <p>Гарантируется, что сумма n по всем тестовым случаям не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно целое число, обозначающее минимальное количество минут, необходимое для того, чтобы Виктор овладел обоими необходимыми навыками, и -1, если невозможно овладеть двумя навыками после чтения любого количества книг.</p>

  <details>
    <summary>Пример</summary>
<pre>
6
4
2 00
3 10
4 01
4 00
5
3 01
3 01
5 01
2 10
9 10
1
5 11
3
9 11
8 01
7 10
6
4 01
6 01
7 01
8 00
9 01
1 00
4
8 00
9 10
9 11
8 11
</pre>
<pre>
7
5
5
9
-1
8
</pre>
    <p>В первом тестовом случае мы можем использовать книги 2 и 3, с общим количеством потраченного времени, равным 3+4=7.</p>

    <p>Во втором тестовом случае мы можем использовать книги 1 и 4, с общим количеством потраченного времени, равным 3+2=5.</p>

    <p>В третьем тестовом случае у нас есть только один вариант, и это чтение книги 1 за общее количество потраченного времени, равное 5.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1829/problem/C" target="_blank">Задача 1829C</a>
      <br><a href="https://codeforces.com/contest/1829" target="_blank">Codeforces Round 871 (Div. 4) 2023-05-06</a>
    </div>

    <p>Виктор может получить оба навыка только в двух случааях</p>
    <ol>
      <li>если прочитает две книги, одна из которых дает первый навык, но не дает второй, а другая дает второй навык, но не дает первый. Это книги с двоичным кодом '10' и '01'</li>
      <li>если прочитает одну книгу, которая дает и первый навык и второй навык. Это книга с кодом '11'</li>
    </ol>
    <p>Можно не рассматривать книги, чтение которых не дает никаких навыков. Это книги с двоичным кодом '00'</p>
    <p>Найдем все книги с кодами 01, 10, 11 и выберем из них те которые можно прочесть за минимальное время</p>

<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n;
    cin >> n;
    int min10 = 10000000;
    int min01 = 10000000;
    int min11 = 10000000;
    for (int i = 0; i &lt; n; i++) {
      int m;
      string s;
      cin >> m >> s;

      // решение
      if (s == "11") {
        min11 = min(min11, m);
      } else if (s == "10") {
        min10 = min(min10, m);
      } else if (s == "01") {
        min01 = min(min01, m);
      }
    }
    int result = min(min11, min10 + min01);

    // вывод результата
    if (result >= 1000000) {
      cout &lt;&lt; -1 &lt;&lt; '\n';
    } else {
      cout &lt;&lt; result &lt;&lt; '\n';
    }
  }
}
</pre>
  </details>
</article>

