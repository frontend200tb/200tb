<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p><a href="https://codeforces.com/group/w0J26SHHez/contests" target="_blank">Codeforces ЯрГУ. Студенты</a></p>
  <p><a href="https://vk.com/yaracm" target="_blank">https://vk.com/yaracm</a></p>
  <p><a href="https://vkvideo.ru/@yaracm" target="_blank">vkvideo.ru/@yaracm</a></p>
</article>


<article class="article">
  <h1>Занятие 26. Разделяй и властвуй</h1>
  <p>Конспект видео</p>
  <p><a href="https://codeforces.com/group/w0J26SHHez/contest/000000" target="_blank">Codeforces Контест 000000</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

      <a href="#p1">Разделяй и властвуй</a>
  <br><a href="#p2">Сортировка слиянием (merge sort)</a>
  <br><a href="#p3">Число инверсий в перестановке</a>
  <br><a href="#p4">Таблица инверсий</a>
  <br><a href="#p5">Задача. Поиск двух ближайших точек</a>

</article>


<!-- Разделяй и властвуй -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Разделяй и властвуй</h3>

  <p>Разделяй и властвуй это принцип, когда мы делим нашу задачу на две подзадачи, решаем каждую из них и собираем ответ.</p>
  <p>Пусть у нас есть массив, который мы хотим отсортировать в возрастающем порядке. Сначала мы делим массив на две части и хотим отдельно отсортировать каждую часть. Каждую часть мы снова делим на две части. Можно оставить части с двумя элементами и их сортировать. Но мы оставим в каждой части по одному элементу. Соберем их за линию в отсортированный массив. Сложность по времени O(NlogN), сложность по памяти O(N). Где logN это число уровней на которые нужо поделить массив. По памяти нужно дополнительно N для буферного массива.</p>
</article>


<!-- Сортировка слиянием (merge sort) -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>Сортировка слиянием (merge sort)</h3>

  <p>Научимся два отсортированных массива в один отсортированный массив. Метод двух указателей. Сначала ставим указатели на начало отсортированных массивов. Сравнимаем элементы, добавляем в ответ наименьший и двигаем указатель.</p>
  <p>Функция merge() собирает два отсортированных массива в третий отсортированный массив. Она принимает указатели на начало и конец участков двух массивов, и начало третьего массива, последним параметром может быть компаратор.</p>
  <code>merge(begin1, end1, begin2, end2, begin3[, comp])</code>
  <p>Напишем свою рекурсивную функцию сортировки слиянием, используя функцию merge. Передадим в нее массив a с элемента l включительно до элемента r не влючительно (полуинтервал). Буферный массив t объявим глобально.</p>
<pre>
void mergeSort(a, l, r, t) {
  if (r - l == 1) {
    return;
  }
  int mid = (r + l) / 2;
  mergeSort(a, l, m, t);
  mergeSort(a, m, r, t);
  merge(a.begin()+l, a.begin()+m, a.begin()+m, a.begin()+r, t.begin()+l);
  copy(t.begin()+l, t.begin()+r, a.begin()+l);
}
</pre>
  <p>Если в массиве один элемент, то он уже отсортирован и это условие выхода из рекурсии. Делим массив пополам, сортируем левую половину и сортируем правую половину. Соединим отсортированные половины.</p>
  <p>Теперь напишем свою функцию merge(), которая принимает четыре параметра </p>
<pre>
void merge(a, l, m, r, t) {
  int it1 = it2 = 0;

  while (l+it1 &lt; m && m+it2 &lt; r) {
    if (a[l+it1] &lt; a[m+it2]) {
      t[it1+it2] = a[l+it1];
      it1++;
    } else {
      t[it1+it2] = a[m+it2];
      it2++;
    }
  }

  while (l+it1 &lt; m) {
    t[it1+it2] = a[l+it1];
    it1++;
  }

  while (m+it2 &lt; r) {
    t[it1+it2] = a[m+it2];
    it2++;
  }

  for (int i = 0; i &lt; r-l; i++) {
    a[l+i] = t[i];
  }
}
</pre>
  <p>Заведем два указателя it1, который показывает на первый не добавленный элемент в первой части, it2, который паказывает на первый не добавленный элемент во второй части. Сравниваем элементы из первой части [l, m) по указателю l+it1, из второй части [m,r) по указателю m+it2 и записываем элемент в буферный массив t по указателю it1+it2. Когда закончится один из массивов, мы закинем в конец буферного массива все элементы из обоих массивов ( в одном из них уже не будет элементов). В конце копируем буферный массив в исходный массив a, который теперь отсортирован.</p>
</article>


<!-- Число инверсий в перестановке -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>Число инверсий в перестановке</h3>

  <h4>Задача</h4>
  <p>Пусть у нас есть перестановка</p>
  <code>p = [5, 8, 1, 3, 4, 7, 6, 2]</code>
  <p>надо найти количество инверсий. Инверсия это такая пара индексов</p>
  <code>(i,j), когда i &lt; j и p[i] > p[j]</code>

  <p>Для каждого элемента посчитаем число элементов справа, меньше него и сложим их.</p>
  <code>4+6+0+1+1+2+1+0 = 15</code>

  <p>Когда мы делаем сортировку по возрастанию, мы удаляем из массива все инверсии и получаем перестановку без инверсий.</p>

  <h4>Задача</h4>
  <p>Напишем алгос, который будет сортировать слиянием массив и считать количество инверсий. Сортировкой массива мы убираем все инверсии. Будем считать инверсии, которые теряются при слиянии частей массива. Когда элемент из левого указателя больше элемента из правого указателя, то элемент из правого указателя пойдет в отсортированный массив и убирается число инверсий, равное числу оставшихся элементов в левом массиве.</p>
<pre>
void mergeSort(a, l, r, t, inv) {
  if (r - l == 1) {
    return;
  }
  int mid = (r + l) / 2;
  mergeSort(a, l, m, t, inv);
  mergeSort(a, m, r, t, inv);
  merge(a.begin()+l, a.begin()+m, a.begin()+m, a.begin()+r, t.begin()+l, inv);
  copy(t.begin()+l, t.begin()+r, a.begin()+l);
}
</pre>
<pre>
void merge(a, l, m, r, t, inv) {
  int it1 = it2 = 0;

  while (l+it1 &lt; m && m+it2 &lt; r) {
    if (a[l+it1] &lt; a[m+it2]) {
      t[it1+it2] = a[l+it1];
      it1++;
    } else {
      t[it1+it2] = a[m+it2];
      it2++;
      inv += m - l - it1;
    }
  }

  while (l+it1 &lt; m) {
    t[it1+it2] = a[l+it1];
    it1++;
  }

  while (m+it2 &lt; r) {
    t[it1+it2] = a[m+it2];
    it2++;
  }

  for (int i = 0; i &lt; r-l; i++) {
    a[l+i] = t[i];
  }
}
</pre>
</article>


<!-- Таблица инверсий -->
<article class="article">
  <div class="anchor" id="p4"></div>
  <h3>Таблица инверсий</h3>

  <p>Еще для поиска количества инверсий в перестановке можно построить таблицу инверсий и потом в ней все просуммировать.</p>
  <p>T[i] это количество чисел, стоящих левее i и больших его.</p>
  <p>Возьмем перестановку</p>
  <code>p = [5, 1, 8, 7, 6, 3, 2, 4]</code>
  <p>Построим по ней таблицу инверсий</p>
  <code>T = [1, 5, 4, 4, 0, 2, 1, 0]</code>
<pre>
for (int i = 1; i &lt;= n; i++) {
  for (int j = 1; j &lt; i - 1; j++) {
    if (p[j] > p[i]) {
      T[p[i]]++;
    }
  }
}
</pre>
  <p>В чем польза таблицы инверсий? По таблице инверсий мы можем восстановить перестановку. Пусть у нас есть таблица инверсий</p>
  <code>T = [1, 5, 4, 4, 0, 2, 1, 0]</code>
  <p>Сначала заводим пустой массив, в котором будет наша перестановка</p>
  <code>p = [0, 0, 0, 0, 0, 0, 0, 0]</code>
  <p>Переберем все числа из таблицы инверсий. T[i] + 1 свободное место это позиция i. Смотрим на T[1]. Видим, что T[1] = 1, значит левее 1 должно быть одно число, которое больше него. То есть саму 1 мы кладем на второе место.</p>
  <code>p = [0, 1, 0, 0, 0, 0, 0, 0]</code>
  <p>Смотрим на T[2]. Видим, что T[2] = 5, значит левее 2 должно быть пять чисел, которые больше него. То есть саму 2 мы кладем на седьмое место.</p>
  <code>p = [0, 1, 0, 0, 0, 0, 2, 0]</code>
  <p>Далее T[3] = 4</p>
  <code>p = [0, 1, 0, 0, 0, 3, 2, 0]</code>
  <p>Далее T[4] = 4</p>
  <code>p = [0, 1, 0, 0, 0, 3, 2, 4]</code>
  <p>Далее T[5] = 0</p>
  <code>p = [5, 1, 0, 0, 0, 3, 2, 4]</code>
  <p>Далее T[6] = 2</p>
  <code>p = [5, 1, 0, 0, 6, 3, 2, 4]</code>
  <p>Далее T[7] = 1</p>
  <code>p = [5, 1, 0, 7, 6, 3, 2, 4]</code>
  <p>Далее T[8] = 0</p>
  <code>p = [5, 1, 8, 7, 6, 3, 2, 4]</code>
</article>


<!-- Задача. Поиск двух ближайших точек -->
<article class="article">
  <div class="anchor" id="p5"></div>
  <h3>Задача. Поиск двух ближайших точек</h3>

  <p>Дано множество точкек на плоскости. Найти две точки, расстояние между которыми минимально.</p>
  <p>Решение за O(n²) это цикл в цикле. Пробежались, перебрали все пары. Нашли пару с минимальным расстоянием.</p>
  <p>Применим принцип "разделяй и властвуй". Поделим множество на две части. Найдем в левой части ответ d1, в правой части ответ d2. Объединим ответы min(d1, d2) и обновим глобальный ответ, который будет не больше чем min(d1, d2).</p>
  <p>Каждая точка p(x, y) имеет две координаты. Сначала отсортируем точки по координате x.</p>
  <p>Пусть имеется 8 точек. Тогда в отсортированном массиве из 8 элементов возьем средний элемент - 4.</p>
  <p>Создадим структуру с координатами точки и ее номером в исходном массиве.</p>
<pre>
struct point {
  int x, y, id;
};
</pre>
  <p>Напишем две функции, которые сравнивают две точки по координатам x и y.</p>
<pre>
bool cmp_x(pont a, point b) {
  return a.x &lt; b.x;
}
bool cmp_y(pont a, point b) {
  return a.y &lt; b.y;
}
</pre>
  <p>Напишем алгоритм поиска, который принимает отсортированный массив точек p, две границы массива l и r в которых мы ищем две ближайшие точки и буферный массив t</p>
<pre>
void solve(p, l, r, t) {
  if (r-l &lt; 3) {
    for (int i = l; i &lt; r; i++) {
      for (int j = l + 1; r; j++) {
        update(p[i], p[j]);
      }
    }
    sort(p.begin()+l, p.end(), cmp_y);
  }
  int m = (l+r)/2;
  solve(p, l, m, t);
  solve(p, m, r, t);
  merge(p.begin()+l, p.begin()+m, p.begin()+m, p.begin()+r, t.begin(), cmp_y);
  copy(t.begin(), t.begin()+l+r, p.begin()+l);
  int sz = 0;
  for (int i = l; i &lt;= r; i++) {
    if (abs(p[i].x - m) &lt; ans) {
      for (int j = sz - 1; j > 0 && p[i].y - t[sz-1].y &lt; ans; j--) {
        update(p[i], t[j]);
      }
    }
  }
}
</pre>
  <p>После выхода из рекурсии точки будут отсортированы уже по y.</p>
</article>

