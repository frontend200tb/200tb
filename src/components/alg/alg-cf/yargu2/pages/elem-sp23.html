<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p><a href="https://codeforces.com/group/w0J26SHHez/contests" target="_blank">Codeforces ЯрГУ. Студенты</a></p>
  <p><a href="https://vk.com/yaracm" target="_blank">https://vk.com/yaracm</a></p>
  <p><a href="https://vkvideo.ru/@yaracm" target="_blank">vkvideo.ru/@yaracm</a></p>
</article>


<article class="article">
  <h1>Занятие 23. Хеш</h1>
  <p>Конспект видео</p>
  <p><a href="https://codeforces.com/group/w0J26SHHez/contest/446882" target="_blank">Codeforces Контест 446882</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p><a href="#p1">Хеш</a></p>
  <p>
        Задача A. Хеш на подотрезке
    <br>Задача B. Подстрочная сортировка
    <br>Задача C. Равенство подстрок
    <br>Задача D. Профессор А
    <br>Задача E. Petr#
    <br>Задача F. Скучные строки
    <br>Задача G. Noooooooo
    <br>Задача H. Расписание смены
    <br>Задача I. Подстроки
    <br>Задача K. Палиндромы
    <br>Задача L. Частотный анализ
  </p>
</article>


<!-- Хеш -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Хеш</h3>

  <p>Постановка задачи. Даны две строки s и t. Проверить, входит ли строка t в s как подстрока.</p>
  <p>Наивное решение за O(n*m). Нам такой алгоритм не нужен.</p>
<pre>
string s, t;
cin >> s >> t;
int n = s.size();
int m = t.size();
bool res = false;

for (int i = 0; i &lt;= n - m; i++) {
  if (s.substr(i, m) == t) {
    res = true;
  }
}

cout &lt;&lt; res;
</pre>

  <p>Если вычислить хеш строк s и t, то можно стравнивать хеш. Это хороший алгоритм за O(n).</p>
<pre>
string s, t;
cin >> s >> t;
int sh = h(s);
int th = h(t);
bool res = false;

for (int i = 0; i &lt;= n - m; i++) {
  if (h(s) == h(t)) {
    res = true;
  }
}

cout &lt;&lt; res;
</pre>
  <p>h(s) это хеш-функция от строки, которая вычислаяется один раз (за один пробег по строке), хеши подстрок вычисляются за O(1), итоговое время работы O(n + m)</p>

  <h4>Вычисление хеш-функции строки</h4>
  <p>Есть 2 основных способа вычисления значений хеш-функции:</p>
  <code>1. h(s) = s[0]*p<sup>0</sup> + s[1]*p<sup>1</sup> + ... + s[n-1]*p<sup>n-1</sup></code>
  <code>2. h(s) = s[0]*p<sup>n-1</sup> + s[1]*p<sup>n-2</sup> + ... + s[n-1]*p<sup>0</sup></code>
  <p>p - основание хеша (число, которое выбирается заранее, и заранее просчитываются все степени), s[i] - код символа (число).</p>
  <p>Когда длина строки до 100000, то даже при основании p = 2 результат хеш-функции не уместится в тип данных int и long long. Поэтому хранить хеш целиком мы не можем. Можно хранить не все значение, а остаток по какому-то модулю.</p>
  <code>1. h(s) = (s[0]*p<sup>0</sup> + ... + s[n-1]*p<sup>n-1</sup>) % mod</code>
  <code>2. h(s) = (s[0]*p<sup>n-1</sup> + ... + s[n-1]*p<sup>0</sup>) % mod</code>
  <p><strong>Коллизия</strong> это ситуация когда две строки не равны, а их хеши по модулю равны. Колизии возможны и без взятия по модулю. Если сгенерировать достаточно большое количество строк, больше чем mod, тогда по принципу Дирихле обязательно найдутся строки с одинаковыми хешами.</p>
  <p>Цель - выбрать модуль и основание таким образом, чтобы минимизировать коллизии.</p>
  <p>Операция взятия остатка от деления затратна по времени, поэтому имеет смысл использовать модуль типа int.</p>
  <p>Альтернативный подход - использование переполнения типов int и long long (что аналогично взятию остатков по модулям 2<sup>32</sup> и 2<sup>64</sup>)</p>
  <p>Минус - хеши, использующие переполнение дают коллизии на строках Туэ-Морса.</p>

  <h4>Строки Туэ-Морса</h4>
  <p>Строки, состоящие из двух символов, получаемые по правилу:</p>
  <ol>
    <li>s<sub>1</sub> = 'A'</li>
    <li>s<sub>i</sub> = s<sub>i-1</sub> + not(s<sub>i-1</sub>)</li>
  </ol>
  <p>называют строками Туэ-Морса. not(s) это строка, получаемая из исходной, заменой всех символов 'A' на символ 'B'. Первые несколько строк:</p>
<pre>
A
AB
ABBA
ABBABAAB
ABBABAABBAABABBA
</pre>
  <p>Нельзя использовать переполнение, из-за строк Туэ-Морса. Но использовать вместе и переполнение и остаток по модулю можно.</p>

  <h4>Выбор модуля</h4>
  <p>Модуль типа int это не очень хорошо. Чтобы уменьшить вероятность коллизий, будем выбирать для модуля простое число порядка 10⁹.</p>
  <p>Минус использования одного простого модуля: достаточно сгенерировать O(sqrt(n)) случайных строк (n - размер модуля), чтобы получить коллизию.</p>
  <p>Выход из ситуации - использование двух простых модулей. Возможные варианты:</p>
  <code>10⁹+7, 10⁹+9, 10⁹+33</code>
  <p>Пара модулей тоже ломается, если взломщику известно основание хеша.</p>

  <h4>Выбор основания</h4>
  <p>Размер основания должен быть больше размера алфавита. Для латинских букв нижнего и верхнего регистра размер алфавита равен 52, тогда можно выбрать размер основания 53. Размер основания нужно брать случайным образом, причем оно должно быть простым.</p>

  <h4>Выбор направления хеша</h4>
  <p>Будет реализован второй способ, так как в этом случае удобнее брать хеши посдтрок.</p>
  <p>Заведем массив h, определяемый следующим образов:</p>
  <code>h[i] = s[0]*p<sup>i-1</sup> + ... + s[i-1]</code>
<pre>
h[0] = 0
h[1] = s[0]
h[2] = s[0]*p + s[1]
h[3] = s[0]*p² + s[1] + s[2]
</pre>
  <code>h[i] = p*h[i-1] + s[i-1]</code>
<pre>
h[0] = 0
h[1] = s[0]
h[2] = s[0]*p + s[1] = h[0]*p + s[1]
h[3] = s[0]*p² + s[1]*p + s[2] = p*(s[0]*p + s[1]) + s2
</pre>

  <h4>Реализация</h4>
<pre>
#include &lt;bits/stdc++.h&gt;

using namespace std;

vector &lt;pair&lt;int, int&gt; &gt; h, p_pow;
const int mod1 = 1e9 + 7;
const int mod2 = 1e9 + 9;

int main() {
  string s, t;
  cin >> s;
  int h = s.size();
  int x = rand();
  int p = max(257, x + (x % 2 == 0));
  h.resize(n+1);
  p_pow.resize(n+1);
  p_pow[0] = (1, 1);
  h[0] = (0, 0);

  for (int i = 0; i &lt; n; i++) {
    h[i+1].first = (h[i].first * 1ll * p + s[i]) % mod1;
    h[i+1].second = (h[i].second * 1ll * p + s[i]) % mod2;
    p_pow[i+1].first = (p_pow[i].first * 1ll * p) % mod1;
    p_pow[i+1].second = (p_pow[i].second * 1ll * p) % mod2;
  }
}
</pre>

  <h4>Хеш подстроки</h4>
  <p>Научимся искать хеш подстроки h[l, r]. Хеш подстроки считется так же как и хеш строки. Число символов подстроки равно r - l + 1.</p>
  <code>h(s[l, r]) = s[l]*p<sup>r-l</sup> + s[l+1]*p<sup>r-l-1</sup> + ... + s[r]</code>
  <code>h(s[0, r]) = h[r+1]</code>
  <code>h[r+1] = s[0]*p<sup>r</sup> + s[1]*p<sup>r-1</sup> + ... + s[l-1]*p<sup>r-l+1</sup> + ... + s[r]</code>
  <code>s[l, r] = s[0, r] - s[0, l-1]</code>
  <code>h[l] = s[0]*p<sup>l-1</sup> + s[1]*p<sup>l-2</sup> + ... + s[l-1]</code>
  <code>h(s[l,r]) = h[r+1] - h[l]*p<sup>r-l+1</sup></code>

  <h4>Алгоритм Рабина-Карпа</h4>
  <p>Даны две строки s и t. Проверить, входит ли строка t в s как подстрока.</p>
  <ol>
    <li>Найдем хеш строки t. Сложность O(m)</li>
    <li>Найдем хеш строки s. Сложность O(n)</li>
    <li>Пробежимся с окном длины m по строке s. Если хеш одной из подстрок совпал с хешем строки t, то ответ - да, если не нашлось ни одной такой подстроки, ответ - нет. Сложность O(n).</li>
  </ol>
  <p>Итоговое время работы O(n+m).</p>
<pre>
m = t.size();
n = s.size();
ht = ht[m];

for (int i = 0; i &lt; n - m; i++) {
  if (get_hash(i, i+m-1) == ht) {
    // нашлась подстрока
  }
}
</pre>
  <p>Так же можно проверить сколько раз одна строка входит в другую.</p>
  <p>Не нужно считать массив хешей строки t. Потому что не нужно потом искать подстроки в строке t. Поэтому считаем только один хеш для строки t длины m.</p>

  <h4>Применения хешей</h4>
  <ol>
    <li>Лексикографическое сравнение строк</li>
    <li>Нахождение количества различных подстрок</li>
    <li>Проверка строки на палиндромность</li>
    <li>Нахождение минимального циклического сдвига строки</li>
    <li>Поиск наидлиннейшей общей подстроки</li>
  </ol>

  <h4>Сравнение строк</h4>
  <p>Даны две строки, определить какая из них больше.</p>
  <ol>
    <li>Если строки совпадают в первых i символах, то они совпадают и на меньшем префиксе.</li>
    <li>Если строки не совпадают в первых i символах, то они не совпадают и на большем префиксе.</li>
  </ol>
  <p>Решение: бинарным поиском ищем самый первый символ, в котором строки не совпадают, и сравниваем их (следует учесть, что длины сток могут не совпадать). Время работы O(logN), N = min(s.size(), t.size())</p>
</article>