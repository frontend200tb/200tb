<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p><a href="https://codeforces.com/group/w0J26SHHez/contests" target="_blank">Codeforces ЯрГУ. Студенты</a></p>
  <p><a href="https://vk.com/yaracm" target="_blank">https://vk.com/yaracm</a></p>
  <p><a href="https://vkvideo.ru/@yaracm" target="_blank">vkvideo.ru/@yaracm</a></p>
</article>


<article class="article">
  <h1>Занятие 22. Z функция. КМП</h1>
  <p>Конспект видео</p>
  <p><a href="https://codeforces.com/group/w0J26SHHez/contest/378491" target="_blank">Codeforces Контест 378491</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
        <a href="#p1">Z функция</a>
    <br><a href="#p2">Алгоритм КМП</a>
  </p>
  <p>
        <a href="#task1">Задача A. Ненокку (простая)</a>
    <br><a href="#task2">Задача B. Дана строка</a>
    <br><a href="#task3">Задача C. Различные подстроки</a>
    <br><a href="#task4">Задача D. Палиндромы</a>
    <br><a href="#task5">Задача E. Много одинаковых подстрок</a>
    <br><a href="#task6">Задача F. Запросы на строке</a>
    <br><a href="#task7">Задача G. Разбиение текста</a>
    <br><a href="#task8">Задача H. Про суффиксные структуры</a>
    <br><a href="#task9">Задача I. Не просто красивые строки</a>
    <br><a href="#task10">Задача J. Пунктуация</a>
    <br><a href="#task11">Задача K. Backspace</a>
    <br><a href="#task12">Задача L. Префиксы и суффиксы</a>
    <br><a href="#task13">Задача M. Вхождения в отрезках</a>
    <br><a href="#task14">Задача N. Циклические сдвиги</a>
    <br><a href="#task15">Задача O. Префиксы-палиндромы</a>
    <br><a href="#task16">Задача P. Префикс функции строки Грея</a>
    <br><a href="#task17">Задача Q. Валерьянка, чтоб была</a>
    <br><a href="#task18">Задача R. Ретрострока</a>
    <br><a href="#task19">Задача S. Пароль</a>
    <br><a href="#task20">Задача T. Первые слова</a>
  </p>
</article>


<!-- Z функция -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Z функция</h3>

  <p>Постановка задачи. Даны две строки s1 и s2. Нужно ответить содержится ли строчка s1 в строке s2.</p>
  <p>Для решения методом Z функции нужно создать вспомогательный вектор Z. Z[i] хранит максимальную длину подстроки, которая начинается в позиции i и совпадает с префиксом.</p>
  <p>Со строкой связаны 3 понятия:</p>
  <ol>
    <li><strong>Подстрока</strong> это подряд идущие символы строки начиная с позиции l до позиции r.</li>
    <li><strong>Префикс</strong> это подстрока, которая начинается с начала строки.</li>
    <li><strong>Суфикс</strong> это подстрока, которая заканчивается в конце строки.</li>
  </ol>

  <p>Пример 1. Дана строка s = "aaaaa" из 5 символов. Построим Z функцию.</p>
<pre>
  0 1 2 3 4
s a a a a a
z 0 4 3 2 1
</pre>
  <p>Записываем z[0] = 0, чтобы построить Z функцию. z[1] = 4 это число символов, начиная с 1-го и до конца строки, которые совпадают с префиксом.</p>

  <p>Пример 2. Дана строка s = "abacaba" из 7 символов. Построим Z функцию.</p>
<pre>
  0 1 2 3 4 5 6
s a b a c a b a
z 0 0 1 0 3 0 1
</pre>

  <p>Пример 3. Дана строка s = "aabaacaabc" из 10 символов. Построим Z функцию.</p>
<pre>
  0 1 2 3 4 5 6 7 8 9
s a a b a a c a a b c
z 0 1 0 2 1 0 3 1 0 0
</pre>

  <p>Наивный алгоритм построения Z функции строки длины n это цикл в цикле. Сложность O(n²). Проходим по строке и для каждой позиции стараемся построить префикс максимальной длины.</p>
<pre>
for (int i = 1; i &lt; s.size(); i++) {
  int cnt = 0;
  for (int j = 0; j &lt; s.size(); j++) {
    if (s[i+j] == s[j]) {
      cnt++;
    } else {
      break;
    }
  }
  z[i] = cnt;
}
</pre>

  <p>Построим Z функцию линейным решением. Сложность O(n). Проходим по строке и запоминаем левую и правую границу кусочков, которые совпадают с префиксом. От позиции l до позиции r находится подстрока, которая совпадает с префиксом от позиции 0 до позиции r-l. В моменте реализации мы находимся в позиции i, между l и r, поэтому s[i] = s[i-l]. Мы строим Z функцию пошагово, поэтому от позиции 0 до позиции i-1 она уже построена. Значит и ячейка z[i-l] уже построена.</p>
  <p>Дальше возможны два варианта. Вариант первый z[i] = z[i-l]. Второй вариант z[i] > z[i-l] потому что за позицией r стоит символ, который позволяет продолжить подстроку, совпадающую с префиксом.</p>
<pre>
int l = 0;
int r = 0;
for (int i = 1; i &lt; s.size(); i++) {
  if (i &lt;= r) {
    if (z[i-l] &lt; r-l+1) {
      z[i] = z[i-l];
    } else {
      z[i] = r-i+1;
      while (z[i]+1 &lt; s.size() && s[z[i]] == s[z[i] + i]) {
        z[i]++;
      }
    }

  } else {
    while (z[i] + i &lt; s.size() && s[z[i]] == s[z[i] + i]) {
      z[i]++;
    }
  }

  if (r &lt; i + z[i]-1) {
    l = i;
    r = i + z[i]-1;
  }
}
</pre>

  <p>Для поиска подстроки s1 в строке s2, создадим строку s3 = s1 + '#' + s2, где # это символ разделитель двух строк, который не встречается ни в строке s1 ни в строке s2. Посчитаем Z функцию строки s3. В позиции где стоит # , Z функция равна 0, потому что решетка точно не встречается в начале строки.</p>
  <p>Пример 1. Дана строка s = "abababcaba". Построим Z функцию, отслеживая левую и правую границу.</p>
  <p>В нулевой позиции z[0] = 0, l = 0, r = 0. В первой позиции символ 'b' не совпадает с началом строки, поэтому z[1] = 0, l = 0, r = 0.</p>
<pre>
   0 1 2 3 4 5 6 7 8 9
s  a b a b a b c a b a
z  0 0 4 0
l  0 0 2 2
r  0 0 5 5
</pre>
  <p> Во второй позиции символ 'a' совпадает с началом строки, поэтому просматриваем следующие символы и находим, что со второй по пятую позицию четыре символа совпадают с началом строки, поэтому z[2] = 4, l = 2, r = 5. В третьей позиции символ 'b' лежит внутри диапазона от l до r, значит он соответствует символу 'b' в первой позиции. Поскольку не выходит за границы поэтому z[3] = z[1] = 0.</p>
  <p>В четвертой позиции символ 'a' лежит внутри диапазона от l до r, значит он соответствует символу 'a' во второй позиции. Поскольку выходит за границы, то пересчитываем z[4] = 2, l = 4, r = 5.</p>

  <h4>Периодическая строка</h4>
  <p><strong>Периодическая строка</strong> состоит из равных кусочков.</p>
  <p><strong>Период</strong> это число повторяющихся подстрок, совпадающих с префиксом, суффиксом и непрерывно повторяющимися в строке.</p>
  <p>Например, строка s = "ababab" имеет период 2.</p>
  <p>Например, строка s = "aaaaaa" имеет несколько периодов 1, 2, 3.</p>
  <p>Часто в задачах надо найти максимальный период строки.</p>
  <p><strong>Почти периодическая строка</strong> состоит из равных кусочков, но последний кусочек является неполным.</p>
  <p>Например, строка s = "abcabca", с повторяющейся подстрокой "abc".</p>
</article>


<!-- Алгоритм КМП -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>Алгоритм Кнута-Мориса-Прата</h3>

  <p>Алгоритм Кнута-Мориса-Прата решает задачу нахождения подстроки в строке. Его сложность O(n).</p>
  <p>Постановка задачи. Дана строка s1 и s2. Определить содержится ли строка s2 в строке s1.</p>
  <p>Создадим вспомогательный вектор Pref размером равным размеру строки s1. В Pref[i] храним максимальную длину подстроки, совпадающую с префиксом который оканчивается в позиции i.</p>
  <p>Пример 1. s1 = "aaaaa"</p>
<pre>
     0 1 2 3 4
   s a a a a a
Pref 0 1 2 3 4
</pre>
  <p>Пример 2. s1 = "abacaba"</p>
<pre>
     0 1 2 3 4 5 6
   s a b a c a b a
Pref 0 0 1 0 1 2 3
</pre>
  <p>Пример 3. s1 = "ababaabc"</p>
<pre>
     0 1 2 3 4 5 6 7
   s a b a b a a b c
Pref 0 0 1 2 3 1 2 0
</pre>
  <p>Алгоритм выполняется пошагово, заполняя вектор Pref от Pref[0]. Когда мы доходим до вычисления Pref[i], все предыдущие значения уже посчитаны. Возможны два варианта.</p>
  <p>Вариант 1. Подстрока длины k, которая начинается в позиции i-k и заканчивается в позиции i-1 совпадает с префиксом длины k, который начинается в позиции 0 и заканчивается в позиции k-1. Следующий символ в позиции i  совпадает со следующим символом префикса в позиции k, то есть s[i] = s[k], тогда</p>
  <code>Pref[i] = Pref[i-1] + 1</code>
  <p>Вариант 2. Символ в позиции i не совпадает с символом в позиции k. Тогда нужно искать совпадение символа s[i] в префиксе от 0 до k-1.</p>
<pre>
int n = s.size();
vector&lt;Pref&gt; Pref(n);

for (int i = 1; i &lt; n; i++) {
  int j = Pref[i-1]; // создаем счетчик

  while (j > 0 && s[i] != s[j]) {
    // если символ не совпал, то смотрим
    // на предыдущий символ
    j = Pref[j-1];
  }

  if (s[i] == s[j]) {
    // если символ совпал, то увеличиваем счетчик
    j++;
  }
  Pref[i] = j;
}
</pre>
  <p>Переменная j выполняет две задачи. Во-первых, она хранит длину совпадающей с префиксом подстроки. Во-вторых, она используется как счетчик, который пробегает по префиксу.</p>
</article>


<!-- Задача A. Ненокку (простая) -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Ненокку (простая)</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Очень известный автор не менее известной книги решил написать продолжение своего произведения. Он писал все свои книги на компьютере, подключенном к интернету. Из-за такой неосторожности мальчику Ненокку удалось получить доступ к еще ненаписанной книге. Каждый вечер мальчик залазил на компьютер писателя и записывал на свой компьютер новые записи. Ненокку, записав на свой компьютер очередную главу, заинтересовался, а использовал ли хоть раз писатель слово "книга". Но он не любит читать книги (он лучше полазает в интернете), и поэтому он просит вас узнать есть ли то или иное слово в тексте произведения. Но естественно его интересует не только одно слово, а достаточно много.</p>

  <h4>Входные данные</h4>
  <p>В каждой строчке входного файла записано одна из двух записей</p>
  <ol>
    <li>? слово (набор не более 50 латинских сиволов)</li>
    <li>A текст (набор не более 1024 латинских символов)</li>
  </ol>
  <p>1 означает просьбу проверить существование подстроки "слово" в произведении.</p>
  <p>2 означает добавление в произведение "текст".</p>
  <p>Число запросов не более 30. Вхдной файл содержит не более 1 килобайта.</p>

  <h4>Выходные данные</h4>
  <p>Выведите на каждую строчку типа 1 "YES", если существоет подстрока "слово", и "NO" в противном случае. Не следует различать регистр букв.</p>

  <details>
    <summary>Пример</summary>
<pre>
? love
? is
A Loveis
? love
? WHO
A Whoareyou
? is
</pre>
<pre>
NO
NO
YES
NO
YES
</pre>
  </details>
</article>


<!-- Задача B. Дана строка -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Дана строка</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Даже больше - дано две строки a и b. Вам требется узнать, где в строке a можно найти строку b как подстроку и выписать все такие позиции.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входного файла содержится строка a, во второй - строка b. Строки состоят только из строчных латинских букв (a-z), их длины не превосходят 100000.</p>

  <h4>Выходные данные</h4>
  <p>В первой строке выходного файла выведите одно число - количество вхождений строки b в строку a. Во второй строке для каждого вхождения выведите номер символа в строке a, где начинается очередная строка b, Вхождения нужно выводить в возрастающем порядке.</p>

  <details>
    <summary>Пример</summary>
<pre>
abacaba
aba
</pre>
<pre>
2
1 5
</pre>
  </details>
</article>


<!-- Задача C. Различные подстроки -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Различные подстроки</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Подстрокой строки s = s<sub>1</sub>s<sub>2</sub>...s<sub>n</sub> называется непрерывная подпоследовательность символов этой строки s<sub>i</sub>s<sub>i+1</sub>...s<sub>j-1</sub>s<sub>j</sub>.</p>
  <p>Дана строка. Сколько различных подстрок, не считая пустой, она содержит?</p>

  <h4>Входные данные</h4>
  <p>В первой строке входного файла задана строка длины от 1 до 100 символов, включительно. Строка состоит из строчных букв латинского алфавита.</p>

  <h4>Выходные данные</h4>
  <p>В первой строке выходного файла выведите одно число - количество различных подстрок данной строки, не считая пустой.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>aab</code>
    <code>5</code>

    <h4>Пример 2</h4>
    <code>dabyx</code>
    <code>15</code>
  </details>
</article>


<!-- Задача D. Палиндромы -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Палиндромы</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Строка называется палиндромом, если она одинаково читается как слева направо, так и справа налево. Например, abba - палиндром, а omax - нет. Для строки a будем обозначать a[i..j] ее подстроку длины j-i+1 с i-й по j-ю позицию включительно (позиции нумеруются с единицы). Для заданной строки a длины N (1 ≤ N ≤ 100000) требуется подсчитать число q пар (i, j), 1 ≤ i ≤ j ≤ n, таких что a[i..j] является палиндромом.</p>

  <h4>Входные данные</h4>
  <p>Входной файл содержит одну строку a длины N, состоящую из маленьких латинских букв.</p>

  <h4>Выходные данные</h4>
  <p>В выходной файл выведите искомое число q.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>aaa</code>
    <code>3</code>

    <h4>Пример 2</h4>
    <code>abba</code>
    <code>2</code>

    <h4>Пример 3</h4>
    <code>omax</code>
    <code>0</code>
  </details>
</article>


<!-- Задача E. Много одинаковых подстрок -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Много одинаковых подстрок</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Задана строка t длины n, состоящая из строчных букв латинского алфавита, и целое число k.</p>

  <p>Определим подстроку какой-либо строки s с индексами от l до r как s[l…r].</p>

  <p>Ваша задача — составить такую строку s минимальной возможной длины, что в ней существует ровно k позиций i таких, что s[i…i+n-1]=t. Другими словами, ваша задача — составить такую строку s минимальной возможной длины, что ровно k подстрок строки s равны t.</p>

  <p>Гарантируется, что существует один возможный ответ.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит два целых числа n и k (1 ≤ n, k ≤ 50) — длину строки t и количество подстрок.</p>

  <p>Вторая строка входных данных содержит строку t, состоящую ровно из n строчных букв латинского алфавита.</p>

  <h4>Выходные данные</h4>
  <p>Выведите такую строку s минимально возможной длины, что ровно k подстрок строки s равны t.</p>

  <p>Гарантируется, что существует один возможный ответ.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
3 4
aba
</pre>
    <code>ababababa</code>

    <h4>Пример 2</h4>
<pre>
3 2
cat
</pre>
    <code>catcat</code>
  </details>
</article>


<!-- Задача F. Запросы на строке -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача F. Запросы на строке</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам даны строка s и m запросов. Каждый запрос задаётся парой индексов li, ri и целым числом ki, и означает, что подстроку s[li... ri] нужно ki раз циклически сдвинуть вправо. Запросы нужно обрабатывать последовательно, друг за другом.</p>

  <p>Циклический сдвиг вправо обозначает перемещение последнего символа на место первого и сдвиг всех остальных символов направо на одну позицию.</p>

  <p>Например, если исходная строка s равна abacaba, то в случае запроса l1 = 3, r1 = 6, k1 = 1 получится строка abbacaa, если же после этого обработать запрос l2 = 1, r2 = 4, k2 = 2, то в результате получится строка baabcaa.</p>

  <h4>Входные данные</h4>
  <p>В первой строке находится строка s (1 ≤ |s| ≤ 10 000) — исходная строка, состоящая из строчных букв английского алфавита. Запись |s| обозначает длину строки s.</p>

  <p>Во второй строке находится число m (1 ≤ m ≤ 300) — количество запросов циклического сдвига.</p>

  <p>В i-й из следующих m строк находится тройка чисел li, ri и ki (1 ≤ li ≤ ri ≤ |s|, 1 ≤ ki ≤ 1 000 000) — параметры i-го запроса.</p>

  <h4>Выходные данные</h4>
  <p>Выведите строку, которая получится после обработки всех m запросов.</p>

  <details>
    <summary>Пример 1</summary>
<pre>
abacaba
2
3 6 1
1 4 2
</pre>
    <code>baabcaa</code>
    <p>Пример разобран в условии задачи.</p>
  </details>
</article>


<!-- Задача G. Разбиение текста -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача G. Разбиение текста</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам задана строка s длины n и пара чисел p, q. Вам требуется разбить строку s на строки длины p и q. Например, строку "Hello" при p = 2, q = 3 можно разбить на две строки "Hel" и "lo" или на две строки "He" и "llo".</p>

  <p>Заметим, что допускается разбиение строки только на строки длины p или только на строки длины q (смотрите второй тестовый пример).</p>

  <h4>Входные данные</h4>
  <p>В первой строке находятся три целых положительных числа n, p, q (1 ≤ p, q ≤ n ≤ 100).</p>

  <p>Во второй строке находится строка s, состоящая из строчных и прописных букв латинского алфавита, и цифр.</p>

  <h4>Выходные данные</h4>
  <p>Если разбить строку s на строки длины p и q невозможно выведите число "-1".</p>

  <p>В противном случае в первой строке выведите целое число k — количество строк в разбиении s.</p>

  <p>В следующих k строках выведите строки в разбиении. Каждая строка должна быть длины p или q. Строки нужно вывести в порядке появления в исходной строке s — слева направо.</p>

  <p>Если существует несколько решений, разрешается вывести любое из них.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
5 2 3
Hello
</pre>
<pre>
2
He
llo
</pre>

    <h4>Пример 2</h4>
<pre>
10 9 5
Codeforces
</pre>
<pre>
2
Codef
orces
</pre>

    <h4>Пример 3</h4>
<pre>
6 4 5
Privet
</pre>
<pre>
-1
</pre>

    <h4>Пример 4</h4>
<pre>
8 1 1
abacabac
</pre>
<pre>
8
a
b
a
c
a
b
a
c
</pre>
  </details>
</article>


<!-- Задача H. Про суффиксные структуры -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача H. Про суффиксные структуры</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>
</article>


<!-- Задача I. Не просто красивые строки -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача I. Не просто красивые строки</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>
</article>


<!-- Задача J. Пунктуация -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача J. Пунктуация</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>
</article>


<!-- Задача K. Backspace -->
<article class="article">
  <div class="anchor" id="task10"></div>
  <h3>Задача K. Backspace</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>
</article>


<!-- Задача L. Префиксы и суффиксы -->
<article class="article">
  <div class="anchor" id="task11"></div>
  <h3>Задача L. Префиксы и суффиксы</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>
</article>


<!-- Задача M. Вхождения в отрезках -->
<article class="article">
  <div class="anchor" id="task12"></div>
  <h3>Задача M. Вхождения в отрезках</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>
</article>


<!-- Задача N. Циклические сдвиги -->
<article class="article">
  <div class="anchor" id="task13"></div>
  <h3>Задача N. Циклические сдвиги</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>
</article>


<!-- Задача O. Префиксы-палиндромы -->
<article class="article">
  <div class="anchor" id="task14"></div>
  <h3>Задача O. Префиксы-палиндромы</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>
</article>


<!-- Задача P. Префикс функции строки Грея -->
<article class="article">
  <div class="anchor" id="task15"></div>
  <h3>Задача P. Префикс функции строки Грея</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>
</article>


<!-- Задача Q. Валерьянка, чтоб была -->
<article class="article">
  <div class="anchor" id="task16"></div>
  <h3>Задача Q. Валерьянка, чтоб была</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>
</article>


<!-- Задача Q. Валерьянка, чтоб была -->
<article class="article">
  <div class="anchor" id="task16"></div>
  <h3>Задача Q. Валерьянка, чтоб была</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>
</article>


<!-- Задача R. Ретрострока -->
<article class="article">
  <div class="anchor" id="task17"></div>
  <h3>Задача R. Ретрострока</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>
</article>


<!-- Задача S. Пароль -->
<article class="article">
  <div class="anchor" id="task18"></div>
  <h3>Задача S. Пароль</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>
</article>


<!-- Задача T. Первые слова -->
<article class="article">
  <div class="anchor" id="task18"></div>
  <h3>Задача T. Первые слова</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>
</article>

