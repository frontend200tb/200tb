<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p><a href="https://codeforces.com/group/w0J26SHHez/contests" target="_blank">Codeforces ЯрГУ. Студенты</a></p>
  <p><a href="https://vk.com/yaracm" target="_blank">https://vk.com/yaracm</a></p>
  <p><a href="https://vkvideo.ru/@yaracm" target="_blank">vkvideo.ru/@yaracm</a></p>
</article>


<article class="article">
  <h1>Занятие 24. Геометрия 1</h1>
  <p>Конспект видео</p>
  <p><a href="https://codeforces.com/group/w0J26SHHez/contest/427143" target="_blank">Codeforces Контест 427143</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p><a href="#p1">Геометрия 1</a></p>
  <p>
        Задача A. Следование направлениям
    <br>Задача B. Постройте прямоугольник
    <br>Задача C. Сложный путь
    <br>Задача D. Ноутбук и проектор
    <br>Задача E. Аллея
    <br>Задача F. Штукатурка
    <br>Задача G. Плохой сосед
    <br>Задача H. Параллелепипед
    <br>Задача I. Вася и кукурузное поле
    <br>Задача J. Вася и треугольник
    <br>Задача K. Шестиугольник Геральда
    <br>Задача L. Созвездие
    <br>Задача M. Два квадрата
    <br>Задача N. Белый лист
  </p>
</article>


<!-- Геометрия 1 -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Геометрия 1</h3>

  <p>В России геометрические задачи решают одним из трех вариантов: питерским, московским, всем остальным сообществом. В питерском варианте прорешивают математическую задачу и выводят результирующую функцию. В московском варианте перебирают все возможные формулы и рано или поздно попадают в ответ. В варианте всем остальным сообществом, выкидывают задачу с геометрией из контеста и решают контест без нее.</p>
  <p>На практике, геометрические задачи в контесте не очень сложные. Там не требуются серьезные знания по математике, знание сложных теорем. Чаще всего это школьная геометрия.</p>
  <p>Первая специфика геометрических задач это вывод результата. Результат всегда вещественный, при его выводе требуется определенная точность, например, не менее 4 знаков после запятой. Это означает что наш ответ не должен отличаться от ответа членов жюри больше чем на 10<sup>-4</sup></p>
  <code>|otv1 - otv2| ≤ 10<sup>-4</sup></code>
  <p>Каждая операция с вещественными числами приводит к округлению результата и потери точности. Поэтому если требуется вывести 4 знака после запятой, то можно вывести 8 знаков.</p>
  <p>Вторая проблема это вывод вещественных чисел в C++. Для этого в C++ подключаем библиотеку <strong>iomanip</strong></p>
  <code>#include &lt;iomanip&gt;</code>
  <code>cout &lt;&lt; fixed &lt;&lt; setprecision(8) &lt;&lt; a;</code>
  <p>Для вывода вещественного числа в языке C исползуем функцию printf</p>
  <code>printf("%.8lf, a);</code>
  <p>Вторая специфика заключается в операциях с числами типа double. Если есть возможность оставаться в целых числах int или long long, то оставайтесь в целых числах.</p>
  <p>От перемены мест вещественных слагаемых сумма будет разная. Любая переменная типа double хранит 16 знаков. При записи вещественного числа, сумма цифр до запятой и после запятой должно равняться 16 знакам. Как только в сумме чисел добавляется новый знак слева, то сразу теряется один знак справа, так чтобы в числе оставалось 16 знаков.</p>
  <p>Для решение геометрической задачи, чтобы не хранить координаты в отдельных переменных x и y, создадим структуру</p>
<pre>
// точка
struct point {
  double x, y;
};
point A;
A.x = 4;
A.y = 3;
</pre>
  <p>При создании структуры, если не создать конструктор и деструктор, то они создаются автоматически и присутствуют в коде.</p>
  <p>Создадим геометрическую фигуру вектор (направленный отрезок с координатой начала и координатой конца).</p>
  <p>Для векторов есть операция сложения, когда складываются координаты начала вектора и координаты конца вектора.</p>
  <code>c = a + b</code>
  <code>c.x = a.x + b.x;</code>
  <code>c.y = a.y + b.y;</code>
  <p>Для структуры вектор , будем использовать структуру точки, поскольку и вектор и точка имеют координаты. Это нехрошо с точки зрения ООП, но нормально с точки зрения спортивного программирования. Напишем оператор для перегрузки операции сложения двух векторов.</p>
<pre>
struct point {
  double x, y;

  point operator+ (point B) {
    point res;
    res.x = x + B.x;
    res.y = y + B.y;
    return res;
  }
};
point A, B;
A.x = 3;
A.y = 4;
B.x = 4;
B.y = -1;
point C = A + B; // C.x = 7; C.y = 3
</pre>

  <p>Для векторов есть операция вычитания, когда вычитаются координаты начала вектора и координаты конца вектора.</p>
  <p>Напишем оператор для перегрузки операции вычитания двух векторов.</p>
<pre>
struct point {
  double x, y;

  point operator+ (point B) {
    point res;
    res.x = x + B.x;
    res.y = y + B.y;
    return res;
  }

  point operator- (point B) {
    point res;
    res.x = x - B.x;
    res.y = y - B.y;
    return res;
  }
};
point A, B;
A.x = 3;
A.y = 4;
B.x = 4;
B.y = -1;
point C = A - B; // C.x = -1; C.y = 5
</pre>

  <p>Для векторов есть операция умножения на число (масштабирование), когда умножаются координаты начала вектора и координаты конца вектора на множитель. Если множитель больше 1 то это увеличение вектора, если меньше 1 и больше 0 то это уменьшение вектора.</p>
struct point {
  double x, y;

  point operator+ (point B) {
    point res;
    res.x = x + B.x;
    res.y = y + B.y;
    return res;
  }

  point operator- (point B) {
    point res;
    res.x = x - B.x;
    res.y = y - B.y;
    return res;
  }

  point operator* (double k) {
    point res;
    res.x = x * k;
    res.y = y * k;
    return res;
  }
};
point A, B;
A.x = 3;
A.y = 4;
B.x = 4;
B.y = -1;
point C = A - B; // C.x = -1; C.y = 5
</pre>

  <p>Функция поиска квадрата длины вектора</p>
<pre>
// квадрат длины вектора
double dist2(point A) {
  return A.x * A.x + A.y * A.y;
}
</pre>
  <p>Для вектора не будем определять операцию деления вектора на число. Всесто того чтобы поделить вектор на число k, мы будет умножать вектор на число 1/k.</p>

  <h4>Пример задачи</h4>
  <p>Есть несколько маленьких треугольников, нужно ответить можно ли из них собрать один большой треугольник. То есть большой треугольник состоит из маленьких треугольников.</p>
  <p>Решается эта задача полным перебором. Нужно все маленькие треугольники расставить так чтобы их смежные стороны были равны, а сумма углов маленьких треугольников, примыкающих к стороне большого треугольника равна 180 градусов.</p>
  <p>При этом при сравнении сторон не нужно брать корень от квадрата стороны, поскольку взятие корня это медленная операция. Достаточно сравнивать квадраты сторон.</p>

  <h4>Пример задачи</h4>
  <p>Дан вектор AB. Как найти его середину C?</p>
  <p>Мы определили операторы и можем ими воспользоваться</p>
  <code>C = (A + B) * 0.5;</code>

  <h4>Скалярное произведение</h4>
  <p>Скалярное произведение это проекция одного вектора на другой. В математике его вычисляют как произведение модулей на косинус угла между ними.</p>
  <code>(a, b) = |a| * |b| * cos(t)</code>
  <p>Угол можно выразить через арккосинус, но это не очень удобно и приводит к потере точности.</p>
  <p>В спортивном программировании его вычисляют как сумму попарных произведений координат.</p>
  <code>(a, b) = a.x * b.x + a.y * b.y</code>
  <p>Для вычисления скалярного произведения пишут функцию <strong>dot</strong>. Причина такого названия это использование в литературе символа точка</p>
  <code>a ∙ b</code>

  <h4>Векторное произведение</h4>
  <p>В математике векторное произведение вычисляют как произведение модулей на синус угла между ними.</p>
  <code>[a, b] = |a| * |b| * sin(t)</code>
  <p>Здесь t это угол поворота вектора a к вектору b по часовой стрелке. Если угол t больше 180 градусов, то векторное произведение получается отрицательным.</p>
  <p>Угол можно выразить через арксинус, но это не очень удобно и приводит к потере точности.</p>
  <p>В спортивном программировании его вычисляют как</p>
  <code>[a, b] = a.x * b.y - a.y * b.x</code>
  <p>Для вычисления скалярного произведения пишут функцию <strong>cross</strong>. Причина такого названия это использование в литературе символа крестик</p>
  <code>a x b</code></p>


</article>

