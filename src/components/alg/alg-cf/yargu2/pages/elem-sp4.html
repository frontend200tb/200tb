<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p><a href="https://codeforces.com/group/w0J26SHHez/contests" target="_blank">Codeforces ЯрГУ. Студенты</a></p>
  <p><a href="https://vk.com/yaracm" target="_blank">https://vk.com/yaracm</a></p>
  <p><a href="https://vkvideo.ru/@yaracm" target="_blank">vkvideo.ru/@yaracm</a></p>
</article>


<article class="article">
  <h1>Занятие 4. Основы C++ 4. Функции</h1>
  <p>Конспект видео</p>
  <p><a href="https://codeforces.com/group/w0J26SHHez/contest/400029" target="_blank">Codeforces Контест 400029</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>Основы C++ 4. Функции</p>
  <p>
        Задача A. НОД
    <br>Задача B. Без массивов
    <br>Задача C. Длинное выражение
    <br>Задача D. Факториал (очень простой)
    <br>Задача E. Разрезание на квадраты
    <br>Задача F. Сортировка Таноса
    <br>Задача G. Медиана
    <br>Задача H. Эпическая игра
    <br>Задача I. Вор и спички
    <br>Задача J. Amr и музыка
    <br>Задача K. Грибоводство
    <br>Задача L. z-сортировка
    <br>Задача M. Сортировка сдвигами
    <br>Задача N. Фотограф
    <br>Задача O. Бомбы
    <br>Задача P. Пары чисел
    <br>Задача Q. Плотный массив
    <br>Задача R. Не соседняя матрица
    <br><a href="#task19">Задача S. Сортировка кубов</a>
    <br>Задача T. Mex подмножеств
    <br>Задача U. Золотая лихорадка
  </p>
</article>


<!-- Задача S. Сортировка кубов -->
<article class="article">
  <div class="anchor" id="task19"></div>
  <h3>Задача S. Сортировка кубов</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Уитли решил попробовать себя в создании тестовых камер. Он создал отличную камеру, но в ней не хватало лишь одной детали — кубов.</p>
  <p>В камеру необходимо было доставить n кубов. i-й куб имеет объем aᵢ.</p>
  <p>Уитли необходимо расставить кубы так, чтобы они были отсортированы в порядке неубывания объема. Строго говоря, для каждого i>1 должно выполняться условие aᵢ₋₁ ≤ aᵢ.</p>
  <p>Для этого Уитли может менять местами две соседние кубы, то есть для любого i>1 можно поменять местами кубы на позициях i-1
   и i.</p>
  <p>Проблема в том, что Уитли нетерпелив. Если ему придется сделать больше, чем n⋅(n-1)/2 - 1 операций обмена, он не захочет делать столь нудную работу.</p>
  <p>Уитли надо узнать: можно ли расставить кубы в порядке неубывания обьема, соблюдая все условия?</p>

  <h4>Входные данные</h4>
  <p>Каждый тест содержит несколько наборов входных данных.</p>
  <p>В первой строке находится одно целое положительное число t (1 ≤ t ≤ 1000) — количество наборов входных данных. Описание наборов входных данных приведено ниже.</p>
  <p>В первой строке каждого набора входных данных находится одно целое положительное число n (2 ≤ n ≤ 5⋅10⁴) — количество кубов.</p>
  <p>Во второй строке находятся n целых положительных чисел aᵢ (1 ≤ aᵢ ≤ 10⁹) — объемы кубов.</p>
  <p>Гарантируется, что сумма n по всем наборам входных данных не превосходит 10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите в отдельной строке одно слово: «YES» (без кавычек), если кубы могут быть отсортированы при заданных условиях, и «NO» (без кавычек) иначе.</p>

  <details>
    <summary>Пример</summary>
<pre>
3
5
5 3 2 1 4
6
2 2 2 2 2 2
2
2 1
</pre>
<pre>
YES
YES
NO
</pre>
    <p>В первом наборе входных данных возможно отсортировать все кубы, используя 7 операций обмена.</p>
    <p>Во втором наборе входных данных все кубы уже отсортированы.</p>
    <p>В третьем наборе входных данных мы можем сделать 0 обменов, однако кубы еще не отсортированы, поэтому отсортировать мы их не можем.</p>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

// Функция для подсчета инверсий с помощью сортировки слиянием
long long mergeAndCount(vector&lt;int&gt;& arr, vector&lt;int&gt;& temp, int left, int mid, int right) {
  int i = left;    // Индекс для левой половины
  int j = mid + 1; // Индекс для правой половины
  int k = left;    // Индекс для временного массива
  long long invCount = 0;

  // Слияние двух половин с подсчетом инверсий
  while (i &lt;= mid && j &lt;= right) {
    if (arr[i] &lt;= arr[j]) {
      temp[k++] = arr[i++];
    } else {
      temp[k++] = arr[j++];
      invCount += (mid - i + 1); // Все элементы от i до mid образуют инверсии с arr[j]
    }
  }

  // Копирование оставшихся элементов левой половины
  while (i &lt;= mid) {
    temp[k++] = arr[i++];
  }

  // Копирование оставшихся элементов правой половины
  while (j &lt;= right) {
    temp[k++] = arr[j++];
  }

  // Копирование отсортированного временного массива обратно в arr
  for (i = left; i &lt;= right; i++) {
    arr[i] = temp[i];
  }

  return invCount;
}

// Рекурсивная функция для сортировки слиянием и подсчета инверсий
long long countInversions(vector&lt;int&gt;& arr, vector&lt;int&gt;& temp, int left, int right) {
  long long invCount = 0;
  if (left &lt; right) {
    int mid = left + (right - left) / 2;

    // Рекурсивный подсчет инверсий в левой и правой половинах
    invCount += countInversions(arr, temp, left, mid);
    invCount += countInversions(arr, temp, mid + 1, right);

    // Подсчет инверсий при слиянии двух половин
    invCount += mergeAndCount(arr, temp, left, mid, right);
  }
  return invCount;
}

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  int t;
  cin >> t;

  while (t--) {
    int n;
    cin >> n;
    vector&lt;int> a(n);
    for (int i = 0; i &lt; n; i++) {
      cin >> a[i];
    }

    // Максимальное количество обменов
    long long maxSwaps = (long long)n * (n - 1) / 2 - 1;

    // Подсчет инверсий
    vector&lt;int> temp(n);
    long long invCount = countInversions(a, temp, 0, n - 1);

    // Проверка условия
    if (invCount &lt;= maxSwaps) {
      cout &lt;&lt; "YES\n";
    } else {
      cout &lt;&lt; "NO\n";
    }
  }

  return 0;
}
</pre>
  </details>
</article>

