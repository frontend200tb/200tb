<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p><a href="https://codeforces.com/group/CkAC2YcRrZ/contests" target="_blank">ЯрГУ. Кружок. Контесты</a></p>
  <p>Автор кружка Игорь Маслеников</p>
</article>


<article class="article">
  <h1>Зимний блиц 2 2024</h1>
  <p><a href="https://codeforces.com/group/CkAC2YcRrZ/contest/364334" target="_blank">Codeforces Контест 364334 2024-01-14</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

      <a href="#task1">Задача A. Не отвлекайся!</a>
  <br><a href="#task2">Задача B. Заурядные числа</a>
  <br><a href="#task3">Задача C. Не соседняя матрица</a>
  <br><a href="#task4">Задача D. Плотный массив</a>
  <br><a href="#task5">Задача E. Сбалансированные остатки</a>
  <br><a href="#task6">Задача F. Сумма кубов</a>
</article>


<!-- Задача A. Не отвлекайся! -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Не отвлекайся!</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1520/problem/A" target="_blank">Задача 1520A</a>
      <br><a href="https://codeforces.com/contest/1520" target="_blank">Codeforces Round 719 (Div. 3) 2021-05-05</a>
    </div>

<pre>
#include &lt;iostream&gt;
#include &lt;map&gt;

using namespace std;

int main() {
// условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // число дней
    cin >> n;
    string s;
    cin >> s;

    // решение
    bool res = true;
    map&lt;char, int&gt; mp;
    for (int i = 0; i &lt; n; i++) {
      if (mp.find(s[i]) == mp.end()) {
        mp.insert(pair(s[i], 1));
      } else {
        if (s[i] == s[i - 1]) {
          mp[s[i]]++;
        } else {
          res = false;
          break;
        }
      }
    }

    // вывод результата
    if (res) {
      cout &lt;&lt; "YES\n";
    } else {
      cout &lt;&lt; "NO\n";
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача B. Заурядные числа -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Заурядные числа</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1520/problem/B" target="_blank">Задача 1520B</a>
      <br><a href="https://codeforces.com/contest/1520" target="_blank">Codeforces Round 719 (Div. 3) 2021-05-05</a>
    </div>

    <h4>Пример 2</h4>
<pre>
8
688
685
658
666
2233
2231
2213
2222
</pre>
<pre>
24
24
23
24
29
29
28
29
</pre>

<pre>
#include &lt;iostream&gt;

using namespace std;

typedef long long ll;

int main() {
  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    ll n; // целое число
    cin >> n;

    // решение
    ll start = n;
    ll res = 0;
    int razr = 1; // число разрядов в числе

    // в каждом разряде кроме старшего 9 заурядных чисел
    while (n >= 10) {
      res += 9;
      n /= 10;
      razr++;
    }

    // в n остался только старший разряд
    // добавим число единиц минус один в старшем разряде
    res += n - 1;

    // соберем последнее число с одинаковыми цифрами
    ll last = n;
    for (int i = 1; i &lt; razr; i++) {
      last *= 10;
      last += n;
    }

    // добавим 1 содержится число с одинаковыми цифрами
    if (start >= last) {
      res++;
    }

    // вывод результата
    cout &lt;&lt; res &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача C. Не соседняя матрица -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Не соседняя матрица</h3>

  <div><i>Ограничение по времени 4с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Будем считать числа a и b соседними, если они отличаются ровно на единицу, то есть |a-b|=1.</p>

  <p>Будем считать клетки квадратной матрицы n x n соседними, если они имеют общую сторону, то есть для клетки (r,c) соседними являются клетки (r,c-1), (r,c+1), (r-1,c) и (r+1,c).</p>

  <p>Для заданного числа n постройте квадратную матрицу n x n, такую что:</p>
  <ul>
    <li>Каждое число от 1 до n² встречается в этой матрице ровно один раз;</li>
    <li>Если (r₁, c₁) и (r₂, c₂) соседние клетки, тогда числа записанные в них не должны быть соседними.</li>
  </ul>

  <h4>Входные данные</h4>
  <p>В первой строке содержится одно целое число t (1≤t≤100). Далее следуют t наборов входных данных.</p>
  <p>Каждый набор входных данных характеризуется одним целым числом n (1≤n≤100).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите:</p>
  <ul>
    <li>-1, если искомой матрицы не существует;</li>
    <li>искомую матрицу, иначе (любую подходящую, если таких существует много).</li>
  </ul>
  <p>Матрицу следуют выводить в виде n строк, где каждая строка содержит n целых чисел.</p>

  <details>
    <summary>Пример</summary>
<pre>
3
1
2
3
</pre>
<pre>
1
-1
2 9 7
4 6 3
1 8 5
</pre>

    <p>Требуется заполнить квадратную матрицу n x n так, чтобы соседние элементы не были соседними числами. Представим матрицу в виде шахматной доски, где белые поля чередуются с черными. У каждой белой клетки все соседи черные и у каждой черной клетки все соседи белые.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1520/problem/C" target="_blank">Задача 1520C</a>
      <br><a href="https://codeforces.com/contest/1520" target="_blank">Codeforces Round 719 (Div. 3) 2021-05-05</a>
    </div>

    <p>В этом решении начинаем с первой клетки [0], она четная, идем через клетку до последней. В четные клетки кладем числа начиная с 1 и увеличивая их, в нечетные начиная с n и уменьшая их. Когда все заполним то последние два числа n и n-1 окажутся соседними. Чтобы исправить это меняем местами первое и последнее число</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  int t;
  cin >> t;

  for (int test = 0; test &lt; t; test++) {
    int n;
    cin >> n;

    if (n == 2) {
      cout &lt;&lt; -1 &lt;&lt; '\n';

    } else if (n == 1) {
      cout &lt;&lt; 1 &lt;&lt; '\n';

    } else {
      int a = 1, b = n * n, cnt = 0;
      vector&lt;vector&lt;int&gt; &gt; res(n);
      for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; n; j++) {
          if (cnt % 2 == 0) {
            res[i].push_back(a);
            a++;
          } else {
            res[i].push_back(b);
            b--;
          }
          cnt++;
        }
      }
      int tmp = res[0][0];
      res[0][0] = res[n - 1][n - 2];
      res[n - 1][n - 2] = tmp;
      for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; n; j++) {
          cout &lt;&lt; res[i][j] &lt;&lt; " ";
        }
        cout &lt;&lt; '\n';
      }
    }
  }
}
</pre>
  </details>

  <details>
    <summary>Мое решение</summary>
    <p>В этом решении начинаем с первой клетки [0], она четная, идем через клетку до последней. В четные клетки кладем числа начиная с 1 и увеличивая их, в нечетные начиная с середины и увеличивая их. Определяем середину. Для четного и нечетного n она будет разная.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  int t;
  cin >> t;

  for (int test = 0; test &lt; t; test++) {
    int n;
    cin >> n;

    if (n == 2) {
      cout &lt;&lt; -1 &lt;&lt; '\n';

    } else if (n == 1) {
      cout &lt;&lt; 1 &lt;&lt; '\n';

    } else {
      int a = 1, b, cnt = 0;
      if (n % 2 == 0) {
        b = n * n / 2 + 1;
      } else {
        b = n * n / 2 + 2;
      }
      vector&lt;vector&lt;int&gt; &gt; res(n);
      for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; n; j++) {
          if (cnt % 2 == 0) {
            res[i].push_back(a);
            a++;
          } else {
            res[i].push_back(b);
            b++;
          }
          cnt++;
        }
      }

      for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; n; j++) {
           cout &lt;&lt; res[i][j] &lt;&lt; " ";
        }
        cout &lt;&lt; '\n';
      }
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача D. Плотный массив -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Плотный массив</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Поликарп называет массив плотным, если в любой паре двух соседних элементов больший элемент не более чем в два раза превышает меньший. Более формально, для любого i(1 ≤ i ≤ n-1) должно быть выполнено условие:</p>
  <code>(max(a[i], a[i+1]) / min(a[i], a[i+1])) ≤ 2 </code>

  <p>Например, массивы [1,2,3,4,3], [1,1,1] и [5,10] — плотные. А массивы [5,11], [1,4,2], [6,6,1] — нет.</p>

  <p>Вам дан массив a, состоящий из n целых чисел. Какое минимальное количество чисел необходимо добавить в массив, чтобы он стал плотным? Вставлять числа можно в любое место массива. Если массив уже является плотным, то числа добавлять не надо.</p>

  <p>Например, если a=[4,2,10,1], то ответ равен 5, а сам массив после вставки в него элементов может выглядеть так: a=[4,2,3,5,10,6,4,2,1] (есть и другие оптимальные способы построить плотный массив a).</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержится одно целое число t (1≤t≤1000). Далее следуют t наборов входных данных.</p>

  <p>В первой строке каждого набора входных данных находится одно целое число n (2≤n≤50) — длина массива a.</p>

  <p>Следующая строка содержит n целых чисел a₁, a₂, ... , aₙ (1 ≤ aᵢ ≤ 50).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно целое число — минимальное количество чисел, которое необходимо добавить в массив, чтобы он стал плотным.</p>

  <details>
    <summary>Пример</summary>
<pre>
6
4
4 2 10 1
2
1 3
2
6 1
3
1 4 2
5
1 2 3 4 3
12
4 31 25 50 30 20 34 46 42 16 15 16
</pre>
<pre>
5
1
2
1
0
3
</pre>
    <p>Первый набор входных данных разобран в условии.</p>
    <p>Во втором наборе входных данных можно вставить один элемент, a=[1,2,3].</p>
    <p>В третьем наборе входных данных можно вставить два элемента, a=[6,4,2,1].</p>
    <p>В четвертом наборе входных данных можно вставить один элемент, a=[1,2,4,2].</p>
    <p>В пятом наборе входных данных массив a уже плотный.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1490/problem/A" target="_blank">Задача 1490A</a>
      <br><a href="https://codeforces.com/contest/1490" target="_blank">Codeforces Round 702 (Div. 3) 2021-02-16</a>
    </div>

    <p>Считаем разницу между двумя соседними элементами. Если больше 2, то если первый элемент меньше второго, то умножаем его на 2 и прибавляем к счетчику 1. Если первый элемент больше второго и делится на 2 без остатка, то делим его на два, иначе делим его на два и прибавляем 1.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ввод данных
  int t;
  cin >> t;

  while (t--) {
    int n;
    cin >> n;
    vector&lt;int&gt; A(n);
    for (int i = 0; i &lt; n; i++) {
      cin >> A[i];
    }

    // решение
    int count = 0;
    int prev = A[0];
    double ref;
    for (int i = 1; i &lt; n; i++) {
      ref = (double)max(prev, A[i]) / min(prev, A[i]);
      while (ref > 2) {
        if (prev &lt; A[i]) {
          prev *= 2;
        } else {
          prev = prev % 2 ? prev / 2 + 1 : prev / 2;
        }
        ref = (double)max(prev, A[i]) / min(prev, A[i]);
        count++;
      }
      prev = A[i];
    }

    // вывод результата
    cout &lt;&lt; count &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача E. Сбалансированные остатки -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Сбалансированные остатки</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1490/problem/B" target="_blank">Задача 1490B</a>
      <br><a href="https://codeforces.com/contest/1490" target="_blank">Codeforces Round 702 (Div. 3) 2021-02-16</a>
    </div>

  </details>
</article>


<!-- Задача F. Сумма кубов -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Сумма кубов</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1490/problem/C" target="_blank">Задача 1490C</a>
      <br><a href="https://codeforces.com/contest/1490" target="_blank">Codeforces Round 702 (Div. 3) 2021-02-16</a>
    </div>

  </details>
</article>

