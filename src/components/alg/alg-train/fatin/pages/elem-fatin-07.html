<h1>Бинарный поиск</h1>


<article class="article">
  <p>Конспект видео от 2024-01-16</p>
  <h4>Бинарный поиск, МЕТОД ОЛИМПИАДНИКОВ. Как подготовиться к собеседованию в Яндекс</h4>

  <p><a href="https://www.youtube.com/@fatin.maksim/videos">youtube Максим Фатин</a></p>
  <p><a href="https://algocode.io/">https://algocode.io/</a></p>
  <p><a href="https://tskills.ru/algo">https://tskills.ru/algo</a></p>

  <p>Чек лист с задачами, которые нужно прорешать самому</p>
  <p><a href="https://leetcode.io/">https://leetcode.io/</a> 74. Search a 2D Matrix</p>
  <p><a href="https://leetcode.io/">https://leetcode.io/</a> 34. Find First and Last Position of Element in Sorted Array</p>
  <p><a href="https://leetcode.io/">https://leetcode.io/</a> 69. Sqrt(x)</p>
  <p><a href="https://leetcode.io/">https://leetcode.io/</a> 658. Find K Closest Elements</p>
</article>


<article class="article">
  <p>Сегодня узнаем в каких задачах используется бинарный поиск. Почему ты пишешь его неправильно и ошибаешься на собесах.</p>
  <p>В начале разберемся в каких задачах используется бинарный поиск. Посмотрим примеры решения. А в конце ты получишь полезный чек-лист для отработки полученных знаний</p>
  <p>Использовать бинарный поиск для решения можно если удается разбить входные данные на две непрерывающиеся последовательности по каким нибудь признакам. Посмотрим сначала на простую задачу.</p>
  <p>Когда на собеседовании тебе попадется задача на бинарный поиск, будет круто если перед тем как решать, ты расскажешь какие задачи вообще могут быть решены бинарным поиском. А если еще расскажешь и про функцию, которую нужно придумать, чтобы сначала шло true а потом false, то будешь на голову выше тех, кто этого не знает.</p>
</article>


<article class="article">
  <h3>Задача 1. Найти число в отсортированном массиве</h3>

  <p>Есть массив nums отсортированный в возрастающем порядке. Проверить есть ли в этом массиве число target. Если такого числа нет, то вернуть -1. Если такое число есть, то вернуть его позицию.</p>

  <p>Пример</p>
  <code>nums = [-1, 0, 3, 5, 9, 12]; target = 9;</code>
  <code>Ответ 4</code>

  <p>Для входный данных можно придумать <strong>функцию</strong>, которая превратит наш массив из чисел в <strong>массив из true и false</strong>. При этом сначала будут идти все true, а потом false. В этой задаче такой функцией будет</p>
  <code>nums[i] &lt;= target</code>
  <p>То есть мы смогли разбить входные данные на <strong>две непрерывающиеся последовательности</strong>. И это будет работать для любых входных данных. Поэтому данную задачу можно решать <strong>бинарным поиском</strong>.</p>
  <p>Будем называть элементы, которые дают ture - хорошими, а false - плохими. В этом случае target может быть только последним хорошим элементом. Именно поэтому после бинарного поиска нужно проверить что он равен target.</p>
  <p>В бинарном поиске мы ищем не один элемент target, а два элемента. Первый где заканчивается true, второй - где начинается false. То есть первый указатель встанет на последний хороший элемент, а второй указатель - на первый плохой.</p>
  <p>Подход обеспечит тебе понимание на что указывает тот или иной указатель. В 96% случаев код будет выглядеть одинаковым. И ты не ошибешься на что указывает тот или иной указатель.</p>
  <p>Сложность по времени O(logN). Сложность по памяти O(1).</p>

  <details>
    <summary>Алгоритм</summary>
    <ol>
      <li>Заведем два указателя pl и pr. pl указывает на первый элемент массива, pr указывает за пределы массива на следующий (несуществующий) элемент после последнего
        <code>let pl = 0, pr = nums.length;</code>
      </li>
      <li>Будем сдвигать левый указатель вправо, а правый влево до тех пор пока они не будут указывать на соседние элементы (разница между ними будет 1)
        <code>while (pr - pl > 1)</code>
      </li>
      <li>Находим середину (опорный элемент)
        <code>let m = Math.floor((pl + pr) / 2);</code>
      </li>
      <li>Проверяем условие. Передаем в нашу функцию опорный элемент
        <code>if (isGood(nums[m], target))</code>
      </li>
      <li>Если элемент хороший (функция вернула true), то двигаем левый указатель вправо на опорный элемент
        <code>pl = m;</code>
      </li>
      <li>Если элемент плохой (функция вернула false), то двигаем правый указатель влево на опорный элемент
        <code>pr = m;</code>
      </li>
      <li>Ответ будет находиться в элементе указывающем на pl. Чтобы pl мог принимать значения [0, nums.length - 1] т.е. от первого и до последнего индекса включительно, сдвигаем pr на 1 вправо от последнего индекса массива.</li>
      <li>Проверяем условие, если pl указывает на target, то вернем pl, иначе вернем -1
        <code>return nums[pl] === target ? pl : -1;</code>
      </li>
    </ol>
  </details>

  <details>
    <summary>Решение (javascript)</summary>
<pre>
function search(nums, target) {
  let pl = 0, pr = nums.length;

  while (pr - pl > 1) {
    // определяем середину
    let m = Math.floor((pl + pr) / 2);
    if (isGood(nums[m], target)) {
      // если число по индексу m хорошее, то двигаем левый указатель
      pl = m;
    } else {
      // если число по индексу m плохое, то двигаем правый указатель
      pr = m;
    }
  }

  // если левый указатель указывает на target
  // то вернуть левый указатель, иначе -1
  return nums[pl] === target ? pl : -1;
}

function isGood(val, target) {
  return val &lt;= target;
}
</pre>
  </details>

  <details>
    <summary>Решение (python)</summary>
<pre>
class Solution:
  def isGood(self, val: int, target: int) -> bool:
    return val &lt;= target

  def search(self, nums: list[int], target: int) -> int
    pl, pr = 0, len(nums)

    while pr - pl > 1:
      m = (pl + pr) // 2
      if self.isGood(nums[m], target):
        pl = m
      else:
        pr = m

    return pl if nums[pl] == target else -1
</pre>
  </details>
</article>


<!-- 2. Найти сдвиг в отсортированном массиве со сдвигом -->
<article class="article">
  <h3>Задача 2. Найти сдвиг в отсортированном массиве со сдвигом</h3>

  <p>Эта задача с собеседования в ВК и Яндекс.</p>
  <p>Есть массив чисел nums. Он отсортирован по возрастанию, но со сдвигом.</p>

  <p>Пример</p>
  <p>Массив [4,5,6,7,1,2,3] был получен из массива [1,2,3,4,5,6,7] сдвигом на 4 элемента вправо</p>

  <p>Кроме массива nums, есть число target, позицию которого нужно вернуть если это число в массиве есть. Если его нет, вернуть -1</p>

  <p>Пример</p>
  <code>nums = [4,5,6,7,0,1,2]; target = 0; // 4</code>

  <p>Эта садача такая же как прошлая, но осложненная сдвигом. Тут бинарный поиск придется применить два раза. Первый раз когда будем искать сам сдвиг. Второй раз для поиска самого элемента.</p>
  <p>Самая интересная часть задачи найти оптимальный способ поиска сдвига. Мы можем просто пройтись по массиву сравнивая соседние элементы и за линейное время определить сдвиг. Но можно и быстрее за логарифм используя бинарный поиск.</p>
  <p>Чтобы найти сдвиг (offset) с помощью бинарного поиска, определим функцию, которая будет возвращать для всех элементов сначала true, а потом false</p>

  <p>В этой задаче такой функцией будет</p>
  <code>nums[i] &gt;= nums[nums.length-1];</code>

  <p>Эта функция сработает, потому что в задаче нет одинаковых элементов. Нам дана возрастающая последовательность.</p>
  <p>Пример 1</p>
  <code>nums = [4,5,6,7,0,1,2]</code>
<pre>
    good   bad
[4 5 6 7 | 0 1 2]
       l   r
</pre>
  <p>Здесь элементы с 4 по 7 хорошие, с 0 по 2 плохие и сдвиг равен 4.</p>

  <p>Пример 2</p>
  <code>nums = [1,2,3,4,5]</code>
<pre>
good    bad
    [ | 1 2 3 4 5]
  l     r
</pre>
  <p>В этом примере хороших элементов нет и сдвиг равен 0.</p>
  <p>Сдвиг равен индексу, на который указывает правый указатель r.</p>
  <p>Сдвиг будет находиться в правом указателе r. Поэтому указатель r может принимать значения [0, nums.length - 1]</p>

  <details>
    <summary>Алгоритм поиска сдвига</summary>
    <ol>
      <li>Заведем два указателя pl и pr. pl указывает за пределы массива на предыдущий (несуществующий) элемент перед первым элементом массива, pr указывает на последний элемент массива
        <code>let pl = -1, pr = nums.length - 1;</code>
      </li>
      <li>Будем сдвигать левый указатель вправо, а правый влево до тех пор пока они не будут указывать на соседние элементы (разница между ними будет 1)
        <code>while (pr - pl > 1)</code>
      </li>
      <li>Находим середину (опорный элемент)
        <code>let m = Math.floor((pl + pr) / 2);</code>
      </li>
      <li>Проверяем условие. Передаем в нашу функцию опорный элемент
        <code>if (isGood(nums[m], target))</code>
      </li>
      <li>Если элемент хороший (функция вернула true), то двигаем левый указатель вправо на опорный элемент
        <code>pl = m;</code>
      </li>
      <li>Если элемент плохой (функция вернула false), то двигаем правый указатель влево на опорный элемент
        <code>pr = m;</code>
      </li>
      <li>Ответ будет находиться в элементе указывающем на pr. Чтобы pr мог принимать значения [0, nums.length - 1] т.е. от первого и до последнего индекса включительно, сдвигаем pl на 1 влево от первого индекса массива.</li>
      <li>Когда цикл закончится, вернем pr
        <code>return pr;</code>
      </li>
    </ol>
  </details>

  <details>
    <summary>Код поиска сдвига (javascript)</summary>
<pre>
function offset(nums) {

  function isGood(i) {
    return nums[i] >= nums[nums.length-1];
  }

  let pl = -1;
  let pr = nums.length - 1;

  while (pr - pl > 1) {
    // определяем середину
    let m = Math.floor((pl +pr) / 2);
    if (isGood(m)) {
      // если число по индексу m хорошее, то двигаем левый указатель
      pl = m;
    } else {
      // если число по индексу m плохое, то двигаем правый указатель
      pr = m;
    }
  }

  return pr;
}
</pre>
  </details>

  <details>
    <summary>Код поиска сдвига (python)</summary>
<pre>
class Solution:
  def offset(self, nums: list[int]):
    def isGood(i: int):
      return nums[i] >= nums[-1]

    pl, pr = -1, len(nums) - 1
    while pr - pl > 1:
      m = (pl + pr) // 2
      if isGood(m):
        pl = m
      else:
        pr = m

    return pr
</pre>
  </details>
</article>


<!-- 3. Найти число в отсортированном массиве со сдвигом -->
<article class="article">
  <h3>Задача 3. Найти число в отсортированном массиве со сдвигом</h3>

  <h3>Задача на бинарный поиск, который надо применить 2 раза</h3>
  <p>Есть массив чисел nums. Он отсортирован по возрастанию, но со сдвигом. Еще есть target - число, позицию которого нужно вернуть, если оно есть в массиве nums. Если его нет - вернуть -1.</p>

  <p>Пример</p>
  <code>search([4,5,6,7,1,2,3], 5); // 1</code>
  <p>Массив [4,5,6,7,1,2,3] получен из массива [1,2,3,4,5,6,7] сдвигом на 4 элемента вправо</p>

  <p>Бинарный поиск нужно применить 2 раза.</p>
  <p>1. Когда будем искать сам сдвиг</p>
  <p>2. Для поиска самого элемента</p>

  <details>
    <summary>Алгоритм</summary>
  </details>

  <details>
    <summary>Код (javascript)</summary>
<pre>
function search(nums, target) {
  function isGood(i) {
    return nums[i] &lt;= target;
  }

  // обычный бинарный поиск, но смещаем на offset дополнительно
  let shift = offset(nums);
  let l = 0;
  let r = nums.length;
  while (r - l > 1) {
    // определяем середину
    // Ошибка №1 это делать m=(l+r+shift)/2
    let m = Math.floor((l + r) / 2);
    if (isGood((m+shift) % nums.length)) {
      // если число по индексу m хорошее, то двигаем левый указатель
      l = m;
    } else {
      // если число по индексу m плохое, то двигаем правый указатель
      r = m;
    }
  }
  // Ошибка №2 это забыть сделать (l+shift) % nums.length
  // Берем остаток от деления чтобы не выйти за границы массива
  let realLeft = (l + shift) % nums.length;
  // если левый указатель указывает на target
  // то вернуть левый указатель, иначе -1
  return nums[realLeft] === target ? realLeft : -1;
}
</pre>
  </details>

  <details>
    <summary>Код (python)</summary>
<pre>
def search(self, nums: list[int], target: int) -> int:
  def isGood(i: int):
    return nums[i] &lt;= target

  // обычный бинарный поиск
  // но смещаем на offset дополнительно
  offs = self.offset(nums)
  pl, pr = 0, len(nums)
  while pr - pl > 1:
    m = (pl + pr) // 2
    if isGood((m + offs) % len(nums)):
      pl = m
    else:
      pr = m

    realLeft = (pl + offs) % len(nums)
    return realLeft if nums[realLeft] == target else - 1
</pre>
  </details>
</article>
