<h1>Два указателя</h1>


<!-- links -->
<article class="article">
  <h2>links</h2>

  <p><a href="https://www.youtube.com/@fatin.maksim/videos">youtube Максим Фатин</a></p>
  <p><a href="https://algocode.io/">https://algocode.io/</a></p>
  <p><a href="https://tskills.ru/algo">https://tskills.ru/algo</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p><a href="#point">Два указателя</a></p>
  <ol>
    <li>
      <a href="#point1">С двух сторон</a>
      <p><a href="#point11">1.1 Отсортированный массив в квадрате</a></p>
      <p><a href="#point15">1.5 Сумма двух чисел в отсортированном массиве</a></p>
    </li>
    <li>
      <a href="#point2">Каждому по указателю</a>
      <p><a href="#point22">2.2 Общие элементы отсортированных массивов</a></p>
    </li>
    <li>
      <a href="#point3">Медленный и быстрый указатели</a>
      <p><a href="#point31">Перемещение нулей</a></p>
    </li>
  </ol>
</article>


<!-- Два указателя -->
<article class="article">
  <div class="anchor" id="point"></div>
  <h3>Два указателя</h3>

  <p>Метод двух указателей можно разделить на 3 группы</p>
  <ol>
    <li>С двух сторон. Например, есть массив. Заводим две переменные pl и pr для два левого и правого указателя. Левый ставим на начало массива, а правый - на конец. Сравниваем элементы массива, на которые указывают указатели. На основе некоторого условия двигаем левый указатель вправо или правый влево. Указатели двигаем друг к другу пока они не встретятся</li>
    <li>Каждому по указателю. Например, есть два массива. Заводим две переменные p1 и p2 для первого и второго указателя. Первый ставим на начало первого массива, второй - на начало второго. Сравниваем элементы на которые указывают указатели. На основе некоторого условия двигаем первый или второй указатель вправо к концу массива. Указатель двигается пока не дойдет до конца массива.</li>
    <li>Медленный и быстрый указатели. Например, есть массив. Заведем две переменные ps и pf для медленного и быстрого указателя.</li>
  </ol>
</article>


<!-- 1. С двух сторон -->
<article class="article">
  <div class="anchor" id="point1"></div>
  <h3>1. С двух сторон</h3>
</article>


<!-- 1.1 Отсортированный массив в квадрате -->
<article class="article">
  <div class="anchor" id="point11"></div>
  <h3>1.1 Отсортированный массив в квадрате</h3>

  <p>Дан массив целых чисел nums, отсортированный в неубывающем порядке. Вернуть массив квадратов каждого числа, отсортированный в неубывающем порядке</p>

  <p>Пример</p>
  <code>Input: nums = [-4,-1,0,3,10]</code>
  <code>Output: [0,1,9,16,100]</code>

  <p>Идея решения. При возведении в квадрат отрицательное число становится положительным. Поэтому самым максимальным числом в результате может стать либо первое либо последнее число исходного массива возведенное в квадрат. Поэтому надо сравнить квадраты первого и последнего числа и максимальный поставить в конец результирующео массива. Потом сдвинуть один указатель и опять сравнить два карайних числа.</p>
  <details>
    <summary>Решение</summary>
    <h4>Алгоритм</h4>
    <ol>
      <li>Заведем переменную res для результата. Положим в нее пустой массив</li>
        <code>let res = [];</code>
      <li>Заведем две переменные pl и pr для левого и правого указателя. Левый поставим на начало массива, правый - на конец
        <code>let pl = 0, pr = nums.length - 1;</code>
      </li>
      <li>Пройдем циклом пока левый указатель меньше или равен правому
        <code>while (pl &lt;= pr)</code>
      </li>
      <li>Сравним квадраты двух элементов. Если квадрат левого элемент больше, то добавим его в массив res и двигаем левый указатель вправо, иначе записываем квадрат правого элемента и двигаем правый указатель влево</li>
      <li>Получили массив, отсортированный по убыванию. Перевернем массив и вернем результат</li>
    </ol>
<pre>
function sortedSquares(nums) {
  const res = [];
  let pl = 0, pr = nums.length - 1;

  while (pl &lt;= pr) {
    if (Math.abs(nums[pl]) > Math.abs(nums[pr])) {
      res.push(Math.pow(nums[pl], 2));
      pl++;
    } else {
      res.push(Math.pow(nums[pr], 2));
      pr--;
    }
  }
  return res.reverse();
}

console.log(sortedSquares([-4,-1,0,3,10])); // [0,1,9,16,100]
</pre>
  </details>
  <p>Сложность по времени O(N). Сложность по памяти O(1).</p>
</article>


<!-- 1.5 Сумма двух чисел в отсортированном массиве -->
<article class="article">
  <div class="anchor" id="point15"></div>
  <h3>1.5 Сумма двух чисел в отсортированном массиве</h3>

  <p>Дан отсортированный массив чисел и число. Определить, есть ли в массиве два числа , которые в сумме равны заданному числу</p>

  <p>Пример</p>
  <code>Input: [4,4], target = 8</code>
  <code>Output: true</code>

  <p>Пример</p>
  <code>Input: [1,2,7,13,18], target = 15</code>
  <code>true</code>

  <details>
    <summary>Решение</summary>
    <p>Метод двух указателей</p>
    <h4>Алгоритм</h4>
    <ol>
      <li>Заведем две переменные l и r для левого и правого указателя и зададим им начальные значения - первый и последний индекс массива
        <code>let l = 0, r = nums.length - 1;</code>
      </li>
      <li>Пройдем циклом пока левый указатель меньше правого
        <code>while (l &lt; r)</code>
      </li>
      <li>Проверим сумму чисел на которые указывают указатели. Если сумма равна target, возвращаем true</li>
      <code>if (nums[l] + nums[r] === t)</code>
      <li>Если сумма больше target, двигаем правый указатель влево, если меньше, двигаем левый указатель вправо
        <code>if (nums[l] + nums[r] > t)</code>
      </li>
      <li>Если цикл закончился, значит никакие два числа не дали в сумме target. Возвращаем false</li>
    </ol>
<pre>
function twoSum(nums, t) {
  let l = 0, r = nums.length - 1;

  while (l &lt; r) {
    if (nums[l] + nums[r] === t) {
      return true;
    } else if (nums[l] + nums[r] > t) {
      r--;
    } else {
      l++;
    }
  }
  return false;
}

console.log(twoSum([1, 2, 7, 13, 15, 18, 29], 15)); // true
console.log(twoSum([1, 2, 7, 13, 15, 18, 29], 10)); // false
</pre>
  </details>
  <p>Сложность по времени O(N). Сложность по памяти O(1)</p>

</article>


<!-- 2. Каждому по указателю -->
<article class="article">
  <div class="anchor" id="point2"></div>
  <h3>2. Каждому по указателю</h3>
</article>


<!-- 2.2 Общие элементы отсортированных массивов -->
<article class="article">
  <div class="anchor" id="point22"></div>
  <h3>2.2 Общие элементы отсортированных массивов</h3>

  <p>Найти пересечение двух отсортированных массивов ИЛИ</p>
  <p>Для двух отсортированных массивов найти все эелементы, которые встречаются в обоих массивах и ответ вернуть в отсортированном массиве.</p>

  <p>Пример</p>
  <code>Input: nums1 = [2,2,5,8,14,19,29,30]</code>
  <code>nums2 = [-3,0,1,2,2,2,8,19]</code>
  <code>Output: [2,2,8,19]</code>

  <details>
    <summary>Решение (оптимальное)</summary>
    <p>Будем использовать метод двух указателей. Паттерн "Каждому по указателю"</p>
    <h4>Алгоритм</h4>
    <ol>
      <li>Заведем переменную res для результата. Положим в нее пустой массив
        <code>const res = [];</code>
      </li>
      <li>Заведем две переменные p1 и p2 для указателей. Поставим первый указатель на первый элемент первого массива, второй - на первый элемент второго.
        <code>let p1 = 0, p2 = 0;</code>
      </li>
      <li>Запустим цикл пока один из указателей не дойдет до конца массива
        <code>while (p1 &lt; a.length || p2 &lt; b.length)</code>
      </li>
      <li>Будем сравнивать два элемента nums[p1] и nums[p2].</li>
      <li>Если они равны, то элемент добавляется массив res и двигаем оба указателя вправо.</li>
      <li>Если не равны, то двигаем вправо указатель на меньшее число.</li>
      <li>Когда один из массивов закончился, выходим из цикла и возвращаем массив res</li>
    </ol>
<pre>
function intersect(a, b) {
  const res = [];
  let p1 = 0, p2 = 0;

  while (p1 &lt; a.length && p2 &lt; b.length) {
    if (a[p1] > b[p2]) {
      p2++;
    } else if (a[p1] &lt; b[p2]) {
      p1++;
    } else {
      res.push(a[p1]);
      p1++;
      p2++;
    }
  }
  return res;
}

let n1 = [2,2,5,8,14,19,29,30];
let n2 = [-3,0,1,2,2,2,8,19];
console.log(intersect(n1, n2)); // [2,2,8,19]
</pre>
  </details>
  <p>Сложность по времени O(n+m). Сложность по памяти O(min(n,m)).</p>
</article>


<!-- 3. Медленный и быстрый указатель -->
<article class="article">
  <div class="anchor" id="point3"></div>
  <h3>3. Медленный и быстрый указатель</h3>
</article>


<!-- 3.1 Перемещение нулей -->
<article class="article">
  <div class="anchor" id="point31"></div>
  <h3>3.1 Перемещение нулей</h3>

  <p>Дан целочисленный массив nums, переместите все нули в его конец, сохранив относительный порядок ненулевых элементов. Сделайте это in-place (на месте), не создавая копию массива</p>

  <p>Пример</p>
  <code>Input: nums = [2,0,0,9,3,0,1]</code>
  <code>Output: [2,9,3,1,0,0,0]</code>

  <p>Пример</p>
  <code>Input: nums = [2,3,0,9,3,0,1]</code>
  <code>Output: [2,3,9,3,1,0,0]</code>

  <p>Идея решения. Создать быстрый и медленный указатели. Быстрый будет идти первый и искать не нулевой элемент. медленый будет идти за ним с шагом 1 и указывать куда надо переместить ненулевой элемент. Когда быстрый указатель выходит за пределы массива, то все элементы начиная с медленного указателя должны быть нулями.</p>

  <p>Сложность по времени O(N). Сложность по памяти O(1).</p>
</article>
