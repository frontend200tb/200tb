<h1>Два указателя</h1>


<article class="article">
  <p>Конспект видео от 2024-08-17</p>
  <h4>Почему ты все еще не выучил алгосы_ С чего вообще начать_ RoadMap для разноса собесов!</h4>

  <p><a href="https://www.youtube.com/@fatin.maksim/videos">youtube Максим Фатин</a></p>
  <p><a href="https://tskills.ru/algo">https://tskills.ru/algo</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p><a href="#about">План на стрим</a></p>
  <p><a href="#evol">Эволюция подготовки к алго-собесу</a></p>
  <p><a href="#task1">Задача 1. Объединить интервалы</a></p>
  <p><a href="#task2">Задача 2. Найти максимальное количество интервалов, которые пересекаются</a></p>
  <p><a href="#stad">Стадии собеседования</a></p>
  <p><a href="#task3">Задача 3. Two Sum</a></p>
  <p><a href="#point">Два указателя</a></p>
  <p><a href="#task4">Задача 4. Отсортированный массив в квадрате</a></p>
  <p><a href="#task5">Задача 5. Общие элементы отсортированных массивов</a></p>
  <p><a href="#task6">Задача 6. Перемещение нулей</a></p>
  <p><a href="#qa">Вопросы и ответы</a></p>
</article>


<!-- План на стрим -->
<article class="article">
  <div class="anchor" id="about"></div>
  <h3>План на стрим</h3>

  <p>У нас сегодня грандиозный план покорения биг теха, покорения алго собесов.</p>
  <ol>
    <li>Смотрим как эволюционировать от 0 задач на leetcode до инженера BigTech</li>
    <li>Какие проблемы есть на каждом этапе и как их решать</li>
    <li>Строим RoadMap развития в алгоритмах</li>
    <li>Разбираем задачи из Озон, Яндекс, Сбера</li>
  </ol>
</article>


<!-- Эволюция подготовки к алго-собесу -->
<article class="article">
  <div class="anchor" id="evol"></div>
  <h3>Эволюция подготовки к алго-собесу</h3>

  <h4>Только начинаю</h4>
  <ol>
    <li>С чего начать. Есть много различного материала. Куда идти и у кого спрашивать?</li>
    <li>Одиноко и непонятно что делать</li>
  </ol>

  <p>Крутой буст</p>
  <ol>
    <li>Энтузиазм и готовность работать. Самое начало это зыбкое болото и тут нужно как лягушка вкалывать чтобы достичь результатов. Должно быть желание прийти к результату. Должна быть четкая цель</li>
    <li>RoadMap с темами. Для того чтобы не просто видосы какие-то смотрел, а чтобы чел по плану</li>
  </ol>

  <h4>Решил менее 50 алго-задач</h4>
  <ol>
    <li>Не прохожу собесы. Задачи вроде похожи. Вроде ты такие уже видел</li>
    <li>Шаг влево-вправо от того что решал и теряюсь и не хватает времени чтобы решить</li>
    <li>Ошибаюсь в BigO. Знаешь что каждый алгоритм нужно оценивать</li>
  </ol>

  <p>Крутой буст</p>
  <ol>
    <li>Детальный план подготовки к собесам</li>
    <li>Осознание паттернов и их применение</li>
    <li>Решение базовых задач по каждой теме с собесов</li>
  </ol>
  <p>Нужно не просто изучать темы, например, два указателя, массивы, сортировки. Нам нужно в двух указателях знать что есть три вида паттернов. Нужно знать что в sliding window есть два вида паттернов - работа с пересекающимися и с непересекающимися окнами. И у каждого паттерна есть код, который не меняется, который шаблонный.</p>
  <p>Есть leetcode который работает как миксер. Там куча задач и все темы перемешаны.</p>

  <h4>Решил менее 100 алго-задач</h4>
  <ol>
    <li>Забываю решения задачек</li>
    <li>Не прохожу собесы</li>
    <li>Шаг влево-вправо от того что решал и теряюсь</li>
    <li>Ошибаюсь в BigO</li>
    <li>Монотонность и скука: столько сделал, а где результат?</li>
  </ol>

  <p>Крутой буст</p>
  <ol>
    <li>Решение задач именно тех, что дают в конкретной компании</li>
    <li>Закрытие узких тем. Есть паттерны, которые решают всего 2-3 задачи. Это считается узкой темой. Такие задачи попадаются очень редко. Например, работа с интервалами.</li>
  </ol>

  <p>До этого был всплеск энтузиазма. Но ты видишь, то что ты делаешь - не дает результата. Идет эмциональный спад. Попадаешь в эмоциональную яму. Но после ямы идет экспоненциальный рост! До тех пор пока ты снова не попадешь в яму. И чем больше таких ям пройдешь, тем круче ты эксперт. В яме отсеивается 90% людей. Они не могут пройти тот момент, когда кажется, что я все делаю, я все решаю, а оно все никак. И когда ты делаешь первый небольшой шаг из ямы, начинаешь видеть небольшой локальный успех, у тебя идет эмоциональный подъем и с этого момента ты начинаешь становаться экспертом.</p>
  <p>От пика до ямы дойти легко. За 3-4 дня. Когда я попадаю в яму, когда все сдались, вот тогда я начинаю фигачить и начинается взлет компетенций. Такие ямы будут встречаться каждые пару месяцев. И если ты научишься их проходить - то это индикатор того что ты сеньер.</p>
  <p>Сколько времени занимает пройти от начинающего до 50 задач</p>
  <p>Чтобы не забывать решение задач. Нужно разложить в голове все по паттернам. Решать задачи по шаблонам. Один паттерн может решить 50 задач. Чтобы избавиться от забывания решений, чтобы мозг хранил только нужную информацию, для этого нужно ее минимизировать.</p>
  <p>Задачки нужно решать регулярно. Это как постоянно подкармливать свой мозг, закидываю туда данные, чтобы он их обрабатывал и выдавал результат.</p>

  <h4>Решил 100+ алго-задач</h4>
  <p>Момент когда ты должен уже стать сильным программистом, но почему то :</p>
  <ol>
    <li>Прохожу собесы, но 50 на 50 и непонятно почему</li>
    <li>На собесах попадаются задачи, которые уже решал, но не могу вспомнить что делать</li>
    <li>Ощущение, что все зря</li>
  </ol>

  <p>Крутой буст</p>
  <ol>
    <li>Осознание, что в собеседовании есть стадии и умение их проработать</li>
    <li>Проработка и систематизация знаний</li>
    <li>Закрытие узких тем</li>
  </ol>

  <p>Каждый кто учился в школе, был небольшой азарт. Когда учительница спрашивает, а ты знаешь и тянешь руку. И с тобой еще тянут несколько человек руки. И ты думаешь - вот бы спросили меня. Вот такое чувство должно возникать на собеседовании после решения 200 задачек.</p>
  <p>Интервьюер тебя спрашивает. Он даже не договорил. А ты уже знаешь что он спросит. Знаешь что ответить.</p>

  <h4>Почему число решенных задач растет а результата нет</h4>
  <ol>
    <li>Нет четкой системы по которой идешь</li>
    <li>Нет поддержки - скучно</li>
    <li>Не видно сразу результат и сложность его оценки</li>
    <li>Нет человека, который уже проходил этот путь и расскажет как прийти к успеху</li>
  </ol>
  <p>Можно одну задачу решить быстро, другую медленно. И в итоге не знаешь понял ты эту тему или нет.</p>

  <h4>Как исправлять</h4>
  <p>Во-первый, надо решать задачи, которые популярны. Список тем на собесе по мере их важности</p>
  <ol>
    <li>Массивы 16%</li>
    <li>Хеш-таблица 15,4%</li>
    <li>Два указателя 13%</li>
    <li>Сортировки 10,7%</li>
    <li>Стек, очередь 7,7%</li>
    <li>Связный список 6,5%</li>
    <li>Куча 5,9%</li>
    <li>Бинарный поиск 5,9%</li>
    <li>Графы</li>
    <li>Плавающее окно</li>
    <li>Деревья</li>
    <li>Другое</li>
  </ol>

  <p>Видно, что два указателя - это третья по важности тема на собесах, после массивов и хеш-таблицы</p>
</article>


<!-- Задача 1. Объединить интервалы -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача 1. Объединить интервалы</h3>

  <p>Задача из узкой темы, потому что таких задач мало.</p>
  <p>У нас есть несколько интервалов. Пересекающиеся нужно объединить.</p>

  <h4>Пример</h4>
<pre>
                        ._____.
                        11   12
._____.
1     3
           ._______.
           5       8
    .________.
    2        6
</pre>
  <p>Для начала их нужно отсортировать</p>
<pre>
._____.
1     3
    .________.
    2        6
           ._______.
           5       8
                        ._____.
                        11   12
</pre>
  <p>Теперь их можно объединить</p>
<pre>
.__________________.
1                  8
                        ._____.
                        11   12
</pre>
  <code>Input : [[11,12], [1,3], [5,8], [2,6]]</code>
  <code>Output : [[1,8], [11,12]]</code>

  <h4>Паттерн точек</h4>
</article>


<!-- Задача 2. Найти максимальное количество интервалов, которые пересекаются -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача 2. Найти максимальное количество интервалов, которые пересекаются</h3>

  <p>Задача из узкой темы, потому что таких задач мало.</p>
  <p>У нас есть несколько интервалов. Найти максимальное количество интервалов, которые пересекаются.</p>

  <h4>Пример</h4>
<pre>
.__.
1  2
.______________.
1              7
   .________.
   2        6
                 ._.
                  8
          .______.
          5      8
              .__________.
              7          12
</pre>
  <p>Здесь максимально одновременно пересекаются три интервала</p>
  <code>Input : [[1,2], [2,3], [2,6], [8,8], [5,8], [7,12]]</code>
  <code>Output : 3</code>

  <h4>Паттерн точек</h4>
</article>


<!-- Стадии собеседования -->
<article class="article">
  <div class="anchor" id="stad"></div>
  <h3>Стадии собеседования</h3>

  <p>На собеседовании есть несколько стадий. На каждой стадии оценивается что-то одно. Как тебя оценивают на собеседовании? Что от тебя хочет интервьюер?</p>
  <ol>
    <li>Soft skills</li>
    <li>Как придумывает решение?</li>
    <li>Оценка сложности</li>
    <li>Качество кода</li>
    <li>Ошибки и их исправление</li>
  </ol>
  <p>Во первый проверяется soft skills. Что ты умеешь правильно коммуницировать. Чтобы ты мог правильно спрашивать подсказки. Если ты просто сидишь и не знаешь что делать, то самое худшее это молчать и думать у себя в голове.</p>
  <p>Хороший интервьюер вытащит тебя из этого состояния. Плохой интервьюер будет молчать вместе с тобой. И через 40 минут скажет - ну, до свидания.</p>
  <p>Второй skill это как ты придумываешь решение. Оценивается сколько времени заняло придумывание, как обосновывал решение, были ли подсказки.</p>
  <p>Во-первый не нужно молчать. Придумывать решение нужно вслух. Но нужно заранее знать чем можно оперировать. Что вообще можно произносить вслух. Оценивается сколько времени заняло придумывание решения. Это не написание кода, это просто идея. Рассказать как решается.</p>
  <p>Про качество кода. Если ты пишешь очень понятный код. И интервьюеру будет сразу понятно что этот код делает. И он будет похож на эталонное решение</p>
  <p>Последний этам ошибки и их исправление. Интервьюер обычно любит спросить - ты уверен в своем решении? Чтобы быть уверенным в своем решении нужно выполнить два пункта</p>
  <p>1. Перед тем как сдавать свое решение проверь синтаксис.</p>
  <p>2. После проверки синтаксиса, пройдись по своему коду второй раз и проверь логику работы</p>
</article>


<!-- Задача 3. Two Sum -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача 3. Two Sum</h3>

  <p>Например, задача. Дан массив чисел nums = [4,4] и число target = 8. Нужно вернуть true если в массиве есть два числа, дающие в сумме 8. Да, это знаменитая Two Sum.</p>
  <p>С чего нужно начинать решение. Когда приходит условие задачи, первое что нужно сделать это уточнить условие. Эту задачу можно решить четырьмя способами. И чтобы выбрать способ правильно, нужно уточнить условие. Пример из задачи мало что говорит. Нужно уточнить отсортирован ли массив.</p>
  <p>Если массив отсортирован, то решать можно <strong>паттерном два указателя с двух сторон</strong>. Ставятся два указателя на первый и последний элемент. Если их сумма больше target, то сумму нужно уменьшать. Для этого двигаем правый указатель в лево. Потому что если будем двигать левый указатель вправо, то сумма будет увеличиваться. Подвинули правый указатель и если сумма меньше target, то сумму надо увеличивать. Для этого двигаем левый указатель вправо. Сложность по времени O(N) потому что в худшем случае мы посмотрим один раз на каждый элемент. Сложность по памяти O(1)</p>
  <code>nums = [1,2,7,13,18]; target = 15;</code>
  <code>true</code>

  <p>Если массив неотсортирован, то решать можно <strong>паттерном хеш-таблица</strong>. Первый элемент кладем как ключ в хеш таблицу. Берем каждый следующий элемент nums[i] и проверяем если target-nums[i] есть в хеш-таблице. Если нет , то добавляем элемент в хеш таблицу. Если есть, то значит есть два числа, которые в сумме дают target и можно вернуть true. Сложность по времени O(N). Сложность по памяти O(N) потому что мы создаем еще одну структуру данных, в которой в худшем случае будет N элементов</p>
  <code>nums = [7,13,6,5]; target = 18;</code>
  <code>true</code>
</article>


<!-- Два указателя -->
<article class="article">
  <div class="anchor" id="point"></div>
  <h3>Два указателя</h3>

  <p><strong>Паттерн два указателя</strong> можно разделить на 3 группы</p>
  <ol>
    <li>
      <h4>Паттерн с двух сторон</h4>
      <p>Можно применить к массиву. Заводим две переменные pl и pr для левого и правого указателя. Левый ставим на начало массива, а правый - на конец. Сравниваем элементы массива, на которые указывают указатели. На основе некоторого условия выбираем элемент, например для формирования нового массива. Двигаем левый указатель вправо или правый влево. Указатели двигаем друг к другу пока они не встретятся.</p>
    </li>
    <li>
      <h4>Паттерн каждому по указателю</h4>
      <p>Можно применить к двум массивам. Заводим две переменные p1 и p2 для первого и второго указателя. Первый ставим на начало первого массива, второй - на начало второго. Сравниваем элементы на которые указывают указатели. На основе некоторого условия выбираем элемент, например для формирования нового массива. Двигаем первый или второй указатель вправо к концу массива. Указатель двигается пока не дойдет до конца массива.</p>
    </li>
    <li>
      <h4>Паттерн медленный и быстрый указатели</h4>
      <p>Можно применить к массиву или связному списку. Заведем две переменные ps и pf для медленного и быстрого указателя. Быстрый указатель идет вперед на несколько шагов, пока не найдет подходящий элемент. Медленный идет вперед на один шаг. Выполняется либо сравнение либо перестановка.</p>
    </li>
  </ol>
</article>


<!-- Задача 4. Отсортированный массив в квадрате -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача 4. Отсортированный массив в квадрате</h3>

  <p>Дан массив целых чисел nums, отсортированный в неубывающем порядке. Вернуть массив квадратов каждого числа, отсортированный в неубывающем порядке</p>

  <h4>Пример</h4>
  <code>Input: nums = [-4,-1,0,3,10]</code>
  <code>Output: [0,1,9,16,100]</code>

  <h4>Паттерн два указателя с двух сторон</h4>
  <p>Идея решения. При возведении в квадрат отрицательное число становится положительным. Поэтому самым максимальным числом в результате может стать либо первое либо последнее число исходного массива возведенное в квадрат. Поэтому надо сравнить квадраты первого и последнего числа и максимальный поставить в конец результирующео массива. Потом сдвинуть один указатель и опять сравнить два карайних числа.</p>

  <details>
    <summary>Алгоритм</summary>

    <ol>
      <li>Заведем переменную result для результата. Положим в нее пустой массив</li>
        <code>let result = [];</code>
      <li>Заведем две переменные pl и pr для левого и правого указателя. Левый поставим на начало массива, правый - на конец
        <code>let pl = 0, pr = nums.length - 1;</code>
      </li>
      <li>Пройдем циклом пока левый указатель меньше или равен правому
        <code>while (pl &lt;= pr)</code>
      </li>
      <li>Сравним квадраты двух элементов. Если квадрат левого элемент больше, то добавим его в массив res и двигаем левый указатель вправо, иначе записываем квадрат правого элемента и двигаем правый указатель влево</li>
      <li>Получили массив, отсортированный по убыванию. Перевернем массив и вернем результат</li>
    </ol>
    <p>Сложность по времени O(N). Сложность по памяти O(1).</p>
  </details>

  <details>
    <summary>Код на javascript</summary>
<pre>
function sortedSquares(nums) {
  const result = [];
  let pl = 0, pr = nums.length - 1;

  while (pl &lt;= pr) {
    if (Math.abs(nums[pl]) > Math.abs(nums[pr])) {
      result.push(Math.pow(nums[pl], 2));
      pl++;
    } else {
      result.push(Math.pow(nums[pr], 2));
      pr--;
    }
  }
  return result.reverse();
}

console.log(sortedSquares([-4,-1,0,3,10])); // [0,1,9,16,100]
</pre>
  </details>

  <details>
    <summary>Код на python</summary>
<pre>
class Solution:
  def sortedSquares(self, nums: List(int)) -> List(int):
    result = []
    pl = 0
    pr = len(nums) - 1

    while pl &lt;= pr:
      if abs(nums[pl]) > abs(nums[pr]):
        result.append(nums[pl] ** 2)
        pl += 1
      else:
        result.append(nums[pr] ** 2)
        pr -= 1

    return reversed(result)
</pre>
  </details>

  <details>
    <summary>Код на java</summary>
<pre>
class Solution {
  public int[] sortedSquares(int[] nums) {
    int[] result = new int[nums.length];
    int pl = 0;
    int pr = nums.length - 1;
    int index = nums.length - 1;

    while (pl &lt;= pr) {
      if (Math.abs(nums[pl]) > Math.abs(nums[pr])) {
        result[index] = nums[pl] ** 2;
        pl += 1;
      } else {
        result[index] = nums[pr] ** 2;
        pr -= 1;
      }
      index -= 1;
    }

    return result;
  }
}
</pre>
  </details>
</article>


<!-- Задача 5. Общие элементы отсортированных массивов -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача 5. Общие элементы отсортированных массивов</h3>

  <p>Найти пересечение двух отсортированных массивов</p>
  <p>Для двух отсортированных массивов найти все элементы, которые встречаются в обоих массивах и ответ вернуть в отсортированном массиве.</p>

  <h4>Пример</h4>
  <code>Input: nums1 = [2,2,5,8,14,19,29,30]</code>
  <code>nums2 = [-3,0,1,2,2,2,8,19]</code>
  <code>Output: [2,2,8,19]</code>

  <h4>Паттерн два указателя каждому по указателю</h4>

  <details>
    <summary>Алгоритм</summary>

    <ol>
      <li>Заведем переменную res для результата. Положим в нее пустой массив
        <code>const res = [];</code>
      </li>
      <li>Заведем две переменные p1 и p2 для указателей. Поставим первый указатель на первый элемент первого массива, второй - на первый элемент второго.
        <code>let p1 = 0, p2 = 0;</code>
      </li>
      <li>Запустим цикл пока один из указателей не дойдет до конца массива
        <code>while (p1 &lt; a.length || p2 &lt; b.length)</code>
      </li>
      <li>Будем сравнивать два элемента nums[p1] и nums[p2].</li>
      <li>Если они равны, то элемент добавляется массив res и двигаем оба указателя вправо.</li>
      <li>Если не равны, то двигаем вправо указатель на меньшее число.</li>
      <li>Когда один из массивов закончился, выходим из цикла и возвращаем массив res</li>
    </ol>
    <p>Сложность по времени O(n+m). Сложность по памяти O(min(n,m)).</p>
  </details>

    <details>
      <summary>Код на javascript</summary>
<pre>
function intersect(a, b) {
  const res = [];
  let p1 = 0, p2 = 0;

  while (p1 &lt; a.length && p2 &lt; b.length) {
    if (a[p1] > b[p2]) {
      p2++;
    } else if (a[p1] &lt; b[p2]) {
      p1++;
    } else {
      res.push(a[p1]);
      p1++;
      p2++;
    }
  }

  return res;
}

let n1 = [2,2,5,8,14,19,29,30];
let n2 = [-3,0,1,2,2,2,8,19];
console.log(intersect(n1, n2)); // [2,2,8,19]
</pre>
  </details>

  <details>
    <summary>Код на python</summary>
<pre>
class Solution:
  def intersect(self, a, b):
    res = []
    p1 = 0;
    p2 = 0;

  while p1 &lt; len(a) and p2 &lt; len(b):
    if a[p1] > b[p2]:
      p2 += 1
    elif a[p1] &lt; b[p2]:
      p1 += 1
    } else {
      res.append(a[p1]);
      p1 += 1
      p2 += 1

  return res
</pre>
  </details>

  <details>
    <summary>Код на java</summary>
<pre>
public class Solution {
  public int[] intersect(int[] a, int[] b) {
  int p1 = 0;
  int p2 = 0;
  List&lt;Integer&gt; res = new ArrayList&lt;&gt;();

  while (p1 &lt; a.length && p2 &lt; b.length) {
    if (a[p1] > b[p2]) {
      p2++;
    } else if (a[p1] &lt; b[p2]) {
      p1++;
    } else {
      res.add(a[p1]);
      p1++;
      p2++;
    }
  }

  return res.stream().mapToInt(i->i).toArray();
  }
}
</pre>
  </details>
</article>


<!-- Задача 6. Перемещение нулей -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача 6. Перемещение нулей</h3>

  <p>Дан целочисленный массив nums, переместите все нули в его конец, сохранив относительный порядок ненулевых элементов. Сделайте это in-place (на месте), не создавая копию массива</p>

  <h4>Пример</h4>
  <code>Input: nums = [2,0,0,9,3,0,1]</code>
  <code>Output: [2,9,3,1,0,0,0]</code>

  <h4>Пример</h4>
  <code>Input: nums = [2,3,0,9,3,0,1]</code>
  <code>Output: [2,3,9,3,1,0,0]</code>

  <h4>Паттерн два указателя быстрый и медленный</h4>

  <p>Идея решения. Создать быстрый и медленный указатели. Быстрый будет идти первый и искать не нулевой элемент. Медленый будет идти за ним с шагом 1 и указывать куда надо переместить ненулевой элемент. Когда быстрый указатель выходит за пределы массива, то все элементы начиная с медленного указателя должны быть нулями.</p>

  <details>
    <summary>Алгоритм</summary>

    <ol>
      <li>Заведем две переменные ps и pf для медленного и быстрого указателей. Поставим медленный и быстрый указатели на первый элемент массива.
        <code>let ps = 0, pf = 0;</code>
      </li>
      <li>Запустим цикл пока быстрый указатель не дойдет до конца массива
        <code>while (pf &lt; nums.length)</code>
      </li>
      <li>Проверяем условие если быстрый указатель указывает не на ноль, то ставим этот элемент на место медленного указателя и сдвигаем медленный указатель на 1 вправо
<pre>
if(nums[pf] !== 0) {
  nums[ps] = nums[pf];
  ps += 1;
}
</pre>
      </li>
      <li>В любом случае двигаем вправо быстрый указатель
        <code>pf += 1;</code>
      </li>
      <li>Когда быстрый указатель вышел за пределы массива, циклом пройдем по всем элементам массива начиная с медленного указателя и до конца и запишем туда нули
<pre>
while (ps &lt; nums.length) {
  nums[ps] = 0;
  ps += 1;
}
</pre>
      </li>
    </ol>
    <p>Сложность по времени O(N). Сложность по памяти O(1).</p>
  </details>

  <details>
    <summary>Код на javascript</summary>
<pre>
function zeroShift(nums) {
  let ps = 0, pf = 0;

  while (pf &lt; nums.length) {
    if(nums[pf] !== 0) {
      nums[ps] = nums[pf];
      ps += 1;
    }
    pf += 1;
  }

  while (ps &lt; nums.length) {
    nums[ps] = 0;
    ps += 1;
  }
}
</pre>
  </details>
</article>


<!-- Вопросы и ответы -->
<article class="article">
  <div class="anchor" id="qa"></div>
  <h3>Вопросы и ответы</h3>

  <h4>Вопрос</h4>
  <p>Где брать инфу о бэктрекинге?</p>

  <h4>Ответ</h4>
  <p>На leetcode и youtube. Но инфы о бэктрекинге очень мало. Он бывает двух видов рекурсивный и нерекурсивный. И если ты можешь решить без рекурсии, то это показывает что ты разобрался в этой теме.</p>

  <h4>Вопрос</h4>
  <p>Как попасть на собес без опыта?</p>
</article>

