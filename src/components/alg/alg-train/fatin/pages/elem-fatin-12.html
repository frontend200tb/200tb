<h1>Хеш-таблица</h1>


<article class="article">
  <p>Конспект видео от 2024-08-25</p>
  <h4>Хеш-таблица на мемах за 2 часа 30 минут и 9 секунд</h4>

  <p><a href="https://www.youtube.com/@fatin.maksim/videos">youtube Максим Фатин</a></p>
  <p><a href="https://tskills.ru/algo">https://tskills.ru/algo</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p><a href="#about">План на стрим</a></p>
  <p><a href="#hash">Хэш-таблица</a></p>
  <p><a href="#sort">Сортировки</a></p>
  <p><a href="#jun">Хеш-таблица Junior</a></p>
  <p><a href="#task1">Задача 1. Топ К часто встречающихся элементов</a></p>
  <p><a href="#mid">Хеш-таблица Middle</a></p>
  <p><a href="#task2">Задача 2. Изоморфные строки</a></p>
  <p><a href="#sen">Хеш-таблица Senior</a></p>
</article>


<!-- План на стрим -->
<article class="article">
  <div class="anchor" id="about"></div>
  <h3>План на стрим</h3>

  <p>Сегодня у нас разносная программа. Сегодня мы обсуждаем хеш-таблицу. Все знают что такое хеш-таблица, но тем не менее заваливают собеседования. Потому что не могут определить эту хеш-таблицу в задачах. Она там скрывается, не просто в том виде в каком мы привыкли ее видеть. И сегодня мы разберем как ее в задаче распознать.</p>

  <ol>
    <li>На сколько важна хеш-таблица на собесах</li>
    <li>Как сейчас большинство учат хеш-таблицу</li>
    <li>RoadMap для эволюции из эникея в сеньера-помидора хеш-таблиц</li>
    <li>Разбор задачек</li>
    <li>Вопросы и ответы</li>
  </ol>
</article>


<!-- Хэш таблица -->
<article class="article">
  <div class="anchor" id="hash"></div>
  <h3>Хэш таблица</h3>

  <p>Хеш-таблица - это вторая по важности тема на собесах, после массивов. Ее спрашивают везде - ТБанк, Яндекс, Авито, Озон. С этой структурой данных нужно уметь работать везде.</p>
  <p>С хеш-таблицей связаны несколько вопросов</p>

  <ol>
    <li>
      <h4>Операции и их сложность</h4>
      <p>Для элемента в хеш-таблице можно провести любую из следующих операций:</p>
      <ol>
        <li>Поиск</li>
        <li>Получение</li>
        <li>Обновление</li>
        <li>Вставка</li>
        <li>Удаление</li>
      </ol>

      <p>Сложность по времени в среднем за O(1), в худшем случае за O(N).</p>
      <p>Сложность O(1) происходит всегда при <strong>поиске</strong>, <strong>получении</strong> или <strong>обновлении</strong>. Если нет коллизии, то еще и при вставке и удалении.</p>
      <p>Сложность O(N) происходит только при <strong>вставке</strong> или <strong>удалении</strong>, если есть коллизия.</p>

    </li>
    <li>
      <h4>Что под капотом</h4>

      <h4>Что может быть ключем хеш-таблицы</h4>
      <p>Ключем хеш-таблицы может быть все что угодно (число, строка и т.д.). Не comparable type не могут быть ключем. В некоторых языках ключем не могут быть mutable type.</p>
      <h4>Что такое хеш-функция</h4>
      <h4>Что такое коллизия</h4>
      <p>Коллизия это одинаковый результат хеширования разных ключей. Если хеш-таблица заранее выделила себе мало памяти и начали появлятся коллизии (когда разные элементы должны быть записаны в одну ячейку памяти), то происходит релокация (перестроение всей таблицы). Этот процесс по времени и по памяти имеет сложность O(N).</p>
      <p>Обратная ситуации коллизии происходит при удалении. Когда в таблице слишком много места и после удаления становится слишком мало элементов, то происходит оптимизация при которой перестраивается вся таблица. Этот процесс по времени и по памяти имеет сложность O(N).</p>
    </li>
    <li>
      <h4>Count sort (сортировка подсчетом)</h4>
      <p>Используют когда маленькое количество уникальных элементов. Которые распологаются в маленьком диапазоне. А общее число входных данных, состоящих из этих элементов, очень велико.</p>
      <p>Если элементы известны заранее, то можно использовать массив. Например, только две цифры 0 и 1, диапазон чисел от 0 до 9, буквы от a до z. Если элементы неизвестны, то используют словарь.</p>
      <p>В массиве для каждого уникального элемента используем свой индекс. В словаре для каждого уникального элемента используем свой ключ. Изначально значение для каждого ключа будет ноль. Потом пройдемся по входным данным и будем прибавлять 1 к значению ключа каждый раз когда встречается данный элемент.</p>
      <p>Если заранее неизвестно какие элементы на входе. Но известно что их ограниченное количество, то надо использовать не массив, а хеш-таблицу.</p>
    </li>
    <li>
      <h4>Анаграмма</h4>
      <p>Задачи на анаграмму решают <strong>паттерном count sort</strong>. Задачи на анаграмму делятся на три вида:</p>
      <ol>
        <li>Группировка анаграмм</li>
        <li>Поиск анаграмм</li>
        <li>Проверка на анаграмму</li>
      </ol>
    </li>
  </ol>

  <h4>Какие есть проблемы с хеш-таблицей</h4>
  <h4>Junior</h4>
  <ol>
    <li>Не могу понять зачем она вообще нужна</li>
    <li>Как понять, что применять именно хеш-таблицу в задаче</li>
    <li>Непонятно с чего начинать и на сколько глубоко нужно знать тему</li>
  </ol>

  <h4>Middle</h4>
  <ol>
    <li>Не знает о паттернах и на собесе долго может решать простую задачу. Пример <strong>паттерна ключ-количество и количество-ключ</strong></li>
    <li>Не может подобрать эффективно индекс для БД, не знает про индексы для эффективной фильтрации</li>
  </ol>

  <h4>Senior</h4>
  <ol>
    <li>Не знает как делать битовые оптимизации при работе с хеш-таблицей и не может глубоко погружаться в детали на собесе</li>
    <li>Знает как решать почти все задачи на собесе, но тратит много времени из-за незнания паттернов</li>
    <li>Забывает решение задачек</li>
  </ol>
</article>


<!-- Сортировки -->
<article class="article">
  <div class="anchor" id="sort"></div>
  <h3>Сортировки</h3>

  <ol>
    <li>
      <h4>Квадратичные</h4>
      <p>Например, bubble sort, gnome sort</p>
      <p>Сложность во времени O(n<sup>2</sup>)</p>
      <p>Сложность по памяти O(1)</p>
      <p>Есть только один case когда нужна квадратичная сортировка на собесе. Это если нужно что-то сделать без дополнительной памяти и на входе большое количество уникальных элементов.</p>
    </li>
    <li>
      <h4>Логарифмические</h4>
      <p>Например, quick sort, merge sort, team sort</p>
      <p>Сложность по времени O(nlogn)</p>
      <p>Сложность по памяти O(logn)</p>
      <p>В худшем случае сложность по времени O(n<sup>2</sup>) и это зависит от выбора pivot. pivot это опорный элемент вокруг которого будет происходить swap (перестановка)</p>
      <p>В худшем случае сложность по памяти O(n) и это зависит от компаратора</p>
      <p>Используются когда заранее ничего не известно о входных данных - много ли входных данных, сколько уникальных элементов. Они универсальный инструмент.</p>
    </li>
    <li>
      <h4>Сортировка подсчетом</h4>
      <p>Например, count sort</p>
      <p>Сложность по времени O(n)</p>
      <p>Сложность по памяти O(n)</p>
      <p>Применяют только при небольшом количестве уникальных элементов</p>
    </li>
    <li>
      <h4>Сортировка + массив</h4>
      <ol>
        <li>
          <h4>Работа с интервалами</h4>
          <p>Обычно интервалы в задачи приходят не отсортированные. Для того чтобы решить их <strong>паттерном точек</strong>, нужно сначала их отсортировать</p>
        </li>
        <li>
          <h4>Сортировка событий</h4>
          <p>Для событий самая сложная часть задачи это придумать компаратор (то, как сравнивать элементы)</p>
        </li>
      </ol>
    </li>
  </ol>
</article>


<!-- Хеш-таблица Junior -->
<article class="article">
  <div class="anchor" id="jun"></div>
  <h3>Хеш-таблица Junior</h3>

  <h4>База</h4>
  <ul>
    <li>Какие есть операции и их алгоритмическая сложность (лучший/худший случай)</li>
    <li>Что может быть ключом хеш-таблицы</li>
  </ul>

  <h4>Алго-собес</h4>
  <ul>
    <li>Умеет определять базовые задачи где нужна хеш-таблица</li>
    <li>Умеет применять <strong>паттерн ключ-количество и количество ключ</strong></li>
  </ul>

  <h4>На работе</h4>
  <ul>
    <li>Умеет использовать хеш-таблицу в day-to-day задачах</li>
  </ul>
</article>


<!-- Задача 1. Топ К часто встречающихся элементов -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача 1. Топ К часто встречающихся элементов</h3>

  <p>Дан целочисленный массив nums и целое число k, нужно вернуть k наиболее частых элементов. Можно вернуть ответ в любом порядке</p>

  <h4>Пример</h4>
  <code>Input: nums = [5,3,1,5,5,3,7], k = 2</code>
  <code>Output: [5,3]</code>

  <h4>Паттерн ключ-количество, количество-ключ</h4>
  <p>Два прохода по входному массиву. Первый раз проходим по входному массиву и создаем хеш-таблицу. Ключем будет элемент входного массива, а значением - сколько раз он встречается. Второй раз проходим по входному массиву и создаем массив. Индексом массива будет количество из хеш-таблицы, а значением - массив с элементами из входного массива.</p>

  <h4>Идея решения.</h4>
  <p>Перебирать элементы входного массива и для каждого элемента считать сколько раз он встретился. Записывать в славарь (хеш-таблица). Ключем будет элемент, значением - его количество.</p>
  <p>Когда словарь заполнен всеми значениями, создать массив размером n+1. Перебирать элементы входного массива и для каждого элемента брать его значение из словаря. Индексами нового массива будут значения из словаря (количество одинаковых элементов), а значением для каждого ключа будет массив с ключами из первого словаря (сами элементы). Таким образом, мы сделаем замену "ключа-значение" на "значение-ключ"</p>

  <details>
    <summary>Алгоритм</summary>
    <ol>
      <li>Заведем переменную res для массива с результатом
        <code>const res = [];</code>
      </li>
      <li>Заведем переменную dict для словаря, где ключем будет элемент входного массива, а значением - сколько раз он встречается
        <code>const dict = {};</code>
      </li>
      <li>Заведем переменную count для массива размером n+1, где индекс будут значения из словаря, а значением - массив с элементами
        <code>const count = [];</code>
      </li>
      <li>Пройдем циклом по входному массиву
        <code>for (let num of nums)</code>
      </li>
      <li>Если очередного элемента нет в словаре, то добавим его в словарь как ключ со значением 0. Увеличим значение dict[num] на 1
<pre>
if (!(num in dict)) {
  dict[num] = 0;
}
dict[num]++;
</pre>
      </li>
      <li>Когда цикл закончится, закончится и формирование словаря
      </li>
      <li>
        Пройдем циклом по словарю
        <code>for (let num in dict)</code>
      </li>
      <li>Добавим очередной ключ словаря в массив count с индексом равным значению из словаря
<pre>
let freq = dict[num];
count[freq].push(Number(num));
</pre>
      </li>
      <li>Пройдем по массиву count с конца
        <code>for (let i = count.length - 1; i > 0; i--)</code>
      </li>
      <li>Добавим первые k элементов в массив с результатом</li>
    </ol>
    <p>Сложность по времени O(5n) = O(n). Сложность по памяти O(3n) = O(n)</p>
  </details>

  <details>
    <summary>Код на javascript</summary>
<pre>
function topKFrenquent(nums, k) {
  // первый проход по входному массиву
  // создаем словарь
  const count = {};
  for (const num of nums) {
    count[num] = (count[num] || 0) + 1;
  }

  // второй проход по входному массиву
  // создаем массив массивов
  const frequencyList = Array.from({length: nums.length + 1}, () => []);
  for (const num in count) {
    const frequency = count[num];
    frequencyList[frequency].push(Number(num));
  }

  // проходим по массиву массивов
  // формируем результат
  const result = [];
  for (let i = frequencyList.length - 1; i >= 0; i--) {
    for (const num of frequencyList[i]) {
      if (k &lt;= 0) {
        return result;
      }
      result.push(num);
      k--;
    }
  }

  return result;
}
</pre>
  </details>

  <details>
    <summary>Код на python</summary>
<pre>
class Solution:
  def topKFrequent(self, nums: List[int], k: int) -> List[int]:
    // первый проход по входному массиву
    // создаем словарь
    count = {}
    for num in nums:
      if num not in count:
        count[num] = 0
      count[num] += 1

    // второй проход по входному массиву
    // создаем массив массивов
    frequencyList = [[] for _ in range(len(nums) + 1)]
    for num in count:
      frequency = count[num]
      frequencyList[frequency].append(num)

    // проходим по массиву массивов
    // формируем результат
    result = []
    for numsList in reversed(freauencyList):
      for num in numsList:
        if k&lt;= 0:
          return result
        result.append(num)
        k -= 1

    return result
</pre>
  </details>

  <details>
    <summary>Код на go</summary>
<pre>
func topKFrequent(nums []int, k int) []int {
  // первый проход по входному массиву
  // создаем словарь
  count := make(map[int]int)
  for _, num:= range nums {
    count[num] += 1
  }

  // второй проход по входному массиву
  // создаем массив массивов
  frequencyList := make([][]int, len(nums) + 1)
  for num, frequency := range count {
    frequencyList[frequency] = append(frequencyList[frequency], num)
  }

  // проходим по массиву массивов
  // формируем результат
  result := []int{}
  for i := len(freauencyList) - 1; i >= 0; i-- {
    for _, num := range freauencyList[i] {
      if k&lt;= 0 {
        return result
      }
      result = append(result, num)
      k -= 1
    }
  }

  return result
}
</pre>
  </details>

  <details>
    <summary>Код на java</summary>
<pre>
class Solution {
  public int[] topKFrequent(int[] nums, int k) {
    // первый проход по входному массиву
    // создаем словарь
    Map&lt;Integer, Integer&gt; count = new HashMap&lt;&gt;();
    for (int num : nums) {
      count.put(num, count.getOrDefault(num, 0) + 1);
    }

    // второй проход по входному массиву
    // создаем массив массивов
    List&lt;Integer&gt;[] frequencyList = new List[nums.length + 1];
    for (int i = 0; i &lt; frequencyList.length; i++) {
      frequencyList[i] = new ArrayList&lt;&gt;();
    }

    for (int num : count.keySet()) {
      int frequency = count.get(num);
      frequencyList(frequency).add(num);
    }

    // проходим по массиву массивов
    // формируем результат
    List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
    for (int i = freauencyList.length - 1; i >= 0; i--) {
      List&lt;Integer&gt; numsList = frequencyList[i];
      for (int num : numsList) {
        if k&lt;= 0 {
          return result.stream().mapToInt(v -> v).toArray();
        }
        result.add(num);
        k -= 1;
      }
    }

    return result.stream().mapToInt(v -> v).toArray();
  }
}
</pre>
  </details>

  <details>
    <summary>Код на C++</summary>
<pre>
class Solution {
public:
  vector&lt;int&gt; topKFrequent(vector&lt;int&gt; &nums, int k) {
    // первый проход по входному массиву
    // создаем словарь
    unordered_map&lt;int, int&gt; count;
    for (int num : nums) {
      count[num]++;
    }

    // второй проход по входному массиву
    // создаем массив массивов
    vector&lt;vector&lt;int&gt;&gt; frequencyList(nums.size() + 1);
    for (auto& [num, frequency] : count) {
      frequencyList[frequency].push_back(num);
    }

    // проходим по массиву массивов
    // формируем результат
    vector&lt;int&gt; result;
    for (int i = freauencyList.size - 1; i >= 0; i--) {
      for (int num : freauencyList[i]) {
        if k&lt;= 0 {
          return result;
        }
        result.push_back(num);
        k -= 1;
      }
    }

    return result;
  }
}
</pre>
  </details>
</article>


<!-- Хеш-таблица Middle -->
<article class="article">
  <div class="anchor" id="mid"></div>
  <h3>Хеш-таблица Middle</h3>

  <h4>Алго-собес</h4>
  <ul>
    <li>Умеет группировать темы с хеш-таблицей и решает больший диапазон задач</li>
    <li>Знает про изоморфизм строк</li>
    <li>Может написать LRU cache</li>
  </ul>

  <h4>На работе</h4>
  <ul>
    <li>Знает о практике кеширования и о проблеме инвалидации</li>
    <li>Может подобрать политику инвалидации</li>
    <li>Умеет обосновать выбор хеш-индекса для БД</li>
    <li>Знает о bitmap индексе для фильтров</li>
    <li>Знает понятие <strong>кардинальности значений</strong> и его эффекте на больших данных</li>
  </ul>
  <p>Когда мы ищем товар в базе данных магазина и применяем много различных фильтов. Например, с доставкой, с расширенной гарантией, с защитой от перегрева, по цене, по наличию, со скидкой и т.д. Если в фильтрах есть булевые значения. То bitmap index все эти значения хорошо упакует и поиск будет быстрее</p>
</article>


<!-- Задача 2. Изоморфные строки -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача 2. Изоморфные строки</h3>

  <p>Даны две строки s и t, определите, являются ли они изоморфными</p>

  <p>Две строки s и t изоморфны, если символы в s можно заменить, чтобы получить t</p>
  <p>Все вхождения символа должны быть заменены другим символом с сохранением порядка символов. Никакие два символа не могут отображаться в один и тот же символ, но символ может отображаться сам на себя</p>

  <h4>Пример 1</h4>
  <code>Input: s = "abacaba", t = "totxtot"</code>
  <code>Output: true</code>

  <h4>Пример 2</h4>
  <code>Input: s = "foo", t = "bar"</code>
  <code>Output: false</code>

  <h4>Идея решения</h4>
  <p>Для каждой строки заведем свой словарь. И будем запоминать какая буква одной строки соответствует какой букве другой строки. Если какая-то буква не соответствует, то будем возвращать false</p>

  <details>
    <summary>Алгоритм</summary>
    <ol>
      <li>Заведем два словаря dict1 и dict2 для каждой строки
        <code>const dict1 = {}, dict2 = {};</code>
      </li>
      <li>Пройдем циклом по строке
        <code>for (let i = 0; i &lt; s.length; i++)</code>
      </li>
      <li>Заведем две переменные для char1 и char2 для текущего символа каждой строки
        <code>const char1 = s[i]; const char2 = t[i];</code>
      </li>
      <li>Если в первом словаре есть ключ равный символу первой строки, и его значение не равно символу второй строки, вернем false
        <code>if (dict1[char1] && dict1[char1] !== char2) return false;</code>
      </li>
      <li>Если во втором словаре есть ключ равный символу второй строки, и его значение не равно символу первой строки, вернем false
        <code>if (dict2[char2] && dict2[char2] !== char1) return false;</code>
      </li>
      <li>Запишем в первый словарь ключ равный символу первой строки и значение равное символу второй строки
        <code>dict1[char1] = char2;</code>
      </li>
      <li>Запишем во второй словарь ключ равный символу второй строки и значение равное символу первой строки</li>
      <code>dict2[char2] = char1;</code>
      <li>Когда цикл закончится, то вернем true. Все символы совпали значит строки изоморфны</li>
    </ol>
    <p>Сложность по времени O(N). Сложность по памяти O(1)</p>
  </details>

  <details>
    <summary>Код на javascript</summary>
<pre>
function isIsomorhic(s, t) {
  if (s.length !== t.length) {
    return false;
  }
  const dict1 = {}, dict2 = {};

  for (let i = 0; i &lt; s.length; i++) {
    const char1 = s[i];
    const char2 = t[i];

    if (dict1[char1] && dict1[char1] !== char2) {
      return false;
    }
    if (dict2[char2] && dict2[char2] !== char1) {
      return false;
    }
    dict1[char1] = char2;
    dict2[char2] = char1;
  }

  return true;
}
</pre>
  </details>

  <details>
    <summary>Код на python</summary>
<pre>
class Solution:
  def isIsomorhic(self, s: str, t: str) -> bool:
    if len(s) != len(t)
      return False
    dict1, dict2 = {}, {}

    for i in range(len(s)):
      if s[i] in dict1 and dict1[s[i]] !== t[i]:
        return False
      if t[i] in dict2 and dict2[t[i]] !== s[i]:
        return False
      dict1[s[i]] = t[i]
      dict2[t[i]] = s[i]

    return true;
</pre>
  </details>

  <details>
    <summary>Код на go</summary>
<pre>
func isIsomorhic(s string, t string) bool {
  if len(s) != len(t)
    return false
  dict1 := make(map[rune]rune)
  dict2 := make(map[rune]rune)

  for i := 0; i &lt; len(s); i++ {
    char1 := rune(s[i])
    char2 := rune(t[i])

    if val, ok := dict1[char1]; ok && val != char2 {
      return false
    }
    if val, ok := dict2[char2]; ok && val != char1 {
      return false
    }
    dict1[char1] = char2
    dict2[char2] = char1
  }

  return true;
}
</pre>
  </details>

  <details>
    <summary>Код на java</summary>
<pre>
class Solution {
  public boolean isIsomorhic(String s, String t) {
    if (s.length() != t.length()) {
      return false;
    }
    Map&lt;Character, Character&gt; dict1 = new HashMap&lt;&gt;();
    Map&lt;Character, Character&gt; dict2 = new HashMap&lt;&gt;();

    for (int i = 0; i &lt; s.length(); i++) {
      char char1 = s.charAt(i);
      char char2 = t.charAt(i);

      if (dict1.containsKey(char1) && dict1.get(char1) != char2) {
        return false;
      }
      if (dict2.containsKey(char2) && dict2.get(char2) != char1) {
        return false;
      }
      dict1.put(char1, char2);
      dict2.put(char2, char1);
    }

    return true;
  }
}
</pre>
  </details>

  <p>Если в словах используются только малые английские буквы, как в задаче на leetcode, то ее можно решить не словарем а массивом. По таблице ASCII 'a' = 97, 'b' = 98 ... 'z' = 122. Переводим каждый символ строки в число и отнимаем от него 97, чтобы массив начинался с 0 и записываем его в массив. В Питоне ord('a') переводит букву в число, а chr(97) переводит число в букву.</p>
  <p>Если алфавит ограничен, то сложность по памяти будет O(1). В алфавите не более 26 букв не зависимо от длины строки на входе.</p>
</article>


<!-- Хеш-таблица Senior -->
<article class="article">
  <div class="anchor" id="sen"></div>
  <h3>Хеш-таблица Senior</h3>

  <h4>Алго-собес</h4>
  <ul>
    <li>Умеет работать с анаграммами</li>
    <li>Умеет заменять хеш-таблицу на массив</li>
  </ul>

  <h4>На работе</h4>
  <ul>
    <li>Умеет в Key-Value БД (Redis,...)</li>
    <li>Понимает когда вообще в принципе нужно использовать Key-Value БД</li>
  </ul>

  <h4>Финты</h4>
  <ul>
    <li>Может реализовать хеш-таблицу на массивах</li>
    <li>Может реализовать хеш-таблицу на  int-ах</li>
  </ul>
</article>

