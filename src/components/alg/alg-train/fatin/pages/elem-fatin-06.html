<h1>Матрица. Суша и вода</h1>


<article class="article">
  <p>Конспект видео от 2023-12-11</p>
  <h4>Задача Собеседования в Яндекс на 300,000 Рублей (НЕЛЬЗЯ РЕШИТЬ)</h4>

  <p><a href="https://www.youtube.com/@fatin.maksim/videos">youtube Максим Фатин</a></p>
  <p><a href="https://algocode.io/">https://algocode.io/</a></p>
  <p><a href="https://tskills.ru/algo">https://tskills.ru/algo</a></p>
</article>


<article class="article">
  <p>Сегодня мы поговорим о задаче которая может тебе встретиться на собеседовании в Яндекс. И которая может тебе стоить сотни тысяч рублей. Сама задача не сложная. И к концу видео ты разберешься как ее решать.</p>
</article>


<article class="article">
  <h3>Задача. Острова на матрице из суши и воды</h3>

  <p>Дана матрица из единиц и нулей. Где 1 это суша, а 0 это вода. Выглядит как карта. Сколько на такой карте островов?</p>
  <p>Участки суши могут образовывать острова. Участки суши образовывают остров если распологаются на соседних клетках по вертикали или горизонтали. Соседние по диагонали клетки не считаются островом</p>

  <h4>Пример</h4>
<pre>
[
  [0, 0, 1, 0, 0],
  [0, 1, 1, 0, 0],
  [0, 1, 1, 0, 0],
  [0, 0, 0, 1, 1],
  [1, 0, 0, 0, 0]
]
</pre>
  <code>Ответ три острова</code>

  <p>Пример</p>
<pre>
[
  [1, 1, 0, 0, 0],
  [1, 1, 0, 0, 0],
  [0, 0, 1, 0, 0],
  [0, 0, 0, 1, 1],
]
</pre>
  <code>Ответ три острова</code>

  <p>Пример</p>
<pre>
[
  [1, 1],
  [1, 1]
]
</pre>
  <code>Ответ один остров</code>

  <p>Это задача на <strong>поиск в ширину - BFS</strong> и <strong>поиск в глубину - DFS</strong>. Это способы обойти граф. При BFS мы обходим граф равномерно во все стороны. При DFS мы идем по одному пути пока он не закончится, после этого выбираем другое направление.</p>
  <p>Нужно пройтись по всем клеткам суши и помечать их как пройденные (окрашивать). Неважно в ширину или в глубину мы будем идти, важно чтобы в конце все клетки были окрашены.</p>
  <p>При <strong>поиске в глубину - DFS</strong> есть два алгоритма - <strong>рекурсивный</strong> и <strong>итеративный</strong>. При <strong>поиске в ширину - BFS</strong> есть только один алгоритм - <strong>итеративный</strong></p>
  <p>В данной задаче хватит рекурсивной реализации DFS. Лучше взять ее. Она проще в написании. Там меньше кода.</p>
</article>


<article class="article">
  <h3>Решение с помощью DFS</h3>

  <p>Нужно обойти входную матрицу так, чтобы посетить каждую клетку. Начинать можно с любой клетки. Мы начнем с первой. Для этого двумя циклами пройдем по матрице и для каждой клетки будем проверять два условия:</p>
  <ol>
    <li>клетка еще не посещена</li>
    <li>в клетке 1 - суша, а не вода</li>
  </ol>
  <p>Если эти условия выполняются, то будем запускать алгоритм <strong>рекурсивного DFS</strong></p>

  <details>
    <summary>Алгоритм решения с помощью DFS</summary>
    <ol>
      <li>Заведем две переменные для размера матрицы len1 и len2
        <code>let len1 = mat.length; let len2 = mat[0].length;</code>
      </li>
      <li>Заведем дополнительную матрицу used, которая по размеру равна размеру входящей матрицы, для запоминания того что мы вершину посетили (покрасили). Изначально все значения равны false, так как мы ни одну вершину еще не посещали. После посещения вершины, ее значение в матрице used делаем true
<pre>
let used = [];
for (let i = 0; i &lt; len1; i++) {
  used[i] = [];
  for (let j = 0; j &lt; len2; j++) {
    used[i][j] = false;
  }
}
</pre>
      </li>
      <li>Заведем переменную result для результата и присвоим ей значение ноль
        <code>let result = 0;</code>
      </li>
      <li>Начинаем обходить входную матрицу. Будет посещена каждая клетка, начиная с первой</li>
      <li>Пройдем циклом по каждой строке матрицы
        <code>for (let i = 0; i &lt; len1; i++)</code>
      </li>
      <li>Пройдем циклом по каждой клетке текущей строки
        <code>for (let j = 0; j &lt; len2; j++)</code>
      </li>
      <li>Проверяем условие если клетка уже посещена или там вода, то переходим к следующей клетке
        <code>if (used[i][j] || mat[i][j] === 0) {continue;}</code>
      </li>
      <li>Иначе (если пришла 1 - суша и в массиве used стоит false - она еще не посещена), вызываем функцию dfs(), которая сделает поиск в <strong>глубину</strong>
        <code>dfs(i, j, used, mat);</code>
      </li>
      <li>Когда мы закончим обход из одной вершины, то прибавим 1 к числу найденных островов
        <code>result++;</code>
      </li>
      <li>Проходим далее по входному массиву, пока не дойдем до следующей вершины, которая 1 (суша) и в массиве used стоит false (она еще не посещена). Для нее также запустим DFS</li>
    </ol>
    <p>Сложность по времени O(n*m). Сложность по памяти O(n*m). Где n*m размер матрицы.</p>
  </details>

  <details>
    <summary>Решение с помощью DFS (javascript)</summary>
<pre>
function countIslands(mat) {
  let len1 = mat.length;
  let len2 = mat[0].length;
  // создадим матрицу used
  let used = [];
  // заполним матрицу used значением false
  for (let i = 0; i &lt; len1; i++) {
    used[i] = [];
    for (let j = 0; j &lt; len2; j++) {
      used[i][j] = false;
    }
  }
  let result = 0;
  // начинаем обходить входную матрицу
  for (let i = 0; i &lt; len1; i++) {
    for (let j = 0; j &lt; len2; j++) {
      // клетка посещена или там вода
      if (used[i][j] || mat[i][j] === 0) {
        continue;
      }
      // выполняем поиск в глубину
      dfs(i, j, used, mat);
      result++;
    }
  }
  return result;
}
</pre>
  </details>

  <details>
    <summary>Решение с помощью DFS (python)</summary>
<pre>
class Solution:
  def in_bounds(self, i: int, j: int, grid: list[list[str]]) -> bool:
    return 0 &lt;= i &lt; len(grid) and 0 &lt;= j &lt; len(grid[0])

  def numIslands(self, grid: list[list[str]]) -> int:
    used = [[False for _ in range(len(grid[i]))] for i in range(len(grid))]
    result = 0
    for i in range(len(grid)):
      for j in range(len(grid[i])):
        if used[i][j] or grid[i][j] == "0":
          continue
        self.dfs(i, j, used, grid)
        result += 1

    return result
</pre>
  </details>

  <h3>Алгоритм рекурсивного DFS</h3>
  <p>В каком порядке будем обходить вершины в DFS? На самом деле не важно. Мы из каждой вершины сначала попробуем идти вниз, потом влево, потом вверх, потом вправо.</p>
  <p>Когда мы начинаем обход вершин надо делать несколько проверок:</p>
  <ol>
    <li>мы не вышли за границы матрицы</li>
    <li>клетка еще не посещена</li>
    <li>в клетке 1 - суша, а не вода</li>
  </ol>
  <p>Если вершина прошла все проверки, то помечаем ее как посещенную (в массиве used отмечаем true) и идем к следующей вершине. Когда дойдем до вершины из которой мы уже обошли во все четыре стороны, то вернемся в предыдущую вершину. И так пока не дойдем снова до первой вершины с которой мы начали обход.</p>

  <details>
    <summary>Алгоритм рекурсивной функции dfs</summary>
    <p>Напишем функцию dfs() поиска в <strong>глубину</strong>. Функция dfs(x,y,used,mat) принимает на вход текущие координаты клетки, массив used и массив mat.</p>
    <ol>
     <li>Проверим условие если клетка вышла за границы матрицы то выйдем из функции
       <code>if (x &lt; 0 || x >= mat.length || y &lt; 0 || y >= mat[0].length) {return;}</code>
     </li>
     <li>Проверим условие если клетка посещена или там вода то выйдем из функции
       <code>if (used[x][y] || mat[x][y] === 0) {return;}</code>
     </li>
     <li>Помечаем клетку в массиве used как посещенную
       <code>used[x][y] = true;</code>
     </li>
     <li>Зададим сдвиг относительно текущей позиции: вниз x = x + 1, влево y = y - 1, вверх x = x - 1, вправо y = y + 1
       <code>let steps = [[1, 0],[0, -1],[-1, 0],[0, 1]];</code>
     </li>
     <li>Обходим всех соседей. Пройдем циклом по массиву сдвигов
      <code>for(let step of steps)</code>
     </li>
     <li>На каждом сдвиге будем изменять координаты клетки и рекурсивно вызывать функцию dfs()
      <code>let nextX = x + step[0]; let nextY = y + step[1];</code>
      <code>dfs(nextX, nextY, used, mat);</code>
     </li>
    </ol>
  </details>
  <p>Недостаток рекурсивного решения - при большой матрице будет переполнение стека вызовов. Во многих языках программирования ограничение по стеку - 1000. Если встретится остров, в котором больше 1000 участков земли, то будет перемолнение стека.</p>

  <details>
    <summary>Код рекурсивной функции dfs (javascript)</summary>
<pre>
function dfs(x, y, used, mat) {

  // вышли за границы матрицы
  if (x &lt; 0 || x >= mat.length || y &lt; 0 || y >= mat[0].length) {
    return;
  }
  // клетка посещена или там вода
  if (used[x][y] || mat[x][y] === 0) {
    return;
  }

  // помечаем клетку как посещенную
  used[x][y] = true;
  // сдвиг относительно текущей позиции
  let steps = [
    [1, 0],  // вниз   x = x + 1
    [0, -1], // влево  y = y - 1
    [-1, 0], // вверх  x = x - 1
    [0, 1]   // вправо y = y + 1
  ];
  // обходим всех соседей
  for(let step of steps) {
    let nextX = x + step[0];
    let nextY = y + step[1];
    dfs(nextX, nextY, used, mat);
  }
}
</pre>
  </details>

  <details>
    <summary>Код рекурсивной функции dfs (python)</summary>
<pre>
def dfs(self, x: int, y: int, used: list[list[bool]], grid: list[list[str]]):
  // вышли за границы матрицы
  if not self.in_bounds(x, y, grid):
    return
  // клетка посещена или там вода
  if used[x][y] or grid[x][y] == "0":
    return
  // помечаем клетку как посещенную
  used[x][y] = ture
  // зададим направления обхода
  // сдвиг относительно текущей позиции
  steps = [
    [1, 0], // x = x + 1 вниз
    [0, -1], // y = y - 1 влево
    [-1, 0], // x = x - 1 вверх
    [0, 1], // y = y + 1 вправо
  ]
  // обходим всех соседей
  for step in steps:
    nextX = x + step[0]
    nextY = y + step[1]
    self.dfs(nextX, nextY, used, grid)
</pre>
  </details>
</article>


<article class="article">
  <h3>Решение с помощью BFS</h3>

  <p>Пример</p>
<pre>
[
  [0, 0, 0, 1, 1],
  [0, 0, 0, 1, 1],
  [0, 0, 0, 1, 1],
  [1, 1, 1, 0, 0],
  [0, 1, 1, 1, 1]
]
</pre>
  <code>Ответ два острова</code>

  <p>Для DFS используется стек.</p>
  <p>Для BFS используется очередь.</p>
  <p>В этом отличие DFS от BFS.</p>
  <p>Алгоритм начинается также как и для DFS</p>
  <p>Нужно обойти входную матрицу так, чтобы посетить каждую клетку. Начинать можно с любой клетки. Мы начнем с первой. Для этого двумя циклами пройдем по матрице и для каждой клетки будем проверять два условия:</p>
  <ol>
    <li>клетка еще не посещена</li>
    <li>в клетке 1 - суша, а не вода</li>
  </ol>
  <p>Если эти условия выполняются, то будем запускать алгоритм BFS</p>

  <details>
    <summary>Алгорим решения с помощью BFS</summary>
    <ol>
      <li>Заведем две переменные для размера матрицы len1 и len2
        <code>let len1 = mat.length; let len2 = mat[0].length;</code>
      </li>
      <li>Заведем дополнительную матрицу used, которая по размеру равна размеру входящей матрицы, для запоминания того что мы вершину посетили (покрасили). Изначально все значения равны false, так как мы ни одну вершину еще не посещали. После посещения вершины, ее значение в матрице used делаем true
<pre>
let used = [];
for (let i = 0; i &lt; len1; i++) {
  used[i] = [];
  for (let j = 0; j &lt; len2; j++) {
    used[i][j] = false;
  }
}
</pre>
      </li>
      <li>Заведем переменную result для результата и присвоим ей значение ноль
        <code>let result = 0;</code>
      </li>
      <li>Начинаем обходить входную матрицу. Будет посещена каждая клетка, начиная с первой</li>
      <li>Пройдем циклом по каждой строке матрицы
        <code>for (let i = 0; i &lt; len1; i++)</code>
      </li>
      <li>Пройдем циклом по каждой клетке текущей строки
        <code>for (let j = 0; j &lt; len2; j++)</code>
      </li>
      <li>Проверяем условие если клетка уже посещена или там вода, то переходим к следующей клетке
        <code>if (used[i][j] || mat[i][j] === 0) {continue;}</code>
      </li>
      <li>Иначе (если пришла 1 - суша и в массиве used стоит false - она еще не посещена), вызываем функцию bfs(), которая сделает поиск в <strong>ширину</strong>
        <code>bfs(i, j, used, mat);</code>
      </li>
      <li>Когда мы закончим обход из одной вершины, то прибавим 1 к числу найденных островов
        <code>result++;</code>
      </li>
      <li>Проходим далее по входному массиву, пока не дойдем до следующей вершины, которая 1 (суша) и в массиве used стоит false (она еще не посещена). Для нее также запустим BFS</li>
    </ol>
    <p>Сложность по времени O(n*m). Сложность по памяти O(n*m). Где n*m размер матрицы.</p>
  </details>

  <details>
    <summary>Решение с помощью BFS (javascript)</summary>
<pre>
function countIslands(mat) {
  let len1 = mat.length;
  let len2 = mat[0].length;
  // создадим матрицу used
  let used = [];
  // заполним матрицу used значением false
  for (let i = 0; i &lt; len1; i++) {
    used[i] = [];
    for (let j = 0; j &lt; len2; j++) {
      used[i][j] = false;
    }
  }
  let result = 0;
  // начинаем обходить входную матрицу
  for (let i = 0; i &lt; len1; i++) {
    for (let j = 0; j &lt; len2; j++) {
      // клетка посещена или там вода
      if (used[i][j] || mat[i][j] === 0) {
        continue;
      }
      // выполняем поиск в ширину
      bfs(i, j, used, mat);
      result++;
    }
  }
  return result;
}
</pre>
  </details>

  <details>
    <summary>Решение с помощью BFS (python)</summary>
<pre>
class Solution:
  def in_bounds(self, i: int, j: int, grid: list[list[str]]) -> bool:
    return 0 &lt;= i &lt; len(grid) and 0 &lt;= j &lt; len(grid[0])

  def numIslands(self, grid: list[list[str]]) -> int:
    used = [[False for _ in range(len(grid[0]))] for _ in range(len(grid))]
    result = 0
    for i in range(len(grid)):
      for j in range(len(grid[i])):
        if used[i][j] or grid[i][j] == '0':
          continue
        self.bfs(i, j, used, grid)
        result += 1

    return result
</pre>
  </details>

  <h3>Алгоритм BFS</h3>
  <p>Создаем очередь и сразу добавляем пришедший элемент в очередь. Помечаем элемент как посещенный. Пока очередь не пуста выполняем алгоритм. Достаем элемент из очереди. Будем обходить всех его соседей. В каком порядке будем обходить соседей? На самом деле не важно. Мы из каждой вершины сначала попробуем идти вниз, потом влево, потом вверх, потом вправо.</p>
  <p>Когда мы начинаем обход вершин надо делать несколько проверок:</p>
  <ol>
    <li>мы не вышли за границы матрицы</li>
    <li>клетка еще не посещена</li>
    <li>в клетке 1 - суша, а не вода</li>
  </ol>
  <p>Если все три условия выполняются, то помечаем ее как посещенную (в массиве used отмечаем true) и добавляем ее в очередь.</p>
  <p>Когда очередь станет пустой это значит что мы обошли клетку и всех ее соседей. Выходим из алгоритма BFS</p>
  <p>Мы помечаем вершину как посещенную <strong>при добавлении ее в очередь!</strong></p>

  <details>
    <summary>Алгоритм функции bfs</summary>
    <p>Напишем функцию bfs() поиска в <strong>ширину</strong>. Функция bfs(x,y,used,mat) принимает на вход текущие координаты клетки, массив used и массив mat.</p>
    <ol>
      <li>Создаем очередь и сразу добавляем пришедший элемент в очередь
        <code>let q = [[x, y]];</code>
      </li>
      <li>Помечаем элемент как посещенный
        <code>used[x][y] = true;</code>
      </li>
      <li>Пока очередь не пуста выполняем алгоритм
        <code>while (q.length > 0)</code>
      </li>
      <li>Достаем элемент из очереди
        <code>[x, y] = q.shift();</code>
      </li>
      <li>Зададим сдвиг относительно текущей позиции: вниз x = x + 1, влево y = y - 1, вверх x = x - 1, вправо y = y + 1
        <code>let steps = [[1, 0],[0, -1],[-1, 0],[0, 1]];</code>
      </li>
      <li>Обходим всех соседей. Пройдем циклом по массиву сдвигов
        <code>for(let step of steps)</code>
      </li>
      <li>На каждом сдвиге будем изменять координаты клетки
        <code>let nextX = x + step[0]; let nextY = y + step[1];</code>
      </li>
      <li>Проверим условие если клетка вышла за границы матрицы то перейдем к следующей итерации
        <code>if (x &lt; 0 || x >= mat.length || y &lt; 0 || y >= mat[0].length) {continue;}</code>
      </li>
      <li>Проверим условие если клетка посещена или там вода то перейдем к следующей итерации
        <code>if (used[x][y] || mat[x][y] === 0) {continue;}</code>
      </li>
      <li>Добавляем элемент в очередь
        <code>q.push([nextX, nextY]);</code>
      </li>
      <li>Помечаем клетку в массиве used как посещенную
        <code>used[nextX][nextY] = true;</code>
      </li>
    </ol>
  </details>

  <details>
    <summary>Код функции bfs (javascript)</summary>
<pre>
function bfs(x, y, used, mat) {
  // сразу кладем элемент в очередь
  let q = [[x, y]];

  // помечаем элемент как посещенный
  used[x][y] = true;

  // пока очередь не пуста выполняем алгоритм
  while (q.length > 0) {
    // достаем элемент из очереди
    [x, y] = q.shift();
    // зададим сдвиг относительно текущей позиции
    let steps = [
      [1, 0],  // вниз   x = x + 1
      [0, -1], // влево  y = y - 1
      [-1, 0], // вверх  x = x - 1
      [0, 1]   // вправо y = y + 1
    ];

    // обходим всех соседей
    for(let step of steps) {
      nextX = x + step[0];
      nextY = y + step[1];

      // вышли за границы матрицы
      if (nextX &lt; 0 || nextX >= mat.length || nextY &lt; 0 || nextY >= mat[0].length) {
        continue;
      }
      // клетка посещена или там вода
      if (used[nextX][nextY] || mat[nextX][nextY] === 0) {
        continue;
      }

      // добавляем элемент в очередь
      q.push([nextX, nextY]);
      // помечаем элемент как посещенный
      used[nextX][nextY] = true;
    }
  }
}
</pre>
  </details>

  <details>
    <summary>Код функции bfs (python)</summary>
<pre>
def dfs(self, x: int, y: int, used: list[list[bool]], grid: list[list[str]]):
  // сразу кладем элемент в очередь
  q = deque([(x, y)])

  // помечаем элемент как посещенный
  used[x][y] = True

  // пока очередь не пуста выполняем алгоритм
  while len(q) > 0:

  // достаем элемент из очереди
  x, y = q.popleft();

  // зададим сдвиг относительно текущей позиции
  steps = [
    [1, 0], // x = x + 1 вниз
    [0, -1], // y = y - 1 влево
    [-1, 0], // x = x - 1 вверх
    [0, 1], // y = y + 1 вправо
  ]

  // обходим всех соседей
  for step in steps:
    nextX = x + step[0]
    nextY = y + step[1]
    // вышли за границы матрицы
    if not self.in_bounds(nextX, nextY, grid):
      continue
    // клетка посещена или там вода
    if used[nextX][nextY] or grid[nextX][nextY] == "0":
      continue
    // добавляем элемент в очередь
    q.append([nextX, nextX])
    // помечаем клетку как посещенную
    used[nextX][nextY] = True
</pre>
  </details>
</article>


<article class="article">
  <h3>Решение с помощью итеративного DFS</h3>

  <p>Остается только рассказать как написать нерекурсивный DFS. Как сделать поиск в глубину не рекурсивным, а итеративным, как поиск в ширину. Это очень просто. Нужно взять реализацию функции BFS. Переименовать функцию BFS в DFS. И поменять одну строку.</p>

  <code>[x, y] = q.shift(); // достаем элемент из очереди</code>
  <code>[x, y] = q.pop(); // достаем элемент из очереди</code>

  <p>Единственное чем отличается <strong>поиск в ширину</strong> и <strong>итеративный поиск в глубину</strong> это тем какая <strong>структура данных</strong> используется. Для поиска в ширину мы используем <strong>очередь</strong>, а для поиска в глубину нужно использовать <strong>стек</strong>. В поиске в ширину мы каждый раз забираем первый элемент (из массива, который реализует очередь). В поиске в глубину мы забираем последний элемент (из массива, который реализует стек).</p>

  <details>
    <summary>Решение с помощью DFS (javascript)</summary>
<pre>
function countIslands(mat) {
  let len = mat.length;
  let len2 = mat[0].length;
  // создадим матрицу used
  let used = [];
  // заполним матрицу used значением false
  for (let i = 0; i &lt; len; i++) {
    used[i] = [];
    for (let j = 0; j &lt; len2; j++) {
      used[i][j] = false;
    }
  }
  let result = 0;
  // начинаем обходить входную матрицу
  for (let i = 0; i &lt; len; i++) {
    for (let j = 0; j &lt; len2; j++) {
      // клетка посещена или там вода
      if (used[i][j] || mat[i][j] === 0) {
        continue;
      }
      // выполняем поиск в глубину
      dfs(i, j, used, mat);
      result++;
    }
  }
  return result;
}
</pre>
  </details>

  <details>
    <summary>Код итеративной функции dfs (javascript)</summary>
<pre>
function dfs(x, y, used, mat) {
  // сразу кладем элемент в очередь
  let q = [[x, y]];
  // помечаем элемент как посещенный
  used[x][y] = true;
  // пока очередь не пуста выполняем алгоритм
  while (q.length > 0) {
    // достаем элемент из очереди
    [x, y] = q.pop();
    // сдвиг относительно текущей позиции
    let steps = [
      [1, 0],  // вниз   x = x + 1
      [0, -1], // влево  y = y - 1
      [-1, 0], // вверх  x = x - 1
      [0, 1]   // вправо y = y + 1
    ];
    // обходим всех соседей
    for(let step of steps) {
      nextX = x + step[0];
      nextY = y + step[1];
      // вышли за границы матрицы
      if (nextX &lt; 0 || nextX >= mat.length || nextY &lt; 0 || nextY >= mat[0].length) {
        continue;
      }
      // клетка посещена или там вода
      if (used[nextX][nextY] || mat[nextX][nextY] === 0) {
        continue;
      }
      // добавляем элемент в очередь
      q.push([nextX, nextY]);
      // помечаем элемент как посещенный
      used[nextX][nextY] = true;
    }
  }
}
</pre>
  </details>
  <p><strong>Итеративный поиск в глубину</strong> использует <strong>очередь</strong>, в отличие от <strong>рекурсивного поиска в глубину</strong>, который изспользует <strong>стек</strong>.</p>
</article>
