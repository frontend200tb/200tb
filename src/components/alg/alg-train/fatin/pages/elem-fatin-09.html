<h1>Деревья на собесах</h1>


<article class="article">
  <p>Конспект видео от 2024-04-22</p>
  <h4>Деревья на собесах: подготовка к алгоритмическому интервью (в одну большую компанию)</h4>

  <p><a href="https://www.youtube.com/@fatin.maksim/videos">youtube Максим Фатин</a></p>
  <p><a href="https://algocode.io/">https://algocode.io/</a></p>
  <p><a href="https://tskills.ru/algo">https://tskills.ru/algo</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p><a href="#terms">Терминология</a></p>
  <p><a href="#storage">Хранение дерева</a></p>
  <p><a href="#sobes">Дерево на собеседовании</a></p>
  <p><a href="#traver">Базовые обходы</a></p>
  <ol>
    <li><a href="#bintree1">Preorder</a></li>
    <li><a href="#bintree2">Inorder</a></li>
    <li><a href="#bintree3">Postorder</a></li>
  </ol>
  <p><a href="#level">Обходы по уровням</a></p>
  <ol>
    <li><a href="#bintree5">Level order</a></li>
    <li><a href="#bintree6">Zigzag level order</a></li>
    <li><a href="#bintree7">Вид справа</a></li>
    <li><a href="#bintree8">Вид слева</a></li>
  </ol>
  <p><a href="#equal">Сравнение деревьев</a></p>
  <ol>
    <li><a href="#bintree9">Симметричное дерево</a></li>
    <li><a href="#bintree10">Идентичные деревья</a></li>
  </ol>
  </ol>
  <p><a href="#sobes2">Что еще нужно для собеседования</a></p>
  <p><a href="#quest">Вопросы из зала</a></p>
</article>


<!-- Терминология -->
<article class="article">
  <div class="anchor" id="terms"></div>
  <h3>Терминология</h3>

  <ol>
    <li>Узел (node)</li>
    <li>Родитель (parent). У родителя есть хотя бы один ребенок</li>
    <li>Ребенок (child). У ребенка есть родитель</li>
    <li>Бинарное дерево. Каждый узел имеет не больше чем 2 ребенка</li>
    <li>Лист (leaf). У листьев нет детей</li>
    <li>Корень (root). У корня нет родителя</li>
    <li>Ребро. Соединяет два узла. Родителя и ребенка</li>
    <li>Высота дерева - число ребер от корня до самого удаленного узла</li>
    <li>Поддеревья. Левое и правое. Если у вершины есть дети, значит у нее есть левое и правое поддерево</li>
    <li>Бамбук. Это крайний случай, когда у каждого узла (кроме корня) есть только один родитель и у каждого узла (кроме листа) есть только один ребенок. Дерево вырождается в прямую линию</li>
    <li>Сбалансированное дерево. Высоба левого и правого поддерева различаются не больше, чем на 1. Высота O(logN), где N - числов вершин</li>
    <li>Несбалансированное дерево. Поддеревья имеют разницу высот больше 1</li>
  </ol>
</article>


<!-- Хранение дерева -->
<article class="article">
  <div class="anchor" id="storage"></div>
  <h3>Хранение дерева</h3>

  <p>Дерево можно представить в двух форматах</p>
  <ol>
    <li>Массив</li>
    <li>Структура данных</li>
  </ol>
  <p>В <strong>массиве</strong> корень дерева лежит по индексу 0.</p>
<pre>
     __________
    | _____    |
    ||     |   |
[1, 2, 3, nil, 4, 5, nil]
 0  1  2   3   4  5   6
       ||_________|   |
       |______________|
</pre>
  <p>Дальше индексы массива, где расположены дети определяются по следующей формуле</p>
  <code>i // индекс массива</code>
  <code>2*i + 1 // левый ребенок</code>
  <code>2*i + 2 // правый ребенок</code>

  <p>В <strong>структуре</strong> хранятся значения и указатели на левого и правого ребенка</p>

  <h4>Код структуры (javascript)</h4>
<pre>
class TreeNode {
  constructor(val, left, right) {
    this.val = val;
    this.left = left;
    this.right = right;
  }
}
</pre>

  <h4>Код структуры (go)</h4>
<pre>
type TreeNode struct {
  Val int
  Left *TreeNode
  Right *TreeNode
}
</pre>

  <h3>Дополнительные данные в узлах</h3>
  <p>В узлах могут лежать какие-то дополнительные данные. Например, сумма поддеревьев, но это уже получилось <strong>дерево отрезков</strong>.</p>
<pre>
  class TreeNode {
    constructor(val, left, right) {
      this.val = val;
      this.left = left;
      this.right = right;
      this.sum = this.val + this.left.val + this.right.val;
    }
  }
  </pre>
</article>


<!-- Дерево на собеседовании -->
<article class="article">
  <div class="anchor" id="sobes"></div>
  <h3>Дерево на собеседовании</h3>

  <ol>
    <li>сбалансированное</li>
    <li>уже заранее постноено и с ним нужно что-то сделать</li>
    <li>приходит в виде структуры со ссылками на левого и правого ребенка. массив приходит крайне редко</li>
    <li>дополнительных данных в узлах нет</li>
  </ol>
</article>


<!-- Базовые обходы -->
<article class="article">
  <div class="anchor" id="traver"></div>
  <h3>Базовые обходы</h3>
</article>


<!-- 1. Preorder -->
<article class="article">
  <div class="anchor" id="bintree1"></div>
  <h3>1. Preorder</h3>

  <p>Дан корень бинарного дерева и требуется вернуть массив значений узлов в preorder порядке</p>

  <p>Пример</p>
<pre>
               1
        /             \
       2               5
    /     \         /     \
   3       4       6       7
 /   \   /   \   /   \   /   \
nil nil nil nil nil nil nil nil
</pre>
  <code>[1, 2, 3, 4, 5, 6, 7]</code>
  <p>Эта задача решается рекурсивно. Вначале приходит корень дерева. Добавляем его в массив с ответом [1]. Идем в левое поддерево. Добавляем значение левого ребенка в массив [1, 2]. Идем в левое поддерево. Добавляем значение левого ребенка в массив [1, 2, 3]. Дальше детей нет.</p>
  <p>Возвращаемся к родителю и идем в правое поддерево. Добавляем значение правого ребенка в массив [1, 2, 3, 4]. Дальше детей нет.</p>
  <p>Возвращаемся к ближайшему родителю у которого есть ребенок. Это корень. Идем в правое поддерево. Добавляем значение правого ребенка в массив [1, 2, 3, 4, 5]. Идем в левое поддерево. Добавляем значение [1, 2, 3, 4, 5,6]. Дальше детей нет.</p>
  <p>Возвращаемся к родителю и идем в правое поддерево. Добавляем значение правого ребенка в массив [1, 2, 3, 4, 5, 6, 7]. Возвращаемся к корню. Все вершины добавлены в массив.</p>

  <details>
    <summary>Алгоритм</summary>
    <h4>Функция traversal()</h4>
    <ol>
      <li>Заведем переменную result для результата и запишем в нее пустой массив
        <code>let result = [];</code>
      </li>
      <li>Вызовем функцию preorder, которую мы сейчас напишем, и передадим в нее корень root и пока пустой массив result
        <code>preorder(root, result);</code>
      </li>
    </ol>
    <p>Теперь напишем функцию preorder, которая принимает узел node и массив result с результатом</p>

    <h4>Функция preorder()</h4>
    <ol>
      <li>Если в узле node ничего нет, то это пустой узел и просто выходим из функции, ничего не записывая в ответ
        <code>if (!node) return;</code>
      </li>
      <li>Если в узле node есть значение, то добавляем его в ответ
        <code>result.push(node.val);</code>
      </li>
      <li>Идем в левое поддерево
        <code>preorder(node.left, result);</code>
      </li>
      <li>Идем в правое поддерево
        <code>preorder(node.right, result);</code>
      </li>
    </ol>
  </details>

  <details>
    <summary>Preorder Traversal (javascript)</summary>
<pre>
function traversal(root) {
  let result = [];
  preorder(root, result);

  return result;
}

function preorder(node, result) {
  if (!node) {
    return;
  }

  result.push(node.val);
  preorder(node.left, result);
  preorder(node.right, result);
}
</pre>
  </details>

  <details>
    <summary>Preorder Traversal (go)</summary>
<pre>
func traversal(root *TreeNode) []int {
  var result []int = nil
  preorder(root, &result)

  return result
}

func preorder(node *TreeNode, result *[]int) {
  if node == nil {
    return
  }

  *result = append(*result, node.Val)
  preorder(node.Left, result)
  preorder(node.Right, result)
}
</pre>
  </details>

  <p>Алгоритм preorder</p>
  <ol>
    <li>если nil-вершина, то возвращаемся к родителю</li>
    <li><h4>добавляем значение вершины в ответ</h4></li>
    <li>идем в левого ребенка</li>
    <li>идем в правого ребенка</li>
  </ol>

  <p>Сложность по времени O(N), где N - число вершин</p>
  <p>Сложность по памяти O(N)</p>

  <p>Вопросы</p>
  <ol>
    <li>Обязательно идти сначала влево, а потом вправо? Ответ: Да. В этом смысл обхода.</li>
    <li>А мне разрешат писать рекурсивное решение? Есть ограничение на стекфрейму. Тысяча вершин обязательно вызовит переполнение стека. Решение не самое идеальное, но его хватает.</li>
    <li>Где применяется preorder?</li>
  </ol>
</article>


<!-- 2. Inorder -->
<article class="article">
  <div class="anchor" id="bintree2"></div>
  <h3>2. Inorder</h3>

  <p>Дан корень бинарного дерева и требуется вернуть массив значений узлов в inorder порядке</p>

  <p>Пример</p>
<pre>
               4
        /             \
       2               6
    /     \         /     \
   1       3       5       7
 /   \   /   \   /   \   /   \
nil nil nil nil nil nil nil nil
</pre>
<code>[1, 2, 3, 4, 5, 6, 7]</code>
  <p>Эта задача решается рекурсивно. К нам приходит корень дерева (4). Идем в левое поддерево. Левая вершина (2) не nil, поэтому идем дальше в левое поддерево. Левая вершина (1) не nil. Идем дальше в левое поддерево. Левая вершина nil.</p>
  <p>Возвращаемся к родителю (1) и добавляем значение родителя в массив [1]. Идем в правое поддерево. Правая вершина nil.</p>
  <p>Вовзращаемся к родителю (1). Возвращаемся к родителю (2) и добавляем значение родителя в массив [1, 2]. Идем в правое поддерево. Правая вершина (3) не nil. Идем в левое поддерево. Левая вершина nil.</p>
  <p>Возвращаемся к родителю (3) и добавляем значение родителя в массив [1, 2 ,3].</p>
  <p>Возвращаемся к родителю (2). Возвращаемся к корню (4). Добавляем значение корня в массив [1, 2, 3, 4].</p>

  <details>
    <summary>Алгоритм</summary>
    <h4>Функция traversal()</h4>
    <ol>
      <li>Заведем переменную result для результата и запишем в нее пустой массив
        <code>let result = [];</code>
      </li>
      <li>Вызовем функцию inorder, которую мы сейчас напишем, и передадим в нее корень root и пока пустой массив result
        <code>inorder(root, result);</code>
      </li>
    </ol>
    <p>Теперь напишем функцию inorder, которая принимает узел node и массив result с результатом</p>

    <h4>Функция inorder()</h4>
    <ol>
      <li>Если в узле node ничего нет, то это пустой узел и просто выходим из функции, ничего не записывая в ответ
        <code>if (!node) return;</code>
      </li>
      <li>Если в узле node есть значение, то идем в левое поддерево
        <code>inorder(node.left, result);</code>
      </li>
      <li>Добавляем значение узла в ответ
        <code>result.push(node.val);</code>
      </li>
      <li>Идем в правое поддерево
        <code>inorder(node.right, result);</code>
      </li>
    </ol>
  </details>

  <details>
    <summary>Inorder Traversal (javascript)</summary>
<pre>
function traversal(root) {
  let result = [];
  inorder(root, result);

  return result;
}

function inorder(node, result) {
  if (!node) {
    return;
  }

  inorder(node.left, result);
  result.push(node.val);
  inorder(node.right, result);
}
</pre>
  </details>

  <details>
    <summary>Inorder Traversal (go)</summary>
<pre>
  func traversal(root *TreeNode) []int {
    var result []int = nil
    inorder(root, &result)

    return result
  }

  func inorder(node *TreeNode, result *[]int) {
  if node == nil {
    return
  }

  inorder(node.Left, result)
  *result = append(*result, node.Val)
  inorder(node.Right, result)
}
</pre>
  </details>

<p>Алгоритм</p>
<ol>
  <li>если nil-вершина, то возвращаемся к родителю</li>
  <li>идем в левого ребенка</li>
  <li><h4>добавляем значение вершины в ответ</h4></li>
  <li>идем в правого ребенка</li>
</ol>
</article>


<!-- 3. Postorder -->
<article class="article">
  <div class="anchor" id="bintree3"></div>
  <h3>3. Postorder</h3>

  <p>Дан корень бинарного дерева и требуется вернуть массив значений узлов в postorder порядке</p>

  <p>Пример</p>
<pre>
              7
       /             \
      3               6
   /     \         /     \
  1       2       4       5
 /   \   /   \   /   \   /   \
nil nil nil nil nil nil nil nil
</pre>
  <code>[1, 2, 3, 4, 5, 6, 7]</code>
  <p>Эта задача решается рекурсивно. К нам приходит корень дерева (7). Идем в левое поддерево. Левая вершина (3) не nil, поэтому идем дальше в левое поддерево. Левая вершина (1) не nil. Идем дальше в левое поддерево. Левая вершина nil. Возвращаемся к родителю (1). Идем в правое поддерево. Правая вершина nil. Вовзращаемся к родителю (1) и добавляем значение родителя в массив [1].</p>
  <p>Возвращаемся к родителю (3). Идем в правое поддерево. Правая вершина (2) не nil. Идем в левое поддерево. Левая вершина nil. Возвращаемся к родителю (2) и добавляем значение родителя в массив [1, 2].</p>
  <p>Возвращаемся к родителю (3) и добавляем значение родителя в массив [1, 2, 3]. Возвращаемся к корню (7). Идем в правое поддерево (6).</p>

  <details>
    <summary>Алгоритм</summary>
    <h4>Функция traversal()</h4>
    <ol>
      <li>Заведем переменную result для результата и запишем в нее пустой массив
        <code>let result = [];</code>
      </li>
      <li>Вызовем функцию postorder, которую мы сейчас напишем, и передадим в нее корень root и пока пустой массив result
        <code>postorder(root, result);</code>
      </li>
    </ol>
    <p>Теперь напишем функцию postorder, которая принимает узел node и массив result с результатом</p>

    <h4>Функция postorder()</h4>
    <ol>
      <li>Если в узле node ничего нет, то это пустой узел и просто выходим из функции, ничего не записывая в ответ
        <code>if (!node) return;</code>
      </li>
      <li>Если в узле node есть значение, то идем в левое поддерево
        <code>postorder(node.left, result);</code>
      </li>
      <li>Идем в правое поддерево
        <code>postorder(node.right, result);</code>
      </li>
      <li>Добавляем значение узла в ответ
        <code>result.push(node.val);</code>
      </li>
    </ol>
  </details>

  <details>
    <summary>Postorder Traversal (javascript)</summary>
<pre>
function traversal(root) {
  let result = [];
  postorder(root, result);
  return result;
}

function postorder(node, result) {
  if (!node) {
    return;
  }

  postorder(node.left, result);
  postorder(node.right, result);
  result.push(node.val);
}
</pre>
  </details>

  <details>
    <summary>Postorder Traversal (go)</summary>
<pre>
  func traversal(root *TreeNode) []int {
    var result []int = nil
    postorder(root, &result)

    return result
  }

  func postorder(node *TreeNode, result *[]int) {
  if node == nil {
    return
  }

  postorder(node.Left, result)
  postorder(node.Right, result)
  *result = append(*result, node.Val)
}
</pre>
  </details>

  <p>Алгоритм</p>
  <ol>
    <li>если nil-вершина, то возвращаемся к родителю</li>
    <li>идем в левого ребенка</li>
    <li>идем в правого ребенка</li>
    <li><h4>добавляем значение вершины в ответ</h4></li>
  </ol>

  <h4>Какой обход когда выбирать?</h4>
  <p>Отличия обхода preorder, inorder, postorder -  в разном порядке добавляем вершины в ответ.</p>
  <p>preorder. Встречается очень часто. Например, когда нужно вывести элемента дерева слева направо. Или когда нужно вывести элементы дерева справа налево, для этого нужно поменять рекурсивные вызовы местами - сначала вызвать preorder на правом ребенке, а потом на левом.</p>
  <p>inorder. Встречается редко. Например, когда нужно вывести в отсортированном порядке элементы в двоичном дереве поиска.</p>
  <p>postorder. Встречается очень редко. Например, преподсчет (сумм) для дерева отрезков.</p>

  <h4>Вопрос</h4>
  <p>Когда ты приходишь на интервью. Тебе дают задачу. А ты не понимаешь как ее решать. Не встречал такую задачу. Что делать?</p>

  <h4>Ответ</h4>
  <p>Первый вариант. Называть методы какими ты можешь решать задачи. Говорим вслух: бинарные деревья, два указателя, хеш-мапа наверно не подходит, ее можно использовать в таких-то случаях. Интервьюер может сказать: а почему не подходит? Это указатель на то что можно подумать в эту сторону.</p>
</article>


<!-- Обходы по уровням -->
<article class="article">
  <div class="anchor" id="level"></div>
  <h3>Обходы по уровням</h3>
  <h4>Level order pattern</h4>
</article>


<!-- Level order -->
<article class="article">
  <div class="anchor" id="bintree5"></div>
  <h3>Level order</h3>

  <p>Дан корень бинарного дерева. Нужно обойти дерево слева направо и сверху вниз и вернуть массив вершин каждого уровня</p>

  <p>Пример</p>
<pre>
               3
       /              \
     9                 4
   /   \           /       \
 nil    2         1         8
      /   \     /   \     /   \
     5    nil nil   nil nil   nil
    / \
  nil nil
</pre>
  <code>[[3], [9, 4], [2, 1, 8], [5]]</code>
  <p>Пусть верхний уровень будет нулевой, на нем вершина 3. Потом первый уровень с вершинами 9,4. Потом второй уровень с вершинами 2,1,8. Потом третий уровень с вершиной 5. На каждом уровне идем слева направо и записываем вершины в массив.</p>

  <details>
    <summary>Алгоритм</summary>
    <p>Идея решения. Возьмем preorder обход. Дополнительно будем передавать текущи уровень в нашу рекурсивную функцию. Для ответа заведем двумерный массив. Индексами первого массива будут уровни, а значением для каждогшо индекса первого массива будет массив с вершинами этого уровня.</p>
    <p>Пройдем алгоритм по шагам.</p>
    <ol>
      <li>В первом шаге мы берем корень. В функцию передаем уровень 0 и вершину 3. Функция добавит вершину 3 в массив по индексу 0.</li>
      <li>Второй шаг, из вершины 3 мы идем в вершину 9. В функцию передаем уровень 1 и вершину 9. Функция добавит вершину 9 в массив по индексу 1.</li>
      <li>Третий шаг, из вершины 9 мы идем в вершину nil. В функцию передаем уровень 2 и вершину nil. Функция проверяет что это вершина nil и сразу делает return, ничего не выполняя</li>
      <li>Четвертый шаг, из вершины 9 мы идем в вершину 2. В функцию передаем уровень 2 и вершину 2. Функциия добавит вершину 2 в массив по индексу 2.</li>
      <li>Пятый шаг, из вершины 2 мы идем в вершину 5. В функцию передаем уровень 3 и вершину 5. Функция добавит вершину 5 в массив по индексу 3.</li>
      <li>Из вершины 5 пробуем зайти сначала влево, потом вправо, там будет nil. Потом поднимемся в вершину 2 и пробуем зайти вправо, там будет nil. Потом поднимаемся к корню. Сейчас мы обошли левое поддерево. Теперь идем в правое</li>
      <li>Из вершины 3 идем в вершину 4. И так пока не обойдем правое поддерево. в результате получим двумерный массив с ответом</li>
    </ol>
  </details>

  <details>
    <summary>Код (javascript)</summary>
<pre>
function levelorder(root) {
  let result = [];
  preorder(root, 0, result);

  return result;
}

function preorder(node, level, result) {
  if (!node) {
    return;
  }

  if (result.length === level) {
    result.push([]);
  }

  result[level].push(node.val);
  preorder(node.left, level + 1, result)
  preorder(node.right, level + 1, result)
}
</pre>
  </details>

  <details>
    <summary>Код (go)</summary>
<pre>
func levelorder(root *TreeNode) [][]int {
  var result [][]int
  preorder(root, 0, &result)

  return result
}

func preorder(node *TreeNode, level int, result *[][]int) {
  if node == nil {
    return
  }

  if len(*result) == level {
    *result = append(*result, []int{})
  }

  (*result)[level] = append((*result)[level], node.Val)
  preorder(node.Left, level + 1, result)
  preorder(node.Right, level + 1, result)
}
</pre>
  </details>

  <p>Сложность по времени O(N)</p>
  <p>Сложность по памяти O(N)</p>
</article>


<!-- Zigzag level order -->
<article class="article">
  <div class="anchor" id="bintree6"></div>
  <h3>Zigzag level order</h3>

  <p>Дан корень бинарного дерева. Нужно обойти дерево по зигзагу. Это значит, слева направо, потом справа налево.</p>
  <p>Начинаем с нулевого уровня и каждый уровень меняем направление обхода. Нулевой уровень, где только одна вершина - корень, слева направо, т.е. берем просто эту одну вершину. Первый уровень обходим уже справо налево</p>

  <p>Пример</p>
<pre>
               3
       /              \
     9                 4
   /   \           /       \
 nil    2         1         8
      /   \     /   \     /   \
     5    nil nil   nil nil   nil
    / \
  nil nil
</pre>
  <code>[[3], [4, 9], [2, 1, 8], [5]]</code>

  <p>Идея решения. Запустить Level order. Потом пройтись по результату и на нечетных уровнях делать reverse для массива с вершинами.</p>

  <details>
    <summary>Код (javascript)</summary>
<pre>
function zigzaglevelorder(root) {
  let result = [];
  preorder(root, 0, result);

  for(let i = 0; i &lt; result.length; i++) {
    if(i%2 == 1) {
      result[i].reverse();
    }
  }

  return result;
}

function preorder(node, level, result) {
  if (!node) {
    return;
  }

  if (result.length === level) {
    result.push([]);
  }

  result[level].push(node.val);
  preorder(node.left, level + 1, result)
  preorder(node.right, level + 1, result)
}
</pre>
  </details>

</article>


<!-- Вид справа -->
<article class="article">
  <div class="anchor" id="bintree7"></div>
  <h3>Вид справа</h3>

  <p>Дан корень бинарного дерева. Нужно вернуть массив самых правых вершин дерева на каждом уровне.</p>

  <p>Пример</p>
<pre>
             3
      /              \
    9                 4
  /   \           /       \
nil    2         1         8
     /   \     /   \     /   \
    5    nil nil   nil nil   nil
  /   \
nil   nil
</pre>
  <code>[3, 4, 8, 5]</code>

  <p>Идея решения. Запустить Level order. Но вместо того чтобы в каждом индексе хранить массив, мы будем хранить последний элемент.</p>

  <details>
    <summary>Код (javascript)</summary>
<pre>
function rightSideView(root) {
  let result = [];
  preorder(root, 0, result);

  return result;
}

function preorder(node, level, result) {
  if (!node) {
    return;
  }

  // останется только последнее значение на уровне
  result[level] = node.val;
  preorder(node.left, level + 1, result)
  preorder(node.right, level + 1, result)
}
</pre>
  </details>
</article>


<!-- Вид слева -->
<article class="article">
  <div class="anchor" id="bintree8"></div>
  <h3>Вид слева</h3>

  <p>Дан корень бинарного дерева. Нужно вернуть массив самых левых вершин дерева на каждом уровне.</p>

  <p>Пример</p>
<pre>
             3
      /              \
    9                 4
  /   \           /       \
nil    2         1         8
     /   \     /   \     /   \
    5    nil nil   nil nil   nil
  /   \
nil   nil
</pre>
  <code>[3, 9, 2, 5]</code>

  <p>Идея решения. Запустить Level order. Но вместо того чтобы в каждом индексе хранить массив, мы будем хранить первый элемент.</p>

  <details>
    <summary>Код (javascript)</summary>
<pre>
function leftSideView(root) {
  let result = [];
  preorder(root, 0, result);

  return result;
}

function preorder(node, level, result) {
  if (!node) {
    return;
  }

  // запишется только первое значение на уровне
  if (result[level] == undefined) {
    result[level] = node.val;
  }
  preorder(node.left, level + 1, result)
  preorder(node.right, level + 1, result)
}
</pre>
  </details>
</article>


<!-- Сравнение деревьев -->
<article class="article">
  <div class="anchor" id="equal"></div>
  <h3>Сравнение деревьев</h3>
  <h4>Symmetric tree pattern</h4>
</article>


<!-- Симметричное дерево -->
<article class="article">
  <div class="anchor" id="bintree9"></div>
  <h3>Симметричное дерево</h3>

  <p>Дан корень бинарного дерева. Нужно вернуть true, если дерево симметрично, и false, если несимметрично</p>

  <p>Пример</p>
<pre>
                    5
         /                     \
        2                        2
    /       \                /       \
   4         8              8         4
  / \     /     \         /   \     /   \
nil nil  5       1       1     5  nil   nil
        / \     / \     / \
      nil nil nil nil nil nil
</pre>
  <code>true</code>

  <details>
    <summary>Алгоритм</summary>
    <h4>Алгоритм функции isSymmetric()</h4>
    <ol>
      <li>Из корня дерева передадим левую и правую вершины в функцию isSymmetricSubtree().</li>
    </ol>
    <h4>Алгоритм функции isSymmetricSubtree()</h4>
    <ol>
      <li>Проверяем условие, если одна вершина null а другая нет то все дерево несимметрично.</li>
      <li>Проверяем условие, если вершины не одинаковые то все дерево несимметрично.</li>
      <li>Рекурсивно вызываем два раза функцию isSymmetricSubtree(). Первый раз передаем из левой вершины левого ребенка, из правой правого. Второй раз передаем из левой вершины правого ребенка, из правой левого.</li>
    </ol>

    <p>Сложность по времени O(N)</p>
    <p>Сложность по памяти O(N)</p>
  </details>

  <details>
    <summary>Решение (javascript)</summary>
<pre>
function isSymmetric(root) {
  return isSymmetricSubtree(root.left, root.right);
}

function isSymmetricSubtree(leftNode, rightNode) {
  if (leftNode == null || rightNode == null) {
    return leftNode == null && rightNode == null;
  }

  if (leftNode.val !== rightNode.val) {
    return false;
  }

  return isSymmetricSubtree(leftNode.left, rightNode.right) &&
         isSymmetricSubtree(leftNode.right, rightNode.left);
}
</pre>
  </details>

  <details>
    <summary>Решение (go)</summary>
<pre>
func isSymmetric(root *TreeNode) bool {
  return isSymmetricSubtree(root.Left, rootRight)
}

func isSymmetricSubtree(leftNode *TreeNode, rightNode *TreeNode) bool {
  if (leftNode == nil || rightNode == nil) {
    return leftNode == nil && rightNode == nil
  }

  if (leftNode.Val != rightNode.Val) {
    return false
  }

  return isSymmetricSubtree(leftNode.Left, rightNode.Right) &&
         isSymmetricSubtree(leftNode.Right, rightNode.Left)
}
</pre>
  </details>

</article>


<!-- Идентичные деревья -->
<article class="article">
  <div class="anchor" id="bintree10"></div>
  <h3>Идентичные деревья</h3>

  <p>Даны корни двух бинарных деревьев. Нужно вернуть true, если деревья одинаковые, и false в противном случае</p>

  <p>Пример</p>
<pre>
       1                1
    /     \          /     \
   2       3        2       3
  / \     / \      / \     / \
nil nil nil nil  nil nil nil nil
</pre>
  <code>true</code>

  <details>
    <summary>Алгоритм</summary>
    <h4>Алгоритм функции isSame()</h4>
    <ol>
      <li>Вызываем два раза функцию isSameSubtree(). Первый раз передаем из первой вершины левую вершину и из второй вершины левую вершину. Второй раз передаем из первой вершины правую вершину и из второй вершины правую вершину</li>
    </ol>
    <h4>Алгоритм функции isSameSubtree()</h4>
    <ol>
      <li>Проверяем условие, если одна вершина null а другая нет то все дерево неидентично.</li>
      <li>Проверяем условие, если вершины не одинаковые то все дерево неидентично.</li>
      <li>Рекурсивно вызываем два раза функцию isSameSubtree(). Первый раз передаем из первой вершины левую вершину и из второй вершины левую вершину. Второй раз передаем из первой вершины правую вершину и из второй вершины правую вершину</li>
    </ol>

    <p>Сложность по времени O(N)</p>
    <p>Сложность по памяти O(N)</p>
  </details>

  <details>
    <summary>Решение (javascript)</summary>
<pre>
function isSame(p, q) {
  return isSameSubtree(p.left, q.left) &&
         isSameSubtree(p.right, q.right);
}

function isSameSubtree(p, q) {
  if (p == null || q == null) {
    return p == null && q == null;
  }

  if (p.val !== q.val) {
    return false;
  }

  return isSameSubtree(p.left, q.left) &&
         isSameSubtree(p.right, q.right);
}
</pre>
  </details>

  <details>
    <summary>Решение (go)</summary>
<pre>
func isSame(p *TreeNode, q *TreeNode) bool {
  return isSameSubtree(p.left, q.left) &&
         isSameSubTree(p.right, q.right)
}

func isSameSubtree(p *TreeNode, q *TreeNode) bool {
  if (p == nil || q == nil) {
    return p == nil && q == nil
  }

  if (p.Val != q.Val) {
    return false
  }

  return isSameSubtree(p.Left, q.Left) &&
         isSameSubtree(p.Right, q.Right)
}
</pre>
  </details>
</article>


<!-- Что еще нужно для собеседования -->
<article class="article">
  <div class="anchor" id="sobes2"></div>
  <h3>Что еще нужно для собеседования</h3>

  <h4>Поиск суммы в бинарном дереве</h4>
  <p>112. Path Sum</p>
  <p>437. Path Sum III</p>

  <h4>Бинарное дерево поиска (BST)</h4>
  <p>98. Validate Binary Search Tree</p>
</article>


<!-- Вопросы из зала -->
<article class="article">
  <div class="anchor" id="quest"></div>
  <h3>Вопросы из зала</h3>

  <h4>Вопрос</h4>
  <p>Насколько адекватно, что многие компании вводят алгоритмические собесы и ребята после собесов эти алгоритмы не увидят никогда?</p>

  <h4>Ответ</h4>
  <p>Изначально была группа людей из физмата, которым в кайф зарешивать эти задачки. И они решили их спрашивать на собесах. Потому что это быстро и сразу что-то проверяет.</p>

  <h4>Вопрос</h4>
  <p>Было в твоей практике такое что ты писал решение, но приходилось от него отказываться в пользу уже готового решения?</p>

  <h4>Ответ</h4>
  <p>Да было. Я очень люблю сам писать решения. Я думал, раз я знаю алгоритмы, то должен показать всю свою мощь. Когда коллеги смотрели на этот код, они думали "о боже, Макс! Что мы будем делать когда ты уйдешь?". После этого брали готовое решение из библиотеки. Советую всем гуглить и не писать свое решение если решение уже есть.</p>

  <h4>Вопрос</h4>
  <p>На собеседованиях перед тем как решить задачу просят предоставить алгоритм. Что посоветуешь?</p>

  <h4>Ответ</h4>
  <p>Первое что нужно сделать это уточнение ограничений. Пока ты спрашиваешь, в голове уже может появиться идея как решать. Советую эти ограничения всегда записывать.</p>
  <p>Второе, нужно определить точно ли мы поняли условие. Для этого можно привести свои тест-кейсы и в добавок протестировать еще крайние случаи. Если интервьюер говорит: "да, правильно", это значит мы правильно поняли задачу.</p>
  <p>Третье, нужно проговорить идеи решения задачи. И оценить асимптотическую сложность каждого решения. После обсуждения каждой идеи нужно определить какое решение будем использовать и проговорить еще раз и еще раз сказать ее асимпточическую сложность. Если интервьюет молчит, то скорее всего ему идея нравится тогда можно приступать к ее воплощению. Если  интервьюеру идея не нравится. то он тебя остановит уже на этом этапе, а не когда ты уже написал код</p>
  <p>Потом идет написание кода. У меня это самы быстрый этап. Просто потому что я уже не встречаю задач, которые не видел раньше. Я написал код. Я в нем уверен.</p>
  <p>У интервьюера есть шаблонное решение, которое он видит перед собой. И он хочет расслабиться и не напрягаться. И если решения не совпадают, он нервничает, он не понимает работает или не работает. Давайте ему облегчим немножко, возьмем входные данные и прогоним.</p>
  <p>Нужно пройтись по коду используя входные данные и написать значение каждой переменной. Важно не пропускать вообще ничего. После того как убедишься что логика правильная, надо отдельно проверить синтаксис. Сложно проверить одновременно. Поэтому надо отдельно проверять логику и отдельно синтаксис.</p>
  <p>Когда интервьюер увидел, что это работает на каких то входных данных, он думает что это возможно правильное решение. И только после того как он принял решение и сказал что оно правильное, надо представить что этот кусок кода помещается в продакшн. И надо рассказать о всех проблемах этого кода в продакшене.</p>
  <p>Это хорошо когда ты предлагаешь еще какие то идеи как улучшить код. Например сдеать его оптимальным или более понятным.</p>

  <h4>Вопрос</h4>
  <p>На сколько часто на собесах спрашивают сложные алгоритмы на деревьях и на графах? Второй вопрос: насколько часто спрашивают параллельные версии DFS и BFS?</p>

  <h4>Ответ</h4>
  <p>Меня на собеседовании в текущую компанию спрашивали параллельный алгоритм BFS. Они наверное увидели что я работал с параллельными алгоритмами на графе, посмотрели рейтинг на codeforce и решили меня погонять.</p>
  <p>Я думаю, что это спрашивают не часто. Если не говорить что ты занимаешься алгоритмами, то особо не будут спрашивать. Это в российском бигтехе.</p>
  <p>Есть только две компании где могут спросить графы. Я, к сожалению, не могу их назвать. Но одна это очень крупная компания, а вторая китайская. В этих двух компаниях дают два типа задач. Первый - очень сложная. Ее дали джуну. Задача была: найти второй кратчайший путь. Нетривиальная надстройка над Дейкстрой. Джун справился. Но это была самая адовая задача о которой я слышал в российском бигтехе. Все адовые задачи в основном дают джунам. Те кто идут на мидл и синьер они все могут расслабиться и все будет хорошо. Такую жесть не спрашивают.</p>
  <p>Второй тип задач это псевдографы. Либо динамика, либо счетчики. Которые решаются достаточно просто, хотя сформулированы как графы. Единственная задача, которую я бы посмотрел это Count of Islands. Это нахождение компонентов в связанных графах. Методы ее решения DFS, BFS, рекурсивно или нерекурсивно</p>
  <p>Еще есть задача. Приходит точка. И строка с командами типа: влево, вправо и т.д. Если робот выйдет из этой точке по этим командам, надо понять вернется ли он обратно. Если да, то на каких ходах он возвращается.</p>
  <p>Все ограничивается тем насколько шарит в алгоритмах интервьюер. Тех кто очень хорошо разбирается в алгоритмах, их обычно не пускают на интервью или просят не жестить.</p>
  <p>Но если специфичная команда, то зарываться на собесе в алгоритмы можно бесконечно глубоко.</p>

  <h4>Вопрос</h4>
  <p>Как спорить с интервьюером, если мое решение не сходится с его решением на бумажке</p>

  <h4>Ответ</h4>
  <p>Я не во всех компаниях вел алгоритмические собесы. Потому что мне не нравится что мне дают пул задач и я должен следовать ему. Есть регламент. В котором написано: если кандидат написал решение то его не нужно переписывать. Вы должны убедиться что оно работает. В этом случае кандидат должен сказать: я полностью уверен в своем решении, расскажите кейс при котором оно не работает</p>

  <h4>Вопрос</h4>
  <p>Нормально на алгоритмическом собесе сказать что тебе комфортно писать на своем языке? Обычно предлагают только python, который ты должен знать уже по дефолту.</p>

  <h4>Ответ</h4>
  <p>Для компании по дефолту ты должен знать все языки. Каждый раз приходя к рекрутеру спрашиваю - на каком языке можно писать. Я люблю C++, хотя сейчас пишу на go. Я пишу все алгоритмы на нем. Потому что там есть все удобные мне структуры данных. Очень часто ко мне приходит интервьюер, который не знает C++. И так как я до этого прихожу к рекрутеру и спрашиваю а можно я буду писать на C++? Мне говорят можно. Если после этого мне бы сказали давай напишем на питоне. Я бы скзал что у меня есть договоренность что я пишу на C++. Если вам будет что-то непонятно, то всегда можете у меня уточнить. Я вам с радостью расскажу как работает структура данных и на чем она сделана</p>

  <h4>Вопрос</h4>
  <p>Допустим я молодец. Я решил задачку. А они говорят - а сейчас мы будем проводить интервью платформы. Спрашивают у меня платформу. Как к нему готовиться? Как вспомнить все что мне давали в универе про плюсы или что-то еще?</p>

  <h4>Ответ</h4>
  <p>Есть несколько компаний, которые называют эту секцию платформой. Когда готовишься к собеседованию, самое простое, это спросить к чему готовиться. Если не дают никакого материала, то linkedin. Я часто провожу ресерч. Если говорить про найм, то я советую не приходить никогда через просто рекрутера. Лучший случай это когда все тебя знают, вся команда тебя знает и они тебя зовут. Перед этим нужно найти контакты тимлида на linkedin. Попросить у него контакты еще чуваков, пусть они с тобой пообщаются. Потому что тебя нанимают всегда как человека. Попадешь ли ты в компанию определяет только тим лид. Значит ему нужно понравиться. Значит нужно познакомиться с ним как с человеком до того как ты пойдешь к нему на работу. Тогда он будет максимально за тебя топить, максимально хотеть тебя в свою команду и предлагать максимально выгодные условия.</p>

  <h4>Вопрос</h4>
  <p>У самого были случаи когда ты заваливал собеседование?</p>

  <h4>Ответ</h4>
  <p>Да. Один раз. Это был Яндекс. Мой первый собес. Я перед этим олимпиадки нарешал, codeforces. Но по какой-то причине, бинарные деревья я вообще не решал. Я их впервые видел. Их тоже разбирают на олимпиадном программировании, но меня это обошло. И мне дают Validate Binary Search Tree. Я увидел эту задачу и понял, что вообще не имею понятия как ее решать. И меня не могло спасти уже ничего.</p>
  <p>После этого я очень расстроился.</p>
</article>
