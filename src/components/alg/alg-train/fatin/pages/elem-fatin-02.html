<h1>Два указателя</h1>


<!-- links -->
<article class="article">
  <h2>links</h2>

  <p><a href="https://www.youtube.com/@fatin.maksim/videos">youtube Максим Фатин</a></p>
  <p><a href="https://algocode.io/">https://algocode.io/</a></p>
  <p><a href="https://tskills.ru/algo">https://tskills.ru/algo</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p><a href="#point">Два указателя</a></p>
  <ol>
    <li>
      <a href="#point1">С двух сторон</a>
      <p><a href="#point11">1.1 Отсортированный массив в квадрате</a></p>
      <p><a href="#point12">1.2 Палиндром</a></p>
      <p><a href="#point13">1.3 Палиндром сложный</a></p>
      <p><a href="#point14">1.4 Уровень воды</a></p>
      <p><a href="#point15">1.5 Сумма двух чисел в отсортированном массиве</a></p>
    </li>
    <li>
      <a href="#point2">Каждому по указателю</a>
      <p><a href="#point21">2.1 Объединить два неубывающих массива</a></p>
      <p><a href="#point22">2.2 Общие элементы отсортированных массивов</a></p>
    </li>
    <li>
      <a href="#point3">Медленный и быстрый указатели</a>
      <p><a href="#point31">Перемещение нулей</a></p>
    </li>
  </ol>
</article>


<!-- Два указателя -->
<article class="article">
  <div class="anchor" id="point"></div>
  <h3>Два указателя</h3>

  <p>Метод двух указателей можно разделить на 3 группы</p>
  <ol>
    <li>С двух сторон. Например, есть массив. Заводим две переменные pl и pr для два левого и правого указателя. Левый ставим на начало массива, а правый - на конец. Сравниваем элементы массива, на которые указывают указатели. На основе некоторого условия двигаем левый указатель вправо или правый влево. Указатели двигаем друг к другу пока они не встретятся</li>
    <li>Каждому по указателю. Например, есть два массива. Заводим две переменные p1 и p2 для первого и второго указателя. Первый ставим на начало первого массива, второй - на начало второго. Сравниваем элементы на которые указывают указатели. На основе некоторого условия двигаем первый или второй указатель вправо к концу массива. Указатель двигается пока не дойдет до конца массива.</li>
    <li>Медленный и быстрый указатели. Например, есть массив. Заведем две переменные ps и pf для медленного и быстрого указателя.</li>
  </ol>
</article>


<!-- 1. С двух сторон -->
<article class="article">
  <div class="anchor" id="point1"></div>
  <h3>1. С двух сторон</h3>
</article>


<!-- 1.1 Отсортированный массив в квадрате -->
<article class="article">
  <div class="anchor" id="point11"></div>
  <h3>1.1 Отсортированный массив в квадрате</h3>

  <p>Дан массив целых чисел nums, отсортированный в неубывающем порядке. Вернуть массив квадратов каждого числа, отсортированный в неубывающем порядке</p>

  <p>Пример</p>
  <code>Input: nums = [-4,-1,0,3,10]</code>
  <code>Output: [0,1,9,16,100]</code>

  <p>Идея решения. При возведении в квадрат отрицательное число становится положительным. Поэтому самым максимальным числом в результате может стать либо первое либо последнее число исходного массива возведенное в квадрат. Поэтому надо сравнить квадраты первого и последнего числа и максимальный поставить в конец результирующео массива. Потом сдвинуть один указатель и опять сравнить два карайних числа.</p>
  <details>
    <summary>Решение</summary>
    <h4>Алгоритм</h4>
    <ol>
      <li>Заведем переменную res для результата. Положим в нее пустой массив</li>
        <code>let res = [];</code>
      <li>Заведем две переменные pl и pr для левого и правого указателя. Левый поставим на начало массива, правый - на конец
        <code>let pl = 0, pr = nums.length - 1;</code>
      </li>
      <li>Пройдем циклом пока левый указатель меньше или равен правому
        <code>while (pl &lt;= pr)</code>
      </li>
      <li>Сравним квадраты двух элементов. Если квадрат левого элемент больше, то добавим его в массив res и двигаем левый указатель вправо, иначе записываем квадрат правого элемента и двигаем правый указатель влево</li>
      <li>Получили массив, отсортированный по убыванию. Перевернем массив и вернем результат</li>
    </ol>
<pre>
function sortedSquares(nums) {
  const res = [];
  let pl = 0, pr = nums.length - 1;

  while (pl &lt;= pr) {
    if (Math.abs(nums[pl]) > Math.abs(nums[pr])) {
      res.push(Math.pow(nums[pl], 2));
      pl++;
    } else {
      res.push(Math.pow(nums[pr], 2));
      pr--;
    }
  }
  return res.reverse();
}

console.log(sortedSquares([-4,-1,0,3,10])); // [0,1,9,16,100]
</pre>
  </details>
  <p>Сложность по времени O(N). Сложность по памяти O(1).</p>
</article>


<!-- 1.2 Палиндром -->
<article class="article">
  <div class="anchor" id="point12"></div>
  <h3>1.2 Палиндром</h3>

  <p>Проверить является ли строка палиндромом</p>
  <p>Палиндром - это строка, которая читается слева-направо и справа-налево одинаково</p>

  <p>Пример</p>
  <code>isPalindrome('topot'); // true</code>
  <code>isPalindrome('topoot'); // false</code>

  <details>
    <summary>Решение (простое, но не оптимальное)</summary>
    <p>Создать еще одну строку, но перевернутую и сравнить если строки будут равны, значит это палиндром.</p>
    <p>Сложность по времени O(N). Сложность по памяти O(N)</p>
<pre>function isPalindrome(str) {
  let rev = str.split('').reverse().join('');
  return str === rev;
}</pre>
  </details>

  <details>
    <summary>Решение (оптимальное)</summary>
    <p>Метод двух указателей.</p>
    <h4>Алгоритм</h4>
    <ol>
      <li>Заведем две переменные l и r для левого и правого указателей. Левый указатель поставим на первую букву строки. Правый указатель поставим на последнюю букву строки.
        <code>let l = 0, r = str.length - 1;</code>
      </li>
      <li>Запустим цикл пока левый указатель меньше правого
        <code>while (l &lt; r)</code>
      </li>
      <li>Будем сравнивать буквы. Если они не равны, то вернем false
        <code>if (str[l] != str[r]) retirn false;</code>
      </li>
      <li>Если они равны, то сдвинем левый указатель на 1 вправо, правый указатель на 1 влево.
        <code>l++; r--;</code>
      </li>
      <li>Когда левый указатель станет равен или больше правого, вернем true</li>
    </ol>
    <p>Сложность по времени O(N). Сложность по памяти O(1) потому что мы не используем дополнительную развернутую строку</p>

<pre>function isPalindrome(str) {
  let l = 0, r = str.length - 1;
  while (l &lt; r) {
    if (str[l] != str[r]) {
      return false
    }
    l++;
    r--;
  }
  return true;
}</pre>
  </details>
</article>


<!-- 1.3 Палиндром сложный -->
<article class="article">
  <div class="anchor" id="point13"></div>
  <h3>1.3 Палиндром сложный</h3>

  <p>Усложним задачу на палиндром. Во входной строке переведем все символы из верхнего регистра в нижний. Удалим все символы, которые не являются буквами или цифрами</p>

  <p>Пример</p>
  <code>1A,baC AB: a 1 -> 1a,bac ab: a 1 -> 1abacaba1 -> true</code>

  <details>
    <summary>Решение</summary>
    <p>Также воспользуемся двумя указателями, как и в предыдущем случае. Напишем вспомогательную функцию alNum() которая проверяет является ли переданный символ буквой или цифрой. Будем проверять каждый символ и если это не буква или цифра, то переходим к следующему символу. Таким образом, сначала сдвигаем левый указатель до первой буквы или цифры, потом сдвигаем правый указатель до первой буквы или цифры. Потом сравниваем два символа, переведенные в нижний регистр.</p>
    <p>Сложность по времени O(N). Сложность по памяти O(1)</p>

<pre>function isPalindrome(str) {
  let l = 0;
  let r = str.length - 1;
  while (l &lt; r) {
    if (!alNum(str[l])) {
      l++;
      continue;
    }
    if (!alNum(str[r])) {
      r--;
      continue;
    }
    if (str[l].toLowerCase() != str[r].toLowerCase()) {
      return false
    }
    l++;
    r--;
  }
  return true;
}

function alNum(a) {
  let b = a.charCodeAt(0);
  if ( b > 47 &&  b &lt; 58 || b > 64 && b &lt; 91 || b > 96 && b &lt; 123) {
    return true;
  } else {
    return false;
  }
}</pre>
  </details>
</article>


<!-- 1.4 Уровень воды -->
<article class="article">
  <div class="anchor" id="point14"></div>
  <h3>1.4 Уровень воды</h3>

  <p>К нам приходит массив чисел обозначающих высоту линий. Сколько максимум воды поместится между двумя любыми линиями если уровень воды не может превышать высоту линии</p>

  <p>Пример</p>
  <code>maxArea([1, 8, 6, 2, 5, 4, 8, 3, 7]); // 49</code>
  <p>Здесь максимум воды поместится между линиями 1 и 8. Высота линий 8 и 7, значит высота воды равна 7, она не может подняться выше 7 Ширина воды равна 7, так как она между 8 и 1, 8-1=7.</p>
<pre>
  #         #
  #         #   #
  # #       #   #
  # #   #   #   #
  # #   # # #   #
  # #   # # # # #
  # # # # # # # #
#_#_#_#_#_#_#_#_#
1 8 6 2 5 4 8 3 7
0 1 2 3 4 5 6 7 8
</pre>
<p>Если решать переборам и перебрать все пары, то получим квадратичную сложность O(n2) и это не оптимально. Оптимальное решение будет через два указателя.</p>

<details>
  <summary>Решение (оптимальное)</summary>
  <h4>Алгоритм</h4>
  <ol>
    <li>Заведем две переменные l и r для левого и правого указателя. Левый поставим на первый элемент массива, правый - на последний.
      <code>let l = 0, r = arr.length - 1;</code>
    </li>
    <li>Заведем две переменные max и cur. max для ответа, в которой будем хранить максимальную площадь. cur для текущей площади. Сначала там будет 0
      <code>let max = 0, cur = 0;</code>
    </li>
    <li>Запустим цикл пока левый указатель меньше правого
      <code>while (l &lt; r)</code>
    </li>
    <li>Обновляем текущую площадь
      <code>cur = Math.min(arr[l], arr[r]) * (r - l);</code>
    </li>
    <li>В переменную max записываем максимум из cur и max
      <code>max = Math.max(max, curr);</code>
    </li>
    <li>Двигаем указатель, который показывает на меньшую высоту</li>
  </ol>

  <pre>function maxArea(arr) {
  let l = 0, r = arr.length - 1;
  let max = 0, cur = 0;

  while (l &lt; r) {
    cur = Math.min(arr[l], arr[r]) * (r - l);
    max = Math.max(max, cur);
    if (arr[l] > arr[r]) {
      r--;
    } else {
      l++;
    }
  }

  return max;
}</pre>
  </details>
</article>


<!-- 1.5 Сумма двух чисел в отсортированном массиве -->
<article class="article">
  <div class="anchor" id="point15"></div>
  <h3>1.5 Сумма двух чисел в отсортированном массиве</h3>

  <p>Дан отсортированный массив чисел и число. Определить, есть ли в массиве два числа , которые в сумме равны заданному числу</p>

  <p>Пример</p>
  <code>Input: [4,4], target = 8</code>
  <code>Output: true</code>

  <p>Пример</p>
  <code>Input: [1,2,7,13,18], target = 15</code>
  <code>true</code>

  <details>
    <summary>Решение</summary>
    <p>Метод двух указателей</p>
    <h4>Алгоритм</h4>
    <ol>
      <li>Заведем две переменные l и r для левого и правого указателя и зададим им начальные значения - первый и последний индекс массива
        <code>let l = 0, r = nums.length - 1;</code>
      </li>
      <li>Пройдем циклом пока левый указатель меньше правого
        <code>while (l &lt; r)</code>
      </li>
      <li>Проверим сумму чисел на которые указывают указатели. Если сумма равна target, возвращаем true</li>
      <code>if (nums[l] + nums[r] === t)</code>
      <li>Если сумма больше target, двигаем правый указатель влево, если меньше, двигаем левый указатель вправо
        <code>if (nums[l] + nums[r] > t)</code>
      </li>
      <li>Если цикл закончился, значит никакие два числа не дали в сумме target. Возвращаем false</li>
    </ol>
<pre>
function twoSum(nums, t) {
  let l = 0, r = nums.length - 1;

  while (l &lt; r) {
    if (nums[l] + nums[r] === t) {
      return true;
    } else if (nums[l] + nums[r] > t) {
      r--;
    } else {
      l++;
    }
  }
  return false;
}

console.log(twoSum([1, 2, 7, 13, 15, 18, 29], 15)); // true
console.log(twoSum([1, 2, 7, 13, 15, 18, 29], 10)); // false
</pre>
  </details>
  <p>Сложность по времени O(N). Сложность по памяти O(1)</p>

</article>


<!-- 2. Каждому по указателю -->
<article class="article">
  <div class="anchor" id="point2"></div>
  <h3>2. Каждому по указателю</h3>
</article>


<!-- 1. Объединить два неубывающих массива -->
<article class="article">
  <div class="anchor" id="point21"></div>
  <h3>1. Объединить два неубывающих массива</h3>

  <p>Есть два неубывающих массива. Нужно их объединить в один неубывающий массив.</p>
  <p>Неубывающий массив - это массив, в котором значение каждого следующего элемента не меньше предыдущего. В отличие от возрастающего массива он может иметь ещё и равные элементы</p>
  <p>Напишем функцию arrayMerge(a1, a2), которая принимает два неубывающих массива и возвращает один объединенный неубывающий массив</p>

  <p>Примеры</p>
  <code>arrayMerge([-2, 3, 3], [-5, 0]); // [-5, -2, 0, 3, 3]</code>
  <code>arrayMerge([1, 2, 4], [9]); // [1, 2, 4, 9]</code>
  <code>arrayMerge([6], []); // [6]</code>

  <details>
    <summary>Решение (простое, но не оптимальное)</summary>
    <h4>Алгоритм</h4>
    <ol>
      <li>Создадим массив res для результата и положим в него все элементы которые у нас есть
        <code>let res = a1.concat(a2);</code>
      </li>
      <li>Отсортируем массив res
        <code>res.sort((a, b) => a - b);</code>
      </li>
      <li>Вернем результат
        <code>return res;</code>
      </li>
    </ol>

    <p>Оценим сложность по времени и памяти это решение. По времени сложность O(NlogN) - это сложность сортировки. Мы создаем дополнительный массив. Пусть размер первого массива n, а второго - m. Тогда дополнительная память это сумма элементов двух массивов n + m. Сложность по памяти O(n + m)</p>

<pre>function arrayMerge(a1, a2) {
  let res = a1.concat(a2);
  res.sort((a, b) => a - b);
  return res;
}</pre>
  </details>

  <details>
    <summary>Решение (оптимальное)</summary>
    <p>Напишем оптимальное решение. Оптимальное оно будет по времени. По памяти нельзя его улучшить, потому что ответ мы должны все равно отдавать в новом массиве, не изменяя входящие массивы.</p>
    <p>Будем использовать метод двух указателей.</p>
    <h4>Алгоритм</h4>
    <ol>
      <li>Заведем переменную res для результата. Положим в нее пустой массив
        <code>let res = [];</code>
      </li>
      <li>Заведем две переменные p1 и p2 для указателей. Поставим первый указатель на первый элемент первого массива, второй - на первый элемент второго.
        <code>let p1 = 0, p2 = 0;</code>
      </li>
      <li>Заведем две переменные len1 и len2 для длин массивов. Чтобы на каждой итерации не вычислять длину заново. Запишем в len1 длину первого массива, а в len2 - второго
        <code>let len1 = a1.length, len2 = a2.length;</code>
      </li>
      <li>Запустим цикл пока один из указателей не дойдет до конца массива
        <code>while (p1 &lt; len1 || p2 &lt; len2)</code>
      </li>
      <li>На каждой итерации будем выбирать наименьший элемент и добавлять его в результирующий массив. Тот элемент, который мы взяли, тот указатель мы и будем сдвигать. Если один из указателей выходит за пределы массива, то добавляем элементы с другого указателя, пока он тоже не выйдет из массива.</li>
    </ol>
    <p>Сложность по времени O(n + m) поскольку вместо сортировки мы проходим один раз по каждому массиву</p>

<pre>function arrayMerge(a1, a2) {
  let res = [];
  let p1 = 0, p2 = 0;
  let len1 = a1.length, len2 = a2.length;
  while (p1 &lt; len1 || p2 &lt; len2) {
    if (p2 >= len2 || p1 &lt; len1 && a1[p1] &lt;= a2[p2]) {
      res.push(a1[p1]);
      p1++;
    } else {
      res.push(a2[p2]);
      p2++
    }
  }
  return res;
}</pre>
  </details>
</article>


<!-- 2.2 Общие элементы отсортированных массивов -->
<article class="article">
  <div class="anchor" id="point22"></div>
  <h3>2.2 Общие элементы отсортированных массивов</h3>

  <p>Найти пересечение двух отсортированных массивов ИЛИ</p>
  <p>Для двух отсортированных массивов найти все эелементы, которые встречаются в обоих массивах и ответ вернуть в отсортированном массиве.</p>

  <p>Пример</p>
  <code>Input: nums1 = [2,2,5,8,14,19,29,30]</code>
  <code>nums2 = [-3,0,1,2,2,2,8,19]</code>
  <code>Output: [2,2,8,19]</code>

  <details>
    <summary>Решение (оптимальное)</summary>
    <p>Будем использовать метод двух указателей. Паттерн "Каждому по указателю"</p>
    <h4>Алгоритм</h4>
    <ol>
      <li>Заведем переменную res для результата. Положим в нее пустой массив
        <code>const res = [];</code>
      </li>
      <li>Заведем две переменные p1 и p2 для указателей. Поставим первый указатель на первый элемент первого массива, второй - на первый элемент второго.
        <code>let p1 = 0, p2 = 0;</code>
      </li>
      <li>Запустим цикл пока один из указателей не дойдет до конца массива
        <code>while (p1 &lt; a.length || p2 &lt; b.length)</code>
      </li>
      <li>Будем сравнивать два элемента nums[p1] и nums[p2].</li>
      <li>Если они равны, то элемент добавляется массив res и двигаем оба указателя вправо.</li>
      <li>Если не равны, то двигаем вправо указатель на меньшее число.</li>
      <li>Когда один из массивов закончился, выходим из цикла и возвращаем массив res</li>
    </ol>
<pre>
function intersect(a, b) {
  const res = [];
  let p1 = 0, p2 = 0;

  while (p1 &lt; a.length && p2 &lt; b.length) {
    if (a[p1] > b[p2]) {
      p2++;
    } else if (a[p1] &lt; b[p2]) {
      p1++;
    } else {
      res.push(a[p1]);
      p1++;
      p2++;
    }
  }
  return res;
}

let n1 = [2,2,5,8,14,19,29,30];
let n2 = [-3,0,1,2,2,2,8,19];
console.log(intersect(n1, n2)); // [2,2,8,19]
</pre>
  </details>
  <p>Сложность по времени O(n+m). Сложность по памяти O(min(n,m)).</p>
</article>


<!-- 3. Медленный и быстрый указатель -->
<article class="article">
  <div class="anchor" id="point3"></div>
  <h3>3. Медленный и быстрый указатель</h3>
</article>


<!-- 3.1 Перемещение нулей -->
<article class="article">
  <div class="anchor" id="point31"></div>
  <h3>3.1 Перемещение нулей</h3>

  <p>Дан целочисленный массив nums, переместите все нули в его конец, сохранив относительный порядок ненулевых элементов. Сделайте это in-place (на месте), не создавая копию массива</p>

  <p>Пример</p>
  <code>Input: nums = [2,0,0,9,3,0,1]</code>
  <code>Output: [2,9,3,1,0,0,0]</code>

  <p>Пример</p>
  <code>Input: nums = [2,3,0,9,3,0,1]</code>
  <code>Output: [2,3,9,3,1,0,0]</code>

  <p>Идея решения. Создать быстрый и медленный указатели. Быстрый будет идти первый и искать не нулевой элемент. медленый будет идти за ним с шагом 1 и указывать куда надо переместить ненулевой элемент. Когда быстрый указатель выходит за пределы массива, то все элементы начиная с медленного указателя должны быть нулями.</p>

  <p>Сложность по времени O(N). Сложность по памяти O(1).</p>
</article>
