<h1>Паттерн Dummy Node</h1>


<article class="article">
  <p>Конспект видео от 2024-02-06</p>
  <h4>СЕКРЕТНЫй паттерн для АЛГО-собесов</h4>

  <p><a href="https://www.youtube.com/@fatin.maksim/videos">youtube Максим Фатин</a></p>
  <p><a href="https://algocode.io/">https://algocode.io/</a></p>
  <p><a href="https://tskills.ru/algo">https://tskills.ru/algo</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p><a href="#about">Связный список (Linked list)</a></p>
  <p><a href="#dummy">Паттерн Dummy node (фейковый узел)</a></p>
  <p><a href="#task1">Задача 1. Удалить N-ый узел с конца списка</a></p>
  <p><a href="#task2">Задача 2. Объединить два связных списка в возрастающем порядке</a></p>
</article>


<article class="article">
  <div class="anchor" id="about"></div>
  <h3>Связный список (Linked list)</h3>

  <p>Linked list - это структура данных, состоящая из узлов. В узле хранится его значение и указатель на следующий узел</p>

  <p>Пример</p>
  <p>Есть связный список из двух узлов. Первый узел хранит указатель на второй узел. Второй узел хранит указатель на null, потому что это последний узел и третьего узла нет</p>

  <p>На собеседовании нужно самому реализовать поиск длины списка. Пройтись по каждому узлу и посчитать длину всего списка. По времени это O(N).</p>
  <p>Различают односвязный список и двусвязный. В односвязном списке из одной вершины можно идти только в следующую, но не предыдущую</p>

  <p>Пример связного списка</p>
<pre>
class LinkedList {
  constructor(val, next) {
    this.val = val;
    this.next = next;
  }
}</pre>
</article>


<article class="article">
  <div class="anchor" id="dummy"></div>
  <h3>Паттерн Dummy node (фейковый узел)</h3>

  <p><strong>Паттерн Dummy node</strong> упрощает решение для задач со связным списком. Добавим фейковую вершину перед головой списка. Эта фейковая вершина станет новой головой списка, которая будет указывать на настоящую голову. В таком случае, у нас всегда будет предыдущая вершина и удаление первой вершины не будет никаким исключением.</p>
  <p>Паттерн dammy node - это присоединение фейковой вершины к голове списка и используется в двух случаях. Когда мы не хотим делать крайним случаем (corner case) удаление первой вершины. И когда мы не знаем какая из вершин должна быть первой в ответе, то есть не знаем куда цеплять ответ.</p>

  <h4>Список задач на leetcode</h4>
  <p>19. Remove Nth node from end of list</p>
  <p>21. Merge two sorted lists</p>
  <p>23. Merge K sorted lists</p>
</article>


<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача 1. Удалить N-ый узел с конца списка</h3>

  <h4>Leetcode 19. Remove Nth Node From End of List</h4>

  <p>Дана голова связного списка и число N. Нужно удалить N-ый узел с конца. Вернуть получившийся список.</p>
  <p>N-ый узел гарантированно есть. N не может быть больше чем длина самого списка</p>

  <p>Пример</p>
  <code>{1,2,3,4,5}. удалить 2 с конца вершину.</code>
  <code>Ответ {1,2,3,5}</code>

  <p>Есть два популярных решения.</p>

  <h4>Решение 1</h4>
  <p>Пройтись по списку и узнать длину. Зная длину мы можем найти элемент, который находится перед N-ым с конца. Само удаление происходит за счет изменения связи. Чтобы удалить N-ый элемент, нужно в элементе N-1 удалить ссылку на N-ый элемент и поставить ссылку на N+1 элемент.</p>
  <p>А если этот N-ый элемент является головой списка и никаких элементов перед ним нет? Можно отдельно обработать этот corner case, сделать в коде дополнительный if, но гораздо красивее будет если реализовать это с помощью <strong>паттерна Dummy node</strong>.</p>
  <p>Если в вашем языке программирования нет Garbage Collector (например, в языке Си), нужно почистить память для удаленной вершины и для dummy node, так как он больше не нужен.</p>

  <details>
    <summary>Решение 1 (в два прохода)</summary>
<pre>
class ListNode {
  constructor(val, next) {
    this.val = val;
    this.next = next;
  }
}

let list4 = new ListNode(4, null);
let list3 = new ListNode(3, list4);
let list2 = new ListNode(2, list3);
let list = new ListNode(1, list2);

function removeNode(head, n) {
  // добавим фейковый узел перед головой списка
  let dummyNode = new ListNode(0, head);

  // находим длину списка с учетом dummyNode
  let len = 0;
  let curr = dummyNode;
  while(curr) {
    curr = curr.next;
    len++;
  }

  // проверим n
  if (n &lt; 1 || n > len - 1) {
    return 0;
  }

  // доходим до (n-1)-ой вершины с конца
  curr = dummyNode;
  for(let i = 0; i &lt; len - n - 1; i++) {
    curr = curr.next;
  }

  // удаляем вершину
  curr.next = curr.next.next;

  return dummyNode.next;
}

console.log(removeNode(list, 2));
</pre>
  </details>

  <p>В первом решении мы сделали 2 прохода по списку. В первом проходе мы нашли длину. Во втором проходе мы дошли до нужной вершины и сделали само удаление.</p>
  <p>Сложность по времени O(N)</p>
  <p>Сложность по памяти O(1)</p>

  <h4>Решение 2</h4>
  <p>Во втором решении будет один проход, но асимптотика остается такой же. Определять длину списка не будем, поэтому первый проход нам не нужен.</p>
  <p>Добавим два указателя slow и fast. Сначала они указывают на dummyNode, то есть на голову списка. Потом двигаем fast на n+1 узлов вперед, так что slow будет указывать на (n-1)-ый узел от указателя fast. Далее двигаем fast за конец списка. Указатель slow будет показывать на (n-1)-ый узел с конца списка. Совершаем удаление n-ой вершины с конца и возвращаем новый список</p>

  <details>
    <summary>Решение 2 (в один проход)</summary>
<pre>
class ListNode {
  constructor(val, next) {
    this.val = val;
    this.next = next;
  }
}

let list4 = new ListNode(4, null);
let list3 = new ListNode(3, list4);
let list2 = new ListNode(2, list3);
let list = new ListNode(1, list2);

function removeNode(head, n) {
  // добавим фейковый узел перед головой списка
  let dummyNode = new ListNode(0, head);

  // добавим два указателя
  let slow = dummyNode;
  let fast = dummyNode;

  // делаем расстояние n+1 между slow и fast
  for (let i = 0; i &lt; n + 1; i++) {
    fast = fast.next;
  }

  // двигаем указатели, пока fast не выйдет за пределы списка
  while (fast) {
    slow = slow.next;
    fast = fast.next;
  }

  // удаляем вершину
  slow.next = slow.next.next;

  return dummyNode.next;
}

console.log(removeNode(list, 2));
</pre>
  </details>
</article>


<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача 2. Объединить два связных списка в возрастающем порядке</h3>

  <p>Даны два связных списка, которые отсортированы в возрастающем порядке. Вернуть новый список, который содержит все элементы из двух списков и отсортирован в возрастающем порядке.</p>
  <p>Здесь отлично подходит <strong>паттерн dummy node</strong> потому что мы не знаем какая из вершин в первом или во втором списке должна быть первой в ответе. И когда мы не знаем куда крепить ответ, отлично подходит dummy node паттерн. Мы заводим фейковую вершину и к ней будем крепить наш результат. Благодаря этому паттерну исчезают множество if в ваших решениях.</p>

  <p>Пример</p>
  <code>Первый список {1,2,4}, Второй список {1,3,4}</code>
  <code>Output: {1,1,2,3,4,4}</code>

  <details>
    <summary>Решение</summary>
<pre>
class ListNode {
  constructor(val=0, next=null) {
    this.val = val;
    this.next = next;
  }
}

let list13 = new ListNode(4, null);
let list12 = new ListNode(2, list13);
let list11 = new ListNode(1, list12);

let list23 = new ListNode(4, null);
let list22 = new ListNode(3, list23);
let list21 = new ListNode(1, list22);

function getVal(node) {
  if (!node) {
    return Infinity;
  }
  return node.val;
}

function mergeLists(list1, list2) {
  // добавим фейковый узел перед головой списка
  let dummyNode = new ListNode();

  // запишем в ответ фейковый узел
  let curr = dummyNode;

  // пока есть узлы хоть в одном списке
  while (list1 || list2) {
    if (getVal(list1) &lt; getVal(list2)) {
      curr.next = list1;
      list1 = list1.next;
    } else {
      curr.next = list2;
      list2 = list2.next;
    }
    curr = curr.next;
  }

  return dummyNode.next;
}

console.log(mergeLists(list11, list21));
</pre>
  </details>
</article>
