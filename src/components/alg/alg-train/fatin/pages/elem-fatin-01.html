<h1>Задача. Два неубывающих массива</h1>


<article class="article">
  <p>Конспект видео от 2023-08-19</p>
  <h4>Самая ПОПУЛЯРНАЯ задача на собеседовании в АВИТО</h4>

  <p><a href="https://www.youtube.com/@fatin.maksim/videos">youtube Максим Фатин</a></p>
  <p><a href="https://tskills.ru/algo">https://tskills.ru/algo</a></p>
</article>

<article class="article">
  <p>Авито, по моему мнению, один из лучших IT работодателей. Потому что имеет сильный технический бренд и достойную оплату труда</p>

  <h4>Задача. Два неубывающих массива</h4>
  <p>Есть два неубывающих массива. Нужно их объединить в один неубывающий массив.</p>
  <p>Неубывающий массив - это массив, в котором значение каждого следующего элемента не меньше предыдущего. В отличие от возрастающего массива он может иметь ещё и равные элементы</p>

  <p>Примеры</p>
  <code>solve([-2, 3, 3], [-5, 0]); // [-5, -2, 0, 3, 3]</code>
  <code>solve([1, 2, 4], [9]); // [1, 2, 4, 9]</code>
  <code>solve([6], []); // [6]</code>

  <details>
    <summary>Алгоритм</summary>
    <p>Будем использовать паттерн <strong>два указателя - каждому по указателю</strong></p>
    <ol>
      <li>Заведем переменную res для результата. Положим в нее пустой массив
        <code>let res = [];</code>
      </li>
      <li>Заведем две переменные p1 и p2 для указателей. Поставим первый указатель на первый элемент первого массива, второй - на первый элемент второго.
        <code>let p1 = 0, p2 = 0;</code>
      </li>
      <li>Заведем две переменные len1 и len2 для длин массивов. Чтобы на каждой итерации не вычислять длину заново. Запишем в len1 длину первого массива, а в len2 - второго
        <code>let len1 = a1.length, len2 = a2.length;</code>
      </li>
      <li>Запустим цикл пока хотя бы один из указателей еще не дошел до конца массива
        <code>while (p1 &lt; len1 || p2 &lt; len2)</code>
      </li>
      <li>На каждой итерации будем проверять условие. Если второй указатель вышел за границы массива, или если первый указатель не вышел за границы массива и элемент первого массива меньше элемента второго
        <code>if (p2 >= len2 || p1 &lt; len1 && nums1[p1] &lt;= nums2[p2])</code>
      </li>
      <li>Если условие выполняется, то добавим элемент первого указателя в результирующий массив и сдвинем первый указатель
        <code>res.push(nums1[p1]); p1++;</code>
      </li>
      <li>Иначе добавим элемент второго указателя и сдвинем второй указатель
        <code>else {res.push(nums2[p2]); p2++;}</code>
      </li>
    </ol>
    <p>Сложность по времени O(n + m) поскольку мы проходим один раз по каждому массиву</p>
    <p>Сложность по памяти O(n + m) поскольку мы создаем массив для результата размера n + m</p>
  </details>

  <details>
    <summary>Решение (javascript)</summary>
<pre>
function solve(nums1, nums2) {
  let res = [];
  let p1 = 0, p2 = 0;
  let len1 = nums1.length, len2 = nums2.length;

  while (p1 &lt; len1 || p2 &lt; len2) {
    if (p2 >= len2 || p1 &lt; len1 && nums1[p1] &lt;= nums2[p2]) {
      res.push(nums1[p1]);
      p1++;
    } else {
      res.push(nums2[p2]);
      p2++;
    }
  }

  return res;
}
</pre>
  </details>

  <details>
    <summary>Решение (python)</summary>
<pre>
def solve(nums1: list[int], nums2: list[int]) -> list[int]:
  res = []
  p1, p2 = 0, 0
  len1 = len(nums1), len2 = len(nums2)

  while p1 &lt; len1 or p2 &lt; len2:
    if p2 >= len2 or p1 &lt; len1 && nums1[p1] &lt;= nums2[p2]:
      res.append(nums1[p1]);
      p1++;
    else:
      res.append(nums2[p2]);
      p2++

  return res
</pre>
  </details>
</article>
