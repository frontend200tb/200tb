<h1>Задачи от Максима Фатина</h1>


<!-- links -->
<article class="article">
  <h2>links</h2>

  <p><a href="https://www.youtube.com/@fatin.maksim/videos">youtube Максим Фатин</a></p>
  <p><a href="https://algocode.io/">https://algocode.io/</a></p>
  <p><a href="https://tskills.ru/algo">https://tskills.ru/algo</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p><a href="#hash">Хэш-таблица</a></p>
  <ol>
    <li><a href="#hash1">Сумма двух чисел в не отсортированном массиве</a></li>
    <li><a href="#hash2">Топ К часто встречающихся элементов</a></li>
    <li><a href="#hash3">Изоморфные строки</a></li>
    <li><a href="#count">Сортировка подсчетом</a></li>
    <li><a href="#count1">Анаграмма</a></li>
  </ol>
  <p><a href="#bit">Операции с битами</a></p>
  <ol>
    <li><a href="#bit1">Поменять 2 числа местами</a></li>
    <li><a href="#bit2">Число, которое встречается в массиве 1 раз</a></li>
    <li><a href="#bit3">Два числа, которые встречаются в массиве 1 раз</a></li>
  </ol>
  <p><a href="#matrix">Матрица</a></p>
  <ol>
    <li><a href="#matrix1">Сумма чисел на двух диагоналях матрицы</a></li>
  </ol>
  <p><a href="#bfsdfs">Поиск в ширину - BFS и поиск в глубину - DFS</a></p>
  <ol>
    <li><a href="#bfsdfs1">Острова на матрице из суши и воды</a></li>
  </ol>
  <p><a href="#binsearch">Бинарный поиск</a></p>
  <ol>
    <li><a href="#binsearch1">Найти число в отсортированном массиве</a></li>
    <li><a href="#binsearch2">Найти сдвиг в отсортированном массиве со сдвигом</a></li>
    <li><a href="#binsearch3">Найти число в отсортированном массиве со сдвигом</a></li>
  </ol>
  <p><a href="#linkedlist">Связный список (Linked list)</a></p>
  <ol>
    <li><a href="#dummynode">Паттерн Dummy node (фейковый узел)</a></li>
    <li><a href="#linkedlist1">Удалить N-ый узел с конца списка</a></li>
    <li><a href="#linkedlist2">Объединить два связных списка в возрастающем порядке</a></li>
  </ol>
  <p><a href="#stack">Стек, очередь</a></p>
  <p><a href="#sort">Сортировки</a></p>
</article>


<!-- Хэш таблица -->
<article class="article">
  <div class="anchor" id="hash"></div>
  <h3>Хэш таблица</h3>


  <h4>Операции и их сложность</h4>
  <ol>
    <li>Поиск</li>
    <li>Вставка</li>
    <li>Получение</li>
    <li>Удаление</li>
  </ol>
  <p>Сложность по времени в среднем за O(1). Но очень редко, когда перестраивается хеш-таблица за O(N). Если хеш-таблица заранее выделила себе мало памяти и начали появлятся коллизии (когда разные элементы должны быть записаны в одну ячейку памяти), то происходит релокация (перестроение всей таблицы). Этот процесс по времени и по памяти имеет сложность O(N).</p>

  <h4>Что может быть ключем хеш-таблицы</h4>
  <p>Ключем хеш-таблицы может быть все что угодно (число, строка и т.д.). В некоторых языках ключем не могут быть mutable type.</p>

  <h4>Count sort (сортировка подсчетом)</h4>
  <p>Используют когда маленькое количество уникальных элементов</p>
  <p>Если элементы известны заранее, то можно использовать массив. Например, только две цифры 0 и 1, диапазон чисел от 0 до 9, буквы от a до z. Если элементы неизвестны, то используют словарь.</p>

  <h4>Анаграмма</h4>
  <p>Группировка анаграмм</p>
  <p>Поиск анаграмм</p>
  <p>Проверка на анаграмму</p>
</article>


<!-- 1. Сумма двух чисел в не отсортированном массиве -->
<article class="article">
  <div class="anchor" id="hash1"></div>
  <h3>1. Сумма двух чисел в не отсортированном массиве</h3>

  <p>Дан не отсортированный массив чисел и число. Определить, есть ли в массиве два числа , которые в сумме равны заданному числу</p>

  <p>Пример</p>
  <code>Input: [7,13,6,5], target = 18</code>
  <code>Output: true</code>

  <details>
    <summary>Решение</summary>
    <p>Метод хэш таблицы</p>
    <h4>Алгоритм</h4>
    <ol>
      <li>Заведем переменную dict для хранения пар ключ-значение и запишев в нее пустой объект
        <code>let dict = {};</code>
      </li>
      <li>Пройдем циклом по массиву
        <code>for (let i = 0; i &lt; nums.length; i++)</code>
      </li>
      <li>Если разница между target и текущим значением есть в словаре, то возвращаем true
        <code>if (t - nums[i] in dict) return true;</code>
      </li>
      <li>Если нет, то добавляем в словарь текущее значение
        <code>dict[nums[i]] = i;</code>
      </li>
      <li>Если цикл закончился, значит нет двух чисел с нужной суммой. Возвращаем false</li>
    </ol>
<pre>
function twoSum(nums, t) {
  let dict = {};

  for (let i = 0; i &lt; nums.length; i++) {
    if (t - nums[i] in dict) {
      return true;
    } else {
      dict[nums[i]] = i;
    }
  }
  return false;
}

console.log(twoSum([7,13,6,5], 18)); // true
console.log(twoSum([7,13,6,5], 21)); // false
</pre>
  </details>
  <p>Сложность по времени O(N). Сложность по памяти O(N)</p>

</article>


<!-- Паттерн "ключ-значение - значение-ключ" -->
<article class="article">
  <div class="anchor" id="key"></div>
  <h3>Паттерн "ключ-значение - значение-ключ"</h3>
</article>


<!-- 2. Топ К часто встречающихся элементов -->
<article class="article">
  <div class="anchor" id="hash2"></div>
  <h3>2. Топ К часто встречающихся элементов</h3>

  <p>Дан целочисленный массив nums и целое число k, нужно вернуть k наиболее частых элементов. Можно вернуть ответ в любом порядке</p>

  <p>Пример</p>
  <code>Input: nums = [5,3,1,5,5,3,7], k = 2</code>
  <code>Output: [5,3]</code>

  <p>Идея решения. Перебирать элементы и для каждого элемента считать сколько раз он встретился. Записывать в славарь. Ключем будет элемент, значением - его количество. Когда хеш-таблица создана, нужно создать массив размером n+1, где индексами будут значения из словаря (количество одинаковых элементов), а значением для каждого ключа будет массив с ключами из первого словаря (сами элементы). Таким образом, мы сделаем замену "ключа-значение" на "значение-ключ"</p>
  <details>
    <summary>Решение</summary>
    <p>Решение с помощью хещ-таблицы и паттерна "ключ-значение - значение-ключ"</p>
    <h4>Алгоритм</h4>
    <ol>
      <li>Заведем переменную res для массива с результатом
        <code>const res = [];</code>
      </li>
      <li>Заведем переменную dict для словаря, где ключем будет элемент входного массива, а значением - сколько раз он встречается
        <code>const dict = {};</code>
      </li>
      <li>Заведем переменную count для массива размером n+1, где индекс будут значения из словаря, а значением - массив с элементами
        <code>const count = [];</code>
      </li>
      <li>Пройдем циклом по входному массиву
        for (let num of nums)
      </li>
      <li>Если очередного элемента нет в словаре, то добавим его в словарь как ключ со значением 0
        <code>if (!(num in dict)) dict[num] = 0;</code>
      </li>
      <li>Увеличим значение dict[num] на 1</li>
      <li>Когда цикл закончится, закончится и формирование словаря
      </li>
      <li>
        Пройдем циклом по словарю
        <code>for (let num in dict)</code>
      </li>
      <li>Добавим очередной ключ словаря в массив count с индексом равным значению из словаря</li>
      <li>Пройдем по массиву count с конца и добавим первые k элементов в массив с результатом</li>
    </ol>
<pre>
function topKFrenq(nums, k) {
  const res = [];
  // ключ - число
  // значение - сколько раз встретилось
  const dict = {};
  // инекс - сколько раз встретилось число
  // значение - массив чисел, которые встретились столько раз
  const count = [];

  for (let num of nums) {
    if (!(num in dict)) {
      dict[num] = 0;
    }
    dict[num]++;
  }

  for (let num in dict) {
    let freq = dict[num];
    count[freq].push(Number(num));
  }

  for (let i = count.length - 1; i > 0; i--) {
    for (let num of count) {
      if (k &lt;= 0) {
        return res;
      }
      res.push(num);
      k--;
    }
  }
  return res;
}
</pre>
  </details>
</article>


<!-- 3. Изоморфные строки -->
<article class="article">
  <div class="anchor" id="hash3"></div>
  <h3>3. Изоморфные строки</h3>

  <p>Даны две строки s и t, определите, являются ли они изоморфными</p>

  <p>Две строки s и t изоморфны, если символы в s можно заменить, чтобы получить t</p>
  <p>Все вхождения символа должны быть заменены другим символом с сохранением порядка символов. Никакие два символа не могут отображаться в один и тот же символ, но символ может отображаться сам на себя</p>

  <h4>Пример 1</h4>
  <code>Input: s = "abacaba", t = "totxtot"</code>
  <code>Output: true</code>

  <h4>Пример 2</h4>
  <code>Input: s = "foo", t = "bar"</code>
  <code>Output: false</code>

  <p>Идея решения. Для каждой строки заведем свой словарь. И будем запоминать какая буква одной строке соответствует какой букве другой строки. Если какая-то буква не соответствует, то будем возвращать false</p>

  <details>
    <summary>Решение</summary>
    <h4>Алгоритм</h4>
    <ol>
      <li>Заведем два словаря dict1 и dict2 для каждой строки
        <code>const dict1 = {}, dict2 = {};</code>
      </li>
      <li>Пройдем циклом по строке
        <code>for (let i = 0; i &lt; s.length; i++)</code>
      </li>
      <li>Если в первом словаре есть ключ равный символу первой строки, и его значение не равно символу второй строки, вернем false
        <code>if (s[i] in dict1 && dict1[s[i]] !== t[i]) return false;</code>
      </li>
      <li>Если во втором словаре есть ключ равный символу второй строки, и его значение не равно символу первой строки, вернем false
        <code>if (t[i] in dict2 && dict2[t[i]] !== s[i]) return false;</code>
      </li>
      <li>Запишем в первый словарь ключ равный символу первой строки и значение равное символу второй строки</li>
      <li>Запишем во второй словарь ключ равный символу второй строки и значение равное символу первой строки</li>
      <li>Когда цикл закончится, то вернем true. Все символы совпали значит строки изоморфны</li>
    </ol>
<pre>
function isIsomorhic(s, t) {
  const dict1 = {}, dict2 = {};
  // dict1 ключ: символ строки s
  // val: сопоставленный символ строки t
  // dict2 ключ: симовл строки t
  // val: сопоставленный символ строки s

  let p1 = 0, p2 = 0;
  for (let i = 0; i &lt; s.length; i++) {
    if (dict1[s[i]] && dict1[s[i]] !== t[i]) {
      return false;
    }
    if (dict2[t[i]] && dict2[t[i]] !== s[i]) {
      return false;
    }
    dict1[s[i]] = t[i];
    dict2[t[i]] = s[i];
  }

  return true;
}
</pre>
  </details>
  <p>Сложность по времени O(N). Сложность по памяти O(N)</p>
</article>


<!-- Сортировка подсчетом -->
<article class="article">
  <div class="anchor" id="count"></div>
  <h3>Сортировка подсчетом</h3>

  <p>Сортировка подсчетом (count sort). Используется когда входных элементов много, а различных вариантов одного элемента мало. Например в строках используются только английские буквы. Всего 26 английских букв. А сама строка может состоять из тысяч букв.</p>
  <p>Для перевода буквы в число будем использовать ASCII таблицу</p>
  <code>'a' = 97, 'z' = 122</code>
  <p>Создадим массив из 26 элементов и заполним их нулями. Берем по очереди каждую букву строки, вычисляем ее ASCII код, вычитаем ASCII код буквы 'a' и увеличиваем количество букв в массиве с таким кодом на 1</p>
</article>


<!-- 1. Анаграмма -->
<article class="article">
  <div class="anchor" id="count1"></div>
  <h3>1. Анаграмма</h3>

  <p>Даны две строки s и t. Надо проверить является ли одна строка анаграммой другой строки.</p>
  <p>Ограничение: строка содержит только английские буквы в нижнем регистре и ее длина не может превышать 5000 символов</p>
  <p>Анаграмма - слово или фраза, образованная путем перестановки букв другого слова или фразы</p>
  <p>Число различных букв в 2 строках должно совпадать, чтобы одна строка стала анаграммой другой строки</p>

  <p>Примеры</p>
  <code>isAnagram('dog', 'god'); // true</code>
  <code>isAnagram('dog', 'good'); // false</code>

  <details>
    <summary>Решение (простое, но не оптимальное)</summary>
    <p>Отсортировать две строки и сравнить. Если они равны, то возвращаем true (это анаграмма). Если не равны, то возвращаем false.</p>
    <p>Сложность по времени O(NlogN) - это сложность сортировки. Сложность по памяти O(N) поскольку каждую строку переводим в массив, при сортировки массива вернется новый массив</p>

<pre>function isAnagram(s, t) {
  return s.split('').sort().join('') == t.split('').sort().join('');
}</pre>
  </details>

  <details>
    <summary>Решение (оптимальное)</summary>
    <p>Будем использовать метод сортировки подсчетом.</p>
    <p>Сложность по времени O(N) потому что мы должны один раз пройтись по всем элементам массива. Сложность по памяти O(1) потому что количество различных элементов заранее известно (26 английских букв)</p>
    <p>Для перевода буквы в число будем использовать ASCII таблицу</p>
    <code>'a' = 97, ..., 'z' = 122</code>
    <h4>Алгоритм</h4>
    <ol>
      <li>Создадим два массива count1 и count2 из 26 элементов и заполним их нулями. Для подсчета букв первой и второй строки.
        <code>let count1 = Array(26).fill(0);</code>
        <code>let count2 = Array(26).fill(0);</code>
      </li>
      <li>Сначала подсчитываем количество для каждой буквы в первой строке.</li>
      <li>Берем по очереди каждую букву первой строки, вычисляем ее ASCII код, вычитаем ASCII код буквы 'a'. и увеличиваем количество букв в массиве с таким кодом на 1</li>
      <li>Точно также подсчитываем количество для каждой буквы во второй строке</li>
      <li>Сравниваем два массива и возвращаем результат. Чтобы сравнить два массива, переведем каждый из них в строку.</li>
    </ol>

<pre>function isAnagram(s, t) {
  if (s.length !== t.length) {
    return false;
  }

  let count1 = Array(26).fill(0);
  let count2 = Array(26).fill(0);

  for (let i = 0; i &lt; s.length; i++) {
    count1[s.charCodeAt(i) - 97]++;
    count2[t.charCodeAt(i) - 97]++;
  }

  return count1.join() == count2.join();
}</pre>
  </details>
</article>


<!-- Операции с битами -->
<article class="article">
  <div class="anchor" id="bit"></div>
  <h3>Операции с битами</h3>
</article>


<!-- 1. Поменять 2 числа местами -->
<article class="article">
  <div class="anchor" id="bit1"></div>
  <h3>1. Поменять 2 числа местами</h3>

  <p>Пусть в двух x и y записаны два числа. Нужно поменять их местами не используя третью переменную</p>
  <p>Есть два способа сделать это</p>
  <p>Первый способ с помощью сложения и вычитания</p>
<pre>x = x + y;
y = x - y;
x = x - y;
</pre>
  <p>Второй способ с помощью операции XOR (исключающее ИЛИ)</p>
<pre>x = x ^ y;
y = x ^ y;
x = x ^ y;
</pre>
</article>


<!-- 2. Число, которое встречается в массиве 1 раз -->
<article class="article">
  <div class="anchor" id="bit2"></div>
  <h3>2. Число, которое встречается в массиве 1 раз</h3>

  <p>Приходит массив целых чисел. Каждое число встречается 2 раза, кроме одного. Найти это число, которое встречается в массиве один раз.</p>
  <p>Нужно решить за константную память O(1). Независимо от длины массива должно выделяться одинаковое количество дополнительной памяти. Использовать хеш таблицу не получится, потому что она требует O(N) памяти</p>

  <p>Пример</p>
  <code>uniq([2, 2, 1]); // 1</code>
  <code>uniq([4, 1, 2, 1, 2]); // 4</code>
  <code>uniq([2]); // 2</code>

  <details>
    <summary>Решение через XOR</summary>
    <p>Пройдем по массиву чисел и выполним исключающее ИЛИ с каждый элементом. Таким образом две одинаковые цифры при исключающем ИЛИ в результате дадут 0.</p>
    <p>Сложность по времени O(N). Сложность по памяти O(1)</p>
  <pre>function uniq(arr) {
  let result = 0;
  for (let i = 0; i &lt; arr.length; i++) {
    result ^= arr[i];
  }
  return result;
}</pre>
  </details>

  <details>
    <summary>Решение через подсчет бит</summary>
    <p>Заведем массив bitsCount для хранения сумм бит всех чисел.  Пройдем по массиву чисел и каждое число переводим в двоичный формат и каждый бит складываем с битами в bitsCount. Пройдем по массиву bitsCount и для каждого числа вычислим остаток от деления на 2. Получим новый массив, в котором будет наш ответ в двоичном виде.</p>
    <p>Сложность по времени O(N). Сложность по памяти O(1) потому что размер bitsCount равен разрядности чисел во входном массиве и не зависит от числа элементов в массиве.</p>
<pre>function uniq(arr) {
  let bitsCount = Array(32).fill(0);
  for (let num of arr) {
    // делаем + 2 ** 31 чтобы работать с положительными числами
    // и не переводить отрицательные в 2-ю систему счисления
    num = num + 2 ** 31;
    let i = 0;
    while (num != 0) {
      bitsCount[i] += num % 2;
      num = Math.floor(num/2);
      i++;
    }
  }
  let result = 0;
  for (let i = 0; i &lt; bitsCount.length; i++) {
    result = result * 2 + bitsCount[bitsCount.length-1-i] % 2;
  }
  return result - 2 ** 31;
}</pre>
  </details>

  <h4>Решение через подсчет бит является универсальным</h4>
  <p>Изменим условие задачи. Найти число, которое встречается 1 раз, а все остальные числа встречаются ровно 3 раза. В универсальном решении нужно будет изменить только одну строчку.</p>

  <details>
    <summary>Решение через подсчет бит</summary>
    <p>Вместо того чтобы использовать %2 мы теперь будем использовать %3</p>
<pre>function uniq(arr) {
  let bitsCount = Array(32).fill(0);
  for (let num of arr) {
    // делаем + 2 ** 31 чтобы работать с положительными числами
    // и не переводить отрицательные в 2-ю систему счисления
    num = num + 2 ** 31;
    let i = 0;
    while (num != 0) {
      bitsCount[i] += num % 2;
      num = Math.floor(num/2);
      i++;
    }
  }
  let result = 0;
  for (let i = 0; i &lt; bitsCount.length; i++) {
    result = result * 2 + bitsCount[bitsCount.length-1-i] % 3;
  }
  return result - 2 ** 31;
}</pre>
  </details>
  <p>Это решение имеет ограничение. Если одно число встречалось N раз, а все остальные M раз, при этом N % M не должно быть равно нулю.</p>
</article>


<!-- 3. Два числа, которые встречаются в массиве 1 раз -->
<article class="article">
  <div class="anchor" id="bit3"></div>
  <h3>3. Два числа, которые встречаются в массиве 1 раз</h3>

  <p>Нужно найти два числа A и B, которые встречаются в массиве только один раз</p>

  <details>
    <summary>Решение с битовой маской</summary>
    <p>Посчитаем XOR для всех чисел в массиве. Одинаковые числа дадут в результате ноль. Останется XOR от двух разных чисел, которые мы ищем. Это числа разные, поэтому у них есть хотя бы один бит, который отличается. Найдем первый бит, который отличается у чисел A и B</p>
<pre>function uniq(arr) {
  // считаем xor для всех чисел в массиве
  let numsXor = 0;
  for (let num of arr) {
    numsXor ^= num;
  }
  // теперь numsXor = A ^ B
  // гдк A и B искомые числа

  // находим первый бит, который не совпадает
  // у искомых чисел A и B (можно взять любой бит)
  // я беру последний равный 1
  let bitMask = numsXor & (numsXor - 1) ^ numsXor;
  // теперь будем делать xor только для тех чисел
  // где есть совпадение по nonZeroBit
  // таким образом мы найдем одно из двух чисел
  // (можно искать и где не совпадает, в этом случае
  // мы найдем не A, а B)
  let A = 0;
  for (let num of arr) {
    if ((bitMask & num) !== 0) {
      A ^= num;
    }
  }
  let B = numsXor ^ A;
  return [A, B];
}</pre>
  </details>
</article>


<!-- Матрица -->
<article class="article">
  <div class="anchor" id="matrix"></div>
  <h3>Матрица</h3>
</article>


<!-- 1. Сумма чисел на двух диагоналях матрицы -->
<article class="article">
  <div class="anchor" id="matrix"></div>
  <h3>1. Сумма чисел на двух диагоналях матрицы</h3>

  <p>Дана матрица. Двумерный массив. Нужно найти сумму всех элементов на двух диагоналях</p>
  <p>Пример</p>
<pre>
[1, 12, 13, 5]
[15, 2, 6, 18]
[9, 7, 3, 12]
[8, 14, 25, 4]
Ответ 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 = 36
</pre>
<pre>
[1, 2]
[3, 4]
Ответ 1 + 2 + 3 + 4 = 10
</pre>
  <p>Перед написанием кода важно уточнить ограничения. Они достаточно сильно могут влиять на решение задачи. Какой максимальный размер матрицы? Всегда ли матрица квадратная? В нашей задаче максимальный размер матрицы 100 на 100 и она всегда квадратная. Какие числа могут быть в матрице? Точно ли что сумма диагональных элементов не вызовет переполнение? В нашей задаче переполнения не будет.</p>

  <details>
    <summary>Решение</summary>
    <p>Сначала обдумаем решение. Пусть есть три матрицы 4х4, 3х3 и 2х2</p>
<pre>
1 0 0 2
0 1 2 0
0 2 1 0
2 0 0 1
Ответ 12
</pre>
<pre>
1 2 3
4 5 6
7 8 9
Ответ 25
</pre>
<pre>
1 2
3 4
Ответ 10
</pre>
    <p>Для матриц с четным размером (4х4) работает такая формула</p>
    <code>mat[i][i] + mat[i][n-i-1]</code>
    <p>Для нечетной матрицы по этой формуле центральный элемент, который лежит на пересечении двух диагоналей, будет складываться дважды. Чтобы проверить что мы складываем разные элементы, надо чтобы i не было равно n-i-1</p>
    <p>Сложность по времени O(N). Сложность по памяти O(1)</p>
<pre>function sum(mat) {
  let len = mat.length;
  let result = 0;
  for (let i = 0; i &lt; len; i++) {
    result += mat[i][i];
    if (i != len-i-1) {
      result += mat[i][len-i-1];
    }
  }
  return result;
}</pre>
  </details>
</article>


<!-- Поиск в ширину - BFS и поиск в глубину - DFS -->
<article class="article">
  <div class="anchor" id="bfsdfs"></div>
  <h3>Поиск в ширину - BFS и поиск в глубину - DFS</h3>
</article>


<!-- 1. Острова на матрице из суши и воды -->
<article class="article">
  <div class="anchor" id="bfsdfs1"></div>
  <h3>1. Острова на матрице из суши и воды</h3>

  <p>Дана матрица из единиц и нулей. Где 1 это суша, а 0 это вода. Выглядит как карта. Участки суши могут образовывать острова. Участки суши образовывают остров если распологаются на соседних клетках по вертикали или горизонтали. Сколько на такой карте островов? Соседние по диагонали клетки не считаются островом</p>

  <p>Пример</p>
<pre>[
[0, 0, 1, 0, 0],
[0, 1, 1, 0, 0],
[0, 1, 1, 0, 0],
[0, 0, 0, 1, 1],
[1, 0, 0, 0, 0]
]</pre>
  <code>Ответ три острова</code>

  <p>Пример</p>
<pre>[
[1, 1, 0, 0, 0],
[1, 1, 0, 0, 0],
[0, 0, 1, 0, 0],
[0, 0, 0, 1, 1],
]</pre>
  <code>Ответ три острова</code>

  <p>Пример</p>
<pre>[
  [1, 1],
  [1, 1]
]</pre>
  <code>Ответ один остров</code>

  <p>Это задача на <strong>поиск в ширину - BFS</strong> и <strong>поиск в глубину - DFS</strong>. Это способы обойти граф. При BFS мы обходим граф равномерно во все стороны. При DFS мы идем по одному пути пока он не закончится, после этого выбираем другое направление.</p>
  <p>Нужно пройтись по всем клеткам суши и помечать их как пройденные (окрашивать). Неважно в ширину или в глубину мы будем идти, важно чтобы в конце все клетки были окрашены.</p>
  <p>В данной задаче хватит рекурсивной реализации DFS. Лучше взять ее. Она проще в написании. Там меньше кода.</p>

  <details>
    <summary>Решение с помощью рекурсивного DFS</summary>
  <p>Для запоминания того что мы вершину посетили (покрасили) будем использовать дополнительный массив used, который по размеру равен размеру входящей матрицы. Изначально все значения равны false, так как мы ни одну вершину еще не посещали. После посещения вершины, ее значение в матрице used делаем true</p>
  <p>Проходим по входному массиву и если пришла 1 (суша) и в массиве used стоит false (она еще не посещена), то будем для нее запускать DFS</p>
  <p>В каком порядке будем обходить вершины в DFS? Из каждой вершины сначала пробуем идти вниз, потом влево, потом вверх, потом вправо.</p>
  <p>Когда мы начинаем обход вершин надо делать несколько проверок. Первая проверка это то что мы не вышли за границы матрицы. Вторая проверка это то что в клетке 1 (суша). Третья проверка это то что вершина посещена. Если вершина прошла все проверки, то помечаем ее как посещенную (в массиве used отмечаем true) и идем к следующей вершине. Когда дойдем до вершины из которой мы уже обошли во все четыре стороны, то вернемся в предыдущую вершину. И так пока не дойдем снова до первой вершины с которой мы начали обход.</p>
  <p>Когда мы закончим обход из одной вершины, то прибавим 1 к числу найденных островов. Проходим далее по входному массиву, пока не дойдем до следующей вершины, которая 1 (суша) и в массиве used стоит false (она еще не посещена). Для нее также запустим DFS</p>
  <p>Сложность по времени O(n*m). Сложность по памяти O(n*m). Где n*m размер матрицы.</p>
  <p>Недостаток рекурсивного решения - при большой матрице будет переполнение стека вызовов.</p>

<pre>function countIslands(mat) {
  let len = mat.length;
  let len2 = mat[0].length;
  // создадим матрицу used
  let used = [];
  // заполним матрицу used значением false
  for (let i = 0; i &lt; len; i++) {
    used[i] = [];
    for (let j = 0; j &lt; len2; j++) {
      used[i][j] = false;
    }
  }
  let result = 0;
  // начинаем обходить входную матрицу
  for (let i = 0; i &lt; len; i++) {
    for (let j = 0; j &lt; len2; j++) {
      // клетка посещена или там вода
      if (used[i][j] || mat[i][j] === 0) {
        continue;
      }
      // выполняем поиск в глубину
      dfs(i, j, used, mat);
      result++;
    }
  }
  return result;
}

function dfs(x, y, used, mat) {
  // вышли за границы матрицы
  if (x &lt; 0 || x >= mat.length || y &lt; 0 || y >= mat[0].length) {
    return;
  }
  // клетка посещена или там вода
  if (used[x][y] || mat[x][y] === 0) {
    return;
  }
  // помечаем клетку как посещенную
  used[x][y] = true;
  // сдвиг относительно текущей позиции
  let steps = [
    [1, 0],  // вниз   x = x + 1
    [0, -1], // влево  y = y - 1
    [-1, 0], // вверх  x = x - 1
    [0, 1]   // вправо y = y + 1
  ];
  // обходим всех соседей
  for(let step of steps) {
    nextX = x + step[0];
    nextY = y + step[1];
    dfs(nextX, nextY, used, mat);
  }
}</pre>
  </details>

  <p>Пример</p>
<pre>[
[0, 0, 0, 1, 1],
[0, 0, 0, 1, 1],
[0, 0, 0, 1, 1],
[1, 1, 1, 0, 0],
[0, 1, 1, 1, 1]
]</pre>
  <code>Ответ два острова</code>

  <details>
    <summary>Решение с помощью BFS</summary>
    <p>Для BFS нам понадобится очередь q. Алгоритм начинается также как и для DFS - мы ищем первую клетку 1 (суша) и used = false. Для нее будем запускать поиск в ширину. Сразу добавляем эту клетку в очередь q. При добавлении клетки в очередь в массиве used помечаем что мы посетили данную вершину (true). Теперь, пока очередь не пуста, будем выполнять следующий алгоритм (BFS).</p>
    <p>1. Достаем элемент из очереди</p>
    <p>2. Будем обходить всех его соседей</p>
    <p>3. Сначала проверим что для соседа выполняется три условия. Первое условие что клетка не вышла за границы массива. Второе условия что в клетке находится 1 (суша). Третье условие что клетка еще не посещена, в массиве used стоит false.</p>
    <p>4. Если все три условия выполняются, то добавляем ее в очередь. Ставим used = true</p>
    <p>Когда всех соседей обошли, начинаем алгоритм сначала, т.е. берем следующий элемент из очереди</p>
    <p>Сложность по времени O(n*m). Сложность по памяти O(n*m). Где n*m размер матрицы.</p>

<pre>function countIslands(mat) {
  let len = mat.length;
  let len2 = mat[0].length;
  // создадим матрицу used
  let used = [];
  // заполним матрицу used значением false
  for (let i = 0; i &lt; len; i++) {
    used[i] = [];
    for (let j = 0; j &lt; len2; j++) {
      used[i][j] = false;
    }
  }
  let result = 0;
  // начинаем обходить входную матрицу
  for (let i = 0; i &lt; len; i++) {
    for (let j = 0; j &lt; len2; j++) {
      // клетка посещена или там вода
      if (used[i][j] || mat[i][j] === 0) {
        continue;
      }
      // выполняем поиск в глубину
      bfs(i, j, used, mat);
      result++;
    }
  }
  return result;
}

function bfs(x, y, used, mat) {
  // сразу кладем элемент в очередь
  let q = [[x, y]];
  // помечаем элемент как посещенный
  used[x][y] = true;
  // пока очередь не пуста выполняем алгоритм
  while (q.length > 0) {
    // достаем элемент из очереди
    [x, y] = q.shift();
    // сдвиг относительно текущей позиции
    let steps = [
      [1, 0],  // вниз   x = x + 1
      [0, -1], // влево  y = y - 1
      [-1, 0], // вверх  x = x - 1
      [0, 1]   // вправо y = y + 1
    ];
    // обходим всех соседей
    for(let step of steps) {
      nextX = x + step[0];
      nextY = y + step[1];
      // вышли за границы матрицы
      if (nextX &lt; 0 || nextX >= mat.length || nextY &lt; 0 || nextY >= mat[0].length) {
        continue;
      }
      // клетка посещена или там вода
      if (used[nextX][nextY] || mat[nextX][nextY] === 0) {
        continue;
      }
      // добавляем элемент в очередь
      q.push([nextX, nextY]);
      // помечаем элемент как посещенный
      used[nextX][nextY] = true;
    }
  }
}</pre>
  </details>

  <p>Остается только рассказать как написать нерекурсивный DFS. Как сделать поиск в глубину не рекурсивным, а итеративным, как поиск в ширину. Это очень просто. Нужно взять реализацию BFS. Переименовать функцию BFS в DFS. И поменять одну строку.</p>

  <code>[x, y] = q.shift(); // достаем элемент из очереди</code>
  <code>[x, y] = q.pop(); // достаем элемент из очереди</code>

  <p>Единственное чем отличается поиск в ширину и в глубину в итеративной реализации это тем какая <strong>структура данных</strong> используется. Для поиска в ширину мы используем <strong>очередь</strong>, а для поиска в глубину нужно использовать <strong>стек</strong>. В поиске в ширину мы каждый раз забираем первый элемент (из массива, который реализует очередь). В поиске в глубину мы забираем последний элемент (из массива, который реализует стек).</p>

  <details>
    <summary>Решение с помощью итеративного DFS</summary>
    <p>Итеративный поиск в глубину использует очередь, в отличие от рекурсивного решения, которое изспользует стек вызовов.</p>
<pre>function countIslands(mat) {
  let len = mat.length;
  let len2 = mat[0].length;
  // создадим матрицу used
  let used = [];
  // заполним матрицу used значением false
  for (let i = 0; i &lt; len; i++) {
    used[i] = [];
    for (let j = 0; j &lt; len2; j++) {
      used[i][j] = false;
    }
  }
  let result = 0;
  // начинаем обходить входную матрицу
  for (let i = 0; i &lt; len; i++) {
    for (let j = 0; j &lt; len2; j++) {
      // клетка посещена или там вода
      if (used[i][j] || mat[i][j] === 0) {
        continue;
      }
      // выполняем поиск в глубину
      dfs(i, j, used, mat);
      result++;
    }
  }
  return result;
}

function dfs(x, y, used, mat) {
  // сразу кладем элемент в очередь
  let q = [[x, y]];
  // помечаем элемент как посещенный
  used[x][y] = true;
  // пока очередь не пуста выполняем алгоритм
  while (q.length > 0) {
    // достаем элемент из очереди
    [x, y] = q.pop();
    // сдвиг относительно текущей позиции
    let steps = [
      [1, 0],  // вниз   x = x + 1
      [0, -1], // влево  y = y - 1
      [-1, 0], // вверх  x = x - 1
      [0, 1]   // вправо y = y + 1
    ];
    // обходим всех соседей
    for(let step of steps) {
      nextX = x + step[0];
      nextY = y + step[1];
      // вышли за границы матрицы
      if (nextX &lt; 0 || nextX >= mat.length || nextY &lt; 0 || nextY >= mat[0].length) {
        continue;
      }
      // клетка посещена или там вода
      if (used[nextX][nextY] || mat[nextX][nextY] === 0) {
        continue;
      }
      // добавляем элемент в очередь
      q.push([nextX, nextY]);
      // помечаем элемент как посещенный
      used[nextX][nextY] = true;
    }
  }
}</pre>
  </details>
</article>


<!-- Бинарный поиск -->
<article class="article">
  <div class="anchor" id="binsearch"></div>
  <h3>Бинарный поиск</h3>

  <p>Использовать бинарный поиск для решения можно если удается разбить входны данные на две непрерывающиеся последовательности по каким нибудь признакам.</p>
</article>


<!-- 1. Найти число в отсортированном массиве -->
<article class="article">
  <div class="anchor" id="binsearch1"></div>
  <h3>1. Найти число в отсортированном массиве</h3>

  <p>Есть массив nums отсортированный в возрастающем порядке. Проверить есть ли в этом массиве число target. Если такого числа нет, то вернуть -1. Если такое число есть, то вернуть его позицию.</p>

  <p>Пример</p>
  <code>nums = [-1, 0, 3, 5, 9, 12]; target = 9;</code>
  <code>Ответ 4</code>

  <p>Для входный данных можно придумать функцию, которая превратит наш массив из чисел в массив из true и false. При этом сначала будут идти все true, а потом false. В этой задаче такой функцие будет</p>
  <code>nums[i] &lt;= target</code>
  <p>То есть мы смогли разбить входные данные на две непрерывающиеся последовательности. И это будет работать для любых входных данных. Поэтому данную задачу можно решать бинарным поиском.</p>
  <p>Будем называть элементы, которые дают ture - хорошими, а false - плохими. В этом случае target может быть только последним хорошим элементом. Именно поэтому после бинарного поиска нужно проверить что он равен target.</p>
  <p>В бинарном поиске мы ищем не один элемент target, а два элемента. Первый где заканчивается true, второй - где начинается false. То есть первый указатель встанет на последний хороший элемент, а второй указатель - на первый плохой.</p>
  <p>Сложность по времени O(logN). Сложность по памяти O(1).</p>

  <details>
    <summary>Решение с помощью бинарного поиска</summary>
    <p>Заведем два указателя l и r. l указывает на первый элемент массива, r указывает за пределы массива на следующий (несуществующий) элемент после последнего. Будем сдвигать левый указатель вправо, а правый влево до тех пор пока они не будут указывать на соседние элементы (разница между ними будет 1).</p>
    <p>Ответ будет находиться в элементе указывающем на l. Чтобы l мог принимать значения [0, nums.length - 1] т.е. от первого и до последнего индекса включительно, сдвигаем r на 1 вправо от последнего индекса массива.</p>
<pre>function search(nums, target) {
  let l = 0;
  let r = nums.length;
  while (r - l > 1) {
    // определяем середину
    let m = Math.floor((l + r) / 2);
    if (isGood(nums[m], target)) {
      // если число по индексу m хорошее, то двигаем левый указатель
      l = m;
    } else {
      // если число по индексу m плохое, то двигаем правый указатель
      r = m;
    }
  }
  // если левый указатель указывает на target
  // то вернуть левый указатель, иначе -1
  return nums[l] === target ? l : -1;
}

function isGood(val, target) {
  return val &lt;= target;
}</pre>
  </details>
</article>


<!-- 2. Найти сдвиг в отсортированном массиве со сдвигом -->
<article class="article">
  <div class="anchor" id="binsearch2"></div>
  <h3>2. Найти сдвиг в отсортированном массиве со сдвигом</h3>

  <p>Есть массив чисел nums. Он отсортирован по возрастанию, но со сдвигом.</p>

  <p>Пример</p>
  <code>nums = [4,5,6,7,1,2,3];</code>
  <code>Ответ 4</code>
  <p>Массив [4,5,6,7,1,2,3] получен из массива [1,2,3,4,5,6,7] сдвигом на 4 элемента вправо</p>

  <p>Чтобы найти сдвиг (offset) с помощью бинарного поиска, определим функцию, которая будет возвращать для всех элементов сначала true, а потом false</p>

  <p>Пример 1</p>
  <code>nums = [4,5,6,7,0,1,2]</code>
<pre>
    good   bad
[4 5 6 7 | 0 1 2]
       l   r
</pre>
  <p>Здесь элементы с 4 по 7 хорошие, с 0 по 2 плохие и сдвиг равен 4.</p>

  <p>Пример 2</p>
  <code>nums = [1,2,3,4,5]</code>
<pre>
good    bad
    [ | 1 2 3 4 5]
  l     r
</pre>
  <p>В этом примере хороших элементов нет и сдвиг равен 0.</p>
  <p>Сдвиг равен индексу, на который указывает правый указатель r.</p>

  <details>
    <summary>Решение с помощью бинарного поиска</summary>
    <p>Ответ будет находиться в правом указателе r. Поэтому указатель r может принимать значения [0, nums.length - 1]</p>
<pre>function offset(nums) {
  function isGood(i) {
    return nums[i] >= nums[nums.length-1];
  }

  let l = -1;
  let r = nums.length - 1;
  while (r - l > 1) {
    // определяем середину
    let m = Math.floor((l + r) / 2);
    if (isGood(m)) {
      // если число по индексу m хорошее, то двигаем левый указатель
      l = m;
    } else {
      // если число по индексу m плохое, то двигаем правый указатель
      r = m;
    }
  }
  // то вернуть правый указатель
  return r;
}</pre>
  </details>
</article>


<!-- 3. Найти число в отсортированном массиве со сдвигом -->
<article class="article">
  <div class="anchor" id="binsearch3"></div>
  <h3>3. Найти число в отсортированном массиве со сдвигом</h3>

  <h3>Задача на бинарный поиск, который надо применить 2 раза</h3>
  <p>Есть массив чисел nums. Он отсортирован по возрастанию, но со сдвигом. Еще есть target - число, позицию которого нужно вернуть, если оно есть в массиве nums. Если его нет - вернуть -1.</p>

  <p>Пример</p>
  <code>search([4,5,6,7,1,2,3], 5); // 1</code>
  <p>Массив [4,5,6,7,1,2,3] получен из массива [1,2,3,4,5,6,7] сдвигом на 4 элемента вправо</p>

  <p>Бинарный поиск нужно применить 2 раза.</p>
  <p>1. Когда будем искать сам сдвиг</p>
  <p>2. Для поиска самого элемента</p>

<pre>function offset(nums) {
  function isGood(i) {
    return nums[i] >= nums[nums.length-1];
  }

  let l = -1;
  let r = nums.length - 1;
  while (r - l > 1) {
    // определяем середину
    let m = Math.floor((l + r) / 2);
    if (isGood(m)) {
      // если число по индексу m хорошее, то двигаем левый указатель
      l = m;
    } else {
      // если число по индексу m плохое, то двигаем правый указатель
      r = m;
    }
  }
  // вернуть правый указатель
  return r;
}

function search(nums, target) {
  function isGood(i) {
    return nums[i] &lt;= target;
  }

  // обычный бинарный поиск, но смещаем на offset дополнительно
  let shift = offset(nums);
  let l = 0;
  let r = nums.length;
  while (r - l > 1) {
    // определяем середину
    // Ошибка №1 это делать m=(l+r+shift)/2
    let m = Math.floor((l + r) / 2);
    if (isGood((m+shift) % nums.length)) {
      // если число по индексу m хорошее, то двигаем левый указатель
      l = m;
    } else {
      // если число по индексу m плохое, то двигаем правый указатель
      r = m;
    }
  }
  // Ошибка №2 это забыть сделать (l+shift) % nums.length
  // Берем остаток от деления чтобы не выйти за границы массива
  let realLeft = (l + shift) % nums.length;
  // если левый указатель указывает на target
  // то вернуть левый указатель, иначе -1
  return nums[realLeft] === target ? realLeft : -1;
}</pre>
</article>


<!-- Связный список (Linked list) -->
<article class="article">
  <div class="anchor" id="linkedlist"></div>
  <h3>Связный список (Linked list)</h3>

  <p>Linked list - это структура данных, состоящая из узлов. В узле хранится его значение и указатель на следующий узел</p>

  <p>Пример</p>
  <p>Есть связный список из двух узлов. Первый узел хранит указатель на второй узел. Второй узел хранит указатель на null, потому что это последний узел и третьего узла нет</p>

  <p>На собеседовании нужно самому реализовать поиск длины списка. Пройтись по каждому узлу и посчитать длину всего списка. По времени это O(N).</p>
  <p>Различают односвязный список и двусвязный. В односвязном списке из одной вершины можно идти только в следующую, но не предыдущую</p>

  <p>Пример связного списка</p>
<pre>
class LinkedList {
  constructor(val, next) {
    this.val = val;
    this.next = next;
  }
}</pre>
</article>


<!-- Паттерн Dummy node (фейковый узел) -->
<article class="article">
  <div class="anchor" id="dummynode"></div>
  <h3>Паттерн Dummy node (фейковый узел)</h3>

  <p>Паттерн Dummy node упрощает решение для задач со связным списком. Добавим фейковую вершину перед головой списка. Эта фейковая вершина станет новой головой списка, которая будет указывать на настоящую голову. В таком случае, у нас всегда будет предыдущая вершина и удаление первой вершины не будет никаким исключением.</p>
  <p>Паттерн dammy node - это присоединение фейковой вершины к голове списка и используется в двух случаях. Когда мы не хотим делать крайним случаем (corner case) удаление первой вершины. И когда мы не знаем какая из вершин должна быть первой в ответе, то есть не знаем куда цеплять ответ.</p>

  <h4>Список задач на leetcode</h4>
  <p>19. Remove Nth node from end of list</p>
  <p>21. Merge two sorted lists</p>
  <p>23. Merge K sorted lists</p>
</article>


<!-- 1. Удалить N-ый узел с конца списка -->
<article class="article">
  <div class="anchor" id="linkedlist1"></div>
  <h3>1. Удалить N-ый узел с конца списка</h3>

  <p>Дана голова связного списка и число N. Нужно удалить N-ый узел с конца. Вернуть получившийся список.</p>
  <p>N-ый узел гарантированно есть. N не может быть больше чем длина самого списка</p>

  <p>Пример</p>
  <code>{1,2,3,4,5}. удалить 2 с конца вершину.</code>
  <code>Ответ {1,2,3,5}</code>

  <p>Есть два популярных решения.</p>

  <h4>Решение 1</h4>
  <p>Пройтись по списку и узнать длину. Зная длину мы можем найти элемент, который находится перед N-ым с конца. Само удаление происходит за счет изменения связи. Чтобы удалить N-ый элемент, нужно в элементе N-1 удалить ссылку на N-ый элемент и поставить ссылку на N+1 элемент.</p>
  <p>А если этот N-ый элемент является головой списка и никаких элементов перед ним нет? Можно отдельно обработать этот corner case, сделать в коде дополнительный if, но гораздо красивее будет если реализовать это с помощью паттерна Dummy node.</p>
  <p>Если в вашем языке программирования нет Garbage Collector (например, в языке Си), нужно почистить память для удаленной вершины и для dummy node, так как он больше не нужен.</p>

  <details>
    <summary>Решение 1 (в два прохода)</summary>
<pre>
class ListNode {
  constructor(val, next) {
    this.val = val;
    this.next = next;
  }
}

let list4 = new ListNode(4, null);
let list3 = new ListNode(3, list4);
let list2 = new ListNode(2, list3);
let list = new ListNode(1, list2);

function removeNode(head, n) {
  // добавим фейковый узел перед головой списка
  let dummyNode = new ListNode(0, head);

  // находим длину списка с учетом dummyNode
  let len = 0;
  let curr = dummyNode;
  while(curr) {
    curr = curr.next;
    len++;
  }

  // проверим n
  if (n &lt; 1 || n > len - 1) {
    return 0;
  }

  // доходим до (n-1)-ой вершины с конца
  curr = dummyNode;
  for(let i = 0; i &lt; len - n - 1; i++) {
    curr = curr.next;
  }

  // удаляем вершину
  curr.next = curr.next.next;

  return dummyNode.next;
}

console.log(removeNode(list, 2));
</pre>
  </details>

  <p>В первом решении мы сделали 2 прохода по списку. В первом проходе мы нашли длину. Во втором проходе мы дошли до нужной вершины и сделали само удаление.</p>
  <p>Сложность по времени O(N)</p>
  <p>Сложность по памяти O(1)</p>

  <h4>Решение 2</h4>
  <p>Во втором решении будет один проход, но асимптотика остается такой же. Определять длину списка не будем, поэтому первый проход нам не нужен.</p>
  <p>Добавим два указателя slow и fast. Сначала они указывают на dummyNode, то есть на голову списка. Потом двигаем fast на n+1 узлов вперед, так что slow будет указывать на (n-1)-ый узел от указателя fast. Далее двигаем fast за конец списка. Указатель slow будет показывать на (n-1)-ый узел с конца списка. Совершаем удаление n-ой вершины с конца и возвращаем новый список</p>

  <details>
    <summary>Решение 2 (в один проход)</summary>
<pre>
class ListNode {
  constructor(val, next) {
    this.val = val;
    this.next = next;
  }
}

let list4 = new ListNode(4, null);
let list3 = new ListNode(3, list4);
let list2 = new ListNode(2, list3);
let list = new ListNode(1, list2);

function removeNode(head, n) {
  // добавим фейковый узел перед головой списка
  let dummyNode = new ListNode(0, head);

  // добавим два указателя
  let slow = dummyNode;
  let fast = dummyNode;

  // делаем расстояние n+1 между slow и fast
  for (let i = 0; i &lt; n + 1; i++) {
    fast = fast.next;
  }

  // двигаем указатели, пока fast не выйдет за пределы списка
  while (fast) {
    slow = slow.next;
    fast = fast.next;
  }

  // удаляем вершину
  slow.next = slow.next.next;

  return dummyNode.next;
}

console.log(removeNode(list, 2));
</pre>
  </details>
</article>


<!-- 2. Объединить два связных списка в возрастающем порядке -->
<article class="article">
  <div class="anchor" id="linkedlist2"></div>
  <h3>2. Объединить два связных списка в возрастающем порядке</h3>

  <p>Даны два связных списка, которые отсортированы в возрастающем порядке. Вернуть новый список, который содержит все элементы из двух списков и отсортирован в возрастающем порядке.</p>
  <p>Здесь отлично подходит паттерн dummy node потому что мы не знаем какая из вершин в первом или во втором списке должна быть первой в ответе. И когда мы не знаем куда крепить ответ, отлично подходит dummy node паттерн. Мы заводим фейковую вершину и к ней будем крепить наш результат. Благодаря этому паттерну исчезают множество if в ваших решениях.</p>

  <p>Пример</p>
  <code>Первый список {1,2,4}, Второй список {1,3,4}</code>
  <code>Output: {1,1,2,3,4,4}</code>

  <details>
    <summary>Решение</summary>
<pre>
class ListNode {
  constructor(val=0, next=null) {
    this.val = val;
    this.next = next;
  }
}

let list13 = new ListNode(4, null);
let list12 = new ListNode(2, list13);
let list11 = new ListNode(1, list12);

let list23 = new ListNode(4, null);
let list22 = new ListNode(3, list23);
let list21 = new ListNode(1, list22);

function getVal(node) {
  if (!node) {
    return Infinity;
  }
  return node.val;
}

function mergeLists(list1, list2) {
  // добавим фейковый узел перед головой списка
  let dummyNode = new ListNode();

  // запишем в ответ фейковый узел
  let curr = dummyNode;

  // пока есть узлы хоть в одном списке
  while (list1 || list2) {
    if (getVal(list1) &lt; getVal(list2)) {
      curr.next = list1;
      list1 = list1.next;
    } else {
      curr.next = list2;
      list2 = list2.next;
    }
    curr = curr.next;
  }

  return dummyNode.next;
}

console.log(mergeLists(list11, list21));
</pre>
  </details>
</article>


<!-- Стек, очередь -->
<article class="article">
  <div class="anchor" id="stack"></div>
  <h3>Стек, очередь</h3>
</article>


<!-- Сортировки -->
<article class="article">
  <div class="anchor" id="sort"></div>
  <h3>Сортировки</h3>

  <ol>
    <li>
      <h4>Квадратичные</h4>
      <p>Сложность во времени O(n<sup>2</sup>)</p>
      <p>Сложность по памяти O(1)</p>
    </li>
    <li>
      <h4>Логарифмические</h4>
      <p>Сложность по времени O(nlogn)</p>
      <p>Сложность по памяти O(logn)</p>
    </li>
    <li>
      <h4>Сортировка подсчетом</h4>
      <p>Сложность по времени O(n)</p>
      <p>Сложность по памяти O(n)</p>
      <p>Применяют только при небольшом количестве уникальных элементов</p>
    </li>
  </ol>
</article>

