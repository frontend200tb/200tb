<h1>Задачи от Максима Фатина</h1>


<!-- links -->
<article class="article">
  <h2>links</h2>

  <p><a href="https://www.youtube.com/@fatin.maksim/videos">youtube Максим Фатин</a></p>
  <p><a href="https://algocode.io/">https://algocode.io/</a></p>
  <p><a href="https://tskills.ru/algo">https://tskills.ru/algo</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p><a href="#hash">Хэш-таблица</a></p>
  <ol>
    <li><a href="#hash1">Сумма двух чисел в не отсортированном массиве</a></li>
    <li><a href="#hash2">Топ К часто встречающихся элементов</a></li>
    <li><a href="#hash3">Изоморфные строки</a></li>
  </ol>
  <p><a href="#sort">Сортировки</a></p>
</article>


<!-- Хэш таблица -->
<article class="article">
  <div class="anchor" id="hash"></div>
  <h3>Хэш таблица</h3>


  <h4>Операции и их сложность</h4>
  <ol>
    <li>Поиск</li>
    <li>Вставка</li>
    <li>Получение</li>
    <li>Удаление</li>
  </ol>
  <p>Сложность по времени в среднем за O(1). Но очень редко, когда перестраивается хеш-таблица за O(N). Если хеш-таблица заранее выделила себе мало памяти и начали появлятся коллизии (когда разные элементы должны быть записаны в одну ячейку памяти), то происходит релокация (перестроение всей таблицы). Этот процесс по времени и по памяти имеет сложность O(N).</p>

  <h4>Что может быть ключем хеш-таблицы</h4>
  <p>Ключем хеш-таблицы может быть все что угодно (число, строка и т.д.). В некоторых языках ключем не могут быть mutable type.</p>

  <h4>Count sort (сортировка подсчетом)</h4>
  <p>Используют когда маленькое количество уникальных элементов</p>
  <p>Если элементы известны заранее, то можно использовать массив. Например, только две цифры 0 и 1, диапазон чисел от 0 до 9, буквы от a до z. Если элементы неизвестны, то используют словарь.</p>

  <h4>Анаграмма</h4>
  <p>Группировка анаграмм</p>
  <p>Поиск анаграмм</p>
  <p>Проверка на анаграмму</p>
</article>


<!-- 1. Сумма двух чисел в не отсортированном массиве -->
<article class="article">
  <div class="anchor" id="hash1"></div>
  <h3>1. Сумма двух чисел в не отсортированном массиве</h3>

  <p>Дан не отсортированный массив чисел и число. Определить, есть ли в массиве два числа , которые в сумме равны заданному числу</p>

  <p>Пример</p>
  <code>Input: [7,13,6,5], target = 18</code>
  <code>Output: true</code>

  <details>
    <summary>Решение</summary>
    <p>Метод хэш таблицы</p>
    <h4>Алгоритм</h4>
    <ol>
      <li>Заведем переменную dict для хранения пар ключ-значение и запишев в нее пустой объект
        <code>let dict = {};</code>
      </li>
      <li>Пройдем циклом по массиву
        <code>for (let i = 0; i &lt; nums.length; i++)</code>
      </li>
      <li>Если разница между target и текущим значением есть в словаре, то возвращаем true
        <code>if (t - nums[i] in dict) return true;</code>
      </li>
      <li>Если нет, то добавляем в словарь текущее значение
        <code>dict[nums[i]] = i;</code>
      </li>
      <li>Если цикл закончился, значит нет двух чисел с нужной суммой. Возвращаем false</li>
    </ol>
<pre>
function twoSum(nums, t) {
  let dict = {};

  for (let i = 0; i &lt; nums.length; i++) {
    if (t - nums[i] in dict) {
      return true;
    } else {
      dict[nums[i]] = i;
    }
  }
  return false;
}

console.log(twoSum([7,13,6,5], 18)); // true
console.log(twoSum([7,13,6,5], 21)); // false
</pre>
  </details>
  <p>Сложность по времени O(N). Сложность по памяти O(N)</p>

</article>


<!-- Паттерн "ключ-значение - значение-ключ" -->
<article class="article">
  <div class="anchor" id="key"></div>
  <h3>Паттерн "ключ-значение - значение-ключ"</h3>
</article>


<!-- 2. Топ К часто встречающихся элементов -->
<article class="article">
  <div class="anchor" id="hash2"></div>
  <h3>2. Топ К часто встречающихся элементов</h3>

  <p>Дан целочисленный массив nums и целое число k, нужно вернуть k наиболее частых элементов. Можно вернуть ответ в любом порядке</p>

  <p>Пример</p>
  <code>Input: nums = [5,3,1,5,5,3,7], k = 2</code>
  <code>Output: [5,3]</code>

  <p>Идея решения. Перебирать элементы и для каждого элемента считать сколько раз он встретился. Записывать в славарь. Ключем будет элемент, значением - его количество. Когда хеш-таблица создана, нужно создать массив размером n+1, где индексами будут значения из словаря (количество одинаковых элементов), а значением для каждого ключа будет массив с ключами из первого словаря (сами элементы). Таким образом, мы сделаем замену "ключа-значение" на "значение-ключ"</p>
  <details>
    <summary>Решение</summary>
    <p>Решение с помощью хещ-таблицы и паттерна "ключ-значение - значение-ключ"</p>
    <h4>Алгоритм</h4>
    <ol>
      <li>Заведем переменную res для массива с результатом
        <code>const res = [];</code>
      </li>
      <li>Заведем переменную dict для словаря, где ключем будет элемент входного массива, а значением - сколько раз он встречается
        <code>const dict = {};</code>
      </li>
      <li>Заведем переменную count для массива размером n+1, где индекс будут значения из словаря, а значением - массив с элементами
        <code>const count = [];</code>
      </li>
      <li>Пройдем циклом по входному массиву
        for (let num of nums)
      </li>
      <li>Если очередного элемента нет в словаре, то добавим его в словарь как ключ со значением 0
        <code>if (!(num in dict)) dict[num] = 0;</code>
      </li>
      <li>Увеличим значение dict[num] на 1</li>
      <li>Когда цикл закончится, закончится и формирование словаря
      </li>
      <li>
        Пройдем циклом по словарю
        <code>for (let num in dict)</code>
      </li>
      <li>Добавим очередной ключ словаря в массив count с индексом равным значению из словаря</li>
      <li>Пройдем по массиву count с конца и добавим первые k элементов в массив с результатом</li>
    </ol>
<pre>
function topKFrenq(nums, k) {
  const res = [];
  // ключ - число
  // значение - сколько раз встретилось
  const dict = {};
  // инекс - сколько раз встретилось число
  // значение - массив чисел, которые встретились столько раз
  const count = [];

  for (let num of nums) {
    if (!(num in dict)) {
      dict[num] = 0;
    }
    dict[num]++;
  }

  for (let num in dict) {
    let freq = dict[num];
    count[freq].push(Number(num));
  }

  for (let i = count.length - 1; i > 0; i--) {
    for (let num of count) {
      if (k &lt;= 0) {
        return res;
      }
      res.push(num);
      k--;
    }
  }
  return res;
}
</pre>
  </details>
</article>


<!-- 3. Изоморфные строки -->
<article class="article">
  <div class="anchor" id="hash3"></div>
  <h3>3. Изоморфные строки</h3>

  <p>Даны две строки s и t, определите, являются ли они изоморфными</p>

  <p>Две строки s и t изоморфны, если символы в s можно заменить, чтобы получить t</p>
  <p>Все вхождения символа должны быть заменены другим символом с сохранением порядка символов. Никакие два символа не могут отображаться в один и тот же символ, но символ может отображаться сам на себя</p>

  <h4>Пример 1</h4>
  <code>Input: s = "abacaba", t = "totxtot"</code>
  <code>Output: true</code>

  <h4>Пример 2</h4>
  <code>Input: s = "foo", t = "bar"</code>
  <code>Output: false</code>

  <p>Идея решения. Для каждой строки заведем свой словарь. И будем запоминать какая буква одной строке соответствует какой букве другой строки. Если какая-то буква не соответствует, то будем возвращать false</p>

  <details>
    <summary>Решение</summary>
    <h4>Алгоритм</h4>
    <ol>
      <li>Заведем два словаря dict1 и dict2 для каждой строки
        <code>const dict1 = {}, dict2 = {};</code>
      </li>
      <li>Пройдем циклом по строке
        <code>for (let i = 0; i &lt; s.length; i++)</code>
      </li>
      <li>Если в первом словаре есть ключ равный символу первой строки, и его значение не равно символу второй строки, вернем false
        <code>if (s[i] in dict1 && dict1[s[i]] !== t[i]) return false;</code>
      </li>
      <li>Если во втором словаре есть ключ равный символу второй строки, и его значение не равно символу первой строки, вернем false
        <code>if (t[i] in dict2 && dict2[t[i]] !== s[i]) return false;</code>
      </li>
      <li>Запишем в первый словарь ключ равный символу первой строки и значение равное символу второй строки</li>
      <li>Запишем во второй словарь ключ равный символу второй строки и значение равное символу первой строки</li>
      <li>Когда цикл закончится, то вернем true. Все символы совпали значит строки изоморфны</li>
    </ol>
<pre>
function isIsomorhic(s, t) {
  const dict1 = {}, dict2 = {};
  // dict1 ключ: символ строки s
  // val: сопоставленный символ строки t
  // dict2 ключ: симовл строки t
  // val: сопоставленный символ строки s

  let p1 = 0, p2 = 0;
  for (let i = 0; i &lt; s.length; i++) {
    if (dict1[s[i]] && dict1[s[i]] !== t[i]) {
      return false;
    }
    if (dict2[t[i]] && dict2[t[i]] !== s[i]) {
      return false;
    }
    dict1[s[i]] = t[i];
    dict2[t[i]] = s[i];
  }

  return true;
}
</pre>
  </details>
  <p>Сложность по времени O(N). Сложность по памяти O(N)</p>
</article>


<!-- Сортировки -->
<article class="article">
  <div class="anchor" id="sort"></div>
  <h3>Сортировки</h3>

  <ol>
    <li>
      <h4>Квадратичные</h4>
      <p>Сложность во времени O(n<sup>2</sup>)</p>
      <p>Сложность по памяти O(1)</p>
    </li>
    <li>
      <h4>Логарифмические</h4>
      <p>Сложность по времени O(nlogn)</p>
      <p>Сложность по памяти O(logn)</p>
    </li>
    <li>
      <h4>Сортировка подсчетом</h4>
      <p>Сложность по времени O(n)</p>
      <p>Сложность по памяти O(n)</p>
      <p>Применяют только при небольшом количестве уникальных элементов</p>
    </li>
  </ol>
</article>

