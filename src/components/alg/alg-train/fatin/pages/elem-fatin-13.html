<h1>Префиксный массив</h1>


<article class="article">
  <p>Конспект видео от 2024-11-03</p>
  <h4>Хакни BigTech и Массивы</h4>

  <p><a href="https://www.youtube.com/@fatin.maksim/videos">youtube Максим Фатин</a></p>
  <p><a href="https://algocode.io/">https://algocode.io/</a></p>
  <p><a href="https://tskills.ru/algo">https://tskills.ru/algo</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p><a href="#about">План на стрим</a></p>
  <p><a href="#interv">Как тебя оценивает интервьюер</a></p>
  <p><a href="#roadmap">RoadMap для изучения массивов</a></p>
  <p><a href="#task1">Задача 1. Сумма на отрезках</a></p>
  <p><a href="#task2">Задача 2. Произведение на отрезках</a></p>
  <p><a href="#task3">Задача 3. Индекс равных сумм</a></p>
  <p><a href="#roadmap2">RoadMap для изучения префиксных массивов</a></p>
  <p><a href="#qa">Вопросы и ответы</a></p>
  <p><a href="#task4">Задача 4. Пропущенное число</a></p>
</article>


<!-- План на стрим -->
<article class="article">
  <div class="anchor" id="about"></div>
  <h3>План на стрим</h3>

  <p>Сегодня у нас в программе массивы для BigTech. Будем разбирать что вообще необходимо знать про массивы. Это не такая то уж и простая тема. Будем разговаривать как тебя оценивает интервьюер и что нужно для собеса.</p>

  <ol>
    <li>Как тебя оценивает интервьюер</li>
    <li>Что важнее всего на собесе в BigTech</li>
    <li>RoadMap для изучения алгосов</li>
    <li>Решим задачи с собеса Яндекса, Озона, Сбера, Joom</li>
  </ol>
</article>


<!-- Как тебя оценивает интервьюер -->
<article class="article">
  <div class="anchor" id="interv"></div>
  <h3>Как тебя оценивает интервьюер</h3>

  <ol>
    <li>
      <h4>Придумывание решения</h4>
      <p>Максимум 2 балла. Не решил 0 баллов. Решил, но были существенные подсказки 1 балл. Решил сам 2 балла.</p>
    </li>
    <li>
      <h4>Оценка сложности</h4>
      <p>Максимум 1 балл. Оценил не верно 0 баллов. Верная оценка, возможны подсказки 1 балл</p>
    </li>
    <li>
      <h4>Качество кода</h4>
      <p>Максимум 2 балла</p>
    </li>
    <li>
      <h4>Ошибки и их исправление</h4>
      <p>Максимум 2 балла</p>
    </li>
  </ol>

  <p>Существенные подсказки это когда вы не знаете как решать, а интервьюер дает вам направление в котором надо подумать. Никто сразу же существенные подсказки давать не будет. Сначала дадут подумать кандидату самому. Потом дадут небольшую подсказку. И уже когда выходим за тайминги, тогда могут дать существенную подсказку</p>
  <p>Тайминги обычно такие. 20 минут на первую задачу. 40 минут на вторую задачу. Если обе задачи решил и еще осталось время то дают третью задачу и очень круто если ее ты тоже решишь.</p>
  <p>В яндексе последние 20 минут дадут блиц опрос чтобы точнее определить твой грейд. Это будет опрос не по алгоритмам, а по SQL, system disign, по языку программирования</p>
  <p>В любом коде содержатся ошибки. Но если ты ошибку находишь сам, то это большой плюс. Не во всех компаниях запускают код. Поэтому если у тебя есть ошибка, то может и прокатить, а может и нет.</p>
  <p>Качество кода. У интервьюера уже есть эталонное решение, к которому они хотят максимально подвести кандидата.</p>

  <h4>Что важнее всего?</h4>
  <ol>
    <li>Придумать решение</li>
    <li>Оценить время и память</li>
    <li>Качество кода</li>
    <li>Ошибки и их исправление</li>
  </ol>

  <h4>Как часто нужны массивы на собесе</h4>
  <p>Более 34.3% задач на собесах это массивы</p>
</article>


<!-- RoadMap для изучения массивов -->
<article class="article">
  <div class="anchor" id="roadmap"></div>
  <h3>RoadMap для изучения массивов</h3>

  <h4>Массивы</h4>
  <ol>
    <li>
      <h4>Префиксный массив</h4>
    </li>
    <li>
      <h4>Два указателя</h4>
      <ol>
        <li>
          <h4>С двух сторон</h4>
          <p>Левый указатель ставим на начало массива, правый на конец массива и они идут навстречу друг другу пока не встретятся.</p>
        </li>
        <li>
          <h4>Каждому по указателю</h4>
          <p>Первый указатель ставят на начало первого массива, второй - на начало второго и они идут до конца массива, сравнивая элементы между собой</p>
        </li>
        <li>
          <h4>Медленный и быстрый</h4>
          <p>В задачах, где надо в массиве заменить какие-то элементы, например, перенести все нули в конец массива.</p>
        </li>
      </ol>
    </li>
    <li>
      <h4>Плавающее окно</h4>
      <ol>
        <li>
          <h4>Пересекающиеся окна</h4>
        </li>
        <li>
          <h4>Не пересекающиеся окна</h4>
        </li>
        <li>
          <h4>Окна фиксированной длины</h4>
        </li>
      </ol>
    </li>
    <li>
      <h4>Задачи на внимательность</h4>
    </li>
  </ol>
</article>


<!-- Задача 1. Сумма на отрезках -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача 1. Сумма на отрезках</h3>

  <p>Реализуй структуру данных, которая умеет быстро находить сумму всех элементов на отрезке [l, r], где l,r - индексы, включая сами индексы. Массив при этом не изменяетсся</p>

  <h4>Пример</h4>
  <code>nums = [2,1,3,5,4]</code>
  <code>l = 0, r = 0 // 2</code>
<pre>
        |0|
nums = [ 2, 1, 3, 5, 4 ]
         0  1  2  3  4
</pre>
  <code>l = 0, r = 4 // 15 (2+1+3+5+4)</code>
<pre>
        |0|         |4|
nums = [ 2, 1, 3, 5, 4 ]
         0  1  2  3  4
</pre>
  <code>l = 1, r = 3 // 9 (1+3+4)</code>
<pre>
           |1|   |3|
nums = [ 2, 1, 3, 5, 4 ]
         0  1  2  3  4
</pre>

  <h4>Паттерн префиксный массив</h4>

  <p>Префикс - это что-то от начала и до какого-то элемента.</p> <p>Префиксная сумма - это сумма элементов от начала и до какого-то элемента.</p>

<pre>
nums =    [2, 1, 3,  5,  4]
           0  1  2   3   4
px   = [0, 2, 3, 6, 11, 15]
        0  1  2  3   4   5
</pre>

  <details>
    <summary>Алгоритм</summary>
    <h4>Создадим функцию pxArray(), которая принимает на вход массив и строит из него нужную структуру данных. На выходе префиксный массив</h4>
    <ol>
      <li>Создаем массив, в который будем записывать префиксные суммы.
      <code>const px = [];</code>
    </li>
      <li>В самый первый элемент с индексом 0 запишем значение 0
        <code>px[0] = 0;</code>
        0 нужен для того, чтобы потом мы могли его вычитать, если отрезок начинается с начала массива. Это позволит избавиться от дополнительной проверки условия if что индекс указывает на начало массива
      </li>
      <li>Каждый следующий элемент формируется по алгоритму. Берется предыдущий элемент и к нему прибавляется элемент из входного массива nums.</li>
      <li>Проходим по входному массиву
        <code>for (const i = 0; i &lt; nums.length; i++)</code>
      </li>
      <li>В префиксный массив записываем сумму
        <code>px[i+1] = px[i] + nums[i];</code>
      </li>
    </ol>
    <p>Сложность по времени O(N) на создание префиксного массива</p>
    <p>Сложность по памяти O(N) на хранение префиксного массива</p>

    <h4>Напишем функцию sumRange(), которая принимает два индекса - левый и правый и возвращает сумму элементов между этими двумя индесами, включая элементы в этих индексах</h4>
    <p>Придумаем формулу нахождения суммы между двумя индексами</p>
    <p>Поскольку левый и правый индекс включительно и префиксный массив имеет индексы на 1 больше чем исходный, то
      <code>result = px[right + 1] - px[left]</code>
    </p>
    <p>Сложность по времени O(1) на вычисление суммы</p>
    <p>Сложность по памяти O(1) на хранение результата</p>
  </details>
  <details>
    <summary>Код на javascript</summary>
<pre>
function pxArray(nums) {
  this.px = [0];
  for (const num of nums) {
    this.px.push(this.px[this.px.length - 1] + num);
  }
}

pxArray.prototype.sumRange = function(left, right) {
  return this.px[right+1] - this.px[left];
};
</pre>
  </details>

  <details>
    <summary>Код на python</summary>
<pre>
class pxArray:
  def __init__(self, nums: List[int]):
    px = [0, ]
    for num in nums:
      px.append(px[-1] + num)
    self.px = px

  def sumRange(self, left: int, right: int) -> int:
    return self.px[right + 1] - self.px[left]
</pre>
  </details>

  <details>
    <summary>Код на go</summary>
<pre>
type pxArray struct {
  px []int
}

func Constructor(nums []int) pxArray {
  px := make([]int, len(nums)+1)
  for i, num := range nums {
    px[i+1] = px[i] + num
  }
  return pxArray{px}
}

func (this *pxArray) SumRange(left int, right int) int {
  return this.px[right+1] - this.px[left]
}
</pre>
  </details>

  <details>
    <summary>Код на java</summary>
<pre>
class pxArray {
  private int[] px;
  public pxArray(int[] nums) {
    px = new int[nums.length + 1];
    for (int i = 0; i &lt; nums.length; i++) {
      px[i + 1] = px[i] + nums[i];
    }
  }
  public int sumRange(int left, int right) {
    return px[right + 1] - px[left];
  }
}
</pre>
  </details>

  <details>
    <summary>Код на C++</summary>
<pre>
class pxArray {
public:
  pxArray(vector&lt;int&gt;& nums) {
    px.push_back(0);
    for (int num : nums) {
      px.push_back(px.back() + num);
    }
  }
  int sumRange(int left, int right) {
    return px[right+1] - px[left];
  }

private:
  vector&lt;int&gt; px;
};
</pre>
  </details>
</article>


<!-- Задача 2. Произведение на отрезках -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача 2. Произведение на отрезках</h3>

  <p>Реализуй структуру данных, которая умеет быстро находить прооизведение всех элементов на отрезке [l, r], где l,r - индексы, включая сами индексы. Массив при этом не изменяетсся. Учитываем что в массиве могут быть нули.</p>

  <h4>Пример</h4>
  <code>nums = [1,0,2,3,4]</code>
  <code>l = 0, r = 0 // 1</code>
<pre>
        |0|
nums = [ 1, 0, 2, 3, 4 ]
         0  1  2  3  4
</pre>

  <code>l = 1, r = 3 // 0 (0*2*3)</code>
<pre>
           |1|   |3|
nums = [ 1, 0, 2, 3, 4 ]
         0  1  2  3  4
</pre>

  <code>l = 2, r = 4 // 24 (2*3*4)</code>
<pre>
              |2|   |4|
nums = [ 1, 0, 2, 3, 4 ]
         0  1  2  3  4
</pre>

  <h4>Паттерн два префиксных массива</h4>
  <p>Префикс - это что-то от начала и до какого-то элемента.</p> <p>Префиксное произведение - это произведение элементов от начала и до какого-то элемента.</p>
  <p>Первый префиксный массив сохранит только количество нулей. А второй префиксный массив сохранит произведение всех не нулевых элементов</p>
  <p>Если на отрезке есть нули, то произведение равно нулю. Если нулей нет, то произведение равно произведению не нулевых элементов на отрезке.</p>

<pre>
nums =    [1, 0, 2, 3,  4]
           0  1  2  3   4
px0  = [0, 0, 1, 1, 1,  1]
        0  1  2  3  4   5
px   = [1, 1, 1, 2, 6, 24]
        0  1  2  3  4   5
</pre>

<details>
  <summary>Алгоритм</summary>
  <h4>Создадим функцию px0Array(), которая принимает на вход массив. На выходе префиксный массив нулей</h4>
  <ol>
    <li>Создаем массив px0, в который будем записывать количество нулей.
    <code>const px0 = [];</code>
  </li>
    <li>В самый первый элемент с индексом 0 запишем значение 0
      <code>px0[0] = 0;</code>
      0 нужен для того, чтобы потом мы могли его вычитать, если отрезок начинается с начала массива. Это позволит избавиться от дополнительной проверки условия if что индекс указывает на начало массива
    </li>
    <li>Каждый следующий элемент формируется по алгоритму. Берется предыдущий элемент и к нему прибавляется 1 если элемент входного массива равен 0.</li>
    <li>Проходим по входному массиву
      <code>for (const i = 0; i &lt; nums.length; i++)</code>
    </li>
    <li>Проверяем условие и в массив px0 записываем количество нулей
<pre>
if (nums[i] === 0) {
  px0[i+1] = px0[i] + 1;
} else {
  px0[i+1] = px0[i];
}
</pre>
    </li>
  </ol>
  <p>Сложность по времени O(N) на создание префиксного массива</p>
  <p>Сложность по памяти O(N) на хранение префиксного массива</p>

  <h4>Создадим функцию pxArray(), которая принимает на вход массив. На выходе префиксный массив произведений</h4>
  <ol>
    <li>Создаем массив px, в который будем записывать префиксные произведения.
    <code>const px = [];</code>
  </li>
    <li>В самый первый элемент с индексом 0 запишем значение 1
      <code>px[0] = 1;</code>
      1 нужна для того, чтобы потом мы могли на нее делить, если отрезок начинается с начала массива. Это позволит избавиться от дополнительной проверки условия if что индекс указывает на начало массива
    </li>
    <li>Каждый следующий элемент формируется по алгоритму. Если приходит ноль, то записывается предыдущий элемент, иначе записывается произведение предыдущего элемента и элемента из входного массива nums.</li>
    <li>Проходим по входному массиву
      <code>for (const i = 0; i &lt; nums.length; i++)</code>
    </li>
    <li>Проверяем условие и в массив px записываем произведение не нулевых элементов
<pre>
if (nums[i] === 0) {
  px[i+1] = px[i];
} else {
  px[i+1] = px[i] * nums[i];
}
</pre>
    </li>
  </ol>
  <p>Сложность по времени O(N) на создание префиксного массива</p>
  <p>Сложность по памяти O(N) на хранение префиксного массива</p>

  <h4>Напишем функцию multRange(), которая принимает два индекса - левый и правый и возвращает произведение элементов между этими двумя индесами, включая элементы в этих индексах</h4>
  <ol>
    <li>Проверим условие, если на отрезке встречается 0, то все произведение равно 0
      <code>if (px0[right + 1] - px0[left] > 0) return 0;</code>
    </li>
    <li>Придумаем формулу нахождения произведения между двумя индексами</li>
    <li>Поскольку левый и правый индекс включительно и префиксный массив имеет индексы на 1 больше чем исходный, то
    <code>result = px[right + 1] / px[left]</code>
  </li>
  </ol>
  <p>Сложность по времени O(1) на вычисление произведения</p>
  <p>Сложность по памяти O(1) на хранение результата</p>
</details>

<details>
  <summary>Код на javascript</summary>
<pre>
function px0Array(nums) {
  this.px0 = [0];
  for (const i = 0; i &lt; nums.length; i++) {
    if (nums[i] === 0) {
      px0[i+1] = px0[i] + 1;
    } else {
      px0[i+1] = px0[i];
    }
  }
}

function pxArray(nums) {
  this.px = [1];
  for (const i = 0; i &lt; nums.length; i++) {
    if (nums[i] === 0) {
      px[i+1] = px[i];
    } else {
      px[i+1] = px[i] * nums[i];
    }
  }
}

pxArray.prototype.multRange = function(left, right) {
  return this.px[right+1] / this.px[left];
};
</pre>
</details>

</article>


<!-- Задача 3. Индекс равных сумм -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача 3. Индекс равных сумм</h3>

  <p>Дан массив целых чисел nums. Нужно найти самый левый индекс элемента, такой, что сумма всех элементов справа и слева от него равны</p>
  <p>Если с какой-либо из сторон нет элементов - считаем сумму равной нулю, а если в массиве нет такого индекса, то нужно вернуть -1</p>

  <h4>Пример 1</h4>
  <code>Input: nums = [7,3,4,5,5]</code>
  <code>Output: 2 // 7+3 = 5+5</code>

  <h4>Пример 2</h4>
  <code>Input: nums = [0,0,0]</code>
  <code>Output: 0 // 0 = 0+0</code>

  <h4>Паттерн префиксный массив и суфиксный массив</h4>
  <p>Найдем префиксные и суфиксные суммы и составим из них массивы</p>
<pre>
nums =    [7,  3,  4,  5,  5]
           0   1   2   3   4
pref = [0, 3, 10, 14, 19, 24]
        0  1   2   3   4   5
suf  =   [24, 17, 14, 10,  5, 0]
           0  1   2   3   4   5
</pre>

  <p>В ответе будет 2 - это индекс элемента, у которого преффиксная сумма равна суффиксной сумме</p>
  <p>Сложность по времени O(N). Сложность по памяти O(N)</p>
  <p>Эту задачу можно решить без дополнительной памяти</p>

  <h4>Второй способ</h4>
  <p>Нам нужны два цикла от 0 до N</p>
  <p>В первом цикле найдем сумму всех элементов - это 24</p>
  <p>Во втором цикле будем определять сумму элементов слева ls и справа rs от текущего и сравнивать их.</p>
  <p>Если суммы равны, то ответом будет индекс текущего элемента</p>
  <p>Сложность по времени O(N). Сложность по памяти O(1)</p>

  <details>
    <summary>Код на javascript</summary>
<pre>
function pivotIndex(nums) {
  let numsSum = 0;
  for (const num of nums) {
    numsSum += num;
  }
  let leftSum = 0;
  for (let i = 0; i &lt; nums.length; i++) {
    let rightSum = numsSum - leftSum - nums[i];
    if (leftSum === rightSum) {
      return i;
    }
    leftSum += nums[i];
  }
  return -1;
}
</pre>
  </details>

  <details>
    <summary>Код на python</summary>
<pre>
class Solution:
  def pivotIndex(self, nums: list[int]) -> int:
    numsSum = sum(nums)

    leftSum = 0
    for i, num in enumerate(nums):
      rightSum = numsSum - leftSum - num
      if leftSum == rightSum:
        return i
      leftSum += num
    return -1
</pre>
  </details>

  <details>
    <summary>Код на C++</summary>
<pre>
class Solution {
public:
  int pivotIndex(vector&lt;int&gt;& nums) {
    int numSum = accumulate(nums, begin(), nums.end(), 0);
    int leftSum = 0;
    for (int i = 0; i &lt; nums.size(); i++) {
      int rightSum = numsSum - leftSum - nums[i];
      if (leftSum == rightSum) {
        return i;
      }
      leftSum += nums[i];
    }
    return -1;
  }
}
</pre>
  </details>

  <details>
    <summary>Код на go</summary>
<pre>
func pivotIndex(nums []int) int {
  numsSum := 0
  for _, num := range nums {
    numsSum += num
  }
  leftSum := 0
  for i, num := range nums {
    rightSum := numsSum - leftSum - num
    if leftSum == rightSum {
      return i
    }
    leftSum += num
  }
  return -1
}
</pre>
  </details>

  <details>
    <summary>Код на java</summary>
<pre>
class Solution {
  public int pivotIndex(int[] nums) {
    int numsSum = 0;
    for (int num : nums) {
      numsSum += num;
    }
    int leftSum = 0;
    for (int i = 0; i &lt; nums.length; i++) {
      int rightSum = numsSum - leftSum - nums[i];
      if (leftSum == rightSum) {
        return i;
      }
      leftSum += nums[i];
    }
    return -1;
  }
}
</pre>
  </details>
</article>


<!-- RoadMap для изучения префиксных массивов -->
<article class="article">
  <div class="anchor" id="roadmap2"></div>
  <h3>RoadMap для изучения префиксных массивов</h3>

  <ol>
    <li>
      <h4>Префиксный массив</h4>
      <p>Например, надо найти сумму на отрезке. Сначала создаем массив префиксных сумм за O(N) и на нем уже ищем сумму за O(1)</p>
    </li>
    <li>
      <h4>Два префиксных массива</h4>
      <p>Например, надо найти произведение на отрезке. Сначала создаем первый префиксный массив в котором сохраним только количество нулей. Во втором префиксном массиве сохраним произведение всех не нулевых элементов. Создание массива за O(N). Нахождение произведения за O(1)</p>
    </li>
    <li>
      <h4>Массив суффиксов</h4>
    </li>
    <li>
      <h4>Накопение суммы</h4>
      <p>Сначала ищем сумму элементов массива. Потом зная всю сумму мы избавляемся от дополнительной памяти</p>
    </li>
    <li>
      <h4>Запоминание предыдущих преффиксных сумм (хеш-таблица)</h4>
      <p>Паттерн запоминания предыдущих преффиксных сумм используется в задачах на хещ-таблицы, бинарные деревья.</p>
    </li>
    <li>
      <h4>2D - преффиксные суммы</h4>
      <p>Двумерные преффиксные суммы используются в матрицах в задачах на сумму, произведение или количество в любом месте матрицы. Также в задачах про строки, столбцы или дианонали матрицы</p>
    </li>
  </ol>

  <h4>Оценка сложности преффиксного массива</h4>
  <p>Сложность по времени O(N)</p>
  <p>Сложность по памяти O(N) если храним преффиксный массив, сложность O(1) если не храним.</p>

  <p>Подходит для:</p>
  <ol>
    <li>Сумма элементов на отрезке</li>
    <li>Произведение элементов на отрезке</li>
    <li>XOR элементов на отрезке</li>
    <li>Количество четных на отрезке</li>
    <li>Количество с каким-то свойством</li>
    <li>База данных. Предагрегативная функция. Надо найти среднее значение на отрезке</li>
  </ol>
  <p>Не подходит для:</p>
  <ol>
    <li>Поиск min или max на отрезке. Для операций у которых нет обратных</li>
    <li>При модификации массива</li>
  </ol>
</article>


<!-- Вопросы и ответы -->
<article class="article">
  <div class="anchor" id="qa"></div>
  <h3>Вопросы и ответы</h3>
</article>


<!-- Задача 4. Пропущенное число -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача 4. Пропущенное число</h3>

  <p>Дан массив целых чисел nums, содержащий n целых чисел в диапазоне [0, n] включительно. Нужно вернуть единственное число из диапазона [0, n] которое отсутствует</p>

  <p>В массиве nums гарантированно отсутствует только одно число из диапазона [0,n], все остальные числа из диапазона встречаются ровно один раз</p>

  <h4>Пример</h4>
  <code>nums = [3, 1, 5, 0, 2] // 4</code>

  <h4>Решение</h4>
  <p>Это задача не алгоритмическая. Это задача математическая. В массиве все числа от 0 до n встречаются только один раз. Одного числа там нет. Найдем сумму всех чисел от 0 до n. Это будет sum1. Найдем сумму всех чисел во входном массиве. Это будет sum2.</p>
  <code>sum1 = 0 + 1 + 2 + 3 + 4 + 5 = 15</code>
  <code>sum2 = 3 + 1 + 5 + 0 + 2 = 11</code>
  <p>Сумма sum2 отличается от суммы sum1 на одно число - которого нет во входном массиве</p>
  <code>result = sum1 - sum2</code>
  <p>Сложность по времени O(N)</p>
  <p>Сложность по памяти O(1)</p>

  <details>
    <summary>Алгоритм</summary>

    <ol>
      <li>Находим сумму чисел он 0 до n. Это можно сделать по формуле суммы чисел в арифметической прогрессии
        <code>sum1 = (min + max) * kol / 2</code>
        <p>min = 0 минимальное число</p>
        <p>max = 5 максимальное число</p>
        <p>kol = 6 количество чисел</p>
        <code>sum1 = (0 + 5) * 6 / 2 = 15</code>
        <p>В коде запишем</p>
        <code>const sum1 = (nums.length - 1) * nums.length / 2;</code>
      </li>
      <li>Находим сумму чисел во входном массиве
<pre>
let sum2 = 0;
for (const num of nums) {
  sum2 += num;
}
</pre>
      </li>
      <li>Возвращаем результат
        <code>return sum1 - sum2;</code>
      </li>
    </ol>
  </details>

  <details>
    <summary>Код на javascript</summary>
<pre>
function lessNum(nums) {
  const sum1 = (nums.length - 1) * nums.length / 2;
  let sum2 = 0;
  for (const num of nums) {
    sum2 += num;
  }

  return sum1 - sum2;
}
</pre>
  </details>
</article>

