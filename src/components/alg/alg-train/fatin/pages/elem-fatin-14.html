<h1>Плавающее окно</h1>


<article class="article">
  <p>Конспект видео от 2024-11-09</p>
  <h4>Оседлай плавающее окно</h4>

  <p><a href="https://www.youtube.com/@fatin.maksim/videos">youtube Максим Фатин</a></p>
  <p><a href="https://algocode.io/">https://algocode.io/</a></p>
  <p><a href="https://tskills.ru/algo">https://tskills.ru/algo</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p><a href="#about">План на стрим</a></p>
  <p><a href="#neud">Как проходит типичное неудачное собеседование</a></p>
  <p><a href="#roadmap">Roadmap для BigTech по теме Sliding Window</a></p>
  <p><a href="#task1">Задача 1. Максимальная сумма</a></p>
  <p><a href="#task2">Задача 2. Сжатие значений счетчика</a></p>
  <p><a href="#task3">Задача 3. Цепочка уникальных генов</a></p>
  <p><a href="#task4">Задача 4. Наглый подставной отчет</a></p>
</article>


<!-- План на стрим -->
<article class="article">
  <div class="anchor" id="about"></div>
  <h3>План на стрим</h3>

  <ol>
    <li>Почему проваливаются собесы</li>
    <li>RoadMap для изучения плавающего окна</li>
    <li>Решим задачи с собеседования Яндекса, ВК, Сбера и Озона</li>
  </ol>

  <p>Сегодня у нас в программе хаканье плавающего окна. В самом начале посмотрим почему проваливаются алгоритмические собесы. Какая основная причина. Посмотрим RoadMap для изучения плавающего окна, какие там есть подтемы. Какие время и память. И решим актуальные задачки с собеседований. То что сейчас актуально. Не то что пылится в книгах, здесь будет самый свежак. То что нужно чтобы попасть в BigTech.</p>
</article>


<!-- Как проходит типичное неудачное собеседование -->
<article class="article">
  <div class="anchor" id="neud"></div>
  <h3>Как проходит типичное неудачное собеседование</h3>

  <ol>
    <li>Рассказывают правила собеса</li>
    <li>Ты читаешь условие</li>
    <li>Охреневаешь от задачки</li>
    <li>Думаешь</li>
    <li>А интервьюер молчит</li>
    <li>Конец</li>
  </ol>

  <p>Обычно интервьюер приходит на собеседование очень уставший. Говорит что у тебя есть 20мин на первую задачку и 40 мин на вторую задачку. Это если Яндекс. В ВК у тебя есть 60 мин, нужно решить одну задачу, но задача потяжелее. Еще есть третья задача, она идет как дополнительная, если ты ее решаешь, то идет достаточно высокий грейд за эту секцию. Каждая секция оценивается в грейде. Если круто все зарешал - сеньер. Если решил две задачи но быстро и хорошо - мидл плюс.</p>
  <p>После этого тебе дают условие к первой задачке. В этот момент ты можешь офигеть, потому что такого ты нигде не видел. Думаешь что мне дали? Я на литкоде решал одно, тут совсем другое. Ты начинаешь думать, а интервьюер как назло молчит. У него был неудачный день и досвидания. Вам нужна подсказка, а интервьюер просто сидит и смотрит на вас.</p>
  <p>У меня такое было и мне было неприятно. Когда я сам стал интервьюер я такого не допускаю. Но у меня прям это засело. Иногда он может не молчать, а что-то говорить, что-то подсказывать, но к конечному решению так и неудается прийти. Даже в какой-то момент ты можешь начать писать код. Но что-то все равно идет не так.</p>

  <h4>В чем причина</h4>
  <ol>
    <li>Сложно придумать идею решения</li>
    <li>Сложно оценить решение по времени и памяти</li>
    <li>Сложно написать код</li>
  </ol>

  <p>Ты рассказываешь идею задачи, потом оцениваешь ее по времени и памяти. Потом пишешь код. Что самое сложное? Придумать идею решения - это детально продумать как это будет выглядеть, до мелочей. Интервьюеру обычно рассказывается общая идея.</p>
  <p>Самое сложное это придумать идею решения. Бывают ошибки интервьюеров, когда пускаю кандидата писать код, но кандидат до конца его еще не продумал. Это самое плохое. Тебе кажется что ты все придумал. Начинаешь писать код. А потом не знаешь как быть дальше, этот случай не продумал, тот случай не учел.</p>
  <p>У каждого решения, у каждого паттерна, который мы сегодня рассмотрим есть оценка сложности по времени и памяти.</p>
</article>


<!-- Roadmap для BigTech по теме Sliding Window -->
<article class="article">
  <div class="anchor" id="roadmap"></div>
  <h3>Roadmap для BigTech по теме Sliding Window</h3>

  <h4>Плавающее окно</h4>
  <ol>
    <li>
      <h4>Окна фиксированной длины</h4>
      <p>Сложность по времени O(N)</p>
      <p>Сложность по памяти O(1)</p>
    </li>
    <li>
      <h4>Пересекающиеся окна</h4>
      <p>Сложность по времени O(N)</p>
      <p>Сложность по памяти O(1)</p>
    </li>
    <li>
      <h4>Не пересекающиеся окна</h4>
      <p>Сложность по времени O(N)</p>
      <p>Сложность по памяти O(1)</p>
    </li>
  </ol>

  <h4>Как определить тип</h4>
  <p>Если в задаче дан массив и нужно что-то делать с k подряд идущими элементами. Например, найти максимальную сумму k подряд идущих элементов. Или найти XOR k подряд идущих элементов. Мы берем плавающее окно из k элементов. Мы его передвигаем и в нем всегда находится одинаковое число элементов. Это окно фиксированной длины.</p>
  <p>Если есть условие, которое группирует элементы. Например, найти максимальное число подряд идущих единичек. Окна максимально широкие, включают все подряд идущие единички, а не только часть их. Тогда это не пересекающиеся окна.</p>
  <p>Если ответы могут пересекаться то это пересекающиеся окна. Задачи на пересекающиеся окна самые сложные.</p>
  <p>Потренируемся: я показываю задачу и читаю условие, а ты говоришь пересекающиеся окна или нет. 1. Фиксированного размера. 2. Пересекающиеся. 3. Не пересекающиеся</p>
</article>


<!-- Задача 1. Максимальная сумма -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача 1. Максимальная сумма</h3>

  <p>Дан массив чисел nums  и число k. Нужно вернуть одно число - максимальную сумму k подряд идущих элементов</p>

  <h4>Пример</h4>
  <code>Input: nums = [3,2,5,9,4,1], k = 3</code>
  <code>Output: 18</code>

  <h4>Паттерн плавающее окно фиксированного размера</h4>

  <p>Нужно искать состояние. Здесь состояние это сумма элементов плавающего окна. Первое состояние это сумма первых k элементов</p>
  <code>sum1 = 3+2+5 = 10</code>
  <p>Второе состояние это сумма k элементов, начиная со второго. Чтобы не считать заново сумму уже известных элементов, нужно научиться переходить из первого состояния во второе.</p>
  <p>Если из первого состояния вычесть первый элемент и прибавить следующий за последним элемент, то получим второе состояние</p>
  <code>sum2 = sum1 - 3 + 9 = 16</code>
  <p>Заведем два указателя. Пусть левый указатель указывает на элемент который нуно вычесть, а правый - на элемент который нужно прибавить, чтобы получить следующую сумму плавающего окна</p>
  <p>Когда посчитаем следующую сумму, обновляем ответ и двигаем указатели вправо на 1.</p>
  <code>sum3 = sum2 - 2 + 4 = 18</code>
  <code>sum4 = sum3 - 5 + 1 = 14</code>
  <p>В ответ возвращаем максимальную сумму 18</p>

  <p>Сложность по времени O(N)</p>
  <p>Сложность по памяти O(1)</p>

  <details>
    <summary>Код на javascript</summary>
<pre>
function maxSum(nums, k) {
    const n = nums.length;
    if (k > n) {
        return 0;
    }

    let currSum = 0;
    for (let i = 0; i &lt; k; i++) {
        currSum += nums[i];
    }

    let maxSumResult = currSum;

    for (let i = k; i &lt; n; i++) {
        currSum = currSum - nums[i - k] + nums[i];
        maxSumResult = Math.max(maxSumResult, currSum);
    }

    return maxSumResult;
}
</pre>
  </details>

  <details>
    <summary>Код на python</summary>
<pre>
from typing import List

def max_sum(nums: List[int], k: int) -> int:
    n = len(nums)
    if k > n:
        return 0

    # Находим сумму первых k элементов
    curr_sum = sum(nums[:k])
    max_sum_result = curr_sum

    # Двигаем окно по массиву
    for i in range(k, n):
        # Обновляем сумму: вычитаем первый элемент предыдущего окна, добавляем новый
        curr_sum = curr_sum - nums[i - k] + nums[i]
        # Обновляем максимальную сумму, если нужно
        if curr_sum > max_sum_result:
            max_sum_result = curr_sum
    return max_sum_result
</pre>
  </details>

  <details>
    <summary>Код на c++</summary>
<pre>
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int maxSum(const std::vector&lt;int&gt;& nums, int k) {
    int n = nums.size();
    if (k > n) {
        return 0;
    }

    int curr_sum = 0;
    for (int i = 0; i &lt; k; ++i) {
        curr_sum += nums[i];
    }

    int max_sum_result = curr_sum;

    for (int i = k; i &lt; n; ++i) {
        curr_sum = curr_sum - nums[i - k] + nums[i];
        max_sum_result = std::max(max_sum_result, curr_sum);
    }

    return max_sum_result;
}
</pre>
  </details>


  <details>
    <summary>Код на java</summary>
<pre>
public class Solution {
    public static int maxSum(int[] nums, int k) {
        int n = nums.length;
        if (k > n) {
            return 0;
        }

        int currSum = 0;
        for (int i = 0; i &lt; k; i++) {
            currSum += nums[i];
        }

        int maxSumResult = currSum;

        for (int i = k; i &lt; n; i++) {
            currSum = currSum - nums[i - k] + nums[i];
            maxSumResult = Math.max(maxSumResult, currSum);
        }

        return maxSumResult;
    }
}
</pre>
  </details>


  <details>
    <summary>Код на go</summary>
<pre>
func maxSum(nums []int, k int) int {
    n := len(nums)
    if k > n {
        return 0
    }

    currSum := 0
    for i := 0; i &lt; k; i++ {
        currSum += nums[i]
    }

    maxSumResult := currSum

    for i := k; i &lt; n; i++ {
        currSum = currSum - nums[i-k] + nums[i]
        if currSum > maxSumResult {
            maxSumResult = currSum
        }
    }

    return maxSumResult
}
</pre>
  </details>

</article>


<!-- Задача 2. Сжатие значений счетчика -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача 2. Сжатие значений счетчика</h3>

  <p>Дан массив уникальных чисел counter, отсортированный по возрастанию, где counter[i] содержит значение метрики в i-ую секунду</p>
  <p>Смотреть на изменения счетчика очень сложно, особенно, когда массив counter очень большой, поэтому нужно объединить все подряд идущие числа на сколько это возможно</p>
  <p>Правила объединения (сжатия) достаточно простые: можно объединять только подряд идущие числа, например, [1,2,3,4] -> ["1->3", "7"]</p>
  <p>"x->y" если есть непрерывно возрастающая последовательность (возрастает на 1) от x до y</p>
  <p>"x" если элементы рядом отличаются больше, чем на 1</p>

  <h4>Пример 1</h4>
  <code>Input: counter = [1,2,3,4,5,8,10,15,16,20]</code>
  <code>["1->5","8","10","15->16","20]</code>

  <h4>Пример 2</h4>
  <code>Input: counter = [-2,-3]</code>
  <code>Output: ["-2->-3"]</code>

  <h4>Паттерн не пересекающиеся плавающие окна</h4>
</article>


<!-- Задача 3. Цепочка уникальных генов -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача 3. Цепочка уникальных генов</h3>

  <p>Дана строка gene, обозначающая последовательность генов. Каждый ген закодирован одной буквой английского алфавита.</p>
  <p>Найти самую длинную непрерываную последовательность генов без повторов (без одинаковых букв)</p>

  <h4>Пример 1</h4>
  <code>Input: gene = "yxyabcxyx"</code>
  <code>Output: 5 // "yabcx"</code>

  <h4>Пример 2</h4>
  <code>Input: gene = "Aac"</code>
  <code>Output: 3</code>

  <h4>Пример 3</h4>
  <code>Input: gene = "ffff"</code>
  <code>Output: 1</code>

  <h4>Паттерн пересекающиеся плавающие окна</h4>
</article>


<!-- Задача 4. Наглый подставной отчет -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача 4. Наглый подставной отчет</h3>

  <p>Дан массив stock, где stock[i] = 1, означает, что в i-ый день акции компании росли, а stock[i] = 0 - падали</p>
  <p>Компания терпит убытки и нужны дополнительные инвестиции, поэтому компания делает наглый подставной отчет для инвесторов. Тебе поручили написать программу, которая поможет посчитать максимальное число дней, когда акции компании непрерывно росли, при этом можно заменить k-дней, когда акции падали на день, когда они росли (т.е. можно заменить k нулей на 1)</p>

  <h4>Пример 1</h4>
  <code>Input: stock = [1,0,1,1,0,1,1,0], k = 2</code>
  <code>Output: 7 // [1,1,1,1,1,1,1,0]</code>

  <h4>Пример 2</h4>
  <code>Input: stock = [1,0,0,1], k = 1</code>
  <code>Output: 2 // [1,1,0,1]</code>

  <h4>Паттерн пересекающиеся плавающие окна</h4>
</article>

