<h1>Плавающее окно</h1>


<article class="article">
  <p>Конспект видео от 2024-11-09</p>
  <h4>Оседлай плавающее окно</h4>

  <p><a href="https://www.youtube.com/@fatin.maksim/videos">youtube Максим Фатин</a></p>
  <p><a href="https://algocode.io/">https://algocode.io/</a></p>
  <p><a href="https://tskills.ru/algo">https://tskills.ru/algo</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p><a href="#about">План на стрим</a></p>
  <p><a href="#neud">Как проходит типичное неудачное собеседование</a></p>
  <p><a href="#roadmap">Roadmap для BigTech по теме Sliding Window</a></p>
  <p><a href="#task1">Задача 1. Максимальная сумма k элементов</a></p>
  <p><a href="#task2">Задача 2. Сжатие значений счетчика</a></p>
  <p><a href="#task3">Задача 3. Цепочка уникальных генов</a></p>
  <p><a href="#task4">Задача 4. Наглый подставной отчет</a></p>
  <p><a href="#fix">Паттерн плавающее окно фиксированного размера</a></p>
  <p><a href="#task5">Задача 5. Максимальное произведение</a></p>
  <p><a href="#task6">Задача 6. Сжатие строки</a></p>
  <p><a href="#slide">Паттерн не пересекающиеся плавающие окна</a></p>
</article>


<!-- План на стрим -->
<article class="article">
  <div class="anchor" id="about"></div>
  <h3>План на стрим</h3>

  <ol>
    <li>Почему проваливаются собесы</li>
    <li>RoadMap для изучения плавающего окна</li>
    <li>Решим задачи с собеседования Яндекса, ВК, Сбера и Озона</li>
  </ol>

  <p>Сегодня у нас в программе хаканье плавающего окна. В самом начале посмотрим почему проваливаются алгоритмические собесы. Какая основная причина. Посмотрим RoadMap для изучения плавающего окна, какие там есть подтемы. Какие время и память. И решим актуальные задачки с собеседований. То что сейчас актуально. Не то что пылится в книгах, здесь будет самый свежак. То что нужно чтобы попасть в BigTech.</p>
</article>


<!-- Как проходит типичное неудачное собеседование -->
<article class="article">
  <div class="anchor" id="neud"></div>
  <h3>Как проходит типичное неудачное собеседование</h3>

  <ol>
    <li>Рассказывают правила собеса</li>
    <li>Ты читаешь условие</li>
    <li>Охреневаешь от задачки</li>
    <li>Думаешь</li>
    <li>А интервьюер молчит</li>
    <li>Конец</li>
  </ol>

  <p>Обычно интервьюер приходит на собеседование очень уставший. Говорит что у тебя есть 20мин на первую задачку и 40 мин на вторую задачку. Это если Яндекс. В ВК у тебя есть 60 мин, нужно решить одну задачу, но задача потяжелее. Еще есть третья задача, она идет как дополнительная, если ты ее решаешь, то идет достаточно высокий грейд за эту секцию. Каждая секция оценивается в грейде. Если круто все зарешал - сеньер. Если решил две задачи но быстро и хорошо - мидл плюс.</p>
  <p>После этого тебе дают условие к первой задачке. В этот момент ты можешь офигеть, потому что такого ты нигде не видел. Думаешь что мне дали? Я на литкоде решал одно, тут совсем другое. Ты начинаешь думать, а интервьюер как назло молчит. У него был неудачный день и досвидания. Вам нужна подсказка, а интервьюер просто сидит и смотрит на вас.</p>
  <p>У меня такое было и мне было неприятно. Когда я сам стал интервьюер я такого не допускаю. Но у меня прям это засело. Иногда он может не молчать, а что-то говорить, что-то подсказывать, но к конечному решению так и неудается прийти. Даже в какой-то момент ты можешь начать писать код. Но что-то все равно идет не так.</p>

  <h4>В чем причина</h4>
  <ol>
    <li>Сложно придумать идею решения</li>
    <li>Сложно оценить решение по времени и памяти</li>
    <li>Сложно написать код</li>
  </ol>

  <p>Ты рассказываешь идею задачи, потом оцениваешь ее по времени и памяти. Потом пишешь код. Что самое сложное? Придумать идею решения - это детально продумать как это будет выглядеть, до мелочей. Интервьюеру обычно рассказывается общая идея.</p>
  <p>Самое сложное это придумать идею решения. Бывают ошибки интервьюеров, когда пускаю кандидата писать код, но кандидат до конца его еще не продумал. Это самое плохое. Тебе кажется что ты все придумал. Начинаешь писать код. А потом не знаешь как быть дальше, этот случай не продумал, тот случай не учел.</p>
  <p>У каждого решения, у каждого паттерна, который мы сегодня рассмотрим есть оценка сложности по времени и памяти.</p>
</article>


<!-- Roadmap для BigTech по теме Sliding Window -->
<article class="article">
  <div class="anchor" id="roadmap"></div>
  <h3>Roadmap для BigTech по теме Sliding Window</h3>

  <h4>Плавающее окно</h4>
  <ol>
    <li>
      <h4>Окна фиксированной длины</h4>
      <p>Сложность по времени O(N)</p>
      <p>Сложность по памяти O(1)</p>
    </li>
    <li>
      <h4>Пересекающиеся окна</h4>
      <p>Сложность по времени O(N)</p>
      <p>Сложность по памяти O(1)</p>
    </li>
    <li>
      <h4>Не пересекающиеся окна</h4>
      <p>Сложность по времени O(N)</p>
      <p>Сложность по памяти O(1)</p>
    </li>
  </ol>

  <h4>Как определить тип</h4>
  <p>Если в задаче дан массив и нужно что-то делать с k подряд идущими элементами. Например, найти максимальную сумму k подряд идущих элементов. Или найти XOR k подряд идущих элементов. Мы берем плавающее окно из k элементов. Мы его передвигаем и в нем всегда находится одинаковое число элементов. Это окно фиксированной длины.</p>
  <p>Если есть условие, которое группирует элементы. Например, найти максимальное число подряд идущих единичек. Окна максимально широкие, включают все подряд идущие единички, а не только часть их. Тогда это не пересекающиеся окна.</p>
  <p>Если ответы могут пересекаться то это пересекающиеся окна. Задачи на пересекающиеся окна самые сложные.</p>
  <p>Потренируемся: я показываю задачу и читаю условие, а ты говоришь пересекающиеся окна или нет. 1. Фиксированного размера. 2. Пересекающиеся. 3. Не пересекающиеся</p>
</article>


<!-- Задача 1. Максимальная сумма k элементов -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача 1. Максимальная сумма k элементов</h3>

  <p>Дан массив чисел nums  и число k. Нужно вернуть одно число - максимальную сумму k подряд идущих элементов</p>

  <h4>Пример</h4>
  <code>Input: nums = [3,2,5,9,4,1], k = 3</code>
  <code>Output: 18</code>

  <h4>Паттерн плавающее окно фиксированного размера</h4>

  <p>Нужно искать состояние. Здесь состояние это сумма элементов плавающего окна. Первое состояние это сумма первых k элементов</p>
  <code>sum1 = 3+2+5 = 10</code>
  <p>Второе состояние это сумма k элементов, начиная со второго. Чтобы не считать заново сумму уже известных элементов, нужно научиться переходить из первого состояния во второе.</p>
  <p>Если из первого состояния вычесть первый элемент и прибавить следующий за последним элемент, то получим второе состояние</p>
  <code>sum2 = sum1 - 3 + 9 = 16</code>
  <p>Заведем два указателя. Пусть левый указатель указывает на элемент который нуно вычесть, а правый - на элемент который нужно прибавить, чтобы получить следующую сумму плавающего окна</p>
  <p>Когда посчитаем следующую сумму, обновляем ответ и двигаем указатели вправо на 1.</p>
  <code>sum3 = sum2 - 2 + 4 = 18</code>
  <code>sum4 = sum3 - 5 + 1 = 14</code>
  <p>В ответ возвращаем максимальную сумму 18</p>

  <p>Сложность по времени O(N)</p>
  <p>Сложность по памяти O(1)</p>

  <details>
    <summary>Код на javascript</summary>
<pre>
function maxSum(nums, k) {
    const n = nums.length;
    if (k > n) {
        return 0;
    }

    let currSum = 0;
    for (let i = 0; i &lt; k; i++) {
        currSum += nums[i];
    }

    let maxSumResult = currSum;

    for (let i = k; i &lt; n; i++) {
        currSum = currSum - nums[i - k] + nums[i];
        maxSumResult = Math.max(maxSumResult, currSum);
    }

    return maxSumResult;
}
</pre>
  </details>

  <details>
    <summary>Код на python</summary>
<pre>
from typing import List

def max_sum(nums: List[int], k: int) -> int:
    n = len(nums)
    if k > n:
        return 0

    # Находим сумму первых k элементов
    curr_sum = sum(nums[:k])
    max_sum_result = curr_sum

    # Двигаем окно по массиву
    for i in range(k, n):
        # Обновляем сумму: вычитаем первый элемент предыдущего окна, добавляем новый
        curr_sum = curr_sum - nums[i - k] + nums[i]
        # Обновляем максимальную сумму, если нужно
        if curr_sum > max_sum_result:
            max_sum_result = curr_sum
    return max_sum_result
</pre>
  </details>

  <details>
    <summary>Код на c++</summary>
<pre>
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int maxSum(const std::vector&lt;int&gt;& nums, int k) {
    int n = nums.size();
    if (k > n) {
        return 0;
    }

    int curr_sum = 0;
    for (int i = 0; i &lt; k; ++i) {
        curr_sum += nums[i];
    }

    int max_sum_result = curr_sum;

    for (int i = k; i &lt; n; ++i) {
        curr_sum = curr_sum - nums[i - k] + nums[i];
        max_sum_result = std::max(max_sum_result, curr_sum);
    }

    return max_sum_result;
}
</pre>
  </details>


  <details>
    <summary>Код на java</summary>
<pre>
public class Solution {
    public static int maxSum(int[] nums, int k) {
        int n = nums.length;
        if (k > n) {
            return 0;
        }

        int currSum = 0;
        for (int i = 0; i &lt; k; i++) {
            currSum += nums[i];
        }

        int maxSumResult = currSum;

        for (int i = k; i &lt; n; i++) {
            currSum = currSum - nums[i - k] + nums[i];
            maxSumResult = Math.max(maxSumResult, currSum);
        }

        return maxSumResult;
    }
}
</pre>
  </details>


  <details>
    <summary>Код на go</summary>
<pre>
func maxSum(nums []int, k int) int {
    n := len(nums)
    if k > n {
        return 0
    }

    currSum := 0
    for i := 0; i &lt; k; i++ {
        currSum += nums[i]
    }

    maxSumResult := currSum

    for i := k; i &lt; n; i++ {
        currSum = currSum - nums[i-k] + nums[i]
        if currSum > maxSumResult {
            maxSumResult = currSum
        }
    }

    return maxSumResult
}
</pre>
  </details>

</article>


<!-- Задача 2. Сжатие значений счетчика -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача 2. Сжатие значений счетчика</h3>

  <h4>Leetcode 228. Summary Ranges</h4>

  <p>Дан массив уникальных чисел counter, отсортированный по возрастанию, где counter[i] содержит значение метрики в i-ую секунду</p>
  <p>Смотреть на изменения счетчика очень сложно, особенно, когда массив counter очень большой, поэтому нужно объединить все подряд идущие числа на сколько это возможно</p>
  <p>Правила объединения (сжатия) достаточно простые: можно объединять только подряд идущие числа, например, [1,2,3,4] -> ["1->3", "7"]</p>
  <p>"x->y" если есть непрерывно возрастающая последовательность (возрастает на 1) от x до y</p>
  <p>"x" если элементы рядом отличаются больше, чем на 1</p>

  <h4>Пример 1</h4>
  <code>Input: counter = [1,2,3,4,5,8,10,15,16,20]</code>
  <code>["1->5","8","10","15->16","20]</code>

  <h4>Пример 2</h4>
  <code>Input: counter = [-2,-3]</code>
  <code>Output: ["-2->-3"]</code>

  <h4>Паттерн не пересекающиеся плавающие окна</h4>

  <p>Заведем два указателя l левый и r правый. Поставим их на первый элемент массива. Этот один элемент будет в нашем первом плавающем окне. Пока левый указатель не выйдет за границы массива, будем продолжать делать одни и те же действия. Пытаемся сдвинуть правый указатель максимально далеко.</p>
  <p>Ставим правый указатель на следующий элемент и сравниваем его с предыдущим. Если они отличаются на 1 значит берем этот элемент в наше плавающее окно, иначе этот элемент уже не берем в наше плавающее окно и останавливаемся.</p>
  <p>Теперь нужно добавить в ответ это плавающее окно. Сравниваем два указателя. Если они одинаковый, то это один элемент и просто добавляем его в ответ. Если они разные, то это диапазон элементов и добавляем его в ответ со стрелочкой "->"</p>
  <p>Переходим к следующему плавающему окну. Передвигаем левый и правый указатель на следующий элемент после предыдущего плавающего окна.</p>
  <details>
    <summary>Код на javascript</summary>
<pre>
function summaryRanges(nums) {
    let l = 0;
    let r = 0;
    let result = [];
    while (l &lt; nums.length) {
        // before
        // l
        // 1 2 3 5 7 8
        // r

        // бежим правым указателем пока в интервале [l, r]
        // находятся все последовательные числа
        while (r + 1 &lt; nums.length && nums[r] + 1 === nums[r + 1]) {
            r += 1;
        }
        // after
        // l
        // 1 2 3 5 7 8
        //     r
        // бежим правым указателем

        // добавлем в ответ
        if (r !== l) {
            result.push(`${nums[l]}->${nums[r]}`);
        } else {
            result.push(`${nums[l]}`);
        }

        // интервалы не пересекаются, поэтому сдвигаем
        // на r + 1 - именно отсюда будет начинаться
        // следующий интервал
        l = r + 1;
        r = r + 1;
    }
    return result;
};
</pre>
  </details>

  <details>
    <summary>Код на python</summary>
<pre>
class Solution:
    # time: O(n)
    # mem:  O(n), без учета памяти на ответ O(1)
    def summaryRanges(self, nums: List[int]) -> List[str]:
        l = 0
        r = 0
        result = []
        while l &lt; len(nums):
            # before
            # l
            # 1 2 3 5 7 8
            # r

            # бежим правым указателем пока в интервале [l, r]
            # находятся все последовательные числа
            while r + 1 &lt; len(nums) and nums[r] + 1 == nums[r + 1]:
                r += 1
            # after
            # l
            # 1 2 3 5 7 8
            #     r
            # бежим правым указателем

            # добавлем в ответ
            if r != l:
                result.append(f'{nums[l]}->{nums[r]}')
            else:
                result.append(f'{nums[l]}')

            # интервалы не пересекаются, поэтому сдвигаем
            # на r + 1 - именно отсюда будет начинаться
            # следующий интервал
            l = r + 1
            r = r + 1
        return result
</pre>
  </details>

  <details>
    <summary>Код на go</summary>
<pre>
func summaryRanges(nums []int) []string {
	l := 0
	r := 0
	result := []string{}
	for l &lt; len(nums) {
		// before
		// l
		// 1 2 3 5 7 8
		// r

		// бежим правым указателем пока в интервале [l, r]
		// находятся все последовательные числа
		for r+1 &lt; len(nums) && nums[r]+1 == nums[r+1] {
			r += 1
		}
		// after
		// l
		// 1 2 3 5 7 8
		//     r
		// бежим правым указателем

		// добавлем в ответ
		if r != l {
			result = append(result, fmt.Sprintf("%d->%d", nums[l], nums[r]))
		} else {
			result = append(result, fmt.Sprintf("%d", nums[l]))
		}

		// интервалы не пересекаются, поэтому сдвигаем
		// на r + 1 - именно отсюда будет начинаться
		// следующий интервал
		l = r + 1
		r = r + 1
	}
	return result
}
</pre>
  </details>

  <details>
    <summary>Код на C++</summary>
<pre>
class Solution {
public:
    // time: O(n)
    // mem:  O(n), без учета памяти на ответ O(1)
    vector<string> summaryRanges(vector<int>& nums) {
        int l = 0;
        int r = 0;
        vector<string> result;
        while (l &lt; nums.size()) {
            // before
            // l
            // 1 2 3 5 7 8
            // r

            // бежим правым указателем пока в интервале [l, r]
            // находятся все последовательные числа
            while (r + 1 &lt; nums.size() && nums[r] + 1 == nums[r + 1]) {
                r += 1;
            }
            // after
            // l
            // 1 2 3 5 7 8
            //     r
            // бежим правым указателем

            // добавлем в ответ
            if (r != l) {
                result.push_back(to_string(nums[l]) + "->" + to_string(nums[r]));
            } else {
                result.push_back(to_string(nums[l]));
            }

            // интервалы не пересекаются, поэтому сдвигаем
            // на r + 1 - именно отсюда будет начинаться
            // следующий интервал
            l = r + 1;
            r = r + 1;
        }
        return result;
    }
};
</pre>
  </details>

<details>
  <summary>Код на java</summary>
<pre>
class Solution {
    public List&lt;String&gt; summaryRanges(int[] nums) {
        List&lt;String&gt; result = new ArrayList&lt;&gt;();
        int l = 0;
        int r = 0;
        while (l &lt; nums.length) {
            // before
            // l
            // 1 2 3 5 7 8
            // r

            // бежим правым указателем пока в интервале [l, r]
            // находятся все последовательные числа
            while (r + 1 &lt; nums.length && nums[r] + 1 == nums[r + 1]) {
                r += 1;
            }
            // after
            // l
            // 1 2 3 5 7 8
            //     r
            // бежим правым указателем

            // добавлем в ответ
            if (r != l) {
                result.add(nums[l] + "->" + nums[r]);
            } else {
                result.add(String.valueOf(nums[l]));
            }

            // интервалы не пересекаются, поэтому сдвигаем
            // на r + 1 - именно отсюда будет начинаться
            // следующий интервал
            l = r + 1;
            r = r + 1;
        }
        return result;
    }
}
</pre>
  </details>
</article>


<!-- Задача 3. Цепочка уникальных генов -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача 3. Цепочка уникальных генов</h3>

  <p>Дана строка gene, обозначающая последовательность генов. Каждый ген закодирован одной буквой английского алфавита.</p>
  <p>Найти самую длинную непрерываную последовательность генов без повторов (без одинаковых букв)</p>

  <h4>Пример 1</h4>
  <code>Input: gene = "yxyabcxyx"</code>
  <code>Output: 5 // "yabcx"</code>

  <h4>Пример 2</h4>
  <code>Input: gene = "Aac"</code>
  <code>Output: 3</code>

  <h4>Пример 3</h4>
  <code>Input: gene = "ffff"</code>
  <code>Output: 1</code>

  <h4>Паттерн пересекающиеся плавающие окна</h4>
</article>


<!-- Задача 4. Наглый подставной отчет -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача 4. Наглый подставной отчет</h3>

  <p>Дан массив stock, где stock[i] = 1, означает, что в i-ый день акции компании росли, а stock[i] = 0 - падали</p>
  <p>Компания терпит убытки и нужны дополнительные инвестиции, поэтому компания делает наглый подставной отчет для инвесторов. Тебе поручили написать программу, которая поможет посчитать максимальное число дней, когда акции компании непрерывно росли, при этом можно заменить k-дней, когда акции падали на день, когда они росли (т.е. можно заменить k нулей на 1)</p>

  <h4>Пример 1</h4>
  <code>Input: stock = [1,0,1,1,0,1,1,0], k = 2</code>
  <code>Output: 7 // [1,1,1,1,1,1,1,0]</code>

  <h4>Пример 2</h4>
  <code>Input: stock = [1,0,0,1], k = 1</code>
  <code>Output: 2 // [1,1,0,1]</code>

  <h4>Паттерн пересекающиеся плавающие окна</h4>
</article>


<!-- Паттерн плавающее окно фиксированного размера -->
<article class="article">
  <div class="anchor" id="fix"></div>
  <h3>Паттерн плавающее окно фиксированного размера</h3>

  <h4>Алгоритм работы с плавающим окном фиксированного размера</h4>
  <code>3, 2, 5, 9, 4, 1</code>

  <ol>
    <li>Работаем с первыми k элементами</li>
    <li>Определяем оптимальный алгоритм перехода</li>
  </ol>
</article>


<!-- Задача 5. Максимальное произведение -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача 5. Максимальное произведение</h3>

  <p>На вход приходит последовательность чисел nums и число k. Найти максимальное произведение k подряд идущих чисел</p>
  <p>В последовательности могут быть нули</p>

  <h4>Пример</h4>
  <code>Input nums = [4, 0, 5, 2, 4, 1, 0]</code>
  <code>Output 40 // 5*2*4</code>

  <h4>Идея решения</h4>
  <ol>
    <li>Подсчитывать произведение ненулевых элементов</li>
    <li>Подсчитывать число нулей внутри плавающего окна</li>
  </ol>

  <h4>Работаем с первыми k элементами</h4>
  <p>Произведение внутри плавающего окна равно произведению ненулевых элементов, если количество нулей равно нулю. Произведение равно нулю если количество нулей больше нуля</p>
  <p>Нужно три переменные. Переменная max хранит максимальное произведение k элементов. Переменная cur хранит текущее произведение k ненулевых элементов. Переменная count хранит количество нулей среди k элементов.</p>

  <h4>Определяем оптимальный алгоритм перехода</h4>
  <p>При переходе к следующему окну нужно проверять элемент, который выходит из окна и элемент, который приходит в окно.</p>
  <p>Если выходящий из окна элемент ненулевой, то текущее произведение ненулевых элементов делим на этот элемент. Если приходящий в окно элемент ненулевой, то текущее произведение умнажаем на этот элемент. Количество нулей остается таким же</p>
  <p>Если выходящий из окна элемент нулевой, то из количества нулей отнимаем 1. Если следующий элемент нулевой, то к количеству нулей прибавляем 1.</p>

  <p>Сложность по времени O(N)</p>
  <p>Сложность по памяти O(1)</p>
</article>


<!-- Задача 6. Сжатие строки -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача 5. Сжатие строки</h3>

  <h4>Leetcode 443. String Compression</h4>

  <p>Дан массив chars и нужно реализовать алгоритм сжатия строки по следующим правилам</p>
  <ol>
    <li>Подряд идущие одинаковые символы группируются</li>
    <li>Группа включает в себя всегда максимально возможное число одинаковых подряд идущих символов</li>
    <li>Если в группе только одна буква, то пишется только она</li>
    <li>Если в группе более одной буквы, то пишется сначала буква, а потом число раз которое она встретилась</li>
    <li>Если буква встретилась более 9 раз, то каждый символ количества должен быть записан отдельно</li>
  </ol>

  <h4>Пример 1</h4>
  <code>Input chars = ["x", "x", "y", "z", "z", "z"]</code>
  <code>Output ["x", "2", "y", "z", "3"]</code>

  <h4>Пример 2</h4>
  <code>Input chars = ["y","x","x","x","x","x","x","x","x","x","x","x","x","y","y"]</code>
  <code>Output ["y", "x", "1", "2", "y", "2"]</code>

  <h4>Пример 3</h4>
  <code>Input chars = ["a","b","c"]</code>
  <code>Output chars = ["a","b","c"]</code>

  <h4>Паттерн не пересекающиеся плавающие окна</h4>

  <h4>Идея решения</h4>
  <h4>Обрабатываем элементы первого плавающего окна</h4>
  <p>Заведем левый и правый указатель. Поставим их на первый элемент. Плавающее окно содержит элементы [l, r] от l до r включительно.</p>
  <p>Первая стадия. Мы смотрим на элемент под правым указателем и сравниваем со следующим элементом. Если они равны то сдвигаем вправо правый указатель. Если они не равны, то мы останавливаемся. Мы подвинули правый указатель максимально далеко.</p>
  <p>Вторая стадия добавления в ответ.</p>
  <h4>Переходим к следующему окну</h4>
  <p>Левый и правый указатель поставим за границу предыдущего окна на следующий элемент. Следующее окно будет после текущего и они никогда не пересекутся</p>

  <p>Сложность по времени O(N)</p>
  <p>Сложность по памяти O(N). В памяти дополнительно хранится только результат. Если результат хранить не надо, то O(1)</p>

  <details>
    <summary>Код на javascript</summary>
<pre>
function compress(chars) {
    let l = 0;
    let r = 0;
    let result = [];
    while (l &lt; chars.length) {
        // before
        // l
        // a a a b b a a
        // r

        // бежим правым указателем пока в интервале [l, r]
        // находятся все одинаковые символы
        while (r + 1 &lt; chars.length && chars[r] === chars[r + 1]) {
            r++;
        }
        // after
        // l
        // a a a b b a a
        //     r

        // обновляем ответ
        let windowSize = r - l + 1;
        if (windowSize === 1) {
            result.push(chars[r]);
        } else {
            result.push(chars[r]);
            result.push(...String(windowSize).split(''));
        }

        // интервалы не пересекаются, поэтому сдвигаем
        // на r + 1 - именно отсюда будет начинаться
        // следующий интервал
        l = r + 1;
        r = r + 1;
    }
    return result;
};
</pre>
  </details>

  <details>
    <summary>Код на python</summary>
<pre>
class Solution:
    # time: O(n)
    # mem:  O(n), если сразу модифицировать массив chars то получим O(1)
    def compress(self, chars: List[str]) -> List[str]:
        l = 0
        r = 0
        result = []
        while l &lt; len(chars):
            # before
            # l
            # a a a b b a a
            # r

            # бежим правым указателем пока в интервале [l, r]
            # находятся все одинаковые символы
            while r + 1 &lt; len(chars) and chars[r] == chars[r + 1]:
                r += 1
            # after
            # l
            # a a a b b a a
            #     r

            # обновляем ответ
            windowSize = r - l + 1
            if windowSize == 1:
                result.append(chars[r])
            else:
                result.append(chars[r])
                result += list(str(windowSize))

            # интервалы не пересекаются, поэтому сдвигаем
            # на r + 1 - именно отсюда будет начинаться
            # следующий интервал
            l = r + 1
            r = r + 1

        return result
</pre>
  </details>

  <details>
    <summary>Код на go</summary>
<pre>
func compress(chars []rune) []rune {
	l := 0
	r := 0
	result := []rune{}
	for l &lt; len(chars) {
		// before
		// l
		// a a a b b a a
		// r

		// бежим правым указателем пока в интервале [l, r]
		// находятся все одинаковые символы
		for r+1 &lt; len(chars) && chars[r] == chars[r+1] {
			r++
		}
		// after
		// l
		// a a a b b a a
		//     r

		// обновляем ответ
		windowSize := r - l + 1
		result = append(result, chars[r])
    if windowSize > 1 {
			result = append(result, []rune(strconv.Itoa(windowSize))...)
		}

		// интервалы не пересекаются, поэтому сдвигаем
		// на r + 1 - именно отсюда будет начинаться
		// следующий интервал
		l = r + 1
		r = r + 1
	}
	return result
}
</pre>
  </details>

  <details>
    <summary>Код на C++</summary>
<pre>
class Solution {
public:
    // time: O(n)
    // mem:  O(n), если сразу модифицировать массив chars то получим O(1)
    vector&lt;char&gt; compress(vector&lt;char&gt;& chars) {
        int l = 0;
        int r = 0;
        vector&lt;char&gt; result;
        while (l &lt; chars.size()) {
            // before
            // l
            // a a a b b a a
            // r

            // бежим правым указателем пока в интервале [l, r]
            // находятся все одинаковые символы
            while (r + 1 &lt; chars.size() && chars[r] == chars[r + 1]) {
                r++;
            }
            // after
            // l
            // a a a b b a a
            //     r

            // обновляем ответ
            int windowSize = r - l + 1;
            result.push_back(chars[r]);
            if (windowSize > 1) {
                for (auto c : to_string(windowSize)) {
                    result.push_back(c);
                }
            }

            // интервалы не пересекаются, поэтому сдвигаем
            // на r + 1 - именно отсюда будет начинаться
            // следующий интервал
            l = r + 1;
            r = r + 1;
        }
        return result;
    }
};
</pre>
  </details>

  <details>
    <summary>Код на java</summary>
<pre>
class Solution {
    // time: O(n)
    // mem:  O(n), если сразу модифицировать массив chars то получим O(1)
    public List&lt;Character&gt; compress(List&lt;Character&gt; chars) {
        int l = 0;
        int r = 0;
        List&lt;Character&gt; result = new ArrayList&lt;&gt;();
        while (l &lt; chars.length) {
            // before
            // l
            // a a a b b a a
            // r

            // бежим правым указателем пока в интервале [l, r]
            // находятся все одинаковые символы
            while (r + 1 &lt; chars.size() && chars.get(r).equals(chars.get(r + 1))) {
                r++;
            }
            // after
            // l
            // a a a b b a a
            //     r

            // обновляем ответ
            int windowSize = r - l + 1;
            result.add(chars[r]);
            if (windowSize > 1) {
                for (char c : String.valueOf(windowSize).toCharArray()) {
                    result.add(c);
                }
            }

            // интервалы не пересекаются, поэтому сдвигаем
            // на r + 1 - именно отсюда будет начинаться
            // следующий интервал
            l = r + 1;
            r = r + 1;
        }
        return result;
    }
}
</pre>
  </details>
</article>


<!-- Задача 6. Сжатие строки -->
<article class="article">
  <div class="anchor" id="slide"></div>
  <h3>Паттерн не пересекающиеся плавающие окна</h3>

  <h4>Алгоритм работы с не пересекающимися окнами</h4>

  <code>x, x, y, z, z, z</code>

  <h4>Код на python</h4>
<pre>
def some(nums: List[int]) -> ReturnType:
  l = 0
  r = 0
  result = []
  while l &lt; len(nums):
      while r + 1 &lt; len(nums) and условие_продолжения_окна:
          r += 1
      // обработка текущего окна и обновление результата

      // сдвиг указателей для следующего окна
      l = r + 1
      r = r + 1

  return result
</pre>
</article>

