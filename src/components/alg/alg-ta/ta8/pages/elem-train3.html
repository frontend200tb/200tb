<h1>Тренировки по алгоритмам 3.0</h1>


<article class="article">
  <h2>Михаил Густокашин</h2>
  <p>Конспект видеокурса <strong>Тренировки по алгоритмам 3.0</strong> от (2023.03.10)</p>
</article>


<!-- Содержание -->
<div class="article">
  <h2>Содержание</h2>

  <p><a href="#urok-1">Лекция 1. Стеки</a></p>
  <p><a href="#task-1">Задача 1. Гистограмма</a></p>
</div>


<!-- Лекция 1. Стеки -->
<article class="article">
  <div class="anchor" id="urok-1"></div>
  <h2>Лекция 1. Стеки</h2>

  <p>Здравствуйте. Меня зовут Михаил Густокашин и сегодня у нас первая лекция тренировок 3.0.</p>

  <h4>План сегодняшней лекции</h4>
  <ol>
    <li>Что такое стек</li>
    <li>Скобочные последовательности</li>
    <li>Вычисление выражений</li>
    <li>Ближайшее меньшее справа</li>
    <li>Рекурсия и избавление от нее</li>
  </ol>

  <h3>1. Что такое стек</h3>
  <p>Стек это такая структура данных, куда элемент последний пришел и первый вышел.</p>
  <p>Last In - First Out (LIFO)</p>
  <p>push(x) - добавить элемент x на вершину стека</p>
  <p>pop() - удалить элемент с вершины стека</p>

  <h3>2. Скобочные последовательности</h3>
  <p>Правильная скобочная последовательность</p>
  <code>Правильные: (), (()), ()()</code>
  <code>Неправильные: ((), )(, ())(</code>

  <p>Правильная скобочная последовательность с несколькими видами скобок</p>
  <code>Правильные: [], {[]()}, []{}()</code>
  <code>Неправильные: [}, {(}), {[](})</code>

  <h4>Подсчет баланса для одного вида скобок</h4>
  <p>Общая мысль: не должны закрываться неоткрытые скобки, в конце все открытые скобки должны быть закрыты</p>
  <p>Идея: считаем "баланс" - на каждую открытую скобку делаем +1, на каждую закрытую -1. Баланс ПСП всегда не отрицателен и в конце равен нулю</p>

  <h4>Подсчет баланса для нескольких видов скобок</h4>
  <p>Для нескольких видов скобок подсчет баланса не подходит, потому что скобки могут быть вперемешку с другим видом скобок. Здесь нужно использовать стек.</p>

  <h4>Идея использования стека</h4>
  <p>Открывающие скобки кладем в стек</p>
  <p>Встретили закрывающую - проверили, что стек не пуст, на вершине стека лежит соответствующая открывающая и убрали ее из стека.</p>
  <p>В конце стек должен оказаться пустым (все открытые закрылись)</p>

  <h4>Где используются ПСП</h4>
  <p>Например, в html или xml. Открывающий тек - открывающая скобка типа "имя тега", а закрывающий тег - соответствующая закрывающая скобка</p>
  <code>Правильно: &lt;table&gt; &lt;tr&gt; &lt;/tr&gt; &lt;/table&gt;</code>
  <code>Неправильно: &lt;table&gt; &lt;tr&gt; &lt;/table&gt; &lt;/tr&gt;</code>

  <h3>3. Вычисление выражений</h3>
  <p>Как мы считаем арифметические выражения</p>
  <ul>
    <li>Ищем самые глубоко вложенные скобки (возможно, с использованием баланса)</li>
    <li>Внутри самых вложенных скобок выполняем операции по убыванию приоритета и заменяем два операнда и операцию на одно число</li>
    <li>Когда внутри скобок осталось одно число - убираем скобки и начинаем сначала</li>
  </ul>

  <h4>Инфиксная и постфиксная записи</h4>
  <p>Префиксная запись (сначала операция, потом операнд)</p>
  <code>sin(x)</code>
  <p>Инфиксная запись (операция между операндами)</p>
  <code>6 + 3 * (1 + 4 * 5) * 2</code>
  <p>Постфиксная запись (сначала операнды, потом операция)</p>
  <code>6 3 1 4 5 * + * 2 * +</code>
  <p>Постфиксная запись записывается без скобок. Можно считать за один проход: операнды складываем в стек, а как только встречается операция - берем два верхних операнда из стека, выполняем операцию и кладем результат в стек. В конце остается ровно одно число в стеке - результат выполнения выражения.</p>

  <h4>Преобразование инфиксной записи в постфиксную</h4>
  <ul>
    <li>Операнд сразу попадает в ответ</li>
    <li>Операция выталкивает в ответ все операции с больше либо равным приоритетом и кладется в стек</li>
    <li>Открывающая скобка кладется в стек</li>
    <li>Закрывающая скобка выталкивает в ответ все операции до открывающей скобки, затем удаляет открывающую скобку</li>
    <li>В конце все операции выписываются в ответ</li>
  </ul>

  <h4>Пример. Преобразуем инфиксную запись в постфиксную</h4>
  <code>Инфиксная запись: 6 + 3 * (1 + 4 * 5) * 2</code>
  <p>Встретили операнд 6 и кладем его в ответ</p>
  <code>Ответ: 6</code>
  <p>Встретили операцию + кладем ее в пустой стек</p>
  <code>Стек: +</code>
  <p>Встретили операнд 3 и кладем его в ответ</p>
  <code>Ответ: 6 3</code>
  <p>Встретили операцию * и кладем ее в стек</p>
  <code>Стек: + *</code>
  <p>Встретили открывающую скобку ( и кладем ее в стек</p>
  <code>Стек: + * (</code>
  <p>Встретили операнд 1 и кладем его в ответ</p>
  <code>Ответ: 6 3 1</code>
  <p>Встретили операцию + и кладем ее в стек</p>
  <code>Стек: + * ( +</code>
  <p>Встретили операнд 4 и кладем его в ответ</p>
  <code>Ответ: 6 3 1 4</code>
  <p>Встретили операцию * и кладем ее в стек</p>
  <code>Стек: + * ( + *</code>
  <p>Встретили операнд 5 и кладем его в ответ</p>
  <code>Ответ: 6 3 1 4 5</code>
  <p>Встретили закрывающую скобку ). Закрывающая скобка выталкивает все операции до открывающей скобки и кладет их в ответ и выталкивает открывающую скобку</p>
  <code>Ответ: 6 3 1 4 5 * +</code>
  <code>Стек: + *</code>
  <p>Встретили операцию * , она выталкивает все из стека все операции с большим или равным приоритетом. Выталкивает из стека операцию *, а сама идет в стек на ее место</p>
  <code>Ответ: 6 3 1 4 5 * + *</code>
  <code>Стек: + *</code>
  <p>Встретили операнд 2 и кладем его в ответ</p>
  <code>Ответ: 6 3 1 4 5 * + * 2</code>
  <p>Выражение закончилось, поэтому стек с операциями выталкиваем в ответ</p>
  <code>Ответ: 6 3 1 4 5 * + * 2 * +</code>

  <p>Теперь, когда у нас есть инфиксная запись выражения, мы можем его подсчитать за два прохода (за линейное время). За первый проход создать постфиксную запись. За второй проход посчитать выражение.</p>

  <h3>4. Поиск ближайшего меньшего справа</h3>
  <p>Пусть дан массив чисел</p>
  <code>[7,2,4,5,3,2,5,1,5,4]</code>
  <p>Тогда для каждого элемента массива можно записать индекс ближайшего меньшего справа</p>
  <code>[1,7,4,4,5,7,7,10,9,10]</code>
  <p>Для каждого числа определить индекс ближайшего меньшего числа, которое находится правее текущего</p>
  <p>Очевидное решение за O(N^2) с помощью сбалансированных двоичных деревьев поиска можно решить за O(NlogN)</p>
  <p>Хотим решение за O(N)</p>

  <h4>Идея решения за O(N)</h4>
  <ul>
    <li>Будем хранить в стеке пары из значения и индекса элементов, для которых ответ еще не найден</li>
    <li>Пойдем по последовательности слева-направо</li>
    <li>Очередной элемент выталкивает из стека все элементы с большим значением - для них он является ответом. После этого ложится в стек сам</li>
    <li>Таким образом, стек всегда будет хранить возрастающую последовательность</li>
  </ul>
  <p>В стеке накапливаем те пары значение и индекс, после которых еще не приходило значение меньше их.</p>

  <h3>5. Рекурсия и избавление от нее</h3>

  <h4>Как запускаются функции</h4>
  <p>При каждом запуске функции в стеке выделяется память под локальные переменные и параметры. Так же запоминаются откуда продолжить выполнение программы после окончания работы функции</p>
  <p>Когда функция заканчивается - ее переменные и параметры удаляются из стека, а выполнение продолжается с запомненного места</p>

  <h4>Пример работы рекурсивной функции</h4>
<pre>function factorial(n){
  if (n ===1) {
    return 1;
  }
  return n * factorial(n - 1);
}</pre>
  <p>Вызовем функцию с параметром 4</p>
  <code>factorial(4);</code>
  <p>В стек попадет n=4 и место откуда вызвана функция, для возврата в него. Потом вызовется функция с n=3  и так далее до n=1. Тогда функция выполнется, вернет результат, удалится из стека и так по цепочке пока не выполнится самая первая функция.</p>

  <h4>Общие правила замены рекурсии стеком</h4>
  <p>Это нужно делать только если у языка есть ограничения или нужна неасимптотическая оптимизация</p>
  <p>Делаем цикл "пока стек не пуст" и делаем всю работу руками</p>
</article>


<!-- Задача 1. Гистограмма -->
<article class="article">
  <div class="anchor" id="task-1"></div>
  <h2>Задача 1. Гистограмма</h2>

  Ограничение времени	1 секунда
  <br>Ограничение памяти	64Mb
  <br>Ввод	стандартный ввод или input.txt
  <br>Вывод	стандартный вывод или output.txt

  <p>Вовочка ломает систему безопасности Пентагона. Для этого ему понадобилось узнать, какие символы в секретных зашифрованных посланиях употребляются чаще других. Для удобства изучения Вовочка хочет получить графическое представление встречаемости символов. Поэтому он хочет построить гистограмму количества символов в сообщении. Гистограмма — это график, в котором каждому символу, встречающемуся в сообщении хотя бы один раз, соответствует столбик, высота которого пропорциональна количеству этих символов в сообщении.</p>

  <h4>Формат ввода</h4>
  <p>Входной файл содержит зашифрованный текст сообщения. Он содержит строчные и прописные латинские буквы, цифры, знаки препинания («.», «!», «?», «:», «-», «,», «;», «(», «)»), пробелы и переводы строк. Размер входного файла не превышает 10000 байт. Текст содержит хотя бы один непробельный символ. Все строки входного файла не длиннее 200 символов.Для каждого символа c кроме пробелов и переводов строк выведите столбик из символов «#», количество которых должно быть равно количеству символов c в данном тексте. Под каждым столбиком напишите символ, соответствующий ему. Отформатируйте гистограмму так, чтобы нижние концы столбиков были на одной строке, первая строка и первый столбец были непустыми. Не отделяйте столбики друг от друга. Отсортируйте столбики в порядке увеличения кодов символов.</p>

  <h4>Формат вывода</h4>
  <p>Для каждого символа c кроме пробелов и переводов строк выведите столбик из символов «#», количество которых должно быть равно количеству символов c в данном тексте. Под каждым столбиком напишите символ, соответствующий ему. Отформатируйте гистограмму так, чтобы нижние концы столбиков были на одной строке, первая строка и первый столбец были непустыми. Не отделяйте столбики друг от друга. Отсортируйте столбики в порядке увеличения кодов символов.</p>

  <h4>Пример 1</h4>
  <code>Ввод: Hello, world!</code>
<pre>Вывод:
     #
     ##
#########
!,Hdelorw</pre>

  <h4>Пример 2</h4>
<pre>Ввод:
Twas brillig, and the slithy toves
Did gyre and gimble in the wabe;
All mimsy were the borogoves,
And the mome raths outgrabe.</pre>
<pre>Вывод:
         #
         #
         #
         #
         #
         #         #
         #  #      #
      #  # ###  ####
      ## ###### ####
      ##############
      ##############  ##
#  #  ############## ###
########################
,.;ADTabdeghilmnorstuvwy</pre>

  <details>
    <summary>Решение</summary>
    <ol>
      <li>Начнем писать функцию histogram, которая на вход принимает строку
        <code>function histogram(str) {}</code>
      </li>
      <li>Создадим переменную для максимальной высоты столбика гистограммы
        <code>let max = 1;</code>
      </li>
      <li>Создадим объект для хранения всех символов гистограммы
        <code>const data = {};</code>
      </li>
      <li>В цикле пройдем по всем символам входной строки
        <code>for (let i = 0; i &lt; str.length; i++) {}</code>
      </li>
      <li>Если символ пробельный, то переходим к следующей итерации цикла
        <code>if (str[i].trim() === '') continue;</code>
      </li>
      <li>Остальные символы будем записывать в объект как свойство, а как значение будем записывать объект с тремя свойствами: символ, количество, код символа. Если в объекте еще нет такого свойства, то запишем его. Если есть - то увеличим количество на 1
<pre>if (!data[str[i]]) {
  data[str[i]] = {
    char: str[i],
    count: 1,
    code: str[i].charCodeAt(0)
  }
} else {
  data[str[i]].count++;
}</pre>
      </li>
      <li>Теперь у нас есть словарь в котором каждый символ входной строки это свойство, а объект из трех свойств это значение. Создадим из этого словаря массив объектов из значений его свойств
        <code>const arr = Object.values(data);</code>
      </li>
      <li>Отсортируем массив arr по коду символов
        <code>arr.sort((a, b) => a.code - b.code);</code>
      </li>
      <li>Создадим массив для записи результата
        <code>let result = [];</code>
      </li>
      <li>В цикле пройдем по строчкам в результате начиная с максимальной и до первой
        <code>for (let i = max; i &gt; 0; i--) {}</code>
      </li>
      <li>В цикле пройдем по всем объектам в массиве arr
        <code>for (let j = 0; j &lt; arr.length; j++) {}</code>
      </li>
      <li>Если количество символов в объекте меньше высоты столбика, то записываем пробел, иначе записываем #
<pre>      if (arr[j].count &lt; i) {
  result.push(' ');
} else {
  result.push('#');
}
}</pre>
      </li>
      <li>Перед завершением внешнего цикла добавим в массив символ перевода на новую строку
        <code>result.push('\n');</code>
      </li>
      <li>И наконец, добавим цикл, в котором пройдем по всем объектам массива arr и добавим в результат строчку с символами
<pre>  for (let i = 0; i &lt; arr.length; i++) {
  result.push(arr[i].char);
}</pre>
      </li>
      <li>Применим на массиве результата метод join, чтобы вернуть строку</li>
    </ol>

<pre>function histogram(str) {
  let max = 1;
  const data = {};

  for (let i = 0; i &lt; str.length; i++) {
    if (str[i].trim() === '') {
      continue;
    }
    if (!data[str[i]]) {
      data[str[i]] = {
        char: str[i],
        count: 1,
        code: str[i].charCodeAt(0)
      }
    } else {
      data[str[i]].count++;
      max = Math.max(max, data[str[i]].count);
    }
  }

  const arr = Object.values(data);
  arr.sort((a, b) => a.code - b.code);
  let result = [];

  for (let i = max; i &gt; 0; i--) {
    for (let j = 0; j &lt; arr.length; j++) {
      if (arr[j].count &lt; i) {
        result.push(' ');
      } else {
        result.push('#');
      }
    }
    result.push('\n');
  }

  for (let i = 0; i &lt; arr.length; i++) {
    result.push(arr[i].char);
  }
  return result.join('');
}</pre>
  </details>



</article>
