<h1>Тренировки по алгоритмам 5.0</h1>


<article class="article">
  <h2>Михаил Густокашин</h2>
  <p>Конспект курса <strong>Тренировки по алгоритмам 5.0</strong> (с 2024-03-01 до 2024.03.29)</p>

  <h4>Лекция 1 Сложность, тестирование, особые случаи</h4>
  <p><a href="https://yandex.ru/yaintern/algorithm-training_2021">yandex.ru/yaintern/algorithm-training_2021</a></p>
  <p><a href="https://contest.yandex.ru/contest/27393/problems/">Задачи</a></p>
  <p>2024-03-01 Лекция 1 Сложность, тестирование, особые случаи.mp4</p>
</article>


<!-- Содержание -->
<article class="article">
  <h3>Содержание</h3>

  <br><a href="#l1">Лекция №1. Сложность, тестирование, особые случаи</a>
  <br><a href="#l1-tema-1">Тема 1. Сложность алгоритмов</a>
  <br><a href="#l1-task-1">Задача 1. Самый частый символ</a>
  <br><a href="#l1-tema-2">Тема 2. Особые случаи</a>
  <br><a href="#l1-task-2">Задача 2. Сумма последовательности</a>
  <br><a href="#l1-task-3">Задача 3. Максимум последовательности</a>
  <br><a href="#l1-tema-3">Тема 3. Тестирование</a>
</article>


<!-- Лекция №1. Сложность, тестирование, особые случаи -->
<article class="article">
  <div class="anchor" id="l1"></div>
  <h3>Лекция №1. Сложность, тестирование, особые случаи</h3>

  <p>Здравствуйте, меня зовут Михаил Густокашин. Я преподаю алгоритмы и структуры данных на факультете компьютерных наук в высшей школе экономики. А сейчас у нас тренировки по алгоритмам уже пятый сезон. И сейчас я расскажу что нас ждет и как все будет устроено.</p>

  <p>Чего хотят на алгоритмическом собеседовании (и в реальной жизни)?</p>
  <ol>
    <li>Умения писать работаюдий код</li>
    <li>Умения тестировать свой код</li>
    <li>Умения писать эффективный код</li>
  </ol>

  <h4>Как этого достичь?</h4>
  <ol>
    <li>Написать 10 000 строк работающего, эффективного и протестированного кода</li>
    <li>Кроме тренировок можно найти задачи на coderun.yandex.ru, leetcode.com, codeforces.com и т.п.</li>
    <li>Наш курс поможет правильно подходить к решению задач</li>
  </ol>

  <h4>План занятий</h4>
  <ol>
    <li>Сложность, тестирование, особые случаи</li>
    <li>Ллинейный поиск</li>
    <li>Множества и словари</li>
    <li>Бинарный поиск</li>
  </ol>

  <h4>Рейтинг</h4>
  <ol>
    <li>К каждому занчтию - домашнее задание с 10 задачами и дедлайном до разбора</li>
    <li>На разборе смотрим решение некоторых задач, в том числе с кодом</li>
    <li>Кто решил больше задач - тот и молодец, штраф не учитывается</li>
  </ol>

  <h4>Бонусы</h4>
  <ol>
    <li>Знания и умения!</li>
    <li>Собеседование по алгоритмам в прямом эфире + его разбор (дважды)</li>
    <li>Персональные тренировки для топ-200 участников</li>
    <li>Пробные алгоритмические собеседования для топ-200 участников с зачетом при отборе</li>
  </ol>

  <h4>Содержание сегодняшней лекции</h4>
  <ol>
    <li>Сложность алгоритмов</li>
    <li>Особые случаи</li>
    <li>Тестирование</li>
  </ol>
</article>


<!-- Тема 1. Сложность алгоритмов -->
<article class="article">
  <div class="anchor" id="l1-tema-1"></div>
  <h3>Тема 1. Сложность алгоритмов</h3>

  <h4>RAM машина (упрощенно)</h4>
  <ol>
    <li>Чтение/запись/инициализация ячейки памяти стоит одну операцию</li>
    <li>Можно выполнять арифметические и логические операции с одной ячейкой памяти, а также переходы</li>
    <li>Похоже на компьютер</li>
  </ol>

  <h4>Сложность алгоритма</h4>
  <ol>
    <li>Сложность алгоритма - порядок количества действий в зависимости от размера входных данных</li>
    <li>Чато применяют О-нотацию - нестрогая оценка сверху</li>
    <li>Суть: хотим понимать во сколько раз замедлится наша программа при увеличении размера входных данных</li>
  </ol>

  <h4>Примеры расчета сложности</h4>
  <ol>
    <li>У нас есть реализация алгоритма в виде программы. При размере входных данных N время работы программы было измерено и составило T. Данные увеличились в 10 раз</li>
    <li>Если сложность O(N) - замедление в 10 раз, O(NlogN) - примерно в 30 раз, O(N^2) - в 100 раз, O(N^3) - в 1000 раз, O(1) - нет замедления.</li>
  </ol>

  <h4>Замечание про константу</h4>
  <ul>
    <li>То во сколько раз замедлится программа не зависит от константы (количества элементарных операций, не зависящих от размера входных данных)</li>
  </ul>

  <p>Может быть разное замедление в разных частях программы. Мы должны учитывать самый худший случай.</p>
</article>


<!-- Задача 1. Самый частый символ -->
<article class="article">
  <div class="anchor" id="l1-task-1"></div>
  <h3>Задача 1. Самый частый символ</h3>
  <p>Дана строка (в кодировке UTF-8), найти самый часто встречающийся в ней символ. Если таких символов несколько - найти любой.</p>

  <p>Решение 1. O(n^2)</p>
  <p>Переберем все позиции и для каждой позиции в строке еще раз переберем все позиции и в случае совпадения прибавим к счетчику единицу. Найдем максимальное значение счетчика.</p>

  <p>Решение 2. O(n*k)</p>
  <p>Переберем все символы, встречающиеся в строке, а затем переберем все позиции и в случае совпадения прибавим к счетчику единицу. Найдем максимальное значение счетчика.</p>

  <p>Решение 3. O(n+k) = O(n)</p>
  <p>Заведем словарь, где ключом является символ, а значением - сколько раз он встретился. Если символ встретился впервые - создаем элемент словаря с ключом, совпадающим с этим символом и значением ноль. Прибавляем к элементу словаря с ключом, совпадающим с этим символом, единицу</p>
</article>


<!-- Тема 2. Особые случаи -->
<article class="article">
  <div class="anchor" id="l1-tema-2"></div>
  <h3>Тема 2. Особые случаи</h3>
</article>


<!-- Задача 2. Сумма последовательности -->
<article class="article">
  <div class="anchor" id="l1-task-2"></div>
  <h3>Задача 2. Сумма последовательности</h3>

  <p>Дан массив чисел. Найти их сумму.</p>

  <details>
    <summary>Решение</summary>
  <p>Мы помним, что пустые строки, последовательности, массивы это страшная вещь и мы стараемся их сразу обработать чтобы ничего не сломалось. Пишем, если длина массива 0 то сразу возвращаем 0, иначе просуммируем все числа.</p>
<pre>function sum(nums) {
  if (nums.length === 0) {
    return 0;
  } else {
    let result = nums[0];
    for (let i = 1; i &lt; nums.length; i++) {
      result += nums[i];
    }
    return result;
  }
}</pre>

  <p>Но в данном случае это уже было лишнее. Потому что if можно убрать и сразу инициализировать результат нулем.</p>

<pre>function sum(nums) {
  let result = 0;
  for (let i = 0; i &lt; nums.length; i++) {
    result += nums[i];
  }
  return result;
}</pre>
  </details>
</article>


<!-- Задача 3. Максимум последовательности -->
<article class="article">
  <div class="anchor" id="l1-task-3"></div>
  <h3>Задача 3. Максимум последовательности</h3>
  <p>Найти максимальный элемент в массиве.</p>

  <p>Решение.</p>
  <p>Сначала нужно в ответ положить нулевой элемент массива. Потом пройтись по всем элементам массива и сравнивая их с ответом, присвоивать ответу большее значение. В конце надо вернуть ответ.</p>

  <details>
    <summary>Решение</summary>
    <p>Мы помним, что для нахождения суммы последовательности мы сначала в результат записывали 0, а потом вычисляли сумму.</p>
<pre>function max(nums) {
  let result = 0;
  for (let i = 0; i &lt; nums.length; i++) {
    if (nums[i] &gt; result) {
      result = nums[i];
    }
  }
  return result;
}</pre>
    <p>Это будет работать, пока не возникнет ситуация, когда все числа будут отрицательные. Мы выведем 0, которого даже нет в последовательности. Поэтому обработаем этот случай, если последовательность пустая, то выведем, например, пустую строку.</p>
<pre>function max(nums) {
  if (nums.length === 0) {
    return '';
  } else {
    let result = nums[0];
    for (let i = 1; i &lt; nums.length; i++) {
      if (nums[i] &gt; result) {
        result = nums[i];
      }
    }
    return result;
  }
}</pre>
  </details>
</article>


<!-- Тема 3. Тестирование -->
<article class="article">
  <div class="anchor" id="l1-tema-3"></div>
  <h3>Тема 3. Тестирование</h3>

  <h4>Что нужно тестировать?</h4>
  <ol>
    <li>Тесты из условия (если есть)</li>
    <li>Общие случаи</li>
    <li>Особые случаи</li>
  </ol>
</article>
