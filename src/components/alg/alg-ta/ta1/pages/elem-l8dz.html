<h1>Тренировки по алгоритмам 1.0</h1>


<article class="article">
  <h2>Михаил Густокашин</h2>
  <p>Конспект курса <strong>Тренировки по алгоритмам 1.0</strong> (с 2021.06.02 до 2021.06.30)</p>
  <p><a href="https://yandex.ru/yaintern/algorithm-training_2021" target="_blank">yandex.ru/yaintern/algorithm-training_2021</a></p>

  <h4>Домашнее задание по лекции 8. Деревья</h4>
  <p><a href="https://contest.yandex.ru/contest/28069/problems/" target="_blank">contest.yandex.ru/contest/28069/problems</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h3>Содержание</h3>

      <a href="#t1">A. Высота дерева</a>
  <br><a href="#t2">B. Глубина добавляемых элементов</a>
  <br><a href="#t3">C. Второй максимум</a>
  <br><a href="#t4">D. Обход</a>
  <br><a href="#t5">E. Вывод листьев</a>
  <br><a href="#t6">F. Вывод развилок</a>
  <br><a href="#t7">G. Вывод веток</a>
  <br><a href="#t8">H. АВЛ-сбалансированность</a>
  <br><a href="#t9">I. Родословная: число потомков</a>
  <br><a href="#t10">J. Родословная: подсчет уровней</a>
</article>


<!-- A. Высота дерева -->
<article class="article">
  <div class="anchor" id="t1"></div>
  <h3>A. Высота дерева</h3>

  <div class="time-memory">(Время 2с. Память 64мб)</div>

  <p>Реализуйте бинарное дерево поиска для целых чисел. Программа получает на вход последовательность целых чисел и строит из них дерево. Элементы в деревья добавляются в соответствии с результатом поиска их места. Если элемент уже существует в дереве, добавлять его не надо. Балансировка дерева не производится.</p>

  <h4>Формат ввода</h4>
  <p>На вход программа получает последовательность натуральных чисел. Последовательность завершается числом 0, которое означает конец ввода, и добавлять его в дерево не надо.</p>

  <h4>Формат вывода</h4>
  <p>Выведите единственное число – высоту получившегося дерева.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>7 3 2 1 9 5 4 6 8 0</code>
    <code>4</code>
  </details>
</article>


<!-- B. Глубина добавляемых элементов -->
<article class="article">
  <div class="anchor" id="t2"></div>
  <h3>B. Глубина добавляемых элементов</h3>

  <div class="time-memory">(Время 2с. Память 64мб)</div>

  <p>В бинарное дерево поиска добавляются элементы. Выведите глубину для каждого добавленного элемента в том порядке, как они добавлялись. Если элемент уже есть в дереве, то ничего добавлять и выводить не нужно. Глубиной называется расстояние от корня дерева до элемента включительно.</p>

  <h4>Формат ввода</h4>
  <p>Вводится последовательность целых чисел, оканчивающаяся нулем. Сам ноль в последовательность не входит. По данной последовательности требуется построить дерево.</p>

  <h4>Формат вывода</h4>
  <p>Выведите ответ на задачу.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>7 3 2 1 9 5 4 6 8 0</code>
    <code>1 2 3 4 2 3 4 4 3 </code>
  </details>
</article>


<!-- C. Второй максимум -->
<article class="article">
  <div class="anchor" id="t3"></div>
  <h3>C. Второй максимум</h3>

  <div class="time-memory">(Время 2с. Память 64мб)</div>

  <p>Выведите второй по величине элемент в построенном дереве. Гарантируется, что такой найдется.</p>

  <h4>Формат ввода</h4>
  <p>Дана последовательность целых чисел, оканчивающаяся нулем. Сам ноль в последовательность не входит.</p>

  <h4>Формат вывода</h4>
  <p>Выведите ответ на задачу.</p>

  <details>
    <summary>Примры</summary>
    <h4>Пример 1</h4>
    <code>7 3 2 1 9 5 4 6 8 0</code>
    <code>8</code>
  </details>
</article>


<!-- D. Обход -->
<article class="article">
  <div class="anchor" id="t4"></div>
  <h3>D. Обход</h3>

  <div class="time-memory">(Время 2с. Память 64мб)</div>

  <p>Выведите все элементы полученного дерева в порядке возрастания.</p>

  <h4>Формат ввода</h4>
  <p>Вводится последовательность целых чисел, оканчивающаяся нулем. Сам ноль в последовательность не входит. По данной последовательности требуется построить дерево.</p>

  <h4>Формат вывода</h4>
  <p>Выведите ответ на задачу.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>7 3 2 1 9 5 4 6 8 0</code>
<pre>
1
2
3
4
5
6
7
8
9
</pre>
  </details>
</article>


<!-- E. Вывод листьев -->
<article class="article">
  <div class="anchor" id="t5"></div>
  <h3>E. Вывод листьев</h3>

  <div class="time-memory">(Время 2с. Память 64мб)</div>

  <p>Для полученного дерева выведите список всех листьев (вершин, не имеющих потомков) в порядке возрастания.</p>

  <h4>Формат ввода</h4>
  <p>Вводится последовательность целых чисел, оканчивающаяся нулем. Сам ноль в последовательность не входит.</p>

  <h4>Формат вывода</h4>
  <p>Выведите ответ на задачу.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>7 3 2 1 9 5 4 6 8 0</code>
<pre>
1
4
6
8
</pre>
  </details>
</article>


<!-- F. Вывод развилок -->
<article class="article">
  <div class="anchor" id="t6"></div>
  <h3>F. Вывод развилок</h3>

  <div class="time-memory">(Время 2с. Память 64мб)</div>

  <p>Для полученного дерева выведите список всех вершин, имеющих по два ребёнка, в порядке возрастания.</p>

  <h4>Формат ввода</h4>
  <p>Вводится последовательность целых чисел, оканчивающаяся нулем. Сам ноль в последовательность не входит. Постройте по этой последовательности дерево.</p>

  <h4>Формат вывода</h4>
  <p>Выведите ответ задачи.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>7 3 2 1 9 5 4 6 8 0</code>
<pre>
3
5
7
</pre>
  </details>
</article>


<!-- G. Вывод веток -->
<article class="article">
  <div class="anchor" id="t7"></div>
  <h3>G. Вывод веток</h3>

  <div class="time-memory">(Время 2с. Память 64мб)</div>

  <p>Для полученного дерева выведите список всех вершин, имеющих только одного ребёнка, в порядке возрастания.</p>

  <h4>Формат ввода</h4>
  <p>Вводится последовательность целых чисел,оканчивающаяся нулем. Построить по ней дерево.</p>

  <h4>Формат вывода</h4>
  <p>Выведите список требуемых вершин.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>7 3 2 1 9 5 4 6 8 0</code>
<pre>
2
9
</pre>
  </details>
</article>


<!-- H. АВЛ-сбалансированность -->
<article class="article">
  <div class="anchor" id="t8"></div>
  <h3>H. АВЛ-сбалансированность</h3>

  <div class="time-memory">(Время 2с. Память 64мб)</div>

  <p>Дерево называется АВЛ-сбалансированным, если для любой его вершины высота левого и правого поддерева для этой вершины различаются не более чем на 1.</p>

  <h4>Формат ввода</h4>
  <p>Вводится последовательность целых чисел, оканчивающаяся нулем. Сам ноль в последовательность не входит. Постройте дерево, соответствующее данной последовательности.</p>

  <h4>Формат вывода</h4>
  <p>Определите, является ли дерево сбалансированным, выведите слово YES или NO.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>7 3 2 1 9 5 4 6 8 0</code>
    <code>YES</code>
  </details>
</article>


<!-- I. Родословная: число потомков -->
<article class="article">
  <div class="anchor" id="t9"></div>
  <h3>I. Родословная: число потомков</h3>

  <div class="time-memory">(Время 2с. Память 64мб)</div>

  <p>В генеалогическом древе у каждого человека, кроме родоначальника, есть ровно один родитель.</p>

  <p>Для каждого элемента дерева определите число всех его потомков (не считая его самого).</p>

  <h4>Формат ввода</h4>
  <p>Программа получает на вход число элементов в генеалогическом древе N. Далее следует N-1 строка, задающие родителя для каждого элемента древа, кроме родоначальника. Каждая строка имеет вид имя_потомка имя_родителя.</p>

  <h4>Формат вывода</h4>
  <p>Выведите список всех элементов в лексикографическом порядке, для каждого элемента выводите количество всех его потомков.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
9
Alexei Peter_I
Anna Peter_I
Elizabeth Peter_I
Peter_II Alexei
Peter_III Anna
Paul_I Peter_III
Alexander_I Paul_I
Nicholaus_I Paul_I
</pre>
<pre>
Alexander_I 0
Alexei 1
Anna 4
Elizabeth 0
Nicholaus_I 0
Paul_I 2
Peter_I 8
Peter_II 0
Peter_III 3
</pre>
    <p>Если вы используете рекурсию, то вам может быть полезно добавление в начало программы следующих строк:</p>
    <code>import sys</code>
    <code>sys.setrecursionlimit(100000)</code>
  </details>
</article>


<!-- J. Родословная: подсчет уровней -->
<article class="article">
  <div class="anchor" id="t10"></div>
  <h3>J. Родословная: подсчет уровней</h3>

  <div class="time-memory">(Время 1с. Память 64мб)</div>

  <p>В генеалогическом древе у каждого человека, кроме родоначальника, есть ровно один родитель. Каждому элементу дерева сопоставляется целое неотрицательное число, называемое высотой. У родоначальника высота равна 0, у любого другого элемента высота на 1 больше, чем у его родителя. Вам дано генеалогическое древо, определите высоту всех его элементов.</p>

  <h4>Формат ввода</h4>
  <p>Программа получает на вход число элементов в генеалогическом древе N. Далее следует N-1 строка, задающие родителя для каждого элемента древа, кроме родоначальника. Каждая строка имеет вид имя_потомка имя_родителя.</p>

  <h4>Формат вывода</h4>
  <p>Программа должна вывести список всех элементов древа в лексикографическом порядке. После вывода имени каждого элемента необходимо вывести его высоту.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
9
Alexei Peter_I
Anna Peter_I
Elizabeth Peter_I
Peter_II Alexei
Peter_III Anna
Paul_I Peter_III
Alexander_I Paul_I
Nicholaus_I Paul_I
</pre>
<pre>
Alexander_I 4
Alexei 1
Anna 1
Elizabeth 1
Nicholaus_I 4
Paul_I 3
Peter_I 0
Peter_II 2
Peter_III 2
</pre>

    <h4>Пример 2</h4>
<pre>
10
AQHFYP MKFXCLZBT
AYKOTYQ QIUKGHWCDC
IWCGKHMFM WPLHJL
MJVAURUDN QIUKGHWCDC
MKFXCLZBT IWCGKHMFM
PUTRIPYHNQ UQNGAXNP
QIUKGHWCDC WPLHJL
UQNGAXNP WPLHJL
YURTPJNR QIUKGHWCDC
</pre>
<pre>
AQHFYP 3
AYKOTYQ 2
IWCGKHMFM 1
MJVAURUDN 2
MKFXCLZBT 2
PUTRIPYHNQ 2
QIUKGHWCDC 1
UQNGAXNP 1
WPLHJL 0
YURTPJNR 2
</pre>

    <h4>Пример 3</h4>
<pre>
10
BFNRMLH CSZMPFXBZ
CSZMPFXBZ IHWBQDJ
FMVQTU FUXATQUGIG
FUXATQUGIG IRVAVMQKN
GNVIZ IQGIGUJZ
IHWBQDJ LACXYFQHSQ
IQGIGUJZ JMUPNYRQD
IRVAVMQKN GNVIZ
JMUPNYRQD BFNRMLH
</pre>
<pre>
BFNRMLH 3
CSZMPFXBZ 2
FMVQTU 9
FUXATQUGIG 8
GNVIZ 6
IHWBQDJ 1
IQGIGUJZ 5
IRVAVMQKN 7
JMUPNYRQD 4
LACXYFQHSQ 0
</pre>
    <p>Эта задача имеет решение сложности O(n), но вам достаточно написать решение сложности O(n<sup>2</sup>) (не считая сложности обращения к элементам словаря). Пример ниже соответствует приведенному древу рода Романовых.</p>
  </details>
</article>
