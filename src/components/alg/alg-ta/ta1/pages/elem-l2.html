<h1>Тренировки по алгоритмам 1.0</h1>


<article class="article">
  <h2>Михаил Густокашин</h2>
  <p>Конспект курса <strong>Тренировки по алгоритмам 1.0</strong> (с 2021.06.02 до 2021.06.30)</p>

  <h4>Лекция 2. Линейный поиск</h4>
  <p><a href="https://yandex.ru/yaintern/algorithm-training_2021">yandex.ru/yaintern/algorithm-training_2021</a></p>
  <p><a href="https://contest.yandex.ru/contest/27393/problems/">Задачи</a></p>
  <p>2021-06-04 Лекция 2 Линейный поиск.mp4</p>
</article>


<!-- Содержание -->
<article class="article">
  <h3>Содержание</h3>

  <br><a href="#l2">Лекция №2. Линейный поиск</a>
  <br><a href="#l2-tema-1">Тема 1. Классические задачи линейного поиска</a>
  <br><a href="#l2-task-1">Задача 1. Найти первое вхождение</a>
  <br><a href="#l2-task-2">Задача 2. Найти последнее вхождение</a>
  <br><a href="#l2-task-3">Задача 3. Найти максимальное число</a>
  <br><a href="#l2-task-4">Задача 4. Найти максимальное и второе по величине число</a>
  <br><a href="#l2-task-5">Задача 5. Найти минимальное четное число</a>
  <br><a href="#l2-tema-2">Тема 2. Два прохода</a>
  <br><a href="#l2-task-6">Задача 6. Самые короткие слова</a>
  <br><a href="#l2-task-7">Задача 7. Сколько воды осталось на острове после сильного дождя</a>
  <br><a href="#l2-tema-3">Тема 3. Задача с собеседования. RLE сжатие строки</a>
</article>


<!-- Лекция №2. Линейный поиск -->
<article class="article">
  <div class="anchor" id="l2"></div>
  <h2>Лекция №2. Линейный поиск</h2>

  <p>Линейный поиск - это совсем несложный алгоритм. Поэтому будем в основном рассматривать его на примере разных задач.</p>

  <h4>Содержание сегодняшней лекции</h4>
  <ol>
    <li>Классические задачи линейного поиска</li>
    <li>Два прохода</li>
    <li>Задача с собеседования</li>
  </ol>
</article>


<!-- Тема 1. Классические задачи линейного поиска -->
<article class="article">
  <div class="anchor" id="l2-tema-1"></div>
  <h3>Тема 1. Классические задачи линейного поиска</h3>

  <h4>Что такое линейный поиск?</h4>
  <ol>
    <li>Линейный поиск - способ поиска, когда перебираются все элементы</li>
    <li>Сложность линейного поиска - линейная O(N)</li>
    <li>Обычно ищут "подходящий" элемент или "наиболее подходящий" элемент</li>
  </ol>
</article>


<!-- Задача 1. Найти первое вхождение -->
<article class="article">
  <div class="anchor" id="l2-task-1"></div>
  <h2>Задача 1. Найти первое вхождение</h2>

  <p>Дана последовательность чисел длиной N. Найти первое (левое) вхождение положительного числа X в нее или вывести -1, если число X не встречалось.</p>

  <details>
    <summary>Решение</summary>
  <p>Сначала положим в ответ -1. Это значит что мы еще не встретили число X. Затем будем перебирать все элементы. Если текущий элемент равен X и ответ равен -1, запишем в ответ текущую позицию. Проверка result === -1 нужна для того чтобы запомнилось именно первое вхождение.</p>
<pre>function findX(nums, x) {
  let result = -1;
  for (let i = 1; i &lt; nums.length; i++) {
    if (nums[i] === x && result === -1) {
      result = i;
    }
  }
  return result;
}</pre>
  </details>
</article>


<!-- Задача 2. Найти последнее вхождение -->
<article class="article">
  <div class="anchor" id="l2-task-2"></div>
  <h2>Задача 2. Найти последнее вхождение</h2>

  <p>Дана последовательность чисел длиной N. Найти последнее (правое) вхождение числа X в нее или вывести -1, если число X не встречалось.</p>

  <details>
    <summary>Решение</summary>
  <p>Сначала положим в ответ -1. Это значит что мы еще не встретили число X. Затем будем перебирать все элементы. Если текущий элемент равен X - запишем в ответ текущую позицию. Зпомнится именно последнее вхождение. Здесь может быть много присваиваний, но на асимптотическую сложность это не повлияет.</p>
<pre>function findX(nums, x) {
  let result = -1;
  for (let i = 1; i &lt; nums.length; i++) {
    if (nums[i] === x) {
      result = i;
    }
  }
  return result;
}</pre>
  </details>

  <p>Можно было использовать решение предыдущей задачи с той разницей, что в цикле идти от последнего элемента к первому.</p>
</article>


<!-- Задача 3. Найти максимальное число -->
<article class="article">
  <div class="anchor" id="l2-task-3"></div>
  <h2>Задача 3. Найти максимальное число</h2>

  <p>Дана последовательность чисел длиной N (N больше 0). Найти максимальное число в последовательности. Последовательность гарантированно не пустая.</p>

  <details>
    <summary>Решение</summary>
    <p>Сначала положим в ответ нулевой элемент последовательности (он точно существует), затем будем перебирать все элементы. Если текущий элемент больше ответа - запишем в ответ текущий элемент. Цикл начинаем со второго элемента, поскольку первый мы уже записали в ответ и его сравнивать с ответом не нужно. Это нам сэкономит одну операцию.</p>
<pre>function findMax(nums) {
  let result = nums[0];
  for (let i = 1; i &lt; nums.length; i++) {
    if (nums[i] &gt; result) {
      result = nums[i];
    }
  }
  return result;
}</pre>
  </details>

  <h2>Задача 3. Найти максимальное значение (например, из строк)</h2>
  <p>Написанное решение будет работать и для строк. Сравнение чисел это быстрая операция. Но сравнение строк уже медленная, потому что строки сравниваются по символьно в лексикографическом порядке и сложность каждого сравнения O(k), где k длина строки. Чем отличается алфавитный порядок от лексикографического? В алфавитном порядке не отличаются большие и маленькие буквы, а в лексикографическом - отличаются.</p>
  <p>Чем плох этот алгоритм для строк? У нас каждый раз, когда строка больше результата, будет происходить копирование в переменную. Если каждая следующая строка больше предыдущей, то на каждом шаге будет происходить копирование в переменную. На некоторых языках, например в питоне, строка это ссылочный тип и копирование будет происходить быстро, потому что копироваться будет только ссылка. На других языках строка это не ссылочный тип и она будет копироваться вся целиком.</p>
  <p>Как избавиться от этой проблемы? Если объект тяжелый и вы кладете этот объект в переменную, то это может занимать не O(1). Это может занимать O от размера объекта.</p>

  <details>
    <summary>Решение</summary>
    <p>В этом случае нам нужно запоминать не значение, а индекс. Это более универсальное значение. Мы находим и значение и индекс максимального элемента.</p>
<pre>function findMax(nums) {
  let max = 0;
  for (let i = 1; i &lt; nums.length; i++) {
    if (nums[i] &gt; nums[max]) {
      max = i;
    }
  }
  return nums[max];
}</pre>
  <p>Но обращение по индексу сложнее чем обращение к переменной, поэтому для сравнения чисел такое подход хуже чем первый вариант.</p>
  </details>
</article>


<!-- Задача 4. Найти максимальное и второе по величине число -->
<article class="article">
  <div class="anchor" id="l2-task-4"></div>
  <h2>Задача 4. Найти максимальное и второе по величине число</h2>

  <p>Дана последовательность чисел длиной N (N больше 1)</p>
  <p>Найти максимальное число и второе по величине число (такое, которое будет максимальным, если вычеркнуть из последовательности одно максмальное число).</p>

  <details>
    <summary>Решение</summary>
    <p>Заведем две переменные для первого и второго максимума. Возьмем первые два числа из последовательности и запишем большее из них в переменную для первого максимума, а меньшее - для второго. Пройдем по последовательности. Если очередное число больше первого максимума, то запишем во второй максимум значение первого, а в первый - текущее число. Если только больше второго, запишем текущее число во второй максимум.</p>
<pre>function find2Max(nums) {
  let max1 = Math.max(nums[0], nums[1]);
  let max2 = Math.min(nums[0], nums[1]);

  for (let i = 2; i &lt; nums.length; i++) {
    if (nums[i] &gt; max1) {
      max2 = max1;
      max1 = nums[i];
    } else if (nums[i] &gt; max2) {
      max2 = nums[i]
    }
  }

  return [max1, max2];
}</pre>
  </details>
</article>


<!-- Задача 5. Найти минимальное четное число -->
<article class="article">
  <div class="anchor" id="l2-task-5"></div>
  <h2>Задача 5. Найти минимальное четное число</h2>

  <p>Дана последовательность чисел длиной N</p>
  <p>Найти минимальное четное число в последовательности или вывести -1, если такого не существует.</p>

  <details>
    <summary>Решение</summary>
    <p>В переменную для ответа положим -1. Если очередное число четное, а ответ равен -1 или ответ больше текущего числа, то запишем в ответ текущее число.</p>
<pre>function findEvenMin(nums) {
  let min = -1;
  for (let i = 0; i &lt; nums.length; i++) {
    if (nums[i] % 2 === 0 && (min === -1 || nums[i] &lt; min)) {
      min = nums[i];
    }
  }
  return min;
}</pre>
  </details>
</article>


<!-- Тема 2. Два прохода -->
<article class="article">
  <div class="anchor" id="l2-tema-2"></div>
  <h2>Тема 2. Два прохода</h2>

  <p>В таких задачах нужно два раза пройти по последовательности.</p>
</article>


<!-- Задача 6. Самые короткие слова -->
<article class="article">
  <div class="anchor" id="l2-task-6"></div>
  <h2>Задача 6. Самые короткие слова</h2>

  <p>Дана последовательность слов</p>
  <p>Вывксти все самые короткие слова через пробел</p>

  <details>
    <summary>Решение в два прохода</summary>
    <p>Линейное решение за два прохода. Сложность O(2N) = O(N).</p>
    <p>В первом проходе по последовательности мы ищем длину самого короткого слова. Во втором проходе добавляем в массив все слова с минимальной длиной. В результат выводим строку, созданную из массива с пробелом между словами.</p>
    <p>Решение с добавлением слов в строку вместо массива было бы не оптимальным. Потому что операция добавления новых слов в строку на самом деле создает новую строку, в которую сначала копирует все содержимое старой строки и уже потом добавляет новое слово.</p>
<pre>function shortWords(strs) {
  let minlen = strs[0].length;
  for (let i = 1; i &lt; strs.length; i++) {
    if (strs[i].length &lt; minlen) {
      minlen = strs[i].length;
    }
  }
  let result = [];
  for (let i = 0; i &lt; strs.length; i++) {
    if (strs[i].length === minlen) {
      result.push(strs[i]);
    }
  }
  return result.join(' ');
}</pre>
  </details>
</article>


<!-- Задача 7. Сколько воды осталось на острове после сильного дождя -->
<article class="article">
  <div class="anchor" id="l2-task-7"></div>
  <h2>Задача 7. Сколько воды осталось на острове после сильного дождя</h2>

  <p>Задача со школьной олимпиады. Игра PitCraft происходит в двумерном мире, который состоит из блоков размером 1 на 1 метр. Остров игрока представляет собой набор столбцов различной высоты, состоящих из блоков камня и окруженный морем. Над островом прошел сильный дождь, который заполнил водой все низины, а не поместившаяся в них вода стекла в море, не увеличив его уровень</p>
  <p>По ландшафту острова определите, сколько блоков воды осталось после дождя в низинах на острове.</p>
<pre>
    #
  #~#
#~###~~#
#~###~~#
#########
</pre>

  <details>
    <summary>Решение</summary>
    <p>К нам на вход приходит массив высот столбцов. Пусть на каждый столбец мы льем воду и тогда эта вода будет сливаться в соседний столбец если высота соседнего столбца меньше. Если рассматривать каждый кубик и пытаться слить с него воду направо и налево, то это очень медленное решение. Попробуем найти что-то побыстрее.</p>
    <p>Нужно пройти во высотам и найти вершину - максимальную высоту через которую вода уже не перельется. Когда вода заполнит все впадины, то слева от вершины все ступеньки будут на подъем, а справа - на спуск. Разделим задачу на две половины - до вершины и после.</p>
    <p>Присвоим переменной результата 0 кубиков воды. Будем идти слева до вершины и присвоим переменной текущего максимума высоту первого столбика. Если следующий столбик ниже, то находим разницу высот и добавляем в результат. Если выше, то обновляем текущий максимум и идем дальше до вершины.</p>
    <p>Вторую половину задачи после вершины мы будем искать так же, но проходиться по последовательности будем с последнего столбика назад к вершине.</p>
    <p>Как быть если максимумов будет несколько? Ничего плохого не произойдет. Между максимумами тоже все заполнится водой. Можно выбрать любой максимум.</p>
    <p>Сложность решения линейная O(N). За два прохода. Первый проход ищем максимум. Второй проход добавляем количество воды к результату.</p>
<pre>function water(h) {
  let maxPos = 0;

  // первый проход ищем максимум
  for (let i = 1; i &lt; h.length; i++) {
    if (h[i] &gt; h[maxPos]) {
      maxPos = i;
    }
  }

  let result = 0;
  let nowMax = 0;

  // второй проход добавляем количество воды к результату
  // слева до вершины
  for (let i = 0; i &lt; maxPos; i++) {
    if (h[i] &gt; nowMax) {
      nowMax = h[i];
    }
    result += nowMax - h[i];
  }

  nowMax = 0;

  // справа до вершины
  for (let i = h.length - 1; i &gt; maxPos; i--) {
    if (h[i] &gt; nowMax) {
      nowMax = h[i];
    }
    result += nowMax - h[i];
  }

  return result;
}</pre>
  </details>
</article>


<!-- Тема 3. Задача с собеседования. RLE сжатие строки -->
<article class="article">
  <div class="anchor" id="l2-tema-3"></div>
  <h2>Тема 3. Задача с собеседования. RLE сжатие строки</h2>

  <p>Дана строка (возможно, пустая), состоящая из букв A-Z: AAAABBBCCXYZDDDD</p>
  <p>Нужно написать функцию RLE, которая на выходе даст строку вида: A4B3C2XYZD4. И сгенерирует ошибку, если на вход пришла невалидная строка</p>
  <p>Пояснения: Если символ встречается 1 раз, он остается без изменений. Если символ повторяется более 1 раза подряд, он пишется один раз и к нему добавляется количество повторений.</p>

  <p>Для начала решим более простую задачу. Сложно считать сколько раз эти символы встречаются.</p>

  <h4>Упрощение задачи</h4>
  <p>Дана строка (возможно, пустая), состоящая из букв A-Z: AAAABBBCCXYZDDDD</p>
  <p>Нужно написать функцию, которая на выходе даст строку вида ABCXYZD</p>

  <details>
    <summary>Решение упрощенной задачи</summary>
    <p>Запишем первый символ в переменную lastChar и создадим пустой массив result. Пройдемся по строке и будем сравнивать текущий символом с lastChar, если не совпадает то lastChar добавляем в массив result, а текущий символ записываем в lastChar. Когда выйдем из цикла lastChar добавляем в массив result.</p>
<pre>function rleEasy(s) {
  let lastChar = s[0];
  let result = [];
  for (let i = 1; i &lt; s.length; i++) {
    if (s[i] !== lastChar) {
      result.push(lastChar);
      lastChar = s[i];
    }
  }
  result.push(lastChar);
  return result.join('');
}</pre>
  </details>

  <p>Теперь нужно положить в ответ не только символ, но и количество идущих подряд символов. Для этого нужно запоминать позицию, где начался символ и встречая следующий символ эту позицию обновлять.</p>

  <details>
    <summary>Решение RLE сжатие строки</summary>
    <p>Добавим счетчик одинаковых букв. Если следующая буква такая же, то счетчик будет прибавлять 1. Если следующая буква другая, то записываем в массив с ответом предыдущую букву, потом записываем счетчик (если он больше 1), потом запоминаем следующую букву и сбрасываем счетчик в 1.</p>
<pre>function rle(s) {
  let lastChar = s[0];
  let result = [];
  let count = 1;
  for (let i = 1; i &lt; s.length; i++) {
    if (s[i] !== lastChar) {
      result.push(lastChar);
      if (count &gt; 1) {
        result.push(count);
      }
      lastChar = s[i];
      count = 1;
    } else {
      count++;
    }
  }
  result.push(lastChar);
  result.push(count);
  return result.join('');
}</pre>
  </details>
</article>
