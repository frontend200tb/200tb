<h1>Тренировки по алгоритмам 1.0</h1>


<article class="article">
  <h2>Михаил Густокашин</h2>
  <p>Конспект курса <strong>Тренировки по алгоритмам 1.0</strong> (с 2021.06.02 до 2021.06.30)</p>
  <p><a href="https://yandex.ru/yaintern/algorithm-training_2021">yandex.ru/yaintern/algorithm-training_2021</a></p>

  <h4>Разбор ДЗ по лекции 3 и 4</h4>
  <p>2021-06-18 Разбор ДЗ по лекции 3 и 4.mp4</p>
</article>


<!-- Содержание -->
<article class="article">
  <h3>Содержание</h3>

  <br><a href="#r34">Разбор ДЗ по лекции 3 и 4</a>
  <br><a href="#r3-1">Занятие 3. Черепахи</a>
  <br><a href="#r3-2">Занятие 3. Пробежки по Манхэттену</a>
  <br><a href="#r4-1">Занятие 4. Расшифровка письменности Майя</a>
  <br><a href="#r4-2">Занятие 4. Контрольная по ударениям</a></li>
  <br><a href="#r4-3">Занятие 4. Дополнительная проверка на списывание</a>
</article>


<!-- Разбор ДЗ по лекции 3 и 4 -->
<article class="article">
  <div class="anchor" id="r34"></div>
  <h2>Разбор ДЗ по лекции 3 и 4</h2>
</article>


<!-- Занятие 3. Черепахи -->
<article class="article">
  <div class="anchor" id="r3-1"></div>
  <h2>Занятие 3. Черепахи</h2>

  <p>Широко известна следующая задача для младших школьников. Три черепахи ползут по дороге. Одна черепаха говорит: "Впереди меня две черепахи". Другая черепаха говорит: "Позади меня две черепахи". Третья черепаха говорит: "Впереди меня две черепахи и позади меня две черепахи". Как такое может быть? Ответ: третья черепаха врет!</p>
  <p>По дороге одна за другой движутся N черепах. Каждая черепаха говорит фразу вида: "Впереди меня ai черепах, а позади меня bi черепах." Ваша задача определить, сколько самое большое количество черепах могут говорить правду.</p>

  <details>
    <summary>Решение</summary>
    <p>Если черепаха называет отрицательное число, то это неправда. Проверяем числа на отрицательность. В сумме всех черепах N. Поэтому проверяем, что ai + bi = N - 1. Если две черепахи сказали одно и то же, то говорит правду только одна. Поэтому делаем множество из всех ответов ai и смотрим чтобы они не повторялись.</p>
<pre>function cherepaha(n, a, b) {
  let setA = new Set();
  for (let i = 0; i &lt; n; i++) {
    if (a[i] >=0 && b[i] >= 0 && a[i] + b [i] === n - 1) {
      setA.add(a[i]);
    }
  }
  return setA.size;
}

let n1 = 6;
let w1 = [1,-3,0,3,4,1];
let w2 = [4,3,5,-1,1,4];

console.log(cherepaha(n1, w1,w2)); // 3</pre>
  </details>
</article>


<!-- Занятие 3. Пробежки по Манхэттену -->
<article class="article">
  <div class="anchor" id="r3-2"></div>
  <h2>Занятие 3. Пробежки по Манхэттену</h2>

  <p>Дороги Нью-Манхэттена устроены следующим образом. С юга на север через каждые сто метров проходит авеню, с запада на восток через каждые сто метров проходит улица. Авеню и улицы нумеруются целыми числами. Меньшие номера соответствуют западным авеню и южным улицам. Таким образом, можно построить прямоугольную систему координат так, чтобы точка (x,y) лежала на пересечении x-ой авеню и y-ой улицы. Легко заметить, что для того, чтобы в Нью-Манхэттене дойти от точки (x1,y1) до точки (x2,y2) нужно пройти |x2-x1| + |y2-y1| кварталов. Эта величина называется манхэттенским расстоянием между точками (x1,y1) и (x2,y2)</p>
  <p>Миша живет в Нью-Манхэттене и каждое утро делает пробежку по городу. Он выбегает из своего дома, который находится в точке (0,0) и бежит по случайному маршруту. Каждую минуту миша либо остается на том же перекрестке, что и минуту назад, или перемещается на один квартал в любом направлении. Чтобы не заблудиться Миша берет с собой навигатор, который каждые t минут говорит Мише, в какой точке он находится. К сожалению, навигатор показывает не точное положение Миши, он может показать любую из точек, манхэттенское расстояние от которых до Миши не превышает d.</p>
  <p>Через t*n минут от начала пробежки, получив n-е сообщение от навигатора, Миша решил что пора бежать домой. Для этого он хочет понять, в каких точках он может находиться. Помогите Мише сделать это.</p>
</article>


<!-- Занятие 4. Расшифровка письменности Майя -->
<article class="article">
  <div class="anchor" id="r4-1"></div>
  <h2>Занятие 4. Расшифровка письменности Майя</h2>

  <p>Одна из проблем расшифровки письменности Майа заключается в определении этого порядка. Рисуя значки некоторого слова, писатели Майя иногда выбирали позиции для значков, исходя скорее из эстетических взглядов, а не определенных правил. Это привело к тому, что, хотя звуки для многих значков известны, археологи не всегда уверены, как должно произноситься записанное слово.</p>
  <p>Археологи ищут некоторое слово W. Они знают значки для него, но не знают все возможные способы их расположения. Поскольку они знают, что Вы приедете на |O|'06, они просят Вас о помощи. Они дадут Вам g значков в надписи, которую они изучают, в порядке их появления. Помогите им, подститав количество возможных появлений слова W.</p>
  <p>Задание. Напишите программу, которая по значкам слова W и по последовательности S значков надписи подсчитывает количество всех возможных вхождений слова W в S, то есть количество всех различных позиций идущих подряд g значков в последовательности S, которые являются какой-либо перестановкой значков слова W.</p>

  <details>
    <summary>Решение</summary>
    <p>Неверным решением было бы брать строку S, брать в ней первые W символов для слова, сортировать их. Потом сдвигаться в строке S на один символ и опять брать W символов, сортировать их и т.д.</p>
    <p>Хорошая идея это посчитать сколько раз каждая буква входит в слово W. Для этого создадим словарь dictW для букв из слова W. Дальше методом окна выбираем в начале предложения S слово длиной W.length, создаем для него словарь dictS и сравниваем его со словарем dictW. Если совпадают то это будет вхождение слова W в предложение S.</p>
    <p>Далее сдвигаем окно на 1 символ. Изменим словарь dictS так что уберем из него первый символ предыдущего слова и добавим один новый символ. Сравним словари dictS и dictW, если совпадают, то увеличим счетчик вхождения слов на 1.</p>
  </details>
</article>


<!-- Занятие 4. Контрольная по ударениям -->
<article class="article">
  <div class="anchor" id="r4-2"></div>
  <h2>Занятие 4. Контрольная по ударениям</h2>

  <p>Учительница задала Пете домашнее задание - в заданном тексте расставить ударения в словах, после чего поручила Васе проверить это домашнее задание. Вася очень плохо знаком с данной темой, поэтому он нашел словарь, в котором указано, как ставятся ударения в словах. К сожалению, в этом словаре присутствуют не все слова. Вася решил, что в словах, которых нет в словаре, он будет считать, что Петя поставил ударения правильно, если в этом слове Петей поставлено ровно одно ударение. Оказалось, что в некоторых словах ударение может быть поставлено больше, чем одним способом. Вася решил, что в этом случае если то, как Петя поставил ударение, соответствует одному из приведенных в словаре вариантов, он будет засчитывать это как правильную расстановку ударения, а если не соответствует, то как ошибку.</p>
  <p>Вам дан словарь, которым пользовался Вася и домашнее заданее, сделанное Петей. Ваша задача - определить количество ошибок, которое в этом задании насчитает Вася.</p>
  <p>Пример</p>
  <code>Словарь cAnnot, cannOt, fOund, pAge.</code>
  <code>Предложение thE pAge cAnnot be found</code>
  <code>Вывод 2</code>

  <details>
    <summary>Решение</summary>
    <p>Создадим словарь dictLower[key, value] с ключами из маленьких букв, в котором будем ранить Set со всеми ударениями. Set(stress) это набор слов с ударениями. К нам приходит очередное слова в тексте. Мы делаем все его буквы маленькими. Дальше возможны два варианта.</p>
    <p>Вариант 1. Если оно есть в словаре, то мы проверяем, что слово с ударением входит в набор слов с ударениями для этого слова.</p>
    <p>Вариант 2. Если его нет в словаре, то мы должны проверить что у него всего одно ударение.</p>
  </details>
</article>


<!-- Занятие 4. Дополнительная проверка на списывание -->
<article class="article">
  <div class="anchor" id="r4-3"></div>
  <h2>Занятие 4. Дополнительная проверка на списывание</h2>

  <p>В первой строке вводятся число n - количество ключевых слов в языке (0 &lt;= n &lt;= 50) и два слова C и D, каждое из которых равно либо "yes", либо "no". Слово C равно "yes", если идентификаторы и ключевые слова в языке чувствительны к регистру символов, и "no", если нет. Слово D равно "yes", если идентификаторы в языке могут начинаться с цифры, и "no", если нет.</p>
  <p>Следующие n строк содержат по одному слову, состоящему из букв латинского алфавита и символов подчеркивания - ключевые слова. Все ключевые слова непусты, различны, при этом, если язык не чувствителен к регистру, то различны и без учета регистра. Длина каждого ключевого слова не превышает 50 символов.</p>
  <p>Далее до конца входных данных идет текст программы. Он содержит только символы с ASCII-кодами от 32 до 126 и переводы строки.</p>
  <p>Размер входных данных не превышает 10 килобайт. В программе есть хотя бы один идентификатор.</p>
  <p>Выведите идентификатор, встречающийся в программе максимальное число раз. Если таких идентификаторов несколько, следует вывести тот, который встречается в первый раз раньше. Если язык во входных данных не чувствителен к регистру, то можно выводить идентификатор в любом регистре.</p>

  <details>
    <summary>Решение</summary>
    <p>Алгоритм решения может быть таким:</p>
    <ol>
      <li>Создать множество ключевых слов</li>
      <li>Создать две булевые переменные для чувствительности к регистру и возможности начинать идентификатор с цифры</li>
      <li>Создать словарь для количества вхождений идентификаторов и их первых позиций</li>
      <li>Создать счетчик слов</li>
      <li>Пройтись по всем строчкам текста</li>
      <li>Для каждой строки заменить все вхождения символов (кроме букв, цифр и подчеркивания) на пробелы</li>
      <li>Нарезать строку на слова</li>
      <li>Для каждого слова проверить, не ключевое ли оно (с учетом регистра)</li>
      <li>Если не ключевое, то проверить что корректное (не число и не начинается с цифры, если этого нельзя)</li>
      <li>Если все ОК, то увеличить счетчик слов на 1, а если встретилось впервые, то запомнить позицию</li>
      <li>Пройтись по всему словарю со счетчиками, выбрать максимальное количество вхождений, если есть равные, то которое встречалось раньше</li>
    </ol>
  </details>
</article>
