<h1>Тренировки по алгоритмам 1.0</h1>


<article class="article">
  <h2>Михаил Густокашин</h2>
  <p>Конспект курса <strong>Тренировки по алгоритмам 1.0</strong> (с 2021.06.02 до 2021.06.30)</p>
  <p><a href="https://yandex.ru/yaintern/algorithm-training_2021" target="_blank">yandex.ru/yaintern/algorithm-training_2021</a></p>

  <h4>Лекция 3. Множества</h4>
  <p>2021-06-07 Лекция 3 Множества.mp4</p>
</article>


<!-- Содержание -->
<article class="article">
  <h3>Содержание</h3>

  <br><a href="#l3">Лекция №3. Множества</a>
  <br><a href="#l3-tema-1">Тема 1. Как устроено множество</a>
  <br><a href="#l3-task-1">Задача 1. Написать свое множество</a>
  <br><a href="#l3-tema-2">Тема 2. Амортизированная сложность</a>
  <br><a href="#l3-tema-3">Тема 3. Примеры задач</a>
  <br><a href="#l3-task-2">Задача 2. Найти два числа с заданной суммой</a>
  <br><a href="#l3-task-3">Задача 3. Входит ли в словарь слово, возможно с пропущеной буквой</a>
  <br><a href="#l4">Лекция №4. Словари и сортировка подсчетом</a>
  <br><a href="#l4-tema-1">Тема 1. Сортировка подсчетом</a>
  <br><a href="#l4-task">Задача. Сортировка последовательности из K различных чисел</a>
  <br><a href="#l4-task-1">Задача 1. Можно ли получить число из другого перестановкой цифр</a>
  <br><a href="#l4-tema-2">Тема 2. Словари</a>
  <br><a href="#l4-task-2">Задача 2. Сколько пар ладей бьют друг друга</a>
  <br><a href="#l4-task-3">Задача 3. Гистограмма Hello, world!</a>
  <br><a href="#l4-tema-3">Тема 3. Задел под оптимизацию</a>
  <br><a href="#l4-task-4">Задада 4. Сгруппировать слова по общим буквам</a>
</article>


<!-- Лекция №3. Множества -->
<article class="article">
  <div class="anchor" id="l3"></div>
  <h2>Лекция №3. Множества</h2>

  <h4>Содержание сегодняшней лекции</h4>
  <ol>
    <li>Как устроено множество</li>
    <li>Амортизированная сложность</li>
    <li>Примеры задач</li>
  </ol>
</article>


<!-- Тема 1. Как устроено множество -->
<article class="article">
  <div class="anchor" id="l3-tema-1"></div>
  <h3>Тема 1. Как устроено множество</h3>

  <p>В множестве каждый элемент либо есть либо нет. Все элементы могут располагаться в любом порядке.</p>

  <h4>Что должно уметь делать множество</h4>
  <ol>
    <li>Добавлять элемент</li>
    <li>Проверять наличие элемента</li>
    <li>Удалять элемент</li>
  </ol>

  <p>Могут быть и вспомогатльные операции - узнать количество элементов в множестве, проверить пустое оно или нет. Для двух множеств могут быть объединения, пересечения.</p>

  <h4>Как устроено множество</h4>
  <ol>
    <li>Придумаем какую-нибудь функцию, которая сопоставляет каждому элементу какое-либо небольшое число</li>
    <li>Вычислим функцию от элемента</li>
    <li>Положим элемент в список с номером, равным значению функции</li>
  </ol>

  <h4>Пример функции добавления для чисел</h4>
  <ol>
    <li>Функция - последняя цифра числа X. F(X) = X & 10</li>
    <li>Вычислим функцию от элемента</li>
    <li>Положим элемент в список с номером, равным значению функции</li>
  </ol>

  <p>Если два элемента (например 137 и 17) имеют одинаковую последнюю цифру, то они попадут в список под номером 7. Это называется коллизия.</p>
  <p>Для решения коллизии для каждого числа заведем список. Сначала все списки пусты. Добавляем число в список, номер которого вычисляет хеш-функция.</p>
  <p>Если есть множество N в котором лежит K элементов, то мы можем перебрать все элементы за O(N+K). Мы будем идти по всем спискам от 0 до N. Если списук пустой, то переходим к следующему списку. Если список не пустой, то вложенном циклом проходим по всем его элементам.</p>

  <h4>Добавление элемента в множество</h4>
  <p>Когда надо добавить элемент в множество, то мы считаем для него хеш-функцию и добавляем его в нужный список.</p>

  <h4>Поиск элемента в множестве</h4>
  <p>Когда надо найти элемент в множестве, то мы считаем для него хеш-функцию и ищем его в нужном списке. Ищем обычным линейным поиском, который проходит по всем элементам списка.</p>

  <h4>Удаление элемента из множества</h4>
  <p>Когда надо удалить элемент из множества, то вначале его надо найти. Делаем то же самое, что и при поиске элемента. Если в списке нет других элементов, то просто удаляем его и список становится пуст. Если есть еще элементы, то копируем последний элемент на место удаляемого и удаляем последний элемент.</p>
  <p>Поиск занял O(K/N) в среднем, а удаление найденного элемента O(1).</p>
</article>


<!-- Задача 1. Написать свое множество -->
<article class="article">
  <div class="anchor" id="l3-task-1"></div>
  <h2>Задача 1. Написать свое множество</h2>

  <p>Создадим пустой массив mySet на setSize элементов. В каждый элемент пустого массива mySet также положим пустой массив.</p>
  <p>Создадим три функции - add() добавление одного элемента в множество, find() поиск элемента в множестве, del() удаление элемента из множества.</p>
  <p>При добавлении числа в можество будем вычислять хеш-функцию. То есть искать остаток от деления числа на размер множества. Хеш-функция вернет нам индекс элемента массива. По этому индексу находится вложенный массив, куда мы добавим новый элемент в конец.</p>
  <p>При поиске числа в множестве будем вычислять хеш-функцию. Получим индекс элемента.Прохойдем линейным поиском по всем элементам вложенного массива и вернем true если он там есть.</p>
  <p>При удалении числа из множества сначала находим его. Записываем на его место последний элемент во вложенном массиве и удаляем последний элемент.</p>
  <p>Мы получили мультимножество. В которое один и тот же элемент может входить несколько раз. Это не множество уникальных значений. При добавлении мы не проверяем элемент на уникальность, есть ли он уже в этом множестве.</p>
  <p>При поиске будет искаться первый элемент, если их несколько. При удалении будет удаляться первый элемент, если их несколько.</p>
  <p>Если нужно сделать множество уникальных элемнтов, то при добавлении элемента в множество надо сделать проверку есть ли такой элемент в множестве. Если есть то новый элемент не добавлять.</p>

  <details>
    <summary>Решение</summary>
<pre>let setSize = 10;
  let mySet = [];

  for (let i = 0; i &lt; setSize; i++) {
    mySet[i] = [];
  }

  function add(x) {
    mySet[x % setSize].push(x);
  }

  function find(x) {
    let nowSet = mySet[x % setSize];
    for (let i = 0; i &lt; nowSet.length; i++) {
      if (x === nowSet[i]) {
        return true;
      }
    }
    return false;
  }

  function del(x) {
   let nowSet = mySet[x % setSize];
   for (let i = 0; i &lt; nowSet.length; i++) {
      if (x === nowSet[i]) {
        nowSet[i] = nowSet[nowSet.length - 1];
        nowSet.pop();
      }
   }
  }</pre>
  </details>

  <h4>Термины</h4>
  <ul>
    <li>F(X) = X % setsize - хеш-функция</li>
    <li>mySet (список списков) - хеш-таблица</li>
    <li>Совпадение значений хеш-функции для разных параметров - коллизия</li>
  </ul>

  <h4>Что можно хранить в множестве эффективно</h4>
  <ul>
    <li>Вообще говоря хранить можно что угодно - в компьютере все состоит из чисел</li>
    <li>Эффективно - только неизменяемые объекты</li>
    <li>Для неизменяемых объектов можно посчитать значение хеш-функции при их создании</li>
    <li>Хеш-функция должна давать равномерное распределение</li>
  </ul>
</article>


<!-- Тема 2. Амортизированная сложность -->
<article class="article">
  <div class="anchor" id="l3-tema-2"></div>
  <h3>Тема 2. Амортизированная сложность</h3>

  <h4>Проблемы с хеш-таблицей</h4>
  <ul>
    <li>Слишком большой размер - ест много памяти O(N)</li>
    <li>Слишком маленький размер - большой коэффициент заполнения и медленный поиск и удаление O(K/N)</li>
    <li>Хочется иметь разумный баланс, например, коэффициент заполнения не больше единицы (K &le; N). Тогда все операции в среднем будут занимать O(1).</li>
  </ul>

  <p>Мы хотим чтобы в множестве хранилось не больше элементов, чем его размер. А точнее чтобы каждый список внутри множества имел только один элемент.</p>

  <h4>Решение проблемы с хеш-таблицей</h4>
  <ul>
    <li>Когда таблица наполнится - увеличим ее размер вдвое и перестроим.</li>
  </ul>

  <p>Найдем сложность добавления N элементов в хэш-таблицу.</p>
  <ul>
    <li>Возьмем таблицу с начальным размером 1.</li>
    <li>Будем добавлять N = 2^P элементов, т.е. P = logN. Таблица расширяется вдвое, поэтому удобно работать со степенями двойки (число элементов).</li>
    <li>Только на P шагах (когда размер таблицы равен очередной степени двойки) может произойти перестроение таблицы за O(N).</li>
  </ul>
  <code>1 + 2 + 4 + 8 + ... + 2^P = 2^(P+1) - 1 = 2N - 1 = O(N)</code>

  <h4>Амортизированная сложность</h4>
  <ul>
    <li>Амортизированная сложность - среднее время выполнения операции (условно)</li>
    <li>У нас амортизированная сложность операции O(1) - всего было N операций и суммарно на это ушло O(N)</li>
    <li>В худжем случае отдельная операция выполняется за O(N) - может не подходить для систем реального времени</li>
  </ul>
</article>


<!-- Тема 3. Примеры задач -->
<article class="article">
  <div class="anchor" id="l3-tema-3"></div>
  <h2>Тема 3. Примеры задач</h2>
</article>


<!-- Задача 2. Найти два числа с заданной суммой -->
<article class="article">
  <div class="anchor" id="l3-task-2"></div>
  <h2>Задача 2. Найти два числа с заданной суммой</h2>

  <p>Дана последовательность положительных чисел длиной N и число X.</p>
  <p>Найти два различных числа A и B из последовательности, чтобы A + B = X, или вернуть пару 0, 0, если такой пары чисел нет.</p>

  <details>
    <summary>Решение 1. O(N^2)</summary>
    <p>В цикле пройдем по последовательности чисел. Для каждого числа во вложенном цикле пройдем опять по последовательности чисел. Найдем пару чисел которые в сумме дадут число X. Вложенный цикл начинается не с нуля, а со следующего числа, на котором работает внешний цикл. Это нужно для того чтобы числа были разные и не складывать два раза одинаковые пары чисел.</p>
<pre>function pairSum(nums, x) {
  for (let i = 0; i &lt; nums.length - 1; i++) {
    for (let j = i + 1; j &lt; nums.length; j++) {
      if (nums[i] + nums[j] === x) {
        return [nums[i], nums[j]];
      }
    }
  }
  return [0,0];
}</pre>
  </details>

  <details>
    <summary>Решение 2. O(N)</summary>
    <p>Будем хранить все уже обработанные числа в множестве. Если очередное число now, а x - now есть в множестве, то мы нашли слагаемые.</p>
<pre>function pairSum(nums, x) {
  let setNums = new Set();
  for (let i = 0; i &lt; nums.length; i++) {
    if (setNums.has(x - nums[i])) {
      return [x - nums[i], nums[i]];
    }
    setNums.add(nums[i]);
  }
  return [0,0];
}</pre>
  </details>
</article>


<!-- Задача 3. Входит ли в словарь слово, возможно с пропущеной буквой -->
<article class="article">
  <div class="anchor" id="l3-task-3"></div>
  <h2>Задача 3. Входит ли в словарь слово, возможно с пропущеной буквой</h2>

  <p>Дан словарь из N слов, длина каждого не превосходит K.</p>
  <p>В записи каждого из M слов текста (каждое длиной до K) может быть пропущена одна буква. Для каждого слова сказать, входит ли оно (возможно, с одной пропущенной буквой) в словарь.</p>

  <details>
    <summary>Решение за O(NK + M)</summary>
    <p>Выбросим из каждого слова словаря по одной букве всеми возможными способами за O(NK) и положим получившиеся слова в словарь. Тогда для каждого слова из K букв мы получим еще K новых слов.</p>
    <p>Например для слова abcd добавим в словарь 5 новых слов: abcd, abc, abd, acd, bcd.</p>
   <p>Для каждого слова из текста просто проверим, есть ли оно в словаре за O(1).</p>
   <p>Принимая во внимание сложность создания строки (нового слова). Сложность решения будет O(NK^2 + M)</p>
   <p>Создадим словарь из всех слов. Потом пройдем по каждому слову в словаре и создадим все слова с одной пропущенной буквой для этого слова.</p>
<pre>function wordInDict(dict, word) {
  let newDict = new Set(dict);
  for (let i = 0; i &lt; dict.length; i++) {
    for (let j = 0; j &lt; dict[i].length; j++) {
      newDict.add(dict[i].slice(0,j) + dict[i].slice(j+1));
    }
  }
  if (newDict.has(word)) {
    return true;
  }
  return false;
}</pre>
  </details>
</article>
