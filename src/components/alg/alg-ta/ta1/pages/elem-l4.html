<h1>Тренировки по алгоритмам 1.0</h1>


<article class="article">
  <h2>Михаил Густокашин</h2>
  <p>Конспект курса <strong>Тренировки по алгоритмам 1.0</strong> (с 2021.06.02 до 2021.06.30)</p>

  <h4>Лекция 4. Словари и сортировка подсчётом</h4>
  <p><a href="https://yandex.ru/yaintern/algorithm-training_2021">yandex.ru/yaintern/algorithm-training_2021</a></p>
  <p><a href="https://contest.yandex.ru/contest/27393/problems/">Задачи</a></p>
  <p>2021-06-09 Лекция 4 Словари и сортировка подсчётом.mp4</p>
</article>


<!-- Содержание -->
<article class="article">
  <h3>Содержание</h3>

  <br><a href="#l4">Лекция №4. Словари и сортировка подсчетом</a>
  <br><a href="#l4-tema-1">Тема 1. Сортировка подсчетом</a>
  <br><a href="#l4-task">Задача. Сортировка последовательности из K различных чисел</a>
  <br><a href="#l4-task-1">Задача 1. Можно ли получить число из другого перестановкой цифр</a>
  <br><a href="#l4-tema-2">Тема 2. Словари</a>
  <br><a href="#l4-task-2">Задача 2. Сколько пар ладей бьют друг друга</a>
  <br><a href="#l4-task-3">Задача 3. Гистограмма Hello, world!</a>
  <br><a href="#l4-tema-3">Тема 3. Задел под оптимизацию</a>
  <br><a href="#l4-task-4">Задада 4. Сгруппировать слова по общим буквам</a>
</article>


<!-- Лекция №4. Словари и сортировка подсчетом -->
<article class="article">
  <div class="anchor" id="train-4"></div>
  <h2>Лекция №4. Словари и сортировка подсчетом</h2>

  <p>Это самая практически полезная лекция. Очень много задач и на практике очень часто встречаются словари.</p>

  <h4>Содержание сегодняшней лекции</h4>
  <ol>
    <li>Сортировка подсчетом</li>
    <li>Словари</li>
    <li>Задел под оптимизацию</li>
  </ol>
</article>


<!-- Тема 1. Сортировка подсчетом -->
<article class="article">
  <div class="anchor" id="l4-tema-1"></div>
  <h2>Тема 1. Сортировка подсчетом</h2>

  <h4>Что такое сортировка подсчетом</h4>
  <ul>
    <li>Пусть необходимо отсортировать массив из N целых чисел, каждое от 0 до K</li>
    <li>Обычная сортировка займет O(NlogN)</li>
    <li>Будем считать количество вхождений каждого числа, а затем выводить каждое число столько раз, сколько оно встречалось. Это займет O(N+K) и O(K) дополнительной папяти</li>
    <li>Интервал значений можно сдвинуть, чтобы он был не от 0 до K, а от минимального до максимального значения в массиве.</li>
  </ul>
  <p>K это разница между максимальным и минимальным значением. K должно быть небольшим.</p>

  <h4>Отсортировать последовательность школьных оценок</h4>
  <p>Например, это школьные оценки от 1 до 5 и нужно их упорядочить. Для таких задач, где не много разных значений мы не будем пользоваться стандартной сортировкой за O(NlogN).</p>
  <p>Каждый раз когда встречаем оценку, будем увеличивать счетчик этих оценок на 1. Для этого заведем массив с индексами от 1 до 5. В программировании массивы начинаются с нулевого элемента. Тогда пусть в массиве будет еще один элемент - нулевой, который нигде не будет использоваться, зато вы ничего не напутаете с индексами.</p>
  <p>Сначала заполним массив нулями. Пусть есть последовательность оценок</p>
  <code>5,4,5,3,2,1,5</code>
  <p>Будем идти по последователности и увеличивать на 1 элемент массива с индексом равным оценке. Когда массив будет заполнен, пройдем теперь по массиву и будем выводить индекс столько раз скольо записано в его ячейке.</p>
  <code>1,2,3,4,5,5,5</code>
</article>


<!-- Задача. Сортировка последовательности из K различных чисел -->
<article class="article">
  <div class="anchor" id="l4-task"></div>
  <h2>Задача. Сортировка последовательности из K различных чисел</h2>

  <details>
    <summary>Сортировка подсчетом</summary>
    <p>Пусть в последовательности из N чисел есть K различных чисел.</p>
    <ol>
      <li>Найдем минимальное и максимальное из чисел. Сложность O(2N).</li>
      <li>Создадим массив длиной K и заполним его нулями. Сложность O(K).</li>
      <li>Пройдем в цикле по исходной последовательности и для каждого числа будем увеличивать на 1 значение в соответствующей ячейке массива длиной K. Сложность O(N).</li>
      <li>Создадим пустой массив для записи результата</li>
      <li>Пройдем в цикле по массиву длиной K и для каждого числа будем записывать его в результат столько раз, какое значение стоит в массиве.</li>
    </ol>
<pre>function sortCount(nums) {
  let min = Math.min(...nums);
  let max = Math.max(...nums);
  let k = max - min + 1;
  let countArr = new Array(k).fill(0);

  for (let i = 0; i &lt; nums.length; i++) {
    countArr[nums[i] - min] += 1;
  }

  let count = 0;
  let newNums= [];
  for (let i = 0; i &lt; k; i++) {
    for (j = 0; j &lt; countArr[i]; j++) {
      newNums[count] = i + min;
      count++;
    }
  }
  return newNums;
}</pre>
  </details>
</article>


<!-- Задача 1. Можно ли получить число из другого перестановкой цифр -->
<article class="article">
  <div class="anchor" id="l4-task-1"></div>
  <h2>Задача 1. Можно ли получить число из другого перестановкой цифр</h2>

  <p>Дано два числа X и Y без ведущих нулей.</p>
  <p>Необходимо проверить, можно ли получить первое из второго перестановкой цифр.</p>

  <details>
    <summary>Решение</summary>
    <p>Посчитаем количество вхождений каждой цифры в каждое из чисел и сравним. Цифры будем постепенно добывать из числа справа с помощью остатка от деления на 10 и деления нацело на 10. Количество цифр будем записывать в массив из 10 элементов от 0 до 9. Сделаем это для первого числа и для второго. Сравним полученные массивы поэлементно.</p>
<pre>function compare(x, y) {
  function count(num) {
    let arr = new Array(10).fill(0);
    while (num &gt; 0) {
      let d = num % 10;
      arr[d]++;
      num = Math.floor(num / 10);
    }
    return arr;
  }

  let dx = count(x);
  let dy = count(y);
  for (let i = 0; i &lt; 10; i++) {
    if (dx[i] !== dy[i]) {
      return false;
    }
  }
  return true;
}</pre>
  </details>
</article>


<!-- Тема 2. Словари -->
<article class="article">
  <div class="anchor" id="l4-tema-2"></div>
  <h2>Тема 2. Словари</h2>

  <p>Словари более универсальны. Но в некоторых ситуациях работают хуже чем сортировка подсчетом.</p>
  <p>Словари позволяют по ключу узнавать значение.</p>

  <h4>Как реализованы словари</h4>
  <ul>
    <li>Словарь - он как множество, но к каждому ключу приписано значение</li>
    <li>Искать по значению в словаре нельзя</li>
    <li>Константа в сложности словарей заметно больше, чем у массивов. Происходит расширение время от времени, считается хеш-функция. Поэтому где можно - лучше использовать сортировку подсчетом</li>
    <li>Сортировку подсчетом неразумно использовать, если данные разреженные</li>
  </ul>
</article>


<!-- Задача 2. Сколько пар ладей бьют друг друга -->
<article class="article">
  <div class="anchor" id="l4-task-2"></div>
  <h2>Задача 2. Сколько пар ладей бьют друг друга</h2>

  <p>На шахматной доске NxN нажодятся M ладей (ладья бьет клетки на той же горизонтали или вертикали до ближайшей занятой)</p>
  <p>Определите, сколько пар ладей бьют друг друга. Ладьи задаются парой чисел I и J, обозначающих координаты клетки</p>
  <code>1 &lt;= N &lt;= 10^9, 0 &lt;= M &lt;= 2 * 10^5</code>

  <details>
    <summary>Решение за O(M)</summary>
    <p>Для каждой занятой горизонтали и вертикали будем хранить количество ладей на них. Количество пар в горизонтали (вертикали) равно количеству ладей минус 1. Суммируем это количество пар для всех горизонталей и вертикалей.</p>
<pre>function count(coord) {
  // создадим два словаря
  // для горизонталей
  let row = {};
  // для вертикалей
  let col = {};
  // пройдем по всем координатам
  for (let i = 0; i &lt; coord.length; i++) {
    // заполним словарь горизонталей
    if (!row[coord[i][0]]) {
      row[coord[i][0]] = 0;
    }
    row[coord[i][0]]++;
    // заполним словарь вертикалей
    if (!col[coord[i][1]]) {
      col[coord[i][1]] = 0;
    }
    col[coord[i][1]]++;
  }
  // найдем пары на горизонталях
  let pairsRow = 0;
  for (let key in row) {
    pairsRow += row[key] -1;
  }
  // найдем пары на вертикалях
  let pairsCol = 0;
  for (let key in col) {
    pairsCol += col[key] -1;
  }
  return pairsRow + pairsCol;
}</pre>

  <p>Тест</p>
  <code>let w1 = [[2,7],[2,4],[4,7],[5,4]];</code>
  <code>console.log(count(w1)); // 3</code>
  </details>

  <p>На олимпиадах встречаются задачи где нужно посчитать количество пар ферзей. Это то же самое. Только нужно учитывать что ферзь бьет еще и по диагонали. Все клетки на каждой диагонали направленной слева-направо вверх имеют одинаковую разницу координат i-j (номер строки минус номер столбца). Все клетки на каждой диагонали направленной слева-направо вниз имеют одинаковую сумму i+j (номер строки плюс номер столбца).</p>
</article>


<!-- Задача 3. Гистограмма Hello, world! -->
<article class="article">
  <div class="anchor" id="l4-task-3"></div>
  <h2>Задача 3. Гистограмма Hello, world!</h2>

  <p>Дана строка S</p>
  <p>Выведите гистограмму как в примере (коды символов отсортированы)</p>
  <code>S = Hello, world!</code>
<pre>
      #
      ##
##########
 !,Hdelorw
</pre>

  <details>
    <summary>Решение</summary>
    <p>Для каждого символа в словаре посчитаем, сколько раз он встречался. Найдем самый частый символ и переберем количество от этого числа до 1. Пройдем по всем отсортированным ключам и если количество больше счетчика - выведем #</p>
    <p>Заведем словарь. Ключами будут символы в строке, а значениями - сколько раз они встречаются. Пройдем по строке, если символ еще не встречался, то создаем в словаре такой ключ со значением ноль. Потом в любом случае прибавляем 1.</p>
    <p>Потом нужно отсортировать все ключи в словаре и занести в счетчик максимальное значение. В цикле от максимального значения счетчика до 1 пройтись по словоарю и вывести построчно гистограмму.</p>
<pre>function hist(str) {
  // создадим словарь
  let dict = {};
  // максимальное число одинаковых букв
  let max = 0;
  // пройдем по символам в строке
  for (let i = 0; i &lt; str.length; i++) {
    // заполним словарь
    if (!dict[str[i]]) {
      dict[str[i]] = 0;
    }
    dict[str[i]]++;
    // находим максимум
    max = Math.max(max, dict[str[i]]);
  }
  // отсортируем ключи объекта
  let sortedKeys = Object.keys(dict).sort();
  // переменная для вывода строки на экран
  let result = [];
  // начиная с верхней строки и до нижней
  for (let i = max; i &gt; 0; i--) {
    // смотрим для каждого ключа
    sortedKeys.forEach(key =&gt; {
      // есть ли он в этой строке
      if (dict[key] &gt;= i) {
        // если есть добавляем #
        result.push('#');
      } else {
        // если нет добавляем пробел
        result.push(' ');
      }
    })
    // добавляем символ переноса строки
    result.push('\n');
  }
  // добавляем строку из отсортированных символов
  result.push(sortedKeys.join(''));
  console.log(result.join(''));
}</pre>

    <p>Тест</p>
    <code>let w1 = 'Hello, world!';</code>
    <code>hist(w1);</code>
<pre>
      #
      ##
##########
 !,Hdelorw
</pre>
    </details>
</article>


<!-- Тема 3. Задел под оптимизацию -->
<article class="article">
  <div class="anchor" id="l4-tema-3"></div>
  <h3>Тема 3. Задел под оптимизацию</h3>

  <p>Преждевременная оптимизация - страшный грех. Например нужно за неделю написать код, который решает бизнес задачу. Но на самых быстрых алгоритмах такой код можно написать только за месяц. А решать задачу нужно уже сейчас. Поэтому выбирают решение попроще, не самое быстрое и эффективное, но которое позволит решить задачу уже сейчас.</p>
  <p>Но если вы знаете как сделать лучше, но на это уже не остается времени, то неплохо оставить задел, чтобы в следующий раз при похожей проблеме можно было быстренько переделать эту тормозящую часть.</p>

  <h4>Всегда ли асимптотическое решение лучше?</h4>
  <p>2*N log N или 1000*N?</p>
  <p>Допустим, мы придумали два решения. Сложность одного O(N), другого - O(NlogN). Тоже классно, но похуже. Только подозрительно большая константа у линейного алгоритма. Найдем N при котором линейный алгоритм будет работать лучше. При N больше чем 2 в 500 степени, линейный алгоритм станет работать лучше. Но 2^500 примерно в 10^70 раз больше количества атомов во вселенной. В реальности разница констант в 500 раз все же случается редко.</p>

  <h4>Некоторые другие критерии качества алгоритма</h4>
  <ol>
    <li>Потребление памяти</li>
    <li>Время на реализацию. В промышленной разработке время на реализацию всегда ограничено. Поэтому всегда приходится отказываться от тех идей, которые не успеете реализовать.</li>
    <li>Сложность поддержки. Код читают гораздо чаще чем пишут. Поэтому надо писать так чтобы было легко читать и через месяц и больше.</li>
    <li>Возможность распараллеливания. Некоторые алгоритмы последовательно опираются на данные, подсчитанные на предыдущем шаге, а некоторые можно распараллелить.</li>
    <li>Необходимая квалификация сотрудника. Может оказаться что имея много  денег, вы не можете найти на рынке достаточное количество квалифицированных сотрудников, которые могут реализовать и поддерживать ваши самые новые и классные алгоритмы.</li>
    <li>Стоимость оборудования. Можно купить железо, которое будет быстрее обрабатывать ваши алгоритмы. Но все равно можно упереться в какойто момент, когда уже физически железо быстрее работать не может.</li>
  </ol>

  <p></p>
</article>


<!-- Задада 4. Сгруппировать слова по общим буквам -->
<article class="article">
  <div class="anchor" id="l4-task-4"></div>
  <h2>Задада 4. Сгруппировать слова по общим буквам</h2>

  <p>Дан массив слов. Нужно слова состоящие из одинаковых букв сгруппировать в подмассивы.</p>
  <code>Ввод ['eat', 'tea', 'tan', 'ate', 'nat', 'bat']</code>
  <code>Вывод [['ate', 'eat', 'tea'], ['nat', 'tan'], ['bat']]</code>

  <details>
    <summary>Решение 1</summary>
    <p>Отсортируем в каждом слове буквы и это будет выступать в роли ключа, а значением будет список слов</p>
<pre>function group(words) {
  let groups = {};
  words.forEach(word => {
    let key = word.split('').sort();
    if (!groups[key]) {
      groups[key] = [];
    }
    groups[key].push(word)
  });
  let result = [];
  for (let k in groups) {
    result.push(groups[k]);
  }

  return result;
}</pre>
    <p>Вдруг слово будет длинное (N)? Сортировка займет O(NlogN). Количество различных букв в слове K&lt;=N, можем посчитать количество каждой за O(N) и отсортировать за O(KlogK), теоретически.</p>
    <p>Но мы думаем: сейчас времени не хватает, осталось 2 минуты, я не успеваю это переделать. Но можно сделать задел на будущее.</p>

    <h4>Задел для возможных оптимизаций</h4>
    <p>Вынесем отдельно в функцию подсчет ключа. Будет тормозить - посмотрим на профилировщике где, и если долго считается ключ - легко поправим на что-то более эффективное.</p>
<pre>function group(words) {
  // функция подсчета ключа
  function getKey(word) {
    return word.split('').sort();
  }

  let groups = {};
  words.forEach(word => {
    let key = getKey(word);
    if (!groups[key]) {
      groups[key] = [];
    }
    groups[key].push(word)
  });
  let result = [];
  for (let k in groups) {
    result.push(groups[k]);
  }

  return result;
}</pre>

    <h4>Оптимизация</h4>
    <p>Изменим функцию подсчета ключа. Создадим словарь. Пройдемся по буквам в слове. Сделаем сортировку подсчетом. Это будет работать за O(KlogK) при K&lt;=N. Сомнительная оптимизация. В среднем хуже чем было.</p>
<pre>function group(words) {
  // функция подсчета ключа
  function getKey(word) {
    let count = {};
    for (i = 0; i &lt; word.length; i++) {
      if(!count[word[i]]) {
        count[word[i]] = 0;
      }
      count[word[i]]++;
    }
    let lst = [];
    let sortedCount = Object.keys(count).sort();
    sortedCount.forEach(sym =&gt; {
      lst.push(sym);

    })
    return lst.sort();
  }

  let groups = {};
  words.forEach(word => {
    let key = getKey(word);
    if (!groups[key]) {
      groups[key] = [];
    }
    groups[key].push(word)
  });
  let result = [];
  for (let k in groups) {
    result.push(groups[k]);
  }

  return result;
}</pre>

    <p>Если такую оптимизацию не выносить в отдельную функцию, а делать в основном коде. То будет очень трудно понять что там вообще происходит.</p>
  </details>
</article>
