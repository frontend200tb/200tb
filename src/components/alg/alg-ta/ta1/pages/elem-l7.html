<h1>Тренировки по алгоритмам 1.0</h1>


<article class="article">
  <h2>Михаил Густокашин</h2>
  <p>Конспект курса <strong>Тренировки по алгоритмам 1.0</strong> (с 2021.06.02 до 2021.06.30)</p>

  <h4>Лекция 7. Сортировка событий</h4>
  <p><a href="https://yandex.ru/yaintern/algorithm-training_2021" target="_blank">yandex.ru/yaintern/algorithm-training_2021</a></p>
  <p><a href="https://contest.yandex.ru/contest/27883/problems/" target="_blank">contest.yandex.ru/contest/27883/problems</a></p>
  <p>2021-06-21 Лекция 7 Сортировка событий.mp4</p>
</article>


<!-- Содержание -->
<article class="article">
  <h3>Содержание</h3>

  <br><a href="#l7">Лекция 7. Сортировка событий</a>
  <br><a href="#l7-1">Сортировка событий</a>
  <br><a href="#l7-task-1">Задача 1. Максимальное количество человек было на сайте одновременно</a>
  <br><a href="#l7-task-2">Задача 2. Суммарное время посетителей на сайте</a>
  <br><a href="#l7-task-3">Задача 3. Какие показания счетчика увидел начальник</a>
  <br><a href="#l7-2">События на круге</a>
  <br><a href="#l7-task-4">Задача 4. Когда были заняты все парковочные места</a>
  <br><a href="#l7-task-5">Задача 5. Минимальное количество автомобилей, которые заняли все места</a>
  <br><a href="#l7-task-6">Задача 6. Номера минимального количества автомобилей, которые заняли все места</a>
</article>


<!-- Лекция 7. Сортировка событий -->
<article class="article">
  <div class="anchor" id="l7"></div>
  <h2>Лекция 7. Сортировка событий</h2>

  <h4>Содержание сегодняшней лекции</h4>
  <ol>
    <li>Сортировка событий</li>
    <li>События на круге</li>
    <li>Два прохода</li>
  </ol>
</article>


<!-- Сортировка событий -->
<article class="article">
  <div class="anchor" id="l7-1"></div>
  <h2>Сортировка событий</h2>

  <p>Что такое сортировка событий</p>
  <ul>
    <li>Пусть есть некоторые отрезки во времени (например, отрезок когда человек находился на сайте, т.е. известно его время входа и выхода</li>
    <li>Что-то интересное происходит только в те моменты, когда человек приходит или уходит - события</li>
    <li>Надо что-нибудь посчитать</li>
  </ul>
</article>


<!-- Задача 1. Максимальное количество человек было на сайте одновременно -->
<article class="article">
  <div class="anchor" id="l7-task-1"></div>
  <h2>Задача 1. Максимальное количество человек было на сайте одновременно</h2>

  <p>Сайт посетило N человек, для каждого известно время входа на сайт In[i] и время выхода с сайта Out[i]. Считается, что человек был на сайте с момента In[i] по Out[i] включительно.</p>
  <p>Определите, какое максимальное количество человек было на сайте одновременно</p>

  <details>
    <summary>Решение</summary>
    <p>Создадим на каждого человека два события: вход и выход. Каждое событие - пара, в которой первое число - время, а второе - тип события. Событие "вход на сайт" должно происходить раньше "выхода с сайта".</p>
    <p>Сначала будем сортировать события по времени, потом по типу. Когда одновременно случаются два собития, когда один человек пришел и один ушел, то считаем что сначала новый человек пришел, а уже потом старый человек ушел.</p>
    <p>Заводим счетчик. Когда человек пришел, прибавляем к счетчику 1, когда ушел - вычитаем 1.</p>
    <p>Напишем функцию maxVisitors, она получает на вход количество людей и два массива: со временем входа и временем выхода.</p>
<pre>function maxVisitors(n, tin, tout) {
  let events = [];
  for (let i = 0; i &lt; n; i++) {
    events.push([tin[i], -1]);
    events.push([tout[i], 1]);
  }
  events.sort();
  let online = 0;
  let maxOnline = 0;
  for (let ev of events) {
    if (ev[1] === -1) {
      online++;
    } else {
      online--;
    }
    maxOnline = Math.max(online, maxOnline);
  }
  return maxOnline;
}

let w1 = 4;
let w2 = [1,2,3,4];
let w3 = [3,4,5,6];

console.log(maxVisitors(w1,w2,w3));</pre>
  </details>
</article>


<!-- Задача 2. Суммарное время посетителей на сайте -->
<article class="article">
  <div class="anchor" id="l7-task-2"></div>
  <h2>Задача 2. Суммарное время посетителей на сайте</h2>

  <p>Сайт посетило N человек, для каждого известно время входа на сайт In[i] и время выхода с сайта Out[i]. Считается, что человек был на сайте с момента In[i] по Out[i] включительно.</p>
  <p>Определите, какое суммарное время на сайте был хотя бы один человек.</p>

  <details>
    <summary>Решение</summary>
    <p>Если мы пришли в событие с положительным счетчиком количества людей, то между этим и предыдущим событием на сайте кто-то был. Прибавим к ответу время между текущим и предыдущим событием.</p>
<pre>function timeVisitors(n, tin, tout) {
  let events = [];
  for (let i = 0; i &lt; n; i++) {
    events.push([tin[i], -1]);
    events.push([tout[i], 1]);
  }
  events.sort();
  let online = 0;
  let time = 0;
  for (let i = 0; i &lt; events.length; i++) {
    if (online > 0) {
      time += events[i][0] - events[i-1][0];
    }
    if (events[i][1] === -1) {
      online++;
    } else {
      online--;
    }
  }
  return time;
}


let w1 = 4;
let w2 = [1,2,5,6];
let w3 = [3,3,6,7];

console.log(timeVisitors(w1,w2,w3));</pre>
  </details>
</article>


<!-- Задача 3. Какие показания счетчика увидел начальник -->
<article class="article">
  <div class="anchor" id="l7-task-3"></div>
  <h2>Задача 3. Какие показания счетчика увидел начальник</h2>

  <p>Сайт посетило N человек, для каждого извествно время входа на сайт In[i] и время выхода с сайта Out[i]. Считается, что человек был на сайте с момента In[i] по Out[i] включительно. Начальник заходил на сайт M раз в моменты времени Boss[i] и смотрел, сколько людей сейчас онлайн. Поседения сайта начальником упорядочены по возрастанию времени</p>
  <p>Определите, какие показания счетчика людей онлайн увидел начальник.</p>

  <details>
    <summary>Решение</summary>
    <p>Создадим третий тип события - "вход начальника" и при наступлении такого события будем сохранять текущее значение счетчика посетителей.</p>
<pre>function countVisitors(n, tin, tout, m, tboss) {
  let events = [];
  for (let i = 0; i &lt; n; i++) {
    events.push([tin[i], -1]);
    events.push([tout[i], 1]);
  }
  for (let i = 0; i &lt; m; i++) {
    events.push([tboss[i], 0]);
  }
  events.sort();
  let online = 0;
  let count = [];
  for (let i = 0; i &lt; events.length; i++) {
    if (events[i][1] === -1) {
      online++;
    } else if (events[i][1] === 1) {
      online--;
    } else {
      count.push(online);
    }
  }
  return count;
}


let w1 = 4;
let w2 = [1,2,5,6];
let w3 = [3,3,6,7];
let w4 = 3;
let w5 = [2,3,4];

console.log(countVisitors(w1,w2,w3,w4,w5));</pre>
  </details>
</article>


<!-- События на круге -->
<article class="article">
  <div class="anchor" id="l7-2"></div>
  <h2>События на круге</h2>

  <p>Что такое события на круге</p>
  <ul>
    <li>Самый доступный пример - ежедневно происходящие события</li>
    <li>Круг - это сутки</li>
    <li>Идея: разрезать отрезки, проходящие через полночь, на два</li>
  </ul>
</article>


<!-- Задача 4. Когда были заняты все парковочные места -->
<article class="article">
  <div class="anchor" id="l7-task-4"></div>
  <h2>Задача 4. Когда были заняты все парковочные места</h2>

  <p>На парковке в торговом центре N мест (занумерованных от 1 до N). За день в ТЦ приезжало M автомобилей, при этом некоторые из них длинные и занимали несколько подряд идущих парковочных мест. Для каждого автомобиля известно время приезда и отъезда, а также два числа - с какого по какое парковочные места он занимал. Если в какой-то момент времени один автомобиль уехал с парковочного места, то место считается освободившимся и в тот же момент времени на его место может встать другой.</p>
  <p>Необходимо определить, был ли момент, в который были заняты все парковочные места.</p>

  <details>
    <summary>Решение</summary>
    <p>События - приезд и отъезд автомобиля (причем отъезд должен происходить раньше). Будем поддерживать количество занятых мест и если после очередного события счетчик равен N, то такие моменты были.</p>
    <p>На каждую машину будем прибавлять или вычитать количество парковочных мест, которые она заняла. Никогда две машины не стоят на одних и тех же парковочных местах, поэтому мы можем не поддерживать множество занятых парковочных мест. Можно смотреть сколько в сумме занято мест.</p>
    <p>Завести счетчик. Каждый раз когда машина приехала - прибавлять количество мест, которые она заняла. Не важно на какие конкретно места встала машина, мы знаем что они не пересекаются. Если счетчик станет равен N - общему количеству мест, то были моменты когда все места на парковке заняты.</p>
    <p>Машина car описывается временем приезда timein, временем отъезда timeout, с какого места placefrom по какое место placeto она заняла.</p>
<pre>function isFull(cars, n) {
  let events = [];
  for (let car of cars) {
    [timein, timeout, placefrom, placeto] = car;
    events.push([timein, 1, placeto - placefrom + 1]);
    events.push([timeout, -1, placeto - placefrom + 1]);
  }
  events.sort();
  let occuped = 0;
  for (let i = 0; i &lt; events.length; i++) {
    if (events[i][1] === -1) {
      occuped -= events[i][2];
    } else if (events[i][1] === 1) {
      occuped += events[i][2];
    }
    if (occuped === n) {
      return true;
    }
  }
  return false;
}


let w1 = [[1,3,1,2],[2,4,2,3]];
let w2 = 2;

console.log(isFull(w1,w2));</pre>
  </details>
</article>


<!-- Задача 5. Минимальное количество автомобилей, которые заняли все места -->
<article class="article">
  <div class="anchor" id="l7-task-5"></div>
  <h2>Задача 5. Минимальное количество автомобилей, которые заняли все места</h2>

  <p>На парковке в торговом центре N мест (занумерованных от 1 до N). За день в ТЦ приезжало M автомобилей, при этом некоторые из них длинные и занимали несколько подряд идущих парковочных мест. Для каждого автомобиля известно время приезда и отъезда, а также два числа - с какого по какое парковочные места он занимал. Если в какой-то момент времени один автомобиль уехал с парковочного места, то место считается освободившимся и в тот же момент времени на его место может встать другой.</p>
  <p>Необходимо определить, был ли момент, в который были заняты все парковочные места и определить минимальное количество автомобилей которые заняли все места. Если такого момента не было - вернуть M + 1.</p>
  <p>В прошлой задаче мы доходили до первого раза когда занята вся парковка и возвращали true. Возможно несколько моментов когда занята вся парковка, при этом каждый раз количество автомобилей может быть разным.</p>

  <details>
    <summary>Решение</summary>
    <p>Добавим еще один счетчик на количество автомобилей и будем обновлять минимальное количество автомобилей когда заняты все места.</p>
    <p>Теперь у нас будет два счетчика - счетчик количества мест, к которому мы будем добавлять длину машины и счетчик количества машин, к которому мы будем добавлять 1.</p>
<pre>function minCars(cars, n) {
  let events = [];
  for (let car of cars) {
    [timein, timeout, placefrom, placeto] = car;
    events.push([timein, 1, placeto - placefrom + 1]);
    events.push([timeout, -1, placeto - placefrom + 1]);
  }
  events.sort();
  let occuped = 0;
  let nowcars = 0;
  let mincars = cars.length + 1;
  for (let i = 0; i &lt; events.length; i++) {
    if (events[i][1] === -1) {
      occuped -= events[i][2];
      nowcars--;
    } else if (events[i][1] === 1) {
      occuped += events[i][2];
      nowcars++;
    }
    if (occuped === n) {
      mincars = Math.min(mincars, nowcars);
    }
  }
  return mincars;
}


let w1 = [[1,3,1,2],[2,4,2,3]];
let w2 = 2;

console.log(minCars(w1,w2));</pre>
  </details>
</article>


<!-- Задача 6. Номера минимального количества автомобилей, которые заняли все места -->
<article class="article">
  <div class="anchor" id="l7-task-6"></div>
  <h2>Задача 6. Номера минимального количества автомобилей, которые заняли все места</h2>

  <p>На парковке в торговом центре N мест (занумерованных от 1 до N). За день в ТЦ приезжало M автомобилей, при этом некоторые из них длинные и занимали несколько подряд идущих парковочных мест. Для каждого автомобиля известно время приезда и отъезда, а также два числа - с какого по какое парковочные места он занимал. Если в какой-то момент времени один автомобиль уехал с парковочного места, то место считается освободившимся и в тот же момент времени на его место может встать другой.</p>
  <p>Необходимо определить, был ли момент, в который были заняты все парковочные места и определить минимальное количество автомобилей которые заняли все места, а также номера этих автомобилей (в том порядке, как они перечисляются в списке). Если парковка никогда не была занята полностью вернуть пустой список</p>

  <details>
    <summary>Решение (неэффективное). O(N^2)</summary>
    <p>Добавим в событие номер автомобиля в списке. При обновлении минимума просто копируем текущее состояние в ответ</p>
<pre>function carsNumbers(cars, n) {
  let events = [];
  for (let i = 0; i &lt; cars.length; i++) {
    [timein, timeout, placefrom, placeto] = cars[i];
    events.push([timein, 1, placeto - placefrom + 1, i]);
    events.push([timeout, -1, placeto - placefrom + 1, i]);
  }
  events.sort();
  let occuped = 0;
  let nowcars = 0;
  let mincars = cars.length + 1;
  let carnums = {};
  let bestcarnums;
  for (let i = 0; i &lt; events.length; i++) {
    if (events[i][1] === -1) {
      occuped -= events[i][2];
      nowcars--;
      delete carnums[events[i][3]];
    } else if (events[i][1] === 1) {
      occuped += events[i][2];
      nowcars++;
      carnums[events[i][3]] = 1;
    }
    if (occuped === n && nowcars &lt; mincars) {
      mincars = nowcars;
      bestcarnums = carnums;
    }
  }
  return bestcarnums;
}


let w1 = [[1,3,1,2],[2,4,2,3]];
let w2 = 2;

console.log(carsNumbers(w1,w2));</pre>
    <p>Сложность O(N^2)</p>
  </details>

  <details>
    <summary>Решение (эффективное). O(N*logN)</summary>
    <p>За первый проход посчитаем минимальное количество машин. На втором проходе мы идем по всем событиям. Когда парковка занята полностью и число машин равно минимальному, которое мы узнали на первом проходе, мы возвращаем текущее состояние множества. Какие машины сейчас стоят, те мы возвращаем в качестве ответа. Ни одного копирования множества здесь не происходит. Сложность O(N*logN)</p>
<pre>function carsNumbers(cars, n) {
  let events = [];
  for (let i = 0; i &lt; cars.length; i++) {
    [timein, timeout, placefrom, placeto] = cars[i];
    events.push([timein, 1, placeto - placefrom + 1, i]);
    events.push([timeout, -1, placeto - placefrom + 1, i]);
  }
  events.sort();
  let occuped = 0;
  let nowcars = 0;
  let mincars = cars.length + 1;
  // первый проход
  for (let i = 0; i &lt; events.length; i++) {
    if (events[i][1] === -1) {
      occuped -= events[i][2];
      nowcars--;
    } else if (events[i][1] === 1) {
      occuped += events[i][2];
      nowcars++;
    }
    if (occuped === n && nowcars &lt; mincars) {
      // минимальное количество
      mincars = nowcars;
    }
  }
  nowcars = 0;
  let carnums = {};
  // второй проход
  for (let i = 0; i &lt; events.length; i++) {
    if (events[i][1] === -1) {
      occuped -= events[i][2];
      nowcars--;
      delete carnums[events[i][3]];
    } else if (events[i][1] === 1) {
      occuped += events[i][2];
      nowcars++;
      carnums[events[i][3]] = 1;
    }
    if (occuped === n && nowcars === mincars) {
      return Object.keys(carnums);
    }
  }
  return [];
}


let w1 = [[1,3,1,2],[2,4,2,3]];
let w2 = 2;

console.log(carsNumbers(w1,w2));</pre>
  </details>
</article>
