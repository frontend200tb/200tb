<h1>Тренировки по алгоритмам 1.0</h1>


<article class="article">
  <h2>Михаил Густокашин</h2>
  <p>Конспект курса <strong>Тренировки по алгоритмам 1.0</strong> (с 2021.06.02 до 2021.06.30)</p>
  <p><a href="https://yandex.ru/yaintern/algorithm-training_2021" target="_blank">yandex.ru/yaintern/algorithm-training_2021</a></p>

  <h4>Лекция 5. Префиксные суммы и два указателя</h4>
  <p>2021-06-14 Лекция 5 Префиксные суммы и два указателя.mp4</p>
</article>


<!-- Содержание -->
<article class="article">
  <h3>Содержание</h3>

  <br><a href="#l5">Лекция 5. Префиксные суммы и два указателя</a>
  <br><a href="#l5-1">Префиксные суммы</a>
  <br><a href="#l5-task-1">Задача 1. Сколько нулей на полуинтервале</a>
  <br><a href="#l5-task-2">Задача 2. Найти количество отрезков с нулевой суммой</a>
  <br><a href="#l5-2">Два указателя</a>
  <br><a href="#l5-task-3">Задача 3. Сколько пар чисел в разности больше определенного числа</a>
  <br><a href="#l5-task-4">Задача 4. Суммарный профессионализм команды</a>
  <br><a href="#l5-task-5">Задача 5. Два отсортированных массива слить в один</a>
</article>


<!-- Лекция 5. Префиксные суммы и два указателя -->
<article class="article">
  <div class="anchor" id="l5"></div>
  <h2>Лекция 5. Префиксные суммы и два указателя</h2>
</article>


<!-- Префиксные суммы -->
<article class="article">
  <div class="anchor" id="l5-1"></div>
  <h2>Префиксные суммы</h2>

  <p>Этот метод позволяет решать задачи вида - сколько событий произошло за определенный интервал времени.</p>
  <p>Что такое префиксные суммы</p>
  <ul>
    <li>Пусть у нас есть массив nums из N чисел и необходимо отвечать на запросы "Чему равна сумма элементов на полуинтервале [L,R)"</li>
    <li>Подсчитаем массив prefixsum длиной N+1, где prefixsum[k] будет хранить сумму всех чисел из nums с индексами от 0 до k-1</li>
  </ul>
<pre>
Индекс     0  1  2   3   4   5   6
num        5  3  8   1   4   6
prefixsum  0  5  8  16  17  21  27
</pre>

  <p>Построение массива префиксных сумм</p>
  <ul>
    <li>Массив можно построить за O(N):
      <code>prefixsum[i] = prefixsum[i-1] + nums[i-1]</code>
    </li>
    <li>Не забыть про отличие размера!</li>
    <li>Переполнение!</li>
  </ul>

  <p>Ответ на запрос суммы на отрезке</p>
  <code>Ответ за O(1): sum(L,R) = prefixsum[R] - prefixsum[L]</code>
  <code>Найдем sum(2,5) = prefixsum[5] - prefixsum[2] = 21 - 8 = 13</code>

  <h4>Реализация RSQ (Range Sum Query - запрос суммы на отрезке) через префиксные суммы</h4>
<pre>function makePrefixSum(nums) {
  let p = [0];
  for (let i = 1; i &lt; nums.length; i++) {
    p[i] = p[i-1] + nums[i-1];
  }
  return p;
}

function rsq(l, r) {
  return prefixSum[r] - prefixSum[l];
}</pre>

  <p>Тест</p>
  <code>let w1 = [2,4,5,2,6,9,2];</code>
  <code>let prefixSum = makePrefixSum(w1);</code>
  <code>console.log(rsq(1, 3)); // 9</code>
</article>


<!-- Задача 1. Сколько нулей на полуинтервале -->
<article class="article">
  <div class="anchor" id="l5-task-1"></div>
  <h2>Задача 1. Сколько нулей на полуинтервале</h2>

  <p>Дана последовательность чисел длиной N и M запросов</p>
  <p>Запросы: "Сколько нулей на полуинтервале [L,R)"</p>

  <details>
    <summary>Решение за O(NM)</summary>
    <p>Для каждого запроса перебираем все числа от L до R (не включительно) и считаем количество нулей. В худшем случае каждый запрос за O(N)</p>
<pre>function countZero(nums, l, r) {
  let count = 0;
  for (let i = l; i &lt; r; i++) {
    if (nums[i] === 0) {
      count++;
    }
  }
  return count;
}</pre>

    <p>Тест</p>
    <code>let w1 = [1,1,0,0,0,1,2];</code>
    <code>console.log(countZero(w1, 2, 5)); // 3</code>
  </details>

  <details>
    <summary>Решение за O(N+M)</summary>
    <p>Применим идею префиксных сумм для быстрого ответа на запрос. Для каждого префикса посчитаем количество нулей на нем (prefixzeroes). Тогда ответ на запрос на полуинтервале [L,R):</p>
    <code>prefixzeroes[R] - prefixzeroes[L]</code>
<pre>
nums         1 0 1 1 0 0 1
prefixzeroes 0 0 1 1 1 2 3 3</pre>

<pre>function makePrefixZeroes(nums) {
  let p = [0];
  for (let i = 1; i &lt; nums.length; i++) {
    if (nums[i-1] === 0) {
      p[i] = p[i-1] + 1;
    } else {
      p[i] = p[i-1];
    }
  }
  return p;
}

function countZero(l,r) {
  return prefixzeroes[r] - prefixzeroes[l];
}

let w1 = [1,1,0,0,0,1,2];
let prefixzeroes = makePrefixZeroes(w1);

console.log(countZero(1, 6));</pre>
  </details>
</article>


<!-- Задача 2. Найти количество отрезков с нулевой суммой -->
<article class="article">
  <div class="anchor" id="l5-task-2"></div>
  <h2>Задача 2. Найти количество отрезков с нулевой суммой</h2>

  <p>Дана последовательность чисел длиной N</p>
  <p>Необходимо найти количество отрезков с нулевой суммой</p>
  <p>Примечание: если элемент равен 0, то этот элемент тоже отрезок с нулевой суммой</p>

  <details>
    <summary>Решение за O(N^3)</summary>
    <p>Переберем начало и конец отрезка и просто просуммируем все его элементы</p>
<pre>
указатели         L         R
индексы    0  1   2  3   4  5   6  7
массив    [4, 3, -1, 0, -3, 5, -2, 0]
</pre>
    <p>Переберем все отрезки. Для этого левый указатель пройдется по всему массиву от 0 до N. Сложность O(N). Правый указатель пройдется по всему массиву от L до N. Сложность O(N). Просуммируем элементы каждого отрезка. Сложность O(N). Итого сложность алгоритма O(N^3).</p>
<pre>function countRange(nums) {
  let result = 0;
  for (let i = 0; i &lt; nums.length; i++) {
    for (let j = i; j &lt; nums.length; j++) {
      rangeSum = 0;
      for (let k = i; k &lt; j + 1; k ++) {
        rangeSum += nums[k];
      }
      if (rangeSum === 0) {
        result++;
      }
    }
  }
  return result;
}


let w1 = [4, 3, -3, 0];
let w2 = [4, 3, -3, 0, -4, 5, -2, -3];

console.log(countRange(w1)); // 2
console.log(countRange(w2)); // 5</pre>
  </details>

  <details>
    <summary>Решение за O(N^2)</summary>
    <p>Переберем начало и будем двигать конец, суммируя элементы</p>
<pre>function countRange(nums) {
  let result = 0;
  for (let i = 0; i &lt; nums.length; i++) {
    rangeSum = 0;
    for (let j = i; j &lt; nums.length; j++) {
      rangeSum += nums[j];
      if (rangeSum === 0) {
        result++;
      }
    }
  }
  return result;
}


let w1 = [4, 3, -3, 0];
let w2 = [4, 3, -3, 0, -4, 5, -2, -3];

console.log(countRange(w1)); // 3
console.log(countRange(w2)); // 6</pre>
  </details>

  <details>
    <summary>Решение за O(N)</summary>
    <p>Насчитаем префиксные суммы. Одинаковые префиксные суммы означают, что сумма на отрезке с началом и концом в позициях, на которых достигаются одинаковые префиксные суммы, будет равна нулю</p>
<pre>function countPrefixSums(nums) {
  let dict = {0: 1};
  let nowsum = 0;
  for (let i = 0; i &lt; nums.length; i++) {
    nowsum += nums[i];
    if (!dict[nowsum]) {
      dict[nowsum] = 0;
    }
    dict[nowsum]++;
  }
  console.log(dict)
  return dict;
}

function countRange(p) {
  let count = 0;
  for (let key in p) {
    let sum = p[key];
    count += sum*(sum-1)/2;
  }
  return count;
}


let w1 = [4, 3, -3, 0];
let w2 = [4, 3, -3, 0, -4, 5, -2, -3];

let p = countPrefixSums(w1);

console.log(countRange(p)); // 3</pre>
  </details>
</article>


<!-- Два указателя -->
<article class="article">
  <div class="anchor" id="l5-2"></div>
  <h2>Два указателя</h2>
</article>


<!-- Задача 3. Сколько пар чисел в разности больше определенного числа -->
<article class="article">
  <div class="anchor" id="l5-task-3"></div>
  <h2>Задача 3. Сколько пар чисел в разности больше определенного числа</h2>

  <p>Дана отсортированная последовательность чисел длиной N и число K</p>
  <p>Необходимо найти количество пар чисел A, B, таких что B - A > K</p>
  <p>Пример</p>
  <code>Вход [1,3,7,8], 4</code>
  <code>Выход 3</code>

  <details>
    <summary>Решение за O(N^2)</summary>
    <p>Переберем все пары чисел и для каждой проверим условие</p>
<pre>function countPairs(nums, k) {
  let result = 0;
  for (let i = 0; i &lt; nums.length; i++) {
    for (let j = i; j &lt; nums.length; j++) {
      if (nums[j] - nums[i] > k) {
        result++;
      }
    }
  }
  return result;
}

let w1 = [1,3,7,8];

console.log(countPairs(w1, 4)); // 3</pre>
  </details>

  <details>
    <summary>Решение за O(N)</summary>
    <p>Возьмем наименьшее число и найдем для него первое подходящее большее. Все еще большие числа точно подходят. Возьмем в качестве меньшего числа следующее, а указатель первого подходящего будем двигать начиная с той позиции, где он находится сейчас</p>
  </details>
</article>


<!-- Задача 4. Суммарный профессионализм команды -->
<article class="article">
  <div class="anchor" id="l5-task-4"></div>
  <h2>Задача 4. Суммарный профессионализм команды</h2>

  <p>Игрок в футбол обладает одной числовой характеристикой - профессионализмом. Команда называется сплоченной, если профессионализм любого игрока не превосходит суммарный профессионализм любых двух игроков из команды. Команда может состоять из любого количества игроков. Дана отсортированная последоваельность чисел длиной N - профессионализм игроков.</p>
  <p>Найти максимальный суммарный профессионализм сплоченной команды</p>

  <details>
    <summary>Решение</summary>
    <p>Решение методом двух указателей.</p>
    <p>Правый указатель на самого сильного игрока сначала будет равен 0. Девым указателем будем идти от нуля до правого и проверять что правый указатель не вышел за диапазон последовательности и левый и правый указатель стали равны или сумма двух самых слабых игроков больше или равна самому сильному игроку. Увеличим правый указатель на 1 и повторим.</p>
<pre>function bestSum(nums) {
  let result = 0;
  let nowsum = 0;
  let right = 0;
  for (let left = 0; left &lt; nums.length - 1; left++) {
    while ((right &lt; nums.length) && (right === left || nums[left] + nums[left+1] &gt;= nums[right])) {
      nowsum += nums[right];
      right++;
    }
    result = Math.max(result, nowsum);
    nowsum -= nums[left];
  }
  return result;
}

let w1 = [1,3,5,7,8];

console.log(bestSum(w1)); // 23</pre>
  </details>
</article>


<!-- Задача 5. Два отсортированных массива слить в один -->
<article class="article">
  <div class="anchor" id="l5-task-5"></div>
  <h2>Задача 5. Два отсортированных массива слить в один</h2>

  <p>Даны две отсортированные последовательности чисел длиной N и M соответственно</p>
  <p>Необходимо слить их в одну отсортированную последовательность</p>

  <details>
    <summary>Решение</summary>
    <p>Поставим два указателя на начало каждой из последовательностей. Выберем тот, который указывает на меньшее число, запишем это число в результат и сдвинем указатель</p>
<pre>function mergeNums(nums1, nums2) {
  let result = [];
  let p1 = 0;
  let p2 = 0;
  while (result.length &lt; nums1.length + nums2.length) {
    if (nums1[p1] &lt; nums2[p2]) {
      result.push(nums1[p1]);
      p1++;
      if (p1 === nums1.length) {
        result = result.concat(nums2.slice(p2))
        break;
      }
    } else {
      result.push(nums2[p2]);
      p2++;
      if (p2 === nums2.length) {
        result = result.concat(nums1.slice(p1))
        break;
      }
    }
  }
  return result;
}

let w1 = [1,3,5,7,8,10];
let w2 = [2,2,4];

console.log(mergeNums(w1,w2));</pre>
  </details>
</article>
