<h1>Тренировки по алгоритмам 1.0</h1>


<article class="article">
  <h2>Михаил Густокашин</h2>
  <p>Конспект курса <strong>Тренировки по алгоритмам 1.0</strong> (с 2021.06.02 до 2021.06.30)</p>

  <h4>Лекция 8. Деревья</h4>
  <p><a href="https://yandex.ru/yaintern/algorithm-training_2021" target="_blank">yandex.ru/yaintern/algorithm-training_2021</a></p>
  <p><a href="https://contest.yandex.ru/contest/28069/problems/" target="_blank">contest.yandex.ru/contest/28069/problems</a></p>
  <p>2021-06-23 Лекция 8 Деревья.mp4</p>
</article>


<!-- Содержание -->
<article class="article">
  <h3>Содержание</h3>

  <br><a href="#l8">Лекция 8. Деревья</a>
  <br><a href="#l8-1">Собственный менеджер памяти</a>
  <br><a href="#l8-2">Бинарное дерево поиска</a>
  <br><a href="#l8-3">Обход деревьев</a>
  <br><a href="#l56">Разбор ДЗ по лекции 5 и 6</a>
  <br><a href="#l5-1">Занятие 5. Счет в гипершашках</a>
  <br><a href="#l5-2">Занятие 5. Робот</a>
  <br><a href="#l5-3">Занятие 5. Треугольники</a>
  <br><a href="#l6-1">Занятие 6. Субботник</a>
  <br><a href="#l6-2">Занятие 6. Медиана объединения</a>
  <br><a href="#l78">Разбор ДЗ по лекции 7 и 8</a>
  <br><a href="#l7-1">Занятие 7. Реклама</a>
  <br><a href="#l7-2">Занятие 7. Охрана</a>
  <br><a href="#l7-3">Занятие 7. Автобусы</a>
  <br><a href="#l7-4">Занятие 7. НГУ-стройка</a>
</article>


<!-- Лекция 8. Деревья -->
<article class="article">
  <div class="anchor" id="l8"></div>
  <h2>Лекция 8. Деревья</h2>

  <h4>Содержание сегодняшней лекции</h4>
  <ol>
    <li>Собственный менеджер памяти</li>
    <li>Бинарное дерево поиска</li>
    <li>Обход деревьев</li>
  </ol>
</article>


<!-- Собственный менеджер памяти -->
<article class="article">
  <div class="anchor" id="l8-1"></div>
  <h2>Собственный менеджер памяти</h2>

  <p>Менеджмент памяти</p>
  <ul>
    <li>У нас есть заранее неизвестное количество структур с двумя ссылками на другие структуры</li>
    <li>Мы знаем заранее, какое максимальное количество структур может существовать одновременно</li>
    <li>Хотим научиться выделять и освобождать память</li>
  </ul>

  <details>
    <summary>Код менеджера памяти</summary>
<pre>function initMemory(maxN) {
  memory = [];
  for (let i = 0; i &lt; maxN.length; i++) {
    memory.push([0, i + 1, 0])
  }
  return [memory, 0];
}

function newNode(memstruct) {
  [memory, firstFree] = memstruct;
  memstruct[1] = memory[firstfree][1];
  return firstfree;
}

function delNode(memstruct, index) {
  [memory, firstFree] = memstruct;
  memory[index][1] = firstFree;
  memstruct[1] = index;
}</pre>
  </details>
</article>


<!-- Бинарное дерево поиска -->
<article class="article">
  <div class="anchor" id="l8-2"></div>
  <h2>Бинарное дерево поиска</h2>

  <p>Что такое бинарное дерево поиска</p>
  <ul>
    <li>У каждого узла ключ и два сынка - левый и правый</li>
    <li>В левом поддереве ключи меньше, а в правом - больше</li>
    <li>Если ключи поступают в случайном порядке, и равномерно распределяются в правой и левой части дерева, то глубина дерева будет O(logN)</li>
    <li>В худшем случае, если приходит возрастающая последовательность, которая добавляется только в правые ветки, глубина дерева будет O(N)</li>
  </ul>

  <p>Из одних и тех же элементов можно составить разные деревья. Зависит от того в каком порядке их добавляем. Обычно корнем дерева становится элемент, который добавляют первым. Любое поддерево можно обрабатывать как дерево, используя рекурсию.</p>

  <h4>Поиск в дереве элемента с ключом 4</h4>
  <p>Сначала смотрим на корень дерева. Сравниваем его с числом, которое нужно найти. Если оно совпало, то это будет ответ. Если 4 меньше чем корень, то переходим в левого потомка и дальше ищем там. Если больше, то переходим в правого потомка.</p>

  <h4>Добавление элемента с ключом 9</h4>
  <p>Добавление элемента очень похоже на поиск. Сначала посмотрим есть ли такой элемент в дереве. Начнем опять с корня. Видим, что 9 больше чем корень и идем вправо. Сравниваем и видим что 9 меньше правого сына. Идем в лево. А там пусто. Добавим сюда 9.</p>

  <h4>Удаление элемента с ключом 4</h4>
  <p>Удаление из дерева это одна из самых сложных операций практически в любой структуре. Сначала найдем элемент с ключом 4.</p>
  <p>Если это лист, то есть у него нет своих потомков,то в его родителе удалим ссылку на него.</p>
  <p>Если у удаляемого элемента есть только один потомок,то у его родителя меняем указатель с элемента 4 на его единственного сына.</p>
  <p>Если у удаляемого элемента 2 ребенка, то есть несколько способов. Рассмотрим один из них. Заменим элемент 4 на первое число, которое больше его. Для этого идем в правое поддерево и ищем в нем самый левый элемент. Там найдем из всех больших чисел самое маленькое число. Если это лист, то есть у него нет потомком, то поставим его на место удаляемого элемента. Если у него один правый сын, то самое маленькое число ставим на мето удаляемого, а правого сына на его место.</p>
  <p>Второй способ это найти самое большое число из левого поддерева и поставить его на место удаляемого элемента</p>

  <details>
    <summary>Реализация поиска</summary>
<pre>function find(memstruct, root, x) {
  let key = memstruct[0][root][0];
  if (x === key) {
    return root;
  } else if (x &lt; key) {
    let left = memstruct[0][root][1];
    // нет такого узла
    if (left === -1) {
      return -1;
    } else {
      // рекурсивно ищем в левом поддереве
      return find(memstruct, left, x);
    }
  } else if (x &gt; key) {
    let right = memstruct[0][root][2];
    // нет такого узла
    if (right === -1) {
      return -1;
    } else {
      // рекурсивно ищем в правом поддереве
      return find(memstruct, right, x);
    }
  }
}</pre>
  </details>

  <details>
    <summary>Реализация добавления</summary>
    <p>Сначала ищем этот узел. Если его нет, то ставим туда новый элемент.</p>
<pre>function createNode(memstruct, key) {
  let index = newnode(memstruct);
  memstruct[0][index][0] = key;
  memstruct[0][index][1] = -1;
  memstruct[0][index][2] = -1;
  return index;
}

function add(memstruct, root, x) {
  let key = memstruct[0][root][0];
  if (x &lt; key) {
    let left = memstruct[0][root][1];
    // если нет такого узла
    if (left === -1) {
      // создаем здесь новый узел
      memstruct[0][root][1] = createNode(memstruct, x);
    } else {
      // если есть такой узел
      // рекурсивно ищем в левом поддереве
      return add(memstruct, left, x);
    }
  } else if (x &gt; key) {
    let right = memstruct[0][root][2];
    // если нет такого узла
    if (right === -1) {
      // создаем здесь новый узел
      memstruct[0][root][2] = createNode(memstruct, x);
    } else {
      // если есть такой узел
      // рекурсивно ищем в правом поддереве
      return add(memstruct, right, x);
    }
  }
}</pre>
  </details>

  <h4>Представление дерева в программе</h4>
  <p>Можно взять массив из трех элементов. Первый элемент key это корень дерева. Второй элемент left это массив из трех элементов, представляющий левое поддерево. Третий элемент right это массив из трех элементов, представляющий правое поддерево.</p>
  <code>[key, left, right]</code>
  <code>[5, [2, null, [3, null, null], [7, null, [8, null, null]]]</code>
</article>


<!-- Обход деревьев -->
<article class="article">
  <div class="anchor" id="l8-3"></div>
  <h2>Обход деревьев</h2>

  <p>Поиск элемента в хэш-таблице был за O(1), а в дереве в лучшем случае за O(logN), в худшем - O(N). Но в дереве элементы упорядочены, а в множестве - нет. Поэтому мы можем получить отсортированную последовательность всех узлов дерева. Для этого надо сделать рекурсивный обход дерева. Сначала идем влево до крайнего элемента, потом печатаем себя, потом заходим вправо и все повторяется.</p>
  <p>Если при добавлении элементов с дерево, одно поддерево становится значительно больше другого, то можно применить балансировку. То есть перестроить дерево выбрав в качестве корня другой элемент.</p>

  <h4>Не бинарные деревья</h4>
  <ul>
    <li>У узлов дерева может быть и больше двух сыновей, тогда их нужно хранить списком</li>
    <li>Примеры: дерево каталогов и файлов, DOM-дерево, дерево классов в программе</li>
    <li>Обходим так же как бинарное, просто запуская рекурсивную функцию для всех детей</li>
  </ul>

  <h4>Сериализация дерева Хаффмана</h4>
  <ul>
    <li>Алгоритм Хаффмана позволяет сопоставить более часто встречающимся символам более короткий код</li>
    <li>Каждый раз берем два самых редко встречающихся символа и объединяем их в один узел</li>
    <li>Строим бинарное дерево, кладем буквы в листья. Переход в левого сына кодируется числом 0, в правого 1, а код символа - это все ребра на пути от корня до листа</li>
    <li>В примере буква "а" встречается 4 раза, буква "б" - 3 раза, а "в" и "г" по одному разу</li>
  </ul>
</article>
