<h1>Тренировки по алгоритмам 2.0</h1>


<article class="article">
  <h2>Михаил Густокашин</h2>
  <p>Конспект курса <strong>Тренировки по алгоритмам 2.0</strong> (с 2021.08.31 до 2021.10.01)</p>
  <p><a href="https://yandex.ru/yaintern/algorithm-training_2021" target="_blank">yandex.ru/yaintern/algorithm-training_2021</a></p>

  <h4>Домашнее задание по лекции 8 дивизион A</h4>
  <p><a href="https://contest.yandex.ru/contest/29405/problems/" target="_blank">contest.yandex.ru/contest/29405/problems</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h3>Содержание</h3>

      <a href="#t0">0. ФИО</a>
  <br><a href="#t1">A. Города-1</a>
  <br><a href="#t2">B. Города-2</a>
  <br><a href="#t3">C. Свинки-копилки</a>
  <br><a href="#t4">D. Бюрократия</a>
  <br><a href="#t5">E. Логическое дерево</a>
</article>


<!-- 0. ФИО -->
<article class="article">
  <div class="anchor" id="t0"></div>
  <h3>0. ФИО</h3>

  <p>Введите свою фамилию, имя и отчество (просто текст).</p>
</article>


<!-- A. Города-1 -->
<article class="article">
  <div class="anchor" id="t1"></div>
  <h3>A. Города-1</h3>

  <div class="time-memory">(Время 1с. Память 256мб)</div>

  <p>Дорожная сеть в Байтландии обладает следующими свойствами:</p>
  <ul>
    <li>Неориентированность: На всех дорогах движение является двусторонним.</li>
    <li>Связность: Из любого города Байтландии можно проехать в любой другой по сети дорог.</li>
    <li>Отсутствие циклов: Между любыми двумя городами Байтландии существует ровно один путь.</li>
  </ul>

  <p>Назовём удалённостью города максимум из расстояний от него до других городов. Требуется найти все города с минимальной удалённостью.</p>

  <h4>Формат ввода</h4>
  <p>Первая строка входа содержит целое число N — количество городов (1 ≤ N ≤ 10<sup>5</sup>). Каждая из последующих N-1 строк содержит по два целых числа — номера городов, соединённых очередной дорогой. Города занумерованы последовательными целыми числами от 1 до N.</p>

  <h4>Формат вывода</h4>
  <p>Выведите в одной строке через пробел минимальную удалённость, количество городов, для которых она достигается, а также список этих городов, отсортированный по возрастанию номеров.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
2
1 2
</pre>
    <code>1 2 1 2</code>
  </details>
</article>


<!-- B. Города-2 -->
<article class="article">
  <div class="anchor" id="t2"></div>
  <h3>B. Города-2</h3>

  <div class="time-memory">(Время 2с. Память 256мб)</div>

  <p>Дорожная сеть в Байтландии обладает следующими свойствами:</p>
  <ul>
    <li>Неориентированность: На всех дорогах движение является двусторонним.</li>
    <li>Связность: Из любого города Байтландии можно проехать в любой другой по сети дорог.</li>
    <li>Отсутствие циклов: Между любыми двумя городами Байтландии существует ровно один путь.</li>
  </ul>

  <p>Назовём суммарной удалённостью города сумму расстояний от него до других городов. Требуется найти все города с минимальной суммарной удалённостью.</p>

  <h4>Формат ввода</h4>
  <p>Первая строка входа содержит целое число N — количество городов (1 ≤ N ≤ 10<sup>5</sup>). Каждая из последующих N-1 строк содержит по два целых числа — номера городов, соединённых очередной дорогой. Города занумерованы последовательными целыми числами от 1 до N.</p>

  <h4>Формат вывода</h4>
  <p>Выведите в одной строке через пробел минимальную суммарную удалённость, количество городов, для которых она достигается, а также список этих городов, отсортированный по возрастанию номеров.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
2
1 2
</pre>
    <code>1 2 1 2</code>
  </details>
</article>


<!-- C. Свинки-копилки -->
<article class="article">
  <div class="anchor" id="t3"></div>
  <h3>C. Свинки-копилки</h3>

  <div class="time-memory">(Время 1с. Память 64мб)</div>

  <p>У Васи есть N свинок-копилок, свинки занумерованы числами от 1 до N. Каждая копилка может быть открыта единственным соответствующим ей ключом или разбита.</p>

  <p>Вася положил ключи в некоторые из копилок (он помнит, какой ключ лежит в какой из копилок). Теперь Вася собрался купить машину, а для этого ему нужно достать деньги из всех копилок. При этом он хочет разбить как можно меньшее количество копилок (ведь ему ещё нужно копить деньги на квартиру, дачу, вертолет…). Помогите Васе определить, какое минимальное количество копилок нужно разбить.</p>

  <h4>Формат ввода</h4>
  <p>В первой строке содержится число N — количество свинок-копилок (1 ≤ N ≤ 100000). Далее идет N строк с описанием того, где лежит ключ от какой копилки: в i-ой из этих строк записан номер копилки, в которой находится ключ от i-ой копилки.</p>

  <h4>Формат вывода</h4>
  <p>Выведите единственное число: минимальное количество копилок, которые необходимо разбить.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
4
2
1
2
4
</pre>
    <code>2</code>
    <p>Ключи от первой и третьей копилки лежат в копилке 2, ключ от второй — в первой, а от четвертой — в ней самой.</p>

    <p>Чтобы открыть все копилки, достаточно разбить, например, копилки с номерами 1 и 4</p>
  </details>
</article>


<!-- D. Бюрократия -->
<article class="article">
  <div class="anchor" id="t4"></div>
  <h3>D. Бюрократия</h3>

  <div class="time-memory">(Время 3с. Память 256мб)</div>

  <p>Мирко стал генеральным директором крупной корпорации. В компании работает N человек, пронумерованных от 1 до N , Мирко имеет номер 1 . У всех кроме Мирко есть начальник. Начальник может иметь несколько подчинённых, но не более одного непосредственного начальника.</p>

  <p>Когда Мирко получает задание от инвесторов, он передаёт его своему подчинённому с наименьшим номером. Этот подчинённый также передаёт его своему подчинённому с наименьшим номером, и так далее, пока задание не перейдёт несчастливому работнику без подчинённых, который должен сделать задание.</p>

  <p>Этот работник получает 1 монету, его начальник получает 2 монеты, начальник этого начальника получает 3 и так далее. Потом тот, кто на самом деле сделал работу, осознаёт, насколько эта капиталистическая система несправедлива и увольняется с работы.</p>

  <p>Мирко получает задания до тех пор, пока в корпорации не останется всего один сотрудник — сам Мирко. Тогда он выполняет это задание, получает 1 монету и уходит из корпорации. Ему стало интересно, сколько всего монет получил каждый бывший сотрудник. Помогите ему с этим.</p>

  <h4>Формат ввода</h4>
  <p>Первая строка содержит одно натуральное число N (1 ≤ N ≤ 2·10<sup>5</sup>) — число сотрудников компании. Следующая строка содержит N -1 чисел a2, a3, ... an (1 ≤ ai &lt; i), где ai — номер начальника i-го сотрудника.</p>

  <h4>Формат вывода</h4>
  <p>Выведите N чисел, i-е число должно означать, сколько монет получил i-й сотрудник</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
3
1 1
</pre>
    <code>5 1 1</code>

    <h4>Пример 2</h4>
<pre>
5
1 2 2 4
</pre>
    <code>13 8 1 3 1</code>
  </details>
</article>


<!-- E. Логическое дерево -->
<article class="article">
  <div class="anchor" id="t5"></div>
  <h3>E. Логическое дерево</h3>

  <div class="time-memory">(Время 2с. Память 256мб)</div>

  <p>Рассмотрим разновидность двоичного дерева, которую мы назовем логическим деревом. В этом дереве каждый уровень полностью заполнен, за исключением, возможно, последнего (самого глубокого) уровня. При этом все вершины последнего уровня находятся максимально слева. Дополнительно, каждая вершина дерева имеет ноль или двоих детей.</p>

  <p>Каждая вершина дерева имеет связанное с ней логическое значение (1 или 0). Кроме этого, каждая внутренняя вершина имеет связанную с ней логическую операцию (И или ИЛИ). Значение вершины с операцией И — это логическое И значений её детей. Аналогично, значение вершины с операцией ИЛИ — это логическое ИЛИ значений её детей. Значения всех листьев задаются во входном файле, поэтому значения всех вершин дерева могут быть найдены.</p>

  <p>Наибольший интерес для нас представляет корень дерева. Мы хотим, чтобы он имел заданное логическое значение v, которое может отличаться от текущего. К счастью, мы можем изменять логические операции некоторых внутренних вершин (заменить И на ИЛИ и наоборот).</p>

  <p>Дано описание логического дерева и набор вершин, операции в которых могут быть изменены. Найдите наименьшее количество вершин, которые следует изменить, чтобы корень дерева принял заданное значение v. Если это невозможно, то выведите строку “IMPOSSIBLE” (без кавычек).</p>

  <h4>Формат ввода</h4>
  <p>В первой строке входного файла находятся два числа n и v (1 ⩽ n ⩽ 10000, 0 ⩽ v ⩽ 1) — количество вершин в дереве и требуемое значение в корне соответственно. Поскольку все вершины имеют ноль или двоих детей, то n нечётно. Следующие n строк описывают вершины дерева. Вершины нумеруются от 1 до n.</p>

  <p>Первые (n-1) / 2 строк описывают внутренние вершины. Каждая из них содержит два числа — g и c, которые принимают значение либо 0, либо 1. Если g = 1, то вершина представляет логическую операцию И, иначе она представляет логическую операцию ИЛИ. Если c = 1, то операция в вершине может быть изменена, иначе нет. Внутренняя вершина с номером i имеет детей 2i и 2i + 1.</p>

  <p>Следующие (n + 1) / 2 строк описывают листья. Каждая строка содержит одно число 0 или 1 — значение листа.</p>

  <h4>Формат вывода</h4>
  <p>В выходной файл выведите ответ на задачу.</p>
</article>
