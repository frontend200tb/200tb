<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p>ЯрГУ. Кружок. Студенты 2023/2024</p>
  <p><a href="https://vkvideo.ru/@yaracm" target="_blank">vkvideo.ru/@yaracm</a></p>
  <p>Автор кружка Игорь Маслеников</p>
</article>


<article class="article">
  <h1>Занятие 9. Базовые алгоритмы 3. Бинарный поиск на массиве</h1>
  <p>Конспект видео</p>
  <p><a href="https://codeforces.com/group/w0J26SHHez/contest/349062" target="_blank">Codeforces Контест 349062</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
    <a href="#p1">Базовые алгоритмы 3. Бинарный поиск на массиве</a>
  </p>
  <p>
        <a href="#task1">Задача A. Сложность двоичного поиска</a>
    <br><a href="#task2">Задача B. Сурен в поисках числа</a>
    <br><a href="#task3">Задача C. Таинство суммы</a>
    <br><a href="#task4">Задача D. Поиск в массиве</a>
    <br><a href="#task5">Задача E. Собственные числа Psych Up</a>
    <br><a href="#task6">Задача F. Количество вхождений</a>
    <br><a href="#task7">Задача G. Экзамен по истории</a>
    <br><a href="#task8">Задача H. Функция Хевисайда</a>
    <br><a href="#task9">Задача I. Модифицированный НОД</a>
    <br><a href="#task10">Задача J. Коровам - колокольчиков</a>
    <br><a href="#task11">Задача K. Про таблицу умножения</a>
    <br><a href="#task12">Задача L. Неквадратное уравнение</a>
    <br><a href="#task13">Задача M. Очередная задача на массиве</a>
    <br><a href="#task14">Задача N. Запросы на поедание конфет</a>
  </p>
</article>


<!-- Базовые алгоритмы 3. Бинарный поиск на массиве -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Базовые алгоритмы 3. Бинарный поиск на массиве</h3>

</article>


<!-- Задача A. Сложность двоичного поиска -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Сложность двоичного поиска</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вася загадал число от 1 до N. За какое наименьшее количество вопросов (на которые Вася отвечает "да" или "нет") Петя может угадать Васино число?</p>

  <h4>Входные данные</h4>
  <p>Вводится одно число N</p>

  <h4>Выходные данные</h4>
  <p>Выведите наименьшее количество вопросов, которого гарантированно хватит Пете, чтобы угадать Васино число.</p>

  <h4>Пример</h4>
  <code>5</code>
  <code>3</code>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;

  // решение
  int k = 1;
  int res = 0;
  while (n > k) {
    k *= 2;
    res++;
  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача B. Сурен в поисках числа -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Сурен в поисках числа</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Однажды к Сурену прибежала Анжелика и показала ему много чисел. К ним подошел Денис и начал спрашивать: есть ли среди показанных заданное число?</p>

  <p>Помогите Сурену ответить на вопросы Дениса.</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержатся 2 числa – количество чисел у Анжелики (1 ≤ N ≤ 10<sup>6</sup>) и количество вопросов Дениса (1 ≤ Q ≤ 10<sup>5</sup>).</p>

  <p>Во второй строке содержится массив чисел Анжелики, каждое число которого по модулю не превосходит 10<sup>9</sup>.</p>

  <p>Далее следуют Q строк в каждой из которых содержится число a<sub>i</sub> (|a<sub>i</sub>| ≤ 10<sup>9</sup>) – число которое называет Денис.</p>

  <h4>Выходные данные</h4>
  <p>На каждый запрос в отдельной необходимо вывести «YES», если загаданное Денисом число есть, и «NO» в противном случае.</p>

  <h4>Пример</h4>
<pre>
2 5
6 5
2
1
7
9
7
</pre>
<pre>
NO
NO
NO
NO
NO
</pre>

  <details>
    <summary>Решение</summary>
    <h4>Пример 2</h4>
<pre>
2 5
6 5
6
5
1
2
3
</pre>
<pre>
YES
YES
NO
NO
NO
</pre>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ускорение ввода и вывода
  ios::sync_with_stdio(0);
  cin.tie(0);
  cout.tie(0);

  // ввод данных
  int n, q;
  cin >> n >> q;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }
  vector&lt;int&gt; B(q);
  for (int i = 0; i &lt; q; i++) {
    cin >> B[i];
  }

  // решение
  sort(A.begin(), A.end());

  // обработка запросов
  for (int i = 0; i &lt; q; i++) {
    int qu = B[i];

    // бинарный поиск
    int left = 0;
    int right = n;
    int med = (left + right) / 2;
    while (right - left > 1) {
      if (qu &lt; A[med]) {
        right = med;
      } else {
        left = med;
      }
      med = (left + right) / 2;
    }

    // вывод результата
    if (A[left] == qu) {
      cout &lt;&lt; "YES" &lt;&lt; '\n';
    } else {
      cout &lt;&lt; "NO" &lt;&lt; '\n';
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача C. Таинство суммы -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Таинство суммы</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 64мб</i></div>

  <p>— Брат мой, Магистр Ордена хочет узнать завтра о результатах наших многолетних изысканий. Он хочет видеть, ни много, ни мало, Суммирующую Машину! Даже более того: он хочет, чтобы наша Машина — всего лишь машина — продемонстрировала свое постижение Таинства Суммы настолько глубоко, насколько это возможно. Он хочет, чтобы Машина нашла каких-нибудь два числа, дающих в сумме священное число 10000 ! — Тс-с-с! Но это же безумство, граничащее с кощунством! Как Машина может ВЫЧИСЛИТЬ священное число? Двадцать семь лет мы работаем над ней, и смогли только лишь научить ее отвечать на вопрос: «Больше сумма двух введенных чисел, чем 10000, или меньше?». Но разве может смертный найти два таких числа, чтобы их сумма оказалась равна 10000 ?</p>

 <p>— И все же нам придется сделать это с помощью нашей Машины, пусть она и неспособна на это. Иначе у нас будут… ну, скажем так, крупные неприятности, если кипящее масло можно назвать таким словом. Впрочем, у меня есть идея. Помнишь, на той неделе мы ввели в Машину числа -7 и 13, она ответила, что их Сумма меньше 10000. Я не знаю, как это проверить, но нам ничего не остается, как доверять созданию наших рук. Что, если теперь мы возьмем число большее, чем -7 и снова запустим Машину? И будем так делать снова и снова, пока не найдем такое число, которое в сумме с 13 даст 10000 ! Надо только подготовить список возрастающих чисел.</p>

  <p>— Не верю я в эту идею… Давай лучше начнем с суммы, заведомо большей, чем Священное число и будем уменьшать одно из слагаемых, так у нас больше шансов избегнуть кипяще… крупных неприятностей. Так ни о чём и не договорившись, Братья разошлись по своим кельям. К следующему дню, каждый из них подготовил такой список чисел, который, по его мнению, мог бы их спасти… Смогут ли спасти их оба списка вместе?</p>

  <p>Ваша программа должна определять, можно ли из двух списков целых чисел выбрать по одному числу так, чтобы в сумме они составили 10000.</p>

  <h4>Входные данные</h4>
  <p>Состоят из двух списков — одного, потом другого. Формат каждого из этих списков таков: в первой строчке записано количество N<sub>i</sub> чисел в i-м списке, далее в N<sub>i</sub> строчках по одному числу в строке записаны сами списки. Выполняются неравенства 1 ≤ N<sub>i</sub> ≤ 50000, все элементы списков лежат в диапазоне от -32768 до 32767. Первый список упорядочен по возрастанию, второй - по убыванию.</p>

  <h4>Выходные данные</h4>
  <p>На выходе следует записать YES, если из списков можно выбрать по числу, которые в сумме дадут 10000 и NO в противном случае.</p>

  <h4>Пример</h4>
<pre>
4
-175
19
19
10424
3
8951
-424
-788
</pre>
  <code>YES</code>
</article>


<!-- Задача D. Поиск в массиве -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Поиск в массиве</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам дан упорядоченный массив, состоящий только из целочисленных элементов, каждый из которых не превосходит 10<sup>9</sup> по абсолютной величине, все элементы массива различны. Происходит серия следующих запросов: требуется найти позицию, на которой находится заданный элемент.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных 2 числа: N (1 ≤ N ≤ 10<sup>5</sup>) - число элементов в массиве и M (1 ≤ M ≤ 10<sup>5</sup>) - количество запросов. В следующей строке вводится N чисел - элементы массива упорядоченные по возрастанию, каждый из которых не превосходит 10<sup>9</sup> по абсолютной величине, все элементы массива различны. В следующих M строках вводится единственное число - запрашиваемый элемент.</p>

  <h4>Выходные данные</h4>
  <p>Вам необходимо отвечать на каждый из M запросов по одному в строке - на какой позиции стоит запрашиваемый элемент. Если же такого элемента нет вывести -1.</p>

  <h4>Пример</h4>
<pre>
3 5
1 3 4
1
2
3
4
5
</pre>
<pre>
1
-1
2
3
-1
</pre>
</article>


<!-- Задача E. Собственные числа Psych Up -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Собственные числа Psych Up</h3>

  <div><i>Ограничение по времени 0.5с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Шёл очередной контест Петрозаводских сборов. Игроки команды Psych Up быстро нашли простую задачу, и Федя сел за компьютер. Через пять минут решение было готово. Не тратя времени на тестирование, Федя отправил его на проверку и через несколько секунд получил вердикт Time Limit Exceeded. Федя скомкал условие задачи и вышел из класса, хлопнув дверью. Что-то шло не так, нужно было развеяться. По пути в туалет он услышал разговор авторов контеста. Паша обсуждал со своим другом решение той самой задачи. Федя смог разобрать из их разговора только слова «собственные числа». Федя подумал и решил, что у него, конечно же, есть собственные числа. Например, дата рождения, номер квартиры, оценка на последнем экзамене, количество поездок на соревнования. Но ведь контест командный. А что такое собственные числа команды? Естественно, что число является собственным для команды, если оно собственное для каждого из её участников. С такими радостными мыслями Федя направился назад в аудиторию.</p>

  <h4>Входные данные</h4>
  <p>Входные данные состоят из трёх блоков по две строки. Первая строка каждого блока содержит целое число n —количество собственных чисел очередного игрока (1 ≤ n ≤ 4000). Во второй строке блока записано n целых различных чисел в порядке возрастания — собственные числа очередного игрока. Все собственные числа — целые, положительные и не превосходят 10<sup>9</sup>.</p>

  <h4>Выходные данные</h4>
  <p>Выведите количество собственных чисел команды Psych Up.</p>

  <h4>Пример</h4>
<pre>
5
13 20 22 43 146
4
13 22 43 146
5
13 43 67 89 146
</pre>
  <code>3</code>
</article>


<!-- Задача F. Количество вхождений -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Количество вхождений</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Однажды Белг нашел на улице здоровенный массив размера n и решил его исследовать. К нему пришел его друг Валсотявс и решил проверить, насколько хорошо Белг изучил его, и начал ему задавать q вопросов следующего вида: он просил его найти число вхождений некоторого числа в этот массив. Но Белг не настолько хорошо изучил его, чтобы запомнить число вхождения любых чисел и отвечать на вопросы Валсотявса. Белг вспомнил о своём дипломе программиста, но давно этим не занимался, поэтому просит вас помочь ему написать программу, которая поможет ответить на все вопросы.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных заданы 2 числа: n и q (1 ≤ n, q ≤ 3 * 10<sup>5</sup>) - размер массива и число запросов соответственно. В следующей строке вводятся n целых чисел - массив который нашёл Белг, каждое число не превосходит 10<sup>9</sup> по абсолютной величине. В последующих q строках вводится по 1 числу - это то число, для которого надо найти его количество вхождений в массив.</p>

  <h4>Выходные данные</h4>
  <p>Выводить нужно ответы на запросы - по одному в строке - число вхождений запрашиваемого числа в заданный массив.</p>

  <h4>Пример 1</h4>
<pre>
10 5
1 2 3 3 4 4 4 5 6 7
4
3
2
1
0
</pre>
<pre>
3
2
1
1
0
</pre>
  <p>В первом тестовом примере - число 4 встречается 3 раза, число 3 - 2, 2 - встречается 1 раз, число 1 - тоже 1, а числа 0 нет в массиве, поэтому оно ни разу не встречается.</p>

  <h4>Пример 2</h4>
<pre>
10 3
4 5 1 2 3 4 7 4 4 0
4
3
6
</pre>
<pre>
4
1
0
</pre>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ввод данных
  int n, q;
  cin >> n >> q;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  sort(A.begin(), A.end());
  vector&lt;int&gt; B, C;
  B.push_back(A[0]);
  C.push_back(1);

  for (int i = 1; i &lt; n; i++) {
    if (A[i] == B[B.size() - 1]) {
      C[C.size() - 1]++;
    } else {
      B.push_back(A[i]);
      C.push_back(1);
    }
  }

  int x, left, right, mid;
  for (int i = 0; i &lt; q; i++) {
    cin >> x;
    left = 0; // [l,r)
    right = B.size();
    while (right - left > 1) {
      mid = (right + left) / 2;
      if (B[mid] > x) {
        right = mid;
      } else {
        left = mid;
      }
    } // [l, l+1)

    // вывод результата
    if (B[left] == x) {
      cout &lt;&lt; C[left] &lt;&lt; '\n';
    } else {
      cout &lt;&lt; 0 &lt;&lt; '\n';
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача G. Экзамен по истории -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Экзамен по истории</h3>

  <div><i>Ограничение по времени 1.5с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Будем справедливы: сессия ставит задачи не только студентам, но и преподавателям. Любой преподаватель обучает немалое количество студентов, а ведь каждого надо еще и проверить. Поэтому один из преподавателей решил принимать экзамен по истории по такой упрощённой процедуре: студент записывает все известные ему «исторические» даты (достаточно, чтобы он написал только года, но, конечно, мог объяснить, чем замечательна та или иная дата). Преподаватель же держит перед глазами список дат, которые студент должен знать. Для оценки знаний студента преподаватель подсчитывает количество чисел в списке студента, которые также есть в списке преподавателя. В зависимости от полученного числа и выставляется итоговая оценка. Вы должны оказать посильную помощь в автоматизации этого процесса, разработав программу для подсчёта количества совпадений в списках студента и преподавателя.</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержится число N — количество записей в списке преподавателя. 1 ≤ N ≤ 15000. Затем идет N строк, содержащих список преподавателя, по одной дате в строке. Записаны только года. Каждый год — целое число в пределах от 1 до 10<sup>9</sup>. Даты в этом списке отсортированы по неубыванию. В следующей после списка строке содержится число M — количество записей в списке студента, 1 ≤ M ≤ 10<sup>6</sup>. Затем также M строк с датами (записаны только года, каждый год — целое число в пределах от 1 до 10<sup>9</sup>). Этот список не отсортирован. В списке как студента, так и преподавателя даты могут повторяться.</p>

  <h4>Выходные данные</h4>
  <p>Вы должны вывести одно число — количество чисел во втором списке, которые также содержатся в первом.</p>

  <h4>Пример</h4>
<pre>
2
1054
1492
4
1492
65536
1492
100
</pre>
  <code>2</code>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  // список преподавателя
  int n;
  cin >> n;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // список студента
  int m;
  cin >> m;
  vector&lt;int&gt; B(m);
  for (int i = 0; i &lt; m; i++) {
    cin >> B[i];
  }

  // решение
  int res = 0;
  for (int i = 0; i &lt; m; i++) {
    int tmp, left, right, mid;
    tmp = B[i];
    left = 0;
    right = n - 1;

    while (right - left > 1) {
      mid = (right + left) / 2;
      if (A[mid] > tmp) {
        right = mid;
      } else {
        left = mid;
      }
    }

    if (A[left] == tmp || A[right] == tmp) {
      res++;
    }
  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача H. Функция Хевисайда -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Функция Хевисайда</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Функцией Хевисайда называется кусочно-постоянная функция, равная нулю для отрицательных значений аргумента и единице — для неотрицательных:</p>
  <code>θ(x)={0, x &lt; 0 ; 1, x ⩾ 0}</code>

  <p>Дана функция</p>
  <code>f(x)=θ(s<sub>1</sub>⋅x - a<sub>1</sub>)+θ(s<sub>2</sub>⋅x - a<sub>2</sub>)+⋯+θ(s<sub>n</sub>⋅x - a<sub>n</sub>)</code>
  <p>, где s<sub>i</sub>=±1. Посчитайте ее значение в точках x<sub>1</sub>, x<sub>2</sub>, ..., x<sub>m</sub>.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано единственное целое число n (1≤n≤200000) — количество слагаемых в функции.</p>

  <p>В следующих n строках записано по два целых числа s<sub>i</sub> и a<sub>i</sub> (s<sub>i</sub>=±1, -10<sup>9</sup>≤a<sub>i</sub>≤10<sup>9</sup>) — параметры i-ого слагаемого функции.</p>

  <p>В следующей строке записано единственное целое число m (1≤m≤200000) — количество значений аргумента, для которых нужно посчитать значение выражения.</p>

  <p>В последней строке записано m целых чисел x<sub>1</sub>, ..., x<sub>m</sub> (-10<sup>9</sup>≤x<sub>i</sub>≤10<sup>9</sup>) — точки, в которых надо посчитать значение выражения.</p>

  <h4>Выходные данные</h4>
  <p>Выведите m строк. В i-ой строке выведите значение выражения f(x<sub>i</sub>).</p>

  <h4>Пример</h4>
<pre>
6
1 3
-1 2
1 9
-1 2
1 7
-1 2
8
0 12 2 8 4 -3 7 9
</pre>
<pre>
0
3
0
2
1
3
2
3
</pre>
</article>


<!-- Задача I. Модифицированный НОД -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача I. Модифицированный НОД</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Что ж, вот еще одна математическая задача. Как известно, НОД — наибольший общий делитель. Найти НОД двух положительных целых чисел несложно.</p>

  <p>Общий делитель двух положительных чисел — это число на которое делятся оба этих числа.</p>

  <p>Но Вам дана более сложная задача. Требуется найти наибольший общий делитель d двух целых чисел a и b, принадлежащий отрезку целых чисел [low, high] (low ≤ high), то есть такой, что low ≤ d ≤ high.</p>

  <p>Может получиться, что в заданном отрезке нет общих делителей.</p>

  <p>Даны два целых числа a и b, далее следует n запросов. Каждый запрос — это некоторый отрезок [low, high]. Напишите программу, которая обработает все заданные запросы.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано два целых числа a и b, описанных выше (1 ≤ a, b ≤ 10<sup>9</sup>). Во второй строке содержится одно целое число n, количество запросов (1 ≤ n ≤ 10<sup>4</sup>). Далее следует n строк. Каждая строка содержит один запрос — два целых числа low и high (1 ≤ low ≤ high ≤ 10<sup>9</sup>).</p>

  <h4>Выходные данные</h4>
  <p>Выведите n строк, i-ая из них должна содержать ответ на i-ый запрос из входных данных. Если в данном отрезке общих делителей нет, выводите -1 в качестве ответа на запрос.</p>

  <h4>Пример</h4>
<pre>
9 27
3
1 5
10 11
9 11
</pre>
<pre>
3
-1
9
</pre>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

// наибольший общий делитель
long long gcd(long long a, long long b) {
  if (b == 0) {
    return a;
  } else {
    return gcd(b, a % b);
  }
}

int main() {
  // ввод данных
  long long a, b;
  cin >> a >> b;
  long long d = gcd(a, b);
  int t;
  cin >> t;

  // решение
  vector&lt;long long&gt; G;
  for (long long i = 1; i * i &lt;= d; i++) {
    if (d % i == 0) {
      G.push_back(i);
      if (d != i * i) {
        G.push_back(d / i);
      }
    }
  }
  sort(G.begin(), G.end());

  for (int test = 0; test &lt; t; test++) {
    int low, high;
    cin >> low >> high;
    int left = 0, right = G.size(), mid;
    while (right - left > 1) {
      mid = (left + right) / 2;
      if (G[mid] > high) {
        right = mid;
      } else {
        left = mid;
      }
    }


    // вывод результата
    if (G[left] >= low) {
      cout &lt;&lt; G[left] &lt;&lt; '\n';
    } else {
      cout &lt;&lt; "-1\n";
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача J. Коровам - колокольчиков -->
<article class="article">
  <div class="anchor" id="task10"></div>
  <h3>Задача J. Коровам - колокольчиков</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Кевин Сан хочет переместить свою драгоценную коллекцию из n колокольчиков (конечно же коровьих) из Мухоглинска в Эксетер, а там — представьте себе! — на полях растёт не кукуруза, а настоящая трава. Для переезда ему надо упаковать все свои колокольчики в k коробок фиксированного размера. Чтобы коллекция не пострадала в ходе перевозки, Кевин не собирается класть в одну коробку более двух колокольчиков. Так как Кевин хочет минимизировать расходы, требуется найти минимальный размер коробок, которые он может использовать для упаковки всей своей коллекции.</p>

  <p></p>Кевин — дотошный коллекционер, и он знает, что размер i-го колокольчика в его коллекции равен целому числу s<sub>i</sub>. Кевин хранит колокольчики упорядоченными, а именно s<sub>i-1</sub> ≤ s<sub>i</sub> для всех i > 1. Также Кевин великолепно упаковывает вещи, поэтому он может поместить один или два колокольчика в коробку размера s тогда и только тогда, когда сумма их размеров не превышает s. Используя информацию о коллекции Кевина, найдите минимальное s, такое что Кевин сможет упаковать все свои n колокольчиков в k коробок размера s.

  <h4>Входные данные</h4>
  <p>В первой строке входных данных находятся два числа n и k (1 ≤ n ≤ 2·k ≤ 100000), обозначающие количество колокольчиков и количество коробок соответственно.</p>

  <p>В следующей строке записано n целых чисел s<sub>1</sub>, s<sub>2</sub>, ..., s<sub>n</sub> (1 ≤ s<sub>i</sub> ≤ 1000000) — размеры колокольчиков в коллекции Кевина. Гарантируется, что s<sub>i</sub> следуют в порядке неубывания.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное целое число — минимальное s, такое что Кевин сможет упаковать все свои n колокольчиков в k коробок размера s.</p>

  <h4>Пример 1</h4>
<pre>
2 1
2 5
</pre>
  <code>7</code>
  <p>В первом примере Кевину придётся упаковать оба колокольчика в одну коробку.</p>

  <h4>Пример 2</h4>
<pre>
4 3
2 3 5 9
</pre>
  <code>9</code>
  <p>Во втором примере Кевин может упаковать колокольчики следующим образом: {2, 3}, {5} и {9}.</p>

  <h4>Пример 3</h4>
<pre>
3 2
3 5 7
</pre>
  <code>8</code>
  <p>В третьем примере оптимальное решение следующее: {3, 5} и {7}.</p>
</article>


<!-- Задача K. Про таблицу умножения -->
<article class="article">
  <div class="anchor" id="task11"></div>
  <h3>Задача K. Про таблицу умножения</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Бизон-Чемпион не только обаятельный, но и очень умный.</p>

  <p>Пока одни учили обычную таблицу умножения, Бизон-Чемпион развлекался по-своему. Бизон-Чемпион рисовал таблицу умножения размера n x m, где элемент, стоящий на пересечении i-й строки и j-го столбца, равняется i·j (строки и столбцы таблицы нумеруются, начиная от единицы). Затем его спрашивали, какое число в этой таблице k-е по величине? Бизон-Чемпион отвечал всегда правильно и не задумываясь. Сможете ли вы повторить его успех?</p>

  <p>Рассмотрим описанную таблицу умножения. Если выписать все n·m чисел из этой таблицы в порядке неубывания, то число выписанное k-м называется k-м по величине.</p>

  <h4>Входные данные</h4>
  <p>В единственной строке содержатся целые числа n, m и k (1 ≤ n, m ≤ 5·10<sup>5</sup>; 1 ≤ k ≤ n·m).</p>

  <h4>Выходные данные</h4>
  <p>Выведите k-е по величине число в таблице умножения n x m.</p>

  <h4>Пример 1</h4>
  <code>2 2 2</code>
  <code>2</code>

  <h4>Пример 2</h4>
  <code>2 3 4</code>
  <code>3</code>

  <h4>Пример 3</h4>
  <code>1 10 5</code>
  <code>5</code>

  <p>Таблица умножения 2 x 3 выглядит следующим образом:</p>
<pre>
1 2 3
2 4 6
</pre>
</article>


<!-- Задача L. Неквадратное уравнение -->
<article class="article">
  <div class="anchor" id="task12"></div>
  <h3>Задача L. Неквадратное уравнение</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Рассмотрим уравнение:</p>
  <code>x<sup>2</sup> + s(x)·x - n = 0,</code>

  <p>где x, n — целые положительные числа, s(x) — функция, равная сумме цифр числа x в десятичной системе счисления.</p>

  <p>Вам дано целое число n, найдите наименьший целый положительный корень уравнения x, или определите, что таких корней нет.</p>

  <h4>Входные данные</h4>
  <p>В единственной строке записано целое число n (1 ≤ n ≤ 10<sup>18</sup>) — параметр уравнения.</p>

  <p>Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.</p>

  <h4>Выходные данные</h4>
  <p>Выведите -1, если уравнение не имеет целых положительных корней. Иначе выведите такое наименьшее целое x (x > 0), что описанное в условии равенство выполняется.</p>

  <h4>Пример 1</h4>
  <code>2</code>
  <code>1</code>
  <p>В первом тестовом примере x = 1 является наименьшим корнем. Так как s(1) = 1 и 1<sup>2</sup> + 1·1 - 2 = 0.</p>

  <h4>Пример 2</h4>
  <code>110</code>
  <code>10</code>
  <p>Во втором тестовом примере x = 10 является наименьшим корнем. Так как s(10) = 1 + 0 = 1 и 10<sup>2</sup> + 1·10 - 110 = 0.</p>

  <h4>Пример 3</h4>
  <code>4</code>
  <code>-1</code>
  <p>В третьем тестовом примере корней у уравнения нет.</p>
</article>


<!-- Задача M. Очередная задача на массиве -->
<article class="article">
  <div class="anchor" id="task13"></div>
  <h3>Задача M. Очередная задача на массиве</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Помимо теории чисел и строковых алгоритмов Профессор Ш. любит заниматься массивами, но не простыми, а отсортированными по неубыванию элементов. Сегодня Профессор Ш. придумал отличную задачу и делится её формулировкой с вами.</p>

  <p>Изначально имеется массив a, состоящий из N чисел, элементы которого расположены в порядке неубывания. К данному массиву можно применять запросы 2 типов:</p>
  <ol>
    <li>Сдвинуть массив циклически влево или вправо на k позиций.</li>
    <li>Проверить, есть ли в массиве число x. Если такое число есть, вывести его номер в массиве (возможно, измененном). Если число входит в массив несколько раз, следует вывести номер его первого вхождения в массив.</li>
  </ol>

  <p>Так как Профессор Ш. умеет работать только с отсортированными массивами, он не всегда умеет проверять, есть ли в массиве число x. Помогите Профессору – напишите программу, которая будет верно отвечать на запросы обоих типов.</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержится число N (1≤N≤2⋅10<sup>5</sup>) – количество элементов массива.</p>

  <p>Во второй строке содержатся N чисел a<sub>i</sub> (-10<sup>18</sup> ≤ a<sub>i</sub> ≤ 10<sup>18</sup>) – элементы массива a. Гарантируется, что изначально элементы массива отсортированы по неубыванию.</p>

  <p>В третьей строке содержится число Q (1 ≤ Q ≤ 3⋅10<sup>5</sup>) – количество запросов.</p>

  <p>В следующих Q строках содержатся запросы. Запросы задаются следующим образом:</p>
  <ol>
    <li>s k (1≤|k|&lt;N) – сдвинуть массив циклически на k позиций. Если число k отрицательное, то сдвиг осуществляется влево, в противном случае сдвиг должен быть осуществлён вправо.</li>
    <li>? x – проверить, есть ли в массиве число x.</li>
  </ol>

  <h4>Выходные данные</h4>
  <p>Для каждого запроса вида «? x» выведите в отдельной строке число – номер числа x в массиве. Если числа x в масиве нет, в отдельной строке выведите «-1». Считается, что элементы массива нумеруются с 1
  .</p>

  <h4>Пример 1</h4>
<pre>
7
1 2 3 4 5 6 7
7
? 9
s 2
? 4
s -2
? 3
s -5
? 6
</pre>
<pre>
-1
6
3
1
</pre>

  <h4>Пример 2</h4>
<pre>
7
1 1 2 2 3 3 4
7
? 9
s 2
? 4
s -1
? 2
s -5
? 1
</pre>
<pre>
-1
2
4
4
</pre>
  <p>Рассмотрим первый пример.</p>
  <p>Изначально массив a=[1,2,3,4,5,6,7].</p>
  <ol>
    <li>Так как число 9 больше любого элемента массива a, выведем -1.</li>
    <li>После запроса s 2 нужно сдвинуть массив вправо на 2 позиции, он станет равен [6,7,1,2,3,4,5].</li>
    <li>Число 4 находится на позиции 6, поэтому выводим 6.</li>
    <li>После запроса s -2 массив примет исходный вид [1,2,3,4,5,6,7]</li>
    <li>Число 3 находится на позиции 3, поэтому выводим 3</li>
    <li>После запроса s -5 массив сдвигается на 5 позиций влево: [6,7,1,2,3,4,5]</li>
    <li>Число 6 находится на позиции 1, поэтому выводим 1.</li>
  </ol>
</article>


<!-- Задача N. Запросы на поедание конфет -->
<article class="article">
  <div class="anchor" id="task14"></div>
  <h3>Задача N. Запросы на поедание конфет</h3>

  <div><i>Ограничение по времени 3.5с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У Тимура есть n конфет. В i-й конфете количество сахара равно a<sub>i</sub>. Так, съев i-ю конфету, Тимур потребляет количество сахара, равное a<sub>i</sub>.</p>

  <p>Тимур задаст вам q запросов о своих конфетах. Для j-го запроса вы должны ответить, какое минимальное количество конфет ему нужно съесть, чтобы потребить количество сахара, большее или равное x<sub>j</sub>. Выведите -1, если невозможно получить такое количество. Другими словами, нужно вывести минимально возможное k такое, что, съев k конфет, Тимур получит количество сахара не менее x<sub>j</sub>, или сказать, что такого k не существует.</p>

  <p>Обратите внимание, что он не может съесть одну и ту же конфету дважды, а запросы не зависят друг от друга (Тимур может использовать одну и ту же конфету в разных запросах).</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит единственное целое число t (1≤t≤1000)  — количество наборов входных данных. Далее следуют описания наборов.</p>

  <p>Первая строка каждого набора содержит 2 целых числа n и q
  (1≤n,q≤1.5⋅10<sup>5</sup>) — количество конфет, которые есть у Тимура и количество запросов соответственно.</p>

  <p>Вторая строка каждого набора содержит n целых чисел a<sub>1</sub>,a<sub>2</sub>,…,a<sub>n</sub> (1≤a<sub>i</sub>≤10<sup>4</sup>) — количество сахара в каждой конфете соответственно.</p>

  <p>Затем следуют q строк.</p>

  <p>Каждая из q содержит единственное целое число x<sub>j</sub> (1≤x<sub>j</sub>≤2⋅10<sup>9</sup>) — количество сахара, которое хочет получить Тимур.</p>

  <p>Гарантируется, что сумма n и сумма q по всем наборам входных данных не превосходит 1.5⋅10<sup>5</sup>.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите q строк. В j-й строке выведите количество конфет, которое нужно съесть Тимуру, чтобы получить количество сахара, большее или равное x<sub>j</sub>. Выведите -1, если получить такое количество невозможно.</p>

  <h4>Пример</h4>
<pre>
3
8 7
4 3 3 1 1 4 5 9
1
10
50
14
15
22
30
4 1
1 2 3 4
3
1 2
5
4
6
</pre>
<pre>
1
2
-1
2
3
4
8
1
1
-1
</pre>
  <p>В первом наборе входных данных примера:</p>
  <ul>
    <li>В первом запросе Тимур может съесть любую конфету, и он наберет нужное количество.</li>
    <li>Во втором запросе Тимур может получить количество не менее 10, съев 7-ю и 8-ю конфету, таким образом потребив количество сахара, равное 14.</li>
    <li>На третий запрос нет возможного ответа.</li>
    <li>В четвертом запросе Тимур может получить количество как минимум 14, съев 7-ю и 8-ю конфету, таким образом потребив количество сахара, равное 14.</li>
  </ul>

  <p>Во втором наборе входных данных примера:</p>
  <ul>
    <li>Для единственного запроса второго набора входных данных мы можем выбрать третью конфету, из которой Тимур получает количество сахара равное 3. Также можно получить тот же ответ, выбрав четвертую конфету.</li>
  </ul>

  <details>
    <summary>Решение</summary>
    <p>Создадим префикс-функцию идя по массиву в убывающем порядке</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ввод данных
  int t;
  cin >> t;
  for (int test = 0; test &lt; t; test++) {
    int n, q;
    cin >> n >> q;
    vector&lt;int&lt; A(n + 1);
    for (int i = 0; i &lt; n; i++) {
      cin >> A[i];
    }

    // решение
    sort(A.begin(), A.end());
    int uk = n;
    vector&lt;int&lt; Pref(n + 1);
    for (int i = 1; i &lt;= n; i++) {
      Pref[i] = Pref[i - 1] + A[uk];
      uk--;
    }

    int x, left, right, mid;
    for (int i = 0; i &lt; q; i++) {
      cin >> x;
      left = 0;
      right = n + 1;

      while (right - left > 1) {
        mid = (right + left) / 2;
        if (Pref[mid] &lt;= x) {
          left = mid;
        } else {
          right = mid;
        }
      }

      // вывод результата
      if (Pref[Pref.size() - 1] &lt; x) {
        cout &lt;&lt; "-1\n";
      } else if (Pref[left] >= x) {
        cout &lt;&lt; left &lt;&lt; "\n";
      } else {
        cout &lt;&lt; right &lt;&lt; "\n";
      }
    }
  }
}
</pre>
  </details>
</article>

