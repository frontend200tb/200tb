<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p>ЯрГУ. Кружок. Студенты 2023/2024</p>
  <p><a href="https://vkvideo.ru/@yaracm" target="_blank">vkvideo.ru/@yaracm</a></p>
  <p>Автор кружка Игорь Маслеников</p>
</article>


<article class="article">
  <h1>Занятие 17. Графы 1. Базовые понятия</h1>
  <p>Конспект видео</p>
  <p><a href="https://codeforces.com/group/w0J26SHHez/contest/413546" target="_blank">Codeforces Контест 413546</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
    <a href="#p1">Графы 1. Базовые понятия</a>
  </p>
  <p>
        <a href="#task1">Задача A. Светофорчики</a>
    <br><a href="#task2">Задача B. Дороги</a>
    <br><a href="#task3">Задача C. Цветной дождь</a>
    <br><a href="#task4">Задача D. Любовный треугольник</a>
    <br><a href="#task5">Задача E. Матрицу в список</a>
    <br><a href="#task6">Задача F. Список в матрицу</a>
    <br><a href="#task7">Задача G. Список рёбер</a>
    <br><a href="#task8">Задача H. Метро</a>
    <br><a href="#task9">Задача I. Шнурки и шестиклассники</a>
    <br><a href="#task10">Задача J. Топология сети</a>
    <br><a href="#task11">Задача K. Дорожная сеть</a>
    <br><a href="#task12">Задача L. Маршруты</a>
    <br><a href="#task13">Задача M. Брасс Бирмингем: дороги</a>
    <br><a href="#task14">Задача N. Вечная зима</a>
  </p>
</article>


<!-- Графы 1. Базовые понятия -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Графы 1. Базовые понятия</h3>

</article>


<!-- Задача A. Светофорчики -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Светофорчики</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 16мб</i></div>

  <p>В подземелье M тоннелей и N перекрестков, каждый тоннель соединяет какие-то два перекрестка. Мышиный король решил поставить по светофору в каждом тоннеле перед каждым перекрестком. Напишите программу, которая посчитает, сколько светофоров должно быть установлено на каждом из перекрестков. Перекрестки пронумерованы числами от 1 до N.</p>

  <h4>Входные данные</h4>
  <p>Записано два числа N и M (0 &lt; N ≤ 100, 0 ≤ M ≤ N * (N - 1) / 2). В следующих M строках записаны по два числа i и j(1 ≤ i, j ≤ N), которые означают, что перекрестки i и j соединены тоннелем. Можно считать, что любые два перекрестка соединены не более, чем одним тоннелем. Нет тоннелей от перекрестка i до него самого.</p>

  <h4>Выходные данные</h4>
  <p>Вывести N чисел: k-ое число означает количество светофоров на k-ом перекрестке.</p>

  <h4>Пример</h4>
<pre>
7 10
5 1
3 2
7 1
5 2
7 4
6 5
6 4
7 5
2 1
5 3
</pre>
  <code>3 3 2 2 5 2 3</code>
</article>


<!-- Задача B. Дороги -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Дороги</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 16мб</i></div>

  <p>В галактике «Milky Way» на планете «Snowflake» есть N городов, некоторые из которых соединены дорогами. Император галактики «Milky Way» решил провести инвентаризацию дорог на планете «Snowflake». Но, как оказалось, он не силен в математике, поэтому он просит вас сосчитать количество дорог. Требуется написать программу, помогающую императору сосчитать количество дорог на планете «Snowflake».</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано число N (0 ≤ N ≤ 100). В следующих N строках записано по N чисел, каждое из которых является единичкой или ноликом. Причем, если в позиции (i, j) квадратной матрицы стоит единичка, то i-ый и j-ый города соединены дорогами, а если нолик, то не соединены.</p>

  <h4>Выходные данные</h4>
  <p>Необходимо вывести число, определяющее количество дорог на планете «Snowflake».</p>

  <h4>Пример</h4>
<pre>
5
0 1 0 0 0
1 0 1 1 0
0 1 0 0 0
0 1 0 0 0
0 0 0 0 0
</pre>
  <code>3</code>
</article>


<!-- Задача C. Цветной дождь -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Цветной дождь</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 16мб</i></div>

  <p>В Банановой республике очень много холмов, соединенных мостами. На химическом заводе произошла авария, в результате чего испарилось экспериментальное удобрение "зован". На следующий день выпал цветной дождь, причем он прошел только над холмами. В некоторых местах падали красные капли, в некоторых - синие, а в остальных - зеленые, в результате чего холмы стали соответствующего цвета. Президенту Банановой республики это понравилось, но ему захотелось покрасить мосты между вершинами холмов так, чтобы мосты были покрашены в цвет холмов, которые они соединяют. К сожалению, если холмы разного цвета, то покрасить мост таким образом не удастся. Посчитайте количество таких "плохих" мостов.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано N (0 &lt; N ≤ 100) - число холмов. Далее идет матрица смежности, описывающая наличие мостов между холмами (1-мост есть, 0-нет). Предпоследняя строка пустая, а в последней строке записано N чисел, обозначающих цвет холмов: 1 - красный; 2 - синий; 3 - зеленый.</p>

  <h4>Выходные данные</h4>
  <p>Вывести количество "плохих" мостов.</p>

  <h4>Пример</h4>
<pre>
7
0 1 0 0 0 1 1
1 0 1 0 0 0 0
0 1 0 0 1 1 0
0 0 0 0 0 0 0
0 0 1 0 0 1 0
1 0 1 0 1 0 0
1 0 0 0 0 0 0

1 1 1 1 1 3 3
</pre>
  <code>4</code>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  int n;
  cin >> n;

  vector&lt;vector&lt;int&gt; &gt; G(n + 1, vector&lt;int&gt;(n + 1));
  for (int i = 1; i &lt;= n; i++) {
    for (int j = 1; j &lt;= n; j++) {
      cin >> G[i][j];
    }
  }

  vector&lt;int&gt; Color(n + 1);
  for (int i = 1; i &lt;= n; i++) {
    cin >> Color[i];
  }


  // решение
  int res = 0;
  for (int i = 1; i &lt;= n; i++) {
    for (int j = i + 1; j &lt;= n; j++) {
      if (G[i][j] == 1) {
        if (Color[i] != Color[j]) {
          res++;
        }
      }
    }
  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача D. Любовный треугольник -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Любовный треугольник</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Как известно, нет самолетов-мужчин и самолетов-женщин. Однако, каждому самолету на Земле нравится какой-то один другой самолет. Всего на Земле n самолетов, пронумерованных от 1 до n, при этом самолету номер i нравится самолет fᵢ, где 1 ≤ fᵢ ≤ n, а также fᵢ ≠ i.</p>

  <p>Назовем любовным треугольником ситуацию, когда самолету A нравится самолет B, самолету B нравится самолет C, а самолету C нравится самолет A. Проверьте, есть ли на Земле хотя бы один любовный треугольник.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно целое число n (2 ≤ n ≤ 5000) — число самолетов.</p>

  <p>Вторая строка содержит n целых чисел f₁, f₂, ..., fₙ (1 ≤ fᵢ ≤ n, fᵢ ≠ i), что означает, что i-му самолету нравится fᵢ-й.</p>

  <h4>Выходные данные</h4>
  <p>Выведите «YES», если на Земле есть любовный треугольник из самолетов. Иначе выведите «NO».</p>

  <p>Каждую букву можно выводить в любом регистре: строчную или заглавную.</p>

  <h4>Пример 1</h4>
<pre>
5
2 4 5 1 3
</pre>
  <code>YES</code>

  <h4>Пример 2</h4>
<pre>
5
5 5 5 5 1
</pre>
  <code>NO</code>
  <p>В первом примере самолету 2 нравится самолет 4, самолету 4 нравится самолет 1, а самолету 1 нравится самолет 2, поэтому это любовный треугольник.</p>

  <p>Во втором примере любовных треугольников нет.</p>

  <details>
    <summary>Решение</summary>
    <p>Задача на ориентированный граф. Показано кто на кого ссылается. Будем искать цыклы длины 3. Проверим что 1 → 2 → 3 → 1</p>
    <code>G[G[G[i]]] == i</code>
<pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  int n;
  cin >> n;

  vector&lt;int&gt; G(n + 1);
  for (int i = 1; i &lt; n; i++) {
    cin >> G[i];
  }

  // решение
  bool flag = false;
  for (int i = 0; i &lt;= n; i++) {
    if (G[i] != i && G[G[G[i]]] == i) {
      flag = true;
    }
  }

  // вывод результата
  if (flag == true) {
    cout &lt;&lt; "YES";
  } else {
    cout &lt;&lt; "NO";
  }
}
</pre>
  </details>
</article>


<!-- Задача E. Матрицу в список -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Матрицу в список</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Неориентированный граф с N вершинами задан матрицей смежности. Выведите его список смежности.</p>

  <h4>Входные данные</h4>
  <p>В первой строке вводится 1 натуральное число N — число вершин в графе (1 ≤ N ≤ 1000). В следующих N строках описан граф матрицей смежности: на пересечении i-й строки и j-го столбца будет стоять единица, если существует ребро из вершины с номером i в вершину с номером j, и ноль в противном случае.</p>

  <h4>Выходные данные</h4>
  <p>Выведите список смежности заданного графа: вывод должен состоять из N строк, в i-й строке должны быть перечислены номера вершин (в возрастающем порядке) с которыми смежна вершина номер i.</p>

  <h4>Пример 1</h4>
<pre>
4
0 1 0 1
1 0 1 0
0 1 0 1
1 0 1 0
</pre>
<pre>
2 4
1 3
2 4
1 3
</pre>

  <h4>Пример 2</h4>
<pre>
6
0 0 1 1 0 0
0 0 0 0 1 1
1 0 0 1 0 0
1 0 1 0 0 0
0 1 0 0 0 1
0 1 0 0 1 0
</pre>
<pre>
3 4
5 6
1 4
1 3
2 6
2 5
</pre>
</article>


<!-- Задача F. Список в матрицу -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Список в матрицу</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Неориентированный граф с N вершинами и M ребрами задан списком рёбер. Выведите его матрицу смежности.</p>

  <h4>Входные данные</h4>
  <p>В первой строке вводится 2 целых числа N и M — число вершин и рёбер в графе (1 ≤ N ≤ 1000, 0 ≤ M ≤ n⋅(n-1)/2)</p>

  <h4>Выходные данные</h4>
  <p>Выведите матрицу смежности графа: на пересечении i-й строки и j-го столбца должна стоять единица, если существует ребро из вершины с номером i в вершину с номером j, и ноль в противном случае.</p>

  <h4>Пример 1</h4>
<pre>
4 4
1 2
2 3
3 4
4 1
</pre>
<pre>
0 1 0 1
1 0 1 0
0 1 0 1
1 0 1 0
</pre>

  <h4>Пример 2</h4>
<pre>
6 6
1 3
4 3
5 2
1 4
6 5
2 6
</pre>
<pre>
0 0 1 1 0 0
0 0 0 0 1 1
1 0 0 1 0 0
1 0 1 0 0 0
0 1 0 0 0 1
0 1 0 0 1 0
</pre>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  int n, m;
  cin >> n >> m;

  vector&lt;vector&lt;int&gt; &gt; G(n + 1, vector&lt;int&gt;(n + 1));
  int x, y;
  for (int i = 1; i &lt; m; i++) {
    cin >> x >> y;

    // решение
    G[x][y] = 1;
    G[y][x] = 1;
  }

  // вывод результата
  for (int i = 1; i &lt;= n; i++) {
    for (int j = 1; j &lt;= n; j++) {
      cout &lt;&lt; G[i][j] &lt;&lt; " ";
    }
    cout &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача G. Список рёбер -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Список рёбер</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам задан неориентированный граф без петель и кратных рёбер с n вершинами и m рёбрами. Ваша задача сохранить граф в виде списка рёбер, и отвечать на запросы - существует ли заданное ребро в списке рёбер.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных записаны 2 числа n и m (1 ≤ n, m ≤ 10⁵), в следующих m строках вводятся пары чисел - номера вершин, которые соединены ребром. В следующей строке задаётся число q (1 ≤ q ≤ 10⁵) - количество запросов, после чего в q строках перечисляются пары чисел обозначающие ребро соединяющее данные вершины, которые надо проверить - есть ли они в графе или нет.</p>

  <h4>Выходные данные</h4>
  <p>Вам необходимо отвечать на запросы по одному в каждой из q строк, в i-й строке ответ на i-й запрос - есть ли данное ребро в графе. Если оно есть - выводить "YES", иначе выводить "NO" (Вывод без кавычек)</p>

  <h4>Пример</h4>
<pre>
5 5
1 2
3 4
5 3
2 3
1 5
6
1 4
3 2
1 5
5 4
2 4
3 4
</pre>
<pre>
NO
YES
YES
NO
NO
YES
</pre>
</article>


<!-- Задача H. Метро -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Метро</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У Алисы сегодня день рождения, и она пригласила к себе в гости своего любимого друга Боба. Теперь перед Бобом встала непростая задача: доехать до дома Алисы.</p>

  <p>В городе, в котором живут Алиса и Боб, строится первая ветка метро. На этой ветке располагается n станций, пронумерованных от 1 до n. Боб живёт рядом со станцией номер 1, Алиса — со станцией номер s. Движение в метро двустороннее, то есть по первому пути поезда следуют от станции 1 до станции n, по второму — в обратном направлении. После того, как поезд доезжает до конечной станции по соответствующему пути, он сразу уезжает в депо, и ехать на нём дальше невозможно.</p>

  <p>Некоторые станции ещё не открылись или открылись неполностью: для каждой из станций и для каждого из путей известно, закрыта ли эта станция на этом пути или нет. Если станция закрыта по данному пути, то все поезда, следующие в ту сторону, проезжают мимо.</p>

  <p>Когда Боб узнал информацию об открытых и закрытых станциях метро, он обнаружил, что доехать до дома Алисы — не такая уж и простая задача. Помогите Бобу определить, сможет ли он доехать до её дома на метро, или же ему придётся срочно искать другие виды транспорта.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит два целых числа n и s (2 ≤ s ≤ n ≤ 1000) — количество станций метро и номер станции, у которой расположен дом Алисы. Боб живет на станции номер 1.</p>

  <p>Далее следует информация об открытых и закрытых станциях метро.</p>

  <p>Вторая строка содержит n целых чисел a₁ a₂, ... , aₙ (aᵢ = 0 или aᵢ = 1). Если aᵢ = 1, то i-я станция открыта по первому пути (то есть в сторону возрастания номеров станций). Иначе станция закрыта по первому пути.</p>

  <p>Третья строка содержит n целых чисел b₁, b₂, ... , bₙ (bᵢ = 0 или bᵢ = 1). Если bᵢ = 1, то i-я станция открыта по второму пути (то есть в сторону убывания номеров станций). Иначе станция закрыта по второму пути.</p>

  <h4>Выходные данные</h4>
  <p>Выведите «YES» (без кавычек), если Бобу удастся добраться до Алисы на метро, и «NO» (без кавычек) иначе.</p>

  <p>Вы можете выводить каждую букву в любом регистре (строчную или заглавную).</p>

  <h4>Пример 1</h4>
<pre>
5 3
1 1 1 1 1
1 1 1 1 1
</pre>
  <code>YES</code>

  <h4>Пример 2</h4>
<pre>
5 4
1 0 0 0 1
0 1 1 1 1
</pre>
  <code>YES</code>

  <h4>Пример 3</h4>
<pre>
5 2
0 1 1 1 1
1 1 1 1 1
</pre>
  <code>NO</code>
  <p>В первом примере все станции открыты, поэтому Бобу следует просто доехать до станции номер 3.</p>

  <p>Во втором примере Бобу надо доехать до станции 5, после чего пересесть на второй путь и доехать до станции 4.</p>

  <p>В третьем примере Боб не может сесть на поезд, следующий в сторону дома Алисы.</p>
</article>


<!-- Задача I. Шнурки и шестиклассники -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача I. Шнурки и шестиклассники</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Аня и Маша ведут математический кружок у шестиклассников. Во время кружка шестиклассники ведут себя плохо. Они принесли на кружок много шнурков, и связались друг с другом. А именно, каждый шнурок связывает вместе двух шестиклассников. При этом, если два шестиклассника связаны шнурком, то шнурок связывает как первого со вторым, так и второго с первым.</p>

  <p>Чтобы навести порядок, Аня и Маша делают следующее. Сначала Аня для каждого шестиклассника находит, со сколькими другими шестиклассниками он связан шнурками. Если шестиклассник связан ровно с одним другим, Аня объявляет ему выговор. Потом Маша собирает в группу всех шестиклассников, которым Аня объявила выговор, и выгоняет вон из класса. Выгнанные шестиклассники отвязываются и уходят из класса, забирая с собой шнурки, которыми они были привязаны. Потом снова Аня для каждого шестиклассника находит, со сколькими другими шестиклассниками он связан, и так далее. И так они делают, пока Ане удается объявить хотя бы один выговор.</p>

  <p>Определите, сколько групп шестиклассников будут выгнаны из класса.</p>

  <h4>Входные данные</h4>
  <p>В первой строке даны два целых числа n и m — исходное число шестиклассников и шнурков (1 ≤ n ≤ 100, 0 ≤ m ≤ n*(n-1)/2). Шестиклассники пронумерованы числами от 1 до n, а шнурки — числами от 1 до m. В следующих m строках дано по два целых числа a и b — номера шестиклассников, связанных i-ым шнурком (1 ≤ a, b ≤ n, a ≠ b). Гарантируется, что никакие два шестиклассника не связаны более чем одним шнурком. Никакой шнурок не связывает шестиклассника с самим собой.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное число — количество групп шестиклассников, которые будут выгнаны из класса.</p>

  <h4>Пример 1</h4>
<pre>
3 3
1 2
2 3
3 1
</pre>
  <code>0</code>

  <h4>Пример 2</h4>
<pre>
6 3
1 2
2 3
3 4
</pre>
  <code>2</code>

  <h4>Пример 3</h4>
<pre>
6 5
1 4
2 4
3 4
5 4
6 4
</pre>
  <code>1</code>

  <p>В первом примере Ане с Машей не выгонят ни одной группы шестиклассников — в изначальной позиции все шестиклассники привязаны к двум другим шестиклассникам, и Ане не удастся сделать ни одного выговора.</p>

  <p>Во втором примере четыре шестиклассника связаны в цепочку, а еще два бегают отдельно. Сначала Аня с Машей выгонят двух крайних шестиклассников из цепочки (1 и 4), а затем — двух оставшихся из цепочки (2 и 3). При этом бегающие отдельно от остальных шестиклассники останутся в классе.</p>

  <p>В третьем примере Аня с Машей сразу же выгонят всех шестиклассников, кроме четвертого, и на этом процесс закончится. Правильный ответ — один.</p>

  <details>
    <summary>Решение</summary>
    <p>Сложность O(n³). При n = 100 это приемлемо.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  int n, m;
  cin >> n >> m;

  // список смежности
  vector&lt;vector&lt;int&gt; &gt; G(n + 1);
  int x, y;
  for (int i = 0; i &lt; m; i++) {
    cin >> x >> y;
    G[x].push_back(y);
    G[y].push_back(x);
  }

  // решение
  int res = 0;
  vector&lt;int&gt; Mark(n + 1);
  vector&lt;int&gt; Level(n + 1);
  bool flag = true;

  while (flag) {
    flag = false;
    for (int i = 1; i &lt;= n; i++) {
      for (int j = 0; j &lt; G[i].size(); j++) {
        if (Mark[G[i][j]] == 0 && Mark[i] == 0) {
          Level[i]++;
        }
      }
    }
    for (int i = 1; i &lt;= n; i++) {
      if (Level[i] == 1) {
        if (flag == false) {
          res++;
        }
        flag = true;
        Mark[i] = 1;
      }
      Level[i] = 0;
    }
  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача J. Топология сети -->
<article class="article">
  <div class="anchor" id="task10"></div>
  <h3>Задача J. Топология сети</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В задаче используется упрощенная модель топологий сетей, внимательно прочтите условие задачи и используйте его как формальный документ при разработке решения.</p>

  <p>Поликарп продолжает работать системным администратором в некоторой большой корпорации. Компьютерная сеть этой корпорации состоит из n компьютеров, некоторые из которых соединены кабелем. Компьютеры пронумеруем целыми числами от 1 до n. Известно, что любые два компьютера соединены кабелем непосредственно или через другие компьютеры.</p>

  <p>Поликарп решил узнать топологию этой сети. Сетевая топология — это способ описания конфигурации сети, схема расположения и соединения сетевых устройств.</p>

  <p>Поликарп знает три основные топологии сети: шина, кольцо и звезда. Шина — это топология, которая представляет собой общий кабель, к которому подсоединены все компьютеры. Кольцо — топология, в которой каждый компьютер соединен кабелем только с двумя другими. Звезда — это топология, в которой все компьютеры сети присоединены к единому центральному узлу.</p>

  <p>Представим каждую из этих топологий сети в виде связного неориентированного графа. Под шиной будем понимать связный граф, являющийся единственным путем, то есть граф, в котором все вершины соединены с двумя другими, за исключением двух вершин, которые являются началом и концом пути. Под кольцом будем понимать связный граф, в котором все вершины соединены с двумя другими. Под звездой будем понимать связный граф, в котором выделена единственная центральная вершина, которая соединена со всеми остальными вершинами. Для лучшего понимания ознакомьтесь с рисунком.</p>

  <p>(1) — шина, (2) — кольцо, (3) — звезда</p>

  <p>Вам задан связный неориентированный граф, характеризующий компьютерную сеть корпорации, в которой работает Поликарп. Помогите ему узнать, к какой из данных топологий относится заданная компьютерная сеть. Если это невозможно определить, сообщите, что топология этой сети неизвестна.</p>

  <h4>Входные данные</h4>
  <p>В первой строке через пробел заданы два целых числа n и m (4 ≤ n ≤ 10⁵; 3 ≤ m ≤ 10⁵) — количество вершин и ребер в графе соответственно. Далее в m строках задано описание ребер графа. В i-той строке через пробел задана пара целых чисел xᵢ, yᵢ (1 ≤ xᵢ, yᵢ ≤ n) — номера вершин, которые соединяет i-ое ребро.</p>

  <p>Гарантируется, что заданный граф является связным. Между любыми двумя вершинами существует не более одного ребра. Ни одно ребро не соединяет вершину саму с собой.</p>

  <h4>Выходные данные</h4>
  <p>В единственную строку выведите название топологии сети, к которой относится заданный граф. Если ответом является шина, выведите «bus topology» (без кавычек), если ответом является кольцо, выведите «ring topology» (без кавычек), если ответом является звезда, выведите «star topology» (без кавычек). Если ни один из этих типов не подходит, выведите «unknown topology» (без кавычек).</p>

  <h4>Пример 1</h4>
<pre>
4 3
1 2
2 3
3 4
</pre>
  <code>bus topology</code>

  <h4>Пример 2</h4>
<pre>
4 4
1 2
2 3
3 4
4 1
</pre>
  <code>ring topology</code>

  <h4>Пример 3</h4>
<pre>
4 3
1 2
1 3
1 4
</pre>
  <code>star topology</code>

  <h4>Пример 4</h4>
<pre>
4 4
1 2
2 3
3 1
1 4
</pre>
  <code>unknown topology</code>
</article>


<!-- Задача K. Дорожная сеть -->
<article class="article">
  <div class="anchor" id="task11"></div>
  <h3>Задача K. Дорожная сеть</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>После столетий кровопролитных войн Берляндия и Бирляндия наконец объединяются! Жители этих стран устали воевать и решили жить дружно. Однако, процесс возвращения к нормальной мирной жизни будет трудным. Отчасти это обусловлено тем, что все дороги в обеих странах были разрушены во время войны. Поэтому на первом же заседании объединенного правительства было принято решение о скорейшем строительстве сети современных дорог. Каждая дорога будет соединять два города, и ездить по ней можно будет в обоих направлениях. По исторической случайности, в Берляндии и Бирляндии есть по n городов. При проектировании плана дорожной сети нужно учесть, что все города в пределах каждой из стран имеют различную значимость, которую можно обозначить целым числом от 1 до n. Таким образом, в объединенной стране будет два города значимости 1, два города значимости 2, и т.д. Для лучшего обеспечения более значимых городов дорогами было принято решение о том, что из города со значимостью k должны быть дороги ровно в k некоторых других городов. При этом не допускается, чтобы между парой городов было более одной дороги. Однако, возникли затруднения с разработкой плана дорог, отвечающего этому требованию. Вам требуется устранить эту проблему.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое число n (1 ≤ n ≤ 200) — количество городов в каждой из стран.</p>

  <h4>Выходные данные</h4>
  <p>В первой строке выведите общее количество дорог, которое будет построено в соответствии с требованиями к дорожной сети. Далее выведите сами дороги. Описание каждой дороги выводите в отдельной строке в формате «x y» (без кавычек), где x и y — номера городов, соединяемых дорогой (x≠y). Считайте, что города Берляндии пронумерованы от 1 до n в порядке возрастания значимости, а города Бирляндии — от n+1 до 2n, также в порядке возрастания значимости. Строки, содержащие информацию о дорогах, можно выводить в любом порядке. В случае, если решения не существует, выведите «-1» (без кавычек). Если решений несколько, выведите любое из них.</p>

  <h4>Пример 1</h4>
  <code>1</code>
<pre>
1
1 2
</pre>

  <h4>Пример 2</h4>
  <code>2</code>
<pre>
3
1 2
2 4
3 4
</pre>
</article>


<!-- Задача L. Маршруты -->
<article class="article">
  <div class="anchor" id="task12"></div>
  <h3>Задача L. Маршруты</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В Берляндии имеется N городов, причем некоторые из них соединены двусторонними дорогами. Никакая дорога не соединяет город с самим собой, и между парой городов не может быть более одной дороги. Коммивояжер Довлентий хочет выбрать маршрут, который проходит через четыре различных города, при этом он должен начинаться и заканчиваться в одном и том же городе, и соседние города маршрута должны быть соединены дорогами. Довлентий просит вас найти количество различных маршрутов, удовлетворяющих таким условиям, учитывая, что направление движения и выбор начального города не имеют значения. Например, маршруты 1→4→3→2→1, 1→2→3→4→1 и 2→3→4→1→2 считаются одинаковыми.</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержатся два целых числа N и M (4 ≤ N ≤ 400, 0 ≤ M ≤ N*(N-1)/2) — количество городов и дорог в Берляндии соответственно.</p>

  <p>В следующих M строках содержатся пары чисел u и v (1 ≤ u, v ≤ N) – пары городов, соединенных дорогами.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите число – количество различных маршрутов, удовлетворяющих условию задачи.</p>

  <h4>Пример 1</h4>
<pre>
4 4
1 2
2 3
3 4
4 1
</pre>
  <code>1</code>

  <h4>Пример 2</h4>
<pre>
4 6
1 2
2 3
3 4
4 1
1 3
2 4
</pre>
  <code>3</code>
</article>


<!-- Задача M. Брасс Бирмингем: дороги -->
<article class="article">
  <div class="anchor" id="task13"></div>
  <h3>Задача M. Брасс Бирмингем: дороги</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Сегодня Игорь и Ира вместе с друзьями — Сашей и Лешей — решили поиграть в новую настольную игру «Brass Birmingham».</p>

  <p>В каждом раунде игроки делают ходы по очереди. Во время хода игрок может построить производство в городах, дорогу, соединяющую два города, либо выполнить действие.</p>

  <p>Игра закончилась поздней ночью, и пришло время подводить итоги. Игорю доверили посчитать количество очков за построение дорог. Каждая построенная игроком дорога приносит ему количество очков, равное суммарному числу предприятий, открытых в городах, соединяемых этой дорогой.</p>

  <p>К сожалению, Игорь случайно опрокинул игровое поле так, что все карточки перемешались. Огорчившись, он вспомнил, что во время игры записывал в блокнот действия каждого игрока. Помогите Игорю посчитать очки за дороги, полученные каждым игроком.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое число N (2 ≤ N ≤ 10⁵) — количество городов в игре.</p>

  <p>Далее для каждого из четырех игроков указано:</p>

  <p>В первой строке целые числа Mₖ, Gₖ (1 ≤ Mₖ, Gₖ ≤ 10⁴) — количество производств и количество дорог, построенных k-м игроком.</p>

  <p>В следующей строке Mₖ целых чисел mₖi (1 ≤ mₖᵢ ≤ N) — города, в которых располагаются производства k-го игрока.</p>

  <p>Далее Gₖ строк, в каждой из которых располагаются по два целых числа aₖᵢ, bₖᵢ (1 ≤ aₖᵢ, bₖᵢ ≤ N) — города, которые соединяются дорогой k-го игрока.</p>

  <h4>Выходные данные</h4>
  <p>Выведите 4 целых числа через пробел – количеств очков за дороги, которые получил каждый из игроков.</p>

  <h4>Пример</h4>
<pre>
4
1 1
1
1 2
3 1
1 2 3
2 3
4 2
1 4 2 3
3 1
4 2
1 4
3
1 3
2 3
3 4
1 2
</pre>
  <code>5 5 9 20 </code>
</article>


<!-- Задача N. Вечная зима -->
<article class="article">
  <div class="anchor" id="task14"></div>
  <h3>Задача N. Вечная зима</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Граф-снежинка генерируется из двух целых чисел x и y, которые больше 1, следующим образом:</p>
  <ul>
    <li>Начните с одной центральной вершины.</li>
    <li>Подключите x новых вершин к этой центральной вершине.</li>
    <li>Подключите y новых вершин к каждой из этих x вершин.</li>
  </ul>
  <p>Например, ниже приведен граф-снежинка для x=5 и y=3.</p>

  <p>Граф-снежинка выше имеет центральную вершину 15, затем x=5 вершин, подключенных к ней (3, 6, 7, 8 и 20), а затем y=3 вершины, подключенные к каждой из них.</p>

  <p>Для заданного графа-снежинки определите значения x и y.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно целое число t (1 ≤ t ≤ 1000) — количество наборов входных данных в тесте.</p>

  <p>Первая строка каждого набора входных данных содержит два целых числа n и m (2 ≤ n ≤ 200; 1 ≤ m ≤ min(1000, n*(n-1)/2)) — количество вершин и ребер в графе соответственно.</p>

  <p>Следующие m строк содержат по два целых числа u и v (1 ≤ u, v ≤ n, u ≠ v) — номера вершин, соединенных ребром. Граф не содержит кратных ребер и петель.</p>

  <p>Гарантируется, что этот граф является графом снежинки для некоторых целых чисел x и y, которые больше 1.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных на отдельной строке выведите значения x и y, в этом порядке, разделенные пробелом.</p>

  <h4>Пример</h4>
<pre>
3
21 20
21 20
5 20
13 20
1 3
11 3
10 3
4 8
19 8
14 8
9 7
12 7
17 7
18 6
16 6
2 6
6 15
7 15
8 15
20 15
3 15
7 6
1 2
1 3
2 4
2 5
3 6
3 7
9 8
9 3
3 6
6 2
2 1
5 2
2 7
4 3
3 8
</pre>
<pre>
5 3
2 2
2 3
</pre>
  <p>Первый набор входных данных изображен в условии. Обратите внимание, что вывод 3 5 является неправильным, так как сначала должно быть выведено x, а затем y.</p>
</article>

