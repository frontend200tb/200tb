<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p>ЯрГУ. Кружок. Студенты 2023/2024</p>
  <p><a href="https://vkvideo.ru/@yaracm" target="_blank">vkvideo.ru/@yaracm</a></p>
  <p>Автор кружка Игорь Маслеников</p>
</article>


<article class="article">
  <h1>Занятие 2. Основы C++ 2. vector, cmath</h1>
  <p>Конспект видео</p>
  <p><a href="https://codeforces.com/group/w0J26SHHez/contest/344329" target="_blank">Codeforces Контест 344329</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
    <a href="#p1">Основы C++ 2. vector, cmath</a>
  </p>
  <p>
        <a href="#task1">Задача A. Последовательность</a>
    <br><a href="#task2">Задача B. Арбуз</a>
    <br><a href="#task3">Задача C. Слоник</a>
    <br><a href="#task4">Задача D. Честный тренер</a>
    <br><a href="#task5">Задача E. Переключение гравитации</a>
    <br><a href="#task6">Задача F. Формирование команд</a>
    <br><a href="#task7">Задача G. Задача о делимости</a>
    <br><a href="#task8">Задача H. Четный массив</a>
    <br><a href="#task9">Задача I. Сумма круглых чисел</a>
    <br><a href="#task10">Задача J. Скучные квартиры</a>
    <br><a href="#task11">Задача K. Точки на прямой</a>
    <br><a href="#task12">Задача L. Смена направления</a>
    <br><a href="#task13">Задача M. Виталий и ночь</a>
    <br><a href="#task14">Задача N. Николай и перестановка</a>
    <br><a href="#task15">Задача O. X-сумма</a>
  </p>
</article>


<!-- Основы C++ 2. vector, cmath -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Основы C++ 2. vector, cmath</h3>

  <p>Подключим библиотеку для вектора</p>
  <code>#include &lt;vector&gt;</code>
  <p>Вектор это динамический массив, длину которого можно изменять во время выполнения программы.</p>
  <p>Создадим вектор целых чисел, изначально пустой</p>
  <code>vector&lt;int&gt; A;</code>
  <p>Создадим вектор целых чисел, содержащий n элементов, изначально равных нулю</p>
  <code>vector&lt;int&gt; A(n);</code>
  <p>Создадим вектор целых чисел, содержащий 10 элементов, изначально равных 5</p>
  <code>vector&lt;int&gt; A(10, 5);</code>
  <p>Создадим двумерный вектор целых чисел, изначально пустой</p>
  <code>vector&lt;vector&lt;int&gt; &gt; A;</code>
  <p>Создадим двумерный вектор целых чисел, содержащий n пустых векторов</p>
  <code>vector&lt;vector&lt;int&gt; &gt; A(n);</code>
  <p>Создадим двумерный вектор целых чисел, содержащий n векторов, по m элементов, изначально равных нулю</p>
  <code>vector&lt;vector&lt;int&gt; &gt; A(n, vector&lt;int&gt; (m));</code>
  <p>Создадим трехерный вектор целых чисел, содержащий n векторов, по m векторов</p>
  <code>vector&lt;vector&lt;vector&lt;int&gt; &gt; &gt; A(n, vector&lt;vector&lt;int&gt; &gt; (m));</code>

  <p>Подключим библиотеку для алгоритмов</p>
  <code>#include &lt;algorithm&gt;</code>

  <p>Подключим математическую библиотеку</p>
  <code>#include &lt;cmath&gt; // или math.h</code>

</article>


<!-- Задача A. Последовательность -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Последовательность</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 16мб</i></div>

  <p>Дана последовательность чисел, завершающаяся нулем. Вывести четные числа в прямом порядке, нечетные - в обратном.</p>

  <h4>Пример</h4>
  <code>13 2 4 21 45 67 23 46 20 1 0</code>
<pre>
2 4 46 20
1 23 67 45 21 13
</pre>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  vector&lt;int&gt; A;
  int tmp = 1;
  while (tmp != 0) {
    cin >> tmp;
    if (tmp != 0) {
      A.push_back(tmp);
    }
  }

  // решение
  vector&lt;int&gt; B; // для четных чисел
  vector&lt;int&gt; C; // для нечетных чисел
  for (int i = 0; i &lt; A.size(); i++) {
    if (A[i] % 2 == 0) {
      B.push_back(A[i]);
    } else {
      C.push_back(A[i]);
    }
  }

  // вывод результата
  for (int i = 0; i &lt; B.size(); i++) {
    cout &lt;&lt; B[i] &lt;&lt; " "; // четные числа
  }
  cout &lt;&lt; '\n';
  for (int i = C.size() - 1; i >= 0; i--) {
    cout &lt;&lt; C[i] &lt;&lt; " "; // нечетные числа
  }
}
</pre>
  </details>
</article>


<!-- Задача B. Арбуз -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Арбуз</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 64мб</i></div>

  <p>В один из жарких летних дней Петя и его друг Вася решили купить арбуз. Они выбрали самый большой и спелый, на их взгляд. После недолгой процедуры взвешивания весы показали w килограмм. Поспешно прибежав домой, изнемогая от жажды, ребята начали делить приобретенную ягоду, однако перед ними встала нелегкая задача. Петя и Вася являются большими поклонниками четных чисел, поэтому хотят поделить арбуз так, чтобы доля каждого весила именно четное число килограмм, при этом не обязательно чтобы доли были равными по величине. Ребята очень сильно устали и хотят скорее приступить к трапезе, поэтому вы должны подсказать им, удастся ли поделить арбуз, учитывая их пожелание. Разумеется, каждому должен достаться кусок положительного веса.</p>

  <h4>Входные данные</h4>
  <p>В первой и единственной строке входных данных записано челое число w (1 ≤ w ≤ 100) вес арбуза</p>

  <h4>Выходные данные</h4>
  <p>Выведите YES, если ребята смогут поделить арбуз на две части, каждая из которых весит четное число килограммм, и NO в противном случае</p>

  <h4>Пример</h4>
  <code>8</code>
  <code>YES</code>

  <p>На Codeforces задачи в контестах нумеруются буквами от A до F. В задаче есть ограничение по времени и по памяти. Присутствует легенда.</p>

  <details>
    <summary>Решение на C++</summary>
    <h4>Проверка четности веса арбуза</h4>
    <p>Для решения задачи необходимо определить, можно ли разделить арбуз весом w килограмм на две части, каждая из которых будет весить четное количество килограмм.</p>
    <p>Для этого нужно проверить 2 условия. w должно быть четным числом, так как сумма двух четных чисел всегда четная. w должно быть больше или равно 4, так как минимальный вес каждой части должен быть 2 кг (наименьшее четное положительное число).</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int w;
  cin >> w;

  // решение и вывод результата
  if (w % 2 == 0 && w >= 4) {
    cout &lt;&lt; "YES";
  } else {
    cout &lt;&lt; "NO";
  }
}
</pre>
  </details>

  <p>После 2020 года можно писать <strong>and</strong> вместо <strong>&&</strong></p>
  <p>Если в функции int main() не написан return, то компилятор сам добавит return 0; в конце</p>

  <details>
    <summary>Решение на Node.js</summary>
<pre>
const readline = require('readline');
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

rl.on('line', (input) => {
  const w = parseInt(input);

  if (w % 2 === 0 && w >= 4) {
    console.log("YES");
  } else {
    console.log("NO");
  }

  rl.close();
});
</pre>
  <p>Модуль readline используется для чтения данных из стандартного потока ввода (stdin). Создаётся интерфейс rl, который связывает stdin и stdout.</p>
  <p>Когда пользователь вводит данные и нажимает Enter, срабатывает событие line. Введённые данные передаются в функцию обратного вызова как строка.</p>
  <p>Введённая строка преобразуется в число с помощью parseInt.</p>
  <p>После обработки ввода интерфейс закрывается с помощью rl.close().</p>
  </details>
</article>


<!-- Задача C. Слоник -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Слоник</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Слоник решил сходить в гости к другу. Оказалось, что дом слоника находится в точке 0, а дом его друга в точке x (x > 0) координатной прямой. За один шаг слоник может переместиться на 1, 2, 3, 4 или 5 позиций вперед. Помогите ему определить, за какое минимальное количество шагов он может добраться додома друга</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных записано одно целое число x (1 ≤ x ≤ 1000000) - координата дома друга слоника</p>

  <h4>Выходные данные</h4>
  <p>Выведите минимальное количество шагов, которые необходимо сделать слонику, чтобы попасть из точки 0 в точку x</p>

  <h4>Пример 1</h4>
  <code>5</code>
  <code>1</code>

  <h4>Пример 2</h4>
  <code>12</code>
  <code>3</code>

  <details>
    <summary>Решение на C++</summary>
    <p>Чтобы минимизировать количество шагов, слоник должен делать максимально возможные шаги (т.е. шаги по 5 позиций). После этого, если останется расстояние, которое меньше 5, он сделает один дополнительный шаг.</p>
    <p>Выражение (x + 4) / 5 эквивалентно округлению вверх результата деления x на 5.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int x;
  cin >> x;

  // решение и вывод результата
  cout &lt;&lt; (x + 4) / 5;
}
</pre>
  </details>

  <details>
    <summary>Решение на Node.js</summary>
<pre>
const readline = require('readline');

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

rl.on('line', (input) => {
  const x = parseInt(input);

  const res = Math.floor((x + 4) / 5);
  console.log(res);

  rl.close();
});
</pre>
  </details>
</article>


<!-- Задача D. Честный тренер -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Честный тренер</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Перед вами стоит n спортсменов. Спортсмены пронумерованы от 1 до n слева направо. Про каждого спортсмена вы знаете его силу — спортсмен с номером i имеет силу sᵢ.</p>

  <p>Вы хотите разделить всех спортсменов на две команды. В каждой команде должен быть хотя бы один спортсмен, и каждый спортсмен должен быть ровно в одной команде.</p>

  <p>Вы хотите, чтобы самый сильный спортсмен из первой команды по силе как можно меньше отличался от самого слабого спортсмена из второй команды. Формально, вы хотите разделить спортсменов на две команды A и B так, чтобы величина |max(A) - min(B)| была как можно меньше, где max(A) — максимальная сила спортсмена из команды A, а min(B) — минимальная сила спортсмена из команды B.</p>

  <p>Например, если n=5 и силы спортсменов равны s=[3, 1, 2, 6, 4], то одно из возможных разделений на команды имеет вид:</p>
  <p>первая команда: A = [1, 2, 4],</p>
  <p>вторая команда: B = [3, 6].</p>
  <p>В этом случае величина |max(A) - min(B)| будет равна |4-3|=1. Этот пример иллюстрирует один из способов оптимального разбиения на две команды.</p>
  <p>Выведите минимальное значение |max(A) - min(B)|.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое число t (1 ≤ t ≤ 1000) — количество наборов тестовых данных в тесте. Далее записаны t наборов тестовых данных.</p>
  <p>Каждый набор состоит из двух строк. В первой строке содержится целое положительное число n (2 ≤ n ≤ 50) — количество спортсменов.</p>
  <p>В следующей строке содержится n положительных целых чисел s₁, s₂, ... , sₙ (1 ≤ sᵢ ≤ 1000), где sᵢ — это сила i-го спортсмена. Обратите внимание, что среди элементов массива s могут быть равные значения.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора тестовых данных выведите одно целое число — минимальное значение величины |max(A) - min(B)| при оптимальном разбиении всех спортсменов на команды. Каждый из спортсменов должен оказаться членом ровно одной из двух команд.</p>

  <h4>Пример 1</h4>
<pre>
5
5
3 1 2 6 4
6
2 1 3 2 4 3
4
7 9 3 1
2
1 1000
3
100 150 200
</pre>
<pre>
1
0
2
999
50
</pre>
  <p>Первый набор тестовых данных разобран в условии.</p>
  <p>Во втором наборе одно из оптимальных разбиений имеет вид A=[2, 1], B=[3, 2, 4, 3], поэтому ответ равен |2-2|=0.</p>

  <h4>Пример 2</h4>
<pre>
1
4
7 9 3 1
</pre>
  <code>2</code>

  <details>
    <summary>Решение</summary>
    <p>Из всех чисел нужно найти два числа с минимальной разницей. Если есть два одинаковых числа, то ответ будет 0, иначе ответом будет модуль разницы двух самых близких чисел</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;  // для INT_MAX

using namespace std;

int main() {
  // ввод данных
  int t;
  cin >> t;

  for (int test = 0; test &lt; t; test++) {
    int n;
    cin >> n;
    vector&lt;int&gt; A(n);
    for (int i = 0; i &lt; n; i++) {
      cin >> A[i];
    }

    // Проверка на дубликаты
    vector&lt;int&gt; B(1001, 0);
    bool has_duplicate = false;
    for (int i = 0; i &lt; n; i++) {
      if (B[A[i]]) {
        has_duplicate = true;
        break;
      } else {
        B[A[i]] = 1;
      }
    }

    if (has_duplicate) {
      cout &lt;&lt; 0 &lt;&lt; '\n';
      continue;  // Переходим к следующему тестовому случаю
    }

    // Поиск минимальной разницы
    // Сортируем массив для поиска минимальной разницы
    sort(A.begin(), A.end());
    int min_dif = INT_MAX;
    for (int i = 1; i &lt; n; i++) {
      min_dif = min(min_dif, A[i] - A[i - 1]);
    }

    // Вывод результата
    cout &lt;&lt; min_dif &lt;&lt; '\n';
  }

  return 0;
}
</pre>
  </details>
</article>


<!-- Задача E. Переключение гравитации -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Переключение гравитации</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Маленький Крис скучает на занятиях по физике (слишком просто), поэтому он смастерил необычную коробку для игрушек, чтобы занять себя. Необычность коробки заключается в том, что она может изменять гравитацию!</p>
  <p>В коробке находятся n столбиков игрушечных кубиков, расположенных в ряд: i-й столбик состоит из aᵢ кубиков. Изначально гравитация в коробке тянет все кубики вниз. Когда Крис переключает гравитацию, она начинает тянуть все кубики к правой стенке коробки. Рисунок показывает начальное и конечное расположение кубиков в коробке: кубики, изменившие свои позиции, выделены оранжевым цветом.</p>
<pre>
#          #
## # ->  ###
####    ####
</pre>
  <p>Вам дано изначальное расположение игрушечных кубиков в коробке. Найдите количество кубиков в каждом из n столбиков после переключения гравитации!</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных записано целое число n (1 ≤ n ≤ 100), количество столбиков в коробке. В следующей строке записано n целых чисел через пробел: i-е число aᵢ (1 ≤ aᵢ ≤ 100) обозначает количество кубиков в i-м столбике.</p>

  <h4>Выходные данные</h4>
  <p>Выведите n целых чисел через пробел: i-е число должно обозначать количество кубиков в i-м столбике после переключения гравитации.</p>

  <h4>Пример 1</h4>
<pre>
4
3 2 1 2
</pre>
  <code>1 2 2 3</code>
  <p>Первый тестовый пример изображен на рисунке. Верхний кубик первого столбика падает на верх последнего столбика; верхний кубик второго столбика падает на верх третьего столбика; средний кубик первого столбика падает на верх второго столбика.</p>

  <h4>Пример 2</h4>
<pre>
3
2 3 8
</pre>
  <code>2 3 8</code>
<pre>
  #      #
  #      #
  #      #
  # ->   #
  #      #
 ##     ##
###    ###
###    ###
</pre>
  <p>Во втором тестовом примере переключение гравитации не меняет высоты столбиков.</p>

  <details>
    <summary>Решение</summary>
    <p>Поскольку гравитация переключается вправо, то есть кубики падают на правую стенку, то достаточно входной массив отсортировать по возрастанию.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // входные данные
  int n;
  cin >> n;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  sort(A.begin(), A.end());

  // вывод результата
  for (int i = 0; i &lt; n; i++) {
    cout &lt;&lt; A[i] &lt;&lt; ' ';
  }
}
</pre>
  </details>
</article>


<!-- Задача F. Формирование команд -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Формирование команд</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В университете учатся n студентов. Количество студентов четно. Умение i-го студента программировать равно aᵢ.</p>
  <p>Тренер хочет сформировать n/2 команд. Каждая команда должна состоять ровно из двух студентов, а каждый студент должен принадлежать ровно одной команде. Два студента могут сформировать команду только тогда, когда их умение программировать одинаково (иначе они не смогут понять друг друга и не смогут сформировать команду).</p>
  <p>Студенты могут решать задачи, чтобы улучшать их умение программировать. Одна решенная задача увеличивает умение программировать на один.</p>
  <p>Тренер хочет знать, какое минимальное количество задач студентам необходимо решить, чтобы сформировать ровно n/2
  команд (то есть каждая пара студентов должна формировать команду). Ваша задача — найти это количество.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит одно целое число n (2 ≤ n ≤ 100) — количество студентов. Гарантируется, что n всегда является четным числом.</p>
  <p>Вторая строка входных данных содержит n целых чисел a₁, a₂, ... , aₙ (1 ≤ aᵢ ≤ 100), где aᵢ равно умению i-го студента программировать.</p>

 <h4>Выходные данные</h4>
  <p>Выведите одно целое число — минимальное количество задач, которое необходимо решить студентам, чтобы сформировать ровно n/2
  команд.</p>

  <h4>Пример 1</h4>
<pre>
6
5 10 2 3 14 5
</pre>
  <code>5</code>
  <p>В первом тестовом примере оптимальными будут команды: (3,4), (1,6) и (2,5), где числа в скобках являются номерами студентов. Тогда для того, чтобы сформировать первую команду, третий студент должен решить 1 задачу, чтобы сформировать вторую команду, никто не должен решать задачи, и чтобы сформировать третью команду, второй студент должен решить 4 задачи, таким образом ответ равен 1+4=5.</p>

  <h4>Пример 2</h4>
<pre>
2
1 100
</pre>
  <code>99</code>
  <p>Во втором тестовом примере первый студент должен решить 99 задач, чтобы сформировать команду со вторым.</p>

  <details>
    <summary>Решение</summary>
    <p>Нужно отсортировать входной массив и объединять соседние элементы в одну команду. Разница между соседними элементами это количество задач, которые необходимо решить, чтобы попасть в команду.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  int n;
  cin >> n;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }
  sort(A.begin(), A.end());
  int res = 0;
  for (int i = 0; i &lt; n; i += 2) {
    res += A[i + 1] - A[i];
  }
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача G. Задача о делимости -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Задача о делимости</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам даны два целых положительных числа a и b. За один ход вы можете увеличить a на 1 (заменить a на a+1). Ваша задача — найти минимальное количество ходов, которое необходимо сделать, чтобы получить значение a, которое делится на b без остатка. Возможно, вам придётся сделать 0
  ходов, так как a уже делится на b.</p>
  <p>Вам нужно ответить на t независимых наборов входных данных.</p>

  <h4>Входные данные</h4>
  <p>Первая строка теста содержит одно целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных. Затем следуют t наборов входных данных. Единственная строка каждого набора содержит два целых числа a
  и b (1 ≤ a, b ≤ 10⁹).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите ответ — минимальное количество ходов, которое нужно сделать, чтобы получить значение a, которое без остатка делилось бы на b.</p>

  <h4>Пример</h4>
<pre>
5
10 4
13 9
100 13
123 456
92 46
</pre>
<pre>
2
5
4
333
0
</pre>

  <details>
    <summary>Решение</summary>
    <p>Если a делится на b без остатка то выводим 0. Если есть остаток от деления, то его нужно вычесть из b чтобы получить результат</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // входные данные
  int t;
  cin >> t;

  while (t--) {
    int a, b;
    cin >> a >> b;

    // решение
    int res = 0;
    if (a % b) {
      res = b - (a % b);
    }

    // вывод результата
    cout &lt;&lt; res &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача H. Четный массив -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Четный массив</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам дан массив a[0…n-1] длины n, который состоит из неотрицательных целых чисел. Обратите внимание: массив нумеруется с нуля.</p>
  <p>Назовём массив хорошим, если четность каждой позиции совпадает с четностью элемента в ней. Более формально, массив является хорошим, если для всех i (0 ≤ i ≤ n-1) выполнено равенство i mod 2 = a[i] mod 2, где x mod 2 — остаток от деления x на 2.</p>
  <p>Например, массивы [0,5,2,1] и [0,17,0,3] — хорошие, а массив [2,4,6,7] — плохой, потому что для i=1 четность i и a[i] различна: i mod 2 = 1 mod 2 = 1, но a [i] mod2 = 4 mod 2 = 0.</p>
  <p>За один ход вы можете взять любые два элемента массива и поменять их местами (эти элементы не обязательно соседние).</p>
  <p>Найдите минимальное количество ходов, за которое можно сделать массив a хорошим, либо укажите, что это сделать невозможно.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано одно целое число t (1 ≤ t ≤ 1000) — количество наборов тестовых данных в тесте. Далее следуют t наборов тестовых данных.</p>
  <p>Каждый набор начинается со строки, в которой записано целое число n (1 ≤ n ≤ 40) — размер массива a.</p>
  <p>Далее следует строка, содержащая n целых чисел a₀, a₁, ... , aₙ₋₁ (0 ≤ aᵢ ≤ 1000) — исходный массив.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора тестовых данных выведите одно целое число — минимальное количество ходов, за которое можно сделать заданный массив a
  хорошим, или -1, если это сделать невозможно.</p>

  <h4>Пример</h4>
<pre>
4
4
3 2 7 6
3
3 2 6
1
7
7
4 9 2 1 18 3 0
</pre>
<pre>
2
1
-1
0
</pre>
  <p>В первом наборе тестовых данных в первый ход можно поменять местами элементы на позициях 0 и 1, а во второй ход поменять местами элементы на позициях 2 и 3.</p>
  <p>Во втором наборе тестовых данных в первый ход надо поменять местами элементы на позициях 0 и 1.</p>
  <p>В третьем наборе тестовых данных нельзя сделать массив хорошим.</p>

  <details>
    <summary>Решение</summary>
    <p>Массив можно сделать хорошим если число четных элементов на нечетных местах равно числу нечетных элементов на четных местах в массиве. Надо вернуть это число (четных элементов на нечентных местах) Иначе массив сделать хорошим нельзя и мы возвращаем -1.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // входные данные
    int n;
    cin >> n;
    vector&lt;int&gt; A(n);
    int even = 0; // четный
    int odd = 0;  // нечетный

    for (int i = 0; i &lt; A.size(); i++) {
      int tmp;
      cin >> tmp;
      A[i] = tmp;

      // решение
      if (i % 2) {
        if (!(A[i] % 2)) {
          even++;
        }
      } else {
        if (A[i] % 2) {
          odd++;
        }
      }
    }

    // вывод результата
    if (even == odd) {
      cout &lt;&lt; even &lt;&lt; '\n';
    } else {
      cout &lt;&lt; "-1\n";
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача I. Сумма круглых чисел -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача I. Сумма круглых чисел</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Положительное целое число называется круглым, если оно имеет вид d00...0. Иными словами, положительное целое число является круглым, если все его цифры, кроме самой левой (старшей), равны нулю. В частности, все числа от 1 до 9 (включительно) являются круглыми.</p>
  <p>Например, следующие числа являются круглыми: 4000, 1, 9, 800, 90. Например, следующие числа не являются круглыми: 110, 707, 222, 1001.</p>
  <p>Вам задано целое положительное число n (1 ≤ n ≤ 10⁴). Представьте число n как сумму круглых чисел, используя минимальное количество слагаемых. Иными словами, вам надо разложить заданное число n
  в сумму наименьшего количества слагаемых, каждое из которых является круглым числом.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных в тесте. Далее следуют t наборов входных данных.</p>
  <p>Каждый набор представляет собой строку, в которой записано целое число n (1 ≤ n ≤ 10⁴).</p>

  <h4>Выходные данные</h4>
  <p>Выведите t ответов на наборы входных данных. Каждый ответ должен начинаться с целого числа k — минимального количества слагаемых. Далее должны следовать k слагаемых, каждое из которых является круглым числом, а их сумма равна n. Слагаемые можно выводить в любом порядке. Если ответов несколько, то выведите любой из них.</p>

  <h4>Пример</h4>
<pre>
5
5009
7
9876
10000
10
</pre>
<pre>
2
5000 9
1
7
4
800 70 6 9000
1
10000
1
10
</pre>

  <details>
    <summary>Решение</summary>
    <p>Максимально возможное входное число содержит 5 цифр, поэтому для отевта заведем массив на 5 элементов. Если остаток от деления на 10 равен нулю, то увеличиваем счетчик нулей на 1, иначе записываем в массив остаток от деления с числом нулей из счетчика нулей, увеличиваем число нулей на 1 и число чисел в ответе на 1.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;

using namespace std;

int main() {
  // входные данные
  int t;
  cin >> t;

  while (t--) {
    int n;
    cin >> n;

    // решение
    int count = 0;  // число чисел в ответе
    int zeroes = 0; // число нулей в следующем числе
    int next = 0;   // следующее число
    vector&lt;int&gt; A(5, 0);
    while (n) {
      if (n % 10 == 0) {
        zeroes++;
      } else {
        next = (n % 10) * (int)pow(10, zeroes);
        A[count] = next;
        count++;
        zeroes++;
      }
      n /= 10;
    }

    // вывод результата
    cout &lt;&lt; count &lt;&lt; '\n';
    for (int i = 0; i &lt; count; i++) {
      cout &lt;&lt; A[i] &lt;&lt; " ";
    }
    cout &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача J. Скучные квартиры -->
<article class="article">
  <div class="anchor" id="task10"></div>
  <h3>Задача J. Скучные квартиры</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Есть дом, в котором расположены 10 000 квартир, пронумерованных от 1 до 10 000.</p>
  <p>Назовем номер квартиры скучным, если ее номер состоит из одинаковых цифр. Примерами скучных квартир являются 11,2,777,9999 и так далее.</p>
  <p>Наш герой очень наглый и он любит звонить в домофоны всех скучных квартир до тех пор, пока кто-то не ответит, в следующем порядке:</p>
  <ol>
    <li>сначала он обзванивает квартиры, состоящие из цифр 1, в возрастающем порядке (1,11,111,1111);</li>
    <li>затем он обзванивает квартиры, состоящие из цифр 2, в возрастающем порядке (2,22,222,2222);</li>
    <li>и так далее.</li>
  </ol>
  <p>Житель скучной квартиры x ответил на звонок. После этого наш герой перестал обзванивать кого-либо еще.</p>
  <p>Наш герой хочет знать, как много цифр он суммарно нажал. Ваша задача — помочь посчитать ему суммарное количество нажатых клавиш.</p>
  <p>Например, если житель квартиры 22 ответил, то наш герой звонил в квартиры с номерами 1,11,111,1111,2,22. Таким образом, суммарное количество нажатий равно 1+2+3+4+1+2=13.</p>
  <p>Вам нужно ответить на t независимых наборов тестовых данных.</p>

  <h4>Входные данные</h4>
  <p>Первая строка теста содержит одно целое число t (1 ≤ t ≤ 36) — количество наборов тестовых данных.</p>
  <p>Единственная строка набора тестовых данных содержит одно целое число x (1 ≤ x ≤ 9999) — номер квартиры, житель которой ответил на звонок. Гарантируется, что x состоит из одинаковых цифр.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора тестовых данных выведите ответ на него: как много цифр суммарно нажал наш герой.</p>

  <h4>Пример</h4>
<pre>
4
22
9999
1
777
</pre>
<pre>
13
90
1
66
</pre>

  <details>
    <summary>Решение</summary>
    <p>Определяем последнюю цифру dig и количество цифр cnt в номере ответившей квартиры. Значит в 4 квартиры каждой предыдущей цифры уже звонили. Сумма цифр в этих 4 кварирах равна 1 + 2 + 3 + 4 = 10. Прибавим к этому цифры от 1 до cnt.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // входные данные
  int t;
  cin >> t;
  while (t--) {
    int n;
    cin >> n;

    // решение
    int res = 0;
    int dig = n % 10; // цифра в номере
    int cnt = 0;      // количество цифр в номере
    while (n) {
      n /= 10;
      cnt++;
    }

    for (int i = 1; i &lt; dig; i++) {
      res += 10;
    }
    for (int i = 1; i &lt;= cnt; i++) {
      res += i;
    }

    // вывод результата
    cout &lt;&lt; res &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача K. Точки на прямой -->
<article class="article">
  <div class="anchor" id="task11"></div>
  <h3>Задача K. Точки на прямой</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Назовём диаметром мультимножества точек на прямой максимальное расстояние между двумя точками этого множества. Например, диаметр мультимножества {1, 3, 2, 1} равен 2.</p>
  <p>Диаметр мультимножества, состоящего из одной точки, равен 0.</p>
  <p>Даны n точек на прямой. Какое минимальное число точек необходимо убрать, чтобы диаметр мультимножества оставшихся точек не превосходил d?</p>

  <h4>Входные данные</h4>
  <p>В первой строке заданы два целых числа n и d (1 ≤ n ≤ 100, 0 ≤ d ≤ 100) — количество точек и ограничение на диаметр, соответственно.</p>
  <p>Во второй строке через пробел заданы n целых чисел (1 ≤ xᵢ ≤ 100) — координаты точек.</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно целое число — минимальное количество удалённых точек.</p>

  <h4>Пример 1</h4>
<pre>
3 1
2 1 4
</pre>
  <code>1</code>
  <p>В первом тестовом примере выгодно удалить точку с координатой 4. Оставшиеся точки будут иметь координаты 1 и 2, поэтому диаметр оставшегося мультимножества будет равен 2 - 1 = 1.</p>

  <h4>Пример 2</h4>
<pre>
3 0
7 7 7
</pre>
  <code>0</code>
  <p>Во втором тестовом примере диаметр равен 0, поэтому удалять точки не потребуется.</p>

  <h4>Пример 3</h4>
<pre>
6 3
1 3 4 6 9 10
</pre>
  <code>3</code>
  <p>В третьем тестовом примере выгодно удалить точки с координатами 1, 9 и 10. Оставшиеся точки будут иметь координаты 3, 4 и 6, поэтому диаметр будет равен 6 - 3 = 3.</p>

  <details>
    <summary>Решение</summary>
    <p>Нужно отсортировать координаты точек, проверить расстояние между каждыми двумя точками. Это цикл в цикле. Выбрать максимальное расстояние, меньшее или равно заданному диаметру. </p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;

using namespace std;

int main() {
  // ввод данных
  int n, d;
  cin >> n >> d;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  sort(A.begin(), A.end());
  int res = 0;
  for (int i = 0; i &lt; n; i++) {
    for (int j = i; j &lt; n; j++) {
      if (A[j] - A[i] &lt;= d) {
        res = max(res, j - i + 1);
      }
    }
  }

  // вывод результата
  cout &lt;&lt; n - res;
}
</pre>
  </details>
</article>


<!-- Задача L. Смена направления -->
<article class="article">
  <div class="anchor" id="task12"></div>
  <h3>Задача L. Смена направления</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Дана сетка, состоящая из n строк и m столбцов. Строки и столбцы пронумерованы от 1 до n и от 1 до m соответственно. Пересечение a-й строки и b-го столбца обозначим за (a,b).</p>
  <p>Изначально вы находитесь в верхнем левом углу (1,1). Ваша цель — добраться до нижнего правого угла (n,m)</p>
  <p>Из клетки (a,b) вы можете двигаться в четырех направлениях: вверх в клетку (a-1,b), вниз в (a+1,b), влево в (a,b-1) или вправо в (a,b+1)</p>
  <p>Вам запрещается двигаться в одном направлении дважды подряд, вы не можете покидать пределы сетки. За какое минимальное количество шагов можно добраться до (n,m)?</p>

  <h4>Входные данные</h4>
  <p>Каждый тест состоит из нескольких наборов входных данных. Первая строка содержит одно целое число t (1 ≤ t ≤ 10³) — количество наборов входных данных. Далее следует описание наборов входных данных.</p>
  <p>Первая строка каждого набора содержит два целых числа n и m (1 ≤ n, m ≤ 10⁹) — размер сетки.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно целое число: -1, если нельзя добраться до (n,m) при заданных ограничениях, в ином случае — минимальное количество шагов.</p>

  <h4>Пример</h4>
<pre>
6
1 1
2 1
1 3
4 2
4 6
10 5
</pre>
<pre>
0
1
-1
6
10
17
</pre>
  <p>1-й набор входных данных: n=1, m=1, изначально вы находитесь в (1,1), поэтому 0 шагов необходимо, чтобы добраться до (n,m)=(1,1).</p>
  <p>2-й набор: нужно сделать один шаг вниз, чтобы достичь (2,1).</p>
  <p>3-й набор: невозможно достичь (1,3), не сделав подряд два шага вправо или не покидая пределы сетки.</p>
  <p>4-й набор: оптимальная последовательность шагов выглядит например так: (1,1)→(1,2)→(2,2)→(2,1)→(3,1)→(3,2)→(4,2). Можно доказать, что это оптимальное решение. Таким образом, ответ равен 6.</p>

  <details>
    <summary>Решение</summary>
    <p>Из двуx сторон n и m определяем длинную сторону. Меняем n и m так, чтобы в n была длинная сторона. Если короткая сторона 1, а длинная больше 2 то решения нет, возвращаем -1.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;cmath&gt;

using namespace std;

int main() {
  // входные данные
  int t;
  cin >> t;
  while (t--) {
    int n, m;
    cin >> n >> m;

    // решение
    if (m > n) {
      int tmp = n;
      n = m;
      m = tmp;
    }

    if ((m == 1) && (n > 2)) {
      cout &lt;&lt; "-1\n";
      continue;  // переходим к следующему тесту
    }

    int res = 0;
    if ((n - m) % 2 == 0) {
      res = (m - 1) * 2 + (n - m) * 2;
    } else {
      res = (m - 1) * 2 + (n - m) * 2 - 1;
    }

    // вывод результата
    cout &lt;&lt; res &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача M. Виталий и ночь -->
<article class="article">
  <div class="anchor" id="task13"></div>
  <h3>Задача M. Виталий и ночь</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Как-то раз Виталий возвращался домой поздно ночью и заинтересовался вопросом: а сколько ещё людей не спит в это время? Для этого Виталий решил посмотреть, какие окна горят в доме, мимо которого он в этот момент проходил.</p>
  <p>Виталий видит перед собой n-этажный дом и 2·m окон на каждом этаже. Согласно планировке, на каждом этаже располагается m квартир, пронумерованных от 1 до m, и каждой из них принадлежит два последовательных окна на данном этаже. Если пронумеровать окна от 1 до 2·m слева направо, то j-й квартире i-го этажа принадлежат окна 2·j - 1 и 2·j в соответствующем ряду окон. Виталий считает, что люди в квартире не спят, если хотя бы в одном из окон этой квартиры горит свет.</p>
  <p>Используя информацию о свете в окнах данного дома, вы должны посчитать количество квартир, в которых, по мнению Виталия, жители не спят.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных следует два целых числа n и m (1 ≤ n, m ≤ 100) — количество этажей в доме и количество квартир на каждом этаже соответственно.</p>
  <p>Следующие n строк описывают этажы сверху вниз и содержат по 2·m символов каждая. Если в i-м окне данного этажа горит свет, то в i-й позиции находится символ '1', иначе там находится символ '0'.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственно целое число — количество квартир, в которых горит свет хотя бы в одном окне, то есть, по мнению Виталия, там кто-то не спит.</p>

  <h4>Пример 1</h4>
<pre>
2 2
0 0 0 1
1 0 1 1
</pre>
  <code>3</code>
  <p>В первом тестовом примере дом двухэтажный, по две квартиры на каждом этаже, то есть всего в нем 4 квартиры. Свет не горит только на втором этаже в левой квартире, так как в обеих комнатах этой квартиры свет выключен.</p>

  <h4>Пример 2</h4>
<pre>
1 3
1 1 0 1 0 0
</pre>
  <code>2</code>
  <p>Во втором тестовом примере дом одноэтажный, и на первом этаже есть три квартиры. Свет горит в самой левой квартире (в обоих окнах) и в средней квартире (в одном окне). В правой же квартире свет не горит.</p>

  <details>
    <summary>Решение</summary>
    <p>К нам приходят два числа. n это число этажей, m это число квартир на этаже. В каждой квартире 2 соседних окна. Всего квартир в доме n * m. Мы можем принимать в цикле по два числа и проверять если одно из них равно 1 то в этой квартире горит свет и значит там не спят.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // входные данные
  int n, m;
  cin >> n >> m;
  int w = n * m; // количесвто квартир в доме
  int res = 0, w1 = 0, w2 = 0;
  for (int i = 1; i &lt;= w; i++) {
    cin >> w1; // свет в 1 окне
    cin >> w2; // свет в 2 окне

    // решение
    if (w1 || w2) {
      res++;
    }
  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача N. Николай и перестановка -->
<article class="article">
  <div class="anchor" id="task14"></div>
  <h3>Задача N. Николай и перестановка</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У Николая есть массив a, состоящий из n различных целых чисел от 1 до n. Другими словами, массив Николая — это перестановка целых чисел от 1 до n.</p>
  <p>Николай решил, что будет лучше, если минимальный элемент его массива (то есть число 1) и максимальный элемент его массива (то есть число n) будут находиться как можно дальше друг от друга. Поэтому он решил ровно один раз поменять местами два каких-нибудь элемента таким образом, чтобы расстояние между минимальным и максимальным элементами стало максимально возможным. Расстоянием между двумя элементами называется модуль разности номеров позиций данных элементов.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных следует целое положительное число n (2 ≤ n ≤ 100) — количество элементов в массиве Николая.</p>
  <p>Во второй строке входных данных записаны различные целые числа a₁, a₂, ... , aₙ (1 ≤ aᵢ ≤ n), где aᵢ равно элементу, который находится в i-й позиции в массиве Николая.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное целое число — максимальное расстояние между минимальным и максимальным элементами в массиве Николая, которое может быть получено с помощью ровно одного обмена местами двух элементов массива.</p>

  <h4>Пример 1</h4>
<pre>
5
4 5 1 3 2
</pre>
  <code>3</code>
  <p>В первом примере оптимального ответа можно добиться поменяв местами 1 и 2.</p>

  <h4>Пример 2</h4>
<pre>
7
1 6 5 3 4 7 2
</pre>
  <code>6</code>
  <p>Во втором примере минимальный и максимальный элементы будут находиться в разных концах массива, если поменять местами 7 и 2.</p>

  <h4>Пример 3</h4>
<pre>
6
6 5 4 3 2 1
</pre>
  <code>5</code>
  <p>В третьем примере расстояние между минимальным и максимальным элементов уже максимально возможное, поэтому нужно сделать какой-нибудь ничего не значащий обмен, например 5 и 2.</p>

  <details>
    <summary>Решение</summary>
    <p>Найти индексы минимального и максимального элемента. Выбрать индекс ближайший краю. Найти максимум от индекса до края.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // входные данные
  int n;
  cin >> n;
  int a[100];
  int mini; // индекс минимума
  int maxi; // индекс максимума

  for (int i = 1; i &lt;= n; i++) {
    cin >> a[i];
    if (a[i] == 1) {
      mini = i;
    }
    if (a[i] == n) {
      maxi = i;
    }
  }

  int mind; // от минимума до края
  int maxd; // от максимума от края
  mind = min(mini - 1, n - mini);
  maxd = min(maxi - 1, n - maxi);

  int res = 0;
  res = n - min(mind, maxd) - 1;
  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача O. X-сумма -->
<article class="article">
  <div class="anchor" id="task15"></div>
  <h3>Задача O. X-сумма</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Дедушка Тимура подарил ему шахматную доску, чтобы он попрактиковался. Эта доска a состоит из n строк и m столбцов. На каждой клетке написано неотрицательное целое число.</p>
  <p>Задача Тимура поставить слона так, чтобы сумма на клетках, атакованных им, была максимальна. Слон атакует во всех направлениях по диагонали. Расстояние, на которое атакует слон, не ограничено. Обратите внимание, что клетка, в которой стоит слон, также считается атакованной. Помогите ему найти максимальную сумму, которую он может получить.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит число t (1 ≤ t ≤ 1000) — количество наборов входных данных в тесте. Далее следуют описания самих наборов.</p>
  <p>Первая строка каждого набора содержит два числа n и m (1 ≤ n ≤ 200, 1 ≤ m ≤ 200).</p>
  <p>Следующие n строк содержат по m целых чисел, j-й элемент i-й строки a<sub>ij</sub> — это число, записанное в j-й клетке i-й строки (0 ≤ a<sub>ij</sub> ≤ 10⁶)</p>
 <p>Гарантируется, что сумма n⋅m по всем наборам не превосходит 4⋅10⁴.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно число — максимальную сумму по всем возможным размещениям слона.</p>

  <h4>Пример</h4>
<pre>
4
4 4
1 2 2 1
2 4 2 4
2 2 3 1
2 4 2 4
2 1
1
0
3 3
1 1 1
1 1 1
1 1 1
3 3
0 1 1
1 0 1
1 1 0
</pre>
<pre>
20
1
5
3
</pre>

  <details>
    <summary>Решение</summary>
    <p>Создадим массив B размером такой же как входной массив A. В клетку B[i] будем записывать сумму из клеток массива A на диагоналях которой она находится.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // входные данные
  int t;
  cin >> t;

  while (t--) {
    int n, m;
    cin >> n >> m;

    vector&lt;vector&lt;int&gt; &gt; A(n, vector&lt;int&gt;(m));
    for (int i = 0; i &lt; n; i++) {
      for (int j = 0; j &lt; m; j++) {
        cin >> A[i][j];
      }
    }

  // решение
    vector&lt;vector&lt;int&gt; &gt; B(n, vector&lt;int&gt;(m));
    // смещение на одну клетку
    int x = 1;
    int res = 0;
    for (int i = 0; i &lt; n; i++) {
      for (int j = 0; j &lt; m; j++) {
        int sum = A[i][j];
        // влево вверх
        x = 1;
        while ((i - x >= 0) && (j - x >= 0)) {
          sum += A[i - x][j - x];
          x++;
        }
        // вправо вверх
        x = 1;
        while ((i - x >= 0) && (j + x &lt; m)) {
          sum += A[i - x][j + x];
          x++;
        }
        // вправо вниз
        x = 1;
        while ((i + x &lt; n) && (j + x &lt; m)) {
          sum += A[i + x][j + x];
          x++;
        }
        // влево вниз
        x = 1;
        while ((i + x &lt; n) && (j - x >= 0)) {
          sum += A[i + x][j - x];
          x++;
        }
        B[i][j] = sum;
        res = max(res, B[i][j]);
      }
    }

  // вывод результата
  cout &lt;&lt; res &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>

