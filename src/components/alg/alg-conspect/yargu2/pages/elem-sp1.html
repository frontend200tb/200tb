<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p>ЯрГУ. Кружок. Студенты 2023/2024</p>
  <p><a href="https://vkvideo.ru/@yaracm" target="_blank">vkvideo.ru/@yaracm</a></p>
  <p>Автор кружка Игорь Маслеников</p>
</article>


<article class="article">
  <h1>Занятие 1. Основы C++ 1. Вводное занятие</h1>
  <p>Конспект видео</p>
  <p><a href="https://codeforces.com/group/w0J26SHHez/contest/341865" target="_blank">Codeforces Контест 341865</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
    <a href="#p1">Основы C++ 1. Вводное занятие</a>
  </p>
  <p>
        <a href="#task1">Задача A. A+B (пробная задача)</a>
    <br><a href="#task2">Задача B. Осьминожки</a>
    <br><a href="#task3">Задача C. Високосный год</a>
    <br><a href="#task4">Задача D. Театральная площадь</a>
    <br><a href="#task5">Задача E. Петины братья</a>
    <br><a href="#task6">Задача F. Куплю лопату</a>
    <br><a href="#task7">Задача G. Кормен — лучший друг человека</a>
    <br><a href="#task8">Задача H. Санаторий</a>
    <br><a href="#task9">Задача I. Экзамены</a>
    <br><a href="#task10">Задача J. Кузнечик и строка</a>
    <br><a href="#task11">Задача K. Парад</a>
    <br><a href="#task12">Задача L. Деление пиццы</a>
    <br><a href="#task13">Задача M. Тренировки</a>
  </p>
</article>


<!-- Основы C++ 1. Вводное занятие -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Основы C++ 1. Вводное занятие</h3>

</article>


<!-- Задача A. A+B (пробная задача) -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. A+B (пробная задача)</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Заданы два целых числа a и b. Выведите a+b</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных в тесте. Далее следуют t наборов входных данных. Каждый набор задан одной строкой, которая содержит два целых числа a, b (-1000 ≤ a, b ≤ 1000).</p>

  <h4>Выходные данные</h4>
  <p>Выведите t целых чисел — искомые суммы a + b для каждого набора входных данных.</p>

  <h4>Пример</h4>
<pre>
4
1 5
314 15
-99 99
123 987
</pre>
<pre>
6
329
0
1110
</pre>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int t;
  cin >> t;

  for (int test = 0; test &lt; t; test++) {
    int a, b;
    cin >> a >> b;

    // вывод результата
    cout &lt;&lt; a + b &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача B. Осьминожки -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Осьминожки</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>У осьминогов каждый год вырастает K щупальцев. Сколько у него будет щупальцев через N лет, если при рождении их у него было A?</p>

  <h4>Входные данные</h4>
  <p>Вводится три числа K, N и A.</p>

  <h4>Выходные данные</h4>
  <p>Вывести ответ на задачу.</p>

  <h4>Пример 1</h4>
  <code>1 2 3</code>
  <code>5</code>

  <h4>Пример 2</h4>
  <code>3 2 1</code>
  <code>7</code>

  <details>
    <summary>Решение</summary>
    <p>Через N лет количество щупальцев будет равно A + K * N</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int k, n, a;
  cin >> k >> n >> a;

  // решение и вывод результата
  cout &lt;&lt; a + k * n;
}
</pre>
  </details>
</article>


<!-- Задача C. Високосный год -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Високосный год</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Требуется определить является ли год високосным. Високосным год называется, если он делится на 4 и при этом не делится на 100, или делится на 400.</p>

  <h4>Входные данные</h4>
  <p>Вводится одно число - исследуемый год (целое неотрицательное число до 2012).</p>

  <h4>Выходные данные</h4>
  <p>Вывести "Yes", если год является високосным, и "No" иначе</p>

  <h4>Пример 1</h4>
  <code>1900</code>
  <code>No</code>

  <h4>Пример 2</h4>
  <code>2000</code>
  <code>Yes</code>

  <details>
    <summary>Решение</summary>
    <h4>Идея решения:</h4>
    <ol>
      <li>Проверить, делится ли год на 4.</li>
      <li>Если год делится на 100, проверить, делится ли он на 400.</li>
      <li>Если год делится на 4 и не делится на 100, или делится на 400, то он високосный.</li>
    </ol>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int year;
  cin >> year;

  // решение и вывод результата
  bool mod4 = year % 4 == 0;
  bool mod100 = year % 100 == 0;
  bool mod400 = year % 400 == 0;
  if (mod4 && !mod100 || mod400) {
    cout &lt;&lt; "Yes";
  } else {
    cout &lt;&lt; "No";
  }

  return 0;
}
</pre>
  </details>
</article>


<!-- Задача D. Театральная площадь -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Театральная площадь</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Театральная площадь в столице Берляндии представляет собой прямоугольник n x m метров. По случаю очередного юбилея города, было принято решение о замощении площади квадратными гранитными плитами. Каждая плита имеет размер a x a.</p>

  <p>Какое наименьшее количество плит понадобится для замощения площади? Разрешено покрыть плитами большую поверхность, чем театральная площадь, но она должна быть покрыта обязательно. Гранитные плиты нельзя ломать или дробить, а разрешено использовать только целиком. Границы плит должны быть параллельны границам площади.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано три целых натуральных числа n, m и a (1 ≤ n, m, a ≤ 10⁹).</p>

  <h4>Выходные данные</h4>
  <p>Выведите искомое количество плит.</p>

  <h4>Пример</h4>
  <code>6 6 4</code>
  <code>4</code>

  <details>
    <summary>Решение</summary>
    <h4>Идея решения:</h4>
    <ol>
      <li>Чтобы покрыть длину n нужно n/a плит с округлением вверх</li>
      <li>Чтобы покрыть ширину m нужно m/a плит с округлением вверх</li>
      <li>Общее количество плит будет равно произведению количества плит по длине и ширине: (n/a) * (m/a) </li>
      <li>Округление вверх можно реализовать с помощью формулы: x/y = (x+y-1) / y</li>
    </ol>

<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  long long n, m, a;
  cin >> n >> m >> a;

  // решение
  // Вычисляем количество плит по длине и ширине с округлением вверх
  long long tilesN = (n + a - 1) / a;
  long long tilesM = (m + a - 1) / a;

  // вывод результата
  cout &lt;&lt; tilesN + tilesM;
}
</pre>
  </details>
</article>


<!-- Задача E. Петины братья -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Петины братья</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>У Пети есть N братьев. Петя не знает сколько лет старшему брату и сколько лет младшему. Помогите Пете.</p>

  <h4>Входные данные</h4>
  <p>Вводится число N (1 ≤ N ≤ 100), затем вводится N чисел – возраст братьев (натуральные числа, не превосходящие 100).</p>

  <h4>Выходные данные</h4>
  <p>Вывести через пробел возраст старшего и младшего брата</p>

  <h4>Пример 1</h4>
<pre>
4
3 2 4 1
</pre>
  <code>4 1</code>

  <h4>Пример 2</h4>
<pre>
5
1 8 9 2 10
</pre>
  <code>10 1</code>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;

  // решение
  int age;
  cin >> age; // Считываем возраст первого брата
  int minAge = age; // Инициализируем минимальный возраст
  int maxAge = age; // Инициализируем максимальный возраст

  // Считываем возраст остальных братьев и обновляем minAge и maxAge
  for (int i = 1; i &lt; N; i++) {
      cin >> age;
      minAge = min(minAge, age); // Обновляем минимальный возраст
      maxAge = max(maxAge, age); // Обновляем максимальный возраст
  }

  // вывод результата
  cout &lt;&lt; maxAge &lt;&lt; " " &lt;&lt; minAge;

  return 0;
}
</pre>
  </details>
</article>


<!-- Задача F. Куплю лопату -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Куплю лопату</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Поликарпу срочно понадобилась лопата! Он пришёл в магазин и выбрал подходящую. Лопата, которая подошла Поликарпу, продается по цене k бурлей. Считайте, что в магазине неограниченное количество таких лопат.</p>

  <p>В кармане у Поликарпа есть неограниченное количество «дестюльников» (монет номиналом в 10 бурлей) и ровно одна монета номинала r (1 ≤ r ≤ 9).</p>

  <p>Какое наименьшее количество лопат придётся купить Поликарпу, чтобы он смог расплатиться за покупку без сдачи? Очевидно, что за 10 лопат он сможет расплатиться без сдачи (заплатив требуемую сумму «дестюльниками», не используя монету номинала r), но, возможно, он сможет купить меньшее количество лопат и расплатиться без сдачи. Обратите внимание, что Поликарп должен купить хотя бы одну лопату.</p>

  <h4>Входные данные</h4>
  <p>В единственной строке входных данных записаны два целых числа k и r (1 ≤ k ≤ 1000, 1 ≤ r ≤ 9) — цена одной лопаты и номинал монеты в кармане Поликарпа, отличной от «дестюльника».</p>

  <p>Помните, что ещё у него в кармане неограниченное количество монет номинала 10, то есть их хватит на покупку любого количества лопат.</p>

  <h4>Выходные данные</h4>
  <p>Выведите искомое минимальное количество лопат, которые нужно купить Поликарпу, чтобы расплатиться без сдачи.</p>

  <h4>Пример 1</h4>
  <code>117 3</code>
  <code>9</code>
  <p>В первом примере Поликарп может купить 9 лопат, заплатив 9·117 = 1053 бурлей. В самом деле, эту сумму он может заплатить используя монеты номиналом 10 бурлей и одну монету номиналом 3 бурля. Купить меньшее количество лопат (и при этом расплатиться без сдачи), он не может.</p>

  <h4>Пример 2</h4>
  <code>237 7</code>
  <code>1</code>
  <p>Во втором примере Поликарпу достаточно купить одну лопату.</p>

  <h4>Пример 3</h4>
  <code>15 2</code>
  <code>2</code>
  <p>В третьем примере Поликарп должен купить 2 лопаты, заплатив 2·15 = 30 бурлей. Эту сумму он, очевидно, может заплатить без сдачи.</p>

  <details>
    <summary>Решение</summary>
    <p>Общая стоимость лопат должна удовлетворять условию min_count * k = 0 или min_count * k = r (mod 10)</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int k, r;
  cin >> k >> r;

  // решение
  int min_count = 1; // Начинаем с одной лопаты

  while (true) {
    int totalCost = n * k; // Общая стоимость n лопат
    // Проверяем, можно ли оплатить без сдачи
    if (totalCost % 10 == r || totalCost % 10 == 0) {
      break;
    }
    min_count++; // Увеличиваем количество лопат
  }

  // вывод результата
  cout &lt;&lt; min_count;
}
</pre>
  </details>
</article>


<!-- Задача G. Кормен — лучший друг человека -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Кормен — лучший друг человека</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Недавно Поликарпу наконец купили собаку, которую он назвал Корменом. Теперь у Поликарпа появилось так много хлопот! Например, Кормен очень любит прогулки.</p>

  <p>Опытным путем Поликарп установил, что псу требуется не менее k прогулок суммарно за любые два последовательных дня, чтобы чувствовать себя отлично. Например, если k = 5 и вчера Поликарп гулял с собакой 2 раза, то сегодня он должен будет погулять не менее 3-х раз.</p>

  <p>Поликарп проанализировал все свои дела на ближайшие n дней вперед и составил последовательность из n целых чисел a₁, a₂, ..., aₙ, где aᵢ — количество прогулок с собакой, которые он совершит в i-й день, исполняя все свои дела во время них (например, ему надо сходить в магазин, выбросить мусор и так далее).</p>

  <p>Помогите Поликарпу определить наименьшее количество прогулок сверх намеченных, которые ему нужно совершить за n дней для того, чтобы Кормен чувствовал себя отлично на протяжении всех n дней. Вы можете считать, что в день до первого и в день после n-го Поликарп выгуливал Кормена ровно по k раз.</p>

  <p>Напишите программу, которая найдет наименьшее количество дополнительных прогулок и соответствующее расписание — последовательность целых чисел b₁, b₂, ..., bₙ (bᵢ ≥ aᵢ), где bᵢ обозначает суммарное количество прогулок в i-й день.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных записаны два целых числа n и k (1 ≤ n, k ≤ 500) — количество дней и минимальное суммарное количество прогулок Кормена за любые два подряд идущих дня.</p>

  <p>Во второй строке записаны целые числа a₁, a₂, ..., aₙ (0 ≤ aᵢ ≤ 500) — количество прогулок Кормена в i-й день, которые уже запланированы Поликарпом.</p>

  <h4>Выходные данные</h4>
  <p>В первую строку выведите наименьшее дополнительное количество прогулок, которые нужно совершить за n дней для того, чтобы Кормен всегда чувствовал себя отлично.</p>

  <p>Во вторую строку выведите n целых чисел b₁, b₂, ..., bₙ, где bᵢ — суммарное количество прогулок в i-й день в соответствии с найденным решением (aᵢ ≤ bᵢ для всех i от 1 до n). Если решений несколько, разрешается вывести любое из них.</p>

  <h4>Пример 1</h4>
<pre>
3 5
2 0 1
</pre>
<pre>
4
2 3 2
</pre>

  <h4>Пример 2</h4>
<pre>
3 1
0 0 0
</pre>
<pre>
1
0 1 0
</pre>

  <h4>Пример 3</h4>
<pre>
4 6
2 4 3 5
</pre>
<pre>
0
2 4 3 5
</pre>

  <details>
    <summary>Решение</summary>
    <h4>Идея решения:</h4>
    <ol>
      <li>Для каждого дня i (начиная со второго) проверяем, выполняется ли условие b<sub>i-1</sub> + b<sub>i</sub> &ge; k, где b<sub>i</sub> — общее количество прогулок в день i.</li>
      <li>Если условие не выполняется, увеличиваем количество прогулок в текущем дне b<sub>i</sub> на недостающее количество.</li>
      <li>После обработки всех дней выводим общее количество дополнительных прогулок и новое расписание.</li>
    </ol>
<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  int n, k;
  cin >> n >> k;
  // Исходное расписание прогулок
  vector&lt;int&gt; A(n);

  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  int day = 0;   // доп прогулка за день
  int extra = 0; // доп прогулки за n дней
  // Новое расписание прогулок
  vector&lt;int&gt; B(n);
  B[0] = A[0];
  for (int i = 1; i &lt; n; i++) {
    if (A[i] + B[i - 1] &lt; k) {
      // если нужна прогулка в i день
      day = k - A[i] - B[i - 1];
      B[i] = A[i] + day;
      extra += day;
    } else {
      // если не нужна прогулка в i день
      B[i] = A[i];
    }
  }

  // вывод результата
  cout &lt;&lt; extra &lt;&lt; '\n';
  for (int i = 0; i &lt; n; i++) {
    cout &lt;&lt; B[i] &lt;&lt; " ";
  }
}
</pre>
  </details>
</article>


<!-- Задача H. Санаторий -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Санаторий</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Василий провел свой отпуск в санатории и, вернувшись, обнаружил, что совершенно забыл о подробностях отдыха!</p>

  <p>В столовой санатория каждый день проходили завтрак, обед и ужин (конечно, именно в таком порядке). Единственное, что осталось у Василия — карточка из столовой, в которой находится запись о том, сколько раз он посещал завтрак, обед или ужин (таким образом, запись представляет собой три неотрицательных целых числа). Василий мог иногда пропустить ту или иную трапезу, например, в один и тот же день он мог посетить завтрак и ужин, но пропустить обед, а в какой-то из дней он мог не ходить в столовую вовсе.</p>

  <p>Василий уже не помнит, в какое время суток он приехал в санаторий (перед завтраком, перед обедом, перед ужином, или после ужина), а в какое уехал (до завтрака, до обеда, до ужина или после ужина) поэтому он готов рассматривать любой из этих вариантов. После приезда в санаторий Василий не покидал его до момента отъезда. Обратите внимание, Василий мог уехать из санатория в тот же день, что и приехал.</p>

  <p>По записи в карточке помогите Василию определить, какое наименьшее количество трапез в столовой санатория он мог пропустить. Трапезы, проходящие в день приезда Василия до его приезда и трапезы, проходящие в день отъезда Василия после его отъезда, пропущенными считать не следует.</p>

  <h4>Входные данные</h4>
  <p>В единственной строке входных данных содержатся три целых числа b, d и s (0 ≤ b, d, s ≤ 10¹⁸, b + d + s ≥ 1) — количество завтраков, обедов и ужинов, которые посетил Василий во время отдыха в санатории, соответственно.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное целое число — наименьшее возможное количество трапез, пропущенных Василием.</p>

  <h4>Пример 1</h4>
  <code>3 2 1</code>
  <code>1</code>
  <p>В первом примере из условия Василий пропустил бы один ужин, если, например, приехал бы к завтраку, пробыл два дня в санатории (включая день приезда) и уехал после завтрака третьего дня.</p>

  <h4>Пример 2</h4>
  <code>1 0 0</code>
  <code>0</code>
  <p>Во втором примере из условия Василий мог приехать к завтраку, сходить на него, и сразу же покинуть санаторий, не пропустив ни одной трапезы.</p>

  <h4>Пример 3</h4>
  <code>1 1 1</code>
  <code>0</code>
  <p>В третьем примере из условия Василий мог пробыть в санатории один полный день, не пропустив ни одной трапезы.</p>

  <h4>Пример 4</h4>
  <code>1000000000000000000 0 1000000000000000000</code>
  <code>999999999999999999</code>

  <details>
    <summary>Решение</summary>
    <h4>Идея решения:</h4>
    <ol>
      <li>Определим, сколько дней Василий провёл в санатории. Это можно сделать, найдя максимальное количество посещений одной из трапез, так как каждая трапеза происходит один раз в день.</li>
      <li>Для каждого дня, кроме первого и последнего, Василий должен был посетить все три трапезы (завтрак, обед, ужин). Если он пропустил какую-то трапезу, это считается пропуском.</li>
      <li>В первый и последний дни Василий мог пропустить трапезы в зависимости от времени приезда и отъезда.</li>
    </ol>
<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

int main() {
    long long b, d, s;
    cin >> b >> d >> s; // Считываем количество завтраков, обедов и ужинов

    // Определяем количество дней
    long long days = max({b, d, s});

    // Вычисляем минимальное количество пропущенных трапез
    long long missed = 0;

    // Пропуски для завтраков
    if (b &lt; days) {
        missed += (days - 1) - b;
    }

    // Пропуски для обедов
    if (d &lt; days) {
        missed += (days - 1) - d;
    }

    // Пропуски для ужинов
    if (s &lt; days) {
        missed += (days - 1) - s;
    }

    // Выводим результат
    cout &lt;&lt; missed;
}
</pre>
  </details>
</article>


<!-- Задача I. Экзамены -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача I. Экзамены</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Впереди у студента Васи сессия, которая будет длиться n дней. Васе предстоит сдать экзамены по m предметам. Предметы пронумерованы от 1 до m.</p>

  <p>Про каждый день известно, какой из m предметов можно сдать в этот день. Возможно, что в какой-то день нельзя сдавать ни один предмет. Однако в каждый день можно сдавать не более одного предмета.</p>

  <p>В очередной день Вася может либо сдавать экзамен по тому предмету, который можно сдавать в этот день (сдача занимает весь день), либо готовиться весь день к экзамену по некоторому предмету, либо отдыхать.</p>

  <p>Про каждый из предметов Вася знает число aᵢ — количество дней, которые нужно готовиться, чтобы сдать экзамен по предмету номер i. Вася может переключаться между подготовкой к экзаменам, то есть необязательно готовиться непрерывно aᵢ-е дней к экзамену номер i. Перемешивать порядок подготовки к экзаменам можно произвольным образом.</p>

  <p>Перед вами стоит задача определить минимальный номер дня, в который Вася сможет закрыть сессию — то есть сдать экзамены по всем предметам, либо определить, что это невозможно сделать. Экзамен по каждому предмету нужно сдать ровно один раз.</p>

  <h4>Входные данные</h4>
  <p>В первой строке следует два целых положительных числа n и m (1 ≤ n, m ≤ 10⁵) — длительность сессии в днях и количество предметов.</p>

  <p>Во второй строке следует n целых чисел d₁, d₂, ..., dₙ (0 ≤ dᵢ ≤ m), где dᵢ равно номеру предмета, экзамен по которому можно сдать в день номер i. Если dᵢ равно 0, то в день номер i нельзя сдавать какой-либо экзамен.</p>

  <p>В третьей строке следует m целых положительных чисел a₁, a₂, ..., aₘ (1 ≤ aᵢ ≤ 10⁵), где aᵢ равно количеству дней, которые нужно готовиться, чтобы сдать экзамен по предмету i.</p>

  <h4>Выходные данные</h4>
  <p>Выведите целое число — минимальный номер дня, в который Вася сможет сдать все экзамены. Если это невозможно, выведите -1.</p>

  <h4>Пример 1</h4>
<pre>
7 2
0 1 0 2 1 0 2
2 1
</pre>
  <code>5</code>

  <h4>Пример 2</h4>
<pre>
10 3
0 0 1 2 3 0 2 0 1 2
1 1 4
</pre>
  <code>9</code>

  <h4>Пример 3</h4>
<pre>
5 1
1 1 1 1 1
5
</pre>
  <code>-1</code>
  <p>В первом тестовом примере Вася может дейстовать следующим образом. В первый и второй день готовиться к экзамену номер 1 и сдать его в пятый день, а между этим подготовиться к экзамену номер 2 в третий день и сдать его в четвёртый.</p>

  <p>Во втором тестовом примере Вася должен готовиться к экзамену номер 3 первые четыре дня и сдать его в пятый день. Затем в шестой день подготовиться к экзамену номер 2 и сдать его в седьмой день. После этого ему нужно подготовиться к экзамену номер 1 за восьмой день и сдать его в девятый день.</p>

  <p>В третьей тестовом примере Вася не сможет сдать единственный экзамен, так как не успеет к нему подготовиться.</p>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/732/problem/D" target="_blank">Задача 732D</a>
      <br><a href="https://codeforces.com/contest/732" target="_blank">Codeforces Round 377 (Div. 2) 2016-10-17</a>
    </div>

    <p>Мы будем использовать бинарный поиск для проверки возможности сдачи всех экзаменов к определенному дню mid. Для каждого предмета находим последний день, когда можно сдать экзамен по этому предмету</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

bool Bin(int mid, vector&lt;int&gt;& D, vector&lt;int&gt;& A, int m) {
  // для каждого экзамена запишем
  // последний день от 1 до mid
  // когда его можно сдать
  vector&lt;int&gt; last(m+1, -1);
  for (int day = 1; day &lt;= mid; day++) {
    if (D[day] != 0) {
      last[D[day]] = day;
    }
  }

  // если какой-нибудь экзамен
  // нельзя сдать до дня mid
  // вернуть false
  for (int exam = 1; exam &lt;= m; exam++) {
    if (last[exam] == -1) {
      return false;
    }
  }

  // соберем структуру &lt;номер дня, номер экзамена&gt;
  // i - номер экзамена
  // last[i] - номер дня
  vector&lt;pair&lt;int, int&gt; &gt; exams;
  for (int i = 1; i &lt;= m; i++) {
    exams.push_back({ last[i], i });
  }

  // сортируем по возрастанию дня сдачи экзамена
  sort(exams.begin(), exams.end());

  // число дней подготовки
  int days_prep = 0;

  // Для каждого последнего дня сдачи экзамена
  for (int exday = 0; exday &lt; m; exday++) {
  // прибавим к дням для подготовки предыдущих экзаменов
  // дни для подготовки к текущему экзамену
    days_prep += A[exams[exday].second];

    // если для подготовки к экзамену
    // и всем предыдущим экзаменам
    // дней больше чем дней до сдачи экзамена
    // то сдать все экзамены невозможно
    if (days_prep > exams[exday].first - 1) {
      return false;
    }
    // добавим день для текущего экзамена
    days_prep++;
  }

  return true;
}

int main() {
  // ускорение ввода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);

  // ввод данных
  int n; // число дней от 1 до n
  int m; // число экзаменов от 1 до m
  cin >> n >> m;

  // day - номер дня от 1 до n
  // D[day] - какой экзамен можно сдать в день day
  vector&lt;int&gt; D(n+1);
  for (int day = 1; day &lt;= n; day++) {
    cin >> D[day];
  }

  // exam - номер экзамена от 1 до m
  // A[exam] - сколько дней нужно готовиться к экзамену exam
  vector&lt;int&gt; A(m+1);
  for (int exam = 1; exam &lt;= m; exam++) {
    cin >> A[exam];
  }

  // решение
  int res = -1;
  int left = 1; // минимальный элемент
  int right = n + 1; // за границей диапазона

  // бинарный поиск по ответу
  // ответ будет в левом указателе
  while (right - left > 1) {
    int mid = left + (right - left) / 2;
    if (Bin(mid, D, A, m)) {
      res = mid;
      right = mid;
    } else {
      left = mid;
    }
  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача J. Кузнечик и строка -->
<article class="article">
  <div class="anchor" id="task10"></div>
  <h3>Задача J. Кузнечик и строка</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Как-то раз, прыгая по лужайке, кузнечик наткнулся на листок со строкой. Кузнечику очень интересно, какой минимальной прыгучестью он должен обладать, чтобы иметь возможность оказаться за дальним концом строки, прыгая только по гласным буквам латинского алфавита. Прыгучесть — максимальная возможная длина прыжка кузнечика.</p>

  <p>Формально, считайте, что в начальный момент кузнечик находится непосредственно перед крайним левым символом строки. Его цель — оказаться в позиции за крайним правым символом строки. За один прыжок кузнечик может прыгнуть вправо на любое расстояние от 1 до величины своей прыгучести.</p>

  <p>Гласными буквами латинского алфавита считаются следующие: 'A', 'E', 'I', 'O', 'U' и 'Y'.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных следует непустая строка состоящая из заглавных букв латинского алфавита. Гарантируется, что длина строки не превосходит 100.</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно целое число a — минимальную прыгучесть кузнечика (в количестве символов), чтобы иметь возможность преодолеть заданную строку, прыгая только по гласным буквам.</p>

  <h4>Пример 1</h4>
  <code>ABABBBACFEYUKOTT</code>
  <code>4</code>

  <h4>Пример 2</h4>
  <code>AAA</code>
  <code>1</code>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/733/problem/A" target="_blank">Задача 733A</a>
      <br><a href="https://codeforces.com/contest/733" target="_blank">Codeforces Round 378 (Div. 2) 2016-10-31</a>
    </div>

    <h4>Пример 3</h4>
    <code>QQQ</code>
    <code>4</code>

<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ввод данных
  string str;
  cin >> str;

  // решение
  int res = 0; // прыгучесть
  int cnt = 0; // число согласных букв
  set&lt;char&gt; vowels = { 'A', 'E', 'I', 'O', 'U', 'Y' };

  for (int i = 0; i &lt; str.size(); i++) {
    // если буква согласная
    if (vowels.find(str[i]) == vowels.end()) {
      cnt++;
      res = max(res, cnt);
    } else {
      cnt = 0;
    }
  }

  res = max(res, cnt) + 1;

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача K. Парад -->
<article class="article">
  <div class="anchor" id="task11"></div>
  <h3>Задача K. Парад</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Совсем скоро в Берляндии состоится парад победы над инопланетными захватчиками. К сожалению, в войне погибли все солдаты, и теперь армия состоит исключительно из новобранцев, многие из которых даже не знают, с какой ноги начинается марш. Гражданское население тоже плохо понимает, с какой ноги начинается марш, поэтому важно лишь, чтобы как можно больше солдат шли в одну ногу.</p>

  <p>В параде будут принимать участие n пеших колонн, i-я из которых состоит из lᵢ солдат, начинающих марш с левой ноги, и rᵢ солдат, начинающих марш с правой ноги.</p>

  <p>Красота парада вычисляется по следующей формуле: если L — это суммарное количество солдат на параде, начинающих марш с левой ноги, а R — это суммарное количество солдат на параде, начинающих марш с правой ноги, то красота будет равна |L - R|.</p>

  <p>Вы можете выбрать не более чем одну колонну, и изменить с какой ноги начинают марш все солдаты данной колонны. Формально, разрешается не более одного раза выбрать какой-то индекс i и поменять местами значения lᵢ и rᵢ.</p>

  <p>Найдите номер колонны, при смене шага в которой красота парада станет максимально возможной, или определите, что такой операцией улучшить красоту парада нельзя.</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержится одно число n (1 ≤ n ≤ 10⁵) — количество пеших колонн. В следующих n строках находятся пары целых чисел lᵢ и rᵢ (1 ≤ lᵢ, rᵢ ≤ 500) — количество солдат в i-й колонне, начинающих марш с левой и с правой ноги соответственно.</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно целое число k — номер колонны, в которой следует сменить шаг, или 0, если максимальная красота уже достигнута.</p>

  <p>Считайте, что колонны пронумерованы от 1 до n в порядке их задания во входных данных. Если решений несколько, выведите любое.</p>

  <h4>Пример 1</h4>
<pre>
3
5 6
8 9
10 3
</pre>
  <code>3</code>
  <p>В первом примере, если вы не дадите приказ какой-либо колонне сменить шаг, то количество солдат, начинающих марш с левой ноги, будет равно 5 + 8 + 10 = 23, а с правой — 6 + 9 + 3 = 18. В таком случае красота парада будет равна |23 - 18| = 5.</p>
  <p>Если вы дадите приказ сменить ногу третьей колонне, то количество солдат, марширующих с левой ноги, будет равно 5 + 8 + 3 = 16, а с правой — 6 + 9 + 10 = 25. В таком случае красота парада будет равна |16 - 25| = 9.</p>
  <p>Каким-либо другим приказом невозможно достичь большей красоты. Таким образом, максимально достижимая красота равна 9.</p>

  <h4>Пример 2</h4>
<pre>
2
6 5
5 6
</pre>
  <code>1</code>

  <h4>Пример 3</h4>
<pre>
6
5 9
1 3
4 8
4 5
23 54
12 32
</pre>
  <code>0</code>

  <details>
    <summary>Решение</summary>
    <h4>Идея решения:</h4>
    <ol>
      <li>Вычислим исходные значения L и R.</li>
      <li>Для каждой колонны вычислим, как изменится красота парада, если мы поменяем шаг в этой колонне.</li>
      <li>Найдём колонну, изменение шага в которой даст максимальное увеличение красоты.</li>
      <li>Если ни одна колонна не улучшает красоту, выводим 0.</li>
    </ol>
<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  int n; // количество колонн
  cin >> n;
  vector&lt;int&gt; AL(n);
  vector&lt;int&gt; AR(n);

  for (int i = 0; i &lt; n; i++) {
    cin >> AL[i]; // левая нога
    cin >> AR[i]; // правая нога
  }

  // решение
  int L = 0;
  int R = 0;
  int maxL = 0;
  int maxR = 0;
  int left = 0;    // кол-во с левой ноги
  int right = 0;   // кол-во с правой ноги
  int difL = 0;     // разница левых
  int difR = 0;     // разница правых
  int max_difL = 0; // макс разница левых
  int max_difR = 0; // макс разница правых
  int colL = 0;     // номер колонны с макс левых
  int colR = 0;     // номер колонны с макс правых

  for (int i = 0; i &lt; n; i++) {
    left = AL[i];
    right = AR[i];
    L += left;
    R += right;
    difL = left - right;
    difR = right - left;
    if (difL > max_difL) {
      max_difL = difL;
      colL = i;
    }
    if (difR > max_difR) {
      max_difR = difR;
      colR = i;
    }
  }
  int beaut = abs(L - R);  // красота
  maxL = L - AL[colR] + AR[colR];
  maxR = R - AR[colL] + AL[colL];

  // вывод результата
  if (maxL >= maxR) {
    if (maxL > L) {
      cout &lt;&lt; colR + 1;
    } else {
      cout &lt;&lt; 0;
    }

  } else if (maxR > maxL) {
    if (maxR > R) {
      cout &lt;&lt; colL + 1;
    } else {
      cout &lt;&lt; 0;
    }
  }
}
</pre>
  </details>

  <details>
    <summary>Вариант решения</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
using namespace std;

int main() {
    int n;
    cin >> n; // Считываем количество колонн

    vector&lt;pair&lt;int, int&gt;&gt; columns(n); // Пары (l_i, r_i) для каждой колонны
    int L = 0, R = 0; // Исходные значения L и R

    // Считываем данные и вычисляем L и R
    for (int i = 0; i &lt; n; i++) {
        cin >> columns[i].first >> columns[i].second;
        L += columns[i].first;
        R += columns[i].second;
    }

    int maxBeauty = abs(L - R); // Исходная красота парада
    int bestColumn = 0; // Номер колонны для изменения (0, если не нужно менять)

    // Перебираем все колонны и находим лучшую для изменения
    for (int i = 0; i &lt; n; i++) {
        int newL = L - columns[i].first + columns[i].second; // Новое L после изменения
        int newR = R - columns[i].second + columns[i].first; // Новое R после изменения
        int newBeauty = abs(newL - newR); // Новая красота парада

        if (newBeauty > maxBeauty) {
            maxBeauty = newBeauty;
            bestColumn = i + 1; // Нумерация колонн с 1
        }
    }

    // Выводим результат
    cout &lt;&lt; bestColumn;
    return 0;
}
</pre>
  </details>
</article>


<!-- Задача L. Деление пиццы -->
<article class="article">
  <div class="anchor" id="task12"></div>
  <h3>Задача L. Деление пиццы</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Студенты Вася и Петя учатся в БГУ (Байтляндском Государственном Университете). На одной из перемен они решили перекусить и заказали пиццу. Пицца представляет собой круг некоторого радиуса. Пиццу доставили уже разрезанную на n кусков, i-й кусок представляет собой сектор с углом равным a<sub>i</sub>. Вася и Петя хотят разделить все куски на два непрерывных сектора так, чтобы разница углов этих секторов была минимальна. Углом сектора называется сумма углов всех кусков пиццы входящих в него. Обратите внимание, что один из секторов может быть пустым.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно целое число n (1 ≤ n ≤ 360) — количество кусков, на которые разрезана пицца.</p>
  <p>Во второй строке записаны n целых чисел aᵢ (1 ≤ aᵢ ≤ 360) — углы секторов, на которые разрезана пицца. Сумма всех aᵢ равна 360.</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно целое число — минимально возможную разницу между углами секторов пиццы которые достанутся Васе и Пете.</p>

  <h4>Пример 1</h4>
<pre>
4
90 90 90 90
</pre>
  <code>0</code>
  <p>В первом тесте Вася может взять 1 и 2 куски, а Петя 3 и 4. Тогда ответ равен |(90 + 90) - (90 + 90)| = 0</p>

  <h4>Пример 2</h4>
<pre>
3
100 100 160
</pre>
  <code>40</code>

  <h4>Пример 3</h4>
<pre>
1
360
</pre>
  <code>360</code>
  <p>В третьем тесте есть только один кусок, который полностью достанется Васе или Пете. Поэтому ответ равен |360 - 0| = 360.</p>

  <h4>Пример 4</h4>
<pre>
4
170 30 150 10
</pre>
  <code>0</code>
  <p>В четвертом тесте Вася может взять 1 и 4 куски, тогда Пете достанутся 2 и 3 куски. Ответ в этом случае равен |(170 + 10) - (30 + 150)| = 0.</p>

  <h4>Пример 8</h4>
<pre>
5
110 90 70 50 40
</pre>
  <code>40</code>
  <p>Куски пиццы должны идти подряд, то есть быть соседними. Пицца круглая, поэтому нужно учитывать что последний кусок пиццы и первый - тоже соседние.</p>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;
  vector&lt;int&gt; A(n);

  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  if (n == 1) {
    cout &lt;&lt; 360;
    return 0;
  }

  int max_sector = 0; // угол макс близкий к 180
  int sector = 0; // угол первого сектора
  for (int i = 0; i &lt; n; i++) {
    if (A[i] > 180) {
      continue;
    }
    sector = A[i];
    for (int j = i + 1; j &lt;= n; j++) {
      // начать сначала если это последний кусок
      if (j == n) {
        j = 0;
      }
      // остановка если прошли круг
      if (j == i) {
        break;
      }
      // добавлять кусок пока меншье половины круга
      if (sector + A[j] &lt;= 180) {
        sector += A[j];
      } else {
        break;
      }
   }
    max_sector = max(max_sector, sector);
  }
  // разница между углами секторов
  int deg = (180 - max_sector) * 2;

  // вывод результата
  cout &lt;&lt; deg;
}
</pre>
  </details>
</article>


<!-- Задача M. Тренировки -->
<article class="article">
  <div class="anchor" id="task13"></div>
  <h3>Задача M. Тренировки</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Закончив обучение в магистратуре и поступив в аспирантуру, Игорь не смог забросить олимпиады. Он решил вести тренировки по спортивному программированию в своём любимом вузе.</p>

  <p>Игорю разрешили проводить тренировки по воскресеньям в новом кабинете. Чтобы организовать первую тренировку, Игорь сделал опрос в беседе 'кто придет на тренировку?' с двумя вариантами ответа: 'к 10 часам', 'к 12 часам', причём каждый участник мог выбрать оба варианта. По итогам опроса оказалось, что за 10 часов было дано A голосов, за 12 часов B голосов, посмотрев на таблицу ответов, Игорь увидел, что C студентов проголосовало и за 10, и за 12 часов, поскольку они могут в любое время.</p>

  <p>В любимом вузе Игоря строго-настрого соблюдаются санитарно-профилактические нормы, и на занятии не должно присутствовать больше, чем D студентов в одном помещении.</p>

  <p>Помогите Игорю определить, сможет ли он провести тренировку, если распределит студентов с учетом их пожеланий, или он не сможет разместить студентов в кабинете, и первую тренировку придется отменить.</p>

  <h4>Входные данные</h4>
  <p>На вход дано четыре целых числа A, B, C, D (0 ≤ A, B, C, D ≤ 10⁵, C ≤ A и C ≤ B) — количество проголосовавших за 10 часов, количество за 12 часов, количество проголосовавших за 10 и 12 часов и то, сколько может находиться студентов в одном помещении одновременно.</p>

  <h3>Выходные данные</h3>
  <p>Выведите 'Yes', если получится провести тренировку, и 'No', если провести тренировку нельзя.</p>

  <h4>Пример 1</h4>
  <code>15 15 10 20</code>
  <code>Yes</code>

  <h4>Пример 2</h4>
  <code>15 15 10 10</code>
  <code>Yes</code>

  <h4>Пример 3</h4>
  <code>15 15 10 10</code>
  <code>No</code>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int a, b, c, d;
  cin >> a >> b >> c >> d;

  // решение
  string res = "No";
  // оставшиеся места на 10 часов
  int rest10 = d - (a - c);
  // оставшиеся места на 12 часов
  int rest12 = d - (b - c);
  // если оставшихся мест больше чем оставшихся студентов
  if (rest10 >= 0 && rest12 >= 0 && rest10 + rest12 >= c) {
    res = "Yes";
  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>

