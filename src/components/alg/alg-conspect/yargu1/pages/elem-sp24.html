<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contests" target="_blank">ЯрГУ. Кружок. Школьники</a></p>
  <p><a href="https://vkvideo.ru/@sportprog_yarsu" target="_blank">vkvideo.ru/@sportprog_yarsu</a></p>
</article>


<article class="article">
  <h1>Занятие 24 Математика #3. Генерация комбинаторных объектов</h1>
  <p>Конспект видео от 2025.03.15</p>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contest/596277" target="_blank">Codeforces Контест 596277</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
    <a href="#p1">Математика #3. Генерация комбинаторных объектов</a>
  </p>
  <p>
        <a href="#task1">Задача A. Перестановки 1 - N</a>
    <br><a href="#task2">Задача B. Генератор</a>
    <br><a href="#task3">Задача C. Все двоичные строки длины n, содержащие ровно k единиц</a>
    <br><a href="#task4">Задача D. Разбиения</a>
    <br><a href="#task5">Задача E. Сочетания</a>
    <br><a href="#task6">Задача F. Выражение</a>
    <br><a href="#task7">Задача G. Скобки-2</a>
    <br><a href="#task8">Задача H. Две прогрессии</a>
    <br><a href="#task9">Задача I. Прямоугольник и квадрат</a>
    <br><a href="#task10">Задача J. Работа после вуза</a>
    <br><a href="#task11">Задача K. Поколение комбинаторов</a>
    <br><a href="#task12">Задача L. Монеты</a>
    <br><a href="#task13">Задача M. Мирные ферзи</a>
    <br><a href="#task14">Задача V. Восстановление перестановки после слияния</a>
    <br><a href="#task15">Задача W. Перестановка подпоследовательности</a>
    <br><a href="#task16">Задача X. CQXYM считает перестановки</a>
    <br><a href="#task17">Задача Y. Николай и перестановка</a>
    <br><a href="#task18">Задача Z. Правильные скобочные последовательности</a>
  </p>
</article>


<!-- Математика #3. Генерация комбинаторных объектов -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Математика #3. Генерация комбинаторных объектов</h3>

  <p>Для генерации комбинаторных объектов будем стараться писать максимально эффективные рекурсивные функции. Примерный шаблон рекурсивной функции для генерации любого комбинаторного объекта:</p>
<pre>
void generate(
     // вектор в котором хранится объект с 0 до n-1
     vector&lt;int&gt;& Res,
     int n, // длина объекта
     int pos // текущая позиция
) {
  // условие завершения генерации объекта
  if (n == pos) {
    // действия со сделанным объектом
  } else {
    // перебор элементов
    for (int i = 1; i &lt;= n; i++) {
      // действия для генерации объекта
      generate(Res, n, pos+1);
    }
  }
}
</pre>

  <h4>Генерация перестановок</h4>

  <p>Перестановка n объектов/элементов — это способ их последовательного расположения с учётом порядка. Например, abc, bca и cab — это разные перестановки трёх букв.</p>
  <code>Pn = n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1</code>
  <p>Поставим перед собой задачу, вывести все перестановки длины n. Их
количество должно равняться n!. Будем стараться выводить перестановки в
лексикографическом порядке.</p>
<pre>
1) 1234 2) 1243 3) 1324 4) 1342 5) 1423 6) 1432
7) 2134 8) 2143 9) 2314 10) 2341 11) 2413 12) 2431
13) 3124 14) 3142 15) 3214 16) 3241 17) 3412 18) 3421
19) 4123 20) 4132 21) 4213 22) 4231 23) 4312 24) 4321
</pre>
  <p>Генерация всех перестановок длины n с лишними комбинациями.  Трудоемкость O(nⁿ).</p>
<pre>
void generate_permutations_super_bad(
  vector&lt;int&gt;& Res,
  int n, int pos
) {
  if (n == pos) {
    for (int i = 0; i &lt; n; i++) {
      cout &lt;&lt; Res[i] &lt;&lt; " ";
    }
    cout &lt;&lt; "\n";
  } else {
    for (int i = 1; i &lt;= n; i++) {
      Res[pos] = i;
      generate_permutations_super_bad(Res, n, pos + 1);
    }
  }
}
</pre>

  <p>Генерация всех перестановок длины n с проверкой комбинации. Трудоемкость O(nⁿ * n²).</p>
<pre>
void generate_permutations_bad(
  vector&lt;int&gt;& Res, int n, int pos) {
  if (n == pos) {
    bool flag = true;
    for (int i = 0; i &lt; n; i++) {
      for (int j = i + 1; j &lt; n; j++) {
        if (Res[i] == Res[j]) {
          flag = false;
        }
      }
    }
    if (flag) {
      for (int i = 0; i &lt; n; i++) {
        cout &lt;&lt; Res[i] &lt;&lt; " ";
      }
      cout &lt;&lt; "\n";
    }
  } else {
    for (int i = 1; i &lt;= n; i++) {
      Res[pos] = i;
      generate_permutations_bad(Res, n, pos + 1);
    }
  }
}
</pre>
  <p>Улучшим реализацию рекурсивной функции. Вместо того, чтобы проверять итоговую сгенерированную последовательность на корректность перестановке (отсутствие повторяющихся элементов в массиве), будем стараться правильно генерировать объект.</p>
  <p>При генерации элемента в pos будем ставить только такие значения, которые не встречались до pos.</p>
  <p>Генерация всех перестановок длины n с отсечением плохих вариантов. Трудоемкость O(n!).</p>
<pre>
void generate_permutations(
  vector&lt;ing&gt;& Res,
  vector&lt;int&gt;& Mark,
  int n, int pos
) {
  if (n == pos) {
    for (int i = 0; i &lt; n; i++) {
      cout &lt;&lt; Res[i] &lt;&lt; " ";
    }
    cout &lt;&lt; "\n";
  } else {
    for (int i = 1; i &lt;= n; i++) {
      if (Mark[i] == 0) {
        Res[pos] = i;
        Mark[i] = 1;
        generate_permutations(Res, Mark, n, pos + 1);
        Mark[i] = 0;
      }
    }
  }
}
</pre>

  <h4>Генерация сочетаний</h4>
  <p>Сочетание из n по k — это неупорядоченный набор из k различных  элементов, взятых из некоторого множества с мощностью n, где k ≤ n. То  есть набор, для которого порядок выбора не имеет значения.</p>
  <code>C<sub>n</sub><sup>k</sup> = A<sub>n</sub><sup>k</sup> / k! = n! / (n - k)!k!.</code>
  <p>Поставим задачу вывести все сочетания максимально правильно, без  генерации лишних комбинаций.</p>
  <p>Генерация всех сочетаний длины k из n элементов с проверкой.  Трудоемкость O(n! * n).</p>
<pre>
void generate_combination_bad(
  vector&lt;int&gt;& Res,
  vector&lt;int&gt;& Mark,
  int n, int k, int pos
) {
  if (k == pos) {
    bool flag = true;
    for (int i = 1; i &lt; k; i++) {
      if (Res[i] &lt; Res[i - 1]) {
        flag = false;
      }
    }
    if (flag) {
      for (int i = 0; i &lt; k; i++) {
        cout &lt;&lt; Res[i] &lt;&lt; " ";
      }
      cout &lt;&lt; "\n";
    }
  } else {
    for (int i = 1; i &lt;= n; i++) {
      if (Mark[i] == 0) {
        Res[pos] = i;
        Mark[i] = 1;
        generate_combination_bad(Res, Mark, n, k, pos + 1);
        Mark[i] = 0;
      }
    }
  }
}
</pre>

  <p>Генерация всех сочетаний длины k из n элементов. Трудоемкость O(n!).</p>
<pre>
void generate_combination_b(
  // храним объект с позиции 1 до n
  vector&lt;int&gt;& Res,
  int n, int k, int pos
) {
  if (k &lt; pos) {
    for (int i = 1; i &lt;= k; i++) {
      cout &lt;&lt; Res[i] &lt;&lt; " ";
    }
    cout &lt;&lt; "\n";
  } else {
    for (int i = Res[pos - 1] + 1; i &lt;= n; i++) {
      Res[pos] = i;
      generate_combination_b(Res, n, k, pos + 1);
    }
  }
}
</pre>
  <p>Улучшим реализацию рекурсивной функции.</p>
  <p>При генерации элемента в pos будем ставить только такие значения, которые строго значения в pos - 1, а также такие значения, что мы сможем завершить объект (на синюю область будет достаточно подходящих элементов).</p>
  <p>Генерация всех сочетаний длины k из n элементов. Трудоемкость O(C<sub>n</sub><sup>k</sup>).</p>
<pre>
void generate_combination(
  vector&lt;int&gt;& Res,
  int n, int k, int pos
) {
  if (k &lt; pos) {
    for (int i = 1; i &lt;= k; i++) {
      cout &lt;&lt; Res[i] &lt;&lt; " ";
    }
    cout &lt;&lt; "\n";
  } else {
    for (int i = Res[pos - 1] + 1; i &lt;= (n - (k - pos)); i++) {
      Res[pos] = 1;
      generate_combination(Res, n, k, pos + 1);
    }
  }
}
</pre>

  <h4>Определитель матрицы</h4>

  <p>Определитель (детерминант) в линейной алгебре — скалярная величина,  которая характеризует ориентированное «растяжение» или «сжатие»  многомерного евклидова пространства после преобразования матрицей.  Для квадратной матрицы A = (a<sub>ij</sub>) размера n x n её определитель |A|  вычисляется по формуле:</p>
  <code>|A| = Σ (по α1,α2,...,αn) (-1)<sup>N(α1,α2,...,αn)</sup>a1α1a2α2 ...anαn,</code>
  <p>где все αi различные числа от 1 до n, суммирование происходит по всем  перестановкам α, a функция N(α1, α2, ..., αn) определяет количество  инверсий.</p>

  <h4>Генерация объекта по номеру</h4>

  <p>Поставим задачу. Вывести n комбинаторный объект в лексикографическом  порядке.</p>
<pre>
           варианты
   |          |          |
   1          2          3
   |          |          |
1  2  3    1  2  3    1  2  3
</pre>

  <p>Генерация перестановки по номеру. Трудоемкость O(n!).</p>
<pre>
void generate_permutation_num(
  vector&lt;int&gt;& Res,
  vector&lt;int&gt;& Mark,
  int n, int pos,
  int &cout, int num_find
) {
  if (n == pos) {
    count++;
    if (count == num_find) {
      for (int i = 0; i &lt; n; i++) {
        cout &lt;&lt; Res[i] &lt;&lt; " ";
      }
    }
  } else {
    for (int i = 1; i &lt;= n; i++) {
      if (Mark[i] == 0) {
        Res[pos] = i;
        Mark[i] = 1;
        generate_permutation_num(Res, Mark, n, pos + 1, count, num_find);
      }
    }
  }
}
</pre>

  <h4>Пример</h4>
  <p>Пусть у нас есть 5 элементов, т.е. n = 5 (например, это цифры 1 2 3 4 5). Число всех перестановок будет равно Pn = n! = 5! = 1 * 2 * 3 * 4 * 5 = 120. Найти перестановку номер 28, если выводить их в лексикографическом порядке.</p>
  <p>У нас есть 5 вариантов. Это если мы зафиксируем первую цифру, то получим перестановки 1xxxx, 2xxxx, 3xxxx, 4xxxx, 5xxxx. Перестановки из 5 элементов, в которых зафиксирована первая цифра это перестановка из 4 элементов и она имеет 24 разных варианта, потому что n! = 4! = 1 * 2 * 3 * 4 = 24.</p>
  <p>Значит, что в каждом из 5 вариантов есть 24 комбинаторных объекта. Пронумеруем их для варианта 1xxxx</p>
  <code>1. 12345 2. 12345 3. 12435 .... 24. 15432</code>
  <p>Мы точно знаем, что в ветке 1xxxx нет перестановки номер 28, потому что там всего 24 перестановки.</p>
  <p>Сколько существует комбинаторных объектов перестановок длины 5, которые начинаются с 2xxxx? Первый элемент зафиксирован, значит остается 4 элемента n! = 4! = 24 перестановки. Их нумерация в лексикографическом порядке начинается с 25 и до 48. Таким образом, перестановка номер 28 находится в ветке 2xxxx.</p>
  <p>Идем дальше. В ветке 2xxxx есть 4 своих подветки длины 5. Мы их получим если зафиксируем вторую цифру 21xxx, 22xxx, 23xxx, 24xxx, 25xxx.</p>
  <p>Сколько перестановок длины 5, которые начинаются с двух фиксированных элементов 21xxx? Это n! = 3! = 1 * 2 * 3 = 6. Они будут пронумерованы с 25 до 30. В веьке 23xxx нумерация от 31 до 36.</p>
  <p>Ветки, в которых нет числа 28 нас не интересуют. Мы переходим только в те ветки где есть число 28. Поэтому сначала мы перешли в ветку 2xxxx, потом в ветку 21xxx.</p>
  <p>В ветке 21xxx есть три подветки 213xx, 214xx, 215xx. Сколько существует комбинаторных объектов перестановок длины 5 начинающиеся с 213xx? Первые три элемента зафиксированы, значит для перестановок остается только два элемента n! = 2! = 1 * 2 = 2. Они будут пронумерованы с 25 до 26. В ветке 214xx тоже 2 объекта с нумерацией от 27 до 28. Переходим в ветку, в которой находится число 28.</p>
  <p>В ветке 214xx есть две подветки 2143x, 2145x. В перестановке из 5 элементов первые 4 элемента зафиксированы, значит в каждой ветке теперь остается только один вариант перестановки. В ветке 2143x один объект с номером 27, в ветке 2145x один объект с номером 28 и это перестановка 21453.</p>
  <p>Мы постепенно углублялись рекурсивно в дереве только в те ветки, которые хорошие. Так добрались до нужного нам элемента. Этот алгоритм называется <strong>рекурсивным деревом с отсечением</strong>.</p>
  <p>Мы искали <strong>перестановки</strong> по номеру. Таким же образом можно искать <strong>сочетания</strong> по номеру</p>
</article>


<!-- Задача A. Перестановки 1 - N -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Перестановки 1 - N</h3>

  <div><i>Ограничение по времени 3с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Выведите перестановки чисел от 1 до N длины N в лексикографическом порядке их следования.</p>

  <h4>Входные данные</h4>
  <p>Вводится единственное число - N (1 ≤ N ≤ 10) из условия задачи.</p>

  <h4>Выходные данные</h4>
  <p>Выведите в лексикографическом порядке перестановки чисел от 1 до N длины N по одной в каждой строке.</p>

  <h4>Пример</h4>
  <code>3</code>
<pre>
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
</pre>
</article>


<!-- Задача B. Генератор -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Генератор</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Даны два натуральных числа N и K. Требуется вывести в файл все цепочки x₁, x₂, ..., xₙ такие, что xᵢ - натуральное и 1 ≤ xᵢ ≤ K.</p>

  <h4>Входные данные</h4>
  <p>В единственной строке записаны натуральные числа N и K (1 ≤ N,  K ≤ 6).</p>

  <h4>Выходные данные</h4>
  <p>Выведите все требуемые цепочки в лексикографическом порядке - по одной на строке. Никакая цепочка не должна встречаться более одного раза.</p>

  <h4>Пример 1</h4>
  <code>2 3</code>
<pre>
1 1
1 2
1 3
2 1
2 2
2 3
3 1
3 2
3 3
</pre>

  <h4>Пример 2</h4>
  <code>1 1</code>
  <code>1</code>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

void gen(vector&lt;int&gt;& Res, int n, int k, int pos) {
  if (n == pos) {
    // выводим по n цифр в строке
    for (int i = 0; i &lt; n; i++) {
      cout &lt;&lt; Res[i] &lt;&lt; ' ';
    }
    cout &lt;&lt; '\n';
  } else {
    // перебираем все возможные цифры
    for (int i = 1; i &lt;= k; i++) {
      Res[pos] = i;
      gen(Res, n, k, pos + 1);
      // выводим одну строку из n цифр
      // и возвращаемся в цикл
      // на следующую итерацию
    }
  }
}

int main() {
  // входные данные
  // n число цифр в строке
  // k число возможных цифр от 1 до k
  int n, k;
  cin >> n >> k;

  // решение
  vector&lt;int&gt; Res(n);
  gen(Res, n, k, 0);
}
</pre>
  </details>
</article>


<!-- Задача C. Все двоичные строки длины n, содержащие ровно k единиц -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Все двоичные строки длины n, содержащие ровно k единиц</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>По данным числам N и K выведите все строки из нулей и единиц длины N, содержащие ровно K единиц, в лексикографическом порядке.</p>

  <h4>Входные данные</h4>
  <p>Заданы 2 числа: N и K (0 ≤ K ≤ N, 0 ≤ N ≤ 100)</p>

  <h4>Выходные данные</h4>
  <p>Необходимо вывести все строки из нулей и единиц длины N, содержащие ровно K единиц, в лексикографическом порядке. Гарантируется, что размер ответа не превышает 10 МБайт.</p>

  <h4>Пример</h4>
  <code>4 1</code>
<pre>
0001
0010
0100
1000
</pre>
</article>


<!-- Задача D. Разбиения -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Разбиения</h3>

  <div><i>Ограничение по времени 4с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Перечислить все разбиения натурального числа n на натуральные слагаемые в порядке обратном лексикографическому (см. примеры для лучшего понимания). Разбиения, отличающиеся порядком слагаемых, считаются одинаковыми (например, 1+3 и 3+1 – одинаковые разбиения числа 4).</p>

  <h4>Входные данные</h4>
  <p>В единственной строке содержится число n (1 ≤ n ≤ 50)</p>

  <h4>Выходные данные</h4>
  <p>Выведите все разбиения числа n на слагаемые в требуемом порядке, по одному в строке.</p>

  <h4>Пример 1</h4>
  <code>2</code>
<pre>
2
1+1
</pre>

  <h4>Пример 1</h4>
  <code>4</code>
<pre>
4
3+1
2+2
2+1+1
1+1+1+1
</pre>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int n;
vector&lt;int&gt; res;

// генерация комбинаторного объекта
void gen(int sum, int u) {
  if (sum == 0) {
    for (int i = 0; i &lt; res.size() - 1; i++) {
      cout &lt;&lt; res[i] &lt;&lt; "+";
    }
    cout &lt;&lt; res[res.size() - 1] &lt;&lt; '\n';
  } else {
    for (int i = min(u, sum); i > 0; i--) {
      res.push_back(i);
      gen(sum - i, i);
      res.pop_back();
    }
  }
}

int main() {
  cin >> n;
  gen(n, n);
}
</pre>
  </details>
</article>


<!-- Задача E. Сочетания  -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Сочетания</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Входной файл choose.in</p>
  <p>Выходной файл choose.out</p>
  <p>Во входном файле заданы числа n и k (1 ≤ k ≤ n ≤ 16). Выведите в выходной файл все сочетания по k из чисел от 1 до n в лексикографическом порядке.</p>

  <h4>Пример</h4>
<pre>
4 2
</pre>
<pre>
1 2
1 3
1 4
2 3
2 4
3 4
</pre>
</article>


<!-- Задача F. Выражение -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Выражение</h3>

  <div><i>Ограничение по времени 0.5с
  <br>Ограничение по памяти 16мб</i></div>
  <p>Даны N целых чисел X1, X2, …, XN. Требуется расставить между ними знаки «+» и «-» так, чтобы значение получившегося выражения было равно заданному целому S.</p>

  <h4>Входные данные</h4>
  <p>Ввод в первой строке содержит числа N и S. В следующей строке располагается N чисел, разделенных пробелом. Ограничения: 2 ≤ N ≤ 24, 0 ≤ Xi ≤ 5⋅10⁷, -10⁹ ≤ S ≤ 10⁹.</p>

  <h4>Выходные данные</h4>
  <p>Выведите «No solution», если такой результат получить невозможно, иначе выведите получившееся равенство. Если решение не единственное, выведите любое.</p>

  <h4>Пример 1</h4>
<pre>
3 10
15 25 30
</pre>
  <code>15+25-30=10</code>

  <h4>Пример 2</h4>
<pre>
2 100
10 10
</pre>
  <code>No solution</code>
</article>


<!-- Задача G. Скобки-2 -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Скобки-2</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 16мб</i></div>

  <p>Вывести все правильные скобочные выражения длиной N, состоящие из круглых и квадратных скобок.</p>

  <h4>Входные данные</h4>
  <p>Дано единственное четное натуральное число N, не превышающее 14.</p>

  <h4>Выходные данные</h4>
  <p>Выведите всевозможные правильные скобочные выражения по одному в каждой строке в произвольном порядке.</p>

  <h4>Пример 1</h4>
  <code>2</code>
<pre>
()
[]
</pre>

  <h4>Пример 2</h4>
  <code>4</code>
<pre>
(())
([])
()()
()[]
[()]
[[]]
[]()
[][]
</pre>

  <details>
    <summary>Решение</summary>
    <p>Создадим стек.</p>
    <ol>
      <li>Если длина стека меньше длины оставшейся последовательности, то можно поставить любую открывающую скобку и занести ее в стек.</li>
      <li>Если в стеке что-то есть, то можно поставить закрывающую скобку, парную открывающей в стеке.</li>
    </ol>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;

using namespace std;

stack&lt;char&gt; st;
int n;
vector&lt;char&gt; res(100);

void gen(int pos) {
  if (pos == n) {
    for (int i = 0; i &lt; n; i++) {
      cout &lt;&lt; res[i];
    }
    cout &lt;&lt; '\n';
  } else {
    if (st.size() == 0) {
      res[pos] = '(';
      st.push('(');
      gen(pos + 1);
      st.pop();
      res[pos] = '[';
      st.push('[');
      gen(pos + 1);
      st.pop();
    } else {
      if (n - pos > st.size()) {
        res[pos] = '(';
        st.push('(');
        gen(pos + 1);
        st.pop();
        res[pos] = '[';
        st.push('[');
        gen(pos + 1);
        st.pop();
      }
      if (st.size() > 0) {
        if (st.top() == '(') {
          res[pos] = ')';
          st.pop();
          gen(pos + 1);
          st.push('(');
        }
        if (st.top() == '[') {
          res[pos] = ']';
          st.pop();
          gen(pos + 1);
          st.push('[');
        }
      }
    }
  }
}

int main() {
  // входные данные
  cin >> n;
  gen(0);
}
</pre>
  </details>
</article>


<!-- Задача H. Две прогрессии -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Две прогрессии</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Арифметическая прогрессия — это такая непустая последовательность чисел, в которой разница между любыми двумя последовательными членами равна константе, называемой разностью прогрессии. Например, последовательность 3, 7, 11, 15 — арифметическая прогрессия. Из определения следует, что любые последовательности длины 1 или 2 — арифметические, а длины 0 — не арифметические.</p>

  <p>Задана последовательность различных целых чисел a1, a2, ..., an. Требуется разбить ее на две арифметические прогрессии или определить, что это невозможно сделать. При разбиении каждый член заданной последовательности должен быть отнесен в одну из двух прогрессий, при этом относительный порядок чисел остается неизменным. Разбиение — это обратная операция к слиянию последовательностей.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое положительное число n (2 ≤ n ≤ 30000), n — длина заданной последовательности. Вторая строка содержит элементы заданной последовательности a1, a2, ..., an ( - 10⁸ ≤ ai ≤ 10⁸). Элементы последовательности — различные целые числа.</p>

  <h4>Выходные данные</h4>
  <p>Выведите искомые арифметические прогрессии, по одной на строке. Прогрессии можно располагать в любом порядке. Каждая прогрессия должна содержать хотя бы одно число. Если решения не существует, то выведите «No solution» (без кавычек) в единственную строку выходного файла. Если решений несколько, выведите любое из них.</p>

  <h4>Пример 1</h4>
<pre>
6
4 1 2 7 3 10
</pre>
<pre>
1 2 3
4 7 10
</pre>

  <h4>Пример 2</h4>
<pre>
5
1 2 3 -2 -7
</pre>
<pre>
1 2 3
-2 -7
</pre>
  <p>Во втором примере возможен другой вариант ответа (число 3 может быть отнесено во вторую прогрессию): 1, 2 и 3, -2, -7.</p>
</article>


<!-- Задача I. Прямоугольник и квадрат -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача I. Прямоугольник и квадрат</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Маленький Петя очень любит прямоугольники, а особенно квадраты. Недавно мама подарила ему 8 попарно не совпадающих точек на плоскости. Он решил разбить их на два множества по 4 точки так, чтобы точки из первого множества лежали в вершинах некоего квадрата, а из второго — в вершинах прямоугольника. Каждая из заданных 8 точек должна принадлежать ровно одному множеству. Допускается, чтобы прямоугольник из второго множества также был квадратом. Если разбиений несколько, Петю удовлетворит любое. Помогите ему найти одно такое разбиение. Обратите внимание, что и прямоугольник, и квадрат из разбиения должны иметь ненулевую площадь. Стороны фигур не обязательно должны быть параллельны осям координат.</p>

  <h4>Входные данные</h4>
  <p>Задано 8 пар целых чисел, по одной паре в каждой строке — координаты точек, которые есть у Пети. Все координаты по модулю не превышают 10⁴. Гарантируется, что никакие две точки не совпадают.</p>

  <h4>Выходные данные</h4>
  <p>В первой строке выведите «YES» (без кавычек), если искомое разбиение существует. Во второй строке выведите 4 числа через пробел — номера точек из исходного множества, которые лежат в вершинах квадрата. Точки нумеруются начиная с 1. Номера можно выводить в любом порядке. В третьей строке выведите номера точек, лежащих в вершинах прямоугольника в аналогичном формате. Все выведенные числа должны быть попарно различны.</p>

  <p>Если искомого разбиения не существует, первая строка должна содержать слово «NO» (без кавычек), после которого ничего выводить не нужно.</p>

  <h4>Пример 1</h4>
<pre>
0 0
10 11
10 0
0 11
1 1
2 2
2 1
1 2
</pre>
<pre>
YES
5 6 7 8
1 2 3 4
</pre>

  <h4>Пример 2</h4>
<pre>
0 0
1 1
2 2
3 3
4 4
5 5
6 6
7 7
</pre>
<pre>
NO
</pre>

  <h4>Пример 3</h4>
<pre>
0 0
4 4
4 0
0 4
1 2
2 3
3 2
2 1
</pre>
<pre>
YES
1 2 3 4
5 6 7 8
</pre>
  <p>Обратите внимание на третий пример: стороны фигур не обязательно должны быть параллельны осям координат.</p>
</article>


<!-- Задача J. Работа после вуза -->
<article class="article">
  <div class="anchor" id="task10"></div>
  <h3>Задача J. Работа после вуза</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Игорь закончил магистратуру, и, как порядочный студент, решил устроиться на работу по специальности в его любимом городе.</p>

  <p>В любимом городе Игоря есть хорошие IT-компании: Accelcomp, Тензор, Akvelon, Fogsoft, Confirmit, Krista и многие другие.</p>

  <p>У Игоря есть n друзей, которые тоже хотят устроиться на работу. Собравшись всей своей дружной компанией, ребята выбрали n+1 IT-компанию из своего родного города.</p>

  <p>Игорь и его друзья хотят устроиться в разные компании, чтобы после испытательного срока поделиться впечатлением от работы в IT. Каждый друг Игоря, как и сам Игорь, высказали, хотят ли они работать в определенной компании. Сможете ли вы посчитать сколькими разными способами они смогут устроиться на работу?</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано n (1 ≤ n &lt; 10) — количество друзей Игоря.</p>

  <p>Следующие n+1 строк описывают предпочтения Игоря и его друзей. В строке с номером i содержится n+1 число k<sub>ij</sub> (1 ≤ i, j ≤ n+1). Если k<sub>ij</sub> = 0, то человек с номером i не хочет работать в компании с номером j, если же k<sub>ij</sub>=1, то человек i хочет работать в компании j.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите количество вариантов трудоустройства студентов с учетом их пожеланий.</p>

  <h4>Пример 1</h4>
<pre>
2
1 1 1
1 1 1
1 1 1
</pre>
  <code>6</code>

  <h4>Пример 2</h4>
<pre>
2
1 1 0
0 1 1
0 0 1
</pre>
  <code>1</code>

  <h4>Пример 3</h4>
<pre>
2
1 1 0
0 1 0
1 0 0
</pre>
  <code>0</code>

  <details>
    <summary>Решение</summary>
    <p>У нас есть n+1 человек, которые хотят попасть на работу в n+1 компаню, причем все должны работать в разных компаниях. Кажды человек может попасть только в ту компанию, в которую он хочет и не может попасть в ту, в которую не хочет.</p>
    <p>На входе единственное число n и матрица (n+1) x (n+1).</p>
    <p>В этой задаче надо посчитать <strong>абсолютный определитель</strong>. Надо сделать генерацию всех перестановок и проверить каждую перестановку. Если человек не хотел попасть в компанию, то это плохая перестановка и мы ее не учитываем в результате. Если хотел - то это хорошая перестановка и мы ее учитываем в результате. Для проверки можно использовать произведение из входной матрицы. Если кто-то не хотел в компанию, то у него в матрице стоит 0 и все произведение равно 0.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

// только для генерации комбинаторных объектов!!!
// можно вместо передачи функции параметров
// использовать глобальные переменные,
// которые видны во всех функциях
int n, k, sum = 0, pos = 0;
vector&lt;int&gt; used(20), res(20);
vector&lt;vector&lt;int&gt; &gt; H(20, vector&lt;int&gt;(20));

void gen(int i) {
  if (i > n) {
    pos = 1;
    // проверка, хорошая или плохая перестановка
    for (int j = 1; j &lt;= n; j++) {
      pos *= H[j][res[j]];
    }
    sum += pos;
  } else {
    for (int j = 1; j &lt;= n; j++) {
      if (used[j] == 0) {
        used[j] = 1;
        res[i] = j;
        gen(i + 1);
        used[j] = 0;
      }
    }
  }
}

int main() {
  // входные данные
  cin >> n;
  n++;
  for (int i = 1; i &lt;= n; i++) {
    for (int j = 1; j &lt;= n; j++) {
      cin >> H[i][j];
    }
  }
  gen(1);
  cout &lt;&lt; sum;
}
</pre>
  </details>
</article>


<!-- Задача K. Поколение комбинаторов -->
<article class="article">
  <div class="anchor" id="task11"></div>
  <h3>Задача K. Поколение комбинаторов</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вхдной файл generation.in</p>
  <p>Выходной файл generation.out</p>

  <p>Сочетанием из n элементов по k называется убывающая последовательность из k чисел из диапазона от 1 до n.</p>
  <p>Сгенерируйте все сочетания из n элементов по k в антилексикографическом порядке, т.е. так, что для любых двух выведенных сочетаний первые l чисел равны, а l + 1-е в предыдущем больше, чем в следующем.</p>

  <h4>Входные данные</h4>
  <p>Во входном файле содержатся два челых числа n и k (1 ≤ k ≤ n ≤ 15).</p>

  <h4>Выходные данные</h4>
  <p>В выходной файл выведите все сочетания из n элементов по k в антилексикографическом порядке, по одному сочетанию на строку.</p>

  <h4>Пример</h4>
<pre>
3 2
</pre>
<pre>
3 2
3 1
2 1
</pre>
</article>


<!-- Задача L. Монеты -->
<article class="article">
  <div class="anchor" id="task12"></div>
  <h3>Задача L. Монеты</h3>

  <div><i>Ограничение по времени 4с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В Волшебной стране используются монетки достоинством A1, A2, ..., AM. Волшебный человечек пришел в магазин и обнаружил, что у него есть ровно по две монетки каждого достоинства. Ему нужно заплатить сумму N. Напишите программу, определяющую, сможет ли он расплатиться без сдачи.</p>

  <h4>Входные данные</h4>
  <p>Во входном файле записано сначала число N (1 ≤ N ≤ 10⁹), затем - число M (1 ≤ M ≤ 15) и далее M попарно различных чисел A1, A2, ..., AM (1 ≤ Ai ≤ 10⁹).</p>

  <h4>Выходные данные</h4>
  <p>Выведите сначала K – количество монет, которое придется отдать Волшебному человечку, если он сможет заплатить указанную сумму без сдачи. Далее выведите K чисел, задающих достоинства монет. Если решений несколько, выведите вариант, в котором Волшебный человек отдаст наименьшее возможное количество монет. Если таких вариантов несколько, выведите любой из них.</p>

  <p>Если без сдачи не обойтись, то выведите одно число 0. Если же у Волшебного человечка не хватит денег, чтобы заплатить указанную сумму, выведите одно число -1 (минус один).</p>

  <h4>Пример 1</h4>
<pre>
5 2
1 2
</pre>
<pre>
3
1 2 2
</pre>

  <h4>Пример 2</h4>
<pre>
7 2
1 2
</pre>
<pre>
-1
</pre>

  <h4>Пример 3</h4>
<pre>
5 2
3 4
</pre>
<pre>
0
</pre>
</article>


<!-- Задача M. Мирные ферзи -->
<article class="article">
  <div class="anchor" id="task13"></div>
  <h3>Задача M. Мирные ферзи</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Известно, что на шахматной доске размером 8 x 8 можно расставить 8 ферзей не бьющих друг друга, причем сделать это можно 92 способами.</p>

  <p>Дано натуральное n. Определите сколькими способами на доске n x n можно расставить n мирных ферзей.</p>

  <h4>Входные данные</h4>
  <p>Во входном файле одно число n(1 ≤ n ≤ 13)</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное число - ответ на задачу.</p>

  <h4>Пример</h4>
  <code>8</code>
  <code>92</code>
</article>


<!-- Задача V. Восстановление перестановки после слияния -->
<article class="article">
  <div class="anchor" id="task14"></div>
  <h3>Задача V. Восстановление перестановки после слияния</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Перестановкой длины n называется последовательность целых чисел от 1 до n длины n, содержащая каждое число ровно один раз. Например, [1], [4,3,5,1,2], [3,2,1] являются перестановками, а [1,1], [0,1], [2,2,1,4] — нет.</p>

  <p>Была задана перестановка p[1…n]. Она была слита сама с собой. Другими словами, были взяты две копии p и элементы второй копии p были вставлены в первую без изменения относительного порядка элементов. Результатом является последовательность длины 2n.</p>

  <p>Например, если p=[3,1,2], то некоторыми возможными результатами являются: [3,1,2,3,1,2], [3,3,1,1,2,2], [3,1,3,1,2,2]. Следующие последовательности не являются возможными результатами слияния: [1,3,2,1,2,3], [3,1,2,3,2,1], [3,3,1,2,2,1].</p>

  <p>Например, если p=[2,1], то возможными результатами являются: [2,2,1,1], [2,1,2,1]. Следующие последовательности не являются возможными результатами слияния: [1,1,2,2], [2,1,1,2], [1,2,2,1].</p>

  <p>Ваша задача — восстановить перестановку p по заданной результирующий последовательности a. Гарантируется, что ответ существует и единственен.</p>

  <p>Вам необходимо ответить на t независимых наборов тестовых данных.</p>

  <h4>Входные данные</h4>
  <p>Первая строка теста содержит одно целое число t (1 ≤ t ≤ 400) — количество наборов тестовых данных. Затем следуют t наборов тестовых данных.</p>

  <p>Первая строка набора тестовых данных содержит одно целое число n (1 ≤ n ≤ 50) — длину перестановки. Вторая строка набора тестовых данных содержит 2n целых чисел a1, a2, …, a2n (1 ≤ ai ≤ n), где ai — i-й элемент в a. Гарантируется, что массив a представляет собой результат слияния некоторой перестановки p с такой же перестановкой p.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора тестовых данных выведите ответ на него: n целых чисел p1, p2, …, pn (1 ≤ pi ≤ n), представляющих собой изначальную перестановку. Гарантируется, что ответ существует и единственен.</p>

  <h4>Пример</h4>
<pre>
5
2
1 1 2 2
4
1 3 1 4 3 4 2 2
5
1 2 1 2 3 4 3 5 4 5
3
1 2 3 1 2 3
4
2 3 2 4 1 3 4 1
</pre>
<pre>
1 2
1 3 4 2
1 2 3 4 5
1 2 3
2 3 4 1
</pre>
</article>


<!-- Задача W. Перестановка подпоследовательности -->
<article class="article">
  <div class="anchor" id="task15"></div>
  <h3>Задача W. Перестановка подпоследовательности</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Дана строка s длины n, состоящая из строчных букв английского алфавита.</p>

  <p>Вы должны выбрать некоторое число k между 0 и n. Затем вы выбираете некоторые k символов s и переставляете их как угодно. При этом позиции остальных символов n-k остаются неизменными. Эту операцию нужно выполнить ровно один раз.</p>

  <p>Например, если s="andrea", то можно выбрать k=4 символов "a_d_ea" и переставить их в порядке "d_e_aa" так, чтобы после операции строка стала "dneraa".</p>

  <p>Определите минимально возможное значение k, выбрав которое можно отсортировать s в алфавитном порядке (то есть, чтобы после операции ее символы располагались в алфавитном порядке).</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно целое число t (1≤t≤1000) — количество наборов входных данных. Затем следуют t наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит одно целое число n (1≤n≤40) — длину строки.</p>

  <p>Вторая строка каждого набора входных данных содержит строку s. Гарантируется, что s содержит только строчные буквы английского алфавита.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите минимальное значение k, которое позволяет получить строку, отсортированную по алфавиту, с помощью операции, описанной выше.</p>

  <h4>Пример</h4>
<pre>
4
3
lol
10
codeforces
5
aaaaa
4
dcba
</pre>
<pre>
2
6
0
4
</pre>
  <p>В первом наборе входных данных мы можем выбрать k=2 символа "_ol" и переставить их как "_lo" (так что результирующая строка будет "llo"). Невозможно отсортировать строку, выбирая строго менее 2 символов.</p>

  <p>Во втором наборе входных данных одним из возможных способов сортировки s является рассмотрение k=6 символов "_o__force_" и перестановка их как "_c__efoor_" (так что результирующая строка будет "ccdeefoors"). Можно показать, что невозможно отсортировать строку, выбирая строго меньше 6 символов.</p>

  <p>В третьем наборе входных данных, строка s уже отсортирована (поэтому мы можем выбрать k=0 символов).</p>

  <p>В четвертом наборе входных данных мы можем выбрать все k=4 символов "dcba" и перевернуть всю строку (так что результирующая строка будет "abcd").</p>
</article>


<!-- Задача X. CQXYM считает перестановки -->
<article class="article">
  <div class="anchor" id="task16"></div>
  <h3>Задача X. CQXYM считает перестановки</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>CQXYM считает перестановки длины 2n.</p>

  <p>Перестановкой является массив, состоящий из n различных целых чисел от 1 до n в произвольном порядке. Например, [2,3,1,5,4] — перестановка, но [1,2,2] не перестановка (2 встречается в массиве дважды) и [1,3,4] тоже не перестановка (n=3, но в массиве встречается 4).</p>

  <p>Перестановка p(длины 2n) будет посчитана только в том случае, если количество i, удовлетворяющих pᵢ &lt; pᵢ₊₁, не меньше n. Например:</p>
  <ul>
    <li>Перестановка [1,2,3,4] будет посчитана, так как количество таких i что pᵢ &lt; pᵢ₊₁ равно 3 (i=1, i=2, i=3).</li>
    <li>Перестановка [3,2,1,4] не будет посчитана, так как количество таких i что pᵢ &lt; pᵢ₊₁ равно 1 (i=3).</li>
  </ul>

  <p>CQXYM хочет, чтобы вы помогли ему найти количество таких перестановок по модулю 1000000007 (10⁹+7).</p>

  <p>Операцией по модулю называется взятие остатка от деления. Например:</p>
  <ul>
    <li>7mod3=1, так как 7=3⋅2+1,</li>
    <li>15mod4=3, так как 15=4⋅3+3.</li>
  </ul>

  <h4>Входные данные</h4>
  <p>Входные данные состоят из нескольких тестовых примеров.</p>

  <p>Первая строка содержит целое число t (t ≥ 1) — количество тестовых примеров. Ниже приводится описание тестовых случаев.</p>

  <p>Единственная для каждого тестового случая строка содержит целое число n (1 ≤ n ≤ 10⁵).</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превосходит 10⁵</p>

  <h4>Выходные данные</h4>
  <p>Для каждого примера выведите ответ в отдельной строке.</p>

  <h4>Пример</h4>
<pre>
4
1
2
9
91234
</pre>
<pre>
1
12
830455698
890287984
</pre>
  <p>n=1, существует только одна перестановка, удовлетворяющая условию: [1,2].</p>

  <p>В перестановке [1,2], p1 &lt; p2, только i = 1 подходит под условие. Так как 1 ≥ n, Эта перестановка будет посчитана. В перестановке [2,1], p1 > p2. Так как 0 &lt; n, эта перестановка не будет посчитана.</p>

  <p>n=2, существует 12 перестановок: [1,2,3,4],[1,2,4,3],[1,3,2,4],[1,3,4,2],[1,4,2,3],[2,1,3,4],[2,3,1,4],[2,3,4,1],[2,4,1,3],[3,1,2,4],[3,4,1,2],[4,1,2,3].</p>
</article>


<!-- Задача Y. Николай и перестановка -->
<article class="article">
  <div class="anchor" id="task17"></div>
  <h3>Задача Y. Николай и перестановка</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У Николая есть массив a, состоящий из n различных целых чисел от 1 до n. Другими словами, массив Николая — это перестановка целых чисел от 1 до n.</p>

  <p>Николай решил, что будет лучше, если минимальный элемент его массива (то есть число 1) и максимальный элемент его массива (то есть число n) будут находиться как можно дальше друг от друга. Поэтому он решил ровно один раз поменять местами два каких-нибудь элемента таким образом, чтобы расстояние между минимальным и максимальным элементами стало максимально возможным. Расстоянием между двумя элементами называется модуль разности номеров позиций данных элементов.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных следует целое положительное число n (2 ≤ n ≤ 100) — количество элементов в массиве Николая.</p>

  <p>Во второй строке входных данных записаны различные целые числа a1, a2, ..., an (1 ≤ ai ≤ n), где ai равно элементу, который находится в i-й позиции в массиве Николая.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное целое число — максимальное расстояние между минимальным и максимальным элементами в массиве Николая, которое может быть получено с помощью ровно одного обмена местами двух элементов массива.</p>

  <h4>Пример 1</h4>
<pre>
5
4 5 1 3 2
</pre>
  <code>3</code>

  <h4>Пример 2</h4>
<pre>
7
1 6 5 3 4 7 2
</pre>
  <code>6</code>

  <h4>Пример 3</h4>
<pre>
6
6 5 4 3 2 1
</pre>
  <code>5</code>
  <p>В первом примере оптимального ответа можно добиться поменяв местами 1 и 2.</p>

  <p>Во втором примере минимальный и максимальный элементы будут находиться в разных концах массива, если поменять местами 7 и 2.</p>

  <p>В третьем примере расстояние между минимальным и максимальным элементов уже максимально возможное, поэтому нужно сделать какой-нибудь ничего не значащий обмен, например 5 и 2.</p>
</article>


<!-- Задача Z. Правильные скобочные последовательности -->
<article class="article">
  <div class="anchor" id="task18"></div>
  <h3>Задача Z. Правильные скобочные последовательности</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 512мб</i></div>

  <p>Скобочная последовательность — это строка, состоящая только из символов «(» и «)». Правильной скобочной последовательностью называется скобочная последовательность, которую можно преобразовать в корректное арифметическое выражение путем вставок между ее символами символов '1' и '+'. Например, скобочные последовательности «()()», «(())» — правильные (полученные выражения: «(1)+(1)», «((1+1)+1)»), а «)(» и «(» — нет.</p>

  <p>Вам дано целое число n. Ваша задача — построить и вывести ровно n различных правильных скобочных последовательностей длины 2n.</p>

  <h4>Входные данные</h4>
  <p>В первой строке задано одно целое число t (1 ≤ t ≤ 50) — количество наборов входных данных.</p>

  <p>Каждый набор входных данных состоит из одной строки, содержащей единственное целое число n (1 ≤ n ≤ 50).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите n строк, каждая из которых должна содержать одну правильную скобочную последовательность длины ровно 2n. Все скобочные последовательности, которые вы выводите для одного набора входных данных, должны быть различны (хотя они могут совпадать в разных наборах входных данных). Если ответов несколько, выведите любой из них. Можно показать, что ответ всегда существует.</p>

  <h4>Пример</h4>
<pre>
3
3
1
3
</pre>
<pre>
()()()
((()))
(()())
()
((()))
(())()
()(())
</pre>
</article>

