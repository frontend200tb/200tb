<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contests" target="_blank">ЯрГУ. Кружок. Школьники</a></p>
  <p><a href="https://vkvideo.ru/@sportprog_yarsu" target="_blank">vkvideo.ru/@sportprog_yarsu</a></p>
  <p>Автор кружка Игорь Маслеников</p>
  <p>Всего вышло 34 видео продолжительностью 80:48:04</p>
</article>


<article class="article">
  <h3>Шаблоны для вставки в программу</h3>

  <p>Подключаем все библиотеки</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;iomanip&gt;
</pre>

  <p>Подключаем пространство имен</p>
  <code>using namespace std;</code>

  <p>Ускорение ввода-вывода. Отключаем синхронизацию с C-потоками и отвязываем cin/cout для ускорения работы.</p>
<pre>
// ускорение ввода-вывода
ios_base::sync_with_stdio(false);
cin.tie(nullptr);
cout.tie(nullptr);
</pre>

  <p>Отладочный режим: если определён макрос _DEBUG, перенаправляем ввод/вывод в файлы input.txt и output.txt.</p>
<pre>
// условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif
</pre>

  <p>Несколько наборов тестовых данных</p>
<pre>
// число тестов
int t;
cin >> t;

while (t--) {

}
</pre>

  <p>Ввод строки целиком, вместе с пробельными символами.</p>
  <p>После чтения cin >> q; в буфере ввода остаётся символ перевода строки '\n'. Затем при первом вызове getline(cin, str); считывается этот оставшийся '\n' и строка str оказывается пустой. Нужно игнорировать оставшийся символ перевода строки.</p>
<pre>
int q;
cin >> q;
cin.ignore();
string str;
getline(cin, str);
</pre>
  <p>На Codeforces задачи в контестах нумеруются буквами от A до F. В задаче есть ограничение по времени и по памяти. Присутствует легенда.</p>
</article>


<article class="article">
  <h1>Занятие 1. Вводное</h1>
  <p>Конспект видео от 2024.09.14</p>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contest/549478" target="_blank">Codeforces Контест 549478</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
        <a href="#p1">Что необходимо для курса</a>
    <br><a href="#p2">Что необходимо для написания кода</a>
    <br><a href="#p3">Основы C++ 1. Вводное занятие</a>
  </p>
  <p>
        <a href="#task1">Задача A. Арбуз</a>
    <br><a href="#task2">Задача B. Слоник</a>
    <br><a href="#task3">Задача C. Мишка и старший брат</a>
    <br><a href="#task4">Задача D. A+B (пробная задача)</a>
    <br><a href="#task5">Задача E. Сумма</a>
    <br><a href="#task6">Задача F. Слово</a>
    <br><a href="#task7">Задача G. Петя и строки</a>
    <br><a href="#task8">Задача H. Матчи</a>
  </p>
</article>


<!-- Что необходимо для курса -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Что необходимо для курса</h3>

  <p>В этом курсе все лекции, задания, алгоритмы и структуры данных будут на языке C++</p>
  <p>Что необходимо для занятий спортивным программированием</p>
  <ol>
    <li>Скачать и установить Visual Studio 2022 Community</li>
    <li>Зарегистрироваться на CodeForces</li>
  </ol>

  <h4>Успех в споривном программировании</h4>
  <p>Успех в спортивном программировании зависит от количества прорешанных задач</p>

  <h4>Рекомендуемая литература</h4>
  <p>Книга Лафоре ""Объектно-ориентированное программирование на C++"</p>
</article>


<!-- Что необходимо для написания кода -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>Что необходимо для написания кода</h3>

  <ol>
    <li>Открыть Visual Studio 2022</li>
    <li>В открывшемся окне <strong>Visual Studio 2022</strong> выбираем
      <code>Создание проекта</code>
    </li>
    <li>В открывшемся окне <strong>Создание проекта</strong> выбираем
      <code>Консольное приложение (C++ Windows Консоль)</code>
      <p>Нажимаем <strong>Далее</strong></p>
    </li>
    <li>В открывшемся окне <strong>Настроить новый проект</strong> заполняем
      <code>Имя проекта - sportprog</code>
      <code>Расположение - D:\code\sportprog</code>
      <p>Нажимаем <strong>Создать</strong></p>
    </li>
  </ol>
</article>


<!-- Основы C++ 1. Вводное занятие -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>Основы C++ 1. Вводное занятие</h3>

  <p>Программа на языке C++ состоит из шести частей.</p>
  <ol>
    <li>Библиотеки</li>
    <li>Пространство имен</li>
    <li>Глобальные переменные</li>
    <li>Структуры и классы</li>
    <li>Функции. Задачи разбиваются на маленькие подзадачи.</li>
    <li>Функция main</li>
  </ol>

  <h4>Тип данных int</h4>
  <p>Занимает 4 байта. Хранит числа от -2<sup>31</sup> до 2<sup>31</sup> - 1 (от -10<sup>9</sup> до 10<sup>9</sup>)</p>

  <h4>Тип данных long long</h4>
  <p>Занимает 8 байт. Хранит числа от -2<sup>63</sup> до 2<sup>63</sup> - 1 (от -8*10<sup>18</sup> до 8*10<sup>18</sup>)</p>

  <h4>Тип unsigned int</h4>
  <p>Занимает 4 байта. Хранит числа от 0 до 2<sup>32</sup> - 1.</p>

  <h4>Тип данных double</h4>
  <p>Занимает 8 байт. Хранит 16 соседних знаков. Вещественное число представляется числом с точкой. Есть цифры до точки и после точки. Количество цифр слева от точки плюс количество цифр справа от точки не может быть больше 16.</p>

  <h4>Тип данных long double</h4>
  <p>Занимает 10 байт. Хранит 20 соседних знаков.</p>

  <h4>Тип данных bool</h4>
  <p>Занимает 1 байт. Хранит только два значения либо true, либо false.</p>

  <h4>Тип данных char</h4>
  <p>Занимает 1 байт. Хранит число от 0 до 255. Это число соответствует символу из таблицы символов ASCII.</p>

  <h4>Переменные</h4>
  <p>Чтобы сохранить в памяти какую-нибудь информацию, нужно создать переменную. Сначала пишется тип переменной, который мы выбираем из стандартных типов, или создаем свой собственный тип. Потом пишется ее имя, которое мы придумываем сами.</p>
  <code>int a;</code>
  <p>При создании переменной в ней хранится минимальное значение из диапазона. Если значение переменной известно заранее, то при создании переменную можно сразу инициализировать.</p>
  <code>int b =10;</code>

  <h4>Ограничения</h4>
  <p>Все задачи по спортивному программированию имеют два ограничения: по времени и по памяти. Ограничение по времени нужно для того чтобы программа не работала бесконечно, а выдавала ответ, например, за две секунды. Ограничение по памяти нужно для того чтобы программа не заняла всю свободную память для своих нужд, а занимала , например, не более 256 мегабайт.</p>

  <h4>Ввод и вывод информации</h4>
  <p>Ввод информации используется для получения исходных данных для задачи. Вывод информации используется для выдачи результата работы программы. Для потокового ввода и вывода необходимо подключить библиотеку iostream</p>
  <code>include &lt;iostream&gt;</code>
  <p>Для сокращения названия функций для ввода и вывода информации, необходимо подключить пространство имен</p>
  <code>using namespace std;</code>
  <p>Теперь вместо std::cin можно писать cin, вместо std::cout можно писать cout.</p>
  <p>Для ввода данных в одну переменную надо написать</p>
  <code>cin >> a;</code>
  <p>Такая операция ввода вернет объект cin, который можно использовать еще раз. И так далее по цепочке. Поэтому для ввода данных в несколько переменных можно написать</p>
  <code>cin >> a >> b >> c;</code>
  <p>Для вывода числа 5 надо написать</p>
  <code>cout &lt;&lt; 5;</code>
  <p>Такая операция ввода вернет объект cout, который можно использовать еще раз. И так далее по цепочке. Поэтому для вывода нескольких данных можно написать</p>
  <code>cout &lt;&lt; 5 &lt;&lt; ' ' &lt;&lt; 3 &lt;&lt; ' ' &lt;&lt; 9;</code>
  <p>Между данными необходимо использовать символ разделитель, например пробел.</p>

  <h4>Асимптотика</h4>
  <p>В зависимости от входных параметров, праграмма выполнит определенное количество действий. Асимптотика это оценка количества действий программы (оценка сложности, трудоемкости). В спортивном программировании всегда подсчитывают наихудшую асимптотику. Потому что на тестовых данных всегда будет тест на очень больших входных данных, который проверяет наихудшую асимптотику программы.</p>
  <p>Обычно за 1 секунду компьютер выполняет около 4*10⁹ простейших операций. Эта константа связана с железом на котором работает сервер. Бывают серверы по-мощнее, бывают по-слабее. Это средняя оценка.</p>

  <h4>Линейная сложность O(n)</h4>
  <p>Если входные данные n ≤ 10⁵. И мы выполняем один цикл по всем входным данным, то будет выполнено c * n  = c * 10⁵ операций, где c это некоторая константа.</p>
  <p>Поскольку 4*10⁹ > 10⁵, то алгоритм с линейной сложностью <strong>решит</strong> задачу за 1 секунду.</p>

  <h4>Квадратичная сложность O(n²)</h4>
  <p>Если входные данные n ≤ 10⁵. И мы выполняем два вложенных цикла по всем входным данным, то будет выполнено c * n²  = c * 10¹⁰ операций, где c это некоторая константа.</p>
  <p>Поскольку 10¹⁰ > 4*10⁹, то алгоритм с квадратичной сложностью <strong>не решит</strong> задачу за 1 секунду.</p>

  <h4>Массивы</h4>
  <p>Массив это набор подряд идущих ячеек памяти с одним типом данных. Массив может быть статический или динамический.</p>
  <p>Создадим динамический массив через указатель</p>
  <code>int *A;</code>
  <p>Создав указатель, мы можем выделить нужное количество элементов начиная с этого места. Выделим память необходимую для хранения n элементов типа int</p>
  <code>A = new int[n];</code>
  <p>Чтобы обратиться к элементу под номером i в массиве, нужно написать имя массива и в квадратных скобках номер элемента</p>
  <code>A[i] = 15;</code>
  <p>В динамическом массиве число элементов неизвестно на этапе компиляции, а определяется во время выполнения программы. Поэтому и память под массив выделяется во время выполнения программы.</p>
  <p>Создадим статический массив на 100 элементов типа int</p>
  <code>int B[100];</code>
  <p>Размер статического массива указан в тексте программы и известен до ее компиляции. Поэтому память под массив выделяется во время компиляции программы и во время выполнения размер массива не изменяется.</p>

  <h4>Многомерный массив</h4>
  <p>Создадим статический двумерный массив на 100 элементов, каждый из которых содержит еще 100 элементов.</p>
  <code>int A[100][100];</code>
  <p>Для обращения к элементу двумерного массива нужно после имени массива указать два индекса</p>
  <code>A[i][j] = 15;</code>
  <p>Массивы больше чем двумерные не используют в спортивном программировании, потому что они занимают слишком много памяти.</p>
  <p>Создание и инициализация массива, например, нулями потребляет время и память. Поэтому ограничение на максимальный размер массива накладывается способностью создать массив, например за 1 секунду. За одну секунду можно создать массив из 10⁶ элементов. Если это массив целых чисел, которые занимают по 4 байта, то такой массив займет 4 мегабайта памяти.</p>

  <h4>Преобразования типов данных</h4>
  <p>Разделяют два способа преобразования типов данных : явный и неявный. Если мы выполняем математическую операцию с переменными разных типов данных, то они сначала приводятся к одному типу данных, затем с ними выполняется математическая операция. Компьютер может выполнять математические операции только с переменными одинакового типа.</p>

  <h4>Неявное преобразование</h4>
  <p>При делении двух целых чисел происходит целочисленное деление, которое возвращает целое число</p>
  <code>int a = 33 / 5; // a = 6</code>
  <p>Если одно из цедых чисел умножить на вещественное, то произойдет неявное преобразование целого числа к вещественному. Дальше при делении произойдет неявное преобразование второго целого числа к вещественному. При делении двух вещественных чисел происходит обычное деление, которое возвращает вещественное число</p>
  <code>double a = (1.0 * 33) / 5; // a = 6.6</code>
  <p>При неявном преобразовании мы не прописываем тип данных, в который нужно преобразовать.</p>

  <h4>Явное преобразование</h4>
  <p>Мы сами преобразовываем одно из целых чисел в вещественное явным способом через оператор double</p>
  <code>double a = double(33) / 5; // a = 6.6</code>
  <p>При явном преобразовании мы прописываем тип данных, в который нужно преобразовать.</p>
</article>


<!-- Задача A. Арбуз -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Арбуз</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 64мб</i></div>

  <p>В один из жарких летних дней Петя и его друг Вася решили купить арбуз. Они выбрали самый большой и спелый, на их взгляд. После недолгой процедуры взвешивания весы показали w килограмм. Поспешно прибежав домой, изнемогая от жажды, ребята начали делить приобретенную ягоду, однако перед ними встала нелегкая задача. Петя и Вася являются большими поклонниками четных чисел, поэтому хотят поделить арбуз так, чтобы доля каждого весила именно четное число килограмм, при этом не обязательно чтобы доли были равными по величине. Ребята очень сильно устали и хотят скорее приступить к трапезе, поэтому вы должны подсказать им, удастся ли поделить арбуз, учитывая их пожелание. Разумеется, каждому должен достаться кусок положительного веса.</p>

  <h4>Входные данные</h4>
  <p>В первой и единственной строке входных данных записано челое число w (1 ≤ w ≤ 100) вес арбуза</p>

  <h4>Выходные данные</h4>
  <p>Выведите YES, если ребята смогут поделить арбуз на две части, каждая из которых весит четное число килограммм, и NO в противном случае</p>

  <details>
    <summary>Пример</summary>
    <code>8</code>
    <code>YES</code>
  </details>


  <details>
    <summary>Решение на C++</summary>

    <div>
      <a href="https://codeforces.com/contest/4/problem/A" target="_blank">Задача 4А</a>
      <br><a href="https://codeforces.com/contest/4" target="_blank">Codeforces Beta Round 4 (Дивизион 2) 2010-03-12</a>
    </div>

    <h4>Проверка четности веса арбуза</h4>
    <p>Для решения задачи необходимо определить, можно ли разделить арбуз весом w килограмм на две части, каждая из которых будет весить четное количество килограмм.</p>
    <p>Для этого нужно проверить 2 условия. w должно быть четным числом, так как сумма двух четных чисел всегда четная. w должно быть больше или равно 4, так как минимальный вес каждой части должен быть 2 кг (наименьшее четное положительное число).</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int w;
  cin >> w;

  // решение и вывод результата
  if (w % 2 == 0 && w >= 4) {
    cout &lt;&lt; "YES";
  } else {
    cout &lt;&lt; "NO";
  }
}
</pre>
  </details>

  <p>После 2020 года можно писать <strong>and</strong> вместо <strong>&&</strong></p>
  <p>Если в функции int main() не написан return, то компилятор сам добавит return 0; в конце</p>

  <details>
    <summary>Решение на Node.js</summary>
<pre>
const readline = require('readline');
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

rl.on('line', (input) => {
  const w = parseInt(input);

  if (w % 2 === 0 && w >= 4) {
    console.log("YES");
  } else {
    console.log("NO");
  }

  rl.close();
});
</pre>
  <p>Модуль readline используется для чтения данных из стандартного потока ввода (stdin). Создаётся интерфейс rl, который связывает stdin и stdout.</p>
  <p>Когда пользователь вводит данные и нажимает Enter, срабатывает событие line. Введённые данные передаются в функцию обратного вызова как строка.</p>
  <p>Введённая строка преобразуется в число с помощью parseInt.</p>
  <p>После обработки ввода интерфейс закрывается с помощью rl.close().</p>
  </details>
</article>


<!-- Задача B. Слоник -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Слоник</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Слоник решил сходить в гости к другу. Оказалось, что дом слоника находится в точке 0, а дом его друга в точке x (x > 0) координатной прямой. За один шаг слоник может переместиться на 1, 2, 3, 4 или 5 позиций вперед. Помогите ему определить, за какое минимальное количество шагов он может добраться додома друга</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных записано одно целое число x (1 ≤ x ≤ 1000000) - координата дома друга слоника</p>

  <h4>Выходные данные</h4>
  <p>Выведите минимальное количество шагов, которые необходимо сделать слонику, чтобы попасть из точки 0 в точку x</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>5</code>
    <code>1</code>

    <h4>Пример 2</h4>
    <code>12</code>
    <code>3</code>
  </details>

  <details>
    <summary>Решение на C++</summary>

    <div>
      <a href="https://codeforces.com/contest/617/problem/A" target="_blank">Задача 617А</a>
      <br><a href="https://codeforces.com/contest/617" target="_blank">Codeforces Round 340 (Div. 2) 2016-01-23</a>
    </div>

    <p>Чтобы минимизировать количество шагов, слоник должен делать максимально возможные шаги (т.е. шаги по 5 позиций). После этого, если останется расстояние, которое меньше 5, он сделает один дополнительный шаг.</p>
    <p>Выражение (x + 4) / 5 эквивалентно округлению вверх результата деления x на 5.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int x;
  cin >> x;

  // решение и вывод результата
  cout &lt;&lt; (x + 4) / 5;
}
</pre>
  </details>

  <details>
    <summary>Решение на Node.js</summary>
<pre>
const readline = require('readline');

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

rl.on('line', (input) => {
  const x = parseInt(input);

  const res = Math.floor((x + 4) / 5);
  console.log(res);

  rl.close();
});
</pre>
  </details>
</article>


<!-- Задача C. Мишка и старший брат -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Мишка и старший брат</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Мишка Лимак хочет стать самым большим медведем, ну, или хотя бы стать больше своего старшего брата Боба. Сейчас вес Лимака равен a, а вес Боба равен b. Гарантируется, что вес Лимака меньше или равен весу Боба. Лимак ест много, и его вес утраивается каждый год, а вес Боба удваивается каждый год. Через сколько целых лет Лимак станет строго больше (т. е. будет весить строго больше) Боба?</p>

  <h4>Входные данные</h4>
  <p>В единственной строке находятся два целых числа a и b (1 ≤ a ≤ b ≤ 10) — веса Лимака и Боба соответственно.</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно целое число — через сколько целых лет Лимак станет строго больше Боба.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>4 7</code>
    <code>2</code>
    <p>В первом примере изначально вес Лимака равен 4, а вес Боба — 7. Через год их веса равны 4·3=12 и 7·2=14 соответственно (один вес утроился, а второй удвоился). Лимак все еще не больше Боба. Через два года их веса равны 36 и 28, то есть вес Лимака больше, чем вес Боба. Лимак стал больше Боба через два года, поэтому вы должны вывести 2.</p>

    <h4>Пример 2</h4>
    <code>4 9</code>
    <code>3</code>
    <p>Во втором примере веса Лимака и Боба в последующие года равны: 12 и 18, затем 36 и 36, и наконец 108 и 72 (через три года). Ответ равен 3. Помните, что Лимак хочет стать строго больше Боба, и его не устроят равные веса.</p>

    <h4>Пример 3</h4>
    <code>1 1</code>
    <code>1</code>
    <p>В третьем примере Лимак станет больше Боба через один год, их веса будут равны 3 и 2 соответственно. Цикл продолжается, пока вес Лимака не станет строго больше веса Боба.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/791/problem/A" target="_blank">Задача 791А</a>
      <br><a href="https://codeforces.com/contest/791" target="_blank">Codeforces Round 405 (рейтинговый, Div. 2, по задачам VK Cup 2017 Раунд 1) 2017-03-18</a>
    </div>

    <p>В цикле while обновляем веса Лимака и Боба каждый год. Увеличиваем счетчик лет на каждом шаге.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int a, b;
  cin >> a >> b;

  // решение
  int years  = 0; // Счетчик лет
  while (a &lt;= b) {
    a *= 3;
    b *= 2;
    years++;
  }

  // вывод результата
  cout &lt;&lt; years;
}
</pre>
  </details>
</article>


<!-- Задача D. A+B (пробная задача) -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. A+B (пробная задача)</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Заданы два целых числа a и b. Выведите a+b</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных в тесте. Далее следуют t наборов входных данных. Каждый набор задан одной строкой, которая содержит два целых числа a, b (-1000 ≤ a, b ≤ 1000).</p>

  <h4>Выходные данные</h4>
  <p>Выведите t целых чисел — искомые суммы a + b для каждого набора входных данных.</p>

  <details>
    <summary>Пример</summary>
<pre>
4
1 5
314 15
-99 99
123 987
</pre>
<pre>
6
329
0
1110
</pre>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1351/problem/A" target="_blank">Задача 1351А</a>
      <br><a href="https://codeforces.com/contest/1351" target="_blank">Testing Round 16 (Unrated) 2020-05-07</a>
    </div>

<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int t;
  cin >> t;

  for (int test = 0; test &lt; t; test++) {
    int a, b;
    cin >> a >> b;

    // вывод результата
    cout &lt;&lt; a + b &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача E. Сумма -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Сумма</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам даны три целых числа a, b и c. Определите, является ли одно из них суммой двух других.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит число t (1 ≤ t ≤ 9261) — количество наборов входных данных. Описание каждого набора состоит из 3 чисел a, b, c (0 ≤ a, b, c ≤ 20).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора выведите «YES», если одно из чисел равно сумме двух других, и «NO» в противном случае. Вы можете вывести ответ в любом регистре (например, строки «YEs», «Yes», «Yes» и «YES» будут считаться как положительный ответ).</p>

  <details>
    <summary>Пример</summary>
<pre>
7
1 4 3
2 5 8
9 11 20
0 0 0
20 20 20
4 12 3
15 7 8
</pre>
<pre>
YES
NO
YES
YES
NO
NO
YES
</pre>
    <p>Примечание. В первом наборе 1+3=4. Во втором наборе ни одно из чисел не является суммой двух других. В третьем наборе 9+11=20.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1742/problem/A" target="_blank">Задача 1742А</a>
      <br><a href="https://codeforces.com/contest/1742" target="_blank">Codeforces Round 827 (Div. 4) 2022-10-13</a>
    </div>

    <p>Для каждого набора входных данных проверяем три условия: a = b + c, b = a + c, c = a + b</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int t;
  cin >> t;

  for (int test = 0; test &lt; t; test++) {
    int a, b, c;
    cin >> a >> b >> c;

    // решение и вывод результата
    if (a == b + c || b == a + c || c == a + b) {
      cout &lt;&lt; "YES" &lt;&lt; '\n';
    } else {
      cout &lt;&lt; "NO" &lt;&lt; '\n';
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача F. Слово -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Слово</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Васю очень огорчает, что многие люди в интернете смешивают маленькие и большие буквы в одном слове. Поэтому он решил разработать расширение для своего любимого браузера, которое меняет регистр букв в каждом слове так, чтобы оно либо состояло только из маленьких букв, либо, наоборот, только из больших. При этом в слове должно измениться как можно меньше букв. Например, слово HoUse должно замениться на house, а слово ViP — на VIP. В случае, если в слове содержится одинаковое количество маленьких и больших букв, нужно заменить все буквы на маленькие. Например, maTRIx нужно заменить на matrix. Ваша задача — обработать указанным способом одно заданное слово.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано слово s — оно состоит из больших и маленьких латинских букв и имеет длину от 1 до 100.</p>

  <h4>Выходные данные</h4>
  <p>Выведите исправленное слово s. Если в заданном слове s строго больше заглавных букв, приведите его к верхнему регистру, иначе — к нижнему.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>HoUse</code>
    <code>house</code>

    <h4>Пример 2</h4>
    <code>ViP</code>
    <code>VIP</code>

    <h4>Пример 3</h4>
    <code>maTRIx</code>
    <code>matrix</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/59/problem/A" target="_blank">Задача 59А</a>
      <br><a href="https://codeforces.com/contest/59" target="_blank">Codeforces Beta Round 55 (Div. 2) 2011-02-11</a>
    </div>

    <h4>Идея решения:</h4>
    <ol>
      <li>Подсчитаем количество больших и маленьких букв в слове.</li>
      <li>Если количество больших букв строго больше, чем маленьких, то преобразуем всё слово в верхний регистр.</li>
      <li>Иначе преобразуем всё слово в нижний регистр.</li>
    </ol>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main() {
  // ввод данных
  string s;
  cin >> s;

  // решение
  int upperCount = 0; // Счётчик больших букв
  int lowerCount = 0; // Счётчик маленьких букв

  // Подсчитываем количество больших и маленьких букв
  for (char c : s) {
    if (isupper(c)) {
      upperCount++;
    } else {
      lowerCount++;
    }
  }

  // Преобразуем слово в нужный регистр
  if (upperCount > lowerCount) {
    for (int i = 0; i &lt; s.length(); i++) {
      s[i] = toupper(s[i]);
    }
  }
  else {
    for (int i = 0; i &lt; s.length(); i++) {
      s[i] = tolower(s[i]);
    }
  }

  // вывод результата
  cout &lt;&lt; s;
}
</pre>
  </details>
</article>


<!-- Задача G. Петя и строки -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Петя и строки</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Маленький Петя очень любит подарки. Его мама подарила ему на день рождения две строки равной длины, состоящие из больших и маленьких букв латинского алфавита. Теперь Петя хочет сравнить эти строки лексикографически. При этом регистр букв значения не имеет, то есть большая буква считается эквивалентной соответствующей маленькой букве. Помогите Пете выполнить сравнение.</p>

  <h4>Входные данные</h4>
  <p>В каждой из первых двух строк записано по одной подаренной строке. Длина строк находится в пределах от 1 до 100 включительно. Гарантируется, что строки имеют одинаковую длину, а также состоят из больших и маленьких букв латинского алфавита.</p>

  <h4>Выходные данные</h4>
  <p>Если первая строка меньше второй, выведите «-1». Если вторая строка меньше первой, выведите «1». Если строки равны, выведите «0». Учтите, что регистр букв не учитывается при сравнении.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
aaaa
aaaA
</pre>
    <code>0</code>

    <h4>Пример 2</h4>
<pre>
abs
Abz
</pre>
    <code>-1</code>

    <h4>Пример 3</h4>
<pre>
abcdefg
AbCdEfF
</pre>
    <code>1</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/112/problem/A" target="_blank">Задача 112А</a>
      <br><a href="https://codeforces.com/contest/112" target="_blank">Codeforces Beta Round 85 (Div. 2 Only) 2011-09-03</a>
    </div>

    <h4>Идея решения:</h4>
    <ol>
      <li>Приведём обе строки к одному регистру (например, к нижнему), чтобы регистр не влиял на сравнение.</li>
      <li>Сравним строки посимвольно:</li>
    </ol>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main() {
  // ввод данных
  string s1, s2;
  cin >> s1 >> s2;

  // решение и вывод результата
  int len = s1.length();
  for (int i = 0; i &lt; len; i++) {
    if (toupper(s1[i]) &gt; toupper(s2[i])) {
      cout &lt;&lt; "1";
      return 0;
    } else if (toupper(s1[i]) &lt; toupper(s2[i])) {
      cout &lt;&lt; "-1";
      return 0;
    }
  }
  cout &lt;&lt; "0";
}
</pre>
  </details>
</article>


<!-- Задача H. Матчи -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Матчи</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Манао работает на спортивном телевидении. Он долгое время наблюдал за футбольными матчами чемпионата одной страны и начал замечать разные закономерности. Например, у каждой команды есть две формы: домашняя и выездная. Когда команда проводит матч на своем стадионе, футболисты надевают домашнюю форму, а когда на чужом — выездную. Единственное исключение из этого правила — когда цвет домашней формы принимающей команды совпадает с цветом формы гостей. В таком случае домашняя команда облачается в свою выездную форму. Цвета домашней и выездной формы для каждой команды различны.</p>

  <p>В чемпионате страны участвует n команд и он состоит из n·(n-1) матчей: каждая из команд принимает каждую другую команду на своем стадионе. Манао задумался, а сколько раз в течение одного чемпионата случится, что команда, играющая на своем стадионе, оденет выездную форму? Обратите внимание, что для подсчета этого количества порядок матчей не играет никакого значения.</p>

  <p>Вам даны цвета домашней и выездной формы каждой команды. Для удобства эти цвета пронумерованы целыми числами таким образом, что никакие два разных цвета не имеют одинаковый номер. Помогите Манао найти ответ на его вопрос.</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержится целое число n (2 ≤ n ≤ 30). В каждой из следующих n строк записана пара разделенных одним пробелом различных целых чисел hᵢ, aᵢ (1 ≤ hᵢ, aᵢ ≤ 100) — номер цвета домашней и выездной форм i-ой команды соответственно.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите количество матчей, в которых домашняя команда выступит в выездной форме.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
3
1 2
2 4
3 4
</pre>
    <code>1</code>
    <p>В первом тестовом примере чемпионат состоит из 6 матчей. Единственный поединок, в котором произойдет интересное нам событие — матч между командами 2 и 1 на стадионе команды 2.</p>

    <h4>Пример 2</h4>
<pre>
4
100 42
42 100
5 42
100 5
</pre>
    <code>5</code>
    <p>Во втором тестовом примере домашней команде придется сменить форму в матчах между командами: 1 и 2, 2 и 1, 2 и 3, 3 и 4, 4 и 2 (первой написана принимающая команда).</p>

  <h4>Пример 3</h4>
<pre>
2
1 2
1 2
</pre>
    <code>0</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/268/problem/A" target="_blank">Задача 268А</a>
      <br><a href="https://codeforces.com/contest/268" target="_blank">Codeforces Round 164 (Div. 2) 2013-01-28</a>
    </div>

<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;
  int d[30], v[30];
  for (int i = 0; i &lt; n; i++) {
    cin >> d[i] >> v[i];
  }

  // решение
  int res = 0;
  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; n; j++) {
      if (d[i] == v[j]) {
        res++;
      }
    }
  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>

