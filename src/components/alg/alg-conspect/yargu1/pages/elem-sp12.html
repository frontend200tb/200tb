<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contests" target="_blank">ЯрГУ. Кружок. Школьники</a></p>
  <p><a href="https://vkvideo.ru/@sportprog_yarsu" target="_blank">vkvideo.ru/@sportprog_yarsu</a></p>
</article>


<article class="article">
  <h1>Занятие 12. Структуры данных #1. stack, queue, deque</h1>
  <p>Конспект видео от 2024.11.30</p>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contest/570478" target="_blank">Codeforces Контест 570478</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
    <a href="#p1">Структуры данных #1. stack, queue, deque</a>
  </p>
  <p>
        <a href="#task1">Задача A. Последовательность</a>
    <br><a href="#task2">Задача B. Скобки Скобочки</a>
    <br><a href="#task3">Задача C. Скобочная последовательность</a>
    <br><a href="#task4">Задача D. Нужно больше деков</a>
    <br><a href="#task5">Задача E. Пробка в Цветочном городе</a>
    <br><a href="#task6">Задача F. Скобочки-2</a>
    <br><a href="#task7">Задача G. Модифицированный стек</a>
    <br><a href="#task8">Задача H. Модифицированная очередь - 2</a>
    <br><a href="#task9">Задача I. Настольный теннис</a>
    <br><a href="#task10">Задача J. Великое Лайнландское переселение</a>
    <br><a href="#task11">Задача K. Минимум на отрезке</a>
    <br><a href="#task12">Задача L. ПОЛИЗ</a>
    <br><a href="#task13">Задача M. Дикие обезьяны</a>
    <br><a href="#task14">Задача N. 38 попугаев</a>
    <br><a href="#task15">Задача O. Правильная скобочная подпоследовательность</a>
    <br><a href="#task16">Задача P. Гистограмма</a>
    <br><a href="#task17">Задача Q. Вежливые соседи</a>
    <br><a href="#task18">Задача R. Небоскрёбы (усложнённая версия)</a>
    <br><a href="#task19">Задача S. Майк и футы</a>
    <br><a href="#task20">Задача T. Две головы - лучше</a>
    <br><a href="#task21">Задача U. Последнее слово техники</a>
  </p>
</article>


<!-- Структуры данных #1. stack, queue, deque -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Структуры данных #1. stack, queue, deque</h3>

  <p><strong>Структура данных</strong> — это контейнер, который хранит данные в определенном макете/конструкции. Этот «макет/конструкция» позволяет структуре данных быть эффективной в некоторых операциях и неэффективной в других.</p>
  <p>Примеры из жизни: шкаф, ящик с инструментами, кладовка.</p>
  <p>Новые библиотеки:</p>
  <code>#include &lt;stack&gt;</code>
  <code>#include &lt;queue&gt;</code>
  <code>#include &lt;deque&gt;</code>

  <p><strong>Линейные</strong> структуры данных в области памяти идут друг за дружкой. Например: массивы, матрицы, deque ...</p>

  <p><strong>Нелинейные</strong> это деревовидные структуры данных и хеш-таблицы.</p>

  <p>Примеры структуры данных:</p>
  <ol>
    <li>Массивы</li>
    <li>Матрицы</li>
    <li>Связанные списки (не используется в <strong>спортпроге</strong>)</li>
    <li>stack</li>
    <li>queue</li>
    <li>set</li>
    <li>map</li>
    <li>Графы</li>
    <li>Деревья</li>
    <li>Хэш таблицы</li>
  </ol>

  <h4>Pair</h4>
  <p><strong>Pair</strong> это контейнер, который объединяет два элемента одного или разных типов данных. Он состоит из двух элементов: первого и второго (порядок должен быть фиксированным).</p>
  <p>Обращение к pair:</p>
<pre>
pair&lt;int, string&gt; my_p;
my_p.first = 10;
my_p.second = "123";
</pre>

  <p><strong>Pair</strong> может заменить классы/структуры при решении задач на олимпиадах:</p>
<pre>
pair&lt;pair&lt;int, string&gt;, pair&lt;int, int&gt; &gt; monster;

monster.first.second = "abcd";
monster.first.first = 10;
monster.second.first = 15;
</pre>

  <p><strong>Pair</strong> очень популярная в <strong>спортпроге</strong> потому что позволяет не использовать настоящую структуру. Работа с pair это ускорение написания кода.</p>
  <p>Мы можем сортировать структуры данных с <strong>pair</strong>. Например vector .</p>
<pre>
vector&lt;pair&lt;int, int&gt; &gt; A(n);
for (int i = 0; i &lt; n; i++) {
  cin >> A[i].first >> A[i].second;
}
sort(A.begin(), A.end());
</pre>

  <h4>Stack</h4>
  <p><strong>Stack</strong> - структура данных, которая работает по принципу LIFO (last-in first-out или ”последний вошел — первым вышел”) — первым всегда извлекается последний добавленный элемент.</p>

  <p>Примеры: стопка книжек, стопка карт, подносы в столовой.</p>

  <p>Объявление stack:</p>
  <code>stack&lt;тип данных&gt; имя;</code>

  <ol>
    <li>.empty() Проверяет, является ли stack пустым. true/false</li>
    <li>.pop() Удаляет элемент из верхней части stack.</li>
    <li>.push(a) Добавляет элемент в верхнюю часть stack.</li>
    <li>.size() Возвращает количество элементов в контейнере stack.</li>
    <li>.top() Возвращает ссылку на элемент в верхней части stack.</li>
  </ol>

  <h4>Queue</h4>
  <p><strong>Queue</strong> - контейнер, который работает по принципу FIFO (first-in first-out или ”первый вошел — первым вышел”) — первым всегда извлекается первый добавленный элемент. То есть это контейнер, аналогичный стандартной очереди, которая часто встречается в нашей повседневной жизни.</p>
  <p>Самый яркий пример честной очереди это очередь в поликлинику ранним утром.</p>

  <ol>
    <li>.back() Возвращает ссылку на последний элемент в queue.</li>
    <li>.empty() Проверяет, является ли queue пустым. true/false</li>
    <li>.front() Возвращает ссылку на первый элемент в начале queue.</li>
    <li>.pop() Удаляет элемент из начала queue.</li>
    <li>.push(a) Добавляет элемент в конец queue.</li>
    <li>.size() Возвращает количество элементов в контейнере queue.</li>
  </ol>

  <h4>Deque</h4>
  <p><strong>Deque</strong> представляет двухстороннюю очередь, ее еще называют двухглавой змеей.  Мы можем так же обращаться по элементам при помощи операторов []. На deque реализована такая структура данных как vector.</p>
  <p>Пример: котопес.</p>

  <ol>
    <li>.empty() Проверяет, является ли deque пустым. true/false</li>
    <li>.size() Возвращает количество элементов в контейнере deque.</li>
    <li>.pop_back() Удаляет элемент в конце deque.</li>
    <li>.pop_front() Удаляет элемент в начале deque.</li>
    <li>.push_back(a) Добавляет элемент в конец deque.</li>
    <li>.push_front(a) Добавляет элемент в начало deque.</li>
    <li>.front() Возвращает ссылку на первый элемент в deque.</li>
    <li>.back() Возвращает ссылку на последний элемент в deque.</li>
    <li>.begin() Возвращает итератор, указывающий на первый элемент.</li>
    <li>.end() Возвращает итератор, указывающий за последним элементом.</li>
    <li>.rbegin() Возвращает итератор, указывающий на последний элементом.</li>
    <li>.rend() Возвращает итератор, указывающий перед первым элементом.</li>
  </ol>
<pre>
deque&lt;int&gt; deq;
int tmp n;
cin >> n;
for (int i = 0; i &lt; n; i++) {
  cin >> tmp;
  deq.push_back(tmp);
}
sort(deq.begin(), deq.end());
for (int i = 0; i &lt; n; i++) {
  cout &lt;&lt; deq[i] &lt;&lt; " ";
}
</pre>
</article>


<!-- Задача A. Последовательность -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Последовательность</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 16мб</i></div>

  <p>Дана последовательность чисел, завершающаяся нулем. Вывести четные числа в прямом порядке, нечетные - в обратном.</p>

  <h4>Пример</h4>
  <code>13 2 4 21 45 67 23 46 20 1 0</code>
<pre>
2 4 46 20
1 23 67 45 21 13
</pre>

  <details>
    <summary>Решение</summary>
    <p>Решим при помощи структур данных, но без вектора.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;

using namespace std;

int main() {
  // ввод данных
  stack&lt;int&gt; st;
  queue&lt;int&gt; q;
  int tmp = 1;

  // решение
  while (tmp != 0) {
    cin >> tmp;
    if (tmp != 0) {
      if (tmp % 2 == 0) {
        q.push(tmp);
      } else {
        st.push(tmp);
      }
    }
  }

  // вывод результата
  while (!q.empty()) {
    cout &lt;&lt; q.front() &lt;&lt; " ";
    q.pop();
  }
  cout &lt;&lt; '\n';
  while (st.size() > 0) {
    cout &lt;&lt; st.top() &lt;&lt; " ";
    st.pop();
  }
}
</pre>
  </details>
</article>


<!-- Задача B. Скобки Скобочки -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Скобки Скобочки</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 16мб</i></div>

  <p>Определить, является ли скобочная последовательность правильной.</p>

  <h4>Входные данные</h4>
  <p>Задана последовательность скобок, состоящая из скобок (, ) и [, ].</p>

  <h4>Выходные данные</h4>
  <p>Вывести Yes, если последовательность правильная, No - в противном случае.</p>

  <h4>Пример 1</h4>
  <code>[()]</code>
  <code>Yes</code>

  <h4>Пример 2</h4>
  <code>([[]()])</code>
  <code>Yes</code>

  <h4>Пример 3</h4>
  <code>(([()([])]))[]</code>
  <code>Yes</code>

  <h4>Пример 4</h4>
  <code>((([)]))</code>
  <code>No</code>

  <details>
    <summary>Решение</summary>
    <p>Эта задача решается только через стек. Перебираем в цикле символы входной строки со скобками. Если стек пустой, то кладем символ в стек. Иначе проверяем, если символ - закрывающая скобка, а в стеке такая же открывающая, то удаляем последний символ из стека. Иначе кладем символ в стек.</p>
    <p>Когда цикл закончится, проверяем стек. Если он пуст, то на входе была правильная скобочная последовательность, иначе - неправильная</p>
<pre>
#include &lt;iostream&gt;
#include &lt;stack&gt;

using namespace std;

int main() {
  // ввод данных
  string s;
  cin >> s;

  // решение
  stack&lt;char&gt; st;
  for (int i = 0; i &lt; s.size(); i++) {
    if (st.size() == 0) {
      st.push(s[i]);
    } else {
      if (s[i] == ')' && st.top() == '(') {
        st.pop();
      } else if (s[i] == ']' && st.top() == '[') {
        st.pop();
      } else {
        st.push(s[i]);
      }
    }
  }

  // вывод результата
  if (st.empty() == true) {
    cout &lt;&lt; "Yes";
  } else {
    cout &lt;&lt; "No";
  }
}
</pre>
  </details>
</article>


<!-- Задача C. Скобочная последовательность -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Скобочная последовательность</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Правильная скобочная последовательность определяется следующим способом:</p>
  <ol>
    <li>пустая строка - правильная скобочная последовательность;</li>
    <li>если "s" - правильная скобочная последовательность, то "(s)" - тоже правильная скобочная последовательность;</li>
    <li>если "s" и "t" - правильные скобочные последовательности, то "st" - тоже правильная скобочная последовательность.</li>
  </ol>
  <p>Дана скобочная последовательность. Достройте ее до правильной, добавив в конец наименьшее возможное число символов. Если это сделать невозможно, выведите IMPOSSIBLE.</p>

  <h4>Входные данные</h4>
  <p>Во входных данных содержится единственная строка длиной от 1 до 200000 символов, состоящая только из скобок "(" и ")".</p>

  <h4>Выходные данные</h4>
  <p>Если невозможно достроить последовательность до правильной, добавив в ее конец некоторое количество символов, выведите IMPOSSIBLE. Иначе выведите правильную скобочную последовательность, полученную из исходной строки добавлением наименьшего числа символов в конец.</p>

  <h4>Пример 1</h4>
  <code>(()</code>
  <code>(())</code>

  <h4>Пример 2</h4>
  <code>(()())</code>
  <code>(()())</code>

  <h4>Пример 3</h4>
  <code>())(()</code>
  <code>IMPOSSIBLE</code>

  <h4>Пример 4</h4>
  <code>(()(()(</code>
  <code>(()(()()))</code>

  <details>
    <summary>Решение</summary>
    <p>Эта задача решается только через стек. Перебираем в цикле символы входной строки со скобками. Если символ - открывающая скобка, то кладем символ в стек. Если символ - закрывающая скобка, проверяем не пустой ли стек, Если не пустой, то удаляем последний символ из стека. Иначе невозможно достроить последовательность, выводим IMPOSSIBLE и заканчиваем программу.</p>
    <p>Если последовательность закончилась, проверяем стек и добавляем в конец исходной последовательности столько закрывающих скобок, сколько открывающих скобок осталось в стеке. Выводим правильную скобочную последовательность.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;stack&gt;
#include &lt;string&gt;

using namespace std;

int main() {
  // ввод данных
  string s;
  cin >> s;

  // решение
  stack&lt;char&gt; st;
  for (int i = 0; i &lt; s.size(); i++) {
    if (s[i] == '(') {
      st.push(s[i]);
    } else if (s[i] == ')') {
      if (st.empty()) {
        cout &lt;&lt; "IMPOSSIBLE";
        return 0;
      } else {
        st.pop();
      }
    }
  }

  for (int i = 0; i &lt; st.size(); i++) {
    s.append(")");
  }

  // вывод результата
  cout &lt;&lt; s;
}
</pre>
  </details>
</article>


<!-- Задача D. Нужно больше деков -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Нужно больше деков</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Восьмиклассник Всеволод начал изучать программирование, и первое что ему в этом деле понравилось - структуры данных! Особенно ему понравился дек, а он, как известно, любит изобретать.</p>

  <p>Всеволод хочет иметь интерактивную программу для работы с деком целых чисел, и он её подробно описал. Вводится одна из следующих команд: "push_back" - добавить элемент в конец дека, "pop_back" - удалить элемент из конца дека, "push_front" - добавить элемент в начало дека, "pop_front" - удалить элемент из начала дека, "show_front" - вывести на экран элемент стоящий в начале дека, "show_back" - вывести на экран элемент стоящий в конце дека.</p>

  <p>Так же Всеволод не хочет, чтобы каждый раз, когда он пытается удалить или показать элемент из пустого дека, программа не завершалась с ошибкой, а вместо этого, при попытке совершить такую операцию, выводить на экран сообщение "DEQUE IS EMPTY!".</p>

  <p>Каждый раз когда вводится команда добавления элмента в дек, после команды надо ввести добавляемое значение (целое число не превосходящее 10<sup>5</sup> по абсолютной величине). Каждый раз когда вводится команда показа элемента, нужно вывести нужное значение либо сообщение об ошибке.</p>

  <p>Команды добавления и удаления элемента из дека ничего не должны выводить, за исключением, быть может, сообщения об ошибке.</p>

  <p>Ну и как любая программа, она должна когда-нибудь завершиться, для этого нужно будет воспользоваться командой "Bye".</p>

  <p>Всеволод готовится к олимпиаде по программированию, поэтому у него нет времени для написания этой программы. Помогите Всеволоду написать её (даже если ваше имя тоже Всеволод).</p>

  <h4>Входные данные</h4>
  <p>На вход подаются описанные выше команды (без кавычек) пока не введется команда завершения. Обратите внимание на регистр входных и выходных данных.</p>

  <h4>Выходные данные</h4>
  <p>Вывести результаты работы команд, каждый с новой строки (без кавычек).</p>

  <h4>Пример</h4>
<pre>
push_back 1
push_back 2
push_front 3
show_front
pop_front
show_back
show_front
Bye
</pre>
<pre>
3
2
1
</pre>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;deque&gt;

using namespace std;

int main() {
  string in;
  deque&lt;int&gt; d;
  int num;

  do {
    cin >> in;
    if (in == "push_back") {
      cin >> num;
      d.push_back(num);
    } else if (in == "push_front") {
      cin >> num;
      d.push_front(num);
    } else if (in == "pop_back") {
      if (d.empty()) {
        cout &lt;&lt; "DEQUE IS EMPTY!" &lt;&lt; '\n';
      } else {
        d.pop_back();
      }
    } else if (in == "pop_front") {
      if (d.empty()) {
        cout &lt;&lt; "DEQUE IS EMPTY!" &lt;&lt; '\n';
      } else {
        d.pop_front();
      }
    } else if (in == "show_back") {
      if (d.empty()) {
        cout &lt;&lt; "DEQUE IS EMPTY!" &lt;&lt; '\n';
      } else {
        cout &lt;&lt; d.back() &lt;&lt; '\n';
      }
    } else if (in == "show_front") {
      if (d.empty()) {
        cout &lt;&lt; "DEQUE IS EMPTY!" &lt;&lt; '\n';
      } else {
        cout &lt;&lt; d.front() &lt;&lt; '\n';
      }
    }
  } while (in != "Bye");

  return 0;
}
</pre>
  </details>
</article>


<!-- Задача E. Пробка в Цветочном городе -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Пробка в Цветочном городе</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Вернувшись из Солнечного города, Незнайка рассказал всем своим друзьям, что у каждого коротышки может быть личный автомобиль. Тут же среди жителей Цветочного города нашлось так много желающих стать автомобилистами, что Винтику и Шпунтику пришлось наладить серийное производство автомобилей на газированной воде с сиропом. Теперь на перекрёстке улицы Колокольчиков и улицы Маргариток иногда возникают заторы из нескольких автомобилей.</p>

  <p>Улица Колокольчиков идёт с юга на север и имеет две полосы. Движение на ней правостороннее: по восточной полосе автомобили едут с юга на север, а по западной — с севера на юг. Улица Маргариток — однополосная и перпендикулярна улице Колокольчиков. По ней организовано одностороннее движение, имеющее разное направление от улицы Колокольчиков (см. рисунок).</p>

  <p>Вчера Незнайка шёл домой и увидел, что на улице Колокольчиков с разных сторон от перекрёстка с улицей Маргариток стоят автомобили. Кто-то из водителей хотел ехать прямо, кто-то налево или направо. Автомобиль способен проехать через перекрёсток за одну секунду, но если водитель совершает левый поворот, он должен сперва пропустить встречные автомобили, следующие прямо и направо. За сколько секунд все автомобили проехали перекрёсток, если считать, что новые автомобили за это время к перекрёстку не подъезжали?</p>

  <h4>Входные данные</h4>
  <p>В первой строке записана последовательность символов «F», «L» и «R», описывающая, куда хотели далее следовать водители автомобилей, подъехавших к перекрёстку с юга. «F» означает, что они ехали прямо, «L» — что поворачивали налево, «R» — что направо. Автомобили перечислены в порядке от самого близкого к перекрёстку до самого далёкого. Во второй строке в том же формате описаны автомобили, подъехавшие к перекрёстку с севера. Обе последовательности имеют длину от 1 до 1000.</p>

  <h4>Выходные данные</h4>
  <p>Выведите время в секундах, за которое все автомобили проехали перекрёсток.</p>

  <h4>Пример 1</h4>
<pre>
RLF
FF
</pre>
  <code>4</code>

  <h4>Пример 2</h4>
<pre>
L
L
</pre>
  <code>1</code>

  <details>
    <summary>Решение</summary>
    <p>Всего возможно четыре ситуации.</p>
    <ol>
      <li>С двух сторон едут прямо и направо. Тогда они проезжают за 1 секунду</li>
      <li>С одной стороны едут прямо и направо. Они проезают за 1 секунду. С другой стороны едут налево. Они ждут</li>
      <li>С одной стороны едут налево. Они ждут. С другой стороны едут прямо и направо. Они проезжают за 1 секунду.</li>
      <li>С двух сторон едут налево. Тогда они проезжают за 1 секунду</li>
    </ol>
<pre>
#include &lt;iostream&gt;
#include &lt;queue&gt;

using namespace std;

int main() {
  // ввод данных
  string kol; // машины на ул.Колокольчиков
  string mar; // машины на ул.Маргариток
  cin >> kol >> mar;

  // решение
  int s = 0; // время в секундах
  queue&lt;char&gt; K;
  queue&lt;char&gt; M;

  for (int i = 0; i &lt; kol.length(); i++) {
    K.push(kol[i]);
  }

  for (int i = 0; i &lt; mar.length(); i++) {
    M.push(mar[i]);
  }

  while (!K.empty() && !M.empty()) {
    char nextK = K.front();
    char nextM = M.front();

    if ((nextK == 'F' || nextK == 'R') && (nextM == 'F' || nextM == 'R')) {
      s++;
      K.pop();
      M.pop();
    } else if ((nextK == 'F' || nextK == 'R') && (nextM == 'L')) {
      s++;
      K.pop();
    } else if ((nextK == 'L') && (nextM == 'F' || nextM == 'R')) {
      s++;
      M.pop();
    } else if ((nextK == 'L') && (nextM == 'L')) {
      s++;
      K.pop();
      M.pop();
    }
  }

  s += K.size() + M.size();

  // вывод результата
  cout &lt;&lt; s;

  return 0;
}
</pre>
  </details>
</article>


<!-- Задача F. Скобочки-2 -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Скобочки-2</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 16мб</i></div>

  <p>Напомним, что называется правильной скобочной последовательностью:</p>
  <ol>
    <li>пустая строка является правильной скобочной последовательностью;</li>
    <li>если строка a — правильная скобочная последовательность, то строки (a), [a] — тоже правильные скобочные последовательности;</li>
    <li>если строки a и b — правильные скобочные последовательности, то строка ab — тоже правильная скобочная последовательность.</li>
  </ol>
  <p>Задана строка S, состоящая из квадратных и круглых скобок. Разрешается заменять квадратную открывающую скобку ([) на круглую открывающую (() и наоборот, а также квадратную закрывающую скобку (]) на круглую закрывающую ()) и наоборот.</p>

  <p>За одно действие разрешается изменить ровно один символ строки. Необходимо за минимальное число действий преобразовать S в правильную скобочную последовательность.</p>

  <h4>Входные данные</h4>
  <p>Дана строка S. Ее длина не превосходит 100 000 символов.</p>

  <h4>Выходные данные</h4>
  <p>Выведите искомое минимальное число действий или -1, если преобразовать S в правильную скобочную последовательность невозможно.</p>

  <h4>Пример 1</h4>
  <code>(())[]</code>
  <code>0</code>

  <h4>Пример 2</h4>
  <code>[(])</code>
  <code>2</code>

  <h4>Пример 3</h4>
  <code>((]]]</code>
  <code>-1</code>
</article>


<!-- Задача G. Модифицированный стек -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Модифицированный стек</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В этой задаче вам нужно написать программу которая будет поддерживать стек и обрабатывать запросы 3-х видов:</p>
  <ol>
    <li>ADD a - добавить число a в стек, a - не превосходит 10000 по абсолютной величине.</li>
    <li>POP - удалить верхнее число из стека, если стек пуст, то ничего не делать.</li>
    <li>MIN - вывести минимум в текущем стеке, а если стек пуст - вывести STACK IS EMPTY.</li>
  </ol>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных находится число T (1 ≤ T ≤ 2 * 10⁵) - число запросов В следующих T строках описан один из трёх вышеописанных запросов.</p>

  <h4>Выходные данные</h4>
  <p>Выводить нужно ответ на запрос MIN - вывести минимум в текущем стеке, а если стек пуст - вывести STACK IS EMPTY. Вывод на каждый запрос осуществлять в отдельной строке</p>

  <h4>Пример</h4>
<pre>
10
ADD 5
ADD 3
ADD 4
MIN
POP
POP
MIN
POP
MIN
POP
</pre>
<pre>
3
5
STACK IS EMPTY
</pre>

  <details>
    <summary>Решение</summary>
    <p>Для запоминания минимального элемента в стеке обычный стек, в каждой ячейке которого записан один элемент, не подойдет. Нужен стек с двумя элементами в каждой ячейке. Первый элемент это текущее значение, а второй элемент это минимильное значение от этой ячейки и ниже.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;stack&gt;

using namespace std;

int main() {
  // ввод данных
  int n, tmp;
  cin >> n;
  pair&lt;int, int&gt; buf;
  stack&lt;pair&lt;int, int&gt; &gt;st;
  string s;

  // решение
  for (int i = 0; i &lt; n; i++) {
    cin >> s;
    if (s == "ADD") {
      cin >> tmp;
      if (st.size() > 0) {
        buf.first = tmp;
        buf.second = min(tmp, st.top().second);
        st.push(buf);
      } else {
        buf.first = tmp;
        buf.second = tmp;
        st.push(buf);
      }
    }
    if (s == "POP") {
      if (st.size() > 0) {
        st.pop();
      }
    }

    // вывод результата
    if (s == "MIN") {
      if (st.size() > 0) {
        cout &lt;&lt; st.top().second &lt;&lt; '\n';
      } else {
        cout &lt;&lt; "STACK IS EMPTY\n";
      }
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача H. Модифицированная очередь - 2 -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Модифицированная очередь - 2</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В этой задаче вам нужно написать программу которая будет поддерживать очередь и обрабатывать запросы 3-х видов:</p>
  <ol>
    <li>ADD a - добавить число a в очередь, a - не превосходит 10000 по абсолютной величине.</li>
    <li>POP - удалить переднее число из очереди, если очередь пуста, то ничего не делать.</li>
    <li>MIN - вывести минимум в текущей очереди, а если очередь пуста - вывести QUEUE IS EMPTY.</li>
  </ol>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных находится число T (1 ≤ T ≤ 2 * 10<sup>5</sup>) - число запросов В следующих T строках описан один из трёх вышеописанных запросов.</p>

  <h4>Выходные данные</h4>
  <p>Выводить нужно ответ на запрос MIN - вывести минимум в текущей очереди, а если очередь пуста - вывести QUEUE IS EMPTY. Вывод на каждый запрос осуществлять в отдельной строке</p>

  <h4>Пример</h4>
<pre>
10
ADD 10
MIN
POP
ADD 10
ADD 15
MIN
POP
MIN
POP
MIN
</pre>
<pre>
10
10
15
QUEUE IS EMPTY
</pre>
</article>


<!-- Задача I. Настольный теннис -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача I. Настольный теннис</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>К теннисному столу выстроилась очередь из n человек. Сначала первые двое играют партию в теннис. Потом проигравший встаёт в конец очереди, а победитель играет со следующим человеком из очереди, и так далее. Они играют до тех пор, пока кто-нибудь не выиграет в k партиях подряд. Этот игрок признаётся победителем.</p>

  <p>Про каждого из участников вы знаете его силу игры в теннис, и у всех игроков они различны. В партии всегда побеждает игрок с большей силой. Определите, кто станет победителем.</p>

  <h4>Входные данные</h4>
  <p>В первой строке находятся два числа, разделённые пробелом: n и k (2 ≤ n ≤ 500, 2 ≤ k ≤ 10¹²) — количество людей и количество побед подряд, после которого игрок становится победителем, соответственно.</p>

  <p>В следующей строке содержится n целых чисел a₁, a₂, ..., aₙ (1 ≤ aᵢ ≤ n), выражающих силу игроков. Гарантируется, что эта строка содержит перестановку, то есть все aᵢ различны.</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно число — силу победителя.</p>

  <h4>Пример 1</h4>
<pre>
2 2
1 2
</pre>
  <code>2</code>

  <h4>Пример 2</h4>
<pre>
4 2
3 1 2 4
</pre>
  <code>3</code>
  <p>Партии во втором примере: 3 играет с 1. 3 побеждает, 1 идет в конец очереди. 3 играет с 2. 3 побеждает. У него две победы подряд, он становится победителем.</p>

  <h4>Пример 3</h4>
<pre>
6 2
6 5 3 1 2 4
</pre>
  <code>6</code>

  <h4>Пример 4</h4>
<pre>
2 10000000000
2 1
</pre>
  <code>2</code>

  <details>
    <summary>Решение</summary>
    <p>Победитель станет известен, когда кто-то выиграет k партий подряд или когда все сыграют хотябы по одному разу, в этом случае победит сильнейший при любом даже очень большом k, потому что все остальные подряд победы будут за ним</p>
<pre>
#include &lt;iostream&gt;
#include &lt;queue&gt;

using namespace std;

int main() {
  // ввод данных
  int n, gamer1, gamer2, tmp;
  long long k;
  queue&lt;int&gt; q;
  cin >> n >> k;
  cin >> gamer1 >> gamer2;

  // решение
  if (gamer2 > gamer1) {
    tmp = gamer2;
    gamer2 = gamer1;
    gamer1 = tmp;
  }
  for (int i = 2; i &lt; n; i++) {
    cin >> tmp;
    q.push(tmp);
  }
  int count_win = 0;
  int iter = 0;
  while (iter &lt; n && count_win &lt; k) {
    if (gamer1 > gamer2) {
      q.push(gamer2);
      count_win++;
      gamer2 = q.front();
      q.pop();
    } else {
      q.push(gamer1);
      gamer1 = gamer2;
      gamer2 = q.front();
      q.pop();
      count_win = 1;
    }
    iter++;
  }

  // вывод результата
  cout &lt;&lt; gamer1;
}
</pre>
  </details>
</article>


<!-- Задача J. Великое Лайнландское переселение -->
<article class="article">
  <div class="anchor" id="task10"></div>
  <h3>Задача J. Великое Лайнландское переселение</h3>

  <div><i>Ограничение по времени 0.8с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Лайнландия представляет из себя одномерный мир, являющийся прямой, на котором располагаются N городов, последовательно пронумерованных от 0 до N-1. Направление в сторону от первого города к нулевому названо западным, а в обратную — восточным.</p>

  <p>Когда в Лайнландии неожиданно начался кризис, все были жители мира стали испытывать глубокое смятение. По всей Лайнландии стали ходить слухи, что на востоке живётся лучше, чем на западе.</p>

  <p>Так и началось Великое Лайнландское переселение. Обитатели мира целыми городами отправились на восток, покинув родные улицы, и двигались до тех пор, пока не приходили в город, в котором средняя цена проживания была меньше, чем в родном.</p>

  <h4>Входные данные</h4>
  <p>В первой строке дано одно число N ( 2≤N≤10<sup>5</sup>) — количество городов в Лайнландии. Во второй строке дано N чисел a<sub>i</sub> ( 0≤a<sub>i</sub>≤10<sup>9</sup>) — средняя цена проживания в городах с нулевого по (N-1)-ый соответственно.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого города в порядке с нулевого по (N-1)-ый выведите номер города, в который переселятся его изначальные жители. Если жители города не остановятся в каком-либо другом городе, отправившись в Восточное Бесконечное Ничто, выведите -1</p>

  <h4>Пример</h4>
<pre>
10
1 2 3 2 1 4 2 5 3 1
</pre>
  <code>-1 4 3 4 -1 6 9 8 9 -1 </code>
</article>


<!-- Задача K. Минимум на отрезке -->
<article class="article">
  <div class="anchor" id="task11"></div>
  <h3>Задача K. Минимум на отрезке</h3>

  <div><i>Ограничение по времени 0.5с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Рассмотрим последовательность целых чисел длины N. По ней с шагом 1 двигается «окно» длины K, то есть сначала в «окне» видно первые K чисел, на следующем шаге в «окне» уже будут находиться K чисел, начиная со второго, и так далее до конца последовательности. Требуется для каждого положения «окна» определить минимум в нём.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных содержатся два числа N и K (1≤N≤150000, 1≤K≤10000, K≤N) — длины последовательности и «окна», соответственно. На следующей строке находятся N чисел — сама последовательность.</p>

  <h4>Выходные данные</h4>
  <p>Выходые данные должны содержать N-K+1 строк — минимумы для каждого положения «окна».</p>

  <h4>Пример</h4>
<pre>
7 3
1 3 2 4 5 3 1
</pre>
<pre>
1
2
2
3
1
</pre>
</article>


<!-- Задача L. ПОЛИЗ -->
<article class="article">
  <div class="anchor" id="task12"></div>
  <h3>Задача L. ПОЛИЗ</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Задано выражение в польской инверсной записи (ПОЛИЗ), в которой доступны операции +, -, *, /. Найти значение выражения с точностью до 4 знаков после запятой. О том что такое польская инверсная запись можно прочитать здесь:</p>

  <a href="http://ru.wikipedia.org/wiki/Обратная_польская_запись">http://ru.wikipedia.org/wiki/Обратная_польская_запись</a>

  <h4>Входные данные</h4>
  <p>Входные данные представляют собой строку - выражение в ПОЛИЗ.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите ответ - значение выражения с точностью до 4 знаков после запятой.</p>

  <h4>Пример 1</h4>
  <code>4 3 2 * 4 * + 37 2 - 3 2 * 5 + / +</code>
  <code>31.1818181818181798803379933815</code>

  <h4>Пример 2</h4>
  <code>37 2 - 3 2 * 5 + / 3 2 * 4 * + 4 +</code>
  <code>31.1818181818181798803379933815</code>
  <p>Тесты из примеров соответствуют следующему выражению:</p>
  <code>4 + 3 * 2 * 4 + (37 - 2) / (3 * 2 + 5)</code>
</article>


<!-- Задача M. Дикие обезьяны -->
<article class="article">
  <div class="anchor" id="task13"></div>
  <h3>Задача M. Дикие обезьяны</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>А тем временем в Южной Варляндии полным ходом шли исследования реки Шамазонки и области Шамазонии. Особенно поразили ученых шамазонские обезьяны. Чтобы добыть себе плоды, висящие на верхушке деревьев, им приходится выполнять тщательно взбираться по лианам, которые в свою очередь работают как весы: если на одной из лиан висит обезьян больше, чем на другой, то обе ветви разорвутся и все обезьяны упадут вниз. Поэтому важно сохранять баланс между ветвями деревьев. Лианы дерева могут содержать ровно две подлианы, каждая из которых должна содержать одинаковое количество обезьян. В данной задаче лиана, содержащая две подлианы, будет обозначаться двумя квадратными скобками «[]», причём подлианы могут содержать ещё подлианы и т.д. Гарантируется, что в данной задаче вложенность лиан не достигает 25 уровней. По заданной конфигурации дерева определите минимальное количество обезьян, которое необходимо, чтобы лианы были сбалансированы и обезьяны смогли получить плоды с верхушки дерева.</p>

  <h4>Входные данные</h4>
  <p>В единственной строке ввода содержится строка S - конфигурация лиан. S может иметь длину от 0 до 150 символов.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите минимальное количество обезьян, чтобы сбалансировать лианы.</p>

  <h4>Пример 1</h4>
  <code>[]</code>
  <code>2</code>

  <h4>Пример 2</h4>
  <code>[[][[]]]</code>
  <code>8</code>
  <p>Левый рисунок соответствует конфигурации и расположению обезьян в первом примере, правый - во втором.</p>
</article>


<!-- Задача N. 38 попугаев -->
<article class="article">
  <div class="anchor" id="task14"></div>
  <h3>Задача N. 38 попугаев</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Как известно, длина удава составляет 5 мартышек, 2 слоненка или 38 попугаев и одно попугайское крылышко из-за того, что звери не могут использовать метрическую систему. Доктор Айболит решил проверить, можно ли подобрать единицу измерения среди животных, выстроившихся к нему в очередь на прием.</p>

  <p>Лечение занимает большую часть времени доктора, поэтому заниматься измерениями он может только в свободное время.</p>

  <p>Приходя на прием к доктору, звери выстраиваются в очередь. Когда пациент встает в очередь, помощник доктора измеряет его длину и заносит результат измерения в список. Прием ведется в порядке очереди. После окончания прием пациент из списка вычеркивается. Периодически Айболит смотрит в список и пытается определить, есть ли в списке такой зверь, которым можно измерить всех остальных (ещё не вычеркнутых зверей из списка) так, чтобы их длины оказались целыми числами.</p>

  <p>Напишите программу, которая поможет доктору Айболиту.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных содержится число N (1≤N≤10<sup>5</sup>) – количество действий со списком пациентов. В следующих N строках содержится описание действий со списком пациентов. Действия бывают 3 видов:</p>
  <ol>
    <li>«+ X» – в очередь добавляется новый пациент длиной X (1≤X≤10<sup>9</sup>)</li>
    <li>«–» – из очереди удаляется пациент</li>
    <li>«?» – есть ли в очереди такой пациент, длиной которого можно измерить всех зверей, стоящих в очереди. Гарантируется, что очередь не пуста.</li>
  </ol>

  <h4>Выходные данные</h4>
  <p>Для каждого запроса вида «?» выведите «N», если в списке зверей нет того, которым можно измерить длины всех остальных зверей. В противном случае выведите «Y» и длину зверя, которым можно измерить длины всех остальных зверей.</p>

  <h4>Система оценки</h4>
  <p>Баллы за каждую подзадачу начисляются только в случае, если все тесты для этой подзадачи и необходимых подзадач успешно пройдены.</p>

  <h4>Пример 1</h4>
<pre>
10
+4
+2
?
+3
?
-
-
?
+1
?
</pre>
<pre>
Y2
N
Y3
Y1
</pre>

  <h4>Пример 2</h4>
<pre>
2
+5
?
</pre>
<pre>
Y5
</pre>
</article>


<!-- Задача O. Правильная скобочная подпоследовательность -->
<article class="article">
  <div class="anchor" id="task15"></div>
  <h3>Задача O. Правильная скобочная подпоследовательность</h3>

  <div><i>Ограничение по времени 5с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Напомним, что скобочная последовательность называется правильной, если путем вставки в нее символов «+» и «1» можно получить из нее корректное математическое выражение. Например, последовательности «(())()», «()» и «(()(()))» — правильные, в то время как «)(», «(()» и «(()))(» — нет.</p>

  <p>Однажды Васе попалась скобочная последовательность. Он решил удалить из нее некоторые скобки так, чтобы последовательность стала правильной. Какую наибольшую длину может иметь получившаяся правильная скобочная последовательность?</p>

  <h4>Входные данные</h4>
  <p>В первой строке входного файла записана непустая строка, состоящая из символов «(» и «)». Её длина не превосходит 10<sup>6</sup>.</p>

  <h4>Выходные данные</h4>
  <p>Выведите длину наибольшей правильной скобочной подпоследовательности.</p>

  <h4>Пример 1</h4>
  <code>(()))(</code>
  <code>4</code>

  <h4>Пример 2</h4>
  <code>((()())</code>
  <code>6</code>
</article>


<!-- Задача P. Гистограмма -->
<article class="article">
  <div class="anchor" id="task16"></div>
  <h3>Задача P. Гистограмма</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Гистограмма является многоугольником, сформированным из последовательности прямоугольников, выровненных на общей базовой линии. Прямоугольники имеют равную ширину, но могут иметь различные высоты. Например, фигура слева показывает гистограмму, которая состоит из прямоугольников с высотами 2, 1, 4, 5, 1, 3, 3. Все прямоугольники на этом рисунке имеют ширину, равную 1.</p>

  <p>Обычно гистограммы используются для представления дискретных распределений, например, частоты символов в текстах. Отметьте, что порядок прямоугольников очень важен. Вычислите область самого большого прямоугольника в гистограмме, который также находится на общей базовой линии. На рисунке справа заштрихованная фигура является самым большим выровненным прямоугольником на изображенной гистограмме.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входного файла записано число N (0&lt;N≤10<sup>6</sup>) — количество прямоугольников гистограммы. Затем следует N целых чисел h<sub>1</sub> ... h<sub>n</sub>, где 0≤h<sub>i</sub>≤10<sup>9</sup>. Эти числа обозначают высоты прямоугольников гистограммы слева направо. Ширина каждого прямоугольника равна 1.</p>

  <h4>Выходные данные</h4>
  <p>Выведите площадь самого большого прямоугольника в гистограмме. Помните, что этот прямоугольник должен быть на общей базовой линии.</p>

  <h4>Пример</h4>
  <code>7 2 1 4 5 1 3 3</code>
  <code>8</code>
</article>


<!-- Задача Q. Вежливые соседи -->
<article class="article">
  <div class="anchor" id="task17"></div>
  <h3>Задача Q. Вежливые соседи</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Игорь и Ира решили поехать на дачу, ведь там куча дел: прополоть и полить грядки, собрать урожай, окучить картошку, проверить сохранность забора, уточнить наличие ящиков для хранения урожая и много-много всего.</p>

  <p>Приехав на дачу, Игорь и Ира увидели, что никого из соседей не было. У Игоря и Иры все соседи на даче очень вежливые люди. Игорю стало интересно, кто из соседей уезжает с дачи каждый день, а кто остается ночевать. Для этого Игорь будет в течение дня записывать в блокнот следующие события:</p>
  <ul>
    <li>+ k – сосед из домика под номером k приехал на свою дачу.</li>
    <li>- k – сосед из домика под номером k сел в машину и собирается уехать.</li>
  </ul>

  <p>Дачные участки стоят вдоль узкой дороги и пронумерованы от 1 до N. Когда соседи приезжают на дачу, они всегда хотят встать рядом со своим участком k, ведь так гораздо удобней. Они могут это сделать только в том случае, если перед участками с 1-го по k-1-й не стоят машины. Если соседи не могут проехать к своему дому, тогда они оставляют свою машину на общей парковке перед дачами.</p>

  <p>Если сосед хочет уехать и его машина стоит на парковке, то он без проблем садится в машину и уезжает, если сосед хочет уехать и его машина стоит рядом с его участком, тогда он садится в машину и уезжает только в том случае, если на дороге не стоят машины перед участками с 1
   по k-1, иначе он сидит и ждет, как вежливый сосед, пока не уедут все машины, которые мешают, если этого не получилось, то он остается на даче.</p>

  <p>Соседи могут возвращаться и уезжать с дачи несколько раз.</p>

  <p>Помогите Игорю – определите, кто из соседей в конце дня остался ночевать на даче, кто – уехал домой, а кто из соседей вообще не приезжал на дачу.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит два целых числа N, M (1 ≤ N, M ≤ 10⁵) – количество соседей и количество записей.</p>

  <p>В следующих M строках содержатся записи в блокноте Игоря:</p>
  <ul>
    <li>+ k (1 ≤ k ≤ N) – на дачу с номером k приехал сосед.</li>
    <li>- k (1 ≤ k ≤ N) – с дачи номер k уезжает сосед.</li>
  </ul>

  <p>Гарантируется, что перед операцией '+' соседа нет ни на участке, ни в машине рядом с участком.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого i соседа выведите в i строке 'YES' (без кавычек), если сосед смог уехать домой, 'NO' (без кавычек), если сосед не уехал и остался ночевать на даче, '-1' (без кавычек) если сосед не приезжал на дачу.</p>

  <h4>Пример</h4>
<pre>
5 7
+ 3
+ 4
+ 2
- 4
- 3
+ 1
- 1
</pre>
<pre>
YES
NO
NO
YES
-1
</pre>

  <details>
    <summary>Решение</summary>
    <p>Решается методом стека с маркировкой. Каждого участника будем маркировать (надевать на него бейджик). Mark[i] = 0 если соседа не было на даче. Mark[i] = 1 если сосед приехал на дачу. Mark[i] = -1 если сосед уехал с дачи.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;stack&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  int n, m;
  cin >> n >> m;
  stack&lt;int&gt; st;
  st.push(n + 10); // несуществующий сосед
  vector&lt;int&gt; Pos(n + 11), Park(n + 11), Uch(n + 11), Mark(n + 11);
  char ch;
  int k;
  for (int i = 0; i &lt; m; i++) {
    cin >> ch >> k;

    // решение
    if (ch == '+') {
      Pos[k] = 1;
      Mark[k] = -1;
      if (st.top() &lt; k) {
        Park[k] = 1;
      } else {
        Uch[k] = 1;
        st.push(k);
      }
    } else {
      if (Park[k] == 1) {
        Mark[k] = 1;
        Park[k] = 0;
      } else {
        Uch[k] = -1;
        while (Uch[st.top()] == -1) {
          Uch[st.top()] = 0;
          Mark[st.top()] = 1;
          st.pop();
        }
      }
    }
  }

  // вывод результата
  for (int i = 1; i &lt;= n; i++) {
    if (Mark[i] == 0) {
      cout &lt;&lt; "-1\n";
    } else if (Mark[i] == 1) {
      cout &lt;&lt; "YES\n";
    } else {
      cout &lt;&lt; "NO\n";
    }
  }
}
</pre>
  </details>
</article>


<!-- R. Небоскрёбы (усложнённая версия) -->
<article class="article">
  <div class="anchor" id="task18"></div>
  <h3>Задача R. Небоскрёбы (усложнённая версия)</h3>

  <div><i>Ограничение по времени 3с
  <br>Ограничение по памяти 512мб</i></div>

  <p>Это более сложная версия задачи. В этой версии n≤500000</p>

  <p>В Берляндии активно застраивается окраина столицы. Компания «Kernel Panic» руководит постройкой жилого комплекса из небоскрёбов в Новой Берлскве. Все небоскрёбы строятся вдоль шоссе. Известно, что компания уже купила n участков возле шоссе и готовится возвести n небоскрёбов, по одному зданию на один участок.</p>

  <p>Архитекторы при планировании зданий должны учитывать несколько требований. Во-первых, поскольку земля на каждом участке имеет разные свойства, для каждого небоскрёба есть свое ограничение по количеству этажей, которое он может иметь. Во-вторых, согласно дизайн-коду города, недопустима ситуация, когда для какого-то небоскрёба сразу по обе стороны от него есть небоскрёбы выше него.</p>

  <p>Более формально, пронумеруем участки целыми числами от 1 до n. Тогда у небоскрёба на участке с номером i количество этажей a<sub>i</sub> не может быть больше m<sub>i</sub> (1≤a<sub>i</sub>≤m<sub>i</sub>). Также не может быть, что на плане существуют два участка с номерами j и k, таких что j &lt; i &lt; k и a<sub>j</sub> > a<sub>i</sub> &lt; a<sub>k</sub>. Участки j и k не обязаны быть соседними с i.</p>

  <p>Компания хочет, чтобы суммарное количество этажей в построенных небоскрёбах было как можно больше. Помогите ей выбрать количество этажей для каждого небоскрёба оптимальным образом, то есть так, чтобы выполнялись все ограничения, а среди всех таких вариантов выберите один из планов, в котором суммарное количество этажей максимально возможно.</p>

  <h4>Входные данные</h4>
  <p>В первой строке задано одно целое число n (1≤n≤500000) — количество участков.</p>

  <p>Вторая строка содержит целые числа m<sub>1</sub>,m<sub>2</sub>, ... ,m<sub>n</sub> (1≤ m<sub>i</sub> ≤ 10<sup>9</sup>) —максимально возможное количество этажей для небоскрёба на каждом участке.</p>

  <h4>Выходные данные</h4>
  <p>Выведите n чисел a<sub>i</sub> — количества этажей в плане для каждого небоскрёба, такие, что выполняются все ограничения, а суммарное количество этажей во всех небоскрёбах максимально возможное.</p>

  <p>Если возможно несколько ответов, выведите любой.</p>

  <h4>Пример 1</h4>
<pre>
5
1 2 3 2 1
</pre>
  <code>1 2 3 2 1</code>
  <p>В первом примере можно построить все небоскрёбы с максимально возможной высотой.</p>

  <h4>Пример 2</h4>
<pre>
3
10 6 8
</pre>
  <code>10 6 6</code>
  <p>Во втором примере придать максимальную высоту всем небоскрёбам нельзя, так как это нарушает ограничение дизайн-кода. Ответ [10,6,6]  является оптимальным. Обратите внимание, что ответ [6,6,8] также удовлетворяет всем ограничениям, но оптимальным не является.</p>
</article>


<!-- S. Майк и футы -->
<article class="article">
  <div class="anchor" id="task19"></div>
  <h3>Задача S. Майк и футы</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Майк — президент страны What-The-Fatherland. Помимо Майка, там живёт ещё n медведей. Все они стоят в ряд и пронумерованы от 1 до n слева направо. Рост i-го медведя составляет ровно ai футов.</p>

  <p>Назовём группой медеведей непустой непрерывный подотрезок этого ряда. Размер группы — это количество медведей в этой группе. Сила группы — это минимальная высота медведя в этой группе.</p>

  <p>Майку хочется знать для каждого x, такого что 1 ≤ x ≤ n, максимальную силу группы медведей размера x.</p>

  <h4>Входные данные</h4>
  <p>В первой строке ввода записано целое число n (1 ≤ n ≤ 2*10<sup>5</sup>), количество медведей.</p>

  <p>Во второй строке записано n целых чисел, разделенных пробелом, a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> (1 ≤ a<sub>i</sub> ≤ 10<sup>9</sup>) — высоты медведей.</p>

  <h4>Выходные данные</h4>
  <p>Выведите n целых чисел в одной строке. Для каждого x от 1 до n выведите максимальную силу среди всех групп размера x.</p>

  <h4>Пример</h4>
<pre>
10
1 2 3 4 5 4 3 2 1 6
</pre>
  <code>6 4 4 3 3 2 2 1 1 1</code>
</article>


<!-- T. Две головы - лучше -->
<article class="article">
  <div class="anchor" id="task20"></div>
  <h3>T. Две головы - лучше</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Ученый с мировым именем Иннокентий решил заняться теорией вычислимости и изобрел новый абстрактный исполнитель, представляющий собой ленту из n ячеек, в каждой из которых записана строчная латинская буква. По ленте ездят две головки, каждая из которых указывает на некоторую ячейку. Это устройство умеет исполнять следующие команды: перемещать заданную головку влево или вправо на одну ячейку, переворачивать ленту между головками, включая ячейки, на которые указывают головки, а также отвечать за запросы, на какой символ указывает заданная головка. Иннокентий попросил вас помочь ему проэмулировать работу этого устройства, потому что собственноручно написанная им программа работает слишком медленно.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записаны три целых числа через пробел: n, l и r (1 ≤ n ≤ 10<sup>5</sup>, 1 ≤ l &lt; r ≤ n) — количество ячеек ленты и начальные позиции левой и правой головок соответственно.</p>

  <p>Во второй строке записаны n строчных латинских букв — содержимое ячеек.</p>

  <p>В третьей строке записано единственное целое число m (1 ≤ m ≤ 3·10<sup>5</sup>) — количество запросов.</p>

  <p>Далее в m строках содержатся запросы следующего вида.</p>
  <ol>
    <li>S X Y — сдвинуть головку X в сторону Y, где X может принимать значения L для левой головки и R для правой головки, а Y может принимать значения L для сдвига влево и R для сдвига вправо.</li>
    <li>R — перевернуть ленту между головками, включая ячейки, на которые указывают головки.</li>
    <li>Q X — спросить, на какой символ указывает головка X, где X может принимать значения L для левой головки и R для правой головки.</li>
  </ol>

  <p>Гарантируется, что левая головка после любого запроса остается левее правой, а также что головки не выходят за пределы ленты.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите ответы на запросы последнего типа. На k-ой позиции выведите единственный строчный латинский символ c<sub>k</sub> — ответ на k-ый по порядку запрос вида «Q X».</p>

  <h4>Пример</h4>
<pre>
11 2 6
abracadabra
12
Q L
Q R
R
Q L
Q R
S L R
S R R
Q L
Q R
R
Q L
Q R
</pre>
  <code>baabcddc</code>
</article>


<!-- U. Последнее слово техники -->
<article class="article">
  <div class="anchor" id="task21"></div>
  <h3>Задача U. Последнее слово техники</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Все знают, насколько бессмысленны открытия британских ученых. Все знают, как японские ученые любят огромных боевых человекоподобных роботов. В этой задаче речь пойдет о французских ученых, которые умудрились соединить в себе и то, и другое: недавно был выпущен робот "Рене Декарт", хоть не боевой, но огромный и совершенно бессмысленный.</p>
  <p>"Рене Декарт" умеет двигаться по массиву целых чисел и вставлять по разные стороны от себя новые элементы. Научное сообщество решило проверить, насколько эффективно новое творение французских ученых, поэтому заготовило q команд, которые роботу надлежит исполнить.</p>
  <p>Итак, в начале эксперимента "Рене Декарт" находился на позиции p массива из n целых чисел (1 &le; p &le; n). Ему могут подавать 5 видов команд</p>
  <ol>
    <li>print - вывести элемент массива, на котором он стоит</li>
    <li>moveLeft - переместиться на шаг влево, если там есть элемент</li>
    <li>moveRight - переместиться на шаг вправо, если там есть элемент</li>
    <li>insertLeft x - вставить слева от себя новый элемент x</li>
    <li>insertRight x - вставить справа от себя новый элемент x</li>
  </ol>
  <p>К сожалению, ученым не удается найти, к какому именно результату должно привести исполнение робором этой серии команд. Поэтому они обратились к вам.</p>
  <p>Вам нужно, зная последовательность команд, вывести правильные ответы на команды print.</p>

  <h4>Входные данные</h4>
  <p>В первой строке через пробел записаны два целых числа n и p (1 &le; n &le; 200000, 1 &le; p &le; n) - количество элементов в массиве в начальный момент времени и позиция в массиве, на которой в начальный момент времени находится робот.</p>
  <p>Во второй строке через пробел перечислены n целых чисел a<sub>i</sub>, ..., a<sub>n</sub> (-10<sup>9</sup> &le; a<sub>i</sub> &le; 10<sup>9</sup> - массив, на позиции p которого в начальный момент времени находится робот.</p>
  <p>В третьей строке записано целое число q (1 &le; q &le; 200000) - количество командр, которые должен исполнить робот.</p>
  <p>Каждая из следующих q строк содержит команду. Их описание дано выше. Значение элемента массива x в коммандах insertLeft и insertright находится в пределах от -10<sup>9</sup> до 10<sup>9</sup>.</p>

  <h4>Выходные данные</h4>
  <p>Для каждой команды типа print на отдельной строке выведите значение элемента массива, на котором в этот момент находится робот.</p>

  <h4>Пример</h4>
<pre>
3 2
2 3 5
14
moveLeft
insertLeft 1
moveLeftprint
moveLeft
moveRight
print
moveRight
insertRight 4
moveRight
moveRight
print
moveRight
moveLEFT
print
</pre>
<PRE>
1
2
5
4
</PRE>
</article>

