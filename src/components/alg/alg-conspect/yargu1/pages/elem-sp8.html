<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contests" target="_blank">ЯрГУ. Кружок. Школьники</a></p>
  <p><a href="https://vkvideo.ru/@sportprog_yarsu" target="_blank">vkvideo.ru/@sportprog_yarsu</a></p>
</article>


<article class="article">
  <h1>Занятие 8. Базовые алгоритмы #1. Префикс-функция</h1>
  <p>Конспект видео от 2024.11.02</p>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contest/563482" target="_blank">Codeforces Контест 563482</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
         <a href="#p">Префикс-функция</a>
    <br><a href="#t1">Задача 1. Найти сумму от l до r</a>
    <br><a href="#t2">Задача 2. Найти сумму в матрице</a>
  </p>
  <p>
        <a href="#task1">Задача A. Трудная задача</a>
    <br><a href="#task2">Задача B. Интервалы</a>
    <br><a href="#task3">Задача C. Сумма чисел в массиве</a>
    <br><a href="#task4">Задача D. Массивные запросы</a>
    <br><a href="#task5">Задача E. Илья и запросы</a>
    <br><a href="#task6">Задача F. Дорога домой</a>
    <br><a href="#task7">Задача G. Битые сектора</a>
    <br><a href="#task8">Задача H. Шифрование сообщений</a>
    <br><a href="#task9">Задача I. Егор и массив</a>
    <br><a href="#task10">Задача J. Злобный гений</a>
    <br><a href="#task11">Задача K. Pekora и батуты</a>
    <br><a href="#task12">Задача L. Also Try Minecraft</a>
    <br><a href="#task13">Задача M. Девочка и максимальная сумма</a>
    <br><a href="#task14">Задача N. Верстовые столбы</a>
  </p>
</article>


<!-- Префикс-функция -->
<article class="article">
  <div class="anchor" id="p"></div>
  <h3>Префикс-функция</h3>

  <p>К базовым алгоритмам мы относим</p>
  <ol>
    <li>Префикс-функция</li>
    <li>Два указателя</li>
    <li>Бинарный поиск</li>
    <li>Сортировка слиянием</li>
    <li>Битовые операции</li>
  </ol>

  <p>На базовом алгоритме <strong>префикс-функции</strong> основан сложный алгоритм <strong>КМП (Кнута - Морриса - Пратта)</strong>. Алгоритм КМП позволяет быстро найти подстроку в строке.</p>
  <p>Простым вариантом <strong>префикс-функции</strong> является массив префиксных сумм</p>
  <p>Усложненным вариантом <strong>префикс-функции</strong> является матрица префиксных сумм</p>
</article>


<!-- Задача 1. Найти сумму от l до r -->
<article class="article">
  <div class="anchor" id="t1"></div>
  <h3>Задача 1. Найти сумму от l до r</h3>

  <p>Дан целочисленный массив A длины n. Необходимо найти сумму элементов массива с позиции l до позиции r</p>
  <code>A = {a₁, a₂, ... , aₙ₋₁, aₙ}</code>
  <code>result = aₗ + aₗ₊₁ + ... + a<sub>r-1</sub> + a<sub>r</sub></code>

  <p>Если запрос единственный, то мы можем посчитать сумму элементов через цикл</p>
<pre>
int result = 0;
for (int i = l; i &lt;= r; i++) {
  result += A[i];
}
</pre>

  <p>Допустим запросов q штук и для каждого запроса необходимо найти сумму элементов с l до r. Наивное решение для обработки запросов очень долгое.</p>
  <p>Более эффективное решение в случае массовых запросов использовать префикс-сумму.</p>
  <p>Префиксная сумма - это подход, при котором предварительно вычисляются суммы элементов массива для быстрого получения суммы любого подмассива.</p>
  <p>Создадим дополнительный массив B, который будет являться префикс-суммой. Размер массива B должен быть как минимум на один элемент больше размера массива A.</p>
  <code>A = {a₁, a₂, ... , aₙ₋₁, aₙ}</code>
  <code>B = {b₀, b₁, b₂, ... , bₙ₋₁, bₙ}</code>
  <p>Каждый элемент массива B хранит в себе сумму элементов массива A</p>
  <code>b₀ = 0</code>
  <code>b₁ = a₁</code>
  <code>b₂ = a₁ + a₂</code>
  <code>...</code>
  <code>bₙ = a₁ + ... + aₙ</code>

  <p>Для использования массива B необходимо решить две задачи</p>
  <ol>
    <li>Уметь быстро создавать массив префикс-сумму</li>
    <li>Уметь быстро отвечать на запрос суммы элементов с l до r</li>
  </ol>
  <p>Для начала научимся собирать массив B.</p>
  <code>b<sub>i</sub> = a<sub>1</sub> + a<sub>2</sub> + ... + a<sub>i</sub></code>
  <code>b<sub>i+1</sub> = a<sub>1</sub> + a<sub>2</sub> + ... + a<sub>i</sub> + a<sub>i+1</sub></code>
  <p>Заметим, что b<sub>i</sub> отличается от b<sub>i+1</sub> на один элемента a<sub>i+1</sub>. Мы можем представить b<sub>i+1</sub> в более коротком виде</p>
  <code>b<sub>i+1</sub> = b<sub>i</sub> + a<sub>i+1</sub></code>

  <details>
    <summary>Код префикс-суммы</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  vector&lt;int&gt; B(n + 1); // префикс суммы
  for (int i = 0; i &lt; n; i++) {
    B[i + 1] = B[i] + A[i];
  }

  // вывод результата
  for (int i = 0; i &lt;= n; i++) {
    cout &lt;&lt; B[i] &lt;&lt; " ";
  }
}
</pre>
  </details>

  <p>Научимся использовать префикс-сумму для быстрого ответа на запросы.</p>
  <p>Мы можем изменить представление запроса по задаче в следующий вид, добавим и вычтем несколько элементов</p>
  <code>result = a<sub>l</sub> + a<sub>r</sub></code>
  <code>result = (a<sub>1</sub> + .. + a<sub>l-1</sub>) + a<sub>l</sub> + a<sub>r</sub> - (a<sub>1</sub> + .. + a<sub>l-1</sub>)</code>
  <code>result = b<sub>r</sub> - b<sub>l-1</sub></code>

  <p>Ограничения для использования алгоритма префикс-функции:</p>
  <ol>
    <li>Функция, на которой собирается дополнительный массив, должна быть обратимой. Например, мы можем собирать на следующих операциях: сложение (вычитание), умножение (деление), xor (xor). Но не можем использовать операции max и min.</li>
    <li>Исходный массив не должен меняться. Изменение одного элемента исходного массива влечет к изменению большого количества элементов в массиве префикс-функции</li>
  </ol>

  <h4>Входные данные</h4>
  <p>В первой строке единственное целое число n (1 &le; 10<sup>5</sup>) - размер массива A</p>
  <p>Во второй строке n целых чисел</p>
  <p>В третьей строке единственное целое число q (1 &le; 10<sup>5</sup>) - число запросов</p>
  <p>В следующих q строках по два числа l и r для подсчета суммы подмассивов</p>

  <h4>Выходные данные</h4>
  <p>q целых чисел, ответы на q запросов</p>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  int n; // размер массива
  cin >> n;
  vector&lt;int&gt; A(n); // входной массив
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  // соберем префикс суммы
  vector&lt;int&gt; B(n + 1); // префикс сумма
  for (int i = 0; i &lt; n; i++) {
    B[i + 1] = B[i] + A[i];
  }

  int q; // число запросов
  cin >> q;
  for (int i = 0; i &lt; q; i++) {
    int l, r;
    cin >> l >> r; // следующий запрос
    int result;
    result = B[r] - B[l-1];

    // вывод результата
    cout &lt;&lt; result &lt;&lt; "\n";
  }
}
</pre>
  </details>
</article>


<!-- Задача 2. Найти сумму в матрице -->
<article class="article">
  <div class="anchor" id="t2"></div>
  <h3>Задача 2. Найти сумму в матрице</h3>

  <p>Для усложнения префикс-функции решим задачу на поиск суммы в матрице</p>
  <p>Пусть у нас есть матрица n x m. Матрица прямоугольная. Необходимо найти сумму элементов в любом прямоугольнике матрицы</p>
<pre>
a<sub>11</sub> a<sub>12</sub> ... a<sub>1m</sub>
a<sub>21</sub> a<sub>22</sub> ... a<sub>2m</sub>
...
a<sub>n1</sub> a<sub>n2</sub> ... a<sub>nm</sub>
</pre>
  <p>Для одномерного массива для хранения префикс-сумм мы создавали дополнительный одномерный массив. Дополнительный одномерный массив на один элемент больше исходного массива. Для матрицы для хранения префикс-сумм мы создадим дополнительную матрицу. Дополнительная матрица на одну строку и на один столбец больше исходной матрицы.</p>
<pre>
b<sub>00</sub> b<sub>01</sub> b<sub>02</sub> ... b<sub>0m</sub>
b<sub>10</sub> b<sub>11</sub> b<sub>12</sub> ... b<sub>1m</sub>
b<sub>20</sub> b<sub>21</sub> b<sub>22</sub> ... b<sub>2m</sub>
...
b<sub>n0</sub> b<sub>n1</sub> b<sub>n2</sub> ... b<sub>nm</sub>
</pre>

  <p>В дополнительном массиве каждый элемент b<sub>i</sub> хранит сумму элементов исходного массива от a<sub>1</sub> до a<sub>i</sub>. Первый элемент b<sub>0</sub> должен быть нейтральный, для префикса сумм b<sub>0</sub> = 0 (для произведения это 1).</p>
<pre>
  a<sub>1</sub>  a<sub>2</sub>  a<sub>3</sub>  a<sub>n</sub>
b<sub>0</sub>  b<sub>1</sub>  b<sub>3</sub>  b<sub>n-1</sub>  b<sub>n</sub>
</pre>
  <code>b<sub>i</sub> = a<sub>1</sub> + a<sub>2</sub> + ... + a<sub>i</sub></code>

  <p>В дополнительной матрице каждый элемент b<sub>ij</sub> хранит сумму элементов в прямоугольнике от a<sub>11</sub> до a<sub>ij</sub>. Все элементы первой строки и все элементы первого столбца должны быть нейтральные, для префикса сумм b<sub>00</sub> = b<sub>01</sub> = b<sub>0n</sub> = 0, b<sub>10</sub> = b<sub>n0</sub> = 0 (для произведение это 1)</p>
<pre>
b<sub>00</sub>    b<sub>01</sub>    b<sub>02</sub>    b<sub>03</sub>    b<sub>0n</sub>
    a<sub>11</sub>    a<sub>12</sub>    a<sub>13</sub>      a<sub>1n</sub>
b<sub>10</sub>    b<sub>11</sub>    b<sub>12</sub>    b<sub>13</sub>    b<sub>1n</sub>
    a<sub>21</sub>    a<sub>22</sub>    a<sub>23</sub>      a<sub>2n</sub>
b<sub>20</sub>    b<sub>21</sub>    b<sub>22</sub>    b<sub>23</sub>    b<sub>2n</sub>
    a<sub>31</sub>    a<sub>32</sub>    a<sub>33</sub>      a<sub>3n</sub>
b<sub>30</sub>    b<sub>31</sub>    b<sub>32</sub>    b<sub>33</sub>    b<sub>3n</sub>
    a<sub>n1</sub>    a<sub>n2</sub>    a<sub>n3</sub>      a<sub>nn</sub>
b<sub>n0</sub>    b<sub>n1</sub>    b<sub>n2</sub>    b<sub>n3</sub>    b<sub>nn</sub>
</pre>
  <code>b<sub>ij</sub> = a<sub>11</sub> + ... + a<sub>1j</sub> + ... + a<sub>i1</sub> + ... + a<sub>ij</sub></code>

  <p>Пусть нам надо посчитать сумму элементов в прямоугольнике от a<sub>22</sub> до a<sub>33</sub>.</p>
  <code>result = b<sub>33</sub> - b<sub>31</sub> - b<sub>13</sub> + b<sub>11</sub></code>
  <p>Это формула "включения - выключения". Ее можно продолжить для трехмерного массива, если требуется такое углубление.</p>

  <h4>Входные данные</h4>
  <p>В первой строке два числа n и m - размер матрицы</p>
  <p>В следующих n строк по m чисел - сама матрица</p>
  <p>В следующей строке одно число q - количество запросов</p>
  <p>В следующих q строках по 4 числа xl, xr, yl, yr - координаты прямоугольника в котором надо посчитать сумму</p>

  <h4>Пример</h4>
<pre>
4 4
1 2 3 4
5 6 7 8
5 6 7 8
1 2 3 4
2
1 2 1 2
3 4 3 4
</pre>
<pre>
14
22
</pre>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  int n, m;
  cin >> n >> m;
  vector&lt;vector&lt;int&gt; &gt; A(n + 1, vector&lt;int>(m + 1));
  for (int i = 1; i &lt;= n; i++) {
    for (int j = 1; j &lt;= m; j++) {
      cin >> A[i][j];
    }
  }

  // создадим префикс-матрицу сумм
  vector&lt;vector&lt;long long&gt; &gt; B(n + 1, vector&lt;long long&gt;(m + 1));

  // сначала соберем префикс сумм по строкам
  for (int i = 1; i &lt;= n; i++) {
    for (int j = 1; j &lt;= m; j++) {
      B[i][j] = B[i][j - 1] + A[i][j];
    }
  }

  // прибавим префикс сумм по столбцам
  for (int i = 1; i &lt;= n; i++) {
    for (int j = 1; j &lt;= m; j++) {
      B[i][j] += B[i-1][j];
    }
  }

  int q, xl, xr, yl, yr;
  long long result;
  cin >> q;
  for (int i = 0; i &lt; q; i++) {
    cin >> xl >> xr >> yl >> yr;
    result = B[xr][yr] - B[xl - 1][yr] - B[xr][yl - 1] + B[xl - 1][yl - 1];

    //вывод результата
    cout &lt;&lt; result &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача A. Трудная задача -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Трудная задача</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Массив s<sub>1</sub>,s<sub>2</sub>,…,s<sub>n</sub> называется массивом префиксных сумм массива a<sub>1</sub>,a<sub>2</sub>,…,a<sub>n</sub>, если s<sub>1</sub>=a<sub>1</sub>,s<sub>2</sub>=a<sub>1</sub>+a<sub>2</sub>,…,s<sub>n</sub>=a<sub>1</sub>+⋯+a<sub>n</sub>.</p>

  <p>У Паши был массив a<sub>1</sub>,a<sub>2</sub>,…,a<sub>n</sub>. Он посчитал массив его префиксных сумм, но его память не безгранична, поэтому он забыл исходный массив. Помогите Паше восстановить исходный массив.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано единственное число n (1≤n≤200000) – количество элементов в массиве.</p>

  <p>Во второй строке через пробел записаны целых чисел s<sub>1</sub>,s<sub>2</sub>,…,s<sub>n</sub> (-2⋅10<sup>14</sup>≤s<sub>i</sub>≤2⋅10<sup>14</sup>) – элементы массива префиксных сумм.</p>

  <h4>Выходные данные</h4>
  <p>Выведите целых чисел – элементы исходного массива a<sub>1</sub>,a<sub>2</sub>,…,a<sub>n</sub> через пробел. Гарантируется, что все a<sub>i</sub> лежат в пределах от -10<sup>9</sup> до 10<sup>9</sup></p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
4
1 3 6 10
</pre>
    <code>1 2 3 4</code>

    <h4>Пример 2</h4>
<pre>
5
-4 -1 3 2 4
</pre>
    <code>-4 3 4 -1 2</code>

    <h4>Пример 3</h4>
<pre>
3
1000000000 2000000000 3000000000
</pre>
    <code>1000000000 1000000000 1000000000</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/gym/100090/problem/L" target="_blank">Задача 100090L</a>
      <br><a href="https://codeforces.com/gym/100090" target="_blank">2012, Отборочный контест СГАУ на четвертьфинал ACM ICPC 2012-10-06</a>
    </div>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;

  vector&lt;long long&gt; Pref(n + 1, 0);
  vector&lt;long long&gt; A(n + 1, 0);
  for (int i = 1; i &lt;= n; i++) {
    cin >> Pref[i];
    A[i] = Pref[i] - Pref[i - 1];
    cout &lt;&lt; A[i] &lt;&lt; ' ';
  }
}
</pre>
  </details>
</article>


<!-- Задача B. Интервалы -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Интервалы</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>— Суеверия ... Предрассудки ... — рассеянно проговорил незнакомец. — Леность ума и зависть, зависть, поросшая волосами зависть ... — Он прервал самого себя. — Простите, Александр Иванович, но я бы осмелился все-таки просить вашего разрешения убрать этот ковш. К сожалению, железо практически не прозрачно для гиперполя, а возрастание напряженности гиперполя в малом объеме ...</p>

  <p>После инцидента с «идеальным потребителем» Выбегалло в НИИ ЧАВО спешно вводят автоматизированную систему безопасности. Она должна гарантировать, что в любом объеме общая интенсивность гиперполя не превышает критическую величину. На Сашу Привалова и его Алдан возложена важная задача по автоматической обработке показаний датчиков, расставленных по всему НИИ.</p>

  <p>Все датчики занумерованы от 1 до N (1 ≤ N ≤ 10000). Показание i-го датчика напряженности гиперполя – это целое число ( - 10000 ≤ k<sub>i</sub> ≤ 10000). Алдану необходимо быстро отвечать на запросы вида: чему равна сумма напряженностей на датчиках с i-го по j-й (i ≤ j). Число запросов Q может быть очень велико (0 ≤ Q ≤ 100000).</p>

  <h4>Входные данные</h4>
  <p>В первой строке входа находится число N. Далее в следующих N строках записаны ki. Далее следует число Q и Q пар чисел i, j.</p>

  <h4>Выходные данные</h4>
  <p>Выведите Q строк с суммами соответствующих показаний датчиков напряженности.</p>

  <details>
    <summary>Пример</summary>
<pre>
5
1
2
3
-1
4
3
1 5
4 4
1 4
</pre>
<pre>
9
-1
5
</pre>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;

  vector&lt;long long&gt; A(n + 1, 0);
  vector&lt;long long&gt; Pref(n + 1, 0);
  for (int i = 1; i &lt;= n; i++) {
    cin >> A[i];
    Pref[i] = Pref[i - 1] + A[i];
  }

  int q, i, j;
  cin >> q;


  while (q--) {
    cin >> i >> j;
    cout &lt;&lt; Pref[j] - Pref[i-1] &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача C. Сумма чисел в массиве -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Сумма чисел в массиве</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В одномерном массиве, заполненном произвольными целыми числами, за один проход найдите непрерывный кусок, сумма чисел в котором максимальна.</p>

  <p>Примечание. Фактически требуется найти такие i и j (i ≤ j), что сумма всех элементов массива от a<sub>i</sub> до a<sub>j</sub> включительно будет максимальна.</p>

  <h4>Входные данные</h4>
  <p>На вход программе сначала подается натуральное n&lt;=100000 — количество элементов в массиве. Далее, по одному в строке расположены сами элементы массива — целые числа, по модулю не превосходящие 30000.</p>

  <h4>Выходные данные</h4>
  <p>Выдайте пару искомых значений индексов. Если таких пар несколько, то j  должно быть минимально возможным, а при равных j  значение i должно быть максимально возможным.</p>

  <details>
    <summary>Пример</summary>
<pre>
5
-1 2 3 -2 2
</pre>
    <code>2 3</code>
  </details>

  <details>
    <summary>Решение</summary>
    <h4>Пример 2</h4>
<pre>
5
-50 -40 -30 -20 -10
</pre>
  <code>5 5</code>

    <h4>Пример 3</h4>
<pre>
5
-10 0 -10 10 10
</pre>
  <code>4 5</code>

    <h4>Пример 4</h4>
<pre>
5
-10 -10 10 10 10
</pre>
  <code>3 5</code>

    <h4>Пример 5</h4>
<pre>
6
0 0 10 10 0 0
</pre>
  <code>3 4</code>

    <h4>Пример 6</h4>
<pre>
5
10 0 10 0 0
</pre>
  <code>1 3</code>
  <p>Сначала находим максимальное число. Если оно меньше или равно нулю, значит нет положительных чисел, и в ответ выводим индекс первого максимального (отрицательного или нуля).</p>
  <p>Правым указателем проходим и складываем по очереди числа и смотрим, если текущая сумма больше максимальной, то обновляем максимум и границы ответа. Если текущая сумма меньше или равна 0, то увеличиваем левый указатель.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;

  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; ++i) {
    cin >> A[i];
  }

  // решение
  int maxA = A[0];
  int i_maxA = 0;
  int sum = 0;
  int max_sum = 0;
  int i = 0, j = 0;
  int pl = 0; // левый указатель
  int pr = 0; // правый указатель

  // двигаем правый указатель до конца массива
  while (pr &lt; n) {
    if (A[pr] > maxA) {
      maxA = A[pr];
      i_maxA = pr;
    }

    sum += A[pr];

    if (sum > max_sum) {
      max_sum = sum;
      i = pl;
      j = pr;
    }

    if (sum &lt;= 0) {
      sum = 0;
      pl = pr + 1;
    }

    pr++;
  }

  // вывод результата
  if (maxA > 0) {
    cout &lt;&lt; i + 1 &lt;&lt; ' ' &lt;&lt; j + 1;
  } else {
    cout &lt;&lt; i_maxA + 1 &lt;&lt; ' ' &lt;&lt; i_maxA + 1;
  }
}
</pre>
  </details>
</article>


<!-- Задача D. Массивные запросы -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Массивные запросы</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Есть массив размера n, изначально заполненный нулями.</p>

  <p>Есть m запросов, каждый из которых содержит 3 параметра: l, r, c.</p>

  <p>После поступления запроса каждый элемент отрезка массива от l  до r увеличивается на c.</p>

  <p>Выведите получившийся в конце массив</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных находится 2 целых числа n и m
   (1≤n,m≤2⋅10<sup>5</sup>) — размер массива и число запросов.</p>

  <p>В следующих m строках вводится по 3 числа: l, r, c (1≤l≤r≤n, -1000≤c≤1000) — запросы описанные в задаче.</p>

  <h4>Выходные данные</h4>
  <p>Выведите n чисел через пробел — получившийся после всех запросов массив.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
1 4
1 1 765
1 1 -43
1 1 -69
1 1 672
</pre>
    <code>1325</code>

    <h4>Пример 2</h4>
<pre>
5 3
1 4 -23
4 5 397
1 5 774
</pre>
    <code>751 751 751 1148 1171</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Изначально массив a<sub>1</sub> a<sub>2</sub> ... a<sub>n</sub> заполнен нулями. Приходит запрос: к каждому элементу с a<sub>5</sub> до a<sub>10</sub> прибавить число 2. Это будет долго. Попробуем это сделать быстрее.</p>
    <p>Создадим префиксный массив (массив обновлений) b<sub>1</sub> b<sub>2</sub> ... b<sub>n</sub> b<sub>n+1</sub>. Прибавим значение 2 к элементу b<sub>5</sub>. Это означает, что начиная с a<sub>5</sub> до a<sub>n</sub> все элементы увеличились на 2.</p>
    <p>Чтобы элементы увеличились только на интервале от a<sub>5</sub> до a<sub>10</sub> нужно из b<sub>11</sub> вычесть 2. Это означает что все элементы от a<sub>11</sub> до a<sub>n</sub> уменьшатся на 2. В итоге +2 -2 = 0, поэтому элементы от a<sub>11</sub> до a<sub>n</sub> не изменят свое значение</p>
    <p>Таким образом, если к b<sub>5</sub> добавить 2, а из b<sub>11</sub> вычесть 2, то все элементы на отрезке [a<sub>5</sub>, a<sub>10</sub>] увеличатся на 2</p>
    <p>Чтобы такое решение было возможно, должно выполнится три условия</p>
    <ol>
      <li>Действие должно быть обратимо. Сложение и вычитание это обратимые действия</li>
      <li>Начальный массив должен быть неизменным</li>
      <li>Результат запрашивать только в самом конце</li>
    </ol>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  int n, m;
  cin >> n >> m;
  // создадим массив с нулями
  vector&lt;long long&gt; Ans(n + 10);
  // создадим префикс-функцию
  vector&lt;long long&gt; Pref(n + 10);
  long long l, r, c;
  for (int i = 0; i &lt; m; i++) {
    cin >> l >> r >> c;
    // все запросы кладем в префикс-функцию
    Pref[l] += c;
    Pref[r + 1] -= c;
  }

  // соберем результат
  for (int i = 1; i &lt; Ans.size(); i++) {
    Ans[i] = Ans[i - 1] + Pref[i];
  }

  //вывод результата
  for (int i = 1; i &lt;= n; i++) {
    cout &lt;&lt; Ans[i] &lt;&lt; " ";
  }
}
</pre>
  </details>
</article>


<!-- Задача E. Илья и запросы -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Илья и запросы</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Лев Илья хочет помочь всем своим друзьям со сдачей экзаменов. Чтобы сдать экзамен по информатике нужно решить следующую задачу.</p>

  <p>Даны строка s = s<sub>1</sub>s<sub>2</sub>... s<sub>n</sub> (n — длина строки), состоящая только из символов «.» и «#», и m запросов. Каждый запрос описывается парой целых чисел l<sub>i</sub>, r<sub>i</sub> (1 ≤ l<sub>i</sub> &lt; r<sub>i</sub> ≤ n). Ответ на запрос l<sub>i</sub>, r<sub>i</sub> — это количество таких целых чисел i (l<sub>i</sub> ≤ i &lt; r<sub>i</sub>), что s<sub>i</sub>= s<sub>i+1</sub>.</p>

  <p>Лев Илья хочет помочь друзьям, но кто же поможет ему. Помогите Льву Илье, решите задачу.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записана строка s длины n (2 ≤ n ≤ 10<sup>5</sup>). Гарантируется, что заданная строка состоит только из символов «.» и «#».</p>

  <p>В следующей строке записано целое число m (1 ≤ m ≤ 10<sup>5</sup>) — количество запросов. В каждой из следующих m строк записано описание соответствующего запроса. В i-той строке записаны целые числа l<sub>i</sub>, r<sub>i</sub> (1 ≤ l<sub>i</sub> &lt; r<sub>i</sub> ≤ n).</p>

  <h4>Выходные данные</h4>
  <p>Выведите m целых чисел — ответы на запросы в том порядке, в котором запросы заданы во входных данных.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
......
4
3 4
2 3
1 6
2 6
</pre>
<pre>
1
1
5
4
</pre>

    <h4>Пример 2</h4>
<pre>
#..###
5
1 3
5 6
1 5
3 6
3 4
</pre>
<pre>
1
1
2
2
0
</pre>
  </details>

  <details>
    <summary>Наивное решение - цикл в цикле</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  string s;
  cin >> s;
  int m;
  cin >> m;
  int l, r;
  for (int i = 0; i &lt; m; i++) {
    cin >> l >> r;

    // решение
    l--;
    r--;
    int result = 0;
    for (int j = l; j &lt; r; j++) {
      if (s[j] == s[j + 1]) {
        result++;
      }
    }

    // вывод результата
    cout &lt;&lt; result &lt;&lt; "\n";
  }
}
</pre>
  </details>

  <details>
    <summary>Решение - префикс-функция</summary>

    <div>
      <a href="https://codeforces.com/contest/313/problem/B" target="_blank">Задача 313B</a>
      <br><a href="https://codeforces.com/contest/313" target="_blank">Codeforces Round 186 (Div. 2) 2013-05-30</a>
    </div>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  string s;
  cin >> s;

  // создадим префикс-функцию
  vector&lt;int&gt; Pref(s.size());
  for (int i = 1; i &lt; s.size(); i++) {
    Pref[i] = Pref[i - 1];
    if (s[i] == s[i - 1]) {
      Pref[i]++;
    }
  }

  int m;
  cin >> m;
  int l, r;
  for (int i = 0; i &lt; m; i++) {
    cin >> l >> r;

    // решение и вывод результата
    l--;
    r--;
    cout &lt;&lt; Pref[r] - Pref[l] &lt;&lt; "\n";
  }
}
</pre>
  </details>
</article>


<!-- Задача F. Дорога домой -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Дорога домой</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Волонтёрша Юля каждый день возвращается из Ярославского государственного университета домой в Брагино на автобусе. Раньше она садилась в автобус на остановке у университета и ехала до остановки около своего дома. Однако постоянные пробки приводили к тому, что время, за которое она добиралась домой, было неприемлемо большим. Тогда Юля решила часть пути проходить пешком. Юля может пройти пешком от университета до любой из остановок по пути следования маршрута, сесть там на автобус, а затем сойти с автобуса на любой другой остановке и пройти оставшуюся часть пути до дома пешком. Иными словами, сесть в автобус Юля может не более одного раза. Заметим, что Юля может как сесть на автобус сразу у университета, так и сойти с автобуса сразу у дома, либо вообще не садиться в автобус. На прямолинейном маршруте от университета, до дома есть N+1 остановка, причем университет имеет номер 0, а остановка у Юлиного дома имеет номер N. Про каждый отрезок маршрута между двумя последовательными остановками Юля знает, за сколько минут его проезжает автобус, и за сколько минут она пройдет его пешком. Автобусы ходят настолько часто (собственно, это одна из причин пробок), что их никогда не приходится ждать, т.е. подойдя к остановке, Юля может в этот же момент времени заскочить в автобус. Юля молодая и спортивная девушка, поэтому она мгновенно входит в автобус и выходит из него. Время стоянки автобуса на остановке настолько мало, что им тоже можно пренебречь.</p>

  <p>Напишите программу, которая вычисляет наименьшее время, которое может пройти от момента прихода Юли на остановку у университета до ее появления на остановке у дома, если она будет действовать оптимально.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных записано целое число N (1≤N≤100000) — количество отрезков маршрута между соседними остановками. Во второй строке записано N целых чисел Aᵢ (1 ≤ Aᵢ ≤ 360, 1 ≤ i ≤ N), где Aᵢ обозначает время, за которое автобус проезжает отрезок маршрута от остановки i-1 до остановки i. В третьей строке записано N целых чисел Bᵢ (1 ≤ Bᵢ ≤ 360, 1 ≤ i ≤ N), где Bᵢ обозначает время, за которое Юля проходит отрезок маршрута от остановки i-1 до остановки i.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное число — ответ на задачу.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
4
1 3 1 1
2 1 2 2
</pre>
    <code>5</code>

    <h4>Пример 2</h4>
<pre>
3
1 2 5
2 9 4
</pre>
    <code>7</code>

    <h4>Пример 3</h4>
<pre>
3
3 7 8
1 2 5
</pre>
    <code>8</code>
  </details>

  <details>
    <summary>Решение</summary>
    <h4>Пример 4. Сначала пешком, потом на автобусе</h4>
<pre>
6
5 5 5 1 1 1
2 2 2 4 4 4
</pre>
  <code>9</code>

    <h4>Пример 5. Сначала на автобусе, потом пешком</h4>
<pre>
6
3 2 2 4 4 4
5 5 5 1 1 1
</pre>
  <code>10</code>

    <h4>Пример 6. Сначала пешком, потом на автобусе, потом пешком</h4>
<pre>
6
5 5 1 2 4 4
2 2 5 5 2 2
</pre>
  <code>11</code>

    <h4>Пример 7</h4>
<pre>
9
5 5 1 1 5 1 1 5 5
1 1 5 5 1 5 5 1 1
</pre>
  <code>13</code>

  <h4>Пример 8</h4>
<pre>
55
195 51 83 36 251 252 1 31 34 137 328 71 356 4 318 143 115 3 333 352 273 16 78 124 354 151 233 107 136 3 118 129 316 297 103 158 196 20 203 117 159 215 269 134 74 86 122 220 263 214 151 215 273 224 9
163 194 210 235 8 245 125 332 240 212 184 182 164 130 220 127 7 34 22 196 209 31 96 289 189 330 57 355 347 55 336 303 55 360 221 351 65 265 360 108 179 226 95 111 214 120 52 78 301 164 141 173 328 290 123
</pre>
  <code>8758</code>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;

  // время на автобусе
  vector&lt;int&gt; A(n + 1);
  for (int i = 1; i &lt;= n; i++) {
    cin >> A[i];
  }

  // время пешком
  vector&lt;int&gt; B(n + 1);
  for (int i = 1; i &lt;= n; i++) {
    cin >> B[i];
  }

  // решение
  // префиксная сумма на автобусе
  vector&lt;int&gt; prefA(n + 1, 0);
  for (int i = 1; i &lt;= n; i++) {
    prefA[i] = prefA[i - 1] + A[i];
  }

  // суффиксная сумма на автобусе
  vector&lt;int&gt; sufA(n + 2, 0);
  for (int i = n; i > 0; i--) {
    sufA[i] = sufA[i + 1] + A[i];
  }

  // префиксная сумма пешком
  vector&lt;int&gt; prefB(n + 1, 0);
  for (int i = 1; i &lt;= n; i++) {
    prefB[i] = prefB[i - 1] + B[i];
  }

  // суффиксная сумма пешком
  vector&lt;int&gt; sufB(n + 2, 0);
  for (int i = n; i > 0; i--) {
    sufB[i] = sufB[i + 1] + B[i];
  }

  // разница во времени
  vector&lt;int&gt; Dif(n + 1);
  for (int i = 1; i &lt;= n; i++) {
    Dif[i] = A[i] - B[i];
  }
  // префикс разницы
  vector&lt;int&gt; prefD(n + 1, 0);
  for (int i = 1; i &lt;= n; i++) {
    prefD[i] = prefD[i - 1] + Dif[i];
  }

  // пусть ответ это минимальное из
  // времени на автобусе или пешком
  int res = min(prefA[n], prefB[n]);

  // метод двух указателей
  // левый указатель left
  // правый указатель right
  //       left      right
  //   1    2    3    4    5    6
  // .____.____.____.____.____.____.

  // собираем вектор отрезков, на которых
  // вермя на автобусе меньше чем пешком
  vector&lt;pair&lt;int, int&gt; &gt; NegA;
  pair&lt;int, int&gt; tmp;
  for (int left = 1; left &lt;= n; left++) {
    int right = left;
    while (right &lt;= n && Dif[right] &lt; 0) {
      right++;
    }
    if (right > left) {
      tmp.first = left;
      tmp.second = right - 1;
      NegA.push_back(tmp);
      left = right;
    }
  }

  // собираем соседние выгодные отрезки вместе
  // ищем максимальный выгодный отрезок
  int cur, next;
  for (int left = 0; left &lt; NegA.size(); left++) {
    int right = left;
    tmp.first = NegA[left].first;
    tmp.second = NegA[right].second;
    cur = prefB[tmp.first - 1] + (prefA[tmp.second] - prefA[tmp.first - 1]) + sufB[tmp.second + 1];
    right++;

    while (right &lt; NegA.size()) {
      tmp.second = NegA[right].second;
      next = prefB[tmp.first - 1] + (prefA[tmp.second] - prefA[tmp.first - 1]) + sufB[tmp.second + 1];
      if (next &lt; cur) {
        cur = next;
      }
      right++;
    }

    res = min(res, cur);
  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача G. Битые сектора -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Битые сектора</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Состояние секторов винчестера жесткого диска задано строкой s
  , состоящей из символов «.» и «*». Символ «.» означает обычный сектор, а символ «*» – битый (неработающий). Известно, что поломка винчестера прогрессирует по следующему правилу: за день каждый обычный сектор, который граничит хотя бы с одним битым, становится битым. Следует считать, что такие изменения происходят раз в сутки одновременно и мгновенно. Например, винчестер, описанный строкой «....***.**....*», на следующий день будет иметь следующее состояние: «...*******..**».</p>

  <p>Напишите программу, которая по заданному текущему состоянию винчестера определит состояние его секторов через k дней.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных заданы через пробел целые числа n и k (1≤n,k≤3⋅10<sup>6</sup>) – количество секторов винчестера (длина строки s) и количество дней. Вторая срока содержит s. Гарантируется, что s  состоит только из символов «*» и «.»</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите состояние винчестера через k  дней в виде строки аналогично второй строке входных данных.</p>

  <details>
    <summary>Пример</summary>
    <h4>Пример 1</h4>
<pre>
11 2
*.....**...
</pre>
    <code>***.******.</code>

    <h4>Пример 2</h4>
<pre>
15 1
....***.**....*
</pre>
    <code>...********..**</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Для каждого сектора, представленного точкой, посчитать количество секторов слева и справа до битого сектора, представленного звездочкой. Для хранения этой информации создадим два вспомогательных массива. Один для хранения расстояний слева, другой для хранения расстояний справа</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  int n, k;
  cin >> n >> k;
  string s;
  cin >> s;
  // добавим бордюр чтобы не делать
  // дополнительные проверки
  s = '.' + s + '.';

  // решение
  // создадим префикс-функцию
  vector&lt;int&gt; PrefL(n + 2);
  vector&lt;int&gt; PrefR(n + 2);
  // через сколько дней битый сектор
  // дойдет до текущего сектора
  int day = 1000000;

  for (int i = 1; i &lt;= n; i++) {
    if (s[i] == '*') {
      day = 0;
    } else {
      day++;
    }
    PrefL[i] = day;
  }
  day = 1000000;
  for (int i = n; i >= 1; i--) {
    if (s[i] == '*') {
      day = 0;
    } else {
      day++;
    }
    PrefR[i] = day;
  }

  // вывод результата
  for (int i = 1; i &lt;= n; i++) {
    if (min(PrefL[i], PrefR[i]) &lt;= k) {
      cout &lt;&lt; '*';
    } else {
      cout &lt;&lt; '.';
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача H. Шифрование сообщений -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Шифрование сообщений</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Умный Бобер из ABBYY придумал новый вид шифрования сообщений и хочет проверить его работу. Делать это вручную долго и трудоемко, поэтому он решил обратиться к участникам ABBYY Cup.</p>

  <p>Сообщение представляет собой n целых чисел a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub>. Для шифрования используется ключ, который представляет собой m целых чисел b<sub>1</sub>, b<sub>2</sub>, ..., b<sub>m</sub> (m ≤ n). Все числа из сообщения и из ключа лежат в интервале от 0 до c-1, включительно, и все последующие вычисления проводятся по модулю c.</p>

  <p>Шифрование проводится в n-m+1 этапов. На первом этапе к каждому из чисел a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>m</sub> прибавляются соответствующие числа b<sub>1</sub>, b<sub>2</sub>, ..., b<sub>m</sub>. На втором этапе к числам a<sub>2</sub>, a<sub>3</sub>, ..., a<sub>m+1</sub> (измененным на предыдущем этапе) прибавляются числа b<sub>1</sub>, b<sub>2</sub>, ..., b<sub>m</sub>. И так далее: на этапе номер i к числам a<sub>i</sub>, a<sub>i+1</sub>, ..., a<sub>i+m-1</sub> прибавляются числа b<sub>1</sub>, b<sub>2</sub>, ..., b<sub>m</sub>. Результатом шифрования является последовательность a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> после n - m + 1 этапов шифрования.</p>

  <p>Помогите Бобру: напишите программу, которая будет осуществлять шифрование сообщений описанным способом.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит три целых числа n, m и c, разделенных единичными пробелами.</p>

  <p>Вторая строка входных данных содержит n целых чисел a<sub>i</sub> (0 ≤ a<sub>i</sub> &lt; c), разделенных единичными пробелами, — исходное сообщение.</p>

  <p>Третья строка входных данных содержит m целых чисел b<sub>i</sub> (0 ≤ b<sub>i</sub> &lt; c), разделенных единичными пробелами, — ключ шифрования.</p>

  <p>Ограничения на входные данные для получения 30 баллов:</p>

  <p>1 ≤ m ≤ n ≤ 10<sup>3</sup></p>
  <p>1 ≤ c ≤ 10<sup>3</sup></p>
  <p>Ограничения на входные данные для получения 100 баллов:</p>

  <p>1 ≤ m ≤ n ≤ 10<sup>5</sup></p>
  <p>1 ≤ c ≤ 10<sup>3</sup></p>

  <h4>Выходные данные</h4>
  <p>Выведите n целых чисел, разделенных пробелами, — результат шифрования сообщения.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
4 3 2
1 1 1 1
1 1 1
</pre>
    <code>0 1 1 0</code>
    <p>В первом примере шифрование проводится в два этапа: после первого этапа a = (0, 0, 0, 1) (вычисления производятся по модулю 2), после второго — a = (0, 1, 1, 0), что и будет ответом.</p>

    <h4>Пример 2</h4>
<pre>
3 1 5
1 2 3
4
</pre>
    <code>0 1 2</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/177/problem/D2" target="_blank">Задача 177D2</a>
      <br><a href="https://codeforces.com/contest/177" target="_blank">ABBYY Cup 2.0 - Easy 2012-04-29</a>
    </div>

  <h4>Пример 3</h4>
<pre>
10 4 11
1 2 3 4 5 6 7 8 9 10
1 2 3 4
</pre>
  <code>2 5 9 3 4 5 6 6 5 3</code>

  <h4>Пример 4</h4>
<pre>
5 4 6
1 2 3 4 5
1 2 3 4
</pre>
  <code>2 5 2 5 3</code>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода и вывода
  ios::sync_with_stdio(0);
  cin.tie(0);
  cout.tie(0);

  // ввод данных
  int n, m, c;
  cin >> n >> m >> c;
  vector&lt;int&gt; A(n + 1);
  for (int i = 1; i &lt;= n; i++) {
    cin >> A[i];
  }
  vector&lt;int&gt; B(m + 1);
  for (int i = 1; i &lt;= m; i++) {
    cin >> B[i];
  }

  // решение
  // число этапов шифрования
  int e = n - m + 1;
  vector&lt;int&gt; D(n + 2, 0);

  // заполняем вектор D
  for (int i = 1; i &lt;= n; i++) {
    if (i &lt;= m) {
      // вариант 1
      if (i &lt;= n + 1 - m) {
        D[i] = (D[i - 1] + B[i]) % c;
      // вариант 2
      } else {
        D[i] = (D[i - 1] + B[i] - B[m - (n + 1 - i)]) % c;
        if (D[i] &lt; 0) {
          D[i] = D[i] + c;
        }
      }

    } else {
      // вариант 3
      if (i &lt;= n + 1 - m) {
        D[i] = D[i - 1];
      // вариант 4
      } else {
        D[i] = (D[i - 1] - B[m - (n + 1 - i)]) % c;
        if (D[i] &lt; 0) {
          D[i] = D[i] + c;
        }
      }
    }

  }
  //for (int i = 1; i &lt;= n; i++) {
  //  cout &lt;&lt; D[i] &lt;&lt; ' ';
  //}
  //cout &lt;&lt; '\n';

  // собираем результат
  for (int i = 1; i &lt;= n; i++) {
    A[i] = (A[i] + D[i]) % c;
  }

  // вывод результата
  for (int i = 1; i &lt;= n; i++) {
    cout &lt;&lt; A[i] &lt;&lt; ' ';
  }
}
</pre>
  </details>
</article>


<!-- Задача I. Егор и массив -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача I. Егор и массив</h3>

  <div><i>Ограничение по времени 1.5с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У Егора есть массив a = a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> и m операций. Каждая операция имеет вид: lᵢ , rᵢ , dᵢ , (1 ≤ lᵢ ≤ rᵢ ≤ n). Применить операцию i к массиву значит, элементы массива c номерами lᵢ , lᵢ + 1 , ... , rᵢ , увеличить на величину dᵢ .</p>

  <p>Егор записал на листочке бумаги k запросов. Каждый запрос имеет вид: xᵢ , yᵢ , (1 ≤ xᵢ ≤ yᵢ ≤ m), что означает, что нужно применить к массиву операции с номерами xᵢ , xᵢ + 1, ..., yᵢ .</p>

  <p>Сейчас Егор хочет узнать, какой будет массив a после выполнения всех запросов. Помогите Егору.</p>

  <h4>Входные данные</h4>
  <p>В первой строке заданы целые числа n, m, k (1 ≤ n, m, k ≤ 10<sup>5</sup>). Во второй строке заданы n целых чисел: a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> (0 ≤ aᵢ ≤ 10<sup>5</sup>) — изначальный массив.</p>

  <p>В следующих m строках заданы операции, операция с номером i записана тремя целыми числами: lᵢ , rᵢ , dᵢ , (1 ≤ lᵢ ≤ rᵢ ≤ n), (0 ≤ dᵢ ≤ 10<sup>5</sup>).</p>

  <p>В следующих k строках заданы запросы, запрос с номером i записан двумя целыми числами: xᵢ , yᵢ , (1 ≤ xᵢ ≤ yᵢ ≤ m).</p>

  <p>Числа в строках разделяются одиночными пробелами.</p>

  <h4>Выходные данные</h4>
  <p>В единственную строку выведите n целых чисел a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> — массив, который получит Егор после применения всех запросов. Выведенные числа разделяйте пробелами.</p>

  <p>Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на C++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
3 3 3
1 2 3
1 2 1
1 3 2
2 3 4
1 2
1 3
2 3
</pre>
    <code>9 18 17</code>

    <h4>Пример 2</h4>
<pre>
1 1 1
1
1 1 1
1 1
</pre>
    <code>2</code>

    <h4>Пример 3</h4>
<pre>
4 3 6
1 2 3 4
1 2 1
2 3 2
3 4 4
1 2
1 3
2 3
1 2
1 3
2 3
</pre>
    <code>5 18 31 20</code>
  </details>

  <details>
    <summary>Решение с TL</summary>
    <p>Решение в лоб. Без оптимизации. На 11 тесте превышнение по времени.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода и вывода
  ios::sync_with_stdio(0);
  cin.tie(0);
  cout.tie(0);

  // ввод данных
  int n, m, k;
  cin >> n >> m >> k;

  // массив
  vector&lt;int&gt; A(n + 1);
  for (int i = 1; i &lt;= n; i++) {
    cin >> A[i];
  }

  // операции
  vector&lt;pair&lt;pair&lt;int, int&gt;, int&gt; &gt; B(m + 1);
  // B[i].first.first  = li
  // B[i].first.second = ri
  // B[i].second       = di
  for (int i = 1; i &lt;= m; i++) {
    cin >> B[i].first.first >> B[i].first.second >> B[i].second;
  }

  // запросы
  vector&lt;pair&lt;int, int&gt; &gt; C(k + 1);
  // C[i].first  = xi
  // C[i].second = yi
  for (int i = 1; i &lt;= k; i++) {
    cin >> C[i].first >> C[i].second;
  }

  // решение
  // проходим по запросам
  for (int i = 1; i &lt;= k; i++) {
    int xi = C[i].first;
    int yi = C[i].second;
    // проходим по операциям
    for (int j = xi; j &lt;= yi; j++) {
      int li = B[j].first.first;
      int ri = B[j].first.second;
      int di = B[j].second;
      // проходим по массиву
      for (int l = li; l &lt;= ri; l++) {
        A[l] += di;
      }
    }
  }

  // вывод результата
  for (int i = 1; i &lt;= n; i++) {
    cout &lt;&lt; A[i] &lt;&lt; ' ';
  }
}
</pre>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/296/problem/C" target="_blank">Задача 296C</a>
      <br><a href="https://codeforces.com/contest/296" target="_blank">Codeforces Round 179 (Div. 2) 2013-04-11</a>
    </div>

    <p>Чтобы избавиться от вложенных циклов, будем использовать префиксный массив дважды. Сначала для операций, потом для итогового массива. В префиксном массиве для операций prefB посчитаем сколько раз каждая операция выполняется. В префиксном итоговом массиве prefA посчитаем количество применений каждой операции.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода и вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);

  // ввод данных
  int n, m, k;
  cin >> n >> m >> k;

  vector&lt;long long&gt; a(n);
  for (int i = 0; i &lt; n; ++i) {
    cin >> a[i];
  }

  vector&lt;int> l(m), r(m);
  vector&lt;long long&gt; d(m);
  for (int i = 0; i &lt; m; ++i) {
    cin >> l[i] >> r[i] >> d[i];
    l[i]--; // Переводим в 0-индексацию для удобства
  }

  // Обработка запросов: создаем массив частот операций
  vector&lt;long long&gt; op_freq(m + 2, 0);
  for (int i = 0; i &lt; k; ++i) {
    int x, y;
    cin >> x >> y;
    x--; // Переводим в 0-индексацию
    op_freq[x]++;
    op_freq[y]--;
  }

  // Префиксные суммы для частот операций
  vector&lt;long long&gt; op_psum(m + 1, 0);
  long long current = 0;
  for (int i = 0; i &lt; m; ++i) {
    current += op_freq[i];
    op_psum[i] = current;
  }

  // Создаем массив для приращений элементов массива a
  vector&lt;long long&gt; delta(n + 2, 0);
  for (int i = 0; i &lt; m; ++i) {
    if (op_psum[i] == 0) continue;
    long long add = d[i] * op_psum[i];
    delta[l[i]] += add;
    delta[r[i]] -= add;
  }

  // Применяем приращения к исходному массиву
  long long current_delta = 0;
  for (int i = 0; i &lt; n; ++i) {
    current_delta += delta[i];
    a[i] += current_delta;
  }

  // вывод результата
  for (int i = 0; i &lt; n; ++i) {
    cout &lt;&lt; a[i] &lt;&lt; " ";
  }
  cout &lt;&lt; endl;
}
  </details>
</article>


<!-- Задача J. Злобный гений -->
<article class="article">
  <div class="anchor" id="task10"></div>
  <h3>Задача J. Злобный гений</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Злобный гений опять занимается исследованиями. В своих каверзных планах он сделает n экспериментов с числами. Каждый эксперимент состоит из набора подряд идущих натуральных чисел от l<sub>i</sub> до r<sub>i</sub> включительно. Злобный гений хочет определить количество простых чисел в каждом из наборов.</p>

  <h4>Входные данные</h4>
  <p>В первой строке задано целое число n (1≤n≤10<sup>5</sup>) — количество экспериментов.</p>

  <p>Далее каждый эксперимент задан двумя целыми числами l<sub>i</sub> и r<sub>i</sub> (1≤l<sub>i</sub>≤r<sub>i</sub>≤10<sup>7</sup>) - границы набора целых чисел.</p>

  <h4>Выходные данные</h4>
  <p>Выведите для каждого эксперимента в отдельной строке количество простых чисел.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
3
2 10
5 5
13 1013
</pre>
<pre>
4
1
165
</pre>

    <h4>Пример 2</h4>
<pre>
1
1 10000000
</pre>
<pre>
664579
</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Соберем решето Эратосфена от 1 до 10⁷. Создадим префикс-функцию, в которой для каждого числа i в этом диапазоне будет храниться количество простых чисел от 1 до i включительно.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода и вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);

  // ввод данных
  int n;
  cin >> n;

  int m = 10000000;
  vector&lt;int&gt; A(m + 1, 0);
  //vector&lt;int&gt; B;
  vector&lt;int&gt; prefB(m + 1, 0);
  A[0] = 1;
  A[1] = 1;

  for (long long i = 2; i &lt;= m; i++) {
    if (A[i] == 0) {
      //B.push_back(i);
      prefB[i] = prefB[i - 1] + 1;
      for (long long j = i * i; j &lt;= m; j += i) {
        A[j] = 1;
      }
    } else {
      prefB[i] = prefB[i - 1];
    }
  }

  // обработка запросов
  while (n--) {
    int li, ri;
    cin >> li >> ri;

    // вывод результата
    cout &lt;&lt; prefB[ri] - prefB[li - 1] &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача K. Pekora и батуты -->
<article class="article">
  <div class="anchor" id="task11"></div>
  <h3>Задача K. Pekora и батуты</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Есть парк батутов с n батутами, расположенными в ряд. i-й из них имеет силу S<sub>i</sub>.</p>

  <p>Pekora может прыгать по батутам в несколько проходов. Она начинает проход, прыгая на любой батут по своему выбору.</p>

  <p>Если сейчас Pekora прыгает на батут i, то батут подбросит ее в позицию i+S<sub>i</sub>, а S<sub>i</sub> станет равно max(S<sub>i</sub>-1,1). Иначе говоря, S<sub>i</sub> уменьшится на 1, кроме случая S<sub>i</sub>=1, когда S<sub>i</sub> останется равно 1.</p>

  <p>Если в позиции i+S<sub>i</sub> нет батута, то этот проход завершен. В противном случае Pekora продолжит проход прыжком с батута в позиции i+S<sub>i</sub> по принципу, описанному выше.</p>

  <p>Pekora не может перестать прыгать во время прохода, пока не приземлится на позицию больше n (в которой нет батута). Бедная Pekora!</p>

  <p>Pekora — непослушный кролик, и хочет разрушить парк батутов, уменьшив все S<sub>i</sub> до 1. Какое минимальное количество проходов ей нужно, чтобы уменьшить все S<sub>i</sub> до 1?</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержится одно целое число t (1≤t≤500) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит одно целое число n (1≤n≤5000) — количество батутов.</p>

  <p>Вторая строка каждого набора входных данных содержит n
  целых чисел S<sub>1</sub>,S<sub>2</sub>,…,S<sub>n</sub> (1≤S<sub>i</sub>≤10<sup>9</sup>), где S<sub>i</sub> — это сила i-го батута.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 5000.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно целое число — минимальное количество проходов, за которое Pekora может уменьшить все S<sub>i</sub> до 1.</p>

  <details>
    <summary>Пример</summary>
<pre>
3
7
1 4 2 2 2 2 2
2
2 3
5
1 1 1 1 1
</pre>
<pre>
4
3
0
</pre>
    <p>Для первого набора входных данных, ниже приведена оптимальная последовательность проходов, которые Pekora может использовать. (Жирным выделены позиции батутов, куда прыгает Pekora в очередной проход).</p>
<pre>
[1,4,2,2,2,2,2]
[1,4,1,2,1,2,1]
[1,3,1,2,1,1,1]
[1,2,1,2,1,1,1]
</pre>
    <p>Для второго набора входных данных оптимальная последовательность проходов приведена ниже.</p>
<pre>
[2,3]
[1,3]
[1,2]
</pre>
    <p>Для третьего набора входных данных, все S<sub>i</sub> уже равны 1.</p>
  </details>

  <details>
    <summary>Решение с TL</summary>
    <p>Превышено ограничение времени на тесте 4</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода и вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n;
    cin >> n;
    vector&lt;int&gt; S(n + 1, 0);
    int count = 0;
    for (int i = 1; i &lt;= n; i++) {
      cin >> S[i];
      count += S[i];
    }

    // решение
    int res = 0;
    while (count != n) {
      count = 0;
      for (int i = 1; i &lt;= n;) {
        if (S[i] > 1) {
          int tmp = S[i];
          S[i]--;
          i += tmp;
        } else {
          count += S[i];
          i++;
        }
      }
      res++;
      if (count == n) {
        res--;
      }
    }

    // вывод результата
    cout &lt;&lt; res &lt;&lt; '\n';
  }
}
</pre>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1491/problem/C" target="_blank">Задача 1491C</a>
      <br><a href="https://codeforces.com/contest/1491" target="_blank">Codeforces Global Round 13 2021-02-28</a>
    </div>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ускорение ввода и вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);

  // число тестов
  int t;
  cin >> t;

  while (t--)	{
    // ввод данных
    int n;
    cin >> n;
    vector&lt;int&gt; S(n + 1);
    for (int i = 1; i &lt;= n; i++) {
      cin >> S[i];
    }

    // решение
    long long res = 0;
    vector&lt;long long&gt; prefS(n + 2, 0);

    for (int i = 1; i &lt;= n; i++) {

      if (S[i] - 1 > prefS[i]) {
        res += S[i] - prefS[i] - 1;
      }

      if (prefS[i] > S[i] - 1) {
        prefS[i + 1] += prefS[i] - S[i] + 1;
      }

      for (int j = i + 2; j &lt;= min(n, S[i] + i); j++) {
        prefS[j]++;
      }

    }

    // вывод результата
    cout &lt;&lt; res &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача L. Also Try Minecraft -->
<article class="article">
  <div class="anchor" id="task12"></div>
  <h3>Задача L. Also Try Minecraft</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вы занимаетесь бета-тестированием нового секретного обновления игры Terraria. Это обновление добавит в игру квесты!</p>

  <p>Для простоты карту мира можно представить как массив длины n, где i-й столбец мира имеет высоту a<sub>i</sub>.</p>

  <p>Вам необходимо протестировать m квестов. Квест с номером j
   представлен двумя целыми числами s<sub>j</sub> и t<sub>j</sub>. В этом квесте вам необходимо добраться из столбца s<sub>j</sub> до столбца t<sub>j</sub>. В начале квеста вы появляетесь в столбце s<sub>j</sub>.</p>

  <p>За один ход вы можете перейти из столбца x в столбец x-1  или в столбец x+1. В этой версии у вас есть Spectre Boots, которые позволяют вам летать. Так как это бета-версия, эти ботинки работают неправильно, поэтому они позволяют вам летать только тогда, когда вы движетесь вверх, и имеют бесконечную длительность полета. Когда вы перемещаетесь из столбца с высотой p в столбец с высотой q, вы получаете какое-то количество урона от падения. Если высота p больше высоты q, вы получаете p-q единиц урона от падения, иначе вы летите вверх и получаете 0 единиц урона.</p>

  <p>Для каждого из заданных квестов определите минимальное количество урона от падения, которое вы можете получить, выполняя этот квест.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит два целых числа n и m (2≤n≤10<sup>5</sup>;1≤m≤10<sup>5</sup>) — количество столбцов в мире и количество квестов, которые вам надо протестировать, соответственно.</p>

  <p>Вторая строка входных данных содержит n целых чисел a<sub>1</sub>,a<sub>2</sub>,…,a<sub>n</sub> (1≤a<sub>i</sub>≤10<sup>9</sup>), где a<sub>i</sub> равно высоте i-го столбца мира.</p>

  <p>Следующие m строк описывают квесты. В j-й из них содержатся два целых числа s<sub>j</sub> и t<sub>j</sub> (1≤s<sub>j</sub>,t<sub>j</sub>≤n;s<sub>j</sub>≠t<sub>j</sub>), которые значат, что вам необходимо переместиться из столбца s<sub>j</sub> в столбец tj в течение j-го квеста.</p>

  <p>Заметьте, что s<sub>j</sub> может быть больше, чем t<sub>j</sub>.</p>

  <h4>Выходные данные</h4>
  <p>Выведите m строк. В j-й из них должно находиться минимальное количество урона от падения, который вы можете получить во время выполнения j-го квеста.</p>

  <details>
    <summary>Пример</summary>
<pre>
7 6
10 8 9 6 8 12 7
1 2
1 7
4 6
7 1
3 5
4 2
</pre>
<pre>
2
10
0
7
3
1
</pre>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1709/problem/B" target="_blank">Задача 1709B</a>
      <br><a href="https://codeforces.com/contest/1709" target="_blank">Educational Codeforces Round 132 (рейтинговый для Div. 2) 2022-07-21</a>
    </div>

    <p>Создадим массив A для входных данных, массив B для префикс-сумм слева направо, массив C для префикс-сумм справа налево.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  int n, m;
  cin >> n >> m;
  vector&lt;long long&gt; A(n + 2), B(n + 2), C(n + 2);
  for (int i = 1; i &lt;= n; i++) {
    cin >> A[i];
  }

  // решение
  for (int i = 2; i &lt;= n; i++) {
    B[i] = B[i - 1];
    if (A[i] &lt; A[i - 1]) {
      B[i] += A[i - 1] - A[i];
    }
  }
  for (int i = n - 1; i >= 0; i--) {
    C[i] = C[i + 1];
    if (A[i] &lt; A[i + 1]) {
      C[i] += A[i + 1] - A[i];
    }
  }
  for (int i = 0; i &lt; m; i++) {
    int l, r;
    cin >> l >> r;

    //вывод результата
    if (l &lt;= r) {
      cout &lt;&lt; B[r] - B[l] &lt;&lt; '\n';
    } else {
      cout &lt;&lt; C[r] - C[l] &lt;&lt; '\n';
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача M. Девочка и максимальная сумма -->
<article class="article">
  <div class="anchor" id="task13"></div>
  <h3>Задача M. Девочка и максимальная сумма</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Девочка очень любит задачи про запросы на массиве.</p>

  <p>Однажды ей попалась довольно известная задача: дан массив из n элементов (элементы массива проиндексированы от 1); также есть q запросов, каждый из которых задается парой целых чисел l<sub>i</sub>, r<sub>i</sub> (1≤l<sub>i</sub>≤r<sub>i</sub>≤n). Для каждого запроса необходимо найти сумму всех элементов массива с индексами от l<sub>i</sub> до r<sub>i</sub> включительно.</p>

  <p>Такая задача показалась Девочке довольно скучной. Она решила, что перед тем, как отвечать на запросы, она перемешает элементы массива, причем так, чтобы сумма ответов на все запросы была максимально возможной. Ваша задача — найти значение этой максимальной суммы.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит два целых числа n (1≤n≤2⋅10<sup>5</sup>) и q (1≤q≤2⋅10<sup>5</sup>), разделенных пробелом — количество элементов в массиве и количество запросов, соответственно.</p>

  <p>Следующая строка содержит n целых чисел a<sub>i</sub> (1≤a<sub>i</sub>≤2⋅10<sup>5</sup>), разделенных пробелами — элементы массива.</p>

  <p>Каждая из следующих q строк содержит два целых числа l<sub>i</sub> и r<sub>i</sub> (1≤l<sub>i</sub>≤r<sub>i</sub>≤n), разделенных пробелом — i-й запрос.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите целое число — максимальную сумму ответов на запросы после перемешивания элементов массива.</p>

  <p>Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.</p>

  <details>
    <summary>Примеры</summary>
  <h4>Пример 1</h4>
<pre>
3 3
5 3 2
1 2
2 3
1 3
</pre>
    <code>25</code>

    <h4>Пример 2</h4>
<pre>
5 3
5 2 4 1 3
1 5
2 3
2 3
</pre>
    <code>33</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/276/problem/C" target="_blank">Задача 276C</a>
      <br><a href="https://codeforces.com/contest/276" target="_blank">Codeforces Round 169 (Div. 2) 2013-02-24</a>
    </div>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ускорение ввода и вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);

  // ввод данных
  int n, q;
  cin >> n >> q;

  vector&lt;int> A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  vector&lt;pair&lt;int, int&gt; &gt; Q(q);
  for (int i = 0; i &lt; q; i++) {
    cin >> Q[i].first >> Q[i].second;
  }

  // решение
  long long res = 0;

  // собираем префиксный массив
  vector&lt;int&gt; prefA(n + 1, 0);
  for (int i = 0; i &lt; q; i++) {
    int left = Q[i].first;
    int right = Q[i].second;
    prefA[left - 1] += 1;
    prefA[right] -= 1;
  }
  for (int i = 1; i &lt; n; i++) {
    prefA[i] += prefA[i - 1];
  }

  sort(A.begin(), A.end());
  sort(prefA.begin(), prefA.end()-1);

  for (int i = 0; i &lt; n; i++) {
    res += (long long)A[i] * (long long)prefA[i];
  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача N. Верстовые столбы -->
<article class="article">
  <div class="anchor" id="task14"></div>
  <h3>Задача N. Верстовые столбы</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 64мб</i></div>

  <p>На самой длинной дороге сказочного королевства установлено n верстовых столбов. Согласно давней традиции, каждый такой столб окрашивается в один из m цветов, в зависимости от того, в какой местности он установлен. Цвета всех столбов нанесены на специальную карту.</p>

  <p>При проведении ремонтных работ, на покраску столбов отправляются бригады маляров. Обычно бригаде выдается участок дороги, начиная с некоторого столба l, и заканчивая некоторым столбом r. При попытках оптимизировать назначение малярных бригад, прорабу часто приходится определять, сколько различных красок потребуется бригаде работающей на участке l…r.</p>

  <p>Напишите программу, которая по заданной карте сможет быстро ответить на множество вопросов описанного типа.</p>

  <h4>Входные данные</h4>
  <p>ввод input.txt</p>
  <p>вывод output.txt</p>
  <p>Первая строка входного файла содержит два целых числа n и k – число верстовых столбов и запросов соответственно. Вторая строка содержит n целых чисел, разделенных пробелами – цвета столбов 1,2,…n. Последующие k строк содержат запросы – по одному запросу на строку. i-тый запрос состоит двух целых чисел l<sub>i</sub> и r<sub>i</sub>, указывающих границы интервала, количество различных цветов на котором необходимо подсчитать.</p>

  <p>Ограничения:</p>
  <code>1≤n≤10000; 1≤m≤255; 1≤l<sub>i</sub>≤r<sub>i</sub>≤n; 1≤k≤100000.</code>

  <h4>Выходные данные</h4>
  <p>Выходной файл дожжен содержать k строчек. Первая строка содержит число различных цветов на интервале l<sub>1</sub>…r<sub>1</sub>; вторая – число различных цветов на интервале l<sub>2</sub>…r<sub>2</sub> и так далее</p>

  <details>
    <summary>Пример</summary>
<pre>
5 3
1 2 3 2 1
1 5
1 3
2 4
</pre>
<pre>
3
3
2
</pre>
  </details>

  <details>
    <summary>Решение с TL</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);

  // работа с файлами
  ifstream fin("input.txt");
  ofstream fout("output.txt");

  // ввод данных
  int n, k;
  fin >> n >> k;
  vector&lt;int&gt; A(n + 1);
  for (int i = 1; i &lt;= n; i++) {
    fin >> A[i];
  }

  // решение
  // обрабатываем запросы
  while (k--) {
    int l, r;
    fin >> l >> r;
    vector&lt;int&gt; freq(256, 0);
    int res = 0;

    for (int i = l; i &lt;= r; i++) {
      if (!freq[A[i]]) {
        res++;
        freq[A[i]] = 1;
      }
    }

    // вывод результата
    fout &lt;&lt; res &lt;&lt; '\n';
  }

  fin.close();
  fout.close();
}
</pre>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);

  // работа с файлами
  ifstream fin("input.txt");
  ofstream fout("output.txt");

  // ввод данных
  int n, k;
  fin >> n >> k;
  vector&lt;int&gt; A(n + 1);
  for (int i = 1; i &lt;= n; i++) {
    fin >> A[i];
  }


  // решение
  // префиксный массив
  vector&lt;vector&lt;int&gt; &gt; prefA(256, vector&lt;int&gt;(n+1,0));
  for (int i = 1; i &lt;= n; i++) {
    prefA[A[i]][i] = 1;
  }
  for (int i = 1; i &lt;= 255; i++) {
    for (int j = 1; j &lt;= n; j++) {
      prefA[i][j] += prefA[i][j-1];
    }
  }

  // обрабатываем запросы
  while (k--) {
    int l, r;
    fin >> l >> r;
    int res = 0;

    for (int i = 1; i &lt;= 255; i++) {
      if (prefA[i][r] - prefA[i][l-1] > 0) {
        res++;
      }
    }

    // вывод результата
    fout &lt;&lt; res &lt;&lt; '\n';
  }

  fin.close();
  fout.close();
}
</pre>
  </details>
</article>

