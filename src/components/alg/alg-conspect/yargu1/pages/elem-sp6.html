<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contests" target="_blank">ЯрГУ. Кружок. Школьники</a></p>
  <p><a href="https://vkvideo.ru/@sportprog_yarsu" target="_blank">vkvideo.ru/@sportprog_yarsu</a></p>
</article>


<article class="article">
  <h1>Занятие 6. Основы С++ #5. Функции</h1>
  <p>Конспект видео от 2024.10.19</p>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contest/559129" target="_blank">Codeforces Контест 559129</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
        <a href="#p1">Функции</a>
    <br><a href="#p2">Рекурсия</a>
    <br><a href="#p3">Числа Фибоначчи</a>
    <br><a href="#p4">НОД</a>
    <br><a href="#p5">Компаратор</a>
    <br><a href="#p6">Работа с файлами</a>
  </p>
  <p>
        <a href="#task1">Задача A. НОД</a>
    <br><a href="#task2">Задача B. Без массивов</a>
    <br><a href="#task3">Задача C. Длинное выражение</a>
    <br><a href="#task4">Задача D. Факториал (очень простой)</a>
    <br><a href="#task5">Задача E. Разрезание на квадраты</a>
    <br><a href="#task6">Задача F. Сортировка Таноса</a>
    <br><a href="#task7">Задача G. Медиана</a>
    <br><a href="#task8">Задача H. Эпическая игра</a>
    <br><a href="#task9">Задача I. Вор и спички</a>
    <br><a href="#task10">Задача J. Amr и музыка</a>
    <br><a href="#task11">Задача K. Грибоводство</a>
    <br><a href="#task12">Задача L. z-сортировка</a>
    <br><a href="#task13">Задача M. Сортировка сдвигами</a>
    <br><a href="#task14">Задача N. Фотограф</a>
    <br><a href="#task15">Задача O. Бомбы</a>
    <br><a href="#task16">Задача P. Пары чисел</a>
    <br><a href="#task17">Задача Q. Плотный массив</a>
    <br><a href="#task18">Задача R. Не соседняя матрица</a>
    <br><a href="#task19">Задача S. Золотая лихорадка</a>
    <br><a href="#task20">Задача T. Mex подмножеств</a>
  </p>
</article>


<!-- Функции -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Функции</h3>

  <p>Функции позволяют отделить часто используемый код и переиспользовать его с разными значениями аргументов.</p>
<pre>
Тип Имя(аргумент1, аргумент2, аргумент3, …) {
  тело функции
  return возвращаемое значение;
}
</pre>
  <p>Если функция ничего не должна возвращать, её тип объявляется как void.</p>
  <p>В C++ есть возможность передавать аргументы в функции двумя способами.</p>
  <ol>
    <li>
      <p>Создавать локальную переменную, копируя в нее значение передаваемого объекта.</p>
<pre>
int sum(int a, int b) {
  return a + b;
}
</pre>
    </li>
    <li>
      <p>Использовать исходный объект с возможностью его изменять. Для этого надо передать аргументы через ссылку & или указатель *.</p>
<pre>
void swap(int& a, int& b) {
  int c = a;
  a = b;
  b = c;
}
</pre>
    </li>
  </ol>
</article>


<!-- Рекурсия -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>Рекурсия</h3>

  <p>Рекурсивные функции - это функции, которые вызывают сами себя. Такие функции довольно часто используются для обхода различных представлений. Например, если нам надо найти факториал числа n!. Так же факториал можно найти и при помощи циклов.</p>
<pre>
long long factorial(long long n) {
  if (n == 1) {
    return 1;
  } else {
    return n * factorial(n-1);
  }
}
</pre>
</article>


<!-- Числа Фибоначчи -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>Числа Фибоначчи</h3>

  <p>Функция для подсчета чисел Фибоначчи, трудоемкость O(a<sup>n</sup>).</p>
<pre>
int Fib(int n) {
  if (n &lt;= 2) {
    return 1;
  } else {
    return Fib(n-1) + Fib(n-2);
  }
}
</pre>
</article>


<!-- НОД -->
<article class="article">
  <div class="anchor" id="p4"></div>
  <h3>НОД</h3>

  <p>Функция для подсчета НОД. Медленная версия</p>
<pre>
int gcd1(int a, int b) {
  while (a != 0 && b != 0) {
    if (a > b) {
      a = a - b;
    } else {
      b = b - a;
    }
  }
  return a + b;
}
</pre>

<p>Функция для подсчета НОД. Быстрая версия</p>
<pre>
int gcd2(int a, int b) {
  while (a != 0 && b != 0) {
    if (a > b) {
      a = a % b;
    } else {
      b = b % a;
    }
  }
  return a + b;
}
</pre>

<p>Функция для подсчета НОД. Рекурсивная версия</p>
<pre>
int gcd3(int a, int b) {
  if (b != 0) {
    return gcd3(b, a % b);
  } else {
    return a;
  }
}
</pre>
</article>


<!-- Компаратор -->
<article class="article">
  <div class="anchor" id="p5"></div>
  <h3>Компаратор</h3>

  <p>Компаратор - это специальная функция, которая умеет сравнивать два объекта.</p>
<pre>
bool имя(аргумент1, аргумент2) {
  действия
  return результат;
}
</pre>
<pre>
bool comp(int a, int b) {
  return a > b;
}

int main() {
  int n;
  cin >> n;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }
  sort(A.begin(), A.end(), comp);
  for (int i = 0; i &lt; n; i ++) {
    cout &lt;&lt; A[i] &lt;&lt; " ";
  }
}
</pre>
</article>


<!-- Работа с файлами -->
<article class="article">
  <div class="anchor" id="p6"></div>
  <h3>Работа с файлами</h3>

  <p>Для работы с файлами необходимо подключить заголовочный файл fstream. В fstream определены несколько классов и подключены заголовочные файлы ifstream — файловый ввод и ofstream — файловый вывод.
  </p>
<pre>
#include &lt;fstream&gt;

int main() {
  int n;
  ifstream in("input.txt");
  ofstream out("output.txt");
  in >> n;
  out &lt;&lt; n * n;
  in.close();
  out.close();
}
</pre>

  <h4>Перенаправление stdin, stdout и stderr на файлы, определенные пользователем</h4>
  <p>freopen обычно используется для перенаправления заранее открытых файлов stdin, stdout и stderr на файлы, определенные пользователем.</p>
  <ul>
    <li>"r" Открывает для чтения. Если файл не существует или не удается найти, вызов завершается ошибкой freopen.</li>
    <li>"w"	Открывает пустой файл для записи. Если указанный файл существует, его содержимое удаляется.</li>
  </ul>
<pre>
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif
  int n;
  cin >> n;
  cout &lt;&lt; n * n;
</pre>
</article>


<!-- Задача A. НОД -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. НОД</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Даны два натуральных числа a и b, не равные нулю одновременно. Вычислить НОД(a, b) — наибольший общий делитель a и b.</p>

  <details>
    <summary>Пример</summary>
    <code>9 12</code>
    <code>3</code>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int nod(int a, int b) {
  while (a != 0 && b != 0) {
    if (a > b) {
      a = a % b;
    } else {
      b = b % a;
    }
  }
  return a + b;
}

int main() {
  // ввод данных
  int a, b;
  cin >> a >> b;

  // решение
  int res = nod(a, b);

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача B. Без массивов -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Без массивов</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Дано натуральное число N и последовательность из N элементов. Требуется вывести эту последовательность в обратном порядке.</p>
  <p>Примечание. В программе запрещается объявлять массивы и использовать циклы (даже для ввода).</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано натуральное число N (N ≤ 10³). Во второй строке через пробел идут N целых чисел, по модулю не превосходящих 1000, - элементы последовательности.</p>

  <h4>Выходные данные</h4>
  <p>Выведите заданную последовательность в обратном порядке.</p>

  <details>
    <summary>Пример</summary>
<pre>
3
1 2 3
</pre>
    <code>3 2 1</code>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

void sequence(int i) {
  i--;
  int temp;
  cin >> temp;
  if (i > 0) {
    sequence(i);
  }
  cout &lt;&lt; temp &lt;&lt; ' ';
}

int main() {
  // ввод данных
  int n;
  cin >> n;

  // решение
  sequence(n);
}
</pre>
  </details>
</article>


<!-- Задача C. Длинное выражение -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Длинное выражение</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В этой задаче вам нужно посчитать значение выражения (1ᵏ + 2ᵏ + ⋯ + nᵏ)ᵖ. В этой задаче необходимо оформить возведение в степень в виде функции. Гарантируется что значение выражения не превышает 9⋅10¹⁸.</p>

  <h4>Входные данные</h4>
  <p>В единственной строке входных данных вводится 3 числа n, k, p.</p>

  <h4>Выходные данные</h4>
  <p>Выведите значение заданного в условии выражения.</p>

  <details>
    <summary>Пример</summary>
    <code>3 2 3</code>
    <code>2744</code>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

long long power(long long a, long long b) {
  long long res = 1;
  for (int i = 1; i &lt;= b; i++) {
    res *= a;
  }
  return res;
}

int main() {
  // ввод данных
  long long n, k, p;
  cin >> n >> k >> p;

  // решение
  long long sum = 0;
  for (int i = 1; i &lt;= n; i++) {
    sum += power(i, k);
  }

  long long res = power(sum, p);

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача D. Факториал (очень простой) -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Факториал (очень простой)</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Дано число n (n ≤ 20). Выведите n!</p>

  <details>
    <summary>Пример</summary>
    <code>4</code>
    <code>24</code>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

long long fakt(long long a) {
  if (a == 1) {
    return 1;
  } else {
    return a * fakt(a-1);
  }
}

int main() {
  // ввод данных
  long long n;
  cin >> n;

  // решение
  long long res = fakt(n);

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача E. Разрезание на квадраты -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Разрезание на квадраты</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Полоска бумаги имеет размеры A x B. Каждый раз от её края отрезается квадрат максимального размера до тех пор, пока не получится квадрат. Сколько квадратов получится?</p>

  <h4>Входные данные</h4>
  <p>Программе даны числа A и B(1 ≤A, B ≤ 10⁹).</p>

  <h4>Выходные данные</h4>
  <p>Требуется вывести количество квадратов.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>15 3</code>
    <code>5</code>

    <h4>Пример 2</h4>
    <code>12 8</code>
    <code>3</code>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int kvadr(int a, int b) {
  if (a == b) {
    return 1;
  } else if (a > b) {
    return 1 + kvadr(a  - b, b);
  } else {
    return 1 + kvadr(b - a, a);
  }
}

int main() {
  // ввод данных
  int a, b;
  cin >> a >> b;

  // решение
  int res = kvadr(a, b);

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача F. Сортировка Таноса -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Сортировка Таноса</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Сортировка Таноса — суперзлодейский алгоритм сортировки, работающий следующим образом: если массив не отсортирован, щелкните пальцами*, чтобы уничтожить первую или вторую половину элементов, и повторите процесс.</p>

  <p>Вам дан входной массив. Какова максимальная длина отсортированного массива, который можно из него получить, используя сортировку Таноса?</p>

  <p>*Требует наличия Перчатки бесконечности.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит число n (1 ≤ n ≤ 16) — размер массива. Гаратируется, что n — степень двойки.</p>
  <p>Вторая строка входных данных содержит n целых чисел, разделенных пробелами, aᵢ (1 ≤ aᵢ ≤ 100) — элементы массива.</p>

  <h4>Выходные данные</h4>
  <p>Выведите максимальную длину отсортированного массива, который можно получить, используя сортировку Таноса. Элементы итогового массива должны быть отсортированы в порядке неубывания.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
4
1 2 2 4
</pre>
    <code>4</code>
    <p>В первом примере массив уже отсортирован, и можно обойтись без щелчков.</p>

    <h4>Пример 2</h4>
<pre>
8
11 12 1 2 13 14 3 4
</pre>
    <code>2</code>
    <p>Во втором примере входной массив содержит отсортированный подмассив из 4 элементов, но увы, удалять элементы из разных частей массива за один щелчок нельзя. Можно удалять только все элементы из первой или из второй половины массива, поэтому потребуется два щелчка, чтобы получить отсортированный массив длины 2.</p>

    <h4>Пример 3</h4>
<pre>
4
7 6 5 4
</pre>
    <code>1</code>
    <p>В третьем примере массив отсортирован в порядке убывания, и спасти от уничтожения получится только один элемент.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1145/problem/A" target="_blank">Задача 1145A</a>
      <br><a href="https://codeforces.com/contest/1145" target="_blank">Первоапрельский контест 2019 2019-03-29</a>
    </div>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int max_size = 0;

bool check(vector&lt;int&gt;& A, int l, int r) {
  for (int i = l; i &lt; r; i++) {
    if (A[i] > A[i + 1]) {
      return false;
    }
  }
  return true;
}

void sort_tanos(vector&lt;int&gt;& A, int l, int r) {
  if (check(A, l, r)) {
    max_size = max(max_size, r - l + 1);
  } else {
    int mid = (l + r) / 2;
    sort_tanos(A, l, mid);     // левая половина
    sort_tanos(A, mid + 1, r); // правая половина
  }
}

int main() {
  // ввод данных
  int n;
  cin >> n;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  sort_tanos(A, 0, n - 1);

  // вывод результата
  cout &lt;&lt; max_size;
}
</pre>
  </details>
</article>


<!-- Задача G. Медиана -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Медиана</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Медианой в массиве длины n называется элемент, который после сортировки элементов по неубыванию будет стоять на позиции номер ⌊(n+1) / 2⌋ (элементы массива нумеруются начиная с 1). Медианой массива (2, 6, 1, 2, 3) является число 2, а медианой массива (0, 96, 17, 23) — число 17.</p>

  <p>Под выражением ⌊(a / b)⌋ понимается целая часть от деления числа a на число b.</p>

  <p>Однажды Вася показал Пете массив из n натуральных чисел и предложил найти медиану этого массива. Петя, даже не взглянув на числа, ответил, что она равна x. Петя очень честный мальчик, поэтому он решил добавить к заданному массиву несколько чисел таким образом, чтобы медиана получившегося массива стала равна x.</p>

  <p>Петя может добавлять в массив любые целые числа от 1 до 10⁵, в том числе и одинаковые. Разумеется, разрешается ничего не добавлять в массив. Если число добавляется несколько раз, то в ответе оно учитывается такое же количество раз. Исходные числа массива запрещено удалять либо заменять.</p>

  <p>Пока Петя отвлекает Васю, вы должны найти минимальное количество чисел, которые ему потребуются.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных записаны два разделенных пробелом целых числа n и x (1 ≤ n ≤ 500, 1 ≤ x ≤ 10⁵) — длина исходного массива и требуемое значение медианы. Во второй строке записаны n чисел через пробел — исходный массив. Элементы массива — целые числа от 1 до 10⁵. Элементы массива не обязательно различны.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное целое число — минимальное количество чисел, которое нужно добавить Пете в массив, чтобы его медиана стала равна x.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
3 10
10 20 30
</pre>
    <code>1</code>
    <p>В первом примере в массив (10, 20, 30) достаточно добавить число 9. В получившемся массиве (9, 10, 20, 30) медианой будет элемент на позиции ⌊(4 + 1) / 2⌋, то есть 10</p>

    <h4>Пример 2</h4>
<pre>
3 4
1 2 3
</pre>
    <code>4</code>
    <p>Во втором примере в массив нужно добавить числа 4, 5, 5, 5. В получившемся массиве медиана равна 4</p>
  </details>

  <details>
    <summary>Еще примеры</summary>

  <h4>Пример 3 (x > A[n-1])</h4>
<pre>
4 2
1 1 1 1
</pre>
  <code>5</code>

  <h4>Пример 4 (x &lt; A[0])</h4>
<pre>
4 1
2 2 2 2
</pre>
  <code>4</code>

  <h4>Пример 6 (x &lt; m)</h4>
<pre>
3 1
1 2 2
</pre>
  <code>1</code>
<pre>
4 1
1 2 2 2
</pre>
  <code>2</code>
<pre>
5 1
1 2 2 2 2
</pre>
  <code>3</code>
<pre>
6 1
1 2 2 2 2 2
</pre>
  <code>4</code>

  <h4>Пример 7 (x > m)</h4>
<pre>
3 2
1 1 2
</pre>
  <code>2</code>
<pre>
4 2
1 1 1 2
</pre>
  <code>3</code>
<pre>
5 2
1 1 1 1 2
</pre>
  <code>4</code>
<pre>
6 2
1 1 1 1 1 2
</pre>
  <code>5</code>

  <h4>Пример 8 (x = m)</h4>
<pre>
5 3
1 2 3 4 5
</pre>
  <code>0</code>
<pre>
6 3
1 2 3 4 5 6
</pre>
  <code>0</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/166/problem/C" target="_blank">Задача 166C</a>
      <br><a href="https://codeforces.com/contest/166" target="_blank">Codeforces Round 113 (Div. 2) 2012-03-23</a>
    </div>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ввод данных
  int n, x;
  cin >> n >> x;

  // собираем входной массив
  vector&lt;int&gt; A(0);
  int temp;
  for (int i = 0; i &lt; n; i++) {
    cin >> temp;
    A.push_back(temp);
  }

  // решение
  // сортируем
  sort(A.begin(), A.end());

  // находим медиану
  int ind = (n + 1) / 2 - 1;
  int med = A[ind];
  int count = 0;

  // всего 5 случаев
  // 1) если x больше всех элементов
  if (x > A[n - 1]) {
    count = n + 1;

  // 2) если x меньше всех элементов
  } else if (x &lt; A[0]) {
    count = n;

  // 3) если x &lt; med
  } else if (x &lt; med) {
    int c = 0;
    // пока x меньше медианы
    while (x &lt; med) {
      c++;
      med = A[ind - c];
    }
    if (n % 2) {
      count = c * 2 - 1;
    } else {
      count = c * 2;
    }

  // 4) если x > med
  } else if (x > med) {
    int c = 0;
    // пока x больше медианы
    while (x > med) {
      c++;
      med = A[ind + c];
    }
    if (n % 2) {
      count = c * 2;
    } else {
      count = c * 2 - 1;
    }
  }

  // 5) если x == med, то оставляем count == 0

  // вывод результата
  cout &lt;&lt; count;
}
</pre>
  </details>
</article>


<!-- Задача H. Эпическая игра -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Эпическая игра</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Семен и Антисемен играют в игру. Изначально каждому игроку дано одно фиксированное целое положительное число, которое не меняется в процессе игры. Семену дано число a, Антисемену дано число b. Также у них есть кучка из n камней. Игроки ходят по очереди, первый ход делает Семен. На своем ходу игрок должен взять из кучки число камней, равное наибольшему общему делителю данного ему числа и количества оставшихся камней в кучке. Проигрывает тот, кто не сможет взять требуемое число камней (по причине того, что в кучке остается строго меньше камней, чем нужно взять).</p>

  <p>Ваша задача — по заданным a, b и n определить, кто выиграет в этой игре.</p>

  <h4>Входные данные</h4>
  <p>В единственной строке через пробел записаны целые числа a, b и n (1 ≤ a, b, n ≤ 100) — числа, данные Семену и Антисемену соответственно, и исходное количество камней в кучке.</p>

  <h4>Выходные данные</h4>
  <p>Если выиграет Семен, выведите «0» (без кавычек), иначе выведите «1» (без кавычек).</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>3 5 9</code>
    <code>0</code>
    <p>Наибольшим общим делителем двух неотрицательных целых чисел a и b называется такое наибольшее положительное целое число k, что a делится на k без остатка, и, аналогично, b делится на k без остатка. Обозначим через gcd(a, b) операцию вычисления наибольшего общего делителя чисел a и b. В частности, gcd(x, 0) = gcd(0, x) = x.</p>

    <p>В первом примере игра будет идти следующим образом:</p>
    <ul>
      <li>Семен должен взять из кучки gcd(3, 9) = 3 камня. После его хода в кучке остается 6 камней.</li>
      <li>Антисемен должен взять из кучки gcd(5, 6) = 1 камень. После его хода в кучке остается 5 камней.</li>
      <li>Семен должен взять из кучки gcd(3, 5) = 1 камень. После его хода в кучке остается 4 камня.</li>
      <li>Антисемен должен взять из кучки gcd(5, 4) = 1 камня. После его хода в кучке остается 3 камня.</li>
      <li>Семен должен взять из кучки gcd(3, 3) = 3 камня. После его хода в кучке остается 0 камней.</li>
      <li>Антисемен должен взять из кучки gcd(5, 0) = 5 камня. Так как 0 &lt; 5, это сделать невозможно, и Антисемен проигрывает.</li>
    </ul>

    <h4>Пример 2</h4>
    <code>1 1 100</code>
    <code>1</code>
    <p>Во втором примере каждый игрок на каждом ходу берет из кучки по одному камню. Так как n четное, последний камень возьмет Антисемен, а Семен после этого не сможет сделать ход.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/119/problem/A" target="_blank">Задача 119A</a>
      <br><a href="https://codeforces.com/contest/119" target="_blank">Codeforces Beta Round 90 2011-10-14</a>
    </div>

<pre>
#include &lt;iostream&gt;

using namespace std;

long long gcd(long long a, long long b) {
  while (a * b != 0) {
    if (a > b) {
      a %= b;
    } else {
      b %= a;
    }
  }
  return a + b;
}

int main() {
  // ввод данных
  long long a, b, n, cnt = 0;
  cin >> a >> b >> n;

  // решение
  while (n != 0) {
    if (cnt == 0) {
      n -= gcd(a, n);
      cnt = 1;
    } else {
      n -= gcd(b, n);
      cnt = 0;
    }
  }

  // вывод результата
  cout &lt;&lt; (cnt + 1) % 2;
}
</pre>
  </details>
</article>


<!-- Задача I. Вор и спички -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача I. Вор и спички</h3>

  <div><i>Ограничение по времени 0.5с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Вор пробрался на склад спичек и хочет украсть как можно больше спичек. На складе находится m контейнеров, в контейнере номер i находится aᵢ коробок спичек, а в каждой коробке bᵢ спичек. Все коробки имеют одинаковый размер. В рюкзак вора помещается ровно n коробок. Ваша задача найти наибольшее количество спичек, которое сможет унести вор. У него нет времени на перекладывание спичек между коробками, поэтому он просто выбирает не более n коробок так, чтобы суммарное число спичек в них было максимальным.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных находится число n (1 ≤ n ≤ 2·10⁸) и число m (1 ≤ m ≤ 20). В i + 1 строке находится пара чисел aᵢ и bᵢ (1 ≤ aᵢ ≤ 10⁸, 1 ≤ bᵢ ≤ 10). Все числа во входных данных — целые.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное число — ответ на задачу.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
7 3
5 10
2 5
3 6
</pre>
    <code>62</code>

    <h4>Пример 2</h4>
<pre>
3 3
1 3
2 2
3 1
</pre>
    <code>7</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/16/problem/B" target="_blank">Задача 16B</a>
      <br><a href="https://codeforces.com/contest/16" target="_blank">Codeforces Beta Round 16 (Див. 2) 2010-06-03</a>
    </div>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

bool compare(const pair&lt;int, int&gt;& a, const pair&lt;int, int&gt;& b) {
  return a.second > b.second;
}

int main() {
  // ввод данных
  int n, m;
  cin >> n >> m;

  vector&lt;pair&lt;int, int&gt; &gt; A(m);
  for (int i = 0; i &lt; m; i++) {
    cin >> A[i].first >> A[i].second;
  }

  // решение
  sort(A.begin(), A.end(), compare);
  int res = 0;
  int ost = n;

  for (auto& cont : A) {
    int a = cont.first;
    int b = cont.second;

    if (ost &lt;= 0) {
      break;
    }

    int take = min(a, ost);
    res += take * b;
    ost -= take;
  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача J. Amr и музыка -->
<article class="article">
  <div class="anchor" id="task10"></div>
  <h3>Задача J. Amr и музыка</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Amr — молодой программист и большой меломан. Он всегда хотел научиться исполнять музыку, но программирование отнимает слишком много его времени. И вот, у юноши созрел план.</p>

  <p>У Amr есть n инструментов, чтобы научиться играть на i-м инструменте, надо потратить на обучение не менее aᵢ дней. Так как Amr занятой человек, он решил посвятить k дней тому, чтобы научиться игре на как можно большем количестве инструментов.</p>

  <p>Amr попросил вас помочь ему распределить свои незанятые дни по инструментам, так, чтобы он научился играть на как можно большем количестве инструментов.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано два числа n, k (1 ≤ n ≤ 100, 0 ≤ k ≤ 10000), количество инструментов и количество дней, соответственно.</p>

  <p>Во второй строке записано n целых чисел aᵢ (1 ≤ aᵢ ≤ 100) — количество дней, необходимых для изучения i-го инструмента.</p>

  <h4>Выходные данные</h4>
  <p>В первой строке выведите единственное целое число m, обозначающее наибольшее количество инструментов, игре на которых Amr сможет научиться.</p>

  <p>Во второй строке выведите m целых чисел через пробел: индексы инструментов, на которых юноше следует учиться играть. Индексы можно выводить в любом порядке.</p>

  <p>Если существует несколько оптимальных решений, выведите любое из них. Использовать все дни на учебу необязательно.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
4 10
4 3 1 2
</pre>
<pre>
4
1 2 3 4
</pre>
    <p>В первом тесте Amr может научиться играть на всех 4 инструментах.</p>

    <h4>Пример 2</h4>
<pre>
5 6
4 3 1 1 2
</pre>
<pre>
3
1 3 4
</pre>
    <p>Во втором тесте другие возможные варианты: {2, 3, 5} или {3, 4, 5}.</p>
    <h4>Пример 3</h4>
<pre>
1 3
4
</pre>
<pre>
0
</pre>
    <p>В третьем тесте у Amr недостаточно времени для того, чтобы научиться играть на единственном данном инструменте.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/507/problem/A" target="_blank">Задача 507A</a>
      <br><a href="https://codeforces.com/contest/507" target="_blank">Codeforces Round 287 (Div. 2) 2015-01-21</a>
    </div>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

bool compare(const pair&lt;int, int&gt;& a, const pair&lt;int, int&gt;& b) {
  return b.second > a.second;
}

int main() {
  // ввод данных
  int n, k;
  cin >> n >> k;

  vector&lt;pair&lt;int, int&gt; &gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    A[i].first = i;
    cin >> A[i].second;
  }

  // решение
  sort(A.begin(), A.end(), compare);
  int res = 0;

  while (res &lt; n && (k -= A[res].second) >= 0) {
    res++;
  }

  // вывод результата
  cout &lt;&lt; res &lt;&lt; '\n';
  for (int i = 0; i &lt; res; i++) {
    cout &lt;&lt; A[i].first + 1 &lt;&lt; ' ';
  }
}
</pre>
  </details>
</article>


<!-- Задача K. Грибоводство -->
<article class="article">
  <div class="anchor" id="task11"></div>
  <h3>Задача K. Грибоводство</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Каждый год в замке Короля Гномов проходит состязание в выращивании грибов среди гномов. Соревнование является одним из самых престижных, а за победу в нем дают деревянную салатницу. В этом году на мероприятие собрались лучшие грибоводы со всего мира, поэтому пришлось немного изменить правила, чтобы зрителям было интереснее наблюдать.</p>

  <p>У каждого грибовода есть свой гриб, который он будет выращивать на состязании. По новым правилам состязание будет состоять из двух частей. Первая часть длится t₁ секунд, а вторая t₂ секунд, между первой и второй частью есть небольшой перерыв.</p>

  <p>После стартового свистка начинается первая часть состязания, и все грибоводы одновременно начинают выращивать грибы, каждый со своей скоростью vᵢ метров в секунду. Спустя t₁ секунд, грибоводы прекращают выращивать грибы и уходят на перерыв. Во время перерыва, по необъяснимым причинам, рост всех грибов уменьшается на k процентов. После перерыва стартует вторая часть состязания и все грибоводы одновременно продолжают выращивать грибы, каждый со своей скоростью uᵢ метров в секунду. Спустя t₂ секунд после окончания перерыва состязание заканчивается. Обратите внимание, что скорости до перерыва и после перерыва могут отличаться.</p>

  <p>Перед состязанием гном Паша узнал у всех участников, какие две скорости они выбрали. Но участники, не захотели раскрывать ему всю свою стратегию и поэтому не сказали в каком порядке они будут использовать эти скорости. То есть если участник выбрал скорости aᵢ и bᵢ, то возможны два варианта: либо до перерыва он использует скорость aᵢ, а после bᵢ, либо наоборот.</p>

  <p>Гном Паша очень хочет выиграть тотализатор. Он знает, что каждый участник выберет стратегию максимизирующую высоту своего гриба. Помогите гному Паше составить финальную таблицу результатов соревнования.</p>

  <p>Участники сортируются в таблице результатов по высоте гриба (участники с более высокими грибами стоят в таблице раньше). При равенстве высот грибов участники сортируются по их номеру (участники с меньшим номером стоят раньше).</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных записано четыре целых числа n, t₁, t₂, k (1 ≤ n, t₁, t₂ ≤ 1000; 1 ≤ k ≤ 100) — количество участников, время до перерыва, время после перерыва и процент, на который падает рост грибов за перерыв, соответственно.</p>

  <p>В каждой из следующих n строк записано по два целых числа. В i-ой (1 ≤ i ≤ n) строке записаны через пробел целые числа aᵢ, bᵢ (1 ≤ aᵢ, bᵢ ≤ 1000) — скорости, которые выбрал учаcтник c номером i.</p>

  <h4>Выходные данные</h4>
  <p>Выведите финальную таблицу результатов: n строк, каждая строка должна содержать номер соответствующего гнома и итоговую максимальную величину его гриба ровно с двумя знаками после точки. Ответ будет считаться правильным, если он абсолютно точный.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
2 3 3 50
2 4
4 2
</pre>
<pre>
1 15.00
2 15.00
</pre>
    <p>Первый пример: Обоим участникам удобнее сначала использовать скорость 2, а потом скорость 4, так как 2·3·0.5 + 4·3 > 4·3·0.5 + 2·3.</p>

    <h4>Пример 2</h4>
<pre>
4 1 1 1
544 397
280 101
280 101
693 970
</pre>
<pre>
4 1656.07
1 937.03
2 379.99
3 379.99
</pre>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/186/problem/B" target="_blank">Задача 186B</a>
      <br><a href="https://codeforces.com/contest/186" target="_blank">Codeforces Round 118 (Div. 2) 2012-05-04</a>
    </div>

    <p>Для каждого участника вычислим максимальную высоту гриба, рассчитанную для двух вариантов порядка скоростей. Отсортировать участников по убыванию высоты гриба, а при равенстве - по порядковым номерам</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

bool compare(const pair&lt;int, double&gt;& a, const pair&lt;int, double&gt;& b) {
  if (a.second != b.second) {
    return a.second > b.second;
  } else {
    return a.first &lt; b.first;
  }

}

int main() {
  // ввод данных
  int n, t1, t2, k;
  cin >> n >> t1 >> t2 >> k;

  // рост
  vector&lt;pair&lt;int, double&gt; &gt; A(n);

  int tmp1, tmp2;
  for (int i = 0; i &lt; n; i++) {
    cin >> tmp1 >> tmp2;

    // рост если первой пришла скорость до перерыва
    double r1 = t1 * tmp1 - t1 * tmp1 * k / 100.0 + t2 * tmp2;

    // рост если первой пришла скорость после перерыва
    double r2 = t1 * tmp2 - t1 * tmp2 * k / 100.0 + t2 * tmp1;

    A[i].first = i;
    A[i].second = (r1 > r2) ? r1 : r2;
  }

  // решение
  sort(A.begin(), A.end(), compare);

  // вывод результата
  cout &lt;&lt; fixed;
  cout.precision(2);

  for (int i = 0; i &lt; n; i++) {
    cout &lt;&lt; A[i].first + 1 &lt;&lt; ' ' &lt;&lt; A[i].second &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача L. z-сортировка -->
<article class="article">
  <div class="anchor" id="task12"></div>
  <h3>Задача L. z-сортировка</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Ученик z-школы нашёл интересный способ сортировки чисел, называемый z-сортировкой. Массив a, состоящий из n элементов является z-отсортированным, если выполнены два условия:</p>
  <ol>
    <li>aᵢ ≥ aᵢ₋₁ для всех чётных i,</li>
    <li>aᵢ ≤ aᵢ₋₁ для всех нечётных i > 1.</li>
  </ol>
  <p>Например массивы [1,2,1,2] и [1,1,1,1] являются z-отсортированными, а массив [1,2,3,4] таковым не является.</p>
  <p>Можете ли вы осуществить z-сортировку заданного массива?</p>

  <h4>Входные данные</h4>
  <p>В первой строке находится целое число n (1 ≤ n ≤ 1000) — количество элементов в массиве a.</p>

  <p>Во второй строке находится n целых чисел aᵢ (1 ≤ aᵢ ≤ 10⁹) — элементы массива a.</p>

  <h4>Выходные данные</h4>
  <p>Если возможно осуществить z-сортировку массива a выведите n целых чисел aᵢ — элементы массива после z-сортировки. В противном случае выведите одно слово "Impossible".</p>

  <details>
    <summary>Примеры</summary>
  <h4>Пример 1</h4>
<pre>
4
1 2 2 1
</pre>
    <code>1 2 1 2</code>

    <h4>Пример 2</h4>
<pre>
5
1 3 2 2 5
</pre>
    <code>1 5 2 3 2</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/652/problem/B" target="_blank">Задача 652B</a>
      <br><a href="https://codeforces.com/contest/652" target="_blank">Educational Codeforces Round 10 2016-03-25</a>
    </div>

    <p>Нужно отсортировать массив. Завести два указателя на начало и конец массива. Потом в новый массив класть по очереди элементы то сначала, то с конца.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;

  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  sort(A.begin(), A.end());
  int l = 0;
  int r = A.size() - 1;
  vector&lt;int&gt; B(0);

  while (r >= l) {
    B.push_back(A[l]);
    B.push_back(A[r]);
    l++;
    r--;
  }

  // вывод результата
  for (int i = 0; i &lt; n; i++) {
    cout &lt;&lt; B[i] &lt;&lt; ' ';
  }
}
</pre>
  </details>
</article>


<!-- Задача M. Сортировка сдвигами -->
<article class="article">
  <div class="anchor" id="task13"></div>
  <h3>Задача M. Сортировка сдвигами</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Во внешней памяти нового поколения расположен массив целых чисел a[1 ... n]=[a₁, a₂, ... , aₙ].</p>

  <p>Данный вид памяти не позволяет изменить значение произвольного элемента по его индексу. Вместо этого можно вырезать любой подотрезок данного массива, циклически сдвинуть его на произвольную величину и вставить обратно на то же самое место.</p>

  <p>Формально, один такий циклический сдвиг состоит из двух последовательных действий:</p>
  <ol>
    <li>Выбрать произвольные l и r (1 ≤ l &lt; r ≤ n) — границы изменяемого подотрезка массива.</li>
    <li>Заменить подотрезок массива a[l ... r] на его циклический сдвиг влево на произвольную величину d. Поясним понятие циклический сдвиг: последовательность [1,4,1,3] является циклическим сдвигом последовательности [3,1,4,1] на 1 влево. Последовательность [4,1,3,1] является циклическим сдвигом последовательности [3,1,4,1] на 2 влево.</li>
  </ol>

  <p>Например, если a=[1,3,2,8,5], то при выборе l=2, r=4
   и d=2 получается подотрезок a[2 ... 4]=[3,2,8]. Затем этот отрезок сдвигается на d=2 влево, и получается подотрезок [8,3,2], который в итоге встает на место исходных элементов отрезка. Получается a=[1,8,3,2,5].</p>

  <p>Отсортируйте заданный массив a, используя не более n циклических сдвигов любых его отрезков. Обратите внимание, что вам не нужно минимизировать количество циклических сдвигов. Подойдет любой способ, который требует n или менее циклических сдвигов.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое число t (1 ≤ t ≤ 1000) — количество наборов входных данных.</p>

  <p>В следующих 2t строках даны описания наборов входных данных.</p>

  <p>В описании каждого набора входных данных первая строка содержит целое число n (2 ≤ n ≤ 50) — длину массива, а во второй строке через пробел перечислены элементы массива aᵢ (-10⁹ ≤ aᵢ ≤ 10⁹). Элементы массива a могут повторяться, то есть не обязаны быть уникальными.</p>

  <h4>Выходные данные</h4>
  <p>Выведите t ответов на все наборы входных данных.</p>

  <p>Первая строка ответа на набор входных данных должна содержать число k (0 ≤ k ≤ n) — количество действий, которыми сортируется массив. Следующие k строк должны содержать описания действий в формате «l r d» (без кавычек), где l и r (1 ≤ l &lt; r ≤ n) — это границы сдвигаемого отрезка, а d (1 ≤ d ≤ r-l) — величина сдвига. Напоминаем, что по условию задачи рассматриваются циклические сдвиги влево, и выбранный отрезок будет сдвинут на d влево.</p>

  <p>Обратите внимание, что от вас не требуется найти минимальное необходимое для сортировки количество циклических сдвигов. Подойдет любой способ сортировки, количество сдвигов в котором не превосходит n.</p>

  <p>Если заданный массив a уже отсортирован, то одним из возможных ответов является k=0 и пустая последовательность циклических сдвигов.</p>

  <p>Если возможных ответов несколько, выведите любой из них.</p>

  <details>
    <summary>Пример</summary>
<pre>
4
2
2 1
3
1 2 1
4
2 4 1 3
5
2 5 1 4 3
</pre>
<pre>
1
1 2 1
1
1 3 2
3
2 4 1
2 3 1
1 3 2
4
2 4 2
1 5 3
1 2 1
1 3 1
</pre>
    <p>Пояснение к четвертому набору данных в примере:</p>
    <ol>
      <li>Выбирается отрезок a[2…4] и сдивгается на 2 влево: [2,5,1,4,3]⟶[2,4,5,1,3]</li>
      <li>Выбирается отрезок a[1…5] и сдвигается на 3 влево: [2,4,5,1,3]⟶[1,3,2,4,5]</li>
      <li>Выбирается отрезок a[1…2] и сдвигается на 1 влево: [1,3,2,4,5]⟶[3,1,2,4,5]</li>
      <li>Выбирается отрезок a[1…3] и сдвигается на 1 влево: [3,1,2,4,5]⟶[1,2,3,4,5]</li>
    </ol>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1579/problem/B" target="_blank">Задача 1579B</a>
      <br><a href="https://codeforces.com/contest/1579" target="_blank">Codeforces Round 744 (Div. 3) 2021-09-26</a>
    </div>

    <p>Для каждого элемента массива находим минимальный элемент в оставшейся части. Если минимальный элемент уже на месте, пропускаем итерацию. Иначе выполняем циклический сдвиг подмассива от текущей позиции до позиции минимального элемента так, чтобы минимальный элемент переместился на текущую позицию.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

void solve() {
  // ввод данных
  int n;
  cin >> n;
  vector&lt;int&gt; a(n);
  for (int i = 0; i &lt; n; ++i) {
      cin >> a[i];
  }

  vector&lt;tuple&lt;int, int, int&gt; &gt; operations;

  for (int i = 0; i &lt; n; ++i) {
    // Находим позицию минимального элемента в оставшейся части
    int min_pos = i;
    for (int j = i + 1; j &lt; n; ++j) {
      if (a[j] &lt; a[min_pos]) {
        min_pos = j;
      }
    }

    if (min_pos == i) continue; // Уже на месте

    // Выполняем циклический сдвиг подмассива a[i..min_pos] на d = min_pos - i
    int d = min_pos - i;
    vector&lt;int&gt; temp(a.begin() + i, a.begin() + min_pos + 1);
    rotate(temp.begin(), temp.begin() + d, temp.end());
    copy(temp.begin(), temp.end(), a.begin() + i);

    operations.emplace_back(i + 1, min_pos + 1, d);
  }

  cout &lt;&lt; operations.size() &lt;&lt; endl;
  for (auto& op : operations) {
    cout &lt;&lt; get&lt;0&gt;(op) &lt;&lt; " "
         &lt;&lt; get&lt;1&gt;(op) &lt;&lt; " "
         &lt;&lt; get&lt;2&gt;(op) &lt;&lt; endl;
  }
}

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    solve();
  }

}
</pre>
  </details>
</article>


<!-- Задача N. Фотограф -->
<article class="article">
  <div class="anchor" id="task14"></div>
  <h3>Задача N. Фотограф</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Валера давно мечтал работать фотографом, и поэтому купил себе новый фотоаппарат. С каждым днем он получал все больше и больше заказов на фотографии, и в один прекрасный день Валере понадобилась программа, которая будет определять, сколько максимум человек он сможет обслужить.</p>

  <p>Память фотоаппарата составляет d мегабайт. Фотоаппарат Валеры умеет делать фотографии в высоком и низком качестве. Одна фотография в низком качестве занимает a мегабайт памяти, одна фотография в высоком качестве занимает b мегабайт памяти. По необъяснимым причинам каждый клиент просит сделать ему несколько фотографий в низком и несколько фотографий в высоком качестве. Более формально, i-ый клиент приходит с просьбой сделать ему xᵢ фотографий в низком качестве и yᵢ фотографий в высоком качестве.</p>

  <p>Валера хочет обслужить как можно больше клиентов, чтобы они остались довольны его работой. Чтобы i-ый клиент остался доволен работой Валеры, ему нужно выполнить заказ клиента полностью, то есть сделать xᵢ фотографий в низком качестве и yᵢ фотографий в высоком качестве. Чтобы сделать одну фотографию в низком качестве, в памяти фотоаппарата должно быть не менее a мегабайт свободной памяти. Аналогично чтобы сделать одну фотографию в высоком качестве, в памяти фотоаппарата должно быть не менее b мегабайт свободной памяти. Изначально память фотоаппарата пуста. Также Валера не удаляет фотографии из фотоаппарата, поэтому память фотоаппарата постепенно заполняется.</p>

  <p>Посчитайте, какое максимальное количество клиентов Валера сможет успешно обслужить, а также выведите номера этих клиентов.</p>

  <h4>Входные данные</h4>
  <p>В первой строке заданы два целых числа n и d (1 ≤ n ≤ 10⁵, 1 ≤ d ≤ 10⁹) — количество клиентов и размер памяти фотоаппарата соответственно. Во второй строке заданы два целых числа a и b (1 ≤ a ≤ b ≤ 10⁴) — размер одной фотографии в низком и высоком качестве соответственно.</p>

  <p>Далее в n строках задано описание клиентов. В i-ой строке содержатся два целых числа xᵢ и yᵢ (0 ≤ xᵢ, yᵢ ≤ 10⁵) — количество требуемых i-ому клиенту фотографий в низком и высоком качестве соответственно.</p>

  <p>Все числа во всех строках разделены единичными пробелами.</p>

  <h4>Выходные данные</h4>
  <p>В первую строку выведите ответ на задачу — максимальное количество клиентов, которое Валера сможет успешно обслужить. Во вторую строку выведите номера этих клиентов в произвольном порядке. Все номера должны быть различны. Если ответов несколько, выведите любой из них. Клиенты нумеруются, начиная с 1, в том порядке, в котором они заданы во входных данных.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
3 10
2 3
1 4
2 1
1 0
</pre>
<pre>
2
3 2
</pre>

    <h4>Пример 2</h4>
<pre>
3 6
6 6
1 1
1 0
1 0
</pre>
<pre>
1
2
</pre>
  </details>

  <details>
    <summary>Мое решение</summary>

    <div>
      <a href="https://codeforces.com/contest/203/problem/C" target="_blank">Задача 203C</a>
      <br><a href="https://codeforces.com/contest/203" target="_blank">Codeforces Round 128 (Div. 2) 2012-07-03</a>
    </div>

    <p>Пример</p>
<pre>
1 10
2 2
1 1
</pre>
<pre>
1
1
</pre>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

bool compare(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b) {
  return a.second &lt; b.second;
}

int main() {
  // ввод данных
  int n, d, a, b;
  cin >> n >> d >> a >> b;
  vector&lt;pair&lt;int, int&gt; &gt; A(n);
  int n1, n2;

  // решение
  for (int i = 0; i &lt; n; i++) {
    cin >> n1;
    cin >> n2;
    A[i].first = i + 1;
    A[i].second = n1 * a + n2 * b;
  }
  sort(A.begin(), A.end(), compare);
  long long sum = 0;
  int count = 0;
  while (count &lt; n && sum + A[count].second &lt;= d) {
    sum += A[count].second;
    count++;
  }

  // вывод результата
  cout &lt;&lt;count &lt;&lt; '\n';
  for (int i = 0; i &lt; count; i++) {
    cout &lt;&lt; A[i].first &lt;&lt; ' ';
  }
}
</pre>
  </details>
</article>


<!-- Задача O. Бомбы -->
<article class="article">
  <div class="anchor" id="task15"></div>
  <h3>Задача O. Бомбы</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У Вас есть робот, задачей которого является уничтожение бомб, расположенных на координатной плоскости. А именно, на координатной плоскости расположены n бомб, причем i-ая бомба расположена в точке с координатами (xᵢ, yᵢ). Известно, что никакие две бомбы не расположены в одной точке и что никакая бомба не расположена в точке с координатами (0, 0).</p>

  <p>Изначально робот расположен в точке с координатами (0, 0). Для удобства будем обозначать парой (x, y) — текущее положение робота. Для того, чтобы уничтожить все бомбы, робот должен выполнить несколько операций, каждая операция одного из следующих трех типов:</p>
  <ol>
    <li>Формат операции — «1 k dir». Во время выполнения операции робот k (k ≥ 1) раз перемещается в направлении dir. Всего робот может двигаться только в 4 направления: «R», «L», «U», «D». За одно перемещение в зависимости от направления dir робот переходит в одну из следующих точек: (x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1) (точки заданы соответственно направлениям). Запрещено выполнять перемещение из точки (x, y), если хотя бы одна из точек пути (кроме точки, в которую мы в конечном итоге придем k-ым перемещением) содержит бомбу.</li>
    <li>Формат операции — «2». Во время выполнения операции робот поднимает бомбу в точке (x, y) и кладет ее в специальный контейнер, расположенный в роботе. Таким образом робот может переносить бомбу из любой точки в любую другую точку. Операцию запрещено выполнять, если в точке (x, y) нет бомбы. Запрещено поднимать бомбу, если в контейнере у робота уже есть бомба.</li>
    <li>Формат операции — «3». Во время выполнения операции робот достает бомбу из контейнера и уничтожает ее. Разрешается выполнять эту операцию, только если робот находится в точке (0, 0). Запрещено выполнять операцию, если в контейнере нет бомбы.
    </li>
  </ol>
  <p>Помогите роботу, найдите последовательность операций минимальной длины, с помощью которой робот уничтожит все бомбы на координатной плоскости.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано единственное целое число n (1 ≤ n ≤ 10⁵) — количество бомб на координатной плоскости. В следующих n строках содержится по два целых числа. В i-ой строке содержатся числа xᵢ, yᵢ ( - 10⁹ ≤ xᵢ, yᵢ ≤ 10⁹) — координаты i-ой бомбы. Гарантируется, что никакие две бомбы не содержатся в одной точке и что никакая бомба не расположена в точке (0, 0).</p>

  <h4>Выходные данные</h4>
  <p>В первой строке выведите единственное число k — минимальное количество операций, необходимых для уничтожения всех бомб. В следующих строках выведите описания этих k операций в формате, указанном в условии. Если существует несколько последовательностей, разрешается вывести любую. Гарантируется, что существует решение, где k ≤ 10⁶.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
2
1 1
-1 -1
</pre>
<pre>
12
1 1 R
1 1 U
2
1 1 L
1 1 D
3
1 1 L
1 1 D
2
1 1 R
1 1 U
3
</pre>

    <h4>Пример 2</h4>
<pre>
3
5 0
0 5
1 0
</pre>
<pre>
12
1 1 R
2
1 1 L
3
1 5 R
2
1 5 L
3
1 5 U
2
1 5 D
3
</pre>
  </details>

  <details>
    <summary>Мое решение</summary>

    <div>
      <a href="https://codeforces.com/contest/350/problem/C" target="_blank">Задача 350C</a>
      <br><a href="https://codeforces.com/contest/350" target="_blank">Codeforces Round 203 (Div. 2) 2013-10-01</a>
    </div>

    <p>Разделим координатную плоскость на 4 четверти. Для каждой четверти заполним свой vector&lt;pair&lt;int, int&gt; &gt; A1,A2,A3,A4. Отсортируем вектора в каждой четверти. Робот сначала обойдет 1 четверть, потом 2,3,4.</p>
    <p>Пример для 1 четверти</p>
<pre>
3
0 5
5 0
5 5
</pre>
<pre>
14
1 5 U
2
1 5 D
3
1 5 R
2
1 5 L
3
1 5 R
1 5 U
2
1 5 D
1 5 L
3
</pre>
    <p>Пример для 2 четверти</p>
<pre>
2
-5 0
-5 5
</pre>
<pre>
10
1 5 L
2
1 5 R
3
1 5 L
1 5 U
2
1 5 D
1 5 R
3
</pre>
    <p>Пример для 3 четверти</p>
<pre>
2
-5 -5
-5 -10
</pre>
<pre>
12
1 5 L
1 5 D
2
1 5 U
1 5 R
3
1 5 L
1 10 D
2
1 10 U
1 5 R
3
</pre>
    <p>Пример для 4 четверти</p>
<pre>
2
0 -5
5 -5
</pre>
<pre>
10
1 5 D
2
1 5 U
3
1 5 R
1 5 D
2
1 5 U
1 5 L
3
</pre>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;

using namespace std;

// сортировка по y если x равны, иначе по x
bool compare(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b) {
  if (a.first == b.first) {
    return abs(a.second) &lt; abs(b.second);
  } else {
    return abs(a.first) &lt; abs(b.first);
  }
}

int main() {
  // ввод данных
  int n;
  cin >> n;

  // решение
  // создадим координаты по четвертям
  // 1 четверть x>=0, y>=0
  vector&lt;pair&lt;int, int&gt; &gt; A1;
  // 2 четверть x&lt;0, y>=0
  vector&lt;pair&lt;int, int&gt; &gt; A2;
  // 3 четверть x&lt;0, y&lt;0
  vector&lt;pair&lt;int, int&gt; &gt; A3;
  // 4 четверть x>=0, y&lt;0
  vector&lt;pair&lt;int, int&gt; &gt; A4;

  int x, y;
  pair&lt;int, int&gt; p;

  // соберем массивы
  for (int i = 0; i &lt; n; i++) {
    cin >> x;
    cin >> y;

    // соберем 1 четверть
    if (x >= 0 && y >= 0) {
      p.first = x;
      p.second = y;
      A1.push_back(p);
    }

    // соберем 2 четверть
    if (x &lt; 0 && y >= 0) {
      p.first = x;
      p.second = y;
      A2.push_back(p);
    }

    // соберем 3 четверть
    if (x &lt; 0 && y &lt; 0) {
      p.first = x;
      p.second = y;
      A3.push_back(p);
    }

    // соберем 4 четверть
    if (x >= 0 && y &lt; 0) {
      p.first = x;
      p.second = y;
      A4.push_back(p);
    }
  }

  sort(A1.begin(), A1.end(), compare);
  sort(A2.begin(), A2.end(), compare);
  sort(A3.begin(), A3.end(), compare);
  sort(A4.begin(), A4.end(), compare);

  // число операций
  vector&lt;string&gt; Res;
  int b1{}, b2{}, b3{}, b4{};
  string step1; // идти вправо или влево
  string step2; // идти вверх или вниз
  string step3 = "2"; // взять бомбу
  string step4; // идти обратно вниз или вверх
  string step5; // идти обратно влево или вправо
  string step6 = "3"; // уничтожить бомбу
  string dir;   // направление
  string s1 = "1 ";

  // робот идет в 1 четверть
  while (b1 &lt; A1.size()) {
    if (A1[b1].first == 0) {
      dir = " U";
      step2 = s1 + to_string(A1[b1].second) + dir;
      Res.push_back(step2);
      Res.push_back(step3);
      dir = " D";
      step4 = s1 + to_string(A1[b1].second) + dir;
      Res.push_back(step4);
      Res.push_back(step6);
    } else if (A1[b1].second == 0) {
      dir = " R";
      step1 = s1 + to_string(A1[b1].first) + dir;
      Res.push_back(step1);
      Res.push_back(step3);
      dir = " L";
      step5 = s1 + to_string(A1[b1].first) + dir;
      Res.push_back(step5);
      Res.push_back(step6);
    } else {
      dir = " R";
      step1 = s1 + to_string(A1[b1].first) + dir;
      Res.push_back(step1);
      dir = " U";
      step2 = s1 + to_string(A1[b1].second) + dir;
      Res.push_back(step2);
      Res.push_back(step3);
      dir = " D";
      step4 = s1 + to_string(A1[b1].second) + dir;
      Res.push_back(step4);
      dir = " L";
      step5 = s1 + to_string(A1[b1].first) + dir;
      Res.push_back(step5);
      Res.push_back(step6);
    }
    b1++;
  }

  // робот идет во 2 четверть
  while (b2 &lt; A2.size()) {
    if (A2[b2].second == 0) {
      dir = " L";
      step1 = s1 + to_string(abs(A2[b2].first)) + dir;
      Res.push_back(step1);
      Res.push_back(step3);
      dir = " R";
      step5 = s1 + to_string(abs(A2[b2].first)) + dir;
      Res.push_back(step5);
      Res.push_back(step6);
    } else {
      dir = " L";
      step1 = s1 + to_string(abs(A2[b2].first)) + dir;
      Res.push_back(step1);
      dir = " U";
      step2 = s1 + to_string(A2[b2].second) + dir;
      Res.push_back(step2);
      Res.push_back(step3);
      dir = " D";
      step4 = s1 + to_string(A2[b2].second) + dir;
      Res.push_back(step4);
      dir = " R";
      step5 = s1 + to_string(abs(A2[b2].first)) + dir;
      Res.push_back(step5);
      Res.push_back(step6);
    }
    b2++;
  }

  // робот идет в 3 четверть
  while (b3 &lt; A3.size()) {
    dir = " L";
    step1 = s1 + to_string(abs(A3[b3].first)) + dir;
    Res.push_back(step1);
    dir = " D";
    step2 = s1 + to_string(abs(A3[b3].second)) + dir;
    Res.push_back(step2);
    Res.push_back(step3);
    dir = " U";
    step4 = s1 + to_string(abs(A3[b3].second)) + dir;
    Res.push_back(step4);
    dir = " R";
    step5 = s1 + to_string(abs(A3[b3].first)) + dir;
    Res.push_back(step5);
    Res.push_back(step6);
    b3++;
  }

  // робот идет в 4 четверть
  while (b4 &lt; A4.size()) {
    if (A4[b4].first == 0) {
      dir = " D";
      step2 = s1 + to_string(abs(A4[b4].second)) + dir;
      Res.push_back(step2);
      Res.push_back(step3);
      dir = " U";
      step4 = s1 + to_string(abs(A4[b4].second)) + dir;
      Res.push_back(step4);
      Res.push_back(step6);
    } else {
      dir = " R";
      step1 = s1 + to_string(A4[b4].first) + dir;
      Res.push_back(step1);
      dir = " D";
      step2 = s1 + to_string(abs(A4[b4].second)) + dir;
      Res.push_back(step2);
      Res.push_back(step3);
      dir = " U";
      step4 = s1 + to_string(abs(A4[b4].second)) + dir;
      Res.push_back(step4);
      dir = " L";
      step5 = s1 + to_string(A4[b4].first) + dir;
      Res.push_back(step5);
      Res.push_back(step6);
    }
    b4++;
  }

  int steps = Res.size();

  // вывод результата
  cout &lt;&lt; steps &lt;&lt; '\n';
  for (int i = 0; i &lt; Res.size(); i++) {
    cout &lt;&lt; Res[i] &lt;&lt; '\n';
  }
}
</pre>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;

using namespace std;

struct Bomb {
  int x, y;
  int index;
};

bool compareBombs(const Bomb &a, const Bomb &b) {
  // Сортируем по расстоянию от начала координат (манхэттенское расстояние)
  return (abs(a.x) + abs(a.y)) &lt; (abs(b.x) + abs(b.y));
}

int main() {
  int n;
  cin >> n;
  vector&lt;Bomb&gt; bombs(n);
  for (int i = 0; i &lt; n; ++i) {
    cin >> bombs[i].x >> bombs[i].y;
    bombs[i].index = i;
  }

  // Сортируем бомбы по удаленности от (0, 0)
  sort(bombs.begin(), bombs.end(), compareBombs);

  vector&lt;string&gt; operations;

  for (const Bomb &bomb : bombs) {
    int x = bomb.x;
    int y = bomb.y;

    // Движение по X
    if (x > 0) {
      operations.push_back("1 " + to_string(x) + " R");
    } else if (x &lt; 0) {
      operations.push_back("1 " + to_string(-x) + " L");
    }

    // Движение по Y
    if (y > 0) {
      operations.push_back("1 " + to_string(y) + " U");
    } else if (y &lt; 0) {
      operations.push_back("1 " + to_string(-y) + " D");
    }

    // Подобрать бомбу
    operations.push_back("2");

    // Вернуться по Y
    if (y > 0) {
      operations.push_back("1 " + to_string(y) + " D");
    } else if (y &lt; 0) {
      operations.push_back("1 " + to_string(-y) + " U");
    }

    // Вернуться по X
    if (x > 0) {
      operations.push_back("1 " + to_string(x) + " L");
    } else if (x &lt; 0) {
        operations.push_back("1 " + to_string(-x) + " R");
    }

    // Уничтожить бомбу
    operations.push_back("3");
  }

  cout &lt;&lt; operations.size() &lt;&lt; endl;
  for (const string &op : operations) {
    cout &lt;&lt; op &lt;&lt; endl;
  }

}
</pre>
  </details>
</article>


<!-- Задача P. Пары чисел -->
<article class="article">
  <div class="anchor" id="task16"></div>
  <h3>Задача P. Пары чисел</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Допустим, мы имеем пару чисел (a, b). Мы можем получить новую пару чисел вида (a + b, b) или (a, a + b) из данной. Назовем такое действие шагом.</p>

  <p>Пусть начальная пара чисел — (1,1). Ваша задача — найти число k, наименьшее количество шагов, необходимых чтобы получить из (1,1) пару, в которой хотя бы одно число равно n.</p>

  <h4>Входные данные</h4>
  <p>Входные данные содержат единственное целое число n (1 ≤ n ≤ 10⁶).</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное число k.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>5</code>
    <code>3</code>

    <h4>Пример 2</h4>
    <code>1</code>
    <code>0</code>
    <p>Из пары (1,1) можно за три хода получить пару, содержащую 5: (1,1) → (1,2) → (3,2) → (5,2).</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/134/problem/B" target="_blank">Задача 134B</a>
      <br><a href="https://codeforces.com/contest/134" target="_blank">Codeforces Testing Round 3 2011-11-30</a>
    </div>

    <p>Нужно из пары (1,1) получить пару (x,n). Возможен переход (a,b) -> (a+b,b) и (a, a+b). При сложении мы должны выбрать из двух вариантов какие числа складывать.</p>
    <p>Попробуем решить обратную задачу, т.е. из пары (x,n) получим пару (1,1). Возможен переход (x,y) -> (x,y-x) и (x-y,y). При переходе у нас должно получиться натуральное число, т.е. целое число больше нуля. При вычитании у нас остается только один вариант, во втором результат будет меньше нуля.</p>
    <p>Перебираем все пары и смотрим за какое количество шагов мы из пары (x,n) придем к паре (1,1). Выберем минимальное количество шагов.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

long long cnt;

long long gcd(long long a, long long b) {
  if (b == 0) {
    if (a != 1) {
      cnt += 1'000'000;
    }
    cnt += a - 1;
    return a;
  } else {
    cnt += a / b;
    return gcd(b, a % b);
  }
}

int main() {
  // ввод данных
  long long n;
  cin >> n;

  // решение
  long long min_count = 10'000'000;
  for (long long i = 1; i &lt; n; i++) {
    cnt = 0;
    gcd(n, i);
    min_count = min(min_count, cnt);
  }
  if (min_count == 10'000'000) {
    cout &lt;&lt; 0;
    return 0;
  }

  // вывод результата
  cout &lt;&lt; min_count - 1;
}
</pre>
  </details>
</article>


<!-- Задача Q. Плотный массив -->
<article class="article">
  <div class="anchor" id="task17"></div>
  <h3>Задача Q. Плотный массив</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Поликарп называет массив плотным, если в любой паре двух соседних элементов больший элемент не более чем в два раза превышает меньший. Более формально, для любого i(1 ≤ i ≤ n-1) должно быть выполнено условие:</p>
  <code>(max(a[i], a[i+1]) / min(a[i], a[i+1])) ≤ 2 </code>

  <p>Например, массивы [1,2,3,4,3], [1,1,1] и [5,10] — плотные. А массивы [5,11], [1,4,2], [6,6,1] — нет.</p>

  <p>Вам дан массив a, состоящий из n целых чисел. Какое минимальное количество чисел необходимо добавить в массив, чтобы он стал плотным? Вставлять числа можно в любое место массива. Если массив уже является плотным, то числа добавлять не надо.</p>

  <p>Например, если a=[4,2,10,1], то ответ равен 5, а сам массив после вставки в него элементов может выглядеть так: a=[4,2,3,5,10,6,4,2,1] (есть и другие оптимальные способы построить плотный массив a).</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержится одно целое число t (1≤t≤1000). Далее следуют t наборов входных данных.</p>

  <p>В первой строке каждого набора входных данных находится одно целое число n (2≤n≤50) — длина массива a.</p>

  <p>Следующая строка содержит n целых чисел a₁, a₂, ... , aₙ (1 ≤ aᵢ ≤ 50).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно целое число — минимальное количество чисел, которое необходимо добавить в массив, чтобы он стал плотным.</p>

  <details>
    <summary>Пример</summary>
<pre>
6
4
4 2 10 1
2
1 3
2
6 1
3
1 4 2
5
1 2 3 4 3
12
4 31 25 50 30 20 34 46 42 16 15 16
</pre>
<pre>
5
1
2
1
0
3
</pre>
    <p>Первый набор входных данных разобран в условии.</p>
    <p>Во втором наборе входных данных можно вставить один элемент, a=[1,2,3].</p>
    <p>В третьем наборе входных данных можно вставить два элемента, a=[6,4,2,1].</p>
    <p>В четвертом наборе входных данных можно вставить один элемент, a=[1,2,4,2].</p>
    <p>В пятом наборе входных данных массив a уже плотный.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1490/problem/A" target="_blank">Задача 1490A</a>
      <br><a href="https://codeforces.com/contest/1490" target="_blank">Codeforces Round 702 (Div. 3) 2021-02-16</a>
    </div>

    <p>Считаем разницу между двумя соседними элементами. Если больше 2, то если первый элемент меньше второго, то умножаем его на 2 и прибавляем к счетчику 1. Если первый элемент больше второго и делится на 2 без остатка, то делим его на два, иначе делим его на два и прибавляем 1.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n;
    cin >> n;
    vector&lt;int&gt; A(n);
    for (int i = 0; i &lt; n; i++) {
      cin >> A[i];
    }

    // решение
    int count = 0;
    int prev = A[0];
    double ref;
    for (int i = 1; i &lt; n; i++) {
      ref = (double)max(prev, A[i]) / min(prev, A[i]);
      while (ref > 2) {
        if (prev &lt; A[i]) {
          prev *= 2;
        } else {
          prev = prev % 2 ? prev / 2 + 1 : prev / 2;
        }
        ref = (double)max(prev, A[i]) / min(prev, A[i]);
        count++;
      }
      prev = A[i];
    }

    // вывод результата
    cout &lt;&lt; count &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача R. Не соседняя матрица -->
<article class="article">
  <div class="anchor" id="task18"></div>
  <h3>Задача R. Не соседняя матрица</h3>

  <div><i>Ограничение по времени 4с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Будем считать числа a и b соседними, если они отличаются ровно на единицу, то есть |a-b|=1.</p>

  <p>Будем считать клетки квадратной матрицы n x n соседними, если они имеют общую сторону, то есть для клетки (r,c) соседними являются клетки (r,c-1), (r,c+1), (r-1,c) и (r+1,c).</p>

  <p>Для заданного числа n постройте квадратную матрицу n x n, такую что:</p>
  <ul>
    <li>Каждое число от 1 до n² встречается в этой матрице ровно один раз;</li>
    <li>Если (r₁, c₁) и (r₂, c₂) соседние клетки, тогда числа записанные в них не должны быть соседними.</li>
  </ul>

  <h4>Входные данные</h4>
  <p>В первой строке содержится одно целое число t (1≤t≤100). Далее следуют t наборов входных данных.</p>
  <p>Каждый набор входных данных характеризуется одним целым числом n (1≤n≤100).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите:</p>
  <ul>
    <li>-1, если искомой матрицы не существует;</li>
    <li>искомую матрицу, иначе (любую подходящую, если таких существует много).</li>
  </ul>
  <p>Матрицу следуют выводить в виде n строк, где каждая строка содержит n целых чисел.</p>

  <details>
    <summary>Пример</summary>
<pre>
3
1
2
3
</pre>
<pre>
1
-1
2 9 7
4 6 3
1 8 5
</pre>

    <p>Требуется заполнить квадратную матрицу n x n так, чтобы соседние элементы не были соседними числами. Представим матрицу в виде шахматной доски, где белые поля чередуются с черными. У каждой белой клетки все соседи черные и у каждой черной клетки все соседи белые.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1520/problem/C" target="_blank">Задача 1520C</a>
      <br><a href="https://codeforces.com/contest/1520" target="_blank">Codeforces Round 719 (Div. 3) 2021-05-05</a>
    </div>

    <p>В этом решении начинаем с первой клетки [0], она четная, идем через клетку до последней. В четные клетки кладем числа начиная с 1 и увеличивая их, в нечетные начиная с n и уменьшая их. Когда все заполним то последние два числа n и n-1 окажутся соседними. Чтобы исправить это меняем местами первое и последнее число</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n;
    cin >> n;

    // решение
    if (n == 2) {
      cout &lt;&lt; -1 &lt;&lt; '\n';

    } else if (n == 1) {
      cout &lt;&lt; 1 &lt;&lt; '\n';

    } else {
      int a = 1, b = n * n, cnt = 0;
      vector&lt;vector&lt;int&gt; &gt; res(n);
      for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; n; j++) {
          if (cnt % 2 == 0) {
            res[i].push_back(a);
            a++;
          } else {
            res[i].push_back(b);
            b--;
          }
          cnt++;
        }
      }
      int tmp = res[0][0];
      res[0][0] = res[n - 1][n - 2];
      res[n - 1][n - 2] = tmp;

      // вывод результата
      for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; n; j++) {
          cout &lt;&lt; res[i][j] &lt;&lt; " ";
        }
        cout &lt;&lt; '\n';
      }
    }
  }
}
</pre>
  </details>

  <details>
    <summary>Мое решение</summary>
    <p>В этом решении начинаем с первой клетки [0], она четная, идем через клетку до последней. В четные клетки кладем числа начиная с 1 и увеличивая их, в нечетные начиная с середины и увеличивая их. Определяем середину. Для четного и нечетного n она будет разная.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n;
    cin >> n;

    // решение
    if (n == 2) {
      cout &lt;&lt; -1 &lt;&lt; '\n';

    } else if (n == 1) {
      cout &lt;&lt; 1 &lt;&lt; '\n';

    } else {
      int a = 1, b, cnt = 0;
      if (n % 2 == 0) {
        b = n * n / 2 + 1;
      } else {
        b = n * n / 2 + 2;
      }
      vector&lt;vector&lt;int&gt; &gt; res(n);
      for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; n; j++) {
          if (cnt % 2 == 0) {
            res[i].push_back(a);
            a++;
          } else {
            res[i].push_back(b);
            b++;
          }
          cnt++;
        }
      }

      // вывод результата
      for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; n; j++) {
           cout &lt;&lt; res[i][j] &lt;&lt; " ";
        }
        cout &lt;&lt; '\n';
      }
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача S. Золотая лихорадка -->
<article class="article">
  <div class="anchor" id="task19"></div>
  <h3>Задача S. Золотая лихорадка</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Изначально у вас есть одна куча золотых самородков, содержащая n самородков. За одну операцию вы можете сделать следующее:</p>
  <ul>
    <li>Разделить любую кучу на две кучи так, чтобы одна из полученных куч содержала в два раза больше золотых самородков, чем другая. (Все кучи должны содержать целое число самородков.)</li>
  </ul>

  <p>Одно из возможных действий - взять кучу размера 6 и разделить ее на кучи размеров 2 и 4, что является допустимым, так как 4 в два раза больше, чем 2.</p>

  <p>Можете ли вы сделать кучу с ровно m золотых самородков, используя ноль или более операций?</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит целое число t (1 ≤ t ≤ 1000) — количество наборов входных данных в тесте.</p>
  <p>Единственная строка каждого набора содержит два целых числа n и m (1 ≤ n, m ≤ 10⁷) — начальный и целевой размер кучи соответственно.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого теста выведите «YES», если вы можете создать кучу размером ровно m, и «NO» в противном случае.</p>

  <p>Вы можете выводить ответ в любом регистре (например, строки «yEs», «yes», «Yes» и «YES» будут распознаны как положительный ответ).</p>

  <details>
    <summary>Пример</summary>
<pre>
11
6 4
9 4
4 2
18 27
27 4
27 2
27 10
1 1
3 1
5 1
746001 2984004
</pre>
<pre>
YES
YES
NO
NO
YES
YES
NO
YES
YES
NO
NO
</pre>
  <p>Первый тест изображен в условии. Мы можем создать кучу размером 4.</p>
  <p>Во втором тесте мы можем выполнить следующие операции: {9}→{6,3}→{4,2,3}. Куча, которая разделяется, выделена красным цветом перед каждой операцией.</p>
  <p>В третьем тесте мы не можем выполнить ни одной операции.</p>
  <p>В четвертом тесте мы не можем получить кучу большего размера, чем у нас изначально.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1829/problem/D" target="_blank">Задача 1829D</a>
      <br><a href="https://codeforces.com/contest/1829" target="_blank">Codeforces Round 871 (Div. 4) 2023-05-06</a>
    </div>

    <p>Напишем рекурсивную функцию three(n, m). Если n == m то возвращаем true. Если m > n или n не делится на 3 то возвращаем false. Вызываем саму себя для (1/3)n и (2/3)n.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

bool three(int n, int m) {
  if (n == m) {
    return true;
  }
  int a, b;
  if (n % 3 || m > n) {
    return false;
  } else {
    a = n / 3;
    b = n / 3 * 2;
    return (three(a, m) || three(b, m));
  }
}

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n, m;
    cin >> n >> m;

    // решение
    bool gold = three(n, m);

    // вывод результата
    if (gold) {
      cout &lt;&lt; "YES" &lt;&lt; '\n';
    } else {
      cout &lt;&lt; "NO" &lt;&lt; '\n';
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача T. Mex подмножеств -->
<article class="article">
  <div class="anchor" id="task20"></div>
  <h3>Задача T. Mex подмножеств</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 512мб</i></div>

  <p>Вам дан набор целых чисел (он может содержать одинаковые элементы).</p>

  <p>Вы должны разделить его на два подмножества A и B (каждое из них также может содержать одинаковые элементы или может быть пустым). Вы должны максимизировать значение mex(A)+mex(B).</p>

  <p>Здесь mex набора целых чисел определяется как наименьшее неотрицательное целое число, которое не принадлежит этому набору. Например:</p>
  <ul>
    <li>mex({1,4,0,2,2,1})=3</li>
    <li>mex({3,3,2,1,3,0,0})=4</li>
    <li>mex(∅)=0 (mex пустого множества)</li>
  </ul>
  <p>Набор разделен на два подмножества A и B, если для любого целого числа x количество вхождений x в этот набор равно сумме количеств вхождений x в A и x в B.</p>

  <h4>Входные данные</h4>
  <p>Каждый тест состоит из нескольких наборов входных данных. В первой строке находится единственное целое число t (1 ≤ t ≤ 100) — количество наборов входных данных. Описание наборов входных данных следует.</p>

  <p>В первой строке описания каждого набора входных данных находится единственное целое число n (1 ≤ n ≤ 100) — размер набора целых чисел.</p>

  <p>Во второй строке описания каждого набора входных данных находится n целых чисел a₁, a₂, ... , aₙ (0 ≤ aᵢ ≤ 100) — элементы данного вам набора целых чисел.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных, выведите максимальное значение mex(A) + mex(B).</p>

  <details>
    <summary>Пример</summary>
<pre>
4
6
0 2 1 5 0 1
3
0 1 2
4
0 2 0 1
6
1 2 3 4 5 6
</pre>
<pre>
5
3
4
0
</pre>
    <p>В первом наборе входных данных A={0,1,2},B={0,1,5} является возможным выбором разделения.</p>
    <p>Во втором наборе входных данных A={0,1,2},B=∅ является возможным выбором разделения.</p>
    <p>В третьем наборе входных данных A={0,1,2},B={0} является возможным выбором разделения.</p>
    <p>В четвертом наборе входных данных A={1,3,5},B={2,4,6} является возможным выбором разделения.</p>
  </details>

  <details>
    <summary>Мое решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1406/problem/A" target="_blank">Задача 1406A</a>
      <br><a href="https://codeforces.com/contest/1406" target="_blank">Codeforces Round 670 (Div. 2) 2020-09-12</a>
    </div>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n;
    cin >> n;
    vector&lt;int&gt; A(n);
    for (int i = 0; i &lt; n; i++) {
      cin >> A[i];
    }

    // решение
    sort(A.begin(), A.end());
    int mexA = -1, mexB = -1;
    int a = 0;

    // разделяем на 2 подмножества
    for (int i = 0; (i &lt; n) && ((mexA &lt; 0) || (mexB &lt; 0)); i++) {
      if (A[i] &lt; a) {
        continue;
      }
      if ( (A[i] == a) && ( (i + 1 &lt; n) && (A[i + 1] == a) ) ) {
        a++;
        i++;
        continue;
      } else if (A[i] == a && mexA >= 0) {
        a++;
        continue;
      } else if (A[i] == a && mexA &lt; 0) {
        mexA = a;
        a++;
      } else {
        if (mexA &lt; 0) {
          mexA = a;
          mexB = a;
        } else {
          mexB = a;
        }
      }
    }
    if (mexA == -1) {
      mexA = A[n-1] + 1;
    }
    if (mexB == -1) {
      mexB = A[n-1] + 1;
    }

    sort(A.begin(), A.end());
    int mex = -1;
    a = 0;
    // считаем на одном подмножестве, второе = 0
    for (int i = 0; (i &lt; n) && (mex &lt; 0); i++) {
      if (A[i] &lt; a) {
        continue;
      }
      if (A[i] == a) {
        a++;
        continue;
      } else {
        mex = a;
      }
    }
    if (mex == -1) {
      mex = A[n-1] + 1;
    }

    mex = max(mex, mexA + mexB);

    // вывод результата
    cout &lt;&lt; mex &lt;&lt; '\n';
  }
}
</pre>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int computeMex(const vector&lt;int&gt;& v) {
  int mex = 0;
  for (int num : v) {
    if (num == mex) mex++;
  }
  return mex;
}

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n;
    cin >> n;
    vector&lt;int&gt; A(n);
    for (int i = 0; i &lt; n; i++) {
      cin >> A[i];
    }

    // решение
    sort(A.begin(), A.end());

    // Самый простой способ максимизировать mex(A) + mex(B) -
    // это взять все элементы в одном множестве (mex будет максимальным),
    // а второе множество оставить пустым (mex = 0)
    int mex_all = computeMex(A);
    int max_mex_sum = mex_all + 0;

    // Также можно попробовать разделить элементы так,
    // чтобы оба mex были как можно больше
    // Например, разделить элементы на те, что меньше некоторого x и остальные
    for (int x = 0; x &lt;= mex_all; x++) {
      vector&lt;int&gt; part1, part2;
      for (int num : A) {
        if (num &lt; x) part1.push_back(num);
        else part2.push_back(num);
      }
      int mex1 = computeMex(part1);
      int mex2 = computeMex(part2);
      max_mex_sum = max(max_mex_sum, mex1 + mex2);
    }

    // вывод результата
    cout &lt;&lt; max_mex_sum &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>

