<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contests" target="_blank">ЯрГУ. Кружок. Школьники</a></p>
  <p><a href="https://vkvideo.ru/@sportprog_yarsu" target="_blank">vkvideo.ru/@sportprog_yarsu</a></p>
</article>


<article class="article">
  <h1>Занятие 26 ДП #4. Обработка событий</h1>
  <p>Конспект видео от 2025.03.29</p>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contest/599925" target="_blank">Codeforces Контест 599925</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
        <a href="#p1">ДП #4. Обработка событий</a>
    <br><a href="#t1">Задача 1. Покраска бордюра</a>
    <br><a href="#t2">Задача 2. Реклама в магазине</a>
    <br><a href="#t3">Задача 3. Построение минимальной цепи</a>
  </p>
  <p>
        <a href="#task1">Задача A. Массивные запросы</a>
    <br><a href="#task2">Задача B. Закраска прямой</a>
    <br><a href="#task3">Задача C. Носки</a>
    <br><a href="#task4">Задача D. Большой отрезок</a>
    <br><a href="#task5">Задача E. Кассы</a>
    <br><a href="#task6">Задача F. Межрегиональная олимпиада - 50</a>
    <br><a href="#task7">Задача G. Минимальное покрытие</a>
    <br><a href="#task8">Задача H. Точки и отрезки</a>
    <br><a href="#task9">Задача I. Древние цивилизации</a>
    <br><a href="#task10">Задача J. Родительская работа</a>
    <br><a href="#task11">Задача K. Два телевизора</a>
    <br><a href="#task12">Задача L. Межрегиональная олимпиада</a>
    <br><a href="#task13">Задача M. Вишневый вопрос</a>
    <br><a href="#task14">Задача N. Сон</a>
  </p>
</article>


<!-- ДП #4. Обработка событий -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>ДП #4. Обработка событий</h3>

  <p>Обработка событий это отрезки и интервалы на прямой и работа с ними. Например, отрезки времени во время которых происходит событие. На прямой времени расположены событие. У каждого события есть начало и конец. События могут пересекаться, а могут не пересекаться.</p>
  <p>Решение задач на обработку собитий состоит из 3 этапов:</p>
  <ol>
    <li>Придумать способ хранения события. Чаще это vector&lt;pair&lt;int, int&gt; &gt;, в котором храним начало и конец события.</li>
    <li>Сортировка событий. Чаще это sort().</li>
    <li>Линейный пробег по всем событиям. Чаще это цикл for.</li>
  </ol>

  <p>Как обрабатывать ситуацию, когда конец одного события совпадает с началом второго события? Нет единственного способа обратотки такой ситуации. Нужно внимательно читать задачу, чтобы определить нужную ситуацию. Если первое событие заканчивается в точке i, а второе событие начинаетя в точке i+1, то эти события не пересекаются. Если первое событие заканчивается в точке i+1, а второе начинается в точке i, то эти события пересекаются. Мы вводим переменную mark, которая обозначает начало события, если mark = -1, или конец события если mark = 1;</p>

  <h4>Цикличные события</h4>
  <p>В сутках 24 часа их можно представить в виде окружности. События происходят ежедневно, в одно и то же время. Могут пересекаться, могут начинаться в одни сутки, а заканчиваться уже в другие.</p>
  <p>Мы уже умеем работать с событиями на прямой и еще не умеем работать с событиями на окружности. Нужно преобразовать события на окружности в события на прямой.</p>
  <p>Поставим на окружности точку разрыва. Например в полночь. Все события которые начинаются до полуночи, а оканчиваются после полуночи разбиваем на 2 события. Первое начинается до полуночи и заканчивается в полночь. Второе начинается в полночь и заканчивается после полуночи. Если изначально было n событий, то после разрыва их может стать не более чем 2n. Если в худшем случае все события делились на 2, то их стало в 2 раза больше.</p>
</article>


<!-- Задача 1. Покраска бордюра -->
<article class="article">
  <div class="anchor" id="t1"></div>
  <h3>Задача 1. Покраска бордюра</h3>

  <p>Есть длинный бордюр, который надо покрасить и краска. Мы покрасили белой краской n отрезков бордюра. Каждый i-ый отрезок имеет начало в li а конец в ri. Сколько метров бордюра мы покрасили? Если бы не было пересечений, то можно просто посчитать длины всех закрашенных отрезков.</p>

  <h4>Пример</h4>
<pre>
5
1 3
3 5
2 4
7 8
7 10
</pre>
  <code>7</code>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;


int main() {
  // ускорение ввода
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  // ввод данных
  int n;
  cin >> n;
  vector&lt;pair&lt;int, int&gt; &gt; A;
  int time, mark;
  pair&lt;int, int&gt; tmp;

  // заполняем вектор событий
  for (int i = 0; i &lt; n; i++) {
    cin >> time; // начало события
    mark = -1;
    tmp.first = time;
    tmp.second = mark;
    A.push_back(tmp);
    cin >> time; // конец события
    mark = 1;
    tmp.first = time;
    tmp.second = mark;
    A.push_back(tmp);
  }

  // решение
  // сортируем вектор событий O(nlogn)
  sort(A.begin(), A.end());

  int res = 0;
  int count = 0;
  int time_last = 0;
  int time_cur = 0;

  // линейный проход по отрезкам O(n)
  for (int i = 0; i &lt; A.size(); i++) {
    time_last = time_cur;
    time_cur = A[i].first;
    if (count != 0) {
      res += time_cur - time_last;
    }
    if (A[i].second == -1) {
      count++;
    } else {
      count--;
    }
  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача 2. Реклама в магазине -->
<article class="article">
  <div class="anchor" id="t2"></div>
  <h3>Задача 2. Реклама в магазине</h3>

  <p>За день в магазине бывает n покупателей. Про каждого покупателя известрно время его прихода time_in и ухода time_out. Сотрудники хотят включить рекламу, которая длится ровно T минут и хотят, чтобы ее прослушало как можно больше покупателей. В какой момент нужно включить рекламу в магазине?</p>

  <h4>Решение</h4>
  <p>Представим время каждого человека в магазине виде отрезка [time_in, time_out]. Человек, который был в магазине меньше времени чем время рекламы T, не прослушает всю рекламу и поэтому в ответе учитываться не будет. Можно переписать время людей, которые гарантированно прослушали рекламу как [time_in, time_out - T]. Теперь реклама это не отрезок, а точка на прямой времени. Мы можем подсчитать сколько людей было в магазине (вошло и еще не вышло) в любой момент времени. Найдем точку с максимальным числом людей и в этот момент включим рекламу.</p>
</article>


<!-- Задача 3. Построение минимальной цепи -->
<article class="article">
  <div class="anchor" id="t3"></div>
  <h3>Задача 3. Построение минимальной цепи</h3>

  <p>Пусть есть n событий, для которых известны начало и конец. Есть промежуток времени от 0 до T, который нужно полностью покрыть этими событиями, используя минимальное количество событий.</p>

  <h4>Решение</h4>
  <p>Сначала найдем событие, которое начинается до 0, а заканчивается после 0 максимально поздно. Потом найдем второе событие, которое начинается до окончания первого события, а заканчивается после окончания первого события максимально поздно. И так далее. Этот алгоритм работает за O(n²). Если сначала отсортировать события, то можно его ускорить.</p>
  <p>Все события будем собирать в структуру данных pair&lt;pair&lt;int, int&gt; &gt; где внутренняя пара это время начала и конца события, а третья переменная это индекс события до сортировки. Отсортируем события за O(nlogn). Линейно пройдем по ним за O(n).</p>

</article>


<!-- Задача A. Массивные запросы -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Массивные запросы</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Есть массив размера n, изначально заполненный нулями.</p>

  <p>Есть m запросов, каждый из которых содержит 3 параметра: l, r, c.</p>

  <p>После поступления запроса каждый элемент отрезка массива от l до r увеличивается на c.</p>

  <p>Выведите получившийся в конце массив</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных находится 2 целых числа n и m (1 ≤ n, m ≤ 2⋅10⁵) — размер массива и число запросов.</p>

  <p>В следующих m строках вводится по 3 числа: l, r, c (1 ≤ l ≤ r ≤ n,  -1000 ≤ c ≤ 1000) — запросы описанные в задаче.</p>

  <h4>Выходные данные</h4>
  <p>Выведите n чисел через пробел — получившийся после всех запросов массив.</p>

  <h4>Пример 1</h4>
<pre>
1 4
1 1 765
1 1 -43
1 1 -69
1 1 672
</pre>
  <code>1325</code>

  <h4>Пример 2</h4>
<pre>
5 3
1 4 -23
4 5 397
1 5 774
</pre>
  <code>751 751 751 1148 1171 </code>
</article>


<!-- Задача B. Закраска прямой -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Закраска прямой</h3>

  <div><i>Ограничение по времени 0.5с
  <br>Ограничение по памяти 256мб</i></div>

  <p>На числовой прямой окрасили N отрезков. Известны координаты левого и правого концов каждого отрезка (Lᵢ и Rᵢ). Найти длину окрашенной части числовой прямой.</p>

  <h4>Входные данные</h4>
  <p>Вход в первой строке содержит число N, в следующих N строках — пары Lᵢ и Rᵢ. Ограничения: все числа целые, не превышающие 10⁹ по абсолютной величине, 1≤N≤15000.</p>

  <h4>Выходные данные</h4>
  <p>Выведите длину окрашенной части прямой.</p>

  <h4>Пример 1</h4>
<pre>
2
1 3
2 4
</pre>
  <code>3</code>

  <h4>Пример 2</h4>
<pre>
1
10 10
</pre>
  <code>0</code>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ускорение ввода
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  // ввод данных
  int n;
  cin >> n;
  vector&lt;pair&lt;long long, long long&gt; &gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i].first >> A[i].second;
  }
  sort(A.begin(), A.end());
  int begin = A[0].first;
  int end = A[0].second;
  long long sum = 0;

  for (int i = 1; i &lt; n; i++) {
    if (A[i].first &lt;= end) {
      if (A[i].second > end) {
        end = A[i].second;
      }
    } else {
      sum += end - begin;
      begin = A[i].first;
      end = A[i].second;
    }
  }

  sum += end - begin;

  // вывод результата
  cout &lt;&lt; sum;
}
</pre>
  </details>
</article>


<!-- Задача C. Носки -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Носки</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Имеется стол длины L. На столе разложено N носков так, что никакой носок не вылезает за границы стола. Далее имеется умный мальчик Васька, который хочет (сугубо в корыстных целях) замерить толщину покрытия стола носками в M точках.</p>

  <h4>Входные данные</h4>
  <p>Во входном файле даны сначала L, N, M (1≤L≤10000, 1≤N≤10000, 1≤M≤100000).</p>

  <p>Далее идут N пар чисел l≤r от 1 до L — левые и правые концы носков.</p>

  <p>Затем идут M чисел от 1 до L интересующие Васька точки.</p>

  <p>Все числа целые.</p>

  <h4>Выходные данные</h4>
  <p>Выведите M чисел — толщину носкового покрытия в каждой точке.</p>

  <h4>Пример</h4>
<pre>
39 4 7
3 21
3 15
2 20
3 17
4
17
33
5
9
25
37
</pre>
<pre>
4
3
0
4
4
0
0
</pre>
</article>


<!-- Задача D. Большой отрезок -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Большой отрезок</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>На координатной прямой задано n отрезков, i-ый отрезок начинается в позиции lᵢ и заканчивается в позиции rᵢ. Будем обозначать такой отрезок через [lᵢ, rᵢ].</p>

  <p>Вы предположили, что один из заданных отрезков покрывает все остальные. Другими словами, существует такой отрезок из заданного набора, в котором содержатся все остальные. Теперь вы хотите убедиться в своем предположении. Найдите отрезок из набора, который покрывает все остальные заданные отрезки, и выведите его номер. Если такого отрезка не существует, выведите -1.</p>

  <p>Формально будем считать, что отрезок [a, b] покрывает отрезок [c, d], если выполняется условие a ≤ c ≤ d ≤ b.</p>

  <h4>Входные данные</h4>
  <p>В первой строке задано целое число n (1 ≤ n ≤ 10⁵) — количество отрезков. В следующих n строках содержатся описания отрезков. В i-ой строке через пробел заданы два целых числа lᵢ, rᵢ (1 ≤ lᵢ ≤ rᵢ ≤ 10⁹) — границы i-ого отрезка.</p>

  <p>Гарантируется, что никакие два отрезка не совпадают.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное целое число — номер отрезка, который покрывает все остальные отрезки набора. Если решения не существует, выведите -1.</p>

  <p>Отрезки нумеруются с 1 в порядке их появления во входных данных.</p>

  <h4>Пример 1</h4>
<pre>
3
1 1
2 2
3 3
</pre>
  <code>-1</code>

  <h4>Пример 2</h4>
<pre>
6
1 5
2 3
1 10
7 10
7 7
10 10
</pre>
  <code>3</code>
</article>


<!-- Задача E. Кассы -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Кассы</h3>

  <div><i>Ограничение по времени 0.5с
  <br>Ограничение по памяти 64мб</i></div>

  <p>На одном из московских вокзалов билеты продают N
  касс. Каждая касса работает без перерыва определенный промежуток времени по фиксированному расписанию (одному и тому же каждый день). Требуется определить, на протяжении какого времени в течение суток работают все кассы одновременно.</p>

  <h4>Входные данные</h4>
  <p>Сначала вводится одно целое число N (0 &lt; N ≤ 10000).</p>

  <p>В каждой из следующих N строк через пробел расположены 6 целых чисел, первые три из которых обозначают время открытия кассы в часах, минутах и секундах (часы — целое число от 0 до 23, минуты и секунды — целые числа от 0 до 59), оставшиеся три — время закрытия в том же формате. Числа разделены пробелами.</p>

  <p>Время открытия означает, что в соответствующую ему секунду касса уже работает, а время закрытия — что в соответствующую секунду касса уже не работает. Например, касса, открытая с 10 ч 30 мин 30 с до 10 ч 35 мин 30 с, ежесуточно работает 300 секунд.</p>

  <p>Если время открытия совпадает с временем закрытия, то касса работает круглосуточно. Если первое время больше второго, то касса начинает работу до полуночи, а заканчивает — на следующий день.</p>

  <h4>Выходные данные</h4>
  <p>Требуется вывести одно число — суммарное время за сутки (в секундах), на протяжении которого работают все N касс.</p>

  <h4>Пример 1</h4>
<pre>
3
1 0 0 23 0 0
12 0 0 12 0 0
22 0 0 2 0 0
</pre>
  <code>7200</code>

  <h4>Пример 2</h4>
<pre>
2
9 30 0 14 0 0
14 15 0 21 0 0
</pre>
  <code>0</code>
</article>


<!-- Задача F. Межрегиональная олимпиада - 50 -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Межрегиональная олимпиада - 50</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>ВНИМАНИЕ в данной задаче все ci одинаковы.</p>

  <p>На межрегиональной олимпиаде по программированию роботов соревнования проводятся в один тур и в необычном формате. Задачи участникам раздаются последовательно, а не все в самом начале тура, и каждая i-я задача (1 ≤ i ≤ n) становится доступной участникам в свой момент времени sᵢ. При поступлении очередной задачи каждый участник должен сразу определить, будет он ее решать или нет. В случае, если он выбирает для решения эту задачу, то у него есть tᵢ минут на то, чтобы сдать ее решение на проверку, причем в течение этого времени он не может переключиться на решение другой задачи. Если же участник отказывается от решения этой задачи, то в будущем он не может к ней вернуться. В тот момент, когда закончилось время, отведенное на задачу, которую решает участник, он может начать решать другую задачу, ставшую доступной в этот же момент, если такая задача есть, или ждать появления другой задачи. При этом за правильное решение i-й задачи участник получает cᵢ баллов (напоминаем, что в данной задаче все cᵢ одинаковы).</p>

  <p>Артур, представляющий на межрегиональной олимпиаде один из региональных центров искусственного интеллекта, понимает, что важную роль на такой олимпиаде играет не только умение решать задачи, но и правильный стратегический расчет того, какие задачи надо решать, а какие пропустить. Ему, как и всем участникам, до начала тура известно, в какой момент времени каждая задача станет доступной, сколько времени будет отведено на ее решение и сколько баллов можно получить за ее решение. Артур является талантливым школьником и поэтому сможет успешно решить за отведенное время и сдать на проверку любую задачу, которую он выберет для решения на олимпиаде.</p>

  <p>Требуется написать программу, которая определяет, какое максимальное количество баллов Артур сможет получить при оптимальном выборе задач, которые он будет решать, а также количество и перечень таких задач.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входного файла содержит одно целое число n (1 ≤ n ≤ 10⁵) количество задач на олимпиаде.</p>

  <p>Последующие n строк содержат описания задач, по три числа на каждой строке: sᵢ момент появления i-й задачи в минутах, tᵢ время, отведенное на ее решение в минутах, и ci сколько баллов получит участник за решение этой задачи (1 ≤ sᵢ, tᵢ, cᵢ ≤ 10⁹).</p>

  <h4>Выходные данные</h4>
  <p>Первая строка выходного файл должна содержать одно число – максимальное количество баллов, которое сможет получить Артур на олимпиаде.</p>

  <p>Вторая строка должна содержать одно целое число m - количество задач, которые надо решить при оптимальном выборе.</p>

  <p>Третья строка должна содержать m разделенных пробелом целых чисел — номера этих задач в порядке их решения. Задачи пронумерованы, начиная с единицы, в порядке их описания во входном файле.</p>

  <p>Если оптимальных ответов несколько, необходимо вывести любой из них.</p>

  <h4>Пример</h4>
<pre>
5
1 2 6
2 3 6
1 2 6
3 1 6
3 2 6
</pre>
<pre>
12
2
1 4
</pre>
</article>


<!-- Задача G. Минимальное покрытие -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Минимальное покрытие</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>На прямой задано некоторое множество отрезков с целочисленными координатами концов [Lᵢ, Rᵢ]. Выберите среди данного множества подмножество отрезков, целиком покрывающее отрезок [0, M], (M — натуральное число), содержащее наименьшее число отрезков.</p>

  <h4>Входные данные</h4>
  <p>В первой строке указана константа M (1 ≤ M ≤ 5000). В каждой последующей строке записана пара чисел Lᵢ и Rᵢ (|Lᵢ|, |Rᵢ| ≤ 50000), задающая координаты левого и правого концов отрезков. Список завершается парой нулей. Общее число отрезков не превышает 100000.</p>

  <h4>Выходные данные</h4>
  <p>В первой строке выходного файла выведите минимальное число отрезков, необходимое для покрытия отрезка [0;M]. Далее выведите список покрывающего подмножества, упорядоченный по возрастанию координат левых концов отрезков. Список отрезков выводится в том же формате, что и во входe. Завершающие два нуля выводить не нужно. Если покрытие отрезка [0,M] исходным множеством отрезков [Lᵢ,Rᵢ] невозможно, то следует вывести единственную фразу "No solution".</p>

  <h4>Пример 1</h4>
<pre>
1
-1 0
-5 -3
2 5
0 0
</pre>
<pre>
No solution
</pre>

  <h4>Пример 2</h4>
<pre>
1
-1 0
0 1
0 0
</pre>
<pre>
1
0 1
</pre>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;


int main() {
  // ускорение ввода
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  // ввод данных
  int M;
  cin >> M;
  vector&lt;pair&lt;int, int&gt; &gt; A;
  int time_in = 1, time_out = 1;
  pair&lt;int, int&gt; tmp;

  while (!(time_in == 0 && time_out == 0)) {
    cin >> time_in >> time_out;
    if (!(time_in == 0 && time_out == 0)) {
      tmp.first = time_in;
      tmp.second = time_out;
      A.push_back(tmp);
    }
  }

  sort(A.begin(), A.end());
  int q = -1; // индекс лучшего элемента
  int time_best_out = 0;

  for (int i = 0; i &lt; A.size(); i++) {
    if (A[i].first &lt;= 0 && A[i].second > time_best_out) {
      time_best_out = A[i].second;
      q = i;
    }
  }

  if (q == -1) {
    cout &lt;&lt; "No solution";
    return 0;
  }

  vector&lt;pair&lt;int, int&gt; &gt; result;
  int buf = q;
  int id = q;
  for (int i = q + 1; i &lt; A.size(); i++) {
    // если появляется пустота
    if (A[i].first > A[id].second) {
      if (A[i].first &lt;= A[buf].second || M &lt;= A[buf].second) {
        result.push_back(A[id]);
        id = buf;
      } else {
        cout &lt;&lt; "No solution";
        return 0;
      }
    }
    if (A[i].second > A[buf].second) {
      buf = i;
    }
  }
  result.push_back(A[id]);
  if (A[buf].second > A[id].second) {
    result.push_back(A[buf]);
  }

  vector&lt;pair&lt;int, int&gt; &gt; full_res;
  bool flag = true;
  for (int i = 0; i &lt; result.size() && flag; i++) {
    full_res.push_back(result[i]);
    if (result[i].second >= M) {
      flag = false;
    }
  }
  if (flag == true) {
    cout &lt;&lt; "No solution";
    return 0;
  }

  // вывод результата
  cout &lt;&lt; full_res.size() &lt;&lt; '\n';
  for (int i = 0; i &lt; full_res.size(); i++) {
    cout &lt;&lt; full_res[i].first &lt;&lt; " "
         &lt;&lt; full_res[i].second &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача H. Точки и отрезки -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Точки и отрезки</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 16мб</i></div>

  <p>Дано N отрезков на числовой прямой и M точек на этой же прямой. Для каждой из данных точек определите, скольким отрезкам она принадлежит. Точка x считается принадлежащей отрезку с концами a и b, если выполняется двойное неравенство min(a,b) ≤ x ≤ max(a,b).</p>

  <h4>Входные данные</h4>
  <p>Первая строка входа содержит два целых числа N — число отрезков и M — число точек (1 ≤ N, M ≤ 10⁵). В следующих N строках по два целых числа aᵢ и bᵢ — координаты концов соответствующего отрезка. В последней строке M целых чисел — координаты точек. Все числа во входном файле не превосходят по модулю 10⁹.</p>

  <h4>Выходные данные</h4>
  <p>Выведите M чисел — для каждой точки количество отрезков, в которых она содержится.</p>

  <h4>Пример 1</h4>
<pre>
3 2
0 5
-3 2
7 10
1 6
</pre>
  <code>2 0</code>

  <h4>Пример 2</h4>
<pre>
1 3
-10 10
-100 100 0
</pre>
  <code>0 0 1</code>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ускорение ввода
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  // ввод данных
  int n, m;
  cin >> n >> m;
  int a1, b1, a, b;
  pair&lt;pair&lt;int, int&gt;, int&gt; tmp;
  vector&lt;pair&lt;pair&lt;int, int&gt;, int&gt; &gt; A;

  // собираем отрезки
  for (int i = 0; i &lt; n; i++) {
    cin >> a1 >> b1;
    a = min(a1, b1);
    b = max(a1, b1);
    tmp.first.first = a;
    tmp.first.second = -1;  // начало отрезка
    A.push_back(tmp);
    tmp.first.first = b;
    tmp.first.second = 1; // маркер окон отрезка
    A.push_back(tmp);
  }

  // собираем точки
  for (int i = 0; i &lt; m; i++) {
    cin >> a;
    tmp.first.first = a;
    tmp.first.second = 0; // точка
    tmp.second = i; // индекс точки
    A.push_back(tmp);
  }

  sort(A.begin(), A.end());
  vector&lt;int&gt; Result(m);
  int count = 0;

  for (int i = 0; i &lt; A.size(); i++) {
    if (A[i].first.second == 0) {
      Result[A[i].second] = count;
    } else {
      if (A[i].first.second == -1) {
        count++;
      } else {
        count--;
      }
    }
  }

  // вывод результата
  for (int i = 0; i &lt; Result.size(); i++) {
    cout &lt;&lt; Result[i] &lt;&lt; " ";
  }
}
</pre>
  </details>
</article>


<!-- Задача I. Древние цивилизации -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача I. Древние цивилизации</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Недавно Петя занялся изучением древних цивилизаций. Он нашел в энциклопедии даты рождения и гибели N различных древних цивилизаций и теперь хочет узнать о влиянии культуры одних цивилизаций на культуру других.</p>

  <p>Петя предположил, что между цивилизациями A и B происходил культурный обмен, если они сосуществовали в течение некоторого ненулевого промежутка времени. Например, если цивилизация A зародилась в 600 году до н.э. и существовала до 400 года до н.э., а цивилизация B зародилась в 450 году до н.э. и существовала до 300 года до н.э., то культура каждой из этих цивилизаций оказывала влияние на развитие другой цивилизации в течение 50 лет. В то же время, если цивилизация C зародилась в 400 году до н.э. и существовала до 50 года до н.э., то она не смогла осуществить культурного обмена с цивилизацией A, в то время как культурный обмен с цивилизацией B продолжался в течение 100 лет.</p>

  <p>Теперь для выполнения своих исследований Петя хочет найти такую пару цивилизаций, культурный обмен между которыми имел место на протяжении наименьшего ненулевого промежутка времени. Помогите ему!</p>

  <h4>Входные данные</h4>
  <p>В первой строке вводится число N — количество цивилизаций, культура которых интересует Петю (1 ≤ N ≤ 100000). Следующие N строк содержат описание цивилизаций — в каждой строке задаются два целых числа Sᵢ и Eᵢ — год зарождения и год гибели соответствующей цивилизации. Все числа не превосходят 10⁹ по абсолютной величине, Sᵢ &lt; Eᵢ.</p>

  <h4>Выходные данные</h4>
  <p>Выведите два числа — номера цивилизаций, периоды существования которых имеют наименьшее ненулевое пересечение. Если никакие две цивилизации не пересекаются во времени, выведите единственное число 0.</p>

  <h4>Пример 1</h4>
<pre>
3
-600 -400
-450 -300
-400 -50
</pre>
  <code>2 1</code>

  <h4>Пример 2</h4>
<pre>
2
10 20
15 21
</pre>
  <code>2 1</code>

  <h4>Пример 3</h4>
<pre>
1
77777 77778
</pre>
  <code>0</code>
</article>


<!-- Задача J. Родительская работа -->
<article class="article">
  <div class="anchor" id="task10"></div>
  <h3>Задача J. Родительская работа</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Малышу Кэмерон и Джейми почти 3 года! Однако, несмотря на то, что ребенок стал более независимым, планирование действий ребенка и предметов домашнего обихода все еще является проблемой для пары.</p>

  <p>У Кэмерона и Джейми есть список из N мероприятий, о которых нужно позаботиться в течение дня. Каждое действие происходит в течение определенного интервала времени суток. Им нужно назначить каждое мероприятие одному из них, причем один человек не может присутствовать на двух мероприятиях проходящих одновременно (мероприятия могут перекрываться), также они не могут опоздать на мероприятие, так как это считается дурным тоном. Мероприятие, которое заканчивается в момент времени t, не считается перекрывающимся с другим мероприятием, которое начинается в момент времени t.</p>

  <p>Например, предположим, что Джейми и Кэмерон нужно посетить 3 мероприятия: одно с 18:00 до 20:00, другое с 19:00 до 21:00 и третье с 22:00 до 23:00. Одна из возможностей была бы для Джейми — посетить мероприятие продолжающееся с 19:00 до 21:00, а Кэмерон — два других. Еще один действительный способ — Кэмерон для посетить мероприятие с 18:00 до 20:00, а Джейми — два других. Обратите внимание, что первые два действия перекрываются во времени между 19:00 и 20:00, поэтому невозможно назначить оба этих действия одному и тому же человеку.</p>

  <p>Учитывая известное время начала и окончания каждого действия, найдите любой график, который не требует, чтобы один и тот же человек посещал перекрывающиеся мероприятия, или скажите, что это невозможно. Другими словами, нужно каждому событию назначить человека, чтобы все мероприятия были в итоге посещены учитывая то, что один человек не может одновременно быть на двух мероприятиях и не может на них опаздывать.</p>

  <p>Если существует несколько решений, вы можете вывести любое из них.</p>

  <h4>Входные данные</h4>
  <p>Каждый тест начинается со строки, содержащей одно целое число N, количество мероприятий которые надо посетить. Затем следует еще N строк. i-ая из этих строк содержит два целых числа Sᵢ и Eᵢ — время начала и конца мероприятия (указано в минутах от начала суток).</p>

  <h4>Выходные данные</h4>
  <p>Выведите одну строку, содержащую IMPOSSIBLE, если нет правильного расписания в соответствии с приведенными выше правилами. Если ответ существует, то выведите строку из ровно N символов. i-ый символ в выходных данных должен быть C, если i-ое посещение мероприятия назначено Кэмерону в предложенном вами расписании, и J, если оно назначено Джейми.</p>

  <p>Если существует несколько решений, вы можете вывести любое из них.</p>

  <p>Ограничения:</p>
  <code>0 ≤ Sᵢ &lt; Eᵢ ≤ 24x60</code>
  <code>2 ≤ N ≤ 1000.</code>

  <h4>Пример 1</h4>
<pre>
3
360 480
420 540
600 660
</pre>
  <code>CJC</code>

  <h4>Пример 2</h4>
<pre>
3
0 1440
1 3
2 4
</pre>
  <code>IMPOSSIBLE</code>

  <h4>Пример 3</h4>
<pre>
5
99 150
1 100
100 301
2 5
150 250
</pre>
  <code>JCCJJ</code>

  <h4>Пример 4</h4>
<pre>
2
0 720
720 1440
</pre>
  <code>CC</code>
</article>


<!-- Задача K. Два телевизора -->
<article class="article">
  <div class="anchor" id="task11"></div>
  <h3>Задача K. Два телевизора</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Поликарп — фанат телевидения.</p>

  <p>Он выписал интересующие его передачи на сегодня. В его списке получилось n телешоу, i-е из них начинается в момент времени lᵢ и заканчивается в момент времени rᵢ.</p>

  <p>У Поликарпа есть два телевизора. Он может одновременно смотреть два различных телешоу по двум телевизорам, но каждый из телевизоров может показывать только одно шоу в один момент. Считайте, что если одно шоу заканчивается ровно в момент начала следующего, то на одном телевизоре их посмотреть не получится.</p>

  <p>Поликарп хочет посмотреть все n телешоу! Достаточно ли ему двух телевизоров, чтобы осуществить задуманное?</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано одно целое число n (1 ≤ n ≤ 2·10⁵) — количество телешоу в списке.</p>

  <p>В следующих n строках заданы по два целых числа lᵢ и rᵢ (0 ≤ lᵢ &lt; rᵢ ≤ 10⁹) — время начала и конца шоу под номером i.</p>

  <h4>Выходные данные</h4>
  <p>Если Поликарп сможет посмотреть все шоу, используя только два телевизора, то выведите «YES» (без кавычек). В противном случае, выведите «NO» (без кавычек).</p>

  <h4>Пример 1</h4>
<pre>
3
1 2
2 3
4 5
</pre>
  <code>YES</code>

  <h4>Пример 2</h4>
<pre>
4
1 2
2 3
2 3
1 2
</pre>
  <code>NO</code>
</article>


<!-- Задача L. Межрегиональная олимпиада -->
<article class="article">
  <div class="anchor" id="task12"></div>
  <h3>Задача L. Межрегиональная олимпиада</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>На межрегиональной олимпиаде по программированию роботов соревнования проводятся в один тур и в необычном формате. Задачи участникам раздаются последовательно, а не все в самом начале тура, и каждая i-я задача (1≤i≤n) становится доступной участникам в свой момент времени sᵢ. При поступлении очередной задачи каждый участник должен сразу определить, будет он ее решать или нет. В случае, если он выбирает для решения эту задачу, то у него есть tᵢ минут на то, чтобы сдать ее решение на проверку, причем в течение этого времени он не может переключиться на решение другой задачи. Если же участник отказывается от решения этой задачи, то в будущем он не может к ней вернуться. В тот момент, когда закончилось время, отведенное на задачу, которую решает участник, он может начать решать другую задачу, ставшую доступной в этот же момент, если такая задача есть, или ждать появления другой задачи. При этом за правильное решение i-й задачи участник получает cᵢ баллов.</p>

  <p>Артур, представляющий на межрегиональной олимпиаде один из региональных центров искусственного интеллекта, понимает, что важную роль на такой олимпиаде играет не только умение решать задачи, но и правильный стратегический расчет того, какие задачи надо решать, а какие пропустить. Ему, как и всем участникам, до начала тура известно, в какой момент времени каждая задача станет доступной, сколько времени будет отведено на ее решение и сколько баллов можно получить за ее решение. Артур является талантливым школьником и поэтому сможет успешно решить за отведенное время и сдать на проверку любую задачу, которую он выберет для решения на олимпиаде.</p>

  <p>Требуется написать программу, которая определяет, какое максимальное количество баллов Артур сможет получить при оптимальном выборе задач, которые он будет решать, а также количество и перечень таких задач.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входного файла содержит одно целое число n (1 ≤ n ≤ 10⁵) количество задач на олимпиаде.</p>

  <p>Последующие n строк содержат описания задач, по три числа на каждой строке: sᵢ момент появления i-й задачи в минутах, tᵢ время, отведенное на ее решение в минутах, и cᵢ сколько баллов получит участник за решение этой задачи (1 ≤ sᵢ, tᵢ, cᵢ ≤ 10⁹).</p>

  <h4>Выходные данные</h4>
  <p>Первая строка выходного файл должна содержать одно число – максимальное количество баллов, которое сможет получить Артур на олимпиаде.</p>

  <p>Вторая строка должна содержать одно целое число m - количество задач, которые надо решить при оптимальном выборе.</p>

  <p>Третья строка должна содержать m разделенных пробелом целых чисел — номера этих задач в порядке их решения. Задачи пронумерованы, начиная с единицы, в порядке их описания во входном файле.</p>

  <p>Если оптимальных ответов несколько, необходимо вывести любой из них.</p>

  <h4>Пример 1</h4>
<pre>
2
1 1 1
2 2 2
</pre>
<pre>
3
2
1 2
</pre>

  <h4>Пример 2</h4>
<pre>
3
1 2 1
3 2 1
2 4 3
</pre>
<pre>
3
1
3
</pre>
  <p>В первом примере Артур успевает решить все задачи и получить три балла.</p>
  <p>Во втором примере Артуру выгоднее решать последнюю задачу и получить за нее три балла, чем решать только первые две и получить два балла.</p>
</article>


<!-- Задача M. Вишневый вопрос -->
<article class="article">
  <div class="anchor" id="task13"></div>
  <h3>Задача M. Вишневый вопрос</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>После долгого отсутствия Раневская наконец-то вернулась в родное поместье. Но вместе с тёплыми воспоминаниями к ней пришли и старые долги. И вот она стоит на пороге банкротства — нужно продавать любимое поместье вместе с вишнёвым садом. Причем ровно в это время на деревьях распускаются цветы! Поэтому она хочет назначить торги на следующий день после самого бурного цветения.</p>

  <p>Более подробно: в её саду растет N вишневых деревьев. Про каждое дерево известно: aᵢ — день, когда оно начинает расцветать, утром этого дня на нем появляется kᵢ цветков, каждое следующее утро их число увеличивается на kᵢ до bᵢ дня включительно. Далее на i-м дереве увядает kᵢ цветков каждый день, начиная с вечера bᵢ дня.</p>

  <p>Наша героиня нуждается в вашей помощи! Найдите день, когда общее число цветков на всех деревьях наибольшее, и выведите самый первый из них.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных находится единственное N (1 ≤ N ≤ 10⁵)  — количество деревьев. Далее в i + 1 строке находится информация об i-м дереве: числа aᵢ, bᵢ и kᵢ (1 ≤ aᵢ ≤ bᵢ ≤ 10⁹, 1 ≤ kᵢ ≤ 10⁹).</p>

  <p>Гарантируется, что ответ помещается в 64-битный тип данных.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите число — самый первый день, в который число цветков на всех деревьях будет наибольшим.</p>

  <h4>Пример</h4>
<pre>
3
1 9 1
20 24 2
35 36 5
</pre>
  <code>24</code>
  <p>Утром 9-го дня суммарное число цветков будет равно 9.</p>

  <p>Утром 24-го дня суммарное число цветков будет равно 10.</p>

  <p>Утром 36-го дня суммарное число цветков будет равно 10.</p>

  <p>Максимальное число цветков на деревьях – 10, первый раз такое количество будет в 24-й день.</p>
</article>


<!-- Задача N. Сон -->
<article class="article">
  <div class="anchor" id="task14"></div>
  <h3>Задача N. Сон</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вероника очень чутко спит и на каждый звук реагирует. Ира очень тщательно следит, как спит Вероника. Она ведет дневник и записывает, как спала Вероника. За несколько месяцев, записей в дневнике стало очень много, целых n штук. Каждая запись в дневнике выглядит следующим образом: hh₁:mm₁:ss₁ – время, в которое Вероника уснула, и hh₂:mm₂:ss₂ – время, в которое Вероника проснулась.</p>

  <p>Однажды сосед сверху начал сверлить дрелью, делая ремонт, от этого звука Вероника проснулась и очень сильно испугалась, Вероника долго плакала. Игорю это очень сильно не понравилось, что ее дочку напугали новые звуки. Игорь пошел разбираться с соседом. Придя к нему, он объяснил ситуацию вежливо и показал дневник, сказав, что крайне нежелательно вести ремонт в промежутки сна Вероники, записанные в дневнике, иначе Игорь снова придет к соседу решать данный вопрос.</p>

  <p>Помогите определить, сколько времени в секундах у соседа на ремонт каждый день.</p>

  <h4>Входные данные</h4>
  <p>В первой строке задано одно целое число n (1 ≤ n ≤ 10⁵) — количество промежутков сна в списке Игоря.</p>

  <p>Далее в каждой строке задано время сна Вероники через пробел в виде hh₁:mm₁:ss₁, hh₂:mm₂:ss₂ (0 ≤ hh₁, hh₂ ≤ 23, 0 ≤ mm₁, mm₂ ≤ 59, 0 ≤ ss₁, ss₂ ≤ 59) — время начала сна и время пробуждения после сна.</p>

  <p>Гарантируется, что каждый промежуток времени сна Вероники меньше 24
  часов.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите число – количество секунд на ремонт у соседа.</p>

  <h4>Пример 1</h4>
<pre>
5
13:00:00 14:00:00
16:00:00 17:00:00
19:00:00 20:00:00
01:00:00 05:00:00
04:00:00 05:00:00
</pre>
  <code>61200</code>

  <h4>Пример 2</h4>
<pre>
4
22:49:13 05:22:28
18:50:30 14:32:25
11:34:33 11:28:25
08:55:57 19:49:53
</pre>
  <code>0</code>

  <h4>Пример 3</h4>
<pre>
2
10:48:15 07:42:04
03:00:33 04:52:08
</pre>
  <code>11171</code>

  <details>
    <summary>Решение</summary>
    <p>Для начала напишем функцию перевода времени.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int time_string_int(string time) {
  int t = 0;
  t = 10 * (time[0] - '0') + (time[1] - '0');  // часы
  t = t * 60 + 10 * (time[3] - '0') + (time[4] - '0');  // минуты
  t = t * 60 + 10 * (time[6] - '0') + (time[7] - '0');  // секунды
  return t;
}

int main() {
  // ускорение ввода
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  // ввод данных
  vector&lt;int&gt; All_time(1000000);
  int n;
  string s1, s2;
  cin >> n;
  int time_start, time_end;

  for (int i = 0; i &lt; n; i++) {
    cin >> s1 >> s2;
    // переход за полночь
    if (s1 &lt; s2) {
      time_start = time_string_int(s1);
      time_end = time_string_int(s2);
      All_time[time_start]++;
      All_time[time_end]--;
    } else {
      time_start = time_string_int(s1);
      time_end = time_string_int("24:00:00");
      All_time[time_start]++;
      All_time[time_end]--;
      time_start = time_string_int("00:00:00");
      time_end = time_string_int(s2);
      All_time[time_start]++;
      All_time[time_end]--;
    }
  }

  int count = 0;
  int result = 0;
  for (int i = 0; i &lt; 24 * 60 * 60; i++) {
    count += All_time[i];
    if (count == 0) {
      result++;
    }
  }

  // вывод результата
  cout &lt;&lt; result;
}
</pre>
  </details>
</article>

