<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p>ЯрГУ. Кружок. Школьники 2024/2025</p>
  <p><a href="https://vkvideo.ru/@sportprog_yarsu" target="_blank">vkvideo.ru/@sportprog_yarsu</a></p>
</article>


<article class="article">
  <h1>Занятие 2. Основы C++ #1. Переменные, ветвление, циклы</h1>
  <p>Конспект видео от 2024.09.22</p>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contest/550879" target="_blank">Codeforces Контест 550879</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
        <a href="#p1">Структура программы</a>
    <br><a href="#p2">Синтаксические правила</a>
    <br><a href="#p3">Типы данных</a>
    <br><a href="#p4">Переменные</a>
    <br><a href="#p5">Операторы</a>
    <br><a href="#p6">Преобразование типов данных</a>
    <br><a href="#p7">Ввод/вывод информации</a>
    <br><a href="#p8">Операции сравнения</a>
    <br><a href="#p9">Ветвление</a>
    <br><a href="#p10">Циклы</a>
  </p>
  <p>
        <a href="#task1">Задача A. Укладка доминошками</a>
    <br><a href="#task2">Задача B. Осьминожки</a>
    <br><a href="#task3">Задача C. Високосный год</a>
    <br><a href="#task4">Задача D. Театральная площадь</a>
    <br><a href="#task5">Задача E. Петины братья</a>
    <br><a href="#task6">Задача F. Куплю лопату</a>
    <br><a href="#task7">Задача G. Солдат и бананы</a>
    <br><a href="#task8">Задача H. Почти счастливое число</a>
    <br><a href="#task9">Задача I. Полицейские-рекруты</a>
    <br><a href="#task10">Задача J. Дивизон</a>
    <br><a href="#task11">Задача K. Счастливый</a>
    <br><a href="#task12">Задача L. Ваня и кубики</a>
    <br><a href="#task13">Задача M. Санаторий</a>
    <br><a href="#task14">Задача N. Кормен — лучший друг человека</a>
    <br><a href="#task15">Задача O. Деление пиццы</a>
    <br><a href="#task16">Задача P. Парад</a>
  </p>
</article>


<!-- Структура программы -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Структура программы</h3>

  <ol>
    <li>Директивы</li>
    <li>Пространство имен</li>
    <li>Глобальные переменные</li>
    <li>Структуры/классы</li>
    <li>Функции</li>
    <li>main</li>
  </ol>

  <h4>Директивы</h4>
  <p>Директива – это командная строка препроцессора. Она в исходном коде имеет определенный формат:</p>
  <code># ключевое_слово заданные_параметры.</code>
  <p>При помощи директив можно выполнять различные операции при «сборке» проекта для компиляции. Формируются они по следующим принципам:</p>
  <ul>
    <li>символ решетки;</li>
    <li>ноль или более символов пробелов/табуляции после;</li>
    <li>одно из предопределенных языком СИ ключевых слов;</li>
    <li>параметры, которые зависят непосредственно от ключевого слова.</li>
  </ul>
  <code>#define, #elif, #else, #endif, #if, #ifdef, #ifndef</code>

  <p>Подключение библиотек:</p>
  <code>#include &lt;имя библиотеки&gt;</code>
  <code>#include &lt;iostream&gt;</code>
  <code>#include &lt;cstdio&gt;</code>

  <p>Собственные библиотеки и старые библиотеки формата C подключаются с добавлением .h.</p>
  <code>#include &lt;cmath&gt;</code>
  <code>#include &lt;math.h&gt;</code>

  <h4>Пространство имен</h4>
  <p>Пространство имён (англ. namespace) — это группа взаимосвязанных функций, переменных, констант, классов, объектов и других компонентов программы.</p>
  <p>Пространства имён нужны, чтобы логически связывать части программы. Например, математические функции, физические, бухгалтерские и так далее.</p>
  <code>using namespace std;</code>

  <h4>main</h4>
  <p>Каждая программа на языке С++ должна иметь как минимум одну функцию - функцию main(). Именно с этой функции начинается выполнение приложения. Ее имя main фиксировано и для всех программ на С++ всегда одинаково.</p>
  <p>Функция также является блоком кода, поэтому ее тело обрамляется фигурными скобками, между которыми определяется набор инструкций.</p>
<pre>
int main(){
  return 0;
}
</pre>
  <p>Если в функции main() не написать return, то компилятор в конце функции сам добавит return 0;</p>
</article>


<!-- Синтаксические правила -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>Синтаксические правила</h3>

  <p>{ } - символы выделения блока действий. В Pascal аналог это begin end, в python отступы, знаки табуляции.</p>
  <p>; - символ обозначающий окончание действия.</p>
  <p>Зарезервированное слово (или ключевое слово) — в языках программирования слово, имеющее специальное значение. Например: if, for, while, int, double.</p>

  <h4>Комментарии</h4>
  <p>Комментарии позволяют понять смысл программы и то, что делают те или иные её части. При компиляции комментарии игнорируются и не оказывают никакого влияния на работу приложения и на его размер.</p>
  <p>Однострочный комментарий размещается на одной строке после двойного слеша //.</p>
  <p>Многострочный комментарий заключается между символами /* текст комментария */. Он может размещаться на нескольких строках.</p>
</article>


<!-- Типы данных -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>Типы данных</h3>

  <p>Целочисленные:</p>
<pre>
int		4 байт	-2^31 … 2^31-1	-2*10^9 … 2*10^9
long long	8 байт	-2^63 … 2^63-1	-8*10^18 … 8*10^18
unsigned int	4 байт	0 … 2^32-1 	0 … 4*10^9
</pre>

  <p>Вещественный:</p>
  <pre>double		8 байт	15 знаков</pre>

  <p>Логический:</p>
  <code>bool			1 байт		false/true</code>

  <p>Символьный:</p>
  <code>char			1 байт		диапазон -128 … 127, либо 0 … 255</code>
</article>


<!-- Переменные -->
<article class="article">
  <div class="anchor" id="p4"></div>
  <h3>Переменные</h3>

  <p>Переменные - это выделенные ячейки в памяти под определенный тип данных.</p>

  <code>тип имя;</code>
  <code>тип имя1, имя2, имя3;</code>
  <code>тип имя = значение;</code>

  <code>double k1, k2, k3, k4;</code>
  <code>int a = 10;</code>
  <code>int b = 2 * a;</code>

  <h4>Правила именования переменной</h4>
  <ul>
    <li>Имя переменной может состоять только из латинских букв, цифр и символа подчёркивания.</li>
    <li>Прописные и строчные буквы в именах различаются, то есть переменные abc и Abc — разные переменные.</li>
    <li>Имя переменной не может начинаться с цифры.</li>
    <li>Имя переменной не может повторяться, то есть нельзя объявить две переменные с одним именем.</li>
    <li>В качестве имени переменной не могут использоваться ключевые слова языка C++.</li>
  </ul>
</article>


<!-- Операторы -->
<article class="article">
  <div class="anchor" id="p5"></div>
  <h3>Операторы</h3>

  <p>Оператор в C++ — это специальный символ (или символы), которые говорят компилятору выполнить определённую математическую, логическую или другую операцию.</p>
  <p>В языке C++ есть следующие встроенные операторы:</p>
  <ul>
    <li>Операторы присваивания.</li>
    <li>Арифметические операторы.</li>
    <li>Операторы сравнения.</li>
    <li>Логические операторы.</li>
    <li>Побитовые операторы.</li>
    <li>Вспомогательные операторы.</li>
  </ul>

  <h4>Операция присвоение</h4>
  <p>Оператор присваивания в C++ — это основная операция, которая используется для присвоения некоторого значения переменным.</p>
  <p>Он обозначается знаком равенства = и имеет следующий синтаксис:</p>
  <code>переменная = значение;</code>
  <p>Значение в правой части будет присвоено переменной в левой части. Переменная и значение должны иметь один и тот же тип данных.</p>
  <code>int a, b = 6;</code>
  <code>a = 10 + (200 * 15) / 40 + b * b;</code>

  <h4>Арифметические операции</h4>
  <p>+	сложение;</p>
  <p>-	вычитание;</p>
  <p>*	умножение;</p>
  <p>/	вещественное деление и целочисленное деление;</p>
  <p>%	взятие остатка.</p>

  <p>целое / целое = целое</p>
  <p>вещественное / вещественное = вещественное</p>
  <p>вещественное / целое = вещественное</p>
  <p>целое / вещественное = вещественное</p>

  <code>10 / 3 = 3</code>
  <code>10 / 3.0 = 3.33333333333</code>

  <code>имя1 = имя1 действие имя2</code>
  <code>sum = sum + a;   sum += a;</code>

  <p>+=	сложение с присвоением;</p>
  <p>-=	вычитание с присвоением;</p>
  <p>*=	умножение с присвоением;</p>
  <p>/=	вещественное деление и целочисленное деление с присвоением;</p>
  <p>%=	взятие остатка с присвоением.</p>

  <p>++	инкремент, увеличение переменной на 1.</p>
  <p>--	декремент, уменьшение переменной на 1.</p>

  <p>++i i++	заменяет i = i + 1.</p>
  <p>--i i--	заменяет i = i - 1.</p>
</article>


<!-- Преобразование типов данных -->
<article class="article">
  <div class="anchor" id="p6"></div>
  <h3>Преобразование типов данных</h3>

  <p>В C++ существует два типа преобразования типов данных:</p>
  <ol>
    <li>Неявное преобразование. Это преобразование типа, которое автоматически выполняется компилятором.</li>
    <li>Явное преобразование также известное как приведение типов. Этот тип преобразования используется, когда пользователь вручную меняет данные с одного типа на другой.</li>
  </ol>
  <p>тип(значение)</p>
  <code>double a = 1.0 * 678;</code>
  <code>double c = 100;</code>
  <code>int b = int(55.0 / 3);</code>
</article>


<!-- Ввод/вывод информации -->
<article class="article">
  <div class="anchor" id="p7"></div>
  <h3>Ввод/вывод информации</h3>

  <code>#include &lt;iostream&gt;</code>
  <p>Библиотека iostream определяет три стандартных потока:</p>
  <ol>
    <li>cin стандартный входной поток (stdin в С)</li>
    <li>cout стандартный выходной поток (stdout в С)</li>
    <li>cerr стандартный поток вывода сообщений об ошибках (stderr в С)</li>
  </ol>

  <p>Для их использования в Microsoft Visual Studio необходимо прописать строку:</p>
  <code>using namespace std;</code>

  <p>В противном случае каждый вызов функций cin, cout будет дополняться пространством имен std и оператором разрешения контекста ::</p>
  <code>std::cin &gt;&gt; Имя;</code>
  <code>std::cout &lt;&lt; Имя;</code>

  <p>Для выполнения операций ввода-вывода переопределены две операции поразрядного сдвига:</p>
  <ol>
    <li>&gt;&gt; получить из входного потока</li>
    <li>&lt;&lt; поместить в выходной поток</li>
  </ol>

  <code>int a;</code>
  <code>cin &gt;&gt; a;</code>
  <code>cout &lt;&lt; 2 * a;</code>

  <h4>Вывод информации</h4>
  <code>cout &lt;&lt; значение;</code>
  <p>Здесь значение преобразуется в последовательность символов и выводится в выходной поток:</p>
  <code>cout &lt;&lt; n;</code>
  <p>Возможно многократное назначение потоков:</p>
  <code>cout &lt;&lt; "значение1" &lt;&lt; "значение2" &lt;&lt; ... &lt;&lt; "значение n";</code>

  <p>Специальный символ перехода на новую строку при выводе '\n'.</p>
  <p>Один символ можно вывести через одинарные ковычки.</p>
  <p>Несколько символов можно вывести через двойные ковычки.</p>

  <code>cout &lt;&lt; 15 &lt;&lt; 55;</code>
  <p>Результат 1555</p>
  <code>cout &lt;&lt; 15 &lt;&lt; " " &lt;&lt; 55;</code>
  <p>Результат 15 55</p>
  <code>cout &lt;&lt; 15 &lt;&lt; " + " &lt;&lt; 55 &lt;&lt;  " = " &lt;&lt; 70;</code>
  <p>Результат 15 + 55 = 70</p>

  <h4>Ввод информации</h4>
  <code>cin &gt;&gt; идентификатор;</code>
  <p>При этом из входного потока читается последовательность символов до пробела, затем эта последовательность преобразуется к типу идентификатора, и получаемое значение помещается в идентификатор:</p>
  <code>int n;</code>
  <code>cin &gt;&gt; n;</code>
  <p>Возможно многократное назначение потоков:</p>
  <code>cin &gt;&gt; переменная1 &gt;&gt; переменная2 &gt;&gt; ... &gt;&gt; переменнаяn;</code>

  <p>При наборе данных на клавиатуре значения для такого оператора должны быть разделены символами (пробел, \n, \t).</p>
  <code>int n;</code>
  <code>char j;</code>
  <code>cin &gt;&gt; n &gt;&gt; j;</code>
  <p>пробел, \n, \t — символы разделители.</p>
</article>


<!-- Операции сравнения -->
<article class="article">
  <div class="anchor" id="p8"></div>
  <h3>Операции сравнения</h3>

  <p>&gt;	больше</p>
  <p>&lt;	меньше</p>
  <p>&gt;=	больше или равно</p>
  <p>&lt;=	меньше или равно</p>
  <p>==	равенство</p>
  <p>!=	не равны друг другу</p>

  <p>Операции сравнения в качестве результата возвращают значение типа bool true или false.</p>

  <h4>Логические операции</h4>
  <p>&&	логическое И</p>
  <p>||	логическое ИЛИ</p>
  <p>!	логическое НЕ</p>

  <p>Операция исключающее ИЛИ отсутствует в языке С++.</p>
  <p>В новых компиляторах C++ есть возможность заменить запись логическое И и логическое ИЛИ:</p>
  <code>&&	and</code>
  <code>||	or</code>
</article>


<!-- Ветвление -->
<article class="article">
  <div class="anchor" id="p9"></div>
  <h3>Ветвление</h3>

  <p>Условный оператор if:</p>
<pre>
if (условие1) {
  // код, который исполнится в случае, когда условие1 истинно
}
</pre>
  <p>Дополнительно можно добавить ветку кода для случая, когда условие ложно:</p>
<pre>
if (условие1) {
  // код, который исполнится, если условие1 истинно
} else {
  // код, который исполнится, если условие1 ложно
}
</pre>

  <p>Если код внутри фигурных скобок состоит из одной инструкции, то фигурные скобки можно не писать. Однако рекомендуется ставить фигурные скобки всегда во избежание ошибок.</p>
  <p>На месте условий может стоять любое выражение логического типа. Простейшие примеры таких выражений — это проверка на равенство и неравенство, а также сравнения на меньше / больше:</p>
  <code>==, !=, &lt;, &lt;=, &gt; и &gt;=</code>
  <p>Условия можно комбинировать с помощью логических операторов:</p>
  <code>&&(и), ||(или) и !(не)</code>
<pre>
int a, b;
cin &gt;&gt; a &gt;&gt; b;
if(a &gt; 0 && b &gt; 0 && a * b &lt; 25)
{
  cout &lt;&lt; "Good";
}
else
{
  cout &lt;&lt; "Bad";}

</pre>
<pre>
if (условие1)
{
  // случай, когда условие1 истинно
}
else if (условие2)
{
  // случай, когда условие1 ложно, а условие2 истинно
}
else if (условие3)
{
  // случай, когда условие1 и условие2 ложны, а условие3 истинно
}
else
{
  // случай, когда условие1, условие2 и условие3 ложны
}
</pre>
<pre>
if (условие1)
{
  if (условие2)
  {
    if (условие3)
    {
      if (условие4)
      {
        // случай, когда все условия истинны
      }
    }
  }
}
</pre>
</article>


<!-- Циклы -->
<article class="article">
  <div class="anchor" id="p10"></div>
  <h3>Циклы</h3>

  <p>В языке C++ существует три основных цикла:</p>
  <ol>
    <li>Цикл for. В нём все условия записываются в одном месте.</li>
    <li>Цикл while. В нём необходимо прописать лишь условие, а все остальные параметры записываются вне цикла.</li>
    <li>Цикл do while. Он схож с циклом while по форме написания, но при этом работает немного по-другому.</li>
  </ol>

  <p>Итерация — это отдельный проход цикла.</p>
  <p>Счетчик цикла — это переменная, в которой хранится количество проходов данного цикла.</p>

  <h4>Цикл while</h4>
  <p>В C++ существует несколько видов циклов. Цикл while — это цикл с предусловием. Перед очередной итерацией проверяется условие, и если оно истинно, то цикл продолжается.</p>
<pre>
while(условие)
{
  //тело цикла
}
</pre>
<pre>
int sum = 0;
int n = 100;
int i =0;
while(i &lt;= n)
{
  sum += i * i;
  i++;
}
cout &lt;&lt; sum;
</pre>

  <h4>Цикл for</h4>
  <p>Цикл for — самый гибкий. Он записывается так:</p>
<pre>
for (инициализация; условие; действие над параметром) {
  // тело цикла
}
</pre>
  <p>Как правило, с циклом ассоциируется некоторый параметр, который меняется от итерации к итерации, а цикл выполняется до тех пор, пока некоторое условие на этот параметр истинно.</p>
  <p>Начальное значение такого параметра можно задать в разделе инициализация, условие проверяет окончание цикла, а действие над параметром, выполняется после каждой итерации.</p>

<pre>
int sum = 0;
int n = 100;
for (int i = 0; i &lt;= n; i++)
{
  int tmp = i * i;
  sum += tmp;
}
cout &lt;&lt; sum;
</pre>

  <p>Для работы в циклах используются два основных оператора:</p>
  <ol>
    <li>Оператор break. Служит для выхода из цикла полностью.</li>
    <li>Оператор continue. Пропускает лишь одну итерацию и не выходит из цикла</li>
  </ol>
</article>


<!-- Задача A. Укладка доминошками -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Укладка доминошками</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Дана прямоугольная клеточная доска размера M x N клеток. Также дано неограниченное количество стандартных доминошек размера 2 x 1 клетку. Доминошки можно поворачивать. Требуется уложить как можно больше доминошек на доску так, чтобы соблюдались следующие условия:</p>
  <ol>
    <li>Каждая доминошка полностью покрывает две клетки доски.</li>
    <li>Никакие две доминошки не перекрываются.</li>
    <li>Каждая доминошка полностью лежит внутри доски. Касание краев доски допускается.</li>
  </ol>
  <p>Найдите максимальное количество доминошек, которое можно уложить с данными ограничениями.</p>

  <h4>Входные данные</h4>
  <p>В единственной строке записано два целых числа M и N — размеры доски в клетках (1 ≤ M ≤ N ≤ 16).</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно число — максимальное количество доминошек, которое можно уложить.</p>

  <h4>Пример 1</h4>
  <code>2 4</code>
  <code>Output: 4</code>

  <h4>Пример 2</h4>
  <code>3 3</code>
  <code>Output: 4</code>

  <details>
    <summary>Решение</summary>
    <p>Каждая доминошка занимает 2 клетки. Поэтому максимальное количество доминошек, которое можно уложить на доску, равно половине площади доски с округлением вниз</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int m, n;
  cin >> m >> n;

  // решение и вывод результата
  cout &lt;&lt; (m * n) / 2;
}
</pre>
  </details>
</article>


<!-- Задача B. Осьминожки -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Осьминожки</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>У осьминогов каждый год вырастает K щупальцев. Сколько у него будет щупальцев через N лет, если при рождении их у него было A?</p>

  <h4>Входные данные</h4>
  <p>Вводится три числа K, N и A.</p>

  <h4>Выходные данные</h4>
  <p>Вывести ответ на задачу.</p>

  <h4>Пример 1</h4>
  <code>1 2 3</code>
  <code>5</code>

  <h4>Пример 2</h4>
  <code>3 2 1</code>
  <code>7</code>

  <details>
    <summary>Решение</summary>
    <p>Через N лет количество щупальцев будет равно A + K * N</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int k, n, a;
  cin >> k >> n >> a;

  // решение и вывод результата
  cout &lt;&lt; a + k * n;
}
</pre>
  </details>
</article>


<!-- Задача C. Високосный год -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Високосный год</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Требуется определить является ли год високосным. Високосным год называется, если он делится на 4 и при этом не делится на 100, или делится на 400.</p>

  <h4>Входные данные</h4>
  <p>Вводится одно число - исследуемый год (целое неотрицательное число до 2012).</p>

  <h4>Выходные данные</h4>
  <p>Вывести "Yes", если год является високосным, и "No" иначе</p>

  <h4>Пример 1</h4>
  <code>1900</code>
  <code>No</code>

  <h4>Пример 2</h4>
  <code>2000</code>
  <code>Yes</code>

  <details>
    <summary>Решение</summary>
    <h4>Идея решения:</h4>
    <ol>
      <li>Проверить, делится ли год на 4.</li>
      <li>Если год делится на 100, проверить, делится ли он на 400.</li>
      <li>Если год делится на 4 и не делится на 100, или делится на 400, то он високосный.</li>
    </ol>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int year;
  cin >> year;

  // решение и вывод результата
  bool mod4 = year % 4 == 0;
  bool mod100 = year % 100 == 0;
  bool mod400 = year % 400 == 0;
  if (mod4 && !mod100 || mod400) {
    cout &lt;&lt; "Yes";
  } else {
    cout &lt;&lt; "No";
  }

  return 0;
}
</pre>
  </details>
</article>


<!-- Задача D. Театральная площадь -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Театральная площадь</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Театральная площадь в столице Берляндии представляет собой прямоугольник n x m метров. По случаю очередного юбилея города, было принято решение о замощении площади квадратными гранитными плитами. Каждая плита имеет размер a x a.</p>

  <p>Какое наименьшее количество плит понадобится для замощения площади? Разрешено покрыть плитами большую поверхность, чем театральная площадь, но она должна быть покрыта обязательно. Гранитные плиты нельзя ломать или дробить, а разрешено использовать только целиком. Границы плит должны быть параллельны границам площади.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано три целых натуральных числа n, m и a (1 ≤ n, m, a ≤ 10⁹).</p>

  <h4>Выходные данные</h4>
  <p>Выведите искомое количество плит.</p>

  <h4>Пример</h4>
  <code>6 6 4</code>
  <code>4</code>

  <details>
    <summary>Решение</summary>
    <h4>Идея решения:</h4>
    <ol>
      <li>Чтобы покрыть длину n нужно n/a плит с округлением вверх</li>
      <li>Чтобы покрыть ширину m нужно m/a плит с округлением вверх</li>
      <li>Общее количество плит будет равно произведению количества плит по длине и ширине: (n/a) * (m/a) </li>
      <li>Округление вверх можно реализовать с помощью формулы: x/y = (x+y-1) / y</li>
    </ol>


<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  long long n, m, a;
  cin >> n >> m >> a;

  // решение
  // Вычисляем количество плит по длине и ширине с округлением вверх
  long long tilesN = (n + a - 1) / a;
  long long tilesM = (m + a - 1) / a;

  // вывод результата
  cout &lt;&lt; tilesN + tilesM;
}
</pre>
  </details>
</article>


<!-- Задача E. Петины братья -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Петины братья</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>У Пети есть N братьев. Петя не знает сколько лет старшему брату и сколько лет младшему. Помогите Пете.</p>

  <h4>Входные данные</h4>
  <p>Вводится число N (1 ≤ N ≤ 100), затем вводится N чисел – возраст братьев (натуральные числа, не превосходящие 100).</p>

  <h4>Выходные данные</h4>
  <p>Вывести через пробел возраст старшего и младшего брата</p>

  <h4>Пример 1</h4>
<pre>
4
3 2 4 1
</pre>
  <code>4 1</code>

  <h4>Пример 2</h4>
<pre>
5
1 8 9 2 10
</pre>
  <code>10 1</code>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;

  // решение
  int age;
  cin >> age; // Считываем возраст первого брата
  int minAge = age; // Инициализируем минимальный возраст
  int maxAge = age; // Инициализируем максимальный возраст

  // Считываем возраст остальных братьев и обновляем minAge и maxAge
  for (int i = 1; i &lt; N; i++) {
      cin >> age;
      minAge = min(minAge, age); // Обновляем минимальный возраст
      maxAge = max(maxAge, age); // Обновляем максимальный возраст
  }

  // вывод результата
  cout &lt;&lt; maxAge &lt;&lt; " " &lt;&lt; minAge;

  return 0;
}
</pre>
  </details>
</article>


<!-- Задача F. Куплю лопату -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Куплю лопату</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Поликарпу срочно понадобилась лопата! Он пришёл в магазин и выбрал подходящую. Лопата, которая подошла Поликарпу, продается по цене k бурлей. Считайте, что в магазине неограниченное количество таких лопат.</p>

  <p>В кармане у Поликарпа есть неограниченное количество «дестюльников» (монет номиналом в 10 бурлей) и ровно одна монета номинала r (1 ≤ r ≤ 9).</p>

  <p>Какое наименьшее количество лопат придётся купить Поликарпу, чтобы он смог расплатиться за покупку без сдачи? Очевидно, что за 10 лопат он сможет расплатиться без сдачи (заплатив требуемую сумму «дестюльниками», не используя монету номинала r), но, возможно, он сможет купить меньшее количество лопат и расплатиться без сдачи. Обратите внимание, что Поликарп должен купить хотя бы одну лопату.</p>

  <h4>Входные данные</h4>
  <p>В единственной строке входных данных записаны два целых числа k и r (1 ≤ k ≤ 1000, 1 ≤ r ≤ 9) — цена одной лопаты и номинал монеты в кармане Поликарпа, отличной от «дестюльника».</p>

  <p>Помните, что ещё у него в кармане неограниченное количество монет номинала 10, то есть их хватит на покупку любого количества лопат.</p>

  <h4>Выходные данные</h4>
  <p>Выведите искомое минимальное количество лопат, которые нужно купить Поликарпу, чтобы расплатиться без сдачи.</p>

  <h4>Пример 1</h4>
  <code>117 3</code>
  <code>9</code>
  <p>В первом примере Поликарп может купить 9 лопат, заплатив 9·117 = 1053 бурлей. В самом деле, эту сумму он может заплатить используя монеты номиналом 10 бурлей и одну монету номиналом 3 бурля. Купить меньшее количество лопат (и при этом расплатиться без сдачи), он не может.</p>

  <h4>Пример 2</h4>
  <code>237 7</code>
  <code>1</code>
  <p>Во втором примере Поликарпу достаточно купить одну лопату.</p>

  <h4>Пример 3</h4>
  <code>15 2</code>
  <code>2</code>
  <p>В третьем примере Поликарп должен купить 2 лопаты, заплатив 2·15 = 30 бурлей. Эту сумму он, очевидно, может заплатить без сдачи.</p>

  <details>
    <summary>Решение</summary>
    <p>Общая стоимость лопат должна удовлетворять условию min_count * k = 0 или min_count * k = r (mod 10)</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int k, r;
  cin >> k >> r;

  // решение
  int min_count = 1; // Начинаем с одной лопаты

  while (true) {
    int totalCost = n * k; // Общая стоимость n лопат
    // Проверяем, можно ли оплатить без сдачи
    if (totalCost % 10 == r || totalCost % 10 == 0) {
      break;
    }
    min_count++; // Увеличиваем количество лопат
  }

  // вывод результата
  cout &lt;&lt; min_count;
}
</pre>
  </details>
</article>


<!-- Задача G. Солдат и бананы -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Солдат и бананы</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Солдат хочет купить w бананов в магазине. Ему надо заплатить k долларов за первый банан, 2k долларов — за второй и так далее (иными словами, за i-й банан надо заплатить i·k долларов).</p>

  <p>У него есть n долларов. Сколько долларов ему придется одолжить у однополчанина, чтобы купить w бананов?</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано три положительных целых числа k, n, w (1 ≤ k, w ≤ 1000, 0 ≤ n ≤ 10⁹), стоимость первого банана, изначальное количество долларов у солдата и количество бананов, которые он хочет купить.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное целое число — количество долларов, которое солдату надо одолжить у однополчанина. Если деньги одалживать не надо, выведите 0.</p>

  <h4>Пример</h4>
  <code>3 17 4</code>
  <code>13</code>

  <details>
    <summary>Решение</summary>
    <p>Пусть price это цена за w бананов. Если у солдата меньше денег, то borrow это количество денег, которые нужно занять.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int k, n, w;
  cin >> k >> n >> w;

  // решение
  int price = 0, borrow = 0;
  for (int i = 1; i &lt;= w; i++) {
    price += i * k;
  }
  borrow = price - n;

  // вывод результата
  if (borrow > 0) {
    cout &lt;&lt; borrow;
  } else {
    cout &lt;&lt; 0;
  }
}
</pre>
  </details>
</article>


<!-- Задача H. Почти счастливое число -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Почти счастливое число</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Петя любит счастливые числа. Всем известно, что счастливыми являются положительные целые числа, в десятичной записи которых содержатся только счастливые цифры 4 и 7. Например, числа 47, 744, 4 являются счастливыми, а 5, 17, 467 — не являются.</p>

  <p>К сожалению, не все числа счастливые. Петя называет число почти счастливым, если количество счастливых цифр в нем — счастливое число. Ему интересно, является ли число n почти счастливым.</p>

  <h4>Входные данные</h4>
  <p>В единственной строке задано целое число n (1 ≤ n ≤ 10¹⁸).</p>

  <p>Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите «YES», если число n — почти счастливое, и «NO» в противном случае (без кавычек).</p>

  <h4>Пример 1</h4>
  <code>40047</code>
  <code>NO</code>
  <p>В первом примере количество счастливых цифр числа равно 3 (первая и последние две цифры), поэтому ответ «NO».</p>

  <h4>Пример 2</h4>
  <code>7747774</code>
  <code>YES</code>
  <p>Во втором примере все цифры числа — счастливые, а их общее количество — 7, поэтому ответ «YES».</p>

  <h4>Пример 3</h4>
  <code>10000000000</code>
  <code>NO</code>
  <p>В третьем примере в числе нет счастливых цифр, поэтому ответ «NO».</p>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  long long n;
  cin >> n;

  // решение и вывод результата
  int count47 = 0;
  while (n &gt; 0) {
    if (n % 10 == 4 || n % 10 == 7) {
      count47++;
    }
    n /= 10;
  }
  if (count47 == 4 || count47 == 7) {
    cout &lt;&lt; "YES";
  }
  else {
    cout &lt;&lt; "NO";
  }
}
</pre>
  </details>
</article>


<!-- Задача I. Полицейские-рекруты -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача I. Полицейские-рекруты</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Недавно в вашем городе открылось отделение полиции. Сейчас идет набор кадров для работы в новом отделении. А тем временем, преступления все совершаются в городе.</p>

  <p>Достоверно известно, что один полицейский может расследовать только одно преступление за всю свою жизнь. Если преступление произошло в тот момент, когда в отделении полиции не было ни одного незанятого преступлениями полицейского, то оно так и останется навсегда нераскрытым.</p>

  <p>Вам заданы события в хронологическом порядке. Каждое событие — это: либо совершение преступления, либо прием на работу нового полицейского. Какое минимальное количество преступлений в любом случае останутся нераскрытыми?</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое число n (1 ≤ n ≤ 10⁵) — количество событий. В следующей строке записано n целых чисел, описывающих события, через пробел.</p>

  <p>Если число равняется -1, значит, произошло одно преступление. В противном случае, число будет положительным (не больше 10) и будет равняться количеству полицейских, нанятых в этот момент. События заданы в хронологическом порядке.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное целое число — количество нерасследованных преступлений.</p>

  <h4>Пример 1</h4>
<pre>
3
-1 -1 1
</pre>
  <code>2</code>

  <h4>Пример 2</h4>
<pre>
8
1 -1 1 -1 -1 1 1 1
</pre>
  <code>1</code>

  <h4>Пример 3</h4>
<pre>
11
-1 -1 2 -1 -1 -1 -1 -1 -1 -1 -1
</pre>
  <code>8</code>

  <details>
    <summary>Решение</summary>
    <h4>Идея решения:</h4>
    <ol>
      <li>Используем счётчик для отслеживания количества свободных полицейских.</li>
      <li>Используем счётчик нераскрытых преступлений.</li>
      <li>Проходим по всем событиям:</li>
      <li>Если событие — это наём полицейских, увеличиваем счётчик свободных полицейских.</li>
      <li>Если событие — это преступление: Если есть свободные полицейские, уменьшаем счётчик свободных полицейских (так как один полицейский расследует это преступление). Если свободных полицейских нет, увеличиваем счётчик нераскрытых преступлений.</li>
      <li>В конце выводим количество нераскрытых преступлений.</li>
    </ol>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;

  // решение
  int cnt_police = 0;
  int cnt_crime = 0;
  int res = 0;
  for (int i = 0; i &lt; n; i++) {
    int tmp;
    cin >> tmp;
    if (tmp > 0) {
      cnt_police += tmp;
    } else if (tmp == -1) {
      if (cnt_police > 0) {
        cnt_police--;
      } else {
        res++;
      }
    }
  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача J. Дивизон -->
<article class="article">
  <div class="anchor" id="task10"></div>
  <h3>Задача J. Дивизон</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>На Codeforces пользователи разделены на 4
  дивизиона по их рейтингу:</p>

  <ol>
    <li>Для 1-го дивизиона: 1900 ≤ rating</li>
    <li>Для 2-го ивизиона: 1600 ≤ rating ≤ 1899</li>
    <li>Для 3-го дивизиона: 1400 ≤ rating ≤ 1599</li>
    <li>Для 4-го дивизиона: rating ≤ 1399</li>
  </ol>

  <p> Учитывая rating, выведите, к какому дивизиону относится rating</p>

  <h4>Входные данные</h4>
  <p>Первая строка ввода содержит целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных в тесте.</p>
  <p>Описание каждого набора состоит из одной строки, содержащей одно целое число rating (-5000 ≤ rating ≤ 5000).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите единственную строку, содержащую дивизион в формате «Division X», где X
  — целое число от 1 до 4, представляющее дивизион для соответствующего рейтинга.</p>

  <h4>Пример</h4>
<pre>
7
-789
1299
1300
1399
1400
1679
2300
</pre>
<pre>
Division 4
Division 4
Division 4
Division 4
Division 3
Division 2
Division 1
</pre>
  <p>Для наборов входных данных 1-4 соответствующие оценки составляют -789, 1299, 1300, 1399, поэтому все они находятся в дивизионе 4.</p>

  <p>Для пятого набора соответствующая оценка составляет 1400, поэтому он находится в дивизионе 3.</p>

  <p>Для шестого набора соответствующий рейтинг составляет 1679, поэтому он находится в дивизионе 2.</p>

  <p>Для седьмого набора соответствующий рейтинг составляет 2300, поэтому он находится в дивизионе 1.</p>

  <details>
    <summary>Решение</summary>
    <h4>Идея решения:</h4>
    <ol>
      <li>Для каждого набора входных данных проверяем, в какой диапазон попадает рейтинг.</li>
      <li>В зависимости от диапазона выводим соответствующий дивизион.</li>
    </ol>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int t;
  cin >> t;

  // решение и вывод результата
  for (int test = 0; test &lt; t; test++) {
    int raiting;
    cin >> raiting;
    if (raiting >= 1900) {
      cout &lt;&lt; "Division 1\n";
    } else if (raiting >= 1600) {
      cout &lt;&lt; "Division 2\n";
    } else if (raiting >= 1400) {
      cout &lt;&lt; "Division 3\n";
    } else {
      cout &lt;&lt; "Division 4\n";
    }
  }

}
</pre>
  </details>
</article>


<!-- Задача K. Счастливый -->
<article class="article">
  <div class="anchor" id="task11"></div>
  <h3>Задача K. Счастливый</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Номер билета — это строка, которая состоит ровно из шести цифр. Номер билета является счастливым, если сумма первых трёх цифр равна сумме последних трёх цифр. Задан номер билета, проверьте счастливый он или нет. Обратите внимание, что в номере могут быть лидирующие нули.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит целое число t (1 ≤ t ≤ 10³) — количество наборов входных данных в тесте.</p>

  <p>Далее следуют описания наборов, каждый из них — это одна строка, которая содержит шесть цифр.</p>

  <h4>Выходные данные</h4>
  <p>Выведите t строк, которые содержат ответы. Выводите:</p>
  <ul>
    <li>YES, если соответствующий номер билета счастливый;</li>
    <li>NO в противном случае.</li>
  </ul>
  <p>Вы можете выводить YES и NO в любом регистре (например, строки yEs, yes, Yes и YES будут распознаны как положительный ответ).</p>

  <h4>Пример</h4>
<pre>
5
213132
973894
045207
000000
055776
</pre>
<pre>
YES
NO
YES
YES
NO
</pre>
  <p>В первом наборе входных данных примера сумма первых трёх цифр равна 2+1+3=6, сумма последних трёх цифр равна 1+3+2=6. Суммы равны. Следовательно, ответ равен «YES».</p>

  <p>Во втором наборе входных данных примера сумма первых трёх цифр равна 9+7+3=19, сумма последних трёх цифр равна 8+9+4=21. Суммы не равны. Следовательно, ответ равен «NO».</p>

  <p>В третьем наборе входных данных примера сумма первых трёх цифр равна 0+4+5=9, сумма последних трёх цифр равна 2+0+7=9. Суммы равны. Следовательно, ответ равен «YES».</p>

  <details>
    <summary>Решение</summary>
    <h4>Идея решения:</h4>
    <p>Для каждого набора входных данных:</p>
    <ol>
      <li>Разделяем номер билета на первые три цифры и последние три цифры.</li>
      <li>Вычисляем сумму первых трёх цифр и сумму последних трёх цифр.</li>
      <li>Если суммы равны, выводим "YES", иначе — "NO".</li>
    </ol>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int t;
  cin >> t;

  for (int test = 0; test &lt; t; test++) {
    int num;
    cin >> num;

    // решение
    int sum1 = 0;
    for (int i = 0; i &lt; 3; i++) {
      sum1 += num % 10;
      num /= 10;
    }
    int sum2 = 0;
    for (int i = 0; i &lt; 3; i++) {
      sum2 += num % 10;
      num /= 10;
    }

    // вывод результата
    if (sum1 == sum2) {
      cout &lt;&lt; "YES\n";
    } else {
      cout &lt;&lt; "NO\n";
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача L. Ваня и кубики -->
<article class="article">
  <div class="anchor" id="task12"></div>
  <h3>Задача L. Ваня и кубики</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Ване на день рождения подарили n кубиков. Он с друзьями решил построить из них пирамиду. Ваня хочет построить пирамиду следующим образом: на верхушке пирамиды должен находиться 1 кубик, на втором уровне — 1 + 2 = 3 кубика, на третьем — 1 + 2 + 3 = 6 кубиков, и так далее. Таким образом, на i-м уровне пирамиды должно располагаться 1 + 2 + ... + (i - 1) + i кубиков.</p>

  <p>Ваня хочет узнать, пирамиду какой максимальной высоты он может создать с использованием имеющихся кубиков.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое число n (1 ≤ n ≤ 10⁴) — количество кубиков, подаренных Ване.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственной строкой максимально возможную высоту пирамиды.</p>

  <h4>Пример 1</h4>
  <code>1</code>
  <code>1</code>

  <h4>Пример 2</h4>
  <code>25</code>
  <code>4</code>

  <details>
    <summary>Решение</summary>
    <h4>Построение пирамиды:</h4>
    <ol>
      <li>На каждом шаге увеличиваем высоту пирамиды на 1.</li>
      <li>Вычисляем количество кубиков, необходимых для текущего уровня: </li>
      <li>Добавляем это количество к общему количеству использованных кубиков.</li>
      <li>Если общее количество кубиков превышает n, откатываем последний уровень и завершаем.</li>
    </ol>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int n;   // число кубиков
  cin >> n;

  // решение
  int h = 0;    // высота пирамиды
  int i = 0;    // текущий кубик
  int need = 0; // нужно кубиков всего
  int level = 0; // кубиков на текущем уровне
  while (need &lt;= n) {
    i++;
    level = level + i;
    need = need + level;
    if (need &lt;= n) {
      h++;
    }
  }

  // вывод результата
  cout &lt;&lt; h;
}
</pre>
  </details>
</article>


<!-- Задача M. Санаторий -->
<article class="article">
  <div class="anchor" id="task13"></div>
  <h3>Задача M. Санаторий</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Василий провел свой отпуск в санатории и, вернувшись, обнаружил, что совершенно забыл о подробностях отдыха!</p>

  <p>В столовой санатория каждый день проходили завтрак, обед и ужин (конечно, именно в таком порядке). Единственное, что осталось у Василия — карточка из столовой, в которой находится запись о том, сколько раз он посещал завтрак, обед или ужин (таким образом, запись представляет собой три неотрицательных целых числа). Василий мог иногда пропустить ту или иную трапезу, например, в один и тот же день он мог посетить завтрак и ужин, но пропустить обед, а в какой-то из дней он мог не ходить в столовую вовсе.</p>

  <p>Василий уже не помнит, в какое время суток он приехал в санаторий (перед завтраком, перед обедом, перед ужином, или после ужина), а в какое уехал (до завтрака, до обеда, до ужина или после ужина) поэтому он готов рассматривать любой из этих вариантов. После приезда в санаторий Василий не покидал его до момента отъезда. Обратите внимание, Василий мог уехать из санатория в тот же день, что и приехал.</p>

  <p>По записи в карточке помогите Василию определить, какое наименьшее количество трапез в столовой санатория он мог пропустить. Трапезы, проходящие в день приезда Василия до его приезда и трапезы, проходящие в день отъезда Василия после его отъезда, пропущенными считать не следует.</p>

  <h4>Входные данные</h4>
  <p>В единственной строке входных данных содержатся три целых числа b, d и s (0 ≤ b, d, s ≤ 10¹⁸, b + d + s ≥ 1) — количество завтраков, обедов и ужинов, которые посетил Василий во время отдыха в санатории, соответственно.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное целое число — наименьшее возможное количество трапез, пропущенных Василием.</p>

  <h4>Пример 1</h4>
  <code>3 2 1</code>
  <code>1</code>
  <p>В первом примере из условия Василий пропустил бы один ужин, если, например, приехал бы к завтраку, пробыл два дня в санатории (включая день приезда) и уехал после завтрака третьего дня.</p>

  <h4>Пример 2</h4>
  <code>1 0 0</code>
  <code>0</code>
  <p>Во втором примере из условия Василий мог приехать к завтраку, сходить на него, и сразу же покинуть санаторий, не пропустив ни одной трапезы.</p>

  <h4>Пример 3</h4>
  <code>1 1 1</code>
  <code>0</code>
  <p>В третьем примере из условия Василий мог пробыть в санатории один полный день, не пропустив ни одной трапезы.</p>

  <h4>Пример 4</h4>
  <code>1000000000000000000 0 1000000000000000000</code>
  <code>999999999999999999</code>

  <details>
    <summary>Решение</summary>
    <h4>Идея решения:</h4>
    <ol>
      <li>Определим, сколько дней Василий провёл в санатории. Это можно сделать, найдя максимальное количество посещений одной из трапез, так как каждая трапеза происходит один раз в день.</li>
      <li>Для каждого дня, кроме первого и последнего, Василий должен был посетить все три трапезы (завтрак, обед, ужин). Если он пропустил какую-то трапезу, это считается пропуском.</li>
      <li>В первый и последний дни Василий мог пропустить трапезы в зависимости от времени приезда и отъезда.</li>
    </ol>
<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

int main() {
    long long b, d, s;
    cin >> b >> d >> s; // Считываем количество завтраков, обедов и ужинов

    // Определяем количество дней
    long long days = max({b, d, s});

    // Вычисляем минимальное количество пропущенных трапез
    long long missed = 0;

    // Пропуски для завтраков
    if (b &lt; days) {
        missed += (days - 1) - b;
    }

    // Пропуски для обедов
    if (d &lt; days) {
        missed += (days - 1) - d;
    }

    // Пропуски для ужинов
    if (s &lt; days) {
        missed += (days - 1) - s;
    }

    // Выводим результат
    cout &lt;&lt; missed;
}
</pre>
  </details>
</article>


<!-- Задача N. Кормен — лучший друг человека -->
<article class="article">
  <div class="anchor" id="task14"></div>
  <h3>Задача N. Кормен — лучший друг человека</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Недавно Поликарпу наконец купили собаку, которую он назвал Корменом. Теперь у Поликарпа появилось так много хлопот! Например, Кормен очень любит прогулки.</p>

  <p>Опытным путем Поликарп установил, что псу требуется не менее k прогулок суммарно за любые два последовательных дня, чтобы чувствовать себя отлично. Например, если k = 5 и вчера Поликарп гулял с собакой 2 раза, то сегодня он должен будет погулять не менее 3-х раз.</p>

  <p>Поликарп проанализировал все свои дела на ближайшие n дней вперед и составил последовательность из n целых чисел a₁, a₂, ..., aₙ, где aᵢ — количество прогулок с собакой, которые он совершит в i-й день, исполняя все свои дела во время них (например, ему надо сходить в магазин, выбросить мусор и так далее).</p>

  <p>Помогите Поликарпу определить наименьшее количество прогулок сверх намеченных, которые ему нужно совершить за n дней для того, чтобы Кормен чувствовал себя отлично на протяжении всех n дней. Вы можете считать, что в день до первого и в день после n-го Поликарп выгуливал Кормена ровно по k раз.</p>

  <p>Напишите программу, которая найдет наименьшее количество дополнительных прогулок и соответствующее расписание — последовательность целых чисел b₁, b₂, ..., bₙ (bᵢ ≥ aᵢ), где bᵢ обозначает суммарное количество прогулок в i-й день.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных записаны два целых числа n и k (1 ≤ n, k ≤ 500) — количество дней и минимальное суммарное количество прогулок Кормена за любые два подряд идущих дня.</p>

  <p>Во второй строке записаны целые числа a₁, a₂, ..., aₙ (0 ≤ aᵢ ≤ 500) — количество прогулок Кормена в i-й день, которые уже запланированы Поликарпом.</p>

  <h4>Выходные данные</h4>
  <p>В первую строку выведите наименьшее дополнительное количество прогулок, которые нужно совершить за n дней для того, чтобы Кормен всегда чувствовал себя отлично.</p>

  <p>Во вторую строку выведите n целых чисел b₁, b₂, ..., bₙ, где bᵢ — суммарное количество прогулок в i-й день в соответствии с найденным решением (aᵢ ≤ bᵢ для всех i от 1 до n). Если решений несколько, разрешается вывести любое из них.</p>

  <h4>Пример 1</h4>
<pre>
3 5
2 0 1
</pre>
<pre>
4
2 3 2
</pre>

  <h4>Пример 2</h4>
<pre>
3 1
0 0 0
</pre>
<pre>
1
0 1 0
</pre>

  <h4>Пример 3</h4>
<pre>
4 6
2 4 3 5
</pre>
<pre>
0
2 4 3 5
</pre>

  <details>
    <summary>Решение</summary>
    <h4>Идея решения:</h4>
    <ol>
      <li>Для каждого дня i (начиная со второго) проверяем, выполняется ли условие b<sub>i-1</sub> + b<sub>i</sub> &ge; k, где b<sub>i</sub> — общее количество прогулок в день i.</li>
      <li>Если условие не выполняется, увеличиваем количество прогулок в текущем дне b<sub>i</sub> на недостающее количество.</li>
      <li>После обработки всех дней выводим общее количество дополнительных прогулок и новое расписание.</li>
    </ol>
<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  int n, k;
  cin >> n >> k;
  // Исходное расписание прогулок
  vector&lt;int&gt; A(n);

  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  int day = 0;   // доп прогулка за день
  int extra = 0; // доп прогулки за n дней
  // Новое расписание прогулок
  vector&lt;int&gt; B(n);
  B[0] = A[0];
  for (int i = 1; i &lt; n; i++) {
    if (A[i] + B[i - 1] &lt; k) {
      // если нужна прогулка в i день
      day = k - A[i] - B[i - 1];
      B[i] = A[i] + day;
      extra += day;
    } else {
      // если не нужна прогулка в i день
      B[i] = A[i];
    }
  }

  // вывод результата
  cout &lt;&lt; extra &lt;&lt; '\n';
  for (int i = 0; i &lt; n; i++) {
    cout &lt;&lt; B[i] &lt;&lt; " ";
  }
}
</pre>
  </details>
</article>


<!-- Задача O. Деление пиццы -->
<article class="article">
  <div class="anchor" id="task15"></div>
  <h3>Задача O. Деление пиццы</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Студенты Вася и Петя учатся в БГУ (Байтляндском Государственном Университете). На одной из перемен они решили перекусить и заказали пиццу. Пицца представляет собой круг некоторого радиуса. Пиццу доставили уже разрезанную на n кусков, i-й кусок представляет собой сектор с углом равным a<sub>i</sub>. Вася и Петя хотят разделить все куски на два непрерывных сектора так, чтобы разница углов этих секторов была минимальна. Углом сектора называется сумма углов всех кусков пиццы входящих в него. Обратите внимание, что один из секторов может быть пустым.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно целое число n (1 ≤ n ≤ 360) — количество кусков, на которые разрезана пицца.</p>
  <p>Во второй строке записаны n целых чисел aᵢ (1 ≤ aᵢ ≤ 360) — углы секторов, на которые разрезана пицца. Сумма всех aᵢ равна 360.</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно целое число — минимально возможную разницу между углами секторов пиццы которые достанутся Васе и Пете.</p>

  <h4>Пример 1</h4>
<pre>
4
90 90 90 90
</pre>
  <code>0</code>
  <p>В первом тесте Вася может взять 1 и 2 куски, а Петя 3 и 4. Тогда ответ равен |(90 + 90) - (90 + 90)| = 0</p>

  <h4>Пример 2</h4>
<pre>
3
100 100 160
</pre>
  <code>40</code>

  <h4>Пример 3</h4>
<pre>
1
360
</pre>
  <code>360</code>
  <p>В третьем тесте есть только один кусок, который полностью достанется Васе или Пете. Поэтому ответ равен |360 - 0| = 360.</p>

  <h4>Пример 4</h4>
<pre>
4
170 30 150 10
</pre>
  <code>0</code>
  <p>В четвертом тесте Вася может взять 1 и 4 куски, тогда Пете достанутся 2 и 3 куски. Ответ в этом случае равен |(170 + 10) - (30 + 150)| = 0.</p>

  <h4>Пример 8</h4>
<pre>
5
110 90 70 50 40
</pre>
  <code>40</code>
  <p>Куски пиццы должны идти подряд, то есть быть соседними. Пицца круглая, поэтому нужно учитывать что последний кусок пиццы и первый - тоже соседние.</p>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;
  vector&lt;int&gt; A(n);

  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  if (n == 1) {
    cout &lt;&lt; 360;
    return 0;
  }

  int max_sector = 0; // угол макс близкий к 180
  int sector = 0; // угол первого сектора
  for (int i = 0; i &lt; n; i++) {
    if (A[i] > 180) {
      continue;
    }
    sector = A[i];
    for (int j = i + 1; j &lt;= n; j++) {
      // начать сначала если это последний кусок
      if (j == n) {
        j = 0;
      }
      // остановка если прошли круг
      if (j == i) {
        break;
      }
      // добавлять кусок пока меншье половины круга
      if (sector + A[j] &lt;= 180) {
        sector += A[j];
      } else {
        break;
      }
   }
    max_sector = max(max_sector, sector);
  }
  // разница между углами секторов
  int deg = (180 - max_sector) * 2;

  // вывод результата
  cout &lt;&lt; deg;
}
</pre>
  </details>
</article>


<!-- Задача P. Парад -->
<article class="article">
  <div class="anchor" id="task16"></div>
  <h3>Задача P. Парад</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Совсем скоро в Берляндии состоится парад победы над инопланетными захватчиками. К сожалению, в войне погибли все солдаты, и теперь армия состоит исключительно из новобранцев, многие из которых даже не знают, с какой ноги начинается марш. Гражданское население тоже плохо понимает, с какой ноги начинается марш, поэтому важно лишь, чтобы как можно больше солдат шли в одну ногу.</p>

  <p>В параде будут принимать участие n пеших колонн, i-я из которых состоит из lᵢ солдат, начинающих марш с левой ноги, и rᵢ солдат, начинающих марш с правой ноги.</p>

  <p>Красота парада вычисляется по следующей формуле: если L — это суммарное количество солдат на параде, начинающих марш с левой ноги, а R — это суммарное количество солдат на параде, начинающих марш с правой ноги, то красота будет равна |L - R|.</p>

  <p>Вы можете выбрать не более чем одну колонну, и изменить с какой ноги начинают марш все солдаты данной колонны. Формально, разрешается не более одного раза выбрать какой-то индекс i и поменять местами значения lᵢ и rᵢ.</p>

  <p>Найдите номер колонны, при смене шага в которой красота парада станет максимально возможной, или определите, что такой операцией улучшить красоту парада нельзя.</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержится одно число n (1 ≤ n ≤ 10⁵) — количество пеших колонн. В следующих n строках находятся пары целых чисел lᵢ и rᵢ (1 ≤ lᵢ, rᵢ ≤ 500) — количество солдат в i-й колонне, начинающих марш с левой и с правой ноги соответственно.</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно целое число k — номер колонны, в которой следует сменить шаг, или 0, если максимальная красота уже достигнута.</p>

  <p>Считайте, что колонны пронумерованы от 1 до n в порядке их задания во входных данных. Если решений несколько, выведите любое.</p>

  <h4>Пример 1</h4>
<pre>
3
5 6
8 9
10 3
</pre>
  <code>3</code>
  <p>В первом примере, если вы не дадите приказ какой-либо колонне сменить шаг, то количество солдат, начинающих марш с левой ноги, будет равно 5 + 8 + 10 = 23, а с правой — 6 + 9 + 3 = 18. В таком случае красота парада будет равна |23 - 18| = 5.</p>
  <p>Если вы дадите приказ сменить ногу третьей колонне, то количество солдат, марширующих с левой ноги, будет равно 5 + 8 + 3 = 16, а с правой — 6 + 9 + 10 = 25. В таком случае красота парада будет равна |16 - 25| = 9.</p>
  <p>Каким-либо другим приказом невозможно достичь большей красоты. Таким образом, максимально достижимая красота равна 9.</p>

  <h4>Пример 2</h4>
<pre>
2
6 5
5 6
</pre>
  <code>1</code>

  <h4>Пример 3</h4>
<pre>
6
5 9
1 3
4 8
4 5
23 54
12 32
</pre>
  <code>0</code>

  <details>
    <summary>Решение</summary>
    <h4>Идея решения:</h4>
    <ol>
      <li>Вычислим исходные значения L и R.</li>
      <li>Для каждой колонны вычислим, как изменится красота парада, если мы поменяем шаг в этой колонне.</li>
      <li>Найдём колонну, изменение шага в которой даст максимальное увеличение красоты.</li>
      <li>Если ни одна колонна не улучшает красоту, выводим 0.</li>
    </ol>
<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  int n; // количество колонн
  cin >> n;
  vector&lt;int&gt; AL(n);
  vector&lt;int&gt; AR(n);

  for (int i = 0; i &lt; n; i++) {
    cin >> AL[i]; // левая нога
    cin >> AR[i]; // правая нога
  }

  // решение
  int L = 0;
  int R = 0;
  int maxL = 0;
  int maxR = 0;
  int left = 0;    // кол-во с левой ноги
  int right = 0;   // кол-во с правой ноги
  int difL = 0;     // разница левых
  int difR = 0;     // разница правых
  int max_difL = 0; // макс разница левых
  int max_difR = 0; // макс разница правых
  int colL = 0;     // номер колонны с макс левых
  int colR = 0;     // номер колонны с макс правых

  for (int i = 0; i &lt; n; i++) {
    left = AL[i];
    right = AR[i];
    L += left;
    R += right;
    difL = left - right;
    difR = right - left;
    if (difL > max_difL) {
      max_difL = difL;
      colL = i;
    }
    if (difR > max_difR) {
      max_difR = difR;
      colR = i;
    }
  }
  int beaut = abs(L - R);  // красота
  maxL = L - AL[colR] + AR[colR];
  maxR = R - AR[colL] + AL[colL];

  // вывод результата
  if (maxL >= maxR) {
    if (maxL > L) {
      cout &lt;&lt; colR + 1;
    } else {
      cout &lt;&lt; 0;
    }

  } else if (maxR > maxL) {
    if (maxR > R) {
      cout &lt;&lt; colL + 1;
    } else {
      cout &lt;&lt; 0;
    }
  }
}
</pre>
  </details>

  <details>
    <summary>Вариант решения</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
using namespace std;

int main() {
    int n;
    cin >> n; // Считываем количество колонн

    vector&lt;pair&lt;int, int&gt;&gt; columns(n); // Пары (l_i, r_i) для каждой колонны
    int L = 0, R = 0; // Исходные значения L и R

    // Считываем данные и вычисляем L и R
    for (int i = 0; i &lt; n; i++) {
        cin >> columns[i].first >> columns[i].second;
        L += columns[i].first;
        R += columns[i].second;
    }

    int maxBeauty = abs(L - R); // Исходная красота парада
    int bestColumn = 0; // Номер колонны для изменения (0, если не нужно менять)

    // Перебираем все колонны и находим лучшую для изменения
    for (int i = 0; i &lt; n; i++) {
        int newL = L - columns[i].first + columns[i].second; // Новое L после изменения
        int newR = R - columns[i].second + columns[i].first; // Новое R после изменения
        int newBeauty = abs(newL - newR); // Новая красота парада

        if (newBeauty > maxBeauty) {
            maxBeauty = newBeauty;
            bestColumn = i + 1; // Нумерация колонн с 1
        }
    }

    // Выводим результат
    cout &lt;&lt; bestColumn;
    return 0;
}
</pre>
  </details>
</article>
