<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contests" target="_blank">ЯрГУ. Кружок. Школьники</a></p>
  <p><a href="https://vkvideo.ru/@sportprog_yarsu" target="_blank">vkvideo.ru/@sportprog_yarsu</a></p>
</article>


<article class="article">
  <h1>Занятие 11. Математика #1. Теория чисел. Основы</h1>
  <p>Конспект видео от 2024.11.23</p>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contest/568747" target="_blank">Codeforces Контест 568747</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
        <a href="#p1">Теория чисел</a>
    <br><a href="#t1">Задача 1. Является ли число простым</a>
    <br><a href="#t2">Задача 2. Вывести все делители числа</a>
    <br><a href="#t3">Задача 3. Вывести все простые делители числа</a>
    <br><a href="#t4">Задача 4. Решето Эратосфена</a>
    <br><a href="#t5">Задача 5. Взятие ответа по остатку</a>
  </p>
  <p>
        <a href="#task1">Задача A. ЕхАб И нОд</a>
    <br><a href="#task2">Задача B. Максимальный НОД</a>
    <br><a href="#task3">Задача C. Задача про LCM</a>
    <br><a href="#task4">Задача D. Простые делители</a>
    <br><a href="#task5">Задача E. Надо побольше</a>
    <br><a href="#task6">Задача F. Решето Эратосфена</a>
    <br><a href="#task7">Задача G. Простые числа easy</a>
    <br><a href="#task8">Задача H. Простые числа</a>
    <br><a href="#task9">Задача I. Коровки и первообразные корни</a>
    <br><a href="#task10">Задача J. Целые точки отрезка</a>
    <br><a href="#task11">Задача K. Никогда не спрашивайте даму о возрасте</a>
    <br><a href="#task12">Задача L. Почти простые числа</a>
    <br><a href="#task13">Задача M. Пары чисел</a>
    <br><a href="#task14">Задача N. Мишка и покер</a>
    <br><a href="#task15">Задача O. Мила и шоколад</a>
    <br><a href="#task16">Задача P. Разложение на множители</a>
    <br><a href="#task17">Задача Q. Прямоугольная игра</a>
    <br><a href="#task18">Задача R. Эпическая игра</a>
  </p>
</article>


<!-- Теория чисел -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Теория чисел</h3>

  <p>Все натуральные числа делятся на три непересекающиеся категории: простые, составные и 1.</p>

  <h4>Простое число</h4>
  <p><strong>Простое число</strong> - натуральной число, имеющее ровно два различных натуральных делителя. Простое число отлично от 1 и делится без остатка только на 1 и на само себя.</p>
  <code>Примеры: 2, 3, 7, 11, 967, 1004911, 1000000007</code>

  <h4>Составное число</h4>
  <p><strong>Составное число</strong> - натуральное число, имеющее делители, отличные от 1 и самого себя. Каждое составное число является произведением двух или более натуральных чисел., больше 1.</p>
  <code>Примеры: 4, 6, 10, 15, 625</code>

  <h4>Решето Эратосфена</h4>
  <p><strong>Решето Эратосфена</strong> перебирает все числа от 1 до n и оставляет только простые числа.</p>

  <h4>НОД</h4>
  <p>НОД - наибольший общий делитель.</p>

  <h4>НОК</h4>
  <p>НОК - наименьшее общее кратное.</p>
  <code>НОК(a, b) = a * b / НОД(a, b);</code>
  <p>Чтобы не выйти за пределы типа данных, лучше сначала разделить, а потом умножить</p>
  <code>НОК(a, b) = a / НОД(a, b) * b;</code>

  <h4>Рекурентное соотношение</h4>
  <p>Найдем aᵖ - возведем число a в степень p. a и p - целые числа. </p>
<pre>
long long res = 1;
for (int i = 0; i &lt; p; i++) {
  res *= a;
}
cout &lt;&lt; res;
</pre>
  <p>Это можно сделать быстрее. Запишем число p в двоичном виде</p>
  <code>p = c1c2c3c4...ck</code>
  <p>В массив B запишем степени числа a</p>
  <code>B[0] = 1, B[1] = a, B[2] = a², B[3] = a⁴, B[4] = a⁸;</code>
  <p>Вычислим значение 2¹². Представим число p = 12 в двоичном виде</p>
  <code>12₁₀ = 1100₂</code>
  <p>Заполним массив B степенями значения a = 2</p>
  <code>B[0] = 1, B[1] = 2, B[2] = 4, B[3] = 16, B[4] = 256</code>

  <h4>Малая теорема Ферма</h4>
  <p>Если a и p целые числа и a не делится на p, тогда верно утверждение, что aᵖ⁻¹ - 1 делится на p</p>

  <p>Остаток от деления</p>
  <p>Чтобы найти остаток от деления числа aᵏ на p, нужно изменить формулу aᵏ % p, потому что при вычислении aᵏ можно выйти за пределы типа данных.</p>
  <code>(((a % p) * a % p) * a % p) ...</code>
</article>


<!-- Задача 1. Является ли число простым -->
<article class="article">
  <div class="anchor" id="t1"></div>
  <h3>Задача 1. Является ли число простым</h3>

  <p>Проверить число на простоту. Является ли число n простым. Проверим линейным алгоритмом O(n)</p>

  <details>
    <summary>Решение за O(n)</summary>
<pre>
int n;
cin >> n;
int count = 0;

for (int i = 1; i &lt;= n; i++) {
  if (n % i == 0) {
    count++;
  }
}

if (count == 2) {
  cout &lt;&lt; "YES";
} else {
  cout &lt;&lt; "NO";
}
</pre>
  </details>

  <p>Оптимизируем алгоритм. Заметим, что если число n является составным, то его можно представить в виде произведения n = a * b, где будет выполняться неравенства a ≤ sqrt(n) и sqrt(n) ≤ b. Воспользуемся этим свойством и будем проверять до корня от числа.</p>

  <details>
    <summary>Решение</summary>
<pre>
int n;
cin >> n;
int count = 0;

for (int i = 2; i &lt;= sqrt(n); i++) { // плохо
  if (n % i == 0) {
    count++;
  }
}

if (count == 0) {
  cout &lt;&lt; "YES";
} else {
  cout &lt;&lt; "NO";
}
</pre>
  </details>

  <p>Улучшим реализацию отказавшись от операции sqrt(n).</p>
  <details>
    <summary>Решение</summary>
<pre>
int n;
cin >> n;
int count = 0;

for (long long i = 2; i * i &lt;= n; i++) { // хорошо
  if (n % i == 0) {
    count++;
  }
}

if (count == 0) {
  cout &lt;&lt; "YES";
} else {
  cout &lt;&lt; "NO";
}
</pre>
  </details>
</article>


<!-- Задача 2. Вывести все делители числа -->
<article class="article">
  <div class="anchor" id="t2"></div>
  <h3>Задача 2. Вывести все делители числа</h3>

  <p>Вывести все делители числа в порядке возрастания. Сделаем наивную реализацию за O(n)</p>

  <details>
    <summary>Решение за O(n)</summary>
<pre>
int n;
cin >> n;

for (int i = 1; i &lt;= n; i++) {
  if (n % i == 0) {
    cout &lt;&lt; i &lt;&lt; " ";
  }
}
</pre>
  </details>

  <p>Улучшим реализацию. Будем бежать до sqrt(n) и сразу же будем определять пару делителей.</p>

  <details>
    <summary>Решение</summary>
<pre>
int n;
cin >> n;
vector&lt;int&gt;A;

for (long long i = 1; i * i &lt;= n; i++) {
  if (n % i == 0) {
    A.push_back(i);
    if (i * i != n) {
      A.push_back(n / i);
    }
  }
}

sort(A.begin(), A.end());
for (int i = 0; i &lt; A.size(); i++) {
  cout &lt;&lt; A[i] &lt;&lt; " ";
}
</pre>
  </details>
</article>


<!-- Задача 3. Вывести все простые делители числа -->
<article class="article">
  <div class="anchor" id="t3"></div>
  <h3>Задача 3. Вывести все простые делители числа</h3>

  <p>Разложить число n на простые множители. В цикле for начинаем с i=2. Будем делить число n на 2 до тех пор, пока оно делится на 2. Таким образом мы удаляем из n все делители равные 2,4,8 и т.д.Дальше i=3 и так мы удалим все простые делители из n от 2 до sqrt(n). Каждую итерацию выводим найденное простое число, пока n не станет равно 1 или не закончится цикл. Если цикл закончился, а n не равно 1, значит у нас остался еще один простой делитель и мы его тоже должны вывести.</p>

  <details>
    <summary>Решение</summary>
<pre>
int n;
cin >> n;

for (long long i = 2; i * i &lt;= n; i++) {
  while (n % i == 0) {
    cout &lt;&lt; i;
    n /= i;
    if (n != 1) {
      cout &lt;&lt; '*';
    }
  }
}

if (n != 1) {
  cout &lt;&lt; n;
}
</pre>
  </details>
</article>


<!-- Задача 4. Решето Эратосфена -->
<article class="article">
  <div class="anchor" id="t4"></div>
  <h3>Задача 4. Решето Эратосфена</h3>

  <p>Реализуем алгоритм решето Эратосфена. Алгоритм находит все простые числа от 1 до n.</p>

  <h4>Решение</h4>
  <p>Заводим вектор A для всех чисел от 0 до n. Числа 0 и 1 не являются простыми, поэтому сразу инициализируем их единицей. </p>
  <p>В конце вектор A будет состоят из 0 и 1. Если A[i] = 0, то i является простым числом. Если A[i] = 1, то это число или 0 или 1 или составное.</p>
  <p>Если в цикле for нашли простое число, то заходим во внутренний цикл for и вычеркиваем (A[i]=1) все числа, которые делятся на это простое число.</p>

  <details>
    <summary>Решение</summary>
<pre>
int n;
cin >> n;

vector&lt;int&gt;A(n + 1);
A[0] = 1;
A[1] = 1;

for (int i = 2; i &lt;= n; i++) {
  if (A[i] == 0) {
    for (int j = 2 * i; j &lt;= n; j += i) {
      A[j] = 1;
    }
  }
}
</pre>
  </details>

  <p>Приведем немного улучшенную реализацию алгоритма Решето Эратосфена. Трудоемкость алгоритма O(n * log2(n)).</p>
  <p>Внутренний цикл for начнем не с j = 2*i, а с j = i*i. Это уменьшит количество итераций</p>

  <details>
    <summary>Решение</summary>
<pre>
int n;
cin >> n;

vector&lt;int&gt;A(n + 1);
vector&lt;int&gt;B;
A[0] = 1;
A[1] = 1;

for (long long i = 2; i &lt;= n; i++) {
  if (A[i] == 0) {
    B.push_back(i);
    for (long long j = i * i; j &lt;= n; j += i) {
      A[j] = 1;
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача 5. Взятие ответа по остатку -->
<article class="article">
  <div class="anchor" id="t5"></div>
  <h3>Задача 5. Взятие ответа по остатку</h3>

  <p>Рассмотрим задачу, где нам необходимо найти произведение целых чисел и выдать результат по остатку от числа mod.</p>
  <p>Наивное решение это найти произведение чисел, а потом результат взять по остатку:</p>
  <code>(a₁ * a₂ * a₃ * a₄ * ... * aₙ) % mod</code>
  <p>К сожалению при перемножении чисел мы можем выйти за пределы типов данных.</p>
  <p>Заметим, что любое число можно представить в виде n = k * mod + h, где 0 ≤ h ≤ mod.</p>
  <p>Для того, чтобы не выходить за типы данных при перемножении, мы можем брать остаток после каждого умножения:</p>
  <code>(((...(a₁ % mod) * a₂ % mod) * a₃ % mod) * a₄ % mod) * ... * aₙ) % mod</code>
</article>


<!-- Задача A. ЕхАб И нОд -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. ЕхАб И нОд</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам дано целое положительное число x. Найдите любые такие два 2  целые положительные числа a и b, для которых НОД(a,b) + НОК(a,b)= x.</p>

  <p>Напомним, что НОД(a,b) — это наибольшее целое число, на которое делятся и a и b. Аналогично, НОК(a,b) - это наименьшее целое число, которое делится и на a и на b.</p>

  <p>Гарантируется, что решение всегда существует. Если существует несколько таких пар (a,b), вы можете вывести любую из них.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно целое число t (1 ≤ t ≤ 100) — количество наборов тестовых данных.</p>

  <p>Каждый набор тестовых данных состоит из одной строки, содержащей одно целое число, x (2 ≤ x ≤ 10⁹).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора тестовых данных, выведите пару целых положительных чисел a и b (1 ≤ a, b ≤ 10⁹)  таких, что НОД(a,b) + НОК(a,b)=x. Гарантируется, что решение всегда существует. Если существует несколько таких пар (a,b), вы можете вывести любую из них.</p>

  <details>
    <summary>Пример</summary>
<pre>
2
2
14
</pre>
<pre>
1 1
6 4
</pre>
    <p>В первом наборе тестовых данных примера,  НОД(1,1) + НОК(1,1) = 1+1=2</p>
    <p>Во втором наборе тестовых данных примера, НОД(6,4) + НОК(6,4) = 2+12=14</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1325/problem/A" target="_blank">Задача 1325A</a>
      <br><a href="https://codeforces.com/contest/1325" target="_blank">Codeforces Round 628 (Div. 2) 2020-03-14</a>
    </div>

    <p>Нужно поисидеть и аккуратно повыписывать примеры для небольших x, чтобы понять какие бывают ответы. В качестве ответа подходят числа 1 и x-1.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // количество тестов
  int t;
  cin >> t;

  for (int test = 0; test &lt; t; test++) {
    // ввод данных
    int x;
    cin >> x;

    // решение и вывод результата
    cout &lt;&lt; 1 &lt;&lt; " " &lt;&lt; x - 1 &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача B. Максимальный НОД -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Максимальный НОД</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Рассмотрим все целые числа в промежутке от 1 до n (включительно).</p>

  <p>По всем парам различных целых чисел из этого промежутка, найдите максимальное возможное значение наибольшего общего делителя чисел в паре. Более формально, найдите максимальное значение gcd(a,b) по всем 1 ≤ a &lt; b ≤ n.</p>

  <p>Наибольшим общим делителем gcd(a,b) пары положительных целых чисел a и b называется наибольшее целое число, являющееся делителем числа a и делителем числа b.</p>

  <h4>Входные данные</h4>
  <p>В первой строке находится единственное целое число t (1 ≤ t ≤ 100)  — количество наборов входных данных. Описание наборов входных данных следует.</p>

  <p>В единственной строке описания каждого набора входных данных находится единственное целое число n (2 ≤ n ≤10<sup>6</sup>).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных, выведите максимальное значение gcd(a,b) по всем 1 ≤ a &lt; b ≤ n.</p>

  <details>
    <summary>Пример</summary>
<pre>
2
3
5
</pre>
<pre>
1
2
</pre>
    <p>В первом наборе входных данных  gcd(1,2)=gcd(2,3)=gcd(1,3)=1</p>
    <p>Во втором наборе входных данных 2 является максимальным возможным значением, соответствующим gcd(2,4).</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1370/problem/A" target="_blank">Задача 1370A</a>
      <br><a href="https://codeforces.com/contest/1370" target="_blank">Codeforces Round 651 (Div. 2) 2020-06-20</a>
    </div>

    <p>Максимальный НОД для пары чисел (a, b) будет максимальным числом d, для которого существует хотя бы два числа в диапазоне от 1 до n, делящиеся на d. Для каждого входного числа n, ответом будет n / 2, округленное вниз (целочисленное деление).</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // количество тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n;
    cin >> n;

    // решение
    int res = n / 2;

    // вывод результата
    cout &lt;&lt; res &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача C. Задача про LCM -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Задача про LCM</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Пусть LCM(x,y) — наименьшее положительное целое число, которое делится и на x, и на y. Например, LCM(13,37)=481, LCM(9,6)=18.</p>

  <p>Вам даны два числа l и r. Найдите два целых числа x и y, для которых выполняются условия: l≤x&lt;y≤r и l≤LCM(x,y)≤r.</p>

  <h4>Входные данные</h4>
  <p>В первой строке задано одно целое число t (1≤t≤10000) — количество наборов входных данных.</p>

  <p>Каждый набор входных данных задается одной строкой, содержащей два целых числа l и r (1≤l&lt;r≤10⁹).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите два целых числа:</p>
  <ul>
    <li>если невозможно найти удовлетворяющие условиям числа x и y, два раза выведите -1;</li>
    <li>иначе выведите значения x и y (если существует несколько возможных решений, выведите любое из них).</li>
  </ul>

  <details>
    <summary>Пример</summary>
<pre>
4
1 1337
13 69
2 4
88 89
</pre>
<pre>
6 7
14 21
2 4
-1 -1
</pre>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1389/problem/A" target="_blank">Задача 1389A</a>
      <br><a href="https://codeforces.com/contest/1389" target="_blank">Educational Codeforces Round 92 (рейтинговый для Див. 2) 2020-07-29</a>
    </div>

    <p>LCM это НОК (наименьшее общее кратное). Условие для x и y</p>
    <code>l≤ x&lt; y ≤ LCM(x,y) ≤ r.</code>
    <p>Решение шуточное. Мы предполагаем, что если выбрать x = l, а y = 2 * l, то НОК(x, y) = 2 * l. Тогда должно выполняться 2 * l &le; r. Расстояние между левой и правой границей должно быть r - l > l. Иначе НОК(x, y) > r и ответа не будет.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int t;
  cin >> t;

  for (int test = 0; test &lt; t; test++) {
    int l, r;
    cin >> l >> r;

    // решение
    if (2 * l &lt;= r) {
      cout &lt;&lt; l &lt;&lt; " " &lt;&lt; 2 * l &lt;&lt; '\n';
    } else {
      cout &lt;&lt; "-1 -1\n";
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача D. Простые делители -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Простые делители</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Все просто: вам дается число, и вы должны вывести все его простые делители.</p>

  <h4>Входные данные</h4>
  <p>В единственной строке единственное число a (1 ≤ a ≤ 10<sup>15</sup>).</p>

  <h4>Выходные данные</h4>
  <p>Вывести через пробел в единственной строке в порядке возрастания все простые делители числа без повторений.</p>

  <details>
    <summary>Пример</summary>
    <code>22</code>
    <code>2 11</code>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  long long a;
  cin >> a;

  // решение и вывод результата
  long long rep = 1;
  for (long long i = 2; i * i &lt;= a; i++) {
    while (a % i == 0) {
      // проверка на повторение
      if (i != rep) {
        rep = i;
        cout &lt;&lt; i &lt;&lt; ' ';
      }
      a /= i;
    }
  }

  // если осталось простое число
  if (a != 1) {
    cout &lt;&lt; a;
  }
}
</pre>
  </details>
</article>


<!-- Задача E. Надо побольше -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Надо побольше</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Дан массив чисел, необходимо вывести наибольший среди всех НОД попарных комбинаций чисел массива и наибольший среди всех НОК попарных комбинаций чисел массива.</p>

  <h4>Входные данные</h4>
  <p>В первой строке n - количество чисел массива (2 ≤ n ≤ 10<sup>3</sup>). Во второй строке через пробел записаны числа массива не превосходящие 10<sup>9</sup>.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке через пробел выведите 2 числа - ответ на вопрос.</p>

  <details>
    <summary>Пример</summary>
<pre>
2
5 6
</pre>
    <code>30 1</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Перебираем все возможные пары чисел в массиве, вычисляем для каждой пары НОД и НОК, обновляем максимальные значения. Это решение эффективно для ограничений задачи (n ≤ 10^3), так как количество пар составляет около 500,000, что вполне допустимо для 2 секунд.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

// Функция для вычисления НОД двух чисел (алгоритм Евклида)
int gcd(int a, int b) {
  while (a != 0 && b != 0) {
    if (a > b) {
      a = a % b;
    } else {
      b = b % a;
    }
  }
  return a + b;
}

// Функция для вычисления НОК двух чисел
int lcm(int a, int b) {
  if (a == 0 || b == 0) {
    return 0;
  }
  return (a / gcd(a, b)) * b;
}

int main() {
  // ввод данных
  int n;
  cin >> n;
  vector&lt;int&gt; nums(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> nums[i];
  }

  // решение
  int max_gcd = 0;
  int max_lcm = 0;

  // Перебираем все пары чисел
  for (int i = 0; i &lt; n; i++) {
    for (int j = i + 1; j &lt; n; j++) {

      // текущий НОД
      int current_gcd = gcd(nums[i], nums[j]);

      // обновляем максимальный НОД
      if (current_gcd > max_gcd) {
        max_gcd = current_gcd;
      }

      // текущий НОК
      int current_lcm = lcm(nums[i], nums[j]);

      // обновляем максимальный НОК
      if (current_lcm > max_lcm) {
        max_lcm = current_lcm;
      }
    }
  }

  // вывод результата
  cout &lt;&lt; max_lcm &lt;&lt; ' ' &lt;&lt; max_gcd;
}
</pre>
  </details>
</article>


<!-- Задача F. Решето Эратосфена -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Решето Эратосфена</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Ваша задача реализовать Решето Эратосфена и вывести все простые числа в диапазоне от 2 до N</p>

  <h4>Входные данные</h4>
  <p>Вводится единственное число 2 ≤ N ≤ 10<sup>5</sup></p>

  <h4>Выходные данные</h4>
  <p>Выведите все простые числа в диапазоне от 2 до N в порядке возрастания через пробел</p>

  <details>
    <summary>Пример</summary>
    <code>2</code>
    <code>2</code>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // входные данные
  int n;
  cin >> n;

  // решение
  vector&lt;int&gt; A(n + 1, 0); // все числа от 0 до n
  vector&lt;int&gt; S; // простые числа от 2 до n

  // решето Эратосфена
  for (long long i = 2; i &lt;= n; i++) {
    if (A[i] == 0) {
      S.push_back(i);
      A[i] = 1;
      for (long long j = i * i; j &lt;= n; j += i) {
        A[j] = 1;
      }
    }
  }

  // вывод результата
  for (int i = 0; i &lt; S.size(); i++) {
    cout &lt;&lt; S[i] &lt;&lt; ' ';
  }

  return 0;
}
</pre>
  </details>
</article>


<!-- Задача G. Простые числа easy -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Простые числа easy</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Необходимо вывести все простые числа от M до N включительно.</p>

  <h4>Входные данные</h4>
  <p>В единственной строке записаны два натуральных числа M и N, разделенных пробелом (2 ≤ M ≤ N ≤ 10<sup>5</sup>)</p>

  <h4>Выходные данные</h4>
  <p>Выведите все простые числа от M до N в порядке возрастания, по одному в строке. Если таковых чисел нет, то следует вывести -1</p>

  <details>
    <summary></summary>
    <h4>Пример 1</h4>
    <code>2 5</code>
<pre>
2
3
5
</pre>

    <h4>Пример 2</h4>
    <code>4 4</code>
    <code>-1</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Собиракем Решето Эратосфена и выбираем из него числа от m до n.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // входные данные
  int m, n;
  cin >> m >> n;

  // решение
  vector&lt;int&gt; A(n + 1, 0);
  // вектор простых чисел
  vector&lt;int&gt; S;

  // решето Эратосфена
  for (long long i = 2; i &lt;= n; i++) {
    if (A[i] == 0) {
      A[i] = 1;
      for (long long j = i * i; j &lt;= n; j += i) {
        A[j] = 1;
      }
      if (i >= m) {
        S.push_back(i);
      }
    }
  }

  // вывод результата
  if (S.empty()) {
    cout &lt;&lt; -1;
  } else {
    for (int i = 0; i &lt; S.size(); i++) {
      cout &lt;&lt; S[i] &lt;&lt; '\n';
    }

  }

  return 0;
}
</pre>
  </details>
</article>


<!-- Задача H. Простые числа -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Простые числа</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Необходимо вывести все простые числа от M до N включительно.</p>

  <h4>Входные данные</h4>
  <p>В единственной строке записаны два натуральных числа M и N, разделенных пробелом (2 ≤ M ≤ N ≤ 5·10<sup>6</sup>)</p>

  <h4>Выходные данные</h4>
  <p>Выведите все простые числа от M до N в порядке возрастания, по одному в строке. Если таковых чисел нет, то следует вывести -1</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>2 5</code>
<pre>
2
3
5
</pre>

    <h4>Пример 2</h4>
    <code>4 4</code>
    <code>-1</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Собиракем Решето Эратосфена и выбираем из него числа от m до n.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // входные данные
  int m, n;
  cin >> m >> n;

  // решение
  vector&lt;int&gt; A(n + 1, 0);
  // вектор простых чисел
  vector&lt;int&gt; S;

  // решето Эратосфена
  for (long long i = 2; i &lt;= n; i++) {
    if (A[i] == 0) {
      A[i] = 1;
      for (long long j = i * i; j &lt;= n; j += i) {
        A[j] = 1;
      }
      if (i >= m) {
        S.push_back(i);
      }
    }
  }

  // вывод результата
  if (S.empty()) {
    cout &lt;&lt; -1;
  } else {
    for (int i = 0; i &lt; S.size(); i++) {
      cout &lt;&lt; S[i] &lt;&lt; '\n';
    }

  }

  return 0;
}
</pre>
  </details>
</article>


<!-- Задача I. Коровки и первообразные корни -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача I. Коровки и первообразные корни</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Коровки только что узнали, что такое первообразный корень! Вам дано простое число p, первообразный корень mod p — целое число x (1 ≤ x &lt; p), такое, что ни одно из целых чисел x - 1, x<sup>2</sup> - 1, ..., x<sup>p-2</sup> - 1 не делится на p, при этом число x<sup>p-1</sup> - 1 делится на p.</p>

  <p>К сожалению, на вычисление первообразных корней уходит много времени, так что коровкам нужна Ваша помощь. Вам дано простое число p, помогите коровкам найти количество первообразных корней mod p.</p>

  <h4>Входные данные</h4>
  <p>Во входных данных содержится единственная строка, в которой записано целое число p (2 ≤ p &lt; 2000). Гарантируется, что p является простым числом.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите количество первообразных корней mod p.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>3</code>
    <code>1</code>
    <p>Единственный первообразный корень mod 3 — 2</p>

    <h4>Пример 2</h4>
    <code>5</code>
    <code>2</code>
    <p>Первообразные корни mod 5 — 2 и 3.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/284/problem/A" target="_blank">Задача 284A</a>
      <br><a href="https://codeforces.com/contest/284" target="_blank">Codeforces Round 174 (Div. 2) 2013-03-17</a>
    </div>

    <p>Первообразным корнем по модулю n (primitive root modulo n) называется такое число g, что все его степени по модулю n пробегают по всем числам, взаимно простым с n. Математически это формулируется таким образом: если g является первообразным корнем по модулю n, то для любого целого a такого, что gcd(a,n)=1, найдётся такое целое k, что g<sup>k</sup> ≡ a (mod n).</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

// Функция для вычисления НОД двух чисел (алгоритм Евклида)
int gcd(int a, int b) {
  while (a != 0 && b != 0) {
    if (a > b) {
      a = a % b;
    } else {
      b = b % a;
    }
  }
  return a + b;
}

int main() {
  // ввод данных
  int p;  // простое число от 2 до 2000
  cin >> p;

  // решение
  int cnt = 0; // число первообразных корней
  for (int i = 1; i &lt; p; i++) {
    if (gcd(p - 1, i) == 1) {
      cnt++;
    }
  }

  // вывод результата
  cout &lt;&lt; cnt;
}
</pre>
  </details>
</article>


<!-- Задача J. Целые точки отрезка -->
<article class="article">
  <div class="anchor" id="task10"></div>
  <h3>Задача J. Целые точки отрезка</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Требуется написать программу, которая вычислит, сколько всего точек с целочисленными координатами принадлежат отрезку.</p>

  <h4>Входные данные</h4>
  <p>Даны четыре целых числа – координаты концов отрезка (x<sub>1</sub>,y<sub>1</sub>) и (x<sub>2</sub>,y<sub>2</sub>). Каждая из координат не превышает по абсолютной величине значения 1000.</p>

  <h4>Выходные данные</h4>
  <p>Требуется вывести количество точек отрезка, имеющих целочисленные координаты.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>1 0 5 0</code>
    <code>5</code>

    <h4>Пример 2</h4>
    <code>-1 -2 2 4</code>
    <code>4</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>dx и dy представляют разности координат концов отрезка по осям x и y. Наибольший общий делитель dx и dy определяет, сколько промежуточных точек с целыми координатами существует между начальной и конечной точками отрезка. Количество таких точек равно cnt+1, так как включаются обе конечные точки.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;cmath&gt;

using namespace std;

// Функция для вычисления НОД двух чисел (алгоритм Евклида)
int gcd(int a, int b) {
  while (a != 0 && b != 0) {
    if (a > b) {
      a = a % b;
    } else {
      b = b % a;
    }
  }
  return a + b;
}

int main() {
  // ввод данных
  int x1, y1, x2, y2;
  cin >> x1 >> y1 >> x2 >> y2;

  // решение
  int dx = abs(x2 - x1);
  int dy = abs(y2 - y1);
  int cnt = gcd(dx, dy);

  // вывод результата
  cout &lt;&lt; cnt + 1;
}
</pre>
  </details>
</article>


<!-- Задача K. Никогда не спрашивайте даму о возрасте -->
<article class="article">
  <div class="anchor" id="task11"></div>
  <h3>Задача K. Никогда не спрашивайте даму о возрасте</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Миссис Литл любит цифры больше всего на свете. Каждый год она пытается составить лучшее число года. Она пытается стать всё более и более эрудированной, и каждый год изучает новую цифру, так что число, которое она составляет, записано в системе счисления, база которой равна возрасту миссис Литл. Чтобы сделать свою жизнь ещё более прекрасной, она пишет только числа, которые делятся на её возраст без единицы. Миссис Литл хочет держать свой возраст в секрете.</p>

  <p>Вам дано число, состоящее из цифр 0, …, 9 и латинских букв A, …, Z, где A равно 10, B равно 11 и так далее. Ваша задача — найти минимальное число k, удовлетворяющее следующему условию: заданное число, записанное в k-ичной системе счисления делится на k - 1.</p>

  <h4>Входные данные</h4>
  <p>Ввод состоит из одной строки, содержащей не более 10<sup>6</sup> цифр или заглавных латинских букв.</p>

  <h4>Выходные данные</h4>
  <p>Вывод должен содержать единственное число k или строку "No solution", если для любых 2 ≤ k ≤ 36 описанное ранее условие не выполняется. Кстати, ответ нужно писать в десятичном виде.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>123</code>
    <code>4</code>

    <h4>Пример 2</h4>
    <code>SOLVEMEPLS</code>
    <code>No solution</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>В любой системе счисления с основанием k число делится на k-1 тогда и только тогда, когда сумма его цифр в этой системе счисления делится на k-1. Это аналогично правилу делимости на 9 в десятичной системе (где 9 — это 10-1). Для заданного основания k все цифры числа должны быть меньше k.</p>
    <p>Сначала находим максимальное значение цифры dmax в заданном числе. Минимально возможное основание k должно быть не меньше dmax+1.</p>
    <p>Для каждого k от max(dmax+1,2) до 36 вычисляем сумму цифр числа, интерпретированного в системе счисления с основанием k. Проверяем, делится ли эта сумма на k-1. Первое k, для которого это условие выполняется, является ответом.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

// определяем цифру
int getDigitValue(char c) {
  if (c >= '0' && c &lt;= '9') {
    return c - '0';
  } else if (c >= 'A' && c &lt;= 'Z') {
    return 10 + (c - 'A');
  }
  return 0; // не должно произойти по условию задачи
}

int main() {
  // ввод данных
  string s;
  cin >> s;

  // решение
  // находим максимальную цифру
  int max_digit = 0;
  for (char c : s) {
    int d = getDigitValue(c);
    if (d > max_digit) {
      max_digit = d;
    }
  }

  // находи минимальную систему счисления
  // для максимальной цифры
  int start_k = max_digit + 1;
  if (start_k &lt; 2) {
    start_k = 2;
  }

  // перебираем системы счисления
  for (int k = start_k; k &lt;= 36; k++) {
    int sum = 0;
    for (char c : s) {
      int d = getDigitValue(c);
      sum += d;
    }
    if (sum % (k - 1) == 0) {
      cout &lt;&lt; k &lt;&lt; endl;
      return 0;
    }
  }

  // нет ответа
  cout &lt;&lt; "No solution" &lt;&lt; endl;
}
</pre>
  </details>
</article>


<!-- Задача L. Почти простые числа -->
<article class="article">
  <div class="anchor" id="task12"></div>
  <h3>Задача L. Почти простые числа</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Число называется почти простым, если оно имеет ровно два различных простых делителя. Например, числа 6, 18, 24 являются почти простыми, а 4, 8, 9, 42 — не являются. Найдите количество почти простых чисел от 1 до n включительно.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входного файла записано число n (1 ≤ n ≤ 3000).</p>

  <h4>Выходные данные</h4>
  <p>Выведите количество почти простых чисел от 1 до n включительно.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>10</code>
    <code>2</code>

    <h4>Пример 2</h4>
    <code>21</code>
    <code>8</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/26/problem/A" target="_blank">Задача 26A</a>
      <br><a href="https://codeforces.com/contest/26" target="_blank">Codeforces Beta Round 26 (Codeforces format) 2010-08-16</a>
    </div>

    <p>Переберем все числа от 1 до 3000 и найдем для них простые делители. Применим решето Эратосфена. Заведем вектор A для хранения решета Эратосфена. Будем записывать 1 если число не простое, 0 если простое.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;

  vector&lt;int&gt; A(n + 1);
  A[0] = 1;
  A[1] = 1;

  // собираем решето Эратосфена
  for (int i = 2; i &lt;= n; i++) {
    if (A[i] == 0) {
      for (int j = 2 * i; j &lt;= n; j += i) {
        A[j] = 1;
      }
    }
  }

  // решение
  int res = 0;
  for (int i = 2; i &lt;= n; i++) {
    int count = 0;
    for (int j = 2; j &lt; A.size(); j++) {
      if (A[j] == 0) {
        if (i % j == 0) {
          count++;
        }
      }
    }
    if (count == 2) {
      res++;
    }
  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача M. Пары чисел -->
<article class="article">
  <div class="anchor" id="task13"></div>
  <h3>Задача M. Пары чисел</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Допустим, мы имеем пару чисел (a, b). Мы можем получить новую пару чисел вида (a + b, b) или (a, a + b) из данной. Назовем такое действие шагом.</p>

  <p>Пусть начальная пара чисел — (1,1). Ваша задача — найти число k, наименьшее количество шагов, необходимых чтобы получить из (1,1) пару, в которой хотя бы одно число равно n.</p>

  <h4>Входные данные</h4>
  <p>Входные данные содержат единственное целое число n (1 ≤ n ≤ 10<sup>6</sup>).</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное число k.</p>

  <details>
    <summary></summary>
    <h4>Пример 1</h4>
    <code>5</code>
    <code>3</code>

    <h4>Пример 2</h4>
    <code>1</code>
    <code>0</code>
    <p>Из пары (1,1) можно за три хода получить пару, содержащую 5: (1,1) → (1,2) → (3,2) → (5,2).</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/134/problem/B" target="_blank">Задача 134B</a>
      <br><a href="https://codeforces.com/contest/134" target="_blank">Codeforces Testing Round 3 2011-11-30</a>
    </div>

<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

long long cnt;

long long gcd(long long a, long long b) {
  if (b == 0) {
    if (a != 1) {
      cnt += 1'000'000;
    }
    cnt += a - 1;
    return a;
  } else {
    cnt += a / b;
    return gcd(b, a % b);
  }
}

int main() {
  long long n;
  cin >> n;
  long long min_count = 10'000'000;
  for (long long i = 1; i &lt; n; i++) {
    cnt = 0;
    gcd(n, i);
    min_count = min(min_count, cnt);
  }
  if (min_count == 10'000'000) {
    cout &lt;&lt; 0;
    return 0;
  }

  cout &lt;&lt; min_count - 1;
}
</pre>
  </details>
</article>


<!-- Задача N. Мишка и покер -->
<article class="article">
  <div class="anchor" id="task14"></div>
  <h3>Задача N. Мишка и покер</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Лимак — старый бурый медведь. Он любит играть в покер со своими друзьями, для чего они часто ходят в ближайшее казино.</p>

  <p>За столом сидят n игроков (включая Лимака), которые уже сделали какие-то ставки. i-й игрок поставил ai долларов.</p>

  <p>Каждый игрок может удвоить или утроить свою ставку произвольное количество раз (может быть, и удвоить, и утроить). В казино есть специальное условие о джекпоте в случае, если ставки всех игроков становятся равны. Могут ли Лимак и его друзья выиграть джекпот?</p>

  <h4>Входные данные</h4>
  <p>В первой строке входного файла записано целое число n (2 ≤ n ≤ 10<sup>5</sup>), количество игроков.</p>

  <p>Во второй строке записано n целых чисел a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> (1 ≤ a<sub>i</sub> ≤ 10<sup>9</sup>) — ставки игроков.</p>

  <h4>Выходные данные</h4>
  <p>Выведите "Yes" (без кавычек), если игроки смогут сделать все ставки равными, или "No" в противном случае.</p>

  <details>
    <summary></summary>
    <h4>Пример 1</h4>
<pre>
4
75 150 75 50
</pre>
    <code>Yes</code>
    <p>В первом тесте первый и третий игроки должны дважды удвоить свои ставки, второй игрок должен удвоить свою ставку один раз, а четвертый игрок должен удвоить и утроить свою ставку.</p>

    <h4>Пример 2</h4>
<pre>
3
100 150 250
</pre>
    <code>No</code>
    <p>Можно показать, что во втором тесте невозможно сделать все ставки равными.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/573/problem/A" target="_blank">Задача 573А</a>
      <br><a href="https://codeforces.com/contest/573" target="_blank">Codeforces Round 318 [RussianCodeCup Thanks-Round] (Div. 1) 2015-08-29</a>
    </div>

    <h4>Пример 3</h4>
    <pre>
    4
    7 14 21 28
    </pre>
      <code>Yes</code>

    <p>Основная теорема арифметики: Любое целое положительное число, большее 1, можно единственным образом представить в виде произведения простых чисел, взятых в определенных степенях. Это означает, что для любого числа n>1 существует единственное представление вида</p>
    <code>2ᵃ·3ᵇ·5ᶜ·7ᵈ·....</code>
    <p>По условию задачи, ставки можно только удваивать и утраивать. Все ставки смогут стать одинаковыми только в том случае, если начальные ставки состоят поделить на произведения степеней двойки и тройки и получить одинаковый остаток.</p>
    <p>Проверим, что все числа делятся на 2 и 3 с одинаковым остатком и выведем ответ.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  bool d23 = 1; // делится на 2 и 3
  int b = -1;   // остаток после деления на 2 и 3

  for (int i = 0; i &lt; n; i++) {

    while (A[i] % 2 == 0) {
      A[i] /= 2;
    }

    while (A[i] % 3 == 0) {
      A[i] /= 3;
    }

    if (b != -1 && b != A[i]) {
      // не делится на 2 и 3
      // с одинаковым остатком
      d23 = 0;
    }

    b = A[i]; // остаток от деления на 2 и 3
  }

  // вывод результата
  if (d23) {
    cout &lt;&lt; "Yes";
  } else {
    cout &lt;&lt; "No";
  }
}
</pre>
  </details>
</article>


<!-- Задача O. Мила и шоколад -->
<article class="article">
  <div class="anchor" id="task15"></div>
  <h3>Задача O. Мила и шоколад</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Маленькой Миле дали задачу. У неё есть n досок, пронумерованных целыми числами от 1 до n. Она должна покрасить их странным образом.</p>

  <p>Непокрашенная доска может быть покрашены в красный цвет, если её номер делится на число a, а также может быть покрашена в синий цвет, если её номер делится на число b. Таким образом, доска номер которой делится на a и на b может быть покрашена как в красный, так и в синий цвет.</p>

  <p>После покраски она получит p шоколадок за каждую доску красного цвета и q шоколадок за каждую доску синего цвета.</p>

  <p>Обратите внимание, что она может красить доски в любом порядке.</p>

  <p>Помогите Миле найти наибольшее количество шоколадок, которые она может получить.</p>

  <h4>Входные данные</h4>
  <p>Единственная строка содержит пять целых чисел n, a, b, p и q (1 ≤ n, a, b, p, q ≤ 10⁹).</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно целое число s — наибольшее количество шоколадок, которые может получить Мила.</p>

  <p>Обратите внимание, что ответ может не поместиться в 32-битном типе данных. Для сохранения числа вы можете использовать, например, тип long long в языке C++ или тип long в языке Java.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>5 2 3 12 15</code>
    <code>39</code>

    <h4>Пример 2</h4>
    <code>20 2 3 3 5</code>
    <code>51</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/678/problem/C" target="_blank">Задача 678C</a>
      <br><a href="https://codeforces.com/contest/678" target="_blank">Educational Codeforces Round 13 2016-06-13</a>
    </div>

    <p>Посчитаем два результата и выберем из них больший. res1 для досок покрашенных в красный цвет и res2 - в синий, среди тех что могут быть покрашени и в красный и в синий.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

long long gcd(long long a, long long b) {
  while (a > 0 && b > 0) {
    if (a > b) {
      a = a % b;
    } else {
      b = b % a;
    }
  }
  return a + b;
}

int main() {
  // ввод данных
  long long n, a, b, p, q;
  cin >> n >> a >> b >> p >> q;

  // решение
  long long nok = a * b / gcd(a, b);
  long long res1 = p * (n / a) + q * (n / b - n / nok);
  long long res2 = p * (n / a - n / nok) + q * (n / b);

  // вывод результата
  cout &lt;&lt; max(res1, res2);
}
</pre>
  </details>
</article>


<!-- Задача P. Разложение на множители -->
<article class="article">
  <div class="anchor" id="task16"></div>
  <h3>Задача P. Разложение на множители</h3>

  <div><i>Ограничение по времени 3с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам дано целое положительное число n. Выведите его разложение на простые множители.</p>

  <p>Если n = a<sub>1</sub><sup>b<sub>1</sub></sup> a<sub>2</sub><sup>b<sub>2</sub></sup> ... a<sub>k</sub><sup>b<sub>k</sub></sup> (b<sub>i</sub> > 0), где a<sub>k</sub> — простые числа, то вывод программы должен выглядеть следующим образом: a<sub>1</sub>*...*a<sub>1</sub>*a<sub>2</sub>*...*a<sub>2</sub>*...*a<sub>k</sub>*...*a<sub>k</sub>, где множители упорядочены в порядке неубывания, и каждый множитель a<sub>i</sub> указан b<sub>i</sub> раз.</p>

  <h4>Входные данные</h4>
  <p>Единственная строка входных данных содержит целое число n (2 ≤ n ≤ 10000).</p>

  <h4>Выходные данные</h4>
  <p>Выведите разложение числа n на простые множители в формате, описанном выше.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>245</code>
    <code>5*7*7</code>

    <h4>Пример 2</h4>
    <code>19</code>
    <code>19</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/162/problem/C" target="_blank">Задача 162C</a>
      <br><a href="https://codeforces.com/contest/162" target="_blank">VK Cup 2012 Уайлд-кард раунд 1 2012-03-17</a>
    </div>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  int n; // число от 2 до 10000
  cin >> n;

  // решение
  vector&lt;int&gt; Res;
  for (int i = 2; i &lt;= n; i++) {
    while (n % i == 0) {
      Res.push_back(i);
      n /= i;
    }
  }

  // вывод результата
  for (int i = 0; i &lt; Res.size() - 1; i++) {
    cout &lt;&lt; Res[i] &lt;&lt; '*';
  }
  cout &lt;&lt; Res[Res.size() - 1];
}
</pre>
  </details>
</article>


<!-- Задача Q. Прямоугольная игра -->
<article class="article">
  <div class="anchor" id="task17"></div>
  <h3>Задача Q. Прямоугольная игра</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Умный Бобер из ABBYY решил устроить себе выходной. Но бездельничать целый день оказалось слишком скучно, и он решил поиграть в игру с камешками. Изначально у Бобра есть n камешков. Он раскладывает их в a одинаковых рядов по b штук в каждом (a > 1). Учтите, что Бобер обязательно использует все камешки, то есть n = a·b.</p>

  <p>После того, как он разложил камешки, Умный Бобер забирает обратно любой из полученных рядов (то есть b камешков) и выбрасывает все остальные камешки. Затем он снова раскладывает все свои камешки (выбирая, возможно, другие a и b) и снова забирает себе один ряд, и так далее. Игра продолжается до тех пор, пока в какой-то момент у Бобра не останется ровно один камешек.</p>

  <p>Игровой процесс можно представить себе как конечную последовательность целых чисел c<sub>1</sub>, ..., c<sub>k</sub>, где:</p>
  <ul>
    <li>c<sub>1</sub> = n</li>
    <li>c<sub>i</sub> + 1 — количество камешков, которые останутся у Бобра после i-ого хода, то есть количество камешков в ряду некоторого разложения c<sub>i</sub> камешков (1 ≤ i &lt; k). Заметим, что c<sub>i</sub> > c<sub>i+1</sub>.</li>
    <li>c<sub>k</sub> = 1</li>
  </ul>

  <p>Результатом игры называется сумма чисел ci. Вам дано число n. Найдите максимальный возможный результат игры.</p>

  <h4>Входные данные</h4>
  <p>Единственная строка входных данных содержит единственное целое число n — начальное количество камешков у Умного Бобра.</p>

  <p>Ограничения на входные данные для получения 30 баллов:</p>
  <code>2 ≤ n ≤ 50</code>

  <p>Ограничения на входные данные для получения 100 баллов:</p>
  <code>2 ≤ n ≤ 10<sup>9</sup></code>

  <h4>Выходные данные</h4>
  <p>Выведите единственное целое число — максимальный возможный результат игры.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>10</code>
    <code>16</code>
    <p>Рассмотрим первый пример (c<sub>1</sub> = 10). Возможные варианты развития игры:</p>
    <ul>
      <li>Можно разложить камешки в 10 рядов по одному в каждом. Тогда c<sub>2</sub> = 1, и игра закончится после первого же хода с результатом 11.</li>
      <li>Можно разложить камешки в 5 рядов по два камешка в каждом. Тогда c<sub>2</sub> = 2, и игра продолжается. На втором ходе 2 камешка можно разложить единственным способом (помните, что выкладывать все камешки в один ряд нельзя!) — в 2 ряда по одному камешку. c<sub>3</sub> = 1, и игра закончится с результатом 13.</li>
      <li>Наконец, можно разложить камешки в 2 ряда по пять камешков. Аналогичными рассуждениями получим c<sub>2</sub> = 5, c<sub>3</sub> = 1, и игра закончится с результатом 16 — максимальным из возможных.</li>
    </ul>

    <h4>Пример 2</h4>
    <code>8</code>
    <code>15</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/177/problem/B2" target="_blank">Задача 177B2</a>
      <br><a href="https://codeforces.com/contest/177" target="_blank">ABBYY Cup 2.0 - Easy 2012-04-29</a>
    </div>

<pre>
  #include &lt;iostream&gt;

    using namespace std;

    int main() {
      // ввод данных
      int n;
      cin >> n;

      // решение
      int res = n;

      for (int i = 2; i * i &lt;= n; i++) {
        while (n % i == 0) {
          n /= i;
          res += n;
        }
      }

      if (n > 1) {
        res++;
      }

      // вывод результата
      cout &lt;&lt; res;
    }
</pre>
  </details>
</article>


<!-- R. Эпическая игра -->
<article class="article">
  <div class="anchor" id="task18"></div>
  <h3>Задача R. Эпическая игра</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Семен и Антисемен играют в игру. Изначально каждому игроку дано одно фиксированное целое положительное число, которое не меняется в процессе игры. Семену дано число a, Антисемену дано число b. Также у них есть кучка из n камней. Игроки ходят по очереди, первый ход делает Семен. На своем ходу игрок должен взять из кучки число камней, равное наибольшему общему делителю данного ему числа и количества оставшихся камней в кучке. Проигрывает тот, кто не сможет взять требуемое число камней (по причине того, что в кучке остается строго меньше камней, чем нужно взять).</p>

  <p>Ваша задача — по заданным a, b и n определить, кто выиграет в этой игре.</p>

  <h4>Входные данные</h4>
  <p>В единственной строке через пробел записаны целые числа a, b и n (1 ≤ a, b, n ≤ 100) — числа, данные Семену и Антисемену соответственно, и исходное количество камней в кучке.</p>

  <h4>Выходные данные</h4>
  <p>Если выиграет Семен, выведите «0» (без кавычек), иначе выведите «1» (без кавычек).</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>3 5 9</code>
    <code>0</code>
    <p>Наибольшим общим делителем двух неотрицательных целых чисел a и b называется такое наибольшее положительное целое число k, что a делится на k без остатка, и, аналогично, b делится на k без остатка. Обозначим через gcd(a, b) операцию вычисления наибольшего общего делителя чисел a и b. В частности, gcd(x, 0) = gcd(0, x) = x.</p>

    <p>В первом примере игра будет идти следующим образом:</p>
    <ol>
      <li>Семен должен взять из кучки gcd(3, 9) = 3 камня. После его хода в кучке остается 6 камней.</li>
      <li>Антисемен должен взять из кучки gcd(5, 6) = 1 камень. После его хода в кучке остается 5 камней.</li>
      <li>Семен должен взять из кучки gcd(3, 5) = 1 камень. После его хода в кучке остается 4 камня.</li>
      <li>Антисемен должен взять из кучки gcd(5, 4) = 1 камня. После его хода в кучке остается 3 камня.</li>
      <li>Семен должен взять из кучки gcd(3, 3) = 3 камня. После его хода в кучке остается 0 камней.</li>
      <li>Антисемен должен взять из кучки gcd(5, 0) = 5 камня. Так как 0 &lt; 5, это сделать невозможно, и Антисемен проигрывает.</li>
    </ol>

    <h4>Пример 2</h4>
    <code>1 1 100</code>
    <code>1</code>
    <p>Во втором примере каждый игрок на каждом ходу берет из кучки по одному камню. Так как n четное, последний камень возьмет Антисемен, а Семен после этого не сможет сделать ход.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/119/problem/A" target="_blank">Задача 119A</a>
      <br><a href="https://codeforces.com/contest/119" target="_blank">Codeforces Beta Round 90 2011-10-14</a>
    </div>

    <p>Напишем функцию gcd и смоделируем ход игры</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

// наибольший общий делитель
long long gcd(long long a, long long b) {
  while (a > 0 && b > 0) {
    if (a > b) {
      a = a % b;
    } else {
      b = b % a;
    }
  }
  return a + b;
}

int main() {
  // ввод данных
  long long a, b, n;
  cin >> a >> b >> n;

  // решение
  long long cnt = 0;
  while (n != 0) {
    if (cnt == 0) {
      n -= gcd(a, n);
      cnt = (cnt + 1) % 2;
    } else {
      n -= gcd(b, n);
      cnt = (cnt + 1) % 2;
    }
  }

  // вывод результата
  cout &lt;&lt; (cnt + 1) % 2;
}
</pre>
  </details>
</article>

