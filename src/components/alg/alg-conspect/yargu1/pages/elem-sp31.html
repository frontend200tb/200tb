<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p>ЯрГУ. Кружок. Школьники 2024/2025</p>
  <p><a href="https://vkvideo.ru/@sportprog_yarsu" target="_blank">vkvideo.ru/@sportprog_yarsu</a></p>
</article>


<article class="article">
  <h1>Занятие 31 Алгоритмы #7. Интерактивные задачи</h1>
  <p>Конспект видео от 2025.05.03</p>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contest/607871" target="_blank">Codeforces Контест 607871</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
    <a href="#p1">Алгоритмы #7. Интерактивные задачи</a>
  </p>
  <p>
        <a href="#task1">Задача A. Is it rated - 2</a>
    <br><a href="#task2">Задача B. AquaMoon и украденная строка</a>
    <br><a href="#task3">Задача C. Медвежонок и простота за 100</a>
    <br><a href="#task4">Задача D. Lost Numbers</a>
    <br><a href="#task5">Задача E. Восстановление массива</a>
    <br><a href="#task6">Задача F. Flamingoes of Mystery</a>
    <br><a href="#task7">Задача G. Найти наибольшее (простая версия)</a>
    <br><a href="#task8">Задача H. Угадай K-й ноль (простая версия)</a>
    <br><a href="#task9">Задача I. Шоколадный заяц</a>
    <br><a href="#task10">Задача J. Из машины</a>
    <br><a href="#task11">Задача K. Андрюша и Python</a>
    <br><a href="#task12">Задача L. Невозможно угадать</a>
    <br><a href="#task13">Задача M. Ближе к звездам</a>
    <br><a href="#task14">Задача N. Интервью</a>
    <br><a href="#task15">Задача O. Не всё так многозначно</a>
    <br><a href="#task16">Задача P. Строчечка</a>
  </p>
</article>


<!-- Алгоритмы #7. Интерактивные задачи -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Алгоритмы #7. Интерактивные задачи</h3>

  <p>Интерактивные задачи используют своеобразный способ ввода вывода информации, не более того. Нет специальных алгоритмов для решения интерактивных задач.</p>
  <p>Для тестирующей системы неважно как вы выводите результат: на каждый тест свой вывод или после всех тестов один вывод результата.</p>
  <p>Архив всех задач хранится отдельно от codeforces на системе polygon.</p>
  <p>Для того чтобы автор задачи корректно сформировал тесты, используется сторонняя программа validator.</p>
  <p>Обязательно вместе с условием задачи существует авторское решение.</p>
  <p>На codeforces одновременно запускается два решения - ваше решение и решение автора. Происходит сверка ответов вашего решения и решения автора.</p>
  <p>На яндекс.контесте нет авторского решения, но есть готовые ответы. Происходит сверка ответов вашего решения и готовых ответов.</p>
  <p>Есть checker. Формат стандартного чекера это сверка вашего решения и авторского решения. Насколько они совпадают между собой. Для интерактивный задач используется не стандартный чекер, для того чтобы можно было изменить формат ввода вывода информации. Такой чекер усложняет обычый процесс. Вместо того чтобы был один input файл и один output файл, добавляется мессенджер общения.</p>
  <p>Из системы к нам на вход приходит i-ое сообщение, на которое мы должны ответить i-ым ответом. Так происходит общение между нами и тестирующей системой.</p>
  <p>Условия интерактивных задач всегда очень большие.</p>
  <p>Для интерактивных задач нельзя делать ускорение ввода вывода.</p>
</article>


<!-- Задача A. Is it rated - 2 -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Is it rated - 2</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <h4>Протокол взаимодействия</h4>
  <p>Эта задача - интерактивная. Вы можете прочитать задаваемые вопросы из стандартного потока ввода, и выводить свои ответы в стандартный поток вывода. Количество вопросов неизвестно заранее, так что вам придется обрабатывать их по мере их поступления, пока вы не достигнете конца файла.</p>

  <p>В каждом запросе вам зададут один вопрос, записанный в одной строке. Вы должны ответить на него правильно, терпеливо и без эмоций. Ваш ответ обрабатывается без учета регистра.</p>

  <p>Пожалуйста, используйте оператор flush после каждого запроса, чтобы не оставить часть запроса в буфере.</p>

  <h4>Пример</h4>
<pre>
Is it rated?
Is it rated?
Is it rated?
</pre>
<pre>
NO
NO
NO
</pre>
</article>


<!-- Задача B. AquaMoon и украденная строка -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. AquaMoon и украденная строка</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У AquaMoon было n строк длины m каждая. n — нечетное число.</p>

  <p>Когда AquaMoon отошла, Cirno попыталась разбить эти n строк на пары. После того, как она сделала (n-1) / 2 пару, она обнаружила, что осталась ровно одна строка без пары!</p>

  <p>В гневе она перемешала каждую пару строк. Для каждой пары она выбрала некоторые позиции (хотя бы 1 и не более, чем m) и обменяла символы в двух строках этой пары на выбранных позициях.</p>

  <p>Например, если m=6 и две строки «abcdef» и «xyzklm» в одной паре и Cirno выбрала позиции 2, 3 и 6 она поменяет 'b' с 'y', 'c' с 'z' и 'f' с 'm'. В результате строки станут «ayzdem» и «xbcklf».</p>

  <p>Затем Cirno украла строку, оставшуюся без пары, и расположила все оставшиеся строки в некотором порядке.</p>

  <p>AquaMoon обнаружила оставшуюся n-1 строку в полном беспорядке. Также, она помнит изначальные n строк. Она хочет узнать, какую строку украли, но она не очень хороша в программировании. Можете ли вы помочь ей?</p>

  <h4>Входные данные</h4>
  <p>Эта задача сделана как интерактивная. Это означает, что ваше решение будет считывать входные данные, которые вывел интерактор. Однако, интерактор выведет полные входные данные в начале, и после этого вы должны будете вывести ответ. Поэтому вы должны решать задачу так, как если бы вы решали обычную, не интерактивную задачу, потому что у вас не будет никакого процесса взаимодействия. Единственная вещь, про которую вы не должны забыть — это сбросить буфер выходного потока после вывода ответа. Иначе ваше решение может получить вердикт «Решение «зависло»». Обратитесь к руководству по интерактивным задачам для более детальной информации про сброс буфера выходного потока.</p>

  <p>Каждый тест состоит из нескольких наборов входных данных. В первой строке находится единственное целое число t (1 ≤ t ≤ 100) — количество наборов входных данных.</p>

  <p>В первой строке описания каждого набора входных данных содержится два целых числа n, m (1 ≤ n ≤ 10⁵, 1 ≤ m ≤ 10⁵) — количество строк и длина каждой строки, соответственно.</p>

 <p>Следующие n строк каждая содержат строку длины m, описывающую изначальные n строк. Все строки состоят из символов латинского алфавита в нижнем регистре.</p>

  <p>Следующая n-1 строка каждая содержит строку длины m, описывающую строки, после того, как Cirno сделала обмены и переставила их.</p>

  <p>Гарантируется, что n нечетно и что сумма n⋅m по всем наборам входных данных не превосходит 10⁵.</p>

  <h4>Формат теста для взлома:</h4>

  <p>В первой строке должно находиться единственное целое число t. После этого должно следовать описание t наборов входных данных в следующем формате:</p>

  <p>В первой строке должно находиться два целых числа n и m.</p>

  <p>В следующих n строках должны быть записаны n строк длины m, описывающих изначальные строки.</p>

  <p>Следующие (n-1) / 2 строк должны описывать пары. Каждая должна содержать в следующем порядке: индекс первой строки i (1 ≤ i ≤ n), индекс второй строки j (1 ≤ j ≤ n, i ≠ j), количество позиций для обмена k (1 ≤ k ≤ m) и список из k позиций, в которых будет сделан обмен (k различных индексов от 1 до m в любом порядке).</p>

  <p>В последней строке должна находиться перестановка из целых чисел от 1
  до n, описывающая способ, которым строки будут перемешаны. Строки будут расположены в том порядке, в котором индексы следуют в перестановке, индекс украденной строки при этом будет пропущен.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите украденную строку в единственной строке.</p>

  <h4>Пример</h4>
<pre>
3
3 5
aaaaa
bbbbb
ccccc
aaaaa
bbbbb
3 4
aaaa
bbbb
cccc
aabb
bbaa
5 6
abcdef
uuuuuu
kekeke
ekekek
xyzklm
xbcklf
eueueu
ayzdem
ukukuk
</pre>
<pre>
ccccc
cccc
kekeke
</pre>
  <p>В первом наборе входных данных в строках «aaaaa» и «bbbbb» обменяли все позиции и «ccccc» является украденной строкой.</p>

  <p>Во втором наборе входных данных в строках «aaaa» и «bbbb» обменяли первые две позиции и «cccc» является украденной строкой.</p>

  <p>Это первый тест, записанный в формате для взломов:</p>
<pre>
3
3 5
aaaaa
bbbbb
ccccc
1 2 5 1 2 3 4 5
2 1 3
3 4
aaaa
bbbb
cccc
1 2 2 1 2
2 1 3
5 6
abcdef
uuuuuu
kekeke
ekekek
xyzklm
1 5 3 2 3 6
2 4 3 2 4 6
5 4 1 2 3
</pre>

  <details>
    <summary>Решение</summary>
    <p>Эта задача не интерактивная. Для входных строк нужно определить частоту символа в каждой позиции. Если в перемешанных строках не будет какого-то символа, то строка содержащая этот символ будет результатом.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    int n, m;
    cin >> n >> m;
    // в английском алфавите 26 букв
    vector&lt;vector&lt;int&gt; &gt; Count_elem(m, vector&lt;int&gt;(26));
    string s;

    for (int i = 0; i &lt; n; i++) {
      cin >> s;
      for (int j = 0; j &lt; m; j++) {
        Count_elem[j][s[j] - 'a']++;
      }
    }

    for (int i = 0; i &lt; n - 1; i++) {
      cin >> s;
      for (int j = 0; j &lt; m; j++) {
        Count_elem[j][s[j] - 'a']--;
      }
    }

    for (int j = 0; j &lt; m; j++) {
      for (int step = 0; step &lt; 26; step++) {
        if (Count_elem[j][step] != 0) {
          cout &lt;&lt; (char)('a' + step);
        }
      }
    }

    cout &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача C. Медвежонок и простота за 100 -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Медвежонок и простота за 100</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Это интерактивная задача. В формате выходных данных вы найдёте информацию о том, как сбрасывать буфер вывода (делать операцию 'flush').</p>

  <p>Медвежонок Лимак загадывает некоторое целое число в интервале [2, 100]. Вам необходимо определить, является ли загаданное число простым или составным.</p>

  <p>Целое число x > 1 называется простым, если у него есть ровно два различных делителя, 1 и x. Если целое число x > 1 не является простым, оно называется составным.</p>

  <p>Вы можете сделать до 20 запросов о делителях загаданного числа. Каждый запрос — это одно целое число в интервале [2, 100]. Проверяющая программа выведет «yes», если целое число из запроса является делителем загаданного числа, и «no» в противном случае.</p>

  <p>Например, если загадано число 14, то проверяющая программа выведет «yes» только для запросов 2, 7 или 14.</p>

  <p>Когда вы закончите задавать вопросы, выведите «prime» (если считаете, что загаданное число простое) или «composite» (если считаете, что загаданное число составное), сделайте операцию 'flush' и завершите работу программы.</p>

  <p>Вы получите вердикт Wrong Answer, если сделаете больше 20 запросов о делителях или если ваша программа выведет число не из интервала [2, 100]. Разумеется, вы получите вердикт Wrong Answer, если неправильно определите тип загаданного числа.</p>

  <p>Вы получите вердикт Idleness Limit Exceeded, если не будете ничего выводить (а тестирующая программа будет ожидать ввода) или забудете сделать операцию 'flush' после какого-нибудь вывода (смотри ниже).</p>

  <h4>Входные данные</h4>
  <p>После каждого запроса требуется считать одну строку из входных данных (стандартный ввод). Эта строка будет «yes» (без кавычек), если выведенное число является делителем загаданного, и «no» (без кавычек) в противном случае.</p>

  <h4>Выходные данные</h4>
  <p>Не более 20 раз вы можете сделать запрос — вывести целое число в диапазоне [2, 100] в одной строке. Обязательно требуется вывести перевод строки и сделать операцию 'flush'. После сброса буфера необходимо считать ответ на запрос из входных данных.</p>

  <p>В любой момент можно перестать делать запросы и вывести «prime» (без кавычек) или «composite» (без кавычек). После этого требуется сделать 'flush' и завершить программу.</p>

  <p>Для сброса буфера вывода (то есть для операции 'flush') сразу после вывода числа или ответа и перевода строки можно сделать:</p>
  <ul>
    <li>fflush(stdout) в языке C++;</li>
    <li>System.out.flush() в Java;</li>
    <li>stdout.flush() в Python;</li>
    <li>flush(output) в Pascal;</li>
    <li>смотрите документацию для других языков.</li>
  </ul>

  <p>Взломы. Чтобы совершить взлом, вам требуется указать загаданное число — одно целое число в интервале [2, 100]. Разумеется, у взламываемого решения не будет возможности прочитать это число из входных данных.</p>

  <h4>Пример 1</h4>
<pre>
yes
no
yes
</pre>
<pre>
2
80
5
composite
</pre>

  <h4>Пример 2</h4>
<pre>
no
yes
no
no
no
</pre>
<pre>
58
59
78
78
2
prime
</pre>
  <p>Ниже приведён пример протокола общения для первого и второго примеров.</p>

  <p>В первом примере Лимак загадал число 30.</p>

<pre>
solution  system
   2        yes
  80         no
   5        yes
composite
</pre>
  <p>Загаданное число делится на 2 и 5, следовательно, является составным. Обратите внимание, что не требуется точно угадывать загаданное число.</p>

  <p>Во втором примере Лимак загадал число 59.</p>
<pre>
solution  system
  58         no
  59        yes
  78         no
  78         no
   2         no
prime
</pre>
  <p>Число 59 является делителем загаданного числа, но в интервале [2, 100] есть только одно число с таким делителем, и оно является простым. Обратите внимание, что ответ известен уже после второго запроса, но не запрещается продолжать спрашивать (если при этом не превышается лимит на 20 запросов).</p>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // решение
  vector&lt;int&gt; A(150);

  // решето эратосфена
  for (int i = 2; i &lt; 150; i++) {
    if (A[i] == 0) {
      for (int j = 2 * i; j &lt; A.size(); j += i) {
        A[j] == 1;
      }
    }
  }

  int k = 0;
  string s;
  for (int i = 2; i &lt; 50; i++) {
    if (A[i] == 0)
    {
      cout &lt;&lt; i &lt;&lt; "\n";
      fflush(stdout);
      cin >> s;
      if (s == "yes") {
        k++;
        if (i * i &lt; 100) {
          cout &lt;&lt; i * i &lt;&lt; "\n";
          fflush(stdout);
          cin >> s;
          if (s == "yes") {
            k++;
          }
        }
      }
    }
  }

  // вывод результата
  if (k &lt; 2) {
    cout &lt;&lt; "prime";
  } else {
    cout &lt;&lt; "composite";
  }
}
</pre>
  </details>
</article>


<!-- Задача D. Lost Numbers -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Lost Numbers</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Это интерактивная задача. Не забывайте о том, что ваша программа должна каждый раз после вывода запроса сбрасывать буфер вывода. Для сброса буфера вывода можно использовать fflush(stdout) в C++, system.out.flush() в Java, stdout.flush() в Python или flush(output) в Pascal. Если вы используете другой язык программирования, посмотрите в его документации, как выполняется эта операция. Также рекомендуем вам прочесть руководство по интерактивным задачам: https://codeforces.com/blog/entry/45307.</p>

  <p>Жюри загадало некоторый массив a, состоящий из 6 чисел. Существуют 6 особых чисел — 4, 8, 15, 16, 23, 42 — и каждое из них встречается в массиве a ровно один раз (то есть a — некоторая перестановка этих чисел).</p>

  <p>Вы не знаете ничего о их порядке в массиве, но вы можете отправить до 4 запросов. В каждом запросе вы выбираете два индекса i и j (1≤i,j≤6, i и j не обязательно должны быть различны), и в ответ вы получите значение ai⋅aj.</p>

  <p>Можете ли вы отгадать массив a?</p>

  <p>Массив a в каждом тесте фиксирован заранее, тестирующая программа не пытается адаптировать его в зависимости от ваших запросов.</p>

  <h4>Протокол взаимодействия</h4>
  <p>До того, как ваша программа даст ответ на задачу, она может отправить до 4 запросов. Чтобы задать запрос, выведите одну строку следующего вида: ? i j, где i и j должны быть двумя целыми числами, удовлетворяющими условию 1 ≤ i, j ≤ 6. Строка, которую вы отправляете, должна заканчиваться символом перевода строки. После отправки запроса программа должна сбросить буфер вывода и прочитать ответ на запрос — строку, содержащую одно целое число ai⋅aj. Если вы отправите некорректный запрос (или отправите более 4 запросов), ответом будет строка 0. Если ваша программа получила такой ответ, она должна немедленно завершиться — иначе вы можете получить вердикт «Ошибка исполнения», «Превышено ограничение времени» или какой-нибудь другой, а не «Неправильный ответ».</p>

  <p>Чтобы дать ответ на задачу, ваша программа должна отправить строку ! a1 a2 a3 a4 a5 a6 с символом перевода строки в конце. После этого она должна сбросить буфер вывода и завершиться.</p>

  <h4>Пример 1</h4>
<pre>
16
64
345
672
</pre>
<pre>
? 1 1
? 2 2
? 3 5
? 4 6
! 4 8 15 16 23 42
</pre>
  <p>Если вы хотите отправить взлом по этой задаче, ваш тест должен содержать ровно шесть целых чисел a1, a2, ..., a6, разделенных пробелами. Каждое из 6 особых чисел должно встречаться в тесте ровно один раз. Тест должен заканчиваться символом конца строки.</p>
</article>


<!-- Задача E. Восстановление массива -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Восстановление массива</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Это интерактивная задача. Вам нужно использовать операцию flush после вывода каждого запроса. Например, в C++ вы должны использовать функцию fflush(stdout), в Java — использовать System.out.flush(), а в Паскале — flush(output).</p>

  <p>В этой задаче вам надо восстановить массив, который заранее вам неизвестен. Вы можете считать, что жюри загадало некоторый массив a, про который вам известна только его длина n.</p>

  <p>Единственное допустимое действие — узнать сумму пары элементов, указав их индексы i и j (индексы должны быть различными). В результате запроса для индексов i и j вы получите сумму ai + aj.</p>

  <p>Известно, что восстановить весь загаданный массив можно не более чем за n запросов. Напишите программу, которая восстановит загаданный жюри массив a длины n за не более чем n запросов на сумму двух элементов (в каждом запросе индексы двух элементов должны быть различны).</p>

  <h4>Протокол взаимодействия</h4>
  <p>Каждый тест в этой задаче состоит из одного массива, который ваша программа должна восстановить.</p>

  <p>В первой строке входных данных следует целое положительное число n (3 ≤ n ≤ 5000) — длина загаданного массива. В первую очередь ваша программа должна прочитать это число.</p>

  <p>Далее ваша программа должна выводить в стандартный вывод запросы на сумму двух элементов массива, либо сообщить о том, что загаданный жюри массив уже найден.</p>

  <p>В случае, если программа осуществляет запрос на сумму, то следует вывести строку вида «? i j» (i и j — различные целые числа от 1 до n) — индексы элементов массива, сумму которых ваша программа запрашивает. В случае, если программа сообщает восстановленный массив, то следует вывести строку вида «! a1 a2 ... an» (гарантируется, что все ai в правильно восстановленном массиве — положительные целые числа и не превосходят 10⁵), где ai равно числу, стоящему в массиве в позиции i. Результатом запроса на сравнение является единственное целое число, равное ai + aj.</p>

  <p>Для массива длины n ваша программа должна сделать не более n запросов на сумму. Обратите внимание, что вывод строки вида «! a1 a2 ... an» не считается запросом и не учитывается при подсчете их количества.</p>

  <p>Не забывайте использовать операцию flush после каждой выведенной строки.</p>

  <p>После вывода ответа ваша программа должна завершиться.</p>

  <h4>Пример</h4>
<pre>
5

9

7

9

11

6

</pre>
<pre>
? 1 5

? 2 3

? 4 1

? 5 2

? 3 4

! 4 6 1 5 5
</pre>
  <p>Вы можете взламывать, задавая тесты следующего вида:</p>
  <ul>
    <li>в первой строке должно быть записано целое число n (3 ≤ n ≤ 5000) — длина массива,</li>
    <li>во второй строке должны быть записаны целые числа a1, a2, ..., an (1 ≤ ai ≤ 10⁵) — элементы загаданного массива.</li>
  </ul>
</article>


<!-- Задача F. Flamingoes of Mystery -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Flamingoes of Mystery</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>This is an interactive problem. You have to use a flush operation right after printing each line. For example, in C++ you should use the function fflush(stdout), in Java — System.out.flush(), in Pascal — flush(output) and in Python — sys.stdout.flush().</p>

  <p>Mr. Chanek wants to buy a flamingo to accompany his chickens on his farm. Before going to the pet shop, Mr. Chanek stops at an animal festival to have fun. It turns out there is a carnival game with a flamingo as the prize.</p>

  <p>There are N mysterious cages, which are numbered from 1 to N. Cage i has Ai (0 ≤ Ai ≤ 10³) flamingoes inside (1 ≤ i ≤ N). However, the game master keeps the number of flamingoes inside a secret. To win the flamingo, Mr. Chanek must guess the number of flamingoes in each cage.</p>

  <p>Coincidentally, Mr. Chanek has N coins. Each coin can be used to ask once, what is the total number of flamingoes inside cages numbered L to R inclusive? With L &lt; R.</p>

  <h4>Input</h4>
  <p>Use standard input to read the responses of your questions.</p>

  <p>Initially, the judge will give an integer N (3 ≤ N ≤ 10³), the number of cages, and the number of coins Mr. Chanek has.</p>

  <p>For each of your questions, the jury will give an integer that denotes the number of flamingoes from cage L to R inclusive.</p>

  <p>If your program does not guess the flamingoes or ask other questions, you will get "Wrong Answer". Of course, if your program asks more questions than the allowed number, your program will get "Wrong Answer".</p>

  <h4>Output</h4>
  <p>To ask questions, your program must use standard output.</p>

  <p>Then, you can ask at most N questions. Questions are asked in the format "? L R", (1 ≤ L &lt; R ≤ N).</p>

  <p>To guess the flamingoes, print a line that starts with "!" followed by N integers where the i-th integer denotes the number of flamingo in cage i. After answering, your program must terminate or will receive the "idle limit exceeded" verdict. You can only guess the flamingoes once.</p>

  <h4>Пример</h4>
<pre>
6

5

15

10

</pre>
<pre>

? 1 2

? 5 6

? 3 4

! 1 4 4 6 7 8
</pre>
  <p>In the sample input, the correct flamingoes amount is [1,4,4,6,7,8].</p>
</article>


<!-- Задача G. Найти наибольшее (простая версия) -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Найти наибольшее (простая версия)</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Единственная разница в легкой и сложной версии это ограничение на количество запросов.</p>

  <p>Это интерактивная задача.</p>

  <p>Есть массив a из n различных чисел. За один запрос вы можете узнать позицию второго максимума на подотрезке a[l..r]. Найдите позицию максимального элемента в массиве за не более чем 40 запросов.</p>

  <p>Подотрезком a[l..r] называются все элементы al,al+1,...,ar. После запроса этого подотрезка на ввод вы получите позицию второго максимума из этого подотрезка во всём массиве.</p>

  <h4>Входные данные</h4>
  <p>В первой строке находится единственное целое число n (2 ≤ n ≤ 10⁵) — число элементов в массиве.</p>

  <h4>Протокол взаимодействия</h4>
  <p>Вы можете делать запросы посредством вывода «? l r» (1≤l &lt; r≤n). Ответом будет выведена позиция второго максимума среди элементов al,al+1,…,ar. Массив a заранее зафиксирован и не может быть изменен во время интеракции.</p>

  <p>Вы можете вывести ответ, выведя «! p», где p — индекс максимального элемента во всем массиве.</p>

  <p>Вы можете сделать не более 40 запросов. Вывод ответа не считается за запрос.</p>

  <p>После вывода запроса не забудьте вывести перевод строки и сбросить буфер вывода. В противном случае вы получите вердикт Решение «зависло». Для сброса буфера используйте:</p>
  <ul>
    <li>fflush(stdout) или cout.flush() в C++;</li>
    <li>System.out.flush() в Java;</li>
    <li>flush(output) в Pascal;</li>
    <li>stdout.flush() в Python;</li>
    <li>смотрите документацию для других языков.</li>
  </ul>

  <h4>Взломы</h4>

  <p>Для того, чтобы сделать взлом, используйте следующий формат теста.</p>

  <p>В первой строке выведите одно целое число n (2 ≤ n ≤ 10⁵). Во второй строке выведите перестановку n целых чисел от 1 до n. Позиция числа n в перестановке и будет позицией максимума.</p>

  <h4>Пример</h4>
<pre>
5

3

4

</pre>
<pre>
? 1 5

? 4 5

! 1
</pre>
  <p>В примере представьте, что a это [5,1,4,2,3]. Так, после запроса подотрезка [1..5] элемент со значением 4 является вторым по значению и стоит на позиции 3. После запроса подтрезка [4..5] элемент со значением 2 является вторым по значению и стоит на позиции 4 во всём массиве.</p>
  <p>Заметьте, что существуют другие массивы a, для которых интеракция выглядит точно также, а ответ может быть другим. Пример вывода дан для понимания интеракции.</p>
</article>


<!-- Задача H. Угадай K-й ноль (простая версия) -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Угадай K-й ноль (простая версия)</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Это интерактивная задача.</p>

  <p>Это простая версия задачи. Отличия от сложной версии состоят в том, что в простой версии t=1 и количество запросов ограничено числом 20.</p>

  <p>Поликарп играет в компьютерную игру. В этой игре загадан массив, состоящий из нулей и единиц. Поликарп выиграет, если t раз угадает позицию k-го слева нуля.</p>

  <p>Поликарп может сделать не более 20 запросов следующего вида:</p>
  <ul>
    <li>? l r — узнать сумму всех элементов на позициях от l до r (1 ≤ l ≤ r ≤ n) включительно.</li>
  </ul>

  <p>В этой (простой) версии задачи этот параграф не имеет смысла, так как всегда t=1. Чтобы игра была более интересной, каждый угаданный ноль превращается в единицу и игра продолжается на измененном массиве. Более формально, если позиция k-го нуля равнялась x, тогда после того, как Поликарп угадает эту позицию, x-й элемент массива заменится с 0 на 1. Конечно, эта особенность на что-либо влияет только при t>1.</p>

  <p>Помогите Поликарпу выиграть в игру.</p>

  <h4>Протокол взаимодействия</h4>
  <p>Сначала ваша программа должна считать два целых числа n и t (1 ≤ n ≤ 2⋅10⁵, t = 1).</p>

  <p>Далее следуют t строк, каждая из которых содержит одно целое число k (1 ≤ k ≤ n). Гарантируется, что в момент запроса в массиве есть хотя бы k нулей. Для того, чтобы получить следующее значение k, вы должны вывести ответ для текущего значения k.</p>

  <p>После этого вы можете сделать не более 20 запросов.</p>

  <p>Используйте следующий формат, чтобы вывести ответ (это не считается за запрос, то есть не учитывается в ограничении 20):</p>
  <ul>
    <li>! x — позиция k-го нуля.</li>
  </ul>

  <p>Позиции в массиве нумеруются слева направо от 1 до n включительно.</p>

  <p>После вывода t ответов ваша программа должна немедленно завершиться.</p>

  <p>В этой задаче интерактор не адаптивный. Это означает, что в рамках одного теста загаданный массив и запросы не меняются.</p>

  <p>При некорректном запросе будет выведено -1. При получении данного значения ваша программа должна немедленно завершиться штатным образом (к примеру, с помощью вызова exit(0)), иначе тестирующая система может выдать произвольный вердикт.</p>

  <p>При превышении количества запросов будет выведен вердикт неправильный ответ.</p>

  <p>Ваше решение может получить вердикт Решение «зависло», если вы ничего не выведете или забудете сбросить буфер вывода.</p>

  <p>Чтобы сбросить буфер вывода вам нужно сделать следующее сразу после вывода запроса и символа конца строки:</p>
  <ul>
    <li>fflush(stdout) или cout.flush() в C++;</li>
    <li>System.out.flush() в Java;</li>
    <li>flush(output) в Pascal;</li>
    <li>stdout.flush() в Python;</li>
    <li>см. документацию других языков.</li>
  </ul>

  <h4>Взломы</h4>

  <p>Используйте следующий формат для взломов:</p>

  <p>В первой строке выведите строку s (1 ≤ |s| ≤ 2⋅10⁵), состоящую из нулей и единиц, и целое число t (t=1) — загаданный массив и количество запросов, соответственно. В следующих t строках выведите число k (1 ≤ k ≤ |s|).</p>

  <p>Взламываемое решение не будет иметь прямого доступа к загаданному массиву.</p>

  <h4>Пример</h4>
<pre>
6 1
2

2

1

1

0

0
</pre>
<pre>
? 4 6

? 1 1

? 1 2

? 2 2

? 5 5

! 5
</pre>
  <p>В первом тесте загадан массив [1,0,1,1,0,1]. В этом тесте k=2.</p>
</article>


<!-- Задача I. Шоколадный заяц -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача I. Шоколадный заяц</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Это интерактивная задача.</p>

  <p>Мы загадали перестановку p длины n из элементов от 1 до n. Вам надо ее отгадать. Чтобы это сделать, вы можете сказать нам 2 различных индекса i и j, и мы вам скажем, чему равняется pi mod pj (остаток от деления pi на pj).</p>

  <p>У нас хватит терпения на то, чтобы ответить на 2⋅n запросов; вам нужно уложиться в это ограничение. Сможете ли вы это сделать?</p>

  <p>Напомним, что перестановка длины n — это массив, состоящий из n различных целых чисел от 1 до n в произвольном порядке. Например, [2,3,1,5,4] — это перестановка, но [1,2,2] — это не перестановка (2 встречается дважды в массиве), а [1,3,4] также не является перестановкой (n=3, но в массиве встречается 4).</p>

  <h4>Входные данные</h4>
  <p>Единственная строка содержит целое число n (1 ≤ n ≤ 10⁴) — длину перестановки.</p>

  <h4>Протокол взаимодействия</h4>
  <p>Взаимодействие начинается с чтения числа n.</p>

  <p>Далее вы можете задать максимум 2⋅n запросов следующего вида:</p>
  <ul>
    <li>«? x y» (1≤x,y≤n,x≠y).</li>
  </ul>

  <p>После каждого запроса вам необходимо считать целое число k, равное pxmodpy.</p>

  <p>Когда вы отгадаете перестановку, выведите в одной строку «! » (без кавычек) и массив p, после чего завершите работу.</p>

  <p>После вывода запроса не забудьте вывести перевод строки и сбросить буфер вывода. В противном случае вы получите вердикт Решение «зависло». Для сброса буфера используйте:</p>
  <ul>
    <li>fflush(stdout) или cout.flush() в C++;</li>
    <li>System.out.flush() в Java;</li>
    <li>flush(output) в Pascal;</li>
    <li>stdout.flush() в Python;</li>
    <li>смотрите документацию для других языков.</li>
  </ul>

  <p>Ваша программа должна немедленно завершиться после прочтения ответа «-1», вы получите вердикт Неправильный ответ. В противном случае вы можете получить любой вердикт, так как программа продолжит чтение из закрытого потока.</p>

  <h4>Формат взломов</h4>

  <p>В первой строке выведите n (1 ≤ n ≤ 10⁴). Во второй строке выведите перестановку из n чисел p1,p2,…,pn.</p>

  <h4>Пример</h4>
<pre>
3

1

2

1

0
</pre>
<pre>
? 1 2

? 3 2

? 1 3

? 2 1

! 1 3 2
</pre>
</article>


<!-- Задача J. Из машины -->
<article class="article">
  <div class="anchor" id="task10"></div>
  <h3>Задача J. Из машины</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Специальный агент Адам взламывает калькулятор члена секретной масонской организации иллюминатов, чтобы получить доступ к информации о её лидерах. Он уже выяснил, что всего в организацию входит n человек, каждый из которых имеет свой порядковый номер. Кроме того, у каждого из них есть уровень, представляющий собой целое число от 1 до n включительно. Уровни всех членов этой организации попарно отличаются. Любой иллюминат может командовать другими иллюминатами более низкого уровня, но вынужден подчиняться иллюминатам более высокого уровня. Адам полагает, что утечка информации об иллюминате наивысшего n-го уровня может его дискредитировать, поэтому ему интересен иллюминат с уровнем n - 1, подчиняющийся только иллюминату с наивысшим уровнем.</p>

  <p>Доступ к секретной сети иллюминатов получить непросто, поэтому единственный вид запросов, которые может делать Адам — это запросы на сравнение уровней двух иллюминатов с заданными порядковыми номерами. В ответ на такой запрос он получает ответ, больше уровень первого иллюмината, чем уровень второго, меньше, или же их уровни равны. Количество запросов ограничено, но из-за особого отношения калькулятора иллюминатов к степеням двойки Адам может безопасно выполнить целых  запросов, прежде чем его присутствие в сети будет замечено.</p>

  <h4>Протокол взаимодействия</h4>
  <p>Это интерактивная задача. Ваша программа должна общаться с программой жюри, используя для этого стандартные потоки ввода и вывода.</p>

  <p>Сначала в отдельной строке записано единственное целое число n (2 ≤ n ≤ 1000) — количество иллюминатов.</p>

  <p>После этого ваша программа может делать запросы на сравнение двух иллюминатов. Для этого в отдельной строке выведите символ «?» и два целых числа через пробел после него — порядковые номера иллюминатов, которых вы хотите сравнить. В ответ на это в отдельной строке будет записан единственный символ «&lt;», если первый иллюминат имеет уровень меньше, чем второй, символ «>», если первый иллюминат имеет уровень больше, чем второй, либо «=», если указанные иллюминаты имеют одинаковый уровень. Вы можете сделать не более чем  таких запросов.</p>

  <p>Когда вы узнаете ответ, выведите символ «!» и единственное целое число через пробел — номер иллюмината, имеющего уровень n - 1.</p>

  <h4>Пример</h4>
<pre>
5
>
>
>
>
>
&lt;
>
</pre>
<pre>
? 1 2
? 1 3
? 1 4
? 1 5
? 2 3
? 2 4
? 4 5
! 4
</pre>
  <p>Обратите внимание, что после вывода каждого сообщения ваша программа должна очищать потоковый буфер, чтобы выведенная вами информация дошла до программы жюри: например, это делают вызовы «fflush(stdout)» или «cout.flush()» в C++, «System.out.flush()» в Java, «Console.Out.Flush()» в C#, «flush(output)» в Pascal, «sys.stdout.flush()» в Python.</p>
</article>


<!-- Задача K. Андрюша и Python -->
<article class="article">
  <div class="anchor" id="task11"></div>
  <h3>Задача K. Андрюша и Python</h3>

  <div><i>Ограничение по времени 0.5с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Это интерактивная задача.</p>

  <p>Первое, что должен сделать преподаватель олимпиадного программирования, — это лечить новобранца от серьезной, но вполне излечимой болезни — питонизма.</p>

  <p>Марат В. — специалист по лечению данной болезни, но, к сожалению, марганцовка закончилась. Тогда у преподавателей не осталось выбора, кроме как спрятать знания Андрея по злосчастному языку программирования в очень надёжном месте: заначке в паркете аудитории 113.</p>

  <p>Паркет в аудитории 113 представляет собой квадрат со стороной n-1 на координатной плоскости и содержит n² точек с натуральными координатами, а заначка — точка на этой плоскости внутри или на стороне квадрата. Андрей первый год ходит на программирование, поэтому он не знает, где она находится. Единственное, что может делать Андрей — задавать глупые вопросы своему соседу Цукерману. Вопросы бывают трёх видов:</p>
  <ol>
    <li>Андрей может спросить про конкретную точку, является ли она заначкой;</li>
    <li>Андрей может спросить про отрезок, заданный координатами его концов, при этом его концы не совпадают — лежит ли загаданная точка на этом отрезке;</li>
    <li>Андрей может спросить про треугольник, заданный координатами его вершин, при этом треугольник невырожденный — лежит ли загаданная точка внутри или на границе этого треугольника.</li>
  </ol>
  <p>В любом запросе координаты точек должны быть натуральными числами.</p>

  <p>Цукерман, может отвечать на вопрос либо «Yes», либо «No».</p>

  <p>Андрей не хочет, чтобы преподаватели узнали, что он ищет свои знания по языку Python, поэтому он должен задать не более, чем 60 вопросов, чтобы никто ничего не заподозрил.</p>

  <p>Помогите Андрюше отгадать загаданную точку в паркете не более чем за 60 вопросов.</p>

  <h4>Протокол взаимодействия</h4>
  <p>Сначала на вход вашей программе подается одно целое число n — количество точек на стороне квадрата, в котором нужно искать точку (1 ≤ n ≤ 10⁸).</p>

  <p>После этого ваша программа может делать запросы:</p>

  <p>Для того, чтобы спросить, является ли точка с натуральными координатами (x,y) искомой (запрос типа 1), нужно вывести в выходной поток в отдельной строке «? 1 x y» .</p>

  <p>Для того, чтобы спросить, лежит ли искомая точка на отрезке с концами в натуральных точках (x1,y1) и (x2,y2) (запрос типа 2), нужно вывести в выходной поток в отдельной строке «? 2 x1 y1 x2 y2 » .</p>

  <p>Для того, чтобы спросить, лежит ли искомая точка внутри треугольника с вершинами в натуральных точках (x1,y1), (x2,y2), (x3,y3) (запрос типа 3), нужно вывести в выходной поток в отдельной строке «? 3 x1 y1 x2 y2 x3 y3 » .</p>

  <p>В ответ на запрос во входном потоке будет записана строка «Yes», если ответ положительный, или «No» в противном случае.</p>

  <p>В любом запросе координаты точек должны быть натуральными числами и не должны превосходить 10⁹.</p>

  <p>Если ваша программа сделает более 60 запросов или задаст некорректный запрос (например, запросите вырожденный треугольник), она получит любой вердикт отличный от «Accepted».</p>

  <p>Определив, в какой точке плоскости находится заначка со знаниями языка Python, ваша программа должна вывести в выходной поток «! x y », где (x,y) — координаты искомой точки.</p>

  <p>Гарантируется, что загаданная точка имеет натуральные координаты, а также загаданная точка фиксированная и не будет меняться в ходе тестирования вашей программы.</p>

  <h4>Пример</h4>
<pre>
3
No
No
No
No
Yes
Yes
</pre>
<pre>
? 2 1 1 3 2
? 2 3 1 2 3
? 2 3 3 1 2
? 2 1 3 2 1
? 3 1 1 2 3 3 1
? 1 2 2
! 2 2
</pre>
  <p>После каждого действия вашей программы выводите символ перевода строки. После вывода очередного запроса обязательно используйте функции очистки потока, чтобы часть вашего вывода не осталась в каком-нибудь буфере. Например, на С++ надо использовать функцию «fflush(stdout)», на Java вызов «System.out.flush()», на Pascal «flush(output)» и «stdout.flush()» для языка Python.</p>

  <h4>ПОЯСНЕНИЕ К ПРИМЕРУ</h4>

  <p>В тесте из условия была загадана точка с координатами (2,2) (F на рисунке) на квадрате со стороной 3. Для удобства представлен рисунок.</p>

  <p>Первый запрос — принадлежит ли точка отрезку (1,1) (3,2) (AD на рисунке)? Ответ — нет.</p>

  <p>Второй запрос — принадлежит ли точка отрезку (3,1) (2,3) (CH на рисунке)? Ответ — нет.</p>

  <p>Третий запрос — принадлежит ли точка отрезку (3,3) (1,2) (IE на рисунке)? Ответ — нет.</p>

  <p>Четвёртый запрос — принадлежит ли точка отрезку (1,3) (2,1) (GB на рисунке)? Ответ — нет.</p>

  <p>Пятый запрос — принадлежит ли точка треугольнику (1,1) (2,3) (3,1) (AHC на рисунке)? Ответ — да.</p>

  <p>Шестой запрос — является ли точка (2,2) искомой? Ответ — да.</p>

  <p>Выводится ответ ! 2 2.</p>
</article>


<!-- Задача L. Невозможно угадать -->
<article class="article">
  <div class="anchor" id="task12"></div>
  <h3>Задача L. Невозможно угадать</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Андрей задумал перестановку p1, . . . , pn из n первых натуральных чисел и сказал ее Павлу, чтобы тот ее не забыл. Это было не слишком мудрое решение, так как Павел страдает расстройствами памяти и не помнит точную перестановку, зато для каждого подотрезка [l; r] Павел может быстро назвать множество чисел pl, . . . , pr, упорядоченное по возрастанию.</p>

  <p>Леше очень интересно, какую именно перестановку задумал Андрей, поэтому он хочет тайно от Андрея узнать ее у Паши. У Леши мало времени, поэтому он успеет задать лишь ⌈n / 2⌉ вопросов (где ⌈x⌉ обозначает число x, округленное вверх). Помогите ему выяснить перестановку Андрея.</p>

  <h4>Формат входных данных</h4>
  <p>Это интерактивная задача. Здесь ваша программа должна по мере решения обмениваться информацией с программой жюри. Обратите внимание, что после вывода каждого сообщения ваша программа должна очищать потоковый буфер, чтобы выведенная вами информация дошла до программы жюри: например, это делают вызовы «fflush(stdout)» или «cout.flush()» в C++, «System.out.flush()» в Java, «flush(output)» в Pascal.</p>

  <p>В начале на вход вашей программе будет передано единственное целое число n (1 ⩽ n ⩽ 100) — размер перестановки. После этого вы имеете право задать не более ⌈n / 2⌉ вопросов, а потом дать окончательный ответ.</p>

  <p>Чтобы задать вопрос, вы должны вывести сначала букву «Q», а затем через пробел два целых числа l, r (1 ⩽ l ⩽ r ⩽ n) — индексы первого и последнего элементов подотрезка, о котором вы будете спрашивать.</p>

  <p>На каждый такой вопрос программа жюри ответит вам, передав (r 􀀀 l + 1) чисел, записанных через пробел: элементы перестановки pl, . . . , pr, предварительно отсортированные.</p>

  <p>Чтобы вывести окончательный ответ, вы должны вывести сначала букву «A», а затем через пробел n элементов перестановки — p1, . . . , pn. После этого ваша программа должна завершиться.</p>

  <h4>Пример</h4>
<pre>
3
3
1 3
</pre>
<pre>
Q 1 1
Q 1 2
A 3 1 2
</pre>
  <p>Пустые строки в примере приведены лишь для удобства, чтобы было лучше понятно, в каком порядке выводятся сообщения. При решении задачи вам не нужно выводить пустые строки, и программа жюри тоже не будет выводить пустые строки.</p>
</article>


<!-- Задача M. Ближе к звездам -->
<article class="article">
  <div class="anchor" id="task13"></div>
  <h3>Задача M. Ближе к звездам</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Ремш из года в год расширяется, а вместе с этим появляется много новых занятий для школьников. И вот в этом году планируется исследование Обратной стороны Луны. Посадка запланирована во время полнолуния, поэтому действовать придется "на ощупь". Чтобы предусмотреть все опасности, Адыгейскими программистами был сделан симулятор прогулки по луне.</p>

  <p>Лунная поверхность в симуляторе представляет из себя поле n * m. Каждая клетка этого поля может быть проходимой или же быть кратером. Проходимые клетки образуют связную область, которая не выходит за границы прямоугольника. Вам не известно какие размеры имеет поле, и даже где находятся проходимые клетки, но гарантируется, что посадка прошла успешно и вы сейчас не в кратере. Ваша задача состоит в прохождении всех доступных клеток не более чем за 100000 действий.</p>

  <h4>Выходные данные</h4>
  <p>Вывод должен состоять из строк "UP", "DOWN", "LEFT" и "RIGHT", если вы хотите переместиться, и из строки "DONE", если вы закончили изучение поля.</p>

  <h4>Протокол взаимодействия</h4>
  <p>Ваша программа должна вывести ваше действие в одной строке. Возможны передвижения в четырех направлениях: "UP", "DOWN", "LEFT" и "RIGHT". И считать ответ программы жюри:</p>
  <ul>
    <li>"BLOCKED" - значит в указанном направление двигаться опасно и вы остаетесь на прежнем месте</li>
    <li>"EMPTY" - этот ответ знаменует успешный переход в следующую клетку.</li>
  </ul>

  <p>Если посещены все доступные клетки ваша программа должна вывести строку "DONE" и завершиться. Иначе продолжить выполнение с вывода действия. Пустые клетки могут быть посещены несколько раз.</p>

  <h4>Пример</h4>
<pre>
UP
LEFT
LEFT
LEFT
DOWN
RIGHT
DOWN
RIGHT
DONE
</pre>
<pre>
BLOCKED
EMPTY
EMPTY
BLOCKED
BLOCKED
EMPTY
EMPTY
EMPTY
</pre>
  <p>Для корректной работы программы после каждой операции вывода данных вам необходимо делать следующие операции:</p>
  <ul>
    <li>В языке Pascal: flush(output);</li>
    <li>В C/C++: fflush(stdout);</li>
    <li>В Java: System.out.flush();</li>
    <li>В Python: sys.stdout.flush();</li>
  </ul>
  <p>Кроме этого, не забывайте после каждой выведенной строки ставить перевод строки.</p>
</article>


<!-- Задача N. Интервью -->
<article class="article">
  <div class="anchor" id="task14"></div>
  <h3>Задача N. Интервью</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Это интерактивная задача. Если вы не знаете, как работают интерактивные задачи, то рекомендуем прочитать руководство для участников.</p>

  <p>Перед последним этапом экзамена директор провел собеседование. Он дал Гону n кучек камней, в i-й кучке лежало ai камней.</p>

  <p>Все камни одинаковы и весят 1 грамм, за исключением одного особого камня, который лежит в неизвестной куче и весит 2 грамма.</p>

  <p>Картинка первого набора входных данных. Кучка 2 имеет особый камень. Кучки имеют веса 1,3,3,4,5, соответственно.</p>

  <p>Гон может задавать директору вопросы только одного типа: он может выбрать k кучек, и директор скажет ему общую массу выбранных куч. Более формально, Гон может выбрать целое число k (1 ≤ k ≤ n) и k различных кучек p1,p2,…,pk (1 ≤ pi ≤ n), и директор скажет ему общую массу mp1+mp2+⋯+mpk, где mi обозначает массу кучки i.</p>

  <p>Гону поручено найти кучку, в которой находится особый камень. Однако директор — занятой человек, поэтому помогите Гону найти эту кучу не более чем за 30 запросов.</p>

  <h4>Входные данные</h4>
  <p>Каждый тест состоит из нескольких наборов входных данных. Первая строка содержит одно целое число t (1 ≤ t ≤ 1000) — количество наборов входных данных. Далее следует описание наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит одно целое число n
   (1 ≤ n ≤ 2⋅10⁵) — количество кучек.</p>

  <p>Вторая строка каждого набора входных данных содержит n целых чисел ai (1 ≤ ai ≤ 10⁴) — количество камней в каждой куче.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 2⋅10⁵.</p>

  <p>После считывания входных данных для каждого набора, продолжите взаимодействие следующим образом.</p>

  <h4>Протокол взаимодействия</h4>
  <p>Вы можете выполнить не более 30 операций, чтобы угадать кучу.</p>

  <p>Чтобы сделать запрос, выведите строку следующего формата:</p>
  <ul>
    <li>? k p1 p2 p3 ... pk-1 pk (1 ≤ k ≤ n; 1 ≤ pi ≤ n; все pi различны) — индексы кучек.</li>
  </ul>

  <p>После каждой операции вы должны считать строку, содержащую одно целое число x — сумму масс выбранных кучек. (Формально, x=mp1+mp2+⋯+mpk).</p>

  <p>Когда вы узнаете индекс кучки с особым камнем, выведите одну строку следующего формата: ! m (1 ≤ m ≤ n).</p>

  <p>После этого переходите к следующему набору входных данных или завершите программу, если наборов больше не осталось.</p>

  <p>Если ваша программа выполнит более 30 операций для одного набора или сделает некорректный запрос, вы можете получить вердикт Неправильный ответ.</p>

  <p>После вывода запроса или ответа не забудьте вывести перевод строки и сбросить буфер вывода. В противном случае вы получите вердикт Решение «зависло». Для сброса буфера используйте:</p>
  <ul>
    <li>fflush(stdout) или cout.flush() в C++;</li>
    <li>System.out.flush() в Java;</li>
    <li>flush(output) в Pascal;</li>
    <li>stdout.flush() в Python;</li>
    <li>смотрите документацию для других языков.</li>
  </ul>

  <p>Дополнительно рекомендуется прочитать интерактивное руководство по решению задач для участников.</p>

  <h4>Взломы</h4>

  <p>Чтобы сделать взлом, используйте следующий формат.</p>

  <p>Первая строка должна содержать одно целое число t (1 ≤ t ≤ 1000) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных должна содержать два целых числа n, m (1 ≤ n ≤ 2⋅10⁵) – количество кучек и кучка с особым камнем.</p>

  <p>Вторая строка каждого набора входных данных должна содержать n целых ai (1 ≤ ai ≤ 10⁴) — количество камней в каждой куче.</p>

  <p>Обратите внимание, что интерактор является неадаптивным, то есть ответ известен до того, как участник задает запросы, и не зависит от запросов, заданных участником.</p>

  <h4>Пример</h4>
<pre>
2
5
1 2 3 4 5

11

6

3

7
1 2 3 5 3 4 2

12

6
</pre>
<pre>
? 4 1 2 3 4

? 2 2 3

? 1 2

! 2

? 4 2 3 5 6

? 2 1 4

! 7

</pre>
  <p>В первом наборе входных данных камень с массой два находится в куче 2, как показано на рисунке. Взаимодействие происходит так:</p>
  <ul>
    <li>? 4 1 2 3 4 — спрашиваем общую массу кучек 1, 2, 3 и 4. Общая масса, которую мы получим, равна 1+3+3+4=11.</li>
    <li>? 2 2 3 — спрашиваем общую массу кучек 2 и 3. Общая масса, которую мы получим, равна 3+3=6.</li>
    <li>? 1 2 — спрашиваем общую массу кучи 2. Общая масса, которую мы получим, равна 3.</li>
    <li>! 2 — мы выяснили, что куча 2 содержит особый камень, поэтому выводим его и переходим к следующему набору входных данных.</li>
  </ul>

  <p>Во втором наборе входных данных камень с весом два находится на индексе 7. Взаимодействие происходит так:</p>
  <ul>
    <li>? 4 2 3 5 6 — спрашиваем общую массу кучек 2, 3, 5 и 6. Общая масса, которую мы получим обратно, равна 2+3+3+4=12.</li>
    <li>? 2 1 4 — спрашиваем общую массу кучек 1 и 4. Общая масса, которую мы получим, равна 1+5=6.</li>
    <li>! 7 — мы каким-то образом выяснили, что куча 7 содержит особый камень, поэтому выводим его и завершаем взаимодействие.</li>
  </ul>

  <details>
    <summary>Решение</summary>
    <p>Задача на бинатрый поиск. Разобьем n кучек пополам и спросим про первую половину. В ответ получи вес камней. Если вес совпадает с числом камней, то ответа в этой половине нет. Переходим ко второй половине и разбиваем ее пополам и т.д. пока не останется один камень, который и будет ответом.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    int left, right, mid, n;
    cin >> n;
    vector&lt;int&gt; A(n + 1);
    for (int i = 1; i &lt;= n; i++) {
      cin >> A[i];
    }

    int sum = 0, sum_res_sys;
    left = 1;
    right = n;

    while (right - left > 1) {
      mid = left + (right - left) / 2;
      cout &lt;&lt; '?' &lt;&lt; ' ' &lt;&lt; mid - left + 1 &lt;&lt; " ";
      for (int i = left; i &lt;= mid; i++) {
        cout &lt;&lt; i &lt;&lt; " ";
      }
      cout &lt;&lt; '\n';
      // заканчиваем вывод
      cout.flush();
      cin >> sum_res_sys;
      sum = 0;
      for (int i = left; i &lt;= mid; i++) {
        sum += A[i];
      }
      if (sum != sum_res_sys) {
        right = mid;
      } else {
        left = mid;
      }
    }

    cout &lt;&lt; "?" &lt;&lt; " " &lt;&lt; 1 &lt;&lt; " " &lt;&lt; left &lt;&lt; '\n';
    cout.flush();
    cin >> sum_res_sys;
    if (sum_res_sys != A[left]) {
      cout &lt;&lt; "!" &lt;&lt; " " &lt;&lt; left &lt;&lt; '\n';
    } else {
      cout &lt;&lt; "!" &lt;&lt; " " &lt;&lt; right &lt;&lt; '\n';
    }
    cout.flush();
  }
}
</pre>
  </details>
</article>


<!-- Задача O. Не всё так многозначно -->
<article class="article">
  <div class="anchor" id="task15"></div>
  <h3>Задача O. Не всё так многозначно</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 512мб</i></div>

  <p>Это интерактивная задача.</p>

  <p>Программа жюри загадала целое число x от 1 до 10⁹ и основание системы счисления b (2 ≤ b ≤ 2023), после чего сообщила вам количество цифр в записи числа x в позиционной системе счисления по основанию b.</p>

  <p>Вы можете задавать запросы «сколько знаков в числе x+d», где d — целое число от 1 до 10¹⁸. Ваша задача — угадать как x, так и b не более, чем за 100 запросов.</p>

  <h4>Протокол взаимодействия</h4>
  <p>Взаимодействие начинает программа жюри, выводя n — количество цифр в b-ичной записи числа x.</p>

  <p>После чего ваша программа задаёт запросы в виде «? d», где 1 ≤ d ≤ 10¹⁸, а программа жюри выдаёт ответ — количество b-ичных цифр в записи x+d.</p>

  <p>Если вы готовы вывести ответ, выведите «! x b», где x и b — угаданные значения числа и основания системы счисления. Вывод ответа запросом не считается.</p>

  <h4>Пример</h4>
<pre>
1

2

3

</pre>
<pre>
? 1

? 3

! 1 2
</pre>
  <p>В примере интерактивного взаимодействия запросы и ответы разделены пустыми строками, чтобы наглядно показать процесс взаимодействия. В настоящем взаимодействии с программой жюри пустых строк не будет, их также не следует выводить, однако после каждого запроса, а также после вывода ответа необходимо выводить перевод строки.</p>
</article>


<!-- Задача P. Строчечка -->
<article class="article">
  <div class="anchor" id="task16"></div>
  <h3>Задача P. Строчечка</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 512мб</i></div>

  <p>Это интерактивная задача.</p>

  <p>Программа жюри загадала строку s длины n, которая состоит из букв «a», «b» и «c». Ваша программа должна её угадать.</p>

  <p>Чтобы угадать строку, ваша программа может делать запросы. Каждый запрос представляет собой число i (1 ≤ i ≤ n-1) и строку u длины два, состоящую из строчных букв английского алфавита. В ответ на запрос программа жюри сообщает, сколько из утверждений s<sub>i</sub> = u<sub>1</sub> и s<sub>i+1</sub> = u<sub>2</sub> верны.</p>

  <p>Требуется угадать загаданную строку, сделав не больше ⌈(4/3)n⌉ запросов. Здесь ⌈…⌉ означает округление вверх.</p>

  <h4>Протокол взаимодействия</h4>
  <p>В этой задаче вам надо будет несколько раз сыграть с программой жюри. Гарантируется, что количество игр в каждом запуске не превышает 100.</p>

  <p>В начале каждой игры ваша программа должна считать со стандартного потока ввода число n (2 ≤ n ≤ 100). Если n=0, то это значит, что ваша программа должна завершить свое исполнение. В ином случае вы начинаете игру с загаданной строкой длины n, и ваша программа может выполнить не более ⌈(4/3)n⌉ запросов.</p>

  <p>Чтобы сделать запрос, необходимо вывести в поток вывода «? i u», где 1≤i≤n-1, u — строка длины два из строчных английских букв. В ответ необходимо считать из стандартного потока ввода целое число a, равное 0, 1 или 2 — сколько утверждений из s<sub>i</sub> = u<sub>1</sub> и s<sub>i+1</sub> = u<sub>2</sub> верны.</p>

  <p>Когда ваша программа угадала загаданную строку, необходимо вывести в стандартный поток вывода «! s », где s  — строка длины n , которую загадала программа жюри. Вывод ответа не считается запросом. После того, как ваша программа выведет угаданную строку, она сразу же может приступать к следующей игре.</p>

  <p>Программа жюри в этой задаче может быть адаптивной. Иначе говоря, программа жюри может подбирать свои ответы таким образом, что существует строка, для которой все ответы корректны, но она не фиксирована заранее, а меняется в зависимости от запросов вашей программы. В частности, если существует строка, для которой все ответы на запросы являются корректными, но отличная от строки, которую угадала ваша программа, решение может получить вердикт «Wrong answer».</p>

  <h4>Пример</h4>
<pre>
3

2

1

1

2

0
</pre>
<pre>
? 1 ab

? 2 ba

? 2 bb

? 2 bc

! abc
</pre>
  <p>В примере интерактивного взаимодействия запросы и ответы разделены пустыми строками, чтобы наглядно показать процесс взаимодействия. В настоящем взаимодействии с программой жюри пустых строк не будет, их также не следует выводить, однако после каждого запроса, а также после вывода ответа необходимо выводить перевод строки.</p>
</article>

