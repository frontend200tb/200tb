<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p>ЯрГУ. Кружок. Школьники 2024/2025</p>
  <p><a href="https://vkvideo.ru/@sportprog_yarsu" target="_blank">vkvideo.ru/@sportprog_yarsu</a></p>
</article>


<article class="article">
  <h1>Занятие 11. Математика #1. Теория чисел. Основы</h1>
  <p>Конспект видео от 2024.11.23</p>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contest/568747" target="_blank">Codeforces Контест 568747</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
        <a href="#p1">Теория чисел</a>
    <br><a href="#t1">Задача 1. Является ли число простым</a>
    <br><a href="#t2">Задача 2. Вывести все делители числа</a>
    <br><a href="#t3">Задача 3. Вывести все простые делители числа</a>
    <br><a href="#t4">Задача 4. Решето Эратосфена</a>
    <br><a href="#t5">Задача 5. Взятие ответа по остатку</a>
  </p>
  <p>
        <a href="#task1">Задача A. ЕхАб И нОд</a>
    <br><a href="#task2">Задача B. Максимальный НОД</a>
    <br><a href="#task3">Задача C. Задача про LCM</a>
    <br><a href="#task4">Задача D. Простые делители</a>
    <br><a href="#task5">Задача E. Надо побольше</a>
    <br><a href="#task6">Задача F. Решето Эратосфена</a>
    <br><a href="#task7">Задача G. Простые числа easy</a>
    <br><a href="#task8">Задача H. Простые числа</a>
    <br><a href="#task9">Задача I. Коровки и первообразные корни</a>
    <br><a href="#task10">Задача J. Целые точки отрезка</a>
    <br><a href="#task11">Задача K. Никогда не спрашивайте даму о возрасте</a>
    <br><a href="#task12">Задача L. Почти простые числа</a>
    <br><a href="#task13">Задача M. Пары чисел</a>
    <br><a href="#task14">Задача N. Мишка и покер</a>
    <br><a href="#task15">Задача O. Мила и шоколад</a>
    <br><a href="#task16">Задача P. Разложение на множители</a>
    <br><a href="#task17">Задача Q. Прямоугольная игра</a>
    <br><a href="#task18">Задача R. Эпическая игра</a>
  </p>
</article>


<!-- Теория чисел -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Теория чисел</h3>

  <p>Простое число - натуральной число, имеющее ровно два различных натуральных делителя. Простое число отлично от 1 и делится без остатка только на 1 и на само себя.</p>
  <p>Примеры: 2, 3, 7, 11, 967, 1004911, 1000000007</p>
  <p>Составное число - натуральное число, имеющее делители, отличные от 1 и самого себя. Каждое составное число является произведением двух или более натуральных чисел., больше 1. Все натуральные числа делятся на три непересекающиеся категории: простые, составные и 1.</p>
  <p>Примеры: 4, 6, 10, 15, 625</p>
</article>


<!-- Задача 1. Является ли число простым -->
<article class="article">
  <div class="anchor" id="t1"></div>
  <h3>Задача 1. Является ли число простым</h3>

  <p>Проверить число на простоту. Является ли число n простым. Проверим линейным алгоритмом O(n)</p>

  <details>
    <summary>Решение за O(n)</summary>
<pre>
int n;
cin >> n;
int count = 0;

for (int i = 1; i &lt;= n; i++) {
  if (n % i == 0) {
    count++;
  }
}

if (count == 2) {
  cout &lt;&lt; "YES";
} else {
  cout &lt;&lt; "NO";
}
</pre>
  </details>

  <p>Оптимизируем алгоритм. Заметим, что если число n является составным, то его можно представить в виде произведения n = a * b, где будет выполняться неравенства a ≤ sqrt(n) и sqrt(n) ≤ b. Воспользуемся этим свойством и будем проверять до корня от числа.</p>

  <details>
    <summary>Решение</summary>
<pre>
int n;
cin >> n;
int count = 0;

for (int i = 2; i &lt;= sqrt(n); i++) { // плохо
  if (n % i == 0) {
    count++;
  }
}

if (count == 0) {
  cout &lt;&lt; "YES";
} else {
  cout &lt;&lt; "NO";
}
</pre>
  </details>

  <p>Улучшим реализацию отказавшись от операции sqrt(n).</p>
  <details>
    <summary>Решение</summary>
<pre>
int n;
cin >> n;
int count = 0;

for (long long i = 2; i * i &lt;= n; i++) { // хорошо
  if (n % i == 0) {
    count++;
  }
}

if (count == 0) {
  cout &lt;&lt; "YES";
} else {
  cout &lt;&lt; "NO";
}
</pre>
  </details>
</article>


<!-- Задача 2. Вывести все делители числа -->
<article class="article">
  <div class="anchor" id="t2"></div>
  <h3>Задача 2. Вывести все делители числа</h3>

  <p>Вывести все делители числа в порядке возрастания. Сделаем наивную реализацию за O(n)</p>

  <details>
    <summary>Решение за O(n)</summary>
<pre>
int n;
cin >> n;

for (int i = 1; i &lt;= n; i++) {
  if (n % i == 0) {
    cout &lt;&lt; i &lt;&lt; " ";
  }
}
</pre>
  </details>

  <p>Улучшим реализацию. Будем бежать до sqrt(n) и сразу же будем определять пару делителей.</p>

  <details>
    <summary>Решение</summary>
<pre>
int n;
cin >> n;
vector&lt;int&gt;A;

for (long long i = 1; i * i &lt;= n; i++) {
  if (n % i == 0) {
    A.push_back(i);
    if (i * i != n) {
      A.push_back(n / i);
    }
  }
}

sort(A.begin(), A.end());
for (int i = 0; i &lt; A.size(); i++) {
  cout &lt;&lt; A[i] &lt;&lt; " ";
}
</pre>
  </details>
</article>


<!-- Задача 3. Вывести все простые делители числа -->
<article class="article">
  <div class="anchor" id="t3"></div>
  <h3>Задача 3. Вывести все простые делители числа</h3>

  <p>Разложить число n на простые множители. В цикле for начинаем с i=2. Будем делить число n на 2 до тех пор, пока оно делится на 2. Таким образом мы удаляем из n все делители равные 2,4,8 и т.д.Дальше i=3 и так мы удалим все простые делители из n от 2 до sqrt(n). Каждую итерацию выводим найденное простое число, пока n не станет равно 1 или не закончится цикл. Если цикл закончился, а n не равно 1, значит у нас остался еще один простой делитель и мы его тожедолжны вывести.</p>

  <details>
    <summary>Решение</summary>
<pre>
int n;
cin >> n;

for (long long i = 2; i * i &lt;= n; i++) {
  while (n % i == 0) {
    cout &lt;&lt; i;
    n /= i;
    if (n != 1) {
      cout &lt;&lt; '*';
    }
  }
}

if (n != 1) {
  cout &lt;&lt; n;
}
</pre>
  </details>
</article>


<!-- Задача 4. Решето Эратосфена -->
<article class="article">
  <div class="anchor" id="t4"></div>
  <h3>Задача 4. Решето Эратосфена</h3>

  <p>Реализуем алгоритм решето Эратосфена. Алгоритм находит все простые числа от 1 до n.</p>

  <h4>Решение</h4>
  <p>Заводим вектор A для всех чисел от 0 до n. Числа 0 и 1 не являются простыми, поэтому сразу инициализируем их единицей. </p>
  <p>В конце вектор A будет состоят из 0 и 1. Если A[i] = 0, то i является простым числом. Если A[i] = 1, то это число или 0 или 1 или составное.</p>
  <p>Если в цикле for нашли простое число, то заходим во внутренний цикл for и вычеркиваем (A[i]=1) все числа, которые делятся на это простое число.</p>

  <details>
    <summary>Решение</summary>
<pre>
int n;
cin >> n;
vector&lt;int&gt;A(n + 1);
A[0] = 1;
A[1] = 1;

for (int i = 2; i &lt;= n; i++) {
  if (A[i] == 0) {
    for (int j = 2 * i; j &lt;= n; j += i) {
      A[j] = 1;
    }
  }
}
</pre>
  </details>

  <p>Приведем немного улучшенную реализацию алгоритма Решето Эратосфена. Трудоемкость алгоритма O(n * log2(n)).</p>
  <p>Внутренний цикл for начнем не с j = 2*i, а с j = i*i. Это уменьшит количество итераций</p>

  <details>
    <summary>Решение</summary>
<pre>
int n;
cin >> n;
vector&lt;int&gt;A(n + 1);
vector&lt;int&gt;B;
A[0] = 1;
A[1] = 1;

for (long long i = 2; i &lt;= n; i++) {
  if (A[i] == 0) {
    B.push_back(i);
    for (long long j = i * i; j &lt;= n; j += i) {
      A[j] = 1;
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача 5. Взятие ответа по остатку -->
<article class="article">
  <div class="anchor" id="t5"></div>
  <h3>Задача 5. Взятие ответа по остатку</h3>

  <p>Рассмотрим задачу, где нам необходимо найти произведение целых чисел и выдать результат по остатку от числа mod.</p>
  <p>Наивное решение это найти произведение чисел, а потом результат взять по остатку:</p>
  <code>(a₁ * a₂ * a₃ * a₄ * ... * aₙ)%mod</code>
  <p>К сожалению при перемножении чисел мы можем выйти за пределы типов данных.</p>
  <p>Заметим, что любое число можно представить в виде n = k * mod + h, где 0 ≤ h ≤ mod.</p>
  <p>Для того, чтобы не выходить за типы данных при перемножении, мы можем брать остаток после каждого умножения:</p>
  <code>(((...(a₁%mod) * a₂%mod) * a₃%mod) * a₄%mod) * ... * aₙ)%mod</code>
</article>


<!-- Задача A. ЕхАб И нОд -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. ЕхАб И нОд</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам дано целое положительное число x. Найдите любые такие два 2  целые положительные числа a и b, для которых НОД(a,b)+НОК(a,b)=x.</p>

  <p>Напомним, что НОД(a,b) — это наибольшее целое число, на которое делятся и a и b. Аналогично, НОК(a,b) - это наименьшее целое число, которое делится и на a и на b.</p>

  <p>Гарантируется, что решение всегда существует. Если существует несколько таких пар (a,b), вы можете вывести любую из них.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно целое число t (1≤t≤100) — количество наборов тестовых данных.</p>

  <p>Каждый набор тестовых данных состоит из одной строки, содержащей одно целое число, x(2≤x≤10⁹).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора тестовых данных, выведите пару целых положительных чисел a и b (1≤a,b≤10⁹)  таких, что НОД(a,b)+НОК(a,b)=x. Гарантируется, что решение всегда существует. Если существует несколько таких пар (a,b), вы можете вывести любую из них.</p>

  <h4>Пример</h4>
<pre>
2
2
14
</pre>
<pre>
1 1
6 4
</pre>
  <p>В первом наборе тестовых данных примера,  НОД(1,1)+НОК(1,1)=1+1=2</p>
  <p>Во втором наборе тестовых данных примера, НОД(6,4)+НОК(6,4)=2+12=14</p>

  <details>
    <summary>Решение</summary>
    <p>Нужно поисидеть и аккуратно повыписывать примеры для небольших x, чтобы понять какие бывают ответы. В качестве ответа подходят числа 1 и x-1.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int t;
  cin >> t;

  for (int test = 0; test &lt; t; test++) {
    int x;
    cin >> x;

    // решение и вывод результата
    cout &lt;&lt; 1 &lt;&lt; " " &lt;&lt; x - 1 &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача B. Максимальный НОД -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Максимальный НОД</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Рассмотрим все целые числа в промежутке от 1 до n (включительно).</p>

  <p>По всем парам различных целых чисел из этого промежутка, найдите максимальное возможное значение наибольшего общего делителя чисел в паре. Более формально, найдите максимальное значение gcd(a,b) по всем 1≤a&lt;b≤n.</p>

  <p>Наибольшим общим делителем gcd(a,b) пары положительных целых чисел a и b называется наибольшее целое число, являющееся делителем числа a и делителем числа b.</p>

  <h4>Входные данные</h4>
  <p>В первой строке находится единственное целое число t (1≤t≤100)  — количество наборов входных данных. Описание наборов входных данных следует.</p>

  <p>В единственной строке описания каждого набора входных данных находится единственное целое число n (2≤n≤10<sup>6</sup>).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных, выведите максимальное значение gcd(a,b) по всем 1≤a&lt;b≤n.</p>

  <h4>Пример</h4>
<pre>
2
3
5
</pre>
<pre>
1
2
</pre>
  <p>В первом наборе входных данных  gcd(1,2)=gcd(2,3)=gcd(1,3)=1</p>
  <p>Во втором наборе входных данных 2 является максимальным возможным значением, соответствующим gcd(2,4).</p>
</article>


<!-- Задача C. Задача про LCM -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Задача про LCM</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Пусть LCM(x,y) — наименьшее положительное целое число, которое делится и на x, и на y. Например, LCM(13,37)=481, LCM(9,6)=18.</p>

  <p>Вам даны два числа l и r. Найдите два целых числа x и y, для которых выполняются условия: l≤x&lt;y≤r и l≤LCM(x,y)≤r.</p>

  <h4>Входные данные</h4>
  <p>В первой строке задано одно целое число t (1≤t≤10000) — количество наборов входных данных.</p>

  <p>Каждый набор входных данных задается одной строкой, содержащей два целых числа l и r (1≤l&lt;r≤10⁹).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите два целых числа:</p>
  <ul>
    <li>если невозможно найти удовлетворяющие условиям числа x и y, два раза выведите -1;</li>
    <li>иначе выведите значения x и y (если существует несколько возможных решений, выведите любое из них).</li>
  </ul>

  <h4>Пример</h4>
<pre>
4
1 1337
13 69
2 4
88 89
</pre>
<pre>
6 7
14 21
2 4
-1 -1
</pre>

  <details>
    <summary>Решение</summary>
    <p>LCM это НОК (наименьшее общее кратное). Условие для x и y</p>
    <code>l≤ x&lt; y ≤ LCM(x,y) ≤ r.</code>
    <p>Решение шуточное. Мы предполагаем, что если выбрать x = l, а y = 2 * l, то НОК(x, y) = 2 * l. Тогда должно выполняться 2 * l &le; r. Расстояние между левой и правой границей должно быть r - l > l. Иначе НОК(x, y) > r и ответа не будет.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int t;
  cin >> t;

  for (int test = 0; test &lt; t; test++) {
    int l, r;
    cin >> l >> r;

    // решение
    if (2 * l &lt;= r) {
      cout &lt;&lt; l &lt;&lt; " " &lt;&lt; 2 * l &lt;&lt; '\n';
    } else {
      cout &lt;&lt; "-1 -1\n";
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача D. Простые делители -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Простые делители</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Все просто: вам дается число, и вы должны вывести все его простые делители.</p>

  <h4>Входные данные</h4>
  <p>В единственной строке единственное число a (1 ≤ a ≤ 10<sup>15</sup>).</p>

  <h4>Выходные данные</h4>
  <p>Вывести через пробел в единственной строке в порядке возрастания все простые делители числа без повторений.</p>

  <h4>Пример</h4>
  <code>22</code>
  <code>2 11</code>
</article>


<!-- Задача E. Надо побольше -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Надо побольше</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Дан массив чисел, необходимо вывести наибольший среди всех НОД попарных комбинаций чисел массива и наибольший среди всех НОК попарных комбинаций чисел массива.</p>

  <h4>Входные данные</h4>
  <p>В первой строке n - количество чисел массива (2 ≤ n ≤ 10<sup>3</sup>). Во второй строке через пробел записаны числа массива не превосходящие 10<sup>9</sup>.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке через пробел выведите 2 числа - ответ на вопрос.</p>

  <h4>Пример</h4>
<pre>
2
5 6
</pre>
  <code>30 1</code>
</article>


<!-- Задача F. Решето Эратосфена -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Решето Эратосфена</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Ваша задача реализовать Решето Эратосфена и вывести все простые числа в диапазоне от 2 до N</p>

  <h4>Входные данные</h4>
  <p>Вводится единственное число 2 ≤ N ≤ 10<sup>5</sup></p>

  <h4>Выходные данные</h4>
  <p>Выведите все простые числа в диапазоне от 2 до N в порядке возрастания через пробел</p>

  <h4>Пример</h4>
  <code>2</code>
  <code>2</code>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // входные данные
  int n;
  cin >> n;

  // решение
  vector&lt;int&gt; A(n + 1, 0);
  // вектор простых чисел
  vector&lt;int&gt; S;

  // решето Эратосфена
  for (long long i = 2; i &lt;= n; i++) {
    if (A[i] == 0) {
      S.push_back(i);
      A[i] = 1;
      for (long long j = i * i; j &lt;= n; j += i) {
        A[j] = 1;
      }
    }
  }

  // вывод результата
  for (int i = 0; i &lt; S.size(); i++) {
    cout &lt;&lt; S[i] &lt;&lt; ' ';
  }

  return 0;
}
</pre>
  </details>
</article>


<!-- Задача G. Простые числа easy -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Простые числа easy</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Необходимо вывести все простые числа от M до N включительно.</p>

  <h4>Входные данные</h4>
  <p>В единственной строке записаны два натуральных числа M и N, разделенных пробелом (2 ≤ M ≤ N ≤ 10<sup>5</sup>)</p>

  <h4>Выходные данные</h4>
  <p>Выведите все простые числа от M до N в порядке возрастания, по одному в строке. Если таковых чисел нет, то следует вывести -1</p>

  <h4>Пример 1</h4>
  <code>2 5</code>
<pre>
2
3
5
</pre>

  <h4>Пример 2</h4>
  <code>4 4</code>
  <code>-1</code>

  <details>
    <summary>Решение</summary>
    <p>Собиракем Решето Эратосфена и выбираем из него числа от m до n.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // входные данные
  int m, n;
  cin >> m >> n;

  // решение
  vector&lt;int&gt; A(n + 1, 0);
  // вектор простых чисел
  vector&lt;int&gt; S;

  // решето Эратосфена
  for (long long i = 2; i &lt;= n; i++) {
    if (A[i] == 0) {
      A[i] = 1;
      for (long long j = i * i; j &lt;= n; j += i) {
        A[j] = 1;
      }
      if (i >= m) {
        S.push_back(i);
      }
    }
  }

  // вывод результата
  if (S.empty()) {
    cout &lt;&lt; -1;
  } else {
    for (int i = 0; i &lt; S.size(); i++) {
      cout &lt;&lt; S[i] &lt;&lt; '\n';
    }

  }

  return 0;
}
</pre>
  </details>
</article>


<!-- Задача H. Простые числа -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Простые числа</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Необходимо вывести все простые числа от M до N включительно.</p>

  <h4>Входные данные</h4>
  <p>В единственной строке записаны два натуральных числа M и N, разделенных пробелом (2 ≤ M ≤ N ≤ 5·10<sup>6</sup>)</p>

  <h4>Выходные данные</h4>
  <p>Выведите все простые числа от M до N в порядке возрастания, по одному в строке. Если таковых чисел нет, то следует вывести -1</p>

  <h4>Пример 1</h4>
  <code>2 5</code>
<pre>
2
3
5
</pre>

  <h4>Пример 2</h4>
  <code>4 4</code>
  <code>-1</code>

  <details>
    <summary>Решение</summary>
    <p>Собиракем Решето Эратосфена и выбираем из него числа от m до n.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // входные данные
  int m, n;
  cin >> m >> n;

  // решение
  vector&lt;int&gt; A(n + 1, 0);
  // вектор простых чисел
  vector&lt;int&gt; S;

  // решето Эратосфена
  for (long long i = 2; i &lt;= n; i++) {
    if (A[i] == 0) {
      A[i] = 1;
      for (long long j = i * i; j &lt;= n; j += i) {
        A[j] = 1;
      }
      if (i >= m) {
        S.push_back(i);
      }
    }
  }

  // вывод результата
  if (S.empty()) {
    cout &lt;&lt; -1;
  } else {
    for (int i = 0; i &lt; S.size(); i++) {
      cout &lt;&lt; S[i] &lt;&lt; '\n';
    }

  }

  return 0;
}
</pre>
  </details>
</article>


<!-- Задача I. Коровки и первообразные корни -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача I. Коровки и первообразные корни</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Коровки только что узнали, что такое первообразный корень! Вам дано простое число p, первообразный корень mod p — целое число x (1 ≤ x &lt; p), такое, что ни одно из целых чисел x - 1, x<sup>2</sup> - 1, ..., x<sup>p-2</sup> - 1 не делится на p, при этом число x<sup>p-1</sup> - 1 делится на p.</p>

  <p>К сожалению, на вычисление первообразных корней уходит много времени, так что коровкам нужна Ваша помощь. Вам дано простое число p, помогите коровкам найти количество первообразных корней mod p.</p>

  <h4>Входные данные</h4>
  <p>Во входных данных содержится единственная строка, в которой записано целое число p (2 ≤ p &lt; 2000). Гарантируется, что p является простым числом.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите количество первообразных корней mod p.</p>

  <h4>Пример 1</h4>
  <code>3</code>
  <code>1</code>
  <p>Единственный первообразный корень mod 3 — 2</p>

  <h4>Пример 2</h4>
  <code>5</code>
  <code>2</code>
  <p>Первообразные корни mod 5 — 2 и 3.</p>
</article>


<!-- Задача J. Целые точки отрезка -->
<article class="article">
  <div class="anchor" id="task10"></div>
  <h3>Задача J. Целые точки отрезка</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Требуется написать программу, которая вычислит, сколько всего точек с целочисленными координатами принадлежат отрезку.</p>

  <h4>Входные данные</h4>
  <p>Даны четыре целых числа – координаты концов отрезка (x<sub>1</sub>,y<sub>1</sub>) и (x<sub>2</sub>,y<sub>2</sub>). Каждая из координат не превышает по абсолютной величине значения 1000.</p>

  <h4>Выходные данные</h4>
  <p>Требуется вывести количество точек отрезка, имеющих целочисленные координаты.</p>

  <h4>Пример 1</h4>
  <code>1 0 5 0</code>
  <code>5</code>

  <h4>Пример 2</h4>
  <code>-1 -2 2 4</code>
  <code>4</code>
</article>


<!-- Задача K. Никогда не спрашивайте даму о возрасте -->
<article class="article">
  <div class="anchor" id="task11"></div>
  <h3>Задача K. Никогда не спрашивайте даму о возрасте</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Миссис Литл любит цифры больше всего на свете. Каждый год она пытается составить лучшее число года. Она пытается стать всё более и более эрудированной, и каждый год изучает новую цифру, так что число, которое она составляет, записано в системе счисления, база которой равна возрасту миссис Литл. Чтобы сделать свою жизнь ещё более прекрасной, она пишет только числа, которые делятся на её возраст без единицы. Миссис Литл хочет держать свой возраст в секрете.</p>

  <p>Вам дано число, состоящее из цифр 0, …, 9 и латинских букв A, …, Z, где A равно 10, B равно 11 и так далее. Ваша задача — найти минимальное число k, удовлетворяющее следующему условию: заданное число, записанное в k-ичной системе счисления делится на k - 1.</p>

  <h4>Входные данные</h4>
  <p>Ввод состоит из одной строки, содержащей не более 10<sup>6</sup> цифр или заглавных латинских букв.</p>

  <h4>Выходные данные</h4>
  <p>Вывод должен содержать единственное число k или строку "No solution", если для любых 2 ≤ k ≤ 36 описанное ранее условие не выполняется. Кстати, ответ нужно писать в десятичном виде.</p>

  <h4>Пример 1</h4>
  <code>123</code>
  <code>4</code>

  <h4>Пример 2</h4>
  <code>SOLVEMEPLS</code>
  <code>No solution</code>
</article>


<!-- Задача L. Почти простые числа -->
<article class="article">
  <div class="anchor" id="task12"></div>
  <h3>Задача L. Почти простые числа</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Число называется почти простым, если оно имеет ровно два различных простых делителя. Например, числа 6, 18, 24 являются почти простыми, а 4, 8, 9, 42 — не являются. Найдите количество почти простых чисел от 1 до n включительно.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входного файла записано число n (1 ≤ n ≤ 3000).</p>

  <h4>Выходные данные</h4>
  <p>Выведите количество почти простых чисел от 1 до n включительно.</p>

  <h4>Пример 1</h4>
  <code>10</code>
  <code>2</code>

  <h4>Пример 2</h4>
  <code>21</code>
  <code>8</code>

  <details>
    <summary>Решение</summary>
    <p>Переберем все числа от 1 до 3000 и найдем для них простые делители. Применим решето Эратосфена. Заведем вектор A для хранения решета Эратосфена. Будем записывать 1 если число не простое, 0 если простое.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;

  vector&lt;int&gt; A(n + 1);
  A[0] = 1;
  A[1] = 1;

  // собираем решето Эратосфена
  for (int i = 2; i &lt;= n; i++) {
    if (A[i] == 0) {
      for (int j = 2 * i; j &lt;= n; j += i) {
        A[j] = 1;
      }
    }
  }

  // решение
  int res = 0;
  for (int i = 2; i &lt;= n; i++) {
    int count = 0;
    for (int j = 2; j &lt; A.size(); j++) {
      if (A[j] == 0) {
        if (i % j == 0) {
          count++;
        }
      }
    }
    if (count == 2) {
      res++;
    }
  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача M. Пары чисел -->
<article class="article">
  <div class="anchor" id="task13"></div>
  <h3>Задача M. Пары чисел</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Допустим, мы имеем пару чисел (a, b). Мы можем получить новую пару чисел вида (a + b, b) или (a, a + b) из данной. Назовем такое действие шагом.</p>

  <p>Пусть начальная пара чисел — (1,1). Ваша задача — найти число k, наименьшее количество шагов, необходимых чтобы получить из (1,1) пару, в которой хотя бы одно число равно n.</p>

  <h4>Входные данные</h4>
  <p>Входные данные содержат единственное целое число n (1 ≤ n ≤ 10<sup>6</sup>).</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное число k.</p>

  <h4>Пример 1</h4>
  <code>5</code>
  <code>3</code>

  <h4>Пример 2</h4>
  <code>1</code>
  <code>0</code>
  <p>Из пары (1,1) можно за три хода получить пару, содержащую 5: (1,1) → (1,2) → (3,2) → (5,2).</p>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

long long cnt;

long long gcd(long long a, long long b) {
  if (b == 0) {
    if (a != 1) {
      cnt += 1'000'000;
    }
    cnt += a - 1;
    return a;
  } else {
    cnt += a / b;
    return gcd(b, a % b);
  }
}

int main() {
  long long n;
  cin >> n;
  long long min_count = 10'000'000;
  for (long long i = 1; i &lt; n; i++) {
    cnt = 0;
    gcd(n, i);
    min_count = min(min_count, cnt);
  }
  if (min_count == 10'000'000) {
    cout &lt;&lt; 0;
    return 0;
  }

  cout &lt;&lt; min_count - 1;
}
</pre>
  </details>
</article>


<!-- Задача N. Мишка и покер -->
<article class="article">
  <div class="anchor" id="task14"></div>
  <h3>Задача N. Мишка и покер</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Лимак — старый бурый медведь. Он любит играть в покер со своими друзьями, для чего они часто ходят в ближайшее казино.</p>

  <p>За столом сидят n игроков (включая Лимака), которые уже сделали какие-то ставки. i-й игрок поставил ai долларов.</p>

  <p>Каждый игрок может удвоить или утроить свою ставку произвольное количество раз (может быть, и удвоить, и утроить). В казино есть специальное условие о джекпоте в случае, если ставки всех игроков становятся равны. Могут ли Лимак и его друзья выиграть джекпот?</p>

  <h4>Входные данные</h4>
  <p>В первой строке входного файла записано целое число n (2 ≤ n ≤ 10<sup>5</sup>), количество игроков.</p>

  <p>Во второй строке записано n целых чисел a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> (1 ≤ a<sub>i</sub> ≤ 10<sup>9</sup>) — ставки игроков.</p>

  <h4>Выходные данные</h4>
  <p>Выведите "Yes" (без кавычек), если игроки смогут сделать все ставки равными, или "No" в противном случае.</p>

  <h4>Пример 1</h4>
<pre>
4
75 150 75 50
</pre>
  <code>Yes</code>
  <p>В первом тесте первый и третий игроки должны дважды удвоить свои ставки, второй игрок должен удвоить свою ставку один раз, а четвертый игрок должен удвоить и утроить свою ставку.</p>

  <h4>Пример 2</h4>
<pre>
3
100 150 250
</pre>
  <code>No</code>
  <p>Можно показать, что во втором тесте невозможно сделать все ставки равными.</p>
</article>


<!-- Задача O. Мила и шоколад -->
<article class="article">
  <div class="anchor" id="task15"></div>
  <h3>Задача O. Мила и шоколад</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Маленькой Миле дали задачу. У неё есть n досок, пронумерованных целыми числами от 1 до n. Она должна покрасить их странным образом.</p>

  <p>Непокрашенная доска может быть покрашены в красный цвет, если её номер делится на число a, а также может быть покрашена в синий цвет, если её номер делится на число b. Таким образом, доска номер которой делится на a и на b может быть покрашена как в красный, так и в синий цвет.</p>

  <p>После покраски она получит p шоколадок за каждую доску красного цвета и q шоколадок за каждую доску синего цвета.</p>

  <p>Обратите внимание, что она может красить доски в любом порядке.</p>

  <p>Помогите Миле найти наибольшее количество шоколадок, которые она может получить.</p>

  <h4>Входные данные</h4>
  <p>Единственная строка содержит пять целых чисел n, a, b, p и q (1 ≤ n, a, b, p, q ≤ 10⁹).</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно целое число s — наибольшее количество шоколадок, которые может получить Мила.</p>

  <p>Обратите внимание, что ответ может не поместиться в 32-битном типе данных. Для сохранения числа вы можете использовать, например, тип long long в языке C++ или тип long в языке Java.</p>

  <h4>Пример 1</h4>
  <code>5 2 3 12 15</code>
  <code>39</code>

  <h4>Пример 2</h4>
  <code>20 2 3 3 5</code>
  <code>51</code>

  <details>
    <summary>Решение</summary>
    <p>Посчитаем два результата и выберем из них больший. res1 для досок покрашенных в красный цвет и res2 - в синий, среди тех что могут быть покрашени и в красный и в синий.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

long long gcd(long long a, long long b) {
  while (a > 0 && b > 0) {
    if (a > b) {
      a = a % b;
    } else {
      b = b % a;
    }
  }
  return a + b;
}

int main() {
  // ввод данных
  long long n, a, b, p, q;
  cin >> n >> a >> b >> p >> q;

  // решение
  long long nok = a * b / gcd(a, b);
  long long res1 = p * (n / a) + q * (n / b - n / nok);
  long long res2 = p * (n / a - n / nok) + q * (n / b);

  // вывод результата
  cout &lt;&lt; max(res1, res2);
}
</pre>
  </details>
</article>


<!-- Задача P. Разложение на множители -->
<article class="article">
  <div class="anchor" id="task16"></div>
  <h3>Задача P. Разложение на множители</h3>

  <div><i>Ограничение по времени 3с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам дано целое положительное число n. Выведите его разложение на простые множители.</p>

  <p>Если n = a<sub>1</sub><sup>b<sub>1</sub></sup> a<sub>2</sub><sup>b<sub>2</sub></sup> ... a<sub>k</sub><sup>b<sub>k</sub></sup> (b<sub>i</sub> > 0), где a<sub>k</sub> — простые числа, то вывод программы должен выглядеть следующим образом: a<sub>1</sub>*...*a<sub>1</sub>*a<sub>2</sub>*...*a<sub>2</sub>*...*a<sub>k</sub>*...*a<sub>k</sub>, где множители упорядочены в порядке неубывания, и каждый множитель a<sub>i</sub> указан b<sub>i</sub> раз.</p>

  <h4>Входные данные</h4>
  <p>Единственная строка входных данных содержит целое число n (2 ≤ n ≤ 10000).</p>

  <h4>Выходные данные</h4>
  <p>Выведите разложение числа n на простые множители в формате, описанном выше.</p>

  <h4>Пример 1</h4>
  <code>245</code>
  <code>5*7*7</code>

  <h4>Пример 2</h4>
  <code>19</code>
  <code>19</code>
</article>


<!-- Задача Q. Прямоугольная игра -->
<article class="article">
  <div class="anchor" id="task17"></div>
  <h3>Задача Q. Прямоугольная игра</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Умный Бобер из ABBYY решил устроить себе выходной. Но бездельничать целый день оказалось слишком скучно, и он решил поиграть в игру с камешками. Изначально у Бобра есть n камешков. Он раскладывает их в a одинаковых рядов по b штук в каждом (a > 1). Учтите, что Бобер обязательно использует все камешки, то есть n = a·b.</p>

  <p>После того, как он разложил камешки, Умный Бобер забирает обратно любой из полученных рядов (то есть b камешков) и выбрасывает все остальные камешки. Затем он снова раскладывает все свои камешки (выбирая, возможно, другие a и b) и снова забирает себе один ряд, и так далее. Игра продолжается до тех пор, пока в какой-то момент у Бобра не останется ровно один камешек.</p>

  <p>Игровой процесс можно представить себе как конечную последовательность целых чисел c<sub>1</sub>, ..., c<sub>k</sub>, где:</p>
  <ul>
    <li>c<sub>1</sub> = n</li>
    <li>c<sub>i</sub> + 1 — количество камешков, которые останутся у Бобра после i-ого хода, то есть количество камешков в ряду некоторого разложения c<sub>i</sub> камешков (1 ≤ i &lt; k). Заметим, что c<sub>i</sub> > c<sub>i+1</sub>.</li>
    <li>c<sub>k</sub> = 1</li>
  </ul>

  <p>Результатом игры называется сумма чисел ci. Вам дано число n. Найдите максимальный возможный результат игры.</p>

  <h4>Входные данные</h4>
  <p>Единственная строка входных данных содержит единственное целое число n — начальное количество камешков у Умного Бобра.</p>

  <p>Ограничения на входные данные для получения 30 баллов:</p>
  <code>2 ≤ n ≤ 50</code>

  <p>Ограничения на входные данные для получения 100 баллов:</p>
  <code>2 ≤ n ≤ 10<sup>9</sup></code>

  <h4>Выходные данные</h4>
  <p>Выведите единственное целое число — максимальный возможный результат игры.</p>

  <h4>Пример 1</h4>
  <code>10</code>
  <code>16</code>
  <p>Рассмотрим первый пример (c<sub>1</sub> = 10). Возможные варианты развития игры:</p>
  <ul>
    <li>Можно разложить камешки в 10 рядов по одному в каждом. Тогда c<sub>2</sub> = 1, и игра закончится после первого же хода с результатом 11.</li>
    <li>Можно разложить камешки в 5 рядов по два камешка в каждом. Тогда c<sub>2</sub> = 2, и игра продолжается. На втором ходе 2 камешка можно разложить единственным способом (помните, что выкладывать все камешки в один ряд нельзя!) — в 2 ряда по одному камешку. c<sub>3</sub> = 1, и игра закончится с результатом 13.</li>
    <li>Наконец, можно разложить камешки в 2 ряда по пять камешков. Аналогичными рассуждениями получим c<sub>2</sub> = 5, c<sub>3</sub> = 1, и игра закончится с результатом 16 — максимальным из возможных.</li>
  </ul>

  <h4>Пример 2</h4>
  <code>8</code>
  <code>15</code>
</article>


<!-- R. Эпическая игра -->
<article class="article">
  <div class="anchor" id="task18"></div>
  <h3>Задача R. Эпическая игра</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Семен и Антисемен играют в игру. Изначально каждому игроку дано одно фиксированное целое положительное число, которое не меняется в процессе игры. Семену дано число a, Антисемену дано число b. Также у них есть кучка из n камней. Игроки ходят по очереди, первый ход делает Семен. На своем ходу игрок должен взять из кучки число камней, равное наибольшему общему делителю данного ему числа и количества оставшихся камней в кучке. Проигрывает тот, кто не сможет взять требуемое число камней (по причине того, что в кучке остается строго меньше камней, чем нужно взять).</p>

  <p>Ваша задача — по заданным a, b и n определить, кто выиграет в этой игре.</p>

  <h4>Входные данные</h4>
  <p>В единственной строке через пробел записаны целые числа a, b и n (1 ≤ a, b, n ≤ 100) — числа, данные Семену и Антисемену соответственно, и исходное количество камней в кучке.</p>

  <h4>Выходные данные</h4>
  <p>Если выиграет Семен, выведите «0» (без кавычек), иначе выведите «1» (без кавычек).</p>

  <h4>Пример 1</h4>
  <code>3 5 9</code>
  <code>0</code>
  <p>Наибольшим общим делителем двух неотрицательных целых чисел a и b называется такое наибольшее положительное целое число k, что a делится на k без остатка, и, аналогично, b делится на k без остатка. Обозначим через gcd(a, b) операцию вычисления наибольшего общего делителя чисел a и b. В частности, gcd(x, 0) = gcd(0, x) = x.</p>

  <p>В первом примере игра будет идти следующим образом:</p>
  <ol>
    <li>Семен должен взять из кучки gcd(3, 9) = 3 камня. После его хода в кучке остается 6 камней.</li>
    <li>Антисемен должен взять из кучки gcd(5, 6) = 1 камень. После его хода в кучке остается 5 камней.</li>
    <li>Семен должен взять из кучки gcd(3, 5) = 1 камень. После его хода в кучке остается 4 камня.</li>
    <li>Антисемен должен взять из кучки gcd(5, 4) = 1 камня. После его хода в кучке остается 3 камня.</li>
    <li>Семен должен взять из кучки gcd(3, 3) = 3 камня. После его хода в кучке остается 0 камней.</li>
    <li>Антисемен должен взять из кучки gcd(5, 0) = 5 камня. Так как 0 &lt; 5, это сделать невозможно, и Антисемен проигрывает.</li>
  </ol>

  <h4>Пример 2</h4>
  <code>1 1 100</code>
  <code>1</code>
  <p>Во втором примере каждый игрок на каждом ходу берет из кучки по одному камню. Так как n четное, последний камень возьмет Антисемен, а Семен после этого не сможет сделать ход.</p>

  <details>
    <summary>Решение</summary>
    <p>Напишем функцию gcd и смоделируем ход игры</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

// наибольший общий делитель
long long gcd(long long a, long long b) {
  while (a > 0 && b > 0) {
    if (a > b) {
      a = a % b;
    } else {
      b = b % a;
    }
  }
  return a + b;
}

int main() {
  // ввод данных
  long long a, b, n;
  cin >> a >> b >> n;

  // решение
  long long cnt = 0;
  while (n != 0) {
    if (cnt == 0) {
      n -= gcd(a, n);
      cnt = (cnt + 1) % 2;
    } else {
      n -= gcd(b, n);
      cnt = (cnt + 1) % 2;
    }
  }

  // вывод результата
  cout &lt;&lt; (cnt + 1) % 2;
}
</pre>
  </details>
</article>

