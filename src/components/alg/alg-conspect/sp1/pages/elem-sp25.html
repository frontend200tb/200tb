<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p>Конспект курса</p>
  <p><a href="https://vkvideo.ru/@sportprog_yarsu" target="_blank">vkvideo.ru/@sportprog_yarsu</a></p>
</article>


<article class="article">
  <h1>Занятие 25 ДП #3. Рюкзак</h1>
  <p>Конспект видео от 2025.03.22</p>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contest/598187" target="_blank">Codeforces Контест 598187</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
    <a href="#p1">ДП #3. Рюкзак</a>
  </p>
  <p>
        <a href="#task1">Задача A. Потешный рюкзак</a>
    <br><a href="#task2">Задача B. Непрерывный рюкзак</a>
    <br><a href="#task3">Задача C. 0-1 рюкзак</a>
    <br><a href="#task4">Задача D. Нормальный рюкзак</a>
    <br><a href="#task5">Задача E. За пригоршню монет</a>
    <br><a href="#task6">Задача F. Копилка</a>
    <br><a href="#task7">Задача G. Не нарушая границы</a>
    <br><a href="#task8">Задача H. Булочки</a>
    <br><a href="#task9">Задача I. Гангстеры</a>
    <br><a href="#task10">Задача J. Did he drop any good loot?</a>
    <br><a href="#task11">Задача K. Задача о прочном рюкзаке</a>
    <br><a href="#task12">Задача L. Дурак и молния</a>
  </p>
</article>


<!-- ДП #3. Рюкзак -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>ДП #3. Рюкзак</h3>

  <p>Задачи о рюкзаке не решаются жадным алгоритмом, сортировки и упорядочивание нам тоже не помогуь. Здесь надо применять чистое динамическое программирование.</p>

  <p>Постановка задачи:</p>
  <p>У нас есть n предметов, каждый из которых имеет собственную ценность cᵢ и собственный вес wᵢ. Рюкзак способен вместить вес равный s.</p>
  <p>Вопрос:</p>
  <p>Какие предметы следует брать, чтобы получить максимальную ценность?</p>
  <code>Сумма (от i=1 до n) aᵢcᵢ = C</code>
  <code>Сумма (от i=1 до n) aᵢwᵢ = W</code>
  <p>W ≤ s, max(C), aᵢ = 0 или 1.</p>

  <h4>Непрерывный рюкзак</h4>

  <p>Постановка задачи:</p>
  <p>У нас есть n предметов, каждый из которых имеет собственную ценность cᵢ и собственный вес wᵢ. Рюкзак способен вместить вес равный s.</p>
  <p>Вопрос:</p>
  <p>Какие предметы следует брать, чтобы получить максимальную ценность?</p>
  <code>Сумма (от i=1 до n) aᵢcᵢ = C</code>
  <code>Сумма (от i=1 до n) aᵢwᵢ = W</code>
  <p>W ≤ s, max(C), aᵢ = 0 или 1.</p>
  <p>Дополнительное условие:</p>
  <ul>
    <li>Мы можем делить предметы на части. (например слитки золота пилить ножовкой)</li>
  </ul>
  <p>Решение задачи:</p>
  <ol>
    <li>Собрать vector&lt;pair&lt;double, pair&lt;int,int&gt; &gt; &gt;, где first это цена за кг, second.first вес предмета, second.second номер предмета.</li>
    <li>Отсортировать вектор.</li>
    <li>Брать в первую очередь предметы самые дорогие за кг.</li>
    <li>Если предмет не помещается целиком, берем кусок, который помещается
   в рюкзак.</li>
  </ol>

  <h4>Рюкзак n ≤ 20</h4>

  <p>Постановка задачи:</p>
  <p>У нас есть n предметов, каждый из которых имеет собственную ценность cᵢ и собственный вес wᵢ. Рюкзак способен вместить вес равный s.</p>
  <p>Вопрос:</p>
  <p>Какие предметы следует брать, чтобы получить максимальную ценность?</p>
  <code>Сумма (от i=1 до n) aᵢcᵢ = C</code>
  <code>Сумма (от i=1 до n) aᵢwᵢ = W</code>
  <p>W ≤ s, max(C), aᵢ = 0 или 1.</p>
  <p>Дополнительное условие:</p>
  <ul>
    <li>n ≤ 20</li>
  </ul>
  <p>Количество предметов достаточно маленькое, что мы можем перебрать все  комбинации выбора предметов через bit маски O(2ⁿn):</p>
<pre>
vector&lt;int&gt; Mask(n + 1);
int best = 0;
for (int i = 0; i &lt; (1 &lt;&lt; n); i++) {
  int tmp = i, sum_c = 0, sum_w = 0;

  for (int j = 1; j &lt;= n; j++) {
    Mask[j] = tmp % 2;
    tmp /= 2;
  }

  for (int j = 1; j &lt;= n; j++) {
    if (Mask[j] == 1) {
      sum_c += C[j];
      sum_w += W[j];
    }
  }

  if (sum_w &lt;= s) {
    if (sum_c > best) {
      best = sum_c;
    }
  }
}
</pre>

  <h4>Рюкзак cᵢ = wᵢ</h4>

  <p>Постановка задачи:</p>
  <p>У нас есть n предметов, каждый из которых имеет собственную ценность cᵢ и собственный вес wᵢ. Рюкзак способен вместить вес равный s.</p>
  <p>Вопрос:</p>
  <p>Какие предметы следует брать, чтобы получить максимальную ценность?</p>
  <code>Сумма (от i=1 до n) aᵢcᵢ = C</code>
  <code>Сумма (от i=1 до n) aᵢwᵢ = W</code>
  <p>W ≤ s, max(C), aᵢ = 0 или 1.</p>
  <p>Дополнительное условие:</p>
  <ul>
    <li>cᵢ = wᵢ</li>
    <li>n * min(s, Сумма (от i=1 до n) wᵢ) ≤ 10⁷</li>
  </ul>


  <details>
    <summary>Рассмотрим конкретный пример:</summary>

  <p>Количество предметов: 5.</p>
  <p>Веса предметов: 4, 8, 4, 12, 7.</p>
  <p>Вместимость рюкзака: 13.</p>
  <p>Последовательно ответим на 5 вопросов ДП:</p>
  <p>1 Что храним?</p>
  <p>Создадим двумерный массив DP. В ячейке DP[i][j] будем хранить 0 если невозможно собрать вес равный j из первых i предметов, 1 если можно собрать вес равный j из первых i предметов.</p>
  <p>2 Как считаем ячейку?</p>
  <p>Если w[i] > j, то DP[i][j] = DP[i - 1][j];</p>
  <p>Если w[i] ≤ j, то DP[i][j] = max(DP[i - 1][j],DP[i - 1][j - w[i]]);</p>
  <p>3 Что является простейшим случаем? (база)</p>
  <p>При 0 предметов единственный вес, который мы можем собрать это ноль кг. Самый простой случай — это нулевая строка матрицы.</p>
  <p>4 Как обходить объект ДП?</p>
  <p>Классический обход слева направо сверху вниз, начиная с 1 строки.</p>
  <p>5 Где хранится ответ на задачу?</p>
  <p>Ответ хранится в последней строке, необходимо будет найти ячейку равную единице с максимальным значением столбца.</p>
    <p>Веса предметов: 4, 8, 4, 12, 7.</p>
    <p>База:</p>
<pre>
        0 1 2 3 4 5 6 7 8 9 10 11 12 13
0 пред. 1 0 0 0 0 0 0 0 0 0  0  0  0  0
1 пред. 0 0 0 0 0 0 0 0 0 0  0  0  0  0
2 пред. 0 0 0 0 0 0 0 0 0 0  0  0  0  0
3 пред. 0 0 0 0 0 0 0 0 0 0  0  0  0  0
4 пред. 0 0 0 0 0 0 0 0 0 0  0  0  0  0
5 пред. 0 0 0 0 0 0 0 0 0 0  0  0  0  0
</pre>
    <p>1 предмет:</p>
<pre>
        0 1 2 3 4 5 6 7 8 9 10 11 12 13
0 пред. 1 0 0 0 0 0 0 0 0 0  0  0  0  0
1 пред. 1 0 0 0 0 0 0 0 0 0  0  0  0  0
2 пред. 0 0 0 0 0 0 0 0 0 0  0  0  0  0
3 пред. 0 0 0 0 0 0 0 0 0 0  0  0  0  0
4 пред. 0 0 0 0 0 0 0 0 0 0  0  0  0  0
5 пред. 0 0 0 0 0 0 0 0 0 0  0  0  0  0
</pre>
    <p>1 предмет:</p>
<pre>
        0 1 2 3 4 5 6 7 8 9 10 11 12 13
0 пред. 1 0 0 0 0 0 0 0 0 0  0  0  0  0
1 пред. 1 0 0 0 1 0 0 0 0 0  0  0  0  0
2 пред. 0 0 0 0 0 0 0 0 0 0  0  0  0  0
3 пред. 0 0 0 0 0 0 0 0 0 0  0  0  0  0
4 пред. 0 0 0 0 0 0 0 0 0 0  0  0  0  0
5 пред. 0 0 0 0 0 0 0 0 0 0  0  0  0  0
</pre>
    <p>2 предмета:</p>
<pre>
        0 1 2 3 4 5 6 7 8 9 10 11 12 13
0 пред. 1 0 0 0 0 0 0 0 0 0  0  0  0  0
1 пред. 1 0 0 0 1 0 0 0 0 0  0  0  0  0
2 пред. 1 0 0 0 1 0 0 0 0 0  0  0  0  0
3 пред. 0 0 0 0 0 0 0 0 0 0  0  0  0  0
4 пред. 0 0 0 0 0 0 0 0 0 0  0  0  0  0
5 пред. 0 0 0 0 0 0 0 0 0 0  0  0  0  0
</pre>
    <p>2 предмета:</p>
<pre>
        0 1 2 3 4 5 6 7 8 9 10 11 12 13
0 пред. 1 0 0 0 0 0 0 0 0 0  0  0  0  0
1 пред. 1 0 0 0 1 0 0 0 0 0  0  0  0  0
2 пред. 1 0 0 0 1 0 0 0 1 0  0  0  1  0
3 пред. 0 0 0 0 0 0 0 0 0 0  0  0  0  0
4 пред. 0 0 0 0 0 0 0 0 0 0  0  0  0  0
5 пред. 0 0 0 0 0 0 0 0 0 0  0  0  0  0
</pre>
    <p>3 предмета:</p>
  <pre>
        0 1 2 3 4 5 6 7 8 9 10 11 12 13
0 пред. 1 0 0 0 0 0 0 0 0 0  0  0  0  0
1 пред. 1 0 0 0 1 0 0 0 0 0  0  0  0  0
2 пред. 1 0 0 0 1 0 0 0 1 0  0  0  1  0
3 пред. 1 0 0 0 1 0 0 0 1 0  0  0  1  0
4 пред. 0 0 0 0 0 0 0 0 0 0  0  0  0  0
5 пред. 0 0 0 0 0 0 0 0 0 0  0  0  0  0
</pre>
    <p>4 предмета:</p>
<pre>
        0 1 2 3 4 5 6 7 8 9 10 11 12 13
0 пред. 1 0 0 0 0 0 0 0 0 0  0  0  0  0
1 пред. 1 0 0 0 1 0 0 0 0 0  0  0  0  0
2 пред. 1 0 0 0 1 0 0 0 1 0  0  0  1  0
3 пред. 1 0 0 0 1 0 0 0 1 0  0  0  1  0
4 пред. 1 0 0 0 1 0 0 0 1 0  0  0  1  0
5 пред. 0 0 0 0 0 0 0 0 0 0  0  0  0  0
</pre>
    <p>5 предметов:</p>
<pre>
        0 1 2 3 4 5 6 7 8 9 10 11 12 13
0 пред. 1 0 0 0 0 0 0 0 0 0  0  0  0  0
1 пред. 1 0 0 0 1 0 0 0 0 0  0  0  0  0
2 пред. 1 0 0 0 1 0 0 0 1 0  0  0  1  0
3 пред. 1 0 0 0 1 0 0 0 1 0  0  0  1  0
4 пред. 1 0 0 0 1 0 0 0 1 0  0  0  1  0
5 пред. 1 0 0 0 1 0 0 1 1 0  0  1  1  0
</pre>
  </details>

  <p>Если в этой задаче сумма веса всех предметов меньше чем вес, который можно положить в рюкзак, то мы просто берем все предметы и кладем их в рюкзак.</p>

<pre>
// создаем матрицу, заполненную изначально нулями
vector&lt;vector&lt;int&gt; &gt; DP(n + 1, vector&lt;int&gt;(s + 1, 0));
// базовый случай
// заполняется первая строка матрицы
DP[0][0] = 1;

// для каждого предмета (для каждой строки)
for (int i = 1; i &lt;= n; i++) {
  // копируем предыдущую строку матрицы
  for (int j = 0; j &lt;= s; j++) {
    DP[i][j] = DP[i - 1][j];
  }
  for (int j = 0; j &lt;= s; j++) {
    // проверяем что вес который мы хотим собрать
    // больше веса текущего предмета
    // нельзя положить вес, превышающий вес рюкзака
    if (j >= W[i]) {
      // если по диагонали в предыдущей строке стоит 1
      if (DP[i - 1][j - W[i]] == 1) {
        // то в текущей ячейке ставим 1
        DP[i][j] = 1;
      }
    }
  }
}

int ans = 0;
// ответ ищем в последней строке матрицы
for (int j = 0; j &lt;= s; j++) {
  if (DP[n][j] == 1) {
    ans = j;
  }
}

cout &lt;&lt; ans;
</pre>


  <h4>Классический рюкзак</h4>

  <p>Постановка задачи:</p>
  <p>У нас есть n предметов, каждый из которых имеет собственную ценность cᵢ и собственный вес wᵢ. Рюкзак способен вместить вес равный s.</p>
  <p>Вопрос:</p>
  <p>Какие предметы следует брать, чтобы получить максимальную ценность?</p>
  <code>Сумма (от i=1 до n) aᵢcᵢ = C</code>
  <code>Сумма (от i=1 до n) aᵢwᵢ = W</code>
  <p>W ≤ s, max(C), aᵢ = 0 или 1.</p>
  <p>Дополнительное условие:</p>
  <ul>
    <li>n * min(s, Сумма (от i=1 до n) wᵢ) ≤ 10⁷</li>
  </ul>
  <p>Дополнительное условие говорит, что максимальный объект будет размером 10⁷. Такой объект можно создать за 1с. Еслы бы объект был еще больше, то это уже TL (превышение ограничения по времени).</p>

  <details>
    <summary>Рассмотрим конкретный пример:</summary>

    <p>Количество предметов: 5.</p>
    <p>Веса предметов: 4, 8, 4, 12, 7.</p>
    <p>Цена предметов: 4, 10, 5, 18, 20.</p>
    <p>Вместимость рюкзака: 13.</p>
    <p>Последовательно ответим на 5 вопросов ДП:</p>
    <p>1 Что храним?</p>
    <p>Создадим двумерный массив DP. В ячейке DP[i][j] будем хранить -1 если невозможно собрать вес равный j из первых i предметов, целое положительное если можно собрать вес равный j из первых i предметов.</p>
    <p>2 Как считаем ячейку?</p>
    <p>Если w[i] > j, то DP[i][j] = DP[i - 1][j];</p>
    <p>Если w[i] ≤ j, то DP[i][j] = max(DP[i - 1][j],DP[i - 1][j - w[i]] + c[i]);</p>
    <p>3 Что является простейшим случаем? (база)</p>
    <p>При 0 предметов единственный вес, который мы можем собрать это ноль кг. Самый простой случай это нулевая строка матрицы.</p>
    <p>4 Как обходить объект ДП?</p>
    <p>Классический обход слева направо сверху вниз, начиная с 1 строки.</p>
    <p>5 Где хранится ответ на задачу?</p>
    <p>Ответ хранится в последней строке, необходимо будет найти ячейку с  максимальным значением.</p>
    <p>Веса предметов: 4, 8, 4, 12, 7.</p>
    <p>Цена предметов: 4, 10, 5, 18, 20.</p>
    <p>База:</p>
<pre>
         0  1  2  3  4  5  6  7  8  9 10 11 12 13
0 пред.  0 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
1 пред. -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
2 пред. -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
3 пред. -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
4 пред. -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
5 пред. -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
</pre>
    <p>1 предмет:</p>
<pre>
         0  1  2  3  4  5  6  7  8  9 10 11 12 13
0 пред.  0 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
1 пред.  0 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
2 пред. -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
3 пред. -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
4 пред. -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
5 пред. -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
</pre>
    <p>1 предмет:</p>
<pre>
         0  1  2  3  4  5  6  7  8  9 10 11 12 13
0 пред.  0 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
1 пред.  0 -1 -1 -1  4 -1 -1 -1 -1 -1 -1 -1 -1 -1
2 пред. -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
3 пред. -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
4 пред. -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
5 пред. -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
</pre>
    <p>2 предмета:</p>
<pre>
         0  1  2  3  4  5  6  7  8  9 10 11 12 13
0 пред.  0 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
1 пред.  0 -1 -1 -1  4 -1 -1 -1 -1 -1 -1 -1 -1 -1
2 пред.  0 -1 -1 -1  4 -1 -1 -1 10 -1 -1 -1 14 -1
3 пред. -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
4 пред. -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
5 пред. -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
</pre>
    <p>3 предмета:</p>
<pre>
         0  1  2  3  4  5  6  7  8  9 10 11 12 13
0 пред.  0 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
1 пред.  0 -1 -1 -1  4 -1 -1 -1 -1 -1 -1 -1 -1 -1
2 пред.  0 -1 -1 -1  4 -1 -1 -1 10 -1 -1 -1 14 -1
3 пред.  0 -1 -1 -1  4 -1 -1 -1 10 -1 -1 -1 14 -1
4 пред. -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
5 пред. -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
</pre>
    <p>3 предмета:</p>
<pre>
         0  1  2  3  4  5  6  7  8  9 10 11 12 13
0 пред.  0 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
1 пред.  0 -1 -1 -1  4 -1 -1 -1 -1 -1 -1 -1 -1 -1
2 пред.  0 -1 -1 -1  4 -1 -1 -1 10 -1 -1 -1 14 -1
3 пред.  0 -1 -1 -1  5 -1 -1 -1 10 -1 -1 -1 15 -1
4 пред. -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
5 пред. -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
</pre>
    <p>4 предмета:</p>
<pre>
         0  1  2  3  4  5  6  7  8  9 10 11 12 13
0 пред.  0 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
1 пред.  0 -1 -1 -1  4 -1 -1 -1 -1 -1 -1 -1 -1 -1
2 пред.  0 -1 -1 -1  4 -1 -1 -1 10 -1 -1 -1 14 -1
3 пред.  0 -1 -1 -1  5 -1 -1 -1 10 -1 -1 -1 15 -1
4 пред.  0 -1 -1 -1  5 -1 -1 -1 10 -1 -1 -1 18 -1
5 пред. -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
</pre>
    <p>5 предмета:</p>
<pre>
         0  1  2  3  4  5  6  7  8  9 10 11 12 13
0 пред.  0 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
1 пред.  0 -1 -1 -1  4 -1 -1 -1 -1 -1 -1 -1 -1 -1
2 пред.  0 -1 -1 -1  4 -1 -1 -1 10 -1 -1 -1 14 -1
3 пред.  0 -1 -1 -1  5 -1 -1 -1 10 -1 -1 -1 15 -1
4 пред.  0 -1 -1 -1  5 -1 -1 -1 10 -1 -1 -1 18 -1
5 пред.  0 -1 -1 -1  5 -1 -1 20 10 -1 -1 25 18 -1
</pre>
    <p>Восстановление ответа:</p>
<pre>
         0  1  2  3  4  5  6  7  8  9 10 11 12 13
0 пред.  0 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
1 пред.  0 -1 -1 -1  4 -1 -1 -1 -1 -1 -1 -1 -1 -1
2 пред.  0 -1 -1 -1  4 -1 -1 -1 10 -1 -1 -1 14 -1
3 пред.  0 -1 -1 -1  5 -1 -1 -1 10 -1 -1 -1 15 -1
4 пред.  0 -1 -1 -1  5 -1 -1 -1 10 -1 -1 -1 18 -1
5 пред.  0 -1 -1 -1  5 -1 -1 20 10 -1 -1 25 18 -1
</pre>
  </details>

<pre>
// создаем матрицу, заполненную изначально -1
vector&lt;vector&lt;int&gt; &gt; DP(n + 1, vector&int;int&gt;(s + 1, -1));
// базовый случай
// заполняется первая строка матрицы
DP[0][0] = 0;

// для каждого предмета (для каждой строки)
for (int i = 1; i &lt;= n; i++) {
  // копируем предыдущую строку матрицы
  for (int j = 0; j &lt;= s; j++) {
    DP[i][j] = DP[i - 1][j];
  }
  for (int j = 0; j &lt;= s; j++) {
    // проверяем что вес который мы хотим собрать
    // больше веса текущего предмета
    // нельзя положить вес, превышающий вес рюкзака
    if (j >= W[i]) {
      // если по диагонали в предыдущей строке не стоит -1
      if (DP[i - 1][j - W[i]] != -1) {
        // то в текущей ячейке ставим максимум из того
        // что было в предыдущей строке и текущий вес
        // + вес из прошлой строки по диагонали
        DP[i][j] = max(DP[i][j], DP[i - 1][j - W[i]] + C[i]);
      }
    }
  }
}

int ans = 0;
for (int j = 0; j &lt;= s; j++) {
  if (DP[n][j] > ans) {
    ans = DP[n][j];
  }
}

cout &lt;&lt; ans;
</pre>

  <h4>Восстановление ответа</h4>
  <p>Соберем все предметы, которые дали максимальный результат.</p>
<pre>
int ans = 0, pos = 0;
vector&lt;int&gt; Res;

// проходим по последней строке
for (int j = 0; j &lt;= s; j++) {
  // выбираем максимум
  if (DP[n][j] > ans) {
    // записываем максимум в ответ
    ans = DP[n][j];
    // запоминаем позицию максимального элемента
    pos = j;
  }
}

// проходим по строчкам снизу вверх
// начинаем с позиции максимального элемента
for (int i = n; i > 0; i--) {
  // если значение не совпадает со значением
  // в предыдущей строке
  if (DP[i][pos] != DP[i - 1][pos]) {
    // заносим предмет в результат
    Res.push_back(i);
    // переходим к позиции по диагонали
    pos = pos - W[i];
  }
}

for (int i = 0; i &lt; Res.size(); i++) {
  cout &lt;&lt; Res[i] &lt;&lt; " ";
}
</pre>

  <h4>Усложнения рюкзака</h4>
  <ul>
    <li>Предметы могут весить 0 кг. (Предметы, которые ничего не весят, всегда берутся в рюкзак)</li>
    <li>Количество способов движения по матрице больше. (Становится более сложный выбор для определения значения в позиции DP[i][j]). Например, в текущую позицию в матрице мы можем попасть не только из строчки выше или по диагонали.</li>
    <li>У предмета больше вариантов выбора чем берем не берем в рюкзак. (многомерный рюкзак vector&lt;vector&lt;vector&lt;int&gt; &gt; &gt;). Например, обычный рюкзак двух мерный, хранящий одно из двух значений: 0 - не берем предмет, 1 - берем предмет. Рюкзак может быть трехмерный (содержит 0, 1 или 2) или четырехмерный (0, 1, 2, 3).</li>
  </ul>
</article>


<!-- Задача A. Потешный рюкзак -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Потешный рюкзак</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У вас есть n слитков золота, каждый имеет свой вес. Также у вас есть рюкзак вместимости S. Необходимо вычислить максимальный вес, который вы можете с собой унести. Вы можете дробить слитки.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано два целых числа S и N (1 ≤ S ≤ 10⁴; 1 ≤ N ≤ 300).</p>

  <p>Во второй строке записаны n целых чисел - веса слитков. Каждый слиток имеет неотрицательный вес, не превосходящий 10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное число - максимальный суммарный вес, который вы можете унести.</p>

  <h4>Пример 1</h4>
<pre>
10 6
2 3 4 4 6 9
</pre>
  <code>10</code>

  <h4>Пример 2</h4>
<pre>
10 6
1 1 1 1 1 1
</pre>
  <code>6</code>
</article>


<!-- Задача B. Непрерывный рюкзак -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Непрерывный рюкзак</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У вас есть n слитков золота, каждый имеет свой вес и стоимость. Также у вас есть рюкзак вместимости S. Необходимо вычислить максимальную суммарную стоимость слитков, которую вы можете получить. Вы можете дробить слитки. В таком случае стоимость слитка будет уменьшаться пропорционально весу слитка.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано два целых числа S и N (1 ≤ S ≤ 10⁴; 1 ≤ N ≤ 300).</p>

  <p>Во второй строке записаны n целых чисел - веса слитков. Каждый слиток имеет неотрицательный вес, не превосходящий 10⁵.</p>

  <p>В третьей строке записаны еще n целых чисел - стоимости слитков. Каждый слиток имеет неотрицательную стоимость, не превосходящую 10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное число - максимальную суммарную стоимость, которую вы можете унести. Если ответ получается не целым, округлите его вверх до ближайшего целого.</p>

  <h4>Пример</h4>
<pre>
8 4
2 4 4 7
2 5 5 9
</pre>
  <code>11</code>
</article>


<!-- Задача C. 0-1 рюкзак -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. 0-1 рюкзак</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У вас есть n слитков золота, каждый имеет свой вес и стоимость. Также у вас есть рюкзак вместимости S. Необходимо вычислить максимальную суммарную стоимость слитков, которую вы можете получить. Вы не можете дробить слитки.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано два целых числа S и N (1 ≤ S ≤ 10⁴; 1 ≤ N ≤ 300).</p>

  <p>Во второй строке записаны n целых чисел - веса слитков. Каждый слиток имеет неотрицательный вес, не превосходящий 10⁵.</p>

  <p>В третьей строке записаны еще n целых чисел - стоимости слитков. Каждый слиток имеет неотрицательную стоимость, не превосходящую 10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное число - максимальную суммарную стоимость, которую вы можете унести.</p>

  <h4>Пример</h4>
<pre>
8 4
2 4 4 7
2 5 5 9
</pre>
  <code>10</code>
</article>


<!-- Задача D. Нормальный рюкзак -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Нормальный рюкзак</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У вас есть n слитков золота, каждый имеет свой вес. Также у вас есть рюкзак вместимости S. Необходимо вычислить максимальный вес, который вы можете с собой унести. Вы не можете дробить слитки.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано два целых числа S и N (1 ≤ S ≤ 10⁴; 1 ≤ N ≤ 300).</p>

  <p>Во второй строке записаны n целых чисел - веса слитков. Каждый слиток имеет неотрицательный вес, не превосходящий 10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное число - максимальный суммарный вес, который вы можете унести.</p>

  <h4>Пример 1</h4>
<pre>
10 6
2 3 4 4 6 9
</pre>
  <code>10</code>

  <h4>Пример 2</h4>
<pre>
10 6
1 1 1 1 1 1
</pre>
  <code>6</code>
</article>


<!-- Задача E. За пригоршню монет -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. За пригоршню монет</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Однажды злой грабитель, проникший в банк, обнаружил в сейфе k слитков золота с массами w1, w2, ..., wk килограмм. Он сразу же оценил стоимость iого слитка в pᵢ бурлей. Его рюкзак сможет вместить лишь W килограмм золота. Ему поручили украсть слитки на максимальную стоимость, причем запомнить номера украденных слитков. Он очень мало думал и поэтому забыл какие слитки взял.</p>

  <p>А сможете ли вы посчитать максимальную стоимость и вывести номера взятых слитков, если вам известны все эти данные.</p>

  <h4>Входные данные</h4>
  <p>В первой строчке входных данных находятся два числа k и W (1 ≤ k, W ≤ 5000) - количество слитков и максимальный вес соответственно.</p>

  <p>Во второй строчке через пробел перечислены k чисел - веса слитков(1 ≤ wᵢ ≤ 5000).</p>

  <p>В третьей же строчке через пробел указаны k чисел pᵢ (1 ≤ pᵢ ≤ 10⁹) - цена iого слитка соответственно.</p>

  <h4>Выходные данные</h4>
  <p>Если ответа нет, то выведите -1 в единственной строчке.</p>

  <p>Иначе в первой строке выведите два числа C и N - максимальная стоимость и количество взятых слитков соответственно. Во второй строке перечислите через пробел N значений - номера взятых слитков.</p>

  <h4>Пример</h4>
<pre>
5 15
6 4 3 2 5
5 3 1 3 6
</pre>
<pre>
14 3
1 4 5
</pre>
  <p>Выходит, что -1 следует выводить, если невозможно взять ни одного слитка</p>
</article>


<!-- Задача F. Копилка -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Копилка</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 16мб</i></div>

  <p>Задан вес E пустой копилки и вес F копилки с монетами. В копилке могут находиться монеты N видов, для каждого вида известна ценность Pᵢ и вес Wᵢ одной монеты. Найти минимальную и максимальную суммы денег, которые могут находиться в копилке.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных находятся числа E и F, во второй - число N, в следующих N строках - по два числа, Pᵢ и Wᵢ. (1 ≤ E ≤ F ≤ 10000, 1 ≤ N ≤ 500, 1 ≤ Pᵢ ≤ 50000, 1 ≤ Wᵢ ≤ 10000).</p>

  <h4>Выходные данные</h4>
  <p>Выведите два числа через пробел - минимальную и максимальную суммы. Если копилка не может иметь точно заданный вес при условии, что она наполнена монетами заданных видов, следует вывести "This is impossible." (Без кавычек).</p>

  <h4>Пример 1</h4>
<pre>
1000 1100
2
1 1
5 2
</pre>
  <code>100 250</code>

  <h4>Пример 2</h4>
<pre>
1000 1010
2
6 3
2 2
</pre>
  <code>10 16</code>

  <h4>Пример 3</h4>
<pre>
1000 2000
1
10 3
</pre>
  <code>This is impossible.</code>

  <details>
    <summary>Решение</summary>
<pre>
#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;

using namespace std;


int main() {
  // ускорение ввода
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  // ввод данных
  long long E, F;
  cin >> E >> F;
  int n;
  cin >> n;
  vector&lt;pair&lt;long long, long long&gt; &gt; A(n + 1);
  for (int i = 1; i &lt;= n; i++) {
    cin >> A[i].first >> A[i].second;
  }

  // решение
  // вес монет
  long long S = F - E;
  // матрица в которой будут все веса
  // которые мы можем собрать из монет
  vector&lt;int&gt; Mark(S + 1);
  vector&lt;long long&gt; Max_val(S + 1, 0);
  vector&lt;long long&gt; Min_val(S + 1, 1e12);
  // когда нет монет, то стоимость равна 0
  Min_val[0] = 0;

  // базовый случай, когда монет 0
  Mark[0] = 1;

  // собираем рюкзак по слоям
  // каждая строчка собирается из предыдущей строчки
  // проходим по номиналам монет
  for (int j = 1; j &lt;= n; j++) {
    // пока вес монет помещается в копилку
    for (int i = 0; i &lt;= S; i++) {
      // если можем добавить еще монету
      if (i + A[j].second &lt;= S && Mark[i] == 1) {
        Mark[i + A[j].second] = 1;
        Max_val[i + A[j].second] = max(Max_val[i + A[j].second], Max_val[i] + A[j].first);
        Min_val[i + A[j].second] = min(Min_val[i + A[j].second], Min_val[i] + A[j].first);
      }
    }
  }

  // вывод результата
  // если собрали необходимый вес
  if (Mark[S] == 1) {
    // выводим мин и макс
    cout &lt;&lt; Min_val[S] &lt;&lt; " " &lt;&lt; Max_val[S];
    // иначе
  } else {
    // выводим что это невозможно
    cout &lt;&lt; "This is impossible.";
  }
}
</pre>
  </details>
</article>


<!-- Задача G. Не нарушая границы -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Не нарушая границы</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>— Хорошая игра, — Принцесса произнесла это немного отстранённо; было понятно, что она думает о чём-то другом.</p>

  <p>— В Долине Замков любят играть в разные игры. И сами их придумывают. Вот, к примеру, мой знакомый Рыцарь недавно играл в одну игру с одной принцессой, — Дракон решил, что нужно рассказать Принцессе про другую игру: быть может, предыдущая не показалась ей особо интересной.</p>

  <p>Принцесса А. предложила Рыцарю сыграть с ней в игру с числами. Она записала на листе бумаги число 0. Назовём это число текущим результатом.</p>

  <p>Дальнейшие ходы принцессы А. и Рыцаря состоят в следующем. Она называет некоторое целое положительное число, а Рыцарь говорит, что нужно сделать с этим числом: прибавить его к текущему результату или же отнять его из текущего результата.</p>

  <p>Принцесса А. выполняет действие, предложенное Рыцарем, и вычисляет полученное значение. Это значение и становится новым текущим результатом.</p>

  <p>Принцесса А. желает, чтобы текущий результат всегда был не меньше нуля и не больше k. Игра заканчивается, когда Рыцарь не может сделать очередной ход (т.е. любое действие приводит к выходу за границы указанного диапазона) или же когда принцесса А. исчерпает задуманную ей последовательность из n чисел.</p>

  <p>Рыцарю удалось узнать, какую последовательность из n чисел принцесса задумала, и теперь он хочет, чтобы игра продлилась как можно дольше.</p>

  <p>Ваша задача — определить максимально возможное количество ходов, которое сможет сделать Рыцарь в игре.</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержатся целые числа n и k (1 ≤ n ≤ 1000, 1 ≤ k ≤ 1000) — количество чисел в последовательности, задуманной принцессой А., и значение, которое не должен превосходить текущий результат.</p>

  <p>Во второй строке содержится n целых чисел c1, c2, ..., cn (1 ≤ cj ≤ k) — последовательность, задуманная принцессой А.</p>

  <h4>Выходные данные</h4>
  <p>В первой строке выведите целое число d — максимально возможное количество ходов, которые может сделать Рыцарь.</p>

  <p>Во второй строке выведите d символов «+» и «–». Символ, стоящий на позиции #j, обозначает, какую операцию следует применить к числу #j из списка принцессы. Если существует несколько способов сделать d ходов, то выведите любой из них.</p>

  <h4>Пример 1</h4>
<pre>
2 5
3 2
</pre>
<pre>
2
++
</pre>

  <h4>Пример 2</h4>
<pre>
5 5
1 2 3 4 5
</pre>
<pre>
4
++-+
</pre>
</article>


<!-- Задача H. Булочки -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Булочки</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Пекарь Лаврентий собирается испечь несколько булочек с начинкой на продажу.</p>

  <p>У Лаврентия есть n грамм теста, а так же m различных видов начинки. Виды начинки пронумерованы натуральными числами от 1 до m. Лаврентий знает, что i-го вида начинки у него осталось aᵢ грамм. Чтобы испечь одну булочку с i-ой начинкой, нужно ровно bᵢ грамм этой начинки и cᵢ грамм теста, а продать одну такую булочку можно за dᵢ тугриков.</p>

  <p>Кроме того, он может испечь булочки без начинки. На каждую такую булочку нужно c₀ грамм теста, а продать такую булочку можно за d₀ тугриков. Лаврентий может испечь любое количество булочек с различными начинками или без начинки, если для этого хватит теста и начинки. Все излишки, которые остались после выпечки, Лаврентий выкидывает.</p>

  <p>Определите какое максимальное количество тугриков Лаврентий может заработать.</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержатся 4 целых числа n, m, c₀ и d₀ (1 ≤ n ≤ 1000, 1 ≤ m ≤ 10, 1 ≤ c₀ , d₀ ≤ 100). В каждой из последующих m строк содержится по 4 целых числа. В i-ой из них находятся числа aᵢ , bᵢ , cᵢ и dᵢ (1 ≤ aᵢ , bᵢ , cᵢ , dᵢ ≤ 100).</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное число — максимальное количество тугриков, которые Лаврентий может заработать.</p>

  <h4>Пример 1</h4>
<pre>
10 2 2 1
7 3 2 100
12 3 1 10
</pre>
  <code>241</code>

  <h4>Пример 2</h4>
<pre>
100 1 25 50
15 5 20 10
</pre>
  <code>200</code>

  <p>Чтобы получить наибольшее количество тугриков в первом примере, нужно испечь 2 булочки с начинкой 1, 4 булочки с начинкой 2 и одну булочку без начинки.</p>

  <p>Во втором примере имеет смысл испечь только 4 булочки без начинки.</p>

  <details>
    <summary>Решение</summary>
    <p>Если решать при помощи ООП, то создаются структуры данных о булочках, сколько нужно теста, сколько начинки, сколько булочка будет стоить. Но в спортивном программировании можно не создавать структуры данных, а использовать стандартную структуру pair, вкладывать pair в pair.</p>
<pre>
#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;

using namespace std;


int main() {
  // ускорение ввода
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  // ввод данных
  int n, m;
  cin >> n >> m;
  // вектор - это рюкзак
  vector&lt;vector&lt;long long&gt; &gt; DP(m + 1, vector&lt;long long&gt;(n + 1, -1));
  // базовый случай
  // за 0 грамм теста получаем 0 тугриков
  DP[0][0] = 0;
  long long c0, d0;
  cin >> c0 >> d0;

  // нулевая строка не стандартная. если у нас нет начинки
  // то мы можем делать булочки без начинки
  for (int i = 1; i &lt;= n; i++) {
    if (i % c0 == 0) {
      DP[0][i] = DP[0][i - c0] + d0;
    }
  }

  // аналог структуры данных Булочка
  vector&lt;pair&lt;pair&lt;int, int&gt;, pair&lt;int, int&gt; &gt; &gt; Elem(m + 1);
  for (int i = 1; i &lt;= m; i++) {
    cin >> Elem[i].first.first >> Elem[i].first.second;
    cin >> Elem[i].second.first >> Elem[i].second.second;
  }

  // вспомогательный массив
  vector&lt;long long&gt; Buf(n + 1);

  // запускаем рюкзак
  // проходим по всем видам начинки
  for (int i = 1; i &lt;= m; i++) {
    // проходим по граммам теста
    for (int j = 0; j &lt;= n; j++) {
      // копируем предыдущую строку
      DP[i][j] = DP[i - 1][j];
      Buf[j] = 0;
    }

    for (int j = 0; j &lt;= n; j++) {
      if (DP[i][j] != -1) {
        for (int count = 1; count &lt;= Elem[i].first.first / Elem[i].first.second &&
          count * Elem[i].second.first + j &lt;= n; count++) {
          Buf[j + count * Elem[i].second.first] = max(Buf[j + count * Elem[i].second.first],
          DP[i][j] + count * Elem[i].second.second);
        }
      }
      DP[i][j] = max(DP[i][j], Buf[j]);
    }
  }

  long long result = 0;
  for (int j = 0; j &lt;= n; j++) {
    result = max(result, DP[m][j]);
  }

  // вывод результата
  cout &lt;&lt; result;
}
</pre>
  </details>
</article>


<!-- Задача I. Гангстеры -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача I. Гангстеры</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 32мб</i></div>

  <p>N гангстеров собираются в ресторан. i-й гангстер приходит в момент времени Ti и имеет богатство Pi. Дверь ресторана имеет K + 1 степень открытости, они обозначаются целыми числами из интервала [0, K]. Степень открытости двери может изменяться на единицу в единицу времени, то есть дверь может открыться на единицу, закрыться на единицу или остаться в том же состоянии. В начальный момент времени дверь закрыта (степень открытости 0). i-й гангстер заходит в ресторан, только если дверь открыта специально для него, то есть когда степень открытости двери соответствует его полноте Si. Если в момент, когда гангстер подходит к ресторану, степень открытости двери меньше его полноты, он уходит и больше не возвращается. Ресторан работает в интервале времени [0, T].</p>

  <p>Требуется собрать гангстеров с максимальным суммарным богатством в ресторане, открывая и закрывая дверь соответствующим образом.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных находятся числа N, K, T, во второй - T1, T2 , ...,  TN, в третьей - P1, P2 , ...,  PN. в четвёртой - S1, S2 , ...,  SN. Числа в строках разделены пробелами. Ограничения:1 ≤ N ≤ 100, 1 ≤ K ≤ 100, 1 ≤ T ≤ 30000, 0 ≤ Ti ≤ T, 1 ≤ Pi ≤ 300, 1 ≤ Si ≤ K.</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно число - максимальное суммарное богатство гангстеров, попавших в ресторан. Если зайти не удалось никому, вывести 0.</p>

  <h4>Пример 1</h4>
<pre>
4 10 20
10 16 8 16
10 11 15 1
10 7 1 8
</pre>
  <code>26</code>

  <h4>Пример 2</h4>
<pre>
2 17 100
5 0
50 33
6 1
</pre>
  <code>0</code>
</article>


<!-- Задача J. Did he drop any good loot? -->
<article class="article">
  <div class="anchor" id="task10"></div>
  <h3>Задача J. Did he drop any good loot?</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Слава играет в очень крутую RPG. Он зачистил подземелье, выбил n крутых артефактов и теперь хочет как можно выгоднее их продать. Для каждого артефакта Слава знает его цену pi и массу wi. Слава не может унести на продажу артефакты с суммарной массой более m. Но Слава может активировать некоторые артефакты. При активации i-ый артефакт увеличивает Славину силу и прибавляет к пределу переносимой массы di (активированные артефакты не исчезают, их стоимость и масса не изменяются, их также можно потом продать). Одновременно Слава может иметь активированными не более 2 артефактов.</p>

  <p>Более формально, Слава хочет выбрать множество артефактов с максимальной суммарной стоимостью среди всех корректных множеств. Множество артефактов i1, i2, ..., ik (k ≤ n) называется корректным, если wi1 + wi2 + ... + wik ≤ m + s, где s — эффект от активации артефактов: s = dj1 + dj2, если Слава активировал артефакты j1 и j2 (j1 ≠ j2), s = dj — если он активировал только артефакт j, и s = 0, если Слава не активировал артефакты (j1, j2 и j обязаны входить в множество взятых артефактов i1, i2, ..., ik).</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержатся два целых числа через пробел: n и m (1 ≤ n ≤ 10⁴, 1 ≤ m ≤ 500) — количество артефактов и максимальная масса, которую способен унести Слава, соответственно.</p>

  <p>Далее в n строках содержатся по три целых числа через пробел: pᵢ, wᵢ и dᵢ (1 ≤ pᵢ ≤ 10⁵, 1 ≤ wᵢ ≤ 100, 0 ≤ dᵢ ≤ 100) — соответственно стоимость артефакта, его масса, а также прибавка к пределу переносимой массы, которую он даёт при активации.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное целое число — максимальную суммарную стоимость унесённых Славой артефактов.</p>

  <h4>Пример 1</h4>
<pre>
5 10
1 5 3
2 4 0
3 2 2
4 1 4
5 3 1
</pre>
  <code>15</code>

  <h4>Пример 2</h4>
<pre>
3 10
100 100 20
200 80 30
300 60 40
</pre>
  <code>0</code>
  <p>В первом тесте Слава не может просто так взять все артефакты — он может унести только массу до 10, а суммарная масса артефактов — 15. Поэтому Слава активирует артефакты 1 и 4, после чего его предел переносимой массы становится равным 10 + 3 + 4 = 17 (Слава также мог активировать любую пару артефактов, дающих в сумме прибавку 5 или более).</p>
  <p>Во втором тесте Слава не может унести никакие артефакты — ни с активацией некоторых, ни без оной.</p>
</article>


<!-- Задача K. Задача о прочном рюкзаке -->
<article class="article">
  <div class="anchor" id="task11"></div>
  <h3>Задача K. Задача о прочном рюкзаке</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 512мб</i></div>

  <p>Задача о рюкзаке — классическая задача информатики.</p>

  <p>Её формулировка такова: есть n предметов, для каждого из которых известны его вес wi и стоимость costi. Также задана грузоподъёмность рюкзака W — ограничение на суммарный вес предметов, которые вы можете взять. Требуется выбрать несколько предметов с суммарным весом не более W так, чтобы их суммарная стоимость была как можно больше.</p>

  <p>В этой задаче вам не требуется решить классическую задачу о рюкзаке. Жюри уже решило её и нашло точный ответ: максимальная возможная суммарная стоимость предметов, влезающих в рюкзак грузоподъёмности W, равна x. Это число жюри вам не сообщает.</p>

  <p>Ваша задача  — решить «задачу о прочном рюкзаке». Теперь рюкзак заявленной грузоподъёмности W может выдержать вес до 3/2 W. Вам нужно решить задачу с ослабленным ограничением не хуже, чем жюри решило задачу с ограничением W.</p>

  <p>Иными словами, вам нужно выбрать набор предметов, суммарная стоимость которых не меньше x, а суммарный вес  — не более 3/2 W.</p>

  <p>Вам необходимо решить задачу для t наборов входных данных.</p>

  <h4>Входные данные</h4>
  <p>В первой строке задано количество наборов входных данных. Далее идут сами наборы в следующем формате.</p>

  <p>Первая строка описания содержит целые числа n и W (1 ≤ n ≤ 10⁵; 1 ≤ W ≤ 10¹²) — количество предметов и заявленная грузоподъёмность рюкзака.</p>

  <p>Каждая из следующих n строк содержит целые числа wᵢ и costᵢ (1 ≤ wᵢ, costᵢ ≤ 10⁶) — вес и стоимость очередного предмета.</p>

  <p>Гарантируется, что сумма значений n по всем наборам входных данных не превышает 10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите, какие предметы нужно взять при ограничении веса 3/2 W, в следующем формате.</p>

  <p>На первой строке выведите количество выбранных предметов k.</p>

  <p>На второй строке перечислите номера выбранных предметов i1, i2, ... , ik (1 ≤ i<sub>j</sub> ≤ n). Выведенные вами номера i<sub>j</sub> должны быть различны. Предметы нумеруются от 1 до n в том порядке, в котором они приведены в тесте.</p>

  <p>Если решений несколько, выведите любое из них.</p>

  <h4>Пример</h4>
<pre>
3
3 10
5 100
5 100
4 99
3 100
97 100
98 101
99 90
3 100
55 100
99 150
200 200
</pre>
<pre>
3
3 1 2
1
2
1
2
</pre>
</article>


<!-- Задача L. Дурак и молния -->
<article class="article">
  <div class="anchor" id="task12"></div>
  <h3>Задача L. Дурак и молния</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>
  <p>У Игоря есть мечта — поймать молнию. Поймать целую молнию очень трудно, поэтому Игорь решил собрать ее из осколков, оставляемых молнией после удара в землю. Каждый осколок имеет свой вес wᵢ и энергию kᵢ, иногда молния оставляет после себя чистый сгусток энергии без веса.</p>

  <p>Чтобы собрать молнию Игорь купил локатор «P-328», показывающий осколки молний, их вес wᵢ и оставшуюся в них энергию kᵢ, и энергоемкий рюкзак «EB-17», который способен удерживать заряд любой мощи и нести вес не более чем b.</p>

  <p>Определите, какой максимальный размер энергии Игорь сможет унести в своем рюкзаке.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записаны числа n, b (1 ≤ n ≤ 10⁵, 0 ≤ b ≤ 10⁷) — количество осколков молнии и вместимость рюкзака.</p>

  <p>Далее в n строках задано по два числа wᵢ и kᵢ (0 ≤ wᵢ, kᵢ ≤ 10⁵) — вес осколка молнии и его энергетический уровень.</p>

  <p>Гарантируется, что n*∑(от i=1 до n)wᵢ ≤ 10⁷.</p>

  <h4>Выходные данные</h4>
  <p>Выведите целое число — максимально возможный заряд молнии, который сможет вместить рюкзак Игоря.</p>

  <h4>Пример 1</h4>
<pre>
3 6
4 9
3 5
3 5
</pre>
  <code>10</code>

  <h4>Пример 2</h4>
<pre>
5 10
3 20
4 50
1 20
4 50
6 100
</pre>
  <code>150</code>

  <h4>Пример 3</h4>
<pre>
3 5
0 10
0 20
0 30
</pre>
  <code>60</code>

  <h4>Пример 4</h4>
<pre>
5 1
4 10
5 8
8 10
4 2
4 10
</pre>
  <code>0</code>
</article>

