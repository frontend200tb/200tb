<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p>ЯрГУ. Кружок. Школьники 2024/2025</p>
  <p><a href="https://vkvideo.ru/@sportprog_yarsu" target="_blank">vkvideo.ru/@sportprog_yarsu</a></p>
</article>


<article class="article">
  <h1>Занятие 13. Базовые алгоритмы #4. Бинарный поиск по ответу</h1>
  <p>Конспект видео от 2024.12.07</p>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contest/572133" target="_blank">Codeforces Контест 572133</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
    <a href="#p1">Бинарный поиск по ответу</a>
  </p>
  <p>
        <a href="#task1">Задача A. Провода</a>
    <br><a href="#task2">Задача B. Дипломы</a>
    <br><a href="#task3">Задача C. Ночная работа</a>
    <br><a href="#task4">Задача D. Факториал</a>
    <br><a href="#task5">Задача E. Ден и коровы</a>
    <br><a href="#task6">Задача F. Покраска забора</a>
    <br><a href="#task7">Задача G. Ярость Битвы</a>
    <br><a href="#task8">Задача H. Гамбургеры</a>
    <br><a href="#task9">Задача I. Шаги</a>
    <br><a href="#task10">Задача J. Осада Вальгаллы</a>
    <br><a href="#task11">Задача K. Сбалансированные кучки камней</a>
    <br><a href="#task12">Задача L. Обои</a>
    <br><a href="#task13">Задача M. Мафия</a>
    <br><a href="#task14">Задача N. Подземелье</a>
    <br><a href="#task15">Задача O. Лопаты и мечи</a>
    <br><a href="#task16">Задача P. Слежка за отрезками</a>
    <br><a href="#task17">Задача Q. Экзамены</a>
  </p>
</article>


<!-- Бинарный поиск по ответу -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Бинарный поиск по ответу</h3>

  <h4>Функции</h4>
  <p>Функция — это зависимость одной переменной величины от другой, то есть взаимосвязь между величинами. Обозначается y = f(x).</p>

  <p>За обозначением f(x) спрятана некоторая формула зависящая от x. Например:</p>
  <code>f(x) = sin(x) + 5 * x² - x³.</code>

  <p>Многомерная функция — это функция с более чем одним аргументом, причём все аргументы являются действительными переменными. Обозначается</p>
  <code>y = f(x₁, x₂), y = g(x₁, x₂, x₃), y = ϕ(x₁, x₂, ..., xₙ).</code>

  <h4>Кусочные функции</h4>
  <p>Кусочная функция — это функция, части которой заданы на определённом промежутке.</p>

  <p>Кусочно-заданная функция — функция одной переменной, определённая на множестве вещественных чисел, которая задана отдельной формулой (или другим способом задания функции) на каждом из интервалов, составляющих область её определения.</p>

  <p>Чтобы построить график кусочной функции, нужно каждый кусочек функции построить на выделенном для него участке, не залезая на соседние.</p>

  <h4>Пример</h4>
  <code>y = 9, при 5 ≤ x</code>
  <code>y = (x - 2)², при 2 ≤ x ≤ 5</code>
  <code>0, при x ≤ 2</code>

  <h4>Булевская функция</h4>
  <p>Булева функция — это функция, которая возвращает результат логического выражения на основе логических переменных, которые могут принимать только два значения: истину (1) или ложь (0).</p>

  <p>Рассмотрим в качестве примера функцию</p>
  <code>f(x) = 0.25x + 3 * sin(x).</code>

  <p>Зададим булевскую функцию:</p>
  <code>g(f(x)) = 1, при f(x) > 2</code>
  <code>g(f(x)) = 0, при f(x) ≤ 2</code>

  <p>Построим график для функции f(x) = 0.25x + 3 * sin(x).</p>
  <p>Выделим куски, где функция f(x) принимает значение больше 2 и меньше 2. Нарисуем функцию g(f(x)).</p>

  <h4>Булевская спец. функция</h4>
  <p>Для алгоритма бинарного поиска по ответу мы требуем специальных условий по булевской функции f(x):</p>
  <ol>
    <li>Функция монотонна. (переход из 0 в 1 или из 1 в 0, происходит один раз)</li>
    <li>Мы можем выделить границы left, right при которых значения функции f(x)
  будет разными f(left)! = f(right).</li>
  </ol>

  <h4>Бинарный поиск по ответу</h4>
  <p>Бинарный поиск по ответу применяется, если:</p>
  <ol>
    <li>Ответ на задачу можно найти математически, но формулу необходимо долго и трудно выводить.</li>
    <li>Мы можем построить булевскую специальную функцию.</li>
    <li>Ответ на задачу будет находится в месте перехода.</li>
  </ol>

  <h4>Последовательность действий алгоритма</h4>
  <ol>
    <li>Определяем булевскую функцию, как именно она выглядит (примерный график);</li>
    <li>Определяем границы области поиска, таким образом, чтобы в f(left) f(right) значения булевской функции были разные;</li>
    <li>Находим середину области поиска;</li>
    <li>Определяем значение булевской функции от значения mid.</li>
    <li>В зависимости от результата сдвигаем, либо левую границу области поиска в середину, либо правую границу области поиска в середину;</li>
    <li>Продолжаем выполнять движение границ области поиска до тех пор, пока границы не станут соседними значениями right - left > 1;</li>
    <li>Делаем дополнительную проверку элементов после окончания цикла while. Ответ на задачу находится в одной из границ.</li>
  </ol>
</article>


<!-- Задача A. Провода -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Провода</h3>

  <div><i>Ограничение по времени 3с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Дано N отрезков провода длиной L₁, L₂, ..., Lₙ сантиметров. Требуется с помощью разрезания получить из них K равных отрезков как можно большей длины, выражающейся целым числом сантиметров. Если нельзя получить K отрезков длиной даже 1 см, вывести 0.</p>

  <h4>Входные данные</h4>
  <p>В первой строке находятся числа N и K. В следующей строке N целых чисел - L₁, L₂, ..., Lₙ</p>

  <p>Ограничения: 1 ≤ N ≤ 10³, 1 ≤ K ≤ 10⁴, 100 ≤ Lᵢ ≤ 10⁷, все числа целые.</p>

  <h4>Выходные данные</h4>
  <p>Вывести одно число - полученную длину отрезков.</p>

  <h4>Пример</h4>
<pre>
3 6
100 200 300
</pre>
  <code>100</code>
</article>


<!-- Задача B. Дипломы -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Дипломы</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Когда Петя учился в школе, он часто участвовал в олимпиадах по информатике, математике и физике. Так как он был достаточно способным мальчиком и усердно учился, то на многих из этих олимпиад он получал дипломы. К окончанию школы у него накопилось n дипломов, причём, как оказалось, все они имели одинаковые размеры: w — в ширину и h — в высоту. Сейчас Петя учится в одном из лучших российских университетов и живёт в общежитии со своими одногруппниками. Он решил украсить свою комнату, повесив на одну из стен свои дипломы за школьные олимпиады. Так как к бетонной стене прикрепить дипломы достаточно трудно, то он решил купить специальную доску из пробкового дерева, чтобы прикрепить её к стене, а к ней — дипломы. Для того чтобы эта конструкция выглядела более красиво, Петя хочет, чтобы доска была квадратной и занимала как можно меньше места на стене. Каждый диплом должен быть размещён строго в прямоугольнике размером w на h. Дипломы запрещается поворачивать на 90 градусов. Прямоугольники, соответствующие различным дипломам, не должны иметь общих внутренних точек. Требуется написать программу, которая вычислит минимальный размер стороны доски, которая потребуется Пете для размещения всех своих дипломов.</p>

  <h4>Входные данные</h4>
  <p>Входной файл содержит три целых числа: w, h, n (1 ≤ w, h, n≤ 10⁹).</p>

  <h4>Выходные данные</h4>
  <p>В выходной файл необходимо вывести ответ на поставленную задачу.</p>
  <p>Подумайте, какой тип данных потребуется для хранения ответа.</p>

  <h4>Пример 1</h4>
  <code>2 3 10</code>
  <code>9</code>

  <h4>Пример 2</h4>
  <code>1 1 1</code>
  <code>1</code>
</article>


<!-- Задача C. Ночная работа -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Ночная работа</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Однажды Васе поручили очень важное задание — написать за ночь программу, которая состоит из n строк кода. Вася уже очень устал и поэтому работает по следующей схеме: сначала он пишет v строк кода, выпивает стакан чая, после чего пишет уже v/k строк, опять выпивает стакан чая, после пишет v / k² строк и так далее: v / k³, v / k⁴ , v / k⁵ , ...</p>

  <p>Под выражением a / b понимается целая часть от деления числа a на число b.</p>

  <p>Как только текущая величина v / kᵖ станет равной 0, Вася немедленно засыпает и просыпается только утром, когда программа должна быть уже полностью написана.</p>

  <p>Васе интересно, какое наименьшее допустимое значение может принимать величина v, чтобы успеть написать не менее n строк кода до того момента, как он заснет.</p>

  <h4>Входные данные</h4>
  <p>Входные данные состоят из двух целых чисел n и k, записанных через пробел — размер программы в строках и коэффициент уменьшения производительности, 1 ≤ n ≤ 10⁹, 2 ≤ k ≤ 10.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное целое число — минимальное значение величины v, при котором Вася успеет написать программу за ночь.</p>

  <h4>Пример 1</h4>
  <code>7 2</code>
  <code>4</code>
  <p>В первом примере при v = 4 Вася будет печатать код следующим образом: сначала 4 строки, потом 2, потом 1, а затем Вася уснет. Таким образом, он успеет за ночь написать 4 + 2 + 1 = 7 строк, и задание будет выполнено.</p>

  <h4>Пример 2</h4>
  <code>59 9</code>
  <code>54</code>
  <p>Во втором примере при v = 54 Вася печатает код следующими порциями: 54, 6. В сумме 54 + 6 = 60, что даже больше, чем n = 59.</p>
</article>


<!-- Задача D. Факториал -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Факториал</h3>

  <div><i>Ограничение по времени 0.25с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Ваша задача найти такое минимальное натуральное число N, что N! содержит ровно Q нулей в конце своей десятичной записи. Как вам известно, N!=1⋅2⋅3⋅...⋅N. Например, 5!=120, 120 оканчивается на 1   ноль.</p>

  <h4>Входные данные</h4>
  <p>На вход подается одно число Q. (0≤Q≤10⁸).</p>

  <h4>Выходные данные</h4>
  <p>Выведите «No solution», если такого N не существует, иначе выведите N.</p>

  <h4>Пример</h4>
  <code>2</code>
  <code>10</code>
</article>


<!-- Задача E. Ден и коровы -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Ден и коровы</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>У Дена много коров. Также он имеет множество стойл, которые расположены вдоль прямой. Он желает расставить коров в стойла таким образом, чтобы минимальное расстояние между любыми двумя коровами было как можно больше. Помогите Дену расставить коров.</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержатся два числа n и k (1 ≤ n ≤ 10⁵, 1 ≤ k ≤ n) - количество коров и стойл. Во второй строке записаны координаты стойл a₁ ... aₙ (1 ≤ aᵢ ≤ 10⁹).</p>

  <h4>Выходные данные</h4>
  <p>Вывести единственное число - максимальное минимальное расстояние между любыми 2 коровами.</p>

  <h4>Пример 1</h4>
<pre>
7 4
1 2 3 5 8 13 21
</pre>
  <code>5</code>

  <h4>Пример 2</h4>
<pre>
7 5
1 2 4 8 16 32 1000000000
</pre>
  <code>7</code>
</article>


<!-- Задача F. Покраска забора -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Покраска забора</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Том Сойер уговорил n своих друзей помочь ему в нелегком деле покраски забора, окружающего дом тетушки Полли. Забор представляет собой k последовательных досок, пронумерованных от 1 до k, причем после k-й доски опять идет первая.</p>

  <p>Друзья Тома очень привередливы, i-й друг согласен участвовать в покраске только в том случае, если ему дадут покрасить участок из ровно ai последовательных досок. Кисточка у Тома только одна, поэтому друзья будут красить по очереди и сразу весь отведенный им отрезок. Тому остается лишь выбрать порядок, в котором приглашать друзей, а также выбрать для каждого желаемое количество последовательных досок.</p>

  <p>При этом каждый из друзей Тома готов красить как еще неокрашенную доску забора, так и доску, которую уже покрасил один из его предшественников. Тем не менее, друзья получают больше удовольствия от покраски неокрашенной доски. Том хочет выбрать число x и распределить отрезки забора для покраски таким образом, чтобы каждый из его друзей покрасил хотя бы x неокрашенных досок. Том очень любит своих друзей и хочет, чтобы каждый из них получил от процесса покраски забора максимальное удовольствие, поэтому он пытается максимизировать x.</p>

  <p>Помогите Тому понять, сколько радости он сможет доставить своим друзьям.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит два целых числа n (1 ≤ n ≤ 10⁵) и k (1 ≤ k ≤ 10⁹). Следующая строка содержит n целых чисел — значения aᵢ (1 ≤ aᵢ ≤ k).</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно число — максимальное возможное значение x.</p>

  <h4>Пример 1</h4>
<pre>
2 100
5 10
</pre>
  <code>5</code>
  <p>В первом примере x = 5, так как один из друзей просто не хочет красить больше пяти досок. Он придет первым, покрасит свои пять, после чего еще 10 неокрашенных досок достанется второму другу Тома. Оставшиеся 85 досок Тому придется красить самому.</p>

  <h4>Пример 2</h4>
<pre>
4 10
7 8 3 5
</pre>
  <code>2</code>
  <p>Во втором примере достичь x = 2 можно, например, так. Сначала третий друг красит доски с 4 по 6 (3 неокрашенных доски). Затем четвертый друг красит доски с 1 по 5 (3 неокрашенных доски). Затем второй друг красит доски с 1 по 8 (2 неокрашенных доски). Наконец, первый друг красит доски с 6 по 10 и с 1 по 2 (2 неокрашенных доски, заметим, что забор идет по циклу и эти доски образуют последовательный отрезок).</p>
</article>


<!-- Задача G. Ярость Битвы -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Ярость Битвы</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Герой по имени Магина сражается с группой из n монстров с помощью легендарного топора, известного как Ярость Битвы. Каждый из монстров имеет aᵢ очков здоровья. Каждым ударом топора Магина уменьшает здоровье того, кого он ударил, на p очков, при этом уменьшая здоровье всех остальных монстров на q очков. Монстр умирает, когда у него остается 0 или менее очков здоровья. Магина хочет при каждом ударе выбирать цель таким образом, чтобы убить всех монстров за минимальное количество ударов. Требуется определить это количество.</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержатся три целых числа через пробел: n, p и q (1 ≤ n ≤ 200000, 1 ≤ q ≤ p ≤ 10⁹) — количество монстров, урон по цели и урон по всем остальным соответственно.</p>

  <p>Во второй строке содержатся n целых чисел через пробел: aᵢ (1 ≤ aᵢ ≤ 10⁹) — количество очков здоровья у каждого из монстров.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное целое число — минимальное количество ударов, за которое Магина сможет убить всех монстров.</p>

  <h4>Пример 1</h4>
<pre>
2 3 2
5 5
</pre>
  <code>2</code>

  <h4>Пример 1</h4>
<pre>
3 5 3
17 13 14
</pre>
  <code>5</code>

  <details>
    <summary>Решение</summary>
    <p>Удар топором наносит точечный урон монстру по которому бьем и общий урон всем остальным монстрам. Разделим удар топором на две части - удар копьем это урон только одному монстру и удар мечем это урон всем остальным монстрам.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ввод данных
  long long p, q, l, r, mid, sum;
  int n;
  cin >> n >> p >> q;
  vector&lt;long long&gt; A(n);
  vector&lt;long long&gt; Buf(n);
  for (int i = 0; i &lt; A.size(); i++) {
    cin >> A[i];
  }

  // решение
  sort(A.begin(), A.end());
  if (p == q && A[n - 1] % q != 0) {
    cout &lt;&lt; A[n - 1] / q + 1;
  } else if (p == q && A[n - 1] % q == 0) {
    cout &lt;&lt; A[n - 1] / q;
  } else {
    l = 0, r = 1e9 + 1;
    p = p - q;
    while (r - l > 1) {
      mid = (r + l) / 2;
      sum = 0;
      for (int i = 0; i &lt; n; i++) {
        if (A[i] - mid * q > 0) {
          Buf[i] = A[i] - mid * q;
        } else {
          Buf[i] = 0;
        }
      }
      for (int i = 0; i &lt; n; i++) {
        sum += Buf[i] / p;
        if (Buf[i] % p != 0) {
          sum++;
        }
      }
      if (sum > mid) {
        l = mid;
      } else {
        r = mid;
      }
    }

    // вывод результата
    cout &lt;&lt; r;
  }
}
</pre>
  </details>
</article>


<!-- Задача H. Гамбургеры -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Гамбургеры</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Поликарп очень любит гамбургеры, особенно приготовленные собственноручно. Поликарп считает, что существует только три достойных ингредиента для приготовления гамбургера: хлеб, колбаса и сыр. Рецепт своего знаменитого «гамбургера от Поликарпа» он записывает в виде строки из букв 'B' (хлеб), 'S' (колбаса) и 'C' (сыр). В рецепте ингредиенты перечисляются снизу вверх, например, рецепт «ВSCBS» обозначает гамбургер в котором снизу вверх идут: хлеб, колбаса, сыр, хлеб и снова колбаса.</p>

  <p>На кухне у Поликарпа в наличии n<sub>b</sub> кусочков хлеба, n<sub>s</sub> кусочков колбасы и n<sub>c</sub> кусочков сыра. Кроме того, в магазине неподалеку есть в продаже все три ингредиента по цене: p<sub>b</sub> рублей за кусок хлеба, p<sub>s</sub> — за кусок колбасы и p<sub>c</sub> — за кусочек сыра.</p>

  <p>У Поликарпа есть r рублей, которые он готов потратить в магазине. Какое наибольшее количество гамбургеров он сможет приготовить? Считается, что ломать или резать любой из кусочков (хлеба, колбасы, сыра) нельзя, а также что в магазине есть бесконечно много кусочков каждого из ингредиентов.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных содержится непустая строка, описывающая рецепт «гамбургера от Поликарпа». Длина строки не превосходит 100, строка содержит только буквы 'B' (прописная латинская B), 'S' (прописная латинская S) и 'C' (прописная латинская C).</p>

  <p>Вторая строка содержит три целых числа n<sub>b</sub>, n<sub>s</sub>, n<sub>c</sub> (1 ≤ n<sub>b</sub>, n<sub>s</sub>, n<sub>c</sub> ≤ 100) — количество кусочков хлеба, колбасы и сыра на кухне Поликарпа. Третья строка содержит три целых числа p<sub>b</sub>, p<sub>s</sub>, p<sub>c</sub> (1 ≤ p<sub>b</sub>, p<sub>s</sub>, p<sub>c</sub> ≤ 100) — цена одного кусочка хлеба, колбасы и сыра в магазине. Наконец, четвертая строка содержит целое число r (1 ≤ r ≤ 10¹²) — количество рублей у Поликарпа.</p>

  <p>Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.</p>

  <h4>Выходные данные</h4>
  <p>Выведите наибольшее количество гамбургеров, которое Поликарп может приготовить. Если он не может приготовить ни одного гамбургера, выведите 0.</p>

  <h4>Пример 1</h4>
<pre>
BBBSSC
6 4 1
1 2 3
4
</pre>
  <code>2</code>

  <h4>Пример 2</h4>
<pre>
BBC
1 10 1
1 10 1
21
</pre>
  <code>7</code>

  <h4>Пример 3</h4>
<pre>
BSC
1 1 1
1 1 3
1000000000000
</pre>
  <code>200000000001</code>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  string str;
  cin >> str;
  long long b, s, c;
  cin >> b >> s >> c;
  long long pb, ps, pc;
  cin >> pb >> ps >> pc;
  long long q;
  cin >> q;

  // решение
  long long l = 0;
  long long r = 1e14;
  long long mid;
  long long B = 0, S = 0, C = 0;
  for (int i = 0; i &lt; str.size(); i++) {
    if (str[i] == 'B') {
      B++;
    }
    if (str[i] == 'S') {
      S++;
    }
    if (str[i] == 'C') {
      C++;
    }
  }

  // бинарный поиск
  while (r - l > 1) {
    mid = (l + r) / 2;
    long long sum_mid = 0;
    if (B * mid > b) {
      sum_mid += (B * mid - b) * pb;
    }
    if (S * mid > s) {
      sum_mid += (S * mid - s) * ps;
    }
    if (C * mid > c) {
      sum_mid += (C * mid - c) * pc;
    }
    if (sum_mid &lt;= q) {
      l = mid;
    } else {
      r = mid;
    }
  }

  // вывод результата
  cout &lt;&lt; l;
}
</pre>
  </details>
</article>


<!-- Задача I. Шаги -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача I. Шаги</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Однажды Вася вышел во двор погулять, а там не оказалось его друзей, с которыми он обычно играл в салки. Мальчик не растерялся и решил поиграть в салки сам с собой. «Как он это сделал?» — спросите вы. Очень просто.</p>

  <p>Вася заметил, что двор представляет собой прямоугольное поле размером n * m клеток, а каждая клетка имеет координаты (x, y) (1 ≤ x ≤ n, 1 ≤ y ≤ m), где x — номер строки поля, y — номер столбца поля.</p>

  <p>Изначально, Вася стоит в клетке с координатами (x<sub>c</sub>, y<sub>c</sub>). Для игры у него заготовлен список из k векторов (dxᵢ, dyᵢ) ненулевой длины. Действие игры происходит следующим образом. Мальчик рассматривает все вектора в порядке от 1 до k, и по очереди выбирает каждый из них в качестве текущего. Выбрав вектор в качестве текущего, мальчик делает максимально возможное количество корректных шагов по направлению этого вектора (возможно, ноль шагов).</p>

  <p>Шагом называется одно перемещение из клетки, где сейчас стоит мальчик, в направлении текущего вектора. То есть, если Вася находится в клетке (x, y), а текущий вектор — (dx, dy), то за один шаг Вася перемещается в клетку (x + dx, y + dy). Шаг считается корректным, если, совершая этот шаг, мальчик не выходит за пределы двора.</p>

  <p>Вася шагал и шагал, шагал и шагал, до тех пор, пока вектора из его списка не закончились. Он так много шагал, что совершенно позабыл, сколько шагов он сделал. Помогите мальчику — посчитайте, сколько шагов он сделал.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных даны два целых числа n и m (1 ≤ n, m ≤ 10⁹) — размеры двора. Во второй строке записаны целые числа x<sub>c</sub> и y<sub>c</sub> — координаты начальной клетки (1 ≤ x<sub>c</sub> ≤ n, 1 ≤ y<sub>c</sub> ≤ m).</p>

  <p>В третьей строке задано целое число k (1 ≤ k ≤ 10⁴) — количество векторов. Далее идут k строк, в каждой из которых записаны два целых числа dxᵢ и dyᵢ (|dxᵢ|, |dyᵢ| ≤ 10⁹, |dx| + |dy| ≥ 1).</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное целое число — количество шагов, которые сделал Вася.</p>

  <p>Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.</p>

  <h4>Пример 1</h4>
<pre>
4 5
1 1
3
1 1
1 1
0 -2
</pre>
  <code>4</code>
  <p>В первом примере Вася изначально находится в клетке (1, 1) и делает 3 шага по первому вектору (1, 1) последовательно посещая клетки: (2, 2), (3, 3), (4, 4). Затем он делает 0 шагов по второму вектору (1, 1). И 1 шаг по третьему вектору (0, -2) и оказывается в клетке (4, 2). В итоге Вася сделает 4 шага.</p>

  <h4>Пример 2</h4>
<pre>
10 10
1 2
1
-1 0
</pre>
  <code>0</code>
  <p>Во втором примере Вася изначально находится в клетке (1, 2) и делает 0 шагов по вектору (-1, 0), так как клетка с координатами (0, 2) находится вне двора.</p>
</article>


<!-- Задача J. Осада Вальгаллы -->
<article class="article">
  <div class="anchor" id="task10"></div>
  <h3>Задача J. Осада Вальгаллы</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Ивар Бескостный — великий лидер. Он пытается захватить Каттегат, в данный момент находящийся под контролем Лагерты. Битва началась, и волны воинов Ивара гибнут одна за другой.</p>

  <p>У Ивара n воинов, он выставляет их вдоль прямой напротив главных ворот так, что i-й воин стоит сразу за (i-1)-м воином. Первый воин возглавляет атаку.</p>

  <p>Каждый атакующий воин может выдержать до aᵢ стрел, прежде чем он падёт, где aᵢ — сила i-го воина.</p>

  <p>Лагерта приказывает своим воинам выпустить kᵢ стрел в течение i-й минуты, стрелы одна за одной поражают первого всё ещё стоящего воина. После того, как все воины Ивара падут и стрелы, находящиеся в воздухе в данный момент, пролетят, Тор бьёт по земле своим молотом и все воины Ивара получают свои силы назад и возвращаются в битву. Другими словами, если все воины умрут в минуту t, в конце этой минуты t они все встанут и будут сражаться.</p>

  <p>Битва будет идти q минут. После каждой минуты вы должны сообщить Ивару, сколько из его воинов находится в строю.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит два целых числа n и q (1 ≤ n, q ≤ 200000) — число воинов Ивара и длительность боя в минутах.</p>

  <p>Вторая строка содержит n целых чисел a₁, a₂, ...,aₙ (1 ≤ aᵢ ≤ 10⁹), обозначающих силы воинов Ивара.</p>

  <p>Третья строка содержит q целых чисел k₁, k₂, ..., k<sub>q</sub> (1 ≤ kᵢ ≤ 10¹⁴), i-е из которых означает число стрел kᵢ, которое будет выпущено в воинов Ивара по приказу Лагерты в минуту i.</p>

  <h4>Выходные данные</h4>
  <p>Выведите q строк, i-я из которых содержит число воинов Ивара, находящихся в строю после i-й минуты.</p>

  <h4>Пример 1</h4>
<pre>
5 5
1 2 1 2 1
3 10 1 1 1
</pre>
<pre>
3
5
4
4
3
</pre>
  <p>В первом примере:</p>
  <ul>
    <li>после 1-й минуты 1-й и 2-й воины умрут.</li>
    <li>после 2-й минуты все воины умрут (а оставшиеся стрелы будут потрачены впустую), после чего их воскресят, поэтому ответ — 5, все воины живы.</li>
    <li>после 3-й минуты 1-й воин умирает.</li>
    <li>после 4-й минуты во 2-го воина попадут и его сила упадёт на 1.</li>
    <li>после 5-й минуты 2-й воин умрёт.</li>
  </ul>

  <h4>Пример 2</h4>
<pre>
4 4
1 2 3 4
9 1 10 6
</pre>
<pre>
1
4
4
1
</pre>
</article>


<!-- Задача K. Сбалансированные кучки камней -->
<article class="article">
  <div class="anchor" id="task11"></div>
  <h3>Задача K. Сбалансированные кучки камней</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В ряд находятся n кучек камней. В i-й кучке изначально hi камней. Вы хотите изменить число камней в кучках, выполнив следующий процесс один раз:</p>
  <ul>
    <li>Вы идете по кучкам от 3-й до n-й, в таком порядке.</li>
    <li>Пусть i — номер текущей кучки.</li>
    <li>Вы можете выбрать целое число d (0 ≤ 3⋅d ≤ hᵢ), переместить d камней из i-й кучки в (i-1)-ю кучку, и 2⋅d камней из i-й кучки в (i-2)-ю.</li>
    <li>Таким образом, hᵢ уменьшается на 3⋅d, hᵢ₋₁ увеличивается на d, и hᵢ₋₂ увеличивается на 2⋅d.</li>
    <li>Вы можете выбирать различные или одинаковые d для различных операций. Некоторые кучки могут стать пустыми, но они все еще считаются за кучки.</li>
  </ul>

  <p>Какое наибольшее число камней в наименьшей кучке может получиться после завершения процесса?</p>

  <h4>Входные данные</h4>
  <p>Во входных данных находятся несколько наборов входных данных. В первой строке находится одно целое число t (1 ≤ t ≤ 2⋅10⁵) — количество наборов входных данных. Далее следуют наборы входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит целое число n (3 ≤ n ≤ 2⋅10⁵).</p>

  <p>Вторая строка каждого набора содержит n целых чисел h₁, h₂, h₃, ...,hₙ (1 ≤ hᵢ ≤ 10⁹).</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превосходит 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите максимальное число камней, которое может содержать наименьшая по количеству камней кучка после завершения процесса.</p>

  <h4>Пример</h4>
<pre>
4
4
1 2 10 100
4
100 100 100 1
5
5 1 1 1 8
6
1 2 3 4 5 6
</pre>
<pre>
7
1
1
3
</pre>
  <p>В первом примере изначально размеры кучек равны [1,2,10,100]. Мы можем перемещать камни следующим образом.</p>
  <ul>
    <li>переместить 3 и 6 камней с 3-й кучки на 2-ю и 1-ю кучки соответственно. Размеры кучек будут равны [7,5,1,100];</li>
    <li>Переместить 6 и 12 камней с последней кучки на 3-ю и 2-ю кучки соответственно. Размеры кучек будут равны [7,17,7,82].</li>
  </ul>

  <p>Во втором наборе размер последней кучки равен 1 и мы не можем его увеличить.</p>

  <p>В третьем наборе оптимально не перемещать никакие камни.</p>

  <p>В четвертом примере можно достичь состояния, в котором размеры кучек равны [3,5,3,4,3,3].</p>
</article>


<!-- Задача L. Обои -->
<article class="article">
  <div class="anchor" id="task12"></div>
  <h3>Задача L. Обои</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Игорь и Ира решили поклеить новые обои в комнате, а то некрасиво жить с обоями от предыдущих жильцов. Сама комната представляет собой параллелепипед с шириной a, длиной b и высотой c. Окна и двери настолько узкие, что Игорь их не учитывает. Обои продаются в рулонах и для поклейки будут разрезаться только поперек.</p>

  <p>В магазине Ире понравились очень красивые обои шириною w и длиною h со сложным рисунком имеющим раппорт длины r. Все рулоны одинаковые и начинаются с одинакового рисунка.</p>

  <p>Игорь и Ира начнут клеить обои с начала рулона и первый кусок приклеят, состыковав его с потолком по ширине рулона. Помогите Игорю и Ире определить какое минимальное количество рулонов обоев им потребуется, если это невозможно сделать выведите -1.</p>

  <h4>Входные данные</h4>
  <p>На вход подается 6 целых положительных чисел a, b, c, h, w, r — длина, ширина, высота комнаты, длина, ширина одного рулона обоев и их раппорт (1 ≤ a, b, c, h, w, r ≤ 10⁶, h ≥ r).</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно целое число минимальное количество рулонов, необходимых для поклейки обоев.</p>

  <h4>Пример 1</h4>
  <code>400 300 200 1000 100 100</code>
  <code>3</code>

  <h4>Пример 2</h4>
  <code>400 300 200 1000 120 100</code>
  <code>-1</code>
  <p>Раппорт на обоях (шаг рисунка) — это расстояние между повторяющимися элементами рисунка.</p>
</article>


<!-- Задача M. Мафия -->
<article class="article">
  <div class="anchor" id="task13"></div>
  <h3>Задача M. Мафия</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Как-то раз собрались n друзей, чтобы сыграть в «Мафию». В каждом раунде игры «Мафия» должен быть назначен ведущий (кто-то один из ребят), остальные n - 1 человек принимают участие в игре. Для каждого человека известно, в каком количестве раундов он хочет принять участие как игрок, а не как ведущий: i-ый человек хочет сыграть aᵢ раундов. Какое минимальное количество раундов игры «Мафия» нужно сыграть, чтобы каждый человек сыграл как минимум столько раундов, сколько хочет?</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое число n (3 ≤ n ≤ 10⁵). Во второй строке через пробел записаны n целых чисел a₁, a₂, ..., aₙ (1 ≤ aᵢ ≤ 10⁹) — i-ое число в списке обозначает количество раундов, которое хочет сыграть i-ый человек.</p>

  <h4>Выходные данные</h4>
  <p>В единственную строку выведите целое число — минимальное количество раундов игры, которое нужно сыграть, чтобы i-ый человек сыграл как минимум aᵢ раундов.</p>

  <p>Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.</p>

  <h4>Пример 1</h4>
<pre>
3
3 2 2
</pre>
  <code>4</code>

  <h4>Пример 2</h4>
<pre>
4
2 2 2 2
</pre>
  <code>3</code>

  <details>
    <summary>Решение с бинарным поиском</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ввод данных
  long long n;
  cin >> n;
  vector&lt;long long&gt; A(n);
  long long max1 = 0;
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
    max1 = max(max1, A[i]);
  }

  // решение
  // бинарный поиск
  long long left = max1;
  long long right = 3 * max1;
  long long mid = 0;
  while (right - left > 1) {
    mid = (left + right) / 2;
    long long count = mid;

    for (int i = 0; i &lt; n; i++) {
      count -= (mid - A[i]);
    }
    if (count &lt;= 0) {
      right = mid;
    } else {
      left = mid;
    }
  }
  mid = left;
  long long count = mid;

  for (int i = 0; i &lt; n; i++) {
    count -= (mid - A[i]);
  }

  // вывод результата
  if (count &lt;= 0) {
    cout &lt;&lt; left;
  } else {
    cout &lt;&lt; right;
  }
}
</pre>
  </details>

  <details>
    <summary>Решение без бинарного поиска</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;
  long long sum = 0, max1 = 0;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
    sum += A[i];
    if (A[i] > max1) {
      max1 = A[i];
    }
  }

  // решение
  int x = ceil(sum / (n - 1.0));

  // вывод результата
  if (x >= max1) {
    cout &lt;&lt; x;
  } else {
    cout &lt;&lt; max1;
  }
}
</pre>
  </details>
</article>


<!-- Задача N. Подземелье -->
<article class="article">
  <div class="anchor" id="task14"></div>
  <h3>Задача N. Подземелье</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вы играете в новую компьютерную игру, в которой необходимо сражаться с монстрами. В очередном подземелье вы встретили трех монстров; у одного из них a очков здоровья, у второго b очков здоровья, а у третьего — c.</p>

  <p>Для убийства монстров у вас есть пушка, которая наносит 1 единицу урона выбранному монстру. При этом каждый 7-й (т. е. выстрелы с номерами 7, 14, 21 и т. д.) выстрел пушки усиленный и наносит 1
  урона всем монстрам, а не только одному из них. Если текущее здоровье монстра равно 0, он не может быть целью обычного выстрела и не получает урона от усиленного выстрела.</p>

  <p>Вы хотите красиво пройти подземелье, а именно, убить всех монстров одним и тем же усиленным выстрелом (т. е. после очередного усиленного выстрела очки здоровья каждого из монстров должны впервые стать равными 0). Каждый выстрел должен попадать в монстра, т. е. вы не можете стрелять мимо цели.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одного целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Каждый набор входных данных состоит из единственной строки, которая содержит три целых числа a, b  и c (1 ≤ a, b,c ≤ 10⁸) — количество очков здоровья у каждого из монстров.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите YES, если можно убить всех монстров одним и тем же усиленным выстрелом. Иначе выведите NO. Каждую букву можно выводить в любом регистре (например, YES, Yes, yes, yEs будут распознаны как положительный ответ).</p>

  <h4>Пример</h4>
<pre>
3
3 2 4
1 1 1
10 1 7
</pre>
<pre>
YES
NO
NO
</pre>
  <p>В первом примере вы можете действовать следующим образом:</p>
  <ul>
    <li>1-й выстрел в первого монстра,</li>
    <li>2-й выстрел во второго монстра,</li>
    <li>3-й выстрел в третьего монстра,</li>
    <li>4-й выстрел в первого монстра,</li>
    <li>5-й выстрел в третьего монстра,</li>
    <li>6-й выстрел в третьего монстра</li>
    <li>и 7-й усиленный выстрел убьет всех монстров.</li>
  </ul>
  <p>Во втором примере вы не можете убить монстров усиленным выстрелом, т. к. суммарное количество очков здоровья монстров равно 3, и вы убьете их за первые 3 выстрела.</p>
</article>


<!-- Задача O. Лопаты и мечи -->
<article class="article">
  <div class="anchor" id="task15"></div>
  <h3>Задача O. Лопаты и мечи</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Поликарп играет в известную компьютерную игру (мы не хотим упоминать ее название). В этой игре он может создавать инструменты двух видов — лопаты и мечи. На создание лопаты Поликарп тратит две палки и один алмаз; на создание меча Поликарп тратит два алмаза и одну палку.</p>

  <p>Каждый инструмент может быть продан за один изумруд. Как много изумрудов может заработать Поликарп, если у него есть a палок и b алмазов?</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит число t (1 ≤ t ≤ 1000) — количество наборов входных данных.</p>

  <p>Единственная строка каждого набора входных данных содержит два числа a и b (0 ≤ a, b ≤ 10⁹) — количество палок и алмазов соответственно.</p>

  <h4>Выходные данные</h4>
  <p>На каждый набор входных данных выведите число — максимальное количество изумрудов, которое может заработать Поликарп.</p>

  <h4>Пример</h4>
<pre>
4
4 4
1000000000 0
7 15
8 7
</pre>
<pre>
2
0
7
5
</pre>
  <p>В первом наборе входных данных Поликарп может заработать два изумруда следующим образом: создать один меч и одну лопату.</p>
  <p>Во втором наборе входных данных у Поликарпа нет алмазов, а значит, он не сможет ничего создать.</p>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int t;
  cin >> t;
  while (t--) {
    long long a, b;
    cin >> a >> b;

    // решение
    long long left = 0;
    long long right = a + b;
    long long mid;

    // бинарный поиск
    while (right - left > 1) {
      mid = (right + left) / 2;
      if (a + b >= 3 * mid && a >= mid && b >= mid) {
        left = mid;
      } else {
        right = mid;
      }
    }

    // вывод результата
    cout &lt;&lt; left &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача P. Слежка за отрезками -->
<article class="article">
  <div class="anchor" id="task16"></div>
  <h3>Задача P. Слежка за отрезками</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У вас есть массив a, состоящий из n нулей. Также, вам дан набор из m необязательно различных отрезков. Каждый отрезок задается двумя числами lᵢ и rᵢ (1 ≤ lᵢ ≤ rᵢ ≤ n) и представляет собой подмассив a<sub>l<sub>i</sub></sub>,a<sub>l<sub>i</sub>+1</sub>,…,a<sub>r<sub>i</sub></sub> массива a.</p>

  <p>Назовём отрезок lᵢ,rᵢ красивым, если количество единиц на этом отрезке строго больше, чем количество нулей. Например, если a=[1,0,1,0,1], тогда отрезок [1,5] является красивым (количество единиц равно 3, количество нулей равно 2), но отрезок [3,4] не является красивым (количество единиц равно 1, количество нулей равно 1).</p>

  <p>У вас также есть q изменений. Каждое изменение задано числом 1 ≤ x ≤ n, это означает, что вы должны присвоить элементу a<sub>x</sub> значение 1.</p>

  <p>Вы должны найти первое изменение, после которого хотя бы один из m заданных отрезков становится красивым, или сообщить, что ни один из них не является красивым после применения всех q изменений.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит два целых числа n и m (1 ≤ m ≤ n ≤ 10⁵) — размер массива a и количество отрезков соответственно.</p>

  <p>Далее следует m строк, состоящих из двух чисел lᵢ и rᵢ (1 ≤ lᵢ ≤ rᵢ ≤ n) — границы отрезков.</p>

  <p>В следующей строке дано целое число q (1 ≤ q ≤ n) — количество измений.</p>

  <p>В следующих q строках содержится по одному целому числу x (1 ≤ x ≤ n) — индекс элемента массива, который нужно приравнять к 1. Гарантируется, что все индексы в запросах различны.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно целое число — наименьший номер изменения, после которого хотя бы один из отрезков окажется красивым, или -1, если ни один отрезок не станет красивым.</p>

  <h4>Пример</h4>
<pre>
6
5 5
1 2
4 5
1 5
1 3
2 4
5
5
3
1
2
4
4 2
1 1
4 4
2
2
3
5 2
1 5
1 5
4
2
1
3
4
5 2
1 5
1 3
5
4
1
2
3
5
5 5
1 5
1 5
1 5
1 5
1 4
3
1
4
3
3 2
2 2
1 3
3
2
3
1
</pre>
<pre>
3
-1
3
3
3
1
</pre>
  <p>В первом примере, после первых двух изменений не будет красивых отрезков, а после третьего изменения на отрезке [1;5] будет 3 единицы и 2 нуля, получается ответ 3.</p>
  <p>Во втором примере у нас не будет красивых отрезков.</p>
</article>


<!-- Задача Q. Экзамены -->
<article class="article">
  <div class="anchor" id="task17"></div>
  <h3>Задача Q. Экзамены</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Студент Валера учится на первом курсе университета. Скоро у него сессия, и ему предстоит сдать ровно n экзаменов. Валера — умный парень, поэтому он сможет сдать любой экзамен с первого раза. Кроме того, он может сдавать несколько экзаменов в один день и в любом порядке.</p>

  <p>Согласно расписанию, экзамен по i-му предмету нужно сдать в день с номером aᵢ. Однако Валера договорился с каждым преподавателем, и преподаватель i-го предмета разрешил организовать досрочную сдачу своего экзамена в день bᵢ (bᵢ &lt; aᵢ). Таким образом, Валера может сдать экзамен по i-му предмету либо в день aᵢ, либо в день bᵢ. Все преподаватели ставят запись о сдаче экзамена в зачетную книжку в день фактической сдачи экзамена и датируют эту запись числом aᵢ.</p>

  <p>Валера считает, что будет достаточно странно, если записи в зачетной книжке будут идти не в порядке неубывания даты. Поэтому Валера просит вас помочь ему. Найдите минимально возможный номер дня, когда Валера сможет сдать последний экзамен, если он будет сдавать экзамены так, чтобы все записи в его зачетной книжке шли в порядке неубывания даты.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано единственное целое положительное число n (1 ≤ n ≤ 5000) — количество экзаменов, которые будет сдавать Валера.</p>

  <p>В каждой из следующих n строк записано по два целых положительных числа через пробел aᵢ и bᵢ (1 ≤ bᵢ &lt; aᵢ ≤ 10⁹) — дата сдачи по расписанию и досрочная дата сдачи i-го экзамена соответственно.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное целое число — минимально возможный номер дня, когда Валера сможет сдать последний экзамен, если он будет сдавать экзамены так, чтобы все записи в его зачетной книжке шли в порядке неубывания даты.</p>

  <h4>Пример 1</h4>
<pre>
3
5 2
3 1
4 2
</pre>
  <code>2</code>
  <p>В первом примере Валера сначала сдаст экзамен по второму предмету в первый день (в зачетную книжку заносится дата сдачи по расписанию, то есть 3). На следующий день сначала он сдаст экзамен по третьему предмету (будет добавлена запись, датированная днем 4), а после него в тот же день сдаст экзамен по первому предмету (в зачетную книжку отметка будет проставлена с днем 5). Таким образом, последний экзамен Валера сдаст во второй день, и даты в зачетной книжке будут идти в порядке неубывания: 3, 4, 5.</p>

  <h4>Пример 2</h4>
<pre>
3
6 1
5 2
4 3
</pre>
  <code>6</code>
  <p>Во втором примере Валера сначала сдаст экзамен по третьему предмету в четвертый день, после него экзамен по второму предмету в пятый день. После этого в шестой день Валера сдаст экзамен по первому предмету.</p>
</article>

