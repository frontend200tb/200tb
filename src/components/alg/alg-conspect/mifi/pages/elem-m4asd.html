<article class="article">
  <h1>МИФИ. Экстремальное программирование</h1>
  <p>Сергей Потапов</p>
  <p>Курс по подготовке к отборочному контесту на направление Экстремальное программирование ИИКС НИЯУ МИФИ.</p>
  <p>Асимптотика и структуры данных. Часть 1</p>
</article>


<!-- Содержание -->
<article class="article">
  <h3>Содержание</h3>

      <a href="#p1">Асимптотика</a>
  <br><a href="#p2">Статический массив</a>
  <br><a href="#p3">Динамический массив</a>
</article>


<!-- Асимптотика -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Асимптотика</h3>

  <p>Асимптотика - это способ описать скорость роста времени (количества операций) и памяти, требуемой для выполнения кода при увеличении входных данных.</p>

  <h4>Задача: угадать число от 1 до 10</h4>
  <p>Если по очереди перебирать числа от 1 до 10, то максимальное число операций будет 10. Асимптотика рассматривает худший случай - это 10 операций.</p>

  <h4>Задача: угадать число от 1 до n</h4>
  <p>Если по очереди перебирать числа от 1 до n, то максимальное число операций будет n. Асимптотика рассматривает худший случай - это n операций. Записывается асимптотика в Big O нотации O(n).</p>
  <p>Асимптотика O(n). Это линейная асимптотика.</p>

  <h4>Задача: угадать 2 числа от 1 до n</h4>
  <p>Каждое число мы угадаем за O(n). Получится O(n) + O(n). Мы не записываем O(2n) или 2 * O(n), потому что константы при записи асимптотики не указываются. Получится все еще O(n).</p>

  <h4>Задача: угадать число от 1 до n</h4>
  <p>Задача: угадать число от 1 до n и выписать его, число на 1 меньше и число на 1 больше. Нам потребуется n операций, чтобы угадать число и 3 операции, чтобы вывести три числа. Мы не записываем O(n+3), потому что константы мы убираем и остается O(n).</p>

  <h4>Задача. Написать свое ФИО</h4>
  <p>В этой задаче решение не зависит от размера входных данных. Всегда 3 операции. Но мы не записываем O(3). Если нет зависимости от входных данных, то все константы сокращаются до 1.</p>
  <p>Асимптотика O(1). Это константная асимптотика.</p>

  <h4>Асимптотики O(n<sup>2</sup>) и O(n)</h4>
  <p>При одинаковом количестве операций n время выполнения программы с асимитотикой O(n<sup>2</sup>) будет значительно дольше чем при O(n), поэтому при решении алгоритмических задач мы всегда стремимся уменьшить асимптотику.</p>

  <h4>Асимптотика задача нахождения числа Фибоначчи</h4>
  <p>Давайте оценим асимптотику нахождения числа Фибоначчи.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  int n; // номер числа Фибоначчи
  cin >> n;

  vector&lt;int&gt; fib(n+1, 0);
  fib[0] = 0;
  fib[1] = 1;

  for (int i = 2; i &lt;= n; i++) {
    fib[i] = fib[i-1] + fib[i-2];
  }

  cout &lt;&lt; fib[n];
}
</pre>

  <p>Цикл от 2 до n даст нам O(n) по времени. Массив из n+1 элементов даст нам O(n) по памяти. Попробуем решить эту задачу за O(1) по памяти, то есть так чтобы дополнительная память не зависила от размера входных данных и была бы константной.</p>
  <pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int n; // номер числа Фибоначчи
  cin >> n;

  int x = 0;
  int y = 1;

  for (int i = 2; i &lt;= n; i++) {
    x = y;
    y = x + y;
  }

  cout &lt;&lt; x;
}
</pre>

  <h4>Задача. Угадать пару чисел, от 1 до n  и от 1 до m.</h4>
  <p>Угадать пару чисел, одно из которых от 1 до n, а второе от 1 до m. И после выписать все числа от 1 до абсолютного значения разности угаданных чисел.</p>
  <p>Первое число найдем за O(n). Второе число найдем за O(m). Оба числа найдем за O(n*m). Найдем абсолютное значение разности</p>
  <code>k = abs(m - n);</code>
  <p>Тогда получим асимптотику O(n*m + k), которая зависит от трех переменных.</p>
</article>


<!-- Статический массив -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>Статический массив</h3>

  <p>Каждый байт памяти хранится в отдельной ячейке компьютера, которая имеет свой уникальный адрес.</p>
  <p>Массив данных хранится в непрерывной области памяти, в соседних ячейках.</p>
  <p>Первый способ созадания статического массива через <strong>квадратные скобки []</strong>:</p>
<pre>
int a[8];
int b[8] = {1,2,3,4,5,6,7,8};
int c[8] = {5,4};
int d[8] = {};
int e[] = {1,2,3,4,5,6,7,8};
</pre>
  <p>Получим массив a, заполненный мусором. Остальные массивы будут инициализированы числами:</p>
<pre>
b // 1 2 3 4 5 6 7 8
c // 5 4 0 0 0 0 0 0
d // 0 0 0 0 0 0 0 0
e // 1 2 3 4 5 6 7 8
</pre>

  <p>Со статическим массивом можно производить следующие действия:</p>
  <ol>
    <li>
      <h4>Чтение, замена одного элемента</h4>
      <p>Зная адрес массива в памяти, размер одного элемента массива и номер элемента, мы можем обратиться к этому элементу, чтобы прочитать или заменить его.</p>
      <code>addr(a[i]) = base_address + i * sizeof(nt);</code>
      <p>Мы используем просто формулу, поэтому это константное время выполнения O(1)</p>
    </li>
    <li>
      <h4>Поиск элемента</h4>
      <p>Для поиска элемента нужно пройтись по всему массиву. Время выполнения O(n).</p>
    </li>
  </ol>

  <p>В статический массив нельзя добавлять или удалять элементы. Скопировать один массив в другой обычным присваиванием тоже нельзя. Для этого нужен второй способ создания массива.</p>

  <p>Второй способ создания статического массива через <strong>std::array</strong></p>
  <code>std::array&lt;int, 8&gt; a = {4,5};</code>
  <p>Такие массивы можно присваивать друг другу</p>
  <code>std::array&lt;int, 8&gt; b = a;</code>
</article>


<!-- Динамический массив -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>Динамический массив</h3>

  <p>Способы создания динамического массива:</p>
<pre>
vector&lt;int&gt; a = {1,2,3};
vector&lt;int&gt; b;
vector&lt;int&gt; c(3,88);
vector&lt;int&gt; d = a;
</pre>
  <p>Получим массивы</p>
<pre>
a // 1 2 3
b // пустой массив
c // 88 88 88
d // 1 2 3
</pre>

  <p>Динамический массив имеет две характеристики size - размер массива и capacity - место в памяти, отведенное под массив. При создании под него выделяется непрерывная область памяти размером capacity. Ячейки памяти до и после массива могут быть заняты чужими данными, к которым из программы нет доступа. В динамический массив можно добавлять элементы. Допустим capacity = 5 и size = 0 и мы добавим два элемента, тогда размер массива увеличится и size = 2. Когда размер увеличится до size = 5, то есть когда будет size = capacity, то мы больше не сможем добавлять элементы в массив в той же области памяти.</p>
  <p>Операционная система должна выбрать новый участок свободной памяти, который будет вдвое больше нынешнего capacity. Когда новая память под массив будет выделена, данные из старой памяти перенесутся в новую память и старая память будет освобождена. Теперь capacity=10 и можно дальше добавлять элементы.</p>

  <p>С динамическим массивом можно производить следующие действия:</p>
  <ol>
    <li>
      <h4>Чтение, замена одного элемента</h4>
      <p>Доступ к элементу</p>
      <code>a[i]</code>
      <p>Зная адрес массива в памяти, размер одного элемента массива и номер элемента, мы можем обратиться к этому элементу, чтобы прочитать или заменить его.</p>
      <code>addr(a[i]) = base_address + i * sizeof(nt);</code>
      <p>Мы используем просто формулу, поэтому это константное время выполнения O(1)</p>
    </li>
    <li>
      <h4>Удаление, добавление одного элемента в конец</h4>
      <p>Добавление в конец массива.</p>
      <code>a.push_back(x)</code>
      <p>Если у нас size=n capacity = 2*n, то n-1 операцию добавления мы будем делать за n-1 шаг, а последнюю одну операцию добавления за 2*n шагов, потому что нужно перенести весь массив в новую выделенную память. Всего получим n-1+2*n = 3n шагов для добавления n элементов, тогда асимптотика будет 3*n/n = 3 константа. Время выполнения O(1).</p>
      <p>Удаление из конца массива.</p>
      <code>a.pop_back()</code>
    </li>
    <li>
      <h4>Удаление, добавление одного элемента в начало</h4>
      <p>Добавление в начало массива.</p>
      <code>a.insert(a.begin(),x)</code>
      <p>При добавлении элемента в начало массива придется двигать все элементы на 1 ячейку памяти вправо. Это долгая операция. Время выполнения O(n).</p>
      <p>Удаление из начала массива.</p>
      <code>a.erase(a.begin())</code>
    </li>
    <li>
      <h4>Удаление, добавление одного элемента в центр</h4>
      <p>Добавление в центр массива.</p>
      <code>a.insert(a.begin()+i,x)</code>
      <p>При добавлении элемента в центр массива придется двигать все последующие элементы на 1 ячейку вправо. В худшем случае это почти все n элементов. Поэтому это тоже долгая операция. Время выполнения O(n).</p>
      <p>Удаление из центра массива.</p>
      <code>a.erase(a.begin()+i)</code>
    </li>
    <li>
      <h4>Поиск элемента</h4>
      <p>Поиск не является встроенным методом динамического массива, поэтому будем использовать функцию из стандартной библиотеки algorithm</p>
      <code>find(a.begin(), a.end(), x)</code>
      <p>Для поиска элемента нужно пройтись по всему массиву. Время выполнения O(n).</p>
    </li>
  </ol>
</article>
