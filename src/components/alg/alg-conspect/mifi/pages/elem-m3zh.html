<article class="article">
  <h1>МИФИ. Экстремальное программирование</h1>
  <p>Сергей Потапов</p>
  <p>Курс по подготовке к отборочному контесту на направление Экстремальное программирование ИИКС НИЯУ МИФИ.</p>
  <p>Жадный алгоритм.</p>
</article>


<!-- Содержание -->
<article class="article">
  <h3>Содержание</h3>

      <a href="#p0">Жадный алгоритм</a>
  <br><a href="#p1">Задача 1. Монеты</a>
  <br><a href="#p2">Задача 2. Максимальное число занятий</a>
  <br><a href="#p3">Задача 3. Максимальное число коробок в матрешке (ЕГЭ)</a>
  <br><a href="#p4">Задача 4. Монеты, где жадный алгоритм не подходит</a>
</article>


<!-- Жадный алгоритм -->
<article class="article">
  <div class="anchor" id="p0"></div>
  <h3>Жадный алгоритм</h3>

  <p>Решим простую задачку. Дан массив чисел 5, 8, 16, 4, 2. Нужно выбрать три числа с максимальной суммой.</p>

  <p>Заметим, что максимальное 16 число из этого массива точно будет в этой тройке. Запишем его в ответ и удалим из массива. Теперь мы решаем другую задачу. Нам дан новый массив и нужно выбрать два числа с максимальной суммой.</p>

  <p>Повторим те же действия. Максимальное число 8 из массива точно будет в этой паре. Добавим его к ответу и удалим из массива. Теперь мы решаем другую задачу. Найти максимальное число в массиве и это число 5.</p>

  <p>Выводим ответ 16, 8, 5. Это три числа с максимальной суммой.</p>

  <p>В этой задаче каждый раз мы жадно выбираем одно число.</p>

  <p>Основная идея жадного алгоритма - на каждом шаге выбирается локально оптимальное решение, в надежде, что в итоге получится глобально оптимальное.</p>

  <p>Из идеи вытекает, что каждый раз мы выбираем наилучшее решение и облегчаем следующий шаг.</p>

  <p>Но жадный алгоритм не всегда работает. Каждый раз нужно доказывать почему он работает.</p>
</article>


<!-- Задача 1. Монеты -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Задача 1. Монеты</h3>

  <p>Есть монеты номиналом 32, 8, 4, 2, 1. Найти минимальное количество монет, которые нужно взять, чтобы получить 55.</p>

  <p>Заметим важную особенность, что 32 делится на 8, а 8 делится на 4, 4 делится на 2, а 2 делится на 1.</p>

  <p>Допустим нам нужно набрать монетами число 32. Мы можем взять</p>
  <ol>
    <li>1 x 32</li>
    <li>4 x 8</li>
    <li>8 x 4</li>
    <li>16 x 2</li>
    <li>32 x 1</li>
  </ol>
  <p>Минимальное число монет будет 1 монета номиналом 32.</p>

  <p>Теперь найдем решение для числа 55. Сперва возьмем монету, которая меньше 55, но больше остальных монет, это 32. Вычитаем эту монету из числа 55 и переходим к следующей задаче</p>
  <ol>
    <li>55 - 1 * 32 = 23</li>
    <li>23 - 2 * 8 = 7</li>
    <li>7 - 1 * 4 = 3</li>
    <li>3 - 1 * 2 = 1</li>
    <li>1 - 1 * 1 = 0</li>
  </ol>
  <p>Посчитаем число монет 1 + 2 + 1 + 1 + 1 = 6.</p>
  <p>Отсортируем номиналы монет от большего к меньшему и положим в массив coins. x это число, которое нужно набрать монетами. i это индекс монеты в массиве coins. Поскольку последняя монета в массиве номиналом 1, то всегда можно набрать заданное число.</p>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  int coins[] = {32, 8, 4, 2, 1};
  int x = 55;
  int i = 0;
  vector&lt;int&gt; res;

  while (x > 0) {
    if (x >= coins[i]) {
      x -= coins[i];
      res.push_back(coins[i]);
    } else {
      i++;
    }
  }

  cout &lt;&lt; res.size();
}
</pre>
</article>


<!-- Задача 2 Максимальное число занятий -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>Задача 2 Максимальное число занятий</h3>

  <p>Дано время начала и время окончания множества занятий, необходимо определить какое максимальное количество занятий можно провести за день в одной аудитории. Время проведенных занятий не могут пересекаться.</p>

  <p>Для каждого занятия заведем пару, в которой будет записано время начала и время конца. Заведем массив, в котором будут записаны все пары занятий.</p>

  <code>less = {{1, 8}, {2, 4}, {5, 7}, {9, 11}, {12, 14}};</code>
<pre>
_______
 __
    __
        __
           __
</pre>

  <p>Отсортируем занятия по времени начала. Попробуем взять занятие, которое начинается раньше остальных. Занятие {1, 8} начинается в 1 и заканчивается в 8. Теперь начиная с 8 будем искать занятие которое начинается раньше остальных. Следующие два занятия {2, 4}, {5, 7},  начинаются в 2 и в 5 и нам уже не подходят, потому что они начинаются раньше, чем заканчивается первое занятие. Следующее занятие {9, 11} начинается в 9 и заканчивается в 11. Теперь начиная с 11 будем искать заняте которое начинается раньше остальных и это последнее занятие {12, 14}, которое начинается в 12 и заканчивается в 14. Получим в ответе 3 занятия.</p>

  <p>Но это не максимальное число. Мы видим, что максимальное число должно быть четыре. Попробуем другой способ.</p>
  <p>Отсортируем занятия по времени окончания. Попробуем взять занятие, которое заканчивается последним. Занятие {12, 14} заканчивается в 14 и начинается в 12. Теперь до 12 будем искать занятие, которое заканчивается после остальных. Это занятие {9, 11}, которое заканчивается в 11 и начинается в 9. Теперь ищем занятие, которое до 9 заканчивается после остальных. Нам подходит занятие {1, 8}, которое заканчивается в 8 и начинается в 1. Больше никакое занятие мы добавить не можем. Получим в ответе 3 занятия.</p>

  <p>Это тоже неправильный ответ. Получилось, что если просто идти слева направо и добавлять занятия которые начинаются раньше и идти справа налево и добавлять занятия которые заканчиваются позже, это неправильно.</p>

  <p>Теперь рассмотрим правильный выриант. Отсортируем занятия по времени окончания и будем идти слева направо. Возьмем занятие {2, 4}, которое заканчивается в 4 и начинается в 2. Теперь начиная с 4 будем искать занятие которое заканчивается раньше остальных. Это занятие {5, 7}. Теперь начиная с 7 будем искать занятие которое заканчивается раньше остальных. Занятие {1, 8} заканчивается раньше остальных, но оно нам не подходит, потому что начинается раньше 7. После этого нам подойдут занятия {9, 11}, {12, 14}.</p>
  <p>В ответе получим 4 занятия и это правильный ответ.</p>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

bool comp(pair&lt;int, int&gt;& a, pair&lt;int, int&gt;& b) {
  return b.second > a.second;
}

int main() {
  vector&lt;pair&lt;int, int&gt; &gt; lessons = {{1, 8}, {2, 4}, {5, 7}, {9, 11}, {12, 14}};
  int right = 0;
  vector&lt;pair&lt;int, int&gt; &gt; res;

  sort(lessons.begin(), lessons.end(), comp);
  for (auto l : lessons) {
    if (l.first >=  right) {
      res.push_back(l);
      right = l.second;
    }
  }

  cout &lt;&lt; res.size();
}
</pre>
</article>


<!-- Задача 3. Максимальное число коробок в матрешке (ЕГЭ) -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>Задача 3. Максимальное число коробок в матрешке (ЕГЭ)</h3>

  <p>Это задача из ЕГЭ под номером 26.</p>

  <p>Дано множество квадратных коробок. Нужно собрать из них матрешку. Чтобы положить коробку внутрь другой коробки разность длин их сторон должна быть 7 и больше. Определить максимальное число коробок в матрешке, и наибольшую коробку, которая может быть последней при максимальном числе коробок.</p>

  <p>Первый вариант начать с самой большой коробки. Отсортируем все коробки по убыванию и возьмем самую большую коробку. Если выполняется условие что сторона следующей коробки как минимум на 7 меньше, то добавляем ее к матрешке.</p>

  <p>Второй вариант начать с самой маленькой коробки. Отсортируем все коробки по возрастанию и возьмем самую маленькую коробку. Если выполняется условие что сторона следующей коробки как минимум на 7 больше, то добавляем ее к матрешке.</p>

  <p>В обоих вариантах мы получим максимальное число коробок в матрешке. Но у нас есть еще одно условие, чтобы при этом наименьшая из коробок была максимально возможной.</p>

  <p>Если мы будем начинать собирать матрешку с самой маленькой коробки, то всегда наименьшая из коробок будет самой маленькой. А если мы будем начинать собирать матрешку с самой большой коробки, то наименьшая из коробок будет максимально возможной.</p>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

bool comp(int a, int b) {
  return a > b;
}

int main() {
  vector&lt;int&gt; boxes = {1, 4, 12, 14, 17, 25};
  int dif = 7;
  vector&lt;int&gt; res;

  sort(boxes.begin(), boxes.end(), comp);
  int cur = boxes[0];
  res.push_back(cur);
  for (auto b : boxes) {
    if (cur >=  b + 7) {
      res.push_back(b);
      cur = b;
    }
  }

  cout &lt;&lt; res.size() &lt;&lt; '\n' &lt;&lt; res[res.size()-1];
}
</pre>
</article>


<!-- Задача 4. Монеты, где жадный алгоритм не подходит -->
<article class="article">
  <div class="anchor" id="p4"></div>
  <h3>Задача 4. Монеты, где жадный алгоритм не подходит</h3>

  <p>Есть монеты номиналом 5, 4, 3, 1. Найти минимальное количество монет, которые нужно взять, чтобы получить 7.</p>

  <p>Первая задача решалась жадным алгоритмом, потому что у нее было одно важное свойство: каждый номинал делился на меньшие номиналы.</p>

  <p>В этой задаче такого свойста нет и поэтому жадным алгоритм может дать неправильный ответ. Попробуем решить эту задачу жадным алгоритмом.</p>

  <p>Сперва возьмем монету, которая меньше 7, но больше остальных монет, это 5. Вычитаем эту монету из числа 7 и переходим к следующей задаче</p>
  <ol>
    <li>7 - 1 * 5 = 2</li>
    <li>2 - 2 * 1 = 0</li>
  </ol>
  <p>Посчитаем число монет 1 + 2 = 3. Это неправильный ответ, потому что число 7 можно собрать из двух монет номиналом 3 и 4.</p>
</article>
