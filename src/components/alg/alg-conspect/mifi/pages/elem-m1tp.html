<article class="article">
  <h1>МИФИ. Экстремальное программирование</h1>
  <p>Сергей Потапов</p>
  <p>Курс по подготовке к отборочному контесту на направление Экстремальное программирование ИИКС НИЯУ МИФИ.</p>
  <p>Два указателя.</p>
</article>


<!-- Содержание -->
<article class="article">
  <h3>Содержание</h3>

      <a href="#p0">Два указателя</a>
  <br><a href="#p1">Задача 1. Палиндром</a>
  <br><a href="#p2">Задача 2. Найти два числа с заданной суммой</a>
  <br><a href="#p3">Задача 3. Найти минимальный подмассив с заданной суммой</a>
  <br><a href="#p4">Задача 4. Найти максимальную подстроку</a>
</article>


<!-- Два указателя -->
<article class="article">
  <div class="anchor" id="p0"></div>
  <h3>Два указателя</h3>

  <p>Обычно в условии задачи задан массив или строка. Мы заводим две переменные l и r которые указывают на какие-то два элемента массива. Обычно мы проверяем элементы, на которые указывают эти указатели, и если выполняется какое-то условие, то двигаем первый указатель, иначе второй. Каждый указатель двигается строко в одну сторону.</p>
  <p>Два типа алгоритма:</p>
  <ol>
    <li>Указатели движутся в одном направлении</li>
    <li>Указатели движутся навстречу друг другу</li>
  </ol>
  <p>Каждый указатель мы можем двигать не больше чем на длину массива.</p>
</article>


<!-- Задача 1. Палиндром -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Задача 1. Палиндром</h3>

  <p>Определить является ли строка s палиндромом.</p>

  <h4>Пример 1</h4>
  <code>abcdeedcba</code>
  <code>YES</code>

  <h4>Пример 2</h4>
  <code>abcddba</code>
  <code>NO</code>

  <p>Паттерн Два указателя навстречу друг другу.</p>
  <p>Вначале поставим первый указатель l на первую букву, а второй указатель r на последнюю букву. Пока r > l будем выполнять следующий алгоритм. Будем сравнивать буквы s[l] и s[r]. Если буквы одинаковы, то двигаем указатель l вправо, а указатель r влево. Если буквы разные, то останавливаем алгоритм и отвечаем, что строка не является палиндромом. Если все буквы были одинаковы, то отвечаем, что строка является палиндромом.</p>

<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  string s; // входная строка
  cin >> s;

  int l = 0;
  int r = s.size() - 1;
  while (r > l) {
    if (s[l] == s[r]) {
      l++;
      r--;
    } else {
      cout &lt;&lt; "NO";
      return 0;
    }
  }

  cout &lt;&lt; "YES";
}
</pre>
</article>


<!-- Задача 2. Найти два числа с заданной суммой -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>Задача 2. Найти два числа с заданной суммой</h3>

  <p>В отсортированном массиве положительных чисел найти 2 таких числа, что их сумма равна 15.</p>

  <h4>Пример</h4>
  <code>1 3 4 7 8 10 16</code>
  <code>7 8</code>

  <p>Паттерн Два указателя навстречу друг другу.</p>
  <p>Вначале поставим первый указатель l на первое число, а второй указатель r на последнее число. Пока r > l будем выполнять следующий алгоритм. Будем вычислять сумму двух элементов s[l] + s[r]. Поскольку массив отсортирован от меньшего числа к большему, то если двигать левый указатель, то сумма будет увеличиваться, а если двигать правый указатель, то сумма будет уменьшаться. Если сумма больше 15-ти, то двигаем указатель r влево. Если сумма меньше 15-ти, то двигаем указатель l вправо. Если сумма равна 15, то выводим ответ.</p>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  int n; // длина массива
  cin >> n;

  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  int l = 0;
  int r = n - 1;
  while (r > l) {
    if (A[l] + A[r] > 15) {
      r--;
    } else if (A[l] + A[r] &lt; 15) {
      l++;
    } else {
      cout &lt;&lt; A[l] &lt;&lt; ' ' &lt;&lt; A[r];
      return 0;
    }
  }

  cout &lt;&lt; "NO";
}
</pre>
</article>


<!-- Задача 3. Найти минимальный подмассив с заданной суммой -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>Задача 3. Найти минимальный подмассив с заданной суммой</h3>

  <p>Найти минимальный по длине подмассив положительных чисел такой, что сумма его элементов больше или равна 15.</p>

  <h4>Пример</h4>
  <code>1 1 7 8 3</code>
  <code>2</code>

  <p>Назовем подмассив хорошим, если сумма его элементов больше или равна 15. Иначе будем называть подмассив плохим. Если к хорошему подмассиву мы будем добавлять элементы слева или справа, то сумма его будет увеличиваться и он останется хорошим, но его длина тоже будет увеличиваться. Поэтому добавлять элементы к хорошему подмассиву не имеет смысла. Если подмассив плохой, то нужно добавлять к нему элементы, пока он не станет хорошим.</p>

  <p>Паттерн Два указателя в одну сторону.</p>
  <p>Вначале поставим первый и второй указатели l и r на первое число. Пока r меньше длины массива будем выполнять следующий алгоритм. Будем вычислять сумму элементов от l до r. Когда l и r указывают на один и тот же элемент, то сумма равна самому этому элементу sum = s[l]. Если sum &lt; 15, то двигаем указатель r влево, при этом сумма будет увеличиваться. Если sum >= 15, то сначала обновляем минимальную длину хорошего подмассива, а затем двигаем указатель l вправо, при этом сумма будет уменьшаться.</p>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  int n; // длина массива
  cin >> n;

  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  int l = 0;
  int r = 0;
  int sum = A[l];
  int res = n; // длина минимального подмассива
  while (r &lt; n) {
    if (sum &lt; 15) {
      r++;
      if (r == n) break;
      sum += A[r];
    } else {
      res = min(res, r - l + 1);
      sum -= A[l];
      l++;
    }
  }

  cout &lt;&lt; res;
}
</pre>
</article>


<!-- Задача 4. Найти максимальную подстроку -->
<article class="article">
  <div class="anchor" id="p4"></div>
  <h3>Задача 4. Найти максимальную подстроку</h3>

  <p>Это задача из ЕГЭ.</p>
  <p>Найти максимальную подстроку, в которой встречаются две буквы "a".</p>

  <h4>Пример</h4>
  <code>bddavfaafdaqcaq</code>
  <code>7</code>

  <p>Назовем подстроку хорошей, если она содержит не больше двух букв "a". Иначе будем называть подстроку плохой. Начнем искать хорошую подстроку с первой буквы строки. Будем добавлять к хорошей подстроке буквы справа, пока она остается еще хорошей. Как только она стала плохой, значин мы нашли ее максимальную длину. Добавлять буквы к плоой подстроке не имеет смысла. Если подстрока плохая, то нужно удалять из не буквы слева, пока она не станет хорошей.</p>

  <p>Паттерн Два указателя в одну сторону.</p>
  <p>Вначале поставим первый и второй указатели l и r на первую букву. Пока r меньше длины строки будем выполнять следующий алгоритм. Будем считать cnt_a число букв "a" в подстроке. Если cnt_a &lt;= 2, то двигаем указатель r влево, при этом длина подстроки будет увеличиваться. Если cnt_a > 2, то сначала обновляем максимальную длину хорошей подстроки, а затем двигаем указатель l вправо, при этом длина подстроки будет уменьшаться.</p>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  string s;
  cin >> s;

  int l = 0;
  int r = 0;
  int cnt_a = 0;
  int res = 0; // длина максимальной подстроки
  while (r &lt; s.size()) {
    if (cnt_a &lt;= 2) {
      r++;
      if (r == s.size()) break;
      if (s[r] == 'a') {
        cnt_a++;
      }
    } else {
      res = max(res, r-l);
      if (s[l] == 'a') {
        cnt_a--;
      }
      l++;
    }
  }

  cout &lt;&lt; res;
}
</pre>
</article>
