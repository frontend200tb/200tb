<article class="article">
  <h1>МИФИ. Экстремальное программирование</h1>
  <p>Сергей Потапов</p>
  <p>Курс по подготовке к отборочному контесту на направление Экстремальное программирование ИИКС НИЯУ МИФИ.</p>
  <p>Динамическое программирование.</p>
</article>


<!-- Содержание -->
<article class="article">
  <h3>Содержание</h3>

      <a href="#p0">Динамическое программирование</a>
  <br><a href="#p1">Задача 1. Числа Фибоначчи</a>
  <br><a href="#p2">Задача 2. Кузнечик</a>
  <br><a href="#p3">Задача 3. Робот. Максимальная сумма (ЕГЭ)</a>
  <br><a href="#p4">Задача 4. Робот. Минимальная сумма</a>
</article>


<!-- Динамическое программирование -->
<article class="article">
  <div class="anchor" id="p0"></div>
  <h3>Динамическое программирование</h3>

  <p>Разбор одного из самых полезных алгоритмов программирования, который чаще всего попадается на отборочном контесте.</p>
  <p>Основная идея - разбить задачу на подзадачи, решить эти подзадачи, и объединить их результаты так, чтобы получить решение исходной задачи.</p>
  <p>Динамическое программирование похоже на рекурсию, вычисляемую в обратном порядке. Рекурсия это функция, которая при вычислении использует саму себя. Что же лучше, рекурсия или ДП? Разберем это на примере задачи поиска n-го числа Фибоначчи.</p>
  <p>Последовательность Фибоначчи: 0, 1, 1, 2, 3, 5, 8. Это такая последовательность, которая начинается с чисел 0 и 1, а каждый следующий элемент равен сумме двух предыдущих.</p>
  <code>f(0) = 0, f(1) = 1</code>
  <code>f(i) = f(i-1) + f(i-2)</code>

  <p>Эту задачу можно решить и через рекурсию и через ДП.</p>
  <p>Решение через рекурсию. Чтобы найти 5 элемент, нужно знать 4 и 3 элементы. Чтобы найти 4 элемент, нужно знать 3 и 2 элементы и т.д. Для поиска каждого элемента функция рекурсивно вызывает саму себя. Каждый вызов функции приводит к замедлению программы. Слишком много вызовов приводит к переполнению стека и компьютер не сможет вычислить ответ.</p>
  <p>Эксперимент показал, что при n = 3331 это последнее число, которое еще не вызвало переполнение стека. Рекурсия с мемоизацией совершает 6661 вызовов функции и вычисляет значение за 0.0071 секунд. Динамическое программирование вычисляет ответ за 0.0018 секунд.</p>

  <h4>Основные параметры ДП</h4>
  <ol>
    <li>Базовые значения. Например, f(0) = 0, f(1) = 1</li>
    <li>Переход к следующему значению. Например, f(i) = f(i-1) + f(i-2)</li>
    <li>Направление динамики. Например, от 2 к n</li>
    <li>Как хранить. Например, в массиве DP от 0 до n</li>
    <li>Как получить ответ. Например в DP[n]</li>
  </ol>
</article>


<!-- Задача 1. Числа Фибоначчи -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Задача 1. Числа Фибоначчи</h3>

  <p>Найти n-ое число в последовательности Фибоначчи.</p>

  <p>В этой задаче задана рекурсия. Очень легко решать ДП, когда известна рекурсия.</p>

  <ol>
    <li>
      <p>Сначала найдем базовые значение</p>
      <code>f(0) = 0, f(1) = 1</code>
    </li>
    <li>
      <p>Найдем формулу перехода к следующему значению</p>
        <code>f(i) = f(i-1) + f(i-2)</code>
      </li>
    <li>
      <p>Найдем в каком порядке вычислять значения. Поскольку любой элемент зависит от двух предыдущих, то чтобы найти элемент, нам нужно чтобы были посчитаны все элементы до него. Направление от 2 до n (прямое).</p>
    </li>
    <li>
      <p>Как хранить элементы. Мы будем хранить в массиве DP. Можно решать и без массива, чтобы не тратить память на массив, но сейчас разберем на примере одномерного массива.</p>
    </li>
    <li>
      <p>Как получить ответ. Ответ будет лежать в ячейке массива DP[n]. В общем случае в каждом элементе массива DP[i] будет лежать ответ для i-го числа последовательности Фибоначчи.</p>
    </li>
  </ol>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  int n; // номер числа Фибоначчи
  cin >> n;

  vector&lt;int&gt; fib(n+1, 0);
  fib[0] = 0;
  fib[1] = 1;

  for (int i = 2; i &lt;= n; i++) {
    fib[i] = fib[i-1] + fib[i-2];
  }

  cout &lt;&lt; fib[n];
}
</pre>
</article>


<!-- Задача 2. Кузнечик -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>Задача 2. Кузнечик</h3>

  <p>Кузнечик стоит на 0 ступеньке, и может прыгать только на следующую ступеньку, либо через 2. Сколько существует различных способов добраться до k-ой ступеньки?</p>

  <p>Эта задача сложнее задачи о числах Фибоначчи, потому что там была задана рекурсия. А задачи с рекурсией легко решить методом ДП.</p>

  <p>Разберем условие. Кузнечик стоит на 0-1 ступеньке. Он может прыгнуть на 1-ю ступеньку или на 3-ю ступеньку. Сколько есть способов чтобы добраться до k-й ступеньки? Для этого для каждой ступеньки нужно определить число способов добраться до нее.</p>

  <ol>
    <li>Кузнечик уже стоит на 0-й ступеньке, значит есть только один способ попасть на 0-ю ступеньку. Это базовый случай.</li>
    <li>Как хранить. Будем в одномерном массиве DP хранить все ступеньки и число способов на них попасть. DP[i] это число способобв попасть на i-ю ступеньку.</li>
    <li>Правило перехода. В i-ю ступеньку можно попасть только из ступенек i-1 и i-3. Поэтому DP[i] = DP[i-1] + DP[i-3].</li>
    <li>Направление. Поскольку каждое число зависит только от предыдущих, то все предыдущие значения должны быть подсчитаны. Направление от 1 до k (прямое).</li>
    <li>Ответ лежит в DP[k]</li>
  </ol>
  <p>Если мы будем вычислять i-й элемент по формуле DP[i] = DP[i-1] + DP[i-3], то мы выйдем за границы массива слева при вычислении 1-го и 2-го элементов. Чтобы это исправить, заведем массив DP на k+4 элементов, чтобы для DP[i] элемента вычислять DP[i+1] и DP[i+3] элементы.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  int k; // номер ступеньки
  cin >> k;

  vector&lt;int&gt; DP(k+4, 0);
  DP[0] = 1;

  for (int i = 0; i &lt;= k; i++) {
    DP[i+1] += DP[i];
    DP[i+3] += DP[i];
  }

  cout &lt;&lt; DP[k];
}
</pre>
</article>


<!-- Задача 3. Робот. Максимальная сумма -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>Задача 3. Робот. Максимальная сумма</h3>

  <p>Это задача из ЕГЭ под номером 18. Обычно она решается с помощью Excell или LibreOffice.</p>
  <p>Дана таблица с числами A[n][m], робот стоит в левой верхней клетке, нужно добраться до нижней правой. Причем робот может ходить только вправо и вниз. Какую максимальную сумму чисел можно получить, пройдя роботом?</p>

  <ol>
    <li>Если в условии дана таблица, то чаще всего для хранения используют двумерный массив. Заведем двумерный массив DP[n][m]. В каждой ячейке DP[i][j] будем хранить максимальное число которое получается когда робот дойдет до этой ячейки.</li>
    <li>Базовый случай DP[0][0] = A[0][0]. В начальной ячейке робот соберет число, которое есть в этой ячейке в исходной таблице.</li>
    <li>Переход. Каждое значение зависит от значения слева и от значения сверху. DP[i][j] = max(DP[i-1][j] + DP[i][j-1]) + A[i][j]</li>
    <li>Направление. Каждый элемент зависит от элемента в предыдущем столбце и элемента в предыдущей строке. Направление будет слева направо, сверху вниз.</li>
    <li>Ответ лежит в элементе DP[n-1][m-1].</li>
  </ol>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  int n, m; // размер таблицы
  cin >> n >> m;
  vector&lt;vector&lt;int&gt; &gt; A(n, vector&lt;int&gt; (m));
  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; m; j++) {
      cin >> A[i][j];
    }
  }

  vector&lt;vector&lt;int&gt; &gt; DP(n, vector&lt;int&gt; (m));
  DP[0][0] = A[0][0];

  // заполним первую строку массива DP
  for (int i = 1; i &lt; n; i++) {
    DP[i][0] = DP[i-1][0] + A[i][0];
  }
  // заполним первый столбец массива DP
  for (int j = 1; j &lt; m; j++) {
    DP[0][j] = DP[0][j-1] + A[0][j];
  }
  for (int i = 1; i &lt; n; i++) {
    for (int j = 1; j &lt; m; j++) {
      DP[i][j] = max(DP[i-1][j], DP[i][j-1]) + A[i][j];
    }
  }

  cout &lt;&lt; DP[n-1][m-1];
}
</pre>
</article>


<!-- Задача 4. Робот. Минимальная сумма -->
<article class="article">
  <div class="anchor" id="p4"></div>
  <h3>Задача 4. Робот. Минимальная сумма</h3>

  <p>Тоже что и в задаче Робот Максисальная сумма, только нужно найти минимальную сумму. Тот же код, где max нужно заменить на min.</p>

  <pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  int n, m; // размер таблицы
  cin >> n >> m;
  vector&lt;vector&lt;int&gt; &gt; A(n, vector&lt;int&gt; (m));
  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; m; j++) {
      cin >> A[i][j];
    }
  }

  vector&lt;vector&lt;int&gt; &gt; DP(n, vector&lt;int&gt; (m));
  DP[0][0] = A[0][0];

  // заполним первую строку массива DP
  for (int i = 1; i &lt; n; i++) {
    DP[i][0] = DP[i-1][0] + A[i][0];
  }
  // заполним первый столбец массива DP
  for (int j = 1; j &lt; m; j++) {
    DP[0][j] = DP[0][j-1] + A[0][j];
  }
  for (int i = 1; i &lt; n; i++) {
    for (int j = 1; j &lt; m; j++) {
      DP[i][j] = min(DP[i-1][j], DP[i][j-1]) + A[i][j];
    }
  }

  cout &lt;&lt; DP[n-1][m-1];
}
</pre>
</article>
