<h1>Бинарный поиск</h1>


<article class="article">
  <p>Конспект двух видео</p>
  <p>Первое от 2024-01-16 <strong>Бинарный поиск, МЕТОД ОЛИМПИАДНИКОВ. Как подготовиться к собеседованию в Яндекс</strong></p>
  <p>Второе <strong>Бинарный поиск</strong></p>

  <p><a href="https://www.youtube.com/@fatin.maksim/videos">youtube Максим Фатин</a></p>
  <p><a href="https://tskills.ru/algo">https://tskills.ru/algo</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p><a href="#bin">Что такое бинарный поиск</a></p>
  <p><a href="#task1">Задача 1. Найти число в отсортированном массиве</a></p>
  <p><a href="#task2">Задача 2. Найти пик в массиве "гора"</a></p>
  <p><a href="#task3">Задача 3. Найти первую и последнюю позицию элемента в отсортированном массиве</a></p>
  <p><a href="#task4">Задача 4. Найти сдвиг в отсортированном массиве со сдвигом</a></p>
  <p><a href="#task5">Задача 5. Найти число в отсортированном массиве со сдвигом</a></p>
  <p><a href="#task6">Задача 6. Найти число в отсортированной матрице</a></p>
  <p><a href="#task7">Задача 7. Найти квадратный корень числа</a></p>
  <p><a href="#task8">Задача 8. Найти K ближайших элементов</a></p>
</article>


<!-- Что такое бинарный поиск -->
<article class="article">
  <div class="anchor" id="bin"></div>
  <h3>Что такое бинарный поиск</h3>

  <p>Сегодня узнаем в каких задачах используется бинарный поиск. Почему ты пишешь его неправильно и ошибаешься на собесах.</p>
  <p>В начале разберемся в каких задачах используется бинарный поиск. Посмотрим примеры решения. А в конце ты получишь полезный чек-лист для отработки полученных знаний</p>

  <h4>Когда можно использовать бинарный поиск</h4>
  <p>Использовать бинарный поиск для решения можно если удается разбить входные данные на две непрерывающиеся последовательности по каким нибудь признакам.</p>

  <h4>Алгоритм решения бинарным поиском нужно</h4>
  <ol>
    <li>Написать функцию good() разбивающую входные данные на две непрерывные части</li>
    <li>Определить в какой части будет ответ</li>
    <li>
      <p>Завести два указателя l левый и r правый и правильно поставить их в начальном положении. </p>
      <p>Если ответ будет в левой части, значит в левом указателе, тогда ставим левый указатель на первый элемент, а правый за границей массива</p>
      <p>Если ответ будет в правой части, значит в правом указателе, тогда ставим правый указатель на последний элемент, а левый за границей массива</p>
    </li>
    <li>Запустить цикл, пока указатели не окажутся рядом while(r-l>=1)</li>
    <li>Найти середину mid = (r+l)/2, передавать середину mid в функцию good() и двигать один из указателей</li>
    <li>Когда цикл закончится, проверить есть ли ответ в нужном указателе</li>
  </ol>

  <h4>Функция для бинарного поиска</h4>
  <p>В каждой задаче на бинарный поиск нужно придумать функцию, которая принимает число из массива входных данных и возвращает булевое значение. Функция возвращает true если это число нам подходит и возвращает false если не подходит. Таким образом после применения этой функции ко всему массиву входных данных, входные данные разделятся на две части. Первая часть слева - хорошая. Вторая часть справа плохая. Будем держать два указателя. Первый показывает на последний хороший элемент. Второй показывает на первый плохой.</p>
  <p>Когда на собеседовании тебе попадется задача на бинарный поиск, будет круто если перед тем как решать, ты расскажешь какие задачи вообще могут быть решены бинарным поиском. А если еще расскажешь и про функцию, которую нужно придумать, чтобы сначала шло true а потом false, то будешь на голову выше тех, кто этого не знает.</p>

  <h4>Чек лист с задачами, которые нужно прорешать самому</h4>
  <p><a href="https://leetcode.io/">https://leetcode.io/</a> 74. Search a 2D Matrix</p>
  <p><a href="https://leetcode.io/">https://leetcode.io/</a> 34. Find First and Last Position of Element in Sorted Array</p>
  <p><a href="https://leetcode.io/">https://leetcode.io/</a> 69. Sqrt(x)</p>
  <p><a href="https://leetcode.io/">https://leetcode.io/</a> 658. Find K Closest Elements</p>
</article>


<!-- Задача 1. Найти число в отсортированном массиве -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача 1. Найти число в отсортированном массиве</h3>

  <h4>Leetcode 704. Binary Search</h4>

  <p>Есть массив целых чисел nums отсортированный в возрастающем порядке и целое число target. Написать функцию для поиска target в массиве nums. Если target существует, вернуть его индекс. Если такого числа нет, то вернуть -1. Если такое число есть, то вернуть его позицию.</p>

  <h4>Пример 1</h4>
  <code>nums = [-1, 0, 3, 5, 9, 12]; target = 9;</code>
  <code>Ответ 4</code>

  <h4>Пример 2</h4>
  <code>nums = [-1, 0, 3, 5, 9, 12]; target = 2;</code>
  <code>Ответ -1</code>

  <h4>Решение</h4>
  <p>Для входный данных можно придумать <strong>функцию</strong>, которая превратит наш массив из чисел в <strong>массив из true и false</strong>. При этом сначала будут идти все true, а потом false. В этой задаче такой функцией будет</p>
  <code>function(num) {return num &lt;= target;}</code>
  <p>То есть мы смогли разбить входные данные на <strong>две непрерывающиеся последовательности</strong>. И это будет работать для любых входных данных. Поэтому данную задачу можно решать <strong>бинарным поиском</strong>.</p>
  <p>Будем называть элементы, которые дают ture - хорошими, а false - плохими. В этом случае target может быть только последним хорошим элементом. Именно поэтому после бинарного поиска нужно проверить что он равен target.</p>
  <p>В бинарном поиске мы ищем не один элемент target, а два элемента. Первый где заканчивается true, второй - где начинается false. То есть первый указатель встанет на последний хороший элемент, а второй указатель - на первый плохой.</p>
  <p>Подход обеспечит тебе понимание на что указывает тот или иной указатель. В 96% случаев код будет выглядеть одинаковым. И ты не ошибешься на что указывает тот или иной указатель.</p>
  <p>Сложность по времени O(logN). Сложность по памяти O(1).</p>

  <details>
    <summary>Алгоритм</summary>
    <ol>
      <li>Заведем два указателя pl и pr. pl указывает на первый элемент массива, pr указывает за пределы массива на следующий (несуществующий) элемент после последнего
        <code>let pl = 0, pr = nums.length;</code>
      </li>
      <li>Будем сдвигать левый указатель вправо, а правый влево до тех пор пока они не будут указывать на соседние элементы (разница между ними будет 1)
        <code>while (pr - pl > 1)</code>
      </li>
      <li>Находим середину (опорный элемент)
        <code>let m = Math.floor((pl + pr) / 2);</code>
      </li>
      <li>Проверяем условие. Передаем в нашу функцию опорный элемент
        <code>if (isGood(nums[m], target))</code>
      </li>
      <li>Если элемент хороший (функция вернула true), то двигаем левый указатель вправо на опорный элемент
        <code>pl = m;</code>
      </li>
      <li>Если элемент плохой (функция вернула false), то двигаем правый указатель влево на опорный элемент
        <code>pr = m;</code>
      </li>
      <li>Ответ будет находиться в элементе указывающем на pl. Чтобы pl мог принимать значения [0, nums.length - 1] т.е. от первого и до последнего индекса включительно, сдвигаем pr на 1 вправо от последнего индекса массива.</li>
      <li>Проверяем условие, если pl указывает на target, то вернем pl, иначе вернем -1
        <code>return nums[pl] === target ? pl : -1;</code>
      </li>
    </ol>
  </details>

  <details>
    <summary>Решение (javascript)</summary>
<pre>
function search(nums, target) {
  let pl = 0, pr = nums.length;

  while (pr - pl > 1) {
    // определяем середину
    let m = Math.floor((pl + pr) / 2);
    if (isGood(nums[m], target)) {
      // если число по индексу m хорошее, то двигаем левый указатель
      pl = m;
    } else {
      // если число по индексу m плохое, то двигаем правый указатель
      pr = m;
    }
  }

  // если левый указатель указывает на target
  // то вернуть левый указатель, иначе -1
  return nums[pl] === target ? pl : -1;
}

function isGood(val, target) {
  return val &lt;= target;
}
</pre>
  </details>

  <details>
    <summary>Решение (python)</summary>
<pre>
class Solution:
  def isGood(self, val: int, target: int) -> bool:
    return val &lt;= target

  def search(self, nums: list[int], target: int) -> int
    pl, pr = 0, len(nums)

    while pr - pl > 1:
      m = (pl + pr) // 2
      if self.isGood(nums[m], target):
        pl = m
      else:
        pr = m

    return pl if nums[pl] == target else -1
</pre>
  </details>
</article>


<!-- Задача 2. Найти пик в массиве "гора" -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача 2. Найти пик в массиве "гора"</h3>

  <h4>Leetcode 852. Peak Index in a Mountain Array</h4>

  <p>Массив arr считается "горой" если имеет свойства</p>
  <ul>
    <li>arr.length >= 3</li>
    <li>
      <p>Сущкствует такой индекс i  , 0 &lt; i &lt; arr.length, для которого</p>
      <p>arr[0] &lt; arr[1] &lt; ... &lt; arr[i-1] &lt; arr[i]</p>
      <p>arr[i] > arr[i+1] > ... > arr[arr.length - 1]</p>
    </li>
  </ul>

  <h4>Пример 1</h4>
  <code>arr = [0,1,0]</code>
  <code>Output: 1</code>

  <h4>Пример 2</h4>
  <code>arr = [0,2,1,0]</code>
  <code>Output: 1</code>

  <h4>Пример 3</h4>
  <code>arr = [0,10,5,2]</code>
  <code>Output: 1</code>

  <h4>Решение</h4>
  <p>Поделим элементы на хорошие и плохие, а потом придумаем функцию. Элемент считается хорошим если он в подмассиве который возрастает. Все элементы в убывающем подмассиве плохие.</p>
  <p>Функция должна определять, что текущий элемент больше предыдущего, тогда он находится в возрастающем массиве</p>
  <code>function(arr, i) {return arr[i-1] &lt; arr[i];}</code>
  <p>Сложность по времени O(logN)</p>
  <p>Сложность по памяти O(1)</p>

  <details>
    <summary>Код на python</summary>
<pre>
class Solution:
  def good(self, i, arr):
    if i == 0:
      return true
    return arr[i-1] &lt; arr[i]

  def peak(self, arr: List[int]) -> int:
    l, r = 0, len(arr) - 1

    while r - l > 1:
      m = (l+r) // 2
      if self.good(m, arr):
        l = m
      else:
        r = m

    return l
</pre>
  </details>
</article>


<!-- Задача 3. Найти первую и последнюю позицию элемента в отсортированном массиве -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача 3. Найти первую и последнюю позицию элемента в отсортированном массиве</h3>

  <h4>Leetcode 34. Find First and Last Position of Element in Sorted Array</h4>

  <p>Дан массив целых чисел nums сортированный в неубывающем порядке. Найти начальную и конечную позицию данного значения target</p>
  <p>Если target не найден, вернуть [-1,-1]</p>

  <h4>Пример 1</h4>
  <code>nums = [5,7,7,8,8,10], target = 8</code>
  <code>Output: [3,4]</code>

  <h4>Пример 2</h4>
  <code>nums = [5,7,7,8,8,10], target = 6</code>
  <code>Output: [-1,-1]</code>

  <h4>Пример 3</h4>
  <code>nums = [], target = 0</code>
  <code>Output: [-1,-1]</code>

  <h4>Паттерн два бинарных поиска</h4>
  <p>Первая функция возвращает true для всех элементов меньше target.</p>
  <code>good1(arr, i) {return arr[i] &lt; target;}</code>
  <p>Так мы найдем левую границу target. Ответ будет в правом указателе. Вначале правый указатель ставим на последний элемент, а левый за границу массива</p>
  <code>let l = -1, r = arr.length - 1;</code>
  <p>Запускаем первый бинарный поиск. Если в ответе будет target, то запускаем второй бинарный поиск, иначе числа target нет в массиве и возвращаем</p>
  <code>return [-1, -1];</code>

  <p>Вторая функция возвращает true для всех элементов меньше или равно target.</p>
  <code>good2(arr, i) {return arr[i] &lt;= target;}</code>
  <p>Так мы найдем правую границу target. Ответ будет в левом указателе. В начале левый указатель ставим на первый элемент, а правый за границу массива</p>
  <code>let l = 0, r = arr.length;</code>
</article>


<!-- Задача 4. Найти сдвиг в отсортированном массиве со сдвигом -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача 4. Найти сдвиг в отсортированном массиве со сдвигом</h3>

  <p>Есть массив чисел nums. Он отсортирован по возрастанию, но со сдвигом. Вернуть сдвиг - целове число на которое сдвинули все элементы вправо</p>

  <h4>Пример 1</h4>
  <p>Массив [4,5,6,7,1,2,3] был получен из массива [1,2,3,4,5,6,7] сдвигом на 4 элемента вправо</p>

  <h4>Паттерн бинарный поиск</h4>
  <p>Чтобы найти сдвиг (offset) с помощью бинарного поиска, определим функцию goodOffset(), которая будет возвращать для всех элементов сначала true, а потом false</p>

  <p>В этой задаче такой функцией будет</p>
<pre>
function goodOffset(i) {
  return nums[i] &gt;= nums[nums.length-1];
}
</pre>

  <p>Эта функция сработает, потому что в задаче нет одинаковых элементов. Нам дана возрастающая последовательность.</p>

<pre>
    good   bad
[4 5 6 7 | 1 2 3]
       l   r
</pre>
  <p>Здесь элементы с 4 по 7 хорошие, с 1 по 3 плохие и сдвиг равен 4.</p>

  <h4>Пример 2</h4>
  <code>nums = [1,2,3,4,5]</code>
<pre>
good    bad
    [ | 1 2 3 4 5]
  l     r
</pre>
  <p>В этом примере хороших элементов нет и сдвиг равен 0.</p>
  <p>Сдвиг равен индексу, на который указывает правый указатель r.</p>
  <p>Сдвиг будет находиться в правом указателе r. Поэтому указатель r может принимать значения [0, nums.length - 1]</p>

  <details>
    <summary>Алгоритм поиска сдвига</summary>
    <ol>
      <li>
        <p>Напишем функцию goodOffset(), которая будет возвращать для всех элементов сначала true, а потом false</p>
<pre>
function goodOffset(i) {
  return nums[i] &gt;= nums[nums.length-1];
}
</pre>
      </li>
      <li>Заведем два указателя pl и pr. Ответ будет находиться в правом указателе pr.
      </li>
      <li>
        Вначале поставим pr на последний элемент массива, pl за пределы массива
        <code>let pl = -1, pr = nums.length - 1;</code>
      </li>
      <li>Пока левый и правый указаели не окажутся рядом
        <code>while (pr - pl > 1)</code>
      </li>
      <li>Находим середину (опорный элемент)
        <code>let m = Math.floor((pl + pr) / 2);</code>
      </li>
      <li>Проверяем условие. Передаем в нашу функцию опорный элемент
        <code>if (goodOffset(nums[m], target))</code>
      </li>
      <li>Если элемент хороший (функция вернула true), то двигаем левый указатель вправо на опорный элемент
        <code>pl = m;</code>
      </li>
      <li>Если элемент плохой (функция вернула false), то двигаем правый указатель влево на опорный элемент
        <code>pr = m;</code>
      </li>
      <li>Ответ будет находиться в элементе указывающем на pr. Чтобы pr мог принимать значения [0, nums.length - 1] т.е. от первого и до последнего индекса включительно, сдвигаем pl на 1 влево от первого индекса массива.</li>
      <li>Когда цикл закончится, вернем pr
        <code>return pr;</code>
      </li>
    </ol>
  </details>

  <details>
    <summary>Код поиска сдвига (javascript)</summary>
<pre>
function findOffset(nums) {

  function goodOffset(i) {
    return nums[i] >= nums[nums.length-1];
  }

  let pl = -1;
  let pr = nums.length - 1;

  while (pr - pl > 1) {
    let m = Math.floor((pl +pr) / 2);
    if (goodOffset(m)) {
      pl = m;
    } else {
      pr = m;
    }
  }

  return pr;
}
</pre>
  </details>

  <details>
    <summary>Код поиска сдвига (python)</summary>
<pre>
class Solution:
  def findOffset(self, nums: list[int]):

    def goodOffset(i: int):
      return nums[i] >= nums[-1]

    pl, pr = -1, len(nums) - 1

    while pr - pl > 1:
      m = (pl + pr) // 2
      if goodOffset(m):
        pl = m
      else:
        pr = m

    return pr
</pre>
  </details>
</article>


<!-- Задача 5. Найти число в отсортированном массиве со сдвигом -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача 5. Найти число в отсортированном массиве со сдвигом</h3>

  <h4>Leetcode 33. Search in Rotated Sorted Array</h4>

  <p>Эта задача с собеседования в ВК и Яндекс.</p>
  <p>Есть массив чисел nums. Он отсортирован по возрастанию, но со сдвигом. Еще есть target - число, позицию которого нужно вернуть, если оно есть в массиве nums. Если его нет - вернуть -1.</p>

  <p>Эта садача такая же как поиск элемента в отсортированном массиве, но осложненная сдвигом. Тут бинарный поиск придется применить два раза. Первый раз когда будем искать сам сдвиг. Второй раз для поиска самого элемента.</p>

  <h4>Пример 1</h4>
  <code>nums = [4,5,6,7,0,1,2], target = 0</code>
  <code>Output: 4</code>

  <h4>Пример 2</h4>
  <code>nums = [4,5,6,7,0,1,2], target = 3</code>
  <code>Output: -1</code>

  <h4>Пример 3</h4>
  <code>nums = [1], target = 0</code>
  <code>Output: -1</code>

 <p>Массив [4,5,6,7,0,1,2] получен из массива [0,1,2,4,5,6,7] сдвигом на 4 элемента вправо</p>

  <h4>Паттерн два бинарных поиска</h4>
  <p>Первый бинарный поиск findOffset() для поиска сдвига</p>
  <p>Для первого бинарного поиска функция goodOffset делит массив на две части</p>
<pre>
function goodOffset(i) {
  return nums[i] >= nums[nums.length-1];
}
</pre>
  <p>Сдвиг будет в правом указателе, поэтому изначально ставим правый указатель на последний элемент, а левый за границы массива</p>
  <code>let l = -1, r = nums.length;</code>
  <p>В массиве без сдвига правый указатель после бинарного поиска будет указывать на нулевой индекс.</p>

  <p>Второй бинарный поиск findTarget для поиска target</p>
  <p>Для второго бинарного поиска функция goodTarget делит массив на две части</p>
<pre>
function goodOffset(i) {
  return nums[i] >= nums[nums.length-1];
}
</pre>

  <details>
    <summary>Алгоритм</summary>
  </details>

  <details>
    <summary>Код (javascript)</summary>
<pre>
function findTarget(nums, target) {
  function goodTarget(i) {
    return nums[i] &lt;= target;
  }

  // первым бинарным поиском ищем offset
  let offset = findOffset(nums);

  // вторым бинарным поиском ищем target
  let l = 0;
  let r = nums.length;
  while (r - l > 1) {
    // Ошибка №1 это делать m=(l+r+shift)/2
    let m = Math.floor((l + r) / 2);
    if (goodTarget((m+shift) % nums.length)) {
      l = m;
    } else {
      r = m;
    }
  }
  // Ошибка №2 это забыть сделать (l+shift) % nums.length
  // Берем остаток от деления чтобы не выйти за границы массива
  let realLeft = (l + shift) % nums.length;
  // если левый указатель указывает на target
  // то вернуть левый указатель, иначе -1
  return nums[realLeft] === target ? realLeft : -1;
}

function findOffset(nums) {

  function goodOffset(i) {
    return nums[i] >= nums[nums.length-1];
  }

  let pl = -1;
  let pr = nums.length - 1;

  while (pr - pl > 1) {
    let m = Math.floor((pl +pr) / 2);
    if (goodOffset(m)) {
      pl = m;
    } else {
      pr = m;
    }
  }

  return pr;
}
</pre>
  </details>

  <details>
    <summary>Код (python)</summary>
<pre>
class Solution:
  def search(self, nums: list[int], target: int) -> int:
    def findOffset(self, nums: list[int]):
      def goodOffset(i: int):
        return nums[i] >= nums[-1]

      pl, pr = -1, len(nums) - 1
      while pr - pl > 1:
        m = (pl + pr) // 2
        if goodOffset(m):
          pl = m
        else:
          pr = m

      return pr

    def goodTarget(i: int):
      return nums[i] &lt;= target

    // первым бинарным поиском ищем offset
    offset = self.findOffset(nums)

    // вторым бинарным поиском ищем target
    pl, pr = 0, len(nums)
    while pr - pl > 1:
      m = (pl + pr) // 2
      // передаем середину в функцию учитывая offset
      if goodTarget((m + offs) % len(nums)):
        pl = m
      else:
        pr = m

      realLeft = (pl + offs) % len(nums)
      return realLeft if nums[realLeft] == target else - 1
</pre>
  </details>
</article>


<!-- Задача 6. Найти число в отсортированной матрице -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача 6. Найти число в отсортированной матрице</h3>

  <h4>Leetcode 74. Search a 2D Matrix</h4>

  <p>Дана целочисленная матрица matrix размером m x n со следующими двумя свойствами</p>
  <p>Первое, каждый ряд отсортирован в неубывающем порядке</p>
  <p>Второе, первое число в каждом ряду больше чем последнее число предыдущего ряда</p>
  <p>Дано целое число target. Вернуть true если target есть в матрице, иначе вернуть false</p>

  <h4>Пример 1</h4>
<pre>
[
  [ 1,  3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 60]
]
target = 3
</pre>
  <code>Output: true</code>

  <p>Есть два варианта решения</p>
  <h4>Первый вариант. Паттерн бинарный поиск.</h4>
  <p>Если представить матрицу matrix(n,m) в виде одномерного массива arr(n*m), то мы можем найти target в нем используя бинарный поиск.</p>
  <p>Чтобы не выделять память под новый массив, будем пересчитывать индексы матрицы на индесы массива, не создавая его. Индекс массива arr будет складываться из индекса строки матрицы и индекса столбца матрицы</p>
  <code>arr[i] = matrix[i / n][i % n]</code>
  <p>Сложность по времени O(log(n*M))</p>
  <p>Сложность по памяти O(1)</p>

  <h4>Второй вариант. Паттерн два бинарных поиска.</h4>
  <p>Сначала запустим первый бинарный поиск по первым элементам всех строк. Так найдем строку в которой может содержаться ответ</p>
  <p>Потом запустим второй бинарный поиск по найденной строке. Так найдем target</p>

  <details>
    <summary>Код на python</summary>
<pre>
class Solution:
  def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
    def elementFromMatrix(i: int):
      n = len(matrix[0])
      return matrix[i // n][i % n]

    def good(i: int):
      return elementFromMaatrix(i) &lt;= target

    l, r, len(matrix) * len(matrix[0])
    while r - l &gt; 1:
      m = (l + r) // 2
      if good(m):
        l = m
      else:
        r = m

    return elementFromMatrix(l) == target
</pre>
  </details>
</article>


<!-- Задача 7. Найти квадратный корень числа -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача 7. Найти квадратный корень числа</h3>

  <h4>Leetcode 69. Sqrt(x)</h4>

  <p>Дано неотрицательное целое число x. Вернуть квадратный корень от x, округленный вниз к ближайшему целому числу. Ответ должен быть также неотрицательным числом.</p>

  <h4>Примечание</h4>
  <p>Нельзя использовать встроенные функции или операторы взятия корня или возведения в степень</p>

  <h4>Ограничения</h4>
  <code>0 &lt;= x &lt;= 2<sup>31</sup>-1</code>

  <h4>Пример 1</h4>
  <code>Input: x = 4</code>
  <code>Output: 2</code>

  <h4>Пример 2</h4>
  <code>Input: x = 8</code>
  <code>Output: 2</code>

  <h4>Паттерн бинарный поиск</h4>
  <p>Напишем функцию good(), которая будет определять подходит нам число или нет.</p>
  <code>i * i &lt;= target</code>
  <p>Ответ будет лежать в левом указателе</p>
  <p>Корень неотрицательного целого числа x может лежать в диапазоне от 0 до числа x. Поэтому поставим левый указатель на 0, а правый на число x+1</p>
  <p>На каждом шаге будем уменьшать диапазон в 2 раза и проверять средний элемент функцией good()</p>
  <p>Сложность по времени O(logN)</p>
  <p>Сложность по памяти O(1)</p>

  <details>
    <summary>Код на python</summary>
<pre>
class Solution:
  def mySqrt(self, x: int) -> int:
    def good(i: int):
      return i * i &lt;= x

    l, r = 0, x + 1

    while r - l &gt; 1:
      m = (l + r) // 2
      if good(m):
        l = m
      else:
        r = m

    return l
</pre>
  </details>
</article>


<!-- Задача 8. Найти K ближайших элементов -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача 8. Найти K ближайших элементов</h3>

  <h4>Leetcode 658. Find K Closest Elements</h4>

  <p>Дан отсортированный массив целых чисел arr, и два целых числа k и x. Вернуть k ближайших целых чисел к x в массиве.Результат должен быть отсортирован в возрастающем порядке</p>
  <p>Число a ближе к числу x чем чесло b, если</p>
  <code>|a-x| &lt; |b-x|</code> или
  <code>|a-x| == |b-x| и a &lt; b</code>

  <h4>Пример 1</h4>
  <code>arr = [1,2,3,4,5], k = 4, x = 3</code>
  <code>Output: [1,2,3,4]</code>

  <h4>Пример 2</h4>
  <code>arr = [1,2,3,4,5], k = 4, x = -1</code>
  <code>Output: [1,2,3,4]</code>

  <h4>Решение</h4>
  <p>Немного переформулируем задачу. Нас просят найти самую выгодную позицию плавающего окна в котором K наиболее ближайших элементов к X. Ответ (K ближайших чисел) распологается в исходном массиве непрерывно</p>
  <p>Для решения будем использовать бинарный поиск, т.к. можно для каждой позиции окна однозначно сказать выгодно ли двигать окно вправо или нет</p>
  <p>Хороший - если подвинуть вправо выгодно</p>
  <p>Сравниваем arr[i] и arr[i+k] чтобы понять что ближе к X. Если arr[i] ближе, то нет смысла двигать вправо т.к. arr[i+k] элемент, который будет в нашем плавающем окне если шагнуть вправо</p>
  <p>arr[i+k] это именно элемент который войдет если подвинуть плавающее окно, т.е. сейчас он не входит</p>
  <p>Ответ будет в r, поэтому изначально l = -1, чтобы r мог принимать значения [0, len(arr)-k] включительно</p>

  <details>
    <summary>Код на python</summary>
<pre>
class Solution:
  def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:

    def good(i: int):
      return x - arr[i] > arr[i+k] - x
</pre>
  </details>
</article>

