<h1>Задачи Авито</h1>


<article class="article">
  <p>Конспект из двух видео</p>
  <p>Первое от 2023-08-19 <strong>Самая ПОПУЛЯРНАЯ задача на собеседовании в АВИТО</strong></p>
  <p>Второе <strong>Интервалы</strong></p>

  <p><a href="https://www.youtube.com/@fatin.maksim/videos">youtube Максим Фатин</a></p>
  <p><a href="https://tskills.ru/algo">https://tskills.ru/algo</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p><a href="#avito">Задачи Авито</a></p>
  <p><a href="#task1">Задача 1. Два неубывающих массива</a></p>
  <p><a href="#task2">Задача 2. Сложение двух чисел</a></p>
  <p><a href="#task3">Задача 3. Топ K самых частых элементов</a></p>
</article>


<!-- Задачи Авито -->
<article class="article">
  <div class="anchor" id="avito"></div>
  <h3>Задачи Авито</h3>
  <p>Авито, по моему мнению, один из лучших IT работодателей. Потому что имеет сильный технический бренд и достойную оплату труда</p>

  <h4>Что спрашивают в Авито</h4>
  <p>В Авито три секции. Первая Алгоритмы на любом языке. Вторая Платформа, когда спрашивают по знаниям конкретного языка. Третья System Design. Есть еще четвертая секция Скрининг, самая первая где-то на полчаса и там гоняют по общим вопросам. Но если компания тебя уже знает, то ее могут пропустить.</p>

  <h4>Все задачи алгоритмических собеседований и контестов Авито</h4>

  <ol>
    <li>Merge Sorted Array (easy)</li>
    <li>Add Two Numbers (easy)</li>
    <li>Top K Frequent Elements (medium)</li>
    <li>Kth Largest Element in an Array (medium)</li>
    <li>Combination Sum II (medium)</li>
    <li>Sum of Subarray Minimums (hard)</li>
  </ol>

  <h4>Дополнительные вопросы</h4>

  <ol>
    <li>
      <h4>Устройство хеш-мапы</h4>
      <ul>
        <li>что такое коллизии</li>
        <li>методы разрешения коллизий</li>
        <li>оценка по времени для всех операций</li>
        <li>как это работает конкретно в вашем ЯП</li>
      </ul>
    </li>
    <li>
      <h4>Структура данных "куча"</h4>
      <ul>
        <li>зачем нужна. примеры задач где можно применить</li>
        <li>оценка по времени для операций</li>
        <li>как устроена внутри</li>
      </ul>
    </li>
    <li>
      <h4>Сортировки</h4>
      <ul>
        <li>виды</li>
        <li>quick sort - сложность</li>
      </ul>
    </li>
  </ol>
</article>


<!-- Задача 1. Два неубывающих массива -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача 1. Два неубывающих массива</h3>

  <p>Есть два неубывающих массива. Нужно их объединить в один неубывающий массив.</p>
  <p>Неубывающий массив - это массив, в котором значение каждого следующего элемента не меньше предыдущего. В отличие от возрастающего массива он может иметь ещё и равные элементы</p>

  <p>Примеры</p>
  <code>solve([-2, 3, 3], [-5, 0]); // [-5, -2, 0, 3, 3]</code>
  <code>solve([1, 2, 4], [9]); // [1, 2, 4, 9]</code>
  <code>solve([6], []); // [6]</code>

  <details>
    <summary>Алгоритм</summary>
    <p>Будем использовать паттерн <strong>два указателя - каждому по указателю</strong></p>
    <ol>
      <li>Заведем переменную res для результата. Положим в нее пустой массив
        <code>let res = [];</code>
      </li>
      <li>Заведем две переменные p1 и p2 для указателей. Поставим первый указатель на первый элемент первого массива, второй - на первый элемент второго.
        <code>let p1 = 0, p2 = 0;</code>
      </li>
      <li>Заведем две переменные len1 и len2 для длин массивов. Чтобы на каждой итерации не вычислять длину заново. Запишем в len1 длину первого массива, а в len2 - второго
        <code>let len1 = a1.length, len2 = a2.length;</code>
      </li>
      <li>Запустим цикл пока хотя бы один из указателей еще не дошел до конца массива
        <code>while (p1 &lt; len1 || p2 &lt; len2)</code>
      </li>
      <li>На каждой итерации будем проверять условие. Если второй указатель вышел за границы массива, или если первый указатель не вышел за границы массива и элемент первого массива меньше элемента второго
        <code>if (p2 >= len2 || p1 &lt; len1 && nums1[p1] &lt;= nums2[p2])</code>
      </li>
      <li>Если условие выполняется, то добавим элемент первого указателя в результирующий массив и сдвинем первый указатель
        <code>res.push(nums1[p1]); p1++;</code>
      </li>
      <li>Иначе добавим элемент второго указателя и сдвинем второй указатель
        <code>else {res.push(nums2[p2]); p2++;}</code>
      </li>
    </ol>
    <p>Сложность по времени O(n + m) поскольку мы проходим один раз по каждому массиву</p>
    <p>Сложность по памяти O(n + m) поскольку мы создаем массив для результата размера n + m</p>
  </details>

  <details>
    <summary>Решение (javascript)</summary>
<pre>
function solve(nums1, nums2) {
  let res = [];
  let p1 = 0, p2 = 0;
  let len1 = nums1.length, len2 = nums2.length;

  while (p1 &lt; len1 || p2 &lt; len2) {
    if (p2 >= len2 || p1 &lt; len1 && nums1[p1] &lt;= nums2[p2]) {
      res.push(nums1[p1]);
      p1++;
    } else {
      res.push(nums2[p2]);
      p2++;
    }
  }

  return res;
}
</pre>
  </details>

  <details>
    <summary>Решение (python)</summary>
<pre>
def solve(nums1: list[int], nums2: list[int]) -> list[int]:
  res = []
  p1, p2 = 0, 0
  len1 = len(nums1), len2 = len(nums2)

  while p1 &lt; len1 or p2 &lt; len2:
    if p2 >= len2 or p1 &lt; len1 && nums1[p1] &lt;= nums2[p2]:
      res.append(nums1[p1]);
      p1++;
    else:
      res.append(nums2[p2]);
      p2++

  return res
</pre>
  </details>
</article>


<!-- Задача 2. Сложение двух чисел -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача 2. Сложение двух чисел</h3>

  <h4>Leetcode 2. Add Two Numbers</h4>

  <p>В этой задаче входные данные могут придти или в связном списке, или в массиве, или в строке. В каждом случае внутри есть только цифры от 0 до 9</p>

  <p>На leetcode, в Сбере и в Яндекс задача дается на связные списки</p>

  <p>Задача на связные списки звучит так. Даны два не пустых связных списка, представляющих собой два неотрицательных целых числа. Цифры хранятся в перевернутом порядке. Каждый узел хранит одну цифру. Сложите два этих числа и верните сумму в виде такого же связного списка</p>

  <p>На Авито дают эту задачу на массивы</p>

  <p>Задача на массивы звучит так. Даны два массива цифр. Вернуть массив цифр с результатом сложения этих цифр</p>

  <h4>Пример 1</h4>
  <p>В оригинальной задаче числа перевернутые</p>
  <code>arr1 = [2, 4, 3], arr2 = [5, 6, 4]</code>
  <code>Output: [7, 0, 8]</code>
  <p>342 + 465 = 807</p>

  <h4>Пример 2</h4>
  <p>В Авито числа не перевернутые</p>
  <code>arr1 = [1, 2, 3], arr2 = [4, 5, 6]</code>
  <code>Output: [0, 5, 7, 9]</code>
  <p>Один ведущий ноль в ответе допускается</p>

  <h4>Пример 3</h4>
  <code>arr1 = [1, 1, 1], arr2 = [1]</code>
  <code>Output: [1, 1, 2]</code>

  <h4>Пример 4</h4>
  <code>arr1 = [9, 9, 9], arr2 = [1]</code>
  <code>Output: [1, 0, 0, 0]</code>

  <h4>Решение</h4>
  <p>В результате сложения может получиться массив длиной равной самому длинному из двух входных массивов +1. Поэтому для результата создаем массив result длиной Math.max(arr1.length, arr2.length) + 1. Причем в самом старшем разряде будет или 0 или 1.</p>
  <p>Теперь нужно научиться складывать эти цифры. Для этого нужно три действия. Сложение (add), перенос (carry) 1 в следующий разряд, учет переноса при сложении.</p>
  <p>Сложим две цифры 9 и 9</p>
  <code>add = (9+9)%10; carry = Math.floor(9/9);</code>
  <p>Пройдем по массиву и сложим цифры одинаковых разрядов, начиная с младших. Тогда в результат (новый массив цифр) мы будем записывать результат сложения</p>
  <code>sum = carry + arr1[i] + arr2[i]</code>
  <code>result[i] = sum%10</code>
  <code>carry = Math.floor(sum/10)</code>
  <p>Сложность по времени O(N)</p>
  <p>Сложность по памяти O(N)</p>

  <details>
    <summary>Код на python для связного списка</summary>
<pre>
class Solution:
  def addTwo(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
    dummy = ListNode()
    carry = 0
    digit = dummy

    # продолжаем находить сумму до тех пор пока есть цифра в одном из списков или пока есть перенос от сложения
    while l1 is not None or l2 is not None or carry != 0:
      # если в рязряде нет цифры, то берем 0
      l1Val = l1.val if l1 is not None else 0
      l2Val = l2.val if l2 is not None else 0

      sum = l1Val + l2Val + carry
      newNode = ListNode(sum % 10)
      carry = sum // 10

      digit.next = newNode
      digit = digit.next

      l1 = l1.next if l1 is not None else None
      l2 = l2.next if l2 is not None else None

    return dummy.next
</pre>
  </details>
</article>


<!-- Задача 3. Топ K самых частых элементов -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача 3. Топ K самых частых элементов</h3>

  <h4>Leetcode 347. Top K Frequent Elements (medium)</h4>

  <p>Дан массив целых чисел nums и целое число K. Вернуть массив из K самых частых элементов. Элементы можно вернуть в любом порядке</p>
  <p>Гарантируется что ответ будет только один</p>

  <h4>Пример 1</h4>
  <code>nums = [1,1,1,2,2,3], k = 2</code>
  <code>Output: [1,2]</code>

  <h4>Пример 2</h4>
  <code>nums = [1], k = 1</code>
  <code>Output: [1]</code>

  <h4>Паттерн ключ-значение и значение-ключ</h4>
  <p>Пусть входной массив nums имеет длину len. Заводим словарь dict = {} ключ-значение. Проходим по входному массиву и заполняем словарь dict. Ключ - элемент входного массива. Значение - сколько раз он встретился. Значением в dict может быть только целое число от 1 до len</p>
  <p>Заводим массив freq = [] длиной len+1. Делаем реверс словаря dict ключ-значение на значение ключ и кладем элемент в массив.</p>
  <p>Сложность по времени O(N)</p>
  <p>Сложность по памяти O(N)</p>

  <details>
    <summary>Код на python</summary>
<pre>
class Solution:
  def topKFrequent(self, nums: List[int], k: int) -> List[int]:
    count = {}
    for num in nums:
      if num not in count:
        count[num] = 0
      count[num] += 1

    freq = [[] for _ in range(len(nums) + 1)]
    for num in count:
      idx = count[num]
      freq[idx].append(num)

    result = []
    for revFreq in reversed(freq):
      for num in revFreq:
        if k &lt;= 0:
          return result
        result.append(num)
        k -= 1

    return result
</pre>
  </details>
</article>
