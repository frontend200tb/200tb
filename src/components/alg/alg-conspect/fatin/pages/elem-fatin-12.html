<h1>Префиксный массив</h1>


<article class="article">
  <p>Конспект двух видео</p>
  <p>Первое от 2024-11-03 <strong>Хакни BigTech и Массивы</strong></p>
  <p>Второе <strong>Массивы</strong></p>

  <p><a href="https://www.youtube.com/@fatin.maksim/videos">youtube Максим Фатин</a></p>
  <p><a href="https://tskills.ru/algo">https://tskills.ru/algo</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p><a href="#about">План на стрим</a></p>
  <p><a href="#interv">Как тебя оценивает интервьюер</a></p>
  <p><a href="#roadmap">RoadMap для изучения массивов</a></p>
  <p><a href="#roadmap2">RoadMap для изучения префиксных массивов</a></p>
  <p><a href="#task1">Задача 1. Сумма на отрезках</a></p>
  <p><a href="#task2">Задача 2. Произведение на отрезках</a></p>
  <p><a href="#task3">Задача 3. Индекс равных сумм</a></p>
  <p><a href="#task4">Задача 4. Подмассив с суммой K</a></p>
  <p><a href="#task5">Задача 5. Сумма подматрицы</a></p>
  <p><a href="#task6">Задача 6. Сумма блока в матрице</a></p>
  <p><a href="#task7">Задача 7. Пропущенное число</a></p>
  <p><a href="#task8">Задача 8. Повторяющееся число</a></p>
  <p><a href="#task9">Задача 9. Пропущенное и повторяющееся число</a></p>
  <p><a href="#task10">Задача 10. Сдвинуть массив</a></p>
  <p><a href="#task11">Задача 11. Монотонный массив</a></p>
  <p><a href="#task12">Задача 12. Самый длинный возрастающий подмассив</a></p>
</article>


<!-- План на стрим -->
<article class="article">
  <div class="anchor" id="about"></div>
  <h3>План на стрим</h3>

  <p>Сегодня у нас в программе массивы для BigTech. Будем разбирать что вообще необходимо знать про массивы. Это не такая то уж и простая тема. Будем разговаривать как тебя оценивает интервьюер и что нужно для собеса.</p>

  <ol>
    <li>Как тебя оценивает интервьюер</li>
    <li>Что важнее всего на собесе в BigTech</li>
    <li>RoadMap для изучения алгосов</li>
    <li>Решим задачи с собеса Яндекса, Озона, Сбера, Joom</li>
  </ol>
</article>


<!-- Как тебя оценивает интервьюер -->
<article class="article">
  <div class="anchor" id="interv"></div>
  <h3>Как тебя оценивает интервьюер</h3>

  <ol>
    <li>
      <h4>Придумывание решения</h4>
      <p>Максимум 2 балла. Не решил 0 баллов. Решил, но были существенные подсказки 1 балл. Решил сам 2 балла.</p>
    </li>
    <li>
      <h4>Оценка сложности</h4>
      <p>Максимум 1 балл. Оценил не верно 0 баллов. Верная оценка, возможны подсказки 1 балл</p>
    </li>
    <li>
      <h4>Качество кода</h4>
      <p>Максимум 2 балла</p>
    </li>
    <li>
      <h4>Ошибки и их исправление</h4>
      <p>Максимум 2 балла</p>
    </li>
  </ol>

  <p>Существенные подсказки это когда вы не знаете как решать, а интервьюер дает вам направление в котором надо подумать. Никто сразу же существенные подсказки давать не будет. Сначала дадут подумать кандидату самому. Потом дадут небольшую подсказку. И уже когда выходим за тайминги, тогда могут дать существенную подсказку</p>
  <p>Тайминги обычно такие. 20 минут на первую задачу. 40 минут на вторую задачу. Если обе задачи решил и еще осталось время то дают третью задачу и очень круто если ее ты тоже решишь.</p>
  <p>В яндексе последние 20 минут дадут блиц опрос чтобы точнее определить твой грейд. Это будет опрос не по алгоритмам, а по SQL, system disign, по языку программирования</p>
  <p>В любом коде содержатся ошибки. Но если ты ошибку находишь сам, то это большой плюс. Не во всех компаниях запускают код. Поэтому если у тебя есть ошибка, то может и прокатить, а может и нет.</p>
  <p>Качество кода. У интервьюера уже есть эталонное решение, к которому они хотят максимально подвести кандидата.</p>

  <h4>Что важнее всего?</h4>
  <ol>
    <li>Придумать решение</li>
    <li>Оценить время и память</li>
    <li>Качество кода</li>
    <li>Ошибки и их исправление</li>
  </ol>

  <h4>Как часто нужны массивы на собесе</h4>
  <p>Более 34.3% задач на собесах это массивы</p>
</article>


<!-- RoadMap для изучения массивов -->
<article class="article">
  <div class="anchor" id="roadmap"></div>
  <h3>RoadMap для изучения массивов</h3>

  <h4>Массивы</h4>
  <ol>
    <li>
      <h4>Префиксный массив</h4>
    </li>
    <li>
      <h4>Два указателя</h4>
      <ol>
        <li>
          <h4>С двух сторон</h4>
          <p>Левый указатель ставим на начало массива, правый на конец массива и они идут навстречу друг другу пока не встретятся.</p>
        </li>
        <li>
          <h4>Каждому по указателю</h4>
          <p>Первый указатель ставят на начало первого массива, второй - на начало второго и они идут до конца массива, сравнивая элементы между собой</p>
        </li>
        <li>
          <h4>Медленный и быстрый</h4>
          <p>В задачах, где надо в массиве заменить какие-то элементы, например, перенести все нули в конец массива.</p>
        </li>
      </ol>
    </li>
    <li>
      <h4>Плавающее окно</h4>
      <ol>
        <li>
          <h4>Пересекающиеся окна</h4>
        </li>
        <li>
          <h4>Не пересекающиеся окна</h4>
        </li>
        <li>
          <h4>Окна фиксированной длины</h4>
        </li>
      </ol>
    </li>
    <li>
      <h4>Задачи на внимательность</h4>
    </li>
  </ol>
</article>


<!-- RoadMap для изучения префиксных массивов -->
<article class="article">
  <div class="anchor" id="roadmap2"></div>
  <h3>RoadMap для изучения префиксных массивов</h3>

  <ol>
    <li>
      <h4>Префиксный массив</h4>
      <p>Например, надо найти сумму на отрезке. Сначала создаем массив префиксных сумм за O(N) и на нем уже ищем сумму за O(1)</p>
    </li>
    <li>
      <h4>Два префиксных массива</h4>
      <p>Например, надо найти произведение на отрезке. Сначала создаем первый префиксный массив в котором сохраним только количество нулей. Во втором префиксном массиве сохраним произведение всех не нулевых элементов. Создание массива за O(N). Нахождение произведения за O(1)</p>
    </li>
    <li>
      <h4>Массив суффиксов</h4>
    </li>
    <li>
      <h4>Накопение суммы</h4>
      <p>Сначала ищем сумму элементов массива. Потом зная всю сумму мы избавляемся от дополнительной памяти</p>
    </li>
    <li>
      <h4>Запоминание предыдущих преффиксных сумм (хеш-таблица)</h4>
      <p>Паттерн запоминания предыдущих преффиксных сумм используется в задачах на хещ-таблицы, бинарные деревья.</p>
    </li>
    <li>
      <h4>2D - преффиксные суммы</h4>
      <p>Двумерные преффиксные суммы используются в матрицах в задачах на сумму, произведение или количество в любом месте матрицы. Также в задачах про строки, столбцы или дианонали матрицы</p>
    </li>
  </ol>

  <h4>Оценка сложности преффиксного массива</h4>
  <p>Сложность по времени O(N)</p>
  <p>Сложность по памяти O(N) если храним преффиксный массив, сложность O(1) если не храним.</p>

  <p>Подходит для:</p>
  <ol>
    <li>Сумма элементов на отрезке</li>
    <li>Произведение элементов на отрезке</li>
    <li>XOR элементов на отрезке</li>
    <li>Количество четных на отрезке</li>
    <li>Количество с каким-то свойством</li>
    <li>База данных. Предагрегативная функция. Надо найти среднее значение на отрезке</li>
  </ol>
  <p>Не подходит для:</p>
  <ol>
    <li>Поиск min или max на отрезке. Для операций у которых нет обратных</li>
    <li>При модификации массива</li>
  </ol>
</article>


<!-- Задача 1. Сумма на отрезках -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача 1. Сумма на отрезках</h3>

  <h4>Leetcode 303. Range Sum Query - Immutable</h4>

  <p>Дан массив целых чисел nums и приходит множество запросов вида [l, r]. Реализуй структуру данных из входного массива, которая умеет быстро находить сумму всех элементов на отрезке [l, r], где l,r - индексы, включая сами индексы. Массив при этом не изменяется</p>

  <h4>Пример</h4>
  <code>nums = [2,1,3,5,4]</code>
  <code>l = 0, r = 0 // 2</code>
<pre>
        |0|
nums = [ 2, 1, 3, 5, 4 ]
         0  1  2  3  4
</pre>
  <code>l = 0, r = 4 // 15 (2+1+3+5+4)</code>
<pre>
        |0|         |4|
nums = [ 2, 1, 3, 5, 4 ]
         0  1  2  3  4
</pre>
  <code>l = 1, r = 3 // 9 (1+3+4)</code>
<pre>
           |1|   |3|
nums = [ 2, 1, 3, 5, 4 ]
         0  1  2  3  4
</pre>

  <h4>Паттерн префиксный массив</h4>

  <p>Префикс - это что-то от начала и до какого-то элемента.</p> <p>Префиксная сумма - это сумма элементов от начала и до какого-то элемента.</p>

<pre>
nums =    [2, 1, 3,  5,  4]
           0  1  2   3   4
px   = [0, 2, 3, 6, 11, 15]
        0  1  2  3   4   5
</pre>

  <p>Паттерн состоит из двух этапов</p>
  <ol>
    <li>Инициализация. Создаем дополнительный префиксный массив - это структура данных, которая хранит сумму всех предыдущих элементов. При этом первый элемент 0, потому что у него нет предыдущих элементов.</li>
    <li>Ответ на запрос суммы на отрезке за одну операцию - вычитание.</li>
  </ol>
  <details>
    <summary>Алгоритм</summary>
    <h4>Создадим функцию pxArray(), которая принимает на вход массив и строит из него нужную структуру данных. На выходе префиксный массив</h4>
    <ol>
      <li>Создаем массив, в который будем записывать префиксные суммы.
      <code>const px = [];</code>
    </li>
      <li>В самый первый элемент с индексом 0 запишем значение 0
        <code>px[0] = 0;</code>
        0 нужен для того, чтобы потом мы могли его вычитать, если отрезок начинается с начала массива. Это позволит избавиться от дополнительной проверки условия if что индекс указывает на начало массива
      </li>
      <li>Каждый следующий элемент формируется по алгоритму. Берется предыдущий элемент и к нему прибавляется элемент из входного массива nums.</li>
      <li>Проходим по входному массиву
        <code>for (const i = 0; i &lt; nums.length; i++)</code>
      </li>
      <li>В префиксный массив записываем сумму
        <code>px[i+1] = px[i] + nums[i];</code>
      </li>
    </ol>
    <p>Сложность по времени O(N) на создание префиксного массива</p>
    <p>Сложность по памяти O(N) на хранение префиксного массива</p>

    <h4>Напишем функцию sumRange(), которая принимает два индекса - левый и правый и возвращает сумму элементов между этими двумя индесами, включая элементы в этих индексах</h4>
    <p>Придумаем формулу нахождения суммы между двумя индексами</p>
    <p>Поскольку левый и правый индекс включительно и префиксный массив имеет индексы на 1 больше чем исходный, то
      <code>result = px[right + 1] - px[left]</code>
    </p>
    <p>Сложность по времени O(1) на вычисление суммы</p>
    <p>Сложность по памяти O(1) на хранение результата</p>
  </details>
  <details>
    <summary>Код на javascript</summary>
<pre>
function pxArray(nums) {
  this.px = [0];
  for (const num of nums) {
    this.px.push(this.px[this.px.length - 1] + num);
  }
}

pxArray.prototype.sumRange = function(left, right) {
  return this.px[right+1] - this.px[left];
};
</pre>
  </details>

  <details>
    <summary>Код на python</summary>
<pre>
class pxArray:
  def __init__(self, nums: List[int]):
    px = [0, ]
    for num in nums:
      px.append(px[-1] + num)
    self.px = px

  def sumRange(self, left: int, right: int) -> int:
    return self.px[right + 1] - self.px[left]
</pre>
  </details>

  <details>
    <summary>Код на go</summary>
<pre>
type pxArray struct {
  px []int
}

func Constructor(nums []int) pxArray {
  px := make([]int, len(nums)+1)
  for i, num := range nums {
    px[i+1] = px[i] + num
  }
  return pxArray{px}
}

func (this *pxArray) SumRange(left int, right int) int {
  return this.px[right+1] - this.px[left]
}
</pre>
  </details>

  <details>
    <summary>Код на java</summary>
<pre>
class pxArray {
  private int[] px;
  public pxArray(int[] nums) {
    px = new int[nums.length + 1];
    for (int i = 0; i &lt; nums.length; i++) {
      px[i + 1] = px[i] + nums[i];
    }
  }
  public int sumRange(int left, int right) {
    return px[right + 1] - px[left];
  }
}
</pre>
  </details>

  <details>
    <summary>Код на C++</summary>
<pre>
class pxArray {
public:
  pxArray(vector&lt;int&gt;& nums) {
    px.push_back(0);
    for (int num : nums) {
      px.push_back(px.back() + num);
    }
  }
  int sumRange(int left, int right) {
    return px[right+1] - px[left];
  }

private:
  vector&lt;int&gt; px;
};
</pre>
  </details>
</article>


<!-- Задача 2. Произведение на отрезках -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача 2. Произведение на отрезках</h3>

  <p>Реализуй структуру данных, которая умеет быстро находить прооизведение всех элементов на отрезке [l, r], где l,r - индексы, включая сами индексы. Массив при этом не изменяетсся. Учитываем что в массиве могут быть нули.</p>

  <h4>Пример</h4>
  <code>nums = [1,0,2,3,4]</code>
  <code>l = 0, r = 0 // 1</code>
<pre>
        |0|
nums = [ 1, 0, 2, 3, 4 ]
         0  1  2  3  4
</pre>

  <code>l = 1, r = 3 // 0 (0*2*3)</code>
<pre>
           |1|   |3|
nums = [ 1, 0, 2, 3, 4 ]
         0  1  2  3  4
</pre>

  <code>l = 2, r = 4 // 24 (2*3*4)</code>
<pre>
              |2|   |4|
nums = [ 1, 0, 2, 3, 4 ]
         0  1  2  3  4
</pre>

  <h4>Паттерн два префиксных массива</h4>
  <p>Префикс - это что-то от начала и до какого-то элемента.</p> <p>Префиксное произведение - это произведение элементов от начала и до какого-то элемента.</p>
  <p>Первый префиксный массив сохранит только количество нулей. А второй префиксный массив сохранит произведение всех не нулевых элементов</p>
  <p>Если на отрезке есть нули, то произведение равно нулю. Если нулей нет, то произведение равно произведению не нулевых элементов на отрезке.</p>

<pre>
nums =    [1, 0, 2, 3,  4]
           0  1  2  3   4
px0  = [0, 0, 1, 1, 1,  1]
        0  1  2  3  4   5
px   = [1, 1, 1, 2, 6, 24]
        0  1  2  3  4   5
</pre>

<details>
  <summary>Алгоритм</summary>
  <h4>Создадим функцию px0Array(), которая принимает на вход массив. На выходе префиксный массив нулей</h4>
  <ol>
    <li>Создаем массив px0, в который будем записывать количество нулей.
    <code>const px0 = [];</code>
  </li>
    <li>В самый первый элемент с индексом 0 запишем значение 0
      <code>px0[0] = 0;</code>
      0 нужен для того, чтобы потом мы могли его вычитать, если отрезок начинается с начала массива. Это позволит избавиться от дополнительной проверки условия if что индекс указывает на начало массива
    </li>
    <li>Каждый следующий элемент формируется по алгоритму. Берется предыдущий элемент и к нему прибавляется 1 если элемент входного массива равен 0.</li>
    <li>Проходим по входному массиву
      <code>for (const i = 0; i &lt; nums.length; i++)</code>
    </li>
    <li>Проверяем условие и в массив px0 записываем количество нулей
<pre>
if (nums[i] === 0) {
  px0[i+1] = px0[i] + 1;
} else {
  px0[i+1] = px0[i];
}
</pre>
    </li>
  </ol>
  <p>Сложность по времени O(N) на создание префиксного массива</p>
  <p>Сложность по памяти O(N) на хранение префиксного массива</p>

  <h4>Создадим функцию pxArray(), которая принимает на вход массив. На выходе префиксный массив произведений</h4>
  <ol>
    <li>Создаем массив px, в который будем записывать префиксные произведения.
    <code>const px = [];</code>
  </li>
    <li>В самый первый элемент с индексом 0 запишем значение 1
      <code>px[0] = 1;</code>
      1 нужна для того, чтобы потом мы могли на нее делить, если отрезок начинается с начала массива. Это позволит избавиться от дополнительной проверки условия if что индекс указывает на начало массива
    </li>
    <li>Каждый следующий элемент формируется по алгоритму. Если приходит ноль, то записывается предыдущий элемент, иначе записывается произведение предыдущего элемента и элемента из входного массива nums.</li>
    <li>Проходим по входному массиву
      <code>for (const i = 0; i &lt; nums.length; i++)</code>
    </li>
    <li>Проверяем условие и в массив px записываем произведение не нулевых элементов
<pre>
if (nums[i] === 0) {
  px[i+1] = px[i];
} else {
  px[i+1] = px[i] * nums[i];
}
</pre>
    </li>
  </ol>
  <p>Сложность по времени O(N) на создание префиксного массива</p>
  <p>Сложность по памяти O(N) на хранение префиксного массива</p>

  <h4>Напишем функцию multRange(), которая принимает два индекса - левый и правый и возвращает произведение элементов между этими двумя индесами, включая элементы в этих индексах</h4>
  <ol>
    <li>Проверим условие, если на отрезке встречается 0, то все произведение равно 0
      <code>if (px0[right + 1] - px0[left] > 0) return 0;</code>
    </li>
    <li>Придумаем формулу нахождения произведения между двумя индексами</li>
    <li>Поскольку левый и правый индекс включительно и префиксный массив имеет индексы на 1 больше чем исходный, то
    <code>result = px[right + 1] / px[left]</code>
  </li>
  </ol>
  <p>Сложность по времени O(1) на вычисление произведения</p>
  <p>Сложность по памяти O(1) на хранение результата</p>
</details>

<details>
  <summary>Код на javascript</summary>
<pre>
function px0Array(nums) {
  this.px0 = [0];
  for (const i = 0; i &lt; nums.length; i++) {
    if (nums[i] === 0) {
      px0[i+1] = px0[i] + 1;
    } else {
      px0[i+1] = px0[i];
    }
  }
}

function pxArray(nums) {
  this.px = [1];
  for (const i = 0; i &lt; nums.length; i++) {
    if (nums[i] === 0) {
      px[i+1] = px[i];
    } else {
      px[i+1] = px[i] * nums[i];
    }
  }
}

pxArray.prototype.multRange = function(left, right) {
  return this.px[right+1] / this.px[left];
};
</pre>
</details>

</article>


<!-- Задача 3. Индекс равных сумм -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача 3. Индекс равных сумм</h3>

  <h4>Leetcode 724. Find pivot index. Поиск опорного индекса.</h4>

  <p>Дан массив целых чисел nums. Нужно найти самый левый индекс элемента, такой, что сумма всех элементов справа и слева от него равны</p>
  <p>Если с какой-либо из сторон нет элементов - считаем сумму равной нулю, а если в массиве нет такого индекса, то нужно вернуть -1</p>

  <h4>Пример 1</h4>
  <code>Input: nums = [7,3,4,5,5]</code>
  <code>Output: 2 // 7+3 = 5+5</code>

  <h4>Пример 2</h4>
  <code>Input: nums = [3,5,-5]</code>
  <code>Output: 0 // 0 = 5-5</code>

  <h4>Пример 3</h4>
  <code>Input: nums = [0,0,0]</code>
  <code>Output: 0 // 0 = 0+0</code>

  <h4>Паттерн префиксный массив и суфиксный массив</h4>
  <p>Найдем префиксные и суфиксные суммы и составим из них массивы</p>
<pre>
nums =    [7,  3,  4,  5,  5]
           0   1   2   3   4
pref = [0, 3, 10, 14, 19, 24]
        0  1   2   3   4   5
suf  =   [24, 17, 14, 10,  5, 0]
           0  1   2   3   4   5
</pre>

  <p>В ответе будет 2 - это индекс элемента, у которого преффиксная сумма равна суффиксной сумме</p>
  <p>Сложность по времени O(N). Сложность по памяти O(N)</p>
  <p>Эту задачу можно решить без дополнительной памяти</p>

  <h4>Второй способ</h4>
  <p>Нам нужны два цикла от 0 до N</p>
  <p>В первом цикле найдем сумму всех элементов sum = 24</p>
  <p>Во втором цикле будем определять сумму элементов слева ls и справа rs от текущего nums[i] и сравнивать их.</p>
  <p>В начале сумма элементов слева ls = 0. Сумма элементов справа rs = sum - ls - nums[0]</p>
  <p>Если суммы равны, то ответом будет индекс текущего элемента</p>
  <p>Если суммы не равны, то ls = ls + nums[i], и переходим к следующему элементу i = i + 1</p>
  <p>Сложность по времени O(N). Сложность по памяти O(1)</p>

  <details>
    <summary>Код на javascript</summary>
<pre>
function pivotIndex(nums) {
  let numsSum = 0;
  for (const num of nums) {
    numsSum += num;
  }
  let leftSum = 0;
  for (let i = 0; i &lt; nums.length; i++) {
    let rightSum = numsSum - leftSum - nums[i];
    if (leftSum === rightSum) {
      return i;
    }
    leftSum += nums[i];
  }
  return -1;
}
</pre>
  </details>

  <details>
    <summary>Код на python</summary>
<pre>
class Solution:
  def pivotIndex(self, nums: list[int]) -> int:
    numsSum = sum(nums)

    leftSum = 0
    for i, num in enumerate(nums):
      rightSum = numsSum - leftSum - num
      if leftSum == rightSum:
        return i
      leftSum += num
    return -1
</pre>
  </details>

  <details>
    <summary>Код на C++</summary>
<pre>
class Solution {
public:
  int pivotIndex(vector&lt;int&gt;& nums) {
    int numSum = accumulate(nums, begin(), nums.end(), 0);
    int leftSum = 0;
    for (int i = 0; i &lt; nums.size(); i++) {
      int rightSum = numsSum - leftSum - nums[i];
      if (leftSum == rightSum) {
        return i;
      }
      leftSum += nums[i];
    }
    return -1;
  }
}
</pre>
  </details>

  <details>
    <summary>Код на go</summary>
<pre>
func pivotIndex(nums []int) int {
  numsSum := 0
  for _, num := range nums {
    numsSum += num
  }
  leftSum := 0
  for i, num := range nums {
    rightSum := numsSum - leftSum - num
    if leftSum == rightSum {
      return i
    }
    leftSum += num
  }
  return -1
}
</pre>
  </details>

  <details>
    <summary>Код на java</summary>
<pre>
class Solution {
  public int pivotIndex(int[] nums) {
    int numsSum = 0;
    for (int num : nums) {
      numsSum += num;
    }
    int leftSum = 0;
    for (int i = 0; i &lt; nums.length; i++) {
      int rightSum = numsSum - leftSum - nums[i];
      if (leftSum == rightSum) {
        return i;
      }
      leftSum += nums[i];
    }
    return -1;
  }
}
</pre>
  </details>
</article>


<!-- Задача 4. Подмассив с суммой K -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача 4. Подмассив с суммой K</h3>

  <h4>Leetcode 560. Subarray Sum Equals K</h4>

  <p>Дан массив nums целых чисел и целое число K. Нужно вернуть число подмассивов, чья сумма равна K. Подмассив должен быть непрерывным</p>

  <h4>Пример 1</h4>
  <code>Input: nums = [1,1,1], k = 2</code>
  <code>Output: 2</code>

  <h4>Пример 2</h4>
  <code>Input: nums = [1,2,3], k = 3</code>
  <code>Output: 2</code>

  <h4>Паттерн Префиксная сумма</h4>
  <p>Создадим словарь. Проходим по входному массиву и для каждого элемента считаем префиксную сумму и записываем ее в словарь как ключ и сколько раз встречалась такая сумма записываем как значение. Проверяем разность между текущим элементом и K. Если эта разность есть в словаре, то добавляем к ответу ее значение.</p>
  <p>Сложность по времени O(N)</p>
  <p>Сложность по памяти O(N)</p>

</article>


<!-- Задача 5. Сумма подматрицы -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача 5. Сумма подматрицы</h3>

  <h4>Leetcode 304. Range Sum Query 2D - Immutable</h4>

  <p>Дана двумерная матрица целых чисел matrix и приходит множество запросов вида [row1, col1, row2, col2]. Реализуй структуру данных из входной матрицы, которая умеет быстро находить сумму всех элементов  внутри прямоугольника определенного верхним левым углом (row1, col1) и нижним правым углом (row2, col2). Матрица при этом не изменяется.</p>

  <h4>Пример</h4>
<pre>
[
  [3, 0, 1, 4, 2],
  [5, 6, 3, 2, 1],
  [1, 2, 0, 1, 5],
  [4, 1, 0, 1, 7],
  [1, 0, 3, 0, 5]
]
</pre>

  <h4>Паттерн префиксная матрица</h4>
  <p>Вхоящая исходная неизменяемая матрица</p>
<pre>
[
  [1, 1, 1],
  [1, 1, 1],
  [1, 1, 1]
]
</pre>
  <p>Префиксная матрица это матрица с суммой элементов в прямоугольнике от верхнего левого угла до текущего. Дополнительно добавим один ряд из нулей и один столбец из нулей чтобы отдельно не обрабатывать крайние случае, когда нужно считать сумму элементов на нулевой строке или столбце.</p>
<pre>
[
  [0, 0, 0, 0],
  [0, 1, 2, 3],
  [0, 2, 4, 6],
  [0, 3, 6, 9]
]
</pre>

  <details>
    <summary>Алгоритм</summary>
    <h4>Создадим функцию __init__(), которая принимает на вход матрицу и строит из нее нужную структуру данных. На выходе префиксная матрица</h4>
    <ol>
      <li>Определяем размер матрицы
        <code>n = len(matrix)</code>
        <code>m = len(matrix[0])</code>
      </li>
      <li>ps это новая структура данных - префиксная матрица. Создаем ее на 1 больше по строкам и на 1 больше по столбцам. Сначала заполняем ее нулями
        <code>ps = [[0 for _ in range(m+1)] for _ in range(n+1)]</code>
      </li>
      <li>Циклом проходимся по входной матрице, чтобы заполнить префиксные суммы в префиксной матрице
        <code>for i in range(1, n+1):</code>
        <code>for j in range(1, m+1):</code>
      </li>
      <li>Найдем сумму элементов исходной матрицы в прямоуголькике заданным верхним левым углом в элементе [0][0] и правым нижним углом в текущем элементе [i][j], но в этой сумме не будет значения текущего элемента matrix[i][j]
        <code>other_sum = ps[i-1][j] + ps[i][j-1] - ps[i-1][j-1]</code>
      </li>
      <li>Тогда значение текущего элемента будет равно найденной сумме плюз значение теущего элемента исходной матрицы
        <code>ps[i][j] = matrix[i-1][j-1] + other_sum</code>
      </li>
    </ol>

    <h4>Напишем функцию sumRegion(), которая принимает два индекса - левый и правый и возвращает сумму элементов между этими двумя индесами, включая элементы в этих индексах</h4>

    <p>Придумаем формулу нахождения суммы между двумя индексами</p>
    <p>Поскольку левый и правый индекс включительно и префиксная матрица имеет индексы на 1 больше чем исходная, то сначала добавим 1 к нижнему правому углу</p>
    <code>row2 += 1</code>
    <code>col2 += 1</code>
    <p>Два прямоугольника не будут входить в искомый прямоугольник. Поэтому от префиксной суммы правого нижнего элемента нужно нужно вычесть префиксные суммы верхнего и левого прямоугольника и прибавить префиксную сумму прямоугольной области которая общая для верхнего и левого прямоугольника</p>
    <code>result = ps[row2][col2] - ps[row1][col2] - ps[row2][col1] + ps[row1][col1]</code>
  </details>

  <details>
    <summary>Код на python</summary>
<pre>
class NumMatrix:
  def __init__(self, matrix: List[List[int]]):
    n = len(matrix)
    m = len(matrix[0])
    ps = [[0 for _ in range(m+1)] for _ in range(n+1)]

    for i in range(1, n+1):
      for j in range(1, m+1):
        other_sum = ps[i-1][j] + ps[i][j-1] - ps[i-1][j-1]
        ps[i][j] = matrix[i-1][j-1] + other_sum

    self.ps = ps

  def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:
    row2 += 1
    col2 += 1

    return self.ps[row2][col2] - self.ps[row1][col2] -
           self.ps[row2][col1] + self.ps[row1][col1]
</pre>
  </details>
</article>


<!-- Задача 6. Сумма блока в матрице -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача 6. Сумма блока в матрице</h3>

  <h4>Leetcode 1314. Matrix Block Sum</h4>

  <p>Дана прямоугольная матрица mat размером m x n и целое число K. Вернуть матрицу answer где каждый элемент answer[i][j] это сумма элементов mat[r][c], отстоящих от данного элемента на расстоянии K вокруг него</p>

  <h4>Пример 1</h4>
  <code>Input: mat = [[1,2,3],[4,5,6],[7,8,9]], k = 1</code>
  <code>Output: [[12,21,16],[27,45,33],[24,39,28]]</code>
<pre>
[
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
]
[
  [1+2+4+5,     2+1+3+4+5+6,       3+2+5+6],
  [4+1+2+5+7+8, 5+1+2+3+4+6+7+8+9, 6+2+3+5+8+9],
  [7+4+5+8,     8+4+5+6+7+9,       9+5+6+8]
]
</pre>
  <h4>Пример 2</h4>
  <code>Input: mat = [[1,2,3],[4,5,6],[7,8,9]], k = 2</code>
  <code>Output: [[45,45,45],[45,45,45],[45,45,45]]</code>

  <h4>Решение</h4>
  <p>Сделаем префиксный массив и с его помощью все аккуратно пересчитвываем</p>
</article>


<!-- Задача 7. Пропущенное число -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача 7. Пропущенное число</h3>

  <h4>Leetcode 268. Missing Number</h4>

  <p>Дан массив целых чисел nums, содержащий n целых чисел в диапазоне [0, n] включительно. Нужно вернуть единственное число из диапазона [0, n] которое отсутствует</p>

  <p>В массиве nums гарантированно отсутствует только одно число из диапазона [0,n], все остальные числа из диапазона встречаются ровно один раз</p>

  <h4>Пример</h4>
  <code>nums = [3, 1, 5, 0, 2] // 4</code>

  <h4>Решение</h4>
  <p>Это задача не алгоритмическая. Это задача математическая. В массиве все числа от 0 до n встречаются только один раз. Одного числа там нет. Найдем сумму всех чисел от 0 до n. Это будет sum1. Найдем сумму всех чисел во входном массиве. Это будет sum2.</p>
  <code>sum1 = 0 + 1 + 2 + 3 + 4 + 5 = 15</code>
  <code>sum2 = 3 + 1 + 5 + 0 + 2 = 11</code>
  <p>Сумма sum2 отличается от суммы sum1 на одно число - которого нет во входном массиве</p>
  <code>result = sum1 - sum2</code>
  <p>Сложность по времени O(N)</p>
  <p>Сложность по памяти O(1)</p>

  <details>
    <summary>Алгоритм</summary>

    <ol>
      <li>Находим сумму чисел он 0 до n. Это можно сделать по формуле суммы чисел в <strong>арифметической прогрессии</strong>
        <code>sum1 = (min + max) * kol / 2</code>
        <p>min = 0 минимальное число</p>
        <p>max = 5 максимальное число</p>
        <p>kol = 6 количество чисел</p>
        <code>sum1 = (0 + 5) * 6 / 2 = 15</code>
        <p>В коде запишем</p>
        <code>const sum1 = (nums.length - 1) * nums.length / 2;</code>
      </li>
      <li>Находим сумму чисел во входном массиве
<pre>
let sum2 = 0;
for (const num of nums) {
  sum2 += num;
}
</pre>
      </li>
      <li>Возвращаем результат
        <code>return sum1 - sum2;</code>
      </li>
    </ol>
  </details>

  <details>
    <summary>Код на javascript</summary>
<pre>
function lessNum(nums) {
  const sum1 = (nums.length - 1) * nums.length / 2;
  let sum2 = 0;
  for (const num of nums) {
    sum2 += num;
  }

  return sum1 - sum2;
}
</pre>
  </details>
</article>


<!-- Задача 8. Повторяющееся число -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача 8. Повторяющееся число</h3>

  <h4>Leetcode 287. Find Duplicate Number</h4>

  <p>Дан массив целых чисел nums, содержащий n+1 целых чисел в диапазоне [1, n] включительно. Нужно вернуть единственное число из диапазона [1, n] которое встречается дважды</p>

  <p>В массиве nums гарантированно присутствует только одно повторяющееся число из диапазона [1,n], все остальные числа из диапазона встречаются ровно один раз</p>

  <p>Нужно решить без изменения входного массива за O(1) по памяти</p>

  <h4>Пример 1</h4>
  <code>nums = [1, 3, 4, 2, 2] // 2</code>

  <h4>Пример 2</h4>
  <code>nums = [3, 1, 3, 4, 2] // 3</code>

  <h4>Решение</h4>
  <p>Это задача не алгоритмическая. Это задача математическая. В массиве все числа от 1 до n встречаются только один раз. Одно число встречается два раза. Найдем сумму всех чисел от 1 до n. Это будет sum1. Найдем сумму всех чисел во входном массиве. Это будет sum2.</p>
  <code>sum1 = 1 + 2 + 3 + 4 = 10</code>
  <code>sum2 = 1 + 3 + 4 + 2 + 2 = 12</code>
  <p>Сумма sum2 отличается от суммы sum1 на одно число - которое встречается два раза</p>
  <code>result = sum2 - sum1</code>
  <p>Сложность по времени O(N)</p>
  <p>Сложность по памяти O(1)</p>

  <details>
    <summary>Код на javascript</summary>
<pre>
function duplNum(nums) {
  const sum1 = (nums.length - 1) * nums.length / 2;
  let sum2 = 0;
  for (const num of nums) {
    sum2 += num;
  }

  return sum2 - sum1;
}
</pre>
  </details>
</article>


<!-- Задача 9. Пропущенное и повторяющееся число -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача 9. Пропущенное и повторяющееся число</h3>

  <p>Дан массив целых чисел nums, содержащий n целых чисел в диапазоне [1, n] включительно. Нужно вернуть единственное число из диапазона [1, n] которое встречается дважды и единственное число которое пропущено</p>

  <p>В массиве nums гарантированно присутствует только одно повторяющееся и одно пропущенное число из диапазона [1,n], все остальные числа из диапазона встречаются ровно один раз</p>

  <p>Нужно решить без изменения входного массива за O(1) по памяти</p>

  <h4>Пример 1</h4>
  <code>nums = [1, 3, 4, 2, 2] // [2, 5]</code>

  <h4>Пример 2</h4>
  <code>nums = [3, 1, 3, 4, 2] // [3, 5]</code>

  <h4>Решение</h4>
  <p>Пусть os это сумма всех элементов от 1 до n</p>
  <code>os = 1+2+3+4+5</code>
  <p>Пусть cs это сумма всех элементов текущего массива</p>
  <code>cs = 1+3+4+2+2</code>
  <p>Пусть x это число которое повторяется дважды</p>
  <p>Пусть y это число которое отсутствует</p>
  <p>Тогда составим уравнение</p>
  <code>os = cs + x - y</code>

  <p>Возведем в квадрат каждое число</p>
  <p>Пусть os2 это сумма квадратов чисел от 1 до n</p>
  <code>os2 = 1<sup>2</sup>+2<sup>2</sup>+3<sup>2</sup>+4<sup>2</sup>+5<sup>2</sup></code>
  <p>Пусть cs2 это сумма квадратов всех элементов текущего массива</p>
  <code>cs2 = 1<sup>2</sup>+3<sup>2</sup>+4<sup>2</sup>+2<sup>2</sup>+2<sup>2</sup></code>
  <p>Тогда составим второе уравнение</p>
  <code>os2 = cs2 + x<sup>2</sup> - y<sup>2</sup></code>
</article>


<!-- Задача 10. Сдвинуть массив -->
<article class="article">
  <div class="anchor" id="task10"></div>
  <h3>Задача 10. Сдвинуть массив</h3>

  <h4>Leetcode 189. Rotate Array</h4>

  <p>Дан массив целых чисел nums и целое неотрицательное число k. Сдвинуть массив на k шагов вправо</p>

  <h4>Пример</h4>
  <code>nums = [1,2,3,4,5,6,7], k = 3</code>
  <code>Output: [5,6,7,1,2,3,4]</code>
  <p>При k=1 и k=2 получится</p>
  <code>Output: [7,1,2,3,4,5,6] // k=1</code>
  <code>Output: [6,7,1,2,3,4,5] // k=2</code>

  <h4>Алгоритм</h4>
  <p>Алгоритм из трех шагов</p>
  <ol>
    <li>Реверс массива
      <code>[7,6,5,4,3,2,1]</code>
    </li>
    <li>Реверс подмассива от 0 до k-1
      <code>[5,6,7,4,3,2,1]</code>
    </li>
    <li>Реверс подмассива от k до n
      <code>[5,6,7,1,2,3,4]</code>
    </li>
  </ol>

  <p>Сложность по времени O(N)</p>
  <p>Сложность по памяти O(1)</p>

  <details>
    <summary>Код на python</summary>
<pre>
fef rotateSubArr(self, nums: List[int], i: int, j: int):
  j -= 1
  while i &lt; j:
    nums[i], nums[j] = nums[j], nums[i]
    i +=1
    j -= 1
  return nums
</pre>
  </details>
</article>


<!-- Задача 11. Монотонный массив -->
<article class="article">
  <div class="anchor" id="task11"></div>
  <h3>Задача 11. Монотонный массив</h3>

  <h4>Leetcode 896. Monotonic Array</h4>

  <p>Массив является монотонным если он или монотонно возрастает или монотонно убывает</p>
  <p>Массив считается монотонно возрастающим если каждый следующий элемент больше или равен предыдущему. Массив считается монотонно убывающим если каждый следующий элемент меньше или равен предыдущему</p>
  <p>Дан массив целых чисел nums. Вернуть true если он монотонный, иначе вернуть false</p>

  <h4>Пример 1</h4>
  <code>nums = [1,2,2,3]</code>
  <code>true</code>

  <h4>Пример 2</h4>
  <code>nums = [6,5,4,4]</code>
  <code>true</code>

  <h4>Алгоритм</h4>
  <p>Заведем две булевы переменные isInc и isDec для определения возрастающего и убывающего массива. Проходимся по массиву и сравниваем по два соседних значения.</p>
  <code>if (nums[i+1] &lt; nums[i]) isInc = false;</code>
  <code>if (nums[i+1] &gt; nums[i]) isDec = false;</code>

  <p>Сложность по времени O(N)</p>
  <p>Сложность по памяти O(1)</p>
</article>


<!-- Задача 12. Самый длинный возрастающий подмассив -->
<article class="article">
  <div class="anchor" id="task12"></div>
  <h3>Задача 12. Самый длинный возрастающий подмассив</h3>

  <h4>Leetcode 674. Longest Continuous Increasing Subsequence</h4>

  <p>Дан неотсортированнй массив целых чисел nums. Вернуть длину самого длинного возрастающего подмассива. Подмассив должен быть строго возрастающим, то есть</p>
  <code>nums[i] &lt; nums[i+1]</code>

  <h4>Пример</h4>
  <code>nums = [1,3,5,4,7]</code>
  <code>3</code>

  <h4>Алгоритм</h4>
  <p>Заведем две переменные len и max для длины текущей и максимальной последовательности.</p>
  <code>len = 0; max = 0;</code>
  <p>Циклом пройдем по массиву начиная со второго элемена. Для того чтобы мы могли каждый элемент сравнивать с предыдущим. И на каждом элементе будем проверять, нужно ли нам добавлять его к текущей последовательности или надо начинать новую последовательность.</p>

  <p>Сложность по времени O(N)</p>
  <p>Сложность по памяти O(1)</p>

  <details>
    <summary>Код на python</summary>
<pre>
class Solution:
  def findLength(self, nums: list[int]) -> int:
    prev = float('-inf')
    len1 = 0
    max1 = 0
    for num in nums:
      if prev &lt; num:
        len1 += 1
      else:
        len1 = 1
      max1 = max(max1, len1)
      prev = num1

    return max1
</pre>
  </details>
</article>

