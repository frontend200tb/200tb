<h1>Два указателя</h1>


<article class="article">
  <p>Конспект из двух видео</p>
  <p>Первое видео от 2023-09-19 <strong>Разбираемся с АЛГОРИТМИЧЕСКИМ собесом</strong></p>
  <p>Второе видео <strong>Два указателя</strong></p>

  <p><a href="https://www.youtube.com/@fatin.maksim/videos">youtube Максим Фатин</a></p>
  <p><a href="https://tskills.ru/algo">https://tskills.ru/algo</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p><a href="#point">Два указателя</a></p>
  <p><a href="#task1">Задача 1. Отсортированный массив в квадрате</a></p>
  <p><a href="#task2">Задача 2. Перемещение нулей</a></p>
  <p><a href="#task3">Задача 3. Палиндром</a></p>
  <p><a href="#task4">Задача 4. Палиндром сложный</a></p>
  <p><a href="#task5">Задача 5. Общие элементы отсортированных массивов</a></p>
  <p><a href="#task6">Задача 6. Сумма двух чисел в сортированном массиве</a></p>
  <p><a href="#task7">Задача 7. Уровень воды</a></p>
  <p><a href="#task8">Задача 8. Разница в один символ</a></p>
</article>


<article class="article">
  <p>Три алгоритмических задачи с реальных собесов</p>
  <p>Первая разогревочная. С собеседования на Senior Android разработчика в Авито. Вторая чуть по сложнее из собеса в Яндекс на Middle позицию. Третья задача самая сложная, самая хитрая, хотя тоже из Яндекса и тоже на Middle позицию</p>
</article>


<!-- Два указателя -->
<article class="article">
  <div class="anchor" id="point"></div>
  <h3>Два указателя</h3>

  <p><strong>Паттерн два указателя</strong> можно разделить на 3 группы</p>
  <ol>
    <li>
      <h4>Паттерн с двух сторон</h4>
      <p>Можно применить к массиву. Заводим две переменные pl и pr для левого и правого указателя. Левый ставим на начало массива, а правый - на конец. Сравниваем элементы массива, на которые указывают указатели. На основе некоторого условия выбираем элемент, например для формирования нового массива. Двигаем левый указатель вправо или правый влево. Указатели двигаем друг к другу пока они не встретятся.</p>
    </li>
    <li>
      <h4>Паттерн каждому по указателю</h4>
      <p>Можно применить к двум массивам. Заводим две переменные p1 и p2 для первого и второго указателя. Первый ставим на начало первого массива, второй - на начало второго. Сравниваем элементы на которые указывают указатели. На основе некоторого условия выбираем элемент, например для формирования нового массива. Двигаем первый или второй указатель вправо к концу массива. Указатель двигается пока не дойдет до конца массива.</p>
    </li>
    <li>
      <h4>Паттерн медленный и быстрый указатели</h4>
      <p>Можно применить к массиву или связному списку. Заведем две переменные ps и pf для медленного и быстрого указателя. Быстрый указатель идет вперед на несколько шагов, пока не найдет подходящий элемент. Медленный идет вперед на один шаг. Выполняется либо сравнение либо перестановка.</p>
    </li>
  </ol>
</article>


<!-- Задача 1. Отсортированный массив в квадрате -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача 1. Отсортированный массив в квадрате</h3>

  <h4>Leetcode 977. Squares of a Sorted Array</h4>

  <p>Дан массив целых чисел nums, отсортированный в неубывающем порядке. Вернуть массив квадратов каждого числа, отсортированный в неубывающем порядке</p>

  <h4>Пример 1</h4>
  <code>Input: nums = [-4,-1,0,3,10]</code>
  <code>Output: [0,1,9,16,100]</code>

  <h4>Пример 2</h4>
  <code>Input: nums = [-7,-3,2,3,11]</code>
  <code>Output: [4,9,9,49,121]</code>

  <h4>Паттерн два указателя с двух сторон</h4>
  <p>Идея решения. При возведении в квадрат отрицательное число становится положительным. Поэтому самым максимальным числом в результате может стать либо первое либо последнее число исходного массива возведенное в квадрат. Поэтому надо сравнить квадраты первого и последнего числа и максимальный поставить в конец результирующео массива. Потом сдвинуть один указатель и опять сравнить два карайних числа.</p>

  <details>
    <summary>Алгоритм</summary>

    <ol>
      <li>Заведем переменную result для результата. Положим в нее пустой массив</li>
        <code>let result = [];</code>
      <li>Заведем две переменные pl и pr для левого и правого указателя. Левый поставим на начало массива, правый - на конец
        <code>let pl = 0, pr = nums.length - 1;</code>
      </li>
      <li>Пройдем циклом пока левый указатель меньше или равен правому
        <code>while (pl &lt;= pr)</code>
      </li>
      <li>Сравним квадраты двух элементов. Если квадрат левого элемент больше, то добавим его в массив result и двигаем левый указатель вправо, иначе записываем квадрат правого элемента и двигаем правый указатель влево</li>
      <li>Получили массив, отсортированный по убыванию. Перевернем массив и вернем результат</li>
    </ol>
    <p>Сложность по времени O(N). Сложность по памяти O(1).</p>
  </details>

  <details>
    <summary>Код на javascript</summary>
<pre>
function sortedSquares(nums) {
  const result = [];
  let pl = 0, pr = nums.length - 1;

  while (pl &lt;= pr) {
    if (Math.abs(nums[pl]) > Math.abs(nums[pr])) {
      result.push(Math.pow(nums[pl], 2));
      pl++;
    } else {
      result.push(Math.pow(nums[pr], 2));
      pr--;
    }
  }
  return result.reverse();
}

console.log(sortedSquares([-4,-1,0,3,10])); // [0,1,9,16,100]
</pre>
  </details>

  <details>
    <summary>Код на python</summary>
<pre>
class Solution:
  def sortedSquares(self, nums: List(int)) -> List(int):
    result = []
    pl = 0
    pr = len(nums) - 1

    while pl &lt;= pr:
      if abs(nums[pl]) > abs(nums[pr]):
        result.append(nums[pl] ** 2)
        pl += 1
      else:
        result.append(nums[pr] ** 2)
        pr -= 1

    return reversed(result)
</pre>
  </details>

  <details>
    <summary>Код на java</summary>
<pre>
class Solution {
  public int[] sortedSquares(int[] nums) {
    int[] result = new int[nums.length];
    int pl = 0;
    int pr = nums.length - 1;
    int index = nums.length - 1;

    while (pl &lt;= pr) {
      if (Math.abs(nums[pl]) > Math.abs(nums[pr])) {
        result[index] = nums[pl] ** 2;
        pl += 1;
      } else {
        result[index] = nums[pr] ** 2;
        pr -= 1;
      }
      index -= 1;
    }

    return result;
  }
}
</pre>
  </details>
</article>


<!-- Задача 2. Перемещение нулей -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача 2. Перемещение нулей</h3>

  <h4>Leetcode 283. Move Zeroes</h4>

  <p>Дан целочисленный массив nums, переместите все нули в его конец, сохранив относительный порядок ненулевых элементов. Сделайте это in-place (на месте), не создавая копию массива</p>

  <h4>Пример 1</h4>
  <code>Input: nums = [0,1,0,3,12]</code>
  <code>Output: [1,3,12,0,0]</code>

  <h4>Пример 2</h4>
  <code>Input: nums = [0]</code>
  <code>Output: [0]</code>

  <h4>Пример 3</h4>
  <code>Input: nums = [2,0,0,9,3,0,1]</code>
  <code>Output: [2,9,3,1,0,0,0]</code>

  <h4>Паттерн два указателя быстрый и медленный</h4>

  <p>Идея решения. Создать быстрый и медленный указатели. Быстрый будет идти первый и искать не нулевой элемент. Медленый будет идти за ним с шагом 1 и указывать куда надо переместить ненулевой элемент. Когда быстрый указатель выходит за пределы массива, то все элементы начиная с медленного указателя должны быть нулями.</p>

  <details>
    <summary>Алгоритм</summary>

    <ol>
      <li>Заведем две переменные ps и pf для медленного и быстрого указателей. Поставим медленный и быстрый указатели на первый элемент массива.
        <code>let ps = 0, pf = 0;</code>
      </li>
      <li>Запустим цикл пока быстрый указатель не дойдет до конца массива
        <code>while (pf &lt; nums.length)</code>
      </li>
      <li>Проверяем условие если быстрый указатель указывает не на ноль, то ставим этот элемент на место медленного указателя и сдвигаем медленный указатель на 1 вправо
<pre>
if(nums[pf] !== 0) {
  nums[ps] = nums[pf];
  ps += 1;
}
</pre>
      </li>
      <li>В любом случае двигаем вправо быстрый указатель
        <code>pf += 1;</code>
      </li>
      <li>Когда быстрый указатель вышел за пределы массива, циклом пройдем по всем элементам массива начиная с медленного указателя и до конца и запишем туда нули
<pre>
while (ps &lt; nums.length) {
  nums[ps] = 0;
  ps += 1;
}
</pre>
      </li>
    </ol>
    <p>Сложность по времени O(N). Сложность по памяти O(1).</p>
  </details>

  <details>
    <summary>Код на javascript</summary>
<pre>
function zeroShift(nums) {
  let ps = 0, pf = 0;

  while (pf &lt; nums.length) {
    if(nums[pf] !== 0) {
      nums[ps] = nums[pf];
      ps += 1;
    }
    pf += 1;
  }

  while (ps &lt; nums.length) {
    nums[ps] = 0;
    ps += 1;
  }
}
</pre>
  </details>

  <details>
    <summary>Код на python</summary>
<pre>
class Solution:
  def moveZeroes(self, nums: List[int]) -> None:
    freeIdx = 0
    for num in nums:
      if num == 0:
        continue
      nums[freeIdx] = num
      freeIdx += 1

    for i in range(freeIdx, len(nums)):
      nums[i] = 0
</pre>
  </details>
</article>


<!-- Задача 3. Палиндром -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача 3. Палиндром</h3>

  <p>Проверить является ли строка палиндромом</p>
  <p>Палиндром - это строка, которая читается слева-направо и справа-налево одинаково</p>

  <p>Пример</p>
  <code>isPalindrome('topot'); // true</code>
  <code>isPalindrome('topoot'); // false</code>

  <h4>Паттерн два указателя с двух сторон</h4>
  <p>Левый указатель ставим на первый элемент строки, правый на последний. Пока правый указатель больше левого выполняем алгоритм. Сравниваем указатели. Если буквы не равны, то это не палиндром. Если буквы равны то двигаем оба указателя</p>

  <details>
    <summary>Алгоритм</summary>
    <ol>
      <li>Заведем две переменные pl и pr для левого и правого указателей. Левый указатель поставим на первую букву строки. Правый указатель поставим на последнюю букву строки.
        <code>let pl = 0, pr = str.length - 1;</code>
      </li>
      <li>Запустим цикл пока левый указатель меньше правого
        <code>while (pl &lt; pr)</code>
      </li>
      <li>Будем сравнивать буквы. Если они не равны, то вернем false
        <code>if (str[pl] != str[pr]) return false;</code>
      </li>
      <li>Если они равны, то сдвинем левый указатель на 1 вправо, правый указатель на 1 влево.
        <code>pl++; pr--;</code>
      </li>
      <li>Когда левый указатель станет равен или больше правого, вернем true</li>
    </ol>
    <p>Сложность по времени O(N) потому что мы один раз проходим по строке</p>
    <p>Сложность по памяти O(1) потому что мы не используем дополнительную развернутую строку</p>
  </details>

  <details>
    <summary>Решение (javascript)</summary>
<pre>function isPalindrome(str) {
  let pl = 0, pr = str.length - 1;
  while (pl &lt; pr) {
    if (str[pl] != str[pr]) {
      return false
    }
    pl++;
    pr--;
  }
  return true;
}</pre>
  </details>

  <details>
    <summary>Решение (python)</summary>
<pre>
def isPalindrome(s: str) -> bool:
  pl = 0, pr = len(s) - 1

  while pl &lt; pr:
    if s[pl] != s[pr]:
      return False
    pl++
    pr--

  return True
</pre>
  </details>
</article>


<!-- Задача 4. Палиндром сложный -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача 4. Палиндром сложный</h3>

  <h4>Leetcode 125. Valid Palindrome</h4>

  <p>Усложним задачу на палиндром. Во входной строке переведем все символы из верхнего регистра в нижний. Удалим все символы, которые не являются буквами или цифрами</p>

  <h4>Пример 1</h4>
  <code>s = "A man, a plan, a canal: Panama"</code>
  <code>Output: true</code>
  <p>"amanaplanacanalpanama" это палиндром</p>

  <h4>Пример 2</h4>
  <code>s = "race a car"</code>
  <code>Output: false</code>
  <p>"raceacar" это не палиндром</p>

  <h4>Пример 3</h4>
  <code>s = " "</code>
  <code>Output: true</code>

  <h4>Пример 4</h4>
  <code>s = "1A,baC AB: a 1"</code>
  <code>Output: true</code>
  <p>"1abacaba1" это палиндром</p>

  <h4>Паттерн два указателя с двух сторон</h4>
  <p>Левый указатель ставим на первый элемент строки, правый на последний. Пока правый указатель больше левого выполняем алгоритм. Если какой-то указатель показывает не на букву, то двигаем его дальше до буквы. Сравниваем указатели. Если буквы не равны, то это не палиндром. Если буквы равны то двигаем оба указателя</p>

  <details>
    <summary>Алгоритм</summary>
    <ol>
      <li>Напишем вспомогательную функцию isLetterDigit() которая проверяет является ли переданный символ буквой или цифрой. </li>
      <li>Заведем две переменные pl и pr для левого и правого указателей. Левый указатель поставим на первую букву строки. Правый указатель поставим на последнюю букву строки.
        <code>let pl = 0, pr = str.length - 1;</code>
      </li>
      <li>Запустим цикл пока левый указатель меньше правого
        <code>while (pl &lt; pr)</code>
      </li>
      <li>Проверяем каждый символ и если это не буква или цифра, то переходим к следующему символу. Таким образом, сначала сдвигаем левый указатель до первой буквы или цифры, потом сдвигаем правый указатель до первой буквы или цифры. </li>
      <li>Сравниваем два символа, переведенные в нижний регистр.Если они не равны, то вернем false
        <code>if (str[pl] != str[pr]) return false;</code>
      </li>
      <li>Если они равны, то сдвинем левый указатель на 1 вправо, правый указатель на 1 влево.
        <code>pl++; pr--;</code>
      </li>
      <li>Когда левый указатель станет равен или больше правого, вернем true</li>
    </ol>
    <p>Сложность по времени O(N) потому что мы один раз проходим по строке</p>
    <p>Сложность по памяти O(1) потому что мы не используем дополнительную развернутую строку</p>
  </details>

  <details>
    <summary>Решение (javascript)</summary>
    <p>Метод строки charCodeAt(0) возвращает код первого символа строки</p>
<pre>
function isPalindrome(str) {
  let l = 0;
  let r = str.length - 1;

  while (l &lt; r) {
    if (!isLetterDigit(str[l])) {
      l++;
      continue;
    }
    if (!isLetterDigit(str[r])) {
      r--;
      continue;
    }
    if (str[l].toLowerCase() != str[r].toLowerCase()) {
      return false
    }
    l++;
    r--;
  }

  return true;
}

function isLetterDigit(a) {
  let b = a.charCodeAt(0);
  if ( b > 47 &&  b &lt; 58 || b > 64 &&
      b &lt; 91 || b > 96 && b &lt; 123) {
    return true;
  } else {
    return false;
  }
}
</pre>
  </details>

  <details>
    <summary>Решение (python)</summary>
    <p>В питоне есть метод isalnum() который проверяет является ли символ цифрой или буквой</p>
<pre>
def isPalindrome(self, s: str) -> bool:
  pl = 0
  pr = len(s) -1

  while pl &lt; pr:
    if not s[pl].isalnum():
      pl += 1
      continue
    if not s[pr].isalnum():
      pr -= 1
      continue
    if s[pl].lower() != s[pr].lower():
      return False
    pl += 1
    pr -= 1

  return True
</pre>
  </details>
</article>


<!-- Задача 5. Общие элементы отсортированных массивов -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача 5. Общие элементы отсортированных массивов</h3>

  <h4>Intersection Of Sorted Arrays (easy)</h4>

  <p>Найти пересечение двух отсортированных массивов</p>
  <p>Для двух отсортированных массивов найти все элементы, которые встречаются в обоих массивах и ответ вернуть в отсортированном массиве.</p>

  <h4>Пример 1</h4>
  <code>nums1 = [1,2,3,3,4,5,6]</code>
  <code>nums2 = [3,3,5]</code>
  <code>Output: [3,3,5]</code>

  <h4>Пример 2</h4>
  <code>nums1 = [1,2,3,3,4,5,6]</code>
  <code>nums2 = [3,5]</code>
  <code>Output: [3,5]</code>

  <h4>Пример 3</h4>
  <code>nums1 = [2,2,5,8,14,19,29,30]</code>
  <code>nums2 = [-3,0,1,2,2,2,8,19]</code>
  <code>Output: [2,2,8,19]</code>

  <h4>Паттерн два указателя каждому по указателю</h4>

  <details>
    <summary>Алгоритм</summary>

    <ol>
      <li>Заведем переменную res для результата. Положим в нее пустой массив
        <code>const res = [];</code>
      </li>
      <li>Заведем две переменные p1 и p2 для указателей. Поставим первый указатель на первый элемент первого массива, второй - на первый элемент второго.
        <code>let p1 = 0, p2 = 0;</code>
      </li>
      <li>Запустим цикл пока один из указателей не дойдет до конца массива
        <code>while (p1 &lt; a.length || p2 &lt; b.length)</code>
      </li>
      <li>Будем сравнивать два элемента nums[p1] и nums[p2].</li>
      <li>Если они равны, то элемент добавляется массив res и двигаем оба указателя вправо.</li>
      <li>Если не равны, то двигаем вправо указатель на меньшее число.</li>
      <li>Когда один из массивов закончился, выходим из цикла и возвращаем массив res</li>
    </ol>
    <p>Сложность по времени O(n+m). Сложность по памяти O(min(n,m)).</p>
  </details>

    <details>
      <summary>Код на javascript</summary>
<pre>
function intersect(a, b) {
  const res = [];
  let p1 = 0, p2 = 0;

  while (p1 &lt; a.length && p2 &lt; b.length) {
    if (a[p1] > b[p2]) {
      p2++;
    } else if (a[p1] &lt; b[p2]) {
      p1++;
    } else {
      res.push(a[p1]);
      p1++;
      p2++;
    }
  }

  return res;
}

let n1 = [2,2,5,8,14,19,29,30];
let n2 = [-3,0,1,2,2,2,8,19];
console.log(intersect(n1, n2)); // [2,2,8,19]
</pre>
  </details>

  <details>
    <summary>Код на python</summary>
<pre>
class Solution:
  def intersect(self, a, b):
    res = []
    p1 = 0;
    p2 = 0;

  while p1 &lt; len(a) and p2 &lt; len(b):
    if a[p1] > b[p2]:
      p2 += 1
    elif a[p1] &lt; b[p2]:
      p1 += 1
    } else {
      res.append(a[p1]);
      p1 += 1
      p2 += 1

  return res
</pre>
  </details>

  <details>
    <summary>Код на java</summary>
<pre>
public class Solution {
  public int[] intersect(int[] a, int[] b) {
  int p1 = 0;
  int p2 = 0;
  List&lt;Integer&gt; res = new ArrayList&lt;&gt;();

  while (p1 &lt; a.length && p2 &lt; b.length) {
    if (a[p1] > b[p2]) {
      p2++;
    } else if (a[p1] &lt; b[p2]) {
      p1++;
    } else {
      res.add(a[p1]);
      p1++;
      p2++;
    }
  }

  return res.stream().mapToInt(i->i).toArray();
  }
}
</pre>
  </details>
</article>


<!-- Задача 6. Сумма двух чисел в сортированном массиве -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача 6. Сумма двух чисел в сортированном массиве</h3>

  <h4>Leetcode 167. Two Sum 2 - Input Array is Sorted (medium)</h4>

  <p>Дан массив целых чисел nums отсортированный в неубывающем порядке. Найти два таких числа в массиве, что в сумме дают заданное число target. Индекс в этой задаче начинается с 1 и заканчивается длиной массива. Вернуть массив таких двух индексов в возрастающем порядке</p>

  <p>Гарантируется что есть ровно одно решение. Нельзя использовать один элемент дважды в ответе</p>

  <h4>Пример 1</h4>
  <code>nums = [2,7,11,15], target = 9</code>
  <code>[1,2]</code>

  <h4>Пример 2</h4>
  <code>nums = [2,3,4], target = 6</code>
  <code>[1,3]</code>

  <h4>Пример 3</h4>
  <code>nums = [-1,0], target = -1</code>
  <code>[1,2]</code>

  <h4>Паттерн два указателя с двух сторон</h4>
  <p>Если массив отсортирован, то решать можно <strong>паттерном два указателя с двух сторон</strong>. Ставятся два указателя на первый и последний элемент.</p>
  <p>Пока правый указатель больше левого будем выполнять цикл</p>
  <p>Если сумма элементов больше target, то сумму нужно уменьшать. Для этого двигаем правый указатель влево.</p>
  <p>Если сумма меньше target, то сумму надо увеличивать. Для этого двигаем левый указатель вправо.</p>
  <p>Сложность по времени O(N) потому что в худшем случае мы посмотрим один раз на каждый элемент. Сложность по памяти O(1)</p>

  <details>
    <summary>Код на python</summary>
<pre>
class Solution:
  def twoSum(self, nums: List[int], target: int) -> List[int]:
    pl = 0
    pr = len(nums) - 1

    while pl &lt; pr
      curr_sum = nums[pl] + nums[pr]
      if curr_sum == target:
        return pl + 1, pr + 1
      elif curr_sum &lt; target:
        pl += 1
      else:
        pr -= 1

    return [-1,-1]
</pre>
  </details>
</article>


<!-- Задача 7. Уровень воды -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача 7. Уровень воды</h3>

  <h4>Leetcode 11. Container With Most Water</h4>

  <p>Дан массив height чисел обозначающих высоту линий. Сколько максимум воды поместится между двумя любыми линиями если уровень воды не может превышать высоту линии</p>
  <p>Из линий получается такой контейнер, в который может поместиться вода. Высота контейнера ограничивается высотой минимальной из двух линий. Ширина контейнера равна расстоянию между двумя линиями.</p>
  <p>Примечание. При измерении между двумя линиями, высоты остальных линий не учитываются</p>

  <h4>Пример 1</h4>
<pre>
  #         #
  #         #   #
  # #       #   #
  # #   #   #   #
  # #   # # #   #
  # #   # # # # #
  # # # # # # # #
#_#_#_#_#_#_#_#_#
1 8 6 2 5 4 8 3 7
0 1 2 3 4 5 6 7 8
</pre>
  <code>height = [1, 8, 6, 2, 5, 4, 8, 3, 7]</code>
  <code>Output: 49</code>

  <p>Здесь максимум воды поместится между линиями height[1] и height[8]. Их высоты равны</p>
  <code>height[1] = 8, height[8] = 7</code>
  <p>Вода, ограниченная двумя линиями, не может подняться выше минимальной из них, поэтому высота воды равна 7</p>
  <p>Ширина воды равна разнице индексов линий. Так как она между 8 и 1, то ширина равна 7.</p>

  <h4>Паттерн два указателя с двух сторон</h4>

  <p>Это brutforce алгоритм, который рассматривает все варианты, не делая полного перебора</p>

  <details>
    <summary>Алгоритм</summary>
    <ol>
      <li>Заведем две переменные pl и pr для левого и правого указателя. Левый поставим на первый элемент массива, правый - на последний.
        <code>let pl = 0, pr = arr.length - 1;</code>
      </li>
      <li>Заведем две переменные max и cur. max для ответа, в которой будем хранить максимальную площадь. cur для текущей площади. Сначала там будет 0
        <code>let max = 0, cur = 0;</code>
      </li>
      <li>Запустим цикл пока левый указатель меньше правого
        <code>while (pl &lt; pr)</code>
      </li>
      <li>Обновляем текущую площадь
        <code>cur = Math.min(h[pl], h[pr]) * (pr - pl);</code>
      </li>
      <li>В переменную max записываем максимум из cur и max
        <code>max = Math.max(max, curr);</code>
      </li>
      <li>Двигаем указатель, который показывает на меньшую высоту. Если высота одинаковая, то двигаем любой.</li>
    </ol>
    <p>Сложность по времени O(N) потому что мы один раз проходим по массиву</p>
    <p>Сложность по памяти O(1) потому что мы используем только две дополнительные переменные, которые не зависят от длины массива</p>
  </details>

  <details>
    <summary>Решение (javascript)</summary>
<pre>
function maxArea(h) {
  let pl = 0, pr = h.length - 1;
  let max = 0, cur = 0;

  while (pl &lt; pr) {
    cur = Math.min(h[pl], h[pr]) * (pr - pl);
    max = Math.max(max, cur);
    if (h[pl] > h[pr]) {
      pr--;
    } else {
      pl++;
    }
  }

  return max;
}
</pre>
  </details>

  <details>
    <summary>Решение (python)</summary>
<pre>
class Solution:
  def maxArea(self, h: List[int]) -> int:
    pl = 0, pr = len(h) - 1
    res = 0, cur = 0

    while pl &lt; pr:
      cur = min(h[pl], h[pr]) * (pr - pl)
      res = max(res, cur)
      if h[pl] &lt; h[pr]:
        pl++
      else:
        pr--

    return res
</pre>
  </details>
</article>


<!-- Задача 8. Разница в один символ -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача 8. Разница в один символ</h3>

  <h4>Leetcode 161. One Edit Distance (premium)</h4>

  <p>Даны две строки s и t. Если между ними разница в один символ, то вернуть true, иначе false. Если можно за одну операцию превратить одну строку в другую. Это может быть одна из трех операций</p>
  <ol>
    <li>Вставить один символ в s чтобы получить t</li>
    <li>Удалить один символ из s чтобы получить t</li>
    <li>Заменить один символ в s на другой чтобы получить t</li>
  </ol>
  <p>Для одинаковых строк всегда возвращаем false</p>

  <h4>Пример 1</h4>
  <code>s = "ab", t = "acb"</code>
  <code>Output: true</code>

  <h4>Пример 2</h4>
  <code>s = "", t = ""</code>
  <code>Output: false</code>

  <h4>Паттерн два указателя каждому по указателю</h4>
  <p>Ставим первый указатель на начало первой строки. Второй - на начало второй. Пока оба указателя не вышли за границу строки делаем цикл. Сравниваем символы - если они равны то двигаем оба указателя вправо на один символ.</p>
  <p>Если символы не равны, то есть только три варианта. Можно сделать либо вставку, либо удаление, либо замену символа.</p>
  <ol>
    <li>
      <p>Если длина строки s на 1 больше длины строки t, то можно сделать только удаление. Первый указатель пропускает один (несовпавший) символ и продолжаем сравнивать символы до конца строк</p>
      <code>s = "aabca", t = "aaca"</code>
    </li>
    <li>
      <p>Если длина строки s на 1 меньше длины строки t, то можно сделать только вставку. Второй указатель пропускает один (несовпавший) символ и продолжаем сравнивать символы до конца строк</p>
      <code>s = "aaca", t = "aabca"</code>
    </li>
    <li>
      <p>Если строки одинаковой длины, то можно сделать только замену. Оба указателя пропускают один (несовпавший) символ и продолжаем сравнивать символы до конца строк</p>
      <code>s = "aaba", t = "aaca"</code>
    </li>
  </ol>
  <p>Если один указатель дошел до конца строки и все символы были равны, то длины строк должны отличаться на 1, чтобы вернуть true</p>
  <code>s = "aaba", t = "aabac"</code>

  <details>
    <summary>Код на python</summary>
<pre>
class Solution:
  def isOneEditDistance(self, s: str, t: str) -> bool:
    if len(t) &gt; len(s)
      # меняем строки местами, чтобы s была больше t
      return self.isOneEditDistance(t, s)

    # не асимптотическая оптимизация
    if len(s) - len(t) &gt; 1:
      return false

    for i in range(0, len(t)):
      if s[i] == t[i]:
        continue
      if len(s) == len(t):
        # операция замены
        return s[i + 1:] == t[i + 1:]
      # операция удаления
      return s[i + 1:] == t[i:]

    # заходим если первые len(t) символов совпали в строках
    # в таком случае если len(s) == len(t) вернем false
    return len(t) + 1 == len(s)
</pre>
  </details>
</article>

