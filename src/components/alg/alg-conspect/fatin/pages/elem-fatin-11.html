<h1>Хеш-таблица</h1>


<article class="article">
  <p>Конспект двух видео от</p>
  <p>Первое видео 2024-08-25 <strong>Хеш-таблица на мемах за 2 часа 30 минут и 9 секунд</strong></p>
  <p>Второе видео <strong>Хеш-таблица</strong></p>

  <p><a href="https://www.youtube.com/@fatin.maksim/videos">youtube Максим Фатин</a></p>
  <p><a href="https://tskills.ru/algo">https://tskills.ru/algo</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p><a href="#about">План на стрим</a></p>
  <p><a href="#hash">Хэш-таблица</a></p>
  <p><a href="#jun">Хеш-таблица Junior</a></p>
  <p><a href="#task1">Задача 1. Топ К часто встречающихся элементов</a></p>
  <p><a href="#mid">Хеш-таблица Middle</a></p>
  <p><a href="#task2">Задача 2. Изоморфные строки</a></p>
  <p><a href="#sen">Хеш-таблица Senior</a></p>
  <p><a href="#task3">Задача 3. Сумма двух чисел</a></p>
  <p><a href="#task4">Задача 4. Правильное судоку</a></p>
  <p><a href="#task5">Задача 5. Симметричная прямая</a></p>
  <p><a href="#task6">Задача 6. LRU кэш</a></p>
  <p><a href="#task7">Задача 7. Префикс общих элементов двух массивов</a></p>
</article>


<!-- План на стрим -->
<article class="article">
  <div class="anchor" id="about"></div>
  <h3>План на стрим</h3>

  <p>Сегодня у нас разносная программа. Сегодня мы обсуждаем хеш-таблицу. Все знают что такое хеш-таблица, но тем не менее заваливают собеседования. Потому что не могут определить эту хеш-таблицу в задачах. Она там скрывается, не просто в том виде в каком мы привыкли ее видеть. И сегодня мы разберем как ее в задаче распознать.</p>

  <ol>
    <li>На сколько важна хеш-таблица на собесах</li>
    <li>Как сейчас большинство учат хеш-таблицу</li>
    <li>RoadMap для эволюции из эникея в сеньера-помидора хеш-таблиц</li>
    <li>Разбор задачек</li>
    <li>Вопросы и ответы</li>
  </ol>
</article>


<!-- Хэш таблица -->
<article class="article">
  <div class="anchor" id="hash"></div>
  <h3>Хэш таблица</h3>

  <p>Хеш-таблица - это вторая по важности тема на собесах, после массивов. Ее спрашивают везде - ТБанк, Яндекс, Авито, Озон. С этой структурой данных нужно уметь работать везде.</p>
  <p>С хеш-таблицей связаны несколько вопросов</p>

  <ol>
    <li>
      <h4>Операции и их сложность</h4>
      <p>Для элемента в хеш-таблице можно провести любую из следующих операций:</p>
      <ol>
        <li>Поиск</li>
        <li>Получение</li>
        <li>Обновление</li>
        <li>Вставка</li>
        <li>Удаление</li>
      </ol>

      <p>Сложность по времени в среднем за O(1), в худшем случае за O(N).</p>
      <p>Сложность O(1) происходит всегда при <strong>поиске</strong>, <strong>получении</strong> или <strong>обновлении</strong>. Если нет коллизии, то еще и при вставке и удалении.</p>
      <p>Сложность O(N) происходит только при <strong>вставке</strong> или <strong>удалении</strong>, если есть коллизия.</p>

    </li>
    <li>
      <h4>Что под капотом</h4>

      <h4>Что может быть ключем хеш-таблицы</h4>
      <p>Ключем хеш-таблицы может быть все что угодно (число, строка и т.д.). Не comparable type не могут быть ключем. В некоторых языках ключем не могут быть mutable type.</p>
      <h4>Что такое хеш-функция</h4>
      <h4>Что такое коллизия</h4>
      <p>Коллизия это одинаковый результат хеширования разных ключей. Если хеш-таблица заранее выделила себе мало памяти и начали появлятся коллизии (когда разные элементы должны быть записаны в одну ячейку памяти), то происходит релокация (перестроение всей таблицы). Этот процесс по времени и по памяти имеет сложность O(N).</p>
      <p>Обратная ситуации коллизии происходит при удалении. Когда в таблице слишком много места и после удаления становится слишком мало элементов, то происходит оптимизация при которой перестраивается вся таблица. Этот процесс по времени и по памяти имеет сложность O(N).</p>
    </li>
    <li>
      <h4>Count sort (сортировка подсчетом)</h4>
      <p>Используют когда маленькое количество уникальных элементов. Которые распологаются в маленьком диапазоне. А общее число входных данных, состоящих из этих элементов, очень велико.</p>
      <p>Если элементы известны заранее, то можно использовать массив. Например, только две цифры 0 и 1, диапазон чисел от 0 до 9, буквы от a до z. Если элементы неизвестны, то используют словарь.</p>
      <p>В массиве для каждого уникального элемента используем свой индекс. В словаре для каждого уникального элемента используем свой ключ. Изначально значение для каждого ключа будет ноль. Потом пройдемся по входным данным и будем прибавлять 1 к значению ключа каждый раз когда встречается данный элемент.</p>
      <p>Если заранее неизвестно какие элементы на входе. Но известно что их ограниченное количество, то надо использовать не массив, а хеш-таблицу.</p>
    </li>
    <li>
      <h4>Анаграмма</h4>
      <p>Задачи на анаграмму решают <strong>паттерном count sort</strong>. Задачи на анаграмму делятся на три вида:</p>
      <ol>
        <li>Группировка анаграмм</li>
        <li>Поиск анаграмм</li>
        <li>Проверка на анаграмму</li>
      </ol>
    </li>
  </ol>

  <h4>Какие есть проблемы с хеш-таблицей</h4>
  <h4>Junior</h4>
  <ol>
    <li>Не могу понять зачем она вообще нужна</li>
    <li>Как понять, что применять именно хеш-таблицу в задаче</li>
    <li>Непонятно с чего начинать и на сколько глубоко нужно знать тему</li>
  </ol>

  <h4>Middle</h4>
  <ol>
    <li>Не знает о паттернах и на собесе долго может решать простую задачу. Пример <strong>паттерна ключ-количество и количество-ключ</strong></li>
    <li>Не может подобрать эффективно индекс для БД, не знает про индексы для эффективной фильтрации</li>
  </ol>

  <h4>Senior</h4>
  <ol>
    <li>Не знает как делать битовые оптимизации при работе с хеш-таблицей и не может глубоко погружаться в детали на собесе</li>
    <li>Знает как решать почти все задачи на собесе, но тратит много времени из-за незнания паттернов</li>
    <li>Забывает решение задачек</li>
  </ol>
</article>


<!-- Хеш-таблица Junior -->
<article class="article">
  <div class="anchor" id="jun"></div>
  <h3>Хеш-таблица Junior</h3>

  <h4>База</h4>
  <ul>
    <li>Какие есть операции и их алгоритмическая сложность (лучший/худший случай)</li>
    <li>Что может быть ключом хеш-таблицы</li>
  </ul>

  <h4>Алго-собес</h4>
  <ul>
    <li>Умеет определять базовые задачи где нужна хеш-таблица</li>
    <li>Умеет применять <strong>паттерн ключ-количество и количество ключ</strong></li>
  </ul>

  <h4>На работе</h4>
  <ul>
    <li>Умеет использовать хеш-таблицу в day-to-day задачах</li>
  </ul>
</article>


<!-- Задача 1. Топ К часто встречающихся элементов -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача 1. Топ К часто встречающихся элементов</h3>

  <p>Дан целочисленный массив nums и целое число k, нужно вернуть k наиболее частых элементов. Можно вернуть ответ в любом порядке</p>

  <h4>Пример</h4>
  <code>Input: nums = [5,3,1,5,5,3,7], k = 2</code>
  <code>Output: [5,3]</code>

  <h4>Паттерн ключ-количество, количество-ключ</h4>
  <p>Два прохода по входному массиву. Первый раз проходим по входному массиву и создаем хеш-таблицу. Ключем будет элемент входного массива, а значением - сколько раз он встречается. Второй раз проходим по входному массиву и создаем массив. Индексом массива будет количество из хеш-таблицы, а значением - массив с элементами из входного массива.</p>

  <h4>Идея решения.</h4>
  <p>Перебирать элементы входного массива и для каждого элемента считать сколько раз он встретился. Записывать в славарь (хеш-таблица). Ключем будет элемент, значением - его количество.</p>
  <p>Когда словарь заполнен всеми значениями, создать массив размером n+1. Перебирать элементы входного массива и для каждого элемента брать его значение из словаря. Индексами нового массива будут значения из словаря (количество одинаковых элементов), а значением для каждого ключа будет массив с ключами из первого словаря (сами элементы). Таким образом, мы сделаем замену "ключа-значение" на "значение-ключ"</p>

  <details>
    <summary>Алгоритм</summary>
    <ol>
      <li>Заведем переменную res для массива с результатом
        <code>const res = [];</code>
      </li>
      <li>Заведем переменную dict для словаря, где ключем будет элемент входного массива, а значением - сколько раз он встречается
        <code>const dict = {};</code>
      </li>
      <li>Заведем переменную count для массива размером n+1, где индекс будут значения из словаря, а значением - массив с элементами
        <code>const count = [];</code>
      </li>
      <li>Пройдем циклом по входному массиву
        <code>for (let num of nums)</code>
      </li>
      <li>Если очередного элемента нет в словаре, то добавим его в словарь как ключ со значением 0. Увеличим значение dict[num] на 1
<pre>
if (!(num in dict)) {
  dict[num] = 0;
}
dict[num]++;
</pre>
      </li>
      <li>Когда цикл закончится, закончится и формирование словаря
      </li>
      <li>
        Пройдем циклом по словарю
        <code>for (let num in dict)</code>
      </li>
      <li>Добавим очередной ключ словаря в массив count с индексом равным значению из словаря
<pre>
let freq = dict[num];
count[freq].push(Number(num));
</pre>
      </li>
      <li>Пройдем по массиву count с конца
        <code>for (let i = count.length - 1; i > 0; i--)</code>
      </li>
      <li>Добавим первые k элементов в массив с результатом</li>
    </ol>
    <p>Сложность по времени O(5n) = O(n). Сложность по памяти O(3n) = O(n)</p>
  </details>

  <details>
    <summary>Код на javascript</summary>
<pre>
function topKFrenquent(nums, k) {
  // первый проход по входному массиву
  // создаем словарь
  const count = {};
  for (const num of nums) {
    count[num] = (count[num] || 0) + 1;
  }

  // второй проход по входному массиву
  // создаем массив массивов
  const frequencyList = Array.from({length: nums.length + 1}, () => []);
  for (const num in count) {
    const frequency = count[num];
    frequencyList[frequency].push(Number(num));
  }

  // проходим по массиву массивов
  // формируем результат
  const result = [];
  for (let i = frequencyList.length - 1; i >= 0; i--) {
    for (const num of frequencyList[i]) {
      if (k &lt;= 0) {
        return result;
      }
      result.push(num);
      k--;
    }
  }

  return result;
}
</pre>
  </details>

  <details>
    <summary>Код на python</summary>
<pre>
class Solution:
  def topKFrequent(self, nums: List[int], k: int) -> List[int]:
    // первый проход по входному массиву
    // создаем словарь
    count = {}
    for num in nums:
      if num not in count:
        count[num] = 0
      count[num] += 1

    // второй проход по входному массиву
    // создаем массив массивов
    frequencyList = [[] for _ in range(len(nums) + 1)]
    for num in count:
      frequency = count[num]
      frequencyList[frequency].append(num)

    // проходим по массиву массивов
    // формируем результат
    result = []
    for numsList in reversed(freauencyList):
      for num in numsList:
        if k&lt;= 0:
          return result
        result.append(num)
        k -= 1

    return result
</pre>
  </details>

  <details>
    <summary>Код на go</summary>
<pre>
func topKFrequent(nums []int, k int) []int {
  // первый проход по входному массиву
  // создаем словарь
  count := make(map[int]int)
  for _, num:= range nums {
    count[num] += 1
  }

  // второй проход по входному массиву
  // создаем массив массивов
  frequencyList := make([][]int, len(nums) + 1)
  for num, frequency := range count {
    frequencyList[frequency] = append(frequencyList[frequency], num)
  }

  // проходим по массиву массивов
  // формируем результат
  result := []int{}
  for i := len(freauencyList) - 1; i >= 0; i-- {
    for _, num := range freauencyList[i] {
      if k&lt;= 0 {
        return result
      }
      result = append(result, num)
      k -= 1
    }
  }

  return result
}
</pre>
  </details>

  <details>
    <summary>Код на java</summary>
<pre>
class Solution {
  public int[] topKFrequent(int[] nums, int k) {
    // первый проход по входному массиву
    // создаем словарь
    Map&lt;Integer, Integer&gt; count = new HashMap&lt;&gt;();
    for (int num : nums) {
      count.put(num, count.getOrDefault(num, 0) + 1);
    }

    // второй проход по входному массиву
    // создаем массив массивов
    List&lt;Integer&gt;[] frequencyList = new List[nums.length + 1];
    for (int i = 0; i &lt; frequencyList.length; i++) {
      frequencyList[i] = new ArrayList&lt;&gt;();
    }

    for (int num : count.keySet()) {
      int frequency = count.get(num);
      frequencyList(frequency).add(num);
    }

    // проходим по массиву массивов
    // формируем результат
    List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
    for (int i = freauencyList.length - 1; i >= 0; i--) {
      List&lt;Integer&gt; numsList = frequencyList[i];
      for (int num : numsList) {
        if k&lt;= 0 {
          return result.stream().mapToInt(v -> v).toArray();
        }
        result.add(num);
        k -= 1;
      }
    }

    return result.stream().mapToInt(v -> v).toArray();
  }
}
</pre>
  </details>

  <details>
    <summary>Код на C++</summary>
<pre>
class Solution {
public:
  vector&lt;int&gt; topKFrequent(vector&lt;int&gt; &nums, int k) {
    // первый проход по входному массиву
    // создаем словарь
    unordered_map&lt;int, int&gt; count;
    for (int num : nums) {
      count[num]++;
    }

    // второй проход по входному массиву
    // создаем массив массивов
    vector&lt;vector&lt;int&gt;&gt; frequencyList(nums.size() + 1);
    for (auto& [num, frequency] : count) {
      frequencyList[frequency].push_back(num);
    }

    // проходим по массиву массивов
    // формируем результат
    vector&lt;int&gt; result;
    for (int i = freauencyList.size - 1; i >= 0; i--) {
      for (int num : freauencyList[i]) {
        if k&lt;= 0 {
          return result;
        }
        result.push_back(num);
        k -= 1;
      }
    }

    return result;
  }
}
</pre>
  </details>
</article>


<!-- Хеш-таблица Middle -->
<article class="article">
  <div class="anchor" id="mid"></div>
  <h3>Хеш-таблица Middle</h3>

  <h4>Алго-собес</h4>
  <ul>
    <li>Умеет группировать темы с хеш-таблицей и решает больший диапазон задач</li>
    <li>Знает про изоморфизм строк</li>
    <li>Может написать LRU cache</li>
  </ul>

  <h4>На работе</h4>
  <ul>
    <li>Знает о практике кеширования и о проблеме инвалидации</li>
    <li>Может подобрать политику инвалидации</li>
    <li>Умеет обосновать выбор хеш-индекса для БД</li>
    <li>Знает о bitmap индексе для фильтров</li>
    <li>Знает понятие <strong>кардинальности значений</strong> и его эффекте на больших данных</li>
  </ul>
  <p>Когда мы ищем товар в базе данных магазина и применяем много различных фильтов. Например, с доставкой, с расширенной гарантией, с защитой от перегрева, по цене, по наличию, со скидкой и т.д. Если в фильтрах есть булевые значения. То bitmap index все эти значения хорошо упакует и поиск будет быстрее</p>
</article>


<!-- Задача 2. Изоморфные строки -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача 2. Изоморфные строки</h3>

  <h4>Leetcode 205. Isomorphic Strings</h4>

  <p>Даны две строки s и t, определите, являются ли они изоморфными</p>

  <p>Две строки s и t изоморфны, если символы в s можно заменить, чтобы получить t</p>
  <p>Все вхождения символа должны быть заменены другим символом с сохранением порядка символов. Никакие два символа не могут отображаться в один и тот же символ, но символ может отображаться сам на себя</p>

  <h4>Пример 1</h4>
  <code>Input: s = "egg", t = "add"</code>
  <code>Output: true</code>

  <h4>Пример 2</h4>
  <code>Input: s = "foo", t = "bar"</code>
  <code>Output: false</code>

  <h4>Пример 3</h4>
  <code>Input: s = "paper", t = "title"</code>
  <code>Output: true</code>

  <h4>Идея решения</h4>
  <p>Для каждой строки заведем свой словарь. И будем запоминать какая буква одной строки соответствует какой букве другой строки. Если какая-то буква не соответствует, то будем возвращать false</p>

  <details>
    <summary>Алгоритм</summary>
    <ol>
      <li>Заведем два словаря dict1 и dict2 для каждой строки
        <code>const dict1 = {}, dict2 = {};</code>
      </li>
      <li>Пройдем циклом по строке
        <code>for (let i = 0; i &lt; s.length; i++)</code>
      </li>
      <li>Заведем две переменные для char1 и char2 для текущего символа каждой строки
        <code>const char1 = s[i]; const char2 = t[i];</code>
      </li>
      <li>Если в первом словаре есть ключ равный символу первой строки, и его значение не равно символу второй строки, вернем false
        <code>if (dict1[char1] && dict1[char1] !== char2) return false;</code>
      </li>
      <li>Если во втором словаре есть ключ равный символу второй строки, и его значение не равно символу первой строки, вернем false
        <code>if (dict2[char2] && dict2[char2] !== char1) return false;</code>
      </li>
      <li>Запишем в первый словарь ключ равный символу первой строки и значение равное символу второй строки
        <code>dict1[char1] = char2;</code>
      </li>
      <li>Запишем во второй словарь ключ равный символу второй строки и значение равное символу первой строки</li>
      <code>dict2[char2] = char1;</code>
      <li>Когда цикл закончится, то вернем true. Все символы совпали значит строки изоморфны</li>
    </ol>
    <p>Сложность по времени O(N). Сложность по памяти O(1)</p>
  </details>

  <details>
    <summary>Код на javascript</summary>
<pre>
function isIsomorhic(s, t) {
  if (s.length !== t.length) {
    return false;
  }
  const dict1 = {}, dict2 = {};

  for (let i = 0; i &lt; s.length; i++) {
    const char1 = s[i];
    const char2 = t[i];

    if (dict1[char1] && dict1[char1] !== char2) {
      return false;
    }
    if (dict2[char2] && dict2[char2] !== char1) {
      return false;
    }
    dict1[char1] = char2;
    dict2[char2] = char1;
  }

  return true;
}
</pre>
  </details>

  <details>
    <summary>Код на python</summary>
<pre>
class Solution:
  def isIsomorhic(self, s: str, t: str) -> bool:
    if len(s) != len(t)
      return False
    dict1, dict2 = {}, {}

    for i in range(len(s)):
      if s[i] in dict1 and dict1[s[i]] !== t[i]:
        return False
      if t[i] in dict2 and dict2[t[i]] !== s[i]:
        return False
      dict1[s[i]] = t[i]
      dict2[t[i]] = s[i]

    return true;
</pre>
  </details>

  <details>
    <summary>Код на go</summary>
<pre>
func isIsomorhic(s string, t string) bool {
  if len(s) != len(t)
    return false
  dict1 := make(map[rune]rune)
  dict2 := make(map[rune]rune)

  for i := 0; i &lt; len(s); i++ {
    char1 := rune(s[i])
    char2 := rune(t[i])

    if val, ok := dict1[char1]; ok && val != char2 {
      return false
    }
    if val, ok := dict2[char2]; ok && val != char1 {
      return false
    }
    dict1[char1] = char2
    dict2[char2] = char1
  }

  return true;
}
</pre>
  </details>

  <details>
    <summary>Код на java</summary>
<pre>
class Solution {
  public boolean isIsomorhic(String s, String t) {
    if (s.length() != t.length()) {
      return false;
    }
    Map&lt;Character, Character&gt; dict1 = new HashMap&lt;&gt;();
    Map&lt;Character, Character&gt; dict2 = new HashMap&lt;&gt;();

    for (int i = 0; i &lt; s.length(); i++) {
      char char1 = s.charAt(i);
      char char2 = t.charAt(i);

      if (dict1.containsKey(char1) && dict1.get(char1) != char2) {
        return false;
      }
      if (dict2.containsKey(char2) && dict2.get(char2) != char1) {
        return false;
      }
      dict1.put(char1, char2);
      dict2.put(char2, char1);
    }

    return true;
  }
}
</pre>
  </details>

  <p>Если в словах используются только малые английские буквы, как в задаче на leetcode, то ее можно решить не словарем а массивом. По таблице ASCII 'a' = 97, 'b' = 98 ... 'z' = 122. Переводим каждый символ строки в число и отнимаем от него 97, чтобы массив начинался с 0 и записываем его в массив. В Питоне ord('a') переводит букву в число, а chr(97) переводит число в букву.</p>
  <p>Если алфавит ограничен, то сложность по памяти будет O(1). В алфавите не более 26 букв не зависимо от длины строки на входе.</p>
</article>


<!-- Хеш-таблица Senior -->
<article class="article">
  <div class="anchor" id="sen"></div>
  <h3>Хеш-таблица Senior</h3>

  <h4>Алго-собес</h4>
  <ul>
    <li>Умеет работать с анаграммами</li>
    <li>Умеет заменять хеш-таблицу на массив</li>
  </ul>

  <h4>На работе</h4>
  <ul>
    <li>Умеет в Key-Value БД (Redis,...)</li>
    <li>Понимает когда вообще в принципе нужно использовать Key-Value БД</li>
  </ul>

  <h4>Финты</h4>
  <ul>
    <li>Может реализовать хеш-таблицу на массивах</li>
    <li>Может реализовать хеш-таблицу на  int-ах</li>
  </ul>
</article>


<!-- Задача 3. Сумма двух чисел -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача 3. Сумма двух чисел</h3>

  <h4>Leetcode 1. Two Sum</h4>

  <p>Дан целочисленный массив nums и целое число target. Вернуть индексы двух чисел, которые в сумме дают target.</p>
  <p>Каждый ввод будет иметь только одно решение и нельзя использовать один элемент дважды</p>
  <p>Вернуть ответ в любом порядке</p>

  <h4>Пример 1</h4>
  <code>nums = [2,7,11,15], target = 9</code>
  <code>Output: [0,1]</code>

  <h4>Пример 2</h4>
  <code>nums = [3,2,4], target = 6</code>
  <code>Output: [1,2]</code>

  <h4>Пример 3</h4>
  <code>nums = [3,3], target = 6</code>
  <code>Output: [0,1]</code>

  <h4>Паттерн хеш-таблица ключ-значение</h4>
  <p>Создадим словарь dict = {}</p>
  <p>Перебираем массив и заполняем словарь. Ключом делаем текущее число, а значением - его индекс в массиве.</p>
  <p>Проверяем если в словаре уже есть ключ равный target - nums[i], значит текущее число в сумме с nums[i] дает target. Их индексы и записываем в ответ</p>
  <p>Сложность по времени O(N)</p>
  <p>Сложность по памяти O(N)</p>

  <details>
    <summary>Код на python</summary>
<pre>
class Solution:
  def twoSum(self, nums: List[int], target: int) -> List[int]:
  # ключ - число, значение - индекс
  dict = {}
  for i, first_num in enumerate(nums):
    # first_num + second_num = target
    second_num = target - first_num
    if second_num in dict:
      return (dict[second_num], i)
    dict[first_num] = i

  return []
</pre>
  </details>
</article>


<!-- Задача 4. Правильное судоку -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача 4. Правильное судоку</h3>

  <h4>Leetcode 36. Valid Sudoku</h4>

  <p>Определить что судоку размером 9х9 валидный. Только заполненные поля нужно валидировать согласно следующим правилам</p>
  <ol>
    <li>Каждый ряд состоит из цифр 1-9 без повторов</li>
    <li>Каждый столбец состоит из цифр 1-9 без повторов</li>
    <li>Каждый из девяти 3х3 квадратов состоит из цифр 1-9 без повторов</li>
  </ol>

  <p>Примечание. Судоку должен быть валидным, но не обязательно иметь решение</p>
  <p>Только изначально заполненные цифры нужно валидировать</p>

  <h4>Пример 1</h4>
<pre>
-----------------------
5 3   |   7   |       |
6     | 1 9 5 |       |
  9 8 |       |   6   |
------|-------|-------|
 8    |   6   |     3 |
 4    | 8   3 |     1 |
 7    |   2   |     6 |
------|-------|-------|
  6   |       | 2 8   |
      | 4 1 9 |     5 |
      |   8   |   7 9 |
-----------------------
</pre>
<pre>
Input: board = [
  ["5", "3", ".", ".", "7", ".", ".", ".", "."],
  ["6", ".", ".", "1", "9", "5", ".", ".", "."],
  [".", "9", "8", ".", ".", ".", ".", "6", "."],
  ["8", ".", ".", ".", "6", ".", ".", ".", "3"],
  ["4", ".", ".", "8", ".", "3", ".", ".", "1"],
  ["7", ".", ".", ".", "2", ".", ".", ".", "6"],
  [".", "6", ".", ".", ".", ".", "2", "8", "."],
  [".", ".", ".", "4", "1", "9", ".", ".", "5"],
  [".", ".", ".", ".", "8", ".", ".", "7", "9"],
]
</pre>
  <code>Output: true</code>

  <h4>Паттерн хеш-таблица</h4>
  <p>Для валидации чисел можно использовать хеш-таблицу. Чтобы отдельно валидировать каждую строку, каждый столбец, каждый квадрат 3х3 нужно 27 хеш-таблиц</p>

  <details>
    <summary>Код на python</summary>
<pre>
class Solution:
  def isValidSudoku(self, board: List[List[str]]) -> bool:
    # тут храним пару (номер строки, значение)
    rows = set()
    # тут храним пару (номер колонки, значение)
    cols = set()
    # тут храним пару (номер блока, значение)
    blocks = set()
    for i in range(len(board)):
      for j in range(len(board[0])):
        val = board[i][j]
        if val == ".":
          continue
        blockIdx = (i // 3) * 3 + (j // 3)
        # если у нас есть такой элемент
        # в строке, столбце, блоке
        # значит невалидное судоку
        if (i, val) in rows or (j, val) in cols or (blockIdx, val) in blocks:
          return False
        rows.add((i, val))
        cols.add((j, val))
        blocks.add((blockIdx, val))

    return True
</pre>
  </details>
</article>


<!-- Задача 5. Симметричная прямая -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача 5. Симметричная прямая</h3>

  <h4>Leetcode 356. Line Reflection (premium)</h4>

  <p>Даны n точек в двумерной системе координат. Можно ли провести вертикальную прямую, параллельную оси y, такую чтобы относительно нее точки были симметричные</p>
  <p>Симметричность означает что все точки разбиты на пары у которых одинаковая координата y и одинаковая удаленность по оси x от искомой вертикальной прямой.</p>

  <h4>Пример 1</h4>
  <code>points = [[1, 1], [-1,1]]</code>
  <code>Output: true</code>

  <h4>Идея решения</h4>
  <p>Если такая линия существует то она может быть только в одном месте - пересекать ось х в точке равноудаленной от самой правой и от самой левой точки</p>
  <code>lineX = (minX + maxX) / 2</code>
  <p>Если перебрать все точки левее lineX, то у каждой точки с координатами (pointLX, pointLY) должна быть пара той же высоты (координата y) правее lineX с координатами (pointRX, pointLY)</p>
  <code>pointRX = 2*lineX - pointLX</code>
  <p>Сложность по времени O(N)</p>
  <p>Сложность по памяти O(N)</p>

  <details>
    <summary>Код на python</summary>
<pre>
class Solution:
  def isReflected(self, points: List[List[int]]) -> bool:
    # находим минимальный и максимальный x
    maxX = max(x for x, y in points)
    minX = min(x for x, y in points)
    # avgX = (maxX + minX) / 2

    # создадим словарь, чтобы проверять наличие точки за O(1)
    points = {(x, y) for x, y in points}
    for x, y in points:
      # maxX + minX - x = 2 * avgX - x
      # чтобы проходило тесты с [[0, 0], [1, 0]]
      # (2 * avgX - x) формула нахождения парной координаты
      # если есть minX = 1, maxX = 5, а текущий x = 2,
      # то 2 * avgX - x = 4
      if (maxX + minX - x, y) not in points:
        return False

    return True
</pre>
  </details>
  <p>Это решение не учитывает случае, когда могут быть точки с одинаковыми коорданатами. Это значит что не укаждой точки есть свободная пара. Чтобы учитывать этот случай, надо использовать не set (только уникальные значения), а map где ключем будет точка, а значением - сколько раз она встречается. Найденные пары точек из map удалять. А в конце посмотреть остались ли точки в map? Если остались, то не укаждой точки нашлась пара.</p>
</article>


<!-- Задача 6. LRU кэш -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача 6. LRU кэш</h3>

  <h4>Leetcode 146. LRU Cache (medium)</h4>

  <p>Построить структуру данных, которая соостветствует LastRecently Used (LRU) cache</p>
  <p>Имплементировать LRUCash class</p>
  <ol>
    <li>LRUCache(int capacity) инициализирует LRU Cache положительным размером capacity</li>
    <li>int get(int key) возвращает значение ключа, если ключ существует, иначе возвращает -1</li>
    <li>void put(int key, int value) обновляет значение ключа если ключ сучествует. Если такого ключа нет, то добавляет пару ключ-значение в кеш. Если номер ключа превышает capacity, то заменяет наименее часто использовавшийся ключ</li>
  </ol>
  <p>Функции get, put должны работать за O(1) в среднем</p>

  <h4>Пример 1</h4>
  <code>["LRUCashe", "put", "put", "get", "put", "get", "put", "get", "get", "get"]</code>
  <code>[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</code>
  <code>Output: [null, null, null, 1, null, -1, 3, 4]</code>
  <h4>Объяснение</h4>
  <code>LRUCache(2) // new LRUCache(2)</code>
  <code>LRUCashe.put(1,1) // cache is {1:1}</code>
  <code>LRUCashe.put(2,2) // cache is {1:1, 2:2}</code>
  <code>LRUCache.get(1) // return 1</code>

  <h4>Политика обновления кеша</h4>
  <p>Например, у нас есть кеш размером 3 элемента. Нам нужно записать в него новый четвертый элемент. Какой мы удалим, чтобы освободить место под новую пару ключ-значение? Выбор элемента для удаления это и есть политика обновления кеша. </p>
  <p>LRU (Last Recently Used) наиболее давно использованный. для его реализации нужен двусторонний связный список и хеш-таблица. Каждый ключ в хеш-таблице будет иметь значение, которое указывает на узел в связном списке и при обращении к ключу узел всегда будет ставиться в конец списка, как последний использованный.</p>
</article>


<!-- Задача 7. Префикс общих элементов двух массивов -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача 7. Префикс общих элементов двух массивов</h3>

  <h4>Leetcode 2657. Find the Prefix Common Array of Two Arrays (medium)</h4>

  <p>Даны два целочисленных массива с пермутацией A и B длиной n. Вернуть префиксный массив. В котором каждый элемент это число одинаковых элементов в префиксах двух массивов A и B.</p>
  <p>Последовательность из n целых чисел называется с пермутацией если состоит из всех целых чисел от 1 до n, встречающихся ровно один раз</p>

  <h4>Пример 1</h4>
  <code>A = [1,3,2,4], B = [3,1,2,4]</code>
  <code>Output: [0,2,3,4]</code>

  <h4>Пример 2</h4>
  <code>A = [2,3,1], B = [3,1,2]</code>
  <code>Output: [0,1,3]</code>
  <p>В решении 1 пересечение множеств находим через пересечение set. Лучший случай O(N), худший случай O(N<sup>2</sup>)</p>

  <details>
    <summary>Решение 1 на python</summary>
<pre>
class Solution:
  def findPrefix(self, A: List[int], B: List[int]) -> List[int]:
    setA = set()
    setB = set()
    result = []

    for i in range(len(A)):
      setA.add(A[i])
      setB.add(B[i])

      commonElementsCount = len(setA.intersection(setB))
      result.append(commonElementCount)

    return result
</pre>
  </details>

  <p>В решении 2 оптимизируем нахождение пересечения. Мы set поменяли на массивы, поэтому худший случай O(N)</p>

  <details>
    <summary>Решение 2 на python</summary>
<pre>
class Solution:
  def findPrefix(self, A: List[int], B: List[int]) -> List[int]:
    setA = [False for _ in range(len(A) + 1)]
    setB = [False for _ in range(len(B) + 1)]
    result = []

    for i in range(len(A)):
      setA[A[i]] = True
      setB[B[i]] = True

      # пересечение множеств
      commonElementsCount = 0
      for j in range(len(setA)):
        commonElementsCount += int(setA[j] and setB[j])

      result.append(commonElementsCount)
    return result
</pre>
  </details>

  <p>В решении 3 оптимизируем нахождение пересечения. Находим пересечение как манипуляции с битами поэтому сложность по времени O(1)</p>

  <details>
    <summary>Решение 3 на python</summary>
<pre>
class Solution:
  def findPrefix(self, A: List[int], B: List[int]) -> List[int]:
    setA = 0
    setB = 0
    result = []

    for i in range(len(A)):
      # тоже самое что и setA[A[i]] = True в прошлом решении
      setA = setA | 1 &lt;&lt; A[i]
      setB = setB | 1 &lt;&lt; B[i]

      # пересечение множеств
      commonElementsCount = 0
      # setA & setB это пересечение множеств
      # если setA = "101100"
      # если setB = "111000"
      # то setA & setB = "101000"
      num = setA & setB

      # в цикле считаем число единиц для числа setA & setB
      # и таким образом понимаем сколько общих чисел
      while num != 0:
        commonElementsCount += num % 2
        num //= 2

      result.append(commonElementsCount)
    return result
</pre>
  </details>
</article>

