<h1>Интернвалы</h1>


<article class="article">
  <p>Конспект видео Интервалы</p>

  <p><a href="https://www.youtube.com/@fatin.maksim/videos">youtube Максим Фатин</a></p>
  <p><a href="https://tskills.ru/algo">https://tskills.ru/algo</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p><a href="#pat">Паттерны решения задач на интервалы</a></p>
  <p><a href="#pat1">Паттерн пересечения интервалов</a></p>
  <p><a href="#pat2">Паттерн объединения интервалов</a></p>
  <p><a href="#task1">Задача 1. Объединить интервалы</a></p>
  <p><a href="#task2">Задача 2. Число комнат для совещаний</a></p>
  <p><a href="#task3">Задача 3. Возможно ли на одной машине совершить данные поездки</a></p>
  <p><a href="#task4">Задача 4. Минимальное число стрел, чтобы лопнуть шары</a></p>
  <p><a href="#task5">Задача 5. Точки и отрезки</a></p>
</article>


<!-- Паттерны решения задач на интервалы -->
<article class="article">
  <div class="anchor" id="pat"></div>
  <h3>Паттерны решения задач на интервалы</h3>


  <p>С интервалами надо уметь делать три вещи</p>
  <ol>
    <li>Проверять что интервалы пересекаются</li>
    <li>Находить пересечение интервалов</li>
    <li>Объединять интервалы</li>
  </ol>

  <p>Для решения задач на интервалы используются три паттерна</p>
  <ol>
    <li>Паттерн пересечения интервалов</li>
    <li>Паттерн объединения интервалов</li>
    <li>Паттерн точек</li>
  </ol>
</article>


<!-- Паттерн пересечения интервалов -->
<article class="article">
  <div class="anchor" id="pat1"></div>
  <h3>Паттерн пересечения интервалов</h3>

  <h4>Как определить что интервалы пересекаются</h4>

  <h4>6 случаев расположения двух интервалов</h4>
<pre>
a1            b1
._____________.
          a2           b2
          .____________.
</pre>

<pre>
a1        b1
._________.
            a2           b2
            .____________.
</pre>

<pre>
a1              b1
._______________.
    a2       b2
    .________.
</pre>
  <code>a1 &lt;= b1, a2 &lt;=b2</code>

  <h4>Условие пересечения интервалов</h4>
  <code>max(a1, a2) &lt;= min(b1, b2)</code>

  <h4>Пересечение интервалов</h4>
  <p>Когда известно, что интервалы пересекаются, можно найти пересечение - все точки, принадлежащие обоим интервалам</p>
  <code>[max(a1, a2) , min(b1, b2)]</code>

<pre>
a1            b1
._____________.
        xxxxxxx
        .____________.
        a2           b2
</pre>
</article>


<!-- Паттерн объединения интервалов -->
<article class="article">
  <div class="anchor" id="pat2"></div>
  <h3>Паттерн объединения интервалов</h3>

  <h4>Как объединять интервалы</h4>

<pre>
a1            b1
._____________.
          a2           b2
          .____________.
</pre>

<pre>
a3                     b3
.______________________.
</pre>
  <code>[min(a1, a2) , max(b1, b2)]</code>

  <p>В задачах границы (точки a1,b1) могут быть включены в интервал, а могут быть нет.</p>
</article>


<!-- Задача 1. Объединить интервалы -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача 1. Объединить интервалы</h3>

  <h4>Leetcode 56. Merge Intervals</h4>

  <p>Дан массив интервалов. Объединить все пересекающиеся интервалы и вернуть массив непересекающихся интервалов</p>
  <p>Каждый инттервал задается его границами, включая сами границы</p>
  <code>intervals[i] = [start, end]</code>

  <h4>Пример 1</h4>
  <code>Input: [ [1,3], [2,6], [8,10], [15,18] ]</code>
  <code>Output: [ [1,6], [8,10], [15,18] ]</code>

  <h4>Пример 2</h4>
  <code>Input: [ [1,4], [4,5] ]</code>
  <code>Output: [ [1,5] ]</code>

  <h4>Алгоритм</h4>
  <ol>
    <li>Отсортировать интервалы. Сортируем в порядке возрастания нижней границы</li>
    <li>Объединить интервалы. Кладем первый интервал в ответ. Далее проходим по массиву интервалов и сравниваем каждый интервал с последним интервалом в ответе. Если они пересекаются, то увеличиваем верхнюю границу последнего интервала в ответе. Если нет, то добавляем в ответ следующий интервал.</li>
  </ol>

  <p>Сложность по времени O(NlogN)</p>
  <p>Сложность по памяти O(N)</p>

  <details>
    <summary>Код на python</summary>
<pre>
class Solution:
  def isOverlap(self, a, b):
    return max(a[0], b[0] &lt;= min(a[1], b[1]))

  def mergeTwo(self, a, b):
    return [a[0], max(a[1], b[1])]

  def merge(self, intervals: List[List[int]]) -> List[List[int]]:
    intervals.sort()
    result = []
    result.append(intervals[0])

    for i in range(1, len(intervals)):
      interval = intervals[i]
      if self.isOverlap(result[-1], interval):
        result[-1] = self.mergeTwo(result[-1], interval)
      else:
        result.append(interval)

    return result
</pre>
  </details>
</article>


<!-- Задача 2. Число комнат для совещаний -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача 2. Число комнат для совещаний</h3>

  <h4>Meeting rooms (medium)</h4>

  <p>Дан двумерный массив целых чисел размером Nx2 содержащий интервалы времени различных встреч.</p>
  <p>A[i][0] время начала i-ой встречи</p>
  <p>A[i][1] время завершения i-ой встречи</p>
  <p>Найти минимальное число комнат чтобы все встречи состоялись</p>
  <p>Примечание. Если встреча заканчивается во время t, а другая встреча начинается во время t, то они могут проходить в одной комнате</p>

  <h4>Пример 1</h4>
<pre>
A = [
  [0, 30],
  [5, 10],
  [15, 20],
]
</pre>
  <code>Output 2</code>

  <h4>Пример 2</h4>
<pre>
A = [
  [1, 18],
  [18, 23],
  [15, 29],
  [4, 15],
  [2, 11],
  [5, 13],
]
</pre>
  <code>Output 4</code>

  <p>Задачу можно решить <strong>методом точек</strong> и <strong>методом интервалов</strong></p>

  <h4>Метод точек</h4>
  <p>В задачах о пересекающихся интервалах можно работать не с интервалами а с точками. Поставим точки на началах и концах интервалов. Пронумеруем точки в порядке возрастания времени их появления. Создадим массив точек. Это двумерный массив. Каждая точка содержит два значения. Первое это время, второе +1 для начала интервала и -1 для конца интервала</p>

  <h4>Пример 3</h4>
<pre>
A = [
  [1, 5],
  [5, 8],
  [7, 9],
]
</pre>
  <code>[[1, +1], [5, -1], [5, +1], [7, +1], [8, -1], [9, -1]</code>

  <h4>Важный момент</h4>
  <p>Реализация массива точек отличается в зависимости от условия. Если <strong>в одно и то же время</strong> по условию происходит сначала освобождение, а потом занятие комнаты, то сначала в массив записывается точка с -1, потом с +1. То есть в массиве мы сначала освобождаем комнату потом занимаем.</p>
  <p>Если <strong>в одно и то же время</strong> по условию сначала занимается комната, потом освобождается, то сначала в массив записывается точка с +1, потом с -1. То есть в массиве мы сначала занимаем новую комнату, потом освобождаем старую.</p>
  <p>Здесь +1 означает что нужна еще одна комната</p>
  <p>-1 означает что освободилась еще одна комната</p>
  <p>Заводим переменную max = 0. В начале, до всех встреч, нет занятых комнат. Число занятых комнат равно нулу</p>
  <p>Проходим по массиву точек и прибавляем к max значение +1 или -1. В конце, когда все встречи закончились, тоже нет занятых комнат. Число max = 0.</p>
  <p>То максимальное значение , которое было в max во время прохождения по массиву, будет ответом</p>
  <p>Сложность по времени O(n * log n). Нужно сортировать массив интервалов</p>
  <p>Сложность по памяти O(N). Метод точек создает дополнительный массив</p>

  <details>
    <summary>Код на python</summary>
<pre>
class Solution:
  def solve(self, A):
    points = []

    for elem in A:
      # точка, +1 - что нужна еще одна комната
      points.append([elem[0], +1])
      # точка, -1 - что одна комната освободилась
      points.append([elem[1], -1])

    # [10, -1] будкт перед [10, +1]
    points.sort()
    max_room = 0
    curr_room = 0

    for point in points
      curr_room += point[1]
      max_room = max(max_room, curr_room)

    return max_room
</pre>
  </details>
</article>


<!-- Задача 3. Возможно ли на одной машине совершить данные поездки -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача 3. Возможно ли на одной машине совершить данные поездки</h3>

  <h4>Leetcode 1094. Car Pooling</h4>

  <p>Дано целое число capacity свободных мест в машине. Машина едет только на восток. То есть она не может развернуться и поехать на запад.</p>
  <p>И дан массив поездок trips. Где каждая поездка содержит массив с числом пассажиров, местом (расстояние в километрах от начала движения машины) где их нужно забрать и местом где их нужно высадить</p>
  <code>trips[i] = [numPassangers, from_i, to_i]</code>
  <p>Вернуть true если на машине можно совершить все данные поездки, иначе вернуть false</p>

  <p>Пример 1</p>
  <code>trips = [ [2,1,5], [3,3,7] ], capacity = 4</code>
  <code>Output: false</code>

  <p>Пример 2</p>
  <code>trips = [ [2,1,5], [3,3,7] ], capacity = 5</code>
  <code>Output: true</code>

  <h4>Метод точек</h4>
  <p>Сортируем массив trips по месту отправления trips[1]</p>
  <p>Создаем массив точек. Где каждая точка это массив с двумя значениями. Первое число км от начала движения, где выходят или заходят люди. Второе число людей. Если люди вышли то число людей со знаком минус, если люди вошли то число людей со знаком плюс.</p>
  <p>Сложность по времени O(NlogN)</p>
  <p>Сложность по памяти O(N)</p>

  <details>
    <summary>Код на python</summary>
<pre>
class Solution:
  def carPooling(self, trips: List[List[int]], capacity: int) -> bool:
  points = []
  for trip in trips
    # координата точки, сколько зашло людей
    points.append([trip[1], trip[0]])
    # координата точки, сколько вышло людей
    points.append([trip[2], -trip[0]])
    points.sort()
    curr = 0
    for point in points
      curr += point[1]
      if curr &gt; capacity:
        return false

    return true
</pre>
  </details>
</article>


<!-- Задача 4. Минимальное число стрел, чтобы лопнуть шары -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача 4. Минимальное число стрел, чтобы лопнуть шары</h3>

  <h4>Leetcode 452. Minimum Number of Arrows to Burst Balloons</h4>

  <p>Есть надувные шары разных размеров. Их положение задано на плоскости XY координатами</p>
  <p>Дан двумерный массив целых чисел, которые представляют собой X координаты надувных шаров. Причем первая координата это начало шара, вторая координата - конец шара. Y координаты не известны.</p>
  <p>Одна выпущенная стрела поражает все шары в той координате, куда она попадет.</p>
  <p>Сколько минимально потребуется стрел, чтобы лопнуть все шары?</p>

  <h4>Пример 1</h4>
  <code>points = [ [10,16], [2,8], [1,6], [7,12] ]</code>
  <code>Output: 2</code>

  <h4>Пример 2</h4>
  <code>points = [ [1,2], [3,4], [5,6], [7,8] ]</code>
  <code>Output: 4</code>

  <h4>Пример 3</h4>
  <code>points = [ [1,2], [2,3], [3,4], [4,5] ]</code>
  <code>Output: 2</code>

  <h4>Метод интервалов</h4>
  <p>Сначала сортируем интервалы по начальной координате. Потом проходимся по массиву интервалов. Зададим две переменные result = 0 для числа стрел, curr = [0, 0] для текущего интервала. Берем первый элемент массива. Увеличиваем результат result++. Обновляем curr = points[0]. Берем следующий элемент массива. Ищем пересечение с curr. Если пересечение есть, то обновляем curr = intersect(curr, points[i]). Если пересечения нет, то берем следующий интервал. Увеличиваем результат result++. Обновляем curr = points[i] и т.д.</p>
  <p>Сложность по времени O(NlogN)</p>
  <p>Сложность по памяти O(1)</p>

  <details>
    <summary>Код на python</summary>
<pre>
class Solution:
  # проверяем пересикаются ли интервалы
  def is_overlap(self, a, b):
    return max(a[0], b[0]) &lt;= min(a[1], b[1])

  # находим пересечение двух пересекающихся интервалов
  def overlap(self, a, b):
    return [max(a[0], b[0]), min(a[1], b[1])]

  def minArrows(self, points: List[List[int]]) -> int:
    points.sort()
    result = 1
    curr = points[0]
    for point in points:
      if self.is_overlap(curr, point):
        curr = self.overlap(curr, point)
        continue
      curr = point
      result += 1

    return result
</pre>
  </details>
</article>


<!-- Задача 5. Точки и отрезки -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача 5. Точки и отрезки</h3>

  <h4>Задача №112542. Точки и отрезки</h4>

  <p>Дано n отрезков на числовой прямой и m точек на этой же прямой. Для каждой из данных точек определите, скольким отрезкам она принадлежит</p>
  <p>Точка x принадлежит отрезку [a, b] если</p>
  <code>min(a, b) &lt; x &lt; max(a, b)</code>
  <p>В ответе должен быть массив, где для каждой точки указано количество отрезков, которым она принадлежит</p>

  <h4>Пример 1</h4>
  <p>Даны три отрезка с координатами [0, 5], [-3, 2], [7, 10] и две точки с координатами 1, 6</p>
  <code>n = [ [0, 5], [-3, 2], [7, 10] ], m = [1, 6]</code>
  <p>Первая точка принадлежит двум отрезкам. Вторая точка не принадлежит ни одному отрезку</p>
  <code>Output: [2, 0]</code>

  <h4>Пример 2</h4>
  <p>Дан один отрезок с координатами [-10, 10] и три точки с координатами -100, 100, 0</p>
  <code>n = [ [-10, 10] ], m = [-100, 100, 0]</code>
  <p>Первая точка не принадлежит ни одному отрезку. Вторая точка не принадлежит ни одному отрезку. Третья точка принадлежит одному отрезку</p>
  <code>Output: [0, 0, 1]</code>

  <h4>Метод точек</h4>
  <p>Из двумерного массива отрезков и из массива координат точек создаем один двумерный массив. В каждом внутреннем массиве первым элементом будет координата (или точки, или начала отрезка, или конца отрезка). Вторым элементом будет 0 если это точка, +1 если это начало отрезка, -1 если это конец отрезка</p>

  <h4>Пример 3</h4>
  <code>n = [ [1, 5], [2, 8], [3, 10] ], m = [3, 6]</code>
  <p>Создаем общий массив points</p>
  <code>points = [ [1, +1], [2, +1], [3, +1], [3, 0], [5, -1], [6, 0], [8, -1], [10, -1] ]</code>
  <p>Создаем две переменные curr = 0 для текущего числа отрезков и result = [] для массива результата</p>
  <p>Сортируем массив points. Проходим по массиву points и смотрим только на второй элемент каждой точки point[1]</p>
  <p>Если point[1] = +1, то обновляем curr++</p>
  <p>Если point[1] = -1, то обновляем curr--</p>
  <p>Если point[1] = 0, то обновляем result. Кладем в него число curr.</p>

  <h4>Важно!</h4>
  <p>Мы получили результат для отсортированных точек. Если на входе точке пришли не отсортированные, то результат надо преобразовать. Чтобы решить эту проблему, будем хранить для точки не два значения [координата, 0], а три значения. Третьим значением будет позиция точки во входных данных [координата, 0, позиция]</p>
  <p>Тогда общий массив points</p>
  <code>points = [ [1, +1], [2, +1], [3, +1], [3, 0, 0], [5, -1], [6, 0, 1], [8, -1], [10, -1] ]</code>
  <p>Теперь если мы встречаем точку в массиве points, то мы должны не просто добавлять curr в конец результата, а должны добавлять curr в нужный индекс массива result</p>
</article>

