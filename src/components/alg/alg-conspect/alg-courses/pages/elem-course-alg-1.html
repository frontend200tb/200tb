<article class="article">
  <h1>Подготовка к алгоритмическому собеседованию</h1>
  <p>Конспект курса</p>
  <a href="https://practicum.yandex.ru/algorithms-interview/">https://practicum.yandex.ru/algorithms-interview/</a>
</article>


<!-- Содержание -->
<article class="article">
  <h3>Содержание</h3>

  <p>
        <a href="#p1">Тема 1. Начало </a>
    <br><a href="#p1.1">1 Вступление</a>
    <br><a href="#p1.2">2 Зачем разработчикам изучать алгоритмы и структуры данных?</a>
  </p>
  <p>
        <a href="#p2.1">Тема 2. Как проходят алгоритмические собеседования</a>
    <br><a href="#p2.1">1 Введение в алгоритмические собеседования</a>
    <br><a href="#p2.2">2 Алгоритмическое собеседование</a>
    <br><a href="#p2.3">3 Критерии успешного собеседования</a>
    <br><a href="#p2.4">4 Навыки решения задач</a>
    <br><a href="#p2.5">5 Почему в крупных компаниях именно такой формат</a>
    <br><a href="#p2.6">6 Как проходить алгоритмические собеседования</a>
    <br><a href="#p2.7">7 Как тестировать свою программу</a>
    <br><a href="#p2.8">8 Конец второй части</a>
  </p>
  <p>
        <a href="#p3.1">Тема 3. Какие алгоритмы нужно знать</a>
    <br><a href="#p3.1">1 Сложность алгоритмов</a>
    <br><a href="#p3.2">2 Два указателя</a>
    <br><a href="#p3.3">3 Бинарный поиск</a>
    <br><a href="#p3.4">4 Рекурсия и поиск с возвратом</a>
    <br><a href="#p3.5">5 Сортировки</a>
    <br><a href="#p3.6">6 Алгоритмы на графах</a>
    <br><a href="#p3.7">7 Деревья</a>
    <br><a href="#p3.8">8 Динамическое программирование</a>
    <br><a href="#p3.9">9 Жадные алгоритмы</a>
    <br><a href="#p3.10">10 Задачи на реализацию</a>
  </p>
  <p>
        <a href="#p4.1">Тема 4. Какие структуры данных нужно знать</a>
    <br><a href="#p4.1">1 Введение</a>
    <br><a href="#p4.2">2 Динамический массив</a>
    <br><a href="#p4.3">3 Стек</a>
    <br><a href="#p4.4">4 Очередь</a>
    <br><a href="#p4.5">5 Связный список</a>
    <br><a href="#p4.6">6 Хеш-таблица</a>
    <br><a href="#p4.7">7 Бинарная куча и приоритетная очередь</a>
    <br><a href="#p4.8">8 Двоичное дерево поиска</a>
  </p>
  <p>
        <a href="#p5.1">Тема 5. Подготовка и практика</a>
    <br><a href="#p5.1">1 Как готовиться к собеседованию</a>
    <br><a href="#p5.2">2 Практика</a>
    <br><a href="#p5.3">3 Как устроен Яндекс Контест</a>
    <br><a href="#p5.4">4 Полезные источники по алгоритмам и структурам данных</a>
    <br><a href="#p5.5">5 Коротко об архитектурных собеседованиях</a>
    <br><a href="#p5.6">6 Коротко о поведенческом интервью</a>
    <br><a href="#p5.7">7 Про английский язык</a>
    <br><a href="#p5.8">8 Как готовить резюме</a>
    <br><a href="#p5.9">9 Перед собеседованием</a>
    <br><a href="#p5.10">10 Завершение</a>
  </p>
</article>


<!-- Тема 1. Начало -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h2>Тема 1. Начало</h2>

  <p>Расскажем, как проходят алгоритмические собеседования и как к ним подготовиться</p>

  <h4>Кому подойдёт курс</h4>
  <ol>
    <li>
      <h4>Опытным разработчикам, которые ещё не изучали алгоритмы</h4>
      Курс позволит не потеряться в обилии фактов. В нём мы собрали то, что нужно изучать для подготовки к собеседованиям.
    </li>
    <li>
      <h4>Разработчикам, которые уже знакомы с алгоритмами и структурами данных</h4>
      Курс поможет оценить уровень вашей подготовки и сфокусироваться на том, что пригодится на интервью.
    </li>
  </ol>

  <h4>Чему вы научитесь</h4>
  <ol>
    <li>Поймёте структуру алгоритмических собеседований, требования и критерии оценки</li>
    <li>Проверите свой уровень знаний алгоритмов и структур данных</li>
    <li>Попрактикуетесь на реальных задачах с собеседований</li>
  </ol>

  <h4>О чём курс</h4>
  <p>Курс сфокусирован на прохождении собеседований, без подробной теории про алгоритмы. Он бесплатный, а уроки сделаны на основе платного курса «Алгоритмы и структуры данных» Яндекс Практикума.</p>

  <h4>Обучаем на реальных примерах</h4>
  <p>Расскажем много неочевидных моментов, которые помогут подготовиться к собеседованию.</p>

  <h4>Личный опыт авторов</h4>
  <p>Авторы курса — опытные разработчики, которые провели и оценили не одну сотню алгоритмических интервью. При этом авторы сами много раз были в роли собеседуемых и получали предложения о работе в компаниях из списка Big Tech.</p>

  <h4>Полезные материалы</h4>
  <p>В курсе поделимся ссылками на лучшие материалы для дальнейшего изучения и самостоятельной подготовки.</p>

  <h4>YandexGPT помогает учиться</h4>
  <p>Когда в теории что-то непонятно, нейросеть объяснит это другими словами. А в конце каждого урока подготовит краткий пересказ о самом главном.</p>

  <h4>Чем полезен бесплатный курс</h4>
  <ol>
    <li>Узнаете, как проводятся собеседования и как их успешно проходить</li>
    <li>Повторите нужную теорию и проверите свои знания</li>
    <li>Потренируетесь решать задачи</li>
  </ol>

  <h3>Программа курса</h3>
  <p>Курс состоит из пяти блоков, в которых есть теория, тесты и практические задачи. По нашим оценкам, для изучения теоретического материала понадобится 10 часов. Время прохождения практики зависит от вашей подготовки.</p>
  <ol>
    <li>
      <h4><a href="#tema-1">Блок 1 Начало</a></h4>
      Краткое введение в курс: расскажем, что такое алгоритмы и структуры данных, зачем их изучать.
      </li>
    <li>
      <h4><a href="#tema-2">Блок 2 Как проходят алгоритмические собеседования</a></h4>
      Поговорим про алгоритмические собеседования: как проводятся и оцениваются. Разберём, почему в крупных компаниях именно такой формат интервью. Поделимся критериями успешного собеседования и расскажем, что нужно делать, чтобы повысить свои шансы на успех.
      <br>Важное при решении задач
      <br>Тестирование своих решений
      <br>Гибкие навыки для собеседований
      <br>Критерии успешного собеседования
      <br>Формат алгоритмических собеседований
    </li>
    <li>
      <h4><a href="#tema-3">Блок 3 Какие алгоритмы нужно знать</a></h4>
      Подробно разберём алгоритмы, которые могут встретиться на собеседовании.
      <br>Графы
      <br>Деревья
      <br>Сортировки
      <br>Бинарный поиск
      <br>Жадные алгоритмы
      <br>Сложность алгоритмов
      <br>Задачи на реализацию
      <br>Метод двух указателей
      <br>Рекурсия и поиск с возвратом
      <br>Динамическое программирование
    </li>
    <li>
      <h4>Блок 4 Какие структуры данных нужно знать</h4>
      Разберём структуры данных, которые пригодятся на собеседованиях. Для каждой из них вспомним идею реализации, основные операции, названия в разных языках программирования и случаи использования.
      <br>Стек
      <br>Очередь
      <br>Хеш-таблица
      <br>Связный список
      <br>Динамический массив
      <br>Двоичное дерево поиска
      <br>Бинарная куча и приоритетная очередь
    </li>
    <li>
      <h4>Блок 5 Подготовка и практика</h4>
      Поделимся рекомендациями по подготовке, задачами на разные темы и источниками для самостоятельной работы. Расскажем, каким должно быть резюме и чего не стоит указывать в нём.
      <br>Практика
      <br>Подготовка резюме
      <br>Полезные источники
    </li>
  </ol>

  <h4>Что ещё важно</h4>
  <ul>
    <li>
      <h4>Примеры с кодом написаны на C++ и Python</h4>
      А практические задачи можно сдавать ещё и на Java или JavaScript. Для прохождения курса пригодятся знания одного из языков.
    </li>
    <li>
      <h4>Нет дедлайнов и команды сопровождения</h4>
      Это курс для самостоятельного изучения. Здесь нет наставников и ревью кода.
    </li>
  </ul>

  <h3>Вопросы и ответы</h3>
  <h4>Подойдёт ли мне этот курс?</h4>
  <p>Курс предназначен для разработчиков, которые планируют проходить алгоритмические собеседования. Материалы будут полезны разработчикам независимо от уровня алгоритмической подготовки.</p>
  <h4>Достаточно ли курса для того, чтобы с нуля разобраться в алгоритмах и структурах данных?</h4>
  <p>К сожалению, нет. Курс помогает самостоятельно подготовиться к алгоритмическому собеседованию. Если хотите подробнее разобраться в теории алгоритмов и структур данных, присмотритесь к платному курсу </p>
  <h4>Какие навыки и знания нужны, чтобы пройти курс?</h4>
  <p>Примеры с кодом написаны на C++ и Python. Сдавать задачи можно также на Java или JavaScript. Студенту нужно знать один из этих четырёх языков.</p>
  <h4>Как и когда я буду учиться?</h4>
  <p>В отличие от других курсов Практикума, здесь нет дедлайнов, сопровождения и ревью кода. Вы можете проходить курс в удобное время и с комфортной вам скоростью.</p>
  <h4>Смогу ли я пройти алгоритмическое собеседование после курса?</h4>
  <p>Знания из курса повысят ваши шансы на успешное прохождение собеседований. В курсе мы сфокусировались на том, что нужно для подготовки к собеседованиям, а также поделились опытом разработчиков и подсветили много неочевидных моментов. А ещё собрали список материалов для самостоятельной подготовки.</p>
  <h4>Получу ли я какой-то документ после курса?</h4>
  <p>После этого курса мы не выдаём диплом. Если вам важно получить документ после учёбы, присмотритесь к другим курсам</p>
</article>


<!-- Тема 1. Урок 1. Вступление -->
<article class="article">
  <div class="anchor" id="p1.1"></div>
  <h3>Тема 1. Урок 1. Вступление</h3>

  <p>В курсе «Подготовка к алгоритмическому собеседованию» мы расскажем о том, как проходят алгоритмические собеседования и как к ним готовиться, чтобы повысить свои шансы на успех. Эти уроки сделаны на основе курса «Алгоритмы и структуры данных» Яндекс Практикума, но здесь полностью бесплатны.</p>
  <p>Авторы курса — опытные разработчики, которые провели и оценили не одну сотню алгоритмических интервью. При этом мы сами много раз были в роли собеседуемых и получали предложения о работе в компаниях из списка Big Tech.</p>

  <h3>Для кого курс</h3>
  <p>Мы сделали этот курс для разработчиков, которые планируют проходить алгоритмические собеседования. Как правило, такие собеседования проводятся в крупных IT-компаниях как на стажировку, так и на штатные позиции. Курс будет полезен разработчикам независимо от уровня алгоритмической подготовки:</p>
  <ul>
    <li>если вы раньше изучали алгоритмы и структуры данных, вы сможете применить их на практике;</li>
    <li>если вы только планируете их изучать, то курс поможет вам сориентироваться и уделять время только тому, что пригодится на собеседованиях.</li>
  </ul>
  <p>Курс состоит из теоретических уроков, тестов и набора практических задач. Прохождение теории и квизов займёт у вас около 10 часов, время решения задач зависит от вашей алгоритмической подготовки. Примерные ориентиры такие:</p>
  <ul>
    <li>Если вы студент-олимпиадник, задачи в курсе потребуют у вас около 10 часов.</li>
    <li>Если вы изучали и помните алгоритмы и структуры данных, но не практиковались много, то вам понадобится 20—40 часов.</li>
    <li>Если вы только планируете изучать алгоритмы и структуры данных, то для того, чтобы выйти на достаточный уровень, приготовьтесь уделить подготовке не менее 150 часов.</li>
  </ul>

  <h3>Что есть в этом курсе</h3>
  <p>В курсе есть три больших раздела.</p>
  <ol>
    <li>Серия теоретических уроков, где подробно рассказывается про алгоритмические собеседования.</li>
    <li>Уроки про требуемые на собеседованиях алгоритмы и структуры данных. В этих уроках коротко описаны основные моменты, которые нужно повторить при подготовке. А ещё в них есть тестовые задания, по которым вы сможете понять, насколько хорошо знаете ту или иную тему.</li>
    <li>Рекомендации по подготовке: задачи на разные темы и источники для самостоятельной работы.</li>
  </ol>

  <p>Мы поделимся своим опытом и осветим много неочевидных моментов. Даже если у вас есть опыт прохождения или проведения интервью, вы можете узнать для себя новую информацию. Кроме того, некоторые уроки, например, про тестирование, могут помочь вам и в повседневной работе.</p>
  <p>Мы приведём список материалов для дальнейшего изучения и самостоятельной подготовки. Этот курс их не заменяет, а дополняет. Мы также надеемся, что курс — хороший старт для подготовки к собеседованиям.</p>

  <h3>Чего нет в этом курсе</h3>
  <ul>
    <li>Курс посвящен только алгоритмическим собеседованиям, другие типы интервью разбираться не будут. Мы приведём ссылки на источники, где про них можно почитать.</li>
    <li>В курсе нет теории алгоритмов и структур данных, но есть ссылки на материалы, где их можно изучить.</li>
    <li>К сожалению, здесь также не будет «лайфхаков», как за вечер подготовиться к интервью. Учитывая это и предыдущие пункты, оставьте для подготовки достаточно времени. В зависимости от компании и вашего текущего уровня владения алгоритмами вам может понадобиться от 2 недель до 6 месяцев.</li>
    <li>В отличие от других курсов Практикума, здесь нет дедлайнов, сопровождения и ревью кода. Вы можете проходить курс с комфортной вам скоростью.</li>
    <li>Наконец, в курсе нет ненужной информации, несмотря на то, что он получился довольно объёмным.</li>
  </ul>

  <h3>В чём отличие курса от других источников</h3>
  <p>В интернете можно найти много информации о собеседованиях. Мы дадим вам ссылки на  лучшие материалы. Зачем тогда мы сделали этот курс?</p>
  <ul>
    <li>Формат обучения. Обычно материалы либо посвящены алгоритмам и структурам данных без фокуса на собеседованиях, либо наоборот, дают полезную информацию про собеседования, но без возможности попрактиковаться и проверить себя. У нас вы узнаете про особенности интервью и сможете проверить свои навыки на практике.</li>
    <li>Большой опыт в алгоритмических собеседованиях позволяет нам дать вам новую информацию.</li>
    <li>Большинство хороших источников написаны на английском языке. Впрочем, если вы готовитесь к трудоустройству в зарубежные компании, это не должно быть проблемой.</li>
    <li>Мы собрали и структурировали информацию об алгоритмических собеседованиях. Это поможет не потеряться в обилии фактов и не тратить время на то, что не нужно.</li>
  </ul>
  <p>Если то, что вы прочитали, вам подходит — добро пожаловать на борт!</p>
  <p>Пожалуйста, расскажите нам немного о вас. В некоторых браузерах форма отображается некорректно, если у вас тоже — заполните анкету по ссылке. </p>
</article>


<!-- Тема 1. Урок 2. Зачем разработчикам изучать алгоритмы и структуры данных? -->
<article class="article">
  <div class="anchor" id="p1.2"></div>
  <h3>Тема 1. Урок 2. Зачем разработчикам изучать алгоритмы и структуры данных?</h3>

  <p>Сначала коротко напомним, о чём вообще речь.</p>

  <h3>Что такое алгоритмы и структуры данных</h3>
  <p>Определить кратчайший путь, выбрать необходимое подмножество объектов, найти наилучшее совпадение строк — каждую из этих задач можно решить несколькими разными способами. Все они дадут одинаковый результат, но один вариант окажется самым простым в реализации, другой — более эффективным, а третий — максимально быстрым, но при этом будет использовать много оперативной памяти.</p>
  <p>Так происходит потому, что в каждом из этих решений будут применяться разные алгоритмы. <strong>Алгоритм</strong> — это инструкция, которая описывает порядок выполнения действий. Алгоритмы описывают то, как мы преобразуем данные, чтобы получить требуемый результат.</p>
  <p>С алгоритмами тесно связаны <strong>структуры данных</strong>, в которых эти данные хранятся. Разные структуры хранят данные по-разному, и из-за этого у них возникают интересные свойства.</p>
  <p>Допустим, мы проводим онлайн-конкурс работ молодых художников. Всего представлено N работ, которые идентифицируются числами от  0 до N-1 включительно. Нужно поддержать 3 типа запроса:</p>
  <ol>
    <li>Лайк работы с идентификатором id.</li>
    <li>Дизлайк работы с идентификатором id.</li>
    <li>Вернуть лучшие K работ. Оценку работы будем считать просто: число лайков минус число дизлайков.</li>
  </ol>
  <p>Для самого простого решения достаточно динамического массива и сортировки.</p>

  <hr>
  <p>❗ Во всём курсе примеры с кодом будут на двух языках: C++ и Python. Чтобы сфокусироваться на сути, а не на реализации, мы не будем указывать импорты стандартных заголовочных файлов или пространств имён. В языке Python мы не будем указывать типы. На собеседованиях вам тоже не нужно будет этого делать.</p>
  <hr>

  <p>Можно предложить альтернативное решение со вспомогательной структурой данных.</p>
  <p>Какой из вариантов стоит выбрать? По сложности кода они приблизительно одинаковые, поэтому выберем более эффективный. Но и по этому критерию однозначного ответа нет.</p>
  <p>Рассмотрим время работы методов:</p>

  <p>Первое решение</p>
  <p>like() O(1)</p>
  <p>dislike() O(1)</p>
  <p>get_best_works() O(NlogN)</p>
  <p>Второе решение</p>
  <p>like() O(logN)</p>
  <p>dislike() O(logN)</p>
  <p>get_best_works() O(K)</p>

  <p>На самом деле get_best_works() первого решения можно соптимизировать, заменив сортировку на алгоритм QuickSelect, который даст время работы O(N), но это в данном случае не так важно, поскольку даже O(N) больше, чемmO(K).</p>
  <p>Второе решение намного быстрее находит лучшие работы. Возможно, его стоит предпочесть, если у нас больше нет никаких дополнительных данных. Но может оказаться, что этот топ нужно пересчитывать раз в сутки, чтобы не было накрутки голосов. При этом поток реакций на работы ожидается большой. Тогда первое решение предпочтительнее, так как оно максимально быстро обрабатывает основной поток запросов, при этом не создавая критически медленных частей.</p>
  <p>В реальной разработке зачастую не всегда существует единственно правильное решение. Поэтому разработчику нужно выяснить требования, оценить сильные и слабые стороны возможных альтернатив и выбрать наилучшую. То же самое на собеседовании. Интервьюер хочет услышать не только правильное решение, но и то, как вы генерируете и сравниваете варианты.</p>

  <hr>
  <p>В англоязычной литературе часто употребляется термин trade-off, который можно отдалённо перевести как «компромисс». От кандидата на интервью ожидается не просто правильное решение, но и то, насколько он может рассматривать и сравнивать альтернативы.</p>
  <hr>

  <h4>Так зачем изучать алгоритмы и структуры данных?</h4>
  <p>Часто звучит вопрос: зачем нужно изучать и спрашивать на собеседованиях алгоритмы, если все они уже реализованы? Мы надеемся, что из предыдущего примера ответ становится немного понятен. Сформулируем по пунктам:</p>
  <ul>
    <li>Разработчик, знающий алгоритмы и структуры данных, может оценивать эффективность кода, в том числе в рабочих задачах и при проведении код-ревью.</li>
    <li>Знание специфики разных структур данных помогает понимать их плюсы, минусы и условия применимости, выбирать правильные решения и поэтому писать более эффективный код.</li>
    <li>
      Алгоритмическая подготовка позволяет разработчику понимать корректность своего кода. То есть убеждаться в том, что решение в принципе даёт правильный ответ. Рассмотрим простейшую задачу — поиск одного элемента в массиве:
      <ul>
        <li>Простой проход по массиву будет оптимальным решением.</li>
        <li>Сложить все элементы в хеш-таблицу и проверить существование элемента будет корректным, но не оптимальным решением — оно требует много дополнительной памяти.</li>
        <li>Бинарный поиск по массиву будет некорректным решением, если массив не отсортирован.</li>
      </ul>
    </li>
  </ul>

  <p>Важно видеть и понимать такие моменты.</p>
  <ul>
    <li>Решение алгоритмических задач улучшает навык написания чистого кода. В них нет противоречивых требований продуктовой логики, некорректных входных данных, «магии», скрытой за фреймворками и вызовами внешних API. Поэтому почти для любой задачи на алгоритмы можно написать аккуратное, понятное, лаконичное и при этом эффективное решение.</li>
    <li>Алгоритмы не устаревают. Они не привязаны к конкретным технологиям или техническому стеку, поэтому полученные знания и навыки будут актуальны до тех пор, пока люди не перестанут писать код.</li>
    <li>От разработчика не ожидается знаний сложных и узкоспециализированных алгоритмов и структур данных. Предполагается, что если он уверенно владеет базой, при столкновении с новой задачей он уже будет знать, что и где искать, и сможет придумать решение.</li>
  </ul>

  <p>Надеемся, вы убедились в том, что разработчикам полезно знать базовые алгоритмы и структуры данных даже для повседневной работы. Кроме знания алгоритмов и структур данных, для успешного интервью необходимы и другие навыки. На самом деле собеседования, которые называют «алгоритмическими», проверяют не только и не столько знания алгоритмов, сколько подход кандидата к решению задач. В следующих уроках мы детально разберёмся, на что и как ещё обращать внимание.</p>
</article>


<!-- Тема 2 Как проходят алгоритмические собеседования -->
<!-- Тема 2. Урок 1. Введение в алгоритмические собеседования -->
<article class="article">
  <div class="anchor" id="p2.1"></div>
  <h2>Тема 2 Как проходят алгоритмические собеседования</h2>
  <h3>Тема 2. Урок 1. Введение в алгоритмические собеседования</h3>

  <p>В ряде крупных IT-компаний кандидаты на собеседованиях пишут код на доске или в онлайн-редакторе без возможности запустить код. В их число входит и Яндекс, и компании, которых собирательно обозначают FAANG.</p>
  <p>Такую проверку проходят все кандидаты, независимо от уровня или опыта работы. Но в обычной жизни код на бумаге пишут редко, поэтому даже опытные разработчики бывают к этому не готовы и не показывают достаточно высокий результат. Тогда хороший кандидат может получить отказ или оффер (от англ. job offer — предложение о работе) на более низкий грейд.</p>

  <hr>
  <p> В большинстве компаний, о которых пойдёт речь, действует система грейдов — уровней специалистов. Если кандидату делают предложение о работе, в нём прописывается и будущий грейд сотрудника. К грейдам жёстко привязаны вилки зарплат и бонусов, поэтому компенсация напрямую зависит от успешности прохождения собеседований.</p>
  <hr>

  <p>Мы подробно расскажем, как это происходит, чтобы вы были готовы. Начнём с общего описания.</p>

  <h3>Общая структура собеседований в крупные IT-компании</h3>
  <ol>
    <li>HR-скрининг</li>
    <li>Онлайн-интервью</li>
    <li>Техническое интервью (Алгоритмы, Архитектура, Поведенческое)</li>
    <li>Оффер в команду. Или оффер и буткемп</li>
  </ol>

  <p>Собеседования в любую из компаний, о которых мы говорили выше, имеют схожую структуру:</p>
  <ol>
    <li>HR-скрининг. Это секция знакомства рекрутера с кандидатом. Как правило, она нужна, чтобы рекрутер оценил опыт кандидата и предложил наиболее релевантные вакансии.</li>
    <li>Онлайн-интервью. Это классическое алгоритмическое собеседование. Оно нужно, чтобы понять, стоит ли рассматривать кандидата дальше. И если да, то на какой примерно грейд.</li>
    <li>Серия технических интервью. Обычно называется onsite — в противоположность онлайну, даже если тоже проводится удалённо. Серия состоит из 4—5 секций длительностью от 45 до 60 минут. Секции идут подряд в течение одного или двух дней. Каждая секция проводится независимо разными интервьюерами. Виды секций: алгоритмы, архитектура, поведенческое собеседование. Точный состав секций нужно узнавать у рекрутера.</li>
  </ol>

  <hr>
  <p>На архитектурном собеседовании нужно спроектировать архитектуру высоконагруженного сервиса. Бывает двух видов: system design interview и product design interview. Например, задача может звучать как «спроектируйте социальную сеть». Кандидату нужно выяснить требования, предложить набор компонентов для решения задачи, а также выбрать для каждого компонента систему хранения данных и описать процесс работы с ней. Помимо того, что решение должно быть рабочим, оно должно горизонтально масштабироваться. На system design interview фокус будет на выборе конкретных компонентов, способности держать нагрузку и отказоустойчивости. Интервью типа product design фокусируется на схеме компонентов и их взаимодействии, API. Обычно такая секция ставится кандидатам уровня Middle или Senior, конкретные правила зависят от компании. Архитектура высоконагруженных сервисов — объёмная тема, которой мы больше не будем касаться в данном курсе.</p>
  <hr>

  <p>Дальше процесс отличается в разных компаниях. В некоторых компаниях кандидату, прошедшему технические интервью, делают оффер. В случае выхода на работу новичок первое время знакомится с компанией и командами через буткемп. После шести недель он выбирает команду, в которой будет работать дальше. В Google кандидат общается с руководителями нанимающих команд, чтобы найти подходящую — оффер делается именно в неё. В Яндексе гибридная схема: кандидат может как общаться с конкретными командами, так и попасть в буткемп — точный сценарий нужно уточнять у рекрутера.</p>

  <hr>
  <p>Буткемп (от англ. bootcamp — тренировочный лагерь) — система, при которой вновь пришедшие в компанию программисты первые несколько недель работают над небольшими задачами разных команд. Это помогает кандидатам и руководителям принять более взвешенное решение о том, в какой команде будет работать новый сотрудник.</p>
  <hr>

  <p>Все собеседования всегда проводятся в формате 1:1, и интервьюеры не видят оценок друг друга. Это сделано для того, чтобы каждый интервьюер ставил оценку полностью независимо от остальных.</p>
  <p>Мы посмотрели, какие типы собеседований бывают, и обозначили их структуру. Теперь сфокусируемся на тех, которые наиболее релевантны нашему курсу, — алгоритмических.</p>
</article>


<!-- Тема 2. Урок 2. Алгоритмическое собеседование -->
<article class="article">
  <div class="anchor" id="p2.2"></div>
  <h3>Тема 2. Урок 2. Алгоритмическое собеседование</h3>

  <p>Одно собеседование, как правило, длится 45 или 60 минут. Рекрутер заранее сообщает кандидату точную длительность. Из этого примерно 5 минут — «накладные расходы»: настройка связи, знакомство, ответы на вопросы кандидата. Так что «содержательная» часть жёстко ограничена 40 или 55 минутами. </p>
  <p>Если кандидат не успевает завершить работу вовремя, интервьюер попросит его остановиться. За это время кандидату нужно решить несколько задач. Обычно две, но иногда одну или три. К сожалению, интервьюер заранее не всегда говорит, какой сложности будут задачи и сколько их нужно решить, чтобы было хорошо.</p>

  <h4>Общая структура работы над задачей</h4>
  <p>Работа над задачей строится так:</p>
  <ol>
    <li>Интервьюер рассказывает условие задачи. В нём может намеренно не хватать важных вводных, потому что ожидается, что кандидат это заметит и спросит.</li>
    <li>Кандидат обсуждает с интервьюером идеи решения. С первого раза решение может быть неправильным или медленным — это нормально, интервьюер на это укажет и предложит ещё подумать. При необходимости даст подсказку.</li>
    <li>Когда кандидат озвучивает правильное решение, можно начинать писать код. Обычно код пишут на доске или в онлайн-редакторе без возможности запуска кода.</li>
    <li>Следующий важный шаг — самостоятельное тестирование и исправление ошибок. Часто кандидаты пропускают нужный тестовый пример или вносят неправильное исправление. О том, как делать правильно и не допускать подобных ошибок, мы расскажем в следующих уроках.</li>
    <li>Кандидат с интервьюером проверяют код на корректность и устраняют ошибки.</li>
    <li>Если ошибок в коде не осталось, интервьюер может задать дополнительный вопрос или перейти к следующей задаче.</li>
  </ol>

  <p>В следующих уроках мы детально рассмотрим этот процесс. Сначала разберёмся, какие задачи задают на интервью.</p>


  <h4>Какие задачи даются на алгоритмических собеседованиях</h4>
  <p>Не каждая задача подойдёт для алгоритмического собеседования. Признаки хороших задач:</p>
  <ul>
    <li>Чтобы придумать решение, в первую очередь нужно знать стандартные алгоритмы и структуры данных. Так, задачи-головоломки («почему люки круглые?») или задачи на математику уже давно не даются. Знание необычных алгоритмов и структур данных не требуется. При этом вполне возможны задачи, где нужно прийти к какой-нибудь несложной, но не самой очевидной идее.</li>
    <li>Задачу можно решить простым и понятным кодом не более чем на 30 (очень редко — больше) строк. То есть при наличии ясной идеи решения в голове код можно написать за несколько минут без подсветки и автодополнения.</li>
    <li>Для решения достаточно знаний языка и его стандартной библиотеки. Если вы придумали, как решить задачу в несколько строк с помощью внешней библиотеки, можете коротко рассказать идею интервьюеру. Так вы покажете широту своего кругозора. Но не тратьте на это больше пары минут — скорее всего, интервьюер попросит вас написать решение без внешней библиотеки.</li>
    <li>Задачи не требуют взаимодействия с внешними ресурсами, такими, как СУБД или сеть. В редких случаях может понадобиться работать со стандартными потоками ввода и вывода.</li>
    <li>В таких задачах не требуется разбора большого количества граничных случаев, также называемых корнер-кейсами.</li>
  </ul>
  <p>Проще говоря, задачи выбираются так, чтобы их можно было придумать и решить за время собеседования, не обладая сверхспособностями.</p>

  <h4>Другие неявные предположения о решении</h4>
  <p>Есть несколько моментов, которые не озвучиваются явно, а как бы подразумеваются. А мы всё-таки расскажем.</p>
  <ol>
    <li>Предполагается, что коду кандидата поступают на вход корректные данные. Например, по условию задачи нужно написать функцию, которая принимает на вход массив целых чисел. Это значит, что:
      <ul>
        <li>нужно считать, что придёт именно массив целых чисел, а не писать обобщённый код;</li>
        <li>не надо проверять, не пришёл ли null вместо массива;</li>
        <li>массив вполне может быть пустым — это не противоречит условию.</li>
      </ul>
    </li>
    <li>Какими-то функциями стандартной библиотеки пользоваться можно и даже нужно. Например, если для решения требуется отсортировать данные, скорее всего, нужно использовать сортировку из стандартной библиотеки, а не писать свою. Из этого можно сделать два вывода:
      <ul>
        <li>основные функции стандартной библиотеки знать необходимо,</li>
        <li>если не знаете, можно ли использовать тот или иной инструмент, — спрашивайте у интервьюера.</li>
      </ul>
    </li>
    <li>Если явно не сказано обратное, предполагается, что ваш код будет запускаться в одном потоке.</li>
    <li>Если в задаче требуется работать со строками, то обычно можно считать, что алфавит ограничен ASCII-символами, то есть не нужно разбираться с кодировками.</li>
  </ol>
  <p>В случае сомнений всегда спрашивайте у интервьюера.</p>
</article>


<!-- Тема 2. Урок 3. Критерии успешного собеседования -->
<article class="article">
  <div class="anchor" id="p2.3"></div>
  <h3>Тема 2. Урок 3. Критерии успешного собеседования</h3>

  <p>В прошлом уроке вы познакомились со структурой алгоритмических собеседований. Напомним, что в них за ограниченное время нужно решить некоторое количество задач: обычно две, реже одну или три.</p>
  <p>Решить задачу — значит без использования внешних источников за определённое время обсудить и написать на реальном языке программирования достаточно производительное решение без логических ошибок, при этом не имея возможности запускать код. Это — главное.</p>

  <hr>
  <p>Часто про алгоритмические интервью говорят: «самое важное — как кандидат думает». Это, безусловно, важно. Но всё-таки основной критерий успеха — правильный код.</p>
  <hr>

  <p>Давайте теперь разберёмся, что это значит.</p>
  <ul>
    <li>«Без использования внешних источников». Во время собеседования нельзя пользоваться документацией или искать решение в интернете. Это лишит собеседование смысла, поскольку решение задач с собеседований найти легко. С реальными задачами так может не получиться, особенно с учётом того, что в крупных компаниях часто используют собственные технологии.</li>
    <li>«За определённое время». К сожалению, заранее неизвестно, сколько времени нужно на решение задачи. Можно прикинуть так: представьте, что вам дали задачу, которую вы решали неделю назад и хорошо помните. Вы спокойно рассказываете алгоритм, затем пишете код и быстро проверяете. Неформально назовём это идеальным временем решения задачи. Прибавьте к нему 7—10 минут, и полу́чите время, которое ожидает интервьюер. У вас есть запас на то, чтобы совершить несколько небольших ошибок при обдумывании решения и при написании кода.</li>
    <li>«Обсудить и написать». Коммуникация с интервьюером важна. Прежде всего потому, что она поможет быстрее найти ошибку или убедиться, что вы на правильном пути. Кроме того, в реальной разработке проекты очень редко делаются в одиночку. Важно оценить, насколько кандидату и интервьюеру будет комфортно работать в одной команде.</li>
    <li>«На реальном языке программирования». Скорее всего, можно совсем на любом известном, псевдокод не подойдёт. На собеседовании пишите код на том языке, который вы знаете лучше всего, чтобы не запутаться в объявлении функций или стандартных структур данных. Не предполагается, что вы помните всю стандартную библиотеку наизусть, но базовые вещи кандидат должен делать уверенно.</li>
    <li>«Достаточно производительное». Когда вы самостоятельно тренируетесь решать задачи, вы видите ограничения на входные данные. Возможно, что на собеседовании у вас их не будет. Придётся самостоятельно разобраться, какое решение будет достаточно быстрым, и проверить своё предположение у интервьюера. Не факт, что от вас ожидают именно оптимального решения. Например, в некоторых задачах допускается решение как за O(n), так и за O(nlogn). Но обязательно сверьтесь с собеседующим.</li>
    <li>«Без логических ошибок» означает, что ваш код корректно работает на допустимых входных данных: правильный ответ выдаётся за нужное время, ошибок времени выполнения не возникает. Это очень важный пункт. «Примерно работающее» решение принято не будет! При этом несущественные опечатки и ошибки компиляции никак не учитываются при оценке. Формальные критерии определить сложно, поэтому приведём несколько примеров.</li>
    <li>«Не имея возможности запускать код». Решение пишется на доске или в онлайн-редакторе, который не позволяет запускать код. Так проверяют, насколько хорошо кандидат понимает работу своего кода. Копировать код и запускать его в других IDE нельзя.</li>
  </ul>

  <p>Не считаются ошибками:</p>
  <ul>
    <li>Опечатка в названии: pint вместо print.</li>
    <li>Несбалансированная скобочная последовательность: d = ((a + b) + c.</li>
    <li>Перепутанный порядок аргументов: vec.assign(0, n) вместо vec.assign(n, 0).</li>
    <li>Отсутствие импортов или указания пространства имён.</li>
  </ul>

  <p>Список того, что считается ошибкой, намного больше. Мы не сможем перечислить все, но приведём несколько самых незаметных примеров:</p>
  <ul>
    <li>Существенная опечатка в имени, которая искажает смысл. В общем случае не рекомендуется использовать однобуквенные имена переменных или имена, отличающиеся одним символом. Исключение: устоявшиеся имена типа i, j, k в коротких циклах.</li>
    <li>Ошибка в индексах: arr[i + 2] вместо arr[i + 1]. Сюда же относятся ситуации, когда происходит выход за пределы массива и программа завершается с ошибкой.</li>
    <li>Иногда неточность при работе с индексами может привести к тому, что программа на некоторых тестах будет уходить в бесконечный цикл.</li>
    <li>Ошибка в знаке: i = i + 1 вместо i = i - 1.</li>
    <li>Вызов метода с семантикой или асимптотикой, отличной от ожидаемой.</li>
    <li>Неправильный тип или операция с числовой переменной.</li>
  </ul>
  <p>Абсолютно все разработчики допускают ошибки. Поэтому нормально, если с первого раза придумать быстрое решение не получится или в первой версии кода будут ошибки. Скорее всего, ни одна из них не фатальная. Важно сохранять спокойствие и реагировать на подсказки интервьюера.</p>

  <h3>Требования к качеству кода</h3>
  <p>Алгоритмическое интервью проходит в режиме сильно ограниченного времени, поэтому никто не ожидает от кандидата кода продакшен-качества. Тем не менее есть несколько важных моментов.</p>
  <ol>
    <li>Старайтесь, чтобы логика кода была максимально прямолинейной. По-простому: собеседующий, который видит уже десятое решение этой задачи, может легко понять, правильное оно или нет. «Запахи» плохого кода:
      <ul>
        <li>Чрезмерно высокая вложенность.</li>
        <li>Много if, особенно вложенных, особенно внутри циклов: проследить логику такого кода практически невозможно.</li>
        <li>Неясно, что является состоянием и как оно изменяется. Возможно, сейчас это не до конца понятно. Ничего страшного, объяснение будет позже.</li>
      </ul>
    </li>
    <li>Если используете идиомы языка, используйте их правильно. Когда не полностью уверены в результате, пишите более прямолинейный код. В нём проще избежать ошибок.</li>
    <li>Если в языке программирования есть стандарт по стилю кода — как PEP 8 в Python, — придерживайтесь его. Если нет, стиль кода должен быть адекватным и консистентным. Как и в продакшене, нехорошо мешать имена переменных в camelCase и underscore_notation, хотя, скорее всего, это не станет поводом для отказа.</li>
    <li>Давайте функциям и переменным короткие и осмысленные имена. Слишком длинные имена скрадут у вас много времени.</li>
    <li>Старайтесь избегать copy-paste. Дублировать похожий код не сто́ит. Но и обобщать не сильно похожие куски не следует.</li>
  </ol>
  <p>Главное, чтобы ваш код можно было понять и легко убедиться в его корректности. В конечном счёте это правило работает не только на собеседовании, но и в реальной разработке.</p>

  <hr>
  <p>Если вы понимаете, что всё делаете быстро, и точно знаете, как улучшить свой код, скажите об этом интервьюеру. Возможно, у него больше нет для вас задач и вы сможете заняться рефакторингом. Если это пройдёт успешно, вы наверняка получите более хороший отзыв от собеседующего.</p>
  <hr>

  <h4>Немного о работе интервьюеров</h4>
  <p>Давайте заглянем по другую сторону собеседования. Вы узнаете, как думают интервьюеры и на что они обращают внимание. Это поможет вам:</p>
  <ul>
    <li>лучше понимать, как с ними взаимодействовать,</li>
    <li>на что обращать внимание на интервью,</li>
    <li>что делать можно и нужно,</li>
    <li>чего делать не следует.</li>
  </ul>
  <p>Интервьюер сам когда-то проходил собеседование как кандидат. Возможно, не один раз. Поэтому он помнит, насколько это сложно и волнительно. Хороший интервьюер хочет оценить умение писать код, а не стрессоустойчивость, поэтому будет стараться создать комфортную и доброжелательную атмосферу.</p>
  <p>Проводить интервью — ответственная и напряжённая работа. Интервьюер активно взаимодействует с кандидатом и в контексте собеседования делает несколько вещей.</p>

  <ol>
    <li>Рассказывает условия задач и отвечает на вопросы кандидата.</li>
    <li>Помогает найти хорошее решение. Как раз на этом этапе нормально, если вы сразу не можете придумать оптимальное решение и рассуждаете вместе с интервьюером. Он должен понимать ход ваших мыслей и задавать наводящие вопросы так, чтобы, с одной стороны, помочь, а с другой — не раскрыть решение с первой же подсказки.</li>
    <li>Во время всего собеседования интервьюер пишет текстовый лог общения с кандидатом. Это нужно для того, чтобы нанимающий менеджер (человек, который в итоге принимает решение о найме на конкретную позицию) в случае сомнений мог посмотреть не только итоговый вердикт, но и ход собеседования.</li>
    <li>Пока кандидат пишет код, интервьюер читает его и разбирается, соответствует ли код описанному алгоритму, есть ли там логические ошибки. Если ошибки есть — как они себя проявляют? На каких тестах решение будет ломаться? Когда код написан, интервьюер уже знает, на что обратить внимание кандидата.</li>
    <li>Аккуратно указывает кандидату на ошибки. Подсказки при этом начинаются с наименее конкретных, чтобы кандидат смог найти проблему с минимумом информации от интервьюера. Правки интервьюер тщательно проверяет, потому что в них тоже могут появиться новые ошибки.</li>
    <li>Наконец, когда интервью подошло к концу и все артефакты собраны, интервьюер пересматривает свои заметки, выставляет оценку и сохраняет всё вместе во внутреннюю систему.</li>
  </ol>
  <p>У каждого собеседующего есть любимые задачи. Он наверняка знает все возможные решения и подводные камни и сможет подсказать кандидату, если тот идёт к неправильному или слишком сложному решению.</p>
</article>


<!-- Тема 2. Урок 4. Навыки решения задач на собеседовании и в работе — есть ли общее? -->
<article class="article">
  <div class="anchor" id="p2.4"></div>
  <h3>Тема 2. Урок 4. Навыки решения задач на собеседовании и в работе — есть ли общее?</h3>

  <p>Подведём небольшой итог и выделим общие моменты, которые важны как для решения задач, так и для реальной работы в IT.</p>

  <ol>
    <li>Гибкие навыки (англ. soft skills).
      <ul>
        <li>Уточняет ли кандидат параметры задачи? В реальности редко встречаются команды, где в разработку передаётся идеальное, подробно расписанное задание. Как правило, его требуется уточнять с заказчиком или руководителем.</li>
        <li>Как кандидат взаимодействует с интервьюером, будет ли им комфортно вместе работать?</li>
        <li>Как кандидат реагирует на сложности в процессе: остаётся собранным или начинает паниковать? Это может быть критично, если сломался продакшен, и каждая минута простоя может стоить $222K.</li>
      </ul>
    </li>
    <li>Насколько ясно кандидат думает и выражает свои мысли.
      <ul>
        <li>Написан ли понятный код?</li>
        <li>Чётко ли выделены сущности и обозначены инварианты?</li>
        <li>Сколько дополнительных условий в коде проверяется? Это необходимые проверки или «костыли», подпирающие неудачные места в коде?</li>
        Проще говоря: если у кандидата решение в 20 строчек нечитаемое и непонятное, вряд ли ему можно доверять кодовую базу из сотен тысяч строк.
      </ul>
    </li>
    <li>Насколько кандидат умеет оценивать алгоритмическую и пространственную сложность кода. На очень больших объёмах данных, обрабатываемых в FAANG, даже небольшая разница в асимптотике может разделять рабочее решение и решение, которое не отработает за несколько лет.</li>
    <li>Насколько кандидат владеет языком программирования, который он знает лучше всего. На алгоритмических интервью требуются только базовые знания: типы переменных, функции, стандартные контейнеры. С ними регулярно сталкивается любой разработчик, независимо от используемого в проекте технического стека. Если даже простейшие вещи вызывают сложности — у разработчика нет ни опыта, ни теоретических знаний, и он будет неэффективен в работе.</li>
    <li>Умеет ли кандидат читать код. Если ему сложно прочесть 20 строк, написанных 5 минут назад, вряд ли такой кандидат сможет эффективно разбираться с чужим или даже своим старым кодом.</li>
    <li>Насколько кандидат умеет тестировать свой код. Если разработчик хотя бы базово тестирует код перед тем, как отдать его в QA, это ускорит выкладку кода в продакшен. Кроме того, одна пара глаз хорошо, а две — лучше. Разработчик знает особенности реализации и может подумать о таких тестах, которые могут не прийти в голову тестировщику.</li>
    <li>Наконец, алгоритмическое собеседование позволяет показать, насколько кандидат способен разобраться в причине бага и исправить код. Хорошо, когда исправлена причина. Но бывает и так, что вместо этого ставится дополнительная проверка, а по сути «заплатка». Она приводит к запутанному коду и не покрывает все ломающиеся случаи.</li>
  </ol>

  <hr>
  <p>В промышленной разработке важно именно понимать реальную и допустимые асимптотики участков кода. Необязательно оптимизировать места, где нагрузки маленькие. Если допустимое решение намного проще, лучше использовать именно его, ведь оно проще поддерживается.</p>
  <hr>

  <p>Как видно, алгоритмические собеседования позволяют проверить множество навыков кандидата.</p>
</article>


<!-- Тема 2. Урок 5. Почему в крупных компаниях именно такой формат -->
<article class="article">
  <div class="anchor" id="p2.5"></div>
  <h3>Тема 2. Урок 5. Почему в крупных компаниях именно такой формат</h3>

  <p>Как мы уже говорили, алгоритмические собеседования помогают оценить большое количество навыков кандидата. Другое преимущество в том, что для этого вида собеседований выработаны стандартные критерии оценки, то есть результат оценивается объективно. Кроме того, само собеседование занимает меньше времени, чем сложное тестовое задание.</p>
  <p>При этом у такого формата есть и недостатки:</p>
  <ol>
    <li>Не проверяется, насколько кандидат может работать с большой кодовой базой. Умеет ли писать расширяемый тестируемый код с выделением правильных абстракций.</li>
    <li>Не проверяется умение пользоваться шаблонами проектирования и популярными инструментами: утилитами, библиотеками, фреймворками.</li>
    <li>К алгоритмическим собеседованиям нужно готовиться, поскольку это редко встречается в повседневной работе разработчика.</li>
    <li>Иногда компании ими злоупотребляют. Пара алгоритмических собеседований даёт нужный сигнал, этого должно быть достаточно. Важно проверить и другие навыки кандидата.</li>
  </ol>

  <p>Почему крупные компании ограничиваются алгоритмическими, архитектурными и поведенческими собеседованиями? Другие способы оценки навыков не всегда подходят.</p>
  <ol>
    <li>Тестовое задание — популярный способ оценить уровень кандидата в IT-компаниях. Но есть недостаток: кандидат может выполнить задание несамостоятельно или найти ответ в интернете.</li>
    <li>Публичный репозиторий с проектами, возможно, может дать лучшее представление о коде кандидата. К сожалению, портфолио легко «накрутить» — создать репозиторий с некоторым сложным и потенциально чужим кодом.</li>
  </ol>

  <p>Некоторые популярные форматы на самом деле есть в цикле интервью.</p>
  <ol>
    <li>Про опыт кандидата обычно говорят во время поведенческого интервью. Это позволяет понять уровень кандидата и задач, с которыми он сталкивался. При этом его одного недостаточно — нужно не только послушать кандидата, но и почитать его код.</li>
    <li>Беседа про детали конкретной технологии не всегда имеет смысл для крупных компаний, где часто используют собственные решения. А понимание фундаментальных принципов работы веб-сервисов проверяется во время архитектурного собеседования.</li>
  </ol>
  <p>Мы рассказали, что проверяют алгоритмические собеседования и почему их проводят в крупных IT-компаниях. Теперь разберём, как решать задачи на алгоритмическом собеседовании.</p>
</article>


<!-- Тема 2. Урок 6. Как проходить алгоритмические собеседования -->
<article class="article">
  <div class="anchor" id="p2.6"></div>
  <h3>Тема 2. Урок 6. Как проходить алгоритмические собеседования</h3>

  <p>В прошлых уроках речь шла о том, как и зачем проводят алгоритмические собеседования. Посмотрим, как в них добиться хорошего результата.</p>
  <p>Обычно интервью состоит из нескольких этапов.</p>

  <h3>Часть 1. Smalltalk</h3>
  <p>Как правило, интервью начинается не с задачи, а со знакомства. Ещё интервьюер может что-нибудь спросить у кандидата, чтобы просто установить контакт и помочь начать говорить. Вопросы бывают про опыт или про то, как прошли предыдущие секции. Не нужно переживать: «правильный» ответ здесь точно не нужен, главное — не тратить больше пары минут и быть хотя бы минимально доброжелательным.</p>
  <p>Возможная ошибка на этом шаге: слишком длинный рассказ — это может отобрать больше времени, чем нужно. Предполагается, что такая вводная часть продлится не более 2—3 минут.</p>

  <h3>Часть 2. Формулировка задачи</h3>
  <ol>
    <li>После вводной части интервьюер формулирует задачу. Сейчас самое важное — разобраться в условии. Лучше всего подойдёт такой способ: перескажите условие своими словами и спросите, правильно ли вы всё поняли. При необходимости можно попросить интервьюера повторить задачу или ответить на вопросы.
    <br>Возможная ошибка: не нужно повторять условие задачи словами интервьюера — возможно, кандидат просто запомнил дословно условие, но не понял его, а интервьюер подумает, что понял и будет считать, что кандидат перешёл к следующему этапу решения.
    </li>
    <li>В зависимости от задачи может потребоваться прояснить формат входных данных. Какие структуры будут поступать на вход функции, которую вам нужно реализовать? В ответ интервьюер может спросить, какой формат вам был бы наиболее удобен. Об этом сто́ит подумать. Во-первых, так вам будет проще решать задачу. Во-вторых, вопрос о формате — упрощённая проверка архитектурного навыка, то есть того, насколько хорошо вы можете проектировать интерфейсы.</li>
    <li>Выясните ограничения. Есть ли условия для входных данных? Допустим, вам нужно что-то сделать с массивом чисел. Тогда важно понять, о каких числах идёт речь: целых или с плавающей точкой. А может быть, гарантируется, что они будут неотрицательными. Для целых чисел нужно уточнить ограничения, чтобы выбрать правильный тип и не получить переполнение.
    <br>Если прозвучала «необычная» деталь, например, что исходный массив отсортирован, отметьте её для себя. Скорее всего, это существенно влияет на ожидаемое решение.
    <br>Некоторые задачи похожи друг на друга, но отличаются деталями. Поэтому возможны ошибки. Например, кандидат видел похожую задачу. В ней гарантировалось, что числа будут неотрицательные. Поэтому кандидат подумал, что в заданной ему сейчас задаче это тоже выполняется.
    </li>
    <li>Выясните ожидаемое поведение на краевых случаях. Можно сделать это устно («Что должна выдавать программа или функция, если входной массив пуст?») или через тест-кейсы. Если решили выписать тест-кейсы, делайте это максимально просто, хоть комментарием в коде. Использовать реальную библиотеку для тестирования необязательно, поэтому нужен самый быстрый вариант.</li>
  </ol>
  <p>Итак, к этому моменту нужно хорошо понимать, что от вас требуется. Если что-то важное осталось непонятным — обязательно выясните, задавая вопросы. Главное — не базироваться на неозвученных предположениях. Иначе можно решать не ту задачу, которую нужно, а это почти гарантированный путь к провалу. Аналогия с промышленной разработкой должна быть очевидна: если сделать не то, что нужно заказчику, потом придётся много переделывать.</p>

  <h3>Часть 3. Придумывание решения</h3>
  <p>Это самая «творческая» и наименее формализуемая часть работы над задачей. При подготовке к интервью вам нужно будет решить много задач. С какими-то вы справитесь самостоятельно, в других вам нужно будет обращаться к подсказкам или изучать разбор решения. При таком процессе у вас в голове появится своя коллекция шаблонов задач и способов решения. Даже если мы детально опишем все возможные варианты, без существенной практики это не поможет быстро вспомнить и реализовать нужную идею во время собеседования. Поэтому перечислим только основные шаги, которые, как правило, полезно сделать. Иногда какие-то пункты можно пропустить или поменять местами.</p>
  <ol>
    <li>Придумайте тестовый пример. Это должен быть хороший общий тест. В следующем уроке мы подробно расскажем, что это такое. Пока можно считать, что это тест, на котором можно будет проверить, что идея и решение в целом рабочие.</li>
    <li>Пользуясь этим примером, подумайте, как достичь нужного результата. Удобнее всего делать это на листочке бумаги или доске.</li>
    <li>Придумайте какое-нибудь корректное решение. Даже если оно очень простое — расскажите его интервьюеру. Оцените время работы и затраты по памяти и, если думаете, что можно решить задачу быстрее, скажите об этом. Так вы покажете интервьюеру, что поняли задачу, можете придумывать простые решения и оценивать их эффективность. Скорее всего, нужно будет придумать более быстрое решение, поэтому не тратьте много времени на простое.</li>
    <li>Первоначальное решение может оказаться оптимальным, но сложным в реализации. Подумайте, как именно вы будете его писать, чтобы избежать ошибок.</li>
    <li>Возможна и другая ситуация, когда существует более асимптотически эффективное решение. В этом случае могут помочь такие приёмы:
      <ul>
        <li>Если у вас есть монотонность, как правило, входных данных или частичных сумм — может быть применим бинарный поиск или метод двух указателей.</li>
        <li>Если вы много раз пересчитываете одно и то же — поможет динамическое программирование.</li>
        <li>Часто для ускорения полезно использовать вспомогательную структуру данных, как правило, хеш-таблицу, кучу или, реже, дерево поиска.</li>
      </ul>
    </li>
    <li>Если ничего применить не получилось, вероятно, оптимальное решение основано на совсем другой идее. Общие рекомендации дать сложно. Вам поможет общение с интервьюером. Сообщите ему, что собираетесь пойти в другом направлении и обязательно рассуждайте вслух.</li>
  </ol>

  <hr>
  <p>💡 Когда вы тренируетесь решать задачи, тоже можете оказаться в ситуации, когда правильное решение не приходит в голову. В этом случае важно не искать сразу подсказку или готовое решение в интернете, а сфокусированно подумать хотя бы полчаса, а лучше час. Особенно это актуально для подготовки на сервисах, которые предоставляют подсказки и решения рядом с задачей. Иначе вы не разовьёте в достаточной степени навык придумывания решений.</p>
  <hr>

  <p>Под эффективностью понимается асимптотика решения по времени и памяти. Может оказаться, что однозначно оптимального решения не существует: одно решение будет быстрее, другое будет использовать меньше памяти. Если вы это понимаете, скажите интервьюеру.</p>
  <p>Оптимизировать константу наоборот, обычно нет смысла. Такие оптимизации усложняют код и добавляют места для ошибок, при этом не влияя на результат: если ваше решение оптимально, то всё и так хорошо, а если нет — ускорение в два раза не поможет. Исключение: задачи, в которых это требование условия, например «за один проход».</p>
  <p>На данном шаге интервьюер оценивает два параметра: как кандидат подходит к решению задач и насколько ясно может объяснять свои мысли. Поэтому нужно проговаривать возникающие идеи решения. Если сходу придумать правильный вариант не получается — это нормально. Собеседующий предложит направления, в которых стоит думать, причём начнёт с более общих подсказок или наводящих вопросов. Кандидату нужно прислушаться к комментариям интервьюера, иначе тому придётся дать более явную подсказку, а это может негативно сказаться на результате.</p>

  <h3>Часть 4. Проработка деталей</h3>
  <p>Когда с общей идеей определились, нужно погрузиться в детали и рассказать, как именно будет работать ваш код. Это очень важная часть! Расскажите, какие структуры данных собираетесь использовать, что у вас будет состоянием, и как оно будет изменяться. В задачах почти всегда есть понятное и лаконичное решение, которое можно рассказать за минуту. Если ваш рассказ получается путаным, вам часто приходится отвлекаться на детали или особые случаи — это лучший индикатор того, что решение далеко от оптимального с точки зрения реализации и над ним следует ещё подумать.</p>

  <hr>
  <p>💡  Обязательно проговорите идею решения достаточно подробно, самостоятельно убедитесь, что оно реализуемо, и получи́те одобрение интервьюера. Часто кандидаты не могут до конца сформулировать решение и начинают писать код — он с высокой вероятностью получится сложным, плохим и не поддающимся отладке. В таком случае интервью будет неуспешным.</p>
  <p>Не бойтесь делать несколько итераций проработки. Если вы понимаете, что рассказанное вами решение чересчур сложное, лучше всего будет сказать это интервьюеру и попросить минуту подумать. Скорее всего, вы поймёте, как избавиться от лишних проверок и решение будет более простым. Это принесёт несколько плюсов: </p>
  <ol>
    <li>Более лаконичное решение быстрее реализовывать.</li>
    <li>Меньше сложного кода — меньше багов.</li>
    <li>Понятное и безошибочное решение — сигнал для интервьюера о том, что вы и в работе будете писать хороший код. Это может дать вам более хороший оффер.</li>
  </ol>

  <p>Когда сформулируете решение, будьте готовы, что интервьюер попросит вас оценить затраты по времени и памяти.</p>
  <p>Применительно к реальной разработке этот этап напоминает дизайн-ревью в миниатюре: прежде чем реализовывать фичу, разработчик проектирует решение и защищает его перед коллегами.</p>

  <h3>Часть 5. Написание кода</h3>
  <p>Наверно, это самая понятная часть — то, чем разработчик занимается почти каждый день. Главное:</p>
  <ol>
    <li>Пишите на том языке, который вы знаете лучше всего.</li>
    <li>Пишите именно то решение, которое вы рассказали. Нормально, если детали будут отличаться, но писать совсем другое решение не надо. Если чувствуете, что у вас сложности и решение получается не таким, как вы рассказали — озвучьте свои сомнения интервьюеру. Возможно, они напрасны. Если замечаете, что начинаете уходить в сторону или код становится запутанным, нужно остановиться и проверить, действительно ли вы делаете то, что озвучили.</li>
    <li>Не обобщайте код без надобности. К примеру, в некоторых задачах решение может принимать массив не только целых чисел, но и массив более широкого класса объектов. В статически типизированных языках в таком случае обычно пишут шаблонные функции или классы, но на собеседовании это делать необязательно. Лучший вариант — спросить интервьюера. Скорее всего, он подтвердит, что тратить время необязательно, но пометит себе, что вы можете и это.</li>
  </ol>

  <h3>Часть 6. Проверка решения и устранение ошибок</h3>
  <p>На этом этапе кандидаты проверяют свой код на логические ошибки, не имея возможности скомпилировать и запустить его. Подробно об ошибках мы рассказали в уроке «Критерии успешного собеседования».</p>
  <p>Эта часть начинается в тот момент, когда кандидат дописал код. Важно сообщить интервьюеру, что вы закончили и собираетесь проверять код. Одна из самых частых ошибок на интервью — кандидат говорит «готово» сразу после того, как дописал последний символ. Чаще всего в коде есть баг, и интервьюеру приходится об этом говорить. Аналогия с реальной разработкой: когда вы написали код для задачи, нужно проверить его, прежде чем создавать пулл-реквест.</p>
  <p>Эта фаза содержит очень много нюансов и подводных камней, поэтому мы вынесли её в отдельный следующий урок.</p>

  <h3>Часть 7. После задачи</h3>
  <p>В зависимости от запланированной структуры и фазы интервью, за полным решением задачи могут последовать:</p>
  <ol>
    <li>Дополнительный вопрос, или follow up. Например, интервьюер может спросить кандидата, как тот бы решал задачу, если бы одно из условий не выполнялось. Чаще всего на фоллоу-апах не требуют писать код. Но если требуют, обычно это засчитывается как ещё одна задача.</li>
    <li>Следующая задача.</li>
    <li>Если интервью подходит к концу — вопросы интервьюеру. Они практически ни на что не влияют. Можете спросить о том, что вам интересно: например, над чем интервьюер работает в компании. Разумеется, не сто́ит задавать провокационные и неуместные вопросы, придерживайтесь безопасных тем.</li>
  </ol>
</article>


<!-- Тема 2. Урок 7. Как тестировать свою программу -->
<article class="article">
  <div class="anchor" id="p2.7"></div>
  <h3>Тема 2. Урок 7. Как тестировать свою программу</h3>

  <p>В этом уроке мы подробно расскажем о том, как тестировать написанное решение и исправлять ошибки. Эти знания применимы не только на собеседовании и в процессе подготовки к нему, но и в повседневной работе.</p>

  <h4>Обзор написанного кода</h4>
  <p>Когда вы написали код, прежде всего полезно просто посмотреть и оценить, понятный ли он. Если в коде логика идёт последовательно, состояние хорошо описано и понятным образом изменяется — это хорошо. Если нет, то главное, что вы можете сделать на данном этапе, — обратить на это внимание и относиться к коду с недоверием.</p>
  <p>Теперь можно чуть внимательнее прочитать собственный код. Часто какой-то случай остаётся неучтённым. Реже решение сильно отличается от того, которое вы запланировали. В таком случае следует очень внимательно его проверить.</p>
  <p>Ещё важно проверить, соответствует ли итоговая сложность решения той, которая требуется в задаче. Иногда код может выглядеть обманчиво. </p>
  <p>Рассмотрим функцию, которая принимает на вход массив целых чисел. Она находит префикс с максимальной суммой и возвращает одно число — сумму чисел этого префикса.</p>

  <p>После того как вы просмотрели свой код и убедились, что он делает то, что нужно, полезно его самостоятельно протестировать.</p>

  <h4>Виды тестов</h4>
  <p>Прежде всего нужно составить или выписать тестовые примеры. Это список пар «входные данные» — «ожидаемый результат». В промышленной разработке инженеры по тестированию проверяют разные классы тестов:</p>
  <ul>
    <li>правильность результата на корректных данных,</li>
    <li>обработка некорректных данных,</li>
    <li>нагрузочные тесты,</li>
    <li>тесты безопасности.</li>
  </ul>

  <p>На собеседованиях можно считать, что на вход поступают корректные данные, асимптотика считается непосредственно по коду (нагрузочные тесты всё равно запустить не получится), поэтому нужно проверять только то, что программа выдаёт правильный ответ на корректных данных.</p>
  <p>Есть ещё одна классификация типов тестирования: blackbox (чёрный ящик) и whitebox (белый ящик). Вместо дословного перевода мы предлагаем использовать более наглядные варианты «непрозрачный ящик» и «прозрачный ящик». </p>
  <p>Суть тестирования по методу непрозрачного ящика: вы думаете только о формулировке задачи, а не о реализации. Вы как будто не видите код, отсюда и «непрозрачный».</p>
  <p>Суть тестирования по методу прозрачного ящика: вы знаете подробности реализации и можете составить тесты так, чтобы затронуть каждую ветку в коде.</p>
  <p>Оба подхода имеют свои плюсы и минусы, но мы сфокусируемся на blackbox-тестах, поскольку они прежде всего проверяют соответствие решения исходной задаче. Кроме того, whitebox-тесты специфичны для конкретного решения, поэтому универсальных рекомендаций мы дать не сможем.</p>

  <h4>Как составлять тесты в модели blackbox-тестирования</h4>
  <p>Вместо конкретных тестов думайте о классах тестов. Опишите словами, что вы хотите проверить, и для каждого класса выберите какой-нибудь конкретный тест.</p>
  <p>Разберёмся на примере классической задачи 2-SUM. Её условие таково: дан массив целых чисел arr и целое число X, нужно определить, существуют ли в массиве два элемента, сумма которых в точности равна X.</p>
  <p>Начинать всегда лучше с самых общих случаев, потому что на них выявляются наиболее существенные ошибки. </p>
  <ol>
    <li>Первый общий случай: в массиве несколько элементов и искомая пара элементов есть. Пример теста: array=[1, -2, 4, 7, 3], X=5 -> True.</li>
    <li>Второй общий случай: то же самое, только теперь пары нет. Например, array=[1, -2, 4, 7, 3], X=6 -> False.</li>
  </ol>
  <p>Самое важное в таких тестах — обеспечить, чтобы пример содержал данные всего возможного диапазона значений.</p>

  <hr>
  <p>💡 Корнер-кейс (англ. corner case) — тест, который проверяет краевой случай. Например, всегда полезно проверять случай пустого массива или строки, поскольку в коде могут быть конструкции вида initial_value = array[0]. Из-за них случится ошибка времени выполнения.</p>
  <hr>

  <p>Получилось 12 тестов. Конечно, это условное число: при другой организации классов проверок оно могло быть другим, единственного правильного ответа тут нет. Если мы не упустили какой-нибудь важный класс, тестов больше не нужно.</p>

  <h3>Как проводить тестирование</h3>
  <p>Мы рассмотрели, как составлять тестовые примеры, теперь нужно понять, как их применять к вашему коду. Это зависит от контекста.</p>
  <p>В реальной работе или при обучении полезно составить все разумные тестовые примеры. Затем вы сможете запустить программу и при необходимости сделать трассировку с помощью отладчика. Кроме этого, часть ошибок помогут найти статические анализаторы кода. После того, как разработчик или тестировщик составят тестовые сценарии, разработчик может использовать всю мощь автоматики для поиска и устранения ошибок.</p>
  <p>На собеседовании вам доступно намного меньше времени на тестирование. И не будет возможности запускать код и тем более использовать какие-либо вспомогательные инструменты. Но вы можете делать трассировку вручную. Для этого нужно:</p>
  <ol>
    <li>Придумать один хороший общий тест. Он должен быть не очень большим, чтобы вы могли провести проверку вручную за 2—3 минуты.</li>
    <li>Выполнять код построчно и следить, что происходит. В зависимости от сложности кода и тестов вы можете выписывать все значения всех переменных на каждом шаге или делать проверку быстрее.</li>
    <li>По окончании проверки убедиться, что вы зашли во все участки кода. Если это не так, подумайте, в каких случаях эти места могут выполниться. Иногда какие-то проверки оказываются лишними. Это нестрашно, но если их можно безопасно убрать, код будет чище.</li>
  </ol>

  <p>Когда планируете решение и пишете код, вы можете заметить случай, в котором корректная работа алгоритма неочевидна. Например, в задаче 2-SUM такими случаями могут быть тест-кейсы №4 и №5, когда в массиве есть один и два элемента со значением X/2 соответственно. Такие случаи тоже можно проверить с помощью трассировки.</p>
  <p>Когда вы будете готовиться к собеседованиям, проверяйте, тестируйте и отлаживайте решения вручную перед тем, как отправлять их на автоматическую проверку. </p>

  <h3>Что делать дальше</h3>
  <p>Разберём ситуацию: вы протестировали свой код, не нашли ошибок, но решение не принимается или интервьюер говорит вам, что баг есть. Как действовать?</p>
  <p>Давайте пойдём от обратного и подумаем, как ошибка может себя проявить:</p>
  <ol>
    <li>В результате ошибки решение работает асимптотически медленнее, чем должно. Предположим, вы работали над задачей 2-SUM, где массив уже отсортирован и нужно найти решение методом двух указателей. Такое решение работает за линейное время, потому что на каждом шаге работы алгоритма расстояние между указателями должно уменьшаться ровно на 1. Поэтому, чтобы проверить асимптотику, не нужно делать трассировку и проверять много тест-кейсов. Достаточно убедиться по коду, что:
      <ul>
        <li>расстояние действительно всегда уменьшается,</li>
        <li>когда оно становится равным 0, выполнение завершается.</li>
      </ul>
    </li>
    <li>Происходит ошибка времени выполнения. В данной задаче это может случиться из-за выхода за пределы массива. Так как указатели смещаются с краёв внутрь массива, такая ошибка маловероятна. Как и в прошлом случае, достаточно убедиться, что выполнение завершается не позже момента, когда указатели встречаются. Это значит, что левый указатель не может находиться правее правого, соответственно, не может обратиться к несуществующему элементу.
    <br>Крайний случай: когда исходный массив пуст, некоторые реализации могут обращаться к несуществующему 0 элементу массива.
    </li>
    <li>
      <p>Программа выводит True там, где должно быть False. То есть требуемой пары в массиве нет, а алгоритм её нашёл. Подумайте, как такое возможно. Это непросто, ведь, скорее всего, любая разумная реализация в конечном счёте будет иметь конструкцию вида:</p>
      <p>Единственное, что может привести к такой ошибке, — совпадение индексов. Теперь вы легко можете проверить своё решение — убедитесь, что указатели не могут встретиться никогда. Здесь тоже необязательно проводить трассировку, это должно быть очевидно из кода.</p>
      <p>Левый указатель должен быть строго левее правого.</p>
      <p>Звучит очевидно, но очень полезно. Это условие должно выполняться в любой момент работы кода. Оно легко и быстро проверяется по коду, потому что для этого не нужно придумывать тест-кейсы и проводить трассировку. Если убедитесь, что условие действительно всегда выполняется, можете быть уверены, что части ошибок удалось избежать.</p>
      <p>Условие, которое должно быть верно в любой момент выполнения программы, называется «инвариант».</p>
      <p>Очень полезно научиться формулировать инварианты на этапе обдумывания решения и проверять их. Это сильно поможет вам не только на собеседованиях, но и в промышленном программировании.</p>
      <p>Вернёмся к поиску ошибок. Остался ещё один случай.</p>
    </li>
    <li>Программа выводит False там, где должно быть True. Значит, в решении может не рассматриваться искомая пара. Это самый общий случай из рассмотренных, поэтому нужно проверить несколько условий:
      <ul>
        <li>в начале работы алгоритма указатели расставлены правильно: левый указатель указывает на самый левый элемент, правый — на самый правый;</li>
        <li>при выполнении итерации цикла смещается только один из указателей и только на один элемент;</li>
        <li>если всё верно, то осталось проверить саму логику изменения указателей.</li>
      </ul>
    </li>
  </ol>
  <p>После такой проверки ошибки должны найтись. Если нет — вы столкнулись с действительно хитрым багом. В этом случае по согласованию с интервьюером можно выписать остальные тест-кейсы и внимательно их проверять. Сначала выпишите все, а затем проверяйте — возможно, вы поймёте в процессе составления тестов, что какой-то случай в вашем коде не учтён.</p>

  <h3>Как исправлять ошибки</h3>
  <p>Допустим, вы нашли ошибку и придумали тест, на котором она проявляется. Особенно важно найти и устранить причину ошибки. Распространённая проблема — разработчик добавляет проверку, которая становится «заплаткой». Это может привести к тому, что ошибка не будет ликвидирована, либо сломается какой-нибудь другой случай. На собеседовании это важно вдвойне, поскольку без запуска кода и при ограниченном времени заметить новую ошибку сложно. Чтобы её исправить, нужно:</p>
  <ol>
    <li>Определить настоящий класс тестов, на которых ошибка проявляется. Может быть, вы нашли ошибку при проверке корнер-кейса, но на самом деле она затрагивает более широкий класс тестов.</li>
    <li>Понять, из-за чего именно ошибка происходит, и устранить её причину.</li>
    <li>Проверить, что проблема действительно устранена. Для этого нужно внимательно проверить тест, на котором ломалась предыдущая версия решения.</li>
    <li>Убедиться, что другие случаи не сломались. Проверить инварианты, разобраться, какие тесты потенциально затрагивают изменение кода, и посмотреть только на них.</li>
  </ol>
  <p>Тестировать код непросто. Но владение этим навыком поможет вам как при прохождении собеседований, так и в промышленной разработке. Развивать умение тестировать на алгоритмических задачах особенно удобно, потому что тесты проверяют функциональность, а не корректность входных данных и требований заказчика.</p>

  <hr>
  <p>При подготовке важно пробовать самостоятельно тестировать задачи и как можно реже смотреть в протокол тестирования.</p>
  <hr>
</article>


<!-- Тема 2. Урок 8. Конец второй части -->
<article class="article">
  <div class="anchor" id="p2.8"></div>
  <h3>Тема 2. Урок 8. Конец второй части</h3>

  <p>В предыдущих уроках мы рассмотрели:</p>
  <ul>
    <li>Зачем разработчикам знать и уметь применять алгоритмы и структуры данных.</li>
    <li>Как проводятся и оцениваются алгоритмические собеседования в крупные IT-компании.</li>
    <li>Что и как нужно делать, чтобы повысить свои шансы на успех на собеседовании.</li>
    <li>Как тестировать свой код без возможности запустить его.</li>
  </ul>
  <p>Мы практически не касались того, какие именно алгоритмы и структуры данных нужно изучать для подготовки к собеседованиям. В следующих разделах мы коротко рассмотрим основные темы. В уроках будут проверочные вопросы, так что вы поймёте, достаточно ли у вас знаний и навыков по теме или нужно их подтянуть.</p>
  <p>Если отвечать на тесты будет сложно, обратитесь к следующим источникам:</p>
  <ol>
    <li>Курс «Алгоритмы и структуры данных» Яндекс Практикума.</li>
    <li>Видеолекции Павла Маврина на YouTube.</li>
    <li>Книга Адитья Бхаргавы «Грокаем алгоритмы. Иллюстрированное пособие для программистов и любопытствующих».</li>
  </ol>
  <p>В 5 модуле мы также приведём список ресурсов, где можно попрактиковаться в решении задач и получить представление о других форматах интервью, таких как архитектурное и поведенческое.</p>
</article>


<!-- Тема 3 Какие алгоритмы нужно знать -->
<!-- Тема 3. Урок 1 Сложность алгоритмов -->
<article class="article">
  <div class="anchor" id="p3.1"></div>
  <h2>Тема 3 Какие алгоритмы нужно знать</h2>
  <h3>Тема 3. Урок 1 Сложность алгоритмов</h3>

  <p>Навык, который точно пригодится на собеседованиях и в реальной разработке, — умение оценивать пространственную и временну́ю сложность решения и кода в терминах O-нотации. Иногда кандидаты рассказывают асимптотически верное решение, а потом путаются или ошибаются. И в результате пишут код с другой асимптотикой. Именно поэтому важно читать свой код с некоторым подозрением.</p>

  <hr>
  <p>💡 Кроме большой O вы могли слышать про другие буквы греческого алфавита в контексте оценки сложности алгоритмов. Не нужно их изучать или повторять — на собеседованиях они не понадобятся.</p>
  <hr>

  <p>Сначала разберёмся с пространственной. Если вы используете вспомогательную структуру данных, надо посчитать, какой объём она будет занимать относительно входных данных. Как правило, тут всё несложно, но есть особые случаи.</p>

  <p>Дан текст, состоящий из  N слов. Длина каждого слова — не более L. В тексте всего A различных символов. Для решения некоторой задачи нужно разделить текст на слова и составить из них словарь, чтобы можно было быстро определять, есть ли некоторое слово в тексте. Сколько памяти нужно для хранения словаря?</p>
  <p>O(N⋅L) Верно! Для хранения словаря нам нужно примерно столько же памяти, сколько всего символов в тексте. По имеющимся величинам можно сказать, что их точно не больше, чем N⋅L.</p>
  <p>Помимо вспомогательных структур данных, память может требоваться для стека вызовов, если в коде есть рекурсивные функции. Такая память не выделяется явно, поэтому про неё можно забыть или неверно рассчитать.</p>
  <p>Сколько дополнительной памяти требует быстрая сортировка массива длины N в среднем? O(logN) В среднем у быстрой сортировки логарифмическая глубина рекурсии. Поскольку она in-place, на каждом шаге выделяется O(1) памяти. Поэтому и памяти тоже требуется логарифм.</p>
  <p>Библиотечные функции могут выделять дополнительную память, как уже упомянутая функция сортировки, — это тоже нужно иметь в виду.</p>

  <h3>Временная сложность</h3>
  <p>В общем виде сложность оценивают так:</p>
  <ol>
    <li>Сначала определите, из каких блоков, независимых с точки зрения операций, состоит программа. Для каждого посчитайте время выполнения. Итоговое время будет максимумом среди этих значений. Например, если для решения задачи 2-SUM вы сортируете входной массив, а затем используете метод двух указателей, то в вашем решении два блока. Первый работает за время (NlogN), второй — за O(N), значит, общее решение требует O(NlogN) времени.</li>
    <li>Для блока посчитайте число операций разного типа и стоимость каждого типа операции. Со стоимостью понятно: как правило она зависит от структур данных, с которыми происходит взаимодействие. Про количество операций немного поговорим дальше и разберём сложный случай.</li>
  </ol>

  <p>Особую трудность могут вызывать амортизированные оценки сложности. Например, есть задача: найти максимальное число идущих подряд одинаковых символов в строке. Для решения задачи написали функцию max_consecutive_elements.</p>
  <p>Представим, что мы передаём в функцию max_consecutive_elements строку длины N.</p>
  <p>Как вы могли убедиться, оценивать сложность алгоритма не всегда просто. Поэтому нужно действовать аккуратно.</p>
</article>


<!-- Тема 3. Урок 2 Два указателя -->
<article class="article">
  <div class="anchor" id="p3.2"></div>
  <h3>Тема 3. Урок 2 Два указателя</h3>

  <p>Задачи на метод двух или трёх указателей, возможно, самые популярные на собеседованиях. Их можно встретить на интервью даже в те компании, где не проводят алгоритмические интервью в традиционном понимании. Дело в том, что для их решения не нужны особые знания, и корректный код может написать разработчик, никогда раньше не сталкивавшийся с алгоритмическими задачами. Но это не значит, что такие задачи — совсем простые.</p>
  <p>Для примера рассмотрим задачу, которую мы разбирали в предыдущем уроке. В ней нужно найти максимальное число одинаковых подряд идущих символов в строке. Код был такой:</p>
  <p>Здесь cur_letter_idx задаёт позицию первого символа группы (левый указатель), а next_letter_idx — позицию первого символа следующей группы (правый указатель). Разность этих индексов равна количеству символов в текущей группе.</p>
  <p>Несмотря на алгоритмическую простоту, задачи на два указателя могут преподнести неприятные сюрпризы.</p>

  <h4>Неприменимость метода</h4>
  <p>Начнём с того, что иногда не совсем очевидно, можно ли применять метод двух указателей для задачи.</p>
  <p>Задача. Дан массив целых чисел arr и целое число X. Определите, существует ли в массиве такой непрерывный подмассив, что сумма его элементов равна X.</p>
  <p>Решается ли такая задача методом двух указателей?</p>
  <p>В такой формулировке задача методом двух указателей не решается. Попробуйте разобраться, в каких случаях могла бы.</p>
  <p>Метод двух указателей работает, когда мы имеем дело с монотонными функциями. Рассмотрим некоторый непрерывный подмассив arr[left:right]. Целевая функция — сумма элементов этого подмассива. Если элементы arr неотрицательные, эта функция монотонно не возрастает с увеличением left и монотонно не убывает с увеличением right</p>

  <hr>
  <p>💡 Функция называется монотонно возрастающей, если каждое её значение строго больше предыдущего. Функция называется монотонно неубывающей, если каждое её значение не меньше предыдущего. Аналогично функция может быть монотонно убывающей (каждое значение строго меньше предыдущего) или монотонно невозрастающей (каждое значение не больше предыдущего). Если функция обладает хотя бы одним из этих свойств, то она монотонная.</p>
  <hr>

  <p>Учитывая свойство монотонности задачу можно было бы решить так: допустим, у нас есть два указателя — left и right. Если сумма подмассива [left; right) равна X — ответ найден. Если она меньше X, попробуем добавить элемент right к сумме, а если больше — уберём left. Изначально left = right = 0. Таким образом, мы для каждого left посмотрим указателем right на соответствующую потенциальную правую границу полуинтервала и не пропустим ответ, если он существует. Поскольку при смещении указателя мы можем быстро пересчитать сумму, общее время работы будет линейным. Запишем это в коде.</p>
  <p>В случае, когда элементы в массиве отсортированы, но могут быть отрицательными, частичные суммы могут не быть целиком монотонными. Однако, в худшем случае будет два участка монотонности: на отрицательных числах частичные суммы будут уменьшаться, затем — увеличиваться. Так что придётся сделать два дополнительных прохода, но задачу мы решим.</p>
  <p>Идея в том, что пока левый указатель перемещается по отрицательным числам, правый двигается влево, а когда левый переместится на неотрицательные числа — правый будет перемещаться вправо. Таким образом, левый указатель посетит каждый элемент один раз, а правый — не более трёх. Так что нам потребуется не более 4⋅N операций, то есть общая сложность будет линейной.</p>
  <p>А вот если на числа вообще нет никаких ограничений, тогда частичные суммы будут колебаться и метод двух указателей не сработает совсем.</p>
  <p>Остальные ошибки, как правило, допускаются по неаккуратности.</p>

  <h4>Неправильная временная сложность</h4>
  <p>Снова рассмотрим решение задачи о максимальном количестве одинаковых подряд идущих символов в строке. На этот раз разработчик по-другому написал всего одну строку. Он запустил код на своём хорошем наборе тестов, и на все программа выдала правильный результат, так что разработчик со спокойной душой закоммитил код:</p>

  <h4>Ошибка в индексах off-by-one</h4>
  <p>Off-by-one — это ошибка в индексе на 1. Она может произойти:</p>
  <ul>
    <li>при вычислении индекса элемента массива,</li>
    <li>если перепутать строгий и нестрогий знаки неравенства.</li>
  </ul>
  <p>Это самый распространённый класс ошибок в таких задачах. Задачи на два указателя дают на собеседованиях, чтобы убедиться, что разработчик способен не ошибиться в нескольких строках собственного кода и не вызвать исключение при работе с самыми стандартными структурами данных — массивами.</p>
  <p>Мы не будем приводить примеры, чтобы сейчас не показывать слишком много плохого кода. Сделаем это в следующем уроке.</p>
</article>


<!-- Тема 3. Урок 3. Бинарный поиск -->
<article class="article">
  <div class="anchor" id="p3.3"></div>
  <h3>Тема 3. Урок 3. Бинарный поиск</h3>

  <p>Бинарный поиск тоже часто встречается на алгоритмических собеседованиях. Вспомним реализацию метода на примере классической задачи. Есть упорядоченный массив целых чисел arr, нужно определить, есть ли в нём число X.</p>

  <h4>Условия применимости бинарного поиска</h4>
  <p>В неупорядоченном массиве применить бинарный поиск, чтобы найти элемент, не получилось бы. Как правило, бинарный поиск применяется на монотонных данных. Что это такое, мы рассказывали в прошлом уроке.</p>
  <p></p>
</article>


<!-- Тема 3. Урок 4. Рекурсия и поиск с возвратом -->
<article class="article">
  <div class="anchor" id="p3.4"></div>
  <h3>Тема 3. Урок 4. Рекурсия и поиск с возвратом</h3>
</article>


<!-- Тема 3. Урок 5. Сортировки -->
<article class="article">
  <div class="anchor" id="p3.5"></div>
  <h3>Тема 3. Урок 5. Сортировки</h3>
</article>


<!-- Тема 3. Урок 6. Алгоритмы на графах -->
<article class="article">
  <div class="anchor" id="p3.6"></div>
  <h3>Тема 3. Урок 6. Алгоритмы на графах</h3>
</article>


<!-- Тема 3. Урок 7. Деревья -->
<article class="article">
  <div class="anchor" id="p3.7"></div>
  <h3>Тема 3. Урок 7. Деревья</h3>
</article>


<!-- Тема 3. Урок 8. Динамическое программирование -->
<article class="article">
  <div class="anchor" id="p3.8"></div>
  <h3>Тема 3. Урок 8. Динамическое программирование</h3>
</article>


<!-- Тема 3. Урок 9. Жадные алгоритмы -->
<article class="article">
  <div class="anchor" id="p3.9"></div>
  <h3>Тема 3. Урок 9. Жадные алгоритмы</h3>
</article>


<!-- Тема 3. Урок 10. Задачи на реализацию -->
<article class="article">
  <div class="anchor" id="p3.10"></div>
  <h3>Тема 3. Урок 10. Задачи на реализацию</h3>
</article>



