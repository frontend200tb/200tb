<article class="article">
  <h1>Основы C/C++ для спортивного программирования</h1>
  Конспект курса
</article>


<article class="article">
  <h3>Ссылка на курс</h3>

  <p><a href="https://stepik.org/course/80538" target="_blank">https://stepik.org/course/80538</a></p>
  <p>4 недели обучения, 2—5 часов в неделю</p>
  <p>Бесплатный курс от МФТИ Центр развития ИТ-образования</p>
</article>



<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p><a href="#about">О курсе</a></p>
  <ol>
    <li>
      <a href="#p1">Переменные</a>
      <ol>
        <li><a href="#p1.1">Первая программа, переменные, считывание</a></li>
        <li><a href="#p1.2">Подводные камни</a></li>
        <li><a href="#p1.3">Локальный запуск</a></li>
        <li><a href="#p1.4">Символьный тип данных</a></li>
        <li><a href="#p1.5">Типы данных с плавающей точкой</a></li>
        <li><a href="#p1.6">Логический тип данных</a></li>
        <li><a href="#p1.7">Итоговое тестирование</a></li>
      </ol>
    </li>
    <li>
      <a href="#p2">Условные операторы и циклы</a>
      <ol>
        <li><a href="#p2.1">Логические операции</a></li>
        <li><a href="#p2.2">Условный оператор</a></li>
        <li><a href="#p2.3">Циклы while, do-while</a></li>
        <li><a href="#p2.4">Цикл for</a></li>
        <li><a href="#p2.5">Итоговое тестирование
        </a></li>
      </ol>
    </li>
    <li>
      <a href="#p3">Массивы и функции</a>
      <ol>
        <li><a href="#p3.1">Массивы</a></li>
        <li><a href="#p3.2">Многомерные массивы</a></li>
        <li><a href="#p3.3">Квадратичные сортировки</a></li>
        <li><a href="#p3.4">Функции</a></li>
        <li><a href="#p3.5">Рекурсия</a></li>
        <li><a href="#p3.6">Итоговое тестирование</a></li>
      </ol>
    </li>
    <li>
      <a href="#p4">Сложные структуры данных</a>
      <ol>
        <li><a href="#p4.1">Указатели</a></li>
        <li><a href="#p4.2">Передача параметров в функцию</a></li>
        <li><a href="#p4.3">Структура: определение и поля</a></li>
        <li><a href="#p4.4">Структура: конструкторы и деструкторы</a></li>
        <li><a href="#p4.5">Перегрузка операторов</a></li>
        <li><a href="#p4.6">Vector</a></li>
        <li><a href="#p4.7">String</a></li>
        <li><a href="#p4.8">Итоговое тестирование</a></li>
      </ol>
    </li>
    <li>
      <a href="#p5">Битовые операции и системы счисления</a>
      <ol>
        <li><a href="#p5.1">Быстрое считывание</a></li>
        <li><a href="#p5.2">Системы счисления</a></li>
        <li><a href="#p5.3">Хранение чисел в компьютере</a></li>
        <li><a href="#p5.4">Битовые операции</a></li>
        <li><a href="#p5.5">Итоговое тестирование</a></li>
      </ol>
    </li>
  </ol>
</article>


<!-- О курсе -->
<article class="article">
  <div class="anchor" id="about"></div>
  <h3>О курсе</h3>

  <p>Языки программирования C и C++ традиционно являются одними из «классических» языков спортивного программирования, наиболее удобными и часто используемыми для написания программ на соревнованиях.</p>
  <p>Онлайн-курс «Основы C/C++ для спортивного программирования» познакомит с базовыми понятиями языка. В рамках курса раскрываются такие темы, как переменные, типы данных, условные операторы, циклы, функции и другие.</p>
  <p>Курс рассчитан на четыре недели. Каждое занятие состоит из видеолекций, посвященных определенной тематике, а также практических задач, которые помогут закрепить пройденный материал.Курс рассчитан на четыре недели. Каждое занятие состоит из видеолекций, посвященных определенной тематике, а также практических задач, которые помогут закрепить пройденный материал.</p>
  <p>Онлайн-курс «Основы C/C++ для спортивного программирования» — это первая часть программы интенсивной подготовки по спортивному программированию и искусственному интеллекту RuCode Festival, реализуемой МФТИ совместно с Фондом развития Физтех-школ при поддержке Фонда президентских грантов.</p>

  <h4>Наши преподаватели</h4>
  <p>Владислав Невструев</p>
  <p>Филипп Рухович</p>
  <p>Олег Христенко</p>
  <p>Владимир Куренков</p>
</article>


<!-- 1 Переменные -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>1 Переменные</h3>
</article>


<!-- 1.1 Первая программа, переменные, считывание -->
<article class="article">
  <div class="anchor" id="p1.1"></div>
  <h3>1.1 Первая программа, переменные, считывание</h3>

  <p>Стандартный шаблон программы на C++</p>
<pre>
#include &lt;iostream&gt;

using namespase std;

int main() {
}
</pre>

  <p><strong>iostream</strong> нужен для того чтобы вводить данные с клавиатуры и выводить данные на экран.</p>
  <p><strong>using namespase std</strong> стандартное пространство имен. В больших проектах бывает важно знать откуда взялась та или иная функция: из стандарта языка или из другого места. Поэтом в больших проектах эту строчку не пишут. В олимпиадном программировании есть только стандартное пространство имен. Поэтому нас эта проблема не волнует.</p>
  <p>Любая программа на языке C++ начинается с функции <strong>main()</strong>. В ней пишут команды, которая должна выполнить программа</p>
  <p>Напишем программу, которая будет принимать два целых числа, а в ответ напишет их сумму.</p>

  <h4>Тип данных int</h4>
  <p>Для хранения целых чисел будем использовать тип int, который занимает 4 байта памяти и может хранить числа</p>
  <code>от -2<sup>31</sup> до 2<sup>31</sup>-1</code>
  <code>примерно от -2&bull;10<sup>9</sup> до 2&bull;10<sup>9</sup></code>
  <p>Объявим переменную</p>
  <code>int a;</code>
  <p>Считаем с клавиатуры переменную</p>
  <code>cin &gt;&gt; a;</code>
  <p>Объявим две переменные</p>
  <code>int a, b;</code>
  <p>Считаем с клавиатуры две переменные</p>
  <code>cin &gt;&gt; a &gt;&gt; b;</code>

  <h4>Деление с остатком</h4>
  <p>При целочисленном делении числа a на число b, на ходим такие целые числа q и r, что</p>
  <code>a = q&#8231;b + r, 0 &le; r &lt; b</code>
  <p>q это частное от деления, его возвращает оператор /</p>
  <code>q = a / b</code>
  <p>r это остаток от деления, его возвращает оператор %</p>
  <code>r = a % b</code>

  <h4>Вывод на экран</h4>
  <p>Выведем число</p>
  <code>cout &lt;&lt; 2;</code>
  <p>Выведем слово</p>
  <code>cout &lt;&lt; "hello";</code>
  <p>Выведем слово и перейдем на новую строку</p>
  <code>cout &lt;&lt; "hello" &lt;&lt; endl;</code>

  <h4>Программа сложения двух чисел</h4>
<pre>
#include &lt;iostream&gt;

using namespase std;

int main() {
  int a, b;
  cin &gt;&gt; a &gt;&gt; b;
  cout &lt;&lt; a + b &lt;&lt; endl;
}
</pre>

  <details>
    <summary>Задача 1. Сумма чисел</summary>
    <h4>Сумма чисел</h4>
    <p>В этой задаче вам даны два числа, требуется найти их сумму.</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат два целых числа a, b (-10<sup>9</sup>&le;a,b&le;10<sup>9</sup>)</p>
    <h4>Выходные данные</h4>
    <p>Найдите сумму двух данных чисел</p>
    <h4>Решение</h4>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a, b;
  cin &gt;&gt; a &gt;&gt; b;
  cout &lt;&lt; a + b;
}
</pre>
  </details>

  <details>
    <summary>Задача 2. Периметр прямоугольника</summary>
    <h4>Периметр прямоугольника</h4>
    <p>В этой задаче требуется найти периметр прямоугольника, зная его стороны</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат два целых числа a, b (1&le;a,b&le;1000) - длины сторон прямоугольника</p>
    <h4>Выходные данные</h4>
    <p>В ответ выпишете единственное число - периметр прямоугольника</p>
    <h4>Примечание</h4>
    <p>Периметром прямоугольника называется сумма длин его сторон</p>
    <h4>Решение</h4>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a, b;
  cin &gt;&gt; a &gt;&gt; b;
  cout &lt;&lt; a + a + b + b;
}
</pre>
  </details>

  <details>
    <summary>Задача 3. Объем куба</summary>
    <h4>Объем куба</h4>
    <p>Найдите объем куба, зная длину его ребра</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат единственное целое число a (1&le;a&le;10<sup>3</sup>) - длину ребра куба</p>
    <h4>Выходные данные</h4>
    <p>В ответ выпишете единственное число - объем куба</p>
    <h4>Решение</h4>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a;
  cin &gt;&gt; a;
  cout &lt;&lt; a * a * a;
}
</pre>
  </details>

  <details>
    <summary>Задача 4. Гномий развод</summary>
    <h4>Гномий развод</h4>
    <p>история про Белоснежку и семь гномов. По этим законам, все имущество должно быть самым справедливым образом поделено между гномами, а то, что поделить поровну нельзя, не должно достаться никому из них. Бережливые гномы решили, что неразделённые вещи выкидывать не будут, а отдадут Белоснежке в качестве приданого</p>
    <h4>Входные данные</h4>
    <p>В единственной строке находится число K (0&le;K&le;10<sup>9</sup>) - количество вещей, которые гномы хотят поделить</p>
    <h4>Выходные данные</h4>
    <p>Выведите долю Белоснежки при гномьем разводе</p>
    <h4>Пример</h4>
    <code>Input: 8</code>
    <code>Output: 1</code>
    <h4>Решение</h4>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a;
  cin &gt;&gt; a;
  cout &lt;&lt; a % 7;
}
</pre>
  </details>

  <details>
    <summary>Задача 5. Поменять местами</summary>
    <h4>Поменять местами</h4>
    <p>Дано натуральное четырехзначное число, необходимо поменять местами средние цифры</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат единственное целое четырехзначное число</p>
    <h4>Выходные данные</h4>
    <p>В ответ напишите четырехзначное число, которое получается из исходного обменом двух средних цифр</p>
    <h4>Пример</h4>
    <code>Input: 1890</code>
    <code>Output: 1980</code>
    <h4>Решение</h4>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a;
  cin &gt;&gt; a;
  int a1 = a % 10;
  int a2 = (a / 10) % 10;
  int a3 = (a / 100) % 10;
  int a4 = a / 1000;
  cout &lt;&lt; (a4 * 1000) + (a2 * 100) + (a3 * 10) + a1;
}
</pre>
  </details>

  <details>
    <summary>Задача 6. Просто деление</summary>
    <h4>Просто деление</h4>
    <p>В этой задаче необходимо научиться делить нацело с округлением вверх</p>
    <h4>Входные данные</h4>
    <p>В единственной строке входных данных содержится два целых числа a,b (1 &le;a,b&le;10<sup>9</sup>)</p>
    <h4>Выходные данные</h4>
    <p>Выведите единственное целое число a / b</p>
    <h4>Примечание</h4>
    <p>В этой задаче запрещено использовать условный оператор</p>
    <h4>Пример</h4>
    <code>Input: 7 3</code>
    <code>Output: 3</code>
    <h4>Решение</h4>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a;
  cin &gt;&gt; a &gt;&gt; b;
  cout &lt;&lt; (a - 1 + b) / b;
}
</pre>
  </details>
</article>


<!-- 1.2 Подводные камни -->
<article class="article">
  <div class="anchor" id="p1.2"></div>
  <h3>1.2 Подводные камни</h3>

  <p>Тип int вмещает в себя число до 2 миллиардов. Что будет если попробовать записать число больше? В этом случае возникает <strong>переполнение</strong></p>
  <p>Если умножить миллион на миллион то получим 10<sup>12</sup> это в 500 раз больше чем 2 миллиарда и не вмещается в тип данных int. Давайте проверим что тогда запишется в int</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a = 1000000;
  cout &lt;&lt; a * a;
}
</pre>
  <code>-727379968</code>
  <p>Запишем в int максимальное для него число. Прибавим к нему 1 и выведем на экран. Получим минимальное число типа int</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a = 2147483647;
  a = a + 1;
  cout &lt;&lt; a;
}
</pre>
  <code>-2147483648</code>
  <p>Если результат не помещается в тип данных int, то нужно использовать другой тип данных.</p>

  <h4>Тип данных long long</h4>
  <p>Тип данных long long занимает 8 байт памяти и может хранить целые числа</p>
  <code>от -2<sup>63</sup> до 2<sup>63</sup>-1</code>
  <code>примерно от -4&bull;10<sup>18</sup> до 4&bull;10<sup>18</sup></code>
  <p>Если для наших данных не хватает типа данных long long то нужно либо создавать свой тип данных (задачи с очень большими данными называются <strong>длинная арифметика</strong>) либо переходить на python - там такой проблемы нет.</p>

  <h4>Беззнаковые типы данных unsigned</h4>
  <p>Значения беззнаковых типов данных unsigned могут быть только положительными. Это значит что не нужно тратить память на хранение отрицательных.</p>

  <h4>Тип данных unsigned long long</h4>
  <code>от 0 до 2<sup>64</sup>-1</code>

  <h4>Тип данных short</h4>
  <p>Если типа int слишком много. Например, массив на миллион значений типа int занимает 4mb. То можно использовать тип данных short, который занимает 2 байта и имеет значения</p>
  <code>от -2<sup>15</sup> до 2<sup>15</sup>-1</code>
  <code>примерно от -32000 до 32000</code>

  <h4>Проблема остатка от деления отрицательного числа</h4>
  <p>5 % 3 должно быть равно 2</p>

  <details>
    <summary>Остаток от деления положительного числа</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a, mod;
  cin &gt;&gt; a &gt;&gt; mod;
  cout &lt;&lt; a % mod;
}
</pre>
  </details>

  <p>-5 % 3 математически должно быть равно 1, но программа выдаст ответ -2. Чтобы получить правильный результат, надо к ответу прибавить 3</p>

  <details>
    <summary>Остаток от деления отрицательнгого числа</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a, mod;
  cin &gt;&gt; a &gt;&gt; mod;
  cout &lt;&lt; (a % mod) + mod;
}
</pre>
  </details>

  <p>Но если для положительного числа прибавить mod, то ответ может быть больше чем mod. Чтобы привести его к правильному виду нужно еще раз взять остаток от деления</p>

  <details>
    <summary>Остаток от деления общий случай для положительного и отрицательнгого числа</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a, mod;
  cin &gt;&gt; a &gt;&gt; mod;
  cout &lt;&lt; ((a % mod) + mod) % mod;
}
</pre>
  </details>

  <h4>Переполнение и остаток по модулю</h4>
  <p>Из-за того что при прибавлении 1 к максимальному числу мы получаем минимальное, получается что мы сидим в числах по модулю 2<sup>32</sup> и смещенных на 2<sup>32</sup> для отрицательных чисел</p>

  <details>
    <summary>Задача 1. Произведение чисел</summary>
    <h4>Произведение чисел</h4>
    <p>В этой задаче требуется найти произведение двух целых чисел</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат два целых числа a,b (-10<sup>9</sup>&le;a,b&le;10<sup>9</sup>)</p>
    <h4>Выходные данные</h4>
    <p>В ответ напишите произведение данных чисел</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  long long a, b;
  cin &gt;&gt; a &gt;&gt; b;
  cout &lt;&lt; a * b;
}
</pre>
  </details>

  <details>
    <summary>Задача 2. Сумма чисел</summary>
    <h4>Сумма чисел</h4>
    <p>В этой задаче необходимо найти сумму двух целых чисел</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат два целых числа a,b (0&le;a,b&le;9*10<sup>18</sup>)</p>
    <h4>Выходные данные</h4>
    <p>В ответ напишите сумму данных чисел</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  unsigned long long a, b;
  cin &gt;&gt; a &gt;&gt; b;
  cout &lt;&lt; a + b;
}
</pre>
  </details>

  <details>
    <summary>Задача 3. Остаток от деления</summary>
    <h4>Остаток от деления</h4>
    <p>В этой задаче требуется найти остаток от деления числа a на число b</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат два целых числа a,b (-10<sup>18</sup>&le;a&le;10<sup>18</sup>; 0&le;b&le;10<sup>18</sup>)</p>
    <h4>Выходные данные</h4>
    <p>Выведите остаток от деления a на b</p>
    <h4>Примечание</h4>
    <p>В этой задаче запрещено использовать условный оператор</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  long long a, b;
  cin &gt;&gt; a &gt;&gt; b;
  cout &lt;&lt; (a % b + b) % b;
}
</pre>
  </details>

  <details>
    <summary>Задача 4. Последняя цифра</summary>
    <h4>Последняя цифра</h4>
    <p>В этой задаче требуется найти последнюю цифру данного числа</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат единственное неотрицательное число, по модулю не превосходящее 10<sup>18</sup></p>
    <h4>Выходные данные</h4>
    <p>Найдите последнюю цифру данного числа</p>
    <h4>Примечание</h4>
    <p>В этой задаче запрещено использовать условный оператор</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  long long a;
  cin &gt;&gt; a;
  cout &lt;&lt; a % 10;
}
</pre>
  </details>

  <details>
    <summary>Задача 5. Перестановка разрядов</summary>
    <h4>Перестановка разрядов</h4>
    <p>Дано четырехзначное отрицательное число. Требуется поменять местами число десятков и сотен в нем</p>
    <h4>Входные данные</h4>
    <p>Во входных данных записано единственное четырехзначное отрицательное целое число. Унарный минус не считается знаком</p>
    <h4>Выходные данные</h4>
    <p>Найдите число, полученное из исходного перестановкой числа десятков и сотен в нем</p>
    <h4>Примечание</h4>
    <p>В этой задаче запрещено использовать тип данных char</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  long long a;
  cin &gt;&gt; a;
  int a1 = a % 10;
  int a2 = (a / 10) % 10;
  int a3 = (a / 100) % 10;
  int a4 = (a / 1000) % 10;
  cout &lt;&lt; a4 * 1000 + a2 * 100 + a3 *10 + a1;
}
</pre>
  </details>
</article>


<!-- 1.3 Локальный запуск -->
<article class="article">
  <div class="anchor" id="p1.3"></div>
  <h3>1.3 Локальный запуск</h3>

  <p>Существует много разных сред разработки, позволяющих компилировать и запускать программы. Среди них можно выделить Code Blocks, Visual Studio или напрямую компилирование из консоли для продвинутых. Мы расскажем как работать в Code Blocks. У него есть ряд преимуществ. Он кроссплатформенный, в нем простой интерфейс, встроенный компилятор MinGW. Скачать его можно с оффициального сайта</p>
  <code><a href="https://www.codeblocks.org/downloads/">https://www.codeblocks.org/downloads/</a></code>
  <p>Выбирайте вариант</p>
  <code>codeblocks-20.03mingw-setup.exe</code>
  <p>Предположим вы скачали, установили и запустили CodeBlocks. Вам необходимо создать файл, в котором будете писать код. Для этого в верхнем левом углу есть иконка создать новый файл или пункт меню</p>
  <code>File - New - Empty file (Ctrl+Shift+N)</code>
  <p>Теперь сохраните этот файл. Выберете где он будет располагатья, его имя и в расширении напишите cpp. Это расширение для файлов, написанных на языке C++</p>

  <details>
    <summary>Сумма двух чисел</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a, b;
  cin &gt;&gt; a &gt;&gt; b;
  cout &lt;&lt; a + b;
}
</pre>
  </details>

  <p>На панели с иконками найдите три кнопки "Скомпилировать", "Запустить", "Скомпилировать и запустить". Нажмите "Скомпилировать и запустить". Или выберете пункт меню</p>
  <code>Build - Build and run (F9)</code>
  <p>Можно создать еще один файл. Он откроется в соседней вкладке. И в нем решать вторую задачу. Компилироваться и запускаться будет та программа в открытой вкладке</p>

  <h4>Задача. Создать файл и запустить код</h4>
  <p>Локально на своем компьютере создайте файл stepik_run.cpp, скопируйте в него следующий код и запустите.</p>

  <details>
    <summary>файл stepik_run.cpp</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main(int argc, char *argv[]) {
  cout &lt;&lt; argv[0] &lt;&lt; endl;
  return 0;
}
</pre>
  <code>D:\code\cpp\stepik_run.exe</code>
  </details>

  <p>Вывод программы отправьте в качестве ответа. Обратите внимание - иногда программа выводит дополнительную информацию в духе время работы программы или сообщение, что программа завершилась успешно. Нас это не интересует, ответом является только первая строчка вывода.</p>
</article>


<!-- 1.4 Символьный тип данных -->
<article class="article">
  <div class="anchor" id="p1.4"></div>
  <h3>1.4 Символьный тип данных</h3>

  <p>Символьный тип данных позволяет хранить один символ. Тип char хранит цифры, английские буквы маленькие и большие и большинство символов с клавиатуры. В олимпиадном программировании русские буквы хранить не нужно.</p>
  <p>Каждый символ имеет свой номер. Хранятся не сами символы, а их номера. Когда нужно вывести символ на экран, компьютер берет этот номер и смотрит в специальную таблицу символов и выводит соответствующий символ. Из-за того что хранятся числа, то с символьным типом можно обращаться так же как с целыми числами - прибавлять к ним числа или складывать их между собой.</p>

  <h4>Таблица ASCII</h4>
  <p>Первые 32 символа (с 0 до 31) заняты под служебные.</p>
  <p>Из них в олимпиадном программировании используются 3 символа - 10 (перевод строки), 9 (табуляция) и 4 (конец файла)</p>
  <p>Наиболее полезный 10 символ - символ перевода строки '\n'. Именно он выводится когда мы пишем</p>
  <code>cout &lt;&lt; endl;</code>
  <p>Но есть и отличия. endl переводит строку и сбрасывает буфер. Компьютер не сразу печатает то что вы ему сказали вывести на экран. А предварительно сохраняет ваш вывод в специальную область памяти - буфер.Компьютер сам выводит данные из буфера, когда он наполняется. Выводить данные большими кусками выгоднее чем маленькими, поскольку вывод на экран это ресурсоемкая операция, а компьютер старается ресурсы экономить.</p>
  <p>Сброс буфера это тоже ресурсоемкая задача. Поэтому иногда полезно вместо endl выводить символ '\n'</p>
  <p>Символ табуляции - 9 символ используется редко</p>
  <p>Иногда используется символ конца файла - 4 символ</p>
  <p>Следующие 10 символов (с 32 по 47) содержат специальные знаки (пробел, плюс, минус и т.д.)</p>
  <p>Следующие 16 символов (с 48 по 57) это цифры</p>
  <p>Следующие 7 символов (с 58 по 64) еще немного знаков (больше, меньше, равно)</p>
  <p>Следующие 26 символов (с 65 по 90) это большие английские буквы
  </p>
  <p>Следующие 6 символов (с 91 по 96) еще немного знаков</p>
  <p>Следующие 26 символов (с 97 по 122) это маленькие английские буквы</p>
  <p>И наконец, последние 5 символов (с 123 по 127) еще немного знаков</p>

  <h4>Тип данных char</h4>
  <p>Тип данных char занимает 1 байт памяти и может содержать 256 значений. Мы рассмотрели первые 127. Вторая часть таблицы отведена под локализованные символы.</p>
  <p>Объявим две переменные типа char и считаем в них символы</p>
  <code>char a, b;</code>
  <code>cin &gt;&gt; a &gt;&gt; b;</code>
  <p>Считается первый не пробельный символ. Это значит что символы "пробел", "табуляция" и "перевод строки" не будут считаны.</p>
  <p>Можно одновременно считывать и цифры и символы</p>
  <code>char a, b; int c; cin &gt;&gt; a &gt;&gt; c &gt;&gt; b;</code>
  <code>Input: 1234!?</code>
  <code>a = 1; b = 234, c = !</code>

  <details>
    <summary>Задача 1. Символ по номеру</summary>
    <h4>Символ по номеру</h4>
    <p>В этой задаче вам по числу необходимо вывести соответствующий ему в ASCII таблице символ</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат единственное целое число a (32 &le;a&le;126)</p>
    <h4>Выходные данные</h4>
    <p>Выведите символ, соответствующий этому числу.</p>

    <h4>Пример 1</h4>
    <code>Input: 100</code>
    <code>Output: d</code>

    <h4>Пример 2</h4>
    <code>Input: 36</code>
    <code>Output: $</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a;
  cin &gt;&gt; a;
  cout &lt;&lt; char(a) &lt;&lt; endl;
  return 0;
}
</pre>
  </details>

  <details>
    <summary>Задача 2. Номер по символу</summary>
    <h4>Номер по символу</h4>
    <p>Найдите порядковый номер данного символа в ASCII-таблице</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат единственный непробельный символ, номер которого не меньше 33 и не больше 126.</p>
    <h4>Выходные данные</h4>
    <p>Найдите номер этого символа</p>

    <h4>Пример 1</h4>
    <code>Input: d</code>
    <code>Output: 100</code>

    <h4>Пример 2</h4>
    <code>Input: $</code>
    <code>Output: 36</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  char a;
  cin &gt;&gt; a;
  cout &lt;&lt; int(a) &lt;&lt; endl;
  return 0;
}
</pre>
  </details>

  <details>
    <summary>Задача 3. i-й символ алфавита</summary>
    <h4>i-й символ алфавита</h4>
    <p>В этой задаче вам дано число i, требуется найти i-й символ алфавита</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат единственное целое число i (1&le;i&le;26)</p>
    <h4>Выходные данные</h4>
    <p>Выведите i-й маленький символ латинского алфавита.</p>

    <h4>Пример 1</h4>
    <code>Input: 1</code>
    <code>Output: a</code>

    <h4>Пример 2</h4>
    <code>Input: 12</code>
    <code>Output: l</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int i;
  cin &gt;&gt; i;
  cout &lt;&lt; char(96+i) &lt;&lt; endl;
  return 0;
}
</pre>
  </details>

  <details>
    <summary>Задача 4. Сделать большой</summary>
    <h4>Сделать большой</h4>
    <p>В этой задаче требуется перевести букву из нижнего регистра в верхний</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат единственный маленький символ латинского алфавита</p>
    <h4>Выходные данные</h4>
    <p>Выведите соответствующий большой символ латинского алфавита</p>

    <h4>Пример 1</h4>
    <code>Input: a</code>
    <code>Output: A</code>

    <h4>Пример 2</h4>
    <code>Input: m</code>
    <code>Output: M</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  char a;
  cin &gt;&gt; a;
  cout &lt;&lt; char(a-32) &lt;&lt; endl;
  return 0;
}
</pre>
  </details>

  <details>
    <summary>Задача 5. Первая цифра числа</summary>
    <h4>Первая цифра числа</h4>
    <p>Выпишите первую цифру данного числа</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат единственное целое число a (0&le;a&le;10<sup>100</sup>)</p>
    <h4>Выходные данные</h4>
    <p>В ответ запишите первую цифру введенного числа</p>

    <h4>Пример 1</h4>
    <code>Input: 93099339395097728908</code>
    <code>Output: 9</code>

    <h4>Пример 2</h4>
    <code>Input: 560</code>
    <code>Output: 5</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  char a;
  cin &gt;&gt; a;
  cout &lt;&lt; a &lt;&lt; endl;
  return 0;
}
</pre>
  </details>
</article>


<!-- 1.5 Типы данных с плавающей точкой -->
<article class="article">
  <div class="anchor" id="p1.5"></div>
  <h3>1.5 Типы данных с плавающей точкой</h3>

  <p>Всего есть три типа для работы с дробными числами.</p>
  <p>float 4 байта</p>
  <p>double 8 байт</p>
  <p>long double 16 байт</p>
  <p>Не все дробные числа можно записать в память. С одной стороны, даже между 0 и 1 находится бесконечно много дробных чисел. С другой стороны, иррациональные числа, которые нельзя записать никакой конечной десятичной дробью. Примеры иррациональных чисел "число пи", "корень из двойки", "два в степени корень из двойки". Для их записи в десятичном виде потребуется бесконечно много знаков. Поэтому хранить все дробные числа невозможно и компьютер хранит дробные числа с некоторой погрешностью.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  double a = 3.14, b;
  cin &gt;&gt; b;
  cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; endl;
  return 0;
}
</pre>
  <p>Арифметическите операции такие же как с целыми числами, но есть два отличия.</p>
  <p>При делении дробных чисел получается дробное число. Настолько точное насколько позволяет тип данных. В отличие от целых чисел, где при делении получается целое число, а дробная часть отбрасывается</p>
  <p>Нельзя взять остаток от деления</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  double a, b;
  cin &gt;&gt; a &gt;&gt; b;
  cout &lt;&lt; a / b &lt;&lt; endl;
  return 0;
}
</pre>
  <p>По умолчанию компьютер выводит дробные числа так как ему удобно. Но мы можем задать формат вывода двумя строчками вначале программы</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  cout.setf(ios::fixed);
  cout.precision(10);

  double a, b;
  cin &gt;&gt; a &gt;&gt; b;
  cout &lt;&lt; a / b &lt;&lt; endl;
  return 0;
}
</pre>

  <h4>Экспоненциальная запись</h4>
  <code>1e-6</code>
  <p>Так удобно записывать большие степени 10. В общем случае запись MeP означает: M - мантиса, e - экспоненциальная запись, P - порядок</p>
  <code>MeP = M*10<sup>P</sup></code>
  <code>1e-6 = 1*10<sup>-6</sup> = 0.000001</code>

  <h4>Разница в погрешностях</h4>
  <p>Напишем три программы для трех типов данных</p>
  <p>Подадим на вход число 10<sup>16</sup> + 2 = 10000000000000002</p>
  <p>Посмотрим как погрешность в представлении чисел влияет на результат</p>

<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  float a;
  cin &gt;&gt; a;
  cout &lt;&lt; a + 1 &lt;&lt; endl;
  return 0;
}
</pre>
  <code>Output: 10000000272564224</code>

<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  double a;
  cin &gt;&gt; a;
  cout &lt;&lt; a + 1 &lt;&lt; endl;
  return 0;
}
</pre>
  <code>Output: 10000000000000004</code>

<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  long double a;
  cin &gt;&gt; a;
  cout &lt;&lt; a + 1 &lt;&lt; endl;
  return 0;
}
</pre>
  <code>Output: 10000000000000003</code>

  <details>
    <summary>Задача 1. Пи</summary>
    <h4>Пи</h4>
    <p>В этой задаче вам требуется вывести число π с заданной точностью</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат число n (0&le;n&le;15) - количество знаков после запятой, которое необходимо вывести</p>
    <h4>Выходные данные</h4>
    <p>Выведите число π с заданной точностью</p>

    <h4>Пример 1</h4>
    <code>Input: 2</code>
    <code>Output: 3.14</code>

    <h4>Пример 2</h4>
    <code>Input: 0</code>
    <code>Output: 3</code>
<pre>
#include &lt;iostream&gt;
#include &lt;cmath&gt;

using namespace std;

int main() {
  int a;
  cin &gt;&gt; a;
  cout.setf(ios::fixed);
  cout.precision(a);
  cout &lt;&lt; M_PI &lt;&lt; endl;

  return 0;
}
</pre>
  </details>

  <details>
    <summary>Задача 2. Деление</summary>
    <h4>Деление</h4>
    <p>В этой задаче надо поделить два числа</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат два целых числа a,b (-10<sup>9</sup>&lt;a,b&lt;10<sup>9</sup>; b&ne;0)</p>
    <h4>Выходные данные</h4>
    <p>Выведите результат деления a/b. Ответ будет считаться верным, если абсолютная или относительная погрешность не больше 10<sup>-6</sup></p>

    <h4>Пример 1</h4>
    <code>10 8</code>
    <code>1.2500000000</code>

    <h4>Пример 2</h4>
    <code>1 3</code>
    <code>0.3333333333</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  cout.setf(ios::fixed);
  cout.precision(10);
  double a, b;
  cin &gt;&gt; a &gt;&gt; b;
  cout &lt;&lt; a / b &lt;&lt; endl;

  return 0;
}
</pre>
  </details>

  <details>
    <summary>Задача 3. Почти целое деление</summary>
    <h4>Почти целое деление</h4>
    <p>В этой задаче требуется поделить два числа, а результат округлить до целых по правилам округления в текущей версии языка C++</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат два целых числа a,b (-10<sup>9</sup>&le;a,b&le;10<sup>9</sup>;b&ne;0)</p>
    <h4>Выходные данные</h4>
    <p>Выведите результат деления a/b, округленный до ближайшего целого числа.</p>
    <h4>Примечание</h4>
    <p>В этой задаче запрещено пользоваться условным оператором.</p>

    <h4>Пример 1</h4>
    <code>10 6</code>
    <code>2</code>

    <h4>Пример 2</h4>
    <code>1 3</code>
    <code>0</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  cout.setf(ios::fixed);
  cout.precision(0);
  double a, b;
  cin &gt;&gt; a &gt;&gt; b;
  cout &lt;&lt; a / b &lt;&lt; endl;

  return 0;
}
</pre>
  </details>

  <details>
    <summary>Задача 4. float неточный</summary>
    <h4>float неточный</h4>
    <p>В этой задаче требуется найти разницу между значением целого числа, сохраненного в типе данных float и его реальным значением.</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат единственное целое число, по модулю не превосходящее 10<sup>18</sup></p>
    <h4>Выходные данные</h4>
    <p>Необходимо вывести разницу между значением числа, если его сохранить в тип данных float и его реальным значением. Для более точного понимания условия смотрите примеры.</p>
    <h4>Примечание</h4>
    <p>На разных компьютерах в данном случае поведение вашей программы может отличаться. </p>

    <h4>Пример 1</h4>
    <code>10000000000000003</code>
    <code>272564221</code>

    <h4>Пример 2</h4>
    <code>20000001</code>
    <code>-1</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  long long a;
  float b;
  cin &gt;&gt; a;
  b = float(a);
  cout &lt;&lt; (long long)(b) - a &lt;&lt; endl;

  return 0;
}
</pre>
  </details>
</article>


<!-- 1.6 Логический тип данных -->
<article class="article">
  <div class="anchor" id="p1.6"></div>
  <h3>1.6 Логический тип данных</h3>

  <p>Числа можно сравнивать. Знаки сравнения ==, !=, &lt;, &gt;, &lt;=, &gt;=. Операции сравнения возвращают значение типа bool и могут принимать только два значения 1 - истина, 2 - ложь.</p>
  <code>bool a = (1 &lt; 2); // 1</code>
  <code>bool b = (2 + 2 == 5); // 0</code>
  <p>Тип bool занимает 1 байт памяти. Каждый байт памяти имеет свой адрес. Поэтому быстрее обратиться к любому байту в памяти, чем к любому биту. Под переменную в памяти отводится нужное число байт, чтобы к ней можно было быстро обратиться.</p>
  <p>Существует возможность обратиться к отдельным битам переменной. Но об этом поговорим подробней в 5 модуле.</p>
  <p>Считаем с клавиатуры переменную логического типа</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  bool a;
  cin &gt;&gt; a;
  cout &lt;&lt; a &lt;&lt; endl;

  return 0;
}
</pre>
  <p>Если ввести 0, то в переменной будет 0. Если ввести любое другое число, то в переменной будет 1.</p>
  <p>Вместо 1 и 0 можно писать true и false</p>
  <code>bool a = true; // 1</code>
  <code>bool a = false; // 0</code>
  <p>Арифметические операции с логическими данными всегда оперируют 1 и 0</p>
  <p>cout выводит на экран логические 1 и 0, а не true и false</p>
  <code>cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; endl;</code>

  <details>
    <summary>Задача 1. Равно нулю?</summary>
    <h4>Равно нулю?</h4>
    <p>В этой задаче требуется проверить, что число не равно нулю</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат единственное целое число, по модулю не превосходящее 10<sup>9</sup></p>
    <h4>Выходные данные</h4>
    <p>Выведите 1, если число не равно 0 и 0 иначе</p>
    <h4>Примечание</h4>
    <p>В этой задаче запрещено использовать условный оператор</p>

    <h4>Пример 1</h4>
    <code>10</code>
    <code>1</code>

    <h4>Пример 2</h4>
    <code>-1000000000</code>
    <code>1</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  bool a;
  cin &gt;&gt; a;
  cout &lt;&lt; a &lt;&lt; endl;

  return 0;
}
</pre>
  </details>

  <details>
    <summary>Задача 2. Больше?</summary>
    <h4>Больше?</h4>
    <p>В этой задаче вам необходимо сравнить два числа.</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат два целых числа a,b (-10<sup>9</sup>&le;a,b&le;10<sup>9</sup>)</p>
    <h4>Выходные данные</h4>
    <p>Выведите 1, если a &lt; b и 0 иначе</p>
    <h4>Примечание</h4>
    <p>В этой задаче запрещено использовать условный оператор</p>

    <h4>Пример 1</h4>
    <code>1 4</code>
    <code>1</code>

    <h4>Пример 2</h4>
    <code>2 -2</code>
    <code>0</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a, b;
  cin &gt;&gt; a &gt;&gt; b;
  cout &lt;&lt; (a &lt; b) &lt;&lt; endl;

  return 0;
}
</pre>
  </details>

  <details>
    <summary>Задача 3. Сколько четных?</summary>
    <h4>Сколько четных?</h4>
    <p>В этой задаче вам требуется найти количество четных чисел среди данных пяти.</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат 5 целых чисел, каждое по модулю не превосходит 10<sup>9</sup></p>
    <h4>Выходные данные</h4>
    <p>Единственное число - количество четных чисел среди данных.</p>
    <h4>Примечание</h4>
    <p>В этой задаче запрещено использовать условный оператор.</p>

    <h4>Пример 1</h4>
    <code>1 2 3 4 5</code>
    <code>2</code>

    <h4>Пример 2</h4>
    <code>1 2 1 2 1</code>
    <code>2</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a, b, c, d, e, count;
  cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e;
  count = (a%2 == 0) + (b%2 == 0) + (c%2 == 0) + (d%2 == 0) + (e%2 == 0);
  cout &lt;&lt; count &lt;&lt; endl;

  return 0;
}
</pre>
  </details>

  <details>
    <summary>Задача 4. Сколько больших нуля?</summary>
    <h4>Сколько больших нуля?</h4>
    <p>В этой задаче требуется найти количество чисел, больших нуля среди данных пяти</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат 5 целых чисел, каждое по модулю не превосходит 10<sup>9</sup></p>
    <h4>Выходные данные</h4>
    <p>Единственное число - количество положительных чисел среди данных</p>
    <h4>Примечание</h4>
    <p>В этой задаче запрещено использовать условный оператор.</p>

    <h4>Пример 1</h4>
    <code>1 2 3 4 5</code>
    <code>5</code>

    <h4>Пример 2</h4>
    <code>-2 -1 0 1 2</code>
    <code>2</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a, b, c, d, e, count;
  cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e;
  count = (a &gt; 0) + (b &gt; 0) + (c &gt; 0) + (d &gt; 0) + (e &gt; 0);
  cout &lt;&lt; count &lt;&lt; endl;

  return 0;
}
</pre>
  </details>
</article>


<!-- 1.7 Итоговое тестирование -->
<article class="article">
  <div class="anchor" id="p1.7"></div>
  <h3>1.7 Итоговое тестирование</h3>

  <details>
    <summary>Задача 1. Сумма чисел</summary>
    <h4>Сумма чисел</h4>
    <p>В этой задаче необходимо найти сумму четырех целых чисел</p>
    <h4>Входные данные</h4>
    <p>Во входных данных записано 4 целых числа, каждое по модулю не превышает 10<sup>9</sup></p>
    <h4>Выходные данные</h4>
    <p>В ответ запишите их сумму</p>

    <h4>Пример 1</h4>
    <code>1 2 3 4</code>
    <code>10</code>

    <h4>Пример 2</h4>
    <code>1 -1 2 -2</code>
    <code>0</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  long long a, b, c, d;
  cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
  cout &lt;&lt; a + b + c + d &lt;&lt; endl;

  return 0;
}
</pre>
  </details>

  <details>
    <summary>Задача 2. Метеоритный дождь</summary>
    <h4>Метеоритный дождь</h4>
    <p>Эта задача была взята из муниципального этапа всероссийской олимпиады школьников по информатике в Майкопе.</p>
    <p>В солнечный декабрьский зимний день ничего не предвещало беды. Так думала и команда, которая решила написать очередной контест. Для написания контеста организатор подготовил несколько компьютеров. Все они пронумерованы числами от 1 до 113. Однако, когда команда пришла к началу контеста, случилось так, что почти все компьютеры были заняты - все, кроме 4-х. Команде нужно было быстро выбрать компьютер, и она уже начала справляться со сложной проблемой выбора, как вдруг по радио объявили, что сегодня будет метеоритный дождь. Причём достоверно известно, что на три из четырёх свободных компьютеров упадёт по метеориту. Так как команда не хочет быть раздавленной метеоритом, ей необходимо выбрать безопасный компьютер. Однако выбор - сложный и долгий процесс, а команда хочет хорошо выступить, поэтому им нельзя терять время ещё на один поиск. Помогите им!</p>
    <h4>Входные данные</h4>
    <p>В первой строке вам даны 4 числа - номера свободных компьютеров. Все они - различные целые числа, не превосходящие 113</p>
    <p>Во второй строке вам даны 3 числа - номера компьютеров, на которые упадёт метеорит. Гарантируется, что эти номера различны и что все соответствующие компьютеры свободны.</p>
    <h4>Выходные данные</h4>
    <p>Выведите единственное число - номер компьютера, который следует выбрать команде</p>

    <h4>Пример 1</h4>
    <code>2 6 7 9, 2 7 9</code>
    <code>Output: 6</code>

    <h4>Пример 2</h4>
    <code>6 7 8 9, 6 7 9</code>
    <code>Output: 8</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a, b, c, d, a1, b1, c1;
  cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
  cin &gt;&gt; a1 &gt;&gt; b1 &gt;&gt; c1;
  cout &lt;&lt; a + b + c + d - a1 - b1 - c1 &lt;&lt; endl;

  return 0;
}
</pre>
  </details>

  <details>
    <summary>Задача 3. Квадратное уравнение</summary>
    <h4>Квадратное уравнение</h4>
    <p>В этой задаче вам необходимо решить квадратное уравнение</p>
    <h4>Входные данные</h4>
    <p>Во входных данных записано три целых числа a,b,c (-10<sup>2</sup>&le;a,b,c&le;10<sup>2</sup>; a &ne; 0), коэффициенты квадратного уравнения a⋅x<sup>2</sup> + b⋅x + c = 0. Гарантируется, что решение существует</p>
    <h4>Выходные данные</h4>
    <p>Выведите корень данного квадратного уравнения. Если корней несколько, выведите любой. Ответ будет считаться верным, если абсолютная или относительная погрешность не превосходит 10<sup>-4</sup></p>

    <h4>Пример 1</h4>
    <code>1 -2 0</code>
    <code>Output: 2.000000</code>

    <h4>Пример 2</h4>
    <code>1 0 -4</code>
    <code>Output: 2.000000</code>
<pre>
#include &lt;iostream&gt;
#include &lt;cmath&gt;

using namespace std;

int main() {
  long double a, b, c;
  cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
  long double d = b*b-4*a*c;
  double f = sqrt(d);
  cout &lt;&lt; (-b+f)/(2*a) &lt;&lt; endl;

  return 0;
}
</pre>
  </details>

  <details>
    <summary>Задача 4. Инверсии</summary>
    <h4>Инверсии</h4>

    <p>Инверсией в последовательности чисел называется такая пара чисел, что в ней большее число идет раньше меньшего. Вам дана последовательность из 4 чисел, необходимо найти количество инверсий в ней</p>

    <h4>Входные данные</h4>
    <p>Входные данные содержат 4 целых числа, каждое по модулю не превосходит 10<sup>9</sup></p>

    <h4>Выходные данные</h4>
    <p>Количество инверсий в данной последовательности.</p>

    <h4>Пример 1</h4>
    <code>1 4 2 3</code>
    <code>Output: 2</code>

    <h4>Пример 2</h4>
    <code>4 3 2 1</code>
    <code>Output: 6</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a, b, c, d, result;
  cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
  result = (c > d) + (b > c) + (b > d) + (a > b) + (a > c) + (a > d);
  cout &lt;&lt; result &lt;&lt; endl;

  return 0;
}
</pre>
  </details>
</article>


<!-- 2 Условные операторы и циклы -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>2 Условные операторы и циклы</h3>
</article>


<!-- 2.1 Логические операции -->
<article class="article">
  <div class="anchor" id="p2.1"></div>
  <h3>2.1 Логические операции</h3>

  <h4>Приоритет операций</h4>

  <p>1. ()</p>
  <p>2. !</p>
  <p>3. *, /, %</p>
  <p>4. +, -</p>
  <p>5. &lt;, &gt;, &lt;=, &gt;=</p>
  <p>6. ==, !=</p>
  <p>7. &&</p>
  <p>8. ||</p>
  <p>9. =</p>

  <h4>Законы де Моргана</h4>

  <p>Логическое И возвращает 1 только если обе переменные 1. Логическое ИЛИ возвращает 0 только если обе переменные 0</p>
  <code>!(A&&B) == !A||!B</code>
  <code>!(A||B) == !A&&!B</code>
  <p>Отрицание дизъюнкции есть конъюнкция отрицаний. Отрицание конъюнкции есть дизъюнкция отрицаний</p>


  <details>
    <summary>Задача 1. Сравнение с 0</summary>
    <h4>Сравнение с 0</h4>
    <p>В этой задаче необходимо опять сравнить данное число с 0.</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат единственное целое число, по модулю не превосходящее 10<sup>9</sup></p>
    <h4>Выходные данные</h4>
    <p>Выведите 1, если значение переменной равно 0, и 0 иначе</p>
    <h4>Примечание</h4>
    <p>В этой задаче запрещено пользоваться условным оператором</p>

    <h4>Пример 1</h4>
    <code>0</code>
    <code>Output: 1</code>

    <h4>Пример 2</h4>
    <code>-10</code>
    <code>Output: 0</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  bool a;
  cin &gt;&gt; a;
  cout &lt;&lt; !a &lt;&lt; endl;

  return 0;
}
</pre>
  </details>


  <details>
    <summary>Задача 2. Таблица истинности</summary>
    <h4>Таблица истинности</h4>
    <p>Дмитрию на уроке по информатике задали построить таблицу истинности следующего выражения: a ИЛИ !a ИЛИ b И (c ИЛИ b И !a). К сожалению, Дмитрий слишком ленив, чтобы самому ее строить, поэтому он попросил вас ему помочь. Для данных a, b, c определите значение выражения</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат три целых числа a,b,c (0&le;a,b,c&le;1)</p>
    <h4>Выходные данные</h4>
    <p>Выведите число 0 или 1 - значение выражения при данных переменных a,b,c</p>
    <h4>Примечание</h4>
    <p>В этой задаче запрещено пользоваться условным оператором.</p>

    <h4>Пример 1</h4>
    <code>1 0 1</code>
    <code>Output: 1</code>

    <h4>Пример 2</h4>
    <code>0 1 1</code>
    <code>Output: 1</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a, b, c;
  cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
  bool result = a || !a || b && (c || b && !a);
  cout &lt;&lt; result &lt;&lt; endl;

  return 0;
}
</pre>
  </details>


  <details>
    <summary>Задача 3. Еще одна таблица истинности</summary>
    <h4>Еще одна таблица истинности</h4>
    <p>Владислав - старший брат Дмитрия, и иногда помогает ему с домашками по информатике. Сейчас Дмитрий принес ему очередное логическое выражение, и просит построить его таблицу истинности. Владислав прознал, что вы владеете программой, которая умеет считать подобные выражения, поэтому просит вас ему помочь. Напишите программу, которая по данным значениям переменных посчитает значения выражения. Кстати, вот оно (!(!a И b ИЛИ c) ИЛИ (b ИЛИ !a)) И ((!c И !b) И !(b ИЛИ !a ИЛИ c))</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат три целых числа a,b,c (0&le;a,b,c&le;1)</p>
    <h4>Выходные данные</h4>
    <p>Выведите число 0 или 1 - значение выражения при данных переменных a,b,c</p>
    <h4>Примечание</h4>
    <p>В этой задаче запрещено пользоваться условным оператором.</p>

    <h4>Пример 1</h4>
    <code>1 0 1</code>
    <code>Output: 0</code>

    <h4>Пример 2</h4>
    <code>0 1 1</code>
    <code>Output: 0</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a, b, c;
  cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
  bool result = (!(!a && b || c) || (b || !a)) && ((!c && !b) && !(b || !a || c));
  cout &lt;&lt; result &lt;&lt; endl;

  return 0;
}
</pre>
  </details>


  <details>
    <summary>Задача 4. Азартные игры</summary>
    <h4>Азартные игры</h4>
    <p>Ярополк и Ярослав играют в азартную игру - они кидают по два кубика, на каждой грани которых написано число от 1 до 6. Правила игры таковы, что Ярослав побеждает, если каждое число на его кубиках больше, чем каждое число на кубиках Ярополка. Иначе побеждает Ярополк. Вам необходимо определить, кто выиграл.</p>
    <h4>Входные данные</h4>
    <p>В первой строке входных данных записано два числа, каждое от 1 до 6 - числа, выпавшие на кубиках Ярополка.</p>
    <p>Во второй строке в аналогичном формате записаны два числа, выпавшие на кубиках Ярослава.</p>
    <h4>Выходные данные</h4>
    <p>Выведите 1, если выиграл Ярополк. Иначе выведите 0.</p>
    <h4>Примечание</h4>
    <p>В этой задаче запрещено пользоваться условным оператором.</p>

    <h4>Пример 1</h4>
    <code>2 2</code>
    <code>3 4</code>
    <code>Output: 0</code>

    <h4>Пример 2</h4>
    <code>1 5</code>
    <code>4 6</code>
    <code>Output: 1</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a1, a2, b1, b2;
  cin &gt;&gt; a1 &gt;&gt; a2 &gt;&gt; b1 &gt;&gt; b2;
  bool result = !((b1 > a1) && (b1 > a2) && (b2 > a1) && (b2 > a2));
  cout &lt;&lt; result &lt;&lt; endl;

  return 0;
}
</pre>
  </details>


  <details>
    <summary>Задача 5. Сколько различных?</summary>
    <h4>Сколько различных?</h4>
    <p>В этой задаче требуется определить, сколько различных чисел среди данных четырех?</p>
    <h4>Входные данные</h4>
    <p>Выведите единственное число - сколько различных чисел в данном множестве.</p>
    <h4>Примечание</h4>
    <p>В этой задаче запрещено пользоваться условным оператором.</p>

    <h4>Пример 1</h4>
    <code>1 2 3 4</code>
    <code>Output: 4</code>

    <h4>Пример 2</h4>
    <code>1 2 1 2</code>
    <code>Output: 2</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a, b, c, d;
  cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
  int count = 4;
  count -= (a == b) || (a == c) || (a == d);
  count -= (b == c) || (b == d);
  count -= (c == d);
  cout &lt;&lt; count &lt;&lt; endl;

  return 0;
}
</pre>
  </details>
</article>


<!-- 2.2 Условный оператор -->
<article class="article">
  <div class="anchor" id="p2.2"></div>
  <h3>2.2 Условный оператор</h3>

  <p>Проверим что число четное</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a;
  cin &gt;&gt; a;
  if (a % 2 != 0) {
    cout &lt;&lt; "odd" &lt;&lt; endl;
  } else {
    cout &lt;&lt; "even" &lt;&lt; endl;
  }

  return 0;
}
</pre>

  <p>Подумайте что делает эта программа</p>

<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a, b;
  cin &gt;&gt; a &gt;&gt; b;
  int c = a / b;
  if (a % b != 0) {
    c = c + 1;
  }

  cout &lt;&lt; c &lt;&lt; endl;

  return 0;
}
</pre>

  <p>Она округляет результат деления к ближайшему целому вверх</p>
  <p>Можно сделать вложенные условия с оператором if. Вложенность ничем е ограничена. Но размер кода, который можно послать в систему ограничен 64 килобайтами</p>


  <details>
    <summary>Задача 1. FTarlusee</summary>
    <h4>FTarlusee</h4>
    <p>В этой задаче вам требуется вывести строковое представление булевой переменной</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат единственное целое неотрицательное число, не превосходящее единицы - значение булевой переменной</p>
    <h4>Выходные данные</h4>
    <p>Выведите "True" (без кавычек), если переменная хранит истину, иначе выведите "False" (без кавычек)</p>

    <h4>Пример 1</h4>
    <code>0</code>
    <code>Output: False</code>

    <h4>Пример 2</h4>
    <code>1</code>
    <code>Output: True</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  bool a;
  cin &gt;&gt; a;
  if (a == 0) {
    cout &lt;&lt; "False" &lt;&lt; endl;
  } else {
    cout &lt;&lt; "True" &lt;&lt; endl;
  }

  return 0;
}
</pre>
  </details>


  <details>
    <summary>Задача 2. Максимум</summary>
    <h4>Максимум</h4>
    <p>В этой задаче требуется выбрать максимальное из двух чисел</p>
    <h4>Входные данные</h4>
    <p>Во входных данных записано два целых числа, каждое по модулю не превосходит 10<sup>9</sup></p>
    <h4>Выходные данные</h4>
    <p>Выведите наибольшее из этих чисел.</p>

    <h4>Пример 1</h4>
    <code>8 11</code>
    <code>Output: 11</code>

    <h4>Пример 2</h4>
    <code>11 8</code>
    <code>Output: 11</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a, b;
  cin &gt;&gt; a &gt;&gt; b;
  if (a > b) {
    cout &lt;&lt; a &lt;&lt; endl;
  } else {
    cout &lt;&lt; b &lt;&lt; endl;
  }

  return 0;
}
</pre>
  </details>


  <details>
    <summary>Задача 3. Имя Доктора</summary>
    <h4>Имя Доктора</h4>
    <p>Как известно, у каждого Доктора есть свой порядковый номер. Имя Доктора - это строковая запись его номера. Вам в плен попался Доктор, и сказал вам свой номер. Требуется узнать его имя.</p>
    <h4>Входные данные</h4>
    <p>Во входных данных находится единственное натуральное число, не превосходящее десяти - номер Доктора.</p>
    <h4>Выходные данные</h4>
    <p>В качестве ответа выведите имя Доктора.</p>

    <h4>Пример 1</h4>
    <code>5</code>
    <code>Output: five</code>

    <h4>Пример 2</h4>
    <code>2</code>
    <code>Output: two</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a;
  cin &gt;&gt; a;
  if (a == 1) {
    cout &lt;&lt; "one";
  } else if (a == 2) {
    cout &lt;&lt; "two";
  } else if (a == 3) {
    cout &lt;&lt; "three";
  } else if (a == 4) {
    cout &lt;&lt; "four";
  } else if (a == 5) {
    cout &lt;&lt; "five";
  } else if (a == 6) {
    cout &lt;&lt; "six";
  } else if (a == 7) {
    cout &lt;&lt; "seven";
  } else if (a == 8) {
    cout &lt;&lt; "eight";
  } else if (a == 9) {
    cout &lt;&lt; "nine";
  } else if (a == 10) {
    cout &lt;&lt; "ten";
  }

  return 0;
}
</pre>
  </details>


  <details>
    <summary>Задача 4. Большая буква?</summary>
    <h4>Большая буква?</h4>
    <p>В этой задаче требуется проверить, является ли данная буква латинского алфавита большой.</p>
    <h4>Входные данные</h4>
    <p>Во входных данных записана одна буква латинского алфавита.</p>
    <h4>Выходные данные</h4>
    <p>Если введенная буква является большой, выведите "BIG" (без кавычек). Иначе выведите "small" (без кавычек).</p>

    <h4>Пример 1</h4>
    <code>w</code>
    <code>Output: small</code>

    <h4>Пример 2</h4>
    <code>W</code>
    <code>Output: BIG</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  char a;
  cin &gt;&gt; a;
  if ((a &gt;= 97) && (a &lt;= 122)) {
    cout &lt;&lt; "small";
  } else if ((a &gt;= 65) && (a &lt;= 90)) {
    cout &lt;&lt; "BIG";
  }

  return 0;
}
</pre>
  </details>


  <details>
    <summary>Задача 5. Сортируй</summary>
    <h4>Сортируй</h4>
    <p>В этой задаче необходимо упорядочить данные числа в порядке неубывания.</p>
    <h4>Входные данные</h4>
    <p>Во входных данных записано три числа, каждое по модулю не превосходит 10<sup>9</sup></p>
    <h4>Выходные данные</h4>
    <p>Вам необходимо вывести те же три числа, но в порядке неубывания.</p>

    <h4>Пример 1</h4>
    <code>3 2 1</code>
    <code>Output: 1 2 3</code>

    <h4>Пример 2</h4>
    <code>2 1 4</code>
    <code>Output: 1 2 4</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a, b, c;
  cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
  if ((a &lt;= b) && (b &lt;= c)) {
    cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; " " &lt;&lt; c;
  } else if ((a &lt;= c) && (c &lt;= b)) {
    cout &lt;&lt; a &lt;&lt; " " &lt;&lt; c &lt;&lt; " " &lt;&lt; b;
  } else if ((b &lt;= a) && (a &lt;= c)) {
    cout &lt;&lt; b &lt;&lt; " " &lt;&lt; a &lt;&lt; " " &lt;&lt; c;
  } else if ((b &lt;= c) && (c &lt;= a)) {
    cout &lt;&lt; b &lt;&lt; " " &lt;&lt; c &lt;&lt; " " &lt;&lt; a;
  } else if ((c &lt;= a) && (a &lt;= b)) {
    cout &lt;&lt; c &lt;&lt; " " &lt;&lt; a &lt;&lt; " " &lt;&lt; b;
  } else if ((c &lt;= b) && (b &lt;= a)) {
    cout &lt;&lt; c &lt;&lt; " " &lt;&lt; b &lt;&lt; " " &lt;&lt; a;
  }

  return 0;
}
</pre>
  </details>
</article>


<!-- 2.3 Циклы while, do-while -->
<article class="article">
  <div class="anchor" id="p2.3"></div>
  <h3>2.3 Циклы while, do-while</h3>

  <h4>Цикл while</h4>
  <p>Пока a &le; b, уменьшаем b на величину a b = b - a</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  char a, b;
  cin &gt;&gt; a &gt;&gt; b;
  int cnt = 0;
  while (a &lt;= b) {
    b = b - a;
    cnt = cnt + 1;
  }
  cout &lt;&lt; cnt &lt;&lt; endl;

  return 0;
}
</pre>

  <h4>Бесконечный цикл</h4>
  <p>Если условие никогда не будет false, то цикл никогда не закончится. Это бесконечный цикл. Необходимо самостоятельно следить за тем, чтобы цикл когда-нибудь завершился. Бесконечный цикл можно остановить командой return</p>
<pre>
while(true) {
  return 0;
}
</pre>
  <p>Но тогда и вся программа завершится. Чтобы завершить только цикл можно воспользоваться командой break. Например, бесконечный цикл завершится когда a станет меньше 0</p>
<pre>
int a;
cin &gt;&gt; a;
while(true) {
  cout &lt;&lt; a &lt;&lt; " ";
  a = a - 2;
  if (a &lt; 0) {
    break;
  }
}
</pre>
  <p>Оператор continue завершает текущую итерацию цикла и переходит к следующей</p>

  <h4>Вложенные циклы</h4>
  <p>Циклы, как и условные операторы, можно вкладывать друг в друга. При этом операторы break и continue работают в самом вложенном цикле, в котором находятся</p>

  <p>while это цикл с предусловием. Сначала проводится проверка, потом выполняется тело цикла. Иногда нужно сделать наоборот, чтобы сначала выполнилсь тело цикла, а потом проводилась проверка. Это может сделать цикл с постусловием do while</p>

  <h4>Цикл do while</h4>
  <p>В цикле с постусловием сначала выполняем тело цикла, потом проверяем условие. Если условие верное, то снова выполняется тело цикла, а потом проверяется условие.</p>


  <details>
    <summary>Задача 1. Расплата Пети</summary>
    <h4>Расплата Пети</h4>
    <p>Петя похулиганил, и за это его наказали. Ему дали число, и он должен до тех пор, пока число не превосходит 10<sup>7</sup> увеличивать его в два раза. Петя хулиган, а не математик, поэтому он не хочет проводить подобные вычисления. Вы - друг Пети, и всегда рады ему помочь. Найдите число, на котором должен остановиться Петя, а также количество шагов, которое ему необходимо сделать.</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат натуральное число, не превосходящее 10<sup>9</sup> - число Пети</p>
    <h4>Выходные данные</h4>
    <p>Выведите два числа: итоговое число Пети, а также количество операций, которые он должен совершить</p>

    <h4>Пример 1</h4>
    <code>1</code>
    <code>Output: 16777216 24</code>

    <h4>Пример 2</h4>
    <code>113</code>
    <code>Output: 14811136 17</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a;
  cin &gt;&gt; a;
  int cnt = 0;
  while (a &lt;= 10000000) {
    a = a * 2;
    cnt = cnt + 1;
  }
  cout &lt;&lt; a &lt;&lt; " " &lt;&lt; cnt;

  return 0;
}
</pre>
  </details>


  <details>
    <summary>Задача 2. Количество чисел</summary>
    <h4>Количество чисел</h4>
    <p>Вводится последовательность чисел до тех пор, пока не будут введены два одинаковых числа подряд. Вам требуется определить количество чисел</p>
    <h4>Входные данные</h4>
    <p>Во входных данных находится последовательность целых чисел, каждое по модулю не превышает 10<sup>9</sup>. Гарантируется, что количество чисел не меньше 2 и не больше 10<sup>4</sup>, а также что все соседние числа попарно различны, кроме последней пары - числа в ней одинаковые.</p>
    <h4>Выходные данные</h4>
    <p>В ответ запишите единственное число - количество введенных чисел</p>

    <h4>Пример</h4>
    <code>4 5 7 8 91 5 2 4 5 6 7 1 2 2</code>
    <code>Output: 14</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a, b;
  cin &gt;&gt; b;
  int cnt = 1;
  do {
    a = b;
    cin &gt;&gt; b;
    cnt = cnt + 1;
  } while (a != b);
  cout &lt;&lt; cnt;

  return 0;
}
</pre>
  </details>


  <details>
    <summary>Задача 3. Сумма цифр</summary>
    <h4>Сумма цифр</h4>
    <p>В этой задаче требуется найти сумму цифр данного числа</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат единственное целое число, по модулю не превосходящее 10<sup>9</sup></p>
    <h4>Выходные данные</h4>
    <p>Выведите сумму цифр данного числа</p>

    <h4>Пример 1</h4>
    <code>113</code>
    <code>Output: 5</code>

    <h4>Пример 2</h4>
    <code>-179</code>
    <code>Output: 17</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a;
  cin &gt;&gt; a;
  if (a &lt; 0) {
    a = -a;
  }
  int sum = (a % 10);
  do {
    a = a / 10;
    sum = sum + (a % 10);
  } while ((a / 10) != 0);
  cout &lt;&lt; sum;

  return 0;
}
</pre>
  </details>


  <details>
    <summary>Задача 4. Следующий год</summary>
    <h4>Следующий год</h4>
    <p>Год называется хорошим, если сумма его цифр равна 13. Вам дано число - номер текущего года. Требуется найти номер следующего хорошего года.</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат единственное натуральное число, не превосходящее 10<sup>4</sup>- номер текущего года</p>
    <h4>Выходные данные</h4>
    <p>Требуется найти номер следующего хорошего года</p>

    <h4>Пример 1</h4>
    <code>2020</code>
    <code>Output: 2029</code>

    <h4>Пример 2</h4>
    <code>1813</code>
    <code>Output: 1822</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a, b, sum;
  cin &gt;&gt; a;
  if (a &lt; 0) {
    a = -a;
  }
  do {
    sum = 0;
    a = a + 1;
    b = a;
    while (b) {
      sum = sum + (b % 10);
      b = b / 10;
    }
  }
  while (sum != 13);
  cout &lt;&lt; a;

  return 0;
}
</pre>
  </details>
</article>


<!-- 2.4 Цикл for -->
<article class="article">
  <div class="anchor" id="p2.4"></div>
  <h3>2.4 Цикл for</h3>

  <p>Цикл for это цикл со счетчиком. Не всегда нужно делать цикл пока не выполнится какое-то условие. Иногда нужно выполнить цикл N раз.</p>
  <p>Найдем сумму чисел от 0 до 9</p>
<pre>
int n = 10;
int sum = 0;
for (int i = 0; i &lt; n; i = i + 1) {
  sum = sum + i;
}
cout &lt;&lt; sum;
</pre>

  <p>Внутри цикла можно выводить числа. Выведем все четные числа от 0 до n</p>
<pre>
int n;
cin &gt;&gt; n;
for (int i = 0; i &lt; n; i += 2) {
  cout &lt;&lt; i &lt;&lt; " ";
}
</pre>

  <p>Выведем все четные числа от n до 0</p>
<pre>
int n;
cin &gt;&gt; n;
if (n % 2 = 1) {
  n -= 1;
}
for (int i = n; i &gt;= n; i -= 2) {
  cout &lt;&lt; i &lt;&lt; " ";
}
</pre>

  <p>Внутри цикла можно вводит и выводить числа. Введем n чисел и сразу выведем их на экран</p>
<pre>
int n;
cin &gt;&gt; n;
for (int i = 0; i &lt; n; i++) {
  int a;
  cin &gt;&gt; a;
  cout &lt;&lt; a &lt;&lt; endl;
}
</pre>


  <details>
    <summary>Задача 1. Сумма чисел</summary>
    <h4>Сумма чисел</h4>
    <p>В этой задаче требуется найти сумму чисел от 1 до n</p>
    <h4>Входные данные</h4>
    <p>Во входных данных записано единственное целое число n (1 &le; n &le; 10<sup>4</sup></p>
    <h4>Выходные данные</h4>
    <p>В ответ напишите сумму чисел от 1 до n</p>

    <h4>Пример 1</h4>
    <code>10</code>
    <code>Output: 55</code>

    <h4>Пример 2</h4>
    <code>100</code>
    <code>Output: 5050</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int n, sum = 0;
  cin &gt;&gt; n;
  for (int i = 0; i &lt;= n; i++) {
    sum = sum + i;
  }
  cout &lt;&lt; sum;

  return 0;
}
</pre>
  </details>


  <details>
    <summary>Задача 2. Четные числа</summary>
    <h4>Четные числа</h4>
    <p>В этой задаче требуется вывести все четные числа от 1 до n в порядке убывания</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат единственное целое число n (2 &le; n &le; 10<sup>5</sup></p>
    <h4>Выходные данные</h4>
    <p>Выведите в одну строчку все четные числа от 1 до n в порядке убывания</p>

    <h4>Пример 1</h4>
    <code>6</code>
    <code>Output: 6 4 2</code>

    <h4>Пример 2</h4>
    <code>9</code>
    <code>Output: 8 6 4 2</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int n;
  cin &gt;&gt; n;
  if (n % 2 == 1) {
    n--;
  }
  for (int i = n; i &gt;= 2; i -= 2) {
    cout &lt;&lt; i &lt;&lt; " ";
  }

  return 0;
}
</pre>
  </details>


  <details>
    <summary>Задача 3. print input</summary>
    <h4>print input</h4>
    <p>Дано множество чисел, требуется вывести его на экран</p>
    <h4>Входные данные</h4>
    <p>В первой строке входных данных записано единственное число n (1 &le; n &le; 10<sup>5</sup></p>
    <p>Во второй строке записано n целых чисел, каждое по модулю не превосходит 10<sup>9</sup></p>
    <h4>Выходные данные</h4>
    <p>Выведите данные вам n чисел. Их количество выводить не нужно</p>

    <h4>Пример 1</h4>
    <code>5</code>
    <code>4 2 3 4 4</code>
    <code>Output: 4 2 3 4 4</code>

    <h4>Пример 2</h4>
    <code>4</code>
    <CODE>13 13 13 13</CODE>
    <code>Output: 13 13 13 13</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int n;
  cin &gt;&gt; n;
  for (int i = 0; i &lt; n; i++) {
    int a;
    cin &gt;&gt; a;
    cout &lt;&lt; a &lt;&lt; " ";
  }

  return 0;
}
</pre>
  </details>


  <details>
    <summary>Задача 4. Сумма</summary>
    <h4>Сумма</h4>
    <p>В этой задаче вам требуется посчитать следующую сумму</p>
    <code>1 + a + a<sup>2</sup> + a<sup>3</sup> + ... + a<sup>n</sup></code>
    <h4>Входные данные</h4>
    <p>Во входных данных записано два целых числа a,n (0 &le; a &le; 10<sup>9</sup>; 0 &le; n &le; 10<sup>3</sup></p>
    <h4>Выходные данные</h4>
    <p>В ответ напишите единственное число - требуемую сумму. Гарантируется,  что искомая сумма не превосходит 10<sup>18</sup></p>

    <h4>Пример 1</h4>
    <code>2 5</code>
    <code>Output: 63</code>

    <h4>Пример 2</h4>
    <code>3 3</code>
    <code>Output: 40</code>
<pre>
#include &lt;iostream&gt;
#include &lt;cmath&gt;

using namespace std;

int main() {
  long long a, sum = 0;
  int n;
  cin &gt;&gt; a &gt;&gt; n;
  for (int i = 0; i &lt;= n; i++) {
    sum += powl(a,i);
  }
  cout &lt;&lt; sum;

  return 0;
}
</pre>
  </details>


  <details>
    <summary>Задача 5. И снова сумма</summary>
    <h4>И снова сумма</h4>
    <p>В этой задаче вам требуется посчитать следующую сумму</p>
    <code>1 - a + a<sup>2</sup> - a<sup>3</sup> + ... &plusmn; a<sup>n</sup></code>
    <h4>Входные данные</h4>
    <p>Во входных данных записано два целых числа a,n (0 &le; a &le; 10<sup>9</sup>; 0 &le; n &le; 10<sup>5</sup></p>
    <h4>Выходные данные</h4>
    <p>В ответ напишите единственное число - требуемую сумму. Гарантируется,  что искомая сумма не превосходит 10<sup>18</sup></p>

    <h4>Пример 1</h4>
    <code>2 5</code>
    <code>Output: -21</code>

    <h4>Пример 2</h4>
    <code>3 3</code>
    <code>Output: -20</code>
<pre>
#include &lt;iostream&gt;
#include &lt;cmath&gt;

using namespace std;

int main() {
  long long a, sum = 0;
  int n;
  cin &gt;&gt; a &gt;&gt; n;
  for (int i = 0; i &lt;= n; i += 2) {
    sum += powl(a,i);
  }
  for (int i = 1; i &lt;= n; i += 2) {
    sum -= powl(a,i);
  }
  cout &lt;&lt; sum;

  return 0;
}
</pre>
  </details>
</article>


<!-- 2.5 Итоговое тестирование -->
<article class="article">
  <div class="anchor" id="p2.5"></div>
  <h3>2.5 Итоговое тестирование</h3>

  <details>
    <summary>Задача 1. Упростите выражение</summary>
    <h4>Упростите выражение</h4>
    <p>Упростите следующее выражение</p>
    <code>!((!a && (!a || !b)) && ((!a && !b) || !a))</code>

    <h4>Закон поглощения</h4>
    <code>a && (a || b) == a</code>
    <code>a || (a && b) == a</code>

    <h4>Закон идемпотентности</h4>
    <code>a && a == a</code>
    <code>a && a == a</code>

    <h4>Закон двойного отрицания</h4>
    <code>~(~a) == a</code>

    <h4>Решение</h4>
    <code>(!a && (!a || !b)) = !a</code>
    <code>((!a && !b) || !a) = !a</code>
    <code>!a && !a = !a</code>
    <code>!(!a) = a</code>
  </details>

  <details>
    <summary>Задача 2. Простое число</summary>
    <h4>Простое число</h4>
    <p>Простым числом называется такое натуральное число, которое имеет ровно два натуральных делителя - себя и единицу. Например, 1 не является простым числом, поскольку у него всего один делитель. 2 и 3 - простые, а вот 4 нет -  у него есть три делителя: 1, 2,4.</p>

    <p>Немного поисследовав простые числа, Физики пришли к очень интересному, но, к сожалению, неверному заключению про простые числа. Мы не знаем это заключение, однако в сеть утекла реализация проверки числа на простоту:</p>

<pre>
int n;
cin &gt;&gt; n;
if (n == 2 || (n % 2 == 1 && n != 9 && n != 1)) {
    cout &lt;&lt; "Prime" &lt;&lt; endl;
} else {
    cout &lt;&lt; "Not Prime" &lt;&lt; endl;
}
</pre>

  <p>Вам необходимо найти такое число, на котором данная программа будет работать неверно. Другими словами, вам необходимо либо найти такое простое число, что программа скажет, что оно не простое, либо наоборот, такое не простое число, что программа посчитает его простым. В ответ запишите любое такое натуральное число, не превосходящее 10<sup>5</sup></p>
  <p>История про физиков следующая: "Исследуют физики простые числа. Смотрят: 3, 5, 7 - простые, а 9 - не простое. Но это ладно, ошибка эксперимента, смотрим дальше - 11, 13 простые. Значит, все нечетные, кроме 9 - простые числа".</p>
  <h4>Ответ: 15</h4>
  </details>

  <details>
    <summary>Задача 3. Сколько раз</summary>
    <h4>Сколько раз выполнится тело цикла for?</h4>
<pre>
for (int i = 0; i &lt;= 666; ++i) {
    while (i % 6 != 0) {
        i = i + 1;
    }
    cout &lt;&lt; i;
}
</pre>
  <h4>Ответ: 112</h4>
  <p>Первый раз при i = 0, и потом через каждые 6 раз, то есть 666 / 6 = 111. Итого 1 + 111 = 112 раз выпролнится цикл for</p>
  </details>

  <details>
    <summary>Задача 4. Интересный делитель</summary>
    <h4>Интересный делитель</h4>
    <p>Данная задача взята из архива Летних Компьютерных Школ в Майкопе</p>
    <p>Интересным делителем называется число N, которое является делителем числа N+1.</p>
    <p>Вам требуется найти количество интересных делителей на отрезке от L до R, концы отрезка включаются.</p>
    <h4>Входные данные</h4>
    <p>Во входном файле записано через пробел два числа L, R (L &lt; R, 1 &le; L, R &le; 10<sup>18</sup></p>
    <h4>Выходные данные</h4>
    <p>Вывести единственное число - ответ на задачу.</p>

    <h4>Пример</h4>
    <code>2 5</code>
    <code>Output: 0</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  long long l, r;
  cin &gt;&gt; l &gt;&gt; r;
  if (l == 1) {
    cout &lt;&lt; 1;
  } else {
    cout &lt;&lt; 0;
  }

  return 0;
}
</pre>
  </details>

  <details>
    <summary>Задача 5. Братья навек</summary>
    <h4>Братья навек</h4>
    <p>Данная задача взята из архива Летних Компьютерных Школ в Майкопе</p>
    <p>Программист Антоша хочет стать самым лучшим программистом, ну, или хотя бы решить задач больше своего старшего брата Андрюши.</p>
    <p>Сейчас количество решенных задач Антоши равно a, а количество решенных задач Андрюши равно b. Гарантируется, что количество решенных задач у Антоши меньше или равно числу решенных задач Андрюши.</p>
    <p>Антоша решает много, и его количество решенных задач утраивается каждый год, а количество решенных задач Андрюши удваивается каждый год.</p>
    <p>Через сколько целых лет Антоша решит строго больше задач чем Андрюша?</p>
    <h4>Входные данные</h4>
    <p>В единственной строке находятся два целых числа a, b (1 &le; a &le; b&le; 10) количество решенных задач у Антоши и Андрюши соответственно.</p>
    <h4>Выходные данные</h4>
    <p>Выведите одно целое число --- через сколько целых лет Антоша решит строго больше задач чем Андрюша.</p>

    <h4>Пример 1</h4>
    <code>4 7</code>
    <code>Output: 2</code>

    <h4>Пример 2</h4>
    <code>4 9</code>
    <code>Output: 3</code>

    <h4>Пример 3</h4>
    <code>1 1</code>
    <code>Output: 1</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a, b;
  cin &gt;&gt; a &gt;&gt; b;
  int year = 0;
  do {
    a *= 3;
    b *= 2;
    year++;
  } while (a &lt;= b);
  cout &lt;&lt; year;

  return 0;
}
</pre>
  </details>

  <details>
    <summary>Задача 6. плати налоги</summary>
    <h4>плати налоги</h4>
    <p>в стране n ввели новый налог - большие буквы стали платными. теперь, за каждую большую букву требуется отдавать b бубликов. не у каждого найдется столько, поэтому на больших буквах теперь надо экономить. однажды один очень богатый Андрей (большая буква в имени проспонсирована им) составил предложение. вам необходимо посчитать, во сколько бубликов обошлось такое предложение Андрею.</p>
    <h4>Входные данные</h4>
    <p>в первой строке входных данных записано единственное число b (1 &le;  b&le; 10<sup>4</sup>) количество решенных задач у Антоши и Андрюши соответственно.</p>
    <p>во второй строке следует составленное Андреем предложение. оно содержит большие и маленькие буквы латинского алфавита, пробелы, запятые и точку. гарантируется, что в предложении ровно одна точка, а также что предложение на нее заканчивается.</p>
    <h4>Выходные данные</h4>
    <p>выведите единственное число - количество бубликов, которое должен заплатить Андрей за составленное предложение.</p>

    <h4>Пример 1</h4>
    <code>11</code>
    <code>I AM RICH.</code>
    <code>Output: 77</code>

    <h4>Пример 2</h4>
    <code>1</code>
    <code>i am not rich.</code>
    <code>Output: 0</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int b;
  char s;
  cin &gt;&gt; b;
  int tax = 0;
  do {
    cin &gt;&gt; s;
    if (s &gt; 64 && s &lt; 91)
    tax += b;
  } while (s != '.');
  cout &lt;&lt; tax;

  return 0;
}
</pre>
  </details>

  <details>
    <summary>Задача 7. Приседания</summary>
    <p></p>Данная задача взята из архива Летних Компьютерных Школ в Майкопе.
    <h4>Приседания</h4>
    <p>Школьник Петя списывал задачи на Летней Компьютерной Школе 2020, поэтому преподаватели заставили его играть в следующую игру. Петя должен сделать n приседаний (1  ≤n ≤ 20000), причем он должен озвучивать номер каждого приседания (нумерация с 1). Если номер текущего приседания не делится ни на 3, ни на 5, то Петя просто называет этот номер. Если номер делится на 3, но не делится на 5, то Петя произносит "Бац". Если номер делится на 5, но не делится на 3, то Петя произносит "Бум". Если номер делится на 15, то Петя произносит "Бацбум". Вам необходимо ответить, сколько соответственно раз Петя произнесет "Бац", "Бум" и "Бацбум".</p>
    <h4>Входные данные</h4>
    <p>На вход подается число n --- количество приседаний. </p>
    <h4>Выходные данные</h4>
    <p>Выведите через пробел сколько раз будут озвучены слова "Бац", "Бум" и "Бацбум".</p>
    <h4>Sample Input 1:</h4>
    <code>17</code>
    <h4>Sample Output 1:</h4>
    <code>4 2 1</code>
    <h4>Sample Input 2:</h4>
    <code>5</code>
    <h4>Sample Output 2:</h4>
    <code>1 1 0</code>
<pre>
#include <iostream>

using namespace std;

int main() {
  int n;
  cin >> n;
  int baz = 0, bum = 0, bazbum = 0;
  bazbum = n / 15;
  baz = n / 3 - bazbum;
  bum = n / 5 - bazbum;
  cout &lt;&lt; baz &lt;&lt; " " &lt;&lt; bum &lt;&lt; " " &lt;&lt; bazbum;
  return 0;
}
</pre>
  </details>
</article>


<!-- 3 Массивы и функции -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>3 Массивы и функции</h3>
</article>


<!-- 3.1 Массивы -->
<article class="article">
  <div class="anchor" id="p3.1"></div>
  <h3>3.1 Массивы</h3>

  <p>Здравствуйте, меня зовут Куренков Владимир. В этом модуле я расскажу вам про статические массивы, сортировку массивов, функции и рекурсию.</p>

  <h4>Статический массив</h4>
  <p>Представим что нужно работать с несколькими однотипными переменными. Было бы неудобно объявлять каждую из них по отдельности. В данном примере их 5</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a0, a1, a2, a3, a4;
  a0 = 7;
  a1 = 1;
  a2 = 5;
  a3 = 3;
  a4 = 5;

  return 0;
}
</pre>
  <p>А что делать когда таких переменных 1000? В языке C++ можно работать с такой структурой данных, которая называется массив. Это позволяет объединить набор однотипных переменных и эффективно обрабатывать их.</p>
  <p>Массив это структура данных, хранящая набор значений или объектов, как правило одинакового типа.</p>

  <h4>Объявление массива</h4>
  <p>При объявлении массива необходимо указать тип элементов массива, имя массива и количесвто элементов в нем</p>
  <code>int a[5]</code>

  <h4>Доступ к элементам массива</h4>
  <p>С каждым элементом массива мы можем работать как с переменной, обращаясь к ней по индексу.</p>

  <h4>Оператор индексатор []</h4>
  <p>Оператор индексатор это пара квадратных скобок. Он используется при объявлении массива, а также для доступа к элементам массива по индексу</p>
  <p> При работе с массивом нуно самому следить чтобы не выйти за границы массива. Если в массиве из 5 элементов обратиться к -1 или 5 элементу, то получим ошибку выполнения программы.</p>
  <code>a[-1] = 1;</code>
  <code>a[5] = 1;</code>

  <details>
    <summary>Пример ввода в массив 10 чисел с клавиатуры и вывода их на экран</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a[10];
  for (int i = 0; i &lt; 10; i++) {
    cin &gt;&gt; a[i];
  }
  for (int i = 0; i &lt; 10; i++) {
    cout &lt;&lt; a[i] &lt;&lt; " ";
  }

  return 0;
}
</pre>
  </details>

  <h4>Алгоритмы</h4>
  <p>Алгоритм обработки элементов массива включает, например, поиск суммы элементов массива, поиск максимального и минимального элемента.</p>
  <p>Чтобы найти сумму, нужно ввести дополнительную переменную s и просуммировать элементы массива в цикле.</p>

  <details>
    <summary>Сумма элементов массива</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a[5];
  for (int i = 0; i &lt; 5; i++) {
    cin &gt;&gt; a[i];
  }
  int s = 0;
  for (int i = 0; i &lt; 5; i++) {
    s += a[i];
  }
  cout &lt;&lt; s;

  return 0;
}
</pre>
  </details>

  <p>Чтобы найти максимальное значение, введем дополнительную переменную m. Вначале предположим, что максимальное значение это элемент с индексом 0. В дальнейшем, если это окажется не так, мы поменяем это значение. Будем последовательно перебирать элементы, сравнивая значение текущего элемента с m.</p>

  <details>
    <summary>Максимальное значение в массиве</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a[10];
  for (int i = 0; i &lt; 10; i++) {
    cin &gt;&gt; a[i];
  }
  int m = a[0];
  for (int i = 1; i &lt; 10; i++) {
    if(a[i] &gt; m) {
      m = a[i];
    }
  }
  cout &lt;&lt; m;

  return 0;
}
</pre>
  </details>

  <p>Такой же алгоритм используется для поиска минимального элемента. Нужно только изменить знак больше на меньше внутри цикла</p>

  <details>
    <summary>Минимальное значение в массиве</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a[10];
  for (int i = 0; i &lt; 10; i++) {
    cin &gt;&gt; a[i];
  }
  int m = a[0];
  for (int i = 1; i &lt; 10; i++) {
    if(a[i] &lt; m) {
      m = a[i];
    }
  }
  cout &lt;&lt; m;

  return 0;
}
</pre>
  </details>

  <p>Как найти индекс элемента, по которому находится нужное нам значение? Для этого мы изменим программу и будем запоминать индекс элемента а не его значение</p>

  <details>
    <summary>Индекс максимального элемента</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a[10];
  for (int i = 0; i &lt; 10; i++) {
    cin &gt;&gt; a[i];
  }
  int im = 0;
  for (int i = 1; i &lt; 10; i++) {
    if(a[i] &gt; a[im]) {
      im = i;
    }
  }
  cout &lt;&lt; im;

  return 0;
}
</pre>
  </details>

  <p>Максимальных и минимальных элементов в массиве может быть несколько. Иногда возникает задача нахождения первого или последнего. Ранее мы посмотрели как найти индекс первого минимального элемента. Чтобы найти индекс последнего, надо поставить нестрогое условие, или перебирать элементы массива с конца.</p>
  <p>Как быть если размер массива заранее неизвестен? В большинстве задач размер массива вводится со стандартным потоком ввода данных. В данном примере мы считываем сначала n - количество элементов. Далее создаем массив размером из n элементов. В цикле при переборе массива мы будем использовать переменную n, так как в ней хранися количество элементов массива</p>

  <details>
    <summary>Ввод и вывод массива</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int n = 0;
  cin &gt;&gt; n;
  int a[n];
  for (int i = 0; i &lt; n; i++) {
    cin &gt;&gt; a[i];
  }
  for (int i = 0; i &lt; 10; i++) {
    cout &lt;&lt; a[i] &lt;&lt; " ";
  }

  return 0;
}
</pre>
  </details>

  <p>Если вы работаете в Visual Studio, то придется делать как показано в примере. Или использовать вектор о котором будем рассказывать позднее</p>

  <details>
    <summary>Ввод и вывод массива в Visual Studio</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int n = 0;
  cin &gt;&gt; n;
  int a[1000];
  for (int i = 0; i &lt; n; i++) {
    cin &gt;&gt; a[i];
  }
  for (int i = 0; i &lt; 10; i++) {
    cout &lt;&lt; a[i] &lt;&lt; " ";
  }

  return 0;
}
</pre>
  </details>

  <p>Последние два примера, которые мы рассмотрим, это переворот массива и циклический сдвиг массива. Чтобы перевернуть массив нужен цикл с двумя переменными i и j. Переменная i будет идти сначала массива. Переменная j будет идти с конца массива. Будем менять местами элементы на позициях i и j. Когда наши переменные цикла встретятся посередине массива, мы прекратим цикл, получив перевернутый массив</p>

  <details>
    <summary>Перевернуть массив</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int n = 10;
  int a[n] = {5,6,7,8,9,1,2,3,4,5};
  for (int i = 0, j = n - 1; i &lt; j; i++, j--) {
    int t = a[i];
    a[i] = a[j];
    a[j] = t;
  }
  for (int i = 0; i &lt; n; i++) {
    cout &lt;&lt; a[i] &lt;&lt; " ";
  }

  return 0;
}
</pre>
  </details>

  <p>Таким же образом можно перевернуть не весь массив, а какую-то его часть. Например, с нуля по k-ый элемент. Или с k-го элемента до конца массива.</p>

  <h4>Циклический сдвиг</h4>
  <p>Циклический сдвиг массива влево это такой сдвиг при котором все элементы уходят влево, а те что были в начале уходят в конец массива.</p>
  <code>0 1 2 3 4 5 6 7 8 9</code>
  <code>2 3 4 5 6 7 8 9 0 1</code>

  <p>Чтобы циклически сдвинуть массив из n элементов на k элементов влево. Надо разбить массив на два подмассива.</p>
  <code>[0,...,k-1,k,...,n-1]</code>
  <code>A = [0,...,k-1], B = [k,...,n-1]</code>
  <p>Перевернем сначала массивы A и B</p>
  <code>A = [k-1,...,0], B = [n-1,...,k]</code>
  <p>Далее перевернем целиком весь полученный массив и получим массив, в котором элементы циклически сдвинуты на k элементов влево</p>
  <code>[k,...,n-1,0,...,k-1]</code>


  <details>
    <summary>Задача 1. Максимум в массиве</summary>
    <h4>Максимум в массиве</h4>
    <p>В этой задаче вам необходимо найти максимум в массиве</p>
    <h4>Входные данные</h4>
    <p>В этой задаче нет входных данных :-) Все, что вам нужно сделать - написать часть программы, которая ищет максимум в массиве. Вы можете полагать, что где-то раньше объявлен массив с именем a, а также есть переменная n, содержащая размер массива. Все элементы в массиве нумеруются от 0 до n-1. Вам необходимо создать переменную ans, в которую следует положить максимум в массиве. Гарантируется, что все элементы массива - целые числа, по модулю не превосходящие 10<sup>9</sup></p>
    <h4>Пример программы</h4>
    <p>Допустим, вашей задачей было бы нахождение суммы двух чисел. Выше объявлены переменные a и b, необходимо объявить переменную c, в которую надо положить сумму данных переменных. Тогда программа, которую вы отправили бы в систему, выглядела так:</p>

    <code>int c;</code>
    <code>c = a + b;</code>
<pre>
int ans = a[0];
for (int i = 0; i &lt; n; i++) {
  if (a[i] &gt; ans) {
      ans = a[i];
  }
}
</pre>
  </details>


  <details>
    <summary>Задача 2. Переворот</summary>
    <h4>Переворот</h4>
    <p>Алексей переворачивает все, до чего дотягивается. Сегодня он перевернул массив, вам нужно перевернуть его обратно.</p>
    <h4>Входные данные</h4>
    <p>Первая строка входных данных содержит единственное целое число n (1&le;n&le;10<sup>5</sup>) - размер массива</p>
    <p>Во второй строке записано n целых чисел, каждое по модулю не превосходит 10<sup>9</sup> - сам массив</p>
    <h4>Выходные данные</h4>
    <p>Выведите данный массив в обратном порядке.</p>

    <h4>Пример 1</h4>
    <code>5</code>
    <code>3 1 4 2 5</code>
    <code>Output: 5 2 4 1 3</code>

    <h4>Пример 2</h4>
    <code>6</code>
    <code>1 2 3 4 5 6</code>
    <code>Output: 6 5 4 3 2 1</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int n;
  cin &gt;&gt; n;
  int a[n];
  for (int i = 0; i &lt; n; i++) {
    cin &gt;&gt; a[i];
  }
  for (int i = n - 1; i &gt;= 0; i--) {
    cout &lt;&lt; a[i] &lt;&lt; " ";
  }

  return 0;
}
</pre>
  </details>


  <details>
    <summary>Задача 3. Trading Places</summary>
    <h4>Trading Places</h4>
    <p>Каждый человек за свою жизнь накопил какое-то количество денег. Прилетели инопланетяне и поменяли накопления у самых богатых и самых бедных людей. Это означает, что для каждого самого бедного человека количество денег у него после обмена станет равным тому, что было у самого богатого человека до обмена. Верно и обратное - для каждого самого богатого человека количество денег у него после обмена станет равным тому, что было у самого бедного человека до обмена. Обратите внимание - суммарное количество денег у всех людей может измениться!</p>
    <p>Инопланетяне улетели, а восстановить экономическое равновесие надо. Вам дано количество денег у каждого человека после обмена, определите, сколько денег у них было до обмена.</p>
    <h4>Входные данные</h4>
    <p>Первая строка входных данных содержит единственное целое число n (1&le;n&le;10<sup>5</sup>) - количество человек</p>
    <p>Во второй строке через пробел записано n целых чисел, каждое по модулю не превосходит 10<sup>9</sup> - количество денег у соответствующего человека после обмена</p>
    <h4>Выходные данные</h4>
    <p>Выведите n чисел - количество денег, которое было у каждого человека до обмена</p>

    <h4>Пример 1</h4>
    <code>5</code>
    <code>-1 2 -1 4 5</code>
    <code>Output: 5 2 5 4 -1</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int n;
  cin &gt;&gt; n;
  int a[n];
  for (int i = 0; i &lt; n; i++) {
    cin &gt;&gt; a[i];
  }
  int min = a[0], max = a[0];
  for (int i = 1; i &lt; n; i++) {
    if (a[i] &lt; min) {
      min = a[i];
    } else if (a[i] &gt; max) {
      max = a[i];
    }
  }
  for (int i = 0; i &lt; n; i++) {
    if (a[i] == min) {
      a[i] = max;
    } else if (a[i] == max) {
      a[i] = min;
    }
  }
  for (int i = 0; i &lt; n; i++) {
    cout &lt;&lt; a[i] &lt;&lt; " ";
  }

  return 0;
}
</pre>
  </details>


  <details>
    <summary>Задача 4. Выставление оценок</summary>
    <p>Данная задача взята из архива Летних Компьютерных Школ в Майкопе.</p>
    <h4>Выставление оценок</h4>
    <p>Однажды Влад, Довлет, Никита и Эдик проверяли письменные работы детей, и вот пришло время выставить оценки в рейтинг! Всего было N работ. Владислав по порядку начал называть оценки Довлету, чтобы он их выставил. Но вот какая проблема, Довлет расслышал не все оценки, а Влад повторять этот список полностью не собирается, однако согласился отвечать на вопросы следующего вида: Довлет называет число — порядковый номер оценки которую называл Влад, а он скажет какая оценка там была. Никита и Эдик, как сокомандники, помогли Довлету и приготовили список из Q чисел — порядковые номера оценок, которые не расслышал Довлет. Вы же товарищ Влада, и должны помочь ему отвечать на вопросы Довлета: если Довлет запрашивает число i, вы должны вывести i-е число, названное Владом.</p>
    <h4>Входные данные</h4>
    <p>В первой строке входных данных находится единственное число n (1&le;n&le;100) - количество оценок названных Владом</p>
    <p>В следующей строке вводится n чисел через пробел — оценки которые назвал Влад. Каждая оценка представляет собой целое число от -100 до 100</p>
    <p>В третьей строке вводится число Q - количество запросов Довлета</p>
    <p>В следующей строке вводится Q чисел через пробел — номера оценок которые запрашивает Довлет у Влада.</p>
    <h4>Выходные данные</h4>
    <p>Вам необходимо ответить на запросы в следующем виде: вывести Q чисел через пробел — ответы на запросы Довлета, i-е число представляет собой ответ i-й запрос. Рассмотрите примеры из условия и описание к ним для большего понимания условия.</p>

    <h4>Пример 1</h4>
    <code>3</code>
    <code>1 2 -4</code>
    <code>3</code>
    <code>2 1 3</code>
    <code>Output: 2 1 -4</code>

    <h4>Пример 2</h4>
    <code>3</code>
    <code>5 65 -9</code>
    <code>1</code>
    <code>2</code>
    <code>Output: 65</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int n;
  cin &gt;&gt; n;
  int a[n];
  for (int i = 0; i &lt; n; i++) {
    cin &gt;&gt; a[i];
  }
  int q;
  cin &gt;&gt; q;
  int b[q];
  for (int i = 0; i &lt; q; i++) {
    cin &gt;&gt; b[i];
  }
  for (int i = 0; i &lt; q; i++) {
    cout &lt;&lt; a[b[i]-1] &lt;&lt; " ";
  }

  return 0;
}
</pre>
  </details>


  <details>
    <summary>Задача 5. Юра и заселение</summary>
    <h4>Юра и заселение</h4>
    <p>Недавно Юра поступил в БГУКП (Берляндский Государственный Университет Крутых Программистов). У Юры есть друг Леша, который поступил вместе с ним, и теперь они заселяются в общежитие.</p>
    <p>Юра и Леша хотят жить в одной комнате. Всего в общежитии есть n комнат. В данный момент в комнате с номером i живут p<sub>i</sub> человек, когда всего в этой комнате может жить q<sub>i</sub> человек (p<sub>i</sub> &le; q<sub>i</sub>). Посчитайте, сколько комнат общежития смогут вместить Юру и Лешу вместе.</p>
    <h4>Входные данные</h4>
    <p>В первой строке содержится единственное целое число n (1&le;n&le;100) - количество комнат</p>
    <p>Во второй строке содержится n целых чисел p<sub>i</sub> (0&le; p<sub>i</sub> &le;100) количество людей, которые уже живут в i-й комнате</p>
    <p>В третьей строке содержится n целых чисел q<sub>i</sub> (p<sub>i</sub> &le; q<sub>i</sub> &le; 100) максимально допустимое количество людей в i-й комнате</p>
    <h4>Выходные данные</h4>
    <p>Выведите одно целое число — количество комнат, в которые Юра с Лешей могут заселиться</p>

    <h4>Пример 1</h4>
    <code>3</code>
    <code>2 1 3</code>
    <code>2 3 4</code>
    <code>Output: 1</code>

    <h4>Пример 2</h4>
    <code>4</code>
    <code>1 1 1 1</code>
    <code>6 4 5 7</code>
    <code>Output: 4</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int n;
  cin &gt;&gt; n;
  int a[n];
  for (int i = 0; i &lt; n; i++) {
    cin &gt;&gt; a[i];
  }
  int b[n];
  for (int i = 0; i &lt; n; i++) {
    cin &gt;&gt; b[i];
  }
  int count = 0;
  for (int i = 0; i &lt; n; i++) {
    if (b[i] - a[i] >= 2) {
      count++;
    }
  }
  cout &lt;&lt; count;

  return 0;
}
</pre>
  </details>


  <details>
    <summary>Задача 6. Четные лучше</summary>
    <h4>Четные лучше</h4>
    <p>Какие ваши любимые числа? Мои - четные! Поэтому вам в этой задаче нужно будет поставить четные числа на первые места, а все остальные - потом</p>
    <h4>Входные данные</h4>
    <p>Первая строка входных данных содержит единственное целое число n (1&le;n&le;10<sup>5</sup>) - количество чисел</p>
    <p>Во второй строке через пробел записаны n целых чисел, каждое по модулю не превосходит 10<sup>9</sup></p>
    <h4>Выходные данные</h4>
    <p>Выведите n чисел в одну строчку. Сначала выведите все четные числа в данном массиве в том же порядке, что они даны во входных данных. Затем выведите все нечетные числа в том же порядке, что и в исходном массиве.</p>

    <h4>Пример 1</h4>
    <code>6</code>
    <code>3 2 1 5 4 6</code>
    <code>Output: 2 4 6 3 1 5 </code>

    <h4>Пример 2</h4>
    <code>10</code>
    <code>5 3 4 5 3 4 2 3 1 1</code>
    <code>Output: 4 4 2 5 3 5 3 3 1 1 </code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int n;
  cin &gt;&gt; n;
  int a[n];
  for (int i = 0; i &lt; n; i++) {
    cin &gt;&gt; a[i];
  }
  int b[n];
  int p1 = 0;
  for (int i = 0; i &lt; n; i++) {
    if (a[i] % 2 == 0) {
      b[p1] = a[i];
      p1++;
    }
  }
  for (int i = 0; i &lt; n; i++) {
    if (a[i] % 2 != 0) {
      b[p1] = a[i];
      p1++;
    }
  }

  for (int i = 0; i &lt; n; i++) {
    cout &lt;&lt; b[i] &lt;&lt; " ";
  }

  return 0;
}
</pre>
  </details>
</article>


<!-- 3.2 Многомерные массивы -->
<article class="article">
  <div class="anchor" id="p3.2"></div>
  <h3>3.2 Многомерные массивы</h3>

  <p>Двумерные массивы (матрицы) широко используются для хранения, представления и обработки данных. Для того чтобы объявить двумерный массив, надо указать тип элемента, имя массива и его размеры.</p>
  <code>int a[3][4]</code>
  <p>В первых квадратных скобках - количество строк, во вторых - количество столбцов</p>
  <p>Трехмерный массив (куб)</p>
  <code>int a[5][5][5]</code>

  <h4>Ввод с клавиатуры и вывод на экран двумерного массива</h4>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int n = 3, m = 4;
  int a[n][m];
  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; m; j++) {
      cin &gt;&gt; a[i][j];
    }
  }
  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; m; j++) {
      cout &lt;&lt; a[i][j] &lt;&lt; " ";
    }
    cout &lt;&lt; endl;
  }

  return 0;
}
</pre>

  <h4>Транспонирование матрицы</h4>
  <p>Транспонирование матрицы - это поменять строки и столбцы местами. Если изменить вывод и поменять цикл по i и по j местами, то мы транспонируем матрицу</p>

  <details>
    <summary>Транспонирование матрицы на экран</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int n = 3, m = 4;
  int a[n][m];
  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; m; j++) {
      cin &gt;&gt; a[i][j];
    }
  }
  for (int j = 0; j &lt; m; j++) {
    for (int i = 0; i &lt; n; i++) {
      cout &lt;&lt; a[i][j] &lt;&lt; " ";
    }
    cout &lt;&lt; endl;
  }

  return 0;
}
</pre>
  </details>

  <p>Если нужно транспонировать матрицу не на экран а в новый двумерный массив, то немного изменим программу. Из исходного массива a, в котором n строк и m столбцов, мы сделаем массив b, в котором m строк и n столбцов. Поэлементно скопируем значения из массива a в b и получим транспонированную матрицу</p>

  <details>
    <summary>Транспонирование матрицы в другую матрицу</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int n = 3, m = 4;
  int a[n][m];
  int b[m][n];
  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; m; j++) {
      cin &gt;&gt; a[i][j];
    }
  }
  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; m; j++) {
      b[j][i] = a[i][j];
    }
  }

  return 0;
}
</pre>
  </details>

  <h4>Поиск минимального элемента матрицы</h4>
<pre>
int amin = a[0][0], imin = 0, jmin = 0;
for (int i = 0; i &lt; n; i++) {
  for (int j = 0; j &lt; m; j++) {
    if (a[i][j] &lt; amin) {
      amin = a[i][j];
      imin = i;
      jmin = j;
    }
  }
}
cout &lt;&lt; amin;
</pre>

  <h4>Поиск максимального элемента матрицы</h4>
<pre>
int amax = a[0][0], imax = 0, jmax = 0;
for (int i = 0; i &lt; n; i++) {
  for (int j = 0; j &lt; m; j++) {
    if (a[i][j] &gt; amax) {
      amax = a[i][j];
      imax = i;
      jmax = j;
    }
  }
}
cout &lt;&lt; amax;
</pre>

  <h4>Поиск первого отрицательного элемента матрицы</h4>
  <p>Гарантируется что хотя бы один отрицательный элемент есть в матрице</p>
<pre>
int ing = 0, jng = 0;
bool OK = false;
for (int i = 0; i &lt; n; i++) {
  for (int j = 0; j &lt; m; j++) {
    if (a[i][j] &lt; 0) {
      ing = i;
      jng = j;
      OK = true;
      break;
    }
  }
  if(OK) break;
}
cout &lt;&lt; a[ing][jng];
</pre>
  <p>Если мы хотим найти первый отрицательный элемент обходя матрицу сначала по столбцам, а затем по строкам, то надо поменять циклы по i и по j местами
  </p>

  <h4>Квадратная матрица</h4>
  <p>Квадратная матрица это двумерный массив, у которого количество строк и столбцов совпадает. В квадратной матрице есть главная диагональ (от a[0][0] до a[n-1][n-1]) и побочная диагональ (от a[0][n-1] до a[n-1][0])</p>
  <p>Мы можем транспонировать квадратную матрицу в текущем массиве без объявления еще одного массива.</p>
<pre>
for (int i = 0; i &lt; n; i++) {
  for (int j = 0; j &lt; n; j++) {
    int t = a[i][j];
    a[i][j] = a[j][i];
    a[j][i] = t;
  }
}
</pre>
  <p>Одной из типовых задач является обход главной и побочной диагонали матрицы</p>

  <details>
    <summary>Сумма элементов главной диагонали</summary>
<pre>
int n = 3;
int a[n][n];
int s = 0;
for (int i = 0; i &lt; n; i++) {
  s += a[i][i];
}
</pre>
  </details>

  <details>
    <summary>Сумма элементов побочной диагонали</summary>
<pre>
int n = 3;
int a[n][n];
int s = 0;
for (int i = 0; i &lt; n; i++) {
  s += a[i][n-i-1];
}
</pre>
  </details>

  <p>Часто нужно работать с элементами, которые находятся над главной диагональю или под ней.</p>

  <details>
    <summary>Сумма элементов над главной диагональю</summary>
<pre>
int s = 0;
for (int i = 0; i &lt; n; i++) {
  for (int j = i+1; j &lt; n; j++) {
  s += a[i][j];
}
</pre>
  </details>

  <details>
    <summary>Сумма элементов под главной диагональю</summary>
<pre>
int s = 0;
for (int i = 0; i &lt; n; i++) {
  for (int j = 0; j &lt; i; j++) {
  s += a[i][j];
}
</pre>
  </details>

  <details>
    <summary>Вывод диагоналей</summary>
<pre>
input
1 2 3
4 5 6
7 8 9
</pre>
<pre>
output
3
2 6
1 5 9
4 8
7
</pre>
<pre>
int i = 0, j = n - 1;
while (true) {
  cout &lt;&lt; a[i][j] &lt;&lt; " ";
  i++, j++;
  if (i == n && j == 1) break;
  if (i == n) {
    i = n - j + 1;
    j = 0;
    cout &lt;&lt; '\n';
  } else if (j == n) {
    j = n - i - 1;
    i = 0;
    cout &lt;&lt; '\n';
  }
}
</pre>
  </details>


  <details>
    <summary>Задача 1. Бухгалтерский учет</summary>
    <h4>Бухгалтерский учет</h4>
    <p>На Галлифрее в году m месяцев, в каждом месяце n дней. Вам известно количество денег, которое заработала некая компания в каждый день года. Вам требуется для каждого месяца найти суммарную выручку компании за этот месяц.</p>
    <h4>Входные данные</h4>
    <p>Первая строка входных данных содержит два целых числа n,m (1&le;n,m&le;500) - количество дней в месяце и количество месяцев в году соответственно</p>
    <p>В следующих n строках записано по m чисел. Число, записанное в i-й строке на j-й позиции, обозначает количество денег, которое заработала компания в i-й день j-о месяца. Все числа в таблице целые и не превосходят 10<sup>9</sup> по модулю.</p>
    <h4>Выходные данные</h4>
    <p>Выведите m чисел - суммарную выручку компании в каждый месяц.</p>

    <h4>Пример 1</h4>
<pre>
3 4
7 2 4 3
9 3 3 6
2 7 8 9
</pre>
    <code>Output: 18 12 15 18</code>

    <h4>Пример 2</h4>
<pre>
5 6
4 5 0 7 7 0
6 4 6 2 1 4
2 0 3 9 0 1
0 5 6 9 8 1
4 7 9 8 8 9
</pre>
    <code>Output: 16 21 24 35 24 15 </code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int n, m; // n-days, m-months
  cin &gt;&gt; n &gt;&gt; m;
  int a[n][m];
  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; m; j++) {
      cin &gt;&gt; a[i][j];
    }
  }

  long long b[m];
  long long sum = 0;
  for (int j = 0; j &lt; m; j++) {
    for (int i = 0; i &lt; n; i++) {
      sum += a[i][j];
    }
    b[j] = sum;
    sum = 0;
  }

  for (int j = 0; j &lt; m; j++) {
    cout &lt;&lt; b[j] &lt;&lt; " ";
  }

  return 0;
}
</pre>
  </details>


  <details>
    <summary>Задача 2. Перевернуть массив</summary>
    <h4>Перевернуть массив</h4>
    <p>Вы уже научились переворачивать одномерный массив. Теперь настало время двумерных! Переворотом двумерного массива называется массив, в котором все строчки идут в обратном порядке, как и элементы в каждой строке.</p>
    <h4>Входные данные</h4>
    <p>В первой строке входных данных записано два целых числа n,m (1&le;n,m&le;500) - количество строк и столбцов в массиве соответственно</p>
    <p>В следующих n строках записано по m чисел - данный вам массив. Все числа в массиве целые, и по модулю не превосходят 10<sup>9</sup></p>
    <h4>Выходные данные</h4>
    <p>Выведите перевернутый массив.</p>

    <h4>Пример 1</h4>
<pre>
3 5
1 2 3 4 5
6 7 8 9 10
11 12 13 14 15
</pre>
<pre>
Output:
15 14 13 12 11
10 9 8 7 6
5 4 3 2 1
</pre>

    <h4>Пример 2</h4>
<pre>
3 4
7 2 4 3
9 3 3 6
2 7 8 9
</pre>
<pre>
Output:
9 8 7 2
6 3 3 9
3 4 2 7
</pre>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int n, m;
  cin &gt;&gt; n &gt;&gt; m;
  int a[n][m];
  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; m; j++) {
      cin &gt;&gt; a[i][j];
    }
  }

  for (int i = n - 1; i &gt;= 0; i--) {
    for (int j = m-1; j &gt;= 0; j--) {
      cout &lt;&lt; a[i][j] &lt;&lt; " ";
    }
    cout &lt;&lt; endl;
  }

  return 0;
}
</pre>
  </details>


  <details>
    <summary>Задача 3. Переворот массива 2</summary>
    <h4>Переворот массива 2</h4>
    <p>Массиву нравится переворачиваться! В этой задачей переворотом массива называется его симметричное отражение относительно побочной диагонали. Побочная диагональ - это диагональ, которая идет из нижнего левого угла в правый верхний.</p>
    <h4>Входные данные</h4>
    <p>В первой строке записано единственное целое число n (1&le;n&le;500) - количество строк и столбцов в массиве.</p>
    <p>В следующих n строках записано по n чисел - элементы массива. Каждое число целое и не превосходит 10<sup>9</sup> по модулю.</p>
    <h4>Выходные данные</h4>
    <p>Выведите перевернутый массив.</p>

    <h4>Пример 1</h4>
<pre>
4
1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 16
</pre>
<pre>
Output:
16 12 8 4
15 11 7 3
14 10 6 2
13 9 5 1
</pre>

    <h4>Пример 2</h4>
<pre>
3
4 6 5
3 8 9
9 1 8
</pre>
<pre>
Output:
8 9 5
1 8 6
9 3 4
</pre>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int n;
  cin &gt;&gt; n;
  int a[n][n];
  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; n; j++) {
      cin &gt;&gt; a[i][j];
    }
  }

  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; n; j++) {
      cout &lt;&lt; a[n-j-1][n-i-1] &lt;&lt; " ";
    }
    cout &lt;&lt; endl;
  }

  return 0;
}
</pre>
  </details>


  <details>
    <summary>Задача 4. Запросы к трехмерному массиву</summary>
    <h4>Запросы к трехмерному массиву</h4>
    <p>Вы со своим напарником проникли в банк массивов, и нашли там самый большой и самый красивый массив. Пока вы любовались его совершенством, ваш напарник по быстрому его упаковывал. Прибежав домой вы обнаружили, что упакован массив был довольно плохо - часть элементов потерялась. Теперь вам необходимо их восстановить. Поскольку вы очень долго им любовались, то запомнили массив во всех деталях. Поскольку восстановлением массива занимается ваш напарник, то он иногда спрашивает у вас, что хранилось раньше в массиве в ячейке с индексами i, j, k. Вам необходимо ответить на все его запросы. Массив нумеруется с единицы.</p>
    <h4>Входные данные</h4>
    <p>В первой строке записано три целых числа k, n, m (1 ≤ k, n, m ≤ 50) - высота, ширина и длинна массива соответственно.</p>
    <p>Далее следует k блоков, в i-м блоке описан i-й слой трехмерной таблицы. Каждый слой представляет из себя двумерный массив с n строками и m столбцами, в каждой ячейке которого записано по одному целому числу, по модулю не превосходящему 10⁹. После каждого слоя следует пустая строка.</p>
    <p>После описания массива записано число Q (1 ≤ Q ≤ 10⁴) - количество запросов напарника.</p>
    <p>В следующих Q строках записаны сами запросы. Каждый запрос описывается тремя целыми числами i, j, t (1 ≤ i ≤ k; 1 ≤ j ≤ n; 1 ≤t ≤ m). В ответ на этот запрос требуется вывести число, которое находится в i-м по высоте слое, в j-й строке и t-м столбце.</p>
    <h4>Выходные данные</h4>
    <p>Выведите Q чисел по одному в строке - ответы на запросы вашего напарника.</p>

    <h4>Пример 1</h4>
<pre>
2 3 4
1 2 3 4
5 6 7 8
9 10 11 12

13 14 15 16
17 18 19 20
21 22 23 24

5
1 1 1
1 1 2
1 2 1
2 3 4
2 2 2
</pre>
<pre>
Output:
1
2
5
24
18
</pre>

    <h4>Пример 2</h4>
<pre>
3 4 5
6 4 1 7 7
3 1 4 6 9
9 4 6 10 7
6 3 9 7 6

3 1 5 8 3
5 2 4 3 1
2 3 6 4 10
4 3 8 9 7

1 7 10 1 2
5 1 2 7 1
6 4 8 5 9
6 3 8 7 2

10
1 4 5
2 1 3
2 4 5
2 3 2
1 1 3
3 1 4
1 2 5
3 3 2
1 3 4
3 2 5
</pre>
<pre>
Output:
6
5
7
3
1
1
9
4
10
1
</pre>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // входные данные
  int k, n, m;
  cin >> k >> n >> m;

  // создаем и заполняем трехмерный массив
  int a[k+1][n+1][m+1];
  for (int i = 1; i &lt;= k; i++) {
    for (int j = 1; j &lt;= n; j++) {
      for (int t = 1; t &lt;= m; t++) {
        cin >> a[i][j][t];
      }
    }
  }

  int q;
  cin >> q;

  for (int qi = 1; qi &lt;= q; qi++) {
    int i, j, t;
    cin >> i >> j >> t;
    cout &lt;&lt; a[i][j][t] &lt;&lt; '\n';
  }
}
</pre>
  </details>

  <details>
    <summary>Задача 5. Чемпионат мира по шахматам</summary>
    <h4>Чемпионат мира по шахматам</h4>

    <p>Вы решили стать чемпионом мира по шахматам! К сожалению, на турниры пускают только игроков с высоким рейтингом, поэтому сначала надо получить разряд, хотя бы четвертый. Вы пришли на рейтинговый турнир, а там произошел невообразимый скандал! Организаторы не верят, что вы умеете играть в шахматы и попросили вас пройти квалификацию.</p>

    <p>Квалификация - очень простой процесс для вас. На доске стоит конь, требуется отметить все клетки, в которые он может походить. К счастью, у вас с собой был компьютер, поэтому вы сразу сели писать программу, которая решает эту задачу.</p>

    <h4>Входные данные</h4>

    <p>Во входных данных записана шахматная доска. Она представляет из себя таблицу 8x8, в каждой клетке которой записан символ точки (номер 46 в ASCII таблице), кроме одной - в ней записан символ K (номер 75 в ASCII таблице). В этой выделенной точке стоит конь.</p>

    <h4>Выходные данные</h4>

    <p>Выведите таблицу в аналогичном формате, заменив все символы точек на символ ! (номер 33 в ASCII таблице) для всех ячеек, в которые может походить конь.</p>

    <h4>Примечание</h4>

    <p>Конь всегда ходит на две клетки в одном направлении (горизонтальном или вертикальном) и на одну в перпендикулярном изначальному. Смотрите первый тест для более точного понимания ходов коня.</p>

    <h4>Sample Input 1:</h4>
<pre>
........
........
........
........
....K...
........
........
........
</pre>

    <h4>Sample Output 1:</h4>
<pre>
........
........
...!.!..
..!...!.
....K...
..!...!.
...!.!..
........
</pre>

    <h4>Sample Input 2:</h4>
<pre>
........
........
........
........
........
........
........
K.......
</pre>

    <h4>Sample Output 2:</h4>
<pre>
........
........
........
........
........
.!......
..!.....
K.......
</pre>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int ki, kj;

  // создаем и заполняем шахматную доску
  char a[8][8];
  for (int i = 0; i &lt; 8; i++) {
    for (int j = 0; j &lt; 8; j++) {
      cin >> a[i][j];
      if (a[i][j] == 75) {
        ki = i;
        kj = j;
      }
    }
  }

  // создаем массив ходов коня
  int b[8][2] = { {1,2},{ 2,1 },{2,-1},{1,-2},
                {-1,-2},{-2,-1},{-2,1},{-1,2}};
  for (int i = 0; i &lt; 8; i++) {
    if ((ki + b[i][0]) >=0 && (ki + b[i][0]) &lt;
    8 && (kj + b[i][1]) >=0 && (kj + b[i][1]) &lt; 8) {
      a[ki + b[i][0]][kj + b[i][1]] = 33;
    }
  }

  for (int i = 0; i &lt; 8; i++) {
    for (int j = 0; j &lt; 8; j++) {
      cout &lt;&lt; a[i][j];
    }
    cout &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- 3.3 Квадратичные сортировки -->
<article class="article">
  <div class="anchor" id="p3.3"></div>
  <h3>3.3 Квадратичные сортировки</h3>

  <p>На вход подается массив (последовательность) чисел. Необходимо отсортировать его по невозрастанию или неубыванию элементов.</p>
  <p>Рассмотрим пример, как можно упорядочить по неубыванию три элемента a, b, c. Для этого мы може последовательно сравнить пары a и b, a и c, b и c.За три сравнения мы упорядочим значения наших элементах. Тот же алгоритм будет работать для четырех переменных a, b, c, d.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a, b, c, d;
  cin >> a >> b >> c >> d;
  if (a > b) swap(a, b);
  if (a > c) swap(a, c);
  if (a > d) swap(a, d);
  if (b > c) swap(b, c);
  if (b > d) swap(b, d);
  if (c > d) swap(c, d);
  cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b &lt;&lt; ' '
       &lt;&lt; c &lt;&lt; ' ' &lt;&lt; d &lt;&lt; '\n';

  return 0;
}
</pre>
  <p>Такой алгоритм легко обобдить для n элементов. swap(a, b) меняет значения a и b местами.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int a[1000];
  for (int i = 0; i &lt; 1000; i++) {
    cin >> a[i];
  }

  // сортировка
  for (int i = 0; i &lt; 1000; i++) {
    for (int j = i + 1; j &lt; 1000; j++) {
      if (a[i] > a[j]) {
        swap(a[i], a[j]);
      }
    }
  }

  // вывод результата
  for (int i = 0; i &lt; 1000; i++) {
    cout &lt;&lt; a[i] &lt;&lt; ' ';
  }

  return 0;
}
</pre>

  <h4>Сортировка выбором</h4>
  <p>Можно немного модифицировать предыдущую сортировку. Давайте не будем менять переменные местами каждый раз когда a[i] > a[j]. Будем искать такой индекс j при котором a[j] будет минимальным от i до конца массива. Будем хранить минимальный индекс элемента в переменной jmin. Будем менять i-й элемент с минимальным после i, если мыл найден меньший элемент.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int a[1000];
  for (int i = 0; i &lt; 1000; i++) {
    cin >> a[i];
  }

  // сортировка выбором
  for (int i = 0; i &lt; 1000; i++) {
    int jmin = i;
    for (int j = i + 1; j &lt; 1000; j++) {
      if (a[jmin] > a[j]) {
        jmin = j;
      }
    }
    swap(a[i], a[jmin]);
  }

  // вывод результата
  for (int i = 0; i &lt; 1000; i++) {
    cout &lt;&lt; a[i] &lt;&lt; ' ';
  }

  return 0;
}
</pre>

  <h4>Сортировка пузырьком</h4>
  <p>Попарно сравнимаем соседние элементы массива начиная с первых двух. Если элемент больше следующего, то мы их меняем местами. В массиве из n элементов мы можем повторить данный алгоритм n-1 раз. За первый проход самый большой элемет становится в конец массива. Повторив этот алгоритм n-1 раз мы поставим все элементы на свои места.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int a[1000];
  for (int i = 0; i &lt; 1000; i++) {
    cin >> a[i];
  }

  // сортировка пузырьком
  for (int i = 0; i &lt; 1000 - 1; i++) {
    for (int j = 0; j &lt; 1000 - 1; j++) {
      if (a[j] > a[j+1]) {
        swap(a[j], a[j+1]);
      }
    }
  }

  // вывод результата
  for (int i = 0; i &lt; 1000; i++) {
    cout &lt;&lt; a[i] &lt;&lt; ' ';
  }

  return 0;
}
</pre>
  <p>Оценка времени работы алгоритма. Алгоритм выполняемт (n-1)*(n-1) действий. Если пренебречь -1, получим n². Такая сортировка будет работать очень долго при n = 10⁵</p>

  <h4>Сортировка расческой</h4>
  <p>Это улучшенная сортировка пузырьком. Изначально сравниваем не соседние, а находящиеся на некотором фиксированном расстоянии элементы. После каждого проходя уменьшаем это расстояние, пока оно не станет равно 1.</p>

  <h4>Сортировка вставками</h4>
  <p>Данный алгоритм не является эффективным. Его используют в гибридных сортировках, использующих сразу несколько алгоритмов сортировки. Применяют для небольшого числа элементов, например 20. Представим, что у нас уже есть отсортированный по неубыванию массив, в который надо добавить один элемент. Если данный элемент больше всех элементов, то мы его добавим в конец. Иначе, надо найти позицию куда добавить заданный элемент, сдвинув все элементы больше его вправо.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int a[1000];
  for (int i = 0; i &lt; 1000; i++) {
    cin >> a[i];
  }

  // сортировка вставками
  for (int i = 0; i &lt; 1000; i++) {
    int j = i;
    for (int k = i - 1; k >= 0; k--) {
      if (a[k] > a[i]) {
        j = k;
      }
    }
    int tmp = a[i];
    for (int k = i; k > j; k--) {
      a[k] = a[k-1];
    }
    a[j] = tmp;
  }

  // вывод результата
  for (int i = 0; i &lt; 1000; i++) {
    cout &lt;&lt; a[i] &lt;&lt; ' ';
  }

  return 0;
}
</pre>

  <h4>Сортировка Шелла</h4>
  <p>Это улучшение сортировки вставками. Изначально сравниваем и сортируем элементы, стоящие на определенном расстоянии d друг от друга. Потом уменьшаем d постепенно доходя до d = 1.</p>

  <details>
    <summary>Задача 1. Украденная Земля</summary>
    <h4>Украденная Земля</h4>

    <p>В мире много разных планет, и всем присвоены какие-то номера. В вашей звездной системе n+1 планета, у каждое есть свой номер, и эти номера давно отсортированы по неубыванию. События последних лет привели к тому, что Землю украли! Ученые люди сообразительные, поэтому выкинули ее из списка, однако недавно Земля вернулась обратно. Теперь перед вами стоит непростая задача - вернуть Землю обратно в список.</p>

    <h4>Входные данные</h4>

    <p>В этой задаче нет входных данных) Все, что вам надо сделать написать часть программы, которая вставляет номер Земли обратно в упорядоченный список. Конечно, после вставки список все еще должен быть упорядочен. Вы можете полагать, что где-то выше вашей программы объявленна переменная n массив a на n+1 элемент, первые n в котором заполнены числами, идущими в порядке неубывания. Массив нумеруется с 0. Также есть переменная t - в ней содержится число, которое требуется вставить в данный массив. Все элементы массива, а также число t - целые и не превосходят 10⁹ по модулю.</p>

    <h4>Выходные данные</h4>

    <p>Выводить ничего не надо. Достаточно написать такую часть программы, которая вставляет число t в массив a.</p>

    <h4>Sample Input:</h4>
<pre>
8 3
1 2 4 5 6 7 8 9
</pre>

    <h4>Sample Output:</h4>
    <code>1 2 3 4 5 6 7 8 9 </code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // входные данные
  int n = 8; // число планет без Земли
  int t = 3;  // число которое надо вставить
  int a[9] = {1,2,4,5, 6,7,8,9}; // массив

  // сортировка вставками
  a[n] = 1e9 + 228;
  for (int i = 0; i &lt; n + 1; i++) {
    if (a[i] > t) {
      for (int j = n; j > i; j--) {
        a[j] = a[j - 1];
      }
      a[i] = t;
      break;
    }
  }

  // вывод результата
  for (int i = 0; i &lt; n + 1; i++) {
    cout &lt;&lt; a[i] &lt;&lt; ' ';
  }

  return 0;
}
</pre>
  </details>

  <details>
    <summary>Задача 2. Сортировка массива</summary>
    <h4>Сортировка массива</h4>

    <p>В данной задаче необходимо отсортировать массив.</p>

    <h4>Входные данные</h4>

    <p>Вам необходимо реализовать часть программы, которая сортирует массив. Можете полагать, что где-то выше вашей программы объявлена переменная n а также массив a на n элементов. Массив нумеруется с 0. Необходимо отсортировать этот массив.</p>

    <h4>Выходные данные</h4>

    <p>Просто отсортируйте массив, ничего выводить не надо.</p>

    <h4>Sample Input:</h4>
<pre>
10
9 6 8 5 5 2 8 9 2 2
</pre>

    <h4>Sample Output:</h4>
    <code>2 2 2 5 5 6 8 8 9 9</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // входные данные
  int n = 10; // размер массива
  int a[10] = {9,6,8,5,5,2,8,9,2,2}; // массив

  // сортировка пузырьком
  for (int i = 0; i &lt; n; i++) {
    for (int j = 1; j &lt; n; j++) {
      if (a[j - 1] > a[j]) {
        int tmp = a[j];
        a[j] = a[j - 1];
        a[j - 1] = tmp;
      }
    }
  }

  // вывод результата
  for (int i = 0; i &lt; n; i++) {
    cout &lt;&lt; a[i] &lt;&lt; ' ';
  }

  return 0;
}
</pre>
  </details>

  <details>
    <summary>Задача 3. Сортируем выбором</summary>
    <h4>Сортируем выбором</h4>

    <p>В этой задаче необходимо посчитать, сколько операций обмена сделает сортировка выбором в той реализации, что была показана на лекции.</p>

    <h4>Входные данные</h4>

    <p>В первой строке входных данных записано единственное целое число (1 ≤ n ≤ 10⁵ ) - размер массива.</p>

    <p>Во второй строке записано n целых чисел, каждое по модулю не превышает 10⁹ - сам массив.</p>

    <h4>Выходные данные</h4>

    <p>Требуется вывести количество операций обмена, которое совершит сортировка выбором.</p>

    <h4>Sample Input 1:</h4>
<pre>
3
3 2 1
</pre>

    <h4>Sample Output 1:</h4>
    <code>3</code>

    <h4>Sample Input 2:</h4>
<pre>
5
2 4 3 2 5
</pre>

    <h4>Sample Output 2:</h4>
    <code>5</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // входные данные
  int n; // размер массива
  cin >> n;
  int a[1000]; // массив
  for (int i = 0; i &lt; n; i++) {
    cin >> a[i];
  }

  // сортировка выбором
  int cnt = 0;
  for (int i = 0; i &lt; n; i++) {
    int jmin = i;
    for (int j = i + 1; j &lt; n; j++) {
      if (a[jmin] > a[j]) {
        jmin = j;
      }
    }
    int tmp = a[i];
    a[i] = a[jmin];
    a[jmin] = tmp;
    cnt++;
  }

  // вывод результата
  cout &lt;&lt; cnt;

  return 0;
}
</pre>
  </details>

  <details>
    <summary>Задача 4. Сортируем пузырьком</summary>
    <h4>Сортируем пузырьком</h4>

    <p>В этой задаче необходимо посчитать, сколько операций обмена сделает сортировка пузырьком в той реализации, что была показана на лекции.</p>

    <h4>Входные данные</h4>

    <p>В первой строке входных данных записано единственное целое число n (1≤n≤1000) - размер массива.</p>

    <p>Во второй строке записано n целых чисел, каждое по модулю не превышает 10⁹ - сам массив.</p>

    <h4>Выходные данные</h4>

    <p>Требуется вывести количество операций обмена, которое совершит сортировка пузырьком.</p>

    <h4>Sample Input 1:</h4>
<pre>
3
3 2 1
</pre>

    <h4>Sample Output 1:</h4>
    <code>3</code>

    <h4>Sample Input 2:</h4>
<pre>
5
2 4 3 2 5
</pre>

    <h4>Sample Output 2:</h4>
    <code>3</code>
  </details>
</article>


<!-- 3.4 Функции -->
<article class="article">
  <div class="anchor" id="p3.4"></div>
  <h3>3.4 Функции</h3>

  <p>Функции позволяют повторно использовать ранее разработанный код. В библиотеке C++ есть уже готовые функции. Например, abs() которая возвращающая модуль числа. Для этого вы используете чужой код, который выполняет некоторые операции. Часто бывает необходимо разработать собственные функции. При объявлении функции необходимо указать тип возвращаемого значения, имя функции и в круглых скобках параметры, которые принимает функция. Если параметров нет, то скобки должны быть пустыми. Далее в фигурных скобках пишется тело функции.</p>
  <code>int func(int a, int b) {}</code>
  <p>Напишем функцию sum() которая возвращает сумму двух чисел, переданных по параметрам.</p>
<pre>
int sum(int a, int b) {
  return a + b;
}

int main() {
  int x = 2, y = 3;
  cout &lt;&lt; sum(x, y);
  return 0;
}
</pre>
  <p>Переменные x и y при вызове функции были скопированы в переменные a и b.</p>
  <p>Напишем функцию _min() которая находит минимальное значение двух чисел, переданных по параметрам.</p>
<pre>
int _min(int a, int b) {
  if (a &lt; b) {
    return a;
  } else {
    return b;
  }
}

int main() {
  cout &lt;&lt; _min(2, 1);
  return 0;
}
</pre>
  <p>Что делать если нужно найти минимум не из двух, а из трех чисел? У нас уже есть фукция, которая ищет минимум из двух чисел. Конечно, можно объявить новую функцию и назвать ее _min3(). Но можно ее назвать как и предыдущую _min(). После чего у нас в программе будет две функции с одним и тем же названием. Но они различаются по количеству параметров. Это будет корректно работать. Если у вас есть две функции с одинаковым именем, но разным количеством параметров, то компилятор будет считать их разными функциями. В зависимости от того сколько переменных передается при вызове, будет вызвана та функция которая принимает столько же параметров.</p>
<pre>
int _min(int a, int b) {
  if (a &lt; b) {
    return a;
  } else {
    return b;
  }
}

int _min(int a, int b, int c) {
  return _min(a, _min(b, c));
}

int main() {
  cout &lt;&lt; _min(2, 1, 3);
  return 0;
}
</pre>
  <p>Что делать если нам нужно найти минимальное значение двух вещественных чисел? А у нас есть только функция для нахождения минимального значения двух целых чисел. Если вызвать функцию для целых чисел, передав туда вещественные числа, она будет работать, но неправильно. Произойдет неявное приведение типов. Вещественные числа, которые вы передадите по параметрам, будут приведены к типу int. Будет отброшена дробная часть числа. Чилса станут целочисленными. Функция вернет минимум из двух целых чисел.</p>
  <p>Для того чтобы находить минимум из двух вещественных чисел, мы можем написать функцию _min(), уже третью в нашей программе. В качестве типа возвращаемого значения она вернет тип double. В качестве параметров будет два числа типа double. Противоречия с уже написанными функциями не будет. Программа при вызове функции _min() с двумя вещественными числами вызовет нужную функцию.</p>
<pre>
int _min(int a, int b) {
  if (a &lt; b) {
    return a;
  } else {
    return b;
  }
}

int _min(int a, int b, int c) {
  return _min(a, _min(b, c));
}

double _min(double a, double b) {
  if (a &lt; b) {
    return a;
  } else {
    return b;
  }
}

int main() {
  cout &lt;&lt; _min(2.6, 5.1);
  return 0;
}
</pre>
  <p>Мы можем в одной и той же программе объявлять функции с одинаковым именем, но различными параметрами и типом возвращаемого значения. Это называется перегрузкой функции. Например, библиотечная функция abs() является перегруженной функцией и возвращает тот же тип, что в нее передается по параметрам. Это работает, потому что она имеет несколько реализаций.</p>
  <p>Напишем функцию, которая принимает массив и выводит его на экран. Данная функция не возвращает какое-либо значение в точку вызова программы.</p>
<pre>
void ptint(int a[], int n) {
  for (int i = 0; i &lt; n; i++) {
    cout &lt;&lt; a[i] &lt;&lt; " ";
  }
}

int main() {
  int n = 0;
  cin >> n;
  int a[n];
  for (int i = 0; i &lt; n; i++) {
    cin >> a[i];
  }
  print (a, n);
  return 0;
}
</pre>

  <h4>Передача параметра по значению</h4>
  <p>Что будет если мы будем менять значения переменных, переданных как параметры внутри функции? Если это тип int или double, то они будут скопированы по значению. Меняя значения переменных внутри функции мы не изменим значения переменных в точке вызова функции.</p>
  <p>В данном примере изменение переменной a внутри функции не изменит значение переменной x в точке вызова.</p>
<pre>
void test(int a) {
  a = a + 1;
}

int main() {
  int x = 3;
  test(x);
  cout &lt;&lt; x;
  return 0;
}
</pre>

  <h4>Передача параметра по ссылке</h4>
  <p>В случае с массивами происходит ситуация при которой мы передаем массив по ссылке. Любые изменения значений массива внутри функции приводят к изменению значений массива в точке вызова. У нас один и тот же массив будедт в функции main() и в функции test(). Если нужно изменить массив внутри функции, но чтобы он не менялся вне функции, нужно создать копию массива внутри функции, по элементно скопировав значения переданного массива и работать в дальнейшем с копией данного массива.</p>
<pre>
void test(int a[], int n) {
  a[0] = 9;
}

int main() {
  int a[5];
  a[0] = 17;
  test(a, 5);
  cout &lt;&lt; a[0];
  return 0;
}
</pre>
  <p>Напишем функцию, которая находит индекс минимального элемента массива. Размер массива будем хранить как глобальную переменную и обращаться к ней внутри функции.</p>
<pre>
int n = 0;

int index_min(int a[]) {
  int imin = 0;
  for (int i = 0; i &lt; n; i++) {
    if (a[i] &lt; a[imin]) {
      imin = i;
    }
  }
  return imin;
}

int main() {
  cin >> n;
  int a[n];
  for (int i = 0; i &lt; n; i++) {
    cin >> a[i];
  }
  cout &lt;&lt; index_min(a);
  return 0;
}
</pre>

  <details>
    <summary>Задача 1. Сумма чисел</summary>
    <h4>Сумма чисел</h4>
    <p>Необходимо написать функцию, которая находит сумму двух чисел.</p>

    <h4>Входные данные</h4>
    <p>В этой задаче нет входных данных. Вам необходимо лишь реализовать функцию с именем sum, которая принимает два целых числа типа int.</p>

    <h4>Выходные данные</h4>

    <p>Ваша функция должна вернуть одно числа типа int - сумму данных чисел.</p>
<pre>
int sum(int a, int b) {
  return a + b;
}
</pre>
  </details>

  <details>
    <summary>Задача 2. Произведение чисел</summary>
    <h4>Произведение чисел</h4>
    <p>Необходимо написать функцию, которая выводит произведение чисел на экран.</p>

    <h4>Входные данные</h4>
    <p>Вам требуется написать функцию, которая называется product, принимает два целых числа, по модулю не превосходящие 10⁹.</p>

    <h4>Выходные данные</h4>
    <p>Функция должна вывести на экран произведение данных чисел.</p>
<pre>
void product(long long a, long long b) {
  cout &lt;&lt; a * b;
}
</pre>
  </details>

  <details>
    <summary>Задача 3. Максимум в массиве</summary>
    <h4>Максимум в массиве</h4>

    <p>В этой задаче вам необходимо написать функцию, которая находит максимум в массиве.</p>

    <h4>Входные данные</h4>
    <p>Вам требуется реализовать функцию get_max, которая первым своим аргументом принимает целое число n - количество элементов в массиве. Вторым аргументом эта функцию должна принимать сам массив, содержащий целые числа, по модулю не превышающие 10⁹. Массив нумернуется с 0.</p>

    <h4>Выходные данные</h4>
    <p>Функция должна вернуть одно целое число - позицию максимального элемента в массиве. Если максимальных элементов несколько, верните позицию любого.</p>
<pre>
int get_max(int n, int a[]) {
  int maxi = 0;
  for (int i = 1; i &lt; n; i++) {
    if (a[i] > a[maxi]) {
      maxi = i;
    }
  }
  return maxi;
}
</pre>
  </details>

  <details>
    <summary>Задача 4. Сортировка массива</summary>
    <h4>Сортировка массива</h4>

    <p>В этой задаче необходимо реализовать функцию, которая сортирует массив.</p>

    <h4>Входные данные</h4>
    <p>Реализуйте функцию my_sort, которая в качестве аргументов принимает количество элементов в массиве и сам массив. Все числа целые и не превосходят 1000 по модулю.</p>

    <h4>Выходные данные</h4>
    <p>Отсортируйте данный массив по невозрастанию.</p>
<pre>
void my_sort(int n, int *a) {
  for (int i = 0; i &lt; n ; i++) {
    for (int j = 0; j &lt; n-1; j++) {
      if (a[j+1] > a[j]) {
        int tmp = a[j];
          a[j] = a[j+1];
          a[j+1] = tmp;
      }
    }
  }
}
</pre>
  </details>
</article>


<!-- 3.5 Рекурсия -->
<article class="article">
  <div class="anchor" id="p3.5"></div>
  <h3>3.5 Рекурсия</h3>

  <p>Разберем как работает рекурсия в программировании и разберем что такое стек вызовов функции. Потом поймем что такое переполнение стека - stack overflow.</p>
  <p>Стек это реализация абстрактного типа данных, который работает по принципу LIFO последнний пришел - первый уйдешь. Стек это массив с которым можно делать только два действия. Первое - добавить число в конец массива. Второе забрать и удалить число с конца массива. Мы не можем забрать элемент снизу не вытащив все верхние элементы.</p>
  <p>Как используется стек при вызове функции? Пусть есть три функции a(), b(), c(). Внутри функции a() вызывается функция b(), а внутри функции b() вызывается функция c(). В один момент времени может выполняться только одна функция.</p>
  <p>При вызовве функции b() приостанавливается функция a() и в стек вызовов заносится точка возврата в функцию a(). Функция a() продолит работу только после того как отработают все инструкции функции b().</p>
  <p>Когда функция b() вызовет функцию c(), ее работа приостанавливается и в стек вызовов заносится точка возврата в функцию b(). Когда функция c() полностью отработает, мы вернемся в функцию b(). Когда отработает функция b() мы вернемся к функции a() и закончим выполнение программы.</p>
  <p>Рекурсия в программировании это возможность функции вызывать саму себя.</p>
  <p>Используя рекурсию найдем произведение всех чисел от 1 до n. Это факториал числа.</p>
  <code>n! = 1 * 2 * 3 * ... * n;</code>
  <code>5! = 1 * 2 * 3 * 4 * 5 = 120</code>
  <p>Мы знаем что 5! = 5 * 4!, n = n * (n-1)! Тогда мы можем записать это в виде рекурсивной функции.</p>
<pre>
int f(int n) {
  if (n == 0 || n == 1) {
    return 1;
  } else {
    return n * f(n - 1);
  }
}

int main() {
  cout &lt;&lt; f(5);
  return 0;
}
</pre>
  <p>Как это будет работать. У нас есть стек вызова и в нем хранится информация для возарата управления из вызываемой функции в функцию ее вызвавшую. f(5) вызовет f(4) и уйдет в стек вызовов. f(4) вызовет f(3) и тоже будет занесена в стек вызовов. И так далее пока мы не вызовем f(1) которая вернет нам 1. После этого из стека вызова будут возвращаться функции. f(2) вернет 2. f(3) вернет 6 и так далее пока последняя функция не вернет нам значение нашего факториала.</p>
  <p>Это пример линейной рекурсии. Это когда внутри функции вызывается одна такая же функция.</p>
  <p>Есть еще ветвлящаяся рекурсия. Это когда внутри функции более одного рекурсивного вызова. Пример ветвлящейся рекурсии мы посмотрим на числах Фибоначчи. Каждое число Фибоначчи это сумма двух предыдущих чисел Фибоначчи. Задаются два первых числа и они равны 1. Это и будет условием выхода из рекурсии.</p>
<pre>
int f(int n) {
  if (n == 0 || n == 1) {
    return 1;
  } else {
    return а(n - 1) + f(n - 2);
  }
}

int main() {
  cout &lt;&lt; f(7);
  return 0;
}
</pre>
  <p>Наглядно это можно проиллюстрировать при помощи дерева. Дерево в данном случае перевернуто и его корень находится сверху. Из дерева виден недостаток рекурсии. Для того чтобы посчитать четверное число Фибоначчи, мы вызовем функцию 9 раз. При ветвлении дерево в различных ветвях совпадает, это значит что надо вычислять числа, которые уже вычисляли в другой ветви. И это является существенным минусом рекурсивных алгоритмов.</p>
  <p>Рекурсию нужно использовать осторожно. Потому что это может привести к большому расходу памяти и сделать алгоритм не эффективным. Если рекурсия спускается очень глубоко, может произойти переполнение стека вызовов.</p>

  <details>
    <summary>Задача 1. Факториал</summary>
    <h4>Факториал</h4>
    <p>В этой задаче вам требуется написать рекурсивную функцию, которая посчитает n! = n⋅(n-1)⋅…⋅1.</p>
    <h4>Входные данные</h4>
    <p>Вам необходимо написать рекурсивную функцию factorial, входным параметром которой подается единственное целое число n (0 ≤ n ≤ 20).</p>
    <h4>Выходные данные</h4>
    <p>Функция должна вернуть единственное целое число - факториал данного числа n.</p>
<pre>
long long factorial(long long n) {
  if (n == 1 || n == 0) {
    return 1;
  } else {
    return n * factorial(n-1);
  }
}
</pre>
  </details>

  <details>
    <summary>Задача 2. Переверни ввод</summary>
    <h4>Переверни ввод</h4>
    <p>В этой задаче вам необходимо вывести введенные числа в обратном порядке.</p>
    <h4>Входные данные</h4>
    <p>Вам необходимо реализовать рекурсивную функцию f, которая принимает один параметр n (1 ≤ n ≤ 1000) - количество чисел, которые необходимо считать. Сама функция в процессе рекурсивного вызова должна считать n чисел и вывести их в обратном порядке через пробел.</p>
    <h4>Выходные данные</h4>
    <p>Выведите введенные числа в обратном порядке. Количество чисел выводить не надо.</p>
    <h4>Sample Input:</h4>
<pre>
5
3 1 4 2 5
</pre>
    <h4>Sample Output:</h4>
    <code>5 2 4 1 3 </code>
<pre>
void f(int n) {
  if (n) {
    int tmp;
    cin >> tmp;
    f(--n);
    cout &lt;&lt; tmp &lt;&lt; " ";
  } else {
    return;
  }
}
</pre>
  </details>

  <details>
    <summary>Задача 3. Остров последнего шанса</summary>
    <h4>Остров последнего шанса</h4>
    <p>Одержимая провалила задание Доктора и теперь пытается извиниться. Доктор очень страшен в гневе, поэтому ее извинение больше похоже на бессвязную речь. Пусть n - степень провала. Тогда извинение уровня n есть строка sₙ = Sir, + sₙ₋₁ + because + sₙ₋₁ + sorry. Извинение уровня 0 есть строка s₀ = it's not my fault. Вам известна степень провала Одержимой и вы хотите знать текст ее извинения.</p>
    <h4>Входные данные</h4>
    <p>Во входных данных содержится единственное целое число n (0 ≤ n ≤ 20) - степень провала.</p>
    <h4>Выходные данные</h4>
    <p>Выведите строку-извинение Одержимой.</p>
    <h4>Примечание</h4>
    <p>Обратите внимание на нестандартные ограничения времени и памяти в этой задаче. Также обратите внимание на расстановку пробелов в тестовом примере.</p>
    <h4>Sample Input 1:</h4>
    <code>1</code>
    <h4>Sample Output 1:</h4>
    <code>Sir, it's not my fault because it's not my fault sorry </code>
    <h4>Sample Input 2:</h4>
    <code>2</code>
    <h4>Sample Output 2:</h4>
    <code>Sir, Sir, it's not my fault because it's not my fault sorry because Sir, it's not my fault because it's not my fault sorry sorry </code>
  </details>
</article>

