<article class="article">
  <h1>Основы C/C++ для спортивного программирования</h1>
  <p>Конспект курса</p>
  <p><a href="https://stepik.org/course/80538" target="_blank">https://stepik.org/course/80538</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p><a href="#about">О курсе</a></p>
  <ol>
    <li>
      <a href="#p1">Переменные</a>
      <ol>
        <li><a href="#p1.1">Первая программа, переменные, считывание</a></li>
        <li><a href="#p1.2">Подводные камни</a></li>
        <li><a href="#p1.3">Локальный запуск</a></li>
        <li><a href="#p1.4">Символьный тип данных</a></li>
        <li><a href="#p1.5">Типы данных с плавающей точкой</a></li>
        <li><a href="#p1.6">Логический тип данных</a></li>
        <li><a href="#p1.7">Итоговое тестирование</a></li>
      </ol>
    </li>
    <li>
      <a href="#p2">Условные операторы и циклы</a>
      <ol>
        <li><a href="#p2.1">Логические операции</a></li>
        <li><a href="#p2.2">Условный оператор</a></li>
        <li><a href="#p2.3">Циклы while, do-while</a></li>
        <li><a href="#p2.4">Цикл for</a></li>
        <li><a href="#p2.5">Итоговое тестирование
        </a></li>
      </ol>
    </li>
    <li>
      <a href="#p3">Массивы и функции</a>
      <ol>
        <li><a href="#p3.1">Массивы</a></li>
        <li><a href="#p3.2">Многомерные массивы</a></li>
        <li><a href="#p3.3">Квадратичные сортировки</a></li>
        <li><a href="#p3.4">Функции</a></li>
        <li><a href="#p3.5">Рекурсия</a></li>
        <li><a href="#p3.6">Итоговое тестирование</a></li>
      </ol>
    </li>
    <li>
      <a href="#p4">Сложные структуры данных</a>
      <ol>
        <li><a href="#p4.1">Указатели</a></li>
        <li><a href="#p4.2">Передача параметров в функцию</a></li>
        <li><a href="#p4.3">Структура: определение и поля</a></li>
        <li><a href="#p4.4">Структура: конструкторы и деструкторы</a></li>
        <li><a href="#p4.5">Перегрузка операторов</a></li>
        <li><a href="#p4.6">Vector</a></li>
        <li><a href="#p4.7">String</a></li>
        <li><a href="#p4.8">Итоговое тестирование</a></li>
      </ol>
    </li>
    <li>
      <a href="#p5">Битовые операции и системы счисления</a>
      <ol>
        <li><a href="#p5.1">Быстрое считывание</a></li>
        <li><a href="#p5.2">Системы счисления</a></li>
        <li><a href="#p5.3">Хранение чисел в компьютере</a></li>
        <li><a href="#p5.4">Битовые операции</a></li>
        <li><a href="#p5.5">Итоговое тестирование</a></li>
      </ol>
    </li>
  </ol>
</article>


<!-- О курсе -->
<article class="article">
  <div class="anchor" id="about"></div>
  <h3>О курсе</h3>

  <p>Языки программирования C и C++ традиционно являются одними из «классических» языков спортивного программирования, наиболее удобными и часто используемыми для написания программ на соревнованиях.</p>
  <p>Онлайн-курс «Основы C/C++ для спортивного программирования» познакомит с базовыми понятиями языка. В рамках курса раскрываются такие темы, как переменные, типы данных, условные операторы, циклы, функции и другие.</p>
  <p>Курс рассчитан на четыре недели. Каждое занятие состоит из видеолекций, посвященных определенной тематике, а также практических задач, которые помогут закрепить пройденный материал.Курс рассчитан на четыре недели. Каждое занятие состоит из видеолекций, посвященных определенной тематике, а также практических задач, которые помогут закрепить пройденный материал.</p>
  <p>Онлайн-курс «Основы C/C++ для спортивного программирования» — это первая часть программы интенсивной подготовки по спортивному программированию и искусственному интеллекту RuCode Festival, реализуемой МФТИ совместно с Фондом развития Физтех-школ при поддержке Фонда президентских грантов.</p>

  <h4>Наши преподаватели</h4>
  <p>Владислав Невструев</p>
  <p>Филипп Рухович</p>
  <p>Олег Христенко</p>
  <p>Владимир Куренков</p>
</article>


<!-- 1 Переменные -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>1 Переменные</h3>
</article>


<!-- 1.1 Первая программа, переменные, считывание -->
<article class="article">
  <div class="anchor" id="p1.1"></div>
  <h3>1.1 Первая программа, переменные, считывание</h3>

  <p>Стандартный шаблон программы на C++</p>
<pre>
#include &lt;iostream&gt;

using namespase std;

int main() {
}
</pre>

  <p><strong>iostream</strong> нужен для того чтобы вводить данные с клавиатуры и выводить данные на экран.</p>
  <p><strong>using namespase std</strong> стандартное пространство имен. В больших проектах бывает важно знать откуда взялась та или иная функция: из стандарта языка или из другого места. Поэтом в больших проектах эту строчку не пишут. В олимпиадном программировании есть только стандартное пространство имен. Поэтому нас эта проблема не волнует.</p>
  <p>Любая программа на языке C++ начинается с функции <strong>main()</strong>. В ней пишут команды, которая должна выполнить программа</p>
  <p>Напишем программу, которая будет принимать два целых числа, а в ответ напишет их сумму.</p>

  <h4>Тип данных int</h4>
  <p>Для хранения целых чисел будем использовать тип int, который занимает 4 байта памяти и может хранить числа</p>
  <code>от -2<sup>31</sup> до 2<sup>31</sup>-1</code>
  <code>примерно от -2&bull;10<sup>9</sup> до 2&bull;10<sup>9</sup></code>
  <p>Объявим переменную</p>
  <code>int a;</code>
  <p>Считаем с клавиатуры переменную</p>
  <code>cin &gt;&gt; a;</code>
  <p>Объявим две переменные</p>
  <code>int a, b;</code>
  <p>Считаем с клавиатуры две переменные</p>
  <code>cin &gt;&gt; a &gt;&gt; b;</code>

  <h4>Деление с остатком</h4>
  <p>При целочисленном делении числа a на число b, на ходим такие целые числа q и r, что</p>
  <code>a = q&#8231;b + r, 0 &le; r &lt; b</code>
  <p>q это частное от деления, его возвращает оператор /</p>
  <code>q = a / b</code>
  <p>r это остаток от деления, его возвращает оператор %</p>
  <code>r = a % b</code>

  <h4>Вывод на экран</h4>
  <p>Выведем число</p>
  <code>cout &lt;&lt; 2;</code>
  <p>Выведем слово</p>
  <code>cout &lt;&lt; "hello";</code>
  <p>Выведем слово и перейдем на новую строку</p>
  <code>cout &lt;&lt; "hello" &lt;&lt; endl;</code>

  <h4>Программа сложения двух чисел</h4>
<pre>
#include &lt;iostream&gt;

using namespase std;

int main() {
  int a, b;
  cin &gt;&gt; a &gt;&gt; b;
  cout &lt;&lt; a + b &lt;&lt; endl;
}
</pre>

  <details>
    <summary>Задача 1. Сумма чисел</summary>
    <h4>Сумма чисел</h4>

    <p>В этой задаче вам даны два числа, требуется найти их сумму.</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат два целых числа a, b (-10<sup>9</sup>&le;a,b&le;10<sup>9</sup>)</p>
    <h4>Выходные данные</h4>
    <p>Найдите сумму двух данных чисел</p>
    <h4>Решение</h4>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a, b;
  cin &gt;&gt; a &gt;&gt; b;
  cout &lt;&lt; a + b;
}
</pre>
  </details>

  <details>
    <summary>Задача 2. Периметр прямоугольника</summary>
    <h4>Периметр прямоугольника</h4>

    <p>В этой задаче требуется найти периметр прямоугольника, зная его стороны</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат два целых числа a, b (1&le;a,b&le;1000) - длины сторон прямоугольника</p>
    <h4>Выходные данные</h4>
    <p>В ответ выпишете единственное число - периметр прямоугольника</p>
    <h4>Примечание</h4>
    <p>Периметром прямоугольника называется сумма длин его сторон</p>
    <h4>Решение</h4>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a, b;
  cin &gt;&gt; a &gt;&gt; b;
  cout &lt;&lt; a + a + b + b;
}
</pre>
  </details>

  <details>
    <summary>Задача 3. Объем куба</summary>
    <h4>Объем куба</h4>

    <p>Найдите объем куба, зная длину его ребра</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат единственное целое число a (1&le;a&le;10<sup>3</sup>) - длину ребра куба</p>
    <h4>Выходные данные</h4>
    <p>В ответ выпишете единственное число - объем куба</p>
    <h4>Решение</h4>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a;
  cin &gt;&gt; a;
  cout &lt;&lt; a * a * a;
}
</pre>
  </details>

  <details>
    <summary>Задача 4. Гномий развод</summary>
    <h4>Гномий развод</h4>

    <p>история про Белоснежку и семь гномов. По этим законам, все имущество должно быть самым справедливым образом поделено между гномами, а то, что поделить поровну нельзя, не должно достаться никому из них. Бережливые гномы решили, что неразделённые вещи выкидывать не будут, а отдадут Белоснежке в качестве приданого</p>
    <h4>Входные данные</h4>
    <p>В единственной строке находится число K (0&le;K&le;10<sup>9</sup>) - количество вещей, которые гномы хотят поделить</p>
    <h4>Выходные данные</h4>
    <p>Выведите долю Белоснежки при гномьем разводе</p>
    <h4>Пример</h4>
    <code>Input: 8</code>
    <code>Output: 1</code>
    <h4>Решение</h4>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a;
  cin &gt;&gt; a;
  cout &lt;&lt; a % 7;
}
</pre>
  </details>

  <details>
    <summary>Задача 5. Поменять местами</summary>
    <h4>Поменять местами</h4>

    <p>Дано натуральное четырехзначное число, необходимо поменять местами средние цифры</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат единственное целое четырехзначное число</p>
    <h4>Выходные данные</h4>
    <p>В ответ напишите четырехзначное число, которое получается из исходного обменом двух средних цифр</p>
    <h4>Пример</h4>
    <code>Input: 1890</code>
    <code>Output: 1980</code>
    <h4>Решение</h4>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a;
  cin &gt;&gt; a;
  int a1 = a % 10;
  int a2 = (a / 10) % 10;
  int a3 = (a / 100) % 10;
  int a4 = a / 1000;
  cout &lt;&lt; (a4 * 1000) + (a2 * 100) + (a3 * 10) + a1;
}
</pre>
  </details>

  <details>
    <summary>Задача 6. Просто деление</summary>
    <h4>Просто деление</h4>

    <p>В этой задаче необходимо научиться делить нацело с округлением вверх</p>
    <h4>Входные данные</h4>
    <p>В единственной строке входных данных содержится два целых числа a,b (1 &le;a,b&le;10<sup>9</sup>)</p>
    <h4>Выходные данные</h4>
    <p>Выведите единственное целое число a / b</p>
    <h4>Примечание</h4>
    <p>В этой задаче запрещено использовать условный оператор</p>
    <h4>Пример</h4>
    <code>Input: 7 3</code>
    <code>Output: 3</code>
    <h4>Решение</h4>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a;
  cin &gt;&gt; a &gt;&gt; b;
  cout &lt;&lt; (a - 1 + b) / b;
}
</pre>
  </details>
</article>


<!-- 1.2 Подводные камни -->
<article class="article">
  <div class="anchor" id="p1.2"></div>
  <h3>1.2 Подводные камни</h3>

  <p>Тип int вмещает в себя число до 2 миллиардов. Что будет если попробовать записать число больше? В этом случае возникает <strong>переполнение</strong></p>
  <p>Если умножить миллион на миллион то получим 10<sup>12</sup> это в 500 раз больше чем 2 миллиарда и не вмещается в тип данных int. Давайте проверим что тогда запишется в int</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a = 1000000;
  cout &lt;&lt; a * a;
}
</pre>
  <code>-727379968</code>
  <p>Запишем в int максимальное для него число. Прибавим к нему 1 и выведем на экран. Получим минимальное число типа int</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a = 2147483647;
  a = a + 1;
  cout &lt;&lt; a;
}
</pre>
  <code>-2147483648</code>
  <p>Если результат не помещается в тип данных int, то нужно использовать другой тип данных.</p>

  <h4>Тип данных long long</h4>
  <p>Тип данных long long занимает 8 байт памяти и может хранить целые числа</p>
  <code>от -2<sup>63</sup> до 2<sup>63</sup>-1</code>
  <code>примерно от -4&bull;10<sup>18</sup> до 4&bull;10<sup>18</sup></code>
  <p>Если для наших данных не хватает типа данных long long то нужно либо создавать свой тип данных (задачи с очень большими данными называются <strong>длинная арифметика</strong>) либо переходить на python - там такой проблемы нет.</p>

  <h4>Беззнаковые типы данных unsigned</h4>
  <p>Значения беззнаковых типов данных unsigned могут быть только положительными. Это значит что не нужно тратить память на хранение отрицательных.</p>

  <h4>Тип данных unsigned long long</h4>
  <code>от 0 до 2<sup>64</sup>-1</code>

  <h4>Тип данных short</h4>
  <p>Если типа int слишком много. Например, массив на миллион значений типа int занимает 4mb. То можно использовать тип данных short, который занимает 2 байта и имеет значения</p>
  <code>от -2<sup>15</sup> до 2<sup>15</sup>-1</code>
  <code>примерно от -32000 до 32000</code>

  <h4>Проблема остатка от деления отрицательного числа</h4>
  <p>5 % 3 должно быть равно 2</p>

  <details>
    <summary>Остаток от деления положительного числа</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a, mod;
  cin &gt;&gt; a &gt;&gt; mod;
  cout &lt;&lt; a % mod;
}
</pre>
  </details>

  <p>-5 % 3 математически должно быть равно 1, но программа выдаст ответ -2. Чтобы получить правильный результат, надо к ответу прибавить 3</p>

  <details>
    <summary>Остаток от деления отрицательнгого числа</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a, mod;
  cin &gt;&gt; a &gt;&gt; mod;
  cout &lt;&lt; (a % mod) + mod;
}
</pre>
  </details>

  <p>Но если для положительного числа прибавить mod, то ответ может быть больше чем mod. Чтобы привести его к правильному виду нужно еще раз взять остаток от деления</p>

  <details>
    <summary>Остаток от деления общий случай для положительного и отрицательнгого числа</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a, mod;
  cin &gt;&gt; a &gt;&gt; mod;
  cout &lt;&lt; ((a % mod) + mod) % mod;
}
</pre>
  </details>

  <h4>Переполнение и остаток по модулю</h4>
  <p>Из-за того что при прибавлении 1 к максимальному числу мы получаем минимальное, получается что мы сидим в числах по модулю 2<sup>32</sup> и смещенных на 2<sup>32</sup> для отрицательных чисел</p>

  <details>
    <summary>Задача 1. Произведение чисел</summary>
    <h4>Произведение чисел</h4>

    <p>В этой задаче требуется найти произведение двух целых чисел</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат два целых числа a,b (-10<sup>9</sup>&le;a,b&le;10<sup>9</sup>)</p>
    <h4>Выходные данные</h4>
    <p>В ответ напишите произведение данных чисел</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  long long a, b;
  cin &gt;&gt; a &gt;&gt; b;
  cout &lt;&lt; a * b;
}
</pre>
  </details>

  <details>
    <summary>Задача 2. Сумма чисел</summary>
    <h4>Сумма чисел</h4>

    <p>В этой задаче необходимо найти сумму двух целых чисел</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат два целых числа a,b (0&le;a,b&le;9*10<sup>18</sup>)</p>
    <h4>Выходные данные</h4>
    <p>В ответ напишите сумму данных чисел</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  unsigned long long a, b;
  cin &gt;&gt; a &gt;&gt; b;
  cout &lt;&lt; a + b;
}
</pre>
  </details>

  <details>
    <summary>Задача 3. Остаток от деления</summary>
    <h4>Остаток от деления</h4>

    <p>В этой задаче требуется найти остаток от деления числа a на число b</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат два целых числа a,b (-10<sup>18</sup>&le;a&le;10<sup>18</sup>; 0&le;b&le;10<sup>18</sup>)</p>
    <h4>Выходные данные</h4>
    <p>Выведите остаток от деления a на b</p>
    <h4>Примечание</h4>
    <p>В этой задаче запрещено использовать условный оператор</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  long long a, b;
  cin &gt;&gt; a &gt;&gt; b;
  cout &lt;&lt; (a % b + b) % b;
}
</pre>
  </details>

  <details>
    <summary>Задача 4. Последняя цифра</summary>
    <h4>Последняя цифра</h4>

    <p>В этой задаче требуется найти последнюю цифру данного числа</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат единственное неотрицательное число, по модулю не превосходящее 10<sup>18</sup></p>
    <h4>Выходные данные</h4>
    <p>Найдите последнюю цифру данного числа</p>
    <h4>Примечание</h4>
    <p>В этой задаче запрещено использовать условный оператор</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  long long a;
  cin &gt;&gt; a;
  cout &lt;&lt; a % 10;
}
</pre>
  </details>

  <details>
    <summary>Задача 5. Перестановка разрядов</summary>
    <h4>Перестановка разрядов</h4>

    <p>Дано четырехзначное отрицательное число. Требуется поменять местами число десятков и сотен в нем</p>
    <h4>Входные данные</h4>
    <p>Во входных данных записано единственное четырехзначное отрицательное целое число. Унарный минус не считается знаком</p>
    <h4>Выходные данные</h4>
    <p>Найдите число, полученное из исходного перестановкой числа десятков и сотен в нем</p>
    <h4>Примечание</h4>
    <p>В этой задаче запрещено использовать тип данных char</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  long long a;
  cin &gt;&gt; a;
  int a1 = a % 10;
  int a2 = (a / 10) % 10;
  int a3 = (a / 100) % 10;
  int a4 = (a / 1000) % 10;
  cout &lt;&lt; a4 * 1000 + a2 * 100 + a3 *10 + a1;
}
</pre>
  </details>
</article>


<!-- 1.3 Локальный запуск -->
<article class="article">
  <div class="anchor" id="p1.3"></div>
  <h3>1.3 Локальный запуск</h3>

  <p>Существует много разных сред разработки, позволяющих компилировать и запускать программы. Среди них можно выделить Code Blocks, Visual Studio или напрямую компилирование из консоли для продвинутых. Мы расскажем как работать в Code Blocks. У него есть ряд преимуществ. Он кроссплатформенный, в нем простой интерфейс, встроенный компилятор MinGW. Скачать его можно с оффициального сайта</p>
  <code><a href="https://www.codeblocks.org/downloads/">https://www.codeblocks.org/downloads/</a></code>
  <p>Выбирайте вариант</p>
  <code>codeblocks-20.03mingw-setup.exe</code>
  <p>Предположим вы скачали, установили и запустили CodeBlocks. Вам необходимо создать файл, в котором будете писать код. Для этого в верхнем левом углу есть иконка создать новый файл или пункт меню</p>
  <code>File - New - Empty file (Ctrl+Shift+N)</code>
  <p>Теперь сохраните этот файл. Выберете где он будет располагатья, его имя и в расширении напишите cpp. Это расширение для файлов, написанных на языке C++</p>

  <details>
    <summary>Сумма двух чисел</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a, b;
  cin &gt;&gt; a &gt;&gt; b;
  cout &lt;&lt; a + b;
}
</pre>
  </details>

  <p>На панели с иконками найдите три кнопки "Скомпилировать", "Запустить", "Скомпилировать и запустить". Нажмите "Скомпилировать и запустить". Или выберете пункт меню</p>
  <code>Build - Build and run (F9)</code>
  <p>Можно создать еще один файл. Он откроется в соседней вкладке. И в нем решать вторую задачу. Компилироваться и запускаться будет та программа в открытой вкладке</p>

  <h4>Задача. Создать файл и запустить код</h4>
  <p>Локально на своем компьютере создайте файл stepik_run.cpp, скопируйте в него следующий код и запустите.</p>

  <details>
    <summary>файл stepik_run.cpp</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main(int argc, char *argv[]) {
  cout &lt;&lt; argv[0] &lt;&lt; endl;
  return 0;
}
</pre>
  <code>D:\code\cpp\stepik_run.exe</code>
  </details>

  <p>Вывод программы отправьте в качестве ответа. Обратите внимание - иногда программа выводит дополнительную информацию в духе время работы программы или сообщение, что программа завершилась успешно. Нас это не интересует, ответом является только первая строчка вывода.</p>
</article>


<!-- 1.4 Символьный тип данных -->
<article class="article">
  <div class="anchor" id="p1.4"></div>
  <h3>1.4 Символьный тип данных</h3>

  <p>Символьный тип данных позволяет хранить один символ. Тип char хранит цифры, английские буквы маленькие и большие и большинство символов с клавиатуры. В олимпиадном программировании русские буквы хранить не нужно.</p>
  <p>Каждый символ имеет свой номер. Хранятся не сами символы, а их номера. Когда нужно вывести символ на экран, компьютер берет этот номер и смотрит в специальную таблицу символов и выводит соответствующий символ. Из-за того что хранятся числа, то с символьным типом можно обращаться так же как с целыми числами - прибавлять к ним числа или складывать их между собой.</p>

  <h4>Таблица ASCII</h4>
  <p>Первые 32 символа (с 0 до 31) заняты под служебные.</p>
  <p>Из них в олимпиадном программировании используются 3 символа - 10 (перевод строки), 9 (табуляция) и 4 (конец файла)</p>
  <p>Наиболее полезный 10 символ - символ перевода строки '\n'. Именно он выводится когда мы пишем</p>
  <code>cout &lt;&lt; endl;</code>
  <p>Но есть и отличия. endl переводит строку и сбрасывает буфер. Компьютер не сразу печатает то что вы ему сказали вывести на экран. А предварительно сохраняет ваш вывод в специальную область памяти - буфер.Компьютер сам выводит данные из буфера, когда он наполняется. Выводить данные большими кусками выгоднее чем маленькими, поскольку вывод на экран это ресурсоемкая операция, а компьютер старается ресурсы экономить.</p>
  <p>Сброс буфера это тоже ресурсоемкая задача. Поэтому иногда полезно вместо endl выводить символ '\n'</p>
  <p>Символ табуляции - 9 символ используется редко</p>
  <p>Иногда используется символ конца файла - 4 символ</p>
  <p>Следующие 10 символов (с 32 по 47) содержат специальные знаки (пробел, плюс, минус и т.д.)</p>
  <p>Следующие 16 символов (с 48 по 57) это цифры</p>
  <p>Следующие 7 символов (с 58 по 64) еще немного знаков (больше, меньше, равно)</p>
  <p>Следующие 26 символов (с 65 по 90) это большие английские буквы
  </p>
  <p>Следующие 6 символов (с 91 по 96) еще немного знаков</p>
  <p>Следующие 26 символов (с 97 по 122) это маленькие английские буквы</p>
  <p>И наконец, последние 5 символов (с 123 по 127) еще немного знаков</p>

  <h4>Тип данных char</h4>
  <p>Тип данных char занимает 1 байт памяти и может содержать 256 значений. Мы рассмотрели первые 127. Вторая часть таблицы отведена под локализованные символы.</p>
  <p>Объявим две переменные типа char и считаем в них символы</p>
  <code>char a, b;</code>
  <code>cin &gt;&gt; a &gt;&gt; b;</code>
  <p>Считается первый не пробельный символ. Это значит что символы "пробел", "табуляция" и "перевод строки" не будут считаны.</p>
  <p>Можно одновременно считывать и цифры и символы</p>
  <code>char a, b; int c; cin &gt;&gt; a &gt;&gt; c &gt;&gt; b;</code>
  <code>Input: 1234!?</code>
  <code>a = 1; b = 234, c = !</code>

  <details>
    <summary>Задача 1. Символ по номеру</summary>
    <h4>Символ по номеру</h4>

    <p>В этой задаче вам по числу необходимо вывести соответствующий ему в ASCII таблице символ</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат единственное целое число a (32 &le;a&le;126)</p>
    <h4>Выходные данные</h4>
    <p>Выведите символ, соответствующий этому числу.</p>

    <h4>Пример 1</h4>
    <code>Input: 100</code>
    <code>Output: d</code>

    <h4>Пример 2</h4>
    <code>Input: 36</code>
    <code>Output: $</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a;
  cin &gt;&gt; a;
  cout &lt;&lt; char(a) &lt;&lt; endl;
  return 0;
}
</pre>
  </details>

  <details>
    <summary>Задача 2. Номер по символу</summary>
    <h4>Номер по символу</h4>

    <p>Найдите порядковый номер данного символа в ASCII-таблице</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат единственный непробельный символ, номер которого не меньше 33 и не больше 126.</p>
    <h4>Выходные данные</h4>
    <p>Найдите номер этого символа</p>

    <h4>Пример 1</h4>
    <code>Input: d</code>
    <code>Output: 100</code>

    <h4>Пример 2</h4>
    <code>Input: $</code>
    <code>Output: 36</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  char a;
  cin &gt;&gt; a;
  cout &lt;&lt; int(a) &lt;&lt; endl;
  return 0;
}
</pre>
  </details>

  <details>
    <summary>Задача 3. i-й символ алфавита</summary>
    <h4>i-й символ алфавита</h4>

    <p>В этой задаче вам дано число i, требуется найти i-й символ алфавита</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат единственное целое число i (1&le;i&le;26)</p>
    <h4>Выходные данные</h4>
    <p>Выведите i-й маленький символ латинского алфавита.</p>

    <h4>Пример 1</h4>
    <code>Input: 1</code>
    <code>Output: a</code>

    <h4>Пример 2</h4>
    <code>Input: 12</code>
    <code>Output: l</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int i;
  cin &gt;&gt; i;
  cout &lt;&lt; char(96+i) &lt;&lt; endl;
  return 0;
}
</pre>
  </details>

  <details>
    <summary>Задача 4. Сделать большой</summary>
    <h4>Сделать большой</h4>

    <p>В этой задаче требуется перевести букву из нижнего регистра в верхний</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат единственный маленький символ латинского алфавита</p>
    <h4>Выходные данные</h4>
    <p>Выведите соответствующий большой символ латинского алфавита</p>

    <h4>Пример 1</h4>
    <code>Input: a</code>
    <code>Output: A</code>

    <h4>Пример 2</h4>
    <code>Input: m</code>
    <code>Output: M</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  char a;
  cin &gt;&gt; a;
  cout &lt;&lt; char(a-32) &lt;&lt; endl;
  return 0;
}
</pre>
  </details>

  <details>
    <summary>Задача 5. Первая цифра числа</summary>
    <h4>Первая цифра числа</h4>

    <p>Выпишите первую цифру данного числа</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат единственное целое число a (0&le;a&le;10<sup>100</sup>)</p>
    <h4>Выходные данные</h4>
    <p>В ответ запишите первую цифру введенного числа</p>

    <h4>Пример 1</h4>
    <code>Input: 93099339395097728908</code>
    <code>Output: 9</code>

    <h4>Пример 2</h4>
    <code>Input: 560</code>
    <code>Output: 5</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  char a;
  cin &gt;&gt; a;
  cout &lt;&lt; a &lt;&lt; endl;
  return 0;
}
</pre>
  </details>
</article>


<!-- 1.5 Типы данных с плавающей точкой -->
<article class="article">
  <div class="anchor" id="p1.5"></div>
  <h3>1.5 Типы данных с плавающей точкой</h3>

  <p>Всего есть три типа для работы с дробными числами.</p>
  <p>float 4 байта</p>
  <p>double 8 байт</p>
  <p>long double 16 байт</p>
  <p>Не все дробные числа можно записать в память. С одной стороны, даже между 0 и 1 находится бесконечно много дробных чисел. С другой стороны, иррациональные числа, которые нельзя записать никакой конечной десятичной дробью. Примеры иррациональных чисел "число пи", "корень из двойки", "два в степени корень из двойки". Для их записи в десятичном виде потребуется бесконечно много знаков. Поэтому хранить все дробные числа невозможно и компьютер хранит дробные числа с некоторой погрешностью.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  double a = 3.14, b;
  cin &gt;&gt; b;
  cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; endl;
  return 0;
}
</pre>
  <p>Арифметическите операции такие же как с целыми числами, но есть два отличия.</p>
  <p>При делении дробных чисел получается дробное число. Настолько точное насколько позволяет тип данных. В отличие от целых чисел, где при делении получается целое число, а дробная часть отбрасывается</p>
  <p>Нельзя взять остаток от деления</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  double a, b;
  cin &gt;&gt; a &gt;&gt; b;
  cout &lt;&lt; a / b &lt;&lt; endl;
  return 0;
}
</pre>
  <p>По умолчанию компьютер выводит дробные числа так как ему удобно. Но мы можем задать формат вывода двумя строчками вначале программы</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  cout.setf(ios::fixed);
  cout.precision(10);

  double a, b;
  cin &gt;&gt; a &gt;&gt; b;
  cout &lt;&lt; a / b &lt;&lt; endl;
  return 0;
}
</pre>

  <h4>Экспоненциальная запись</h4>
  <code>1e-6</code>
  <p>Так удобно записывать большие степени 10. В общем случае запись MeP означает: M - мантиса, e - экспоненциальная запись, P - порядок</p>
  <code>MeP = M*10<sup>P</sup></code>
  <code>1e-6 = 1*10<sup>-6</sup> = 0.000001</code>

  <h4>Разница в погрешностях</h4>
  <p>Напишем три программы для трех типов данных</p>
  <p>Подадим на вход число 10<sup>16</sup> + 2 = 10000000000000002</p>
  <p>Посмотрим как погрешность в представлении чисел влияет на результат</p>

<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  float a;
  cin &gt;&gt; a;
  cout &lt;&lt; a + 1 &lt;&lt; endl;
  return 0;
}
</pre>
  <code>Output: 10000000272564224</code>

<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  double a;
  cin &gt;&gt; a;
  cout &lt;&lt; a + 1 &lt;&lt; endl;
  return 0;
}
</pre>
  <code>Output: 10000000000000004</code>

<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  long double a;
  cin &gt;&gt; a;
  cout &lt;&lt; a + 1 &lt;&lt; endl;
  return 0;
}
</pre>
  <code>Output: 10000000000000003</code>

  <details>
    <summary>Задача 1. Пи</summary>
    <h4>Пи</h4>

    <p>В этой задаче вам требуется вывести число π с заданной точностью</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат число n (0&le;n&le;15) - количество знаков после запятой, которое необходимо вывести</p>
    <h4>Выходные данные</h4>
    <p>Выведите число π с заданной точностью</p>

    <h4>Пример 1</h4>
    <code>Input: 2</code>
    <code>Output: 3.14</code>

    <h4>Пример 2</h4>
    <code>Input: 0</code>
    <code>Output: 3</code>
<pre>
#include &lt;iostream&gt;
#include &lt;cmath&gt;

using namespace std;

int main() {
  int a;
  cin &gt;&gt; a;
  cout.setf(ios::fixed);
  cout.precision(a);
  cout &lt;&lt; M_PI &lt;&lt; endl;

  return 0;
}
</pre>
  </details>

  <details>
    <summary>Задача 2. Деление</summary>
    <h4>Деление</h4>

    <p>В этой задаче надо поделить два числа</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат два целых числа a,b (-10<sup>9</sup>&lt;a,b&lt;10<sup>9</sup>; b&ne;0)</p>
    <h4>Выходные данные</h4>
    <p>Выведите результат деления a/b. Ответ будет считаться верным, если абсолютная или относительная погрешность не больше 10<sup>-6</sup></p>

    <h4>Пример 1</h4>
    <code>10 8</code>
    <code>1.2500000000</code>

    <h4>Пример 2</h4>
    <code>1 3</code>
    <code>0.3333333333</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  cout.setf(ios::fixed);
  cout.precision(10);
  double a, b;
  cin &gt;&gt; a &gt;&gt; b;
  cout &lt;&lt; a / b &lt;&lt; endl;

  return 0;
}
</pre>
  </details>

  <details>
    <summary>Задача 3. Почти целое деление</summary>
    <h4>Почти целое деление</h4>

    <p>В этой задаче требуется поделить два числа, а результат округлить до целых по правилам округления в текущей версии языка C++</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат два целых числа a,b (-10<sup>9</sup>&le;a,b&le;10<sup>9</sup>;b&ne;0)</p>
    <h4>Выходные данные</h4>
    <p>Выведите результат деления a/b, округленный до ближайшего целого числа.</p>
    <h4>Примечание</h4>
    <p>В этой задаче запрещено пользоваться условным оператором.</p>

    <h4>Пример 1</h4>
    <code>10 6</code>
    <code>2</code>

    <h4>Пример 2</h4>
    <code>1 3</code>
    <code>0</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  cout.setf(ios::fixed);
  cout.precision(0);
  double a, b;
  cin &gt;&gt; a &gt;&gt; b;
  cout &lt;&lt; a / b &lt;&lt; endl;

  return 0;
}
</pre>
  </details>

  <details>
    <summary>Задача 4. float неточный</summary>
    <h4>float неточный</h4>

    <p>В этой задаче требуется найти разницу между значением целого числа, сохраненного в типе данных float и его реальным значением.</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат единственное целое число, по модулю не превосходящее 10<sup>18</sup></p>
    <h4>Выходные данные</h4>
    <p>Необходимо вывести разницу между значением числа, если его сохранить в тип данных float и его реальным значением. Для более точного понимания условия смотрите примеры.</p>
    <h4>Примечание</h4>
    <p>На разных компьютерах в данном случае поведение вашей программы может отличаться. </p>

    <h4>Пример 1</h4>
    <code>10000000000000003</code>
    <code>272564221</code>

    <h4>Пример 2</h4>
    <code>20000001</code>
    <code>-1</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  long long a;
  float b;
  cin &gt;&gt; a;
  b = float(a);
  cout &lt;&lt; (long long)(b) - a &lt;&lt; endl;

  return 0;
}
</pre>
  </details>
</article>


<!-- 1.6 Логический тип данных -->
<article class="article">
  <div class="anchor" id="p1.6"></div>
  <h3>1.6 Логический тип данных</h3>

  <p>Числа можно сравнивать. Знаки сравнения ==, !=, &lt;, &gt;, &lt;=, &gt;=. Операции сравнения возвращают значение типа bool и могут принимать только два значения 1 - истина, 2 - ложь.</p>
  <code>bool a = (1 &lt; 2); // 1</code>
  <code>bool b = (2 + 2 == 5); // 0</code>
  <p>Тип bool занимает 1 байт памяти. Каждый байт памяти имеет свой адрес. Поэтому быстрее обратиться к любому байту в памяти, чем к любому биту. Под переменную в памяти отводится нужное число байт, чтобы к ней можно было быстро обратиться.</p>
  <p>Существует возможность обратиться к отдельным битам переменной. Но об этом поговорим подробней в 5 модуле.</p>
  <p>Считаем с клавиатуры переменную логического типа</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  bool a;
  cin &gt;&gt; a;
  cout &lt;&lt; a &lt;&lt; endl;

  return 0;
}
</pre>
  <p>Если ввести 0, то в переменной будет 0. Если ввести любое другое число, то в переменной будет 1.</p>
  <p>Вместо 1 и 0 можно писать true и false</p>
  <code>bool a = true; // 1</code>
  <code>bool a = false; // 0</code>
  <p>Арифметические операции с логическими данными всегда оперируют 1 и 0</p>
  <p>cout выводит на экран логические 1 и 0, а не true и false</p>
  <code>cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; endl;</code>

  <details>
    <summary>Задача 1. Равно нулю?</summary>
    <h4>Равно нулю?</h4>

    <p>В этой задаче требуется проверить, что число не равно нулю</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат единственное целое число, по модулю не превосходящее 10<sup>9</sup></p>
    <h4>Выходные данные</h4>
    <p>Выведите 1, если число не равно 0 и 0 иначе</p>
    <h4>Примечание</h4>
    <p>В этой задаче запрещено использовать условный оператор</p>

    <h4>Пример 1</h4>
    <code>10</code>
    <code>1</code>

    <h4>Пример 2</h4>
    <code>-1000000000</code>
    <code>1</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  bool a;
  cin &gt;&gt; a;
  cout &lt;&lt; a &lt;&lt; endl;

  return 0;
}
</pre>
  </details>

  <details>
    <summary>Задача 2. Больше?</summary>
    <h4>Больше?</h4>

    <p>В этой задаче вам необходимо сравнить два числа.</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат два целых числа a,b (-10<sup>9</sup>&le;a,b&le;10<sup>9</sup>)</p>
    <h4>Выходные данные</h4>
    <p>Выведите 1, если a &lt; b и 0 иначе</p>
    <h4>Примечание</h4>
    <p>В этой задаче запрещено использовать условный оператор</p>

    <h4>Пример 1</h4>
    <code>1 4</code>
    <code>1</code>

    <h4>Пример 2</h4>
    <code>2 -2</code>
    <code>0</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a, b;
  cin &gt;&gt; a &gt;&gt; b;
  cout &lt;&lt; (a &lt; b) &lt;&lt; endl;

  return 0;
}
</pre>
  </details>

  <details>
    <summary>Задача 3. Сколько четных?</summary>
    <h4>Сколько четных?</h4>

    <p>В этой задаче вам требуется найти количество четных чисел среди данных пяти.</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат 5 целых чисел, каждое по модулю не превосходит 10<sup>9</sup></p>
    <h4>Выходные данные</h4>
    <p>Единственное число - количество четных чисел среди данных.</p>
    <h4>Примечание</h4>
    <p>В этой задаче запрещено использовать условный оператор.</p>

    <h4>Пример 1</h4>
    <code>1 2 3 4 5</code>
    <code>2</code>

    <h4>Пример 2</h4>
    <code>1 2 1 2 1</code>
    <code>2</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a, b, c, d, e, count;
  cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e;
  count = (a%2 == 0) + (b%2 == 0) + (c%2 == 0) + (d%2 == 0) + (e%2 == 0);
  cout &lt;&lt; count &lt;&lt; endl;

  return 0;
}
</pre>
  </details>

  <details>
    <summary>Задача 4. Сколько больших нуля?</summary>
    <h4>Сколько больших нуля?</h4>

    <p>В этой задаче требуется найти количество чисел, больших нуля среди данных пяти</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат 5 целых чисел, каждое по модулю не превосходит 10<sup>9</sup></p>
    <h4>Выходные данные</h4>
    <p>Единственное число - количество положительных чисел среди данных</p>
    <h4>Примечание</h4>
    <p>В этой задаче запрещено использовать условный оператор.</p>

    <h4>Пример 1</h4>
    <code>1 2 3 4 5</code>
    <code>5</code>

    <h4>Пример 2</h4>
    <code>-2 -1 0 1 2</code>
    <code>2</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a, b, c, d, e, count;
  cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e;
  count = (a &gt; 0) + (b &gt; 0) + (c &gt; 0) + (d &gt; 0) + (e &gt; 0);
  cout &lt;&lt; count &lt;&lt; endl;

  return 0;
}
</pre>
  </details>
</article>


<!-- 1.7 Итоговое тестирование -->
<article class="article">
  <div class="anchor" id="p1.7"></div>
  <h3>1.7 Итоговое тестирование</h3>

  <details>
    <summary>Задача 1. Сумма чисел</summary>
    <h4>Сумма чисел</h4>

    <p>В этой задаче необходимо найти сумму четырех целых чисел</p>
    <h4>Входные данные</h4>
    <p>Во входных данных записано 4 целых числа, каждое по модулю не превышает 10<sup>9</sup></p>
    <h4>Выходные данные</h4>
    <p>В ответ запишите их сумму</p>

    <h4>Пример 1</h4>
    <code>1 2 3 4</code>
    <code>10</code>

    <h4>Пример 2</h4>
    <code>1 -1 2 -2</code>
    <code>0</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  long long a, b, c, d;
  cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
  cout &lt;&lt; a + b + c + d &lt;&lt; endl;

  return 0;
}
</pre>
  </details>

  <details>
    <summary>Задача 2. Метеоритный дождь</summary>
    <h4>Метеоритный дождь</h4>

    <p>Эта задача была взята из муниципального этапа всероссийской олимпиады школьников по информатике в Майкопе.</p>
    <p>В солнечный декабрьский зимний день ничего не предвещало беды. Так думала и команда, которая решила написать очередной контест. Для написания контеста организатор подготовил несколько компьютеров. Все они пронумерованы числами от 1 до 113. Однако, когда команда пришла к началу контеста, случилось так, что почти все компьютеры были заняты - все, кроме 4-х. Команде нужно было быстро выбрать компьютер, и она уже начала справляться со сложной проблемой выбора, как вдруг по радио объявили, что сегодня будет метеоритный дождь. Причём достоверно известно, что на три из четырёх свободных компьютеров упадёт по метеориту. Так как команда не хочет быть раздавленной метеоритом, ей необходимо выбрать безопасный компьютер. Однако выбор - сложный и долгий процесс, а команда хочет хорошо выступить, поэтому им нельзя терять время ещё на один поиск. Помогите им!</p>
    <h4>Входные данные</h4>
    <p>В первой строке вам даны 4 числа - номера свободных компьютеров. Все они - различные целые числа, не превосходящие 113</p>
    <p>Во второй строке вам даны 3 числа - номера компьютеров, на которые упадёт метеорит. Гарантируется, что эти номера различны и что все соответствующие компьютеры свободны.</p>
    <h4>Выходные данные</h4>
    <p>Выведите единственное число - номер компьютера, который следует выбрать команде</p>

    <h4>Пример 1</h4>
    <code>2 6 7 9, 2 7 9</code>
    <code>Output: 6</code>

    <h4>Пример 2</h4>
    <code>6 7 8 9, 6 7 9</code>
    <code>Output: 8</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a, b, c, d, a1, b1, c1;
  cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
  cin &gt;&gt; a1 &gt;&gt; b1 &gt;&gt; c1;
  cout &lt;&lt; a + b + c + d - a1 - b1 - c1 &lt;&lt; endl;

  return 0;
}
</pre>
  </details>

  <details>
    <summary>Задача 3. Квадратное уравнение</summary>
    <h4>Квадратное уравнение</h4>

    <p>В этой задаче вам необходимо решить квадратное уравнение</p>
    <h4>Входные данные</h4>
    <p>Во входных данных записано три целых числа a,b,c (-10<sup>2</sup>&le;a,b,c&le;10<sup>2</sup>; a &ne; 0), коэффициенты квадратного уравнения a⋅x<sup>2</sup> + b⋅x + c = 0. Гарантируется, что решение существует</p>
    <h4>Выходные данные</h4>
    <p>Выведите корень данного квадратного уравнения. Если корней несколько, выведите любой. Ответ будет считаться верным, если абсолютная или относительная погрешность не превосходит 10<sup>-4</sup></p>

    <h4>Пример 1</h4>
    <code>1 -2 0</code>
    <code>Output: 2.000000</code>

    <h4>Пример 2</h4>
    <code>1 0 -4</code>
    <code>Output: 2.000000</code>
<pre>
#include &lt;iostream&gt;
#include &lt;cmath&gt;

using namespace std;

int main() {
  long double a, b, c;
  cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
  long double d = b*b-4*a*c;
  double f = sqrt(d);
  cout &lt;&lt; (-b+f)/(2*a) &lt;&lt; endl;

  return 0;
}
</pre>
  </details>

  <details>
    <summary>Задача 4. Инверсии</summary>
    <h4>Инверсии</h4>

    <p>Инверсией в последовательности чисел называется такая пара чисел, что в ней большее число идет раньше меньшего. Вам дана последовательность из 4 чисел, необходимо найти количество инверсий в ней</p>

    <h4>Входные данные</h4>
    <p>Входные данные содержат 4 целых числа, каждое по модулю не превосходит 10<sup>9</sup></p>

    <h4>Выходные данные</h4>
    <p>Количество инверсий в данной последовательности.</p>

    <h4>Пример 1</h4>
    <code>1 4 2 3</code>
    <code>Output: 2</code>

    <h4>Пример 2</h4>
    <code>4 3 2 1</code>
    <code>Output: 6</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a, b, c, d, result;
  cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
  result = (c > d) + (b > c) + (b > d) + (a > b) + (a > c) + (a > d);
  cout &lt;&lt; result &lt;&lt; endl;

  return 0;
}
</pre>
  </details>
</article>


<!-- 2 Условные операторы и циклы -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>2 Условные операторы и циклы</h3>
</article>


<!-- 2.1 Логические операции -->
<article class="article">
  <div class="anchor" id="p2.1"></div>
  <h3>2.1 Логические операции</h3>

  <h4>Приоритет операций</h4>

  <p>1. ()</p>
  <p>2. !</p>
  <p>3. *, /, %</p>
  <p>4. +, -</p>
  <p>5. &lt;, &gt;, &lt;=, &gt;=</p>
  <p>6. ==, !=</p>
  <p>7. &&</p>
  <p>8. ||</p>
  <p>9. =</p>

  <h4>Законы де Моргана</h4>

  <p>Логическое И возвращает 1 только если обе переменные 1. Логическое ИЛИ возвращает 0 только если обе переменные 0</p>
  <code>!(A&&B) == !A||!B</code>
  <code>!(A||B) == !A&&!B</code>
  <p>Отрицание дизъюнкции есть конъюнкция отрицаний. Отрицание конъюнкции есть дизъюнкция отрицаний</p>


  <details>
    <summary>Задача 1. Сравнение с 0</summary>
    <h4>Сравнение с 0</h4>

    <p>В этой задаче необходимо опять сравнить данное число с 0.</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат единственное целое число, по модулю не превосходящее 10<sup>9</sup></p>
    <h4>Выходные данные</h4>
    <p>Выведите 1, если значение переменной равно 0, и 0 иначе</p>
    <h4>Примечание</h4>
    <p>В этой задаче запрещено пользоваться условным оператором</p>

    <h4>Пример 1</h4>
    <code>0</code>
    <code>Output: 1</code>

    <h4>Пример 2</h4>
    <code>-10</code>
    <code>Output: 0</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  bool a;
  cin &gt;&gt; a;
  cout &lt;&lt; !a &lt;&lt; endl;

  return 0;
}
</pre>
  </details>


  <details>
    <summary>Задача 2. Таблица истинности</summary>
    <h4>Таблица истинности</h4>

    <p>Дмитрию на уроке по информатике задали построить таблицу истинности следующего выражения: a ИЛИ !a ИЛИ b И (c ИЛИ b И !a). К сожалению, Дмитрий слишком ленив, чтобы самому ее строить, поэтому он попросил вас ему помочь. Для данных a, b, c определите значение выражения</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат три целых числа a,b,c (0&le;a,b,c&le;1)</p>
    <h4>Выходные данные</h4>
    <p>Выведите число 0 или 1 - значение выражения при данных переменных a,b,c</p>
    <h4>Примечание</h4>
    <p>В этой задаче запрещено пользоваться условным оператором.</p>

    <h4>Пример 1</h4>
    <code>1 0 1</code>
    <code>Output: 1</code>

    <h4>Пример 2</h4>
    <code>0 1 1</code>
    <code>Output: 1</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a, b, c;
  cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
  bool result = a || !a || b && (c || b && !a);
  cout &lt;&lt; result &lt;&lt; endl;

  return 0;
}
</pre>
  </details>


  <details>
    <summary>Задача 3. Еще одна таблица истинности</summary>
    <h4>Еще одна таблица истинности</h4>

    <p>Владислав - старший брат Дмитрия, и иногда помогает ему с домашками по информатике. Сейчас Дмитрий принес ему очередное логическое выражение, и просит построить его таблицу истинности. Владислав прознал, что вы владеете программой, которая умеет считать подобные выражения, поэтому просит вас ему помочь. Напишите программу, которая по данным значениям переменных посчитает значения выражения. Кстати, вот оно (!(!a И b ИЛИ c) ИЛИ (b ИЛИ !a)) И ((!c И !b) И !(b ИЛИ !a ИЛИ c))</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат три целых числа a,b,c (0&le;a,b,c&le;1)</p>
    <h4>Выходные данные</h4>
    <p>Выведите число 0 или 1 - значение выражения при данных переменных a,b,c</p>
    <h4>Примечание</h4>
    <p>В этой задаче запрещено пользоваться условным оператором.</p>

    <h4>Пример 1</h4>
    <code>1 0 1</code>
    <code>Output: 0</code>

    <h4>Пример 2</h4>
    <code>0 1 1</code>
    <code>Output: 0</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a, b, c;
  cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
  bool result = (!(!a && b || c) || (b || !a)) && ((!c && !b) && !(b || !a || c));
  cout &lt;&lt; result &lt;&lt; endl;

  return 0;
}
</pre>
  </details>


  <details>
    <summary>Задача 4. Азартные игры</summary>
    <h4>Азартные игры</h4>

    <p>Ярополк и Ярослав играют в азартную игру - они кидают по два кубика, на каждой грани которых написано число от 1 до 6. Правила игры таковы, что Ярослав побеждает, если каждое число на его кубиках больше, чем каждое число на кубиках Ярополка. Иначе побеждает Ярополк. Вам необходимо определить, кто выиграл.</p>
    <h4>Входные данные</h4>
    <p>В первой строке входных данных записано два числа, каждое от 1 до 6 - числа, выпавшие на кубиках Ярополка.</p>
    <p>Во второй строке в аналогичном формате записаны два числа, выпавшие на кубиках Ярослава.</p>
    <h4>Выходные данные</h4>
    <p>Выведите 1, если выиграл Ярополк. Иначе выведите 0.</p>
    <h4>Примечание</h4>
    <p>В этой задаче запрещено пользоваться условным оператором.</p>

    <h4>Пример 1</h4>
    <code>2 2</code>
    <code>3 4</code>
    <code>Output: 0</code>

    <h4>Пример 2</h4>
    <code>1 5</code>
    <code>4 6</code>
    <code>Output: 1</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a1, a2, b1, b2;
  cin &gt;&gt; a1 &gt;&gt; a2 &gt;&gt; b1 &gt;&gt; b2;
  bool result = !((b1 > a1) && (b1 > a2) && (b2 > a1) && (b2 > a2));
  cout &lt;&lt; result &lt;&lt; endl;

  return 0;
}
</pre>
  </details>


  <details>
    <summary>Задача 5. Сколько различных?</summary>
    <h4>Сколько различных?</h4>

    <p>В этой задаче требуется определить, сколько различных чисел среди данных четырех?</p>
    <h4>Входные данные</h4>
    <p>Выведите единственное число - сколько различных чисел в данном множестве.</p>
    <h4>Примечание</h4>
    <p>В этой задаче запрещено пользоваться условным оператором.</p>

    <h4>Пример 1</h4>
    <code>1 2 3 4</code>
    <code>Output: 4</code>

    <h4>Пример 2</h4>
    <code>1 2 1 2</code>
    <code>Output: 2</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a, b, c, d;
  cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
  int count = 4;
  count -= (a == b) || (a == c) || (a == d);
  count -= (b == c) || (b == d);
  count -= (c == d);
  cout &lt;&lt; count &lt;&lt; endl;

  return 0;
}
</pre>
  </details>
</article>


<!-- 2.2 Условный оператор -->
<article class="article">
  <div class="anchor" id="p2.2"></div>
  <h3>2.2 Условный оператор</h3>

  <p>Проверим что число четное</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a;
  cin &gt;&gt; a;
  if (a % 2 != 0) {
    cout &lt;&lt; "odd" &lt;&lt; endl;
  } else {
    cout &lt;&lt; "even" &lt;&lt; endl;
  }

  return 0;
}
</pre>

  <p>Подумайте что делает эта программа</p>

<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a, b;
  cin &gt;&gt; a &gt;&gt; b;
  int c = a / b;
  if (a % b != 0) {
    c = c + 1;
  }

  cout &lt;&lt; c &lt;&lt; endl;

  return 0;
}
</pre>

  <p>Она округляет результат деления к ближайшему целому вверх</p>
  <p>Можно сделать вложенные условия с оператором if. Вложенность ничем е ограничена. Но размер кода, который можно послать в систему ограничен 64 килобайтами</p>


  <details>
    <summary>Задача 1. FTarlusee</summary>
    <h4>FTarlusee</h4>

    <p>В этой задаче вам требуется вывести строковое представление булевой переменной</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат единственное целое неотрицательное число, не превосходящее единицы - значение булевой переменной</p>
    <h4>Выходные данные</h4>
    <p>Выведите "True" (без кавычек), если переменная хранит истину, иначе выведите "False" (без кавычек)</p>

    <h4>Пример 1</h4>
    <code>0</code>
    <code>Output: False</code>

    <h4>Пример 2</h4>
    <code>1</code>
    <code>Output: True</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  bool a;
  cin &gt;&gt; a;
  if (a == 0) {
    cout &lt;&lt; "False" &lt;&lt; endl;
  } else {
    cout &lt;&lt; "True" &lt;&lt; endl;
  }

  return 0;
}
</pre>
  </details>


  <details>
    <summary>Задача 2. Максимум</summary>
    <h4>Максимум</h4>

    <p>В этой задаче требуется выбрать максимальное из двух чисел</p>
    <h4>Входные данные</h4>
    <p>Во входных данных записано два целых числа, каждое по модулю не превосходит 10<sup>9</sup></p>
    <h4>Выходные данные</h4>
    <p>Выведите наибольшее из этих чисел.</p>

    <h4>Пример 1</h4>
    <code>8 11</code>
    <code>Output: 11</code>

    <h4>Пример 2</h4>
    <code>11 8</code>
    <code>Output: 11</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a, b;
  cin &gt;&gt; a &gt;&gt; b;
  if (a > b) {
    cout &lt;&lt; a &lt;&lt; endl;
  } else {
    cout &lt;&lt; b &lt;&lt; endl;
  }

  return 0;
}
</pre>
  </details>


  <details>
    <summary>Задача 3. Имя Доктора</summary>
    <h4>Имя Доктора</h4>

    <p>Как известно, у каждого Доктора есть свой порядковый номер. Имя Доктора - это строковая запись его номера. Вам в плен попался Доктор, и сказал вам свой номер. Требуется узнать его имя.</p>
    <h4>Входные данные</h4>
    <p>Во входных данных находится единственное натуральное число, не превосходящее десяти - номер Доктора.</p>
    <h4>Выходные данные</h4>
    <p>В качестве ответа выведите имя Доктора.</p>

    <h4>Пример 1</h4>
    <code>5</code>
    <code>Output: five</code>

    <h4>Пример 2</h4>
    <code>2</code>
    <code>Output: two</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a;
  cin &gt;&gt; a;
  if (a == 1) {
    cout &lt;&lt; "one";
  } else if (a == 2) {
    cout &lt;&lt; "two";
  } else if (a == 3) {
    cout &lt;&lt; "three";
  } else if (a == 4) {
    cout &lt;&lt; "four";
  } else if (a == 5) {
    cout &lt;&lt; "five";
  } else if (a == 6) {
    cout &lt;&lt; "six";
  } else if (a == 7) {
    cout &lt;&lt; "seven";
  } else if (a == 8) {
    cout &lt;&lt; "eight";
  } else if (a == 9) {
    cout &lt;&lt; "nine";
  } else if (a == 10) {
    cout &lt;&lt; "ten";
  }

  return 0;
}
</pre>
  </details>


  <details>
    <summary>Задача 4. Большая буква?</summary>
    <h4>Большая буква?</h4>

    <p>В этой задаче требуется проверить, является ли данная буква латинского алфавита большой.</p>
    <h4>Входные данные</h4>
    <p>Во входных данных записана одна буква латинского алфавита.</p>
    <h4>Выходные данные</h4>
    <p>Если введенная буква является большой, выведите "BIG" (без кавычек). Иначе выведите "small" (без кавычек).</p>

    <h4>Пример 1</h4>
    <code>w</code>
    <code>Output: small</code>

    <h4>Пример 2</h4>
    <code>W</code>
    <code>Output: BIG</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  char a;
  cin &gt;&gt; a;
  if ((a &gt;= 97) && (a &lt;= 122)) {
    cout &lt;&lt; "small";
  } else if ((a &gt;= 65) && (a &lt;= 90)) {
    cout &lt;&lt; "BIG";
  }

  return 0;
}
</pre>
  </details>


  <details>
    <summary>Задача 5. Сортируй</summary>
    <h4>Сортируй</h4>

    <p>В этой задаче необходимо упорядочить данные числа в порядке неубывания.</p>
    <h4>Входные данные</h4>
    <p>Во входных данных записано три числа, каждое по модулю не превосходит 10<sup>9</sup></p>
    <h4>Выходные данные</h4>
    <p>Вам необходимо вывести те же три числа, но в порядке неубывания.</p>

    <h4>Пример 1</h4>
    <code>3 2 1</code>
    <code>Output: 1 2 3</code>

    <h4>Пример 2</h4>
    <code>2 1 4</code>
    <code>Output: 1 2 4</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a, b, c;
  cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
  if ((a &lt;= b) && (b &lt;= c)) {
    cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; " " &lt;&lt; c;
  } else if ((a &lt;= c) && (c &lt;= b)) {
    cout &lt;&lt; a &lt;&lt; " " &lt;&lt; c &lt;&lt; " " &lt;&lt; b;
  } else if ((b &lt;= a) && (a &lt;= c)) {
    cout &lt;&lt; b &lt;&lt; " " &lt;&lt; a &lt;&lt; " " &lt;&lt; c;
  } else if ((b &lt;= c) && (c &lt;= a)) {
    cout &lt;&lt; b &lt;&lt; " " &lt;&lt; c &lt;&lt; " " &lt;&lt; a;
  } else if ((c &lt;= a) && (a &lt;= b)) {
    cout &lt;&lt; c &lt;&lt; " " &lt;&lt; a &lt;&lt; " " &lt;&lt; b;
  } else if ((c &lt;= b) && (b &lt;= a)) {
    cout &lt;&lt; c &lt;&lt; " " &lt;&lt; b &lt;&lt; " " &lt;&lt; a;
  }

  return 0;
}
</pre>
  </details>
</article>


<!-- 2.3 Циклы while, do-while -->
<article class="article">
  <div class="anchor" id="p2.3"></div>
  <h3>2.3 Циклы while, do-while</h3>

  <h4>Цикл while</h4>
  <p>Пока a &le; b, уменьшаем b на величину a b = b - a</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  char a, b;
  cin &gt;&gt; a &gt;&gt; b;
  int cnt = 0;
  while (a &lt;= b) {
    b = b - a;
    cnt = cnt + 1;
  }
  cout &lt;&lt; cnt &lt;&lt; endl;

  return 0;
}
</pre>

  <h4>Бесконечный цикл</h4>
  <p>Если условие никогда не будет false, то цикл никогда не закончится. Это бесконечный цикл. Необходимо самостоятельно следить за тем, чтобы цикл когда-нибудь завершился. Бесконечный цикл можно остановить командой return</p>
<pre>
while(true) {
  return 0;
}
</pre>
  <p>Но тогда и вся программа завершится. Чтобы завершить только цикл можно воспользоваться командой break. Например, бесконечный цикл завершится когда a станет меньше 0</p>
<pre>
int a;
cin &gt;&gt; a;
while(true) {
  cout &lt;&lt; a &lt;&lt; " ";
  a = a - 2;
  if (a &lt; 0) {
    break;
  }
}
</pre>
  <p>Оператор continue завершает текущую итерацию цикла и переходит к следующей</p>

  <h4>Вложенные циклы</h4>
  <p>Циклы, как и условные операторы, можно вкладывать друг в друга. При этом операторы break и continue работают в самом вложенном цикле, в котором находятся</p>

  <p>while это цикл с предусловием. Сначала проводится проверка, потом выполняется тело цикла. Иногда нужно сделать наоборот, чтобы сначала выполнилсь тело цикла, а потом проводилась проверка. Это может сделать цикл с постусловием do while</p>

  <h4>Цикл do while</h4>
  <p>В цикле с постусловием сначала выполняем тело цикла, потом проверяем условие. Если условие верное, то снова выполняется тело цикла, а потом проверяется условие.</p>


  <details>
    <summary>Задача 1. Расплата Пети</summary>
    <h4>Расплата Пети</h4>

    <p>Петя похулиганил, и за это его наказали. Ему дали число, и он должен до тех пор, пока число не превосходит 10<sup>7</sup> увеличивать его в два раза. Петя хулиган, а не математик, поэтому он не хочет проводить подобные вычисления. Вы - друг Пети, и всегда рады ему помочь. Найдите число, на котором должен остановиться Петя, а также количество шагов, которое ему необходимо сделать.</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат натуральное число, не превосходящее 10<sup>9</sup> - число Пети</p>
    <h4>Выходные данные</h4>
    <p>Выведите два числа: итоговое число Пети, а также количество операций, которые он должен совершить</p>

    <h4>Пример 1</h4>
    <code>1</code>
    <code>Output: 16777216 24</code>

    <h4>Пример 2</h4>
    <code>113</code>
    <code>Output: 14811136 17</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a;
  cin &gt;&gt; a;
  int cnt = 0;
  while (a &lt;= 10000000) {
    a = a * 2;
    cnt = cnt + 1;
  }
  cout &lt;&lt; a &lt;&lt; " " &lt;&lt; cnt;

  return 0;
}
</pre>
  </details>


  <details>
    <summary>Задача 2. Количество чисел</summary>
    <h4>Количество чисел</h4>

    <p>Вводится последовательность чисел до тех пор, пока не будут введены два одинаковых числа подряд. Вам требуется определить количество чисел</p>
    <h4>Входные данные</h4>
    <p>Во входных данных находится последовательность целых чисел, каждое по модулю не превышает 10<sup>9</sup>. Гарантируется, что количество чисел не меньше 2 и не больше 10<sup>4</sup>, а также что все соседние числа попарно различны, кроме последней пары - числа в ней одинаковые.</p>
    <h4>Выходные данные</h4>
    <p>В ответ запишите единственное число - количество введенных чисел</p>

    <h4>Пример</h4>
    <code>4 5 7 8 91 5 2 4 5 6 7 1 2 2</code>
    <code>Output: 14</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a, b;
  cin &gt;&gt; b;
  int cnt = 1;
  do {
    a = b;
    cin &gt;&gt; b;
    cnt = cnt + 1;
  } while (a != b);
  cout &lt;&lt; cnt;

  return 0;
}
</pre>
  </details>


  <details>
    <summary>Задача 3. Сумма цифр</summary>
    <h4>Сумма цифр</h4>

    <p>В этой задаче требуется найти сумму цифр данного числа</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат единственное целое число, по модулю не превосходящее 10<sup>9</sup></p>
    <h4>Выходные данные</h4>
    <p>Выведите сумму цифр данного числа</p>

    <h4>Пример 1</h4>
    <code>113</code>
    <code>Output: 5</code>

    <h4>Пример 2</h4>
    <code>-179</code>
    <code>Output: 17</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a;
  cin &gt;&gt; a;
  if (a &lt; 0) {
    a = -a;
  }
  int sum = (a % 10);
  do {
    a = a / 10;
    sum = sum + (a % 10);
  } while ((a / 10) != 0);
  cout &lt;&lt; sum;

  return 0;
}
</pre>
  </details>


  <details>
    <summary>Задача 4. Следующий год</summary>
    <h4>Следующий год</h4>

    <p>Год называется хорошим, если сумма его цифр равна 13. Вам дано число - номер текущего года. Требуется найти номер следующего хорошего года.</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат единственное натуральное число, не превосходящее 10<sup>4</sup>- номер текущего года</p>
    <h4>Выходные данные</h4>
    <p>Требуется найти номер следующего хорошего года</p>

    <h4>Пример 1</h4>
    <code>2020</code>
    <code>Output: 2029</code>

    <h4>Пример 2</h4>
    <code>1813</code>
    <code>Output: 1822</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a, b, sum;
  cin &gt;&gt; a;
  if (a &lt; 0) {
    a = -a;
  }
  do {
    sum = 0;
    a = a + 1;
    b = a;
    while (b) {
      sum = sum + (b % 10);
      b = b / 10;
    }
  }
  while (sum != 13);
  cout &lt;&lt; a;

  return 0;
}
</pre>
  </details>
</article>


<!-- 2.4 Цикл for -->
<article class="article">
  <div class="anchor" id="p2.4"></div>
  <h3>2.4 Цикл for</h3>

  <p>Цикл for это цикл со счетчиком. Не всегда нужно делать цикл пока не выполнится какое-то условие. Иногда нужно выполнить цикл N раз.</p>
  <p>Найдем сумму чисел от 0 до 9</p>
<pre>
int n = 10;
int sum = 0;
for (int i = 0; i &lt; n; i = i + 1) {
  sum = sum + i;
}
cout &lt;&lt; sum;
</pre>

  <p>Внутри цикла можно выводить числа. Выведем все четные числа от 0 до n</p>
<pre>
int n;
cin &gt;&gt; n;
for (int i = 0; i &lt; n; i += 2) {
  cout &lt;&lt; i &lt;&lt; " ";
}
</pre>

  <p>Выведем все четные числа от n до 0</p>
<pre>
int n;
cin &gt;&gt; n;
if (n % 2 = 1) {
  n -= 1;
}
for (int i = n; i &gt;= n; i -= 2) {
  cout &lt;&lt; i &lt;&lt; " ";
}
</pre>

  <p>Внутри цикла можно вводит и выводить числа. Введем n чисел и сразу выведем их на экран</p>
<pre>
int n;
cin &gt;&gt; n;
for (int i = 0; i &lt; n; i++) {
  int a;
  cin &gt;&gt; a;
  cout &lt;&lt; a &lt;&lt; endl;
}
</pre>


  <details>
    <summary>Задача 1. Сумма чисел</summary>
    <h4>Сумма чисел</h4>

    <p>В этой задаче требуется найти сумму чисел от 1 до n</p>
    <h4>Входные данные</h4>
    <p>Во входных данных записано единственное целое число n (1 &le; n &le; 10<sup>4</sup></p>
    <h4>Выходные данные</h4>
    <p>В ответ напишите сумму чисел от 1 до n</p>

    <h4>Пример 1</h4>
    <code>10</code>
    <code>Output: 55</code>

    <h4>Пример 2</h4>
    <code>100</code>
    <code>Output: 5050</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int n, sum = 0;
  cin &gt;&gt; n;
  for (int i = 0; i &lt;= n; i++) {
    sum = sum + i;
  }
  cout &lt;&lt; sum;

  return 0;
}
</pre>
  </details>


  <details>
    <summary>Задача 2. Четные числа</summary>
    <h4>Четные числа</h4>

    <p>В этой задаче требуется вывести все четные числа от 1 до n в порядке убывания</p>
    <h4>Входные данные</h4>
    <p>Входные данные содержат единственное целое число n (2 &le; n &le; 10<sup>5</sup></p>
    <h4>Выходные данные</h4>
    <p>Выведите в одну строчку все четные числа от 1 до n в порядке убывания</p>

    <h4>Пример 1</h4>
    <code>6</code>
    <code>Output: 6 4 2</code>

    <h4>Пример 2</h4>
    <code>9</code>
    <code>Output: 8 6 4 2</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int n;
  cin &gt;&gt; n;
  if (n % 2 == 1) {
    n--;
  }
  for (int i = n; i &gt;= 2; i -= 2) {
    cout &lt;&lt; i &lt;&lt; " ";
  }

  return 0;
}
</pre>
  </details>


  <details>
    <summary>Задача 3. print input</summary>
    <h4>print input</h4>

    <p>Дано множество чисел, требуется вывести его на экран</p>
    <h4>Входные данные</h4>
    <p>В первой строке входных данных записано единственное число n (1 &le; n &le; 10<sup>5</sup></p>
    <p>Во второй строке записано n целых чисел, каждое по модулю не превосходит 10<sup>9</sup></p>
    <h4>Выходные данные</h4>
    <p>Выведите данные вам n чисел. Их количество выводить не нужно</p>

    <h4>Пример 1</h4>
    <code>5</code>
    <code>4 2 3 4 4</code>
    <code>Output: 4 2 3 4 4</code>

    <h4>Пример 2</h4>
    <code>4</code>
    <CODE>13 13 13 13</CODE>
    <code>Output: 13 13 13 13</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int n;
  cin &gt;&gt; n;
  for (int i = 0; i &lt; n; i++) {
    int a;
    cin &gt;&gt; a;
    cout &lt;&lt; a &lt;&lt; " ";
  }

  return 0;
}
</pre>
  </details>


  <details>
    <summary>Задача 4. Сумма</summary>
    <h4>Сумма</h4>

    <p>В этой задаче вам требуется посчитать следующую сумму</p>
    <code>1 + a + a<sup>2</sup> + a<sup>3</sup> + ... + a<sup>n</sup></code>
    <h4>Входные данные</h4>
    <p>Во входных данных записано два целых числа a,n (0 &le; a &le; 10<sup>9</sup>; 0 &le; n &le; 10<sup>3</sup></p>
    <h4>Выходные данные</h4>
    <p>В ответ напишите единственное число - требуемую сумму. Гарантируется,  что искомая сумма не превосходит 10<sup>18</sup></p>

    <h4>Пример 1</h4>
    <code>2 5</code>
    <code>Output: 63</code>

    <h4>Пример 2</h4>
    <code>3 3</code>
    <code>Output: 40</code>
<pre>
#include &lt;iostream&gt;
#include &lt;cmath&gt;

using namespace std;

int main() {
  long long a, sum = 0;
  int n;
  cin &gt;&gt; a &gt;&gt; n;
  for (int i = 0; i &lt;= n; i++) {
    sum += powl(a,i);
  }
  cout &lt;&lt; sum;

  return 0;
}
</pre>
  </details>


  <details>
    <summary>Задача 5. И снова сумма</summary>
    <h4>И снова сумма</h4>

    <p>В этой задаче вам требуется посчитать следующую сумму</p>
    <code>1 - a + a<sup>2</sup> - a<sup>3</sup> + ... &plusmn; a<sup>n</sup></code>
    <h4>Входные данные</h4>
    <p>Во входных данных записано два целых числа a,n (0 &le; a &le; 10<sup>9</sup>; 0 &le; n &le; 10<sup>5</sup></p>
    <h4>Выходные данные</h4>
    <p>В ответ напишите единственное число - требуемую сумму. Гарантируется,  что искомая сумма не превосходит 10<sup>18</sup></p>

    <h4>Пример 1</h4>
    <code>2 5</code>
    <code>Output: -21</code>

    <h4>Пример 2</h4>
    <code>3 3</code>
    <code>Output: -20</code>
<pre>
#include &lt;iostream&gt;
#include &lt;cmath&gt;

using namespace std;

int main() {
  long long a, sum = 0;
  int n;
  cin &gt;&gt; a &gt;&gt; n;
  for (int i = 0; i &lt;= n; i += 2) {
    sum += powl(a,i);
  }
  for (int i = 1; i &lt;= n; i += 2) {
    sum -= powl(a,i);
  }
  cout &lt;&lt; sum;

  return 0;
}
</pre>
  </details>
</article>


<!-- 2.5 Итоговое тестирование -->
<article class="article">
  <div class="anchor" id="p2.5"></div>
  <h3>2.5 Итоговое тестирование</h3>

  <details>
    <summary>Задача 1. Упростите выражение</summary>
    <h4>Упростите выражение</h4>

    <p>Упростите следующее выражение</p>
    <code>!((!a && (!a || !b)) && ((!a && !b) || !a))</code>

    <h4>Закон поглощения</h4>
    <code>a && (a || b) == a</code>
    <code>a || (a && b) == a</code>

    <h4>Закон идемпотентности</h4>
    <code>a && a == a</code>
    <code>a && a == a</code>

    <h4>Закон двойного отрицания</h4>
    <code>~(~a) == a</code>

    <h4>Решение</h4>
    <code>(!a && (!a || !b)) = !a</code>
    <code>((!a && !b) || !a) = !a</code>
    <code>!a && !a = !a</code>
    <code>!(!a) = a</code>
  </details>

  <details>
    <summary>Задача 2. Простое число</summary>
    <h4>Простое число</h4>

    <p>Простым числом называется такое натуральное число, которое имеет ровно два натуральных делителя - себя и единицу. Например, 1 не является простым числом, поскольку у него всего один делитель. 2 и 3 - простые, а вот 4 нет -  у него есть три делителя: 1, 2,4.</p>

    <p>Немного поисследовав простые числа, Физики пришли к очень интересному, но, к сожалению, неверному заключению про простые числа. Мы не знаем это заключение, однако в сеть утекла реализация проверки числа на простоту:</p>

<pre>
int n;
cin &gt;&gt; n;
if (n == 2 || (n % 2 == 1 && n != 9 && n != 1)) {
    cout &lt;&lt; "Prime" &lt;&lt; endl;
} else {
    cout &lt;&lt; "Not Prime" &lt;&lt; endl;
}
</pre>

  <p>Вам необходимо найти такое число, на котором данная программа будет работать неверно. Другими словами, вам необходимо либо найти такое простое число, что программа скажет, что оно не простое, либо наоборот, такое не простое число, что программа посчитает его простым. В ответ запишите любое такое натуральное число, не превосходящее 10<sup>5</sup></p>
  <p>История про физиков следующая: "Исследуют физики простые числа. Смотрят: 3, 5, 7 - простые, а 9 - не простое. Но это ладно, ошибка эксперимента, смотрим дальше - 11, 13 простые. Значит, все нечетные, кроме 9 - простые числа".</p>
  <h4>Ответ: 15</h4>
  </details>

  <details>
    <summary>Задача 3. Сколько раз</summary>
    <h4>Сколько раз выполнится тело цикла for?</h4>

<pre>
for (int i = 0; i &lt;= 666; ++i) {
    while (i % 6 != 0) {
        i = i + 1;
    }
    cout &lt;&lt; i;
}
</pre>
  <h4>Ответ: 112</h4>
  <p>Первый раз при i = 0, и потом через каждые 6 раз, то есть 666 / 6 = 111. Итого 1 + 111 = 112 раз выпролнится цикл for</p>
  </details>

  <details>
    <summary>Задача 4. Интересный делитель</summary>
    <h4>Интересный делитель</h4>

    <p>Данная задача взята из архива Летних Компьютерных Школ в Майкопе</p>
    <p>Интересным делителем называется число N, которое является делителем числа N+1.</p>
    <p>Вам требуется найти количество интересных делителей на отрезке от L до R, концы отрезка включаются.</p>
    <h4>Входные данные</h4>
    <p>Во входном файле записано через пробел два числа L, R (L &lt; R, 1 &le; L, R &le; 10<sup>18</sup></p>
    <h4>Выходные данные</h4>
    <p>Вывести единственное число - ответ на задачу.</p>

    <h4>Пример</h4>
    <code>2 5</code>
    <code>Output: 0</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  long long l, r;
  cin &gt;&gt; l &gt;&gt; r;
  if (l == 1) {
    cout &lt;&lt; 1;
  } else {
    cout &lt;&lt; 0;
  }

  return 0;
}
</pre>
  </details>

  <details>
    <summary>Задача 5. Братья навек</summary>
    <h4>Братья навек</h4>

    <p>Данная задача взята из архива Летних Компьютерных Школ в Майкопе</p>
    <p>Программист Антоша хочет стать самым лучшим программистом, ну, или хотя бы решить задач больше своего старшего брата Андрюши.</p>
    <p>Сейчас количество решенных задач Антоши равно a, а количество решенных задач Андрюши равно b. Гарантируется, что количество решенных задач у Антоши меньше или равно числу решенных задач Андрюши.</p>
    <p>Антоша решает много, и его количество решенных задач утраивается каждый год, а количество решенных задач Андрюши удваивается каждый год.</p>
    <p>Через сколько целых лет Антоша решит строго больше задач чем Андрюша?</p>
    <h4>Входные данные</h4>
    <p>В единственной строке находятся два целых числа a, b (1 &le; a &le; b&le; 10) количество решенных задач у Антоши и Андрюши соответственно.</p>
    <h4>Выходные данные</h4>
    <p>Выведите одно целое число --- через сколько целых лет Антоша решит строго больше задач чем Андрюша.</p>

    <h4>Пример 1</h4>
    <code>4 7</code>
    <code>Output: 2</code>

    <h4>Пример 2</h4>
    <code>4 9</code>
    <code>Output: 3</code>

    <h4>Пример 3</h4>
    <code>1 1</code>
    <code>Output: 1</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a, b;
  cin &gt;&gt; a &gt;&gt; b;
  int year = 0;
  do {
    a *= 3;
    b *= 2;
    year++;
  } while (a &lt;= b);
  cout &lt;&lt; year;

  return 0;
}
</pre>
  </details>

  <details>
    <summary>Задача 6. плати налоги</summary>
    <h4>плати налоги</h4>

    <p>в стране n ввели новый налог - большие буквы стали платными. теперь, за каждую большую букву требуется отдавать b бубликов. не у каждого найдется столько, поэтому на больших буквах теперь надо экономить. однажды один очень богатый Андрей (большая буква в имени проспонсирована им) составил предложение. вам необходимо посчитать, во сколько бубликов обошлось такое предложение Андрею.</p>
    <h4>Входные данные</h4>
    <p>в первой строке входных данных записано единственное число b (1 &le;  b&le; 10<sup>4</sup>) количество решенных задач у Антоши и Андрюши соответственно.</p>
    <p>во второй строке следует составленное Андреем предложение. оно содержит большие и маленькие буквы латинского алфавита, пробелы, запятые и точку. гарантируется, что в предложении ровно одна точка, а также что предложение на нее заканчивается.</p>
    <h4>Выходные данные</h4>
    <p>выведите единственное число - количество бубликов, которое должен заплатить Андрей за составленное предложение.</p>

    <h4>Пример 1</h4>
    <code>11</code>
    <code>I AM RICH.</code>
    <code>Output: 77</code>

    <h4>Пример 2</h4>
    <code>1</code>
    <code>i am not rich.</code>
    <code>Output: 0</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int b;
  char s;
  cin &gt;&gt; b;
  int tax = 0;
  do {
    cin &gt;&gt; s;
    if (s &gt; 64 && s &lt; 91)
    tax += b;
  } while (s != '.');
  cout &lt;&lt; tax;

  return 0;
}
</pre>
  </details>

  <details>
    <summary>Задача 7. Приседания</summary>
    <p></p>Данная задача взята из архива Летних Компьютерных Школ в Майкопе.
    <h4>Приседания</h4>

    <p>Школьник Петя списывал задачи на Летней Компьютерной Школе 2020, поэтому преподаватели заставили его играть в следующую игру. Петя должен сделать n приседаний (1  ≤n ≤ 20000), причем он должен озвучивать номер каждого приседания (нумерация с 1). Если номер текущего приседания не делится ни на 3, ни на 5, то Петя просто называет этот номер. Если номер делится на 3, но не делится на 5, то Петя произносит "Бац". Если номер делится на 5, но не делится на 3, то Петя произносит "Бум". Если номер делится на 15, то Петя произносит "Бацбум". Вам необходимо ответить, сколько соответственно раз Петя произнесет "Бац", "Бум" и "Бацбум".</p>
    <h4>Входные данные</h4>
    <p>На вход подается число n --- количество приседаний. </p>
    <h4>Выходные данные</h4>
    <p>Выведите через пробел сколько раз будут озвучены слова "Бац", "Бум" и "Бацбум".</p>
    <h4>Sample Input 1:</h4>
    <code>17</code>
    <h4>Sample Output 1:</h4>
    <code>4 2 1</code>
    <h4>Sample Input 2:</h4>
    <code>5</code>
    <h4>Sample Output 2:</h4>
    <code>1 1 0</code>
<pre>
#include <iostream>

using namespace std;

int main() {
  int n;
  cin >> n;
  int baz = 0, bum = 0, bazbum = 0;
  bazbum = n / 15;
  baz = n / 3 - bazbum;
  bum = n / 5 - bazbum;
  cout &lt;&lt; baz &lt;&lt; " " &lt;&lt; bum &lt;&lt; " " &lt;&lt; bazbum;
  return 0;
}
</pre>
  </details>
</article>


<!-- 3 Массивы и функции -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>3 Массивы и функции</h3>
</article>


<!-- 3.1 Массивы -->
<article class="article">
  <div class="anchor" id="p3.1"></div>
  <h3>3.1 Массивы</h3>

  <p>Здравствуйте, меня зовут Куренков Владимир. В этом модуле я расскажу вам про статические массивы, сортировку массивов, функции и рекурсию.</p>

  <h4>Статический массив</h4>
  <p>Представим что нужно работать с несколькими однотипными переменными. Было бы неудобно объявлять каждую из них по отдельности. В данном примере их 5</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a0, a1, a2, a3, a4;
  a0 = 7;
  a1 = 1;
  a2 = 5;
  a3 = 3;
  a4 = 5;

  return 0;
}
</pre>
  <p>А что делать когда таких переменных 1000? В языке C++ можно работать с такой структурой данных, которая называется массив. Это позволяет объединить набор однотипных переменных и эффективно обрабатывать их.</p>
  <p>Массив это структура данных, хранящая набор значений или объектов, как правило одинакового типа.</p>

  <h4>Объявление массива</h4>
  <p>При объявлении массива необходимо указать тип элементов массива, имя массива и количесвто элементов в нем</p>
  <code>int a[5]</code>

  <h4>Доступ к элементам массива</h4>
  <p>С каждым элементом массива мы можем работать как с переменной, обращаясь к ней по индексу.</p>

  <h4>Оператор индексатор []</h4>
  <p>Оператор индексатор это пара квадратных скобок. Он используется при объявлении массива, а также для доступа к элементам массива по индексу</p>
  <p> При работе с массивом нуно самому следить чтобы не выйти за границы массива. Если в массиве из 5 элементов обратиться к -1 или 5 элементу, то получим ошибку выполнения программы.</p>
  <code>a[-1] = 1;</code>
  <code>a[5] = 1;</code>

  <details>
    <summary>Пример ввода в массив 10 чисел с клавиатуры и вывода их на экран</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a[10];
  for (int i = 0; i &lt; 10; i++) {
    cin &gt;&gt; a[i];
  }
  for (int i = 0; i &lt; 10; i++) {
    cout &lt;&lt; a[i] &lt;&lt; " ";
  }

  return 0;
}
</pre>
  </details>

  <h4>Алгоритмы</h4>
  <p>Алгоритм обработки элементов массива включает, например, поиск суммы элементов массива, поиск максимального и минимального элемента.</p>
  <p>Чтобы найти сумму, нужно ввести дополнительную переменную s и просуммировать элементы массива в цикле.</p>

  <details>
    <summary>Сумма элементов массива</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a[5];
  for (int i = 0; i &lt; 5; i++) {
    cin &gt;&gt; a[i];
  }
  int s = 0;
  for (int i = 0; i &lt; 5; i++) {
    s += a[i];
  }
  cout &lt;&lt; s;

  return 0;
}
</pre>
  </details>

  <p>Чтобы найти максимальное значение, введем дополнительную переменную m. Вначале предположим, что максимальное значение это элемент с индексом 0. В дальнейшем, если это окажется не так, мы поменяем это значение. Будем последовательно перебирать элементы, сравнивая значение текущего элемента с m.</p>

  <details>
    <summary>Максимальное значение в массиве</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a[10];
  for (int i = 0; i &lt; 10; i++) {
    cin &gt;&gt; a[i];
  }
  int m = a[0];
  for (int i = 1; i &lt; 10; i++) {
    if(a[i] &gt; m) {
      m = a[i];
    }
  }
  cout &lt;&lt; m;

  return 0;
}
</pre>
  </details>

  <p>Такой же алгоритм используется для поиска минимального элемента. Нужно только изменить знак больше на меньше внутри цикла</p>

  <details>
    <summary>Минимальное значение в массиве</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a[10];
  for (int i = 0; i &lt; 10; i++) {
    cin &gt;&gt; a[i];
  }
  int m = a[0];
  for (int i = 1; i &lt; 10; i++) {
    if(a[i] &lt; m) {
      m = a[i];
    }
  }
  cout &lt;&lt; m;

  return 0;
}
</pre>
  </details>

  <p>Как найти индекс элемента, по которому находится нужное нам значение? Для этого мы изменим программу и будем запоминать индекс элемента а не его значение</p>

  <details>
    <summary>Индекс максимального элемента</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a[10];
  for (int i = 0; i &lt; 10; i++) {
    cin &gt;&gt; a[i];
  }
  int im = 0;
  for (int i = 1; i &lt; 10; i++) {
    if(a[i] &gt; a[im]) {
      im = i;
    }
  }
  cout &lt;&lt; im;

  return 0;
}
</pre>
  </details>

  <p>Максимальных и минимальных элементов в массиве может быть несколько. Иногда возникает задача нахождения первого или последнего. Ранее мы посмотрели как найти индекс первого минимального элемента. Чтобы найти индекс последнего, надо поставить нестрогое условие, или перебирать элементы массива с конца.</p>
  <p>Как быть если размер массива заранее неизвестен? В большинстве задач размер массива вводится со стандартным потоком ввода данных. В данном примере мы считываем сначала n - количество элементов. Далее создаем массив размером из n элементов. В цикле при переборе массива мы будем использовать переменную n, так как в ней хранися количество элементов массива</p>

  <details>
    <summary>Ввод и вывод массива</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int n = 0;
  cin &gt;&gt; n;
  int a[n];
  for (int i = 0; i &lt; n; i++) {
    cin &gt;&gt; a[i];
  }
  for (int i = 0; i &lt; 10; i++) {
    cout &lt;&lt; a[i] &lt;&lt; " ";
  }

  return 0;
}
</pre>
  </details>

  <p>Если вы работаете в Visual Studio, то придется делать как показано в примере. Или использовать вектор о котором будем рассказывать позднее</p>

  <details>
    <summary>Ввод и вывод массива в Visual Studio</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int n = 0;
  cin &gt;&gt; n;
  int a[1000];
  for (int i = 0; i &lt; n; i++) {
    cin &gt;&gt; a[i];
  }
  for (int i = 0; i &lt; 10; i++) {
    cout &lt;&lt; a[i] &lt;&lt; " ";
  }

  return 0;
}
</pre>
  </details>

  <p>Последние два примера, которые мы рассмотрим, это переворот массива и циклический сдвиг массива. Чтобы перевернуть массив нужен цикл с двумя переменными i и j. Переменная i будет идти сначала массива. Переменная j будет идти с конца массива. Будем менять местами элементы на позициях i и j. Когда наши переменные цикла встретятся посередине массива, мы прекратим цикл, получив перевернутый массив</p>

  <details>
    <summary>Перевернуть массив</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int n = 10;
  int a[n] = {5,6,7,8,9,1,2,3,4,5};
  for (int i = 0, j = n - 1; i &lt; j; i++, j--) {
    int t = a[i];
    a[i] = a[j];
    a[j] = t;
  }
  for (int i = 0; i &lt; n; i++) {
    cout &lt;&lt; a[i] &lt;&lt; " ";
  }

  return 0;
}
</pre>
  </details>

  <p>Таким же образом можно перевернуть не весь массив, а какую-то его часть. Например, с нуля по k-ый элемент. Или с k-го элемента до конца массива.</p>

  <h4>Циклический сдвиг</h4>
  <p>Циклический сдвиг массива влево это такой сдвиг при котором все элементы уходят влево, а те что были в начале уходят в конец массива.</p>
  <code>0 1 2 3 4 5 6 7 8 9</code>
  <code>2 3 4 5 6 7 8 9 0 1</code>

  <p>Чтобы циклически сдвинуть массив из n элементов на k элементов влево. Надо разбить массив на два подмассива.</p>
  <code>[0,...,k-1,k,...,n-1]</code>
  <code>A = [0,...,k-1], B = [k,...,n-1]</code>
  <p>Перевернем сначала массивы A и B</p>
  <code>A = [k-1,...,0], B = [n-1,...,k]</code>
  <p>Далее перевернем целиком весь полученный массив и получим массив, в котором элементы циклически сдвинуты на k элементов влево</p>
  <code>[k,...,n-1,0,...,k-1]</code>


  <details>
    <summary>Задача 1. Максимум в массиве</summary>
    <h4>Максимум в массиве</h4>

    <p>В этой задаче вам необходимо найти максимум в массиве</p>
    <h4>Входные данные</h4>
    <p>В этой задаче нет входных данных :-) Все, что вам нужно сделать - написать часть программы, которая ищет максимум в массиве. Вы можете полагать, что где-то раньше объявлен массив с именем a, а также есть переменная n, содержащая размер массива. Все элементы в массиве нумеруются от 0 до n-1. Вам необходимо создать переменную ans, в которую следует положить максимум в массиве. Гарантируется, что все элементы массива - целые числа, по модулю не превосходящие 10<sup>9</sup></p>
    <h4>Пример программы</h4>
    <p>Допустим, вашей задачей было бы нахождение суммы двух чисел. Выше объявлены переменные a и b, необходимо объявить переменную c, в которую надо положить сумму данных переменных. Тогда программа, которую вы отправили бы в систему, выглядела так:</p>

    <code>int c;</code>
    <code>c = a + b;</code>
<pre>
int ans = a[0];
for (int i = 0; i &lt; n; i++) {
  if (a[i] &gt; ans) {
      ans = a[i];
  }
}
</pre>
  </details>


  <details>
    <summary>Задача 2. Переворот</summary>
    <h4>Переворот</h4>

    <p>Алексей переворачивает все, до чего дотягивается. Сегодня он перевернул массив, вам нужно перевернуть его обратно.</p>
    <h4>Входные данные</h4>
    <p>Первая строка входных данных содержит единственное целое число n (1&le;n&le;10<sup>5</sup>) - размер массива</p>
    <p>Во второй строке записано n целых чисел, каждое по модулю не превосходит 10<sup>9</sup> - сам массив</p>
    <h4>Выходные данные</h4>
    <p>Выведите данный массив в обратном порядке.</p>

    <h4>Пример 1</h4>
    <code>5</code>
    <code>3 1 4 2 5</code>
    <code>Output: 5 2 4 1 3</code>

    <h4>Пример 2</h4>
    <code>6</code>
    <code>1 2 3 4 5 6</code>
    <code>Output: 6 5 4 3 2 1</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int n;
  cin &gt;&gt; n;
  int a[n];
  for (int i = 0; i &lt; n; i++) {
    cin &gt;&gt; a[i];
  }
  for (int i = n - 1; i &gt;= 0; i--) {
    cout &lt;&lt; a[i] &lt;&lt; " ";
  }

  return 0;
}
</pre>
  </details>


  <details>
    <summary>Задача 3. Trading Places</summary>
    <h4>Trading Places</h4>

    <p>Каждый человек за свою жизнь накопил какое-то количество денег. Прилетели инопланетяне и поменяли накопления у самых богатых и самых бедных людей. Это означает, что для каждого самого бедного человека количество денег у него после обмена станет равным тому, что было у самого богатого человека до обмена. Верно и обратное - для каждого самого богатого человека количество денег у него после обмена станет равным тому, что было у самого бедного человека до обмена. Обратите внимание - суммарное количество денег у всех людей может измениться!</p>
    <p>Инопланетяне улетели, а восстановить экономическое равновесие надо. Вам дано количество денег у каждого человека после обмена, определите, сколько денег у них было до обмена.</p>
    <h4>Входные данные</h4>
    <p>Первая строка входных данных содержит единственное целое число n (1&le;n&le;10<sup>5</sup>) - количество человек</p>
    <p>Во второй строке через пробел записано n целых чисел, каждое по модулю не превосходит 10<sup>9</sup> - количество денег у соответствующего человека после обмена</p>
    <h4>Выходные данные</h4>
    <p>Выведите n чисел - количество денег, которое было у каждого человека до обмена</p>

    <h4>Пример 1</h4>
    <code>5</code>
    <code>-1 2 -1 4 5</code>
    <code>Output: 5 2 5 4 -1</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int n;
  cin &gt;&gt; n;
  int a[n];
  for (int i = 0; i &lt; n; i++) {
    cin &gt;&gt; a[i];
  }
  int min = a[0], max = a[0];
  for (int i = 1; i &lt; n; i++) {
    if (a[i] &lt; min) {
      min = a[i];
    } else if (a[i] &gt; max) {
      max = a[i];
    }
  }
  for (int i = 0; i &lt; n; i++) {
    if (a[i] == min) {
      a[i] = max;
    } else if (a[i] == max) {
      a[i] = min;
    }
  }
  for (int i = 0; i &lt; n; i++) {
    cout &lt;&lt; a[i] &lt;&lt; " ";
  }

  return 0;
}
</pre>
  </details>


  <details>
    <summary>Задача 4. Выставление оценок</summary>
    <p>Данная задача взята из архива Летних Компьютерных Школ в Майкопе.</p>
    <h4>Выставление оценок</h4>

    <p>Однажды Влад, Довлет, Никита и Эдик проверяли письменные работы детей, и вот пришло время выставить оценки в рейтинг! Всего было N работ. Владислав по порядку начал называть оценки Довлету, чтобы он их выставил. Но вот какая проблема, Довлет расслышал не все оценки, а Влад повторять этот список полностью не собирается, однако согласился отвечать на вопросы следующего вида: Довлет называет число — порядковый номер оценки которую называл Влад, а он скажет какая оценка там была. Никита и Эдик, как сокомандники, помогли Довлету и приготовили список из Q чисел — порядковые номера оценок, которые не расслышал Довлет. Вы же товарищ Влада, и должны помочь ему отвечать на вопросы Довлета: если Довлет запрашивает число i, вы должны вывести i-е число, названное Владом.</p>
    <h4>Входные данные</h4>
    <p>В первой строке входных данных находится единственное число n (1&le;n&le;100) - количество оценок названных Владом</p>
    <p>В следующей строке вводится n чисел через пробел — оценки которые назвал Влад. Каждая оценка представляет собой целое число от -100 до 100</p>
    <p>В третьей строке вводится число Q - количество запросов Довлета</p>
    <p>В следующей строке вводится Q чисел через пробел — номера оценок которые запрашивает Довлет у Влада.</p>
    <h4>Выходные данные</h4>
    <p>Вам необходимо ответить на запросы в следующем виде: вывести Q чисел через пробел — ответы на запросы Довлета, i-е число представляет собой ответ i-й запрос. Рассмотрите примеры из условия и описание к ним для большего понимания условия.</p>

    <h4>Пример 1</h4>
    <code>3</code>
    <code>1 2 -4</code>
    <code>3</code>
    <code>2 1 3</code>
    <code>Output: 2 1 -4</code>

    <h4>Пример 2</h4>
    <code>3</code>
    <code>5 65 -9</code>
    <code>1</code>
    <code>2</code>
    <code>Output: 65</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int n;
  cin &gt;&gt; n;
  int a[n];
  for (int i = 0; i &lt; n; i++) {
    cin &gt;&gt; a[i];
  }
  int q;
  cin &gt;&gt; q;
  int b[q];
  for (int i = 0; i &lt; q; i++) {
    cin &gt;&gt; b[i];
  }
  for (int i = 0; i &lt; q; i++) {
    cout &lt;&lt; a[b[i]-1] &lt;&lt; " ";
  }

  return 0;
}
</pre>
  </details>


  <details>
    <summary>Задача 5. Юра и заселение</summary>
    <h4>Юра и заселение</h4>

    <p>Недавно Юра поступил в БГУКП (Берляндский Государственный Университет Крутых Программистов). У Юры есть друг Леша, который поступил вместе с ним, и теперь они заселяются в общежитие.</p>
    <p>Юра и Леша хотят жить в одной комнате. Всего в общежитии есть n комнат. В данный момент в комнате с номером i живут p<sub>i</sub> человек, когда всего в этой комнате может жить q<sub>i</sub> человек (p<sub>i</sub> &le; q<sub>i</sub>). Посчитайте, сколько комнат общежития смогут вместить Юру и Лешу вместе.</p>
    <h4>Входные данные</h4>
    <p>В первой строке содержится единственное целое число n (1&le;n&le;100) - количество комнат</p>
    <p>Во второй строке содержится n целых чисел p<sub>i</sub> (0&le; p<sub>i</sub> &le;100) количество людей, которые уже живут в i-й комнате</p>
    <p>В третьей строке содержится n целых чисел q<sub>i</sub> (p<sub>i</sub> &le; q<sub>i</sub> &le; 100) максимально допустимое количество людей в i-й комнате</p>
    <h4>Выходные данные</h4>
    <p>Выведите одно целое число — количество комнат, в которые Юра с Лешей могут заселиться</p>

    <h4>Пример 1</h4>
    <code>3</code>
    <code>2 1 3</code>
    <code>2 3 4</code>
    <code>Output: 1</code>

    <h4>Пример 2</h4>
    <code>4</code>
    <code>1 1 1 1</code>
    <code>6 4 5 7</code>
    <code>Output: 4</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int n;
  cin &gt;&gt; n;
  int a[n];
  for (int i = 0; i &lt; n; i++) {
    cin &gt;&gt; a[i];
  }
  int b[n];
  for (int i = 0; i &lt; n; i++) {
    cin &gt;&gt; b[i];
  }
  int count = 0;
  for (int i = 0; i &lt; n; i++) {
    if (b[i] - a[i] >= 2) {
      count++;
    }
  }
  cout &lt;&lt; count;

  return 0;
}
</pre>
  </details>


  <details>
    <summary>Задача 6. Четные лучше</summary>
    <h4>Четные лучше</h4>

    <p>Какие ваши любимые числа? Мои - четные! Поэтому вам в этой задаче нужно будет поставить четные числа на первые места, а все остальные - потом</p>
    <h4>Входные данные</h4>
    <p>Первая строка входных данных содержит единственное целое число n (1&le;n&le;10<sup>5</sup>) - количество чисел</p>
    <p>Во второй строке через пробел записаны n целых чисел, каждое по модулю не превосходит 10<sup>9</sup></p>
    <h4>Выходные данные</h4>
    <p>Выведите n чисел в одну строчку. Сначала выведите все четные числа в данном массиве в том же порядке, что они даны во входных данных. Затем выведите все нечетные числа в том же порядке, что и в исходном массиве.</p>

    <h4>Пример 1</h4>
    <code>6</code>
    <code>3 2 1 5 4 6</code>
    <code>Output: 2 4 6 3 1 5 </code>

    <h4>Пример 2</h4>
    <code>10</code>
    <code>5 3 4 5 3 4 2 3 1 1</code>
    <code>Output: 4 4 2 5 3 5 3 3 1 1 </code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int n;
  cin &gt;&gt; n;
  int a[n];
  for (int i = 0; i &lt; n; i++) {
    cin &gt;&gt; a[i];
  }
  int b[n];
  int p1 = 0;
  for (int i = 0; i &lt; n; i++) {
    if (a[i] % 2 == 0) {
      b[p1] = a[i];
      p1++;
    }
  }
  for (int i = 0; i &lt; n; i++) {
    if (a[i] % 2 != 0) {
      b[p1] = a[i];
      p1++;
    }
  }

  for (int i = 0; i &lt; n; i++) {
    cout &lt;&lt; b[i] &lt;&lt; " ";
  }

  return 0;
}
</pre>
  </details>
</article>


<!-- 3.2 Многомерные массивы -->
<article class="article">
  <div class="anchor" id="p3.2"></div>
  <h3>3.2 Многомерные массивы</h3>

  <p>Двумерные массивы (матрицы) широко используются для хранения, представления и обработки данных. Для того чтобы объявить двумерный массив, надо указать тип элемента, имя массива и его размеры.</p>
  <code>int a[3][4]</code>
  <p>В первых квадратных скобках - количество строк, во вторых - количество столбцов</p>
  <p>Трехмерный массив (куб)</p>
  <code>int a[5][5][5]</code>

  <h4>Ввод с клавиатуры и вывод на экран двумерного массива</h4>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int n = 3, m = 4;
  int a[n][m];
  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; m; j++) {
      cin &gt;&gt; a[i][j];
    }
  }
  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; m; j++) {
      cout &lt;&lt; a[i][j] &lt;&lt; " ";
    }
    cout &lt;&lt; endl;
  }

  return 0;
}
</pre>

  <h4>Транспонирование матрицы</h4>
  <p>Транспонирование матрицы - это поменять строки и столбцы местами. Если изменить вывод и поменять цикл по i и по j местами, то мы транспонируем матрицу</p>

  <details>
    <summary>Транспонирование матрицы на экран</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int n = 3, m = 4;
  int a[n][m];
  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; m; j++) {
      cin &gt;&gt; a[i][j];
    }
  }
  for (int j = 0; j &lt; m; j++) {
    for (int i = 0; i &lt; n; i++) {
      cout &lt;&lt; a[i][j] &lt;&lt; " ";
    }
    cout &lt;&lt; endl;
  }

  return 0;
}
</pre>
  </details>

  <p>Если нужно транспонировать матрицу не на экран а в новый двумерный массив, то немного изменим программу. Из исходного массива a, в котором n строк и m столбцов, мы сделаем массив b, в котором m строк и n столбцов. Поэлементно скопируем значения из массива a в b и получим транспонированную матрицу</p>

  <details>
    <summary>Транспонирование матрицы в другую матрицу</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int n = 3, m = 4;
  int a[n][m];
  int b[m][n];
  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; m; j++) {
      cin &gt;&gt; a[i][j];
    }
  }
  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; m; j++) {
      b[j][i] = a[i][j];
    }
  }

  return 0;
}
</pre>
  </details>

  <h4>Поиск минимального элемента матрицы</h4>
<pre>
int amin = a[0][0], imin = 0, jmin = 0;
for (int i = 0; i &lt; n; i++) {
  for (int j = 0; j &lt; m; j++) {
    if (a[i][j] &lt; amin) {
      amin = a[i][j];
      imin = i;
      jmin = j;
    }
  }
}
cout &lt;&lt; amin;
</pre>

  <h4>Поиск максимального элемента матрицы</h4>
<pre>
int amax = a[0][0], imax = 0, jmax = 0;
for (int i = 0; i &lt; n; i++) {
  for (int j = 0; j &lt; m; j++) {
    if (a[i][j] &gt; amax) {
      amax = a[i][j];
      imax = i;
      jmax = j;
    }
  }
}
cout &lt;&lt; amax;
</pre>

  <h4>Поиск первого отрицательного элемента матрицы</h4>
  <p>Гарантируется что хотя бы один отрицательный элемент есть в матрице</p>
<pre>
int ing = 0, jng = 0;
bool OK = false;
for (int i = 0; i &lt; n; i++) {
  for (int j = 0; j &lt; m; j++) {
    if (a[i][j] &lt; 0) {
      ing = i;
      jng = j;
      OK = true;
      break;
    }
  }
  if(OK) break;
}
cout &lt;&lt; a[ing][jng];
</pre>
  <p>Если мы хотим найти первый отрицательный элемент обходя матрицу сначала по столбцам, а затем по строкам, то надо поменять циклы по i и по j местами
  </p>

  <h4>Квадратная матрица</h4>
  <p>Квадратная матрица это двумерный массив, у которого количество строк и столбцов совпадает. В квадратной матрице есть главная диагональ (от a[0][0] до a[n-1][n-1]) и побочная диагональ (от a[0][n-1] до a[n-1][0])</p>
  <p>Мы можем транспонировать квадратную матрицу в текущем массиве без объявления еще одного массива.</p>
<pre>
for (int i = 0; i &lt; n; i++) {
  for (int j = 0; j &lt; n; j++) {
    int t = a[i][j];
    a[i][j] = a[j][i];
    a[j][i] = t;
  }
}
</pre>
  <p>Одной из типовых задач является обход главной и побочной диагонали матрицы</p>

  <details>
    <summary>Сумма элементов главной диагонали</summary>
<pre>
int n = 3;
int a[n][n];
int s = 0;
for (int i = 0; i &lt; n; i++) {
  s += a[i][i];
}
</pre>
  </details>

  <details>
    <summary>Сумма элементов побочной диагонали</summary>
<pre>
int n = 3;
int a[n][n];
int s = 0;
for (int i = 0; i &lt; n; i++) {
  s += a[i][n-i-1];
}
</pre>
  </details>

  <p>Часто нужно работать с элементами, которые находятся над главной диагональю или под ней.</p>

  <details>
    <summary>Сумма элементов над главной диагональю</summary>
<pre>
int s = 0;
for (int i = 0; i &lt; n; i++) {
  for (int j = i+1; j &lt; n; j++) {
  s += a[i][j];
}
</pre>
  </details>

  <details>
    <summary>Сумма элементов под главной диагональю</summary>
<pre>
int s = 0;
for (int i = 0; i &lt; n; i++) {
  for (int j = 0; j &lt; i; j++) {
  s += a[i][j];
}
</pre>
  </details>

  <details>
    <summary>Вывод диагоналей</summary>
<pre>
input
1 2 3
4 5 6
7 8 9
</pre>
<pre>
output
3
2 6
1 5 9
4 8
7
</pre>
<pre>
int i = 0, j = n - 1;
while (true) {
  cout &lt;&lt; a[i][j] &lt;&lt; " ";
  i++, j++;
  if (i == n && j == 1) break;
  if (i == n) {
    i = n - j + 1;
    j = 0;
    cout &lt;&lt; '\n';
  } else if (j == n) {
    j = n - i - 1;
    i = 0;
    cout &lt;&lt; '\n';
  }
}
</pre>
  </details>


  <details>
    <summary>Задача 1. Бухгалтерский учет</summary>
    <h4>Бухгалтерский учет</h4>

    <p>На Галлифрее в году m месяцев, в каждом месяце n дней. Вам известно количество денег, которое заработала некая компания в каждый день года. Вам требуется для каждого месяца найти суммарную выручку компании за этот месяц.</p>
    <h4>Входные данные</h4>
    <p>Первая строка входных данных содержит два целых числа n,m (1&le;n,m&le;500) - количество дней в месяце и количество месяцев в году соответственно</p>
    <p>В следующих n строках записано по m чисел. Число, записанное в i-й строке на j-й позиции, обозначает количество денег, которое заработала компания в i-й день j-о месяца. Все числа в таблице целые и не превосходят 10<sup>9</sup> по модулю.</p>
    <h4>Выходные данные</h4>
    <p>Выведите m чисел - суммарную выручку компании в каждый месяц.</p>

    <h4>Пример 1</h4>
<pre>
3 4
7 2 4 3
9 3 3 6
2 7 8 9
</pre>
    <code>Output: 18 12 15 18</code>

    <h4>Пример 2</h4>
<pre>
5 6
4 5 0 7 7 0
6 4 6 2 1 4
2 0 3 9 0 1
0 5 6 9 8 1
4 7 9 8 8 9
</pre>
    <code>Output: 16 21 24 35 24 15 </code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int n, m; // n-days, m-months
  cin &gt;&gt; n &gt;&gt; m;
  int a[n][m];
  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; m; j++) {
      cin &gt;&gt; a[i][j];
    }
  }

  long long b[m];
  long long sum = 0;
  for (int j = 0; j &lt; m; j++) {
    for (int i = 0; i &lt; n; i++) {
      sum += a[i][j];
    }
    b[j] = sum;
    sum = 0;
  }

  for (int j = 0; j &lt; m; j++) {
    cout &lt;&lt; b[j] &lt;&lt; " ";
  }

  return 0;
}
</pre>
  </details>


  <details>
    <summary>Задача 2. Перевернуть массив</summary>
    <h4>Перевернуть массив</h4>

    <p>Вы уже научились переворачивать одномерный массив. Теперь настало время двумерных! Переворотом двумерного массива называется массив, в котором все строчки идут в обратном порядке, как и элементы в каждой строке.</p>
    <h4>Входные данные</h4>
    <p>В первой строке входных данных записано два целых числа n,m (1&le;n,m&le;500) - количество строк и столбцов в массиве соответственно</p>
    <p>В следующих n строках записано по m чисел - данный вам массив. Все числа в массиве целые, и по модулю не превосходят 10<sup>9</sup></p>
    <h4>Выходные данные</h4>
    <p>Выведите перевернутый массив.</p>

    <h4>Пример 1</h4>
<pre>
3 5
1 2 3 4 5
6 7 8 9 10
11 12 13 14 15
</pre>
<pre>
Output:
15 14 13 12 11
10 9 8 7 6
5 4 3 2 1
</pre>

    <h4>Пример 2</h4>
<pre>
3 4
7 2 4 3
9 3 3 6
2 7 8 9
</pre>
<pre>
Output:
9 8 7 2
6 3 3 9
3 4 2 7
</pre>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int n, m;
  cin &gt;&gt; n &gt;&gt; m;
  int a[n][m];
  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; m; j++) {
      cin &gt;&gt; a[i][j];
    }
  }

  for (int i = n - 1; i &gt;= 0; i--) {
    for (int j = m-1; j &gt;= 0; j--) {
      cout &lt;&lt; a[i][j] &lt;&lt; " ";
    }
    cout &lt;&lt; endl;
  }

  return 0;
}
</pre>
  </details>


  <details>
    <summary>Задача 3. Переворот массива 2</summary>
    <h4>Переворот массива 2</h4>

    <p>Массиву нравится переворачиваться! В этой задачей переворотом массива называется его симметричное отражение относительно побочной диагонали. Побочная диагональ - это диагональ, которая идет из нижнего левого угла в правый верхний.</p>
    <h4>Входные данные</h4>
    <p>В первой строке записано единственное целое число n (1&le;n&le;500) - количество строк и столбцов в массиве.</p>
    <p>В следующих n строках записано по n чисел - элементы массива. Каждое число целое и не превосходит 10<sup>9</sup> по модулю.</p>
    <h4>Выходные данные</h4>
    <p>Выведите перевернутый массив.</p>

    <h4>Пример 1</h4>
<pre>
4
1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 16
</pre>
<pre>
Output:
16 12 8 4
15 11 7 3
14 10 6 2
13 9 5 1
</pre>

    <h4>Пример 2</h4>
<pre>
3
4 6 5
3 8 9
9 1 8
</pre>
<pre>
Output:
8 9 5
1 8 6
9 3 4
</pre>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int n;
  cin &gt;&gt; n;
  int a[n][n];
  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; n; j++) {
      cin &gt;&gt; a[i][j];
    }
  }

  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; n; j++) {
      cout &lt;&lt; a[n-j-1][n-i-1] &lt;&lt; " ";
    }
    cout &lt;&lt; endl;
  }

  return 0;
}
</pre>
  </details>


  <details>
    <summary>Задача 4. Запросы к трехмерному массиву</summary>
    <h4>Запросы к трехмерному массиву</h4>

    <p>Вы со своим напарником проникли в банк массивов, и нашли там самый большой и самый красивый массив. Пока вы любовались его совершенством, ваш напарник по быстрому его упаковывал. Прибежав домой вы обнаружили, что упакован массив был довольно плохо - часть элементов потерялась. Теперь вам необходимо их восстановить. Поскольку вы очень долго им любовались, то запомнили массив во всех деталях. Поскольку восстановлением массива занимается ваш напарник, то он иногда спрашивает у вас, что хранилось раньше в массиве в ячейке с индексами i, j, k. Вам необходимо ответить на все его запросы. Массив нумеруется с единицы.</p>
    <h4>Входные данные</h4>
    <p>В первой строке записано три целых числа k, n, m (1 ≤ k, n, m ≤ 50) - высота, ширина и длинна массива соответственно.</p>
    <p>Далее следует k блоков, в i-м блоке описан i-й слой трехмерной таблицы. Каждый слой представляет из себя двумерный массив с n строками и m столбцами, в каждой ячейке которого записано по одному целому числу, по модулю не превосходящему 10⁹. После каждого слоя следует пустая строка.</p>
    <p>После описания массива записано число Q (1 ≤ Q ≤ 10⁴) - количество запросов напарника.</p>
    <p>В следующих Q строках записаны сами запросы. Каждый запрос описывается тремя целыми числами i, j, t (1 ≤ i ≤ k; 1 ≤ j ≤ n; 1 ≤t ≤ m). В ответ на этот запрос требуется вывести число, которое находится в i-м по высоте слое, в j-й строке и t-м столбце.</p>
    <h4>Выходные данные</h4>
    <p>Выведите Q чисел по одному в строке - ответы на запросы вашего напарника.</p>

    <h4>Пример 1</h4>
<pre>
2 3 4
1 2 3 4
5 6 7 8
9 10 11 12

13 14 15 16
17 18 19 20
21 22 23 24

5
1 1 1
1 1 2
1 2 1
2 3 4
2 2 2
</pre>
<pre>
Output:
1
2
5
24
18
</pre>

    <h4>Пример 2</h4>
<pre>
3 4 5
6 4 1 7 7
3 1 4 6 9
9 4 6 10 7
6 3 9 7 6

3 1 5 8 3
5 2 4 3 1
2 3 6 4 10
4 3 8 9 7

1 7 10 1 2
5 1 2 7 1
6 4 8 5 9
6 3 8 7 2

10
1 4 5
2 1 3
2 4 5
2 3 2
1 1 3
3 1 4
1 2 5
3 3 2
1 3 4
3 2 5
</pre>
<pre>
Output:
6
5
7
3
1
1
9
4
10
1
</pre>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // входные данные
  int k, n, m;
  cin >> k >> n >> m;

  // создаем и заполняем трехмерный массив
  int a[k+1][n+1][m+1];
  for (int i = 1; i &lt;= k; i++) {
    for (int j = 1; j &lt;= n; j++) {
      for (int t = 1; t &lt;= m; t++) {
        cin >> a[i][j][t];
      }
    }
  }

  int q;
  cin >> q;

  for (int qi = 1; qi &lt;= q; qi++) {
    int i, j, t;
    cin >> i >> j >> t;
    cout &lt;&lt; a[i][j][t] &lt;&lt; '\n';
  }
}
</pre>
  </details>

  <details>
    <summary>Задача 5. Чемпионат мира по шахматам</summary>
    <h4>Чемпионат мира по шахматам</h4>

    <p>Вы решили стать чемпионом мира по шахматам! К сожалению, на турниры пускают только игроков с высоким рейтингом, поэтому сначала надо получить разряд, хотя бы четвертый. Вы пришли на рейтинговый турнир, а там произошел невообразимый скандал! Организаторы не верят, что вы умеете играть в шахматы и попросили вас пройти квалификацию.</p>

    <p>Квалификация - очень простой процесс для вас. На доске стоит конь, требуется отметить все клетки, в которые он может походить. К счастью, у вас с собой был компьютер, поэтому вы сразу сели писать программу, которая решает эту задачу.</p>

    <h4>Входные данные</h4>

    <p>Во входных данных записана шахматная доска. Она представляет из себя таблицу 8x8, в каждой клетке которой записан символ точки (номер 46 в ASCII таблице), кроме одной - в ней записан символ K (номер 75 в ASCII таблице). В этой выделенной точке стоит конь.</p>

    <h4>Выходные данные</h4>

    <p>Выведите таблицу в аналогичном формате, заменив все символы точек на символ ! (номер 33 в ASCII таблице) для всех ячеек, в которые может походить конь.</p>

    <h4>Примечание</h4>

    <p>Конь всегда ходит на две клетки в одном направлении (горизонтальном или вертикальном) и на одну в перпендикулярном изначальному. Смотрите первый тест для более точного понимания ходов коня.</p>

    <h4>Sample Input 1:</h4>
<pre>
........
........
........
........
....K...
........
........
........
</pre>

    <h4>Sample Output 1:</h4>
<pre>
........
........
...!.!..
..!...!.
....K...
..!...!.
...!.!..
........
</pre>

    <h4>Sample Input 2:</h4>
<pre>
........
........
........
........
........
........
........
K.......
</pre>

    <h4>Sample Output 2:</h4>
<pre>
........
........
........
........
........
.!......
..!.....
K.......
</pre>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int ki, kj;

  // создаем и заполняем шахматную доску
  char a[8][8];
  for (int i = 0; i &lt; 8; i++) {
    for (int j = 0; j &lt; 8; j++) {
      cin >> a[i][j];
      if (a[i][j] == 75) {
        ki = i;
        kj = j;
      }
    }
  }

  // создаем массив ходов коня
  int b[8][2] = { {1,2},{ 2,1 },{2,-1},{1,-2},
                {-1,-2},{-2,-1},{-2,1},{-1,2}};
  for (int i = 0; i &lt; 8; i++) {
    if ((ki + b[i][0]) >=0 && (ki + b[i][0]) &lt;
    8 && (kj + b[i][1]) >=0 && (kj + b[i][1]) &lt; 8) {
      a[ki + b[i][0]][kj + b[i][1]] = 33;
    }
  }

  for (int i = 0; i &lt; 8; i++) {
    for (int j = 0; j &lt; 8; j++) {
      cout &lt;&lt; a[i][j];
    }
    cout &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- 3.3 Квадратичные сортировки -->
<article class="article">
  <div class="anchor" id="p3.3"></div>
  <h3>3.3 Квадратичные сортировки</h3>

  <p>На вход подается массив (последовательность) чисел. Необходимо отсортировать его по невозрастанию или неубыванию элементов.</p>
  <p>Рассмотрим пример, как можно упорядочить по неубыванию три элемента a, b, c. Для этого мы може последовательно сравнить пары a и b, a и c, b и c.За три сравнения мы упорядочим значения наших элементах. Тот же алгоритм будет работать для четырех переменных a, b, c, d.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a, b, c, d;
  cin >> a >> b >> c >> d;
  if (a > b) swap(a, b);
  if (a > c) swap(a, c);
  if (a > d) swap(a, d);
  if (b > c) swap(b, c);
  if (b > d) swap(b, d);
  if (c > d) swap(c, d);
  cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b &lt;&lt; ' '
       &lt;&lt; c &lt;&lt; ' ' &lt;&lt; d &lt;&lt; '\n';

  return 0;
}
</pre>
  <p>Такой алгоритм легко обобдить для n элементов. swap(a, b) меняет значения a и b местами.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int a[1000];
  for (int i = 0; i &lt; 1000; i++) {
    cin >> a[i];
  }

  // сортировка
  for (int i = 0; i &lt; 1000; i++) {
    for (int j = i + 1; j &lt; 1000; j++) {
      if (a[i] > a[j]) {
        swap(a[i], a[j]);
      }
    }
  }

  // вывод результата
  for (int i = 0; i &lt; 1000; i++) {
    cout &lt;&lt; a[i] &lt;&lt; ' ';
  }

  return 0;
}
</pre>

  <h4>Сортировка выбором</h4>
  <p>Можно немного модифицировать предыдущую сортировку. Давайте не будем менять переменные местами каждый раз когда a[i] > a[j]. Будем искать такой индекс j при котором a[j] будет минимальным от i до конца массива. Будем хранить минимальный индекс элемента в переменной jmin. Будем менять i-й элемент с минимальным после i, если мыл найден меньший элемент.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int a[1000];
  for (int i = 0; i &lt; 1000; i++) {
    cin >> a[i];
  }

  // сортировка выбором
  for (int i = 0; i &lt; 1000; i++) {
    int jmin = i;
    for (int j = i + 1; j &lt; 1000; j++) {
      if (a[jmin] > a[j]) {
        jmin = j;
      }
    }
    swap(a[i], a[jmin]);
  }

  // вывод результата
  for (int i = 0; i &lt; 1000; i++) {
    cout &lt;&lt; a[i] &lt;&lt; ' ';
  }

  return 0;
}
</pre>

  <h4>Сортировка пузырьком</h4>
  <p>Попарно сравнимаем соседние элементы массива начиная с первых двух. Если элемент больше следующего, то мы их меняем местами. В массиве из n элементов мы можем повторить данный алгоритм n-1 раз. За первый проход самый большой элемет становится в конец массива. Повторив этот алгоритм n-1 раз мы поставим все элементы на свои места.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int a[1000];
  for (int i = 0; i &lt; 1000; i++) {
    cin >> a[i];
  }

  // сортировка пузырьком
  for (int i = 0; i &lt; 1000 - 1; i++) {
    for (int j = 0; j &lt; 1000 - 1; j++) {
      if (a[j] > a[j+1]) {
        swap(a[j], a[j+1]);
      }
    }
  }

  // вывод результата
  for (int i = 0; i &lt; 1000; i++) {
    cout &lt;&lt; a[i] &lt;&lt; ' ';
  }

  return 0;
}
</pre>
  <p>Оценка времени работы алгоритма. Алгоритм выполняемт (n-1)*(n-1) действий. Если пренебречь -1, получим n². Такая сортировка будет работать очень долго при n = 10⁵</p>

  <h4>Сортировка расческой</h4>
  <p>Это улучшенная сортировка пузырьком. Изначально сравниваем не соседние, а находящиеся на некотором фиксированном расстоянии элементы. После каждого проходя уменьшаем это расстояние, пока оно не станет равно 1.</p>

  <h4>Сортировка вставками</h4>
  <p>Данный алгоритм не является эффективным. Его используют в гибридных сортировках, использующих сразу несколько алгоритмов сортировки. Применяют для небольшого числа элементов, например 20. Представим, что у нас уже есть отсортированный по неубыванию массив, в который надо добавить один элемент. Если данный элемент больше всех элементов, то мы его добавим в конец. Иначе, надо найти позицию куда добавить заданный элемент, сдвинув все элементы больше его вправо.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int a[1000];
  for (int i = 0; i &lt; 1000; i++) {
    cin >> a[i];
  }

  // сортировка вставками
  for (int i = 0; i &lt; 1000; i++) {
    int j = i;
    for (int k = i - 1; k >= 0; k--) {
      if (a[k] > a[i]) {
        j = k;
      }
    }
    int tmp = a[i];
    for (int k = i; k > j; k--) {
      a[k] = a[k-1];
    }
    a[j] = tmp;
  }

  // вывод результата
  for (int i = 0; i &lt; 1000; i++) {
    cout &lt;&lt; a[i] &lt;&lt; ' ';
  }

  return 0;
}
</pre>

  <h4>Сортировка Шелла</h4>
  <p>Это улучшение сортировки вставками. Изначально сравниваем и сортируем элементы, стоящие на определенном расстоянии d друг от друга. Потом уменьшаем d постепенно доходя до d = 1.</p>

  <details>
    <summary>Задача 1. Украденная Земля</summary>
    <h4>Украденная Земля</h4>

    <p>В мире много разных планет, и всем присвоены какие-то номера. В вашей звездной системе n+1 планета, у каждое есть свой номер, и эти номера давно отсортированы по неубыванию. События последних лет привели к тому, что Землю украли! Ученые люди сообразительные, поэтому выкинули ее из списка, однако недавно Земля вернулась обратно. Теперь перед вами стоит непростая задача - вернуть Землю обратно в список.</p>
    <h4>Входные данные</h4>
    <p>В этой задаче нет входных данных) Все, что вам надо сделать написать часть программы, которая вставляет номер Земли обратно в упорядоченный список. Конечно, после вставки список все еще должен быть упорядочен. Вы можете полагать, что где-то выше вашей программы объявленна переменная n массив a на n+1 элемент, первые n в котором заполнены числами, идущими в порядке неубывания. Массив нумеруется с 0. Также есть переменная t - в ней содержится число, которое требуется вставить в данный массив. Все элементы массива, а также число t - целые и не превосходят 10⁹ по модулю.</p>
    <h4>Выходные данные</h4>
    <p>Выводить ничего не надо. Достаточно написать такую часть программы, которая вставляет число t в массив a.</p>
    <h4>Sample Input:</h4>
<pre>
8 3
1 2 4 5 6 7 8 9
</pre>
    <h4>Sample Output:</h4>
    <code>1 2 3 4 5 6 7 8 9 </code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // входные данные
  int n = 8; // число планет без Земли
  int t = 3;  // число которое надо вставить
  int a[9] = {1,2,4,5, 6,7,8,9}; // массив

  // сортировка вставками
  a[n] = 1e9 + 228;
  for (int i = 0; i &lt; n + 1; i++) {
    if (a[i] > t) {
      for (int j = n; j > i; j--) {
        a[j] = a[j - 1];
      }
      a[i] = t;
      break;
    }
  }

  // вывод результата
  for (int i = 0; i &lt; n + 1; i++) {
    cout &lt;&lt; a[i] &lt;&lt; ' ';
  }

  return 0;
}
</pre>
  </details>

  <details>
    <summary>Задача 2. Сортировка массива</summary>
    <h4>Сортировка массива</h4>

    <p>В данной задаче необходимо отсортировать массив.</p>
    <h4>Входные данные</h4>
    <p>Вам необходимо реализовать часть программы, которая сортирует массив. Можете полагать, что где-то выше вашей программы объявлена переменная n а также массив a на n элементов. Массив нумеруется с 0. Необходимо отсортировать этот массив.</p>
    <h4>Выходные данные</h4>
    <p>Просто отсортируйте массив, ничего выводить не надо.</p>
    <h4>Sample Input:</h4>
<pre>
10
9 6 8 5 5 2 8 9 2 2
</pre>
    <h4>Sample Output:</h4>
    <code>2 2 2 5 5 6 8 8 9 9</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // входные данные
  int n = 10; // размер массива
  int a[10] = {9,6,8,5,5,2,8,9,2,2}; // массив

  // сортировка пузырьком
  for (int i = 0; i &lt; n; i++) {
    for (int j = 1; j &lt; n; j++) {
      if (a[j - 1] > a[j]) {
        int tmp = a[j];
        a[j] = a[j - 1];
        a[j - 1] = tmp;
      }
    }
  }

  // вывод результата
  for (int i = 0; i &lt; n; i++) {
    cout &lt;&lt; a[i] &lt;&lt; ' ';
  }

  return 0;
}
</pre>
  </details>

  <details>
    <summary>Задача 3. Сортируем выбором</summary>
    <h4>Сортируем выбором</h4>

    <p>В этой задаче необходимо посчитать, сколько операций обмена сделает сортировка выбором в той реализации, что была показана на лекции.</p>
    <h4>Входные данные</h4>
    <p>В первой строке входных данных записано единственное целое число (1 ≤ n ≤ 10⁵ ) - размер массива.</p>
    <p>Во второй строке записано n целых чисел, каждое по модулю не превышает 10⁹ - сам массив.</p>
    <h4>Выходные данные</h4>
    <p>Требуется вывести количество операций обмена, которое совершит сортировка выбором.</p>
    <h4>Sample Input 1:</h4>
<pre>
3
3 2 1
</pre>
    <h4>Sample Output 1:</h4>
    <code>3</code>
    <h4>Sample Input 2:</h4>
<pre>
5
2 4 3 2 5
</pre>
    <h4>Sample Output 2:</h4>
    <code>5</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // входные данные
  int n; // размер массива
  cin >> n;
  int a[1000]; // массив
  for (int i = 0; i &lt; n; i++) {
    cin >> a[i];
  }

  // сортировка выбором
  int cnt = 0;
  for (int i = 0; i &lt; n; i++) {
    int jmin = i;
    for (int j = i + 1; j &lt; n; j++) {
      if (a[jmin] > a[j]) {
        jmin = j;
      }
    }
    int tmp = a[i];
    a[i] = a[jmin];
    a[jmin] = tmp;
    cnt++;
  }

  // вывод результата
  cout &lt;&lt; cnt;

  return 0;
}
</pre>
  </details>

  <details>
    <summary>Задача 4. Сортируем пузырьком</summary>
    <h4>Сортируем пузырьком</h4>

    <p>В этой задаче необходимо посчитать, сколько операций обмена сделает сортировка пузырьком в той реализации, что была показана на лекции.</p>
    <h4>Входные данные</h4>
    <p>В первой строке входных данных записано единственное целое число n (1 ≤ n ≤ 1000) - размер массива.</p>
    <p>Во второй строке записано n целых чисел, каждое по модулю не превышает 10⁹ - сам массив.</p>
    <h4>Выходные данные</h4>
    <p>Требуется вывести количество операций обмена, которое совершит сортировка пузырьком.</p>
    <h4>Sample Input 1:</h4>
<pre>
3
3 2 1
</pre>
    <h4>Sample Output 1:</h4>
    <code>3</code>
    <h4>Sample Input 2:</h4>
<pre>
5
2 4 3 2 5
</pre>
    <h4>Sample Output 2:</h4>
    <code>3</code>
  </details>
</article>


<!-- 3.4 Функции -->
<article class="article">
  <div class="anchor" id="p3.4"></div>
  <h3>3.4 Функции</h3>

  <p>Функции позволяют повторно использовать ранее разработанный код. В библиотеке C++ есть уже готовые функции. Например, abs() которая возвращающая модуль числа. Для этого вы используете чужой код, который выполняет некоторые операции. Часто бывает необходимо разработать собственные функции. При объявлении функции необходимо указать тип возвращаемого значения, имя функции и в круглых скобках параметры, которые принимает функция. Если параметров нет, то скобки должны быть пустыми. Далее в фигурных скобках пишется тело функции.</p>
  <code>int func(int a, int b) {}</code>
  <p>Напишем функцию sum() которая возвращает сумму двух чисел, переданных по параметрам.</p>
<pre>
int sum(int a, int b) {
  return a + b;
}

int main() {
  int x = 2, y = 3;
  cout &lt;&lt; sum(x, y);
  return 0;
}
</pre>
  <p>Переменные x и y при вызове функции были скопированы в переменные a и b.</p>
  <p>Напишем функцию _min() которая находит минимальное значение двух чисел, переданных по параметрам.</p>
<pre>
int _min(int a, int b) {
  if (a &lt; b) {
    return a;
  } else {
    return b;
  }
}

int main() {
  cout &lt;&lt; _min(2, 1);
  return 0;
}
</pre>
  <p>Что делать если нужно найти минимум не из двух, а из трех чисел? У нас уже есть фукция, которая ищет минимум из двух чисел. Конечно, можно объявить новую функцию и назвать ее _min3(). Но можно ее назвать как и предыдущую _min(). После чего у нас в программе будет две функции с одним и тем же названием. Но они различаются по количеству параметров. Это будет корректно работать. Если у вас есть две функции с одинаковым именем, но разным количеством параметров, то компилятор будет считать их разными функциями. В зависимости от того сколько переменных передается при вызове, будет вызвана та функция которая принимает столько же параметров.</p>
<pre>
int _min(int a, int b) {
  if (a &lt; b) {
    return a;
  } else {
    return b;
  }
}

int _min(int a, int b, int c) {
  return _min(a, _min(b, c));
}

int main() {
  cout &lt;&lt; _min(2, 1, 3);
  return 0;
}
</pre>
  <p>Что делать если нам нужно найти минимальное значение двух вещественных чисел? А у нас есть только функция для нахождения минимального значения двух целых чисел. Если вызвать функцию для целых чисел, передав туда вещественные числа, она будет работать, но неправильно. Произойдет неявное приведение типов. Вещественные числа, которые вы передадите по параметрам, будут приведены к типу int. Будет отброшена дробная часть числа. Чилса станут целочисленными. Функция вернет минимум из двух целых чисел.</p>
  <p>Для того чтобы находить минимум из двух вещественных чисел, мы можем написать функцию _min(), уже третью в нашей программе. В качестве типа возвращаемого значения она вернет тип double. В качестве параметров будет два числа типа double. Противоречия с уже написанными функциями не будет. Программа при вызове функции _min() с двумя вещественными числами вызовет нужную функцию.</p>
<pre>
int _min(int a, int b) {
  if (a &lt; b) {
    return a;
  } else {
    return b;
  }
}

int _min(int a, int b, int c) {
  return _min(a, _min(b, c));
}

double _min(double a, double b) {
  if (a &lt; b) {
    return a;
  } else {
    return b;
  }
}

int main() {
  cout &lt;&lt; _min(2.6, 5.1);
  return 0;
}
</pre>
  <p>Мы можем в одной и той же программе объявлять функции с одинаковым именем, но различными параметрами и типом возвращаемого значения. Это называется перегрузкой функции. Например, библиотечная функция abs() является перегруженной функцией и возвращает тот же тип, что в нее передается по параметрам. Это работает, потому что она имеет несколько реализаций.</p>
  <p>Напишем функцию, которая принимает массив и выводит его на экран. Данная функция не возвращает какое-либо значение в точку вызова программы.</p>
<pre>
void ptint(int a[], int n) {
  for (int i = 0; i &lt; n; i++) {
    cout &lt;&lt; a[i] &lt;&lt; " ";
  }
}

int main() {
  int n = 0;
  cin >> n;
  int a[n];
  for (int i = 0; i &lt; n; i++) {
    cin >> a[i];
  }
  print (a, n);
  return 0;
}
</pre>

  <h4>Передача параметра по значению</h4>
  <p>Что будет если мы будем менять значения переменных, переданных как параметры внутри функции? Если это тип int или double, то они будут скопированы по значению. Меняя значения переменных внутри функции мы не изменим значения переменных в точке вызова функции.</p>
  <p>В данном примере изменение переменной a внутри функции не изменит значение переменной x в точке вызова.</p>
<pre>
void test(int a) {
  a = a + 1;
}

int main() {
  int x = 3;
  test(x);
  cout &lt;&lt; x;
  return 0;
}
</pre>

  <h4>Передача параметра по ссылке</h4>
  <p>В случае с массивами происходит ситуация при которой мы передаем массив по ссылке. Любые изменения значений массива внутри функции приводят к изменению значений массива в точке вызова. У нас один и тот же массив будедт в функции main() и в функции test(). Если нужно изменить массив внутри функции, но чтобы он не менялся вне функции, нужно создать копию массива внутри функции, по элементно скопировав значения переданного массива и работать в дальнейшем с копией данного массива.</p>
<pre>
void test(int a[], int n) {
  a[0] = 9;
}

int main() {
  int a[5];
  a[0] = 17;
  test(a, 5);
  cout &lt;&lt; a[0];
  return 0;
}
</pre>
  <p>Напишем функцию, которая находит индекс минимального элемента массива. Размер массива будем хранить как глобальную переменную и обращаться к ней внутри функции.</p>
<pre>
int n = 0;

int index_min(int a[]) {
  int imin = 0;
  for (int i = 0; i &lt; n; i++) {
    if (a[i] &lt; a[imin]) {
      imin = i;
    }
  }
  return imin;
}

int main() {
  cin >> n;
  int a[n];
  for (int i = 0; i &lt; n; i++) {
    cin >> a[i];
  }
  cout &lt;&lt; index_min(a);
  return 0;
}
</pre>

  <details>
    <summary>Задача 1. Сумма чисел</summary>
    <h4>Сумма чисел</h4>

    <p>Необходимо написать функцию, которая находит сумму двух чисел.</p>
    <h4>Входные данные</h4>
    <p>В этой задаче нет входных данных. Вам необходимо лишь реализовать функцию с именем sum, которая принимает два целых числа типа int.</p>
    <h4>Выходные данные</h4>
    <p>Ваша функция должна вернуть одно числа типа int - сумму данных чисел.</p>
<pre>
int sum(int a, int b) {
  return a + b;
}
</pre>
  </details>

  <details>
    <summary>Задача 2. Произведение чисел</summary>
    <h4>Произведение чисел</h4>

    <p>Необходимо написать функцию, которая выводит произведение чисел на экран.</p>
    <h4>Входные данные</h4>
    <p>Вам требуется написать функцию, которая называется product, принимает два целых числа, по модулю не превосходящие 10⁹.</p>
    <h4>Выходные данные</h4>
    <p>Функция должна вывести на экран произведение данных чисел.</p>
<pre>
void product(long long a, long long b) {
  cout &lt;&lt; a * b;
}
</pre>
  </details>

  <details>
    <summary>Задача 3. Максимум в массиве</summary>
    <h4>Максимум в массиве</h4>

    <p>В этой задаче вам необходимо написать функцию, которая находит максимум в массиве.</p>
    <h4>Входные данные</h4>
    <p>Вам требуется реализовать функцию get_max, которая первым своим аргументом принимает целое число n - количество элементов в массиве. Вторым аргументом эта функцию должна принимать сам массив, содержащий целые числа, по модулю не превышающие 10⁹. Массив нумернуется с 0.</p>
    <h4>Выходные данные</h4>
    <p>Функция должна вернуть одно целое число - позицию максимального элемента в массиве. Если максимальных элементов несколько, верните позицию любого.</p>
<pre>
int get_max(int n, int a[]) {
  int maxi = 0;
  for (int i = 1; i &lt; n; i++) {
    if (a[i] > a[maxi]) {
      maxi = i;
    }
  }
  return maxi;
}
</pre>
  </details>

  <details>
    <summary>Задача 4. Сортировка массива</summary>
    <h4>Сортировка массива</h4>

    <p>В этой задаче необходимо реализовать функцию, которая сортирует массив.</p>
    <h4>Входные данные</h4>
    <p>Реализуйте функцию my_sort, которая в качестве аргументов принимает количество элементов в массиве и сам массив. Все числа целые и не превосходят 1000 по модулю.</p>
    <h4>Выходные данные</h4>
    <p>Отсортируйте данный массив по невозрастанию.</p>
<pre>
void my_sort(int n, int *a) {
  for (int i = 0; i &lt; n ; i++) {
    for (int j = 0; j &lt; n-1; j++) {
      if (a[j+1] > a[j]) {
        int tmp = a[j];
          a[j] = a[j+1];
          a[j+1] = tmp;
      }
    }
  }
}
</pre>
  </details>
</article>


<!-- 3.5 Рекурсия -->
<article class="article">
  <div class="anchor" id="p3.5"></div>
  <h3>3.5 Рекурсия</h3>

  <p>Разберем как работает рекурсия в программировании и разберем что такое стек вызовов функции. Потом поймем что такое переполнение стека - stack overflow.</p>
  <p>Стек это реализация абстрактного типа данных, который работает по принципу LIFO последнний пришел - первый уйдешь. Стек это массив с которым можно делать только два действия. Первое - добавить число в конец массива. Второе забрать и удалить число с конца массива. Мы не можем забрать элемент снизу не вытащив все верхние элементы.</p>
  <p>Как используется стек при вызове функции? Пусть есть три функции a(), b(), c(). Внутри функции a() вызывается функция b(), а внутри функции b() вызывается функция c(). В один момент времени может выполняться только одна функция.</p>
  <p>При вызовве функции b() приостанавливается функция a() и в стек вызовов заносится точка возврата в функцию a(). Функция a() продолит работу только после того как отработают все инструкции функции b().</p>
  <p>Когда функция b() вызовет функцию c(), ее работа приостанавливается и в стек вызовов заносится точка возврата в функцию b(). Когда функция c() полностью отработает, мы вернемся в функцию b(). Когда отработает функция b() мы вернемся к функции a() и закончим выполнение программы.</p>
  <p>Рекурсия в программировании это возможность функции вызывать саму себя.</p>
  <p>Используя рекурсию найдем произведение всех чисел от 1 до n. Это факториал числа.</p>
  <code>n! = 1 * 2 * 3 * ... * n;</code>
  <code>5! = 1 * 2 * 3 * 4 * 5 = 120</code>
  <p>Мы знаем что 5! = 5 * 4!, n = n * (n-1)! Тогда мы можем записать это в виде рекурсивной функции.</p>
<pre>
int f(int n) {
  if (n == 0 || n == 1) {
    return 1;
  } else {
    return n * f(n - 1);
  }
}

int main() {
  cout &lt;&lt; f(5);
  return 0;
}
</pre>
  <p>Как это будет работать. У нас есть стек вызова и в нем хранится информация для возарата управления из вызываемой функции в функцию ее вызвавшую. f(5) вызовет f(4) и уйдет в стек вызовов. f(4) вызовет f(3) и тоже будет занесена в стек вызовов. И так далее пока мы не вызовем f(1) которая вернет нам 1. После этого из стека вызова будут возвращаться функции. f(2) вернет 2. f(3) вернет 6 и так далее пока последняя функция не вернет нам значение нашего факториала.</p>
  <p>Это пример линейной рекурсии. Это когда внутри функции вызывается одна такая же функция.</p>
  <p>Есть еще ветвлящаяся рекурсия. Это когда внутри функции более одного рекурсивного вызова. Пример ветвлящейся рекурсии мы посмотрим на числах Фибоначчи. Каждое число Фибоначчи это сумма двух предыдущих чисел Фибоначчи. Задаются два первых числа и они равны 1. Это и будет условием выхода из рекурсии.</p>
<pre>
int f(int n) {
  if (n == 0 || n == 1) {
    return 1;
  } else {
    return а(n - 1) + f(n - 2);
  }
}

int main() {
  cout &lt;&lt; f(7);
  return 0;
}
</pre>
  <p>Наглядно это можно проиллюстрировать при помощи дерева. Дерево в данном случае перевернуто и его корень находится сверху. Из дерева виден недостаток рекурсии. Для того чтобы посчитать четверное число Фибоначчи, мы вызовем функцию 9 раз. При ветвлении дерево в различных ветвях совпадает, это значит что надо вычислять числа, которые уже вычисляли в другой ветви. И это является существенным минусом рекурсивных алгоритмов.</p>
  <p>Рекурсию нужно использовать осторожно. Потому что это может привести к большому расходу памяти и сделать алгоритм не эффективным. Если рекурсия спускается очень глубоко, может произойти переполнение стека вызовов.</p>

  <details>
    <summary>Задача 1. Факториал</summary>
    <h4>Факториал</h4>

    <p>В этой задаче вам требуется написать рекурсивную функцию, которая посчитает n! = n⋅(n-1)⋅…⋅1.</p>
    <h4>Входные данные</h4>
    <p>Вам необходимо написать рекурсивную функцию factorial, входным параметром которой подается единственное целое число n (0 ≤ n ≤ 20).</p>
    <h4>Выходные данные</h4>
    <p>Функция должна вернуть единственное целое число - факториал данного числа n.</p>
<pre>
long long factorial(long long n) {
  if (n == 1 || n == 0) {
    return 1;
  } else {
    return n * factorial(n-1);
  }
}
</pre>
  </details>

  <details>
    <summary>Задача 2. Переверни ввод</summary>
    <h4>Переверни ввод</h4>

    <p>В этой задаче вам необходимо вывести введенные числа в обратном порядке.</p>
    <h4>Входные данные</h4>
    <p>Вам необходимо реализовать рекурсивную функцию f, которая принимает один параметр n (1 ≤ n ≤ 1000) - количество чисел, которые необходимо считать. Сама функция в процессе рекурсивного вызова должна считать n чисел и вывести их в обратном порядке через пробел.</p>
    <h4>Выходные данные</h4>
    <p>Выведите введенные числа в обратном порядке. Количество чисел выводить не надо.</p>
    <h4>Sample Input:</h4>
<pre>
5
3 1 4 2 5
</pre>
    <h4>Sample Output:</h4>
    <code>5 2 4 1 3 </code>
<pre>
void f(int n) {
  if (n) {
    int tmp;
    cin >> tmp;
    f(--n);
    cout &lt;&lt; tmp &lt;&lt; " ";
  } else {
    return;
  }
}
</pre>
  </details>

  <details>
    <summary>Задача 3. Остров последнего шанса</summary>
    <h4>Остров последнего шанса</h4>

    <p>Одержимая провалила задание Доктора и теперь пытается извиниться. Доктор очень страшен в гневе, поэтому ее извинение больше похоже на бессвязную речь. Пусть n - степень провала. Тогда извинение уровня n есть строка sₙ = Sir, + sₙ₋₁ + because + sₙ₋₁ + sorry. Извинение уровня 0 есть строка s₀ = it's not my fault. Вам известна степень провала Одержимой и вы хотите знать текст ее извинения.</p>
    <h4>Входные данные</h4>
    <p>Во входных данных содержится единственное целое число n (0 ≤ n ≤ 20) - степень провала.</p>
    <h4>Выходные данные</h4>
    <p>Выведите строку-извинение Одержимой.</p>
    <h4>Примечание</h4>
    <p>Обратите внимание на нестандартные ограничения времени и памяти в этой задаче. Также обратите внимание на расстановку пробелов в тестовом примере.</p>
    <h4>Sample Input 1:</h4>
    <code>1</code>
    <h4>Sample Output 1:</h4>
    <code>Sir, it's not my fault because it's not my fault sorry </code>
    <h4>Sample Input 2:</h4>
    <code>2</code>
    <h4>Sample Output 2:</h4>
    <code>Sir, Sir, it's not my fault because it's not my fault sorry because Sir, it's not my fault because it's not my fault sorry sorry </code>
<pre>
#include &lt;iostream&gt;
using namespace std;

void sorry(int n) {
  if (n == 0) {
    cout &lt;&lt; "it's not my fault";
    return;
  } else {
    cout &lt;&lt; "Sir, ";
    sorry(n - 1);
    cout &lt;&lt; " because ";
    sorry(n - 1);
    cout &lt;&lt; " sorry";
  }
}

int main() {
  int n;
  cin >> n;
  sorry(n);
}
</pre>
  </details>

  <details>
    <summary>Задача 4. Странный вывод массива</summary>
    <h4>Странный вывод массива</h4>

    <p>В этой задаче вам дан массив, и требуется вывести его в очень странном порядке. А именно сначала требуется вывести средний элемент массива. Если массив четной длины, то требуется вывести элемент слева от середины. Затем в аналогичном формате выводится правая половина массива, а затем левая, если они не пусты.</p>
    <h4>Входные данные</h4>
    <p>В первой строке входных данных записано единственное целое число n (1 ≤ n ≤ 10⁵) - размер массива.</p>
    <p>В следующей строке записано n целых чисел, по модулю не превышающих 10⁹ - сам массив.</p>
    <h4>Выходные данные</h4>
    <p>Требуется вывести данный массив в странном порядке.</p>
    <h4>Sample Input 1:</h4>
<pre>
7
4 7 10 7 5 5 1
</pre>
    <h4>Sample Output 1:</h4>
    <code>7 5 1 5 7 10 4</code>
    <h4>Sample Input 2:</h4>
<pre>
6
8 7 2 5 9 8
</pre>
    <h4>Sample Output 2:</h4>
    <code>2 9 8 5 8 7</code>
<pre>
#include &lt;iostream&gt;
using namespace std;

void f(int a[], int l, int r) {
  int d = r - l + 1;
  if (d &lt; 1) {
    return;
  }
  cout &lt;&lt; a[(r + l) / 2] &lt;&lt; " ";
  f(a, (r + l) / 2 + 1, r);
  f(a, l, (r + l) / 2 - 1);
}

int main() {
  int n;
  cin >> n;
  int a[n];
  for (int i = 0; i &lt; n; i++) {
    cin >> a[i];
  }
  f(a, 0, n - 1);
}
</pre>
  </details>

  <details>
    <summary>Задача 5. Долгая дорога к Дюне</summary>
    <h4>Долгая дорога к Дюне</h4>

    <p>Для благословения Дюны требуется правильно выполнить очень сложный обряд. Заключается он в том, что вам необходимо посчитать число Дюны Dₙ = Dₙ₋₁ + Dₙ₋₂. К сожалению, недостаточно просто посчитать это число, надо пройти путь вычисления целиком. Это обозначает, что если вам в какой-то момент для вычислений понадобилось число Dᵢ, а вы его уже знаете из более ранних вычислений, то надо не лениться и посчитать его полностью еще раз. Маленькие числа Дюны известны и в вычислениях не нуждаются: D₁ = D₂ = 1. Сами по себе числа Дюны никого не интересуют, главное - пройти путь. Теперь вам интересно, сколько чисел придется вычислять, чтобы целиком пройти этот путь.</p>
    <h4>Входные данные</h4>
    <p>Во входных данных находится единственное целое число n (1 ≤ n ≤ 40).</p>
    <h4>Выходные данные</h4>
    <p>Выведите количество шагов, которое необходимо проделать для вычисления Dₙ.</p>
    <h4>Sample Input 1:</h4>
    <code>5</code>
    <h4>Sample Output 1:</h4>
    <code>4</code>
    <h4>Sample Input 2:</h4>
    <code>6</code>
    <h4>Sample Output 2:</h4>
    <code>7</code>
<pre>
#include &lt;iostream&gt;
using namespace std;

int f(int n) {
  static int count = 0;
  if (n > 2) {
    count++;
  } else {
    return 0;
  }
  f(n - 1);
  f(n - 2);
  return count;
}

int main() {
  int n;
  cin >> n;
  int res = f(n);
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- 3.6 Итоговое тестирование -->
<article class="article">
  <div class="anchor" id="p3.6"></div>
  <h3>3.6 Итоговое тестирование</h3>

  <details>
    <summary>Задача 1. Потребление памяти</summary>
    <p>Сколько байт памяти будет выделено на работу следующей программы</p>
<pre>
int a[113];
long long b[179];
char ch;
unsigned long long q;
</pre>Решение</p>
<code>4*113 + 8*179 + 1 +8 = 1893</code>
  </details>

  <details>
    <summary>Задача 2. Выбрать функции</summary>
    <p>Какие функции не приведут к ошибке компиляции или неявному приведению типов?</p>
    <ol>
      <li>
<pre>
void f(int a, int b) {
  return a + b;
}
</pre>
      </li>
      <li>
<pre>
int f(double a, double b) {
  return a + b;
}
</pre>
      </li>
      <li>
<pre>
int f(int a, int b) {
  return a + b;
}
</pre>
      </li>
      <li>
<pre>
long long f(int a, int b) {
  return a + b;
}
</pre>
      </li>
      <li>
<pre>
void f(int a, int b) {
  int c = a + b;
  return;
}
</pre>
      </li>
    </ol>
    <p>Ответ: 3, 5</p>
  </details>

  <details>
    <summary>Задача 3. Вызов функций</summary>
    <p>Приведён пример следующей программы. В каком порядке будут вызваны функции? Вызов функции main учитывать не надо.</p>

    <p>Ответ запишите в виде непрерывной последовательности букв. Правильным по формату но не по значению будет ответ ABC.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

void D() {}
void E() {}
void C() {}

void B() {
  D();
  E();
}

void A() {
  B();
  C();
  B();
}

int main() {
  A();
  return 0;
}
</pre>
  <p>Ответ: ABDECBDE</p>
  </details>

  <details>
    <summary>Задача 4. Эх, рекурсия</summary>
    <p>Сколько раз будет вызвана функция f во время выполнения программы?</p>
<pre>
#include &lt;iostream&gt;
using namespace std;

void f(int n) {
  if (n > 0) {
    f(n - 1);
    f(n - 2);
  }
}

int main() {
  f(3);
  return 0;
}
</pre>
  <code>9</code>
  </details>

  <details>
    <summary>Задача 5. Горки</summary>
    <p>Данная задача взята из архива Летних школ в Майкопе</p>

    <p>Дан массив, состоящий из целых чисел. Назовём <strong>горкой</strong> элемент массива, у которого два соседа и оба меньше данного. Напишите программу, которая в данном массиве определит количество горок.</p>

    <h4>Входные данные</h4>
    <p>Сначала задано число N - количество элементов в массиве (1 ≤ N ≤ 100). Далее через пробел записаны N чисел - элементы массива. Массив состоит из целых чисел.</p>

    <h4>Выходные данные</h4>
    <p>Необходимо вывести количество <strong>горок</strong> - элементов массива, у которых два соседа и которые при этом строго больше обоих своих соседей.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int N;
  cin >> N;
  int a[100];
  for (int i = 0; i &lt; N; i++) {
      cin >> a[i];
  }
  int sum = 0;
  for (int i = 1; i &lt; N - 1; i++) {
    if (a[i] > a[i - 1] && a[i] > a[i + 1]) {
      sum++;
    }
  }
  cout &lt;&lt; sum;
}
</pre>
  </details>

  <details>
    <summary>Задача 6. Тренировка перед чемпионатом мира!</summary>

    <p>Это возмутительно! В прошлый раз вас выгнали из квалификации, хотя вы решили поставленную задачу для всех возможных ситуаций! Вы не отчаялись и решили начать тренировку.</p>

    <p>Тренироваться нужно сразу начиная со сложных фигур, ваш выбор пал на ферзя. Итак, на доске стоит ферзь, требуется отметить все клетки, в которые он может походить. После нескольких часов решения этой задачи вы не смогли побороть соблазн и опять сели писать программу, которая ее решает.</p>

    <h4>Входные данные</h4>

    <p>Во входных данных записана шахматная доска. Она представляет из себя таблицу 8x8, в каждой клетке которой записан символ точки (номер 46 в ASCII таблице), кроме одной - в ней записан символ F (номер 70 в ASCII таблице). В этой выделенной точке стоит ферзь.</p>

    <h4>Выходные данные</h4>

    <p>Выведите таблицу в аналогичном формате, заменив все символы точек на символ ! (номер
    33 в ASCII таблице) для всех ячеек, в которые может походить ферзь.</p>

    <h4>Примечание</h4>

    <p>Ферзь всегда ходит на любое количество клеток в любую из восьми сторон. Смотрите первый тест для более точного понимания ходов ферзя.</p>

    <h4>Sample Input 1:</h4>
<pre>
........
........
........
........
....F...
........
........
........
</pre>
    <h4>Sample Output 1:</h4>
<pre>
!...!...
.!..!..!
..!.!.!.
...!!!..
!!!!F!!!
...!!!..
..!.!.!.
.!..!..!
</pre>
    <h4>Sample Input 2:</h4>
<pre>
........
........
........
........
........
........
........
F.......
</pre>
    <h4>Sample Output 2:</h4>
<pre>
!......!
!.....!.
!....!..
!...!...
!..!....
!.!.....
!!......
F!!!!!!!
</pre>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  char a[8][8];
  int fx, fy;
  // ввод доски и ферзя
  for (int i = 0; i &lt; 8; i++) {
    for (int j = 0; j &lt; 8; j++) {
      cin >> a[i][j];
      if (a[i][j] == 'F') {
        fy = i;
        fx = j;
      }
    }
  }
  // решение
  // 8 направлений
  // вверх
  int x = 1, y = 1;
  while (fy - y >= 0) {
    a[fy - y][fx] = '!';
    y++;
  }
  // вверх-вправо
  x = 1, y = 1;
  while ((fy - y >= 0) && (fx + x &lt; 8)) {
    a[fy - y][fx + x] = '!';
    y++;
    x++;
  }
  // вправо
  x = 1, y = 1;
  while (fx + x &lt; 8) {
    a[fy][fx + x] = '!';
    x++;
  }
  // вниз-вправо
  x = 1, y = 1;
  while ((fy + y &lt; 8) && (fx + x &lt; 8)) {
    a[fy + y][fx + x] = '!';
    y++;
    x++;
  }
  // вниз
  x = 1, y = 1;
  while (fy + y &lt; 8) {
    a[fy + y][fx] = '!';
    y++;
  }
  // вниз-влево
  x = 1, y = 1;
  while ((fy + y &lt; 8) && (fx - x >= 0)) {
    a[fy + y][fx - x] = '!';
    y++;
    x++;
  }
  // влево
  x = 1, y = 1;
  while (fx - x >= 0) {
    a[fy][fx - x] = '!';
    x++;
  }
  // вверх-влево
  x = 1, y = 1;
  while ((fy - y >= 0) && (fx - x >= 0)) {
    a[fy - y][fx - x] = '!';
    y++;
    x++;
  }
  // вывод результата
  for (int i = 0; i &lt; 8; i++) {
    for (int j = 0; j &lt; 8; j++) {
      cout &lt;&lt; a[i][j];
    }
    cout &lt;&lt; '\n';
  }
}
</pre>
  </details>

  <details>
    <summary>Задача 7. Звездочки</summary>

    <p>Вы обнаружили слово. Так оказалось, что в этом слове соседние буквы не дружат между собой. Вам требуется разделить их звездочками.</p>

    <h4>Входные данные</h4>

    <p>Вам необходимо написать рекурсивную функцию f, которая принимает два аргумента. Эти аргументы вы можете использовать как угодно для своего удобства, они не несут особого смысла. В главной программе будет вызвана команда f(-1, -1). Также ваша функция может возвращать произвольные значения, в том числе никакие. В главной программе возврат вашей функции никак не будет проверяться.</p>

    <p>Функция должна целиком считать слово и на экран вывести то же самое слово, но в котором все соседние буквы разделены звездочками. Для вашего удобства после слова следует символ . (номер 46 в ASCII таблице), его не надо считать за часть слова, выводить и разделять звездочкой со словом. Гарантируется, что слово состоит только из заглавных и строчных символов латинского алфавита. Смотрите тестовый пример для более полного понимания условия.</p>

    <h4>Выходные данные</h4>

    <p>Функция должны вывести на экран разделенное слово.</p>
<pre>
void f(int a, int b) {
  char sym;
  cin >> sym;
  if (sym == '.') {
      return;
  }
  if (a == -1) {
    cout &lt;&lt; sym;
  } else {
    cout &lt;&lt; '*' &lt;&lt; sym;
  }
  f(0, 0);
}
</pre>
  </details>

  <details>
    <summary>Задача 8. Проблема свободного места</summary>
    <p>Данная задача взята с муниципального этапа всероссийской олимпиады школьников в Майкопе.</p>

    <p>Темная ночь. Шумят волны, начинает капать дождь. Челкаш после очередного заплыва приплыл к контрабандистам, чтобы сбыть награбленный товар. Однако не все пошло по плану: выяснилось, что у контрабандистов на корабле уже фактически нет места. Задачу о рюкзаке контрабандисты не знают, и потому они требуют, чтобы Челкаш отдавал им товар в порядке неубывания веса. Челкаш уже очень устал и ничего не соображает, и потому эта задача кажется ему непосильной.</p>

    <p>К его счастью, в этот раз он приплыл не один, а вместе с Гаврилой. Но запуганный Гаврила сидит в углу лодки и еле может пошевелить руками, и потому отсортировать товар он также не может. Поэтому Челкаш решает поступить так: он выкладывает весь товар в ряд и q раз меняет какие-то два элемента ряда местами. После этого он бросается на Гаврилу и требует, что бы он сказал, является ряд отсортированным по неубыванию или нет. Как уже было сказано, Челкаш очень устал, и даже если в какой-то момент товар оказался отсортированным, Челкаш может продолжить задавать вопросы.</p>

    <p>В темноте Гаврила видит очень плохо, и потому он не может помочь своему товарищу. Но в то же время он понимает, что если он ошибется, то на следующий день, когда Челкаш узнает об ошибке, Гавриле несдобровать. Гаврила просит Вас помочь ему справиться со столь непростой задачей.</p>

    <h4>Входные данные</h4>

    <p>В первой строке входных данных дано два целых числа n и q (2 ≤ n ≤ 10⁵, 1 ≤ q ≤ 10⁵) — количество товара и запросов соответственно. Во второй строке дано n натуральных чисел, не превосходящих 10⁹ — веса товаров. Далее следуют q строк, каждая из которых содержит два различных целых числа a и b (1 ≤ a, b ≤ n), означающих, что Челкаш поменял элементы ряда с позициями a и b местами.</p>

    <h4>Выходные данные</h4>

    <p>Выведите q строк, являющимися ответами на запросы Челкаша. Если после изменения позиций элементов ряд стал отсортированным по неубыванию, выведите "Sorted!". В противном случае выведите "Unsorted!". Кавычки выводить не нужно.</p>

    <h4>Sample Input 1:</h4>
<pre>
5 4
1 2 5 3 4
3 4
4 5
1 5
5 1
</pre>

    <h4>Sample Output 1:</h4>
<pre>
Unsorted!
Sorted!
Unsorted!
Sorted!
</pre>

    <h4>Sample Input 2:</h4>
<pre>
2 3
2 10
1 2
1 2
1 2
</pre>

    <h4>Sample Output 2:</h4>
<pre>
Unsorted!
Sorted!
Unsorted!
</pre>
  <p>Создадим второй массив B из элементов первого массива A и отсортируем его. Сравним элементы массивов A и B и посчитаем сколько элементов отличается.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;  //sort()

using namespace std;

void swap(int* a, int* b) {
  int tmp = *a;
  *a = *b;
  *b = tmp;
}

int main() {
  int n, q;
  cin >> n >> q;
  vector&lt;int&gt; a(n), sorted(n);
  int incorrect = 0;  // Количество несортированных позиций

  // Считываем массив
  for (int i = 0; i &lt; n; i++) {
    cin >> a[i];
    sorted[i] = a[i];  // Копируем в отсортированный массив
  }

  // Сортируем массив для дальнейшего сравнения
  sort(sorted.begin(), sorted.end());

  // Изначально проверяем количество "несортированных" позиций
  for (int i = 0; i &lt; n; i++) {
    if (a[i] != sorted[i]) {
      incorrect++;
    }
  }

  // Обрабатываем запросы
  for (int i = 0; i &lt; q; i++) {
    int x, y;
    cin >> x >> y;
    x--; y--;  // Приведение к нулевому индексу

    // Проверяем сколько несортированных элементов участвуют в обмене
    int before_swap = 0;
    if (a[x] != sorted[x]) before_swap++;
    if (a[y] != sorted[y]) before_swap++;

    // Меняем элементы местами
    swap(a[x], a[y]);

    // После обмена проверяем несортированность этих двух элементов
    int after_swap = 0;
    if (a[x] != sorted[x]) after_swap++;
    if (a[y] != sorted[y]) after_swap++;

    // Обновляем количество неправильных позиций
    incorrect = incorrect - before_swap + after_swap;

    // Выводим результат
    if (incorrect == 0) {
      cout &lt;&lt; "Sorted!" &lt;&lt; endl;
    } else {
      cout &lt;&lt; "Unsorted!" &lt;&lt; endl;
    }
  }

  return 0;
}
</pre>
  </details>
</article>


<!-- 4 Сложные структуры данных -->
<article class="article">
  <div class="anchor" id="p4"></div>
  <h3>4 Сложные структуры данных</h3>
</article>


<!-- 4.1 Указатели -->
<article class="article">
  <div class="anchor" id="p4.1"></div>
  <h3>4.1 Указатели</h3>

  <p>Любая программа на C++ работает в памяти. В нулевом приближении будем считать что память это просто последовательность байт. Для каждой переменной или массиву переменных выделяется соответствующее количество последовательно расположенных ячеек памяти. Для типа int 4, для типа double 8, для массива их 30-ти long long 8*30 = 240 байт.</p>
  <p>Указатель это переменная, которая хранит адрес в памяти где находится переменная, а точнее номер первой ячейки.</p>
  <p>Чтобы создать указатель на переменную типа int нужно записать</p>
  <code>int *uk;</code>
  <p>Переменная создана, но она не проинициализирована, она никуда не указывает. Чтобы это исправить, создадим переменную типа int и запишем ее адрес в указатель</p>
  <code>int d = 5;</code>
  <code>uk = &d;</code>
  <p>Здесь знак & это оператор, который по заданной переменной d находит ее адрес в памяти. Вычисляется адрес переменной d и записывается в uk.</p>
  <p>Указатель хранит в себе адрес переменной. Чтобы получить значение переменной нужно выполнить операцию разименования указателя. Для этого служит оператор звездочка *. Оператор звездочка * является обратным к оператору амперсанд &. Результатом является, в нулевом приближении, значение хранящееся в области памяти, на которую указывает оператор звездочка *.</p>
  <p>Пока uk указывает на переменную d, выражение *uk это практически псевдоним d. Можно брать (*uk) в скобки, чтобы понять что это не операция умножения, а операция разименования.</p>
  <p>Чтобы объявить несколько указателей в одной строке, нужно писать звездочку около каждого имени переменной.</p>
  <code>int *uka, *ukb, *ukc;</code>
  <p>В процессе программы, значение указателя может переприсваиваться.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  double d = 0.0, d2 = 0.0;
  double *uk = &d;
  *uk = 5.34;
  cout &lt;&lt; d &lt;&lt; ' ' &lt;&lt; d2 &lt;&lt; endl; // 5.34 0

  uk = &d2;
  *uk = 7.19;
  cout &lt;&lt; d &lt;&lt; ' ' &lt;&lt; d2 &lt;&lt; endl; // 5.34 7.19
  return 0;
}
</pre>
  <p>Указатели можно переприсваивать друг другу</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  double d = 0.0, d2 = 0.0;
  double *uk = &d;
  *uk = 5.34;
  cout &lt;&lt; d &lt;&lt; ' ' &lt;&lt; d2 &lt;&lt; endl; // 5.34 0

  double *uk2 = &d2;
  *uk2 = 7.19;
  cout &lt;&lt; d &lt;&lt; ' ' &lt;&lt; d2 &lt;&lt; endl; // 5.34 7.19

  uk = uk2;
  *uk = 2.56;
  cout &lt;&lt; d &lt;&lt; ' ' &lt;&lt; d2 &lt;&lt; endl; // 5.34 2.56
  cout &lt;&lt; *uk &lt;&lt; ' ' &lt;&lt; *uk2 &lt;&lt; endl; // 2.56 2.56

  uk = NULL; // uk = 0
  if (uk == 0) {
    cout &lt;&lt; "ZERO POINTER!" &lt;&lt; endl;
  } else {
    cout &lt;&lt; *uk &lt;&lt; endl;
  }

  return 0;
}
</pre>
  <p>Возможно что два или более указателей указывают на одну и ту же переменную. В этом случае, когда мы изменяем переменную, то она изменится для всех указателей на нее указывающих.</p>
  <p>Указателю может быть присвоено значение 0 или NULL. Это означает что указатель не указывает никуда. При попытке разименовать такой указатель, программа аварийно завершит работу с ошибкой segmentation fault. Необходимо всегда следить за тем, чтобы нулевой указатель ни при каких обстаятельствах не разименовывался.</p>
  <p>Указатели могут сравниваться не только с нулем, но и между собой.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  long long a = 348, b = 585829;
  long long *uka = &a;
  long long *ukb = &b;
  cout &lt;&lt; (uka == ukb) &lt;&lt; ' ' &lt;&lt; ((*uka) == (*ukb)) &lt;&lt; endl; // 0 0

  *uka = *ukb;
  cout &lt;&lt; (uka == ukb) &lt;&lt; ' ' &lt;&lt; ((*uka) == (*ukb)) &lt;&lt; endl; // 0 1

  uka = ukb;
  cout &lt;&lt; (uka == ukb) &lt;&lt; ' ' &lt;&lt; ((*uka) == (*ukb)) &lt;&lt; endl; // 1 1

  cout &lt;&lt; (uka == ukb) &lt;&lt; endl; // 0
  return 0;
}
</pre>

  <p>Сравнение указателей на разные переменные смысла не имеет, потому что только компилятор решает поместить переменную в ячейку памяти с большим адресом или с меньшим. Исключением является ситуация когда указатели показывают на элементы одного и того же массива. Тогда меньшим окажется тот указатель, который указывает на элемент с меньшим индексом.</p>
  <p>Чтобы задать массив в памяти, компилятору нужно знать три вещи.</p>
  <ol>
    <li>Тип элементов</li>
    <li>Где находится начало массива</li>
    <li>Число элементов</li>
  </ol>
  <p>Первые два пункта могут быть заданы указателем.</p>
  <code>int a[10];</code>
  <code>int *uk = a;</code>
  <p>Это идентично записи</p>
  <code>int *uk = &a[0]</code>
  <p>Таким образом, можно считать, что переменная с именем a уже является указателем. От настоящего указателя его отличает только то, что невозможно изменить его значение.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a[10];
  a[0] = 19;
  a[4] = 57;

  int *uk = a;
  cout &lt;&lt; *uk &lt;&lt; endl; // 19

  uk = &a[0];
  cout &lt;&lt; *uk &lt;&lt; endl; // 19

  uk = &a[4];
  cout &lt;&lt; *uk &lt;&lt; endl; // 57

  return 0;
}
</pre>

  <p>Аналогичным образом устроен и многомерный массив.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a[10] = {5,11,34,144,38,-4,2,1,9,3};

  int *uk = &a[4];
  cout &lt;&lt; *uk &lt;&lt; endl; // 38

  uk = a + 4;
  cout &lt;&lt; *uk &lt;&lt; endl; // 38

  uk -= 3; // uk = &a[1];
  cout &lt;&lt; *uk &lt;&lt; endl; // 11

  uk -= 3; // uk = &a[-2]; выход за границы массива
  cout &lt;&lt; *uk &lt;&lt; endl;

  return 0;
}
</pre>

  <p>Компилятор никак не следит за выходом за пределы массива. Эта ответственность на программисте. Однако указатели выходящие за пределы массива вполне могут быть полезными.</p>

<pre>
#include &lt;iostream&gt;

using namespace std;

// большие массивы лучше объявлять глобальными
const int MAXN = 10000000;
int a[MAXN];

int main() {
  // заполним массив числами от 0 до MAXN-1
  // 1 способ
  for (int i = 0; i &lt; MAXN; i++) {
    a[i] = i;
  }
  // 2 способ
  int *ukbegin = a;
  int *ukend = a + MAXN;
  int i = 0;
  for (int *uk = ukbegin; uk != ukend; uk++) {
    *uk = i;
    i++;
  }

  return 0;
}
</pre>

  <p>Во втором способе применение указателей дает небольшое ускорение - порядка 10%.</p>

  <details>
    <summary>Задача 1. Куда бы указать?</summary>
    <p>На черном рынке вы добыли два указателя. По законам вашей страны с собой нельзя носить больше одного указателя, поэтому вы решили пойти на хитрость - сделать так, чтобы эти два указателя указывали в одно место: так поймавший вас жандарм может принять их за один. Сделайте это!</p>

    <h4>Техническая часть</h4>

    <p>Вам необходимо написать часть программы, в результате работы которой два объявленных выше указателя начинают указывать на одно и то же место в памяти. Гарантируется, что выше объявлено два указателя ptr1 и ptr2, оба имеют тип int*.</p>
<pre>
ptr1 = ptr2;
</pre>
  </details>

  <details>
    <summary>Задача 2. Заполнение массива</summary>

    <p>За участие в олимпиаде вам подарили массив размера n. Однако, поскольку вы заняли k-е место, то вместо того, чтобы просто отдать вам массив, вам дали указатель на его k-ю позицию в 0-нумерации. Теперь вы хотите заполнить его числами от n до 1 по убыванию.</p>

    <h4>Техническая часть</h4>

    <p>Вам необходимо реализовать часть программы, в результате работы которой в данном массиве окажутся числа от n до 1, идущие в массиве по убыванию. Гарантируется, что где-то выше объявлены и проинициализированы переменные n, k, считывать их не нужно. Также объявлен указатель ptr, указывающий на k-й элемент массива в 0 нумерации.</p>

    <h4>Sample Input:</h4>
    <code>5 3</code>

    <h4>Sample Output:</h4>
    <code>5 4 3 2 1</code>
<pre>
for (int i = n; i > 0; i--) {
  *(ptr - k + n - i) = i;
}
</pre>
  </details>

  <details>
    <summary>Задача 3. Сколько указателей?</summary>

    <p>На огороде вы вырастили 10 указателей, и пришла пора собирать плоды! К сожалению, некоторые указатели еще не выросли - они указывают на нулевой указатель. Все остальные - на какие-либо переменные. Вам необходимо написать часть программы, которая посчитает, сколько из данных указателей указывают на переменную.</p>

    <h4>Техническая часть</h4>

    <p>Выше объявлено 10 указателей с именами a1 a2 a3 ... a10. Каждый из них указывает либо на реальную переменную, либо в нулевой указатель. Вам необходимо создать переменную ans и положить в нее количество указателей, указывающих на переменную.</p>
<pre>
int ans = 0;
if (a1 != nullptr) ans++;
if (a2 != nullptr) ans++;
if (a3 != nullptr) ans++;
if (a4 != nullptr) ans++;
if (a5 != nullptr) ans++;
if (a6 != nullptr) ans++;
if (a7 != nullptr) ans++;
if (a8 != nullptr) ans++;
if (a9 != nullptr) ans++;
if (a10 != nullptr) ans++;
</pre>
  </details>

  <details>
    <summary>Задача 4. Какого размера массив?</summary>

    <p>Вы подглядели у вашего друга массив. Теперь у вас есть несколько указателей на него. На массив, конечно, не на друга. Теперь вы хотите узнать, насколько у него маленький массив. Другими словами, вы хотите найти такое минимальное число k, что в массиве размера k можно создать все указатели, данные вам. Например, если у вас есть три указателя, которые указывают на 3-й, 4-й и 7-й элементы, то ответом будет 5 - достаточно взять подмассив исходного с третьего по седьмой элемент.</p>

    <h4>Техническая часть</h4>
    <p>Где-то выше объявлена переменная n и массив указателей a размера n. Гарантируется, что все указатели в этом массиве указывают на какие-то элементы массива вашего друга. Сам массив содержит в себе элементы типа int*. Вам необходимо создать переменную ans и положить в нее минимально возможный размер массива друга</p>
<pre>
int *minPtr = a[0], *maxPtr = a[0];
for (int i = 0; i &lt; n; i++) {
  if (a[i] > maxPtr) maxPtr = a[i];
  if (minPtr > a[i]) minPtr = a[i];
}
int ans = maxPtr - minPtr + 1;
</pre>
  </details>
</article>


<!-- 4.2 Передача параметров в функцию -->
<article class="article">
  <div class="anchor" id="p4.2"></div>
  <h3>4.2 Передача параметров в функцию</h3>

  <p>Рассмотрим межфункциональное взаимодействие с использованием указателей и ссылок. Можно передать переменную в функцию по указателю.</p>

  <p>Рассмотрим простой пример. Функция sqr() принимает число и возвращает его квадрат. Чтобы изменить переменную a на ее квадрат, нужно записать a = sqr(a);. При этом сначала значение переменной a копируется во временную переменную x, значение переменной x возводится в квадрат, копируется значение переменной x в переменную a.</p>

<pre>
#include &lt;iostream&gt;

using namespace std;

int sqr(int x) {
  return x * x;
}

int main() {
  int a = 57;
  a = sqr(a);
  cout &lt;&lt; a &lt;&lt; endl; // 3249

  int dp[10][10][11][17];
  int i = 5, j = 7, k = 9, l = 11;

  dp[i][j][k][l] = sqr(dp[i][j][k][l]);
  // место, где расположено dp[i][j][k][l],
  // будет вычисляться дважды

  return 0;
}
</pre>

  <p>Двух лишних копирований можно избежать если передавать в функцию не переменную, а указатель на нее.</p>

<pre>
#include &lt;iostream&gt;

using namespace std;

void sqr(int *x) {
  *x *= (*x);
}

int main() {
  int a = 57;
  sqr(&a);
  cout &lt;&lt; a &lt;&lt; endl; // 3249

  int dp[10][10][11][17];
  int i = 5, j = 7, k = 9, l = 11;

  sqr(&dp[i][j][k][l]);
  // место, где расположено dp[i][j][k][l],
  // теперь вычисляется лишь один раз

  return 0;
}
</pre>

  <h4>Передача массива в функцию</h4>
  <p>Мы можем передавать в функцию и массив. По указателю на начало массива проблематично узнать количество элементов в нем. Но можно передать еще и указатель на конец массива.</p>

<pre>
#incude &lt;iostream&gt;
#include &lt;memory.h&gt;

using namespace std;

int fillArray(int* ukbegin, int* ukend) {
  int i = 0;
  for (int* uk = ukbegin; uk != ukend; ++uk) {
    *uk = i++;
  }

  return ukend - ukbegin;
}

int main() {
  const int n = 20;
  int a[n];
  // заполняем массив нулями
  memset(a, 0, sizeof(a));
  for (int i = 0; i &lt; n; ++i) {
    cout &lt;&lt; a[i] &lt;&lt; ' ';
  }
  cout &lt;&lt; endl;

  cout &lt;&lt; fillArray(a, a + 10) &lt;&lt; endl; // 10
  for (int i = 0; i &lt; n; ++i) {
    cout &lt;&lt; a[i] &lt;&lt; ' ';
  }
  cout &lt;&lt; endl;

  cout &lt;&lt; fillArray(a + 5, a + 13) &lt;&lt; endl; // 8
  for (int i = 0; i &lt; n; ++i) {
    cout &lt;&lt; a[i] &lt;&lt; ' ';
  }
  cout &lt;&lt; endl;

  return 0;
}
</pre>

  <p>Указатели на одинаковый тип можно вычитать друг из друга и тогда будет вычислено расстояние между ними, выраженное в количестве переменных этого типа, которые могут уместиться между ними. Например, начало включительно, а конец - нет.</p>
  <p>Классическим примером является функция swap(), которая принимает две переменные и меняет их значения местами. Для этого нужно передать в функцию указатели на две переменные, как это показано в первом примере.</p>
<pre>
по указателю
#include &lt;iostream&gt;

using namespace std;

void swap(int* a, int* b) {
  int tmp = *a;
  *a = *b;
  *b = tmp;
}

int main() {
  int x = 5;
  int y = 7;
  swap(&x, &y);
  cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; endl; // 7 5

  return 0;
}
</pre>

  <p>Если передавать в функцию сами переменные, то с исходными переменными ничего не произойдет, как это показано во втором примере. В этом случае вы скопировали переменные и функция меняла местами копии переменных.</p>
<pre>
по значению
#include &lt;iostream&gt;

using namespace std;

void swap(int a, int b) {
  int tmp = a;
  a = b;
  b = tmp;
}

int main() {
  int x = 5;
  int y = 7;
  swap(&x, &y);
  cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; endl; // 5 7

  return 0;
}
</pre>

  <p>Чтобы передавать в функцию указатели, нужно при вызове функций, приписывать амперсанды к переменным. Но можно использовать и ссылки.</p>

  <h4>Ссылки: псевдонимы переменных</h4>

  <p>Ссылка очень похожа на указатель. Отличие в том, что значение указателя можно поменять и он будет указывать на другой адрес. Ссылка всегда указывает на один адрес.</p>
  <p>Чтобы понять как работает ссылка, рассмотрим пример. Объявим ссылку int& link = a;. Теперь link это еще одно имя переменной a. Область видимости link такая же как у переменной a.</p>

<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int a = 5;
  int& link = a;
  cout &lt;&lt; link &lt;&lt; endl; // 5

  link = 7;
  cout &lt;&lt; a &lt;&lt; endl; // 7

  a *= 2;
  cout &lt;&lt; link &lt;&lt; endl; // 14

  return 0;
}
</pre>

  <p>Такая ссылка очень удобная при использовании многомерных массивов.</p>
  <p>Например, если мы работаем с переменной dp[i][j][k][l], то нехорошо ее использовать по нескольку раз и заставлять компилятор по нескольку раз вычислять положение переменной в массиве по переменным i, j, k, l.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int dp[5][7][9][12];
  dp[2][3][5][7] = 5;
  dp[2][3][5][7] *= dp[2][3][5][7] + 3;
  int a = dp[2][3][5][7] / 38;
  cout &lt;&lt; dp[2][3][5][7] * 2 - 5 + a &lt;&lt; endl;

  return 0;
}
</pre>

  <p>Вместо этого, имеет смысл завести ссылку link на dp[i][j][k][l] и работать дальше с link. Это и удобнее и эффективнее.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int dp[5][7][9][12];
  int &link = dp[2][3][5][7];
  link = 5;
  link *= link + 3;
  int a = link / 38;
  cout &lt;&lt; link * 2 - 5 + 5 &lt;&lt; endl;

  return 0;
}
</pre>

  <h4>Передача параметров по ссылке</h4>

  <p>Рассмотрим передачу переменных в функцию по ссылке. Теперь вместо звездочек * d в описании параметров функции стоят амперсанды &. Это означает что в функцию мы передали две переменные, которые внутри функции будут называтья a и b. Копирование при этом не происходит. Ведь a и b это лишь ссылки, на объявленные в другом месте, переменные. И в результате swap-а их значения будут изменяться</p>
  <p>Аналогично реализуется и функция возведения в квадрат.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

void ewap(int &a, int &b) {
  int t = a;
  a = b;
  b = t;
}

void sqr(int &x) {
  x *= x;
}

int main() {
  int p = 5;
  int q = 7;
  swap(p, q);
  cout &lt;&lt; p &lt;&lt; ' ' &lt;&lt; endl; // 7 5
  sqr(p);
  cout &lt;&lt; p &lt;&lt; endl; // 49

  return 0;
}
</pre>

  <h4>По ссылке или по значению? По значению - бессмысленно</h4>

  <p>Рассмотрим функцию, которая принимает два параметра a и b и увеличивает a. Как передать переменные? По ссылке или по значению? Если передать обе переменные по значению, то функция будет бессмысленной. Будут скопированы два значения без изменения исходных переменных.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

void inc(int x, int y) {
  x += y * y;
}

int main() {
  int a = 5;
  int b = 7;

  inc(a, b);
  cout &lt;&lt; a &lt;&lt; endl; // 5

  return 0;
}
</pre>

  <p>По ссылке - лучше, но не идеально. В этом случае все хорошо работает если мы передаем по ссылке переменные. Но если мы передаем число, то возникает ошибка компиляции. Передавать по ссылке можно только переменную.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;memory.h&gt;

using namespace std;

void inc(int &x, int &y) {
  x += y * y;
}

int main() {
  int a = 5;
  int b = 7;

  inc(a, b);
  cout &lt;&lt; a &lt;&lt; endl; // 54

  inc(a, 3); // не компилируется

  return 0;
}
</pre>

  <p>Можно комбинировать! Одну переменную передать по ссылке, а другую по значению.</p>

<pre>
#include &lt;iostream&gt;
#include &lt;memory.h&gt;

using namespace std;

void inc(int &x, int y) {
  x += y * y;
}

int main() {
  int a = 5;
  int b = 7;

  inc(a, b);
  cout &lt;&lt; a &lt;&lt; endl; // 54

  inc(a, 3);
  cout &lt;&lt; a &lt;&lt; endl; // 14

  return 0;
}
</pre>

  <p>Мы рассмотрели только базовую работу с указателями и ссылками. Мы еще не рассматривали модификаторы const и работу с динамической памятью. Если описывать все возможности работы с указателями и ссылками, то надо описать половину работы всего языка C++.</p>

  <details>
    <summary>Задача 1. Прием по ссылке</summary>
    <p>В этой задаче требуется реализовать функцию, которая принимает число типа int по ссылке и увеличивает его значение в два раза.</p>
    <p>Реализуйте единственную функцию f, принимающую одно число типа int по ссылке и увеличивающее его значение в два раза.</p>
<pre>
void f(int &a) {
  a *= 2;
}
</pre>
  </details>

  <details>
    <summary>Задача 2. Подозрительный подарок</summary>
    <p>Недавно вы были в шаурмячной рядом с вокзалом, и в ней, в дополнение к шаурме, вам подарили указатель. Сама шаурма никаких подозрений вызывать не может, а вот с указателем может быть что-то нечисто. Вы решили его проверить. Для этого вам необходимо реализовать функцию, которая возвращает истину, если указатель нулевой, и ложь иначе.</p>
    <p>Вам необходимо реализовать функцию check, принимающую один указатель на переменную типа int, и возвращающую true, если этот указатель нулевой и ложь иначе.</p>

    <p>Пример</p>
    <code>0</code>
    <code>1</code>
<pre>
bool check(int *p) {
  return !p;
}
</pre>
  </details>

  <details>
    <summary>Задача 3. Арифметическая прогрессия</summary>
    <p>Иван прятал числа на черный день, и вот этот черный день настал! За всю свою жизнь Иван накопил целых три целых числа, но за такой долгий срок последнее число немножко поели крысы. Иван точно помнить, что данные три числа образовывали арифметическую прогрессию. Помогите Ивану, напишите функцию, которая принимает три переменные и исправляет третью.</p>
    <p>Вам необходимо реализовать функцию f, принимающую три целых числа типа int. В результате работы функции числа в этих трех переменных должны образовывать арифметическую прогрессию в том порядке, в котором они были переданы в функцию. Обратите внимание - значения должны измениться в переданных переменных, а не в созданных для функции копиях.</p>

    <p>Пример</p>
    <code>6 9 13</code>
    <code>6 9 12</code>
<pre>
void f(int &a, int &b, int &c) {
  int tmp = b - a;
  c = b + tmp;
}
</pre>
  </details>

  <details>
    <summary>Задача 4. Расстояние</summary>
    <p>Мы загадали массив, содержащий переменные типа int и два числа в нем. Вам необходимо реализовать функцию, которая ищет расстояние между загаданными элементами. Причем на вход вашей функции мы будем передавать сами эти элементы. Другими словами, в функции main следующий код должен выводить на экран количество элементов между  i-м и j-м элементом массива включительно.</p>
    <code>cout &lt;&lt; dist(a[i], a[j]) &lt;&lt; endl;</code>
    <p>Вам необходимо реализовать функцию dist, которая по переданным элементам одного массива типа int определит расстояние между ними.</p>

    <p>Пример</p>
    <code>10 4 6</code>
    <code>3</code>
<pre>
int dist(int &i, int &j) {
  int *iPtr = &amp;i;
  int *jPtr = &amp;j;
  return abs(iPtr - jPtr) + 1;
}
</pre>
  </details>

  <details>
    <summary>Задача 5. Вечное слияние упорядоченного разума</summary>
    <p>В этой задаче вам необходимо реализовать функцию merge. Эта функция принимает на вход 5 указателей: первые два указывают на начало и конец первого массива включительно, следущие два - на начало и конец второго массива, а пятый указатель указывает на начало массива-буфера, в который необходимо слить первые два. Гарантируется, что данные массивы не пересекаются между собой и буфером, а также что в буфере достаточно выделенной памяти, чтобы вместить первые два. Также гарантируется, что размеры исходных массивов не превосходят 10⁵.</p>
    <p>Дополнительно гарантируется, что два данных массива отсортированы по неубыванию, требуется чтобы получившийся массив также был отсортирован по неубыванию.</p>

    <p>Пример</p>
<pre>
4
1 7 8 9
6
1 2 3 3 9 10
</pre>
  <code>1 1 2 3 3 7 8 9 9 10 </code>

<pre>
void merge(int *p1, int *p2, int *s1, int *s2, int *d) {
  while (p2 >= p1 && s2 >= s1) {
    if (*p1 >= *s1) {
      *d = *s1;
      d++;
      s1++;
    } else {
      *d = *p1;
      d++;
      p1++;
    }
  }

  while (p2 >= p1) {
    *d = *p1;
    d++;
    p1++;
  }

  while (s2 >= s1) {
    *d = *s1;
    d++;
    s1++;
  }
}
</pre>
  </details>
</article>


<!-- 4.3 Структура: определение и поля -->
<article class="article">
  <div class="anchor" id="p4.3"></div>
  <h3>4.3 Структура: определение и поля</h3>

  <h4>Сложные объекты</h4>

  <p>В этом уроке мы обсудим как можно создавать свои пользовательские типы данных и методы работы с ними. Стандартные типы данных, такие как int, char, long long и т.п., не всегда удобны сами по себе. Зачастую, объекты, с которыми мы работаем, описываются с помощью нескольких параметров.</p>
  <p>Например, для описания жилого дома нужны несколько параметров: высота, число этажей, число квартир, адрес... На каждый параметр можно завести переменную, но что если таких объектов несколько? И с ними нужно работать. Например, сортировать их по высоте, находить минимальное количество этажей. Способ по умолчанию это хранить несколько массивов, в каждом из которых хранить некоторые параметры. Но это крайне неудобно, например, если хочется поменять два объекта местами. Тогда нужно поменять местами все параметры у соответствующих массивов. В этом случае, всегда есть риск забыть поменять какой-нибудь параметр. Особенно остро эта проблема проявляется если вы захотите добавить еще один параметр уже после того как написали основной код. В этом случае легко забыть, что у функции swap надо добавить еще одну строчку. Также большим недостатком будет что вся разработка завязана на конкретном наборе массивов. Например, swap не сможет поменять местами такие же дома, но хранящиеся в других массивах.</p>
  <p>Вследствие такого рода неудобств, в C++ всроена возможность создания своего пользовательского типа. Чтобы начать, необходимо написать:</p>
  <code>struct House {};</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

struct House {};

void helloHouse(House h) {
  cout &lt;&lt; "Hello, House!" &lt;&lt; endl;
}

int main() {
  House h;
  helloHouse(h);

  return 0;
}
</pre>

  <p>Теперь мы можем сказать, что мы создали новый тип данных House. Можно создавать переменную типа House и даже передавать ее в функцию. Но практического смысла все это пока не имеет. Чтобы обрести практический смысл, добавим в нашу структуру переменные.</p>
<pre>
struct House {
  double height;
  int floors;
  int flats;
};
</pre>
  <p>Сейчас наш House состоит из трех параметров: высоты height, этажей floors и квартир flats. Эти переменные называются полями структуры House.</p>
  <p>Напишем программу, в которой создадим экземпляры структуры House и поработаем с их полями. Присвоим им некоторые значения.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

struct House {
  double height;
  int floors;
  int flats;
};

int main() {
  House h1, h2, h3, h4;
  h3.height = 10.74;
  h3.floors = 3;
  h3.flats = 12;

  cin >> h1.height >> h1.floors >> h1.flats;

  h1.height += h3.height;
  h2.height = h1.height - h3.height;
  h2.floors = h1.floors + h3.floors;
  h2.flats = h2.floors * 2 + h3.floors * 3;

  cout &lt;&lt; h2.height &lt;&lt; ' '
       &lt;&lt; h2.floors &lt;&lt; ' '
       &lt;&lt; h2.flats &lt;&lt; endl;

  return 0;
}
</pre>
  <p>Можно присваивать значение не только полям структуры, но и всей структуре целиком. Если, например, мы напишем h4 = h3, то значение всех полей h3 будут почленно скопированы в h4. Также мы можем объявить ссылку и указатель на экземпляр класса House.</p>
  <p>Обратите внимение, если у вас есть указатель ukh на структуру, то доступ к его полям осуществляется не с помощью оператора "." точка, а с помощью оператора "->" стрелочка.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

struct House {
  double height;
  int floors;
  int flats;
};

int main() {
  House h1, h2, h3, h4;
  h3.height = 10.74;
  h3.floors = 3;
  h3.flats = 12;

  h4 = h3;
  cout &lt;&lt; h4.height &lt;&lt; ' '
       &lt;&lt; h4.floors &lt;&lt; ' '
       &lt;&lt; h4.flats &lt;&lt; endl;

  House &linkh3 = h3;
  linkh3.floors *= 5;
  cout &lt;&lt; h3.height &lt;&lt; ' '
       &lt;&lt; h3.floors &lt;&lt; ' '
       &lt;&lt; h3.flats &lt;&lt; endl;

  House* ukh = &amp;h4;
  ukh->height += 13.82;
  cout &lt;&lt; ukh->height &lt;&lt; ' '
       &lt;&lt; ukh->floors &lt;&lt; ' '
       &lt;&lt; ukh->flats &lt;&lt; endl;

  return 0;
}
</pre>

  <p>Класс можжно передавать в функцию по значению или ссылке, а также возвращать его из функции. В программе ниже структура считывается с экрана. В функцию swap() параметры передаются по ссылке.</p>

<pre>
#include &lt;iostream&gt;

using namespace std;

struct House {
  double height;
  int floors;
  int flats;
};

House readHouse() {
  House h;
  cin >> h.height >> h.floors >> h.flats;
  return h;
}

void swap(House& h1, House& h2) {
  House tmp = h1;
  h1 = h2;
  h2 = tmp;
}

void printHouse(House* h) {
  cout &lt;&lt; h->height &lt;&lt; ' '
       &lt;&lt; h->floors &lt;&lt; ' '
       &lt;&lt; h->flats &lt;&lt; endl;
}

int main() {
  House h3, h4;
  h3 = readHouse();
  h4 = readHouse();
  swap(h3, h4);
  printHouse(&h3);
  printHouse(&h4);

  return 0;
}
</pre>

  <p>Подведем промежуточный итог, написав программу, которая считывает чило n и n домов, каждый из которых задан тремя параметрами. Запишем их в массив, отсортируем по возрастанию высоты и выведем их номера на экран в отсортированном порядке.</p>

<pre>
#include &lt;iostreqm&gt;

using namespace std;

struct House {
  double height;
  int floors;
  int flats;
  int id;
}

House readHouse(int id) {
  House h;
  cin >> h.height >> h.floors >> h.flats;
  h.id = id;
  return h;
}

void swap(House &h1, House &h2) {
  House tmp = h1;
  h1 = h2;
  h2 = tmp;
}

void sortByHeight(House* begin, House* end) {
  for (House* bound = end; bound != begin; --bound) {
    for (House* uk = begin + 1; uk != end; ++uk) {
      if (uk->height &lt; (uk - 1)->height) {
        swap(*uk, *(uk - 1));
      }
    }
  }
}

const int MAXN = 10000;
House houses[MAXN];

int main() {
  int n;
  cin >> n;
  for (int i = 0; i &lt; n; ++i) {
    houses[i] = readHouse(i);
  }
  sortByHeight(houses, houses + n);
  for (int i = 0; i &lt; n; ++i) {
    cout &lt;&lt; houses[i].id &lt;&lt; ' ';
  }
  cout &lt;&lt; endl;

  return 0;
}
</pre>
  <p>Конечно, можны было создать массив объявленных структур. Очень удобным оказывается решение добавить новое поле id чтобы понимать какой номер соответствующий house имеет в нашем массиве.</p>
  <p>Далее мы затронем такие темы как методы структуры и перегрузка операторов. Сделаем это на примере класса Time, который будет хранить временные моменты и отрезки, в том числе отрицательные, выраженные в сутках, часах, минутах и секундах. Для этого достаточно хранить четыре целочисленных параметра. Часы бывают от 0 до 23, минуты и секунды - от 0 до 59.</p>

<pre>
#include &lt;iostream&gt;

using namespace std;

struct Time {
  int days, hours, minutes, seconds;
};

int getSeconds(Time t) {
  return ((t.days * 24 + t.hours) * 60 + t.minutes) * 60 + t.seconds;
}

int main() {
  Time t1; // промежуток времени 320 минут
  t1.days = 0;
  t1.hours = 5;
  t1.minutes = 20;
  t1.seconds = 0;
  cout &lt;&lt; getSeconds(t1) &lt;&lt; endl; // 19200

  Time t2; // момент времени -1 секунда
  t2.days = -1;
  t2.hours = 23;
  t2.minutes = 59;
  t2.seconds = 59;
  cout &lt;&lt; getSeconds(t2) &lt;&lt; endl; // -1

  Time t3; // год, округленный до часов
  t3.days = 365;
  t3.hours = 6;
  t3.minutes = 0;
  t3.seconds = 0;

  // момент времени за 6 дней
  // 12 часов 36 минут 14 секунд
  Time t4;
  t4.days = -7;
  t4.hours = 11;
  t4.minutes = 23;
  t4.seconds = 46;
  cout &lt;&lt; getSeconds(t4) &lt;&lt; endl; // -563774

  return 0;
}
</pre>

  <p>Временной промежуток удобно задавать в количестве секунд. Поэтому нам понадобится функция getSeconds(), которая вычисляет количество секунд, которое составляет заданный промежуток.</p>
  <p>Напишем еще один способ реализации такой функции. Для этого мы занесем реализацию функции внутрь структуры. Это превратит функцию в метод структуры.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

struct Time {
  int days, hours, minutes, seconds;

  int inSeconds() {
    return ((days * 24 + hours) * 60 + minutes) * 60 + seconds;
  }
};

int main() {
  Time t1; // промежуток времени 320 минут
  t1.days = 0;
  t1.hours = 5;
  t1.minutes = 20;
  t1.seconds = 0;
  cout &lt;&lt; t1.inSeconds() &lt;&lt; endl; // 19200

  Time t2; // момент времени -1 секунда
  t2.days = -1;
  t2.hours = 23;
  t2.minutes = 59;
  t2.seconds = 59;
  cout &lt;&lt; t2.inSeconds() &lt;&lt; endl; // -1

  // момент времени за 6 дней
  // 12 часов 36 минут 14 секунд
  Time t3;
  t3.days = -7;
  t3.hours = 11;
  t3.minutes = 23;
  t3.seconds = 46;
  cout &lt;&lt; t3.inSeconds() &lt;&lt; endl; // -563774

  return 0;
}
</pre>

  <p><strong>Метод</strong> это функция, определенная внутри класса и имеющая доступ ко всем его полям, а также другим методам, без использования точек. Сам метод может быть вызван у экземпляра класса через точку.</p>
  <p>Неудобно почленно прописывать чему равен каждый из членов у каждого из класса. Хорошей идеей оказывается реализовать метод setData() с четырьмя параметрами. Теперь можно определить экземпляр класса в одну строчку, а не в четыре.</p>

<pre>
#include &lt;iostream&gt;

using namespace std;

struct Time {
  int days, hours, minutes, seconds;

  void setData(int newDays, int newHours,
    int newMinutes, int newSeconds){
    days = newDays;
    hours = newHours;
    minutes = newMinutes;
    seconds = newSeconds;
  }

  void setSeconds(int newSeconds) {
    seconds = newSeconds;
  }

  int inSeconds() {
    return ((days * 24 + hours) * 60 + minutes) * 60 + seconds;
  }
};

int main() {
  Time t1; // промежуток времени 320 минут
  t1.setData(0, 5, 20, 0);
  cout &lt;&lt; t1.inSeconds() &lt;&lt; endl; // 19200

  Time t2; // момент времени -1 секунда
  t2.setData(-1, 23, 59, 59);
  cout &lt;&lt; t2.inSeconds() &lt;&lt; endl; // -1

  // момент времени за 6 дней
  // 12 часов 36 минут 14 секунд
  Time t3;
  t3.setData(-7, 11, 23, 46);
  cout &lt;&lt; t3.inSeconds() &lt;&lt; endl; // -563774

  return 0;
}
</pre>

  <p>Еще можно определить методы setSeconds() который переприсваивает только секунды, setMinutes() который переприсваивает только минуты и т.д.</p>
  <p>Сразу после создания экземпляра класса, значения его не определены и только компилятор решает что там будет. Чтобы избежать периода неинициализации, можно инициализировать структуру при ее создании. Это можно сделать с помощью конструктора.</p>
  <p>В следующем уроке мы обсудим конструкторы и деструкторы в мельчайших деталях.</p>

  <details>
    <summary>Задача 1. Прямоугольник</summary>

    <p>В этой задаче вам необходимо реализовать структуру rectangle, у которой есть метод set, принимающий два аргумента - длины сторон прямоугольника (гарантируется, что это целые числа). Также у нее должен быть метод get, который возвращает квадрат длины диагонали этого прямоугольника. Вы вольны сами выбирать, какие еще методы или поля будут у вашей структуры.</p>

    <h4>Пример</h4>
    <code>3 5</code>
    <code>34</code>
<pre>
struct rectangle {
  int a, b;
  void set(int _a, int _b) {
    a = _a;
    b = _b;
  }
  int get() {
      return a * a + b * b;
  }
};
</pre>
  </details>

  <details>
    <summary>Задача 2. Загадочное рагу</summary>

    <p>В этот раз структуру писать будем мы! Вам останется лишь ей воспользоваться. Где-то в программе реализована структура strange_struct с пятью полями типа int, которые называются a, b, c, d, queue. Вам необходимо реализовать функцию f, которая принимает указатель на эту структуру и возвращает сумму ее полей.</p>

    <h4>Пример</h4>
    <code>1 2 3 4 5</code>
    <code>15</code>

    <p>Для доступа к членам структуры с помощью указателя на структуру следует использовать оператор "стрелка". Сумму пяти чисел типа int запишем в переменную типа long long. Чтобы не было переполнения при сложении, первым числом сложим с 0LL.</p>
<pre>
long long f(struct strange_struct *p) {
  long long sum = 0LL + p->a + p->b + p->c + p->d + p->queue;
  return sum;
}
</pre>
  </details>

  <details>
    <summary>Задача 3. Время</summary>

    <p>В этой задаче вам необходимо реализовать структуру my_time, имеющую 4 поля: дни (day), часы (hour), минуты (minute) и секунды (second). Также в ней должен быть метод set, принимающий одно целое число t (-10⁹ ≤ t ≤ 10⁹) - количество секунд, и переводящий его в привычные дни, часы, минуты и секунды, заполняя соответствующие поля структуры.</p>

    <h4>Пример 1</h4>
    <code>12345</code>
    <code>0 3 25 45</code>

    <h4>Пример 2</h4>
    <code>-86401</code>
    <code>-2 23 59 59</code>
<pre>
struct my_time {
  int day, hour, minute, second;
  void set(int _s) {
    int s = _s;
    if (s >= 0) {
      second = s % 60;
      s /= 60;
      minute = s % 60;
      s /= 60;
      hour = s % 24;
      s /= 24;
      day = s;
    } else {
      day = s % 86400 ? -(-s / 86400 + 1) : s / 86400;
      s = s - day * 86400;
      second = s % 60;
      s /= 60;
      minute = s % 60;
      s /= 60;
      hour = s % 24;
    }
  }
};
</pre>
  </details>

  <details>
    <summary>Задача 4. Односвязный список</summary>

    <p>В шаблоне кода вы можете видеть реализацию структуры node. Ее единственное поле - указатель на структуру node. При помощи такой конструкции можно делать списки - достаточно организовать указатели так, чтобы для каждого экземпляра node его указатель указывал на следущий экземпляр node в списке. При этом указатель в последнем node в списке нулевой.</p>

    <p>Мы организовали такой список за вас и дали вам указатель на его начало. Ваша задача - найти длину такого списка.</p>

    <p>Вам необходимо реализовать функцию get, которая принимает один аргумент - указатель на структуру node. Возвращать эта функция должна количество элементов в списке. Гарантируется, что список не зациклен, а также что указатель в последнем элементе списка нулевой.</p>

    <h4>Пример</h4>
    <code>5</code>
    <code>5</code>
<pre>
struct node {
    node *next;
};

int get(struct node *p) {
  int cnt = 1;
  while (p->next != nullptr) {
    cnt++;
    p = p->next;
  }
  return cnt;
}
</pre>
  </details>

  <details>
    <summary>Задача 5. Между первой и второй...</summary>

    <p>В этой задаче нам снова понадобятся списки из предыдущей задачи, однако в этот раз мы их немного усложнили. Как вы можете видеть, в списках теперь два поля - привычный нам указатель на следующий элемент и целое число val. В нем мы храним значение очередной ячейки списка.</p>

    <p>Мы составили для вас два списка, значения в которых отсортированы по неубыванию. Вам необходимо составить третий список, который будет содержать в себе те же самые значения, и при этом так же будет отсортирован по неубыванию.</p>

    <p>Вам необходимо реализовать функцию merge, которая на вход принимает два указателя на node - начало соответствующих списков. Функция должна вернуть указатель на начало объединенного списка. Гарантируется, что данные вам списки не зациклены, а также что в последних ячейках списков указатели на следующий элемент нулевые. Ваш список должен содержать в себе все те же значения, что и данные два, и идти они должны по неубыванию. Пожалуйста, не надо зацикливать итоговый список) Кстати, вы можете делать с данными списками что угодно, мы не будем проверять, что вы их не меняли.</p>

    <h4>Пример</h4>
<pre>
4
1 7 8 9
6
1 2 3 3 9 10
</pre>
    <code>1 1 2 3 3 7 8 9 9 10 </code>

<pre>
struct node {
    node *next;
    int val;
};

//Пишите вашу функцию merge здесь
struct node* merge(struct node* p1, struct node* p2) {
  struct node dummy;
  struct node* cur = &amp;dummy;

  while (p1 != nullptr && p2 != nullptr) {
    if (p1->val > p2->val) {
      cur->next = p2;
      cur = cur->next;
      p2 = p2->next;
    } else {
      cur->next = p1;
      cur = cur->next;
      p1 = p1->next;
    }
  }

  while (p1 != nullptr) {
    cur->next = p1;
    cur = cur->next;
    p1 = p1->next;
  }

  while (p2 != nullptr) {
    cur->next = p2;
    cur = cur->next;
    p2 = p2->next;
  }

  return dummy.next;
}
</pre>
  </details>
</article>


<!-- 4.4 Структура: конструкторы и деструкторы -->
<article class="article">
  <div class="anchor" id="p4.4"></div>
  <h3>4.4 Структура: конструкторы и деструкторы</h3>

  <p>На прошлом уроке мы поговорили о структурах, их полях и методах, работе с ними. В этом гуроке поговорим о конструкторах и деструкторах - важнейших составляющих структур.</p>
  <p><strong>Конструктор</strong> это метод, который вызывается при создании структуры. Конструктор отличается от других методов класса только двумя вещами:</p>
  <ol>
    <li>Называется этот метод также как и сам класс</li>
    <li>В конструкторе не пишется возвращаемый тип</li>
  </ol>

  <h4>Конструктор: два способа инициализации</h4>

  <p>Рассмотрим два способа реализации конструктора, который инициализирует переменные класса.</p>

  <p>В первом способе мы просто присваиваем каждому полю соответствующее значение.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

struct Time {
  int days, hours, minutes, seconds;

  Time(int d, int h, int m, int s) {
    days = d;
    hours = h;
    minutes = m;
    seconds = s;
  }
};

int main() {
  Time t(-3, 10, 1, 15);
  cout &lt;&lt; t.days &lt;&lt; t.hours
       &lt;&lt; t.minutes &lt;&lt; t.seconds &lt;&lt; endl;

  return 0;
}
</pre>

  <p>Во втором способе все выглядит более нетривиально. Идея очень проста. Для каждого из полей мы вызываем соответствующие конструкторы. Для int можно вызвать конструктор! Который сохранит в него заданное значение. Важный момент! При создании переменной конструктор будет вызван так или иначе.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

struct Time {
  int days, hours, minutes, seconds;

  Time(int d, int h, int m, int s)
      :days(d), hours(h), minutes(m), seconds(s) {}
};

int main() {
  Time t(-3, 10, 1, 15);
  cout &lt;&lt; t.days &lt;&lt; t.hours
       &lt;&lt; t.minutes &lt;&lt; t.seconds &lt;&lt; endl;

  return 0;
}
</pre>

  <p>В первом варианте, для каждого поля конструктор будет вызван. Если программист в явном виде не указал его, компилятор вызовет конструктор по умолчанию. Только после вызова того или иного конструктора для каждого поля, запускается основное тело метода, заключенное в фигурных скобках метода. Таким образом, первый конструктор делает двойную работу - сначала инициализирует переменные по умолчанию, а потом делает присваивание.</p>
  <p>Конкретно в данном случае разницу в производительности вы не увидите. Но настоятельно рекомендую привыкать использовать именно второй способ.</p>

  <h4>Конструктор: использование this</h4>

  <p></p>Может показаться что именно параметры конструктора не должны совпадать с названиями полей. Однако это не совсем так. Покажем один из способов реализовать конструктор с пересекающимися именами.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

struct Time {
  int days, hours, minutes, seconds;

  Time(int days, int hours, int minute, int seconds) {
    this->days = days;
    this->hours = hours;
    this->minutes = minutes;
    this->seconds = seconds;
  }
};

int main() {
  Time t(-3, 10, 1, 15);
  cout &lt;&lt; t.days &lt;&lt; t.hours
       &lt;&lt; t.minutes &lt;&lt; t.seconds &lt;&lt; endl;

  return 0;
}
</pre>

  <p>В первом способе мы видим слово <strong>this</strong> - это ключевое слово языка C++. Внутри экземпляра класса this является указателем на этот класс. this можно использовать не только в конструкторе, но и других методах. В случае пересекающихся имен, компилятор отличает их очень просто. Приоритет имеет переменная, объявленная на более глубоком уровне.</p>
  <p>Здесь переменная days объявлена сначала в самой структуре, а потом внутри структуры как параметр конструктора. Таким образом, параметр конструктора оказался глубже. Поэтому в конструкторе под переменной days подразумевается именно параметр конструктора.</p>
  <p>Чтобы обратиться к более высокой версии days, мы используем this. То есть обращаемся к нашему классу по указателю this.</p>

  <h4>Вызов конструкторов полей</h4>

  <p>Непосредственно в случае конструктора, есть более изящный способ работы с одинаковыми именами. Ниже в коде мы напрямую вызываем конструкторы полей. Здесь все происходит без лишних проблем. Компилятор понимает, что в блоке между двоеточием и фигурной скобкой мы можем вызывать лишь конструкторы полей. Поэтому то что вне круглых скобок это точно поля класса.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

struct Time {
  int days, hours, minutes, seconds;

  Time(int d, int h, int m, int s)
      :days(days), hours(hours), minutes(minutes), seconds(secondes) {}
};

int main() {
  Time t(-3, 10, 1, 15);
  cout &lt;&lt; t.days &lt;&lt; t.hours
       &lt;&lt; t.minutes &lt;&lt; t.seconds &lt;&lt; endl;

  return 0;
}
</pre>

  <p>С другой стороны, при определении какая из доступных переменных станет параметром, компилятор понимает ту же логику что и ранее. Будет выбрана переменная, определенная на более глубоком уровне. В нашем случае это параметры конструктора. Эти соображения и приводят нас ко второй реализации.</p>

  <h4>Два конструктора</h4>

  <p>Конструкторов может быть несколько. Впрочем, как и методов с одинаковым именем. Вполне нормально если они отличаются количеством, типами параметров. Здесь работает та же логика что и с функциями с одинаковым именем. В этом случае компилятор сумеет выбрать из нескольких вариантов подходящий. В нашем случае, просто по количеству параметров.</p>
  <p>В нашем случае, второй конструктор принимает на вход количество секунд и переводит их в формат дней, часов и т.д. Здесь мы, пользуясь тем что переменные уже проинициализированы как-то, просто вызываем уже написанный в домашнем задании метод.</p>

<pre>
#include &lt;iostream&gt;

using namespace std;

struct Time {
  int days, hours, minutes, seconds;

  Time(int d, int h, int m, int s)
      :days(days), hours(hours), minutes(minutes), seconds(secondes) {}

  Time(int seconds) {
    setDataFromSeconds(seconds);
  }

  void setDataFromSeconds(int seconds) {
    // метод из домашнего задания
  }
};

int main() {
  Time t(-3, 10, 1, 15);
  cout &lt;&lt; t.days &lt;&lt; t.hours
       &lt;&lt; t.minutes &lt;&lt; t.seconds &lt;&lt; endl;

  Time t2(-336);
  cout &lt;&lt; t2.days &lt;&lt; t2.hours
       &lt;&lt; t2.minutes &lt;&lt; t2.seconds &lt;&lt; endl;

  return 0;
}
</pre>

  <p>Теперь у нас есть два способа задать класс. Задав все параметры и задав время в секундах. Другими словами, мы теперь вполне можем написать Time t1(2, 3, 5, 29);, а также Time t2(-579);.</p>

  <h4>Отсутствие конструктора по умолчанию</h4>

  <p>Однако, если мы попытаемся как и раньше записать Time t;, то компилятор откажется это компилировать. Действительно, вы не написали в явном виде какой конструктор вызвать. Какой-то конструктор должен быть вызван. Так как параметров не указано, в этом случае, компилятор пытается вызвать конструктор без параметров, но он не определен.</p>

  <h4>Явная реализация конструктора по умолчанию</h4>

  <p>Эту проблему можно решить, реализовав конструктор по умолчанию. И в явном виде проинициализировать в нем все параметры нулями.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

struct Time {
  int days, hours, minutes, seconds;

  Time(): days(0), hours(0), minutes(0), seconds(0) {}

  Time(int d, int h, int m, int s)
      :days(days), hours(hours), minutes(minutes), seconds(secondes) {}

  Time(int seconds) {
    setDataFromSeconds(seconds);
  }

  void setDataFromSeconds(int seconds) {
    // метод из домашнего задания
  }
};

int main() {
  Time t();
  cout &lt;&lt; t.days &lt;&lt; t.hours
       &lt;&lt; t.minutes &lt;&lt; t.seconds &lt;&lt; endl;

  return 0;
}
</pre>

  <p>Теперь запись Time t; вполне корректна. Вот вопрос. При реализации класса House мы не реализовали не то что конструкторы без параметров, но и вообще никакого конструктора. И запись вида House h; вполне работала. Как же так?</p>

  <h4>Отсутствие конструкторов. Конструктор по умолчанию</h4>

  <p>Дело в том, что если вы не реализовали совсем никакого конструктора, то тогда компилятор сам реализует конструктор по умолчанию. Это конструктор без параметров, который инициализирует все поля, вызывая для каждого из них конструкторы без параметров, в фигурных скобочках у которых не написано ничего. Если в вашем конструкторе между двоеточием и фигурной скобкой не оказалось какого-то поля, то для него компилятор вызовет конструктор без параметров.</p>

  <h4>Отсутствие конструкторов + C++11 = конструктор через список инициализации</h4>

  <p>Если компилятор поддерживает стандарт C++11, то тогда отсутствие вручную реализованных конструкторов дает вам еще одну возможность удобно инициализировать структуру с помощью списка инициализации.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

struct House {
  double height;
  int floors;
  int flats;
};

int main() {
  House h{5.34, 10, 29};
  cout &lt;&lt; h.height &lt;&lt; h.floors
       &lt;&lt; h.flats &lt;&lt; endl;

  return 0;
}
</pre>

  <p>Его применение заключается в том, что мы пишем House h{};. В фигурных скобках перечисляем значения, которые должны быть присвоены полям, в порядке перечисления полей в объявлении класса. Поэтому если у вас нет никаких конструкторов, например конструктор от количества секунд в классе Time, то можно не писать никаких конструкторов. Вместо этого можно использовать конструктор по умолчанию (то есть конструктор без параметров) и конструктор через список инициализации (конструктор с фигурными скобками).</p>

  <h4>Деструкторы</h4>

  <p>Деструкторы это методы, которые вызываются при уничтожении экземпляра структуры.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

struct House {
  double height;
  int floors;
  int flats;

  ~House() {
    cout &lt;&lt; "house is destoyed" &lt;&lt; endl;
  }
};

int main() {
  House h{5.34, 10, 29};
  cout &lt;&lt; h.height &lt;&lt; h.floors
       &lt;&lt; h.flats &lt;&lt; endl;

  return 0;
}
</pre>
  <p>Деструктор реализуется абсолютно также как и конструктор, за исключением трех моментов.</p>
  <ol>
    <li>Деструктор называется так же как и класс (так же как и конструктор), но перед названием пишется знак ~ тильда.</li>
    <li>В деструктор нельзя передавать параметры.</li>
    <li>Нет аналога списка между двоеточиями и фигурными скобками. Это прямое следствие того, что деструктор может быть только один, без параметров.</li>
  </ol>

  <p>Технически сначала выполняется то, что написано в фигурных скобочках. А потом вызываются деструкторы полей класса. Если деструктор не реализован программистом, то компилятор формирует деструктор по умолчанию, который не делает ничего, как и конструктор по умолчанию.</p>
  <p>В следующем уроке мы затронем возможность перегрузки операторов в языке C++.</p>

  <details>
    <summary>Задача 1. Прямоугольник</summary>

    <p>Вы обнаружили две точки на плоскости. "Подозрительно!", - подумали вы. И не случайно, ведь эти две точки были противоположными углами прямоугольника, стороны которого параллельны осям координат. Вы решили его поймать. Процесс поимки прямоугольника включает в себя написание структуры rectangle, которая по данным координатам умеет находить длины сторон прямоугольника.</p>

    <p>Вам необходимо реализовать структуру rectangle, у которой есть два поля: w и h (длины сторон вдоль X и Y координат соответственно). Также эта структура должна иметь конструктор, который по четырем числам x1, y1, x2, y2 типа int заполнит эти два поля.</p>

    <h4>Пример</h4>
    <code>1 1 4 6</code>
    <code>3 5</code>
  </details>

  <details>
    <summary>Задача 2. Последнее заклинание</summary>

    <p>Ходят слухи, что перед смертью волшебника все заклинания, которые он знал, произносятся сами собой. Однако, единственный известный вам волшебник знает всего одно заклинание и ничего не может с этим поделать. Вы решили ему помочь. Для этого вам необходимо изучить такой таинственный закон магии подробнее. Естественно, убивать волшебника не хочется, поэтому вам нужно реализовать структуру, которая имитирует подобное поведение.</p>

    <p>Вам необходимо реализовать структуру wizard, которая имеет два поля a и b, конструктор, который принимает два аргумента и заполняет оба поля, а также деструктор. Он должен вывести на экран сумму двух полей структуры перед самоуничтожением.</p>

    <h4>Примечание</h4>

    <p>Обратите внимание - в выходные данные выводится какая-то дополнительная информация. Вам самим это делать не нужно, за вас все сделает магия)</p>

    <h4>Пример</h4>
    <code>3 4</code>
    <code>Last spell: 7</code>
  </details>

  <details>
    <summary>Задача 3. Vector</summary>

    <p>Вам необходимо реализовать структуру данных vector, которая хранит в себе целые числа и у которой есть следующие методы:</p>
    <ol>
      <li>Конструктор от одной переменной n. После его выполнения в структуре должно быть n элементов, все равны 0</li>
      <li>Конструктор от двух переменных n, val. После его выполнения в структуре должно быть n элементов, все равны val.</li>
      <li>push_back - метод от одной переменной val. Добавляет элемент val в конец вашей структуры.</li>
      <li>pop_back - метод без аргументов, удаляющий последний элемент в структуре.</li>
      <li>get - метод от одной переменной i. Возвращает элемент, находящийся на i-й позиции в вашей структуре в нумерации с 0.</li>
      <li>size - метод без аргументов, возвращает количество элементов в структуре.</li>
    </ol>

    <p>Гарантируется, что все запросы корректны - то есть вам никогда не нужно будет удалять элемент из пустой структуры, обращаться к i-у элементу, если в структуре меньше, чем i элементов. Также гарантируется, что максимальное количество элементов, которое когда либо может оказаться в вашей структуре не превосходит 10⁵.</p>
  </details>
</article>


<!-- 4.5 Перегрузка операторов -->
<article class="article">
  <div class="anchor" id="p4.5"></div>
  <h3>4.5 Перегрузка операторов</h3>

  <h4>Перегрузка операторов: мотивация</h4>

  <p>Вернемся к классу Time. Если воспринимать Time как промежуток времени, то оказывается логичной идеей их сложить.</p>
  <p>Напрашивается идея реализовать функцию sum(), которая принимает на вход два Time и возвращает один. Ее реализация в программе ниже.</p>

<pre>
#include &lt;iostream&gt;

using namespace std;

struct Time {
  int days, hours, minutes, seconds;
}

Time sum(Time t1, Time t2) {
  Time t{t1.days + t2.days, t1.hours + t2.hours,
  t1.minutes + t2.minutes, t1.seconds + t2.seconds};
  if (t.seconds >= 60) {
    t.seconds -= 60;
    ++t.minutes;
  }
  if (t.minutes >= 60) {
    t.minutes -= 60;
    ++t.hours;
  }
  if (t.hours >= 24) {
    t.hours -= 24;
    ++t.days;
  }

  return t;
}

int main() {
  Time ta{5, 7, 12, 15}, tb{0, 0, 0, 45};
  Time tc{-1, 0, 0, 0}, td{0, 1, 2, 0};
  Time t = sum(ta, tb);
  t = sum(sum(sum(ta, tb), tc), td);
  cout &lt;&lt; t.days &lt;&lt; ' '
       &lt;&lt; t.hours &lt;&lt; ' '
       &lt;&lt; t.minutes &lt;&lt; ' '
       &lt;&lt; t.seconds &lt;&lt; endl;

  return 0;
}
</pre>
  <p>Все очень похоже на сложение столбиком. Почленно складываем секунды, минуты, часы и дни. Причем если образовалось более 60 секунд, то переносим 60 секунд в минуту и т.д. Теперь если у нас есть промежутки ta и tb, то мы их сможем сложить с помощью строчки</p>
  <code>Time t = sum(ta, tb);</code>
  <p>Однако, если мы захотим сложить три промежутка времени, то получится уже более громоздкая строчка, не говоря уже о четырех, пяти и т.д. Если бы это были int, мы бы просто записали</p>
  <code>int t = ta + tb + tc + td;</code>
  <p>Однако это не так сложно сделать. Единственное что нам мешает это то, что компилятор не знает как сложить два Time. Ведь это класс, который изобрел программист. Нам нужно объяснить компилятору как сложить Time.</p>

  <h4>Перегрузка оператора +</h4>

  <p>Для этого мы заменим в функции sum само слово sum на operator +. Теперь следующие строчки вполне корректны</p>
  <code>Time t = ta + tb;</code>
  <code>Time t = ta + tb + tc + td;</code>
<pre>
#include &lt;iostream&gt;

using namespace std;

struct Time {
  int days, hours, minutes, seconds;
}

Time operator + (Time t1, Time t2) {
  Time t{t1.days + t2.days, t1.hours + t2.hours,
  t1.minutes + t2.minutes, t1.seconds + t2.seconds};
  if (t.seconds >= 60) {
    t.seconds -= 60;
    ++t.minutes;
  }
  if (t.minutes >= 60) {
    t.minutes -= 60;
    ++t.hours;
  }
  if (t.hours >= 24) {
    t.hours -= 24;
    ++t.days;
  }

  return t;
}

int main() {
  Time ta{5, 7, 12, 15}, tb{0, 0, 0, 45};
  Time tc{-1, 0, 0, 0}, td{0, 1, 2, 0};
  Time t = ta + tb;  // не вызовет ошибок
  t = ta + tb + tc + td;  // не вызовет ошибок
  cout &lt;&lt; t.days &lt;&lt; ' '
       &lt;&lt; t.hours &lt;&lt; ' '
       &lt;&lt; t.minutes &lt;&lt; ' '
       &lt;&lt; t.seconds &lt;&lt; endl;

  return 0;
}
</pre>

  <h4>Перегрузка оператора +: разные типы</h4>

  <p>Можем ли мы теперь сложить t + число? подразумевая что число это количество секунд? Конечно можем. Для этого мы просто реализуем еще один operator +, параметрами которого будут Time и int. Внутри функции превратим int в Time, вызвав соответствующий конструктор. И вызовем operator + от двух Time.</p>
<pre>
Time operator + (Time t1, Time t2) {
  Time t{t1.days + t2.days, t1.hours + t2.hours,
  t1.minutes + t2.minutes, t1.seconds + t2.seconds};
  if (t.seconds >= 60) {
    t.seconds -= 60;
    ++t.minutes;
  }
  if (t.minutes >= 60) {
    t.minutes -= 60;
    ++t.hours;
  }
  if (t.hours >= 24) {
    t.hours -= 24;
    ++t.days;
  }

  return t;
}

Time operator + (Time t, int seconds) {
  return t + Time(seconds);
}

Time operator + (int seconds, Time t) {
  return Time(seconds) + t;
}
</pre>

  <h4>Другие операторы</h4>

  <p>Аналогичным образом можно организовать операторы -, *, /. А также все сравнения >, >= и т.п.</p>
  <p>Однако в случае умножения возникает вопрос. А что такое промежуток умножить на промежуток? В отличие от сложения, этот вопрос интуитивно не понятен. Однако понятно, что такое умножить временной промежуток на число.</p>
<pre>
Time operator * (Time t, int times) {
  return Time(t.inSeconds() * times);
}

Time operator * (int times, Time t) {
  return t * times;
}

int main() {
  Time t{0, 3, 6, 0};
  Time t2 = t * 3;
  t2 = 3 * t;
}
</pre>

  <h4>Возможность и осмысленность</h4>

  <p>Возможно, конечно, сделать так чтобы при делении int на Time получался House и выводился на экран "GUS". Но нужно при этом думать замем это делать.</p>
<pre>
House operator / (int x, Time t) {
  cout &lt;&lt; "GUS";
  return House{x, t, t};
}
</pre>

  <p>Если перегрузка оператора не имеет смысла, то может ее и не реализовывать? Сама перегрузка оператора это не более чем удобство, фишка без которой можно прекрасно обойтись.</p>
  <p>Перегружайте операторы только тогда, когда это сделает код более интуитивно понятным, а не наоборот - затрудняет его чтение.</p>

  <h4>Структуры и классы: отличия минимальны</h4>

  <p>В языке C++ структура и класс это практически одно и тоже.</p>
<pre>
struct House {
  double height;
  int floors;
  int flats;
};

// эквивалентно

class House {
public:
  double height;
  int floors;
  int flats;
};
</pre>
  <p>Единственное отличие между ними это доступность полей и методов по умолчанию. По умолчанию в структуре struct доступно все без ограничений. Если заменить слово struct на слово class то поля и переменные будут недоступные. Чтобы это исправить, нужно добавить в начале тела класса слово public:</p>
  <p>В промышленном программировании программисты внимательно следят какие поля и методы должны попадать в секцию public, а какие в private, то есть должны быть доступны только изнутри. Это необходимо для работы больших программ и систем, например, поисковика google или yandex.</p>
  <p>Однако на олимпиаде, вам нужно лишь написать программу максимум в пару сотен строк, которая отработает на тестах, получит окей и больше окажется никому не нужна.</p>
  <p>Для олимпиадных целей, заморачиваться о приватности и использовать слово class видится абсолютно неосмысленным.</p>
  <p>Итак, мы поняли как реализовывать структуры и разобрали примеры.</p>
</article>

