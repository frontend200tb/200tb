<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p>ЯрГУ. Кружок. Контесты</p>
  <p>Автор кружка Игорь Маслеников</p>
</article>


<article class="article">
  <h1>Контест Round 998 (Div.3) 19.01.2025</h1>
  <p><a href="https://codeforces.com/contest/2060" target="_blank">Codeforces Round 998 (Div.3)</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
        <a href="#task1">Задача A. Фибоначчиевость</a>
    <br><a href="#task2">Задача B. Карточная игра Фермера Джона</a>
    <br><a href="#task3">Задача C. Игра математиков</a>
    <br><a href="#task4">Задача D. Сортировка вычитанием минимума</a>
    <br><a href="#task5">Задача E. Составление графа</a>
    <br><a href="#task6">Задача F. Умножительные массивы</a>
    <br><a href="#task7">Задача G. Ошибочная сортировка</a>
  </p>
</article>


<!-- Задача A. Фибоначчиевость -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Фибоначчиевость</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Дан массив из 5 целых чисел. Изначально вам известны только a₁, a₂, a₄, a₅. Вы можете присвоить элементу a3 любое целое значение (в том числе отрицательное или нулевое). Фибоначчиевость массива — это количество целых чисел i (1 ≤ i  ≤3) таких, что a<sub>i+2</sub> = aᵢ + a<sub>i+1</sub>. Найдите максимальную Фибоначчиевость среди всех целых значений a₃.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 500) — количество наборов входных данных.</p>

  <p>Единственная строка каждого набора входных данных содержит четыре целых числа a₁, a₂, a₄, a₅ (1 ≤ aᵢ ≤ 100).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите максимальную Фибоначчиевость на новой строке.</p>

  <h4>Пример</h4>
<pre>
6
1 1 3 5
1 3 2 1
8 10 28 100
100 1 100 1
1 100 1 100
100 100 100 100
</pre>
<pre>
3
2
2
1
1
2
</pre>
  <p>В первом наборе входных данных мы можем установить a3 равным 2, чтобы достичь максимальной Фибоначчиевости равной 3.</p>

  <p>В третьем наборе входных данных можно показать, что 2 — это максимальная Фибоначчиевость, которую можно достичь. Это можно сделать, установив a3 равным 18.</p>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;deque&gt;
#include &lt;stack&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;

using namespace std;

int main() {
	// Заметим, что нам выгодно продлевать последовательность Фибоначчи либо первых двух элементов, либо последних двух
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int n;
	cin >> n;

	while (n--) {
		int a1, a2, a3, a4, a5;
		cin >> a1 >> a2 >> a4 >> a5;
		a3 = a5 - a4; // продлим последовательность из последних двух и посчитаем фибоначчиевость
		int count = 0;
		if (a1 + a2 == a3) {
			count++;
		}
		if (a2 + a3 == a4) {
			count++;
		}
		if (a3 + a4 == a5) {
			count++;
		}
		int count1 = 0;
		a3 = a1 + a2; // продлим последовательность из первых двух и посчитаем фибоначчиевость
		if (a1 + a2 == a3) {
			count1++;
		}
		if (a2 + a3 == a4) {
			count1++;
		}
		if (a3 + a4 == a5) {
			count1++;
		}

    // выведем максимум из двух вариантов
		cout &lt;&lt; max(count, count1) &lt;&lt; '\n';
	}
}
</pre>
  </details>
</article>


<!-- Задача B. Карточная игра Фермера Джона -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Карточная игра Фермера Джона</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>n коров Фермера Джона играют в карточную игру! У Фермера Джона есть колода из n⋅m карт, пронумерованных от 0 до n⋅m-1. Он раздает m карт каждой из своих n коров.</p>

  <p>Фермер Джон хочет, чтобы игра была честной, поэтому каждая корова может сыграть только 1 карту за раунд. Он решает определить порядок ходов, который задается перестановкой∗ p длины n, так что корова с номером pᵢ будет i-й коровой, которая положит карту наверх центральной стопки в раунде.</p>

  <p>Другими словами, в каждом раунде происходят следующие события:</p>
  <ul>
    <li>Корова с номером p₁ кладет любую карту из своей колоды наверх центральной стопки.</li>
    <li>Корова с номером p₂ кладет любую карту из своей колоды наверх центральной стопки.</li>
    <li>...</li>
    <li>Корова с номером pₙ кладет любую карту из своей колоды наверх центральной стопки.</li>
  </ul>

  <p>Есть одна загвоздка. Изначально в центральной стопке находится карта с номером -1. Чтобы положить карту, номер карты должен быть больше номера карты на верхней части центральной стопки. Затем вновь положенная карта становится верхней картой центральной стопки. Если корова не может положить ни одной карты из своей колоды, игра считается проигранной.</p>

  <p>Фермер Джон задается вопросом: существует ли p, такое что все его коровы смогут опустошить свою колоду после игры во все m раундов? Если да, выведите любое допустимое p. В противном случае выведите -1.</p>

  <p>* Перестановка длины n содержит каждое целое число от 1 до n ровно один раз</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 400) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора содержит два целых числа n и m (1 ≤ n⋅m ≤ 2000) — количество коров и количество карт, которые получает каждая корова.</p>

  <p>Следующие n строк содержат по m целых чисел каждая — карты, полученные каждой коровой. Гарантируется, что все указанные числа (по всем n строкам) различны и находятся в диапазоне от 0 до n⋅m-1, включительно.</p>

  <p>Гарантируется, что сумма n⋅m по всем наборам входных данных не превышает 2000.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите следующее на новой строке:</p>
  <ul>
    <li>Если p существует, выведите n целых числа, разделенных пробелами: p₁, p₂, ..., pₙ.</li>
    <li>В противном случае выведите -1.</li>
  </ul>

  <h4>Пример</h4>
<pre>
4
2 3
0 4 2
1 5 3
1 1
0
2 2
1 2
0 3
4 1
1
2
0
3
</pre>
<pre>
1 2
1
-1
3 1 2 4
</pre>
  <p>В первом примере один из порядков ходов, который позволяет сыграть все карты, заключается в том, чтобы первой корове ходить перед второй коровой. Карты, которые будут сыграны: 0→1→2→3→4→5.</p>

  <p>Во втором примере только одна корова, поэтому если корова сыграет все свои карты в порядке возрастания, колода будет опустошена.</p>

  <p>В третьем примере можно показать, что не существует допустимого порядка ходов, который позволяет сыграть все карты.</p>

  <details>
    <summary>Решение</summary>
    <p>Заметим следующее: чтобы корова смогла сходить в первый раз у нее должна быть карта от 0 до n-1. Кроме этого так как очередь хода всегда одна все карты у коровы должны быть равны первой (самой маленькой) + n*(номер хода -1). Значит мы просто должны посчитать может ли корова сходить в каждом раунде. Если может то ее очередь будет равна первой карте + 1 (так как карты идут с 0)</p>
<pre>
#include &lt;gorithm&gt;
#include &lt;cmath&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;deque&gt;
#include &lt;stack&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;

using namespace std;

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int t;
	cin >> t;

	while (t--)
	{
		int n, m;
		cin >> n >> m;
		vector &lt;set &lt;int&gt; &gt; A(n); // set использовать хорошо для мгновенной сортировки
		vector &lt;int&gt; Ans(n);
		for (int i=0; i&lt;n; i++)
			for (int j = 0; j &lt; m; j++)
			{
				int a;
				cin >> a;
				A[i].insert(a);
			}
		bool flag = true;
		for (int i = 0; i &lt; n; i++)
		{
			int st = *A[i].begin(); // первой картой в сете должна быть карта от 0 до n - 1
			if (st >= n) // Если это не так то выведем -1
			{
				cout &lt;&lt; -1 &lt;&lt; '\n';
				flag = false;
				break;
			}
			int cur=st+n; // проверим на наличие все карты которые должны быть у коровы
			for (int j = 1; j &lt; m; j++) // если есть лишнее карты, то мы найдем их отсутсвие у нужной коровы дальше
			{
				if (A[i].find(cur) == A[i].end())
				{
					cout &lt;&lt; -1 &lt;&lt; '\n';
					flag = false;
					break;
				}
				cur += n;
			}
			if (flag) // если все карты оказались на месте, то корова занимает место в массиве ответа
				Ans[st] = i + 1;
			else
				break;
		}
		if (flag)
		{
			for (int i = 0; i &lt; n; i++)// выведем ответ
				cout &lt;&lt; Ans[i] &lt;&lt; ' ';
			cout &lt;&lt; '\n';
		}
	}
}
</pre>
  </details>
</article>


<!-- Задача C. Игра математиков -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Игра математиков</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Алиса и Боб играют в игру. На доске написано n (n четное) целых чисел x₁, x₂, ..., xₙ. Также дано целое число k и целое число score, которое изначально равно 0. Игра длится n/2 ходов, в которых последовательно происходят следующие события:</p>
  <ul>
    <li>Алиса выбирает целое число с доски и стирает его. Назовем выбранное Алисой число a.</li>
    <li>Боб выбирает целое число с доски и стирает его. Назовем выбранное Бобом число b.</li>
    <li>Если a+b=k, добавляем 1 к score.</li>
  </ul>

  <p>Алиса играет, чтобы минимизировать score, в то время как Боб играет, чтобы максимизировать score. Предполагая, что оба игрока используют оптимальные стратегии, каков будет score после окончания игры?</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит два целых числа n и k (2 ≤ n ≤ 2⋅10⁵, 1 ≤ k ≤ 2⋅n, n четное).</p>

  <p>Вторая строка каждого набора входных данных содержит n целых чисел x₁, x₂, ..., xₙ (1 ≤ xᵢ ≤ n) — числа на доске.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите score, если оба игрока играют оптимально.</p>

  <h4>Пример</h4>
<pre>
4
4 4
1 2 3 2
8 15
1 2 3 4 5 6 7 8
6 1
1 1 1 1 1 1
16 9
3 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3
</pre>
<pre>
2
1
0
4
</pre>
  <p>В первом наборе входных данных один из возможных сценариев игры выглядит следующим образом:</p>
  <ul>
    <li>Алиса выбирает 1, а Боб выбирает 3. Счет увеличивается, так как 1+3=4. Теперь на доске остаются два целых числа 2 и 2.</li>
    <li>Алиса и Боб оба выбирают 2. Счет увеличивается, так как 2+2=4.</li>
    <li>Игра заканчивается, так как на доске больше нет целых чисел.</li>
  </ul>

  <p>В третьем наборе входных данных невозможно, чтобы сумма выбранных Алиской и Бобом целых чисел была равна 1, поэтому мы отвечаем 0.</p>

  <p>Обратите внимание, что это всего лишь пример того, как может проходить игра для демонстрационных целей. Это может не быть самыми оптимальными стратегиями Алисы или Боба.</p>

  <details>
    <summary>Решение</summary>
    <p>разобьём элементы массива на пары. если для элемента a в массиве есть элемент k - a, то поставим их в пару. элементы, для которых пары не нашлось, сгруппируем по парам произвольным образом. зафиксируем это разбиение на пары. когда Алиса выбирает какой-то элемент, Боб всегда может взять элемент, стоящий в паре с выбранным Алисой. таким образом score зависит только от действий Боба и равен количеству пар с суммой k </p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;string&gt;

using namespace std;

#define ll long long
void solve() {
    ll n, k;
    cin >> n >> k;
    vector&lt;ll&gt; A(n);
    for (ll i = 0; i &lt; n; ++i)
    {
        cin >> A[i];
    }
    ll ans = 0; // найдём максимальное количество пар с суммой k
    multiset&lt;ll&gt; st; // будем в мультисете хранить элементы, которые пока без пары
    for (ll i = 0; i &lt; n; ++i)
    {
        if (st.count(k - A[i])) // проверяем количество свободных элементов, дающих k в сумме с рассматриваемым
        {                       // если оно больше нуля, мы нашли новую пару с суммой k
            ++ans;              // увеличиваем ответ
            st.erase(st.find(k - A[i])); // удаляем из мультисета один из таких свободных элементов, так как он уже будет в паре
        }
        else
        {                       // если свободного подходящего элемента нет
            st.insert(A[i]);    // то рассматриваемый элемент пока без пары, добавляем его в мультисет
        }
    }
    cout &lt;&lt; ans &lt;&lt; '\n'; // нашли максимальный ответ, выводим его
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int t;
    cin >> t;

    while (t--) {
        solve();
    }
}
</pre>
  </details>
</article>


<!-- Задача D. Сортировка вычитанием минимума -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Сортировка вычитанием минимума</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Дана последовательность a, состоящая из n положительных целых чисел.</p>

  <p>Вы можете выполнять следующую операцию любое количество раз.</p>
  <ul>
    <li>Выберите индекс i (1 ≤ i &lt; n) и вычтите min(a<sub>i</sub>, a<sub>i+1</sub>) из обоих a<sub>i</sub> и a<sub>i+1</sub>.</li>
  </ul>

  <p>Определите, возможно ли сделать последовательность неубывающей, используя операцию любое количество раз.</p>

  <h4>Входные данные</h4>
  <p>Каждый тест содержит несколько наборов входных данных. Первая строка содержит количество наборов входных данных t (1 ≤ t ≤ 10⁴). Описание наборов входных данных следует далее.</p>

  <p>Первая строка каждого набора входных данных содержит одно целое число n (2 ≤ n ≤ 2⋅10⁵).</p>

  <p>Вторая строка каждого набора входных данных содержит a₁, a₂, ..., aₙ (1 ≤ aᵢ ≤ 10⁹).</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Если возможно сделать последовательность неубывающей, выведите «YES» в новой строке. В противном случае выведите «NO» в новой строке.</p>

  <p>Вы можете вывести ответ в любом регистре. Например, строки «yEs», «yes», и «Yes» также будут распознаны как положительные ответы.</p>

  <h4>Пример</h4>
<pre>
5
5
1 2 3 4 5
4
4 3 2 1
4
4 5 2 3
8
4 5 4 5 4 5 4 5
9
9 9 8 2 4 4 3 5 3
</pre>
<pre>
YES
NO
YES
YES
NO
</pre>
  <p>В первом наборе входных данных массив уже отсортирован.</p>

  <p>Во втором наборе входных данных можно показать, что это невозможно.</p>

  <p>В третьем наборе входных данных, после выполнения операции на i=1, массив становится [0,1,2,3], который теперь находится в неубывающем порядке.</p>

  <details>
    <summary>Решение</summary>
    <p>когда производится вычитание минимума, один из элементов становится равным нулю, другой элемент будет неотрицательным. найдём минимальный индекс i, для которого a[i] > a[i + 1]. тогда для элементов a[i - 1] и a[i] должна быть произведена операция. в её результате a[i - 1] = 0, значит все элементы на префиксе a[0...i - 1] должны быть равны 0. тогда будем идти по массиву и выполнять операцию для каждой пары элементов</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;string&gt;

using namespace std;

#define ll long long
void solve() {
    ll n;
    cin >> n;
    vector&lt;ll&gt; A(n);
    for (ll i = 0; i &lt; n; ++i)
    {
        cin >> A[i];
    }

    for (ll i = 1; i &lt; n; ++i)
    {
        if (A[i] >= A[i - 1]) // если i-ый элемент больше предыдущего
        {                     // то мы можем выполнить операцию, после неё рассмотренный префикс так и останется неубывающим
            A[i] -= A[i - 1]; // A[i] = A[i] - A[i - 1], A[i - 1] = 0
        }
        else
        {                     // если после проведённых операций с префиксом A[i - 1] > A[i], то массив не получится неубывающим
            cout &lt;&lt; "NO\n";   // выводим NO и завершаем проверку
            return;
        }
    }
    cout &lt;&lt; "YES\n"; //после операций мы смогли получить неубывающий массив, выводим YES
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int t;
    cin >> t;

    while (t--) {
        solve();
    }
}
</pre>
  </details>
</article>


<!-- Задача E. Составление графа -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Составление графа</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Даны два простых неориентированных графа F и G с n узлами. У графа F есть m₁ рёбер, а у графа G — m₂ рёбер. Вы можете выполнять одну из следующих двух операций любое количество раз:</p>
  <ul>
    <li>Выберите два целых числа u и v (1 ≤ u, v ≤ n), такие что между u и v в графе F есть ребро. Затем удалите это ребро из F.</li>
    <li>Выберите два целых числа u и v (1 ≤ u, v ≤ n), такие что между u и v в графе F нет ребра. Затем добавьте ребро между u и v в F.</li>
  </ul>
  <p>Определите минимальное количество операций, необходимых для того, чтобы для всех целых чисел u и v (1 ≤ u, v ≤ n) существовал путь от u до v в F если и только если существует путь от u до v в G.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10⁴) — количество независимых наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит три целых числа n, m₁ и m₂ (1 ≤ n ≤ 2⋅10⁵, 0 ≤ m₁, m₂ ≤ 2⋅10⁵) — количество узлов, количество рёбер в F и количество рёбер в G.</p>

  <p>Следующие m₁ строк содержат по два целых числа u и v (1 ≤ u, v ≤ n) — между u и v в графе F есть ребро. Гарантируется, что нет повторяющихся рёбер и петель.</p>

  <p>Следующие m₂ строк содержат по два целых числа u и v (1 ≤ u, v ≤ n) — между u и v в графе G есть ребро. Гарантируется, что нет повторяющихся рёбер и петель.</p>

  <p>Гарантируется, что сумма n, сумма m₁ и сумма m₂ по всем наборам входных данных не превышают 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно целое число, обозначающее минимальное количество операций, необходимых на новой строке.</p>

  <h4>Пример</h4>
<pre>
5
3 2 1
1 2
2 3
1 3
2 1 1
1 2
1 2
3 2 0
3 2
1 2
1 0 0
3 3 1
1 2
1 3
2 3
1 2
</pre>
<pre>
3
0
2
0
2
</pre>
  <p>В первом наборе входных данных вы можете выполнить следующие три операции:</p>
  <ol>
    <li>Добавить ребро между вершиной 1 и вершиной 3.</li>
    <li>Удалить ребро между вершиной 1 и вершиной 2.</li>
    <li>Удалить ребро между вершиной 2 и вершиной 3.</li>
  </ol>
  <p>Можно показать, что меньшее количество операций невозможно достичь.</p>
  <p>Во втором наборе входных данных графы F и G уже изначально удовлетворяют условию.</p>
  <p>В пятом наборе входных данных рёбра от 1 до 3 и от 2 до 3 должны быть оба удалены.</p>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;string&gt;

using namespace std;

#define ll long long
void dfs(ll x, vector&lt;ll&gt;& Col, vector&lt;vector&lt;ll&gt; &gt;& G)
{
    for (auto i : G[x])
    {
        if (Col[i] == 0)
        {
            Col[i] = Col[x];
            dfs(i, Col, G);
        }
    }
}
void solve()
{
    ll n, m1, m2;
    cin >> n >> m1 >> m2;
    vector&lt;vector&lt;ll&gt; &gt; F(n + 1);
    while (m1--)
    {
        ll u, v;
        cin >> u >> v;
        F[u].push_back(v);
        F[v].push_back(u); // создаём список смежности для графа F
    }
    vector&lt;vector&lt;ll&gt; &gt; G(n + 1);
    while (m2--)
    {
        ll u, v;
        cin >> u >> v;
        G[u].push_back(v);
        G[v].push_back(u); // создаём список смежности для графа G
    }
    // в задаче требуется, чтобы в итоге в графах G и F совпадали компоненты связности
    // найдём копоненты связности графа G
    vector&lt;ll&gt; Col(n + 1); // вектор цветов
    ll c = 0; // номер цвета
    for (ll i = 1; i &lt;= n; ++i)
    {
        if (Col[i] == 0) // найдена новая компонента связности
        {
            ++c; // увеличиваем текущий номер цвета
            Col[i] = c;
            dfs(i, Col, G); // красим в этот цвет все вершины из этой компоненты
        }
    }
    // в итоге c будет равно количеству компонент связности
    // если две вершины графа находятся в разных компонентах, то между ними не должно быть ребра
    vector&lt;vector&lt;ll&gt; &gt; O(n + 1); // создадим граф, в который будем добавлять только рёбра графа F между вершинами одного цвета
    ll count = 0; // счётчик удалённых рёбер
    for (ll i = 1; i &lt;= n; ++i)
    {
        for (auto x : F[i]) // проверяем все вершины, смежные с вершиной i
        {
            if (Col[x] == Col[i]) // если x и i одного цвета
            {
                O[i].push_back(x); // добавляем ребро между ними в граф
            }
            else
            {               // если они из разных компонент, такое ребро нужно удалить
                ++count;    // увеличиваем счётчик
            }
        }
    }
    count /= 2; // каждое удалённое ребро мы посчитали два раза
                // делим счётчик на 2 и получаем количество рёбер, которые необходимо удалить
    // теперь у нас есть граф, в котором рёбра есть только между вершинами, которые должны быть в одной компоненте связности
    for (ll i = 1; i &lt;= n; ++i)
    {
        Col[i] = 0;
    }
    ll k = 0; // посчитаем количество компонент связности в этом графе
    for (ll i = 1; i &lt;= n; ++i)
    {
        if (Col[i] == 0)
        {
            ++k;
            Col[i] = k;
            dfs(i, Col, O);
        }
    }
    // сейчас в графе k компонент связности, мы должны объединить некоторые и получить c компонент
    // чтобы объединить две компоненты в одну, достаточно одного ребра
    // добавив k - c новых рёбер, мы можем получить c компонент связности
    count += k - c; // увеличиваем ответ на это число
    cout &lt;&lt; count &lt;&lt; '\n';
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int t;
    cin >> t;

    while (t--) {
        solve();
    }
}
</pre>
  </details>
</article>


<!-- Задача F. Умножительные массивы -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Умножительные массивы</h3>

  <div><i>Ограничение по времени 4с
  <br>Ограничение по памяти 512мб</i></div>

  <p>Даны целые числа k и n. Для каждого целого числа x от 1 до k посчитайте количество целых массивов a, таких что выполняются все следующие условия:</p>
  <ul>
    <li>1 ≤ |a| ≤ n, где |a| обозначает длину массива a.</li>
    <li>1 ≤ aᵢ ≤ k для всех 1 ≤ i ≤ |a|.</li>
    <li>a1xa2x⋯xa|a|=x (т.е. произведение всех элементов равно x).</li>
  </ul>

  <p>Обратите внимание, что два массива b и c различны, если либо их длины различны, либо существует индекс 1 ≤ i ≤ |b|, такой что bᵢ ≠ cᵢ.</p>

  <p>Выведите ответ по модулю 998244353.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10³) — количество наборов входных данных.</p>

  <p>Единственная строка каждого набора входных данных содержит два целых числа k и n (1 ≤ k ≤ 10⁵,1 ≤ n ≤ 9⋅10⁸).</p>

  <p>Гарантируется, что сумма k по всем наборам входных данных не превышает 10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите k целых чисел, разделенных пробелом, на новой строке: количество массивов для x=1, 2, ..., k, по модулю 998244353.</p>

  <h4>Пример</h4>
<pre>
3
2 2
4 3
10 6969420
</pre>
<pre>
2 3
3 6 6 10
6969420 124188773 124188773
729965558 124188773 337497990
124188773 50981194 729965558 337497990
</pre>
  <p>В первом наборе входных данных существует 2 массива a с |a|≤2 и произведением элементов, равным 1:</p>
  <ul>
    <li>[1]</li>
    <li>[1,1]</li>
  </ul>
  <p>Существует 3 массива a с |a|≤2 и произведением элементов, равным 2:</p>
  <ul>
    <li>[2]</li>
    <li>[1,2]</li>
    <li>[2,1]</li>
  </ul>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;
using ll = long long;
using vll = std::vector&lt;ll&gt;;



ll bin_pow_m(ll x, ll y, ll mod)// степень по модулю
{
	if (y == 0)
		return 1;
	if (y == 1)
	{
		return x % mod;
	}
	if (y % 2)
	{
		return (bin_pow_m(x, y - 1, mod) * x) % mod;
	}
	else
	{

		return bin_pow_m(x * x % mod, y / 2, mod);;
	}
}

vll F;//факториал по модулю
vll F1;//обратный факториал по модулю
void Fbild(ll n, ll mod)
{
	F.resize(n + 1);
	F1.resize(n + 1);
	F[0] = 1;
	F1[0] = bin_pow_m(F[0], mod - 2, mod);
	for (int i = 1; i &lt; F.size(); i++)
	{
		F[i] = (F[i - 1] * i) % mod;
		F1[i] = bin_pow_m(F[i], mod - 2, mod);
	}
}

ll mod = 998244353;
ll smalC(ll n, ll k)// количество вариантов выбрать из n элементов k по модулю
{
	if (n == k)
		return 1;
	if (n &lt; k)
		return 0;
	ll ans = 1;
	for (ll i = n - k + 1; i &lt;= n; i++)
		ans = (ans * i) % mod;
	return (ans * F1[k]) % mod;
}

void slove()
{
	ll k, n;
	cin>>k >> n;
	vector&lt;vll&gt; deg(k + 1);
	//решетом Эратосфена получаем все делители каждого числа до k
	for (ll i = 2; i &lt;= k; i++)
	{
		for (ll j = i; j &lt;= k; j += i)
			deg[j].push_back(i);
	}
	// dp[i][j]- количество способов разбить число i на j делитеолей больших 1
	vector&lt;vll&gt;dp(k + 1, vll(20));

	for (int i = 2; i &lt; k + 1; i++)//база dp количество способов разложить число на один делитель всегда 1 (само это число)
		dp[i][1] = 1;
	//заметим что 1 вообще нельзя разбить на делители >1
	for (int i = 2; i &lt;= k; i++)
	{
		for (int j = 2; j &lt; 20; j++)
		{
			for (auto c : deg[i])//перебираем делители числа i и представляем что ставим его в конец тогда если мы зафиксировали последний делитель то ответ лежит в оставшемся числе которое разбили на один делитель меньше
				dp[i][j] = (dp[i / c][j - 1] + dp[i][j]) % mod;
		}
	}
	cout &lt;&lt; n &lt;&lt; ' ';//для 1 всегда отвте n
	for (ll i = 2; i &lt;= k; i++)
	{
		ll an = 0;
		for (ll j = 1; j &lt; 20; j++)
		{
			an = (an + smalC(n + 1, j + 1) * dp[i][j] % mod) % mod;//по формуле счиатем количество разбиений от 1 до n делителей среди который j больше 1, числа i
			//за пояснением к формуле лучше обратиться к разбору, там хорошо описаны матетматические переходы
		}
		cout &lt;&lt; an &lt;&lt; ' ';
	}
	cout &lt;&lt; endl;
}

int main()
{
	Fbild(1e6, 998244353);
	ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	ll t = 1;
	cin >> t;

	while (t--) {
		slove();
	}
}
</pre>
  </details>
</article>


<!-- Задача G. Ошибочная сортировка -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Ошибочная сортировка</h3>

  <div><i>Ограничение по времени 4с
  <br>Ограничение по памяти 1024мб</i></div>

  <p>Сегодня Алиса дала Бобу массивы, которые он должен отсортировать по возрастанию. Снова! На данный момент никто точно не знает, сколько раз она это делала.</p>

  <p>Бобу даны две последовательности a и b, обе длиной n. Все целые числа в диапазоне от 1 до 2n встречаются ровно один раз в одной из последовательностей a или b. Другими словами, конкатенированная∗ последовательность a+b является перестановкой† длины 2n.</p>

  <p>Боб должен отсортировать обе последовательности по возрастанию одновременно, используя функцию swap Алисы. Функция swap Алисы реализована следующим образом:</p>
  <ul>
    <li>Даны два индекса i и j (i≠j), она меняет местами a<sub>i</sub> с b<sub>j</sub> и b<sub>i</sub> с a<sub>j</sub>.</li>
  </ul>

  <p>Учитывая последовательности a и b, пожалуйста, определите, можно ли отсортировать обе последовательности по возрастанию одновременно после использования функции swap Алисы любое количество раз.</p>

  <p>* Конкатенированная последовательность a+b обозначает последовательность [a₁, a₂, a₃, ..., b₁, b₂, b₃, ...].</p>

  <p>† Перестановка длины m содержит все целые числа от 1 до m в каком-то порядке.</p>

  <h4>Входные данные</h4>
  <p>Каждый тест содержит несколько наборов входных данных. Первая строка содержит количество наборов входных данных t (1 ≤ t ≤ 10⁴). Далее следует описание наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит одно целое число n (3 ≤ n ≤ 2⋅10⁵).</p>

  <p>Вторая строка каждого набора входных данных содержит a₁,a₂,…,aₙ (1 ≤ aᵢ ≤ 2n).</p>

  <p>Третья строка каждого набора входных данных содержит b₁,b₂,…,bₙ (1 ≤ bᵢ ≤ 2n).</p>

  <p>Гарантируется, что все целые числа в диапазоне [1, 2n] встречаются ровно один раз в одной из последовательностей a или b.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Если возможно отсортировать обе последовательности одновременно, выведите «YES» в новой строке. В противном случае выведите «NO» в новой строке.</p>

  <p>Вы можете вывести ответ в любом регистре. Например, строки «yEs», «yes», и «Yes» также будут признаны положительными ответами.</p>

  <h4>Пример</h4>
<pre>
5
3
2 1 3
4 6 5
3
2 1 5
4 3 6
4
1 6 4 3
5 2 8 7
4
5 3 7 1
8 6 4 2
7
5 1 9 12 3 13 7
2 4 11 14 6 10 8
</pre>
<pre>
NO
YES
NO
YES
YES
</pre>
  <p>В первом наборе входных данных можно показать, что это невозможно.</p>

  <p>Во втором наборе входных данных Боб может выполнить одну операцию с индексами i=1 и j=2. Массивы становятся [3,4,5] и [1,2,6] соответственно. Оба массива теперь отсортированы.</p>
</article>

