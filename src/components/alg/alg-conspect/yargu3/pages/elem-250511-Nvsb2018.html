<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p><a href="https://codeforces.com/group/CkAC2YcRrZ/contests" target="_blank">ЯрГУ. Кружок. Контесты</a></p>
  <p>Автор кружка Игорь Маслеников</p>
</article>


<article class="article">
  <h1>Личное первенство Новосибирска 2018</h1>
  <p><a href="https://codeforces.com/group/CkAC2YcRrZ/contest/609334" target="_blank">Codeforces Контест 609334 2025-05-11</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

      <a href="#task1">Задача A. Мафия</a>
  <br><a href="#task2">Задача B. Крот</a>
  <br><a href="#task3">Задача C. Корона</a>
  <br><a href="#task4">Задача D. Стерлядь</a>
  <br><a href="#task5">Задача E. Парные гонки</a>
  <br><a href="#task6">Задача F. Групповой раунд</a>
  <br><a href="#task7">Задача G. Красивое имя</a>
  <br><a href="#task8">Задача H. Премия</a>
  <br><a href="#task9">Задача I. Супер-кола</a>
  <br><a href="#task10">Задача J. Форматирование</a>
  <br><a href="#task11">Задача K. Старая дача</a>
</article>


<!-- Задача A. Мафия -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Мафия</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Как известно, основное преступление мафии - неуплата налогов с нелегальных доходов. Одному налоговому полицейскому удалось поймать бухгалтера мафиозного клана и получить список членов этой преступной организации и их личных доходов. Из списка он узнал, что каждый член клана непосредственно подчиняется только одному члену клана (которого называет "босс"), и лишь один, крестный отец, не подчиняется никому, при этом никакой член клана не подчинен сам себе даже опосредованно. Для каждого члена клана в списке был указан размер его личных нелегальных доходов и графики перечислений. Полицейский понял, что каждый член клана знает не только свой счет в банке, но и счета в банке всех вышестоящих босов вплоть до крестного отца.</p>
  <p>Начальник полиции поставил полицейскому задачу: узнать счета в банке, содержащие в сумме не менее S долларов нелегальных доходов. Определите минимальное количество членов преступного клана, которых полицейский должен арестовать, чтобы выполнить задачу начальника, считая, что каждый арестованный под угрозой конфискации средств сразу выдаст все известные ему счтета (свой и всех вышестоящих босов).</p>

  <h4>Входные данные</h4>
  <p>В первой строке входного файла два целых числа N, 1 ≤ N ≤ 10000 - количество членов преступного клана, S, 1 ≤ S ≤ 500000 - требуемая сумма доходов. Будем считать, что все члены клана пронумерованы от 0 до N - 1, причем номер 0 у крестного отца.</p>
  <p>Во второй строке N - 1 чисел p<sub>1</sub>, ... , p<sub>N-1</sub>, описывающие связи между членами клана, p<sub>i</sub>, 0 ≤ p<sub>i</sub> ≤ i - номер босса для i-го члена клана.</p>
  <p>В третьей строке N чисел w<sub>0</sub>, ... , w<sub>N-1</sub>, где w<sub>i</sub>, 1 ≤ w<sub>i</sub> ≤ 100, - личный доход i-го члена клана.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке одно целое число - минимальное количество арестов, которое необходимо произвести, чтобы узнать счета, сумма доходов на которых не менее S. Если сумму S набрать невозможно, то вывести "IMPOSSIBLE"</p>

  <details>
    <summary>Примеры</summary>
  <h4>Пример 1</h4>
<pre>
5 4
0 0 1 1
1 1 1 1 1
</pre>
  <code>2</code>

  <h4>Пример 2</h4>
<pre>
5 6
0 0 1 1
1 1 1 1 1
</pre>
  <code>IMPOSSIBLE</code>
  </details>
</article>


<!-- Задача B. Крот -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Крот</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Юные натуралисты получили задание сфотографировать крота, вылезающего из норы. Они довольно быстро нашли квадратную поляну, на которой было множество кротовых нор, но крот не хотел вылезать из них, пока поблизовти находились люди. Тогда они решили установить в центре поляны фотокамеру с тепловым датчиком движения. Это устройство работает следующим образом: определив движение в области контроля датчика, камера поворачивается так, чтобы движущийся объект оказался в центре кадра, и делает снимок. Обасть контроля датчика представляет собой сектор в 90 градусов, включая его граничные лучи, и при повороте камеры остается неизменной. Определите, какое максимальное количество нор может находиться в области контроля датчика.</p>

  <h4>Входные данные</h4>
  <p>В первой строке одно натуральное число N - количество нор на поляне, 1 ≤ N ≤ 5000.</p>
  <p>Далее N строк по два целых числа через пробел - декартовы координаты нор X и Y, -1000 ≤ X, Y ≤ 1000. Центр поляны расположен в точке с координатами (0, 0).</p>
  <p>Гарантируется, что в центре поляны норы нет и что никакие две норы не находятся в одной точке.</p>

  <h4>Выходные данные</h4>
  <p>В первой и единственной строке одно натуральное число - максимальное количество нор, которое может оказаться в области контроля датчика, установленного вместе с камерой в центре поляны. Дальностью действия датчика можно пренебречь.</p>

  <details>
    <summary>Пример</summary>
<pre>
8
3 1
1 1
2 3
2 2
-1 1
-1 2
-8 -2
1 -5
</pre>
  <code>5</code>
  </details>
</article>


<!-- Задача C. Корона -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Корона</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Король решил украсить свою корону дополнителными драгоценными камнями. Придворные ювелиры долго думали, как сделать это лучшим образом, и пришли к выводу, что, не нарушая целостности композиции, на корону можно добавить ровно K камней. Король хочет, чтобы корона была очень дорогой, но при этом его также беспокоит суммарный вес, который добавится за счет дополнительных украшений. Зная стоимость и вес каждого из N драгоценных камней, имеющихся у короля, помогите ему выбрать K камней так, чтобы соотношение их суммарной стоимости к их суммарному весу было максимальным.</p>

  <h4>Входные данные</h4>
  <p>В первой строке два натуральных числа через пробел: N - количество драгоценных камней в сокровищнице короля, 1 ≤ N ≤ 1000, и K - количество камней, которое следует добавить на корону, 1 ≤ K ≤ N.</p>
  <p>Далее N строк по два натуральных числа через пробел, описывающих каждый из камней. Первое число в строке - стоимость камня, второе - его вес. Оба числа не превышают 1000.</p>

  <h4>Выходные данные</h4>
  <p>В первой и единственной строке два целых числа через символ '/' - числитель и знаменатель несократимой дроби, представляющей собой максимальное значение соотношения суммарной стоимости K камней из имеющегося множества к их суммарному весу. Если ответ - целое число, то в качестве знаменателя вывести 1.</p>

  <details>
    <summary>Пример</summary>
<pre>
3 2
5 1
3 2
2 3
</pre>
  <code>8/3</code>
  </details>
</article>


<!-- Задача D. Стерлядь -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Стерлядь</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Розничному продавцу стерляди, которая может весить до N грамм, от предыдущего продавца достался набор из K типов гирь по N гирь каждого типа. В ответ на просьбу докупить гири хозяин торговой точки отметил, что гирь и так очень много, и поинтересовался целесообразностью данной покупки, а именно: он попросил посчитать, сколько различных весов из диапазона от 1 до N продавец может набрать, используя уже имеющиеся гири. Помогите продавцу стерляди ответить на этот вопрос.</p>

  <h4>Входные данные</h4>
  <p>В первой строке два натуральных числа через пробел: K - количество типов гирь, имеющихся у продавца, 1 ≤ K ≤ 1000, и N - максимальный вес стерляди, 2 ≤ N ≤ 10¹⁵.</p>
  <p>Во второй строке K натуральных чисел через пробел, каждое из которых не превышает 10000, - веса имеющихся гирь.</p>

  <h4>Выходные данные</h4>
  <p>В первой и единственной строке одно целое число - количество различных весов в диапазоне от 1 до N включительно, которые можно набрать имеющимися гирями.</p>

  <details>
    <summary>Пример</summary>
<pre>
2 10
3 5
</pre>
  <code>6</code>
  </details>
</article>


<!-- Задача E. Парные гонки -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Парные гонки</h3>

  <div><i>Ограничение по времени 4с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Любители домашних насекомых ежегодно проводят чемпионат по тараканьим бегам. Соревнования проводятся в N раундов парными гонками с выбыванием после поражения, всего участников чемпионата 2ⁿ. Перед началом соревнований проводится жеребьевка, в результате которой каждому участнику присваивается стартовый номер. В первом раунде таракан с первым стартовым номером бежит с соперником со вторым стартовым номером, 3-й с 4-м, ... , 2ⁿ⁻¹-й с 2ⁿ-м. Победители проходят в следующий раунд, проигравшие выбывают. Во втором раунде участвуют уже 2ⁿ⁻¹ участников, победитель первой пары бежит в одном забеге с победителем второй пары, победитель 3-й пары с победителем 4-й и т.д. В конечном итоге в N-м раунде будут соревноваться два участника и определится абсолютный победитель.</p>
  <p>Важно заметить, что все 2ⁿ участников имеют различную скорость от 1 до 2ⁿ и в забеге всегда побеждает более быстрый, получая за победу количество очков, равное скорости соперника. Очевидно, что абсолютным победителем станет самый быстрый, но максимальное суммарное количесвто очков может набрать другой участник, все зависит от предстартовой жеребьевки.</p>
  <p>Хозяева вложили немало усилий в подготовку и им нетерпится узнать, как выступит их питомец. Чтобы немного успокоить владельцев тараканов, нужно сделать оценку его шансов, т.е. посчитать математическое ожидание количества набранных очков.</p>

  <h4>Входные данные</h4>
  <p>В первой и единственной строке входного файла два целых числа N, 2 ≤ N ≤ 10 количество раундов и K, 1 ≤ K ≤ 2ⁿ - скорость таракана, для которого требуется сделать оценку результата.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке необходимо выдать математическое ожидание количества набранных очков для таракана со скоростью K в виде несократимой дроби, для ыелых чисел знаменатель равен 1.</p>

  <details>
    <summary>Примеры</summary>
  <h4>Пример 1</h4>
  <code>2 2</code>
  <code>1/3</code>

  <h4>Пример 2</h4>
  <code>3 3</code>
  <code>3/7</code>
  </details>
</article>


<!-- Задача F. Групповой раунд -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Групповой раунд</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В любительском чемпионате по футболу участники, как и на настоящем чемпионате мира, разбиты на группы по 4 команды, где каждая команда должна сыграть с каждой. За победу команда получает 3 очка, за ничью - 1 очко, за поражение - 0 очков. Отличие в том, что матчи проводятся в произвольное время и в произвольном порядке, а потому часть матчей к моменту их проведения уже не влияет на распределение мест. Зная результаты нескольких прошедших матчей в группе, определите, какие команды сохранили шанс на единоличное первое место по результатам всех матчей. Команда занимает единоличное первое место, если суммарное количество очков, которое она набирает, строго больше суммарного количества очков, набранного любой другой командой группы, после проведения всех шести матчей в группе.</p>

  <h4>Входные данные</h4>
  <p>В первой строке одно целое число N, 0 ≤ N ≤ 6, - количество прошедших матчей в группе.</p>
  <p>Далее N строк по 4 целых неотрицательных числа T1, T2, G1, G2 через пробел - описания прошедших матчей. Числа T1, T2 - номера команд, участвовавших в матче, а G1, G2 - количество голов, забитых в этом матче командами T1, T2 соответственно. Команды в группе нумеруются от 1 до 4. Количество голов, забитых в матче одной командой, не превышает 10.</p>

  <h4>Выходные данные</h4>
  <p>В первой строке вывести YES, если первая команда может занять единоличное первое место в группе по итогам всех матчей, и NO в противном случае. Вторая, третья и четвертая строки формируются аналогично для второй, третьей и четвертой команд соответственно.</p>

  <details>
    <summary>Пример</summary>
<pre>
3
1 2 10 0
3 2 2 0
4 2 1 0
</pre>
<pre>
YES
NO
YES
YES
</pre>
  </details>
</article>


<!-- Задача G. Красивое имя -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Красивое имя</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В одном индейском племени все имена состоят из одного и того же набора латинских букв, то есть количество вхождений каждой буквы в любое имя одинаково. Красивым именем считается имя, в котором одинаковые буквы не стоят рядом. Однажды индейцы решили составить перечень всех возможных красивых имен в алфавитном порядке, но сразу столкнулись с проблемой: как определить первое имя в перечне. Помогите им в этом.</p>

  <h4>Входные данные</h4>
  <p>В первой строке целое число N, 1 ≤ N ≤ 100000, - число букв в имени. Вторая строка представляет собой последовательность из N строчных латинских букв, заканчивающуюся символом перехода на новую строку, - имя одного из индейцев племени.</p>

  <h4>Выходные данные</h4>
  <p>В первой и единственной строке последовательность из N строчных латинских букв - первое в алфавитном порядке красивое имя, которое может иметь индеец данного племени. Если такого имени нет, вывести IMPOSSIBLE.</p>

  <details>
    <summary>Примеры</summary>
  <h4>Пример 1</h4>
<pre>
6
cbacba
</pre>
  <code>abacbc</code>

  <h4>Пример 2</h4>
<pre>
6
aaaa
</pre>
  <code>IMPOSSIBLE</code>
  </details>
</article>


<!-- Задача H. Премия -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Премия</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>За успешное выступление на олимпиаде по программированию вам выписали премию. В результате странной ошибки, указанная в приказе сумма преми оказалась неправильной - в ее записи появилось K лишних цифр. Так как выступление было очень успешным, вам предложили самостоятельно выбрать, какие K цифр вычеркнуть. Сделайте это так, чтобы сумма премии оказалась максимальной.</p>

  <h4>Формат входных данных</h4>
  <p>В первой строке одно положительное N-значное число, первая цифра которого отлична от 0, - сумма премии, указанная в приказе. Во второй строке одно положительное число K, 1 ≤ K &lt; N ≤ 1000000, - количество цифр, которое необходимо вычеркнуть.</p>

  <h4>Выходные данные</h4>
  <p>В первой и единственной строке одно натуральное число - максимально возможная сумма премии, которую можно получить, вычеркнув K цифр из указанного в приказе числа.</p>

  <details>
    <summary>Пример</summary>
<pre>
9052
2
</pre>
  <code>95</code>
  </details>
</article>


<!-- Задача I. Супер-кола -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача I. Супер-кола</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Компания по производству лимонада "Супер-кола" проводит очередную рекламную акцию - меняет крышки от бутылок, на которых указаны очки, на призы. Ребенок выбрал приз ценой M очков. Каждая крышка дает K очков. Сколько потратит отец, чтобы ребенок получил приз, если каждая бутылка "Супер-колы" стоит N рублей?</p>

  <h4>Входные данные</h4>
  <p>В единственной строке три разделенных пробелами целых числа M, 1 ≤ M ≤ 10000 - число очков для получения приза, K, 1 ≤ K ≤ M - число очков на каждой крышке, N, 1 ≤ N ≤ 10000 - цена бутылки.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке одно целое число - сумма потраченных денег для получения приза.</p>

  <details>
    <summary>Пример</summary>
  <code>7 5 10</code>
  <code>20</code>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {

  // ввод данных
  int m; // число очков для приза
  int k; // число очков в бутылке
  int n; // цена бутылки
  cin >> m >> k >> n;

  // решение
  int d = 0; // сумма денег
  int b = 0; // число бутылок

  b = m % k ? m / k + 1 : m / k;
  d = b * n;

  // вывод результата
  cout &lt;&lt; d;

  return 0;
}
</pre>
  </details>
</article>


<!-- Задача J. Форматирование -->
<article class="article">
  <div class="anchor" id="task10"></div>
  <h3>Задача J. Форматирование</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>При вводе данных люди часто используют десятичную запись числа неоптимально - добавляют нули в старшие разряды целой и в младшие разряды дробной части, а также нулевую дробную часть для целых чисел. Ваша задача - исправить введенное неотрицательное число так, чтобы полученная десятичная запись имела минимальную длину. Заметим, что запись, которая начинается или заканчивается десятичным разделителем, корректной не является.</p>

  <h4>Входные данные</h4>
  <p>Единственная строка - десятичная запись числа, состоящая из цифр и не более одной запятой (десятичного разделителя). Общее число символов в строке не превышает 100.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке минимальная по длине десятичная запись заданного числа.</p>

  <details>
    <summary>Пример</summary>
  <code>0123,0010</code>
  <code>123,001</code>
  </details>

  <details>
    <summary>Решение</summary>

  <h4>Пример 2</h4>
  <code>0000,110</code>
  <code>0,11</code>

  <h4>Пример 3</h4>
  <code>001100,0000</code>
  <code>1100</code>

  <h4>Пример 4</h4>
  <code>0000,0000</code>
  <code>0</code>

  <h4>Пример 5</h4>
  <code>0000</code>
  <code>0</code>

<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  string s;
  cin >> s;

  // решение
  string r;
  int i = 0;
  int end = s.length();

  // отсекаем ведущие нули
  while (s[i] == '0') {
    i++;
  }

  // записываем число до точки
  while (i &lt; end && s[i] != ',') {
    r.push_back(s[i]);
    i++;
  }

  // если еще ничего нет
  if (r.empty()) {
    // записываем ноль перед точкой
    r.push_back('0');
  }

  // если есть точка
  if (s[i] == ',') {
    // записываем точку
    r.push_back(s[i]);
    int dot = i;
    i = s.length() - 1;

    // пропускаем последние нули
    while (s[i] == '0') {
      i--;
    }

    // если после точки ничего нет
    if (s[i] == ',') {
      // удаляем точку
      r.pop_back();
    } else {
      int end = i;
      for (i = dot + 1; i &lt;= end; i++) {
        r.push_back(s[i]);
      }
    }
  }

  // вывод результата
  cout &lt;&lt; r;

  return 0;
}
</pre>
  </details>
</article>


<!-- Задача K. Старая дача -->
<article class="article">
  <div class="anchor" id="task11"></div>
  <h3>Задача K. Старая дача</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>На старой даче стоит старый забор из N старых цветных досок. В старом сарае стоят N старых банок с краской, причем для окраски одной доски требуется одна банка краски. Старый дед, хозяин старой дачи, хочет слегка подновить старый забор, сделав его менее разноцветным. По заданным цветам досок и краски определите, какое минимальное количество различных цветов останется у забора после перекраски всех или нескольких досок.</p>

  <h4>Входные данные</h4>
  <p>В первой строке одно целое число N, 1 ≤ N ≤ 10⁵, - число досок и банок. Во второй строке N строчных латинских букв, обозначающие цвета досок забора. В третьей строке N строчных латинских букв, обозначающие цвета красок в банках. Соответствие ммежду цветами и буквами взаимно однозначное.</p>

  <h4>Выходные данные</h4>
  <p>Минимально возможное число различных цветов забора после перекраски части досок.</p>

  <details>
    <summary>Пример</summary>
<pre>
5
abcde
edcba
</pre>
  <code>3</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Создадим частотный массив на 26 элементов, по числу латинских букв. Пройдем по двум строкам и будем записывать в частотный массив сколько раз какая буква встречается. Отсортируем частотный массив и будем считать сколько различных букв помещается в число n.</p>

  <h4>Пример 2</h4>
<pre>
5
abccc
edcba
</pre>
  <code>2</code>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ввод данных
  int n;     // число досок и банок
  string d;  // доски
  string b;  // банки
  cin >> n;
  cin >> d >> b;

  // решение
  vector&lt;int&gt; Cnt(26, 0);
  // заполним частотный массив
  // для латинских букв
  for (int i = 0; i &lt; n; i++) {
    Cnt[d[i] - 'a']++;
    Cnt[b[i] - 'a']++;
  }

  sort(Cnt.begin(), Cnt.end());
  int res = 0;
  int c = 0;
  int i = 25;

  while (c &lt; n && i >= 0) {
    res++;
    c += Cnt[i];
    i--;
  }

  // вывод результата
  cout &lt;&lt; res;

  return 0;
}
</pre>
  </details>
</article>

