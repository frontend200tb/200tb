<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p><a href="https://codeforces.com/group/CkAC2YcRrZ/contests" target="_blank">ЯрГУ. Кружок. Контесты</a></p>
  <p>Автор кружка Игорь Маслеников</p>
</article>


<article class="article">
  <h1>Летний блиц 2 2025</h1>
  <p><a href="https://codeforces.com/group/CkAC2YcRrZ/contest/614846" target="_blank">Codeforces Контест 614846 2025-06-08</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

      <a href="#task1">Задача A. Третья сторона</a>
  <br><a href="#task2">Задача B. XOR и треугольник</a>
  <br><a href="#task3">Задача C. Симметричное кодирование</a>
  <br><a href="#task4">Задача D. Красивые пары троек</a>
  <br><a href="#task5">Задача E. Ingenuity-2</a>
  <br><a href="#task6">Задача F. Разослать сообщения</a>
  <br><a href="#task7">Задача G. Иванушка-дурачок и теория вероятностей</a>
  <br><a href="#task8">Задача H. Весь мир — задача по программированию (упрощённая версия)</a>
  <br><a href="#task9">Задача I. Лаборатории</a>
  <br><a href="#task10">Задача J. Алиса и кукла</a>
  <br><a href="#task11">Задача K. Алиса и нечестная игра</a>
  <br><a href="#task12">Задача L. Белые полосы</a>
  <br><a href="#task13">Задача M. Склеивание слов</a>
  <br><a href="#task14">Задача N. Круглый коридор</a>
</article>


<!-- Задача A. Третья сторона -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Третья сторона</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Розовые солдаты дали вам последовательность a, состоящую из n положительных целых чисел.</p>

  <p>Вы должны многократно выполнять следующую операцию до тех пор, пока не останется только 1 элемент.</p>
  <ul>
    <li>Выберите два различных индекса i и j.</li>
    <li>Затем выберите положительное целое число x, такое что существует невырожденный треугольник∗ со сторонами ai, aj и x.</li>
    <li>Наконец, удалите два элемента ai и aj, и добавьте x в конец a.</li>
  </ul>

  <p>Найдите максимальное возможное значение единственного последнего элемента в последовательности a.</p>

  <p>* Треугольник со сторонами длиной a, b, c является невырожденным, если a+b>c, a+c>b, b+c>a.</p>

  <h4>Входные данные</h4>
  <p>Каждый тест состоит из нескольких наборов входных данных. В первой строке находится одно целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных. Далее следует описание наборов входных данных.</p>

  <p>Первая строка каждого набора содержит одно целое число n (1 ≤ n ≤ 2⋅10⁵).</p>

  <p>Вторая строка каждого набора содержит n целых чисел a1, a2, …, an (1 ≤ ai ≤ 1000) — элементы последовательности a.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите максимальное возможное значение единственного последнего элемента на отдельной строке.</p>

  <details>
    <summary>Пример</summary>
<pre>
4
1
10
3
998 244 353
5
1 2 3 4 5
9
9 9 8 2 4 4 3 5 3
</pre>
<pre>
10
1593
11
39
</pre>
  <p>В первом примере уже есть только один элемент. Значение единственного последнего элемента равно 10.</p>
  <p>Во втором примере a изначально равен [998,244,353]. Одна из оптимальных последовательностей операций:</p>
  <ol>
    <li>Удалите a2=244 и a3=353, и добавьте 596 в конец a. Теперь a равен [998,596].</li>
    <li>Удалите a1=998 и a2=596, и добавьте 1593 в конец a. Теперь a равен [1593].</li>
  </ol>
  <p>Можно показать, что единственный последний элемент не может быть больше 1593. Поэтому ответ равен 1593.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Третья сторона невырожденного треугольника меньше суммы длин двух других сторон и больше разности длин двух других сторон. Стороны должны быть целыми числами поэтому третья сторона должна быть на 1 меньше суммы двух сторон.</p>
    <p>Сохраним первое число массива для первой стороны треугольника. Пробежим по массиву и будем прибавлять следующее число, как вторую сторону треугольника, вычтем 1 и получим третью сторону. </p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // длина массива
    cin >> n;

    // решение
    int third;
    cin >> third;

    int next;
    for (int i = 1; i &lt; n; i++) {
      cin >> next;
      third += next - 1;
    }

    // вывод результата
    cout &lt;&lt; third &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача B. XOR и треугольник -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. XOR и треугольник</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>На этот раз розовые солдаты дали вам целое число x (x≥2).</p>

  <p>Пожалуйста, определите, существует ли положительное целое число y, которое удовлетворяет следующим условиям.</p>
  <ul>
    <li>y строго меньше x.</li>
    <li>Существует невырожденный треугольник∗ со сторонами длиной x, y, x⊕y. Здесь ⊕ обозначает побитовую операцию XOR.</li>
  </ul>

  <p>Кроме того, если существует такое целое число y, выведите любое.</p>

  <p>* Треугольник со сторонами длиной a, b, c является невырожденным, если a+b>c, a+c>b, b+c>a.</p>

  <h4>Входные данные</h4>
  <p>Каждый тест состоит из нескольких наборов входных данных. В первой строке находится одно целое число t (1 ≤ t ≤ 2000) — количество наборов входных данных. Далее следует описание наборов входных данных.</p>

  <p>Единственная строка каждого набора содержит одно целое число x (2 ≤ x ≤ 10⁹).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно целое число на отдельной строке. Целое число, которое вы должны вывести, следующее:</p>
  <ul>
    <li>Если существует целое число y, удовлетворяющее условиям, выведите значение y (1 ≤ y &lt; x);</li>
    <li>В противном случае выведите -1.</li>
  </ul>
  <p>Если существует несколько целых чисел, удовлетворяющих условиям, вы можете вывести любое.</p>

  <details>
    <summary>Пример</summary>
<pre>
7
5
2
6
3
69
4
420
</pre>
<pre>
3
-1
5
-1
66
-1
320
</pre>
  <p>В первом примере существует невырожденный треугольник со сторонами длины 3, 5 и 3⊕5=6. Поэтому y=3 является допустимым ответом.</p>
  <p>Во втором примере 1 является единственным возможным кандидатом для y, но он не может образовать невырожденный треугольник. Поэтому ответ -1.</p>
  </details>

  <details>
    <summary>Решение с TL</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int x;
    cin >> x;

    // решение
    // x, y, z - стороны невырожденного треугольника
    int res = -1;
    for (int y = x - 1; y > 0; y--) {
      int z = x ^ y;
      if (x + y > z && x + z > y && y + z > x) {
        res = y;
        break;
      }
    }

    // вывод результата
    cout &lt;&lt; res &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача C. Симметричное кодирование -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Симметричное кодирование</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У Поликарпа есть строка s, которая состоит из строчных латинских букв. Он кодирует эту строку по следующему алгоритму:</p>
  <ul>
    <li>сначала он строит новую вспомогательную строку r, которая состоит из всех различных букв строки s, записанных в алфавитном порядке;</li>
    <li>далее кодирование происходит так: каждый символ в строке s заменяется на симметричный ему символ из строки r (первый символ строки r будет заменён на последний, второй на предпоследний и так далее).</li>
  </ul>
  <p>Например, кодирование строки s=«codeforces» происходит так:</p>
  <ul>
    <li>строка r получается равной «cdefors»;</li>
    <li>первый символ s1='c' заменяется на 's';</li>
    <li>второй символ s2='o' заменяется на 'e';</li>
    <li>третий символ s3='d' заменяется на 'r';</li>
    <li>...</li>
    <li>последний символ s10='s' заменяется на 'c'.</li>
  </ul>
  <p>Таким образом, результатом кодирования строки s=«codeforces» является строка «serofedsoc».</p>

  <p>Напишите программу, которая осуществляет декодирование — то есть по результату кодирования восстанавливает исходную строку s.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно целое число t (1≤t≤104) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора содержит одно целое число n (1≤n≤2⋅105) — длину строки b.</p>

  <p>Вторая строка каждого набора содержит строку b длины n, состоящую из строчных латинских букв — результат кодирования исходной строки s.</p>

  <p>Гарантируется, что сумма значений n по всем наборам входных данных в тесте не превосходит 2⋅105.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите строку s из которой был получен результат кодирования b.</p>

  <details>
    <summary>Пример</summary>
<pre>
5
10
serofedsoc
3
ttf
9
tlrhgmaoi
1
w
15
hnndledmnhlttin
</pre>
<pre>
codeforces
fft
algorithm
w
meetinthemiddle
</pre>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;map&gt;

using namespace std;

int main() {
  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // длина строки
    cin >> n;
    string b;
    cin >> b;

    // решение

    // оставляем уникальные буквы
    // и сортируем их по алфавиту
    set&lt;char&gt; st;
    for (char ch : b) {
      st.insert(ch);
    }

    // вспомогательная строка
    vector&lt;char&gt; A;
    for (char ch : st) {
      A.push_back(ch);
    }
    int m = st.size();

    // создаем словарь
    // буква - индекс во вспомогательной строке
    map&lt;char, int&gt; mp;
    for (int i = 0; i &lt; m; i++) {
      mp[A[i]] = i;
    }

    // восстанавливаем строку
    string s = "";
    for (char ch : b) {
      s.push_back(A[m - mp[ch] - 1]);
    }

    // вывод результата
    cout &lt;&lt; s &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача D. Красивые пары троек -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Красивые пары троек</h3>

  <div><i>Ограничение по времени 4с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Поликарпу подарили массив a из n целых чисел. Ему очень нравятся тройки чисел, поэтому для каждого j (1 ≤ j ≤ n-2) он выписал тройку из элементов [a<sub>j</sub>, a<sub>j+1</sub>, a<sub>j+2</sub>].</p>

  <p>Поликарп считает пару из троек b и c красивой, если они различаются ровно в одной позиции, то есть выполняется одно из следующих условий:</p>
  <ul>
    <li>b1≠c1 и b2=c2 и b3=c3;</li>
    <li>b1=c1 и b2≠c2 и b3=c3;</li>
    <li>b1=c1 и b2=c2 и b3≠c3.</li>
  </ul>
  <p>Найдите количество красивых пар троек среди выписанных троек [a<sub>j</sub>, a<sub>j+1</sub>, a<sub>j+2</sub>].</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора содержит одно целое число n (3 ≤ n ≤ 2⋅10⁵) — длину массива a.</p>

  <p>Вторая строка каждого набора содержит n целых чисел a1, a2, …, an (1 ≤ ai ≤ 10⁶) — элементы массива.</p>

  <p>Гарантируется, что сумма значений n по всем наборам входных данных в тесте не превосходит 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно целое число — количество красивых пар троек среди пар вида [a<sub>j</sub>, a<sub>j+1</sub>, a<sub>j+2</sub>].</p>

  <p>Обратите внимание, что ответ может не умещаться в 32-битные типы данных.</p>

  <details>
    <summary>Пример</summary>
<pre>
8
5
3 2 2 2 3
5
1 2 1 2 1
8
1 2 3 2 2 3 4 2
4
2 1 1 1
8
2 1 1 2 1 1 1 1
7
2 1 1 1 1 1 1
6
2 1 1 1 1 1
5
2 1 1 1 1
</pre>
<pre>
2
0
3
1
8
4
3
2
</pre>
  <p>В первом примере a=[3,2,2,2,3], Поликарп выпишет следующие тройки:</p>
  <ol>
    <li>[3,2,2];</li>
    <li>[2,2,2];</li>
    <li>[2,2,3].</li>
  </ol>
  <p>Красивыми парами являются тройка 1 с тройкой 2 и тройка 2 с тройкой 3.</p>
  <p>В третьем примере a=[1,2,3,2,2,3,4,2], Поликарп выпишет следующие тройки:</p>
  <ol>
    <li>[1,2,3];</li>
    <li>[2,3,2];</li>
    <li>[3,2,2];</li>
    <li>[2,2,3];</li>
    <li>[2,3,4];</li>
    <li>[3,4,2];</li>
  </ol>
  <p>Красивыми парами являются тройка 1 с тройкой 4, тройка 2 с тройкой 5, тройка 3 с тройкой 6.</p>
  </details>
</article>


<!-- Задача E. Ingenuity-2 -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Ingenuity-2</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Представим поверхность Марса как бесконечную координатную плоскость. Изначально в точке с координатой (0,0) находятся ровер Perseverance-2 и вертолёт Ingenuity-2. Специально для них был разработан набор инструкций s из n инструкций следующего вида:</p>
  <ul>
    <li>N: переместиться на один метр на север (из точки (x,y) в (x,y+1));</li>
    <li>S: переместиться на один метр на юг (из точки (x,y) в (x,y-1));</li>
    <li>E: переместиться на один метр на восток (из точки (x,y) в (x+1,y));</li>
    <li>W: переместиться на один метр на запад (из точки (x,y) в (x-1,y)).</li>
  </ul>

  <p>Каждая инструкция должна быть исполнена либо ровером, либо вертолётом. Причём каждый аппарат должен выполнить хотя бы одну инструкцию. Ваша задача распределить инструкции так, чтобы после исполнения всех n инструкций вертолёт и ровер оказались в одной точке или определить что это невозможно.</p>

  <h4>Входные данные</h4>
  <p>Первая строка ввода содержит t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора содержит одно целое число n (1 ≤ n ≤ 2⋅10⁵) — количество инструкций.</p>

  <p>Вторая строка каждого набора содержит строку s длины n из символов 'N', 'S', 'E', 'W' — последовательность инструкций.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных теста не превосходит 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных, если существует требуемое распределение инструкций, выведите строку p длины n из символов 'R', 'H'. Если i-я операция должна быть исполнена ровером, то pi=R, если i-я операция должна быть исполнена вертолётом, то pi=H. Если существует несколько решений, выведите любое из них.</p>

  <p>В противном случае выведите NO.</p>

  <details>
    <summary>Пример</summary>
<pre>
10
6
NENSNE
3
WWW
6
NESSWS
2
SN
2
WE
4
SSNN
4
WESN
2
SS
4
EWNN
4
WEWE
</pre>
<pre>
RRHRRH
NO
HRRHRH
NO
NO
RHRH
RRHH
RH
RRRH
RRHH
</pre>
  <p>Рассмотрим первый пример: строка S=NENSNE. Одно из возможных решений, показанное на рисунке ниже p=RRHRRH, с использованием которого и ровер, и вертолет окажутся на один метр на север и на один метр на восток.</p>
  <p>Для WWW решение невозможно.</p>
  </details>
</article>


<!-- Задача F. Разослать сообщения -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Разослать сообщения</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Степан — очень занятой человек, сегодня ему нужно отправить n сообщений в моменты времени m1,m2,…mn (mi &lt; mi+1). Но, к сожалению, к моменту времени 0 на его телефоне осталось всего f единиц заряда. В момент времени 0 телефон включен.</p>

  <p>За одну единицу времени включенный телефон теряет a единиц заряда. Также в любой момент времени Степан может выключить телефон и включить его позже. Это действие израсходует b единиц энергии за раз. Считайте включение и выключение моментальным, то есть вы можете включить его в момент x и послать сообщение в тот же момент и наоборот, послать сообщение в момент x и выключить телефон в тот же момент.</p>

  <p>Если в какой-то момент уровень заряда опускается до 0 (становится ≤0), то отправить сообщение в этот момент времени невозможно.</p>

  <p>Так как все сообщения очень важны для Степана, он хочет узнать, сможет ли он отправить все сообщения, без возможности зарядить телефон.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных содержится одно целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных в тесте. Далее следуют описания наборов.</p>

  <p>Первая строка каждого набора содержит четыре целых числа n, f, a и b (1 ≤ n ≤ 2⋅10⁵, 1 ≤ f, a, b ≤ 10⁹) — количество сообщений, изначальный заряд телефона, расход заряда за единицу времени и расход при последовательном выключении и включении.</p>

  <p>Вторая строка каждого набора содержит n целых чисел m1, m2, …, mn (1 ≤ mi ≤ 10⁹, mi &lt; mi+1) — моменты времени, в которые нужно отправить сообщения.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превосходит 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите «YES», если Степан сможет отправить все сообщения и «NO» в противном случае.</p>

  <p>Вы можете выводить каждую букву в любом регистре (строчную или заглавную). Например, строки «yEs», «yes», «Yes» и «YES» будут приняты как положительный ответ.</p>

  <details>
    <summary>Пример</summary>
<pre>
6
1 3 1 5
3
7 21 1 3
4 6 10 13 17 20 26
5 10 1 2
1 2 3 4 5
1 1000000000 1000000000 1000000000
1000000000
3 11 9 6
6 8 10
12 621526648 2585904 3566299
51789 61859 71998 73401 247675 298086 606959 663464 735972 806043 806459 919683
</pre>
<pre>
NO
YES
YES
NO
NO
YES
</pre>
  <p>В первом наборе входных данных примера в момент времени 0 заряд телефона равен 3. При отправке сообщения в момент времени 3 без выключения будет потрачено (3-0)⋅1=3 единицы заряда, в таком случае заряд упадёт до 0 и Степан не сможет отправить это сообщение. При выключении и включении заряд телефона уменьшится на 5, а значит и таким образом отправить сообщение не получится.</p>
  <p>Во третьем наборе входных данных примера в момент времени 0 заряд телефона равен 10, за одну единицу времени телефон теряет 1 единицу заряда, а при выключении и включении — 2 единицы заряда. Чтобы отправить все сообщения можно действовать следующим образом:</p>
  <ul>
    <li>Выключить телефон в момент времени 0 и включить в момент времени 1, после этого останется 10-2=8 единиц заряда;</li>
    <li>отправить сообщение в момент времени 1;</li>
    <li>отправить сообщение в момент времени 2, после этого останется 8-(2-1)⋅1=7 единиц заряда;</li>
    <li>Выключить телефон в момент времени 2 и включить в момент времени 3, после этого останется 7-2=5 единиц заряда;</li>
    <li>отправить сообщение в момент времени 3;</li>
    <li>Выключить телефон в момент времени 3 и включить в момент времени 4, после этого останется 5-2=3 единиц заряда;</li>
    <li>отправить сообщение в момент времени 4;</li>
    <li>Выключить телефон в момент времени 4 и включить в момент времени 5, после этого останется 3-2=1 единиц заряда;</li>
    <li>отправить сообщение в момент времени 5.</li>
  </ul>
  <p>Последний (шестой) набор примера может упасть, если в вашем решении есть переполнение целочисленного типа.</p>
  </details>
</article>


<!-- Задача G. Иванушка-дурачок и теория вероятностей -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Иванушка-дурачок и теория вероятностей</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 512мб</i></div>

</article>


<!-- Задача H. Весь мир — задача по программированию (упрощённая версия) -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Весь мир — задача по программированию (упрощённая версия)</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 512мб</i></div>

</article>


<!-- Задача I. Лаборатории -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача I. Лаборатории</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

</article>


<!-- Задача J. Алиса и кукла -->
<article class="article">
  <div class="anchor" id="task10"></div>
  <h3>Задача J. Алиса и кукла</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

</article>


<!-- Задача K. Алиса и нечестная игра -->
<article class="article">
  <div class="anchor" id="task11"></div>
  <h3>Задача K. Алиса и нечестная игра</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

</article>


<!-- Задача L. Белые полосы -->
<article class="article">
  <div class="anchor" id="task12"></div>
  <h3>Задача L. Белые полосы</h3>

  <div><i>Ограничение по времени 1.5с
  <br>Ограничение по памяти 256мб</i></div>

</article>


<!-- Задача M. Склеивание слов -->
<article class="article">
  <div class="anchor" id="task13"></div>
  <h3>Задача M. Склеивание слов</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

</article>


<!-- Задача N. Круглый коридор -->
<article class="article">
  <div class="anchor" id="task14"></div>
  <h3>Задача N. Круглый коридор</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

</article>

