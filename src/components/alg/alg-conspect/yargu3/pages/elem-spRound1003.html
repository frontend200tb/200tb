<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p><a href="https://codeforces.com/group/CkAC2YcRrZ/contests" target="_blank">ЯрГУ. Кружок. Контесты</a></p>
  <p>Автор кружка Игорь Маслеников</p>
</article>


<article class="article">
  <h1>Контест Round 1003 (Div.4)</h1>
  <p><a href="https://codeforces.com/contest/2065" target="_blank">Codeforces Round 1003 (Div.4)</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
        <a href="#task1">Задача A. Скибидус и Амог'у</a>
    <br><a href="#task2">Задача B. Скибидус и Огайо</a>
    <br><a href="#task3">Задача C1. Скибидус и Fanum tax (простая версия)</a>
    <br><a href="#task4">Задача C2. Скибидус и Fanum tax (сложная версия)</a>
    <br><a href="#task5">Задача D. Скибидус и сигма</a>
    <br><a href="#task6">Задача E. Скибидус и rizz</a>
    <br><a href="#task7">Задача F. Скибидус и slay</a>
    <br><a href="#task8">Задача G. Скибидус и ложь</a>
    <br><a href="#task9">Задача H. Бро считает себя избранным</a>
  </p>
</article>


<!-- Задача A. Скибидус и Амог'у -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Скибидус и Амог'у</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Скибидус приземляется на чужой планете, где местное племя Амог говорит на языке Амог'у. В Амог'у существуют две формы существительных: единственное и множественное.</p>

  <p>Учитывая, что корень существительного записывается как S, две формы записываются следующим образом:</p>
  <ul>
    <li>Единственное: S + «us»</li>
    <li>Множественное: S + «i»</li>
  </ul>
  <p>Здесь + обозначает конкатенацию строк. Например, abc + def = abcdef.</p>

  <p>Например, когда S записывается как «amog», то форма единственного числа записывается как «amogus», а форма множественного числа записывается как «amogi». Обратите внимание, что существительные Амог'у могут иметь пустой корень — в частности, «us» является формой единственного числа для «i».</p>

  <p>Дано существительное Амог'у в форме единственного числа, пожалуйста, преобразуйте его в соответствующее существительное во множественном числе.</p>

  <h4>Входные данные</h4>
  <p>Каждый тест состоит из нескольких наборов входных данных. В первой строке находится одно целое число t (1 ≤ t ≤ 100) — количество наборов входных данных. Далее следует описание наборов входных данных.</p>

  <p>Единственная строка каждого набора входных данных содержит строку W, которая является существительным Амог'у в единственном числе. Гарантируется, что W состоит только из строчных английских букв, имеет длину не более 10 и заканчивается на «us».</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите соответствующее существительное во множественном числе на отдельной строке.</p>

  <h4>Пример</h4>
<pre>
9
us
sus
fungus
cactus
sussus
amogus
chungus
ntarsus
skibidus
</pre>
<pre>
i
si
fungi
cacti
sussi
amogi
chungi
ntarsi
skibidi
</pre>

  <details>
    <summary>Решение</summary>
    <p>элементарная задача. считываем строку и возвращаем её же, но с замененными последними символами</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int t;
  cin >> t;

  while (t--) {
    string w;
    cin >> w;

    for (int i = 0; i &lt; w.size() - 2; i++) {
      cout &lt;&lt; w[i];
    }

    cout &lt;&lt; "i\n";
  }
}
</pre>
  </details>
</article>


<!-- Задача B. Скибидус и Огайо -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Скибидус и Огайо</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Скибидусу дана строка s, состоящая из строчных латинских букв. Пока s содержит более чем 1 букву, он может:</p>
  <ul>
    <li>Выбрать индекс i (1 ≤ i ≤ |s|-1, |s| обозначает текущую длину s), такой что si=si+1. Заменить si на любую строчную латинскую букву по своему выбору. Удалить si+1 из строки.</li>
  </ul>

  <p>Скибидус должен определить минимально возможную длину, которую он может достичь за любое количество операций.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 100) — количество наборов входных данных.</p>

  <p>Единственная строка каждого набора входных данных содержит строку s (1 ≤ |s| ≤ 100). Гарантируется, что s содержит только строчные латинские буквы.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите целое число на новой строке — минимально достижимую длину s.</p>

  <h4>Пример</h4>
<pre>
4
baa
skibidus
cc
ohio
</pre>
<pre>
1
8
1
4
</pre>
  <p>В первом наборе входных данных Скибидус может:</p>
  <ul>
    <li>Выполнить операцию на i=2. Он заменяет s2 на b и удаляет s3 из строки. Затем s становится bb.</li>
    <li>Выполнить операцию на i=1. Он заменяет s1 на b и удаляет s2 из строки. Затем s становится b.</li>
    <li>Поскольку s содержит только 1 букву, Скибидус не может выполнить больше операций.</li>
  </ul>
  <p>Таким образом, ответ равен 1 для первого набора входных данных.</p>
  <p>Во втором наборе входных данных он не может выполнить операцию ни на одном индексе. Поэтому ответ по-прежнему равен длине начальной строки, 8.</p>

  <details>
    <summary>Решение</summary>
    <p>Нетрудно заметить, что если в строке есть два подряд идущих одинаковых символа, то всю строку можно сократить до 1 символа. этим циклом я просто ищу такуие два символа. вывожу единичку, если они находятся, и длину строки, если нет</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int t;
  cin >> t;

  while (t--) {
    string s;
    cin >> s;
    int res = s.size();
    for (int i = 1; i &lt; s.size(); i++) {
      if (s[i] == s[i - 1]) {
        res = 1;
        break;
      }
    }

    cout &lt;&lt; res &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача C1. Скибидус и Fanum tax (простая версия) -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C1. Скибидус и Fanum tax (простая версия)</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Это простая версия задачи. В этой версии m=1.</p>

  <p>Скибидус получил два массива a и b, содержащие соответственно n и m элементов. Для каждого целого числа i от 1 до n ему разрешено выполнить операцию не более одного раза:</p>
  <ul>
    <li>Выбрать целое число j такое, что 1 ≤ j ≤ m. Присвоить aᵢ := b<sub>j</sub> - aᵢ. Обратите внимание, что в результате этой операции aᵢ может стать неположительным.</li>
  </ul>

  <p>Скибидус нуждается в вашей помощи, чтобы определить, может ли он отсортировать a в неубывающем порядке∗ выполнив вышеуказанную операцию некоторое количество раз.</p>

  <p>* a отсортирован в неубывающем порядке, если a₁ ≤ a₂ ≤ ... ≤ aₙ.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит два целых числа n и m (1 ≤ n ≤ 2⋅10⁵, m = 1).</p>

  <p>Следующая строка каждого набора входных данных содержит n целых чисел a₁, a₂, ..., aₙ (1 ≤ aᵢ ≤ 10⁹).</p>

  <p>Следующая строка каждого набора входных данных содержит m целых чисел b₁, b₂, ..., bₘ (1 ≤ bᵢ ≤ 10⁹).</p>

  <p>Гарантируется, что сумма n и сумма m по всем наборам входных данных не превышают 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных, если возможно отсортировать a в неубывающем порядке, выведите «YES» на новой строке. В противном случае выведите «NO» на новой строке.</p>

  <p>Вы можете выводить ответ в любом регистре. Например, строки «yEs», «yes», и «Yes» также будут распознаны как положительные ответы.</p>

  <h4>Пример</h4>
<pre>
5
1 1
5
9
3 1
1 4 3
3
4 1
1 4 2 5
6
4 1
5 4 10 5
4
3 1
9 8 7
8
</pre>
<pre>
YES
NO
YES
NO
YES
</pre>
  <p>В первом наборе входных данных [5] уже отсортирован.</p>

  <p>Во втором наборе входных данных можно показать, что это невозможно.</p>

  <p>В третьем наборе входных данных мы можем присвоить a₃ := b₁ - a₃ = 6 - 2 = 4. Последовательность [1,4,4,5] отсортирована в неубывающем порядке.</p>

  <p>В последнем случае мы можем применить операции на каждом индексе. Последовательность становится [-1,0,1], которая отсортирована в неубывающем порядке.</p>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  int t;
  cin >> t;

  while (t--) {
    int n, m;
    cin >> n >> m;
    vector&lt;long long&gt; A(n + 1, 3'000'000'000'000);
    for (int i = 0; i &lt; n; i++) {
      cin >> A[i];
    }

    long long buf;
    cin >> buf;
    bool flag = true;
    long long h1, h2, tmp1, tmp2;

    for (int i = n - 1; i >= 0; i--) {
      tmp1 = A[i];
      tmp2 = buf - A[i];
      h1 = max(tmp1, tmp2);
      h2 = min(tmp1, tmp2);

      if (h1 &lt;= A[i + 1]) {
        A[i] = h1;
      } else if (h2 &lt;= A[i + 1]) {
        A[i] = h2;
      } else {
        flag = false;
      }
    }

    if (flag) {
      cout &lt;&lt; "YES\n";
    } else {
      cout &lt;&lt; "NO\n";
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача C2. Скибидус и Fanum tax (сложная версия) -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача C2. Скибидус и Fanum tax (сложная версия)</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Это сложная версия задачи. В этой версии m ≤ 2⋅10⁵.</p>

  <p>Скибидус получил два массива a и b, содержащие соответственно n и m элементов. Для каждого целого числа i от 1 до n ему разрешено выполнить операцию не более одного раза:</p>
  <ul>
    <li>Выбрать целое число j такое, что 1 ≤ j ≤ m. Присвоить aᵢ := b<sub>j</sub> - aᵢ. Обратите внимание, что в результате этой операции aᵢ может стать неположительным.</li>
  </ul>

  <p>Скибидус нуждается в вашей помощи, чтобы определить, может ли он отсортировать a в неубывающем порядке∗ выполнив вышеуказанную операцию некоторое количество раз.</p>

  <p>* a отсортирован в неубывающем порядке, если a₁ ≤ a₂ ≤ ... ≤ aₙ.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит два целых числа n и m (1 ≤ n ≤ 2⋅10⁵, 1 ≤ m ≤ 2⋅10⁵).</p>

  <p>Следующая строка каждого набора входных данных содержит n целых чисел a₁, a₂, ..., aₙ (1 ≤ aᵢ ≤ 10⁹).</p>

  <p>Следующая строка каждого набора входных данных содержит m целых чисел b₁, b₂, ..., bₘ (1 ≤ bᵢ ≤ 10⁹).</p>

  <p>Гарантируется, что сумма n и сумма m по всем наборам входных данных не превышают 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных, если возможно отсортировать a в неубывающем порядке, выведите «YES» на новой строке. В противном случае выведите «NO» на новой строке.</p>

  <p>Вы можете выводить ответ в любом регистре. Например, строки «yEs», «yes», и «Yes» также будут распознаны как положительные ответы.</p>

  <h4>Пример</h4>
<pre>
5
1 3
5
9 1 1000000000
3 2
1 4 3
3 4
4 3
2 4 6 5
6 1 8
5 2
6 4 5 4 5
4 1000
3 1
9 8 7
8
</pre>
<pre>
YES
NO
YES
NO
YES
</pre>
  <p>В первом наборе входных данных [5] уже отсортирован.</p>

  <p>Во втором наборе входных данных можно показать, что это невозможно.</p>

  <p>В третьем наборе входных данных мы можем установить a₂ := b₁ - a₂ = 6 - 4 = 2 и a₃ := b₃ - a₃ = 8 - 6 = 2. Последовательность [2,2,2,5] отсортирована в неубывающем порядке.</p>

  <p>В последнем случае мы можем применить операции на каждом индексе. Последовательность становится [-1,0,1], которая отсортирована в неубывающем порядке.</p>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;set&gt;

using namespace std;

int main() {
  int t;
  cin >> t;

  while (t--) {
    int n, m, b;
    cin >> n >> m;
    vector&lt;int&gt; A(n);

    // вместо массива делаем сет, чтобы
    // было удобнее искать в нем элементы
    set&lt;int&gt; B;
    bool f = false;
    for (int i = 0; i &lt; n; i++) {
      cin >> A[i];
    }
    while (m--) {
      cin >> b;
      B.insert(b);
    }

    //первому элементу массива А присваиваем минимальное значение
    //(*B.begin() - минимальное значение в "массиве" В)
    A[0] = min(A[0], *B.begin() - A[0]);
    int a;
    for (int i = 1; i &lt; n; i++) {
      //сохраняем A[i]
      a = A[i];
      //b - A[i] >= A[i-1]
      //b >= A[i] + A[i-1], где b - число из массива В
      //если есть такое b, заменяем A[i] на b - A[i]
      //выбираем минимальное значение A[i] такое, что оно не меньше A[i-1]
      //(из A[i], которое было, и b - A[i])
      if (B.lower_bound(A[i] + A[i - 1]) != B.end()) {
        A[i] = *B.lower_bound(A[i] + A[i - 1]) - A[i];
      }

      if (min(A[i], a) >= A[i - 1]) A[i] = min(A[i], a);
    }

    //проверка, отсортирован ли массив А
    for (int i = 1; i &lt; n; i++)
      if (A[i] &lt; A[i - 1])
      {
        cout &lt;&lt; "NO" &lt;&lt; endl;
        f = true;
        break;
      }
    if (!f) cout &lt;&lt; "YES" &lt;&lt; endl;
  }
}
</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Это решение не зашло на тесте 2</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // наборы тестов
  int t;
  cin >> t;

  while (t--) {
    // входные данные
    int n, m;
    cin >> n >> m;
    vector&lt;long long&gt; A(n + 1, 3'000'000'000'000);
    for (int i = 0; i &lt; n; i++) {
      cin >> A[i];
    }

    vector&lt;long long&gt; B(m);
    for (int i = 0; i &lt; m; i++) {
      cin >> B[i];
    }

    // решение
    bool flag = true;
    B.push_back(0);
    sort(B.begin(), B.end());

    for (int i = n - 1; i >= 0; i--) {
      int left = 0;
      int right = B.size() - 1;
      int mid;

      while (right - left > 1) {
        mid = (left + right) / 2;
        if (B[mid] &lt;= A[i] + A[i + 1]) {
          left = mid;
        } else {
          right = mid;
        }
      }

      if (B[right] &lt;= A[i] + A[i + 1]) {
        mid = right;
      } else if (B[left] &lt;= A[i] + A[i + 1]) {
        mid = left;
      } else {
        mid = -1;
      }

      if (mid == 0 || mid == -1) {
        if (A[i] > A[i + 1]) {
          flag = false;
        }
      } else {
        int h1, h2, tmp1, tmp2;
        tmp1 = A[i];
        tmp2 = B[mid] - A[i];
        h1 = max(tmp1, tmp2);
        h2 = min(tmp1, tmp2);

        if (h1 &lt;= A[i + 1]) {
          A[i] = tmp1;
        } else if (h2 &lt;= A[i + 1]) {
          A[i] = tmp2;
        } else {
          flag = false;
        }
      }
    }


    // вывод результата
    if (flag) {
      cout &lt;&lt; "YES\n";
    } else {
      cout &lt;&lt; "NO\n";
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача D. Скибидус и сигма -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача D. Скибидус и сигма</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Обозначим оценку массива b с k элементами как ∑(от i=1 до k)(∑(от j=1 до i)b<sub>j</sub>). Иными словами, пусть Si обозначает сумму первых i элементов массива b. Тогда оценка может быть записана как S1+S2+…+Sk.</p>

  <p>Скибидусу даны n массивов a1,a2,…,an, каждый из которых содержит m элементов. Будучи тем самым сигмой, он хотел бы объединить их в любом порядке, чтобы получить один массив, содержащий n⋅m элементов. Пожалуйста, найдите максимальную возможную оценку, которую Скибидус может достичь с помощью своего объединенного массива!</p>

  <p>Формально, среди всех возможных перестановок∗ p длины n, выведите максимальную оценку для ap1+ap2+⋯+apn, где + обозначает объединение†.</p>

  <p>* Перестановка длины n содержит все целые числа от 1 до n ровно один раз.</p>

  <p>† Объединение двух массивов c и d с длинами e и f соответственно (т.е. c+d) это c1,c2,…,ce,d1,d2,…df.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит два целых числа n и m (1 ≤ n⋅m ≤ 2⋅10⁵) — количество массивов и длину каждого массива.</p>

  <p>i-я из следующих n строк содержит m целых чисел ai,1,ai,2,…,ai,m (1 ≤ ai, j ≤ 10⁶) — элементы i-го массива.</p>

  <p>Гарантируется, что сумма n⋅m по всем наборам входных данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите максимальную оценку среди всех возможных перестановок p
  на новой строке.</p>

  <h4>Пример</h4>
<pre>
3
2 2
4 4
6 1
3 4
2 2 2 2
3 2 1 2
4 1 2 1
2 3
3 4 5
1 1 9
</pre>
<pre>
41
162
72
</pre>
  <p>Для первого набора входных данных есть две возможности для p:</p>
  <ul>
    <li>p=[1,2]. Тогда ap1+ap2=[4,4,6,1]. Его оценка равна 4+(4+4)+(4+4+6)+(4+4+6+1)=41.</li>
    <li>p=[2,1]. Тогда ap1+ap2=[6,1,4,4]. Его оценка равна 6+(6+1)+(6+1+4)+(6+1+4+4)=39.</li>
  </ul>
  <p>Максимально возможная оценка равна 41.</p>
  <p>Во втором наборе входных данных одна из оптимальных расстановок окончательного объединенного массива: [4,1,2,1,2,2,2,2,3,2,1,2]. Мы можем вычислить, что оценка равна 162.</p>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

bool comp(pair&lt;long long, int&gt; a, pair&lt;long long, int&gt; b) {
  // чтобы после сортировки элементы были не от меньшего к большему,
  // а от большего к меньшему
  return a.first > b.first;
}

int main() {
  int t;
  cin >> t;

  while (t--) {
    int n, m;
    cin >> n >> m;
    vector&lt;vector&lt;int&gt; &gt; A(n, vector&lt;int&gt;(m));
    // вектор сумм элементов каждого из массивов
    vector&lt;pair&lt;long long, int&gt; &gt; sum(n);
    for (int i = 0; i &lt; n; i++) {
      for (int j = 0; j &lt; m; j++) {
        cin >> A[i][j];
        // добавляем число в сумму
        sum[i].first += A[i][j];
        // записываем номер суммы, чтобы после
        // сортировки можно было восстановить порядок
        sum[i].second = i;
      }
    }

    // сортируем суммы от большей к меньшей
    // наибольшая оценка получится, если в начало
    // общего массива поставить массивы с большей суммой
    sort(sum.begin(), sum.end(), comp);

    // res - итоговая оценка общего массива, res1 - часть,
    // которая добавляется при подсчете оценки
    long long res = 0, res1 = 0;
    for (int i = 0; i &lt; n; i++) {
      for (int j = 0; j &lt; m; j++) {
        // добавляем числа к оценке согласно порядку, установленному
        res += res1 + A[sum[i].second][j];
        // отосортированным массивом сумм
        res1 += A[sum[i].second][j];
      }
    }

    cout &lt;&lt; res &lt;&lt; endl;
  }
}
</pre>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // наборы тестов
  int t;
  cin >> t;

  while (t--) {
    // входные данные
    int n, m;
    cin >> n >> m;
    vector&lt;pair&lt;long long, vector&lt;long long&gt; &gt; &gt; A(n);
    for (int i = 0; i &lt; n; i++) {
      A[i].first = 0;
      for (int j = 0; j &lt; m; j++) {
        int tmp;
        cin >> tmp;
        A[i].second.push_back(tmp);
        A[i].first += tmp;
      }
    }

    // решение
    sort(A.begin(), A.end());
    vector&lt;long long&gt; B;
    for (int i = n - 1; i >= 0; i--) {
      for (int j = 0; j &lt; m; j++) {
        B.push_back(A[i].second[j]);
      }
    }

    long long res = 0;
    long long mult = n * m;
    for (int i = 0; i &lt; B.size(); i++) {
      res += B[i] * mult;
      mult--;
    }

    // вывод результата
    cout &lt;&lt; res &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача E. Скибидус и rizz -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача E. Скибидус и rizz</h3>

  <div><i>Ограничение по времени 1.5с
  <br>Ограничение по памяти 256мб</i></div>

  <p>С приближением Дня Святого Валентина Скибидус отчаянно нуждается в способе привлечь внимание своей возлюбленной! К счастью, он знает, как это сделать: создать идеальную двоичную строку!</p>

  <p>Дана двоичная строка∗ t, пусть x представляет количество 0 в t, а y представляет количество 1 в t. Тогда её баланс определяется как значение max(x-y,y-x).</p>

  <p>Скибидус дает вам три целых числа n, m и k. Он просит вас помочь ему построить двоичную строку s длиной n+m из ровно n символов 0 и m символов 1, так что максимальный баланс среди всех её подстрок† равен ровно k. Если это невозможно, выведите -1.</p>

  <p>* Двоичная строка состоит только из символов 0 и 1.</p>

  <p>† Строка a является подстрокой строки b, если a может быть получена из b путем удаления нескольких (возможно, нуля или всех) символов с начала и нескольких (возможно, нуля или всех) символов с конца.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая и единственная строка каждого набора содержит три целых числа n, m и k (0 ≤ n, m ≤ 2⋅10⁵, 1 ≤ k ≤ n+m, n+m ≥ 1).</p>

  <p>Гарантируется, что сумма n и сумма m по всем наборам входных данных не превышают 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных, если возможно построить строку s, выведите её на новой строке. Если существует несколько возможных строк s, выведите любую. В противном случае выведите -1 на новой строке.</p>

  <h4>Пример</h4>
<pre>
6
1 2 1
4 3 2
2 4 3
8 3 2
5 0 4
5 0 5
</pre>
<pre>
101
0100101
011011
-1
-1
00000
</pre>
  <p>В первом примере мы должны построить s так, чтобы он содержал одну 0, две 1 и максимальный баланс 1 среди всех её подстрок. Одним из возможных корректных s является 101, потому что:</p>
  <ul>
    <li>Рассмотрим подстроку, ограниченную индексами [1,1]. Её баланс равен max(0-1,1-0)=1.</li>
    <li>Рассмотрим подстроку, ограниченную индексами [1,2]. Её баланс равен max(1-1,1-1)=0.</li>
    <li>Рассмотрим подстроку, ограниченную индексами [1,3]. Её баланс равен max(1-2,2-1)=1.</li>
    <li>Рассмотрим подстроку, ограниченную индексами [2,2]. Её баланс равен max(1-0,0-1)=1.</li>
    <li>Рассмотрим подстроку, ограниченную индексами [2,3]. Её баланс равен max(1-1,1-1)=0.</li>
    <li>Рассмотрим подстроку, ограниченную индексами [3,3]. Её баланс равен max(0-1,1-0)=1.</li>
  </ul>

  <p>Среди всех возможных подстрок максимальный баланс равен 1.</p>

  <p>Во втором примере подстрока с максимальным балансом — это 0100, которая имеет баланс max(3-1,1-3)=2.</p>

  <details>
    <summary>Решение</summary>
    <p>обычная задача на составление строки. в самом начале проверяю, возмоэно ли вообще набрать такое k путем рассмотра модуля разности (очевидно), а затем (если это возможно) делаю строку с некоторым числом нулей/единиц в начале, чередующимися единицами и нолями и выставлением оставшихся символов</p>
<pre>
#include &lt;bits/stdc++.h&gt;

using namespace std;

int main(){
  int t; cin >> t;
  while(t--){
    int n, m, k; cin >> n >> m >> k;
    if(max(n, m) - min(n, m) > k || k > max(n, m)){
      cout &lt;&lt; "-1" &lt;&lt; endl;
      continue;
    }
    else{
      pair&lt;int, int&gt; use1 = {n, 0}, use2 = {m, 1};
      if(m > n) swap(use1, use2);
      for(int i = 0; i &lt; k; i++){
        cout &lt;&lt; use1.second;
        use1.first--;
      }
      while(use2.first > 0){
        cout &lt;&lt; use2.second;
        use2.first--;
        swap(use1, use2);
      }
      while(use1.first > 0){
        cout &lt;&lt; use1.second;
        use1.first--;
      }
      cout &lt;&lt; "\n";
    }
  }
}
</pre>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // наборы тестов
  int t;
  cin >> t;

  while (t--) {
    // входные данные
    int n, m, k;
    cin >> n >> m >> k;

    if (abs(n - m) > k) {
      cout &lt;&lt; "-1\n";
    } else if (n &lt; k && m &lt; k) {
      cout &lt;&lt; -1;
    } else {
      if (n >= m) {
        for (int i = 0; i &lt; k; i++) {
          cout &lt;&lt; 0;
        }
        n -= k;
        while (n > 0 || m > 0) {
          if (m > 0) {
            cout &lt;&lt; 1;
            m--;
          }
          if (n > 0) {
            cout &lt;&lt; 0;
            n--;
          }
        }
        cout &lt;&lt; '\n';
      } else {
        for (int i = 0; i &lt; k; i++) {
          cout &lt;&lt; 1;
        }
        m -= k;
        while (n > 0 || m > 0) {
          if (n > 0) {
            cout &lt;&lt; 0;
            n--;
          }
          if (m > 0) {
            cout &lt;&lt; 1;
            m--;
          }
        }
        cout &lt;&lt; '\n';
      }
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача F. Скибидус и slay -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача F. Скибидус и slay</h3>

  <div><i>Ограничение по времени 4с
  <br>Ограничение по памяти 512мб</i></div>

  <p>Определим мажорирующий элемент последовательности из k элементов как уникальное значение, которое появляется строго более чем ⌊k/2⌋ раз. Если такое значение не существует, то последовательность не имеет мажорирующего элемента. Например, последовательность [1,3,2,3,3] имеет мажорирующий элемент 3, потому что оно появляется 3>⌊5/2⌋=2 раза, но [1,2,3,4,5] и [1,3,2,3,4] не имеют мажорирующего элемента.</p>

  <p>Скибидус нашел дерево∗ из n вершин и массив a длиной n. Вершина i имеет значение ai, написанное на ней, где ai — это целое число в диапазоне [1,n].</p>

  <p>Для каждого i от 1 до n определите, существует ли нетривиальный простой путь†
  такой, что i является мажорирующим элементом последовательности целых чисел, написанных на вершинах, которые образуют путь.</p>

  <p>* Деревом называется связный граф без циклов.</p>

  <p>† Последовательность вершин v1,v2,...,vm (m≥2) образует нетривиальный простой путь, если vi и vi+1 соединены ребром для всех 1≤i≤m-1 и все vi попарно различны. Обратите внимание, что путь должен состоять как минимум из 2 вершин.</p>

  <h4>Входные данные</h4>
  <p>Каждый тест состоит из нескольких наборов входных данных. В первой строке находится одно целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных. Далее следует описание наборов входных данных.</p>

  <p>Первая строка каждого набора содержит одно целое число n (2 ≤ n ≤ 5⋅10⁵)  — количество вершин.</p>

  <p>Вторая строка каждого набора содержит a1,a2,…,an (1 ≤ ai ≤ n)  — целые числа, написанные на вершинах.</p>

  <p>Каждая из следующих n-1 строк содержит два целых числа ui и vi, обозначающих две вершины, соединенные ребром (1≤ui,vi≤n, ui≠vi).</p>

  <p>Гарантируется, что данные ребра образуют дерево.</p>

  <p>Гарантируется, что сумма n по всем тестам не превышает 5⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого теста выведите двоичную строку s длиной n на отдельной строке. si должно вычисляться следующим образом:</p>
  <ul>
    <li>Если существует нетривиальный путь, содержащий i как мажорирующий элемент, то si равно '1';</li>
    <li>В противном случае si равно '0'.</li>
  </ul>

  <h4>Пример</h4>
<pre>
4
3
1 2 3
1 3
2 3
4
3 1 1 3
1 2
2 3
4 2
4
2 4 4 2
1 2
2 3
3 4
13
1 4 4 7 4 7 1 1 7 11 11 11 11
1 2
2 3
3 4
4 5
4 6
2 7
7 8
2 9
6 10
5 11
11 12
10 13
</pre>
<pre>
000
1010
0001
1001001000100
</pre>
  <p>В первом примере нет нетривиального пути с 1, 2 или 3 в качестве мажорирующего элемента, поэтому выводимая двоичная строка — «000».</p>

  <p>Во втором примере 1→2→4 — это нетривиальный путь с 3 в качестве мажорирующего элемента.</p>

  <details>
    <summary>Решение</summary>
    <p>Необходимо догадаться, что если существует путь длины n с мажорирующим элементом, то из него можно взять подпуть (кусок) состоящий из двух или трех вершин, такой что он тоже будет мажорирующим. догадавшись до этой идеи необходимо быстро научиться проверять пути длины 1 ребро и длины 2 ребра на мажорирование. проверка ребра на мажорирование означает что вершины в ребре имеют одинаковое значение. для проверки путей длины 3 будем проверять их через вершину в середине, пробежавшись по ее соседям</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;iomanip&gt;

using namespace std;

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  int test;
  cin >> test;
  for (int t = 0; t &lt; test; t++) {
    int n;
    cin >> n;
    vector&lt;int&gt; A(n + 1);//считали значения в вершинах
    for (int i = 1; i &lt;= n; i++) {
      cin >> A[i];
    }

    // результирующий вектор, если Res[i]==1
    // значит существует путь такой что
    // набор значений в вершинах пути мажорируется i
    vector&lt;int&gt; Res(n + 1);
    vector&lt;vector&lt;int&gt; &gt; G(n + 1);//список смежности
    int x, y;
    for (int i = 0; i &lt; n - 1; i++) {
      cin >> x >> y;
      G[x].push_back(y);
      G[y].push_back(x);
      if (A[x] == A[y]) {//проверка ребра
        Res[A[x]] = 1;
      }
    }

    //подсчет соседей для каждой вершины
    vector&lt;int&gt; Count(n + 1);
    for (int i = 1; i &lt;= n; i++) {
      for (int j = 0; j &lt; G[i].size(); j++) {
        Count[A[G[i][j]]]++;

        // если вдруг у вершины i окажется два
        // соседа G[i][j] с одинаковым значением
        if (Count[A[G[i][j]]] == 2) {
          // то мы можем собрать длину пути 3 G[i][j1] i G[i][j2]
          // такую что в ней будет мажорирующий элемент A[G[i][j1]]
          Res[A[G[i][j]]] = 1;
        }
      }

      //подчистим обратно массив
      for (int j = 0; j &lt; G[i].size(); j++) {
        Count[A[G[i][j]]]--;
      }
    }

    //вывели ответ
    for (int i = 1; i &lt;= n; i++) {
      cout &lt;&lt; Res[i];
    }
    cout &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача G. Скибидус и ложь -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача G. Скибидус и ложь</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Скибидус был похищен инопланетянами с Амога! Скибидус пытается выкрутиться, но инопланетяне с Амога не верят ему. Чтобы доказать, что он не врет, инопланетяне с Амога попросили его решить эту задачу:</p>

  <p>Целое число x считается полупростым, если его можно записать в виде p⋅q, где p и q — (не обязательно разные) простые числа. Например, 9 является полупростым, так как его можно записать как 3⋅3, а 3 является простым числом.</p>

  <p>Скибидусу был дан массив a, содержащий n целых чисел. Он должен сообщить количество пар (i,j) таких, что i≤j и lcm(ai,aj) * является полупростым.</p>

  <p>* Для двух целых чисел x и y, lcm(x,y) обозначает наименьшее общее кратное x и y.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит целое число n (2 ≤ n ≤ 2⋅10⁵).</p>

  <p>Следующая строка содержит n целых чисел a1,a2,…,an (2 ≤ ai ≤ n).</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите количество упорядоченных пар индексов на новой строке.</p>

  <h4>Пример</h4>
<pre>
3
4
2 2 3 4
6
2 2 3 4 5 6
9
2 2 4 5 7 8 9 3 5
</pre>
<pre>
5
12
18
</pre>
  <p>В первом наборе входных данных 5 пар индексов: (1,3), (1,4), (2,3), (2,4) и (4,4).</p>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;algorithm&gt;

using ll = long long;

using namespace std;

// вектор в которм 1 значит чсило простое,
// 2 если оно квадарат простого, 3 если это куб
// простого или оно полупростоеи любое
// другое значение для других вариантов
vector&lt;ll&gt; p(2e5, 1);

// функция для каждого теста
void solve() {
	ll n;
	cin >> n;
	vector&lt;ll&gt; a(n);
	for (int i = 0; i &lt; n; i++)
		cin >> a[i];

	ll an = 0;//ответ

  // мэп в которм храним скольок раз встретили текущее число
	map&lt;ll, ll&gt; q;

  // количество простых которые мы уже обработали
	ll col = 0;

  // отсортируем начльные числа чтоб простые
	// шли до чисел котрые они делят
	sort(a.begin(), a.end());
	for (int i = 0; i &lt; n; i++)
	{
    // сюда запишем делители числа a[i]
		vector&lt;ll&gt; t;
		for (ll j = 2; j * j &lt;= a[i]; j++)
		{
			if (a[i] % j == 0)
			{
				t.push_back(j);
				t.push_back(a[i] / j);
			}
		}
		if (p[a[i]] == 1)
		{
			// число простое, а значит к нему в пару подойдут
			// только простые которые мы обработали
			// (заметим что до него нет чисел которые делились
			// на него поэтому полупростых которыве на него делятся нет)
			an += col - q[a[i]];
			col++;
			q[a[i]]++;
		} else
		{
			if (p[a[i]] == 2)
			{
				// число квадарат простого, а значит попдойдут
				// такие же как оно, а также все эти простые числа
				an += q[t[0]];
				q[a[i]]++;
				an += q[a[i]];
			} else
			{
				if (t.size() == 2 && p[t[0]] == 1 && p[t[1]] == 1)
				{
					// сейчас у нас два делителя у числа а значит
					// оно уже не лучше чем полупростое
					// полупростое оно если оба его делителя простые
					// если это так тогда нам подойдут оба этих простыхи само число
					an += q[t[0]];
					an += q[t[1]];
					q[a[i]]++;
					an += q[a[i]];
				}
			}

		}
	}
	cout &lt;&lt; an &lt;&lt; endl;
}

int main()
{

	ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	ll t = 1;
	cin >> t;
	//решето эратосфена для заполнения глобального вектора
	for (int i = 2; i &lt; p.size(); i++)
	{

		for (int j = 2 * i; j &lt; p.size(); j += i)
			p[j] += p[i];

	}
	while (t--)
	{
		solve();
	}
}
</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Неправильный ответ на тесте 2</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  vector&lt;long long&gt; Count(1000000);
  vector&lt;long long&gt; Count2(1000000);

  // наборы тестов
  int t;
  cin >> t;

  while (t--) {
    // входные данные
    int n;
    cin >> n;

    // решение
    long long res = 0;
    vector&lt;long long&gt; Elem(n);
    int count_simple = 0;
    for (int i = 0; i &lt; n; i++) {
      cin >> Elem[i];
      int z = 0;
      int tmp = Elem[i];
      vector&lt;int&gt; F;
      for (long long j = 2; j * j &lt;= tmp; j++) {
        while (tmp % j == 0) {
          z++;
          tmp /= j;
          F.push_back(j);
        }
      }
      if (tmp > 1) {
        z++;
        F.push_back(tmp);
      }
      tmp = Elem[i];
      if (z == 1) {
        res += count_simple - Count[tmp];
        res += Count2[tmp];
        Count[tmp]++;
        count_simple++;
      }
      if (z == 2) {
        res++;
        if (F[0] == F[1]) {
          res += Count2[F[0]];
          res += Count[F[0]];
          Count2[tmp]++;
          Count2[F[0]]++;
        } else {
          res += Count[F[0]];
          res += Count[F[1]];
          res += Count2[tmp];
          Count2[tmp]++;
          Count[F[0]]++;
          Count[F[1]]++;
        }
      }
    }
    cout &lt;&lt; res &lt;&lt; '\n';

    for (int i = 0; i &lt; n; i++) {
      int z = 0;
      int tmp = Elem[i];
      vector&lt;int&gt; F;
      for (long long j = 2; j * j &lt;= tmp; j++) {
        while (tmp % j == 0) {
          z++;
          tmp /= j;
          F.push_back(j);
        }
      }
      if (tmp > 1) {
        z++;
        F.push_back(tmp);
      }
      tmp = Elem[i];
      if (z == 1) {
        Count[tmp]--;
      }
      if (z == 2) {
        if (F[0] == F[1]) {
          Count2[tmp]--;
          Count2[F[0]]--;
        } else {
          Count2[tmp]--;
          Count[F[0]]--;
          Count[F[1]]--;
        }
      }
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача H. Бро считает себя избранным -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача H. Бро считает себя избранным</h3>

  <div><i>Ограничение по времени 3с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Скибидус думает, что он избранный! Он доказал это, решив эту сложную задачу. Сможете ли вы?</p>

  <p>Дана двоичная строка∗ t, f(t) определяется как минимальное количество смежных подстрок, каждая из которых состоит из одинаковых символов, на которые можно разбить t. Например, f(00110001)=4, потому что t можно разбить как [00][11][000][1], где каждый сегмент в скобках состоит из одинаковых символов.</p>

  <p>Скибидус даёт вам двоичную строку s и q запросов. В каждом запросе один символ строки переворачивается (т.е. 0 меняется на 1, а 1 меняется на 0), изменения сохраняются после обработки запроса. После каждого запроса выведите сумму по всем f(b), где b — это непустая подпоследовательность† строки s, по модулю 998244353.</p>

  <p>* Двоичная строка состоит только из символов 0 и 1.</p>

  <p>† Подпоследовательность строки — это строка, которую можно получить, удалив несколько (возможно, ноль) символов из оригинальной строки.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора содержит двоичную строку s (1 ≤ |s| ≤ 2⋅10⁵).</p>

  <p>Следующая строка каждого набора содержит целое число q (1 ≤ q ≤ 2⋅10⁵) — количество запросов.</p>

  <p>Следующая строка содержит q целых чисел v1,v2,…,vq (1 ≤ vi ≤ |s|), обозначающих, что svi переворачивается в i-м запросе.</p>

  <p>Гарантируется, что сумма |s| и сумма q по всем наборам входных данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите q целых чисел в одной строке — ответ после каждого запроса по модулю 998244353.</p>

  <h4>Пример</h4>
<pre>
3
101
2
1 3
10110
3
1 2 3
101110101
5
7 2 4 4 1
</pre>
<pre>
10 7
61 59 67
1495 1169 1417 1169 1396
</pre>
  <p>В первом тестовом случае s становится 001 после первого запроса. Давайте посчитаем ответ для каждой подпоследовательности:</p>
  <ul>
    <li>f(s1)=f(0)=1</li>
    <li>f(s2)=f(0)=1</li>
    <li>f(s3)=f(1)=1</li>
    <li>f(s1s2)=f(00)=1</li>
    <li>f(s1s3)=f(01)=2</li>
    <li>f(s2s3)=f(01)=2</li>
    <li>f(s1s2s3)=f(001)=2</li>
  </ul>
  <p>Сумма этих значений равна 10, по модулю 998244353.</p>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

using namespace std;

using ll = long long;

string s;
ll mod = 998244353;

// бинарное возведение по модулю
ll bin_pow_m(ll x, ll y, ll mod) {
	if (y == 0)
		return 1;
	if (y == 1)
	{
		return x % mod;
	}
	if (y % 2)
	{
		return (bin_pow_m(x, y - 1, mod) * x) % mod;
	} else
	{

		return bin_pow_m(x * x % mod, y / 2, mod);;
	}
}

// узел кодирующий информацию про все
// подпоследовательности какой-то подстроки
struct node
{
  //сумарное значение функции данной
	// подстроки по всем подпоследовательностям
	ll an = 0;
  //колчество подпоследовательностей строки вида (0..0, 0..1, 1..0, 1..1)
	ll c00 = 0, c01 = 0, c10 = 0, c11 = 0;
	ll ras = 0;//длина текущей подстроки
};

// функция сливающая две соседние подстроки левую(а) и првую(b)
node merg(node a, node b)
{
	node c;//будущий результат

  //размер результирующей подстроки это сумма размеров дочерних
	c.ras = b.ras + a.ras;

	// пересчет ответа для результирующей подстроки
	// все результаты строки а дадут свое занчение
	// с любой подпоследовательностей строки b и наоборт
	//  с небольшим исключением которое обработаем позже
	// количество подпоследовательностей строки t это 2^k, где  k - это размер строки t
	c.an = (c.an + a.an * bin_pow_m(2, b.ras, mod) % mod) % mod;
	c.an = (c.an + b.an * bin_pow_m(2, a.ras, mod) % mod) % mod;

	// исключение
	// самый первый символ строки b может не дать +1
	// в том случае если последний символ
	// подпоследовательности сроки а равен ему
	// тогда учитывая что мы знаем количество каждого вида
	// подпоследовательности прочто вычтем эти варианты
	c.an = (c.an + mod - a.c00 * b.c00 % mod) % mod;
	c.an = (c.an + mod - a.c00 * b.c01 % mod) % mod;
	c.an = (c.an + mod - a.c10 * b.c00 % mod) % mod;
	c.an = (c.an + mod - a.c10 * b.c01 % mod) % mod;
	c.an = (c.an + mod - a.c01 * b.c10 % mod) % mod;
	c.an = (c.an + mod - a.c01 * b.c11 % mod) % mod;
	c.an = (c.an + mod - a.c11 * b.c10 % mod) % mod;
	c.an = (c.an + mod - a.c11 * b.c11 % mod) % mod;

	//пересчет количества каждой подпоследовательности новой подстроки
	c.c00 = (a.c00 + b.c00) % mod;
	c.c00 = (c.c00 + a.c00 * b.c00 % mod) % mod;
	c.c00 = (c.c00 + a.c00 * b.c10 % mod) % mod;
	c.c00 = (c.c00 + a.c01 * b.c00 % mod) % mod;
	c.c00 = (c.c00 + a.c01 * b.c10 % mod) % mod;

	c.c01 = (a.c01 + b.c01) % mod;
	c.c01 = (c.c01 + a.c00 * b.c01 % mod) % mod;
	c.c01 = (c.c01 + a.c00 * b.c11 % mod) % mod;
	c.c01 = (c.c01 + a.c01 * b.c01 % mod) % mod;
	c.c01 = (c.c01 + a.c01 * b.c11 % mod) % mod;

	c.c10 = (a.c10 + b.c10) % mod;
	c.c10 = (c.c10 + a.c11 * b.c00 % mod) % mod;
	c.c10 = (c.c10 + a.c11 * b.c10 % mod) % mod;
	c.c10 = (c.c10 + a.c10 * b.c00 % mod) % mod;
	c.c10 = (c.c10 + a.c10 * b.c10 % mod) % mod;

	c.c11 = (a.c11 + b.c11) % mod;
	c.c11 = (c.c11 + a.c11 * b.c11 % mod) % mod;
	c.c11 = (c.c11 + a.c11 * b.c01 % mod) % mod;
	c.c11 = (c.c11 + a.c10 * b.c11 % mod) % mod;
	c.c11 = (c.c11 + a.c10 * b.c01 % mod) % mod;
	return c;
}

// теперь умея легко соеденять строки используя
// узлы построим на них обычное дерево отрезков
vector&lt;node&gt; tree;

void build(ll id, ll tl, ll tr) {
	if (tl + 1 == tr)//если в листе
	{
		tree[id].an = 1;
		tree[id].ras = 1;
    // в зависимости от символа в этой позиции
		// устанавливаем ту самую единственную подпоследовательность
		if (s[tl] == '0')
		{
			tree[id].c00 = 1;

		} else
			tree[id].c11 = 1;
		return;
	}
	//если нет то считаем детей и получем текущий узел их слиянием
	ll mid = tl + tr >> 1;
	build(id * 2, tl, mid);
	build(id * 2 + 1, mid, tr);
	tree[id] = merg(tree[id * 2], tree[id * 2 + 1]);
}

//обновить лист
void upd(ll id, ll tl, ll tr, ll x) {
  //если мы в листе меняем его на новое значение
	if (tl + 1 == tr)
	{
		tree[id].an = 1;
		tree[id].c11 = 0;
		tree[id].c00 = 0;
		if (s[tl] == '0')
		{
			tree[id].c00 = 1;

		} else
			tree[id].c11 = 1;
		return;
	}
	//если нет то определяем в каком из сыновей нужный лист лежит
	ll mid = tl + tr >> 1;
	if (mid > x)
		upd(id * 2, tl, mid, x);
	else
		upd(id * 2 + 1, mid, tr, x);
	//обновляем текущий узел
	tree[id] = merg(tree[id * 2], tree[id * 2 + 1]);
}

//функция для каждого теста
void solve() {
	cin >> s;
	ll n;
	n = s.size();
	ll m;
	cin >> m;
	tree.clear();
	tree.resize(4 * n);
	build(1, 0, n);

  // для каждого запроса меняем нужный элемент
	// и выводим первый узел который хранит нужный ответ для все строки
	while (m--)	{
		ll x;
		cin >> x;
		x--;
		if (s[x] == '0')
			s[x] = '1';
		else
			s[x] = '0';
		upd(1, 0, n, x);
		cout &lt;&lt; tree[1].an &lt;&lt; ' ';
	}
	cout &lt;&lt; endl;
}

int main() {
	ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	ll t = 1;
	cin >> t;

	while (t--)
	{
		solve();
	}
}
</pre>
  </details>
</article>

