<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p>ЯрГУ. Кружок. Контесты</p>
  <p>Автор кружка Игорь Маслеников</p>
</article>


<article class="article">
  <h1>Контест Round 1020 (Div.3)</h1>
  <p><a href="https://codeforces.com/contest/2106" target="_blank">Codeforces Round 1020 (Div.3)</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
        <a href="#task1">Задача A. Доктор ТС</a>
    <br><a href="#task2">Задача B. Св. Хрома</a>
    <br><a href="#task3">Задача C. Черри Бомб</a>
    <br><a href="#task4">Задача D. Цветочный мальчик</a>
    <br><a href="#task5">Задача E. Волк</a>
    <br><a href="#task6">Задача F. Гоблин</a>
    <br><a href="#task7">Задача G1. Бодлер (простая версия)</a>
    <br><a href="#task8">Задача G2. Бодлер (сложная версия)</a>
  </p>
</article>


<!-- Задача A. Доктор ТС -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Доктор ТС</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Чтобы проверить интеллект своих пациентов, доктор ТС создал следующий тест.</p>

  <p>Сначала он создает двоичную строку∗ s длиной n символов. Затем он создает n двоичных строк a₁, a₂, ... , aₙ. Известно, что ai создается путем копирования s, а затем инвертирования i-го символа (1 становится 0 и наоборот). После создания всех n строк он располагает их в сетке, где i-я строка — это aᵢ.</p>

  <p>Например,</p>
  <ul>
    <li>Если s=101, то a=[001,111,100].</li>
    <li>Если s=0000, то a=[1000,0100,0010,0001].</li>
  </ul>

  <p>Пациенту нужно подсчитать количество 1, написанных на доске, менее чем за секунду. Сможете ли вы пройти тест?</p>

  <p>* Двоичная строка — это строка, которая состоит только из символов 1 и 0.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных состоит из одного целого числа t (1 ≤ t ≤ 1000) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит одно целое число n (1 ≤ n ≤ 10) — длину двоичной строки s.</p>

  <p>Вторая строка каждого набора входных данных содержит одну двоичную строку s длины n.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно целое число — количество 1 на доске.</p>

  <h4>Пример</h4>
<pre>
5
3
101
1
1
5
00000
2
11
3
010
</pre>
<pre>
5
0
5
2
4
</pre>
  <p>Первый пример объяснен в условии.</p>

  <p>Во втором примере единственной строкой, написанной на доске, будет строка 0, поэтому ответ — 0.</p>

  <p>В третьем примере на доске будут написаны следующие строки: [10000,01000,00100,00010,00001], так что на доске написано пять 1.</p>
</article>


<!-- Задача B. Св. Хрома -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Св. Хрома</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Дана перестановка∗
  p
  длины n, которая содержит каждое целое число от 0 до n-1, и полоса из n ячеек. Св. Хрома будет окрашивать i-ю ячейку полосы в цвет MEX(p₁, p₂, ... , pᵢ)†.</p>

  <p>Например, пусть p=[1,0,3,2]. Тогда Св. Хрома будет окрашивать ячейки полосы следующим образом: [0,2,2,4].</p>

  <p>Вам даны два целых числа n и x. Поскольку Св. Хрома любит цвет x, постройте перестановку p, чтобы количество ячеек в полосе, окрашенных в цвет x, было максимально.</p>

  <p>* Перестановка длины n — это последовательность из n элементов, содержащая каждое целое число от 0 до n-1 ровно один раз. Например, [0,3,1,2] является перестановкой, но [1,2,0,1] не является таковой, поскольку 1 встречается дважды, а [1,3,2] не является таковой, поскольку 0 вообще не встречается.</p>

  <p>† Функция MEX для последовательности определяется как первое неотрицательное целое число, которое в ней не встречается. Например, MEX(1,3,0,2)=4, а MEX(3,1,2)=0.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит одно целое число t (1 ≤ t ≤ 4000) — количество наборов входных данных.</p>

  <p>Единственная строка каждого набора входных данных содержит два целых числа n и x (1 ≤ n ≤ 2⋅10⁵, 0 ≤ x ≤ n) — количество ячеек и цвет, который вы хотите максимизировать.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Выведите перестановку p длины n, чтобы количество ячеек в полосе, окрашенных в цвет x, было максимально. Если существует несколько таких перестановок, выведите любую из них.</p>

  <h4>Пример</h4>
<pre>
7
4 2
4 0
5 0
1 1
3 3
1 0
4 3
</pre>
<pre>
1 0 3 2
2 3 1 0
3 2 4 1 0
0
0 2 1
0
1 2 0 3
</pre>
  <p>Первый пример объясняется в условии. Можно показать, что 2 — это максимальное количество ячеек, которые могут быть окрашены в цвет 2. Обратите внимание, что другим правильным ответом будет перестановка [0,1,3,2].</p>

  <p>Во втором примере перестановка дает раскраску [0,0,0,4], так что 3 ячейки окрашены в цвет 0, можно показать, что это максимум.</p>
</article>


<!-- Задача C. Черри Бомб -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Черри Бомб</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Два целых массива a и b размером n являются дополняющими, если существует целое число x, такое что aᵢ + bᵢ = x для всех 1 ≤ i ≤ n. Например, массивы a=[2,1,4] и b=[3,4,1] являются дополняющими, поскольку aᵢ + bᵢ = 5 для всех 1 ≤ i ≤ 3. Однако массивы a=[1,3] и b=[2,1] не являются дополняющими.</p>

  <p>Коровка Нерд считает, что всем интересна математика, поэтому она дала Черри Бомб два массива целых чисел a и b. Известно, что a и b оба содержат n неотрицательных целых чисел, не превосходящих k.</p>

  <p>К сожалению, Черри Бомб потеряла некоторые элементы в b. Потерянные элементы в b обозначены как -1. Помогите Черри Бомб подсчитать количество возможных массивов b, таких что:</p>
  <ul>
    <li>a и b являются дополняющими.</li>
    <li>Все потерянные элементы заменены неотрицательным целым числом не более k.</li>
  </ul>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит одно целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит два целых числа n и k (1 ≤ n ≤ 2⋅10⁵, 0 ≤ k ≤ 10⁹) — размер массивов и максимальное возможное значение их элементов.</p>

  <p>Вторая строка содержит n целых чисел a₁, a₂, ... , aₙ (0 ≤ aᵢ ≤ k).</p>

  <p>Третья строка содержит n целых чисел b₁, b₂, ... , bₙ (-1 ≤ bᵢ ≤ k). Если bi = -1, то этот элемент отсутствует.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Выведите ровно одно целое число, количество способов, которыми Черри Бомб может заполнить отсутствующие элементы из b, так что a и b являются дополняющими.</p>

  <h4>Пример</h4>
<pre>
7
3 10
1 3 2
-1 -1 1
5 1
0 1 0 0 1
-1 0 1 0 -1
5 1
0 1 0 0 1
-1 1 -1 1 -1
5 10
1 3 2 5 4
-1 -1 -1 -1 -1
5 4
1 3 2 1 3
1 -1 -1 1 -1
5 4
1 3 2 1 3
2 -1 -1 2 0
5 5
5 0 5 4 3
5 -1 -1 -1 -1
</pre>
<pre>
1
0
0
7
0
1
0
</pre>
  <p>В первом примере единственный способ заполнить отсутствующие элементы в b, чтобы a и b были дополняющими, это если b=[2,0,1].</p>

  <p>Во втором примере нет способа заполнить отсутствующие элементы в b, чтобы a и b были дополняющими.</p>

  <p>В четвертом примере некоторые массивы b, которые являются дополняющими к a: [4,2,3,0,1],[7,5,6,3,4], и [9,7,8,5,6].</p>
</article>


<!-- Задача D. Цветочный мальчик -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Цветочный мальчик</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У цветочного мальчика есть сад из n цветов, которые можно представить в виде последовательности целых чисел a₁, a₂, ... , aₙ, где aᵢ — это красота i-го цветка слева.</p>

  <p>Игорь хочет собрать ровно m цветов. Для этого он будет проходить по саду слева направо и выбирать, собирать ли цветок на текущей позиции. Среди собранных цветов, i-й цветок должен иметь красоту не менее bᵢ.</p>

  <p>Игорь заметил, что может быть невозможно собрать m цветов, которые соответствуют его требованиям по красоте, поэтому перед тем, как он начнет собирать цветы, он может выбрать любое целое число k и с помощью своей волшебной палочки вырастить новый цветок с красотой k и разместить его в любом месте в саду (между двумя соседними цветами, перед первым цветком или после последнего цветка). Поскольку его магические способности ограничены, он может сделать это не более одного раза.</p>

  <p>Выведите минимальное целое число k, которое Игорь должен выбрать, когда он выполняет вышеупомянутую операцию, чтобы гарантировать, что он сможет собрать m цветов. Если он может собрать m цветов без использования операции, выведите 0. Если собрать m цветов невозможно, даже используя операцию, выведите -1.</p>

  <h4>Входные данные</h4>
  <p>Первая строка ввода содержит одно целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора содержит ровно два целых числа n и m (1 ≤ m ≤ n ≤ 2⋅10⁵) — количество цветов в саду и количество цветов, которые Игорь хочет собрать, соответственно.</p>

  <p>Вторая строка каждого набора содержит n целых чисел a₁, a₂, ... , aₙ (1 ≤ aᵢ ≤ 10⁹) — где aᵢ — это красота i-го цветка слева в саду.</p>

  <p>Третья строка каждого набора содержит m целых чисел b₁, b₂, ... , bₘ (1 ≤ bᵢ ≤ 10⁹) — где bᵢ — это минимальная красота, которую должен иметь i-й цветок, который Игорь соберет.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите минимальное целое число k, которое Игорь должен выбрать при выполнении операции, чтобы гарантировать, что он сможет собрать m цветов. Если он может собрать m цветов без использования операции, выведите 0. Если собрать m цветов невозможно, даже используя операцию, выведите -1.</p>

  <h4>Пример</h4>
<pre>
7
9 5
3 5 2 3 3 5 8 1 2
4 6 2 4 6
6 3
1 2 6 8 2 1
5 4 3
5 3
4 3 5 4 3
7 4 5
6 3
8 4 2 1 2 5
6 1 4
5 5
1 2 3 4 5
5 4 3 2 1
6 3
1 2 3 4 5 6
9 8 7
5 5
7 7 6 7 7
7 7 7 7 7
</pre>
<pre>
6
3
7
0
-1
-1
7
</pre>
  <p>В первом примере предположим, что Игорь вырастит цветок с красотой 6 и разместит его между третьим и четвертым цветками. Тогда сад будет выглядеть следующим образом: [3,5,2,6,3,3,5,8,1,2]. Затем он может выбрать второй, четвертый, шестой, седьмой и восьмой цветки с красотами [5,6,3,5,8].</p>

  <p>В третьем примере он может вырастить цветок с красотой 7 и разместить его перед первым цветком. Сад будет выглядеть следующим образом: [7,4,3,5,4,3]. Теперь он может выбрать первый, второй и четвертый цветки.</p>

  <p>В четвертом примере Игорю не нужно использовать операцию, поэтому ответ равен 0.</p>

  <p>В шестом примере, независимо от того, как Игорь выполнит операцию, он не сможет собрать 3 цветка, так чтобы i-й цветок, который он соберет, имел красоту не менее bi, поэтому ответ равен -1.</p>
</article>


<!-- Задача E. Волк -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Волк</h3>

  <div><i>Ограничение по времени 4с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Волк нашел n овец с значениями вкусности p₁, p₂, ... , pₙ, где p — это перестановка∗. Волк хочет выполнить бинарный поиск по p, чтобы найти овцу с вкусностью k, но p может быть не отсортирован. Успех бинарного поиска в диапазоне [l,r] для k обозначается как f(l,r,k), которое определяется следующим образом:</p>

  <p>Если l>r, то f(l,r,k) неудачен. В противном случае, пусть m=⌊(l+r)/2⌋, и:</p>
  <ul>
    <li>Если pₘ = k, то f(l,r,k) успешен,</li>
    <li>Если pₘ &lt; k, то f(l,r,k)=f(m+1,r,k),</li>
    <li>Если pₘ > k, то f(l,r,k)=f(l,m-1,k).</li>
  </ul>

  <p>Корова Нерд решает помочь Волку. Корова Нерд получает q запросов, каждый из которых состоит из трех целых чисел l, r и k. Перед началом поиска Корова Нерд может выбрать неотрицательное целое число d и d индексов 1 ≤ i₁ &lt; i₂ &lt; ... &lt; i<sub>d</sub> ≤ n, где p<sub>ij</sub> ≠ k для всех 1 ≤ j ≤ d. Затем она может переупорядочить элементы p<sub>i1</sub>, p<sub>i2</sub>, ... , p<sub>id</sub> так, как ей нравится.</p>

  <p>Для каждого запроса выведите минимальное целое число d, которое Корова Нерд должна выбрать, чтобы f(l,r,k) мог быть успешен, или сообщите, что это невозможно. Обратите внимание, что запросы независимы, и переупорядочивание на самом деле не выполняется.</p>

  <p>* Перестановка длины n — это массив, который содержит каждое целое число от 1 до n ровно один раз.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит одно целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора содержит два целых числа n и q (1 ≤ n, q ≤ 2⋅10⁵) — длина p и количество запросов соответственно.</p>

  <p>Вторая строка каждого набора содержит n целых чисел p₁, p₂, ... , pₙ — вкусность i-й овцы. Гарантируется, что каждое целое число от 1 до n появляется ровно один раз в p.</p>

  <p>Следующие q строк содержат три целых числа l, r и k (1 ≤ l ≤ r ≤ n, 1 ≤ k ≤ n) — диапазон, в котором будет выполняться бинарный поиск, и целое число, которое ищется для каждого запроса.</p>

  <p>Гарантируется, что сумма n и сумма q по всем наборам входных данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого запроса выведите минимальное целое число d, которое Корова Нерд должна выбрать, чтобы f(l,r,k) был успешен. Если это невозможно, выведите -1.</p>

  <h4>Пример</h4>
<pre>
8
5 3
1 2 3 4 5
1 5 4
1 3 4
3 4 4
7 4
3 1 5 2 7 6 4
3 4 2
2 3 5
1 5 6
1 7 3
2 1
2 1
1 2 1
1 1
1
1 1 1
7 1
3 4 2 5 7 1 6
1 7 1
16 1
16 10 12 6 13 9 14 3 8 11 15 2 7 1 5 4
1 16 4
16 1
14 1 3 15 4 5 6 16 7 8 9 10 11 12 13 2
1 16 14
13 1
12 13 10 9 8 4 11 5 7 6 2 1 3
1 13 2
</pre>
<pre>
0 -1 0
2 0 -1 4
-1
0
-1
-1
-1
-1
</pre>
  <p>В первом примере, во втором запросе: Поскольку 4 нет среди первых трех элементов, невозможно найти его при поиске в этом диапазоне.</p>

  <p>Во втором примере, в первом запросе вы можете выбрать индексы 2, 3 и поменять их местами, так что p=[3,5,1,2,7,6,4]. Затем f(3,4,2) будет работать следующим образом:</p>
  <ol>
    <li>Пусть m=⌊(3+4)/2⌋=3. Поскольку p3 = 1 &lt; 2, то f(3,4,2)=f(4,4,2).</li>
    <li>Пусть m=⌊(4+4)/2⌋=4. Поскольку p4 = 2 = k, то f(4,4,2) успешен. Следовательно, f(3,4,2) также успешен.</li>
  </ol>

  <p>Общее количество выбранных индексов составило 2, так что окончательная стоимость равна 2, что можно показать, что это минимум. Обратите внимание, что для этого запроса мы не можем выбрать индекс 4, так как p₄=k=2.</p>

  <p>В последнем запросе второго примера мы можем выбрать индексы 2,3,4,5 и переупорядочить их так, что p=[3,5,2,7,1,6,4]. Затем f(1,7,3) успешен.</p>
</article>


<!-- Задача F. Гоблин -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Гоблин</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>К доктору ТС поступил новый пациент по имени Гоблин. Он хочет проверить интеллект Гоблина, но ему надоели его стандартные тесты. Поэтому он решил сделать тест немного сложнее.</p>

  <p>Сначала, он создает двоичную строку∗ s длиной n символов. Затем, он создает n двоичных строк a₁, a₂, ... , aₙ. Известно, что aᵢ создается путем копирования s, а затем инвертирования i-го символа (1 становится 0 и наоборот). После создания всех n строк, он размещает их в сетке n x n g, где g<sub>i,j</sub> = a<sub>ij</sub>.</p>

  <p>Множество S размером k, содержащее различные пары целых чисел {(x₁,y₁), (x₂,y₂), ... , (xₖ,yₖ)}, считается хорошим, если:</p>
  <ul>
    <li>1 ≤ xᵢ, yᵢ ≤ n для всех 1 ≤ i ≤ k.</li>
    <li>g<sub>xᵢ,yᵢ</sub> = 0 для всех 1 ≤ i ≤ k.</li>
    <li>Для любых двух целых чисел i и j (1 ≤ i, j ≤ k) координата (xᵢ, yᵢ) достижима из координаты (x<sub>j</sub>, y<sub>j</sub>), перемещаясь по соседним клеткам (которые имеют общую сторону), в каждой из которых записано значение 0.</li>
  </ul>

  <p>Задача Гоблина — найти максимальный возможный размер хорошего множества S. Поскольку доктор ТС щедр, на этот раз, он дал ему две секунды, чтобы найти ответ вместо одной. Гоблин известен своей хитростью, поэтому он попросил вас помочь обмануть доктора.</p>

  <p>* Двоичная строка — это строка, состоящая только из символов 1 и 0.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных состоит из одного целого числа t (1 ≤ t ≤ 10³) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора содержит одно целое число n (1 ≤ n ≤ 2⋅10⁵) — длина двоичной строки s.</p>

  <p>Вторая строка каждого набора содержит одну двоичную строку s длиной n.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно число — максимальный возможный размер хорошего множества ячеек из сетки.</p>

  <h4>Пример</h4>
<pre>
6
3
000
4
0010
7
1011001
4
0001
2
11
1
0
</pre>
<pre>
3
9
10
7
1
0
</pre>
  <p>В первом примере на доске записана следующая сетка:</p>
<pre>
100
010
001
</pre>
  <p>Множество, состоящее из ячеек (1,2) и (1,3), является хорошим. Множество, состоящее из ячеек (1,1) и (1,2), не является хорошим, так как значение ячейки (1,1) не равно 0. Множество ячеек (1,2), (1,3), (2,3) является хорошим и имеет максимальный размер 3. Обратите внимание, что множество ячеек (2,1), (3,1) и (3,2) также является хорошим с максимальным размером 3.</p>

  <p>Во втором примере на доске записана следующая сетка:</p>
<pre>
1010
0110
0000
0011
</pre>
  <p>И максимальный возможный размер хорошего множества равен 9.</p>
</article>


<!-- Задача G1. Бодлер (простая версия) -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G1. Бодлер (простая версия)</h3>

  <div><i>Ограничение по времени 3с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Это простая версия задачи. Единственное отличие между двумя версиями заключается в том, что в этой версии гарантируется, что каждая вершина имеет общее ребро с вершиной 1.</p>

  <p>Эта задача является интерактивной.</p>

  <p>Бодлер очень богат, поэтому он купил дерево размером n, корнем которого является произвольная вершина. Кроме того, каждая вершина имеет значение 1 или -1. В этой версии гарантируется, что каждая вершина смежна с вершиной 1. Однако обратите внимание, что вершина 1 не обязательно является корнем.</p>

  <p>Коровка-Нерд увидела дерево и влюбилась в него. Однако компьютерные науки не приносят ей достаточно денег, поэтому она не может позволить себе его купить. Бодлер решил сыграть с Коровкой-Нерд в игру, и если она выиграет, то подарит ей дерево.</p>

  <p>Коровка-Нерд не знает, какая вершина является корнем, и она также не знает значений вершин. Однако она может задавать Бодлеру запросы двух типов:</p>
  <ul>
    <li>1 k u1 u2 ... uk: Пусть f(u) — это сумма значений всех вершин на пути от корня дерева до вершины u. Коровка-Нерд может выбрать целое число k (1≤k≤n) и k вершин u1,u2,...,uk, и она получит значение f(u1)+f(u2)+...+f(uk).</li>
    <li>2 u: Бодлер переключит значение вершины u. В частности, если значение u равно 1, оно станет -1, и наоборот.</li>
  </ul>

  <p>Коровка-Нерд выигрывает, если она правильно угадает значение каждой вершины (значения финального дерева, после выполнения запросов) за n+200 запросов. Можешь помочь ей выиграть?</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит одно целое число t (1 ≤ t ≤ 100), количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит одно целое число n (2 ≤ n ≤ 10³), размер дерева.</p>

  <p>Каждая из следующих n-1 строк содержит два целых числа u и v (1 ≤ u, v ≤ n, u ≠ v), обозначающие ребро между вершинами u и v в дереве. В этой версии гарантируется, что либо u=1, либо v=1.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 10³, и что каждый предоставленный граф является допустимым деревом.</p>

  <h4>Протокол взаимодействия</h4>
  <p>Чтобы задать запрос типа 1, выведите строку в следующем формате (без кавычек):</p>
  <code>"? 1 k u1 u2... uk", (1≤k,ui≤n)</code>

  <p>Жюри вернет одно целое число, f(u1)+f(u2)+...+f(uk).</p>

  <p>Чтобы задать запрос типа 2, выведите строку в следующем формате:</p>
  <code>"? 2 u" (1≤u≤n)</code>

  <p>Жюри переключит значение вершины u: если ее значение равно 1, оно станет -1, и наоборот.</p>

  <p>Когда вы найдете ответ, выведите одну строку в следующем формате:</p>
  <code>"! v1,v2,...,vn" (vi=1 или vi=-1, и vi — это значение вершины i после выполнения запросов)</code>

  <p>После этого продолжайте обрабатывать следующий набор входных данных или завершите программу, если это был последний набор. Печать ответа не считается запросом.</p>

  <p>Интерактор не адаптивен, что означает, что значения дерева известны до того, как участник задаст запросы.</p>

  <p>Если ваша программа сделает более n+200 запросов, ваша программа должна немедленно завершиться, чтобы получить вердикт Неправильный ответ. В противном случае вы можете получить произвольный вердикт, потому что ваше решение продолжит читать из закрытого потока.</p>

  <p>После вывода запроса не забудьте вывести конец строки и сбросить вывод. В противном случае вы можете получить вердикт Превышен лимит бездействия. Для этого используйте:</p>
  <ul>
    <li>fflush(stdout) или cout.flush() в C++</li>
    <li>System.out.flush() в Java;</li>
    <li>flush(output) в Pascal;</li>
    <li>stdout.flush() в Python;</li>
    <li>смотрите документацию для других языков.</li>
  </ul>

  <h4>Хаки</h4>
  <p>Для хаков используйте следующий формат.</p>

  <p>Первая строка должна содержать одно целое число t (1 ≤ t ≤ 100) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных должна содержать ровно два целых числа n и root (2 ≤ n ≤ 10³, 1 ≤ root ≤ n) — размер дерева и корень дерева.</p>

  <p>Вторая строка каждого набора входных данных должна содержать ровно n целых чисел a1,a2,...,an (|ai|=1) — где ai — это значение вершины i.</p>

  <p>Каждая из следующих n-1 строк должна содержать ровно два целых числа u и v (1 ≤ u, v ≤ n) — обозначающие ребро дерева между вершинами u и v.</p>

  <p>Сумма n по всем наборам входных данных не должна превышать 10³, и каждый предоставленный граф должен быть допустимым деревом. Для этой версии каждая вершина должна быть смежна с вершиной 1.</p>

  <h4>Пример</h4>
<pre>
1
4
1 2
3 1
1 4

0


-6

</pre>
<pre>




? 1 3 1 2 3

? 2 2
? 1 3 1 2 3

! -1 -1 -1 1
</pre>
  <p>В примере корень дерева — это вершина 2, а значения вершин равны [-1,1,-1,1]. Поэтому f(1)=0,f(2)=1,f(3)=-1,f(4)=1.</p>

  <p>Сначала мы запрашиваем сумму f(1)+f(2)+f(3), поэтому мы получаем значение 0. Затем мы переключаем значение вершины 2, и значения становятся: [-1,-1,-1,1]. Поэтому f(1)=-2,f(2)=-1,f(3)=-3,f(4)=-1, и f(1)+f(2)+f(3)=-6.</p>

  <p>Наконец, мы понимаем, что значения вершин равны [-1,-1,-1,1], поэтому мы отвечаем на это.</p>

  <p>Обратите внимание, что это всего лишь объяснение того, как работают запросы, и оно не должно использовать какую-либо конкретную стратегию для решения задачи.</p>
</article>


<!-- Задача G2. Бодлер (сложная версия) -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача G2. Бодлер (сложная версия)</h3>

  <div><i>Ограничение по времени 3с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Это сложная версия задачи. Единственное отличие между двумя версиями заключается в том, что в сложной версии дерево может иметь любую форму.</p>

  <p>Эта задача интерактивная.</p>

  <p>Бодлер очень богат, поэтому он купил дерево размером n, корень которого находится в произвольной вершине. Кроме того, каждая вершина имеет значение 1 или -1.</p>

  <p>Коровка-Нерд увидела дерево и влюбилась в него. Однако компьютерные науки не приносят ей достаточно денег, поэтому она не может позволить себе его купить. Бодлер решил сыграть с Коровкой-Нерд в игру, и если она выиграет, он подарит ей дерево.</p>

  <p>Коровка-Нерд не знает, какая вершина является корнем, и она также не знает значений вершин. Однако она может задавать Бодлеру запросы двух типов:</p>
  <ul>
    <li>1 k u1 u2 ... uk: Пусть f(u) — это сумма значений всех вершин на пути от корня дерева до вершины u. Коровка-Нерд может выбрать целое число k (1≤k≤n) и k вершин u1,u2,...,uk, и она получит значение f(u1)+f(u2)+...+f(uk).</li>
    <li>2 u: Бодлер изменит значение вершины u. В частности, если значение u равно 1, оно станет -1, и наоборот.</li>
  </ul>

  <p>Коровка-Нерд выигрывает, если она правильно угадает значение каждой вершины (значения финального дерева, после выполнения запросов) за n+200 запросов. Можете ли вы помочь ей выиграть?</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит одно целое число t (1 ≤ t ≤ 100) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит одно целое число n (2 ≤ n ≤ 10³) — размер дерева.</p>

  <p>Каждая из следующих n-1 строк содержит два целых числа u и v (1 ≤ u, v ≤ n, u ≠ v), обозначающих ребро между вершинами u и v в дереве.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 10³ и что каждый предоставленный граф является деревом.</p>

  <h4>Протокол взаимодействия</h4>
  <p>Чтобы задать запрос типа 1, выведите строку в следующем формате (без кавычек):</p>
  <code>"? 1 k u1 u2 ... uk", (1≤k,ui≤n)</code>

  <p>Жюри вернет одно целое число, f(u1)+f(u2)+...+f(uk).</p>

  <p>Чтобы задать запрос типа 2, выведите строку в следующем формате:</p>
   <code>"? 2 u" (1≤u≤n)</code>

  <p>Жюри изменит значение вершины u: если его значение равно 1, оно станет -1, и наоборот.</p>

  <p>Когда вы найдете ответ, выведите одну строку в следующем формате:</p>
  <code>"! v1,v2,...,vn" (vi=1 или vi=-1, и vi — значение вершины i после выполнения запросов)</code>

  <p>После этого продолжайте обрабатывать следующий набор входных данных или завершите программу, если это был последний набор входных данных. Печать ответа не считается запросом.</p>

  <p>Интерактор не адаптивен, что означает, что значения дерева известны до того, как участник задает запросы.</p>

  <p>Если ваша программа сделает более n+200 запросов, ваша программа должна немедленно завершиться, чтобы получить вердикт Неправильный ответ. В противном случае вы можете получить произвольный вердикт, потому что ваше решение продолжит читать из закрытого потока.</p>

  <p>После вывода запроса не забудьте вывести конец строки и сбросить вывод. В противном случае вы можете получить вердикт Превышен лимит бездействия. Для этого используйте:</p>
  <ul>
    <li>fflush(stdout) или cout.flush() в C++</li>
    <li>System.out.flush() в Java;</li>
    <li>flush(output) в Pascal;</li>
    <li>stdout.flush() в Python;</li>
    <li>смотрите документацию для других языков.</li>
  </ul>

  <h4>Хаки</h4>
  <p>Для хаков используйте следующий формат.</p>

  <p>Первая строка должна содержать одно целое число t (1 ≤ t ≤ 100) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных должна содержать ровно два целых числа n и root (2 ≤ n ≤ 10³, 1 ≤ root ≤ n) — размер дерева и корень дерева.</p>

  <p>Вторая строка каждого набора входных данных должна содержать ровно n целых чисел a1,a2,...,an (|ai|=1) — где ai — значение вершины i.</p>

  <p>Каждая из следующих n-1 строк должна содержать ровно два целых числа u и v (1≤u,v≤n) — обозначающих ребро дерева между вершинами u и v.</p>

  <p>Сумма n по всем наборам входных данных не должна превышать 10³, и каждый предоставленный граф должен быть допустимым деревом.</p>

  <h4>Пример</h4>
<pre>
3
4
1 4
4 2
2 3

1

-1


-5

-5

2
1 2

2

7
1 2
2 7
7 3
7 4
7 5
7 6

-1


</pre>
<pre>




? 1 3 1 2 4

? 1 2 3 1

? 2 4
? 1 3 1 2 4

? 1 2 3 1

! -1 -1 -1 -1


? 1 1 1

! 1 1






? 1 1 1

! -1 1 1 1 1 1 -1
</pre>
  <p>В первом примере корнем дерева является вершина 4, а значения: [-1,-1,-1,1] (значение i-й вершины — это значение вершины i).</p>

  <p>Изначально f(1)=0,f(2)=0,f(3)=-1,f(4)=1. Поэтому ответ на наш первый запрос — это f(1)+f(2)+f(4)=1, а на второй запрос — это f(3)+f(1)=-1.</p>

  <p>После изменения значения вершины 4 значения становятся [-1,-1,-1,-1]. Кроме того, f(1)=-2,f(2)=-2,f(3)=-3,f(4)=-1. Поэтому f(1)+f(2)+f(4)=-5 и f(3)+f(1)=-5.</p>

  <p>Мы отвечаем, что финальные значения вершин равны [-1,-1,-1,-1], что верно. Обратите внимание, что мы сообщаем значения вершин после изменений, а не до.</p>

  <p>Во втором примере корнем дерева является 2, а начальные значения равны [1,1].</p>

  <p>В последнем примере корнем дерева является 1, а начальные значения равны [-1,1,1,1,1,1,-1].</p>

  <p>Обратите внимание, что это всего лишь объяснение того, как работают запросы, и оно не должно использовать какую-либо конкретную стратегию для решения задачи.</p>
</article>

