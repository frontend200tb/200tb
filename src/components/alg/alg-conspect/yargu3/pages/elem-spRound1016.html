<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p>ЯрГУ. Кружок. Контесты</p>
  <p>Автор кружка Игорь Маслеников</p>
</article>


<article class="article">
  <h1>Контест Round 1016 (Div.3)</h1>
  <p><a href="https://codeforces.com/contest/2093" target="_blank">Codeforces Round 1016 (Div.3)</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
        <a href="#task1">Задача A. Идеальный генератор</a>
    <br><a href="#task2">Задача B. Дорогое число</a>
    <br><a href="#task3">Задача C. Простое повторение</a>
    <br><a href="#task4">Задача D. Кайфовая таблица</a>
    <br><a href="#task5">Задача E. Мин макс мех</a>
    <br><a href="#task6">Задача F. Хакеры и нейросети</a>
    <br><a href="#task7">Задача G. Укоротить массив</a>
  </p>
</article>


<!-- Задача A. Идеальный генератор -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Идеальный генератор</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Назовем массив a, состоящий из k положительных целых чисел, палиндромным, если [a1,a2,…,ak]=[ak,ak-1,…,a1]. Например, массивы [1,2,1] и [5,1,1,5] являются палиндромными, а массивы [1,2,3] и [21,12] — нет.</p>

  <p>Назовем число k идеальным генератором, если любое целое число n (n≥k) можно представить в виде суммы элементов палиндромного массива длины ровно k. Все элементы массива должны быть больше 0.</p>

  <p>Например, число 1 является идеальным генератором, потому что любое натуральное число n можно сгенерировать с помощью массива [n]. Число 2 же идеальным генератором не является — для числа 3 не существует палиндромного массива длины 2.</p>

  <p>Определите, является ли данное число k идеальным генератором.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит одно целое число t (1 ≤ t ≤ 1000) — количество наборов входных данных.</p>

  <p>Первая и единственная строка каждого набора содержит одно целое число k (1 ≤ k ≤ 1000).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого числа k вам нужно вывести одно слово «YES», если оно является идеальным генератором, или «NO» в противном случае.</p>

  <p>Вы можете выводить «Yes» и «No» в любом регистре (например, строки «yES», «yes» и «Yes» будут распознаны как положительный ответ).</p>

  <h4>Пример</h4>
<pre>
5
1
2
3
73
1000
</pre>
<pre>
YES
NO
YES
YES
NO
</pre>
</article>


<!-- Задача B. Дорогое число -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Дорогое число</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Стоимостью целого положительного числа n называется частное числа n и суммы его цифр.</p>

  <p>Например, стоимость числа 104 равна 104 / (1+0+4) = 20.8, а стоимость числа 111 равна 111 / (1+1+1) = 37.</p>

  <p>Вам дано целое положительное число n, не содержащее ведущих нулей. Вы можете удалить из числа n любое количество цифр (в том числе ни одной), так чтобы оставшееся число содержало хотя бы одну цифру и осталось строго больше нуля. Оставшиеся цифры нельзя менять местами. При этом в результате у вас может получиться число с ведущими нулями.</p>

  <p>Например, вам дано число 103554. Если вы решите удалить из него цифры 1, 4 и одну цифру 5, то в результате у вас получится число 035, стоимость которого равна 035 / (0+3+5) = 4.375.</p>

  <p>Какое минимальное количество раз нужно удалить цифру из числа, чтобы его стоимость стала минимальной возможной?</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 1000) — количество наборов входных данных.</p>

  <p>Единственная строка каждого набора входных данных содержит целое число n
  (1 ≤ n &lt; 10¹⁰⁰) без ведущих нулей.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно целое число в новой строке — количество цифр, которое нужно удалить из числа, чтобы его стоимость стала минимальной.</p>

  <h4>Пример</h4>
<pre>
4
666
13700
102030
7
</pre>
<pre>
2
4
3
0
</pre>
</article>


<!-- Задача C. Простое повторение -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Простое повторение</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Паша очень любит простые числа∗ ! В очередной раз, в попытках найти новый способ генерации простых чисел, его заинтересовал такой алгоритм, найденный на просторах интернета:</p>
  <ul>
    <li>Взять запись числа x в десятичной системе счисления без ведущих нулей и повторить её k раз, получая новое число y.</li>
  </ul>
  <p>Например, при x=52 и k=3 получится y=525252, а при x=6 и k=7 получится y=6666666.</p>

  <p>Паша очень хочет, чтобы получившееся число y было простым, но пока не знает, как проверять простоту чисел, полученных по этому алгоритму. Помогите Паше и скажите, является ли y простым!</p>

  <p>* Целое число x является простым, если у него есть ровно 2 различных делителя: 1 и x. Например, 13 является простым, потому что имеет всего 2 делителя: 1 и 13. Отметим, что число 1 не является простым, так как имеет всего один делитель.</p>

  <h4>Входные данные</h4>
  <p>Каждый тест состоит из нескольких наборов входных данных. Первая строка содержит одно целое число t (1 ≤ t ≤ 100) — количество наборов входных данных. Далее следуют описания наборов входных данных.</p>

  <p>Первая и единственная строка каждого набора данных содержит два целых числа: x и k (1 ≤ x ≤ 10⁹, 1 ≤ k ≤ 7).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите «YES» (без кавычек), если полученное число y будет простым, и «NO» в противном случае.</p>

  <p>Вы можете выводить «Yes» и «No» в любом регистре (например, строки «yES», «yes» и «Yes» будут распознаны как положительный ответ).</p>

  <h4>Пример</h4>
<pre>
4
52 3
6 7
7 1
1 7
</pre>
<pre>
NO
NO
YES
NO
</pre>
</article>


<!-- Задача D. Кайфовая таблица -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Кайфовая таблица</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вадим обожает заполнять квадратные таблицы целыми числами. Но только сегодня он придумал, как делать это по кайфу! Возьмём, к примеру, таблицу размера 2x2, строки пронумерованы сверху вниз, а столбцы  — слева направо. Поставим 1 в левую верхнюю клетку, 2 — в правую нижнюю, 3 — в левую нижнюю и 4 — в правую верхнюю. Большего для кайфа и не нужно!</p>

  <p>К счастью для Вадима, у него есть таблица размером 2nx2n. Он собирается заполнить её целыми числами от 1 до 22n в порядке возрастания. Чтобы заполнить настолько большую таблицу, Вадим поделит её на 4 равных квадратных таблицы, вначале заполнит левую верхнюю, затем правую нижнюю, после левую нижнюю и в конце правую верхнюю. Каждую меньшую таблицу при их заполнении он будет делить на меньшие до тех пор, пока не дойдёт до табличек размерами 2x2, которые будет заполнять в описанном выше порядке.</p>

  <p>Сейчас Вадим в нетерпении начать заполнять таблицу, но у него есть q вопросов двух видов:</p>
  <ul>
    <li>какое число будет стоять в клетке в x-й строке, y-м столбце;</li>
    <li>в клетке с какими координатами будет стоять число d.</li>
  </ul>
  <p>Помогите ответить Вадиму на каждый из вопросов.</p>

  <h4>Входные данные</h4>
  <p>Каждый тест состоит из нескольких наборов входных данных. Первая строка содержит одно целое число t (1 ≤ t ≤ 10) — количество наборов входных данных. Далее следуют описания наборов входных данных.</p>

  <p>В первой строке каждого набора данных дано целое число n, описывающее размер таблицы (1 ≤ n ≤ 30).</p>

  <p>Во второй строке каждого набора данных дано целое число q — количество вопросов (1 ≤ q ≤ 20000).</p>

  <p>В следующих q строках каждого набора данных описаны вопросы в следующих форматах:</p>
  <ul>
    <li>-> x y  — какое число будет стоять в клетке (1 ≤ x, y ≤ 2ⁿ);</li>
    <li>&lt;- d  — в клетке с какими координатами будет стоять число (1 ≤ d ≤ 2²ⁿ).</li>
  </ul>

  <p>Гарантируется, что сумма q по всем наборам входных данных не превосходит 20000.</p>

  <h4>Выходные данные</h4>
  <p>Выведите ответы на каждый из вопросов в отдельной строке.</p>

  <h4>Пример</h4>
<pre>
2
2
5
-> 4 3
&lt;- 15
&lt;- 4
-> 3 1
-> 1 3
1
8
-> 1 1
-> 1 2
-> 2 1
-> 2 2
&lt;- 1
&lt;- 2
&lt;- 3
&lt;- 4
</pre>
<pre>
7
2 3
1 2
9
13
1
4
3
2
1 1
2 2
2 1
1 2
</pre>
</article>


<!-- Задача E. Мин макс мех -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Мин макс мех</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Дан массив a длины n и число k.</p>

  <p>Подотрезком будем называть последовательность из одного и более подряд идущих элементов массива. Надо разбить массив a на k непересекающихся подотрезков b1,b2,…,bk так, чтобы объединение этих подотрезков было равно всему массиву и при этом x, равное минимальному MEX(bi), i∈[1..k], было наибольшим.</p>

  <p>MEX(v) — обозначает минимальное целое неотрицательное число, которого нет в массиве v.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора содержит два целых числа n, k (1 ≤ k ≤ n ≤ 2⋅10⁵) — длину массива и количество отрезков, на которые надо разбить массив.</p>

  <p>Вторая строка каждого набора содержит n целых чисел aᵢ (0 ≤ aᵢ ≤ 10⁹) — элементы массива.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого запроса выведите одно число  — такое максимальное значение x, что существует разбиение массива a на k подотрезков, при котором минимальный MEX равен x.</p>

  <h4>Пример</h4>
<pre>
7
1 1
0
5 1
0 1 3 2 4
6 2
2 1 0 0 1 2
5 5
0 0 0 0 0
5 2
2 3 4 5 6
6 2
0 0 1 1 2 2
4 4
1 0 0 0
</pre>
<pre>
1
5
3
1
0
1
0
</pre>
</article>


<!-- Задача F. Хакеры и нейросети -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Хакеры и нейросети</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Хакеры опять пытаются составить забавные фразы, используя вывод нейросетей. В этот раз им очень захотелось получить массив строк a длины n.</p>

  <p>Исходно у них есть массив c длины n, заполненный пропусками, которые обозначаются символом *. Таким образом, если n=4, то исходно c=[*,*,*,*].</p>

  <p>У хакеров есть доступ к m нейросетям, у каждой из которых есть свой вариант ответа на их запрос – массив строк bᵢ длины n.</p>

  <p>Хакеры пытаются получить массив a из массива c, используя следующие операции:</p>
  <ol>
    <li>Выбрать нейросеть i, которая проведёт следующую операцию над массивом c: выберет случайный пропуск, например, на позиции j, и заменит c<sub>j</sub> на b<sub>i,j</sub>. Например, если была выбрана первая нейросеть и c=[*,«like»,*], а b₁=[«I»,«love»,«apples»], то после операции с первой нейросетью c может стать равным или [«I»,«like»,*], или [*,«like»,«apples»].</li>
    <li>Выбрать позицию j и заменить c<sub>j</sub> на пропуск.</li>
  </ol>
  <p>К сожалению, из-за особенностей хакерского доступа к нейросетям, хакеры смогут увидеть изменённый массив c только после завершения всех операций, поэтому им придётся заранее задать всю последовательность операций.</p>

  <p>Однако, случайное поведение нейросетей может привести к тому, что нужный массив так и не будет получен, или его получение потребует чрезмерного количества операций, поэтому хакеры рассчитывают на вашу помощь в выборе последовательности операций, которая гарантированно и за минимальное количество операций получит массив a.</p>

  <p>Более формально, если существует последовательность операций, с помощью которой можно гарантированно получить массив a из массива c, то среди всех таких последовательностей найдите ту, в которой минимальное количество операций, и выведите количество операций в ней.</p>

  <p>Если последовательности операций, переводящей массив c в массив a, не существует, то выведите -1.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно целое число t (1 ≤ t ≤ 1000) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит два целых числа n
  и m (1 ≤ n, m ≤ 500) — длину исходного массива a и количество нейросетей соответственно.</p>

  <p>Вторая строка каждого набора входных данных содержит массив a, состоящий из n строк aᵢ (1 ≤ |aᵢ| ≤ 10), разделённых пробелами.</p>

  <p>Следующие m строк каждого набора входных данных содержат массивы bᵢ — по одному в каждой строке, состоящие из n строк b<sub>i,j</sub> (1 ≤ |b<sub>i,j</sub>| ≤ 10), разделённых пробелами.</p>

  <p>Гарантируется, что сумма |aᵢ| и |b<sub>i,j</sub>| по всем тестовым наборам не превышает 2⋅10⁵, а также что сумма n⋅m по всем тестовым наборам также не превышает 2⋅10⁵.</p>

  <p>Гарантируется, что строки, поданные на вход, состоят только из символов латинского алфавита нижнего и верхнего регистра.</p>

  <p>Обратите внимание, что длина каждой отдельной строки из ввода не превышает 10.</p>

  <h4>Выходные данные</h4>
  <p>Выведите t чисел — по одному числу на каждый набор входных данных, каждое в отдельной строке.</p>

  <p>Если существует последовательность операций, позволяющих гарантированно получить массив a из i-го набора данных, то i-е число — количество операций в минимальной такой последовательности.</p>

  <p>Иначе в качестве i-го числа выведите -1.</p>

  <h4>Пример</h4>
<pre>
4
3 3
I love apples
He likes apples
I love cats
They love dogs
3 2
Icy wake up
wake Icy up
wake up Icy
4 3
c o D E
c o D s
c O l S
c o m E
4 5
a s k A
d s D t
O R i A
a X b Y
b a k A
u s k J
</pre>
<pre>
5
-1
6
8
</pre>
</article>


<!-- Задача G. Укоротить массив -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Укоротить массив</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 512мб</i></div>

  <p>Красота массива b длины m равна max(b<sub>i</sub>⊕b<sub>j</sub>) среди всевозможных пар 1 ≤ i ≤ j ≤ m, где x⊕y — это побитовый XOR чисел x и y. Обозначим значение красоты массива b как f(b).</p>

  <p>Массив b называется красивым, если f(b) ≥ k.</p>

  <p>Недавно Костя купил в магазине массив a длины n. Он считает этот массив слишком длинным, поэтому он планирует вырезать из него какой-то красивый подотрезок. То есть он хочет выбрать числа l и r (1 ≤ l ≤ r ≤ n) такие, что массив al…r является красивым. Длиной такого подотрезка будет число r-l+1. Сам массив a целиком так же считается своим подотрезом (l=1 и r=n).</p>

  <p>Вашей задачей будет найти длину кратчайшего красивого подотрезка в массиве a. Если никакой подотрезок не является красивым, вы должны вывести число -1.</p>

  <h4>Входные данные</h4>
  <p>В первой строке дано количество тестов t (1 ≤ t ≤ 10⁴).</p>

  <p>Далее идут t блоков по две строки:</p>

  <p>В первой строке блока даны два целых числа n и k (1 ≤ n ≤ 2⋅10⁵, 0 ≤ k ≤ 10⁹).</p>

  <p>Во второй строке блока дан массив a из n целых чисел (0 ≤ aᵢ ≤ 10⁹).</p>

  <p>Гарантируется, что сумма n по всем тестам не превосходит 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого теста нужно вывести одно целое число — минимальную длину отрезка (l,r), для которого f(al…r) ≥ k. Если такого отрезка не нашлось, нужно вывести -1.</p>

  <h4>Пример</h4>
<pre>
6
5 0
1 2 3 4 5
5 7
1 2 3 4 5
5 8
1 2 3 4 5
5 7
3 5 1 4 2
5 3
3 5 1 4 2
6 71
26 56 12 45 60 27
</pre>
<pre>
1
2
-1
4
2
-1
</pre>
</article>

