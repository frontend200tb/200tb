<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p>ЯрГУ. Кружок. Контесты</p>
  <p>Автор кружка Игорь Маслеников</p>
</article>


<article class="article">
  <h1>Контест Round 993 (Div.4)</h1>
  <p>Конспект видео от 2024.12.15</p>
  <p><a href="https://codeforces.com/contest/2044" target="_blank">Codeforces Round 993 (Div.4)</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
        <a href="#task1">Задача A. Легкая задача</a>
    <br><a href="#task2">Задача B. Обычная задача</a>
    <br><a href="#task3">Задача C. Сложная задача</a>
    <br><a href="#task4">Задача D. Задача посложнее</a>
    <br><a href="#task5">Задача E. Безумная задача</a>
    <br><a href="#task6">Задача F. Легкая демоническая задача</a>
    <br><a href="#task7">Задача G1. Средняя демоническая задача (легкая версия)</a>
    <br><a href="#task8">Задача G2. Средняя демоническая задача (сложная версия)</a>
    <br><a href="#task9">Задача H. Сложная демоническая задача</a>
  </p>
</article>


<!-- Задача A. Легкая задача -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Легкая задача</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Дано целое число n. Cube хочет знать, сколько существует упорядоченных пар положительных целых чисел (a,b) таких, что a=n-b. Поскольку Cube не очень хороша в математике, пожалуйста, помогите ей!</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1≤t≤99) — количество наборов входных данных.</p>

  <p>Единственная строка каждого набора входных данных содержит целое число n (2≤n≤100).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите количество упорядоченных пар (a,b) на новой строке.</p>

  <h4>Пример</h4>
<pre>
3
2
4
6
</pre>
<pre>
1
3
5
</pre>
  <p>В первом наборе входных данных единственная упорядоченная пара, которая подходит, это (a,b)=(1,1).</p>

  <p>Во втором наборе входных данных три упорядоченные пары (a,b), которые подходят: (3,1),(2,2),(1,3).</p>

  <details>
    <summary>Решение</summary>
    <p>Количество пар на 1 меньше чем целое число n.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  int t;
  cin >> t;

  while (t--) {
    int n;
    cin >> n;

    // решение
    int res = n - 1;

    // вывод результата
    cout &lt;&lt; res &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача B. Обычная задача -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Обычная задача</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>На стеклянной витрине магазина написана строка, состоящая только из символов 'p', 'q' и 'w'. Ship проходит мимо магазина, стоя прямо перед стеклянной витриной, и наблюдает строку a. Затем Ship заходит внутрь магазина, смотрит прямо на ту же стеклянную витрину и наблюдает строку b.</p>

  <p>Ship дает вам строку a. Ваша задача — найти и вывести строку b.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1≤t≤100) — количество наборов входных данных.</p>

  <p>Единственная строка каждого набора входных данных содержит строку a (1≤|a|≤100) — строку, которую Ship наблюдает снаружи магазина. Гарантируется, что a содержит только символы 'p', 'q' и 'w'.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите строку b, строку, которую Ship наблюдает изнутри магазина, на новой строке.</p>

  <h4>Пример</h4>
<pre>
5
qwq
ppppp
pppwwwqqq
wqpqwpqwwqp
pqpqpqpq
</pre>
<pre>
pwp
qqqqq
pppwwwqqq
qpwwpqwpqpw
pqpqpqpq
</pre>

  <details>
    <summary>Решение</summary>
    <p>Символы p и q зеркальны друг другу, символ w зеркален самому себе. Поэтому будем идти с конца строки и заменять символы p на q, q на p.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;string&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  int t;
  cin >> t;

  while (t--) {
    string a;
    cin >> a;

    // решение
    string b = "";
    for (int i = a.length() - 1; i >= 0; i--) {
      switch (a[i]) {
        case 'w': b = b + "w"; break;
        case 'p': b = b + "q"; break;
        case 'q': b = b + "p"; break;
      }
    }

    // вывод результата
    cout &lt;&lt; b &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача C. Сложная задача -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Сложная задача</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Ball — преподаватель в Университете Пейперфолда. Места в его классе расположены в 2 ряда по m мест в каждом.</p>

  <p>Ball обучает a+b+c обезьян, и он хочет разместить как можно больше обезьян на местах. Ball знает, что a из них хотят сидеть только в ряду 1, b из них хотят сидеть только в ряду 2, а c из них не имеют предпочтений. На каждом месте может сидеть только одна обезьяна, и предпочтения каждой обезьяны должны быть соблюдены, если она сидит.</p>

  <p>Какое максимальное количество обезьян может посадить Ball?</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Каждый набор входных данных содержит четыре целых числа m, a, b и c (1 ≤ m, a, b, c ≤ 10⁸).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите максимальное количество обезьян, которые вы можете рассадить по местам.</p>

  <h4>Пример</h4>
<pre>
5
10 5 5 10
3 6 1 1
15 14 12 4
1 1 1 1
420 6 9 69
</pre>
<pre>
20
5
30
2
84
</pre>
  <p>Во втором наборе входных данных 6 обезьян хотят сидеть в первом ряду, но доступно только 3 места. Обезьяны, которые не имеют предпочтений, и обезьяны, которые предпочитают сидеть во втором ряду, могут сидеть во втором ряду вместе. Таким образом, ответ равен 3+2=5.</p>

  <details>
    <summary>Решение</summary>
    <p>Будем считать занятые места и свободные места. Сначала заполним первый ряд обезьянами <strong>a</strong>, затем заполним второй ряд обезьянами <strong>b</strong>, затем на свободные места посадим обезьян <strong>c</strong>.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  int t;
  cin >> t;

  while (t--) {
    int m, a, b, c;
    cin >> m >> a >> b >> c;

    // решение
    // сколько обезьян сидит
    int res = 0;
    // сколько свободных мест
    int p = 0;

    // заполняем первый ряд обезьянами a
    if (a >= m) {
      res += m;
    } else {
      res += a;
      p += m - a;
    }

    // заполняем второй ряд обезьянами b
    if (b >= m) {
      res += m;
    } else {
      res += b;
      p += m - b;
    }

    // досаживаем обезьян c
    if (p > c) {
      res += c;
    } else {
      res += p;
    }

    // вывод результата
    cout &lt;&lt; res &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача D. Задача посложнее -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Задача посложнее</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Дана последовательность положительных целых чисел. Положительное целое число называется модой последовательности, если оно встречается максимальное количество раз среди всех положительных целых чисел. Например, модой последовательности [2,2,3] является 2, а для последовательности [9,9,8,8,7,7] может считаться модой любое из чисел 9, 8 или 7.</p>

  <p>Вы дали НЛО массив a длиной n. Чтобы поблагодарить вас, НЛО решает построить другой массив b длиной n так, чтобы ai была модой последовательности [b1, b2, ... , bi] для всех 1 ≤ i ≤ n.</p>

  <p>Однако НЛО не знает, как построить массив b, поэтому вы должны ей помочь. Обратите внимание, что для вашего массива должно выполняться условие 1 ≤ bi ≤ n для всех 1 ≤ i ≤ n.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит целое число n (1 ≤ n ≤ 2⋅10⁵) — длина массива a.</p>

  <p>Следующая строка каждого набора входных данных содержит n целых чисел a1, a2, ... , an (1 ≤ ai ≤ n).</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите n чисел b1, b2, ... , bn (1 ≤ bi ≤ n) в новой строке. Можно показать, что массив b всегда можно построить. Если существует несколько возможных массивов, вы можете вывести любой из них.</p>

  <h4>Пример</h4>
<pre>
4
2
1 2
4
1 1 1 2
8
4 5 5 5 1 1 2 1
10
1 1 2 2 1 1 3 3 1 1
</pre>
<pre>
1 2
1 1 2 2
4 5 5 1 1 2 2 3
1 8 2 2 1 3 3 9 1 1
</pre>
  <p>Давайте проверим корректность нашего образца вывода в наборе входных данных 2</p>
  <ul>
    <li>При i=1, 1 является единственной возможной модой для [1].</li>
    <li>При i=2, 1 является единственной возможной модой для [1,1].</li>
    <li>При i=3, 1 является единственной возможной модой для [1,1,2].</li>
    <li>При i=4, 1 или 2 могут считаться модой для [1,1,2,2]. Поскольку ai=2, этот массив является допустимым.</li>
  </ul>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  int t;
  cin >> t;

  while (t--) {
    int n;
    cin >> n;
    vector&lt;int&gt; A(n);
    for (int i = 0; i &lt; n; i++) {
      cin >> A[i];
    }

    // решение
    vector&lt;int&gt; B(n);
    vector&lt;int&gt; Mark(n + 1);
    for (int i = 0; i &lt; n; i++) {
      if (Mark[A[i]] == 0) {
        B[i] = A[i];
        Mark[A[i]] = 1;
      }
    }

    vector&lt;int&gt; Buf;
    for (int i = 1; i &lt;= n; i++) {
      if (Mark[i] == 0) {
        Buf.push_back(i);
      }
    }
    for (int i = 0; i &lt; n; i++) {
      if (B[i] == 0) {
        B[i] = Buf[Buf.size() - 1];
        Buf.pop_back();
      }
    }

    // вывод результата
    for (int i = 0; i &lt; n; i++) {
      cout &lt;&lt; B[i] &lt;&lt; ' ';
    }
    cout &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача E. Безумная задача -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Безумная задача</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Даны пять целых чисел k, l₁, r₁, l₂ и r₂ . Вам нужно помочь Wave посчитать количество упорядоченных пар (x, y), таких что выполняются все следующие условия:</p>
  <ul>
    <li>l₁ ≤ x ≤ r₁</li>
    <li>l₂ ≤ y ≤ r₂</li>
    <li>Существует неотрицательное целое число n, такое что y/x = kⁿ</li>
  </ul>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Единственная строка каждого набора входных данных содержит пять целых чисел k, l₁, r₁, l₂ и r₂ (2 ≤ k ≤ 10⁹, 1≤ l₁ ≤ r₁ ≤ 10⁹, 1 ≤ l₂ ≤ r₂ ≤ 10⁹).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите количество подходящих упорядоченных пар (x, y) на новой строке.</p>

  <h4>Пример</h4>
<pre>
5
2 2 6 2 12
2 1 1000000000 1 1000000000
3 5 7 15 63
1000000000 1 5 6 1000000000
15 17 78 2596 20914861
</pre>
<pre>
12
1999999987
6
1
197
</pre>
  <p>В третьем наборе входных данных подходящие упорядоченные пары следующие:</p>
  <ul>
    <li>(5,15)</li>
    <li>(5,45)</li>
    <li>(6,18)</li>
    <li>(6,54)</li>
    <li>(7,21)</li>
    <li>(7,63)</li>
  </ul>
  <p>В четвертом наборе входных данных единственная допустимая упорядоченная пара это (1, 1000000000)</p>

  <details>
    <summary>Решение</summary>
    <p>В первом примере есть 12 пар (2,2),(2,4),(2,8),(3,3),(3,6),(3,12),(4,4),(4,8),(5,5),(5,10),(6,6),(6,12).</p>
    <p>Надо рассмотреть 4 случая взаимного расположения двух отрезков</p>
<pre>
1 случай
l2 > l1
r1 > r2
l1               r1
._________________.
    l2        r2
    .__________.
</pre>
<pre>
2 случай
l1 > l2
r2 > r1
    l1        r1
    .__________.
l2                  r2
.____________________.
</pre>
<pre>
3 случай
l2 > l1
r1 > l2
r2 > r1
l1        r1
.__________.
    l2          r2
    .____________.
</pre>
<pre>
4 случай
l1 > l2
r2 > l1
r1 > r2
    l1        r1
    .__________.
l2        r2
.__________.
</pre>
<pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  int t;
  cin >> t;

  while (t--) {
    long long k, l1, r1, l2, r2;
    cin >> k >> l1 >> r1 >> l2 >> r2;

    // решение
    long long res = 0;
    long long level = 1;
    long long left1, right1, left2, right2;
    while (level &lt;= 1e9) {
      left1 = l1;
      right1 = r1;
      left2 = l2 / level;
      if (l2 % level != 0) {
        left2++;
      }
      right2 = r2 / level;
      right1++;
      right2++;
      if (left1 &lt;= left2 && right2 &lt;= right1) {
        res += right2 - left2;
      } else if (left2 &lt;= left1 && right1 &lt;= right2) {
        res += right1 - left1;
      } else if (left1 &lt;= left2 && left2 &lt;= right1 && right1 &lt;= right2) {
        res += right1 - left2;
      } else if (left2 &lt;= left1 && left1 &lt;= right2 && right2 &lt;= right1) {
        res += right2 - left1;
      }
      level *= k;
    }

    // вывод результата
    cout &lt;&lt; res &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача F. Легкая демоническая задача -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Легкая демоническая задача</h3>

  <div><i>Ограничение по времени 4с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Для произвольной матрицы Robot определяет её красоту как сумму элементов в матрице.</p>

  <p>Robot дает вам массив a длиной n и массив b длиной m. Вы строите матрицу n на m M, такую что Mi,j=ai⋅bj для всех 1≤i≤n и 1≤j≤m.</p>

  <p>Затем Robot дает вам q запросов, каждый из которых состоит из одного целого числа x. Для каждого запроса определите, возможно ли выполнить следующую операцию ровно один раз так, чтобы M имела красоту x:</p>
  <ol>
    <li>Выберите целые числа r и c такие, что 1≤r≤n и 1≤c≤m.</li>
    <li>Установите Mi,j в 0 для всех упорядоченных пар (i,j) таких, что i=r, j=c или оба.</li>
  </ol>

  <p>Обратите внимание, что запросы не являются постоянными, что означает, что вы на самом деле не устанавливаете никакие элементы в 0 в процессе — вам только нужно вывести, возможно ли найти r и c так, чтобы, если вышеуказанная операция будет выполнена, красота матрицы будет равна x. Также обратите внимание, что вы должны выполнять операцию для каждого запроса, даже если красота исходной матрицыуже равна x.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит три целых числа n, m и q (1≤n,m≤2⋅105,1≤q≤5⋅104) — длина a, длина b и количество запросов соответственно.</p>

  <p>Вторая строка содержит n целых чисел a1,a2,…,an (0≤|ai|≤n).</p>

  <p>Третья строка содержит m целых чисел b1,b2,…,bm (0≤|bi|≤m).</p>

  <p>Следующие q строк каждая содержит одно целое число x (1≤|x|≤2⋅105), красота матрицы, которую вы хотите достичь, установив все элементы в строке и столбце в 0.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите «YES» (без кавычек), если существует способ выполнить вышеупомянутую операцию так, чтобы красота была равна x, и «NO» (без кавычек) в противном случае.</p>

  <p>Вы можете выводить «YES» и «NO» в любом регистре (например, строки «yES», «yes» и «Yes» будут распознаны как положительный ответ).</p>

  <h4>Пример 1</h4>
<pre>
3 3 6
-2 3 -3
-2 2 -1
-1
1
-2
2
-3
3
</pre>
<pre>
NO
YES
NO
NO
YES
NO
</pre>

  <h4>Пример 2</h4>
<pre>
5 5 6
1 -2 3 0 0
0 -2 5 0 -3
4
-3
5
2
-1
2
</pre>
<pre>
YES
YES
YES
YES
NO
YES
</pre>
  <p>Во втором примере матрица выглядит следующим образом:</p>
  <code>0 -2 5 0 -3</code>
  <code>0 4 -10 0 6</code>
  <code>0 -6 15 0 -9</code>
  <code>0 0 0 0 0</code>
  <code>0 0 0 0 0</code>

  <p>Выполнив операцию с r=4 и c=2, получим матрицу:</p>
  <code>0 0 5 0 -3</code>
  <code>0 0 -10 0 6</code>
  <code>0 0 15 0 -9</code>
  <code>0 0 0 0 0</code>
  <code>0 0 0 0 0</code>

  <p>которая имеет красоту 4. Таким образом, мы выводим YES.</p>
  <p>В втором запросе, выбирая r=3 и c=5, получается матрица с красотой -3.</p>
  <p>В третьем запросе, выбирая r=3 и c=3, получается матрица с красотой 5.</p>

  <details>
    <summary>Решение</summary>
    <p>Задача по теории Графов на удаление циклов. Во втором тесте ориентированный граф, все ребра идут друг за другом. В третьем тесте есть цикл. Все элементы в цикле всегда имеют единицы. Все вершины которые ведут в циклы, нужно посчитать расстояние до цикла.</p>
<pre>
#include &lt;bits/stdc++.h&gt;

using namespace std;

#define FOR(i,a,b) for (int i = (a); i &lt; (b); ++i)
#define F0R(i,a) FOR(i,0,a)
#define int long long
#define vt vector
#define endl "\n"

const int N = 4e5 + 5;
bool apos[N], aneg[N], bpos[N], bneg[N], posspos[N], possneg[N];

signed main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    int n,m,q;
    cin >> n >> m >> q;
    vector&lt;int&gt; a(n), b(m);
    int asum = 0, bsum = 0;
    F0R(i, n) {
        cin >> a[i];
        asum += a[i];
    }
    F0R(i, m) {
        cin >> b[i];
        bsum += b[i];
    }
    F0R(i, n) {
        if(abs(asum-a[i]) &lt; N) {
            if(asum-a[i] &lt; 0) aneg[a[i]-asum]=true;
            else apos[asum-a[i]]=true;
        }
    }
    F0R(i, m) {
        if(abs(bsum-b[i]) &lt; N) {
            if(bsum-b[i] &lt; 0) bneg[b[i]-bsum]=true;
            else bpos[bsum-b[i]]=true;
        }
    }
    FOR(i, 1, N) {
        FOR(j, 1, N) {
            if(i * j > N) break;
            if(apos[i]&&bpos[j]) posspos[i*j]=true;
            if(apos[i]&&bneg[j]) possneg[i*j]=true;
            if(aneg[i]&&bpos[j]) possneg[i*j]=true;
            if(aneg[i]&&bneg[j]) posspos[i*j]=true;
        }
    }
    while(q--) {
        int x;
        cin >> x;
        if(x>0) {
            if(posspos[x]) {
                cout &lt;&lt; "YES" &lt;&lt; endl;
            } else {
                cout &lt;&lt; "NO" &lt;&lt; endl;
            }
        } else {
            if(possneg[-x]) {
                cout &lt;&lt; "YES" &lt;&lt; endl;
            } else {
                cout &lt;&lt; "NO" &lt;&lt; endl;
            }
        }
    }
    return 0;
}
</pre>
  </details>
</article>


<!-- Задача G1. Средняя демоническая задача (легкая версия) -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G1. Средняя демоническая задача (легкая версия)</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Это легкая версия задачи. Ключевое отличие между двумя версиями выделено жирным шрифтом.</p>

  <p>Группа из n пауков собралась, чтобы обменяться плюшевыми игрушками. Изначально у каждого паука есть 1 плюшевая игрушка. Каждый год, если паук i имеет хотя бы одну плюшевую игрушку, он отдаст ровно одну плюшевую игрушку пауку rᵢ. В противном случае он ничего не сделает. Обратите внимание, что все передачи плюшевых игрушек происходят одновременно. В этой версии, если у любого паука в любой момент времени больше 1 плюшевой игрушки, он выбросит все, кроме 1.</p>

  <p>Процесс считается стабильным в текущем году, если у каждого паука количество плюшевых игрушек (до обмена в текущем году) совпадает с количеством плюшевых игрушек, которое у него было в предыдущем году (до обмена в предыдущем году). Обратите внимание, что год 1 никогда не может быть стабильным.</p>

  <p>Найдите первый год, в котором процесс становится стабильным.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит целое число n (2 ≤ n ≤ 2⋅10⁵) — количество пауков.</p>

  <p>Следующая строка содержит n целых чисел r₁, r₂, ... , rₙ (1 ≤ rᵢ ≤ n, rᵢ ≠ i) — получатель плюшевой игрушки от каждого паука.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите целое число в новой строке, первый год, в котором процесс становится стабильным.</p>

  <h4>Пример</h4>
<pre>
5
2
2 1
5
2 3 4 5 1
5
2 1 4 2 3
5
4 1 1 5 4
10
4 3 9 1 6 7 9 10 10 3
</pre>
<pre>
2
2
5
4
5
</pre>
  <p>Для второго набора входных данных:</p>
  <ul>
    <li>В год 1 следующий массив показывает количество плюшевых игрушек у каждого паука: [1,1,1,1,1]. Затем происходит обмен в год 1.</li>
    <li>В год 2 следующий массив показывает количество плюшевых игрушек у каждого паука: [1,1,1,1,1]. Поскольку этот массив такой же, как в предыдущем году, этот год является стабильным.</li>
  </ul>

  <p>Для третьего набора входных данных:</p>
  <ul>
    <li>В год 1 следующий массив показывает количество плюшевых игрушек у каждого паука: [1,1,1,1,1]. Затем происходит обмен в год 1.</li>
    <li>В год 2 следующий массив показывает количество плюшевых игрушек у каждого паука: [1,1,1,1,0]. Затем происходит обмен в год 2. Обратите внимание, что, хотя два паука отдали пауку 2 плюшевые игрушки, паук 2 может оставить только одну плюшевую игрушку.</li>
    <li>В год 3 следующий массив показывает количество плюшевых игрушек у каждого паука: [1,1,0,1,0]. Затем происходит обмен в год 3.</li>
    <li>В год 4 следующий массив показывает количество плюшевых игрушек у каждого паука: [1,1,0,0,0]. Затем происходит обмен в год 4.</li>
    <li>В год 5 следующий массив показывает количество плюшевых игрушек у каждого паука: [1,1,0,0,0]. Поскольку этот массив такой же, как в предыдущем году, этот год является стабильным.</li>
  </ul>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;

using namespace std;

void dfs(vector&lt;int&gt;& Pred, vector&lt;int&gt;& Mark,
         int x, stack&lt;int&gt; &st, bool &flag) {
  Mark[x] = 1;
  st.push(x);
  if (Mark[Pred[x]] == 0) {
    dfs(Pred, Mark, Pred[x], st, flag);
  } else {
    if (Mark[Pred[x]] == 1) {
      st.push(Pred[x]);
      flag = false;
    }
  }
}

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  int t;
  cin >> t;

  while (t--) {
    int n;
    cin >> n;

    // решение
    vector&lt;int&gt; A(n + 1);
    vector&lt;vector&lt;int&gt; &gt; G(n + 1);
    for (int i = 1; i &lt;= n; i++) {
      cin >> A[i];
      G[A[i]].push_back(i);
    }

    vector&lt;int&gt; Mark(n + 1);
    stack&lt;int&gt; st;
    bool flag;

    // собираем циклы
    for (int i = 1; i &lt;= n; i++) {
      if (Mark[i] == 0) {
        flag = true;
        dfs(A, Mark, i, st, flag);
        if (flag) {
          while (st.size() > 0) {
            Mark[st.top()] = 3;
            st.pop();
          }
        } else {
          int g = st.top();
          Mark[st.top()] = 2;
          st.pop();
          while (st.top() != g) {
            Mark[st.top()] = 2;
            st.pop();
          }
          st.pop();
          while (st.size() > 0) {
            Mark[st.top()] = 3;
            st.pop();
          }
        }
      }
    }

    // собираем очереди
    vector&lt;int&gt; Level(n + 1);
    vector&lt;int&gt; Mark_new(n + 1);
    queue&lt;int&gt; q;
    for (int i = 1; i &lt;= n; i++) {
      if (Mark[i] == 2) {
        q.push(i);
        Mark_new[i] = 1;
      }
    }
    while (q.size() > 0) {
      int tmp = q.front();
      q.pop();
      for (int i = 0; i &lt; G[tmp].size(); i++) {
        if (Mark_new[G[tmp][i]] == 0) {
          Mark_new[G[tmp][i]] = 1;
          Level[G[tmp][i]] = 1 + Level[tmp];
          q.push(G[tmp][i]);
        }
      }
    }
    int res = 0;
    for (int i = 1; i &lt;= n; i++) {
      res = max(res, Level[i]);
    }

    // вывод результата
    cout &lt;&lt; res + 2 &lt;&lt; '\n';
  }
}
</pre>
  </details>

  <details>
    <summary>Решение Codeforces</summary>
<pre>
#include &lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;


int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int tt;
    cin>>tt;
    while(tt--)
    {
        int n;
        cin>>n;
        vector&lt;int&gt; r(n+1),d(n+1);
        for(int i=1;i &lt;=n;i++)
        {
            cin>>r[i];
            d[r[i]]++;
        }
        set&lt;pair&lt;int,int&gt; &gt; s;
        for(int i=1;i &lt;=n;i++)
            s.insert({d[i],i});
        int ans=2;
        queue&lt;int&gt; q;
        while(!s.empty()&&(*s.begin()).first==0)
        {
            while(!s.empty()&&(*s.begin()).first==0)
            {
                int k=(*s.begin()).second;
                auto it=s.find({d[r[k]],r[k]});
                d[r[k]]--;
                if(it!=s.end())
                {
                    s.erase(it);
                    q.push(r[k]);
                }
                s.erase(s.begin());
            }
            while(!q.empty())
                s.insert({d[q.front()],q.front()}),q.pop();
            ans++;
        }
        cout &lt;&lt; ans &lt;&lt; '\n';
    }
    return 0;
}
</pre>
  </details>
</article>


<!-- Задача G2. Средняя демоническая задача (сложная версия) -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача G2. Средняя демоническая задача (сложная версия)</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Это сложная версия задачи. Ключевое отличие между двумя версиями выделено жирным шрифтом.</p>

  <p>Группа из n пауков собралась, чтобы обменяться плюшевыми игрушками. Изначально у каждого паука есть 1 плюшевая игрушка. Каждый год, если паук i имеет хотя бы одну плюшевую игрушку, он отдаст ровно одну плюшевую игрушку пауку rᵢ. В противном случае он ничего не сделает. Обратите внимание, что все передачи плюшевых игрушек происходят одновременно. В этой версии каждому пауку разрешено иметь более 1 плюшевой игрушки в любой момент времени.</p>

  <p>Процесс считается стабильным в текущем году, если у каждого паука такое же количество плюшевых игрушек (до обмена в текущем году), как и в предыдущем году (до обмена в предыдущем году). Обратите внимание, что год 1 никогда не может быть стабильным.</p>

  <p>Найдите первый год, в котором процесс становится стабильным.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит целое число n (2 ≤ n ≤ 2⋅10⁵) — количество пауков.</p>

  <p>Следующая строка содержит n целых чисел r₁, r₂, ... , rₙ (1 ≤ rᵢ ≤ n, rᵢ ≠ i) — получатель плюшевой игрушки от каждого паука.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите целое число в новой строке, первый год, в котором процесс становится стабильным.</p>

  <h4>Пример</h4>
<pre>
5
2
2 1
5
2 3 4 5 1
5
2 1 4 2 3
5
4 1 1 5 4
10
4 3 9 1 6 7 9 10 10 3
</pre>
<pre>
2
2
5
5
5
</pre>
  <p>Для второго набора входных данных:</p>
  <ul>
    <li>В год 1 следующий массив показывает количество плюшевых игрушек у каждого паука: [1,1,1,1,1]. Затем происходит обмен в год 1.</li>
    <li>В год 2 следующий массив показывает количество плюшевых игрушек у каждого паука: [1,1,1,1,1]. Поскольку этот массив такой же, как в предыдущем году, этот год является стабильным.</li>
  </ul>

  <p>Для третьего набора входных данных:</p>
  <ul>
    <li>В год 1 следующий массив показывает количество плюшевых игрушек у каждого паука: [1,1,1,1,1]. Затем происходит обмен в год 1.</li>
    <li>В год 2 следующий массив показывает количество плюшевых игрушек у каждого паука: [1,2,1,1,0]. Затем происходит обмен в год 2.</li>
    <li>В год 3 следующий массив показывает количество плюшевых игрушек у каждого паука: [1,3,0,1,0]. Затем происходит обмен в год 3.</li>
    <li>В год 4 следующий массив показывает количество плюшевых игрушек у каждого паука: [1,4,0,0,0]. Затем происходит обмен в год 4.</li>
    <li>В год 5 следующий массив показывает количество плюшевых игрушек у каждого паука: [1,4,0,0,0]. Поскольку этот массив такой же, как в предыдущем году, этот год является стабильным.</li>
  </ul>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;

using namespace std;

void dfs(vector&lt;int&gt;& Pred, vector&lt;int&gt;& Mark,
         int x, stack&lt;int&gt; &st, bool &flag) {
  Mark[x] = 1;
  st.push(x);
  if (Mark[Pred[x]] == 0) {
    dfs(Pred, Mark, Pred[x], st, flag);
  } else {
    if (Mark[Pred[x]] == 1) {
      st.push(Pred[x]);
      flag = false;
    }
  }
}

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);

  // ввод данных
  int t;
  cin >> t;

  while (t--) {
    int n;
    cin >> n;

    // решение
    vector&lt;int&gt; A(n + 1);
    vector&lt;vector&lt;int&gt; &gt; G(n + 1);
    for (int i = 1; i &lt;= n; i++) {
      cin >> A[i];
      G[A[i]].push_back(i);
    }

    vector&lt;int&gt; Mark(n + 1);
    stack&lt;int&gt; st;
    bool flag;

    // собираем циклы
    for (int i = 1; i &lt;= n; i++) {
      if (Mark[i] == 0) {
        flag = true;
        dfs(A, Mark, i, st, flag);
        if (flag) {
          while (st.size() > 0) {
            Mark[st.top()] = 3;
            st.pop();
          }
        } else {
          int g = st.top();
          Mark[st.top()] = 2;
          st.pop();
          while (st.top() != g) {
            Mark[st.top()] = 2;
            st.pop();
          }
          st.pop();
          while (st.size() > 0) {
            Mark[st.top()] = 3;
            st.pop();
          }
        }
      }
    }

    // собираем очереди
    vector&lt;int&gt; Level(n + 1);
    vector&lt;int&gt; Mark_new(n + 1);
    vector&lt;int&gt; Pool;
    vector&lt;int&gt; DP(n + 1, 1);
    queue&lt;int&gt; q;

    for (int i = 1; i &lt;= n; i++) {
      if (Mark[i] == 2) {
        q.push(i);
        Mark_new[i] = 1;
      }
    }

    while (q.size() > 0) {
      int tmp = q.front();
      q.pop();
      for (int i = 0; i &lt; G[tmp].size(); i++) {
        if (Mark_new[G[tmp][i]] == 0) {
          Mark_new[G[tmp][i]] = 1;
          Level[G[tmp][i]] = 1 + Level[tmp];
          q.push(G[tmp][i]);
          Pool.push_back(G[tmp][i]);
        }
      }
    }

    for (int i = Pool.size() - 1; i >= 0; i--) {
      DP[A[Pool[i]]] += DP[Pool[i]];
    }
    int res = 0;
    for (int i = 1; i &lt;= n; i++) {
      if (Mark[i] == 3) {
        res = max(res, DP[i]);
      }
    }

    // вывод результата
    cout &lt;&lt; res + 2 &lt;&lt; '\n';
  }
}
</pre>
  </details>

  <details>
    <summary>Решение Codeforces</summary>
<pre>
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;


int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int tt;
    cin>>tt;
    while(tt--)
    {
        int n;
        cin>>n;
        vector&lt;int&gt; r(n+1),d(n+1),v(n+1,1);
        for(int i=1;i &lt;=n;i++)
        {
            cin>>r[i];
            d[r[i]]++;
        }
        set&lt;pair&lt;int,int&gt; &gt; s;
        for(int i=1;i &lt;=n;i++)
        {
            s.insert({d[i],i});
        }
        int ans=2;
        queue&lt;int&gt; q;
        while(!s.empty()&&(*s.begin()).first==0)
        {
            while(!s.empty()&&(*s.begin()).first==0)
            {
                int k=(*s.begin()).second;
                ans=max(ans,v[k]+2);v[r[k]]+=v[k];
                auto it=s.find({d[r[k]],r[k]});
                d[r[k]]--;
                if(it!=s.end())
                {
                    s.erase(it);
                    q.push(r[k]);
                }
                s.erase(s.begin());
            }
            while(!q.empty())
                s.insert({d[q.front()],q.front()}),q.pop();
        }
        cout &lt;&lt; ans &lt;&lt; '\n';
    }
    return 0;
}
</pre>
  </details>
</article>


<!-- Задача H. Сложная демоническая задача -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача H. Сложная демоническая задача</h3>

  <div><i>Ограничение по времени 3.5с
  <br>Ограничение по памяти 512мб</i></div>

  <p>Swing открывает фабрику блинов! Хорошая фабрика блинов должна хорошо уметь разравнивать вещи, поэтому Swing собирается протестировать свое новое оборудование на 2D матрицах.</p>

  <p>Swing дана матрица n x n M , содержащая положительные целые числа. У него есть q запросов, которые он хочет вам задать.</p>

  <p>Для каждого запроса он дает вам четыре целых числа x1, y1, x2, y2 и просит вас разровнять подматрицу, ограниченную (x1, y1) и (x2, y2), в массив A. Формально,</p>
  <code>A=[M(x1,y1),M(x1,y1+1),…,M(x1,y2),M(x1+1,y1),M(x1+1,y1+1),…,M(x2,y2)]</code>

  <p>Следующее изображение иллюстрирует разравнивание подматрицы, ограниченной красными пунктирными линиями. Оранжевые стрелки указывают направление, в котором элементы подматрицы добавляются в конец A, а A показан внизу изображения.</p>

  <p>После этого он спрашивает вас о значении ∑|A|(i=1)Ai⋅i (сумма Ai⋅i по всем i).</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10³) — количество наборов входных данных.</p>

  <p>Первая строка каждого теста содержит два целых числа n и q (1 ≤ n ≤ 2000, 1 ≤ q ≤ 10⁶) — размер M и количество запросов.</p>

  <p>Следующие n строк содержат по n целых чисел, i-я из которых содержит M(i,1), M(i,2), ... , M(i,n) (1 ≤ M(i,j) ≤ 10⁶).</p>

  <p>Следующие q строк содержат четыре целых числа x1, y1, x2 и y2 (1 ≤ x1 ≤ x2 ≤n, 1 ≤ y1 ≤ y2 ≤ n) — границы запроса.</p>

  <p>Гарантируется, что сумма n по всем тестовым случаям не превышает 2000, а сумма q по всем тестовым случаям не превышает 10⁶.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого теста выведите результаты q запросов на новой строке.</p>

  <h4>Пример</h4>
<pre>
2
4 3
1 5 2 4
4 9 5 3
4 5 2 3
1 5 5 2
1 1 4 4
2 2 3 3
1 2 4 3
3 3
1 2 3
4 5 6
7 8 9
1 1 1 3
1 3 3 3
2 2 2 2
</pre>
<pre>
500 42 168
14 42 5
</pre>
  <p>Во втором запросе первого набора входных данных, A=[9,5,5,2]. Поэтому сумма равна 1⋅9+2⋅5+3⋅5+4⋅2=42.</p>

  <details>
    <summary>Решение Codeforces</summary>
<pre>
#include &lt;bits/stdc++.h&gt;
using namespace std;
using ll = long long;
using vll = vector &lt;ll&gt;;
using ii = pair &lt;ll, ll&gt;;
using vii = vector &lt;ii&gt;;

void tc () {
    ll n, Q;
    cin >> n >> Q;
    vector &lt;vll&gt; mat(n, vll(n));
    for (vll &ve : mat) {
        for (ll &i : ve) cin >> i;
    }
    vector &lt;vll&gt; psR(n, vll(n+1)), psRr(n, vll(n+1)), psRc(n+1, vll(n+1)), ps(n+1, vll(n+1)), psRrc(n+1, vll(n+1));
    for (ll i = 0; i &lt; n; i++) {
        for (ll j = 0; j &lt; n; j++) {
            psR[i][j+1] = psR[i][j] + mat[i][j];
        }
    }
    for (ll i = 0; i &lt; n; i++) {
        for (ll j = 0; j &lt; n; j++) {
            psRr[i][j+1] = psRr[i][j] + mat[i][j]*(j+1);
        }
    }
    for (ll i = 0; i &lt; n; i++) {
        for (ll j = 0; j &lt;= n; j++) {
            psRc[i+1][j] = psRc[i][j] + psR[i][j]*(i+1);
        }
    }
    for (ll i = 0; i &lt; n; i++) {
        for (ll j = 0; j &lt;= n; j++) {
            psRrc[i+1][j] = psRrc[i][j] + psRr[i][j];
        }
    }
    for (ll i = 0; i &lt; n; i++) {
        for (ll j = 0; j &lt;= n; j++) {
            ps[i+1][j] = ps[i][j] + psR[i][j];
        }
    }
    while (Q--) {
        ll x1, y1, x2, y2;
        cin >> x1 >> y1 >> x2 >> y2;
        x1--; y1--; x2--; y2--;
        ll ans = 0;
        ans += -(ps[x2+1][y2+1]-ps[x2+1][y1]-ps[x1][y2+1]+ps[x1][y1])*x1*(y2-y1+1);
        ans += (psRc[x2+1][y2+1] - psRc[x1][y2+1] - (ps[x2+1][y2+1]-ps[x1][y2+1]))*(y2-y1+1);

        ans += (psRc[x2+1][y1] - psRc[x1][y1] - (ps[x2+1][y1]-ps[x1][y1]))*-(y2-y1+1);
        ans += (ps[x2+1][y2+1]-ps[x1][y2+1])*-y1;
        ans += (ps[x2+1][y1]-ps[x1][y1])*y1;

        ans += psRrc[x2+1][y2+1] - psRrc[x1][y2+1];
        ans +=-(psRrc[x2+1][y1] - psRrc[x1][y1]);
        cout &lt;&lt; ans &lt;&lt; ' ';
    }
    cout &lt;&lt; '\n';
}

int main () {
    cin.tie(nullptr) -> sync_with_stdio(false);
    ll T; cin >> T; while (T--) { tc(); }
    return 0;
}
</pre>
  </details>
</article>
