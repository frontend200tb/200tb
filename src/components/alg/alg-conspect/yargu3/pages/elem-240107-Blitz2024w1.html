<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p><a href="https://codeforces.com/group/CkAC2YcRrZ/contests" target="_blank">ЯрГУ. Кружок. Контесты</a></p>
  <p>Автор кружка Игорь Маслеников</p>
</article>


<article class="article">
  <h1>Зимний блиц 1 2024</h1>
  <p><a href="https://codeforces.com/group/CkAC2YcRrZ/contest/496754" target="_blank">Codeforces Контест 496754 2024-01-07</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

      <a href="#task1">Задача A. Сумма круглых чисел</a>
  <br><a href="#task2">Задача B. Сумма слагаемых одинаковой четности</a>
  <br><a href="#task3">Задача C. K-е неделящееся на n</a>
  <br><a href="#task4">Задача D. Алиса, Боб и конфеты</a>
  <br><a href="#task5">Задача E. Особые элементы</a>
  <br><a href="#task6">Задача F. Марафон</a>
  <br><a href="#task7">Задача G. Все различные</a>
  <br><a href="#task8">Задача H. Где слон?</a>
  <br><a href="#task9">Задача I. Часы</a>
  <br><a href="#task10">Задача J. Двоичный дек</a>
</article>


<!-- Задача A. Сумма круглых чисел -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Сумма круглых чисел</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Положительное целое число называется круглым, если оно имеет вид d00...0. Иными словами, положительное целое число является круглым, если все его цифры, кроме самой левой (старшей), равны нулю. В частности, все числа от 1 до 9 (включительно) являются круглыми.</p>

  <p>Например, следующие числа являются круглыми: 4000, 1, 9, 800, 90. Например, следующие числа не являются круглыми: 110, 707, 222, 1001.</p>

  <p>Вам задано целое положительное число n (1 ≤ n ≤ 10⁴). Представьте число n как сумму круглых чисел, используя минимальное количество слагаемых. Иными словами, вам надо разложить заданное число n в сумму наименьшего количества слагаемых, каждое из которых является круглым числом.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных в тесте. Далее следуют t
  наборов входных данных.</p>

  <p>Каждый набор представляет собой строку, в которой записано целое число n (1 ≤ n ≤ 10⁴).</p>

  <h4>Выходные данные</h4>
  <p>Выведите t ответов на наборы входных данных. Каждый ответ должен начинаться с целого числа k — минимального количества слагаемых. Далее должны следовать k слагаемых, каждое из которых является круглым числом, а их сумма равна n. Слагаемые можно выводить в любом порядке. Если ответов несколько, то выведите любой из них.</p>

  <details>
    <summary>Пример</summary>
<pre>
5
5009
7
9876
10000
10
</pre>
<pre>
2
5000 9
1
7
4
800 70 6 9000
1
10000
1
10
</pre>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1352/problem/A" target="_blank">Задача 1352A</a>
      <br><a href="https://codeforces.com/contest/1352" target="_blank">Codeforces Round 640 (Div. 4) 2020-05-09</a>
    </div>

    <p>Максимально возможное входное число содержит 5 цифр, поэтому для отевта заведем массив на 5 элементов. Если остаток от деления на 10 равен нулю, то увеличиваем счетчик нулей на 1, иначе записываем в массив остаток от деления с числом нулей из счетчика нулей, увеличиваем число нулей на 1 и число чисел в ответе на 1.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    int n;
    cin >> n;

    // решение
    int count = 0;  // число чисел в ответе
    int zeroes = 0; // число нулей в следующем числе
    int next = 0;   // следующее число
    vector&lt;int&gt; A(5, 0);
    while (n) {
      if (n % 10 == 0) {
        zeroes++;
      } else {
        next = (n % 10) * (int)pow(10, zeroes);
        A[count] = next;
        count++;
        zeroes++;
      }
      n /= 10;
    }

    // вывод результата
    cout &lt;&lt; count &lt;&lt; '\n';
    for (int i = 0; i &lt; count; i++) {
      cout &lt;&lt; A[i] &lt;&lt; " ";
    }
    cout &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача B. Сумма слагаемых одинаковой четности -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Сумма слагаемых одинаковой четности</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Заданы два целых положительных числа n (1 ≤ n ≤ 10⁹) и k (1 ≤ k ≤ 100). Представьте число n в виде суммы k положительных целых чисел одинаковой четности (с одинаковыми остатками от деления на 2).</p>

  <p>Иными словами, найдите такие a1, a2, …, ak, что все ai > 0, n = a1+a2+…+ak и либо все ai одновременно четные, либо все ai одновременно нечетные. Если такого представления не существует, то сообщите об этом.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое число t (1 ≤ t ≤ 1000) — количество наборов входных данных в тесте. Далее записаны t
  наборов входных данных по одному в строке.</p>

  <p>Каждый набор представляет собой два целых положительных числа n (1 ≤ n ≤ 10⁹) и k (1 ≤ k ≤ 100).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите:</p>
  <ul>
    <li>YES и искомые ai, если ответ существует (если ответов несколько, то выведите любой из них);</li>
    <li>NO, если ответа не существует.</li>
  </ul>
  <p>Буквы в словах YES и NO можно выводить в любом регистре.</p>

  <details>
    <summary>Пример</summary>
<pre>
8
10 3
100 4
8 7
97 2
8 8
3 10
5 3
1000000000 9
</pre>
<pre>
YES
4 2 4
YES
55 5 5 35
NO
NO
YES
1 1 1 1 1 1 1 1
NO
YES
3 1 1
YES
111111110 111111110 111111110 111111110 111111110 111111110 111111110 111111110 111111120
</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Для любого числа нужно попробовать два варианта.</p>
    <p>Первый вариант - разложить число x на k - 1 единичек и в конце прибавить остаток, равный x - (n -1). Если остаток нечетный, то это и будет ответ, потому что единички тоже нечетные. Если остаток четный, то нас это не устраивает и нужно пробовать второй вариант.</p>
    <p>Второй вариант - разложить число x на k - 1 двоечек и в конце прибавить остаток, равный x - 2 * (n - 1). Если остаток четный, то это и будет ответ, потому что двоечки тоже четные. Если остаток будет нечетный, то ответа не существует.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

// условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // исходное число
    int k; // число слагаемых
    cin >> n >> k;

    // решение
    // 1 вариант
    // k - 1 единичек + остаток
    int x1 = n - (k - 1); // остаток
    // 2 вариант
    // k - 1 двоечек + остаток
    int x2 = n - 2 * (k - 1); // остаток
    if (x1 > 0 && x1 % 2 == 1) {
      cout &lt;&lt; "YES" &lt;&lt; '\n';
      for (int i = 1; i &lt; k; i++) {
        cout &lt;&lt; 1 &lt;&lt; ' ';
      }
      cout &lt;&lt; x1 &lt;&lt; '\n';
    } else if (x2 > 0 && x2 % 2 == 0) {
      cout &lt;&lt; "YES" &lt;&lt; '\n';
      for (int i = 1; i &lt; k; i++) {
        cout &lt;&lt; 2 &lt;&lt; ' ';
      }
      cout &lt;&lt; x2 &lt;&lt; '\n';
    } else {
      cout &lt;&lt; "NO" &lt;&lt; '\n';
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача C. K-е неделящееся на n -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. K-е неделящееся на n</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Заданы два целых положительных числа: n и k. Выведите k-е положительное целое число, которое не делится на n.</p>

  <p>Например, если n=3, а k=7, то все числа, которые не делятся на 3, имеют вид: 1,2,4,5,7,8,10,11,13…. 7-е число среди них равно 10.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое число t (1 ≤ t ≤ 1000) — количество наборов входных данных в тесте. Далее записаны t
  наборов входных данных по одному в строке.</p>

  <p>Каждый набор представляет собой два целых положительных числа n (2 ≤ n ≤ 10⁹) и k (1 ≤ k ≤ 10⁹).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите k-е целое положительное число, которое не делится на n.</p>

  <details>
    <summary>Пример</summary>
<pre>
6
3 7
4 12
2 1000000000
7 97
1000000000 1000000000
2 1
</pre>
<pre>
10
15
1999999999
113
1000000001
1
</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Неоптимальное решение это перебирать все числа, начиная с 1. Если число не делится на n, то увеличивать счетчик. Когда счетчик будет равен k, то вывести число в ответ. Сложность O(n).</p>
    <p>Оптимальное решение основано на формуле, которая считается за O(1). k-ое положительное число равно k. k-ое положительное число не делящееся на n это число сдвинутое вправо от k на (k - 1) / (n - 1).</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
// условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // делитель
    int k; // номер целого числа, не делящегося на n
    cin >> n >> k;

    // решение
    int res = k + (k - 1) / (n - 1);

    // вывод результата
    cout &lt;&lt; res &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача D. Алиса, Боб и конфеты -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Алиса, Боб и конфеты</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В ряд выложены n конфет, которые пронумерованы слева направо от 1 до n. Размер i-й конфеты равен ai.</p>

  <p>Алиса и Боб играют в интересную и вкусную игру — они едят конфеты. Алиса будет есть конфеты слева направо, а Боб — справа налево. Игра заканчивается, когда все конфеты съедены.</p>

  <p>Процесс состоит из ходов. Во время хода игрок съедает одну или более конфет со своей стороны (Алиса ест слева, Боб — справа). Первый ход делает Алиса. Во время первого хода она съест 1
  конфету (ее размер равен a1). Затем каждый следующий ход стороны чередуются — то есть второй ход совершает Боб, затем Алиса, затем снова Боб и так далее.</p>

  <p>На каждом ходу игрок считает суммарный размер конфет, съеденных за текущий ход. Как только это число становится строго больше, чем суммарный размер конфет, съеденных другим игроком на предыдущем ходу, текущий игрок завершает ход. Иными словами, на очередном ходу игрок ест наименьшее возможное количество конфет, при котором сумма размеров съеденных в этот ход конфет строго больше суммы размеров конфет, которые съел другой игрок на предыдущем ходу. Если конфет недостаточно, чтобы совершить ход таким образом, то игрок доедает все оставшиеся конфеты и игра заканчивается.</p>

  <p>Например, если n=11 и a=[3,1,4,1,5,9,2,6,5,3,5], то:</p>
  <ol>
    <li>ход 1: Алиса съест одну конфету размера 3 и последовательность конфет примет вид [1,4,1,5,9,2,6,5,3,5];</li>
    <li>ход 2: на предыдущем ходу Алиса съела 3, значит, Боб должен съесть 4 или более — Боб съест одну конфету размера 5 и последовательность конфет примет вид [1,4,1,5,9,2,6,5,3];</li>
    <li>ход 3: на предыдущем ходу Боб съел 5, значит, Алиса должна съесть 6 или более — Алиса съест три конфеты суммарным размером 1+4+1=6 и последовательность конфет примет вид [5,9,2,6,5,3];</li>
    <li>ход 4: на предыдущем ходу Алиса съела 6, значит, Боб должен съесть 7 или более — Боб съест две конфеты суммарным размером 3+5=8 и последовательность конфет примет вид [5,9,2,6];</li>
    <li>ход 5: на предыдущем ходу Боб съел 8, значит, Алиса должна съесть 9 или более — на пятом ходу Алиса съест две конфеты суммарным размером 5+9=14 и последовательность конфет примет вид [2,6];</li>
    <li>ход 6 (последний): на предыдущем ходу Алиса съела 14, значит, Боб должен съесть 15 или более — это невозможно, поэтому Боб съест две оставшиеся конфеты и игра закончится.</li>
  </ol>

  <p>Выведите количество ходов в этой игре и два числа:</p>
  <ul>
    <li>a — суммарный размер всех конфет, съеденных Алисой за всю игру;</li>
    <li>b — суммарный размер всех конфет, съеденных Бобом за всю игру.</li>
  </ul>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое число t (1 ≤ t ≤ 5000) — количество наборов входных данных. Далее следуют описания t наборов входных данных.</p>

  <p>Каждый набор состоит из двух строк. В первой строке содержится целое число n (1 ≤ n ≤ 1000) — количество конфет. Во второй строке содержится последовательность целых чисел a1,a2,…,an (1 ≤ ai ≤ 1000) — размеры конфет в порядке их расположения слева направо.</p>

  <p>Гарантируется, что сумма значений n по всем наборам входных данных в тесте не превосходит 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите три целых числа — количество ходов в игре и искомые величины a и b.</p>

  <details>
    <summary>Пример</summary>
<pre>
7
11
3 1 4 1 5 9 2 6 5 3 5
1
1000
3
1 1 1
13
1 2 3 4 5 6 7 8 9 10 11 12 13
2
2 1
6
1 1 1 1 1 1
7
1 1 1 1 1 1 1
</pre>
<pre>
6 23 21
1 1000 0
2 1 2
6 45 46
2 2 1
3 4 2
4 4 3
</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Паттерн два указателя - левый pl и правый pr. Алиса и Боб по очереди делают ходы, пока правый pr >= pl. Подсчитываем число ходов, размер съеденных конфет.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

// условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // число конфет
    cin >> n;
    vector&lt;int&gt; A(n + 1);
    for (int i = 1; i &lt;= n; i++) {
      cin >> A[i];
    }

    // решение
    int pl = 1; // левый указатель
    int pr = n; // правый указатель
    int cnt = 0; // число ходов
    int a = 0; // размер всех конфет, которые съела Алиса
    int b = 0; // размер всех конфет, которые съел Боб
    int a_hod = 0; // размер конфет, которые съела Алиса за ход
    int b_hod = 0; // размер конфет, которые съел Боб за ход

    // пока есть конфеты
    while (pr >= pl) {

      // ход Алисы
      a_hod = 0;
      while ( (pr >= pl) && (b_hod >= a_hod) ) {
        a_hod += A[pl];
        pl++;
      }
      a += a_hod;
      cnt++;

      // ход Боба
      b_hod = 0;
      if (pr >= pl) {
        cnt++;
      }
      while ( (pr >= pl) && (a_hod >= b_hod) ) {
        b_hod += A[pr];
        pr--;
      }
      b += b_hod;

    }

    // вывод результата
    cout &lt;&lt; cnt &lt;&lt; ' ' &lt;&lt; a
         &lt;&lt; ' ' &lt;&lt; b  &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача E. Особые элементы -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Особые элементы</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Обратите внимание на нестандартное ограничение по памяти в этой задаче.</p>

  <p>С целью отсечения эффективных решений от неэффективных в этой задаче ограничение времени довольно строгое. Предпочтите использование компилируемых статически типизированных языков (например, C++). Если используете Python, то отсылайте решения на PyPy. Постарайтесь написать в самом деле эффективное решение.</p>

  <p>Задан массив a=[a1,a2,…,an] (1 ≤ ai ≤ n). Его элемент ai называется особым, если существует такая пара индексов l и r (1 ≤ l &lt; r ≤ n), что ai=al+al+1+…+ar. Иными словами, элемент называется особым, если он представим в виде суммы двух или более подряд идущих элементов массива (не важно, особых или нет).</p>

  <p>Выведите количество особых элементов заданного массива a.</p>

  <p>Например, если n=9 и a=[3,1,4,1,5,9,2,6,5], то ответ равен 5:</p>
  <ul>
    <li>a3=4 — особый элемент, так как a3=4=a1+a2=3+1;</li>
    <li>a5=5 — особый элемент, так как a5=5=a2+a3=1+4;</li>
    <li>a6=9 — особый элемент, так как a6=9=a1+a2+a3+a4=3+1+4+1;</li>
    <li>a8=6 — особый элемент, так как a8=6=a2+a3+a4=1+4+1;</li>
    <li>a9=5 — особый элемент, так как a9=5=a2+a3=1+4.</li>
  </ul>

  <p>Обратите внимание, что среди элементов массива a могут быть равные — если несколько элементов равны и являются особыми, то все они должны быть посчитаны в ответе.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое число t (1 ≤ t ≤ 1000) — количество наборов входных данных в тесте. Далее следуют описания t наборов входных данных.</p>

  <p>Каждый набор задается двумя строками. В первой строке записано целое число n (1 ≤ n ≤ 8000) — длина массива a. Во второй строке записаны целые числа a1,a2,…,an (1 ≤ ai ≤ n).</p>

  <p>Гарантируется, что сумма значений n по всем наборам входных данных не превосходит 8000.</p>

  <h4>Выходные данные</h4>
  <p>Выведите t чисел — количества особых элементов для каждого из заданных массивов.</p>

  <details>
    <summary>Пример</summary>
<pre>
5
9
3 1 4 1 5 9 2 6 5
3
1 1 2
5
1 1 1 1 1
8
8 7 6 5 4 3 2 1
1
1
</pre>
<pre>
5
1
0
4
0
</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Заведем set сумм. В него будем записывать суммы соседних элементов от 1 до n. Перебираем все возможные суммы всех возможных длин и смотрим какие суммы мы можем получить. Начинаем с первого элемента входного массива, в сумме участвует два и более элементов. Поскольку элементы в массиве имеют значение от 1 до n, то сумму больше n можно уже не учитывать.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;set&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

// условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // размер массива
    cin >> n;
    vector&lt;int&gt; A(n + 1);
    for (int i = 1; i &lt;= n; i++) {
      cin >> A[i];
    }

    // решение
    int res = 0; // число особых элементов
    int pl = 1; // левый указатель
    int pr = pl + 1; // правый указатель

    // соберем set сумм
    set&lt;int&gt; Sum;

    while (pl &lt; n) {
      int sum = A[pl];
      pr = pl + 1;
      while ( (pr &lt; n + 1) && (sum + A[pr] &lt; n + 1) ) {
        sum += A[pr];
        pr++;
        Sum.insert(sum);
      }
      pl++;
    }

    // проверим элементы входного массива
    // если элемент есть в Sum, то увеличиваем res
    for (int i = 1; i &lt;= n; i++) {
      if (Sum.find(A[i]) != Sum.end()) {
        res++;
      }
    }

    // вывод результата
    cout &lt;&lt; res  &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача F. Марафон -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Марафон</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Тимур и три других человека участвуют в марафоне. Вам даны 4 различных целых числа a, b, c, d.</p>

  <p>Значение a соответствует расстоянию, которое пробежал Тимур, значения b, c, d соответствуют расстояниям, которые пробежали три других участника.</p>

  <p>Выведите число участников, пробежавших большее расстояние, чем Тимур.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных в тесте.</p>

  <p>Далее следуют описания наборов, каждое из них содержит ровно четыре различных целых числа a, b, c, d (0 ≤ a, b, c, d ≤ 10⁴).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора данных выведите единственное число — количество участников, пробежавших большее расстояние, чем Тимур.</p>

  <details>
    <summary>Пример</summary>
<pre>
4
2 3 4 1
10000 0 1 2
500 600 400 300
0 9999 10000 9998
</pre>
<pre>
2
0
1
3
</pre>
  <p>В первом наборе данных всего 2 пробежали больше Тимура — те, кто пробежал расстояния, равные 3 и 4 соответственно. Последний участник пробежал меньше Тимура.</p>

  <p>Во втором наборе данных никто не пробежал больше Тимура, так как Тимур пробежал 10000, в то время как остальные пробежали расстояния, равные 0, 1, и 2 соответственно.</p>

  <p>В третьем наборе только один человек пробежал больше Тимура — тот, кто пробежал расстояние 600, так как Тимур пробежал 500.</p>
  </details>
</article>


<!-- Задача G. Все различные -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Все различные</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У Sho есть массив a состоящий из n целых чисел. За одну операцию Sho может выбрать два различных индекса i и j, после чего удалить из массива элементы ai и aj.</p>

  <p>Например, для массива [2,3,4,2,5] Sho может выбрать индексы 1 и 3 и удалить соответствующие элементы из массива. После этой операции массив будет выглядеть так: [3,2,5]. Заметьте, что после любой операции длина массива уменьшится на два.</p>

  <p>После нескольких операций у Sho остался массив, содержащий только различные числа. Также, он применил операции таким образом, что длина оставшегося массива максимальна из всех возможных.</p>

  <p>Более формально, после всех операций массив Sho удовлетворяет двум следующим критериям:</p>
  <ul>
    <li>В массиве не существует таких пар индексов, что i &lt; j и ai = aj.</li>
    <li>Длина массива a максимальна.</li>
  </ul>

  <p>Выведите длину оставшегося у Sho массива.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит целое число t (1 ≤ t ≤ 10³) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора данных содержит единственное число n (1 ≤ n ≤ 50) — длину начального массива.</p>

  <p>Вторая строка каждого набора данных содержит n целых чисел ai (1 ≤ ai ≤ 10⁴) — элементы начального массива.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора данных выведите единственное число — длину оставшегося массива. Помните, что в оставшемся массиве все элементы различны, а его длина максимальна.</p>

  <details>
    <summary>Пример</summary>
<pre>
4
6
2 2 2 3 3 3
5
9 1 9 9 1
4
15 16 16 15
4
10 100 1000 10000
</pre>
<pre>
2
1
2
4
</pre>
  <p>В первом наборе данных Sho может сделать следующие операции:</p>
  <ol>
    <li>Выбрать индексы 1 и 5. Тогда массив станет [2,2,2,3,3,3]→[2,2,3,3].</li>
    <li>Выбрать индексы 1 и 4. Тогда массив станет [2,2,3,3]→[2,3].</li>
  </ol>
  <p>Финальный массив имеет длину 2, так что ответом является 2. Можно доказать, что Sho не может получить массив большей длины.</p>
  <p>Во втором наборе данных Sho может сделать следующие операции:</p>
  <ol>
    <li>Выбрать индексы 3 и 4. Тогда массив станет [9,1,9,9,1]→[9,1,1].</li>
    <li>Выбрать индексы 1 и 3. Тогда массив станет [9,1,1]→[1].</li>
  </ol>

  <p>Финальный массив имеет длину 1, так что ответом является 1. Можно доказать, что Sho не может получить массив большей длины.</p>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;set&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // длина массива
    cin >> n;
    set&lt;int&gt; A;
    int in;
    for (int i = 0; i &lt; n; i++) {
      cin >> in;
      A.insert(in);
    }

    // решение
    int res = 0;
    int m = A.size();

    if (m == n) {
      res = m;
    } else if ((n - m) % 2 == 0) {
      res = m;
    } else {
      res = m - 1;
    }

    // вывод результата
    cout &lt;&lt; res &lt;&lt; '\n';
  }

}
</pre>
  </details>
</article>


<!-- Задача H. Где слон? -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Где слон?</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У Михая есть шахматная доска размером 8x8, у которой ряды пронумерованы от 1 до 8 сверху вниз и столбцы пронумерованы от 1 до 8 слева направо.</p>

  <p>Михай поставил ровно одного слона на свою шахматную доску. Слон не находится на краях доски. (другими словами, ряд и столбец позиции слона находятся между 2 и 7 включительно.)</p>

  <p>Слон атакует по всем направлениям по диагонали, без ограничения на дистанцию на которой он атакует. Обратите внимание, что клетка на которой расположен слон тоже считается атакованной.</p>

  <p>Пример слона на доске. Атакованные клетки отмечены красным.
  Михай отметил все атакованные клетки, но забыл где находится слон. Помогите Михаю найти позицию слона!</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит единственное число t (1 ≤ t ≤ 36) — количество наборов входных данных. Далее следуют описание наборов. Перед каждым набором во входных данных записана пустая строка.</p>

  <p>Каждый набор состоит из 8 строк, в каждой по 8 символов. Каждый символ является или '#' или '.', обозначая атакованную клетку, или не атакованную соответственно.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора выведите два числа r и c (2 ≤ r, c ≤ 7) — ряд и столбец, на которых располагается слон.</p>

  <p>Гарантируется, что входные данные даны таким образом, что всегда существует единственное расположение слона, не находящееся на краях доски.</p>

  <details>
    <summary>Пример</summary>
<pre>
3

.....#..
#...#...
.#.#....
..#.....
.#.#....
#...#...
.....#..
......#.

#.#.....
.#......
#.#.....
...#....
....#...
.....#..
......#.
.......#

.#.....#
..#...#.
...#.#..
....#...
...#.#..
..#...#.
.#.....#
#.......
</pre>
<pre>
4 3
2 2
4 5
</pre>
  <p>Первый пример показан в условии. Так как слон находится на пересечении ряда 4 и столбца 3, правильным ответом является 4 3.</p>
  </details>
</article>


<!-- Задача I. Часы -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача I. Часы</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У Виктора есть 24-часовые часы, показывающие время в формате «HH:MM» (00 ≤ HH ≤ 23, 00 ≤ MM ≤ 59). Он будет смотреть на часы каждые x минут, начиная со времени s.</p>

  <p>Посчитайте как много различных палиндромов Виктор увидит, смотря на часы каждые x минут, начиная с момента времени s.</p>

  <p>Например, если Виктор начнет смотреть на часы в 03:12 и затем будет смотреть на них каждые 360 минут (то есть каждые 6 часов), то он увидит на часах 03:12, 09:12, 15:12, 21:12, 03:12, и далее время будет повторяться. В этом случае время 21:12 будет единственным палиндромом, который Виктор увидит, так что ответом будет 1.</p>

  <p>Палиндромом является строка, которая читается с конца так же, как и с начала. Например, времена 12:21, 05:50, 11:11 являются палиндромами, а 13:13, 22:10, 02:22 — нет.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит единственное число t (1 ≤ t ≤ 100) — количество наборов входных данных. Далее следуют описания наборов.</p>

  <p>Единственная строка каждого набора входных данных содержит строку s длиной 5 символов в формате «HH:MM», где «HH» может быть от «00» до «23» и «MM» может быть от «00» до «59» (и «HH», и «MM» содержат ровно два символа), а так же число x (1 ≤ x ≤ 1440) — количество минут, между моментами времени, когда Виктор смотрит на часы.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора выведите единственное число  — количество различных палиндромов, которые увидит Виктор, если будет смотреть на часы каждые x минут, начиная со времени s.</p>

  <details>
    <summary>Пример</summary>
<pre>
6
03:12 360
00:00 1
13:22 2
15:15 10
11:11 1440
22:30 27
</pre>
<pre>
1
16
10
0
1
1
</pre>
  <p>Первый пример объяснён в условии.</p>
  </details>
</article>


<!-- Задача J. Двоичный дек -->
<article class="article">
  <div class="anchor" id="task10"></div>
  <h3>Задача J. Двоичный дек</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У Славика есть массив длины n, состоящий только из нулей и единиц. За одну операцию он может удалить либо первый, либо последний элемент массива.</p>

  <p>Какое минимальное число операций нужно совершить Славику, чтобы сумма оставшихся элементов в массиве равнялась в точности s после совершения всех операций? В случае, если число s не может быть получено как сумма элементов массива после любого числа операций, выведите «-1».</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит единственное число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p></p>Первая строка каждого набора содержит два числа n и s (1 ≤ n, s ≤ 2⋅10⁵) — длина массива и необходимая сумма элементов.

  <p>Вторая строка каждого набора содержит n целых чисел ai (0 ≤ ai ≤ 1) — элементы массива.</p>

  <p>Гарантируется что сумма n по всем наборам данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите единственное число — минимальное количество операций, необходимое чтобы сумма всех элементов массива равнялась s. Выведите «-1», если получить массив с суммой элементов s невозможно.</p>

  <details>
    <summary>Пример</summary>
<pre>
7
3 1
1 0 0
3 1
1 1 0
9 3
0 1 0 1 1 1 0 0 1
6 4
1 1 1 1 1 1
5 1
0 0 1 1 0
16 2
1 1 0 0 1 0 0 1 1 0 0 0 0 0 1 1
6 3
1 0 1 0 0 0
</pre>
<pre>
0
1
3
2
2
7
-1
</pre>
  <p>В первом наборе сумма элементов во всем массиве уже равна 1, поэтому никаких операций больше не требуется.</p>

  <p>Во втором наборе сумма элементов равна 2, а нам нужна сумма 1, поэтому мы можем удалить из массива первый элемент, после чего массив превратится в [1,0], сумма элементов которого будет равна 1.</p>

  <p>В третьем наборе сумма элементов массива изначально равна 5, а нам нужна сумма 3. Мы можем получить такую сумму удалив первые 2 элемента, после чего удалив последний элемент, сделав всего 3 операции. Массив станет [0,1,1,1,0,0], сумма элементов которого будет 3.</p>
  </details>
</article>

