<h1>Занятие 3. Основы С++ #2. Массивы, трудоемкость</h1>


<article class="article">
  <p>Конспект курса <strong>Спортивное программирование в ЯрГУ</strong></p>
  <p>Конспект видео <strong>Занятие 3. Основы С++ #2. Массивы, трудоемкость</strong> от 2024.09.29</p>
  <p><a href="https://vkvideo.ru/@sportprog_yarsu">vkvideo.ru/@sportprog_yarsu</a></p>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contest/552380">Codeforces Контест 552380</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p><a href="#p1">Массивы</a></p>
  <p><a href="#p2">Трудоемкость</a></p>
  <p><a href="#p3">Сортировка</a></p>
  <p><a href="#task1">Задача A. Лестница, Пик или Ничего</a></p>
  <p><a href="#task2">Задача B. Кража в магазине</a></p>
  <p><a href="#task3">Задача C. Подарки</a></p>
  <p><a href="#task4">Задача D. Тройка</a></p>
  <p><a href="#task5">Задача E. Честный тренер</a></p>
  <p><a href="#task6">Задача F. Массив с нечетной суммой</a></p>
  <p><a href="#task7">Задача G. Напитки</a></p>
  <p><a href="#task8">Задача H. Кольцевая</a></p>
  <p><a href="#task9">Задача I. Сортировка кубов</a></p>
  <p><a href="#task10">Задача J. ACM ICPC</a></p>
  <p><a href="#task11">Задача K. Влад и столовые</a></p>
  <p><a href="#task12">Задача L. Филя и задание</a></p>
  <p><a href="#task13">Задача M. Деление на группы</a></p>
  <p><a href="#task14">Задача N. Максимизация пересечений (простая версия)</a></p>
  <p><a href="#task15">Задача O. Масштабирование</a></p>
</article>


<!-- Массивы -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Массивы</h3>

  <p>Массив представляет набор однотипных данных. Формальное определение массива выглядит следующим образом:</p>
  <code>тип_переменной название_массива [длина_массива];</code>

  <p>После типа переменной идет название массива, а затем в квадратных скобках его размер.</p>
  <p>Обращение к элементу прописывается следующим образом:</p>
  <code>Название_массива[индекс_элемента]</code>

  <ol>
    <li>Правила на имена массивов такие же, как и у переменных.</li>
    <li>Индексация элементов в массиве начинается с 0. Если в массиве 100 элементов, то элементы пронумерованы от 0 до 99 включительно.  </li>
    <li>При создании массива все элементы заполнены «мусором», минимальными значениями типа данных.</li>
    <li>При обращении за пределы массивы возвращается ошибка программы.</li>
  </ol>

  <h4>Статический массив</h4>
  <p>Статический массив — это массив фиксированной длины. Мы не можем изменять или обновлять размер этого массива.</p>
  <p>Конструкция создания:</p>
  <code>тип_данных имя_массива[константный_размер];</code>
<pre>
int Arr1[100];
int Arr2[3] = { 1,2,3 }
const int count = 10;
int Arr3[count];
</pre>

  <h4>Динамический массив</h4>
  <p>Динамический массив в С++ — это массив переменной длины.</p>
  <p>Сначала создается указатель определенного типа данных, который будет указывать на область памяти, где будет храниться массив. Следующим действием мы задаем нужный нам размер массива и в области памяти компьютера выделяется нужное количество подряд идущих ячеек.</p>
  <p>Оператор new выделяет память на определённое количество элементов заданного типа данных.</p>
<pre>
int size;
cin >> size;
int * Array;
Array = new int[size];
</pre>

  <h4>Ввод/вывод массива</h4>
  <p>Пример программы:</p>
<pre>
int n;
cin >> n;
int *A;
A = new int[n];
for (int i = 0; i &lt; n; i ++) {
  cin >> A[i];
}
// действия программы
for (int i = 0; i &lt; n; i++) {
  cout &lt;&lt; A[i] &lt;&lt; " ";
}
</pre>
</article>


<!-- Трудоемкость -->
<article class="article">
  <div class="anchor" id="p2"></div>
  <h3>Трудоемкость</h3>

  <p>Трудоёмкость алгоритма — это количество «элементарных» операций, совершаемых алгоритмом для решения конкретной проблемы (задачи) в данной формальной системе.</p>

  <p>Полезные константы:</p>
  <p>10<sup>6</sup> количество чисел, которое можно считать за 1сек.</p>
  <p>4*10<sup>9</sup>	количество простейших операций, которое делает компьютер за 1сек.</p>
  <p>2*10<sup>7</sup> 	количество памяти, которое можно выделить в задаче.</p>

  <p>Трудоемкость описывается через понятие O.</p>
  <p>Запись имеет вид O(F(N)), где F - это функция, оценивающая количество действий в программе, зависящая от количества элементов, подающихся в нее. Для успешной сдачи задачи необходимо, чтобы оценка программы была хорошей.</p>
  <p>Грубо говоря, сумма всех действий программы была меньше, чем 4*10<sup>9</sup></p>
  <p>Сумма действий программы &lt; O(F(N)) &lt; const * F(N)</p>

  <p>Пример:</p>
  <p>Сумма действий программы &lt; O(N<sup>2</sup>) &lt; const * N<sup>2</sup> &lt; 10 * N<sup>2</sup></p>
<pre>
N		O(N) 		O(N2) 		O(log2(N))  	O(N * log2(N))
10		10		100		4		10 * 4
102 		100		104		7		100 * 7
103		1000		106		10		1000 * 10
106  		106		1012		20		106 * 20
</pre>
</article>


<!-- Сортировка -->
<article class="article">
  <div class="anchor" id="p3"></div>
  <h3>Сортировка</h3>

  <p>Сортировка массива — это упорядочивание набора однотипных данных по возрастанию, убыванию или иному правилу.</p>
  <p>Сортировка применяется для облегчения поиска элементов в упорядоченном множестве.</p>

  <p>Примеры сортировок:</p>
  <ol>
    <li>Сортировка пузырьком</li>
    <li>Улучшенная сортировка пузырьком</li>
    <li>Сортировка шейкер</li>
    <li>Сортировка вставкой</li>
    <li>Сортировка merge sort</li>
    <li>Сортировка частотным массивом</li>
  </ol>

  <h4>Сортировка пузырьком</h4>
  <p>Сортировка пузырьком — один из самых известных алгоритмов сортировки. Мы последовательно сравниваем значения соседних элементов и меняем числа местами, если необходимо. Трудоемкость: O(n<sup>2</sup>).</p>
<pre>
for (int i = 0; i &lt; n; i++) {
  for (int j = 1; j &lt; n; j++) {
    if (A[j] &lt; A[j-1]) {
      int tmp = A[j];
      A[j] = A[j-1];
      A[j - 1] = temp;
    }
  }
}
</pre>

  <p>Массив:</p>
  <code>1, 4, 7, 19, 25, 32, -10, 4, 7, 19, 19, 1</code>

  <p>Упорядоченный массив:</p>
  <code>-10, 1, 1, 4, 4, 7, 7, 19, 19, 19, 25, 32</code>
  <p>Чем больше элементов в массиве, тем дольше алгоритм пузырька будет его сортировать.</p>

  <h4>Улучшенная сортировка пузырьком</h4>
  <p>Улучшим реализацию добавив флаг проверки на swap. В худшем случае трудоемкость O(n<sup>2</sup>), в лучшем случае трудоемкость O(n).</p>
<pre>
bool flag = true;
for (int i = 0; i &lt; n && flag; i++) {
  flag = false;
  for (int j = 1; j &lt; n; j++) {
    if (A[j] &lt; A[j-1]) {
      flag = true;
      int tmp = A[j];
      A[j] = A[j-1];
      A[j - 1] = temp;
    }
  }
}
</pre>

  <h4>Частотный массив</h4>
  <p>Частотный словарь Count_elem — это вспомогательный массив, в котором запоминается сколько раз встречались значения. В ячейке Count_elem[i] хранится сколько раз число i встречается в исходном массиве.</p>
<pre>
int* Count_elem;
Count_elem = new int[1000000];
for (int i = 0; i &lt; 1000000; i++) {
  Count_elem[i] = 0;
}
int elem;
for (int i = 0; i &lt; n; i++) {
  cin >> elem;
  Count_elem[elem]++;
}
</pre>
</article>


<!-- Задача A. Лестница, Пик или Ничего -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Лестница, Пик или Ничего</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам даны три цифры a, b и c. Определите, образуют ли они лестницу, пик или ни то, ни другое.</p>
  <p>Лестница удовлетворяет условию a&lt;b&lt;c.</p>
  <p>Пик удовлетворяет условию a&lt;b&gt;c.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно целое число t
   (1≤t≤1000) — количество наборов входных данных.</p>
  <p>Единственная строка каждого набора содержит три цифры a, b, c
   (0≤a, b, c≤9).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите «STAIR» если цифры образуют лестницу, «PEAK» если цифры образуют пик, и «NONE» в противном случае (выводите строки без кавычек).</p>

  <h4>Пример</h4>
<pre>
7
1 2 3
3 2 1
1 5 3
3 4 1
0 0 0
4 1 7
4 5 7
</pre>
<pre>
STAIR
NONE
PEAK
PEAK
NONE
NONE
STAIR
</pre>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int t;
  cin >> t;

  for (int test = 0; test &lt; t; test++) {
  int a, b, c;
  cin >> a >> b >> c;

  // решение
  string result = "NONE";
  if (c > b && b > a) {
    result = "STAIR";
  }
  if (b > a && b > c) {
    result = "PEAK";
  }

  // вывод результата
  cout &lt;&lt; result &lt;&lt; "\n";

  }
}
</pre>
  </details>
</article>


<!-- Задача B. Кража в магазине -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Кража в магазине</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В магазине компьютерной техники ночью произошла кража.</p>
  <p>До этого все клавиатуры, которые продавались в магазине, были пронумерованы по очереди, начиная с некоторого натурального числа x. Например, если x=4 и в магазине продавалось 3 клавиатуры, то они имели номера 4, 5 и 6, а если x=10 и в магазине продавалось 7 клавиатур, то они имели номера 10, 11, 12, 13, 14, 15 и 16.</p>
  <p>После кражи в магазине осталось n клавиатур с номерами a<sub>1</sub>,a<sub>2</sub>,…,a<sub>n</sub>. Определите минимальное количество клавиатур, которые могли быть украдены, если никто из сотрудников магазина не помнит значение x.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно целое число n (1≤n≤1000) — количество оставшихся в магазине клавиатур.</p>
  <p>Вторая строка содержит n различных целых чисел a<sub>1</sub>,a<sub>2</sub>,…,a<sub>n</sub> (1≤a<sub>i</sub>≤10<sup>9</sup>) — номера клавиатур, оставшихся в магазине после кражи. Все значения a<sub>i</sub> заданы в произвольном порядке и попарно различны.</p>

  <h4>Выходные данные</h4>
  <p>Выведите минимальное количество клавиатур, которые могли быть украдены, если никто из сотрудников магазина не помнит значение x.</p>

  <h4>Пример 1</h4>
<pre>
4
10 13 12 8
</pre>
  <code>2</code>
  <p>В первом примере, если x=8, то минимальное количество клавиатур, украденных из магазина, равно 2. То есть были украдены компьютеры с номерами 9 и 11.</p>

  <h4>Пример 2</h4>
<pre>
5
7 5 6 4 8
</pre>
  <code>0</code>
  <p>Во втором примере, если x=4, то ни одна клавиатура не была украдена из магазина.</p>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;

  int min;
  cin >> min;
  int max = min;

  for (int i = 1; i &lt; n; i++) {
    int temp;
    cin >> temp;

  // решение
    if (min > temp) {
      min = temp;
    }
    if (temp > max) {
      max = temp;
    }
  }
  int result = max - min + 1 - n;

  // вывод результата
  cout &lt;&lt; result;
}
</pre>
  </details>
</article>


<!-- Задача C. Подарки -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Подарки</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Маленький Петя очень любит подарки. Недавно мама подарила ему новый ноутбук на Новый Год. Он тут же решил передарить его кому-то еще, ведь что может быть приятнее, чем дарить кому-то подарок. По этому случаю он организовал новогоднюю вечеринку у себя дома и пригласил туда n своих друзей.</p>
  <p>Больше чем самому дарить подарки Петя любит только смотреть, как другие дарят подарки кому-либо. Так что ноутбук он припрятал до следующего Нового Года, а сам решил понаблюдать за процессом обмена подарками между своими друзьями, оставаясь в стороне. Он пронумеровал всех своих друзей целыми числами от 1 до n. Петя запомнил, что друг с номером i подарил подарок другу с номером p<sub>i</sub>. Он также запомнил, что каждому из его друзей достался ровно один подарок.</p>
  <p>Теперь для каждого друга i Петя хочет узнать номер друга, который подарил ему подарок.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано одно целое число n (1 ≤ n ≤ 100) — количество приглашенных на вечеринку друзей Пети. Во второй строке записаны n целых чисел через пробел: i-ое число задает p<sub>i</sub> — номер друга, которому подарил подарок друг с номером i. Гарантируется, что каждый друг получил ровно один подарок. Возможно, что некоторые друзья не разделяют мнения Пети о приятности дарения подарков другим, а поэтому подарили подарок сами себе.</p>

  <h4>Выходные данные</h4>
  <p>Выведите n целых чисел, разделенных пробелом: i-ое число должно быть равно номеру друга, от которого получил подарок друг с номером i.</p>

  <h4>Пример 1</h4>
<pre>
4
2 3 4 1
</pre>
  <code>4 1 2 3</code>

  <h4>Пример 2</h4>
<pre>
3
1 3 2
</pre>
  <code>1 3 2</code>

  <h4>Пример 3</h4>
<pre>
2
1 2
</pre>
  <code>1 2</code>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;

  // решение
  vector&lt;int&gt; A(n + 1), B(n + 1);
  for (int i = 1; i &lt;= n; i++) {
    cin >> A[i];
    B[A[i]] = i;
  }

  // вывод результата
  for (int i = 1; i &lt;= n; i++) {
    cout &lt;&lt; B[i] &lt;&lt; " ";
  }
}
</pre>
  </details>
</article>


<!-- Задача D. Тройка -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Тройка</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам задан массив a из n элементов. Найдите любое число, которое встречается в этом массиве хотя бы три раза, или выведите -1, если таких чисел нет.</p>

  <h4>Входные данные</h4>
  <p>В первой строке задано целое число t (1≤t≤10<sup>4</sup>) — количество наборов входных данных.</p>
  <p>Первая строка набора входных данных содержит одно целое число n (1≤n≤2⋅10<sup>5</sup>) — количество элементов в массиве.</p>
  <p>Вторая строка набора входных данных содержит n целых чисел a<sub>1</sub>,a<sub>2</sub>,…,a<sub>n</sub> (1≤a<sub>i</sub>≤n) — элементы массива.</p>
  <p>Гарантируется, что сумма n по всем наборам входных данных не превосходит 2⋅10<sup>5</sup>.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите любое целое число, которое встречается в массиве хотя бы три раза, или -1, если такого числа нет.</p>

  <h4>Пример</h4>
<pre>
7
1
1
3
2 2 2
7
2 2 3 3 4 2 2
8
1 4 3 4 3 2 4 1
9
1 1 1 2 2 2 3 3 3
5
1 5 2 4 3
4
4 4 4 4
</pre>
<pre>
-1
2
2
4
3
-1
4
</pre>
  <p>В первом наборе входных данных в массиве всего один элемент, поэтому не существует числа, которое встречается хотя бы три раза. Следовательно, ответ равен -1.</p>
  <p>Во втором наборе входных данных все три элемента массива равны 2, поэтому 2 встречается трижды. Следовательно, в качестве ответа надо вывести 2.</p>
  <p>В третьем наборе входных данных 2 встречается четыре раза, поэтому 2 — ответ.</p>
  <p>В четвертом наборе входных данных 4 встречается три раза, поэтому 4 — ответ.</p>
  <p>В пятом наборе входных данных каждое из чисел 1, 2 и 3 встречается хотя бы три раза, поэтому любое из них может быть ответом.</p>
  <p>В шестом наборе входных данных все элементы массива различны, поэтому ни одно число не встречается хотя бы три раза, и ответ равен -1.</p>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int t;
  cin >> t;

  for (int test = 0; test &lt; t; test++) {
    int n;
    cin >> n;
    int len = n + 1;
    int* Arr;
    Arr = new int[len];
    for (int i = 0; i &lt;= n; i++) {
      Arr[i] = 0;
    }
    int tmp;
    for (int i = 0; i &lt; n; i++) {
      cin >> tmp;
      Arr[tmp]++;
    }
    int res = -1;
    for (int i = 0; i &lt;= n; i++) {
      if (Arr[i] >= 3) {
        res = i;
      }
    }

    cout &lt;&lt; res &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача E. Честный тренер -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Честный тренер</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Перед вами стоит n спортсменов. Спортсмены пронумерованы от 1 до n слева направо. Про каждого спортсмена вы знаете его силу — спортсмен с номером i имеет силу s<sub>i</sub>.</p>

  <p>Вы хотите разделить всех спортсменов на две команды. В каждой команде должен быть хотя бы один спортсмен, и каждый спортсмен должен быть ровно в одной команде.</p>

  <p>Вы хотите, чтобы самый сильный спортсмен из первой команды по силе как можно меньше отличался от самого слабого спортсмена из второй команды. Формально, вы хотите разделить спортсменов на две команды A и B так, чтобы величина |max(A) - min(B)| была как можно меньше, где max(A) — максимальная сила спортсмена из команды A, а min(B) — минимальная сила спортсмена из команды B.</p>

  <p>Например, если n=5 и силы спортсменов равны s=[3, 1, 2, 6, 4], то одно из возможных разделений на команды имеет вид:</p>
  <p>первая команда: A = [1, 2, 4],</p>
  <p>вторая команда: B = [3, 6].</p>
  <p>В этом случае величина |max(A) - min(B)| будет равна |4-3|=1. Этот пример иллюстрирует один из способов оптимального разбиения на две команды.</p>
  <p>Выведите минимальное значение |max(A) - min(B)|.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое число t (1 &le; t &le; 1000) — количество наборов тестовых данных в тесте. Далее записаны t наборов тестовых данных.</p>
  <p>Каждый набор состоит из двух строк. В первой строке содержится целое положительное число n (2 &lt; n &le; 50) — количество спортсменов.</p>
  <p>В следующей строке содержится n положительных целых чисел s<sub>1</sub>, s<sub>2</sub>, ... , s<sub>n</sub> (1 &le; s<sub>i</sub> &le; 1000), где s<sub>i</sub> — это сила i-го спортсмена. Обратите внимание, что среди элементов массива s могут быть равные значения.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора тестовых данных выведите одно целое число — минимальное значение величины |max(A) - min(B)| при оптимальном разбиении всех спортсменов на команды. Каждый из спортсменов должен оказаться членом ровно одной из двух команд.</p>

  <h4>Пример 1</h4>
<pre>
5
5
3 1 2 6 4
6
2 1 3 2 4 3
4
7 9 3 1
2
1 1000
3
100 150 200
</pre>
<pre>
1
0
2
999
50
</pre>
  <p>Первый набор тестовых данных разобран в условии.</p>
  <p>Во втором наборе одно из оптимальных разбиений имеет вид A=[2, 1], B=[3, 2, 4, 3], поэтому ответ равен |2-2|=0.</p>

  <h4>Пример 2</h4>
<pre>
1
4
7 9 3 1
</pre>
  <code>2</code>

  <details>
    <summary>Решение</summary>
    <p>Из всех чисел нужно найти два числа с минимальной разницей. Если есть два одинаковых числа, то ответ будет 0, иначе ответом будет модуль разницы двух самых близких чисел</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;  // для INT_MAX

using namespace std;

int main() {
  // ввод данных
  int t;
  cin >> t;

  for (int test = 0; test &lt; t; test++) {
    int n;
    cin >> n;
    vector&lt;int&gt; A(n);
    for (int i = 0; i &lt; n; i++) {
      cin >> A[i];
    }

    // Проверка на дубликаты
    vector&lt;int&gt; B(1001, 0);
    bool has_duplicate = false;
    for (int i = 0; i &lt; n; i++) {
      if (B[A[i]]) {
        has_duplicate = true;
        break;
      } else {
        B[A[i]] = 1;
      }
    }

    if (has_duplicate) {
      cout &lt;&lt; 0 &lt;&lt; '\n';
      continue;  // Переходим к следующему тестовому случаю
    }

    // Поиск минимальной разницы
    // Сортируем массив для поиска минимальной разницы
    sort(A.begin(), A.end());
    int min_dif = INT_MAX;
    for (int i = 1; i &lt; n; i++) {
      min_dif = min(min_dif, A[i] - A[i - 1]);
    }

    // Вывод результата
    cout &lt;&lt; min_dif &lt;&lt; '\n';
  }

  return 0;
}
</pre>
  </details>
</article>


<!-- Задача F. Массив с нечетной суммой -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Массив с нечетной суммой</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Задан массив a, состоящий из n целых чисел.</p>
  <p>За один ход вы можете выбрать два индекса 1≤i,j≤n таких, что i≠j и присвоить ai:=aj. Вы можете выполнить такие ходы любое (возможно, нулевое) количество раз. Вы можете выбирать разные индексы в разных операциях. Операция := это операция присвоения (то есть вы выбираете i, j и заменяете ai на aj).</p>
  <p>Ваша задача — определить, возможно ли получить массив с нечетной (неделящейся на 2) суммой элементов.</p>
  <p>Вы должны ответить на t независимых наборов входных данных.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит одно целое число t (1≤t≤2000) — количество наборов входных данных.</p>
  <p>Следующие 2t строк описывают наборы входных данных. Первая строка набора содержит одно целое число n (1≤n≤2000) — количество элементов в a. Вторая строка набора содержит n целых чисел a1,a2,…,an (1≤ai≤2000), где ai — это i-й элемент a.</p>
  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 2000 (∑n≤2000).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите ответ на него — «YES» (без кавычек) если возможно получить массив с нечетной суммой элементов, и «NO» в противном случае.</p>

  <h4>Пример</h4>
<pre>
5
2
2 3
4
2 2 8 8
3
3 3 3
4
5 5 5 5
4
1 1 1 1
</pre>
<pre>
YES
NO
YES
NO
NO
</pre>

  <details>
    <summary>Решение</summary>
    <p>Сумма чет+чет делится на 2. Сумма нечет+нечет делится на 2. Сумма чет+нечет не делится на 2.</p>
    <p>Нужно узнать сколько нечетных чисел. Если все числа четные, то сумма будет четная при любых преобразованиях. Если все числа нечетные, то сумма будет четная если их четное количество, сумма будет нечетная если их нечетное количество. Если есть четные и нечетные числа, то преобразовывая нечетные в четные оставим одно нечетное число чтобы получить нечетную сумму.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int t;
  cin >> t;
  for (int test = 0; test &lt; t; test++) {
    int n;
    cin >> n;
    int count = 0;
    int tmp;
    for (int i = 0; i &lt; n; i++) {
      cin >> tmp;
      if (tmp % 2 == 1) {
        count++;
      }
    }
    if ((count > 0 && count &lt; n) || (count == n && n % 2 == 1)) {
      cout &lt;&lt; "YES\n";
    } else {
      cout &lt;&lt; "NO\n";
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача G. Напитки -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Напитки</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Маленький мальчик Вася очень любит апельсиновый сок, и поэтому в любом продукте и напитке у него на кухне обязательно содержится апельсиновый сок. В его холодильнике хранятся n напитков, объемная доля апельсинового сока в i-ом напитке составляет p<sub>i</sub> процентов.</p>

  <p>Однажды Вася решил приготовить себе апельсиновый коктейль, и для этого он взял в равных пропорциях каждого из n напитков и смешал. После этого ему стало интересно, как много апельсинового сока содержится в его коктейле.</p>

  <p>Найдите объемную долю апельсинового сока в получившемся напитке.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входного файла содержится единственное целое число n (1 ≤ n ≤ 100) — количество апельсиновых напитков в холодильнике у Васи. Во второй строке находятся n целых чисел p<sub>i</sub> (0 ≤ p<sub>i</sub> ≤ 100) — объемная доля в процентах апельсинового сока в i-ом напитке. Числа разделены пробелом.</p>

  <h4>Выходные данные</h4>
  <p>Выведите объемную долю в процентах апельсинового сока в коктейле Васи. Ответ будет считаться верным, если его абсолютная или относительная погрешность не превышает 10<sup>-4</sup>.</p>

  <h4>Пример 1</h4>
<pre>
3
50 50 100
</pre>
  <code>66.666666666667</code>
  <p>Пояснение к первому примеру: пусть Вася возьмет из холодильника каждого напитка по x миллилитров. Тогда количество чистого сока, которое будет в коктейле равно x/2 + x/2 +x = 2*x миллилитров. Общий объем коктейля равен 3·x миллилитров, значит, объемная доля сока в коктейле равна 2*x/(3*x) = 2/3, то есть, 66.(6) процентов.</p>

  <h4>Пример 2</h4>
<pre>
4
0 25 50 75
</pre>
  <code>37.500000000000</code>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;

  int temp;
  int sum = 0;
  for (int i = 0; i &lt; n; i++) {
    cin >> temp;
    sum += temp;
  }

  // решение
  double res = (double) sum / n;

  // Вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача H. Кольцевая -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Кольцевая</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>На кольцевой линии берляндского метро расположено n станций. Известны расстояния между всеми парами соседних станций:</p>
  <ul>
    <li>d<sub>1</sub> — расстояние между 1-ой и 2-ой станцией;</li>
    <li>d<sub>2</sub> — расстояние между 2-ой и 3-ой станцией;</li>
    <li>...</li>
    <li>d<sub>n-1</sub> — расстояние между n-1-ой и n-ой станцией;</li>
    <li>d<sub>n</sub> — расстояние между n-ой и 1-ой станцией.</li>
  </ul>
  <p>Поезда ходят по кольцевой линии в обоих направлениях. Найдите кратчайшее расстояние между станциями с номерами s и t.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое число n (3 ≤ n ≤ 100) — количество станций на кольцевой линии. Во второй строке записано n целых чисел d<sub>1</sub>, d<sub>2</sub>, ..., d<sub>n</sub> (1 ≤ d<sub>i</sub> ≤ 100) — расстояния между парами соседних станций. В третьей строке записано два целых числа s и t (1 ≤ s, t ≤ n) — номера станций, между которыми требуется найти кратчайшее расстояние. Эти номера могут совпадать.</p>
  <p>Числа в строках разделяются одиночными пробелами.</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно число — длину кратчайшего пути между станциями с номерами s и t.</p>

  <h4>Пример 1</h4>
<pre>
4
2 3 4 9
1 3
</pre>
  <code>5</code>
  <p>В первом примере длина пути 1 → 2 → 3 равна 5, длина пути 1 → 4 → 3 равна 13</p>

  <h4>Пример 2</h4>
<pre>
4
5 8 2 100
4 1
</pre>
  <code>15</code>
  <p>Во втором примере длина пути 4 → 1 равна 100, длина пути 4 → 3 → 2 → 1 равна 15</p>
  <h4>Пример 3</h4>
<pre>
3
1 1 1
3 1
</pre>
  <code>1</code>
  <p>В третьем примере длина пути 3 → 1 равна 1, длина пути 3 → 2 → 1 равна 2.</p>
  <h4>Пример 4</h4>
<pre>
3
31 41 59
1 1
</pre>
  <code>0</code>
  <p>В четвертом примере номера станций совпадают, поэтому кратчайшее расстояние равно 0</p>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;
    vector&lt;int&gt; A(n+1, 0);
  for (int i = 1; i &lt;= n; i++) {
    cin >> A[i];
  }
  int s, t;
  cin >> s >> t;

  // решение
  int dist_right = 0;
  int dist_left = 0;
  int dist;
  int s1 = s;
  while (s1 != t) {
    dist_right += A[s1];
    s1++;
    if (s1 == n + 1) {
      s1 = 1;
    }
  }
  int t1 = t;
  while (t1 != s) {
    dist_left += A[t1];
    t1++;
    if (t1 == n + 1) {
      t1 = 1;
    }
  }
  dist = min(dist_right, dist_left);

  // Вывод результата
  cout &lt;&lt; dist;
}
</pre>
  </details>
</article>


<!-- Задача I. Сортировка кубов -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача I. Сортировка кубов</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Уитли решил попробовать себя в создании тестовых камер. Он создал отличную камеру, но в ней не хватало лишь одной детали — кубов.</p>
  <p>В камеру необходимо было доставить n кубов. i-й куб имеет объем a<sub>i</sub>.</p>
  <p>Уитли необходимо расставить кубы так, чтобы они были отсортированы в порядке неубывания объема. Строго говоря, для каждого i>1 должно выполняться условие a<sub>i-1</sub>≤a<sub>i</sub>.</p>
  <p>Для этого Уитли может менять местами две соседние кубы, то есть для любого i>1 можно поменять местами кубы на позициях i-1
   и i.</p>
  <p>Проблема в том, что Уитли нетерпелив. Если ему придется сделать больше, чем n⋅(n-1)/2-1 операций обмена, он не захочет делать столь нудную работу.</p>
  <p>Уитли надо узнать: можно ли расставить кубы в порядке неубывания обьема, соблюдая все условия?</p>

  <h4>Входные данные</h4>
  <p>Каждый тест содержит несколько наборов входных данных.</p>
  <p>В первой строке находится одно целое положительное число t (1≤t≤1000) — количество наборов входных данных. Описание наборов входных данных приведено ниже.</p>
  <p>В первой строке каждого набора входных данных находится одно целое положительное число n (2≤n≤5⋅10<sup>4</sup>) — количество кубов.</p>
  <p>Во второй строке находятся n целых положительных чисел a<sub>i</sub>
   (1≤a<sub>i</sub>≤10<sup>9</sup>) — объемы кубов.</p>
  <p>Гарантируется, что сумма n по всем наборам входных данных не превосходит 10<sup>5</sup>.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите в отдельной строке одно слово: «YES» (без кавычек), если кубы могут быть отсортированы при заданных условиях, и «NO» (без кавычек) иначе.</p>

  <h4>Пример</h4>
<pre>
3
5
5 3 2 1 4
6
2 2 2 2 2 2
2
2 1
</pre>
<pre>
YES
YES
NO
</pre>
  <p>В первом наборе входных данных возможно отсортировать все кубы, используя 7 операций обмена.</p>
  <p>Во втором наборе входных данных все кубы уже отсортированы.</p>
  <p>В третьем наборе входных данных мы можем сделать 0 обменов, однако кубы еще не отсортированы, поэтому отсортировать мы их не можем.</p>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

// Функция для подсчета инверсий с помощью сортировки слиянием
long long mergeAndCount(vector&lt;int&gt;& arr, vector&lt;int&gt;& temp, int left, int mid, int right) {
  int i = left;    // Индекс для левой половины
  int j = mid + 1; // Индекс для правой половины
  int k = left;    // Индекс для временного массива
  long long invCount = 0;

  // Слияние двух половин с подсчетом инверсий
  while (i &lt;= mid && j &lt;= right) {
    if (arr[i] &lt;= arr[j]) {
      temp[k++] = arr[i++];
    } else {
      temp[k++] = arr[j++];
      invCount += (mid - i + 1); // Все элементы от i до mid образуют инверсии с arr[j]
    }
  }

  // Копирование оставшихся элементов левой половины
  while (i &lt;= mid) {
    temp[k++] = arr[i++];
  }

  // Копирование оставшихся элементов правой половины
  while (j &lt;= right) {
    temp[k++] = arr[j++];
  }

  // Копирование отсортированного временного массива обратно в arr
  for (i = left; i &lt;= right; i++) {
    arr[i] = temp[i];
  }

  return invCount;
}

// Рекурсивная функция для сортировки слиянием и подсчета инверсий
long long countInversions(vector&lt;int&gt;& arr, vector&lt;int&gt;& temp, int left, int right) {
  long long invCount = 0;
  if (left &lt; right) {
    int mid = left + (right - left) / 2;

    // Рекурсивный подсчет инверсий в левой и правой половинах
    invCount += countInversions(arr, temp, left, mid);
    invCount += countInversions(arr, temp, mid + 1, right);

    // Подсчет инверсий при слиянии двух половин
    invCount += mergeAndCount(arr, temp, left, mid, right);
  }
  return invCount;
}

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  int t;
  cin >> t;

  while (t--) {
    int n;
    cin >> n;
    vector&lt;int> a(n);
    for (int i = 0; i &lt; n; i++) {
      cin >> a[i];
    }

    // Максимальное количество обменов
    long long maxSwaps = (long long)n * (n - 1) / 2 - 1;

    // Подсчет инверсий
    vector&lt;int> temp(n);
    long long invCount = countInversions(a, temp, 0, n - 1);

    // Проверка условия
    if (invCount &lt;= maxSwaps) {
      cout &lt;&lt; "YES\n";
    } else {
      cout &lt;&lt; "NO\n";
    }
  }

  return 0;
}
</pre>
  </details>
</article>


<!-- Задача J. ACM ICPC -->
<article class="article">
  <div class="anchor" id="task10"></div>
  <h3>Задача J. ACM ICPC</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В одном маленьком, но очень гордом ВУЗе было принято решение выиграть ACM ICPC. Для этого нужно составить как можно больше команд из трёх человек, но так как желающих студентов всего 6, было решено составить две команды.</p>
  <p>Участнику с номером i по результатам тестирования была присвоена некоторая сила ai. Силой команды называется сумма сил всех участников в этой команде. Теперь руководству ВУЗа интересно, возможно ли собрать две команды с одинаковой силой. Ответьте на этот вопрос руководства.</p>

  <h4>Входные данные</h4>
  <p>В единственной строке находятся шесть целых чисел a1, ..., a6 (0 ≤ ai ≤ 1000) — силы участников.</p>

  <h4>Выходные данные</h4>
  <p>Выведите «YES» (без кавычек), если из данных участников можно собрать две команды с одинаковой силой, и «NO» (без кавычек) — иначе.</p>
  <p>Вы можете выводить каждую букву в любом регистре (строчную или заглавную).</p>

  <h4>Пример 1</h4>
  <code>1 3 2 1 2 1</code>
  <code>YES</code>
  <p>В первом тесте можно взять в первую команду 1-го, 2-го и 6-го участника, во вторую — 3-го, 4-го и 5-го: силы команд будут 1 + 3 + 1 = 2 + 1 + 2 = 5.</p>

  <h4>Пример 2</h4>
  <code>1 1 1 1 1 99</code>
  <code>NO</code>
  <p>Во втором тесте участник номер 6 слишком сильный и его команда будет заведомо сильнее другой.</p>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  const int len = 6;
  int Arr[len];
  for (int i = 0; i &lt; len; i++) {
    cin >> Arr[i];
  }
  bool flag = false;
  int sum = Arr[0] + Arr[1] + Arr[2] + Arr[3] + Arr[4] + Arr[5];
  int tmp = 0;

  for (int i1 = 0; i1 &lt; 6; i1++) {
    for (int i2 = i1 + 1; i2 &lt; 6; i2++) {
      for (int i3 = i2 + 1; i3 &lt; 6; i3++) {
        tmp = Arr[i1] + Arr[i2] + Arr[i3];
        if (tmp == sum - tmp)
          flag = true;
      }
    }
  }

  if (flag == true) {
    cout &lt;&lt; "YES";
  }
  else {
    cout &lt;&lt; "NO";
  }
}
</pre>
  </details>
</article>


<!-- Задача K. Влад и столовые -->
<article class="article">
  <div class="anchor" id="task11"></div>
  <h3>Задача K. Влад и столовые</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Влад очень любит ходить в столовые. За свою жизнь он сделал это n раз. К сожалению, в последнее время он начал замечать, что его выбор не отличается разнообразием. Ему хочется это исправить, и поэтому он провёл следующее исследование.</p>
  <p>Сначала Влад присвоил каждой столовой индивидуальный номер. Затем он выписал в ряд все номера столовых, в которых он был, в порядке посещения. Теперь он хочет найти такую столовую, что последний раз он в ней был раньше последних посещений всех остальных столовых. Иными словами, он хочет найти столовую, в которой не был дольше всего на текущий момент. Помогите ему в этом.</p>

  <h4>Входные данные</h4>
  <p>В первой строке находится одно целое число n (1 ≤ n ≤ 2·10<sup>5</sup>) — количество выписанных Владом номеров столовых.</p>
  <p>Во второй строке находятся n целых чисел a1, a2, ..., an (0 ≤ ai ≤ 2·10<sup>5</sup>) — номера столовых в порядке посещения Владом. Влад мог посетить одну и ту же столовую несколько раз. Обратите внимание, не обязательно, что столовые пронумерованы подряд.</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно число — номер столовой, в которой Влад не был как можно дольше.</p>

  <h4>Пример 1</h4>
<pre>
5
1 3 2 1 2
</pre>
  <code>3</code>
  <p>Рассмотрим первый тест. В нём есть три столовые, причём последнее посещение столовых с номерами 1 и 2 состоялись после последнего посещения столовой с номером 3, поэтому эта столовая — искомая.</p>

  <h4>Пример 2</h4>
<pre>
6
2 1 2 2 4 1
</pre>
  <code>2</code>
  <p>Во втором тесте также есть три столовые с номерами 1, 2 и 4. Столовые с номерами 1 и 4 были посещены после последнего посещения столовой с номером 2, поэтому ответ 2. Обратите внимание, что Влад мог пропустить некоторые номера в нумерации столовых.</p>

  <details>
    <summary>Решение</summary>
    <p>Заведем массив (на 200001 элементов потому что всего столовок может быть не больше 200000)для всех возможных номеров столовых. И будем для каждого номера записывать день, в который мы последний раз посещали эту столовую. Когда массив заполним, то найдем в нем столовую с наименьшим значением дня когда мы были в ней последний раз. Ответ всегда будет единственным, потому что в один день Влад ходил только в одну столовую.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int n;
  cin >> n;
  int* lastDay;
  lastDay = new int[200001];
  for (int i = 0; i &lt; 200001; i++) {
    lastDay[i] = -1;
  }
  int tmp;
  for (int i = 1; i &lt;= n; i++) {
    cin >> tmp;
    lastDay[tmp] = i;
  }
  int day = 200001;
  int number;
  for (int i = 0; i &lt; 200001; i++) {
    if (lastDay[i] &lt; day && lastDay[i] != -1) {
      day = lastDay[i];
      number = i;
    }
  }
  cout &lt;&lt; number;
}
</pre>
  </details>
</article>


<!-- Задача L. Филя и задание -->
<article class="article">
  <div class="anchor" id="task12"></div>
  <h3>Задача L. Филя и задание</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Сегодня ёжик Филя впервые пошёл в школу! Учительница дала ему домашнее задание, с которым ёжик, к сожалению, не может справиться без вашей помощи.</p>
  <p>У Фили есть массив целых неотрицательных чисел a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub>. Он сначала один раз выбирает целое положительное число x, после чего он к некоторым числам массива прибавляет данное x (не более одного раза к каждому элементу массива), из некоторых вычитает x (не более одного раза к каждому элементу массива), а некоторые числа оставляет нетронутыми. Нужно сказать, можно ли таким образом сделать массив из одинаковых чисел.</p>
  <p>Филя хочет знать, можно ли так выбрать x, а затем совершить такие действия, что в итоге массив будет состоять из одинаковых чисел.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных содержится число n (1 ≤ n ≤ 100000) — количество чисел в массиве Фили. Во второй строке содержится n целых чисел a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> (0 ≤ a<sub>i</sub> ≤ 10<sup>9</sup>) — элементы массива.</p>

  <h4>Выходные данные</h4>
  <p>Если c помощью описанной в условии операции невозможно сделать все числа в массиве одинаковыми, то выведите «NO» (без кавычек). В противном случае выведите «YES» (без кавычек).</p>

  <h4>Пример 1</h4>
<pre>
5
1 3 3 2 1
</pre>
  <code>YES</code>
  <p>В первом примере следует выбрать x = 1, после чего прибавить его к первому и последнему элементам и вычесть из второго и третьего.</p>

  <h4>Пример 2</h4>
<pre>
5
1 2 3 4 5
</pre>
  <code>NO</code>
</article>


<!-- Задача M. Деление на группы -->
<article class="article">
  <div class="anchor" id="task13"></div>
  <h3>Задача M. Деление на группы</h3>

  <div><i>Ограничение по времени 4с
  <br>Ограничение по памяти 256мб</i></div>

  <p>На первое собрание кружка по программированию Берляндского ГУ пришли n студентов (n — четно). Было решено поделить всех студентов на две группы. У каждой группы будет ровно по одному занятию в неделю в один из будних дней (понедельник, вторник, среда, четверг или пятница), причем дни занятий у каждой группы должны быть разными. Также было решено, что количество студентов в каждой группе должно быть одинаковым.</p>
  <p>Каждый из студентов заполнил форму, в которой отметил дни недели, в которые ему было бы удобно посещать занятия.</p>
  <p>Перед вами стоит задача определить, возможно ли выбрать два различных будних дня в неделю, в которые будут проходить занятия у каждой из групп, а также поделить всех студентов на две группы таким образом, чтобы каждый из студентов занимался в один из тех дней, в который ему удобно, при этом количество студентов в каждой из групп должно быть одинаковым.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано одно целое число t (1≤t≤10<sup>4</sup>) — количество наборов входных данных.</p>
  <p>Далее следуют описания t наборов входных данных.</p>
  <p>В первой строке каждого набора входных данных записано одно четное целое число n (2≤n≤1000) — количество студентов.</p>
  <p>В i-й из следующих n строк следует 5 целых чисел 0 или 1, причем j-е число равно 1, если i-му студенту удобно ходить на занятия в j -й будний день, или j-е число равно 0, если i-му студенту неудобно ходить на занятия в j-й будний день.</p>
  <p>Гарантируется, что каждый из студентов хочет ходить на занятия хотя бы в один из будних дней. Гарантируется, что сумма количества студентов по всем наборам входных данных не превосходит 10<sup>5</sup></p>

  <h4>Выходные данные</h4>
  <p>На каждый набор входных данных выведите ответ. Если возможно разделить всех студентов на две равные группы и выбрать дни для занятий так, чтобы всем студентам было удобно, выведите «YES» (без кавычек). В противном случае выведите «NO» (без кавычек).</p>

  <h4>Пример</h4>
<pre>
2
4
1 0 0 1 0
0 1 0 0 1
0 0 0 1 0
0 1 0 1 0
2
0 0 0 1 0
0 0 0 1 0
</pre>
<pre>
YES
NO
</pre>
  <p>В первом наборе входных данных возможно распределить студентов так, чтобы удовлетворить всем описанным условиям. Для этого в одну группу нужно распределить первого и третьего студентов, которые будут заниматься в четверг, то есть в четвертый будний день, а в другую группу — второго и четвертого студентов, которые будут заниматься во вторник, то есть во второй будний день.</p>
  <p>Во втором наборе входных данных невозможно разделить студентов на группы так, чтобы группы занимались в разные будние дни.</p>
</article>


<!-- Задача N. Максимизация пересечений (простая версия) -->
<article class="article">
  <div class="anchor" id="task14"></div>
  <h3>Задача N. Максимизация пересечений (простая версия)</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Единственная разница между двумя версиями состоит в том, что в этой версии n≤1000 и сумма значений n по всем наборам входных данных теста не превосходит 1000.</p>
  <p>Терминал — это ряд без промежутков из n равных отрезков, пронумерованных от 1 до n по порядку. Есть два терминала, один над другим.</p>
  <p>Вам дан массив a длины n. Для всех i=1,2,…,n должен быть прямой провод из некоторой точки на отрезке i верхнего терминала в некоторую точку на отрезке a<sub>i</sub> нижнего терминала. Например, на следующих рисунках показаны два возможных соединения, при n=7 и a=[4,1,4,6,7,7,5].</p>
  <p>Пересечение происходит, когда два провода имеют общую точку. На картинке выше пересечения обведены красным.</p>
  <p>Какое максимальное количество пересечений может быть при оптимальном размещении проводов?</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1≤t≤1000) — количество наборов входных данных.</p>
  <p>Первая строка каждого набора содержит целое число n(1≤n≤1000) — длина массива.</p>
  <p>Вторая строка каждого набора содержит n целых чисел a<sub>1</sub>,a<sub>2</sub>,…,a<sub>n</sub> (1≤a<sub>i</sub>≤n) — элементы массива.</p>
  <p>Сумма n по всем наборам входных данных не превосходит 1000.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора выведите единственное целое число — максимальное количество пересечений, при оптимальном расположении проводов.</p>

  <h4>Пример</h4>
<pre>
4
7
4 1 4 6 7 7 5
2
2 1
1
1
3
2 2 2
</pre>
<pre>
6
1
0
3
</pre>
  <p>Первый пример показан на втором рисунке в условии.</p>
  <p>Во втором примере при единственно возможном соединении появляется пересечение двух проводов, поэтому ответ равен 1.</p>
  <p>В третьем тестовом примере единственно возможное соединение состоит из одного провода, поэтому ответ равен 0.</p>
</article>


<!-- Задача O. Масштабирование -->
<article class="article">
  <div class="anchor" id="task15"></div>
  <h3>Задача O. Масштабирование</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Дано целое число n. Выведите шахматную доску размером 2n*2n, состоящую из 2*2 клеток, чередующихся между '#' и '.', с верхним левым углом, содержащим '#'.</p>
<pre>
n = 1
##
##
</pre>
<pre>
n = 2
##..
##..
..##
..##
</pre>
<pre>
n = 3
##..##
##..##
..##..
..##..
##..##
##..##
</pre>
<pre>
n = 4
##..##..
##..##..
..##..##
..##..##
##..##..
##..##..
..##..##
..##..##
</pre>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1≤t≤20) — количество наборов входных данных.</p>
  <p>Единственная строка каждого набора входных данных содержит одно целое число n (1≤n≤20) — это означает, что вам нужно вывести шахматную доску размером 2n.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите 2n строк, каждая содержащая 2n символов без пробелов — шахматную доску, как описано в условии. Не выводите пустые строки между наборами входных данных.</p>

  <h4>Пример</h4>
<pre>
4
1
2
3
4
</pre>
<pre>
##
##
##..
##..
..##
..##
##..##
##..##
..##..
..##..
##..##
##..##
##..##..
##..##..
..##..##
..##..##
##..##..
##..##..
..##..##
..##..##
</pre>
</article>

