<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p>Конспект курса</p>
  <p><a href="https://vkvideo.ru/@sportprog_yarsu" target="_blank">vkvideo.ru/@sportprog_yarsu</a></p>
</article>


<article class="article">
  <h1>Контест Round 991 (Div.3)</h1>
  <p><a href="https://codeforces.com/contest/2050" target="_blank">Codeforces Round 991 (Div.3)</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
        <a href="#task1">Задача A. Переносы строк</a>
    <br><a href="#task2">Задача B. Переливайка</a>
    <br><a href="#task3">Задача C. Неинтересное число</a>
    <br><a href="#task4">Задача D. Максимизация цифровой строки</a>
    <br><a href="#task5">Задача E. Три строки</a>
    <br><a href="#task6">Задача F. Максимальное модульное равенство</a>
    <br><a href="#task7">Задача G. Развал дерева</a>
  </p>
</article>


<!-- Задача A. Переносы строк -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Переносы строк</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У Кости есть текст s из n слов, состоящих из букв латинского алфавита. Также у него есть две полоски, на которые он должен выписать текст. На первую полоску помещается m
  символов, а на вторую — сколько угодно.</p>

  <p>Костя должен выбрать число x и выписывает первые x слов из s
  на первую полоску, а все остальные — на вторую. Ради экономии места слова выписываются без отступов, но каждое слово должно полностью быть на одной полоске.</p>

  <p>Так как место на второй полоске очень ценно, Костя просит вас выбрать максимальное возможное число x, чтобы все слова s₁, s₂, ... ,sₓ уместились на первую полоску длины m.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 1000) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит два целых числа n и m (1 ≤ n ≤ 50; 1 ≤ m ≤ 500) — число слов в списке и максимальное число символов, которое может быть в первой строке.</p>

  <p>Следующие n строк содержат по одному слову sᵢ из строчных букв латинского алфавита, длина sᵢ не превышает 10.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите максимальное число слов x, такое что первые x слов имеют суммарную длину не больше m.</p>

  <h4>Пример</h4>
<pre>
5
3 1
a
b
c
2 9
alpha
beta
4 12
hello
world
and
codeforces
3 2
ab
c
d
3 2
abc
ab
a
</pre>
<pre>
1
2
2
1
0
</pre>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

void solve() {
  long long n, m;
  cin >> n >> m;

  vector&lt;string&gt; v(n);

  for (int i = 0; i &lt; n; ++i) {
    cin >> v[i];
  }
  // суммарная длина добавленных строк
  long long len = 0;

  for (int i = 0; i &lt; n; ++i) {
    // если очередную строку не можем добавить,
    // то можем выводить ответ i
    if (len + v[i].size() > m) {
      // благодаря индексации с нуля количество
      // строк от 0-ой до (i - 1)-ой равно i
      cout &lt;&lt; i &lt;&lt; '\n';
      return;
    }

    // если добавить можем, то увеличиваем суммарную длину
    len += v[i].size();
  }

  // если все строки получилось добавить, то ответ - n
  cout &lt;&lt; n &lt;&lt; '\n';
}

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  cout.tie(NULL);

  long long t = 1;
  cin >> t;

  while (t--) {
    solve();
  }
}
</pre>
  </details>
</article>


<!-- Задача B. Переливайка -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Переливайка</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Дан массив a длины n. За одну операцию можно выбрать индекс i от 2 до n-1 и сделать одно из следующих действий:</p>
  <ul>
    <li>Вычесть 1 из a<sub>i-1</sub>, затем прибавить 1 к a<sub>i+1</sub>.</li>
    <li>Вычесть 1 из a<sub>i+1</sub>, затем прибавить 1 к a<sub>i-1</sub>.</li>
  </ul>

  <p>При этом все полученные после каждой операции числа должны оставаться неотрицательными. Можно ли сделать все элементы массива равными за какое-то количество таких операций?</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно целое число t (1 ≤ t ≤ 10⁴)  — количество наборов входных данных. Далее следует описание наборов входных данных.</p>

  <p>Первая строка каждого набора данных содержит число n (3 ≤ n ≤ 2⋅10⁵).</p>

  <p>Вторая строка каждого набора данных содержит n чисел aᵢ (1 ≤ aᵢ ≤ 10⁹).</p>

  <p>Гарантируется, что сумма n по всем наборам данных не превосходит 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора данных выведите «YES» без кавычек, если можно сделать все элементы равными после некоторого числа данных операций, иначе выведите «NO» без кавычек.</p>

  <p>Ответ можно выводить в любом регистре: «yes», «YeS», «nO»  — также являются корректными выводами.</p>

  <h4>Пример</h4>
<pre>
8
3
3 2 1
3
1 1 3
4
1 2 5 4
4
1 6 6 1
5
6 2 1 4 2
4
1 4 2 1
5
3 1 2 1 3
3
2 4 2
</pre>
<pre>
YES
NO
YES
NO
YES
NO
NO
NO
</pre>

  <details>
    <summary>Решение</summary>
    <p>заметим, что можем начать решать задачу для четных и нечетных индексов отдельно потому что i-1 и i+1 имеют одинаковую четность будем рассуждать про четные(для нечетных аналогично) тогда поймем, что на самом деле мы можем уровнять, когда сумма чисел стоящих на четных позициях делится нацело на количество четных позиций и действительно сумма на четных позициях от операций не меняется, а все они станут равны, а значит сумма делится на количество слагаемых то есть на количество четных позиций если это условие не выполняется, то ответ сразу Нет ну а теперь мы точно знаем к каким числам сведем числа на четных и нечетных позициях осталось только проверить, что это одно и тоже число</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

using namespace std;

void slove() {
  int n;
  cin >> n;
  //сумма на четных и нечетных позициях соответственно
  long long sch = 0, snch = 0;
  //заметим, что для суммы нам потребуется тип данных long long
  //количество четных и нечетных
  int cntch = 0, cntnch = 0;соответственно
  for (int i = 0; i &lt; n; i++) {
    int x;
    cin >> x;

    //определяем четность индекса
    if (i % 2==1) {
      snch += x;
      cntnch++;
    } else {
      sch += x;
      cntch++;
    }
  }

  //если все условия выполняются, то мы всегда сможем их приравнять
  if (sch % cntch == 0 && snch % cntnch == 0 && (snch / cntnch == sch / cntch)) {
    cout &lt;&lt; "YES" &lt;&lt; endl;
    return;
  }
  cout &lt;&lt; "NO" &lt;&lt; endl;
}

int main() {
  int t = 1;
  cin >> t;//количество наборов входных

  while (t--) {
    //функция, которая решает один набор  входных данных
    slove();
  }
}
</pre>
  </details>
</article>


<!-- Задача C. Неинтересное число -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Неинтересное число</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам дано число n длины не больше 10⁵.</p>

  <p>Вы можете любое количество раз сделать с ним следующее: выбрать одну из его цифр, возвести её в квадрат и заменить получившейся исходную цифру. При этом результат должен быть цифрой (то есть, если вы выбрали цифру x, то значение x² должно быть меньше 10).</p>

  <p>Можно ли такими действиями получить из исходного числа такое, которое будет делиться нацело на 9?</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Единственная строка каждого набора содержит число n, без ведущих нулей. Длина числа не превосходит 10⁵.</p>

  <p>Гарантируется, что сумма длин чисел по всем наборам входных данных не превосходит 10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите «YES», если с помощью описанных операций можно получить число, делящееся на 9, и «NO» иначе.</p>

  <p>Вы можете выводить каждую букву в любом регистре (строчную или заглавную). Например, строки «yEs», «yes», «Yes» и «YES» будут приняты как положительный ответ.</p>

  <h4>Пример</h4>
<pre>
9
123
322
333333333333
9997
5472778912773
1234567890
23
33
52254522632
</pre>
<pre>
NO
YES
YES
NO
NO
YES
NO
YES
YES
</pre>
  <p>В первом примере из числа 123 возможно получить только 123, 143, 129 и 149, ни одно из них не делится на 9.</p>

  <p>Во втором примере нужно заменить вторую цифру на её квадрат, тогда n станет равно 342=38⋅9.</p>

  <p>В третьем примере число уже делится на 9.</p>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

using namespace std;
void slove()
{
	//такое число не влезет в целочисленные типы данных, поэтому прочитаем его как строчку
	string s;
	cin >> s;
	int cnt = 0;
	int su = 0;
	int cnt1 = 0;
	//вспомним призанк делимости на 9
	// надо чтобы сумма цифр числа делилась на 9
	// также поймем, что по условию задачи мы можем возводить в квадрат только 1,2,3
	// 1 смысла возводить в квадрат не имеет (оно не поменяется)
	// тогда давайте пока просто посчитаем сумму цифр числа и количество 2 и 3 в его записи
	//
	for (int i = 0; i &lt; s.size(); i++)
	{
		su += s[i] - '0';//так можно быстро из символа получить цифру, если мы заранее знаем, что символ цифра
		if (s[i] == '2')//подсчитываем количество двоек
		{
			cnt++;
		}
		if (s[i] == '3')//количество троек
		{
			cnt1++;
		}
	}
	su %= 9;//нам не интересна вся сумма, а только ее остаток по модулю 9
	if (su == 0)//если он 0, то ничего делать не надо, ура отвечаем ДА
	{
		cout &lt;&lt; "YES" &lt;&lt; endl;
		return;
	}
	//
	// тогда теперь будем возводить в квадрат наши 2 и 3
	// возведение 2 дает нашей сумме еще +2
	// возведение 3 дает +6
	// заметим, что так как 2 и 9 взаимно просты, то в случае, если у нас есть 8 двоек - это уже победа, ибо мы сможем обойти все остатки по модулю 9
	// это мы не будем использовать в решении просто поймем, что на самом деле нам не так много надо 2 и 3
	// также поймем, что возведение одной 3 это как возвести три двойки
	// тогда запустим цикл и будем пытаться на каждой итерации получить сумму, которая делится на 9
	// заведем пременную dob, чтобы записывать туда сколько на данный момент возведено 2
	//
	int dob = 0;
	for (int i = 0; i &lt; 1000; i++)//будем проделывать операцию 1000 раз, нам это позволяют входные данные, на самом деле как мы поняли достаточно гораздо меньше
	{
		if (cnt > 0)//если у нас еще осталась 2, которую мы не возвели в квадрат
		{
			dob++;//возводим
			cnt--;
			su += 2;//сумма увеличилась на 2
			if (dob == 3 && cnt1 > 0)//если у нас есть 3 возведенные двойки и есть невозведенная тройка делаем замену,так как малый шаг нам выгоднее, прибережем двойки на будущее
			{
				cnt += 3;//возвращаем 3 двойки
				dob = 0;//обнуляем счетчик
				cnt1--;//уменьшаем количество невозведенных 3
			}
			if (su % 9 == 0)//если у нас получилось, выводим ответ и прекращаем выполнение функции
			{
				cout &lt;&lt; "YES" &lt;&lt; endl;
				return;
			}
		}
		else//если свобоных 2 нет
		{
			if (cnt1 > 0)//есть ли свободные тройки
			{
				su += 6;//если да возводим и к сумме получается +6
				cnt1--;
			}
			if (su % 9 == 0)//если у нас получилось, выводим ответ и прекращаем выполнение функции
			{
				cout &lt;&lt; "YES" &lt;&lt; endl;
				return;
			}
			if (su % 9 == 2 && dob >= 1)//если у нас получилось сумма с остатком 2 по модулю 9 и у нас есть хотя бы одна возведенная двойка, то отменяем ее возведение и победа
			{
				cout &lt;&lt; "YES" &lt;&lt; endl;
				return;
			}
			if (su % 9 == 4 && dob >= 2)//если у нас получилось сумма с остатком 4 по модулю 9 и у нас есть хотя бы две возведенные двойки, то отменяем их возведение и победа
			{
				cout &lt;&lt; "YES" &lt;&lt; endl;
				return;
			}
		}
	}
	cout &lt;&lt; "NO" &lt;&lt; endl;//если за такое количество операций не смогли получить ответ, тогда это невозможно
}
int main()
{
	int t = 1;
	cin >> t;//количество наборов входных

	while (t--)
	{
		slove();//функция которая решает один набор  входных данных
	}
}
</pre>
  </details>
</article>


<!-- Задача D. Максимизация цифровой строки -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Максимизация цифровой строки</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Дана строка s, состоящая из цифр от 0 до 9. За одно действие можно выбрать любую цифру, кроме 0 или самой левой цифры, уменьшить её на 1 и поменять с цифрой слева от неё местами.</p>

  <p>Например, за одну операцию из строки 1023 можно получить строки 1103, 1022.</p>

  <p>Найдите, какую лексикографически максимальную строку можно получить с помощью этой операции.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно целое число t (1 ≤ t ≤ 10⁴)  — количество наборов входных данных. Далее следует описание наборов входных данных.</p>

  <p>Каждая строка набора данных содержит строку s из цифр (1 ≤ |s| ≤ 2⋅10⁵), где |s| — это длина строки s. Строка не содержит ведущих нулей.</p>

  <p>Гарантируется, что сумма |s| по всем наборам данных не превосходит 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите ответ в единственной строке.</p>

  <h4>Пример</h4>
<pre>
6
19
1709
11555
51476
9876543210
5891917899
</pre>
<pre>
81
6710
33311
55431
9876543210
7875567711
</pre>
  <p>В первом примере подойдёт следующая последовательность операций: 19→81.</p>

  <p>Во втором примере подойдёт следующая последовательность операций: 1709→1780→6180→6710.</p>

  <p>В четвёртом примере подойдёт следующая последовательность операций: 51476→53176→53616→53651→55351→55431.</p>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

void solve() {
  string s;
  cin >> s;

  long long n = s.size();
  vector&lt;long long&gt; v(n);

  for (int i = 0; i &lt; n; ++i) {
    v[i] = s[i] - '0';         // для удобства перепишем строку s в массив целых чисел v
  }

  for (int i = 0; i &lt; n; ++i) {
    long long ind = i;         // индекс элемента, который должен стоять на i-ой позиции
    long long val = v[i];      // значение элемента с индексом ind, когда он будет стоять на i-ой позиции

    for (int j = i + 1; j &lt;= min(n - 1, (long long)i + 10); ++j) {  // так как все числа до 9, элемент, стоящий дальше
    // (i + 10)-ой позиции точно нельзя поставить в позицию i

      if (v[j] - (j - i) > val) {  // (j - i) - сколько потеряет v[j], если мы его переставим в i-ую позицию
        ind = j;
        val = v[j] - (j - i);
      }
    }

    while (ind > i) {  // проделываем операцию, пока найденный элемент на позиции ind не встанет на позицию i
      --v[ind];
      swap(v[ind], v[ind - 1]);
      --ind;
    }
  }

  for (int i = 0; i &lt; n; ++i) {
    cout &lt;&lt; v[i];  // выводим ответ
  }

  cout &lt;&lt; '\n';
}

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  cout.tie(NULL);

  long long t = 1;
  cin >> t;

  while (t--) {
    solve();
  }
}
</pre>
  </details>
</article>


<!-- Задача E. Три строки -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Три строки</h3>

  <div><i>Ограничение по времени 2.5с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Даны три строки: a, b и c, состоящие из строчных латинских букв. Строка c была получена следующим образом:</p>
  <ol>
    <li>На каждом шаге случайно выбиралась строка a или строка b, и первый символ выбранной строки удалялся из неё и приписывался в конец строки c, пока одна из строк не заканчивалась. После этого оставшиеся символы непустой строки добавлялись в конец c.</li>
    <li>Затем в строке c было произвольно изменено некоторое количество символов.</li>
  </ol>
  <p>Например, из строк a=abra и b=cada без замен символов могли получиться строки caabdraa, abracada, acadabra.</p>

  <p>Найдите минимальное количество символов, которые могли быть изменены в строке c.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит одно целое число t (1 ≤ t ≤ 10³) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора содержит одну строку из строчных латинских букв a (1 ≤ |a| ≤ 10³) — первая строка. Где |a| обозначает длину строки a.</p>

  <p>Вторая строка каждого набора содержит одну строку из строчных латинских букв b (1 ≤ |b| ≤ 10³) — вторая строка. Где |b| обозначает длину строки b.</p>

  <p>Третья строка каждого набора содержит одну строку из строчных латинских букв c (|c| = |a| + |b|) — третья строка.</p>

  <p>Гарантируется, что сумма |a| по всем наборам входных данных не превосходит 2⋅10³. Также сумма |b| по всем наборам входных данных не превосходит 2⋅10³.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно целое число — минимальное количество символов, которые могли быть изменены в строке c.</p>

  <h4>Пример</h4>
<pre>
7
a
b
cb
ab
cd
acbd
ab
ba
aabb
xxx
yyy
xyxyxy
a
bcd
decf
codes
horse
codeforces
egg
annie
egaegaeg
</pre>
<pre>
1
0
2
0
3
2
3
</pre>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

void solve() {
  string a, b, c;
  cin >> a >> b >> c;

  long long na = a.size();
  long long nb = b.size();

  vector&lt;vector&lt;long long&gt; &gt; dp(na + 1, vector&lt;long long&gt;(nb + 1));  // dp[i][j] - минимальное количество замен, которые нужно сделать к моменту,
  // когда мы стоим на i-ой позиции в строке a и j-ой позиции в строке b

  dp[0][0] = 0;  // когда мы стоим на нулевом символе (нумерация с нуля) в строке a и в строке b мы не взяли
                 // ни одного символа, значит сделали 0 замен.

  for (int i = 1; i &lt;= na; ++i) {
    dp[i][0] = dp[i - 1][0];
    // заполняем нулевой столбец dp
    if (c[i - 1] != a[i - 1]) {
      ++dp[i][0];
    }
  }

  for (int i = 1; i &lt;= nb; ++i) {
    dp[0][i] = dp[0][i - 1];
    // заполняем нулевую строку dp
    if (c[i - 1] != b[i - 1]) {
      ++dp[0][i];
    }
  }

  for (int i = 1; i &lt;= na; ++i) {
    for (int j = 1; j &lt;= nb; ++j) {
      long long t1 = dp[i - 1][j];
      long long t2 = dp[i][j - 1];
      // мы можем прийти в dp[i][j] либо из dp[i - 1][j], взяв символ из строки a
      if (c[i + j - 1] != a[i - 1]) {  // либо из dp[i][j - 1], взяв символ из строки b
        ++t1;
      }

      if (c[i + j - 1] != b[j - 1]) {
        ++t2;
      }

      dp[i][j] = min(t1, t2);  // ответ посчитаем как минимум из двух возможных переходов
    }
  }

  cout &lt;&lt; dp[na][nb] &lt;&lt; '\n';  // dp[na][nb] - минимальное количество замен, когда мы использовали все символы из строк a и b
}

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  cout.tie(NULL);

  long long t = 1;
  cin >> t;

  while (t--) {
    solve();
  }
}
</pre>
  </details>
</article>


<!-- Задача F. Максимальное модульное равенство -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Максимальное модульное равенство</h3>

  <div><i>Ограничение по времени 5с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Дан массив a длины n и q запросов вида l, r.</p>

  <p>Для каждого запроса найдите такое максимальное m, что все числа a<sub>l</sub>, a<sub>l+1</sub>, ..., a<sub>r</sub> равны по модулю m. Иными словами, a<sub>l</sub> mod m = a<sub>l+1</sub> mod m = ... = a<sub>r</sub> mod m, где a mod b — это остаток от деления a на b. В частности, если число m может быть бесконечно большим, выведите 0.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора содержит два целых числа n, q (1 ≤ n, q ≤ 2⋅10⁵) — длину массива и количество запросов.</p>

  <p>Вторая строка каждого набора содержит n целых чисел aᵢ (1 ≤ aᵢ ≤ 10⁹) — элементы массива.</p>

  <p>В следующих q строках каждого набора вводится по два числа l, r (1 ≤ l ≤ r ≤ n) — отрезок запроса.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превосходит 2⋅10⁵, как и сумма q не превосходит 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого запроса выведите максимальное значение m, описанное в условии.</p>

  <h4>Пример</h4>
<pre>
3
5 5
5 14 2 6 3
4 5
1 4
2 4
3 5
1 1
1 1
7
1 1
3 2
1 7 8
2 3
1 2
</pre>
<pre>
3 1 4 1 0
0
1 6
</pre>
  <p>В первом запросе первого примера 6 mod 3 = 3 mod 3 = 0, можно показать, что для больших m нужное условие выполняться не будет.</p>

  <p>В третьем запросе первого примера 14 mod 4 = 2 mod 4 = 6 mod 4 = 2, можно показать, что для больших m нужное условие выполняться не будет.</p>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

using namespace std;
// данную задачу можно решить деревом отрезков
// поймем, что значит, что все числа равны по модулю m
// это значит, что все возможные разности этих чисел делятся на m
// но количество пар очень много, примерно n^2
// тогда заметим еще одну вещь, что если выбрать n-1 пару, которые будут образовывать дерево
// (ребро это пара чисел, которые мы взяли)
// если мы решим задачу для них, то решим для всех
// потому что все остальные расстояния(а разность можно сказать тоже самое что расстояние между числами)
// выражаются через выбранные арифметическими действиями + и -
// а значит их НОД(наиболший общий делитель) не изменится
// а, собственно говоря, его и ищем
// это значит, что все возможные разности этих чисел делятся на m == если хотим max(m) то это НОД всех возможных разностей
//
int gcd(int a, int b)//функция считает НОД двух чисел
{
	if (a &lt; b)
	{
		swap(a, b);
	}
	if (b == 0)
		return a;
	return gcd(b, a % b);
}

struct node//структура, которая отвечает за какой-то отрезок
{
	int z = 0;//какое-то число на этом отрезке, чтобы можно было соединять отрезки
	int nod = 0;//ответ на отрезке
};

vector&lt;node&gt; tree;//дерево отрезков
vector&lt;int&gt; a;//начальный массив

node mer(node a, node b)//функция слияния двух отрезков
{
	node c;
	c.nod = gcd(a.nod, b.nod);
	if (a.z > 0 && b.z > 0 && a.z != b.z)//тут происходит проверка на то, что мы соединяем или с пустым отрезком или что на отрезке все числа равны
	{
		int t = abs(a.z - b.z);
		c.nod = gcd(c.nod, t);
	}
	c.z = max(a.z, b.z);
	return c;
}

void build(int id, int tl, int tr)//построение дерева отрезков
{
	if (tl + 1 == tr)
	{
		tree[id].z = a[tl];
		return;
	}
	int mid = tl + tr >> 1;
	build(id * 2, tl, mid);
	build(id * 2 + 1, mid, tr);
	tree[id] = mer(tree[id * 2], tree[id * 2 + 1]);
}
node def;//пустой отрезок

node an(int id, int tl, int tr, int l, int r)//функция, собирающая ответ по дереву отрезков
{
	if (tl >= r || tr &lt;= l)
	{
		return def;
	}
	if (tl >= l && tr &lt;= r)
	{
		return tree[id];
	}
	int mid = tl + tr >> 1;
	return mer(an(id * 2, tl, mid, l, r), an(id * 2 + 1, mid, tr, l, r));
}

void slove()
{
	int n, q;
	cin >> n >> q;
	a.clear();
	tree.clear();
	a.resize(n);
	tree.resize(4 * n);
	for (int i = 0; i &lt; n; i++)
		cin >> a[i];
	build(1, 0, n);
	while (q--)
	{
		int l, r;
		cin >> l >> r; l--;
		cout &lt;&lt; an(1, 0, n, l, r).nod &lt;&lt; ' ';
	}
	cout &lt;&lt; endl;
}
int main()
{
	int t = 1;
	cin >> t;//количество наборов входных

	while (t--)
	{
		slove();//функция, которая решает один набор  входных данных
	}
}
</pre>
  </details>
</article>


<!-- Задача G. Развал дерева -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Развал дерева</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Дано дерево∗ из n вершин. Вы можете один раз выбрать две вершины a и b и удалить все вершины на пути из a в b, включая сами вершины. Если вы выберете a=b, то будет удалена только одна вершина.</p>

  <p>Ваша задача — найти максимальное количество компонент связности†, которое может образоваться после удаления пути из дерева.</p>

  <p>* Деревом называется связный граф без циклов.</p>

  <p>† Компонента связности это такое множество вершин, в котором из каждой вершины можно попасть по рёбрам в любую другую (и нельзя попасть в вершины, не принадлежащие этому множеству)</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит одно целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора содержит одно целое число n (2 ≤ n ≤ 2⋅10⁵) — размер дерева.</p>

  <p>Следующие n-1 строк содержат по два целых числа u и v (1 ≤ u, v ≤ n, u ≠ v) — вершины, соединённые ребром. Гарантируется, что рёбра образуют дерево.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превосходит 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно целое число — максимальное число компонент связности, которого можно добиться с помощью описанной операции.</p>

  <h4>Пример</h4>
<pre>
6
2
1 2
5
1 2
2 3
3 4
3 5
4
1 2
2 3
3 4
5
2 1
3 1
4 1
5 4
6
2 1
3 1
4 1
5 3
6 3
6
2 1
3 2
4 2
5 3
6 4
</pre>
<pre>
1
3
2
3
4
3
</pre>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

// задача на дп на поддеревьях
// будем обходить дфсом и собирать постепенно ответ и дп
//

vector&lt;vector&lt;int&gt; &gt; g;//список смежности графа
vector&lt;int&gt; dp;//ответ, если путь который мы удаляем пройдет через эту вершинку и пойдет дальше к корню
vector&lt;int&gt; ans;//ответ, если путь закончился в этой вершинке

void dfs(int v, int pr)//обычный дфс
{
	int col = 0;
	int m1 = 0;//лучшее значение dp сыновей
	int m2 = 0;//вторая по величине dp сыновей
	for (auto c : g[v])
	{
		if (pr != c)
		{
			dfs(c, v);//если это не отец, запускаем обход для сына
			if (m1 &lt; dp[c])
			{
				m2 = m1;
				m1 = dp[c];
			}
			else
			{
				if (m2 &lt; dp[c])
					m2 = dp[c];
			}
			col++;//считаем количество сыновей
		}
	}
	dp[v] = max(col, col - 1 + m1);//тогда мы или начнем удаляемый путь из текущей вершинки или продолжим из какого-то сына наверх к отцу
	ans[v] = max({ col + (pr != -1),dp[v] + (pr != -1), m1 + m2 + col - 2 + (pr != -1) });
	//
	// мы могли начать и закончить в этой вершинке
	// мы могли начать где-то в сыновьях и закончить в этой вершинке
	// мы могли начть в сыновьях, дойти до этой вершики и спуститься в другого сына
	// выбираем лучший вариант
	//
}

void slove()
{
	int n;
	cin >> n;
	//очистка и выделение памяти для глобальных переменных
	g.clear();
	dp.clear();
	ans.clear();
	g.resize(n);
	dp.resize(n);
	ans.resize(n);
	for (int i = 0; i &lt; n - 1; i++)//считывем граф и сохраняем в список смежности
	{
		int x, y;
		cin >> x >> y;
		x--; y--;
		g[x].push_back(y);
		g[y].push_back(x);
	}
	dfs(0, -1);
	cout &lt;&lt; *max_element(ans.begin(), ans.end()) &lt;&lt; endl;//выбираем лучший ответ из имеющихся
}
int main()
{
	int t = 1;
	cin >> t;//количество наборов входных

	while (t--)
	{
		slove();//функция, которая решает один набор  входных данных
	}
}
</pre>
  </details>
</article>
