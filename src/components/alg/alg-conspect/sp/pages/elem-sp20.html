<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p>Конспект курса</p>
  <p><a href="https://vkvideo.ru/@sportprog_yarsu" target="_blank">vkvideo.ru/@sportprog_yarsu</a></p>
</article>


<article class="article">
  <h1>Занятие 20 Графы#2. Поиск в ширину</h1>
  <p>Конспект видео от 2025.02.08</p>
  <p><a href="https://codeforces.com/group/1LSR3R5twn/contest/586871" target="_blank">Codeforces Контест 586871</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
    <a href="#p1">Графы#2. Поиск в ширину</a>
  </p>
  <p>
        <a href="#task1">Задача A. Путь</a>
    <br><a href="#task2">Задача B. Кратчайший путь</a>
    <br><a href="#task3">Задача C. Ребро на пути</a>
    <br><a href="#task4">Задача D. Вершина на пути</a>
    <br><a href="#task5">Задача E. Праздник</a>
    <br><a href="#task6">Задача F. Бейджик</a>
    <br><a href="#task7">Задача G. Диаметр графа</a>
    <br><a href="#task8">Задача H. Транспорт на Новый год</a>
    <br><a href="#task9">Задача I. Путешествие КORовьева</a>
    <br><a href="#task10">Задача J. Ярмарка</a>
    <br><a href="#task11">Задача K. Пасьянс</a>
    <br><a href="#task12">Задача L. Метро</a>
    <br><a href="#task13">Задача M. Брасс Бирмингем: монеты</a>
    <br><a href="#task14">Задача N. Брасс Бирмингем: пиво</a>
    <br><a href="#task15">Задача O. Непростительное заклятие (сложная версия)</a>
    <br><a href="#task16">Задача P. Непростительное заклятие (простая версия)</a>
  </p>
</article>


<!-- Графы#2. Поиск в ширину -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Графы#2. Поиск в ширину</h3>

  <h4>Поиск в ширину. BFS</h4>

  <p>Алгоритм поиск в ширину bfs (breadth first search) имеет огромное приложение в теории графов, как и алгоритм dfs. Алгоритм основан на трех принципах, а именно:</p>
  <ol>
    <li>обходим граф, посещая каждую вершину только один раз;</li>
    <li>использование структуры данных queue&lt;int&gt;;</li>
    <li>обходим граф по удаленности от вершины start, или так называемый
обход графа по слоям.</li>
  </ol>

  <p>При реализации алгоритма bfs будем выполнять последовательность действий:</p>
  <ol>
    <li>создаем очередь и добавляем в нее вершину start;</li>
    <li>вытаскиваем первую вершину x из очереди;</li>
    <li>рассматриваем все смежные вершины с x. Если смежная вершина не
была помечена, добавляем ее в очередь и помечаем;</li>
    <li>повторяем действия до тех пор, пока очередь не окажется пустой.</li>
  </ol>

  <p>Рассмотрим способы применения алгоритма bfs, приведем идеи решений и их реализации:</p>
  <ol>
    <li>поиск количества компонент связности;</li>
    <li>проверка существования пути от вершины a к вершине b;</li>
    <li>поиск кратчайшего пути от вершины start до вершины finish в
неориентированном невзвешенном графе;</li>
    <li>восстановление кратчайшего пути в неориентированном невзвешенном
графе;</li>
    <li>проверка графа на двудольность;</li>
    <li>поиск мостов между вершинами a и b (определенное ребро на
кратчайшем пути от a до b);</li>
    <li>поиск диаметра графа (дерева);</li>
    <li>поиск циклов (плохо).</li>
  </ol>

  <h4>Поиск количества компонент связности</h4>
  <p>Одной из самых простых задач является поиск количества компонент связности. Для ее решения воспользуемся алгоритмом bfs. Для решения задачи в main программы создадим переменную cnt, которая будет хранить ответ на задачу. Обойдем все вершины в графе. Если вершина x не была помечена, то запустим алгоритм bfs из вершины x.</p>

  <p>Приведем реализацию алоритма в виде функции bfs_number_comp. В аргументах функции bfs_number_comp передаем:</p>
  <ol>
    <li>vector &lt;vector&lt; int&gt; &gt; G — граф, представленный в виде списка смежности, где в каждой i строке каждая ячейка — это номер вершины, с которой смежна вершина с номером i;</li>
    <li>vector &lt;int&gt; Mark — вектор посещаемости. Mark[i] равняется 1, если до вершины с номером i построен путь, иначе равняется 0. Изначально каждая вершина считается не посещенной;</li>
    <li>start — вершина старта.</li>
  </ol>
  <p>Трудоемкость алгоритма O(m), где m — количество ребер.</p>
<pre>
void bfs_number_comp(
     vector&lt;vector&lt;int&gt; &gt;& G,
     vector&lt;int&gt;& Mark,
     int start) {
  queue&lt;int&gt; q;
  q.push(start);
  Mark[start] = 1;
  int tmp;

  while (q.size() > 0) {
    tmp = q.front();
    q.pop();
    for (int i = 0; i &lt; G[tmp].size(); i++) {
      if (Mark[G[tmp][i]] == 0) {
        Mark[G[tmp][i]] = 1;
        q.push(G[tmp][i]);
      }
    }
  }
}

int cnt = 0;
for (int i = 1; i &lt;= n; i++) {
  if (Mark[i] == 0) {
    cnt++;
    bfs_number_comp(G, Mark, i);
  }
}
cout &lt;&lt; cnt;
</pre>

  <p>Реализация BFS без очереди</p>
<pre>
void bfs_number_comp_no_queue(
     vector&lt;vector&lt;int&gt; &gt;& G,
     vector&lt;int&gt;& Mark,
     int start) {
  vector&lt;int&gt; Arr;
  int uk = 0, tmp;
  Arr.push_back(start);
  Mark[start] = 1;

  while (uk &lt; Arr.size()) {
    tmp = Arr[uk];
    uk++;
    for (int i = 0; i &lt; G[tmp].size(); i++) {
      if (Mark[G[tmp][i]] == 0) {
        Mark[G[tmp][i]] = 1;
        Arr.push_back(G[tmp][i])
      }
    }
  }
}
</pre>

  <h4>Проверка существования пути от вершины a к вершине b</h4>

  <p>Для поверки на запрос, существует ли путь от вершины a к вершине b, достаточно запустить функцию bfs_number_comp из вершины a и проверить Mark[b]. Это неплохое решение задачи, однако, если запросов на проверку много, программа будет долго работать. Для решения задачи воспользуемся вспомогательной памятью для запоминания, в какой компоненте связности располагается каждая вершина графа.</p>

  <p>Создадим дополнительный vector&lt;int&gt; Color, где для каждой i вершины будем хранить номер компоненты связности, в которой располагается вершина i. Если Color[a] == Color[b], это будет означать, что вершины лежат в одной компоненте связности.</p>

  <p>Улучшим реализацию функции bfs_number_comp. Добавим в аргументы функции:</p>
  <ol>
    <li>vector &lt;int&gt; Color — вектор покраски компонент связности. Color[i] равняется номеру цвета компоненты связности, в которой располагается вершина i;</li>
    <li>number_color — номер цвета компоненты связности.</li>
  </ol>
<pre>
void bfs_color(
     vector&lt;vector&lt;int&gt; &gt;& G,
     vector&lt;int&gt;& Mark,
     vector&lt;int&gt;& Color,
     int number_color,
     int start) {
  queue&lt;int&gt; q;
  q.push(start);
  Mark[start] = 1;
  Color[start] = number_color;
  int tmp

  while (q.size() > 0) {
    tmp = q.front();
    q.pop();
    for (int i = 0; i &lt; G[tmp].size(); i++) {
      if (Mark[G[tmp][i]] == 0) {
        Mark[G[tmp][i]] = 1;
        Color[G[tmp][i]] = number_color;
        q.push(G[tmp][i]);
      }
    }
  }
}
</pre>

  <h4>Поиск кратчайшего пути от вершины start до вершины finish</h4>

  <p>Поставим перед собой задачу определить длину кратчайшего пути от вершины start в вершину finish в неориентированном не взвешенном графе.</p>
  <p>Для поиска длины кратчайшего пути улучшим реализацию функции bfs_number_comp. Добавим вспомогательный vector &lt;int&gt; Len, где в Len[i] будет храниться целое число, длина кратчайшего пути от вершины start до i вершины. Ответом на задачу будет значение Len[finish].</p>
  <p>Реализуем функцию bfs_path, дополнив функцию bfs_number_comp. Добавим в аргументы функции:</p>
  <ol>
    <li>vector &lt;int&gt; Len — вектор длин путей. Len[i] равняется длине кратчайшего пути от вершины start до вершины i.</li>
  </ol>

<pre>
void bfs_path(
     vector&lt;vector&lt;int&gt; &gt;& G,
     vector&lt;int&gt;& Mark,
     vector&lt;int&gt;& Len,
     int start) {
  queue&lt;int&gt; q;
  q.push(start);
  Mark[start] = 1;
  Len[start] = 0;
  int tmp;

  while (q.size() > 0) {
    tmp = q.front();
    q.pop();
    for (int i = 0; i &lt; G[tmp].size(); i++) {
      if (Mark[G[tmp][i]] == 0) {
        Mark[G[tmp][i]] = 1;
        Len[G[tmp][i]] = 1 + Len[tmp];
        q.push(G[tmp][i]);
      }
    }
  }
}
</pre>

  <h4>Восстановление кратчайшего пути в неориентированном невзвешенном графе</h4>

  <p>В задачах иногда требуется не только определить длину кратчайшего пути, но и вывести сам кратчайший путь между парой вершин start и finish. Для вывода самого пути мы можем запомнить для каждой вершины x, из какой смежной вершины мы в нее прибыли. Для этого создадим вспомогательный vector&lt;int&gt; Putty, где в Putty[i] будет храниться номер смежной вершины, из которой мы при прибыли в вершину i.</p>

<pre>
void bfs_save_path(
     vector&lt;vector&lt;int&gt; &gt;& G,
     vector&lt;int&gt;& Mark,
     vector&lt;int&gt;& Len,
     vector&lt;int&gt; Putty,
     int start) {
  queue&lt;int&gt; q;
  q.push(start);
  Mark[start] = 1;
  Len[start] = 0;
  Putty[start] = start;
  int tmp;

  while (q.size() > 0) {
    tmp = q.front();
    q.pop();
    for (int i = 0; i &lt; G[tmp].size(); i++) {
      if (Mark[G[tmp][i]] == 0) {
        Mark[G[tmp][i]] = 1;
        Len[G[tmp][i]] = 1 + Len[tmp];
        Putty[G[tmp][i]] = tmp;
        q.push(G[tmp][i]);
      }
    }
  }
}
</pre>

  <p>Для восстановления пути из вершины start в вершину finish мы пройдем по Putty от вершины finish в вершину start. Таким образом, мы пройдем ребра в обратном порядке и сможем восстановить путь.</p>
<pre>
void find_path(
     vector&lt;int&gt; Putty,
     vector&lt;int&gt; Path,
     int start,
     int finish,
     int n) {
  Path.push_back(finish);
  int u = finish;

  while (u != Putty[u]) {
    Path.push_back(Putty[u]);
    u = Putty[u];
  }
  reverse(Path.begin(), Path.end());
}
</pre>

  <h4>Проверка графа на двудольность</h4>

  <p>Для проверки графа на двудольность мы должны покрасить его вершины в два цвета таким образом, чтобы любые две смежные вершины были покрашены в два разных цвета. Воспользуемся вспомогательным vector&lt;int&gt; Color, где в Color[i] будем запоминать, в какой цвет покрасили i вершину. Для проверки графа на двудольность потребуется проверить каждую компоненту связности, что она является двудольной, то есть в каждой компоненте связности потребуется запустить алгоритм bfs.</p>
  <p>Изменим реализацию функции bfs_color. Поменяем в ней способ использования vector&lt;int&gt; Color, добавим переменную flag для проверки на двудольность:</p>
  <ol>
    <li>vector&lt;int&gt; Color — вектор покраски вершин. Color[i] равняется цвету двудольности для вершины i 0 или 1;</li>
    <li>flag — флаг, проверяющий, что граф двудольный. Если flag равняется false, то граф не является двудольным, если true — граф двудольный.</li>
  </ol>

<pre>
void bfs_bipartite(
     vector&lt;vrctor&lt;int&gt; &gt;& G,
     vector&lt;int&gt;& Mark,
     vector&lt;int&gt;& Color,
     bool& flag,
     int start) {
  queue&lt;int&gt; q;
  q.push(start);
  Mark[start] = 1;
  Color[start] = 1;
  int tmp;

  while (q.size() > 0) {
    tmp = q.front();
    q.pop();
    for (int i = 0; i &lt; G[tmp].size(); i++) {
      if (Mark[G[tmp][i]] == 0) {
        Mark[G[tmp][i]] = 1;
        Color[G[tmp][i]] = (Color[tmp] + 1) % 2;
        q.push(G[tmp][i]);
      } else if (Color[G[tmp][i]] == Color[tmp]) {
        flag = false;
      }
    }
  }
}
</pre>
</article>


<!-- Задача A. Путь -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Путь</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 16мб</i></div>

  <p>В неориентированном графе требуется найти длину кратчайшего пути между двумя вершинами.</p>

  <h4>Входные данные</h4>
  <p>Сначала записано число N - количество вершин в графе (1 ≤ N ≤ 100). Затем записана матрица смежности (0 обозначает отсутствие ребра, 1 - наличие ребра). Затем записаны номера двух вершин - начальной и конечной.</p>

  <h4>Выходные данные</h4>
  <p>Выведите длину кратчайшего пути. Если пути не существует, выведите одно число -1.</p>

  <h4>Пример</h4>
<pre>
5
0 1 0 0 1
1 0 1 0 0
0 1 0 0 0
0 0 0 0 0
1 0 0 0 0
3 5
</pre>
  <code>3</code>
</article>


<!-- Задача B. Кратчайший путь -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Кратчайший путь</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам дан неориентированный граф. Найдите кратчайший путь от вершины a до вершины b.</p>

  <h4>Входные данные</h4>
  <p>В первой строке целое число n (1 ≤ n ≤ 10³) - количество вершин. Далее на вход подается матрица смежности данного графа. И в последней строке записаны 2 числа - стартовая и конечная вершина соответственно (1 ≤ a ≤ n, 1 ≤ b ≤ n).</p>

  <h4>Выходные данные</h4>
  <p>Если пути между a и b нет, выведите единственное число -1. Иначе выведите в первой строке l - длину кратчайшего пути между этими двумя вершинами в рёбрах, а во второй строке выведите l + 1 число — вершины этого пути.</p>

  <h4>Пример 1</h4>
<pre>
6
001000
000000
100000
000000
000001
000010
1 2
</pre>
  <code>-1</code>

  <h4>Пример 2</h4>
<pre>
6
010011
101111
010111
011010
111101
111010
3 4
</pre>
<pre>
1
3 4
</pre>
</article>


<!-- Задача C. Ребро на пути -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Ребро на пути</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам дан неориентированный граф, состоящий из n вершин и m ребер</p>
  <code>(1 ≤ n ≤ 1000, 1 ≤ m ≤ n⋅(n-1)/2)</code>
  <p>Вам необходимо ответить на t (1 ≤ t ≤ 2000) запросов, лежит ли ребро (a, b) на каком либо кратчайшем пути из вершины u в вершину v.</p>

  <h4>Входные данные</h4>
  <p>В первой строке вводится количество вершин и ребер графа. В последующих m строках вводится по одному ребру. Затем вводится число t количество запросов. Каждый запрос состоит из 4
  чисел в отдельной строке - номеров вершин u, v, a и b  соответственно.</p>

  <h4>Выходные данные</h4>
  <p>На каждый запрос вам необходимо вывести в отдельной строке "YES", если ребро (a,b) лежит на каком-нибудь кратчайшем пути между вершинами u и v и "NO" иначе.</p>

  <h4>Пример 1</h4>
<pre>
6 5
1 2
2 3
3 4
4 5
5 6
2
1 5 3 2
1 4 5 6
</pre>
<pre>
YES
NO
</pre>

  <h4>Пример 2</h4>
<pre>
6 6
1 2
2 3
3 4
4 5
5 6
1 6
4
1 5 3 2
1 5 6 1
1 4 1 2
1 5 3 2
</pre>
<pre>
NO
YES
YES
NO
</pre>
</article>


<!-- Задача D. Вершина на пути -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Вершина на пути</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам дан неориентированный граф, состоящий из n вершин и m ребер</p>
  <code>(1 ≤ n ≤ 1000, 1 ≤ m ≤ n⋅(n-1)/2)</code>
  <p>Вам необходимо ответить на t (1≤t≤2000) запросов, лежит ли вершина k на каком либо кратчайшем пути из вершины u в вершину v.</p>

  <h4>Входные данные</h4>
  <p>В первой строке вводится количество вершин и ребер графа. В последующих m строках вводится по одному ребру. Затем вводится число t количество запросов. Каждый запрос состоит из 3
  чисел в отдельной строке - номеров вершин u, v и k соответственно.</p>

  <h4>Выходные данные</h4>
  <p>На каждый запрос вам необходимо вывести в отдельной строке "YES", если вершина k лежит на каком-нибудь кратчайшем пути между вершинами u и v и "NO" иначе.</p>

  <h4>Пример 1</h4>
<pre>
6 5
1 2
2 3
3 4
4 5
5 6
2
1 5 3
1 4 6
</pre>
<pre>
YES
NO
</pre>

  <h4>Пример 2</h4>
<pre>
6 6
1 2
2 3
3 4
4 5
5 6
1 6
4
1 5 3
1 5 6
1 4 6
1 5 2
</pre>
<pre>
NO
YES
YES
NO
</pre>
</article>


<!-- Задача E. Праздник -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Праздник</h3>

  <div><i>Ограничение по времени 3с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В компании работает n сотрудников, пронумерованных от 1 до n. У каждого сотрудника либо нет руководителя, либо есть ровно один непосредственный руководитель — некоторый другой сотрудник с другим номером. Сотрудник A называется начальником другого сотрудника B, если выполняется хотя бы одно из двух условий:</p>
  <ul>
    <li>Сотрудник A — непосредственный руководитель сотрудника B.</li>
    <li>У сотрудника B есть непосредственный руководитель, сотрудник C, такой, что A является начальником сотрудника C.</li>
  </ul>

  <p>В структуре компании нет циклов. То есть никакой сотрудник не является начальником своего непосредственного руководителя.</p>

  <p>Сегодня компания собирается организовать праздник. Для этого необходимо разделить всех n сотрудников на несколько групп: каждый человек должен относиться ровно к одной группе. Более того, в каждой группе не должно быть таких двух сотрудников A и B, что A является начальником B.</p>

  <p>Ваша задача — найти наименьшее возможное количество таких групп.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число n (1 ≤ n ≤ 2000) — количество сотрудников.</p>

  <p>Следующие n строк содержат целые числа pi (1 ≤ pi ≤ n или pi = -1). Каждое pi обозначает непосредственного руководителя i-го сотрудника. Если pi равно -1, то i-ый сотрудник не имеет непосредственного руководителя.</p>

  <p>Гарантируется, что никакой сотрудник не является своим собственным непосредственным руководителем (pi ≠ i). Также гарантируется, что структура компании не содержит циклов.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное целое число — минимальное количество групп, на которые можно разделить всех сотрудников.</p>

  <h4>Пример</h4>
<pre>
5
-1
1
2
1
-1
</pre>
  <code>3</code>
  <p>В первом примере достаточно трех групп:</p>
  <ol>
    <li>Сотрудник 1</li>
    <li>Сотрудники 2 и 4</li>
    <li>Сотрудники 3 и 5</li>
  </ol>
</article>


<!-- Задача F. Бейджик -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Бейджик</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Как вы, возможно, знаете в ЛКШ за плохое поведение ставят дырки в бейджик. Вот и сегодня один из суровых преподавателей поймал группу из n школьников за очередной проделкой. Пронумеруем для удобства школьников в этой группе от 1 до n.</p>

  <p>Преподаватель подошёл к школьнику a и поставил ему дырку в бейджик. Тот, правда, попытался оправдаться, что зачинщиком бы некоторый другой школьник pa.</p>

  <p>После этого преподаватель подошёл к школьнику pa и поставил дырку в бейджик и ему. Тот в ответ послал его к школьнику ppa.</p>

  <p>Так продолжалось некоторое время, но, так как количество школьников было конечно, то через некоторое время преподаватель пришёл к школьнику, которому он уже поставил дырку.</p>

  <p>После этого он поставил в бейдж этого школьника вторую дырку и счёл на этом свой долг выполненным.</p>

  <p>Вы не знаете с какого школьника a начал преподаватель. Но вы знаете все числа pi. Выясните для каждого возможного школьника a того школьника, которому была поставлена вторая дырка.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит одно целое число n (1 ≤ n ≤ 1000) — количество нашкодивших школьников.</p>

  <p>Вторая строка содержит n целых чисел p1, ..., pn (1 ≤ pi ≤ n), где pi это номер школьника, к которому посылает преподавателя школьник под номером i.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого школьника a от 1 до n выведите номер школьника, которому поставят две дырки, если преподаватель начнёт ставить дырки со школьника a.</p>

  <h4>Пример 1</h4>
<pre>
3
2 3 2
</pre>
  <code>2 2 3</code>

  <h4>Пример 2</h4>
<pre>
3
1 2 3
</pre>
  <code>1 2 3</code>
  <p>В первом примере, если a=1, то преподаватель подойдёт к школьникам 1, 2, 3, 2, тем самым вторую дырку получит школьник 2.</p>

  <p>В первом примере, если a=2, то преподаватель подойдёт к школьникам 2, 3, 2 и школьник 2 получит вторую дырку в бейдж. Если a=3, то учитель подойдёт к школьникам 3, 2, 3, тем самым школьник 3 получит вторую дырку в бейджик.</p>

  <p>Во втором примере с какого бы школьника не начал преподаватель, этот же школьник и будет тем, кто получит вторую дырку в бейджике.</p>
</article>


<!-- Задача G. Диаметр графа -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Диаметр графа</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>CQXYM хочет построить связный неориентированный граф на n
  вершинах с m ребер и диаметром, строго меньшим k-1.</p>

  <p>Также CQXYM не хочет, чтобы граф имел петли или кратные ребра (то есть каждое ребро соединяет две различные вершины, между любой парой вершин проведено не более чем одно ребро).</p>

  <p>Диаметр графа — это максимальное расстояние между любыми двумя его вершинами.</p>

  <p>Расстояние между двумя вершинами — наименьшее количество ребер в пути, концами которого являются эти вершины.</p>

  <p>CQXYM задается вопросом, можно ли построить такой граф.</p>

  <h4>Входные данные</h4>
  <p>Входные данные состоят из нескольких тестовых примеров.</p>

  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10⁵) — количество тестовых примеров. Ниже приводится описание тестовых случаев.</p>

  <p>Единственная для каждого тестового случая строка содержит три целых числа: n (1 ≤ n ≤ 10⁹), m, k (0 ≤ m, k ≤ 10⁹).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого тестового случая выведите YES, если построить граф возможно, и NO в противном случае. Вы можете выводить буквы в любом регистре (верхнем или нижнем).</p>

  <h4>Пример</h4>
<pre>
5
1 0 3
4 5 3
4 6 3
5 4 1
2 1 1
</pre>
<pre>
YES
NO
YES
NO
NO
</pre>
  <p>В первом тестовом случае диаметр графа равен 0.</p>

  <p>Во втором случае диаметр графа может быть только 2.</p>

  <p>В третьем случае диаметр графа может быть только 1.</p>
</article>


<!-- Задача H. Транспорт на Новый год -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Транспорт на Новый год</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Новый год приходит в Линейный мир! В этом мире есть n ячеек, пронумерованных целыми числами от 1 до n, уложенных в виде доски размером 1 x n. В ячейках живут люди. Однако, передвигаться между различными ячейками сложно, ведь выйти из ячейки — дело непростое. В то же время, люди хотят знакомиться с людьми, живущими в других ячейках.</p>

  <p>И вот, tncks0121 придумал систему транспорта для передвижения между ячейками, чтобы люди могли отпраздновать Новый год. Сперва он задумал n - 1 положительных целых чисел a1, a2, ..., an - 1. Для каждого целого числа i, где 1 ≤ i ≤ n - 1, выполняется условие 1 ≤ ai ≤ n - i. Затем он создал n - 1 порталов, пронумерованных целыми числами от 1 до n - 1. Из них i-й (1 ≤ i ≤ n - 1) портал соединяет ячейку номер i и ячейку номер (i + ai), т. е. с его помощью можно путешествовать из ячейки i в ячейку (i + ai). К сожалению, портал не работает в обратную сторону, то есть нельзя пройти из ячейки (i + ai) в ячейку i по i-му порталу. Легко заметить, что из-за условия 1 ≤ ai ≤ n - i нельзя покинуть Линейный мир, пользуясь порталами.</p>

  <p>Я нахожусь в ячейке 1 и хочу пройти в ячейку t. Однако я не знаю, могу ли я там оказаться. Пожалуйста, определите, могу ли я пройти в ячейку t, пользуясь только построенной системой транспорта.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано два целых числа через пробел, n (3 ≤ n ≤ 3 x 10⁴) и t (2 ≤ t ≤ n) — количество ячеек и номер ячейки, в которую я хочу попасть.</p>

  <p>Во второй строке записано n - 1 целых чисел через пробел a1, a2, ..., an - 1 (1 ≤ ai ≤ n - i). Гарантируется, что пользуясь данной транспортной системой, покинуть Линейный мир нельзя.</p>

  <h4>Выходные данные</h4>
  <p>Если я могу дойти до ячейки t по данной транспортной системе, выведите "YES". В противном случае, выведите "NO".</p>

  <h4>Пример 1</h4>
<pre>
8 4
1 2 1 2 1 2 1
</pre>
  <code>YES</code>

  <h4>Пример 2</h4>
<pre>
8 5
1 2 1 2 1 1 1
</pre>
  <code>NO</code>
  <p>В первом примере можно дойти до t, посетив следующие ячейки: 1, 2, 4.</p>

  <p>Во втором примере можно посетить лишь ячейки 1, 2, 4, 6, 7, 8; значит, мы не можем попасть в требуемую ячейку 5.</p>
</article>


<!-- Задача I. Путешествие КORовьева -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача I. Путешествие КORовьева</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Коровьев (или Фагот) — старший подчинённый Воланда. Поэтому ему вместе с котом Бегемотом часто приходится выполнять поручения мессира. Но, кажется, на этот раз им не обойтись без Вашей помощи!</p>

  <p>Воланд раздобыл карту города и хочет попасть в театр, где он будет демонстрировать сеансы чёрной магии с её полным разоблачением. На карте отмечены точки (дома), и их соединяют дороги. На дорогах написаны их протяжённости. Свита Воланда сейчас находится в одном из домов, отмеченных на карте. Театр тоже отмечен на карте.</p>

  <p>Воланд попросил Коровьева и Бегемота разработать самый короткий маршрут от дома до театра. Но не всё так просто, ведь Воланд — не обычный смертный и обладает сверхспособностями. Поэтому он считает длиной маршрута побитовый OR длин дорог на этом маршруте (о том, что такое побитовый OR читайте в примечании).</p>

  <p>Коровьев и Бегемот сами не справятся с такой сложной задачей, ведь на карте очень много домов и дорог. Они обратились за помощью к Вам. Помогите им! Напишите программу, которая будет решать эту задачу.</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержатся два натуральных числа — n и m (2 ≤ n ≤ 10⁵, 1 ≤ m ≤ 10⁵).</p>

  <p>Каждая из следующих m строк содержит 3 целых числа — pᵢ, qᵢ, wᵢ (1 ≤ pᵢ, qᵢ, ≤ n, 0 ≤ wᵢ ≤ 10⁹, pᵢ ≠ qᵢ), где pᵢ и qᵢ — вершины, соединяемые i-м ребром, а wᵢ — вес этого ребра. Гарантируется, что граф не содержит кратных ребер.</p>

  <p>Последняя строка содержит два натуральных числа — a и b (1 ≤ a, b ≤ n, a ≠ b) — вершины, между которыми требуется найти путь наименьшего веса (дом Воланда и театр).</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите целое число — наименьший вес по всем путям между a и b. Если между a и b не существует пути, то выведите «-1» (без кавычек)</p>

  <h4>Пример 1</h4>
<pre>
3 3
1 2 5
1 3 1
2 3 5
1 2
</pre>
  <code>5</code>

  <h4>Пример 2</h4>
<pre>
5 3
3 5 6
1 4 7
2 4 6
1 3
</pre>
  <code>-1</code>
  <p>Побитовый OR двух чисел вычисляется следующим образом: cначала оба числа переводятся в двоичную систему счисления, затем одно записывается под другим. i-й бит результата будет равен единице, если i-й бит первого числа равен единице и/или i-й бит второго числа равен единице.</p>

  <p>Например, 10 OR 6 = 1010₂ OR 0110₂ = 1110₂ = 14.</p>

  <p>В большинстве языков программирования побитовый OR уже встроен. В языках C++, Python эта операция обозначается как |, в Pascal — это операция or, в Visual Basic — это операция Or.</p>
</article>


<!-- Задача J. Ярмарка -->
<article class="article">
  <div class="anchor" id="task10"></div>
  <h3>Задача J. Ярмарка</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 512мб</i></div>

  <p>В Байтландии собираются провести ярмарку. В Байтландии n городов, которые соединены m двухсторонними дорогами, причём из любого города можно доехать до любого другого, передвигаясь только по дорогам.</p>

  <p>В Байтландии производят k
  различных товаров, причём каждый город специализируется на одном товаре. Чтобы ярмарка состоялась, на неё нужно привезти хотя бы s различных товаров. Чтобы привезти товары из города u в город v нужно потратить d(u,v) монет, где d(u,v) — длина кратчайшего пути между городами u и v. Длина пути — это количество дорог, которые входят в этот путь.</p>

  <p>Организаторы ярмарки оплатят перевозку товаров, однако они сами могут выбрать, производителей из каких городов пригласить на ярмарку. Теперь организаторы хотят для каждого из n городов посчитать, какое минимальное количество монет нужно потратить на перевозку товаров, чтобы провести ярмарку в этом городе.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записаны 4 целых числа n, m, k, s (1 ≤ n ≤ 10⁵, 0 ≤ m ≤ 10⁵, 1 ≤ s ≤ k ≤ min(n, 100)) — количество городов, количество дорог, количество различных товаров, количество различных товаров необходимых для проведения ярмарки.</p>

  <p>В следующей строке записаны n чисел a1, a2, ... ,an (1 ≤ ai ≤ k), где ai — номер товара, который производится в i-м городе. Гарантируется, что среди чисел ai встречаются все числа от 1 до k.</p>

  <p>В следующих m строках описываются дороги. Каждая дорога описывается парой u v городов, которые она соединяет (1 ≤ u,v ≤ n, u ≠ v). Гарантируется, что между любой парой городов не более одной дороги. Гарантируется, что можно доехать из любого города в любой, двигаясь только по дорогам.</p>

  <h4>Выходные данные</h4>
  <p>Выведите n чисел, i-е из которых — минимальное количество монет на перевозку товаров при проведении ярмарки в городе i. Разделяйте числа пробелами.</p>

  <h4>Пример 1</h4>
<pre>
5 5 4 3
1 2 4 3 2
1 2
2 3
3 4
4 1
4 5
</pre>
  <code>2 2 2 2 3</code>

  <h4>Пример 2</h4>
<pre>
7 6 3 2
1 2 3 3 2 2 1
1 2
2 3
3 4
2 5
5 6
6 7
</pre>
  <code>1 1 1 2 2 1 1</code>
  <p>Рассмотрим первый пример.</p>

  <p>Чтобы провести ярмарку в городе 1, можно привезти товары из городов 1 (0 монет), 2 (1 монета) и 4 (1 монета). Суммарное количество монет равно 2.</p>

  <p>Город 2: Товары из городов 2 (0), 1 (1), 3 (1). Сумма 2.</p>

  <p>Город 3: Товары из городов 3 (0), 2 (1), 4 (1). Сумма 2.</p>

  <p>Город 4: Товары из городов 4 (0), 1 (1), 5 (1). Сумма 2.</p>

  <p>Город 5: Товары из городов 5 (0), 4 (1), 3 (2). Сумма 3.</p>
</article>


<!-- Задача K. Пасьянс -->
<article class="article">
  <div class="anchor" id="task11"></div>
  <h3>Задача K. Пасьянс</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Мальчик Вася хочет разложить древнерусский пасьянс под названием «Боян». Пасьянс раскладывается по следующим правилам:</p>
  <ul>
    <li>Колода из n карт тщательно перемешивается, после чего все n карт выкладываются на стол в ряд слева направо;</li>
    <li>Перед каждым ходом на столе лежат в ряд несколько стопок карт (изначально n стопок, в каждой стопке по одной карте). Пронумеруем эти стопки слева направо от 1 до x. За один ход разрешается целиком переместить стопку с наибольшим номером x (то есть самую правую из оставшихся) на стопку x - 1 (если такая существует) или на стопку x - 3 (если такая существует). При этом одну стопку можно переместить на другую, только если верхние карты этих стопок имеют одинаковые масти или достоинства. Заметим, что если стопка x перемещается на стопку y, верхняя карта стопки x становится верхней картой результирующей стопки. Также заметим, что после каждого хода общее количество стопок уменьшается на 1;</li>
    <li>Пасьянс считается разложенным, если все карты находятся в одной стопке.</li>
  </ul>
  <p>Вася уже перемешал карты и выложил их на стол, помогите ему понять, можно разложить пасьянс из этих карт или нет.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных записано единственное целое число n (1 ≤ n ≤ 52) — количество карт в колоде Васи. В следующей строке записано n строк через пробел c1, c2, ..., cn, где строка ci описывает i-ую выложенную на стол карту колоды. Каждая строка ci состоит ровно из двух символов, первый символ обозначает достоинство карты, второй — масть. Карты на столе пронумерованы слева направо.</p>

  <p>Достоинство карты описывается одним из символов: «2», «3», «4», «5», «6», «7», «8», «9», «T», «J», «Q», «K», «A». Масть карты описывается одним из символов: «S», «D», «H», «C».</p>

  <p>Не гарантируются, что в колоде присутствуют все возможные карты. Также карты в колоде Васи могут повторяться.</p>

  <h4>Выходные данные</h4>
  <p>Выведите в единственной строке ответ на задачу: строку «YES» (без кавычек), если разложить пасьянс возможно, строку «NO» (без кавычек) в противном случае.</p>

  <h4>Пример 1</h4>
<pre>
4
2S 2S 2C 2C
</pre>
  <code>YES</code>

  <h4>Пример 2</h4>
<pre>
2
3S 2C
</pre>
  <code>NO</code>
  <p>В первом примере можно действовать так:</p>
  <ul>
    <li>переложить 4-ую стопку на 1-ую;</li>
    <li>переложить 3-ую стопку на 2-ую;</li>
    <li>переложить 2-ую стопку на 1-ую.</li>
  </ul>
  <p>Во втором примере разложить пасьянс никак нельзя.</p>
</article>


<!-- Задача L. Метро -->
<article class="article">
  <div class="anchor" id="task12"></div>
  <h3>Задача L. Метро</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Классическая для городов Берляндии схема метрополитена представляет собой набор n станций, соединенных n переездами, каждый из которых соединяет ровно две станции и не проходит через какие-либо другие. Кроме того, в классической схеме с каждой станции можно добраться до любой другой, двигаясь по переездам. Переезды можно использовать в обе стороны для перемещения. Между каждой парой станций — не более одного переезда.</p>

  <p>Недавно математики Берляндии доказали теорему, согласно которой в любой классической схеме существует кольцевая и притом ровно одна. Иными словами, в любой классической схеме можно найти единственный цикл из станций (в котором любые две соседние соединены переездом), и этот цикл не содержит никакую станцию более одного раза.</p>

  <p>Это открытие имело мощный социальный эффект — ведь теперь станции можно было сравнивать по принципу их удаления от кольцевой. Например, один житель мог сказать: «я живу в трех переездах от кольцевой», а другой ему ответить: «неудачник, а — я в одном». В интернете стали появляться приложения, предлагающие рассчитать удаленность станции от кольцевой (пошлите смс на короткий номер...).</p>

  <p>Правительство Берляндии решило положить конец этим беспорядкам и взять ситуацию в свои руки. Вам поручено написать программу, которая по схеме метрополитена города для каждой станции определит удаленность от кольцевой.</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержится целое число n (3 ≤ n ≤ 3000), n — количество станций (и одновременно переездов) в схеме метро. Далее в n строках содержатся описания переездов, по одному в строке. Каждая строка содержит пару целых чисел xᵢ, yᵢ (1 ≤ xᵢ, yᵢ ≤ n), и обозначает наличие переезда со станции xᵢ до станции yᵢ. Станции пронумерованы от 1 до n в произвольном порядке. Гарантируется, что xᵢ ≠ yᵢ и то, что между каждой парой станций не более одного переезда. Переезды можно использовать для перемещения в обе стороны. Гарантируется, что заданное описание представляет собой классическую схему метрополитена.</p>

  <h4>Выходные данные</h4>
  <p>Выведите n чисел. Числа разделяйте пробелами, i-ое из них должно быть равно удалению i-ой станции от кольцевой. Для станций на кольцевой выводите число 0.</p>

  <h4>Пример 1</h4>
<pre>
4
1 3
4 3
4 2
1 2
</pre>
  <code>0 0 0 0</code>

  <h4>Пример 2</h4>
<pre>
6
1 2
3 4
6 4
2 3
1 3
3 5
</pre>
  <code>0 0 0 1 1 2</code>
</article>


<!-- Задача M. Брасс Бирмингем: монеты -->
<article class="article">
  <div class="anchor" id="task13"></div>
  <h3>Задача M. Брасс Бирмингем: монеты</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Сегодня Игорь и Ира вместе с друзьями — Сашей и Лешей — играют в новую настольную игру «Brass Birmingham».</p>

  <p>В каждом раунде игроки по очереди делают ходы. Во время хода игрок может построить производство в городах или дорогу, которая соединяет два города, либо выполнить действие. За все свои постройки игроки платят деньги, ведь в этой игре, как и в реальном мире, всё стоит денег. В конце своего хода игрок выстраивает башенку из потраченных монет и кладет её рядом со своей фигуркой в поле оплаты, а в конце раунда потраченные монеты возвращаются в банк.</p>

  <p>Игорь хочет как можно быстрее начать следующий раунд, поэтому решил оптимизировать процесс возвращения денег в банк. Так, за одну операцию он собирает монеты одного номинала со всех верхушек башенок. Сколько раз Игорю придется повторить эту операцию, чтобы начать новый раунд как можно быстрее?</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержится целое число n (1 ≤ n ≤ 30) — количество различных номиналов монет.</p>

  <p>Во второй строке содержатся четыре целых числа mᵢ (1 ≤ mᵢ ≤ 30,1 ≤ i ≤ 4) — количество монет в башенке i -го игрока.</p>

  <p>В последующих четырёх строках содержится описание башенок каждого игрока. В i-й из них записано mᵢ целых чисел k<sub>ij</sub> (1 ≤ k<sub>ij</sub> ≤ n, 1 ≤ i ≤ 4, 1 ≤ j ≤ mᵢ) — номинал монеты с номером j. Монеты нумеруются снизу вверх.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите число — минимальное количество операций, необходимое Игорю, чтобы вернуть все монетки в банк.</p>

  <h4>Пример 1</h4>
<pre>
5
2 2 2 2
1 1
1 2
1 3
1 4
</pre>
  <code>4</code>

  <h4>Пример 2</h4>
<pre>
5
3 2 3 2
1 1 1
3 2
2 2 3
4 5
</pre>
  <code>6</code>
</article>


<!-- Задача N. Брасс Бирмингем: пиво -->
<article class="article">
  <div class="anchor" id="task14"></div>
  <h3>Задача N. Брасс Бирмингем: пиво</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Сегодня Игорь и Ира вместе с друзьями — Сашей и Лешей — решили поиграть в новую настольную игру «Brass Birmingham».</p>

  <p>В каждом раунде игроки делают ходы по очереди. Во время хода игрок может построить производство в городах, дорогу, соединяющую два города, либо выполнить действие.</p>

  <p>В свой ход Игорь хочет открыть как можно больше своих заводов. Для того, чтобы открыть один завод, игроку требуется перенести к заводу ровно один бочонок «пива», ведь без бочонка «пива» не получится торжественно открыть предприятие. Таким образом, чем больше бочонков «пива» Игорь подвезёт, тем больше заводов он сможет открыть.</p>

  <p>Бочонки «пива» располагаются на пивоварнях, ранее построенных игроками. На каждой пивоварне располагается ровно один бочонок «пива».</p>

  <p>Для открытия заводов Игорь хочет использовать свои бочонки «пива», которые он заготовил ранее. Если их окажется недостаточно, то Игорю придется использовать бочонки «пива» других игроков.</p>

  <p>Правила игры гласят, что бочонки «пива» со своих пивоварен можно использовать без ограничений. Если же игрок хочет перенести бочонок «пива» с чужой пивоварни для построения своего завода, то данное действие можно сделать, только если завод и пивоварня находятся в одном городе, либо между пивоварней и заводом существует путь по дорогам.</p>

  <p>Какое количество своих и чужих бочонков «пива» использует Игорь?</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое число N (2 ≤ N ≤ 10⁵) — количество городов в игре.</p>

  <p>Во второй строке записано целое число M (1 ≤ M ≤ 10⁵) — количество заводов, которые хочет открыть Игорь.</p>

  <p>В третьей строке записано M целых чисел mᵢ (1 ≤ mᵢ ≤N) — города, в которых Игорь хочет открыть заводы. В одном городе может быть несколько заводов.</p>

  <p>В четвертой строке записано целое число K (1 ≤ K ≤ 10⁵) — количество пивоварен Игоря.</p>

  <p>В пятой строке записано K целых чисел kᵢ (1 ≤ kᵢ ≤ N) — города, в которых располагаются пивоварни Игоря. В одном городе может быть несколько пивоварен Игоря.</p>

  <p>В шестой строке записано целое число L (1 ≤ L ≤ 10⁵) — количество пивоварен других игроков.</p>

  <p>В седьмой строке записано L целых чисел lᵢ (1 ≤ lᵢ ≤ N) — города, в которых располагаются пивоварни других игроков. В одном городе может быть несколько пивоварен других игроков.</p>

  <p>В восьмой строке записано целое число G (1 ≤ G ≤ 10⁵) — количество уже построенных дорог.</p>

  <p>В следующих G строках записаны пары целых чисел aᵢ, bᵢ (1 ≤ aᵢ, bᵢ ≤ N) — города, которые соединяются дорогой с номером i.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите два целых числа, разделенных пробелом: количество своих и количество чужих бочонков «пива», которое потребуются Игорю.</p>

  <h4>Пример 1</h4>
<pre>
8
4
1 4 3 2
2
2 8
4
8 7 6 5
4
1 2
2 3
4 3
4 5
</pre>
  <code>2 1</code>

  <h4>Пример 2</h4>
<pre>
6
5
2 3 5 2 5
2
1 2
8
2 2 1 6 4 1 2 3
9
4 3
5 2
4 6
1 2
5 6
6 5
1 2
3 4
6 1
</pre>
  <code>2 3</code>
</article>


<!-- Задача O. Непростительное заклятие (сложная версия) -->
<article class="article">
  <div class="anchor" id="task15"></div>
  <h3>Задача O. Непростительное заклятие (сложная версия)</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Это сложная версия задачи. В этой версии нет дополнительных ограничений на число k.</p>

  <p>Верховный чародей Визенгамота однажды поймал злого волшебника Drahyrt, но злой волшебник вернулся и хочет отомстить верховному чародею. Поэтому он украл у его ученика Гарри заклинание s.</p>

  <p>Заклинание — это строка длины n, состоящая из строчных латинских букв.</p>

  <p>Drahyrt хочет заменить заклинание на непростительное заклятие — строку t.</p>

  <p>Drahyrt с помощью древней магии может менять местами буквы на расстоянии k или k+1 в заклинании сколько угодно раз. Другими словами, Drahyrt может поменять буквы на позициях i и j в заклинании s если |i-j|=k или |i-j|=k+1.</p>

  <p>Например, если k=3,s= «talant» и t= «atltna», то Drahyrt может действовать следующим образом:</p>
  <ul>
    <li>поменять местами буквы на позициях 1 и 4, получив заклинание «aaltnt».</li>
    <li>поменять местами буквы на позициях 2 и 6, получив заклинание «atltna».</li>
  </ul>

  <p>Вам даны заклинания s и t. Может ли Drahyrt изменить заклинание s на t?</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных дано единственное целое число T (1 ≤ T ≤ 10⁴) — количество наборов входных данных в тесте.</p>

  <p>Далее следуют описания наборов входных данных.</p>

  <p>В первой строке содержится два целых числа n,k (1 ≤ n ≤ 2⋅10⁵, 1 ≤ k ≤ 2⋅10⁵) — длина заклинаний и число k такое, что Drahyrt может менять буквы в заклинании на расстоянии k или k+1.</p>

  <p>Во второй строке дано заклинание s — строка длины n, состоящая из строчных латинских букв.</p>

  <p>В третьей строке дано заклинание t — строка длины n, состоящая из строчных латинских букв.</p>

  <p>Гарантируется, что сумма значений n по всем наборам входных данных не превосходит 2⋅10⁵. Обратите внимание, что ограничений на сумму значений k по всем наборам входных данных нет.</p>

  <h5>Выходные данные</h5>
  <p>Для каждого набора входных данных выведите в отдельной строке «YES» если Drahyrt может изменить заклинание s на t и «NO» иначе.</p>

  <p>Вы можете выводить ответ в любом регистре (например, строки «yEs», «yes», «Yes» и «YES» будут распознаны как положительный ответ).</p>

  <h4>Пример</h4>
<pre>
7
6 3
talant
atltna
7 1
abacaba
aaaabbc
12 6
abracadabraa
avadakedavra
5 3
accio
cicao
5 4
lumos
molus
4 3
uwjt
twju
4 3
kvpx
vxpk
</pre>
<pre>
YES
YES
NO
YES
NO
YES
NO
</pre>

  <p>Первый пример разобран в условии.</p>

  <p>Во втором примере можно менять соседние буквы местами, так что можем отсортировать строку например с помощью сортировки пузырьком.</p>

  <p>В третьем примере можно показать, что из строки s невозможно получить строку t меняя местами буквы на расстоянии 6 или 7.</p>

  <p>В четвертом примере подходит например следующая последовательность преобразований:</p>
  <code>«accio» → «aocic» → «cocia» → «iocca» → «aocci» → «aicco» → «cicao».</code>

  <p>В пятом примере можно показать, что невозможно получить из строки s строку t.</p>

  <p>В шестом примере достаточно поменять местами две крайние буквы.</p>
</article>


<!-- Задача P. Непростительное заклятие (простая версия) -->
<article class="article">
  <div class="anchor" id="task16"></div>
  <h3>Задача P. Непростительное заклятие (простая версия)</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Это простая версия задачи. В этой версии k всегда равно 3.</p>

  <p>Верховный чародей Визенгамота однажды поймал злого волшебника Drahyrt, но злой волшебник вернулся и хочет отомстить верховному чародею. Поэтому он украл у его ученика Гарри заклинание s.</p>

  <p>Заклинание — это строка длины n, состоящая из строчных латинских букв.</p>

  <p>Drahyrt хочет заменить заклинание на непростительное заклятие — строку t.</p>

  <p>Drahyrt с помощью древней магии может менять местами буквы на расстоянии k или k+1 в заклинании сколько угодно раз. В этой версии задачи можно менять буквы на расстоянии 3 или 4. Другими словами, Drahyrt может поменять буквы на позициях i и j в заклинании s если |i-j|=3 или |i-j|=4.</p>

  <p>Например, если s= «talant» и t= «atltna», то Drahyrt может действовать следующим образом:</p>
  <ul>
    <li>поменять местами буквы на позициях 1 и 4, получив заклинание «aaltnt».</li>
    <li>поменять местами буквы на позициях 2 и 6, получив заклинание «atltna».</li>
  </ul>

  <p>Вам даны заклинания s и t. Может ли Drahyrt изменить заклинание s на t?</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных дано единственное целое число T (1≤T≤104) — количество наборов входных данных в тесте.</p>

  <p>Далее следуют описания наборов входных данных.</p>

  <p>В первой строке содержится два целых числа n,k (1≤n≤2⋅105, k=3) — длина заклинаний и число k такое, что Drahyrt может менять буквы в заклинании на расстоянии k
  или k+1.</p>

  <p>Во второй строке дано заклинание s — строка длины n, состоящая из строчных латинских букв.</p>

  <p>В третьей строке дано заклинание t — строка длины n, состоящая из строчных латинских букв.</p>

  <p>Гарантируется, что сумма значений n по всем наборам входных данных не превосходит 2⋅105. Обратите внимание, что ограничений на сумму значений k по всем наборам входных данных нет.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите в отдельной строке «YES» если Drahyrt может изменить заклинание s на t и «NO» иначе.</p>

  <p>Вы можете выводить ответ в любом регистре (например, строки «yEs», «yes», «Yes» и «YES» будут распознаны как положительный ответ).</p>

  <h4>Пример</h4>
<pre>
7
6 3
talant
atltna
7 3
abacaba
aaaabbc
12 3
abracadabraa
avadakedavra
5 3
accio
cicao
5 3
lumos
molus
4 3
uwjt
twju
4 3
kvpx
vxpk
</pre>
<pre>
YES
YES
NO
YES
NO
YES
NO
</pre>
  <p>Первый пример разобран в условии.</p>

  <p>Во втором примере можно действовать следующим образом:</p>
  <ol>
    <li>Поменять местами буквы на позициях 2 и 5 (расстояние 3), тогда получим заклинание «aaacbba».</li>
    <li>Поменять местами буквы на позициях 4 и 7 (расстояние 3), тогда получим заклинание «aaaabbc».</li>
  </ol>

  <p>В третьем примере можно показать, что из строки s невозможно получить строку t меняя местами буквы на расстоянии 3 или 4.</p>

  <p>В четвертом примере подходит например следующая последовательность преобразований:</p>
  <code>«accio» → «aocic» → «cocia» → «iocca» → «aocci» → «aicco» → «cicao».</code>

  <p>В пятом примере можно показать, что невозможно получить из строки s строку t.</p>

  <p>В шестом примере достаточно поменять местами две крайние буквы.</p>
</article>

