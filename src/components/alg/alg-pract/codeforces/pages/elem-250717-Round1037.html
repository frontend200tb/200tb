<article class="article">
  <a href="https://codeforces.com/contest/2126" target="_blank">Codeforces 2126 Round 1037 (Div.3) 2025-07-17</a>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

      <a href="#task1">Задача A. Всего одна цифра</a>
  <br><a href="#task2">Задача B. В горах нет казино</a>
  <br><a href="#task3">Задача C. Сейчас точно успею</a>
  <br><a href="#task4">Задача D. Это точно в последний раз</a>
  <br><a href="#task5">Задача E. Н-О-Д, не повезло!</a>
  <br><a href="#task6">Задача F. 1-1-1, бесплатное дерево!</a>
  <br><a href="#task7">Задача G1. Большие выигрыши! (простая версия)</a>
  <br><a href="#task8">Задача G2. Большие выигрыши! (сложная версия)</a>
</article>


<!-- Задача A. Всего одна цифра -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Всего одна цифра</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам дано целое число x. Необходимо найти наименьшее неотрицательное целое число y такое, что у чисел x и y есть хотя бы одна общая цифра. Иными словами, должна существовать такая десятичная цифра d, которая входит в запись как числа x, так и числа y.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 1000) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора содержит одно целое число x (1 ≤ x ≤ 1000).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно целое число y — минимальное неотрицательное число, удовлетворяющее условию.</p>

  <details>
    <summary>Пример</summary>
<pre>
5
6
96
78
122
696
</pre>
<pre>
6
6
7
1
6
</pre>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
// условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int x; // целое число от 1 до 1000
    cin >> x;

    // решение
    int minx = 9;
    while (x > 0) {
      int digit = x % 10;
      x /= 10;
      if (digit &lt; minx) {
        minx = digit;
      }
    }

    // вывод результата
    cout &lt;&lt; minx &lt;&lt; '\n';
  }

}
</pre>
  </details>
</article>


<!-- Задача B. В горах нет казино -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. В горах нет казино</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Дан массив a из n чисел и число k. Значение ai описывает погоду в i-й день: если в i-й день будет дождь, то ai = 1, иначе в i-й день будет хорошая погода и ai=0.</p>

  <p>Жан хочет посетить как можно больше пиков. Один поход на пик занимает ровно k дней, при этом в каждый из этих дней должна быть хорошая погода (ai = 0). То есть, формально, можно начать поход в день i только если все aj = 0 для всех j (i ≤ j ≤ i + k - 1).</p>

  <p>После каждого похода, прежде чем начать следующий, Жан должен взять перерыв не менее одного дня, то есть на следующий день после похода он не сможет снова отправиться в следующий поход.</p>

  <p>Найдите максимальное количество пиков, которые сможет посетить Жан.</p>

  <h4>Входные данные</h4>
  <p>Каждый тест состоит из нескольких наборов входных данных. Первая строка содержит единственное целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных. Далее следует их описание.</p>

  <p>Первая строка каждого набора входных данных содержит два целых числа n и k (1 ≤ n ≤ 10⁵, 1 ≤ k ≤ n).</p>

  <p>Во второй строке задано n чисел ai (ai ∈ {0, 1}), где ai обозначает погоду в i-й день.</p>

  <p>Гарантируется, что суммарное значение n по всем наборам входных данных не превосходит 10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора данных выведите одно целое число: максимальное количество походов, которое может совершить Жан.</p>

  <details>
    <summary>Пример</summary>
<pre>
5
5 1
0 1 0 0 0
7 3
0 0 0 0 0 0 0
3 1
1 1 1
4 2
0 1 0 1
6 2
0 0 1 0 0 0
</pre>
<pre>
3
2
0
0
2
</pre>
    <p>В первом примере:</p>
    <ul>
      <li>1-й день — хорошая погода, Жан идёт в поход. (a1=0)</li>
      <li>2-й день — обязательный перерыв.</li>
      <li>3-й день — снова хорошая погода, Жан идёт во второй поход. (a3=0)</li>
      <li>4-й день — перерыв.</li>
      <li>5-й день — хорошая погода, третий поход. (a5=0)</li>
    </ul>
    <p>Таким образом, Жан может совершить 3 похода, чередуя каждый из них с обязательным днём отдыха.</p>
    <p>Во втором примере:</p>
    <ul>
      <li>С 1 по 3 день — три дня хорошей погоды, Жан идёт в поход. (a1=a2=a3=0)</li>
      <li>4-й день — обязательный перерыв.</li>
      <li>С 5 по 7 день — снова три дня хорошей погоды, Жан идёт во второй поход. (a5=a6=a7=0)</li>
    </ul>
    <p>Всего Жан совершает 2 похода.</p>
    <p>В третьем примере:</p>
    <ul>
      <li>Нет ни одного дня с хорошей погодой (ai=1 для всех i)</li>
    </ul>
    <p>Жан не может совершить ни одного похода. Ответ: 0</p>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

// условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // число дней
    int k; // число дней для похода
    cin >> n >> k;
    vector&lt;int&gt; A(n + 1);
    for (int i = 1; i &lt;= n; i++) {
      cin >> A[i];
    }

    // решение
    int res = 0;
    for (int i = 1; i &lt;= n; i++) {
      int good = 0; // число подряд хороших дней
      while (i &lt;= n && A[i] == 0 && k > good) {
        good++;
        i++;
      }
      if (k == good) {
        res++;
        good = 0;
      }
    }

    // вывод результата
    cout &lt;&lt; res &lt;&lt; '\n';
  }

}
</pre>
  </details>
</article>


<!-- Задача C. Сейчас точно успею -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Сейчас точно успею</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам даны n башен, пронумерованных от 1 до n. Башня i имеет высоту hi. В момент времени 0 вы находитесь на башне с номером k, а текущий уровень воды равен 1.</p>

  <p>Каждую секунду уровень воды поднимается на 1 единицу. В любой момент времени, если уровень воды становится строго больше высоты башни, на которой вы находитесь, вы погибаете.</p>

  <p>У вас есть магическая способность: вы можете в момент x начать телепортироваться с башни i на башню j, на это уйдёт |hi-hj| секунд. То есть до момента x+|hi-hj| вы будете находиться на башне i, а в момент x+|hi-hj| вы переместитесь на башню j. Начать новую телепортацию можно в тот же момент, когда вы только попали на башню j.</p>

  <p>Например, если n=k=4, h=[4,4,4,2], то если в момент 0 начать телепортацию с башни 4 на башню 1, перемещение будет выглядеть следующим образом:</p>
<pre>
0:    1:    2:
            0
###   ###   ###
###0  ###0  ~~~~
####  ~~~~  ~~~~
~~~~  ~~~~  ~~~~
</pre>

  <p>Обратите внимание, что если бы высота башни 1 была равна 5, то телепортироваться сразу на неё не получилось бы, так как вас бы затопило в момент 2.</p>

  <p>Ваша цель — добраться до любой башни с максимальной высотой до того, как вас накроет вода.</p>

  <p>Определите, возможно ли это.</p>

  <h4>Входные данные</h4>
  <p>Каждый тест состоит из нескольких наборов входных данных. Первая строка содержит единственное целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных. Далее следует их описание.</p>

  <p>Первая строка каждого набора входных данных содержит два целых числа n и k (1 ≤ k ≤ n ≤ 10⁵) — количество башен и номер башни, на которой вы находитесь изначально.</p>

  <p>Вторая строка содержит n целых чисел h1,h2,…,hn (1 ≤ hi ≤ 10⁹) — высоты башен.</p>

  <p>Гарантируется, что сумма всех n по всем наборам входных данных не превышает 10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого теста выведите по одной строке: «YES», если вы можете добраться до башни с максимальной высотой до того, как вода накроет вас, или «NO» — в противном случае.</p>

  <p>Вы можете выводить каждую букву в любом регистре (строчную или заглавную). Например, строки «yEs», «yes», «Yes» и «YES» будут приняты как положительный ответ.</p>

  <details>
    <summary>Пример</summary>
<pre>
5
5 3
3 2 1 4 5
3 1
1 3 4
4 4
4 4 4 2
6 2
2 3 6 9 1 2
4 2
1 2 5 6
</pre>
<pre>
YES
NO
YES
YES
NO
</pre>
    <p>В первом наборе входных данных единственный возможный путь: 3→2→1→4→5.</p>
    <p>Во втором наборе входных данных, не зависимо от порядка, добраться до самой высокой башни не получится.</p>
    <p>В третьем наборе входных данных один из возможных путей: 4→1.</p>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios::sync_with_stdio(0);
  cin.tie(0);
  cout.tie(0);

  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // число башен
    int k; // номер башни
    cin >> n >> k;

    vector&lt;int&gt; A(n);
    for (int i = 0; i &lt; n; i++) {
      cin >> A[i];
      // A[i] - высота башни i
    }

    // решение
    int h = A[k - 1]; // начальная высота
    sort(A.begin(), A.end());

    bool flag = false;
    for (int i = 0; i &lt; n; i++) {
      if (A[i] > h) {
        int tm = A[i] - h;
        if (tm > A[i - 1]) {
          flag = true;
        }
      }
    }

    // вывод результата
    if (flag) {
      cout &lt;&lt; "NO\n";
    } else {
      cout &lt;&lt; "YES\n";
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача D. Это точно в последний раз -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Это точно в последний раз</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам даны n казино, пронумерованных от 1 до n. Каждое казино описывается тремя целыми числами: lᵢ, rᵢ и realᵢ (lᵢ ≤ realᵢ ≤ rᵢ). У вас изначально есть k монет.</p>

  <p>Вы можете сыграть в казино i, только если для текущего количества монет x верно lᵢ ≤ x ≤ rᵢ. После игры ваше количество монет становится равно realᵢ.</p>

  <p>Вы можете посещать казино в любом порядке и не обязаны заходить во все. Каждое казино можно посетить не более одного раза.</p>

  <p>Ваша задача — найти максимальное итоговое количество монет, которое вы можете получить.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора содержит два целых числа n и k (1 ≤ n ≤ 10⁵, 0 ≤ k ≤ 10⁹) — количество казино и начальное число монет.</p>

  <p>Далее следуют n строк. В i-й из них записаны три целых числа lᵢ, rᵢ, realᵢ (0 ≤ lᵢ ≤ realᵢ ≤ rᵢ ≤ 10⁹) — параметры i-го казино.</p>

  <p>Гарантируется, что сумма всех n по всем наборам входных данных не превышает 10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно целое число — максимальное количество монет, которое вы можете получить после оптимального выбора порядка посещения казино.</p>

  <details>
    <summary>Пример</summary>
<pre>
5
3 1
2 3 3
1 2 2
3 10 10
1 0
1 2 2
1 2
1 2 2
2 2
1 3 2
2 4 4
2 5
1 10 5
3 6 5
</pre>
<pre>
10
0
2
4
5
</pre>
  <p>В первом примере вы можете сначала сыграть во 2-е казино. После этого у вас будет 2 монеты. Затем можно сыграть в 1-е казино, и количество монет увеличится до 3. Наконец, после игры в 3-м казино, у вас становится 10 монет — это и есть максимальное возможное количество.</p>
  <p>Во втором примере у вас нет денег, так что вы не сможете заработать больше.</p>
  <p>В четвертом примере вам выгодно сразу сыграть во 2-е казино и заработать 4 монеты.</p>
  </details>
</article>


<!-- Задача E. Н-О-Д, не повезло! -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Н-О-Д, не повезло!</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Даны два массива p и s длины n, где p является префиксным НОД∗ некоторого массива a, а s — суффиксным НОД того же массива a. Иными словами, если бы массив a существовал, то для каждого 1 ≤ i ≤ n выполнялись бы оба равенства:</p>
  <ul>
    <li>pᵢ = gcd (a₁, a₂, …, aᵢ)</li>
    <li>sᵢ = gcd (a₁, a<sub>i+1</sub>, …, aₙ)</li>
  </ul>
  <p>Определите, существует ли такой массив a, для которого данные массивы p и s могут быть получены.</p>
  <p>* gcd(x,y) обозначает наибольший общий делитель (НОД) чисел x и y.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Описание каждого набора входных данных состоит из трёх строк:</p>

  <p>Первая строка каждого набора входных данных содержит одно целое число n (1 ≤ n ≤ 10⁵) — длину массива.</p>

  <p>Вторая строка каждого набора входных данных содержит n
  целых чисел p₁, p₂, …, pₙ (1 ≤ pᵢ ≤ 10⁹) — элементы массива.</p>

  <p>Третья строка каждого набора входных данных содержит n целых чисел s₁, s₂, …, sₙ (1 ≤ sᵢ ≤ 109) — элементы массива.</p>

  <p>Гарантируется, что сумма всех n по всем наборам входных данных не превышает 10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите «Yes» (без кавычек), если существует массив a, для которого данные массивы p и s могут быть получены, и «No» (без кавычек) иначе.</p>

  <p>Вы можете выводить каждую букву в любом регистре (строчную или заглавную). Например, строки «yEs», «yes», «Yes» и «YES» будут приняты как положительный ответ.</p>

  <details>
    <summary>Пример</summary>
<pre>
5
6
72 24 3 3 3 3
3 3 3 6 12 144
3
1 2 3
4 5 6
5
125 125 125 25 25
25 25 25 25 75
4
123 421 282 251
125 1981 239 223
3
124 521 125
125 121 121
</pre>
<pre>
YES
NO
YES
NO
NO
</pre>
  <p>Для первого примера возможен массив: [72, 24, 3, 6, 12, 144].</p>
  <p>Для второго примера можно показать, что таких массивов не существует.</p>
  <p>Для третьего примера существует массив: [125, 125, 125, 25, 75].</p>
  </details>
</article>


<!-- Задача F. 1-1-1, бесплатное дерево! -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. 1-1-1, бесплатное дерево!</h3>

  <div><i>Ограничение по времени 4с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Дано дерево∗ из n вершин, пронумерованных от 1 до n. Каждая вершина имеет начальный цвет aᵢ.</p>

  <p>Каждое ребро дерева задаётся тремя числами: uᵢ, vᵢ и cᵢ, где uᵢ и vᵢ — концы ребра, а cᵢ — параметр ребра. Стоимость ребра определяется следующим образом: если цвета вершин uᵢ и vᵢ совпадают, стоимость равна 0, иначе стоимость равна cᵢ.</p>

  <p>Также вам дано q запросов. Каждый запрос имеет вид: перекрасить вершину v в цвет x. Запросы зависят друг от друга (после каждого запроса изменение цвета сохраняется). После каждого запроса необходимо вывести сумму стоимостей всех рёбер дерева.</p>

  <p>* Деревом называется связный граф без циклов.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит два целых числа n и q (1 ≤ n, q ≤ 2⋅10⁵)— количество вершин и количество запросов соответственно.</p>

  <p>Во второй строке содержится n целых чисел a₁, a₂, …, aₙ (1 ≤ aᵢ ≤ n), где i-е число задаёт начальный цвет вершины i.</p>

  <p>В следующих n-1 строках описаны рёбра дерева. Каждая строка содержит три целых числа u, v и c, обозначающих ребро между вершинами u и v с параметром c (1 ≤ u, v ≤ n, 1 ≤ c ≤ 10⁹).</p>

  <p>В следующих q строках записаны запросы. Каждый запрос содержит два целых числа v и x — перекрасить вершину v в цвет x (1 ≤ v, x ≤ n).</p>

  <p>Гарантируется, что сумма n и сумма q по всем наборам данных не превосходят 2⋅10⁵</p>

  <h4>Выходные данные</h4>
  <p>Для каждого запроса выведите в отдельной строке одно целое число — сумму стоимостей всех рёбер дерева после применения соответствующего запроса.</p>

  <details>
    <summary>Пример</summary>
<pre>
4
1 1
1
1 1
2 3
1 1
1 2 10
1 2
2 2
1 1
5 4
1 2 1 2 3
1 2 5
2 3 3
2 4 4
4 5 7
3 2
5 2
1 2
2 3
4 3
1 1 2 2
1 2 2
2 3 6
2 4 8
3 1
4 1
2 2
</pre>
<pre>
0
10
0
10
12
5
0
12
8
0
16
</pre>
  <p>Первый пример: n=1, одна вершина — нет рёбер. Запрос: перекрасить a1 в 1, сумма стоимостей равна 0.</p>
  <p>Второй пример: n=2, ребро 1-2 (c=10). Запросы:</p>
  <ul>
    <li>a1=2: цвета [2,1], стоимость равна 10;</li>
    <li>a2=2: цвета [2,2], стоимость 0;</li>
    <li>a1=1: цвета [1,2], стоимость 10.</li>
  </ul>
  <p>Третий пример. n=5, рёбра: 1-2 (c=5), 2-3 (c=3), 2-4 (c=4), 4-5 (c=7). Начальные цвета [1,2,1,2,3]. Запросы:</p>
  <ul>
    <li>a3=2→[1,2,2,2,3]: рёбра 1-2 (c=5) и 4-5 (c=7) дают 12;</li>
    <li>a5=2→[1,2,2,2,2]: ребро 1-2 (c=5), стоимость 5;</li>
    <li>a1=2→[2,2,2,2,2]: стоимость равна 0;</li>
    <li>a2=3→[2,3,2,2,2]: рёбра 1-2 (5), 2-3 (3), 2-4 (4) дают 12.</li>
  </ul>
  </details>
</article>


<!-- Задача G1. Большие выигрыши! (простая версия) -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G1. Большие выигрыши! (простая версия)</h3>

  <div><i>Ограничение по времени 4с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Это простая версия задачи. Отличие между версиями заключается в том, что в этой версии aᵢ ≤ min(n, 100).</p>

  <p>Вам дан массив из n целых чисел a1,a2,…,an.</p>

  <p>Ваша задача — найти такой подмассив a[l, r] (непрерывную последовательность элементов a<sub>l</sub>, a<sub>l+1</sub>, …, a<sub>r</sub>), для которого значение выражения med(a[l, r]) - min(a[l, r]) максимально.</p>

  <p>Здесь:</p>
  <ul>
    <li>med — медиана подмассива, то есть элемент, стоящий на позиции ⌈ (k+1) / 2⌉ после сортировки подмассива, где k — его длина;</li>
    <li>min — минимальный элемент этого подмассива.</li>
  </ul>

  <p>Например, рассмотрим массив a=[1,4,1,5,3,3] и выберем подмассив a[2,5]=[4,1,5,3]. В отсортированном виде он выглядит как [1,3,4,5].</p>
  <ul>
    <li>med(a[2,5])=4, так как ⌈ (4+1) / 2⌉= третий элемент в отсортированном подмассиве равен 4;</li>
    <li>min(a[2,5])=1, так как минимальный элемент равен 1.</li>
  </ul>

  <p>В данном примере значение med-min=4-1=3.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит одно целое число n (1 ≤ n ≤ 2⋅10⁵) — длину массива.</p>

  <p>Вторая строка каждого набора входных данных содержит n целых чисел a1, a2, …, an (1 ≤ aᵢ ≤ min(n,100) ) — элементы массива.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>На каждый набор входных данных выведите одно целое число — максимальное возможное значение med-min среди всех подмассивов массива.</p>

  <details>
    <summary>Пример</summary>
<pre>
5
5
3 2 5 3 1
4
4 1 1 3
7
6 1 3 4 6 2 7
4
4 2 3 1
5
1 2 3 4 5
</pre>
<pre>
3
3
5
2
2
</pre>
  <p>В первом примере рассмотрим массив: a=[3, 2, 5, 3, 1] можно выбрать подмассив a[2, 3], то есть элементы [2, 5].</p>
  <ul>
    <li>Длина подмассива равна 2.</li>
    <li>Медиана — это элемент на позиции ⌈3/2⌉=2 в отсортированном подмассиве. После сортировки получаем [2, 5], med=5.</li>
    <li>Минимальный элемент подмассива: min=2.</li>
  </ul>
  <p>Следовательно, med-min=5-2=3, что и является максимальным ответом.</p>
  <p>Во втором тесте массив: a=[4, 1, 1, 3] можно выбрать подмассив a[1, 2], то есть элементы [4, 1].</p>
  <ul>
    <li>Длина подмассива равна 2.</li>
    <li>Медиана — это элемент на позиции ⌈3/2⌉=2 в отсортированном подмассиве. После сортировки получаем [1, 4], med=4.</li>
    <li>Минимальный элемент подмассива: min=1.</li>
  </ul>
  <p>Следовательно, med-min=4-1=3.</p>
  <p>Можно доказать, что оба этих подмассива являются оптимальными и дают максимальное значение выражения med-min.</p>
  </details>
</article>


<!-- Задача G2. Большие выигрыши! (сложная версия) -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача G2. Большие выигрыши! (сложная версия)</h3>

  <div><i>Ограничение по времени 4с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Это сложная версия задачи. Отличие между версиями заключается в том, что в этой версии aᵢ ≤ n.</p>

  <p>Вам дан массив из n целых чисел a1, a2, …, an.</p>

  <p>Ваша задача — найти такой подмассив a[l, r] (непрерывную последовательность элементов a<sub>l</sub>, a<sub>l+1</sub>, …, a<sub>r</sub> ), для которого значение выражения med(a[l, r]) - min(a[l, r]) максимально.</p>

  <p>Здесь:</p>
  <ul>
    <li>med — медиана подмассива, то есть элемент, стоящий на позиции ⌈ (k+1) / 2⌉ после сортировки подмассива, где k — его длина;</li>
    <li>min — минимальный элемент этого подмассива.</li>
  </ul>

  <p>Например, рассмотрим массив a=[1,4,1,5,3,3] и выберем подмассив a[2,5]=[4,1,5,3]. В отсортированном виде он выглядит как [1,3,4,5].</p>
  <ul>
    <li>med(a[2,5])=4, так как ⌈ (4+1) / 2⌉= третий элемент в отсортированном подмассиве равен 4;</li>
    <li>min(a[2,5])=1, так как минимальный элемент равен 1.</li>
  </ul>

  <p>В данном примере значение med-min = 4-1 = 3.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит одно целое число n (1 ≤ n ≤ 2⋅10⁵) — длину массива.</p>

  <p>Вторая строка каждого набора входных данных содержит n целых чисел a1, a2, …, an (1 ≤ aᵢ ≤ n) — элементы массива.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>На каждый набор входных данных выведите одно целое число — максимальное возможное значение med-min среди всех подмассивов массива.</p>

  <details>
    <summary>Пример</summary>
<pre>
5
5
3 2 5 3 1
4
4 1 1 3
7
6 1 3 4 6 2 7
4
4 2 3 1
5
1 2 3 4 5
</pre>
<pre>
3
3
5
2
2
</pre>
  <p>В первом примере рассмотрим массив: a=[3, 2, 5, 3, 1] можно выбрать подмассив a[2, 3], то есть элементы [2, 5].</p>
  <ul>
    <li>Длина подмассива равна 2.</li>
    <li>Медиана — это элемент на позиции ⌈3/2⌉=2 в отсортированном подмассиве. После сортировки получаем [2, 5], med=5.</li>
    <li>Минимальный элемент подмассива: min=2.</li>
  </ul>
  <p>Следовательно, med-min=5-2=3, что и является максимальным ответом.</p>
  <p>Во втором тесте массив: a=[4, 1, 1, 3] можно выбрать подмассив a[1, 2], то есть элементы [4, 1].</p>
  <ul>
    <li>Длина подмассива равна 2.</li>
    <li>Медиана — это элемент на позиции ⌈3/2⌉=2 в отсортированном подмассиве. После сортировки получаем [1, 4], med=4.</li>
    <li>Минимальный элемент подмассива: min=1.</li>
  </ul>
  <p>Следовательно, med-min=4-1=3.</p>
  <p>Можно доказать, что оба этих подмассива являются оптимальными и дают максимальное значение выражения med-min.</p>
  </details>
</article>

