<article class="article">
  <a href="https://codeforces.com/contest/1313" target="_blank">Codeforces 1313 Round 622 (Div.2) 2020-02-23</a>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

      <a href="#task1">Задача A. Ресторан быстрого питания</a>
  <br><a href="#task2">Задача B. Альтернативные правила</a>
  <br><a href="#task3">Задача C1. Небоскрёбы (упрощённая версия)</a>
  <br><a href="#task4">Задача C2. Небоскрёбы (усложнённая версия)</a>
  <br><a href="#task5">Задача D. Новый год</a>
  <br><a href="#task6">Задача E. Конкатенация с пересечением</a>
</article>


<!-- Задача A. Ресторан быстрого питания -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Ресторан быстрого питания</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

</article>


<!-- Задача B. Альтернативные правила -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Альтернативные правила</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

</article>


<!-- Задача C1. Небоскрёбы (упрощённая версия) -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C1. Небоскрёбы (упрощённая версия)</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 512мб</i></div>

</article>


<!-- C2 Небоскрёбы (усложнённая версия) -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача C2. Небоскрёбы (усложнённая версия)</h3>

  <div><i>Ограничение по времени 3с
  <br>Ограничение по памяти 512мб</i></div>

  <p>Это более сложная версия задачи. В этой версии n≤500000</p>

  <p>В Берляндии активно застраивается окраина столицы. Компания «Kernel Panic» руководит постройкой жилого комплекса из небоскрёбов в Новой Берлскве. Все небоскрёбы строятся вдоль шоссе. Известно, что компания уже купила n участков возле шоссе и готовится возвести n небоскрёбов, по одному зданию на один участок.</p>

  <p>Архитекторы при планировании зданий должны учитывать несколько требований. Во-первых, поскольку земля на каждом участке имеет разные свойства, для каждого небоскрёба есть свое ограничение по количеству этажей, которое он может иметь. Во-вторых, согласно дизайн-коду города, недопустима ситуация, когда для какого-то небоскрёба сразу по обе стороны от него есть небоскрёбы выше него.</p>

  <p>Более формально, пронумеруем участки целыми числами от 1 до n. Тогда у небоскрёба на участке с номером i количество этажей a<sub>i</sub> не может быть больше m<sub>i</sub> (1 ≤ a<sub>i</sub> ≤ m<sub>i</sub>). Также не может быть, что на плане существуют два участка с номерами j и k, таких что j &lt; i &lt; k и a<sub>j</sub> > a<sub>i</sub> &lt; a<sub>k</sub>. Участки j и k не обязаны быть соседними с i.</p>

  <p>Компания хочет, чтобы суммарное количество этажей в построенных небоскрёбах было как можно больше. Помогите ей выбрать количество этажей для каждого небоскрёба оптимальным образом, то есть так, чтобы выполнялись все ограничения, а среди всех таких вариантов выберите один из планов, в котором суммарное количество этажей максимально возможно.</p>

  <h4>Входные данные</h4>
  <p>В первой строке задано одно целое число n (1 ≤ n ≤ 500000) — количество участков.</p>

  <p>Вторая строка содержит целые числа m<sub>1</sub>, m<sub>2</sub>, ... , m<sub>n</sub> (1 ≤ m<sub>i</sub> ≤ 10<sup>9</sup>) —максимально возможное количество этажей для небоскрёба на каждом участке.</p>

  <h4>Выходные данные</h4>
  <p>Выведите n чисел a<sub>i</sub> — количества этажей в плане для каждого небоскрёба, такие, что выполняются все ограничения, а суммарное количество этажей во всех небоскрёбах максимально возможное.</p>

  <p>Если возможно несколько ответов, выведите любой.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
5
1 2 3 2 1
</pre>
    <code>1 2 3 2 1</code>
    <p>В первом примере можно построить все небоскрёбы с максимально возможной высотой.</p>

    <h4>Пример 2</h4>
<pre>
3
10 6 8
</pre>
    <code>10 6 6</code>
    <p>Во втором примере придать максимальную высоту всем небоскрёбам нельзя, так как это нарушает ограничение дизайн-кода. Ответ [10,6,6]  является оптимальным. Обратите внимание, что ответ [6,6,8] также удовлетворяет всем ограничениям, но оптимальным не является.</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1313/problem/C2" target="_blank">Задача 1313C2</a>
      <br><a href="https://codeforces.com/contest/1313" target="_blank">Codeforces Round 622 (Div. 2) 2020-02-23</a>
    </div>

    <p>Нам нужно создать последовательность, где нет ситуации, когда небоскрёб имеет соседей с обеих сторон, которые выше его. Это означает, что последовательность должна быть унимодальной (сначала возрастает, затем убывает).</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;

using namespace std;

// функция Sum возвращает вектор пар
// first - максимальная сумма этажей до текущей позиции
// second - индекс предыдущего меньшего элемента
vector&lt;pair&lt;long long, int&gt; &gt; Sum(const vector&lt;int&gt;& Et, int n) {
  vector&lt;pair&lt;long long, int&gt; &gt; Res(n);

  // стек пар возрастающих чисел
  // first - значение
  // second - индекс
  stack&lt;pair&lt;int, int&gt; &gt; st;
  st.push(make_pair(0, -1)); // базовый случай

  for (int i = 0; i &lt; n; i++) {
    // поддерживаем возрастающий порядок в стеке
    while (st.top().first >= Et[i]) {
      // достаем из стека элементы
      // которые больше или равны текущему
      st.pop();
    }

    // число домов, где Et[i] максимальное
    int i_max = i - st.top().second;

    // вклад текущего сегмента
    long long cur_seg = (long long)Et[i] * (i_max);

    // весь сегмент это сумма текущего и предыдущего
    long long seg = cur_seg + (st.top().second >= 0 ?
    Res[st.top().second].first : 0);

    // индекс предыдущего меньшего элемента
    int min_el_idx = st.top().second;

    // максимальная сумма
    Res[i] = make_pair(seg, min_el_idx);

    // добавляем текущий элемент в стек
    st.push(make_pair(Et[i], i));
  }

  return Res;
}

int main() {
  // ускорение ввода-вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // ввод данных
  int n;  // число домов
  cin >> n;
  vector&lt;int&gt; Et(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> Et[i]; // этажи
  }

  // решение

  // прямой проход находит оптимальную
  // возрастающую последовательность
  // t[i].first - максимальная сумма до позиции i
  // t[i].second -  индекс предыдущего меньшего элемента
  vector&lt;pair&lt;long long, int&gt; &gt; inc_pass = Sum(Et, n);

  // переворачиваем массив Et
  reverse(Et.begin(), Et.end());

  // обратный проход находит оптимальную
  // убывающую последовательность
  vector&lt;pair&lt;long long, int&gt; &gt; dec_pass = Sum(Et, n);

  // переворачиваем результат обратно
  reverse(dec_pass.begin(), dec_pass.end());

  // восстанавливаем исходный порядок Et
  reverse(Et.begin(), Et.end());

  // ищем индекс пика
  // inc_pass[i].first - сумма слева
  // dec_pass[i].first - сумма справа
  // вычитаем Et[i] чтобы избежать двойного учёта текущего элемента
  int ind = 0;
  for (int i = 0; i &lt; n; i++) {
    if (inc_pass[i].first + dec_pass[i].first - Et[i] >
        inc_pass[ind].first + dec_pass[ind].first - Et[ind]) {
      ind = i;
    }
  }

  // собираем результат
  vector&lt;int&gt; Res(n);

  // левая часть до пика
  for (int i = ind; i >= 0; i = inc_pass[i].second) {
    for (int j = i; j > inc_pass[i].second; j--) {
      Res[j] = Et[i];
    }
  }

  // подготовка к заполнению правой части
  // переворачиваем dec_pass
  reverse(dec_pass.begin(), dec_pass.end());
  // переворачиваем Et
  reverse(Et.begin(), Et.end());
  // новый индекс пика для перевернутого массива
  ind = n - 1 - ind;
  // переворачиваем частично заполненный результат
  reverse(Res.begin(), Res.end());

  // правая часть после пика
  for (int i = ind; i >= 0; i = dec_pass[i].second) {
    for (int j = i; j > dec_pass[i].second; j--) {
      Res[j] = Et[i];
    }
  }

  // переворачиваем полностью заполненный результат
  reverse(Res.begin(), Res.end());

  // вывод результата
  for (int i = 0; i &lt; n; i++) {
    cout &lt;&lt; Res[i] &lt;&lt; ' ';
  }
}
</pre>
  </details>
</article>


<!-- Задача D. Новый год -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача D. Новый год</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 512мб</i></div>

</article>


<!-- Задача E. Конкатенация с пересечением -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача E. Конкатенация с пересечением</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 512мб</i></div>

</article>
