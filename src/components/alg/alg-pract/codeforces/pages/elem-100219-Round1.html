<article class="article">
  <a href="https://codeforces.com/contest/1" target="_blank">Codeforces Beta Round 1 2010-02-19</a>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

      <a href="#task1">Задача A. Театральная площадь</a>
  <br><a href="#task2">Задача B. Электронные таблицы</a>
  <br><a href="#task3">Задача C. Древнеберляндский цирк</a>
</article>


<!-- Задача A. Театральная площадь -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Театральная площадь</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Театральная площадь в столице Берляндии представляет собой прямоугольник n x m метров. По случаю очередного юбилея города, было принято решение о замощении площади квадратными гранитными плитами. Каждая плита имеет размер a x a.</p>

  <p>Какое наименьшее количество плит понадобится для замощения площади? Разрешено покрыть плитами большую поверхность, чем театральная площадь, но она должна быть покрыта обязательно. Гранитные плиты нельзя ломать или дробить, а разрешено использовать только целиком. Границы плит должны быть параллельны границам площади.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано три целых натуральных числа n, m и a (1 ≤ n, m, a ≤ 10⁹).</p>

  <h4>Выходные данные</h4>
  <p>Выведите искомое количество плит.</p>

  <h4>Пример</h4>
  <code>6 6 4</code>
  <code>4</code>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1/problem/A" target="_blank">Задача 1А</a>
      <br><a href="https://codeforces.com/contest/1" target="_blank">Codeforces Beta Round 1 2010-02-19</a>
    </div>

    <h4>Идея решения:</h4>
    <ol>
      <li>Чтобы покрыть длину n нужно n/a плит с округлением вверх</li>
      <li>Чтобы покрыть ширину m нужно m/a плит с округлением вверх</li>
      <li>Общее количество плит будет равно произведению количества плит по длине и ширине: (n/a) * (m/a) </li>
      <li>Округление вверх можно реализовать с помощью формулы: x/y = (x+y-1) / y</li>
    </ol>

<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  long long n, m, a;
  cin >> n >> m >> a;

  // решение
  // Вычисляем количество плит по длине и ширине с округлением вверх
  long long tilesN = (n + a - 1) / a;
  long long tilesM = (m + a - 1) / a;

  // вывод результата
  cout &lt;&lt; tilesN * tilesM;
}
</pre>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  long long n, m, a;
  cin >> n >> m >> a;

  // решение
  long long h1 = n / a;
  long long h2 = m / a;
  if (n % a != 0) {
    h1++;
  }
  if (m % a != 0) {
    h2++;
  }

  // вывод результата
  cout &lt;&lt; h1 * h2;
}
</pre>
  </details>
</article>


<!-- Задача B. Электронные таблицы -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Электронные таблицы</h3>

  <div><i>Ограничение по времени 10с
  <br>Ограничение по памяти 64мб</i></div>

  <p>В популярных системах электронных таблиц (например, в программе Excel) используется следующая нумерация колонок. Первая колонка имеет номер A, вторая B и т.д. до 26-ой, которая обозначается буквой Z. Затем идут двухбуквенные обозначения: 27-ая обозначается как AA, 28-ая как AB, а 52-я обозначается парой AZ. Аналогично, следом за ZZ следуют трехбуквенные обозначения и т.д.</p>

  <p>Строки обычно обозначаются целыми числами от 1. Номер ячейки получается конкатенацией обозначений для столбца и строки. Например, BC23 это обозначение для ячейки в столбце 55, строке 23.</p>

  <p>Иногда используется другая форма записи: RXCY, где X и Y это целые числа, обозначающие номер строки и столбца, соответственно. Например, R23C55 это ячейка из примера выше.</p>

  <p>Ваша задача написать программу, которая считывает последовательность обозначений ячеек и выводит каждое из обозначений в другой форме записи.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое число n (1 ≤ n ≤ 10⁵), количество обозначений в тесте. Далее идет n строк, каждая из которых содержит обозначение. Известно, что все обозначения корректны, и не содержат ячейки с номерами строк или столбцов больших 10⁶.</p>

  <h4>Выходные данные</h4>
  <p>Выведите n строк — каждая строка должна содержать обозначение ячейки в отличной форме записи.</p>

  <h4>Пример</h4>
<pre>
2
R23C55
BC23
</pre>
<pre>
BC23
R23C55
</pre>

  <details>
    <summary>Решение</summary>
    <p>Определим тип обозначения. Если в обозначении встречается буква после цифры, то это второй тип, иначе перывый. Если первый тип, то переводим буквенное обозначение колонки в число. Если второе то переводим числовое обозначение колонки в буквенное.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main() {
  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // ввод данных
  int n; // число ячеек в таблице
  cin >> n;

  // решение
  // для каждой ячейки
  while (n--) {
    string cell; // обозначение строки и столбца
    cin >> cell;

    // определим тип обозначения
    // 1 - колонка - строка (буквы - цифры)
    // 2 - RXCY строка номер - колонка номер
    int type = 1;
    int flag_dig = 0; // встретилась цифра

    for (char ch : cell) {
      if (flag_dig && isalpha(ch)) {
        type = 2; // встретилась буква после цифры
      }
      if (isdigit(ch)) {
        flag_dig = 1;
      }
    }

    string res = "";
    if (type == 1) {
      int c = 0; // колонка
      string r = ""; // строка
      for (char ch : cell) {
        if (isalpha(ch)) {
          // для колонки
          //переводим буквенное обозначение в число
          c = c * 26 + (ch - 'A' + 1);
        }
        if (isdigit(ch)) {
          // для строки
          // собираем число в виде строки из цифр
          r += ch;
        }
      }
      res += "R" + r + "C" + to_string(c);
    }


    if (type == 2) {
      string r = ""; // строка
      string c = ""; // колонка
      int i = 1;
      for (; cell[i] != 'C'; i++) {
        // для строки
        // собираем число в виде строки из цифр
        r += cell[i];
      }
      for (i++; i &lt; cell.size(); i++) {
        // для колонки
        // собираем число в виде строки из цифр
        c += cell[i];
      }
      int dig_c = stoi(c); // переводим строку в число
      string col = "";
      // переводим числовое обозначение в буквенное
      while (dig_c) {
        dig_c--; // чтобы 'A' соответствовало 0, а не 1
        char l = dig_c % 26 + 'A';

        col = l + col;
        dig_c /= 26;
      }
      res += col + r;
    }

    // вывод результата
    cout &lt;&lt; res &lt;&lt; '\n';
  }

}
</pre>
  </details>
</article>


<!-- Задача C. Древнеберляндский цирк -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Древнеберляндский цирк</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Это сейчас все цирки в Берляндии имеют круглую арену диаметром 13 метров, а в древности все было совсем иначе.</p>

  <p>В Древней Берляндии цирки имели арены в форме правильных многоугольников, а размеры и количества углов могли варьироваться от цирка к цирку. В каждом углу арены в землю был заколочен специальный столб, а на них были натянуты канаты, ограничивающие арену.</p>

  <p>Недавно ученые Берляндии раскопали останки арены древнего цирка. Ими было найдено всего три столба, остальные были уничтожены временем.</p>

  <p>Ваша задача по координатам найденных трех столбов определить, какую наименьшую площадь могла иметь арена этого цирка.</p>

  <h4>Входные данные</h4>
  <p>Входной файл состоит из трех строк, каждая из которых содержит пару чисел — координаты столба. Любая из координат не превосходит по абсолютной величине 1000, и задана с 6 знаками после десятичной точки.</p>

  <h4>Выходные данные</h4>
  <p>Выведите искомую площадь с точностью не менее 6 знаков после точки. Гарантируется, в оптимальном многоугольнике будет не более 100 вершин.</p>

  <h4>Пример</h4>
<pre>
0.000000 0.000000
1.000000 1.000000
0.000000 1.000000
</pre>
  <code>1.00000000</code>

  <details>
    <summary>Решение</summary>
    <h4>Тест 31</h4>
<pre>
46.172435 -22.819705
17.485134 -1.663888
101.027565 111.619705
</pre>
    <code>16483.233301</code>
<pre>
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;iomanip&gt;

using namespace std;

#define PI acos(-1)

double gcd(double a, double b) {
  // проверка на близость к нулю (из-за погрешностей вычислений)
  return a &lt; 0.01 ? b : gcd(fmod(b, a), a);
}

int main() {
// условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // ввод данных
  double x1, y1, x2, y2, x3, y3;
  cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;

  // решение

  // длины сторон треугольника, образованного тремя столбами
  double a, b, c;
  a = sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
  b = sqrt((x2 - x3) * (x2 - x3) + (y2 - y3) * (y2 - y3));
  c = sqrt((x1 - x3) * (x1 - x3) + (y1 - y3) * (y1 - y3));

  // полупериметр и площадь по формуле Герона
  double p, s;
  p = (a + b + c) / 2.0;
  s = sqrt(p * (p - a) * (p - b) * (p - c));

  // радиус описанной окружности (это будет радиус цирковой арены)
  double r;
  r = a * b * c / (4 * s);

  // сортируем стороны (чтобы c была наибольшей)
  if (a > c) {
    swap(a, c);
  }
  if (b > c) {
    swap(b, c);
  }

  // центральные углы, под которыми видны
  // стороны треугольника из центра окружности
  double A, B, C;
  A = 2 * asin(a / (2 * r));
  B = 2 * asin(b / (2 * r));
  C = 2 * PI - A - B;

  // Вычисляем НОД этих углов — это даст нам угол p,
  // на который можно "разбить" окружность для
  // построения минимального правильного многоугольника
  p = gcd(A, B);
  p = gcd(p, C);

  // Считаем площадь правильного многоугольника
  // с таким углом p и радиусом r
  double res = (PI * r * r * sin(p)) / p;

  // вывод результата
  cout &lt;&lt; fixed &lt;&lt; setprecision(6) &lt;&lt; res;
}
</pre>
  </details>
</article>

