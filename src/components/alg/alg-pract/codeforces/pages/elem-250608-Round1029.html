<article class="article">
  <a href="https://codeforces.com/contest/2117" target="_blank">Codeforces 2117 Round 1029 (Div.3) 2025-06-08</a>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

      <a href="#task1">Задача A. Ложная тревога</a>
  <br><a href="#task2">Задача B. Сжатие</a>
  <br><a href="#task3">Задача C. Классное разделение</a>
  <br><a href="#task4">Задача D. Месть</a>
  <br><a href="#task5">Задача E. Потерянная душа</a>
  <br><a href="#task6">Задача F. Дикие цветы</a>
  <br><a href="#task7">Задача G. ОМГраф</a>
  <br><a href="#task8">Задача H. Непрекращающийся дождь</a>
</article>


<!-- Задача A. Ложная тревога -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Ложная тревога</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Юсеф стоит у входа в длинный коридор с n дверями в ряд, пронумерованными от 1 до n. Ему нужно пройти через все двери от 1 до n по порядку и добраться до выхода (за дверью n).</p>

  <p>Каждая дверь может быть открыта или закрыта. Если дверь открыта, Юсеф проходит через нее за 1 секунду. Если дверь закрыта, Юсеф не может пройти через нее.</p>

  <p>Однако у Юсефа есть специальная кнопка, которую он может использовать не более одного раза в любой момент. Эта кнопка делает все закрытые двери открытыми на x
  секунд.</p>

  <p>Ваша задача — определить, может ли Юсеф пройти через все двери, если он может использовать кнопку не более одного раза.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит целое число t (1 ≤ t ≤ 1000) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит два целых числа n, x (1 ≤ n, x ≤ 10) — количество дверей и количество секунд действия кнопки соответственно.</p>

  <p>Вторая строка каждого набора входных данных содержит n  целых чисел a1, a2, ... , an (ai ∈ {0,1}) — состояние каждой двери. Открытые двери представлены как '0', а закрытые двери представлены как '1'.</p>

  <p>Гарантируется, что в каждом наборе хотя бы одна дверь закрыта.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите «YES», если Юсеф может добраться до выхода, и «NO» в противном случае.</p>

  <p>Вы можете выводить каждую букву в любом регистре (строчную или заглавную). Например, строки «yEs», «yes», «Yes» и «YES» будут приняты как положительный ответ.</p>

  <details>
    <summary>Пример</summary>
<pre>
7
4 2
0 1 1 0
6 3
1 0 1 1 0 0
8 8
1 1 1 0 0 1 1 1
1 2
1
5 1
1 0 1 0 1
7 4
0 0 0 1 1 0 1
10 3
0 1 0 0 1 0 0 1 0 0
</pre>
<pre>
YES
NO
YES
YES
NO
YES
NO
</pre>

    <p>В первом наборе входных данных оптимальный способ таков:</p>
    <ul>
      <li>В момент времени 0
        дверь открыта, поэтому Юсеф проходит.</li>
      <li>В момент времени 1
        дверь закрыта, Юсеф может сейчас использовать кнопку и пройти через дверь.</li>
      <li>В момент времени 2
        действие кнопки все еще продолжается, поэтому Юсеф все еще может пройти.</li>
      <li>В момент времени 3
        действие кнопки закончилось, но дверь открыта. Юсеф проходит и добирается до выхода.</li>
    </ul>
    <p>Во втором наборе входных данных у Юсефа есть кнопка на 3 секунды, но ему нужно как минимум 4 секунды, чтобы добраться до выхода. Поэтому ответ NO.</p>
    <p>В третьем наборе входных данных Юсеф может включить кнопку перед тем, как начать двигаться. Все двери останутся открытыми, пока он не доберется до выхода.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Найдем крайнюю левую единицу и крайнюю правую единицу. Посчитаем сколько между ними расстояние. Если оно меньше x то Юсуф пройдет, иначе нет.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // число дверей
    int x; // число секунд
    cin >> n >> x;
    vector&lt;int&gt; A(n); // состояние дверей
    //
    for (int i = 0; i &lt; n; i++) {
      cin >> A[i];
    }

    // решение
    int first = -1; // первая закрытая дверь
    int last = -1; // последняя закрытая дверь

    // пробежим по всем дверям
    for (int i = 0; i &lt; n; i++) {
      if (A[i] == 1) {
        if (first == -1) {
          first = i;
        }
        last = i;
      }
    }

    string res = "YES";
    if (last + 1 - first > x) {
      res = "NO";
    }

    // вывод результата
    cout &lt;&lt; res &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача B. Сжатие -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Сжатие</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Операция сжатия на массиве a размером m определяется следующим образом:</p>
  <ul>
    <li>Выберите индекс i (2 ≤ i ≤ m-1) такой, что ai > ai-1 и ai > ai+1.</li>
    <li>Удалите ai из массива.</li>
  </ul>

  <p>Определим счёт перестановки∗ p как максимальное количество раз, которое вы можете выполнить операцию сжатия на p.</p>

  <p>Юсеф дал вам одно целое число n. Постройте перестановку p длины n с максимально возможным счётом. Если есть несколько ответов, вы можете вывести любой из них.</p>

  <p>* Перестановка длины n — это массив, состоящий из n различных целых чисел от 1 до n в произвольном порядке. Например, [2,3,1,5,4] является перестановкой, но [1,2,2] не является перестановкой (число 2 встречается дважды в массиве), и [1,3,4] также не является перестановкой (при n=3 в массиве есть 4).</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит целое число t (1 ≤ t ≤ 10³) — количество наборов входных данных.</p>

  <p>Каждый набор входных данных содержит целое число n (3 ≤ n ≤ 2⋅10⁵) — размер перестановки.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите любую перестановку p1, p2, … , pn, которая максимизирует количество операций сжатия.</p>

  <details>
    <summary>Пример</summary>
<pre>
2
3
6
</pre>
<pre>
1 3 2
2 3 6 4 5 1
</pre>

    <p>В первом наборе входных данных:</p>
    <ul>
      <li>Мы выбираем p=[1,3,2].</li>
      <li>Выбираем индекс 2 и удаляем p2 из массива. Массив становится p=[1,2].</li>
    </ul>
    <p>Можно показать, что максимальное количество операций, которые мы можем выполнить, равно 1. Другой допустимый ответ — p=[2,3,1].</p>
    <p>Во втором наборе входных данных:</p>
    <ul>
      <li>Мы выбираем p=[2,3,6,4,5,1].</li>
      <li>Выбираем индекс 5 и удаляем p5 из массива. Массив становится p=[2,3,6,4,1].</li>
      <li>Выбираем индекс 3 и удаляем p3 из массива. Массив становится p=[2,3,4,1].</li>
      <li>Выбираем индекс 3 и удаляем p3 из массива. Массив становится p=[2,3,1].</li>
      <li>Выбираем индекс 2 и удаляем p2 из массива. Массив становится p=[2,1].</li>
    </ul>
    <p>Максимальное количество операций, которые мы можем выполнить, равно 4. Любая перестановка со счётом 4 является допустимой.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>На вход приходит число n это значит что у нас есть все числа от 1 до n. Построим из них "пик", то есть до середины числа будут возрастать, на середине будет максимальное число, а после середины числа будут убывать.</p>
    <p>Например, сначала выведем все нечетные числа от 1 до n, потом все четные от n до 1.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // размер перестановки
    cin >> n;

    // решение
    int max_even; // максимальное четное
    int max_odd; // максимальное нечетное
    if (n % 2 == 0) {
      max_even = n;
      max_odd = n - 1;
    } else {
      max_even = n - 1;
      max_odd = n;
    }
    vector&lt;int&gt; Res;
    for (int i = 1; i &lt;= max_odd; i += 2) {
      Res.push_back(i);
    }
    for (int i = max_even; i > 0; i -= 2) {
      Res.push_back(i);
    }

    // вывод результата
    for (int i = 0; i &lt; n; i++) {
      cout &lt;&lt; Res[i] &lt;&lt; ' ';
    }
    cout &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача C. Классное разделение -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Классное разделение</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У Юсефа есть массив a размером n. Он хочет разделить массив на один или несколько смежных отрезков так, чтобы каждый элемент ai принадлежал ровно одному отрезку.</p>

  <p>Разделение называется классным, если для каждого отрезка bj все элементы в bj также присутствуют в bj+1 (если он существует). То есть каждый элемент в отрезке должен также присутствовать и в следующем отрезке.</p>

  <p>Например, если a=[1,2,2,3,1,5], классное разделение, которое может сделать Юсеф, это b1=[1,2], b2=[2,3,1,5]. Это классное разделение, потому что каждый элемент в b1 (то есть 1 и 2) также присутствует в b2. В отличие от этого, b1=[1,2,2], b2=[3,1,5] не является классным разделением, так как 2 присутствует в b1, но не в b2.</p>

  <p>Обратите внимание, что после разделения массива вы не изменяете порядок отрезков. Также обратите внимание, что если элемент появляется несколько раз в каком-либо отрезке bj, он должен появляться хотя бы один раз в bj+1.</p>

  <p>Ваша задача — помочь Юсефу, найдя максимальное количество отрезков, которые образуют классное разделение.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора содержит целое число n (1 ≤ n ≤ 2⋅10⁵) — размер массива.</p>

  <p>Вторая строка каждого набора содержит n целых чисел a1, a2, … , an (1 ≤ ai ≤ n) — элементы массива.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно целое число — максимальное количество отрезков, которые образуют классное разделение.</p>

  <details>
    <summary>Пример</summary>
<pre>
8
6
1 2 2 3 1 5
8
1 2 1 3 2 1 3 2
5
5 4 3 2 1
10
5 8 7 5 8 5 7 8 10 9
3
1 2 2
9
3 3 1 4 3 2 4 1 2
6
4 5 4 5 6 4
8
1 2 1 2 1 2 1 2
</pre>
<pre>
2
3
1
3
1
3
3
4
</pre>

    <p>Первый пример разобран в условии. Мы можем разделить его на b1=[1,2], b2=[2,3,1,5]. Можно показать, что нет другого разделения с большим количеством отрезков.</p>
    <p>Во втором примере мы можем разделить массив на b1=[1,2], b2=[1,3,2], b3=[1,3,2]. Максимальное количество отрезков равно 3.</p>
    <p>В третьем примере единственное разделение, которое мы можем сделать, это b1=[5,4,3,2,1]. Любое другое разделение не будет удовлетворять условию. Поэтому ответ равен 1.</p>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;map&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // размер массива
    cin >> n;
    vector&lt;int&gt; A(n);
    map&lt;int, int&gt; mp;
    for (int i = 0; i &lt; n; i++) {
      cin >> A[i];
      mp[A[i]]++;
    }

    // решение
    int res = 0;
    set&lt;int&gt; st;
    int cnt = mp.size();
    for (int i = n - 1; i >= 0; i--) {
      st.insert(A[i]);
      mp.find(A[i])->second--;
      if (mp.find(A[i])->second == 0) {
        mp.erase(A[i]);
      }
      if (st.size() == cnt) {
        res++;
        while (st.size() > 0) {
          st.erase(st.begin());
        }
        cnt = mp.size();
      }
    }

    // вывод результата
    cout &lt;&lt; res &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача D. Месть -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Месть</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Юсеф хочет взорвать массив a1,a2,…,an. Массив взрывается, когда все его элементы становятся равными нулю.</p>

  <p>В одной операции Юсеф может сделать одно из следующих:</p>
  <ol>
    <li>Для каждого индекса i в a уменьшить ai на i.</li>
    <li>Для каждого индекса i в a уменьшить ai на n-i+1.</li>
  </ol>

  <p>Ваша задача — помочь Юсефу определить, возможно ли взорвать массив, используя любое количество операций.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит целое число n (2 ≤ n ≤ 2⋅10⁵) — размер массива.</p>

  <p>Вторая строка каждого набора входных данных содержит n целых чисел a1, a2, … , an (1 ≤ ai ≤ 10⁹) — элементы массива.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите «YES», если Юсеф может взорвать массив, в противном случае выведите «NO».</p>

  <p>Вы можете выводить ответ в любом регистре (верхнем или нижнем). Например, строки «yEs», «yes», «Yes», и «YES» будут распознаны как положительные ответы.</p>

  <details>
    <summary>Пример</summary>
<pre>
6
4
3 6 6 3
5
21 18 15 12 9
10
2 6 10 2 5 5 1 2 4 10
7
10 2 16 12 8 20 4
2
52 101
2
10 2
</pre>
<pre>
NO
YES
NO
NO
YES
NO
</pre>

    <p>Во втором наборе входных данных мы можем сделать следующее:</p>
    <ul>
      <li>Выполнить 1 операцию первого типа. Массив становится [20,16,12,8,4].</li>
      <li>Выполнить 4 операции второго типа. Массив становится [0,0,0,0,0].</li>
    </ul>
    <p>В первом, третьем, четвертом и шестом наборах входных данных можно доказать, что невозможно сделать все элементы равными нулю, используя любое количество операций.</p>
  </details>


  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n;
    cin >> n;
    vector&lt;long long&gt; A(n);
    for (int i = 0; i &lt; n; i++) {
      cin >> A[i];
    }

    // решение
    long long find_el = A[1] - A[0];
    bool flag_res = true;
    vector&lt;long long&gt; B(n);
    if (find_el >= 0) {
      for (int i = 0; i &lt; n; i++) {
        B[i] = A[i] - find_el * (i + 1);
      }
      for (int i = 0; i &lt; n - 1; i++) {
        if (B[i] != B[i + 1]) {
          flag_res = false;
        }
        if (B[i] % (n + 1) != 0) {
          flag_res = false;
        }
        if (B[i] &lt; 0) {
          flag_res = false;
        }
      }
    } else {
      reverse(A.begin(), A.end());
      find_el = -find_el;
      for (int i = 0; i &lt; n; i++) {
        B[i] = A[i] - find_el * (i + 1);
      }
      for (int i = 0; i &lt; n - 1; i++) {
        if (B[i] != B[i + 1]) {
          flag_res = false;
        }
        if (B[i] % (n + 1) != 0) {
          flag_res = false;
        }
        if (B[i] &lt; 0) {
          flag_res = false;
        }
      }
    }

    // вывод результата
    if (flag_res) {
      cout &lt;&lt; "YES\n";
    } else {
      cout &lt;&lt; "NO\n";
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача E. Потерянная душа -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Потерянная душа</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Даны два целых массива a и b, каждый длиной n.</p>

  <p>Вы можете выполнять следующую операцию любое количество раз:</p>
  <ul>
    <li>Выберите индекс i (1 ≤ i ≤ n-1) и присвойте ai:=bi+1, или присвойте bi:=ai+1.</li>
  </ul>

  <p>Перед выполнением любых операций вы можете выбрать индекс i (1 ≤ i ≤ n) и удалить как ai, так и bi из массивов. Это удаление можно выполнить не более одного раза.</p>

  <p>Пусть количество совпадений между двумя массивами c и d длиной m равно количеству позиций j (1 ≤ j ≤ m), таких что cj=dj.</p>

  <p>Ваша задача — вычислить максимальное количество совпадений, которое вы можете достичь.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных. Описание каждого набора входных данных следует далее.</p>

  <p>Первая строка содержит целое число n (2 ≤ n ≤ 2⋅10⁵) — длина массивов a и b.</p>

  <p>Вторая строка содержит n целых чисел a1, a2, …, an (1 ≤ ai ≤ n) — элементы массива a.</p>

  <p>Третья строка содержит n целых чисел b1, b2, …, bn (1 ≤ bi ≤ n) — элементы массива b.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно целое число — ответ для данного набора.</p>

  <details>
    <summary>Пример</summary>
<pre>
10
4
1 3 1 4
4 3 2 2
6
2 1 5 3 6 4
3 2 4 5 1 6
2
1 2
2 1
6
2 5 1 3 6 4
3 5 2 3 4 6
4
1 3 2 2
2 1 3 4
8
3 1 4 6 2 2 5 7
4 2 3 7 1 1 6 5
10
5 1 2 7 3 9 4 10 6 8
6 2 3 6 4 10 5 1 7 9
5
3 2 4 1 5
2 4 5 1 3
7
2 2 6 4 1 3 5
3 1 6 5 1 4 2
5
4 1 3 2 5
3 2 1 5 4
</pre>
<pre>
3
3
0
4
3
5
6
4
5
2
</pre>

    <p>В первом наборе входных данных мы можем сделать следующее:</p>
    <ul>
      <li>Мы решим не удалять никакой индекс.</li>
      <li>Выберите индекс 3 и присвойте a3:=b4. Массивы становятся: a=[1,3,2,4], b=[4,3,2,2].</li>
      <li>Выберите индекс 1 и присвойте a1:=b2. Массивы становятся: a=[3,3,2,4], b=[4,3,2,2].</li>
      <li>Выберите индекс 1 и присвойте b1:=a2. Массивы становятся: a=[3,3,2,4], b=[3,3,2,2]. Обратите внимание, что вы можете выполнить ai:=bi+1 и bi:=ai+1 на одном и том же индексе i.</li>
    </ul>
    <p>Количество совпадений равно 3. Можно показать, что это максимальный ответ, который мы можем достичь.</p>
    <p>Во втором наборе входных данных мы можем сделать следующее, чтобы достичь максимума в 3:</p>
    <ul>
      <li>Давайте решим удалить индекс 5. Массивы становятся: a=[2,1,5,3,4], b=[3,2,4,5,6].</li>
      <li>Выберите индекс 4 и присвойте b4:=a5. Массивы становятся: a=[2,1,5,3,4], b=[3,2,4,4,6].</li>
      <li>Выберите индекс 3 и присвойте a3:=b4. Массивы становятся: a=[2,1,4,3,4], b=[3,2,4,4,6].</li>
      <li>Выберите индекс 2 и присвойте a2:=b3. Массивы становятся: a=[2,4,4,3,4], b=[3,2,4,4,6].</li>
      <li>Выберите индекс 1 и присвойте b1:=a2. Массивы становятся: a=[2,4,4,3,4], b=[4,2,4,4,6].</li>
      <li>Выберите индекс 2 и присвойте b2:=a3. Массивы становятся: a=[2,4,4,3,4], b=[4,4,4,4,6].</li>
      <li>Выберите индекс 1 и присвойте a1:=b2. Массивы становятся: a=[4,4,4,3,4], b=[4,4,4,4,6].</li>
    </ul>
    <p>В третьем наборе входных данных можно показать, что мы не можем получить никаких совпадений. Поэтому ответ равен 0.</p>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

// условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // размер массивов
    cin >> n;
    vector&lt;vector&lt;pair&lt;int, int&gt; &gt; &gt; All_el(n + 1);
    vector&lt;vector&lt;int&gt; &gt; A(n + 1);
    vector&lt;vector&lt;int&gt; &gt; B(n + 1);
    pair&lt;int, int&gt; tmp;
    int h;

    // собираем элементы первого массива
    for (int i = 1; i &lt;= n; i++) {
      cin >> h;
      tmp.first = i;
      tmp.second = 1; // признак первого массива
      All_el[h].push_back(tmp);
      A[h].push_back(i);
    }

    // собираем элементы второго массива
    for (int i = 1; i &lt;= n; i++) {
      cin >> h;
      tmp.first = i;
      tmp.second = 2; // признак второго массива
      All_el[h].push_back(tmp);
      B[h].push_back(i);
    }

    for (int i = 1; i &lt; All_el.size(); i++) {
      sort(All_el[i].begin(), All_el[i].end());
    }
    int best = 0;

    for (int i = 1; i &lt;= n; i++) {
      if (All_el[i].size() >= 2) {
        for (int j = 0; j &lt; All_el[i].size() - 1; j++) {
          if (All_el[i][j].first == All_el[i][j + 1].first) {
            best = max(best, All_el[i][j].first);
          } else if (All_el[i][j].second != All_el[i][j + 1].second) {
            if (All_el[i][j + 1].first - All_el[i][j].first > 1) {
              best = max(best, All_el[i][j].first);
            }
          }
        }
      }
    }

    // если в массиве есть два одинаковых соседних числа
    // то можно сделать красивую последовательность
    for (int i = 1; i &lt;= n; i++) {
      if (A[i].size() > 1) {
        best = max(best, A[i][A[i].size() - 2]);
      }
      if (B[i].size() > 1) {
        best = max(best, B[i][B[i].size() - 2]);
      }
    }

    // вывод результата
    cout &lt;&lt; best &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача F. Дикие цветы -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Дикие цветы</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У Юсефа есть корневое дерево∗, состоящее ровно из n вершин, с корнем в вершине 1. Вы хотите дать Юсефу массив a длины n, где каждый элемент ai (1≤i≤n) может быть либо 1, либо 2.</p>

  <p>Обозначим su как сумму av, где вершина v находится в поддереве† вершины u. Юсеф считает дерево особым, если все значения в s попарно различны (т.е. все суммы поддеревьев уникальны).</p>

  <p>Ваша задача — помочь Юсефу подсчитать количество различных массивов a, которые делают дерево особым. Два массива b и c различны, если существует индекс i, такой что bi≠ci.</p>

  <p>Поскольку результат может быть очень большим, вы должны вывести его по модулю 10⁹+7.</p>

  <p>* Дерево — это связный неориентированный граф с n-1
   рёбрами.</p>

  <p>† Поддерево вершины v — это множество всех вершин, которые проходят через v по простому пути к корню. Обратите внимание, что вершина v также включена в множество.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Каждый тест состоит из нескольких строк. Первая строка теста содержит целое число n (2 ≤ n ≤ 2⋅10⁵) — количество вершин в дереве.</p>

  <p>Затем следуют n-1 строк, каждая из которых содержит два целых числа u и v (1 ≤ u, v ≤ n, u ≠ v), которые описывают пару вершин, соединённых ребром. Гарантируется, что данный граф является деревом и не имеет петель или кратных рёбер.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого теста выведите одно целое число x — количество различных массивов a, которые делают дерево особым, по модулю 10⁹+7.</p>

  <details>
    <summary>Пример</summary>
<pre>
7
2
1 2
8
1 2
2 3
3 8
2 4
4 5
5 6
6 7
10
1 2
2 3
3 4
4 5
5 6
4 7
7 8
4 9
9 10
7
1 4
4 2
3 2
3 5
2 6
6 7
7
1 2
2 3
3 4
3 5
4 6
6 7
7
5 7
4 6
1 6
1 3
2 6
6 7
5
3 4
1 2
1 3
2 5
</pre>
<pre>
4
24
0
16
48
0
4
</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Нужно посчитать листья дерева. Если list = 1 то ответ 2<sup>n</sup>. Если листьев 2, то нужно думать. Это обход дерева методом BFS.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

// условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // число вершин
    cin >> n;

    vector&lt;vector&lt;int&gt; &gt; G(n + 1);
    for (int i = 0; i &lt; n - 1; i++) {
      int a, b;
      cin >> a >> b;
      G[a].push_back(b);
      G[b].push_back(a);
    }

    long long mod = 1e9 + 7;
    vector&lt;int&gt; Level(n + 1);
    vector&lt;int&gt; Mark(n + 1);
    queue&lt;int&gt; q;
    q.push(1);
    vector&lt;int&gt; Putty(n + 1);
    Putty[1] = 1;

    while (q.size() > 0) {
      int tmp = q.front();
      q.pop();
      Mark[tmp] = 1;
      for (int i = 0; i &lt; G[tmp].size(); i++) {
        if (Mark[G[tmp][i]] == 0) {
          q.push(G[tmp][i]);
          Putty[G[tmp][i]] = tmp;
          Level[tmp]++;
        }
      }
    }

    int count_node = 0;
    for (int i = 1; i &lt;= n; i++) {
      if (Level[i] > 2) {
        count_node++;
        count_node++;
      } else if (Level[i] == 2) {
        count_node++;
      }
    }

    if (count_node > 1) {
      cout &lt;&lt; 0 &lt;&lt; '\n';
    } else if (count_node == 0) {

      // это дерево бамбук
      long long res = 1;
      for (int i = 1; i &lt;= n; i++) {
        res = (res * 2) % mod;
      }
      cout &lt;&lt; res &lt;&lt; '\n';
    } else {
      // нужно найти количство узлов от листа до развилки
      int id_node1 = -1;
      int id_node2 = -1;
      for (int i = 1; i &lt;= n; i++) {
        if (Level[i] == 0) {
          if (id_node1 == -1) {
            id_node1 = i;
          } else {
            id_node2 = i;
          }
        }
      }

      int len1 = 0;
      int len2 = 0;
      while (Level[Putty[id_node1]] != 2) {
        id_node1 = Putty[id_node1];
        len1++;
      }

      while (Level[Putty[id_node2]] != 2) {
        id_node2 = Putty[id_node2];
        len2++;
      }

      if (len1 == len2) {
        long long res = 2;

        while (Putty[id_node1] != id_node1) {
          id_node1 = Putty[id_node1];
          res = (res * 2) % mod;
        }
        cout &lt;&lt; res &lt;&lt; '\n';
      } else {
        long long res = 3;
        while (Putty[id_node1] != id_node1) {
          id_node1 = Putty[id_node1];
          res = res * 2 % mod;
        }
        for (int j = 0; j &lt; max(len1, len2) - min(len1, len2) - 1; j++) {
          res = (res * 2) % mod;
        }
        cout &lt;&lt; res &lt;&lt; '\n';
      }
    }

  }
}
</pre>
  </details>
</article>


<!-- Задача G. ОМГраф -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. ОМГраф</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам дан неориентированный связный взвешенный граф. Определим стоимость пути длины k следующим образом:</p>
  <ul>
    <li>Пусть веса всех рёбер на пути равны w1,...,wk.</li>
    <li>Стоимость пути равна (min<sup>k</sup><sub>i=1</sub>wi)+(max<sup>k</sup><sub>i=1</sub>wi), или, другими словами, максимальный вес ребра + минимальный вес ребра.</li>
  </ul>
  <p></p>

  <p>По всем путям от вершины 1 до n сообщите стоимость пути с минимальной стоимостью. Обратите внимание, что путь не обязательно простой.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит два целых числа n и m (2 ≤ n ≤ 2⋅10⁵, n-1 ≤ m ≤ min(2⋅10⁵, n(n-1) / 2)).</p>

  <p>Следующие m строк содержат целые числа u,v и w (1 ≤ u, v ≤ n, 1 ≤ w ≤ 10⁹), представляющие ребро из вершины u в v с весом w. Гарантируется, что граф не содержит петель или кратных рёбер, и полученный граф связен.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 2⋅10⁵ и что сумма m по всем наборам входных данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно целое число, минимальную стоимость пути от вершины 1 до n.</p>

  <details>
    <summary>Пример</summary>
<pre>
4
3 2
1 2 1
2 3 1
3 2
1 3 13
1 2 5
8 9
1 2 6
2 3 5
3 8 6
1 4 7
4 5 4
5 8 7
1 6 5
6 7 5
7 8 5
3 3
1 3 9
1 2 8
2 3 3
</pre>
<pre>
2
18
10
11
</pre>

    <p>Для второго набора входных данных оптимальный путь это 1→2→1→3, веса рёбер равны 5,5,13, так что стоимость равна min(5,5,13)+max(5,5,13)=5+13=18. Можно доказать, что нет пути с меньшей стоимостью.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Бинпоиском находим дорогие пути. И делаем СНМ. В СНМ запоминаем самое дешевое и самое дорогое. После сортировки стоимости путей, находим бинпоиском самый дорогой путь. Два указателя: левый на левой границе, на самом дешевом пути, правый - на дорогом, который мы нашли бинпоиском. Определим результат как сумму дешевого и дорогого. Левый мы не можем сдвинуть левее, потому что некуда. Правый мы не будем двигать правее, потому что будет только хуже. Сдвигаем левый указатель вправо, то есть дешевый становится дороже, а правый указатель влево, то есть дорогой становится дешевле. Обновляем результат. Двигаем, пока происходят улучшения. Если улучшения уже не происходят, то нет смысла двигать их дальше, на этом надо остановиться.</p>
  </details>
</article>


<!-- Задача H. Непрекращающийся дождь -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Непрекращающийся дождь</h3>

  <div><i>Ограничение по времени 3с
  <br>Ограничение по памяти 192мб</i></div>

  <p>Обратите внимание на необычное ограничение по памяти.</p>

  <p>Серебряный Волк дает вам массив a длиной n и q запросов. В каждом запросе она заменяет элемент в a. После каждого запроса она просит вас вывести максимальное целое число k, такое что существует целое число x, которое является k-большинством подмассива∗ массива a.</p>

  <p>Целое число y является k-большинством массива b, если y появляется как минимум ⌊(|b|+1) / 2⌋+k раз в b, где |b| представляет длину b. Обратите внимание, что b может не иметь k-большинства.</p>

  <p>* Массив b является подмассивом массива a, если b можно получить из a путем удаления нескольких (возможно, нуля или всех) элементов с начала и нескольких (возможно, нуля или всех) элементов с конца.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10⁴)  — количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит два целых числа n и q (1 ≤ n, q ≤ 3⋅10⁵)  — длина a и количество запросов.</p>

  <p>Следующая строка содержит n целых чисел a1,a2,…,an через пробел (1≤ai≤n).</p>

  <p>Следующие q строк содержат два целых числа i и x, обозначающие запрос, который заменяет ai на x (1≤i,x≤n).</p>

  <p>Гарантируется, что сумма n и сумма q по всем наборам входных данных не превышает 3⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите ответ на все запросы в одной новой строке, разделенной пробелами.</p>

  <details>
    <summary>Пример</summary>
<pre>
2
5 5
1 2 3 4 5
3 4
1 4
2 4
4 3
2 3
7 8
3 2 3 3 2 2 3
2 3
5 3
6 3
3 4
4 4
7 4
6 4
2 4
</pre>
<pre>
1 1 2 1 0
2 2 3 2 1 1 1 2
</pre>
  </details>
</article>

