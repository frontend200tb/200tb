<article class="article">
  <p><a href="https://codeforces.com/contest/1873" target="_blank">Codeforces Round 898 (Div. 4) 2023-09-21</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
        <a href="#task1">Задача A. Короткая сортировка</a>
    <br><a href="#task2">Задача B. Хороший ребенок</a>
    <br><a href="#task3">Задача C. Стрельба по мишени</a>
    <br><a href="#task4">Задача D. 1D Ластик</a>
    <br><a href="#task5">Задача E. Построение аквариума</a>
    <br><a href="#task6">Задача F. Деревья с деньгами</a>
    <br><a href="#task7">Задача G. ABBC или BACB</a>
    <br><a href="#task8">Задача H. Безумный город</a>
  </p>
</article>


<!-- Задача A. Короткая сортировка -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Короткая сортировка</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Есть три карты с буквами a, b, c, расположенные в ряд в некотором порядке. Вы можете выполнить следующую операцию не более одного раза:</p>
  <ul>
    <li>Выберите две карты и поменяйте их местами.</li>
  </ul>

  <p>Возможно ли, чтобы ряд стал abc после выполнения операции? Выведите «YES», если это возможно, и «NO» в противном случае.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно целое число t (1≤t≤6) — количество наборов входных данных.</p>

  <p>Единственная строка каждого набора содержит одну строку, состоящую из трех символов a, b и c ровно по одному, представляющих карты.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите «YES», если вы можете сделать ряд abc с помощью не более одной операции, или «NO» в противном случае.</p>

  <p>Вы можете вывести ответ в любом регистре (например, строки «yEs», «yes», «Yes» и «YES» будут распознаны как положительный ответ).</p>

  <h4>Пример</h4>
<pre>
6
abc
acb
bac
bca
cab
cba
</pre>
<pre>
YES
YES
YES
NO
NO
YES
</pre>
  <p>В первом наборе входных данных примера нам не нужно выполнять никаких операций, так как ряд уже abc.</p>
  <p>Во втором наборе входных данных примера мы можем поменять местами c и b: acb→abc.</p>
  <p>В третьем наборе входных данных примера мы можем поменять местами b и a: bac→abc.</p>
  <p>В четвертом наборе входных данных примера невозможно получить abc с помощью не более одной операции.</p>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // количество тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    string s;
    cin >> s;

    // решение
    string temp = "abc"; // шаблон
    int cnt = 0; // число букв не на своих местах

    // считаем число букв не на своих местах
    for (int i = 0; i &lt; 3; i++) {
      if (s[i] != temp[i]) {
        cnt++;
      }
    }

    // вывод результата
    // один обмен меняет 2 буквы
    // значит должно быть не более двух букв не на своих местах
    if (cnt > 2) {
      cout &lt;&lt; "NO\n";
    } else {
      cout &lt;&lt; "YES\n";
    }
  }

}
</pre>
  </details>
</article>


<!-- Задача B. Хороший ребенок -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Хороший ребенок</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Славик готовит подарок для дня рождения друга. У него есть массив a
  из n цифр, и подарком будет произведение всех этих цифр. Поскольку Славик - хороший ребенок, он хочет сделать наибольшее возможное произведение, для этого он может добавить 1 к ровно одной из своих цифр.</p>

  <p>Какое максимальное произведение может получить Славик?</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора содержит одно целое число n ( 1≤ n ≤ 9) — количество цифр.</p>

  <p>Вторая строка каждого набора содержит n целых чисел, разделенных пробелом, aᵢ (0 ≤ aᵢ ≤ 9) — цифры в массиве.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно целое число — максимальное произведение, которое может получить Славик, добавив 1
  к ровно одной из своих цифр.</p>

  <h4>Пример</h4>
<pre>
4
4
2 2 1 2
3
0 1 2
5
4 3 2 3 4
9
9 9 9 9 9 9 9 9 9
</pre>
<pre>
16
2
432
430467210
</pre>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // количество тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n;
    cin >> n;

    // решение
    int min_n = 9; // минимальная цифра
    int cnt0 = 0;  // количество нулей
    int tmp; // принятая цифра
    int prod = 1; // произведение цифр

    for (int i = 0; i &lt; n; i++) {
      // принимаем следующую цифру
      cin >> tmp;
      if (tmp == 0) {
        // если пришел ноль
        // обновляем минимум
        min_n = 0;
        // считаем число пришедших нулей
        cnt0++;
        if (cnt0 > 1) {
          // если было два нуля, то произведение равно нулю
          prod = 0;
        }
      } else {
        // считаем произведение всех цифр без нулей
        prod *= tmp;
        if (min_n > tmp) {
          // обновляем минимум
          min_n = tmp;
        }
      }
    }

    // увеличивать надо минимальную цифру
    // если минимальная цифра это ноль
    // то изменим ее на 1 и произведение останется прежним
    if (min_n) {
      prod /= min_n;
      prod *= min_n + 1;
    }

    // вывод результата
    cout &lt;&lt; prod &lt;&lt; '\n';
  }

}
</pre>
  </details>
</article>


<!-- Задача C. Стрельба по мишени -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Стрельба по мишени</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Мишень размером 10x10 состоит из пяти «колец», как показано на рисунке. Попадание в каждое кольцо даёт разное количество очков: внешнее кольцо — 1 очко, следующее кольцо — 2 очка, ..., центральное кольцо — 5 очков.</p>
<pre>
1111111111
1222222221
1233333321
1234444321
1234554321
1234554321
1234444321
1233333321
1222222221
1111111111
</pre>
  <p>Влад выпустил несколько стрел по мишени. Помогите ему определить, сколько очков он набрал.</p>

  <h4>Входные данные</h4>
  <p>Ввод содержит несколько наборов входных данных. Первая строка ввода содержит одно целое число t (1 ≤ t ≤ 1000) — количество наборов входных данных.</p>

  <p>Каждый набор состоит из 10 строк, каждая из которых содержит 10 символов. Каждый символ в сетке может быть либо 'X' (обозначает попадание стрелы), либо '.' (обозначает промах).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно целое число — общее количество очков.</p>

  <h4>Пример</h4>
<pre>
4
X.........
..........
.......X..
.....X....
......X...
..........
.........X
..X.......
..........
.........X
..........
..........
..........
..........
..........
..........
..........
..........
..........
..........
..........
..........
..........
..........
....X.....
..........
..........
..........
..........
..........
XXXXXXXXXX
XXXXXXXXXX
XXXXXXXXXX
XXXXXXXXXX
XXXXXXXXXX
XXXXXXXXXX
XXXXXXXXXX
XXXXXXXXXX
XXXXXXXXXX
XXXXXXXXXX
</pre>
<pre>
17
0
5
220
</pre>
  <p>В первом примере на внешнем кольце находятся три стрелы, каждая из которых стоит 1 очко, на следующем кольце находятся две стрелы, каждая из которых стоит 3 очка, и на следующем кольце находятся две стрелы, каждая из которых стоит 4 очка. Общий счет равен 3x1+2x3+2x4=17.</p>
  <p>Во втором примере стрел нет, поэтому счет равен 0.</p>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // количество тестов
  int t;
  cin >> t;

  while (t--) {
    // решение
    int cnt = 0;
    char sym;
    for (int str = 1; str &lt; 11; str++) {
      for (int col = 1; col &lt; 11; col++) {
        // следующий символ
        cin >> sym;
        if (sym == 'X') {
          if      (str == 1 || str == 10 || col == 1 || col == 10) {
            cnt += 1;
          } else if (str == 2 || str == 9 || col == 2 || col == 9) {
            cnt += 2;
          } else if (str == 3 || str == 8 || col == 3 || col == 8) {
            cnt += 3;
          } else if (str == 4 || str == 7 || col == 4 || col == 7) {
            cnt += 4;
          } else {
            cnt += 5;
          }
        }
      }
    }

    // вывод результата
    cout &lt;&lt; cnt &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача D. 1D Ластик -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. 1D Ластик</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У вас есть полоска бумаги s, которая имеет длину n ячеек. Каждая ячейка может быть либо черной, либо белой. За одну операцию вы можете выбрать любые k последовательных ячеек и сделать их все белыми.</p>

  <p>Найдите минимальное количество операций, необходимых для удаления всех черных ячеек.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно целое число t (1 ≤ t ≤ 1000) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора содержит два целых числа n и k (1 ≤ k ≤ n ≤ 2⋅10⁵) — длина полоски бумаги и целое число, используемое в операции.</p>

  <p>Вторая строка каждого набора содержит строку s длиной n, состоящую из символов B (представляющего черную ячейку) и W (представляющего белую ячейку).</p>

  <p>Сумма n по всем тестам не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно целое число — минимальное количество операций, необходимых для удаления всех черных ячеек.</p>

  <h4>Пример</h4>
<pre>
8
6 3
WBWWWB
7 3
WWBWBWW
5 4
BWBWB
5 5
BBBBB
8 2
BWBWBBBB
10 2
WBBWBBWBBW
4 1
BBBB
3 2
WWW
</pre>
<pre>
2
1
2
1
4
3
4
0
</pre>
  <p>В первом наборе входных данных примера вы можете выполнить следующие операции:</p>
  <code>WBWWWB→WWWWWB→WWWWWW</code>
  <p>Во втором наборе входных данных примера вы можете выполнить следующие операции:</p>
  <code>WWBWBWW→WWWWWWW</code>
  <p>В третьем наборе входных данных примера вы можете выполнить следующие операции:</p>
  <code>BWBWB→BWWWW→WWWWW</code>
</article>


<!-- Задача E. Построение аквариума -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Построение аквариума</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вы любите рыб, поэтому решили построить аквариум. У вас есть кусок коралла, состоящий из n колонн, i-я из которых имеет высоту ai единиц. Затем вы построите вокруг коралла аквариум следующим образом:</p>
  <ul>
    <li>Выберите целое число h ≥ 1 — высоту аквариума. Постройте стены высотой h с обеих сторон аквариума.</li>
    <li>Затем заполните аквариум водой так, чтобы высота каждой колонны была равна h, если только коралл не выше h; в этом случае в эту колонну вода добавляться не должна.</li>
  </ul>
  <p>Например, с a=[3,1,2,4,6,2,5] и высотой h=4, вы потратите в общей сложности w=8 единиц воды, как показано на рисунке.</p>
<pre>
h = 4
         6
         6 5
    |###46#5|
    |3##46#5|
    |3#24625|
a = |3124625|
</pre>
  <p>Вы можете использовать не более x единиц воды для заполнения аквариума, но вы хотите построить наибольший возможный аквариум. Какое наибольшее значение h вы можете выбрать?</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора содержит два положительных целых числа n и x (1 ≤ n ≤ 2⋅10⁵; 1 ≤ x ≤ 10⁹) — количество колонн коралла и максимальное количество воды, которое вы можете использовать.</p>

  <p>Вторая строка каждого набора содержит n целых чисел, разделенных пробелом, aᵢ (1 ≤ aᵢ ≤ 10⁹) — высоты колонн коралла.</p>

  <p>Сумма n по всем наборам входных данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно положительное целое число h (h ≥ 1) — максимальную высоту аквариума, для заполнения которого вам потребуется не более x единиц воды.</p>

  <p>Можно доказать, что при таких ограничениях всегда существует такое значение h.</p>

  <h4>Пример</h4>
<pre>
5
7 9
3 1 2 4 6 2 5
3 10
1 1 1
4 1
1 4 3 4
6 1984
2 6 5 9 1 8
1 1000000000
1
</pre>
<pre>
4
4
2
335
1000000001
</pre>
  <p>Первый пример изображен в условии. С h=4 нам потребуется 8 единиц воды, но если увеличить h до 5, нам потребуется 13 единиц воды, что больше, чем x=9. Поэтому оптимальное значение h=4.</p>
  <p>Во втором примере случае мы можем выбрать h=4 и добавить 3 единицы к каждой колонне, используя в общей сложности 9 единиц воды. Можно показать, что это оптимально.</p>
  <p>В третьем примере случае мы можем выбрать h=2 и использовать всю нашу воду, поэтому это оптимально.</p>
</article>


<!-- Задача F. Деревья с деньгами -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Деревья с деньгами</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Лука стоит перед рядом из n деревьев. У i-го дерева есть ai фруктов и высота hi.</p>

  <p>Он хочет выбрать непрерывный подмассив массива [h<sub>l</sub>, h<sub>l+1</sub>, … , h<sub>r</sub>]
 , такой что для каждого i (l ≤ i &lt; r), hi делится† на h<sub>i+1</sub>. Он соберет все фрукты с каждого дерева в подмассиве (то есть, он соберет a<sub>l</sub>+a<sub>l+1</sub>+⋯+a<sub>r</sub> фруктов). Однако, если он соберет больше k фруктов в общей сложности, его поймают.</p>

  <p>Какова максимальная длина подмассива, который Лука может выбрать, чтобы не попасться?</p>

  <p>† x делится на y, если отношение x/y является целым числом.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно целое число t (1 ≤ t ≤ 1000) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора содержит два целых числа, разделенных пробелом: n и k (1 ≤ n ≤ 2⋅10⁵; 1 ≤ k ≤ 10⁹) — количество деревьев и максимальное количество фруктов, которое Лука может собрать, не попавшись.</p>

  <p>Вторая строка каждого набора содержит n целых чисел, разделенных пробелом: aᵢ (1 ≤ aᵢ ≤ 10⁴) — количество фруктов в i-м дереве.</p>

  <p>Третья строка каждого набора содержит n целых чисел, разделенных пробелом: hᵢ (1 ≤ hᵢ ≤ 10⁹) — высота i-го дерева.</p>

  <p>Сумма n по всем наборам входных данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно целое число, длину максимального непрерывного подмассива, удовлетворяющего условиям, или 0, если такого подмассива нет.</p>

  <h4>Пример</h4>
<pre>
5
5 12
3 2 4 1 8
4 4 2 4 1
4 8
5 4 1 2
6 2 3 1
3 12
7 9 10
2 2 4
1 10
11
1
7 10
2 6 3 1 5 10 6
72 24 24 12 4 4 2
</pre>
<pre>
3
2
1
0
3
</pre>
  <p>В первом примере Лука может выбрать подмассив с l=1 и r=3.</p>
  <p>Во втором примере Лука может выбрать подмассив с l=3 и r=4.</p>
  <p>В третьем примере Лука может выбрать подмассив с l=2 и r=2.</p>
</article>


<!-- Задача G. ABBC или BACB -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. ABBC или BACB</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Дана строка s, состоящая из символов A и B. Изначально у вас нет монет. Вы можете выполнять два типа операций:</p>
  <ul>
    <li>Выберите подстроку† AB, замените ее на BC и получите монету.</li>
    <li>Выберите подстроку† BA, замените ее на CB и получите монету.</li>
  </ul>
  <p>Какое максимальное количество монет вы можете получить?</p>
  <p>† Подстрока длины 2 - это последовательность из двух соседних символов строки.</p>

  <h4>Входные данные</h4>
  <p>Ввод состоит из нескольких наборов входных данных. Первая строка ввода содержит одно целое число t (1 ≤ t ≤ 1000) — количество наборов входных данных.</p>

  <p>Единственная строка каждого набора содержит строку s (1 ≤ |s| ≤ 2⋅10⁵). Все символы s являются либо A, либо B.</p>

  <p>Сумма длин s по всем наборам входных данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно целое число — максимальное количество монет, которое вы можете получить.</p>

  <h4>Пример</h4>
<pre>
8
ABBA
ABA
BAABA
ABB
AAAAAAB
BABA
B
AAA
</pre>
<pre>
2
1
3
1
6
2
0
0
</pre>
  <p>В первом примере вы можете выполнить следующие операции, чтобы получить 2 монеты:</p>
  <code>ABBA→BCBA→BCCB</code>
  <p>Во втором примере вы можете выполнить следующую операцию, чтобы получить 1 монету:</p>
  <code>ABA→BCA</code>
  <p>В третьем примере вы можете выполнить следующие операции, чтобы получить 3 монеты:</p>
  <code>BAABA→CBABA→CBACB→CCBCB</code>
</article>


<!-- Задача H. Безумный город -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Безумный город</h3>

  <div><i>Ограничение по времени 4с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Марсель и Валериу находятся в безумном городе, который представляет собой n зданий с n двусторонними дорогами между ними.</p>

  <p>Марсель и Валериу начинают в зданиях a и b соответственно. Марсель хочет поймать Валериу, то есть оказаться в том же здании, что и он, или встретиться на одной дороге.</p>

  <p>Во время каждого хода они выбирают, пойти в соседнее здание от текущего или остаться в том же здании. Поскольку Валериу хорошо знает Марселя, Валериу может предсказать, куда Марсель пойдет в следующем ходу. Валериу может использовать эту информацию, чтобы сделать свой ход. Они начинают и заканчивают ход одновременно.</p>

  <p>Гарантируется, что любая пара зданий соединена некоторым путем, и между любой парой зданий есть не более одной дороги.</p>

  <p>Предполагая, что оба игрока играют оптимально, ответьте, есть ли у Валериу стратегия, чтобы бесконечно уходить от Марселя.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно целое число t (1 ≤ t ≤ 1000) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора содержит три целых числа, разделенных пробелом: n, a, b (3 ≤ n ≤ 2⋅10⁵; 1 ≤ a, b ≤ n) — количество зданий (которое равно количеству дорог) и начальные здания Марселя и Валериу.</p>

  <p>Следующие n строк содержат по два целых числа uᵢ, vᵢ (1 ≤ uᵢ, vᵢ ≤ n, uᵢ ≠ vᵢ) — между зданиями uᵢ и vᵢ есть дорога. Между любой неупорядоченной парой зданий может быть не более одной дороги.</p>

  <p>Сумма n по всем наборам входных данных не превышает 2⋅10⁵.</p>

  <p>Дороги заданы таким образом, что можно добраться из любого здания в любое другое, двигаясь по дорогам.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите «YES», если Валериу может бесконечно уходить от Марселя, и «NO» в противном случае.</p>

  <p>Вы можете выводить ответ в любом регистре (например, строки «yEs», «yes», «Yes» и «YES» будут распознаны как положительный ответ).</p>

  <h4>Пример</h4>
<pre>
6
3 2 1
2 1
3 2
1 3
4 1 4
1 4
1 2
1 3
2 3
4 1 2
1 2
2 3
2 4
3 4
7 1 1
4 1
2 1
5 3
4 6
4 2
7 5
3 4
8 5 3
8 3
5 1
2 6
6 8
1 2
4 8
5 7
6 7
10 6 1
1 2
4 3
5 8
7 8
10 4
1 9
2 4
8 1
6 2
3 1
</pre>
<pre>
YES
NO
YES
NO
NO
YES
</pre>
  <p>В первом примере граф выглядит следующим образом:</p>
<pre>
  3
 / \
2___1
</pre>
  <p>Марсель начинает в здании 2, а Валериу начинает в здании 1. Валериу знает, каким путем Марсель будет двигаться вокруг треугольника, и он может просто всегда двигаться так же, чтобы всегда избегать Марселя.</p>
  <p>Во втором примере граф выглядит следующим образом:</p>
<pre>
  3
 / \
2___1___4
</pre>
  <p>Марсель начинает в здании 1, а Валериу начинает в здании 4. Марсель может пойти в здание 4 на своем первом ходу и победить, так как Валериу должен либо пойти в здание 1 (тогда они встретятся на дороге от 1 до 4), либо остаться в здании 4 (тогда они встретятся в здании 4). Таким образом, у Валериу нет стратегии для победы.</p>
</article>
