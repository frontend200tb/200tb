<article class="article">
  <a href="https://codeforces.com/contest/1030" target="_blank">Codeforces 1030 Технокубок 2019 - Отборочный Раунд 1 2019-09-23</a>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

      <a href="#task1">Задача A. В поисках простой задачи</a>
  <br><a href="#task2">Задача B. Вася и кукурузное поле</a>
  <br><a href="#task3">Задача C. Вася и золотой билет</a>
  <br><a href="#task4">Задача D. Вася и треугольник</a>
  <br><a href="#task5">Задача E. Вася и хорошие последовательности</a>
  <br><a href="#task6">Задача F. Сдвигаем ящики</a>
  <br><a href="#task7">Задача G. Линейный конгруэнтный генератор</a>
</article>


<!-- Задача A. В поисках простой задачи -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. В поисках простой задачи</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Начиная очередной чемпионат, координаторы Codeforces всегда стараются сделать первую задачу максимально простой. В этот раз координатор выбрал некоторую задачу и спросил у n
  человек, достаточно ли она простая. Каждый человек ответил, что задача простая, или что задача сложная.</p>

  <p>Если хоть кто-то из этих n человек ответил, что задача сложная, ее нужно заменить, иначе не нужно. По данным ответам определите, нужно ли заменить задачу.</p>

  <h4>Входные данные</h4>
  <p>В первой строке задано одно целое число n (1 ≤ n ≤ 100) — количество опрошенных человек.</p>

  <p>Во второй строке заданы n целых чисел, каждое из которых равно либо 0, либо 1 — ответы опрошенных. Если i-е число равно 0, то i-й человек считает задачу простой, а если оно равно 1, то i-й человек считает задачу сложной.</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно слово: «EASY», если задача по мнению всех опрошенных является легкой, либо «HARD», если хотя бы один опрошенный считает задачу сложной.</p>

  <p>Вы можете выводить каждую из букв в любом регистре (как строчную или как заглавную): «EASY», «easy», «EaSY» и «eAsY» будут распознаны корректно.</p>

  <details>
    <summary>Примеры</summary>
  <h4>Пример 1</h4>
<pre>
3
0 0 1
</pre>
  <code>HARD</code>

  <h4>Пример 2</h4>
<pre>
1
0
</pre>
  <code>EASY</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Если есть хоть одна единица, то ответ HARD.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int n; // число человек
  cin >> n;

  int in;
  string res = "EASY";

  // проверим ответ каждого человека
  for (int i = 0; i &lt; n; i++) {
    cin >> in;
    if (in == 1) {
      res = "HARD";
    }
  }

  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача B. Вася и кукурузное поле -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Вася и кукурузное поле</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У Васи есть кукурузное поле, описываемое двумя числами — n
  и d. Кукурузное поле можно представить в декартовой системе координат как прямоугольник с углами в точках (0,d), (d,0), (n,n-d) и (n-d,n).</p>
  <p>Также Вася знает координаты m кузнечиков. Кузнечик номер i находится в точке (xᵢ,yᵢ). Так как Вася не любит, когда кузнечики поедают его кукурузу, то про каждого кузнечика Вася хочет знать, находится ли он на поле или нет. Считается, что кузнечик находится на кукурузном поле, если он находится внутри или на границах прямоугольника, описанного выше.</p>
  <p>Помогите Васе! Сообщите про каждого кузнечика, находится ли он на кукурузном поле.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит два целых числа n и d (1 ≤ d &lt; n ≤ 100).</p>

  <p>Вторая строка содержит одно целое число m (1 ≤ m ≤ 100) — количество кузнечиков.</p>

  <p>i-я из следующих m строк содержит два целых числа xᵢ и yᵢ (0 ≤ xᵢ, yᵢ ≤ n) — положение i-го кузнечика.</p>

  <h4>Выходные данные</h4>
  <p>Выведите m строк. В i-й строке выведите «YES», если i-й кузнечик находится на кукурузном поле. Иначе в i-й строке выведите «NO».</p>

  <p>Вы можете выводить каждую из букв в любом регистре (строчную или заглавную).</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
7 2
4
2 4
4 1
6 3
4 5
</pre>
<pre>
YES
NO
NO
YES
</pre>
    <h4>Пример 2</h4>
<pre>
8 7
4
4 4
2 8
8 1
6 1
</pre>
<pre>
YES
NO
YES
YES
</pre>
  <p>Кукурузное поле из первого примера изображено на рисунке выше. Внутри него находятся кузнечики 1 (с координатами (2,4)) и 4 (с координатами (4,5)).</p>
  <p>Кукурузное поле из второго примера изображено на рисунке ниже. Внутри него находятся кузнечики 1(с координатами (4,4)), 3 (с координатами (8,1)) и 4 (с координатами (6,1)).</p>
  </details>
</article>


<!-- Задача C. Вася и золотой билет -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Вася и золотой билет</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Недавно Вася нашел золотой билет — последовательность из n цифр a₁a₂…aₙ. Вася считает билет счастливым, если его можно разбить на два или более непересекающихся отрезка с одинаковой суммой цифр на каждом отрезке. Например, билет 350178 счастливый, т. к. его можно разбить на три отрезка 350, 17 и 8: 3+5+0=1+7=8. Заметим, что каждая цифра должна принадлежать ровно одному отрезку.</p>

  <p>Помогите Васе! Сообщите ему, является ли найденный им золотой билет счастливым.</p>

  <h4>Входные данные</h4>
  <p>В первой строке содержится целое число n (2 ≤ n ≤ 100) — количество цифр в билете.</p>

  <p>Вторая строка содержит n цифр a₁a₂…aₙ (0 ≤ aᵢ ≤ 9) — сам билет. Цифры записаны без пробелов.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите «YES», если найденный Васей билет является счастливым. В противном случае выведите «NO» (в любом случае без учета регистра).</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
5
73452
</pre>
    <code>YES</code>
    <h4>Пример 2</h4>
<pre>
4
1248
</pre>
    <code>NO</code>
    <p>В первом примере билет можно разбить на 7, 34 и 52: 7=3+4=5+2.</p>
    <p>Во втором примере невозможно разбить билет на равные по сумме цифр отрезки.</p>
  </details>
</article>


<!-- Задача D. Вася и треугольник -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Вася и треугольник</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У Васи есть три целых числа n, m и k. Он хочет найти три целочисленные точки (x₁, y₁), (x₂, y₂), (x₃, y₃) такие что 0 ≤ x₁, x₂, x₃ ≤ n, 0 ≤ y₁, y₂, y₃ ≤ m и площадь треугольника, образованная этими точками равна n * m / k.</p>

  <p>Помогите Васе! Найдите такие три точки (если возможно). Если существует несколько решений, выведите любое из них.</p>

  <h4>Входные данные</h4>
  <p>В единственной строке заданы три целых числа n, m, k (1 ≤ n, m ≤ 10⁹, 2 ≤ k ≤ 10⁹).</p>

  <h4>Выходные данные</h4>
  <p>Если не существует точек, удовлетворяющих описанным выше условиям, в первой строке выведите «NO».</p>

  <p>В противном случае в первой строке выведите «YES». В следующий трех строках выведите по два целых числа xᵢ, yᵢ. Если существует несколько решений, выведите любое из них.</p>

  <p>Вы можете выводить буквы в любом регистре (строчные или заглавные).</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>4 3 3</code>
<pre>
YES
1 0
2 3
4 1
</pre>
    <h4>Пример 2</h4>
    <code>4 4 7</code>
    <code>NO</code>
    <p>В первом примере площадь треугольника равна n * m / k = 4 . Сам треугольник представлен на рисунке ниже:</p>
    <p>Во втором примере не существует ни одного треугольника с площадью n * m / k = 16 / 7.</p>
  </details>
</article>


<!-- Задача E. Вася и хорошие последовательности -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Вася и хорошие последовательности</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У Васи есть последовательность a состоящая из n целых чисел a₁, a₂, …, aₙ. За одну операцию Вася может выбрать число из последовательности и поменять местами два любых бита в его двоичной записи. Например из числа 6 (…00000000110₂) Вася может получить числа 3 (…00000000011₂), 12 (…000000001100₂), 1026 (…10000000010₂) и так далее. Вася может применять эту операцию любое количество раз (возможно, ни разу) к любому из заданных чисел.</p>

  <p>Вася считает последовательность чисел хорошей, если, применяя к ней описанную выше операцию, он может получить последовательность, побитовое исключающее ИЛИ всех элементов которой равно 0.</p>

  <p>Для заданной последовательности a₁, a₂, …, aₙ Вася хочет знать количество пар целых чисел (l, r) таких, что 1 ≤ l ≤ r ≤ n и последовательность a<sub>l</sub>, a<sub>l+1</sub>, …, a<sub>r</sub> является хорошей.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно целое число n (1 ≤ n ≤ 3⋅10⁵) — длину последовательности.</p>

  <p>Вторая строка содержит n целых чисел a₁, a₂, …, aₙ (1 ≤ aᵢ ≤ 10¹⁸) — саму последовательность a.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите одно целое число — количество пар целых чисел (l, r) таких, что 1 ≤ l ≤ r ≤ n и последовательность a<sub>l</sub>, a<sub>l+1</sub>, …, a<sub>r</sub> является хорошей.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
3
6 7 14
</pre>
  <code>2</code>
    <h4>Пример 2</h4>
<pre>
4
1 2 1 16
</pre>
  <code>4</code>
  <p>В первом примере подходят пары (2,3) и (1,3). Для пары (2,3) числа можно изменить следующим образом: a2=7→11, a3=14→11 и 11⊕11=0, где ⊕ — операция побитового исключающего ИЛИ. Для пары (1,3) числа можно изменить следующим образом: a1=6→3, a2=7→13, a3=14→14 and 3⊕13⊕14=0.</p>
  <p>Во втором примере подходят четыре пары: (1,2), (2,3), (3,4) и (1,4).</p>
  </details>
</article>


<!-- Задача F. Сдвигаем ящики -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Сдвигаем ящики</h3>

  <div><i>Ограничение по времени 2.5с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Задана бесконечная клеточная полоса. На ней расположены n ящиков: i-й ящик находится в клетке aᵢ и имеет вес wᵢ. Все aᵢ различны; также, a<sub>i-1</sub> &lt; aᵢ для всех корректных i.</p>

  <p>Вы решили собрать вместе некоторые ящики. «Собрать вместе» ящики с номерами в отрезке [l,r] означает, что вам необходимо их расположить таким образом, что их позиции образуют некоторый отрезок [x,x+(r-l)].</p>

  <p>За один шаг вы можете сдвинуть любой ящик в соседнюю клетку, если она не занята другим ящиком (т. е. выбрать i и изменить aᵢ на 1, при этом все позиции должны остаться различными). На передвижение ящика i на одну клетку вы тратите энергию, равную его весу wᵢ. Вы можете двигать ящики в любом порядке любое количество раз.</p>

  <p>Веса некоторых ящиков иногда изменяются, поэтому Вам необходимо обработать запросы двух видов:</p>
  <ol>
    <li>id nw — вес wid ящика id становится равным nw.</li>
    <li>l r — вы должны вычислить минимальную суммарную энергию, необходимую для того, чтобы собрать вместе ящики с номерами в отрезке [l,r]. Так как ответ может быть слишком большим, выведите остаток от деления ответа на 1000000007 = 10⁹ + 7. Обратите внимание, при таком запросе ящики остаются на местах, вам нужно лишь вычислить ответ.</li>
  </ol>

  <p>Обратите внимание, что минимизировать надо сам ответ, а не его остаток от деления на 10⁹ + 7. Например, если у вас два возможных ответа — 2⋅10⁹ + 13 и 2⋅10⁹ + 14 — то необходимо выбрать первый ответ и вывести 10⁹ + 6, даже с учетом того, что второй ответ дает остаток 0.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит два целых числа n и q (1 ≤ n, q ≤ 2⋅10⁵) — количество ящиков и запросов.</p>

  <p>Вторая строка содержит n целых чисел a1, a2, … an (1 ≤ aᵢ ≤ 10⁹) — позиции ящиков. Все ai различны, ai-1 &lt; ai для всех корректных i.</p>

  <p>Третья строка содержит n целых чисел w1, w2, … wn (1 ≤ wᵢ ≤ 10⁹) — начальные веса ящиков.</p>

  <p>Следующие q строк содержат запросы, по одному запросу в строке.</p>

  <p>Каждый запрос описывается одной строкой, содержащей два целых числа x и y. Если x &lt; 0, то это запрос первого типа, причем id = -x, nw = y (1 ≤ id ≤ n, 1 ≤ nw ≤ 10⁹). Если же x > 0, то это запрос второго типа, причем l = x, а r = y (1 ≤ l<sub>j</sub> ≤ r<sub>j</sub> ≤ n). Число x не может быть равно 0.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого запроса второго типа выведите ответ на него в отдельной строке. Так как ответ может быть слишком большим, выведите остаток от деления его на 1000000007 = 10⁹ + 7.</p>

  <details>
    <summary>Пример</summary>
<pre>
5 8
1 2 6 7 10
1 1 1 1 2
1 1
1 5
1 3
3 5
-3 5
-1 10
1 4
2 5
</pre>
<pre>
0
10
3
4
18
7
</pre>
  <p>Рассмотрим запросы из примера:</p>
  <ol>
    <li>1 1 : ящик только один, поэтому двигать его не надо.</li>
    <li>1 5 : мы можем сдвинуть ящики в отрезок [4,8] : 1⋅|1-4|+1⋅|2-5|+1⋅|6-6|+1⋅|7-7|+2⋅|10-8|=10.</li>
    <li>1 3 : мы можем сдвинуть ящики в отрезок [1,3].</li>
    <li>3 5 : мы можем сдвинуть ящики в отрезок [7,9].</li>
    <li>-3 5 : изменение w3 из 1 в 5.</li>
    <li>-1 10 : изменение w1 из 1 в 10. Теперь веса ящиков равны w=[10,1,5,1,2].</li>
    <li>1 4 : мы можем сдвинуть ящики в отрезок [1,4].</li>
    <li>2 5 : мы можем сдвинуть ящики в отрезок [5,8].</li>
  </ol>
  </details>
</article>


<!-- Задача G. Линейный конгруэнтный генератор -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Линейный конгруэнтный генератор</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 512мб</i></div>

  <p>Вам задан генератор кортежей чисел f<sup>(k)</sup> = (f<sup>(k)</sup>₁, f<sup>(k)</sup>₂, …,f<sup>(k)</sup>ₙ), где f<sup>(k)</sup>ᵢ = (aᵢ⋅f<sup>(k-1)</sup>ᵢ + bᵢ)mod pᵢ и f<sup>(0)</sup> = (x₁, x₂, …, xₙ). Здесь xmody означает остаток от деления x на y. Все pᵢ — простые числа.</p>

  <p>Можно заметить, что при фиксированных наборах xᵢ, yᵢ, aᵢ начиная с некоторого номера кортежи f<sup>(k)</sup> будут повторять кортежи с меньшими номерами. Найдите максимальное количество различных кортежей (из всех f<sup>(k)</sup> при k ≥ 0), которые может выдать данный генератор, если xᵢ, aᵢ, bᵢ — целые числа в диапазоне [0, pᵢ-1] и могут быть выбраны произвольно. Так как ответ может быть слишком большим, выведите остаток от его деления на 10⁹+7.</p>

  <h4>Входные данные</h4>
  <p>В первой строке находится целое число n (1 ≤ n ≤ 2⋅10⁵) — количество элементов в кортеже.</p>

  <p>Во второй строке находятся n простых целых чисел — соответствующие модули p₁, p₂, …, pₙ (2 ≤ pᵢ ≤ 2⋅10⁶).</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное число — максимальное количество различных кортежей по модулю 10⁹+7.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
4
2 3 5 7
</pre>
    <code>210</code>
    <h4>Пример 2</h4>
<pre>
3
5 3 3
</pre>
    <code>30</code>
    <p>В первом примере можно выбрать следующие параметры: a=[1,1,1,1], b=[1,1,1,1], x=[0,0,0,0], тогда f<sup>(k)</sup>ᵢ = k mod pᵢ.</p>
    <p>Во втором примере можно выбрать следующие параметры: a=[1,1,2], b=[1,1,0], x=[0,0,1].</p>
  </details>
</article>

