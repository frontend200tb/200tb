<article class="article">
  <a href="https://codeforces.com/contest/2114" target="_blank">Codeforces 2114 Round 1027 (Div.3) 2025-05-26</a>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

      <a href="#task1">Задача A. Квадратный год</a>
  <br><a href="#task2">Задача B. Не очень палиндромная строка</a>
  <br><a href="#task3">Задача C. Нужно больше массивов</a>
  <br><a href="#task4">Задача D. Встаньте поближе</a>
  <br><a href="#task5">Задача E. Кирей атакует поместье</a>
  <br><a href="#task6">Задача F. Небольшие операции</a>
  <br><a href="#task7">Задача G. Построй массив</a>
</article>


<!-- Задача A. Квадратный год -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Квадратный год</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Можно заметить следующий замечательный математический факт: число 2025 представимо в виде (20+25)².</p>
  <p>Вам дан год, представленный строкой s, состоящей ровно из 4 символов. Таким образом, в записи года допустимы ведущие нули. Например, «0001», «0185», «1375» — валидные записи года. Вам необходимо представить его в виде (a+b)², где a и b — целые неотрицательные числа, или определить, что это невозможно.</p>
  <p>Например, если s = «0001», то можно выбрать a=0, b=1, и записать год как (0+1)²=1.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит одно целое число t ( ≤ t ≤ 10⁴) — количество наборов входных данных.</p>
  <p>Далее следуют описания наборов.</p>
  <p>Единственная строка каждого набора содержит строку s, состоящую ровно из 4 символов. Каждый символ является цифрой от 0 до 9.</p>

  <h4>Выходные данные</h4>
  <p>На отдельной строке для каждого набора входных данных выведите:</p>
  <ul>
    <li>Два числа a и b (a, b ≥ 0), такие что (a+b)²=s, если они существуют. Если подходящих пар несколько, вы можете вывести любую.</li>
    <li>число -1 иначе.</li>
  </ul>

  <details>
    <summary>Пример</summary>
<pre>
5
0001
1001
1000
4900
2025
</pre>
0 1
-1
-1
34 36
20 25
  </details>
</article>


<!-- Задача B. Не очень палиндромная строка -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Не очень палиндромная строка</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Влад нашёл двоичную строку∗ s чётной длины n. Он считает пару индексов (i, n-i+1), где 1 ≤ i &lt; n-i+1 хорошей, если верно, что s<sub>i</sub> = s<sub>n-i+1</sub>.</p>
  <p>Например, в строке '010001' только 1 хорошая пара, так как s₁ ≠ s₆, s₂ ≠ s₅ и s₃ = s₄. А в строке '0101' нет ни одной хорошей пары.</p>
  <p>Влад любит палиндромы, но не слишком сильно, поэтому он хочет переставить некоторые символы строки так, чтобы в строке оказалось ровно k хороших пар индексов.</p>
  <p>Определите, возможно ли переставить символы в данной строке так, чтобы ровно k пар индексов (i, n-i+1) были хорошими.</p>
  <p>* Строка s называется двоичной, если она состоит только из символов '0' и '1'</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>
  <p>Первая строка каждого набора содержит два целых числа n
  и k (2 ≤ n ≤ 2⋅10⁵, 0 ≤ k ≤ n / 2, n — чётное) — длину строки и нужное количество хороших пар.</p>
  <p>Вторая строка каждого набора содержит двоичную строку s длины n.</p>
  <p>Гарантируется, что сумма n по всем наборам входных данных не превосходит 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите «YES», если существует способ переставить символы строки так, чтобы хороших пар стало ровно k, иначе выведите «{NO}».</p>
  <p>Вы можете выводить каждую букву в любом регистре (строчную или заглавную). Например, строки «yEs», «yes», «Yes» и «YES» будут приняты как положительный ответ.</p>

  <details>
    <summary>Пример</summary>
<pre>
6
6 2
000000
2 1
01
4 1
1011
10 2
1101011001
10 1
1101011001
2 1
11
</pre>
<pre>
NO
NO
YES
NO
YES
YES
</pre>
  </details>
</article>


<!-- Задача C. Нужно больше массивов -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Нужно больше массивов</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Дан массив a и n целых чисел. Он отсортирован в порядке неубывания, то есть a<sub>i</sub> ≤ a<sub>i+1</sub> для всех 1 ≤ i &lt; n.</p>
  <p>Вы можете удалить сколько угодно элементов массива (в том числе вы можете не удалять их вовсе), не изменив при этом порядок оставшихся. После удалений произойдёт следующее:</p>
  <ul>
    <li>a₁ выписывается в новый массив;</li>
    <li>если a₁+1 &lt; a₂, то a₂ выписывается в новый массив, иначе a2 выписывается в тот же массив, что и a₁;</li>
    <li>если a₂+1 &lt; a₃, то a₃ выписывается в новый массив, иначе a₃ выписывается в тот же массив, что и a₂;</li>
    <li>⋯</li>
  </ul>
  <p>Например, если a=[1,2,4,6], то:</p>
  <ul>
    <li>a₁=1 выписывается в новый массив, полученные массивы: [1]</li>
    <li>a₁+1=2, поэтому a₂=2 дописывается в уже существующий массив, полученные массивы: [1,2];</li>
    <li>a₂+1=3, поэтому a₃=4 выписывается в новый массив, полученные массивы: [1,2] и [4];</li>
    <li>a₃+1=5, поэтому a₄=6 выписывается в новый массив, полученные массивы: [1,2], [4] и [6].</li>
  </ul>
  <p>Ваша задача — удалить элементы так, чтобы в результате описанного выше алгоритма создалось как можно больше массивов. Если вы удалите все элементы из массива, то не будет создано ни одного нового массива.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит одно целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>
  <p>Первая строка каждого набора содержит одно целое число n (1≤n≤2⋅10⁵) — длину массива.</p>
  <p>Вторая строка каждого набора содержит n целых чисел a₁,a₂,…,aₙ (1 ≤ a<sub>i</sub> ≤ 10⁶, a<sub>i</sub> ≤ a<sub>i+1</sub>) — элементы массива.</p>
  <p>Гарантируется, что сумма n по всем наборам входных данных не превосходит 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно целое число — максимальное количество массивов, которое можно получить, удалив любое (возможно, нулевое) количество элементов.</p>

  <details>
    <summary>Пример</summary>
<pre>
6
6
1 2 3 4 5 6
3
1 2 3
4
1 2 2 4
1
2
3
1 4 8
2
1 1
</pre>
<pre>
3
2
2
1
3
1
</pre>
  <p>В первом примере можно удалить a₃ и a₅, тогда a=[1,2,4,6], процесс составления массивов для него показан в условии.</p>
  <p>Во втором примере нужно удалить a₂, после этого a=[1,3], а выписаны будут массивы [1] и [3].</p>
  <p>В третьем примере удаления делать не нужно, для a=[1,2,2,4] выписаны будут массивы [1,2,2] и [4].</p>
  </details>
</article>


<!-- Задача D. Встаньте поближе -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Встаньте поближе</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Игровое поле является матрицей 10⁹x10⁹, клетка на пересечении a-й строки и b-го столбца обозначается как (a,b).</p>
  <p>На игровом поле расположены n монстров, i-й в клетке (xᵢ, yᵢ), остальные клетки пустые. В одной клетке не может находиться более одного монстра.</p>
  <p>Вы можете не более одного раза выбрать любого монстра и переместить его в любую клетку поля, не занятую другим монстром.</p>
  <p>После этого вы должны выбрать один прямоугольник на поле, все монстры внутри выбранного прямоугольника будут уничтожены. За каждую клетку выбранного прямоугольника вы должны заплатить 1 монету.</p>
  <p>Ваша задача — найти минимальное количество монет, необходимое, чтобы уничтожить всех монстров.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит одно целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>
  <p>Первая строка каждого набора содержит одно целое число n  (1 ≤ n ≤ 2⋅10⁵) — количество монстров на поле.</p>
  <p>Следующие n строк содержат по два целых числа xᵢ и yᵢ (1 ≤ xᵢ,yᵢ ≤ 10⁹) — координаты клетки с i-м монстром. Все пары (xᵢ, yᵢ) различны.</p>
  <p>Гарантируется, что сумма n по всем наборам входных данных не превосходит 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно целое число — минимальную стоимость уничтожения всех n монстров.</p>

  <details>
    <summary>Пример</summary>
<pre>
7
3
1 1
1 2
2 1
5
1 1
2 6
6 4
3 3
8 2
4
1 1
1 1000000000
1000000000 1
1000000000 1000000000
1
1 1
5
1 2
4 2
4 3
3 1
3 2
3
1 1
2 5
2 2
4
4 3
3 1
4 4
1 2
</pre>
<pre>
3
32
1000000000000000000
1
6
4
8
</pre>
  <p>Ниже приведены примеры оптимальных перемещений, зелёным выделены клетки прямоугольника, который необходимо выбрать.</p>
  </details>
</article>


<!-- Задача E. Кирей атакует поместье -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Кирей атакует поместье</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Однажды Кирей подло пробрался в полное ловушек поместье Айнцбернов, но был обнаружен фамильяром Кирицугу. Оценив свои силы, Кирей решил отступить. Поместье представляет собой дерево из n вершин с корнем в вершине 1. В каждой вершине дерева записано число a<sub>i</sub> — опасность вершины i. Напомним, что деревом называется связный неориентированный граф без циклов.</p>
  <p>Чтобы отступление оказалось успешным, Кирей должен вычислить для каждой вершины значение угрозы. Угроза вершины равна максимальной знакопеременной сумме на вертикальном пути с началом в этой вершине. Знакопеременная сумма на вертикальном пути с началом в вершине i равна a<sub>i</sub> - a<sub>pi</sub> + a<sub>ppi</sub> - …, где p<sub>i</sub> — родитель вершины i на пути к корню (к вершине 1).</p>
  <p>Например, в дереве ниже у вершины 4 есть следующие вертикальные пути:</p>
  <ul>
    <li>[4] с знакопеременной суммой a₄ = 6;</li>
    <li>[4,3] с знакопеременной суммой a₄ - a₃ = 6-2=4;</li>
    <li>[4,3,2] с знакопеременной суммой a₄ - a₃ + a₂ =6-2+5=9;</li>
    <li>[4,3,2,1] с знакопеременной суммой a₄ - a₃ + a₂ - a₁ =6-2+5-4=5.</li>
  </ul>
  <p>Красным цветом указаны опасности вершин.</p>
  <p>Помогите Кирею вычислить значения угроз для всех вершин и покинуть поместье.</p>

  <h4>Входные данные</h4>
  <p>В первой строке дано целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>
  <p>Далее следует описание наборов.</p>
  <p>В первой строке дано целое число n (2 ≤ n ≤ 2⋅10⁵) — количество вершин в дереве.</p>
  <p>Во второй строке даны n целых чисел a₁, a₂, …, aₙ (1 ≤ aᵢ ≤ 10⁹) — опасности вершин.</p>
  <p>В следующих n-1 строках даны числа v,u (1 ≤ v, u ≤ n, v ≠ u) — описание рёбер дерева.</p>
  <p>Гарантируется, что сумма n по всем наборам входных данных не превосходит 2⋅10⁵. Также гарантируется, что заданный набор рёбер образует дерево.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите n целых чисел — угрозу каждой вершины.</p>

  <details>
    <summary>Пример</summary>
<pre>
2
5
4 5 2 6 7
1 2
3 2
4 3
5 1
6
1000000000 500500500 900900900 9 404 800800800
3 4
5 1
2 5
1 6
6 4
</pre>
<pre>
4 5 2 9 7
1000000000 1500500096 1701701691 199199209 404 800800800
</pre>
  <p>Дерево из первого набора входных данных изображено в условии, максимальные знакопеременные суммы достигаются следующим образом:</p>
  <ol>
    <li>a₁ = 4;</li>
    <li>a₂ = 5;</li>
    <li>a₃ = 2;</li>
    <li>a₄ - a₃ + a₂ =6-2+5=9;</li>
    <li>a₅ = 7.</li>
  </ol>
  </details>
</article>


<!-- Задача F. Небольшие операции -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Небольшие операции</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Дано целое число x и целое число k. За одну операцию вы можете сделать одно из двух действий:</p>
  <ul>
    <li>выбрать целое число 1≤a≤k и присвоить x=x⋅a;</li>
    <li>выбрать целое число 1≤a≤k и присвоить x=x/a, значение x/a должно быть целым.</li>
  </ul>
  <p>Найдите минимальное количество операций, необходимое, чтобы сделать число x равным y, или определите, что это невозможно.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит одно целое число t (1≤t≤10⁴) — количество наборов входных данных.</p>
  <p>Единственная строка каждого набора содержит три целых числа x, y и k (1≤x,y,k≤10⁶).</p>
  <p>Гарантируется, что сумма x и сумма y по всем наборам входных данных не превосходит 10⁸</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите -1, если получить x=y с помощью данных операций невозможно, и минимальное число необходимых операций, иначе.</p>

  <details>
    <summary>Пример</summary>
<pre>
8
4 6 3
4 5 3
4 6 2
10 45 3
780 23 42
11 270 23
1 982800 13
1 6 2
</pre>
<pre>
2
-1
-1
3
3
3
6
-1
</pre>
  </details>
</article>


<!-- Задача G. Построй массив -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Построй массив</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 512мб</i></div>

  <p>Вчера Дима нашёл пустой массив и решил добавить в него несколько целых чисел. Он может неограниченное число раз выполнять следующую операцию:</p>
  <ul>
    <li>добавить любое целое число в левый или правый конец массива.</li>
    <li>затем, пока в массиве есть пара одинаковых соседних элементов, они будут заменяться на их сумму.</li>
  </ul>
  <p>Можно показать, что одновременно в массиве может быть не более одной такой пары.</p>
  <p>Например, массив равен [3,6,4]. Если мы добавим слева число 3, то сначала массив будет равен [3,3,6,4], затем два первых элемента заменятся на 6, и массив станет равен [6,6,4], а затем — [12,4].</p>
  <p>После выполнения операции ровно k раз он считает, что получил массив a длины n, но не помнит, какие именно операции применил. Определите, существует ли последовательность из k операций, в результате которой из пустого массива мог получиться данный массив a, или определите, что это невозможно.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно целое число t (1 ≤ t ≤ 10⁴) — число наборов входных данных. Далее следуют описания наборов входных данных.</p>
  <p>Первая строка описания каждого набора содержит два целых числа n и k (1 ≤ n ≤ 10⁵, n ≤ k ≤ 10⁶) — длину полученного массива и число операций.</p>
  <p>Вторая строка содержит n целых чисел aᵢ (1 ≤ aᵢ ≤ 10⁹, aᵢ₋₁ ≠ aᵢ) — элементы полученного массива.</p>
  <p>Гарантируется, что сумма значений n по всем наборам входных данных не превосходит 10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных, если подходящей последовательности операций длины k не существует, то выведите «NO». Иначе выведите «YES».</p>
  <p>Вы можете выводить «YES» и «NO» в любом регистре (например, строки «yEs», «yes», «Yes» и «YES» будут распознаны как положительный ответ).</p>

  <details>
    <summary>Пример</summary>
<pre>
8
3 3
2 1 4
3 7
2 1 4
2 15
2 16
3 10
256 32 1
3 289
768 96 1
3 290
768 96 1
5 7
5 1 6 3 10
4 6
6 8 5 10
</pre>
<pre>
YES
NO
YES
YES
YES
NO
YES
YES
</pre>
  </details>
</article>


