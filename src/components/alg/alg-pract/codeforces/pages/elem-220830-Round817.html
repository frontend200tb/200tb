<article class="article">
  <a href="https://codeforces.com/contest/1722" target="_blank">Codeforces Round 817 (Div. 4) 2022-08-30</a>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

      <a href="#task1">Задача A. Проверка правописания</a>
  <br><a href="#task2">Задача B. Дальтонизм</a>
  <br><a href="#task3">Задача C. Игра в слова</a>
  <br><a href="#task4">Задача D. Ряд</a>
  <br><a href="#task5">Задача E. Считаем прямоугольники</a>
  <br><a href="#task6">Задача F. L-фигуры</a>
  <br><a href="#task7">Задача G. Чётный-нечётный XOR</a>
</article>


<!-- Задача A. Проверка правописания -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Проверка правописания</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Тимуру очень нравится его имя. В качестве написания его имени он допускает любую перестановку букв строки Timur. Например, следующие строки — это корректные способы написания его имени: Timur, miurT, Trumi, mriTu. Обратите внимание, что написание содержит прописную букву T, а остальные буквы должны быть строчными.</p>

  <p>Сегодня в качестве имени он написал строку s длины n, которая состоит из прописных и строчных букв латинского алфавита. Он попросил вас проверить, является ли строка s  правильным написанием его имени.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит целое число t (1 ≤ t ≤ 10³) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит целое число n (1 ≤ n ≤ 10) — длину заданной строки s.</p>

  <p>Вторая строка содержит s, которая состоит только из прописных и строчных букв латинского алфавита.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите «YES» (без кавычек), если строка s удовлетворяет условию, или «NO» (без кавычек), если нет.</p>

  <p>Вы можете выводить ответ в любом регистре (например, вывод «yEs», «yes», «Yes» и «YES» всё ещё будет считаться корректным).</p>

  <details>
    <summary>Пример</summary>
<pre>
10
5
Timur
5
miurT
5
Trumi
5
mriTu
5
timur
4
Timr
6
Timuur
10
codeforces
10
TimurTimur
5
TIMUR
</pre>
<pre>
YES
YES
YES
YES
NO
NO
NO
NO
NO
NO
</pre>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // длина строки
    cin >> n;
    string s; // строка
    cin >> s;

    // решение
    string res = "YES";

    // проверим длину строки
    if (s.size() != 5) {
      res = "NO";

    // проверим вхождение всех букв в строку
    } else if (s.find('T') == -1 || s.find('i') == -1 ||
      s.find('m') == -1 || s.find('u') == -1 || s.find('r') == -1) {
      res = "NO";
    }

    // вывод результата
    cout &lt;&lt; res &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача B. Дальтонизм -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Дальтонизм</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У Васи есть прямоугольное поле, которое состоит из 2 строк и n столбцов. Каждая ячейка имеет цвет: красный, зелёный или синий.</p>

  <p>У Васи дальтонизм и он не отличает зелёный цвет от синего. Определите, одинаково ли Вася видит первую и вторую строку поля?</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит целое число t (1 ≤ t ≤ 100) — количество наборов входных данных. Далее заданы описания наборов.</p>

  <p>Первая строка каждого набора входных данных содержит целое число n (1 ≤ n ≤ 100) — количество столбцов в заданном прямоугольном поле.</p>

  <p>Следующие две строки содержат по n символов каждая: R, G или B, которые обозначают красный цвет, зелёный цвет или синий цвет соответственно — описание поля.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите «YES», если Вася видит две строки одинаково, или выведите «NO», если это не так.</p>

  <p>Вы можете выводить ответ в любом регистре (например, вывод «yEs», «yes», «Yes» и «YES» всё ещё будет считаться корректным).</p>

  <details>
    <summary>Пример</summary>
<pre>
6
2
RG
RB
4
GRBG
GBGB
5
GGGGG
BBBBB
7
BBBBBBB
RRRRRRR
8
RGBRRGBR
RGGRRBGR
1
G
G
</pre>
<pre>
YES
NO
YES
NO
YES
YES
</pre>
  <p>В первом наборе входных данных примера Вася видит вторую клетку каждой строки одинаково, потому что вторая клетка первой строки зеленая, а вторая клетка второй строки синяя, эти два цвета он не различает. Остальные же клетки имеют одинаковый цвет. Таким образом, Вася видит эти строки одинаковыми.</p>
  <p>Во втором наборе входных данных примера Вася видит две строки различными.</p>
  <p>В третьем наборе входных данных каждый символ поля либо зелёный, либо синий. Таким образом, Вася видит строки одинаково.</p>
  </details>

   <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // число столбцов
    cin >> n;
    string s1, s2; // строки
    cin >> s1 >> s2;

    // решение
    string res = "YES";

    // сравним символы строки
    for (int i = 0; i &lt; n; i++) {
      if (s1[i] == 'R') {
        if (s2[i] != 'R') {
          res = "NO";
        }
      } else {
        if (s2[i] == 'R') {
          res = "NO";
        }
      }
    }

    // вывод результата
    cout &lt;&lt; res &lt;&lt; '\n';
  }
}
</pre>
   </details>
</article>


<!-- Задача C. Игра в слова -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Игра в слова</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Три друга играют в игру. Каждый из них пишет n различных слов, каждое длины 3.</p>

  <p>После этого они считают очки по следующим правилам:</p>
  <ul>
    <li>если слово написано только одним игроком, то тот, кто его написал, получает 3 очка;</li>
    <li>если слово написано двумя игроками, то каждый из них получает по 1 очку;</li>
    <li>если слово написано всеми тремя игроками, то за него очки не начисляются.</li>
  </ul>
  <p>Выведите финальное количество очков у каждого игрока.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое число t (1 ≤ t ≤ 100) — количество наборов входных данных. Далее следуют описания наборов.</p>

  <p>Первая строка каждого набора содержит целое число n (1 ≤ n ≤ 1000) — количество слов, написанных каждым игроком.</p>

  <p>Следующие три строки содержат по n различных слов каждая — слова написанные каждым из игроков. Все эти слова состоят из 3 строчных букв латинского алфавита.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите через пробел три целых числа — количество очков у первого, второго и третьего из друзей. Выводите очки именно в таком порядке — i-м выводите количество очков у i-го из друзей.</p>

  <details>
    <summary>Пример</summary>
<pre>
3
1
abc
def
abc
3
orz for qaq
qaq orz for
cod for ces
5
iat roc hem ica lly
bac ter iol ogi sts
bac roc lly iol iat
</pre>
<pre>
1 3 1
2 2 6
9 11 5
</pre>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;set&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // число слов
    cin >> n;
    set&lt;string&gt; s1; // слова первого игрока
    for (int i = 0; i &lt; n; i++) {
      string x;
      cin >> x;
      s1.insert(x);
    }
    set&lt;string&gt; s2; // слова второго игрока
    for (int i = 0; i &lt; n; i++) {
      string x;
      cin >> x;
      s2.insert(x);
    }
    set&lt;string&gt; s3; // слова третьего игрока
    for (int i = 0; i &lt; n; i++) {
      string x;
      cin >> x;
      s3.insert(x);
    }

    // решение
    int score1 = 0;
    int score2 = 0;
    int score3 = 0;

    // пройдем по словам первого игрока
    for (string s : s1) {
      if (s2.find(s) == s2.end() && s3.find(s) == s3.end()) {
        score1 += 3;
      } else if (s2.find(s) != s2.end() && s3.find(s) != s3.end()) {
        // никто не получает очки
      } else {
        score1++;
      }
    }

    // пройдем по словам второго игрока
    for (string s : s2) {
      if (s1.find(s) == s1.end() && s3.find(s) == s3.end()) {
        score2 += 3;
      } else if (s1.find(s) != s1.end() && s3.find(s) != s3.end()) {
        // никто не получает очки
      } else {
        score2++;
      }
    }

    // пройдем по словам третьего игрока
    for (string s : s3) {
      if (s1.find(s) == s1.end() && s2.find(s) == s2.end()) {
        score3 += 3;
      } else if (s1.find(s) != s1.end() && s2.find(s) != s2.end()) {
        // никто не получает очки
      } else {
        score3++;
      }
    }

    // вывод результата
    cout &lt;&lt; score1 &lt;&lt; ' '
    &lt;&lt; score2 &lt;&lt; ' '
    &lt;&lt; score3 &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача D. Ряд -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Ряд</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В ряд вдоль одной линии стоят n человек, каждый смотрит либо влево, либо вправо.</p>

  <p>Каждый человек посчитал количество людей, которое он видит (то есть количество человек в направлении его взгляда). Назовём величиной ряда сумму посчитанных значений.</p>

  <p>Например, если люди стоят следующим образом: LRRLL, где L обозначает человека в направлении «влево», а R обозначает человека в направлении «вправо», то посчитанные значения равны [0,3,2,3,4], а величина ряда равна 0+3+2+3+4=12.</p>

  <p>Вам задано начальное расположение людей вдоль линии. Для каждого k от 1 до n, определите максимальную возможную величину ряда, если вы можете изменить направление не более чем у k человек.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое число t (1 ≤ t ≤ 100) — количество наборов входных данных. Далее следуют описания наборов.</p>

  <p>Первая строка каждого набора содержит целое число n (1 ≤ n ≤ 2⋅10⁵) — количество человек в ряду.</p>

  <p>Следующая строка состоит из n символов, каждый из которых либо L, либо R — строка описывает направления для всех людей.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превосходит 2⋅10⁵.</p>

  <p>Обратите внимание, что ответ для некоторых наборов входных данных может не поместиться в 32-битный тип данных, поэтому вы должны использовать 64-битный тип данных из вашего языка программирования (например, long long в C++).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите n целых чисел — для всех k от 1 до n выведите максимальное значение ряда, если можно изменить направление не более чем k человек в ряду.</p>

  <details>
    <summary>Пример</summary>
<pre>
6
3
LLR
5
LRRLL
1
L
12
LRRRLLLRLLRL
10
LLLLLRRRRR
9
LRLRLRLRL
</pre>
<pre>
3 5 5
16 16 16 16 16
0
86 95 98 101 102 102 102 102 102 102 102 102
29 38 45 52 57 62 65 68 69 70
44 50 54 56 56 56 56 56 56
</pre>
  </details>

 <details>
  <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // число человек
    cin >> n;
    string s; // строка
    cin >> s;

    // решение
    // посчитаем начальную величину ряда
    long long cnt0 = 0;
    for (int i = 0; i &lt; n; i++) {
      if (s[i] == 'L') {
        cnt0 += i; // сколько слева
      } else if (s[i] == 'R') {
        cnt0 += n - 1 - i; // сколько справа
      }
    }

    // для получения максимальной величины
    // люди слева от середины должны смотреть направо,
    // люди справа от середины должны смотреть налево
    // идти нужно с концов массива к середине
    int l = 0; // левый указатель
    int r = n - 1; // правый указатель
    int k = 0; // число замен
    vector&lt;long long&gt; Cnt(n + 1);
    Cnt[0] = cnt0;

    while (r > l) {
      if (s[l] == 'L') {
        s[l] = 'R';
        k++;
        long long add = n - 1 - l; // сколько справа
        long long del = l; // сколько слева
        Cnt[k] = Cnt[k - 1] - del + add;
      }
      if (r > l && s[r] == 'R') {
        s[r] = 'L';
        k++;
        long long add = r; // сколько слева
        long long del = n - 1 - r; // сколько справа
        Cnt[k] = Cnt[k - 1] - del + add;
      }
      l++;
      r--;
    }

    // заполняем оставшиеся n - k элементов
    for (int i = k + 1; i &lt;= n; i++) {
      Cnt[i] = Cnt[i - 1];
    }

    // вывод результата
    for (int i = 1; i &lt;= n; i++) {
      cout &lt;&lt; Cnt[i] &lt;&lt; ' ';
    }
    cout &lt;&lt; '\n';
  }
}
</pre>
 </details>
</article>


<!-- Задача E. Считаем прямоугольники -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Считаем прямоугольники</h3>

  <div><i>Ограничение по времени 6с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У вас есть n прямоугольников, i-й из них имеет высоту hi и ширину wi.</p>

  <p>Вам надо ответить на q запросов, которые задаются четырьмя числами: hs ws hb wb.</p>

  <p>Для каждого запроса выведите суммарную площадь всех таких прямоугольников, которые могут вместить в себя прямоугольник с высотой hs и шириной ws и при этом сами вмещаются в прямоугольник с высотой hb и шириной wb. Иными словами, выведите ∑hi⋅wi по всем i, что hs &lt; hi &lt; hb и ws &lt; wi &lt; wb.</p>

  <p>Обратите внимание, что если у прямоугольников одинаковая ширина или высота, то ни один из них не может вместить в себя другой. Также обратите внимание, что вы не можете вращать прямоугольники.</p>

  <p>Обратите внимание, что для некоторых наборов входных данных ответ не будет помещаться в 32-х битных целочисленный тип, вы должны использовать 64-битный целочисленный тип вашего языка (например, long long в C++).</p>

  <h4>Входные данные</h4>
  <p>В первой строке входных данных записано целое число t (1 ≤ t ≤ 100) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит два целых числа n, q (1 ≤ n ≤ 10⁵; 1 ≤ q ≤ 10⁵) — количество прямоугольников и количество запросов.</p>

  <p>Затем следуют n строк, каждая содержит два целых числа hi, wi (1 ≤ hi, wi ≤ 1000) — высоту и ширину i-го прямоугольника.</p>

  <p>Затем в q строках заданы запросы, каждая строка содержит четыре целых числа hs,ws,hb,wb (1 ≤ hs &lt; hb, ws &lt; wb ≤ 1000) — описание запроса.</p>

  <p>Сумма значений q по всем набора входных данных не превосходит 10⁵. Сумма значений n по всем наборам входных данных не превосходит 10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите q строк, i-я должна содержать ответ на i-й запрос.</p>

  <details>
    <summary>Пример</summary>
<pre>
3
2 1
2 3
3 2
1 1 3 4
5 5
1 1
2 2
3 3
4 4
5 5
3 3 6 6
2 1 4 5
1 1 2 10
1 1 100 100
1 1 3 3
3 1
999 999
999 999
999 998
1 1 1000 1000
</pre>
<pre>
6
41
9
0
54
4
2993004
</pre>
  <p>В первом наборе входных данных только один запрос. Нам надо найти сумму площадей всех прямоугольников, которые вмещают прямоугольник 1x1 и сами вмещаются в прямоугольник 3x4.</p>

  <p>Нам подходит только прямоугольник 2x3, так как 1 &lt; 2 (сравниваем высоты) и 1 &lt; 3 (сравниваем ширины), то 1x1 помещается в него. Аналогично, 2 &lt; 3 (сравниваем высоты) и 3 &lt; 4 (сравниваем ширины), то есть он помещается в 3x4.</p>

  <p>Прямоугольник 3x2 слишком высок, чтобы поместиться в 3x4 rectangle.</p>

  <p>Суммарная площадь в ответа равна 2⋅3=6.</p>
  </details>
</article>


<!-- Задача F. L-фигуры -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. L-фигуры</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>L-фигура это фигура на клетчатой бумаге, выглядящая как одна из четырех первых фигур на картинке ниже. L-фигура содержит ровно три закрашенных клетки (обозначаемых как *), которые могут быть повернуты в любую сторону.</p>
<pre>
*    *  **  **
**  **   *  *
</pre>

  <p>Вам дана прямоугольная сетка из клеток. Определите, содержит ли она только L-фигуры, которые не соприкасаются друг с другом ни одним углом и ни одной стороной. Более формально:</p>
  <ul>
    <li>Каждая закрашенная клетка в сетке является частью ровно одной L-фигуры и</li>
    <li>нет двух L-фигур, которые бы соприкасались углом или стороной.</li>
  </ul>
  <p>Например, последние две сетки на картинке выше не удовлетворяют требованиям, потому что есть две L-фигуры, соприкасающихся углами и стороной соответственно.</p>

  <h4>Входные данные</h4>
  <p>Входные данные состоят из множества тестовых случаев. Первая строка содержит одно целое число t (1 ≤ t ≤ 100) — количество тестовых случаев. Затем следуют описания тестовых случаев.</p>

  <p>Первая строка каждого тестового случая содержит два целых числа n и m (1 ≤ n, m ≤ 50) — количество строк и столбцов в сетке соответственно.</p>

  <p>Затем следуют n строк, содержащих m символов. Каждый символ это либо «.», либо «*» — пустая или закрашенная клетка соответственно.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого тестового случая выведите «YES» если сетка состоит только из L-фигур, не касающихся друг друга углами или сторонами, иначе «NO».</p>

  <p>Вы можете выводить ответ в любом регистре (например, строки «yEs», «yes», «Yes» and «YES» будут считаться за положительный ответ).</p>

  <details>
    <summary>Пример</summary>
<pre>
10
6 10
........**
.**......*
..*..*....
.....**...
...*.....*
..**....**
6 10
....*...**
.**......*
..*..*....
.....**...
...*.....*
..**....**
3 3
...
***
...
4 4
.*..
**..
..**
..*.
5 4
.*..
**..
....
..**
..*.
3 2
.*
**
*.
2 3
*..
.**
3 2
..
**
*.
3 3
.**
*.*
**.
3 3
..*
.**
..*
</pre>
<pre>
YES
NO
NO
NO
YES
NO
NO
YES
NO
NO
</pre>
  </details>
</article>


<!-- Задача G. Чётный-нечётный XOR -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Чётный-нечётный XOR</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Дано целое число n, найдите любой массив a, состоящий из n различных неотрицательных целых чисел, меньших 2³¹, такой, что побитовый XOR элементов на нечетных позициях равен побитовому XOR элементов на четных позициях.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно целое число t (1 ≤ t ≤ 629) — количество наборов входных данных.</p>

  <p>Затем следуют t строк, каждая содержит одно целое число n (3 ≤ n ≤ 2⋅10⁵) — длина массива.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превосходит 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одну строку, содержащую n различных целых чисел, которые удовлетворяют условиям.</p>

  <p>Если ответов несколько, выведите любой.</p>

  <details>
    <summary>Пример</summary>
<pre>
7
8
3
4
5
6
7
9
</pre>
<pre>
4 2 1 5 0 6 7 3
2 1 3
2 1 3 0
2 0 4 5 3
4 1 2 12 3 8
1 2 3 4 5 6 7
8 2 3 7 4 0 5 6 9
</pre>
  <p>В первом наборе входных данных XOR на нечетных позициях равен 4⊕1⊕0⊕7=2 и XOR на четных позициях 2⊕5⊕6⊕3=2.</p>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // размер массива
    cin >> n;

    // решение
    vector&lt;int&gt; Res(n);
    int even = 0; // четный
    int odd = 0;  // нечетный

    // соберем массив без двух предпоследних элементов
    // из последовательных чисел начиная с 1
    for (int i = 0; i &lt; n - 2; i++) {
      Res[i] = i + 1;
      if (i % 2 == 0) {
        even ^= Res[i];
      }
      if (i % 2 == 1) {
        odd ^= Res[i];
      }
    }

    // если в полученном массиве XOR одинаковый
    // для четных и нечетных элементов
    // то пересоберем массив еще раз, начиная с нуля
    if (even == odd) {
      for (int i = 0; i &lt; n - 2; i++) {
        Res[i] = i;
        if (i % 2 == 0) {
          even ^= Res[i];
        }
        if (i % 2 == 1) {
          odd ^= Res[i];
        }
      }
    }

    // чтобы не получилось повторяющихся чисел
    // добавим число с 1 в самом старшем разряде
    // и подберем для него число по операции XOR
    Res[n - 2] = 2'147'483'647; // 2^30
    Res[n - 1] = even ^ odd ^ Res[n - 2];

    // вывод результата
    for (int i = 0; i &lt; n; i++) {
      cout &lt;&lt; Res[i] &lt;&lt; ' ';
    }
    cout &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>

