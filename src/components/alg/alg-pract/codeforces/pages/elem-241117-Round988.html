<article class="article">
  <a href="https://codeforces.com/contest/2037" target="_blank">Codeforces Round 988 (Div.3) 2024-11-17</a>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

      <a href="#task1">Задача A. Двойки</a>
  <br><a href="#task2">Задача B. Перехваченные входные данные</a>
  <br><a href="#task3">Задача C. Любимая перестановка Суперультры</a>
  <br><a href="#task4">Задача D. Акулий серфинг</a>
  <br><a href="#task5">Задача E. Любимая двоичная строка Качины</a>
  <br><a href="#task6">Задача F. Пылающее Пламя</a>
  <br><a href="#task7">Задача G. Исследование Натлана</a>
</article>


<!-- Задача A. Двойки -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Двойки</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Кинич просыпается к началу нового дня. Он включает свой телефон, проверяет почту и находит загадочный подарок. Он решает распаковать подарок.</p>

  <p>Кинич распаковывает массив a из n целых чисел. Изначально счет Кинича равен 0. Он будет выполнять следующую операцию любое количество раз:</p>
  <ul>
    <li>Выберите такие два индекса i и j (1 ≤ i &lt; j ≤ n), что ни i, ни j не были выбраны в каких-либо предыдущих операциях, и aᵢ = a<sub>j</sub>. Затем добавьте 1 к своему счету.</li>
  </ul>

  <p>Выведите максимальный счет, который Кинич может достичь после выполнения вышеупомянутой операции любое количество раз.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 500) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит целое число n (1 ≤ n ≤ 20) — длина массива a.</p>

  <p>Следующая строка каждого набора входных данных содержит n целых чисел a₁, a₂, ... , aₙ (1 ≤ aᵢ ≤ n), разделенных пробелами.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите максимальный счет, который можно достичь на новой строке.</p>

  <h4>Пример</h4>
<pre>
5
1
1
2
2 2
2
1 2
4
1 2 3 1
6
1 2 3 1 2 3
</pre>
<pre>
0
1
0
1
3
</pre>
  <p>В первом и третьем тестах Кинич не может выполнить никаких операций.</p>

  <p>Во втором тесте Кинич может выполнить одну операцию с i = 1 и j = 2.</p>

  <p>В четвертом тесте Кинич может выполнить одну операцию с i = 1 и j = 4.</p>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  int test; //количество тестов
  cin >> test;

  //все тесты обрабатываем по отдельности
  for (int t = 0; t &lt; test; t++) {
    int n;
    cin >> n;
    //частотный массив
    vector&lt;int&gt; B(n + 1);

    //подсчет сколько раз мы встретили каждое число
    for (int i = 0; i &lt; n; i++) {
      int tmp;
      cin >> tmp;
      B[tmp]++;//увеличение значения на 1
    }
    int res = 0;//переменная, где хранится ответ

    //Догадаемся, что, если мы хотим максимизировать ответ.
    //Необходимо посчитать количество пар с одинаковыми числами.
    for (int i = 0; i &lt; B.size(); i++) {
      // подсчет количества пар, где элементы
      // в паре равняются i
      res += B[i] / 2;
    }
    cout &lt;&lt; res &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача B. Перехваченные входные данные -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Перехваченные входные данные</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Чтобы помочь вам подготовиться к предстоящему контесту на Codeforces, Ситлали задала задачу на матрицу и пытается передать вам матрицу размером n на m через ваш поток ввода. В частности, ваш поток ввода должен содержать следующее:</p>
  <ul>
    <li>Первая строка содержит два целых числа n и m — размеры сетки.</li>
    <li>Следующие n строк содержат по m целых чисел — значения сетки.</li>
  </ul>

  <p>Однако кто-то перехватил ваш поток ввода, перемешал все данные и поместил их в одну строку! Теперь есть k целых чисел, все в одной строке, и вы не знаете, что означало каждое целое число. Вместо того чтобы просить Ситлали повторно отправить ввод, вы решаете самостоятельно определить значения n
  и m.</p>

  <p>Выведите любое возможное значение n и m, которые могла предоставить Ситлали.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит целое число k (3 ≤ k ≤ 2⋅10⁵) — общее количество входных данных в вашем потоке ввода.</p>

  <p>Следующая строка каждого набора входных данных содержит k целых чисел a₁, a₂, ... , aₖ (1 ≤ aᵢ ≤ k) — перемешанные входные данные вашего потока ввода. Гарантируется, что n и m содержатся среди k целых чисел.</p>

  <p>Гарантируется, что сумма k по всем наборам входных данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите два целых числа, одно возможное значение n и m. Если существует несколько возможных ответов, выведите любой.</p>

  <h4>Пример</h4>
<pre>
5
3
1 1 2
11
3 3 4 5 6 7 8 9 9 10 11
8
8 4 8 3 8 2 8 1
6
2 1 4 5 3 3
8
1 2 6 3 8 5 5 3
</pre>
<pre>
1 1
3 3
2 3
4 1
1 6
</pre>
  <p>В первом наборе входных данных первоначальный ввод мог быть следующим:</p>
  <code>1 1</code>
  <code>2</code>

  <p>Во втором наборе входных данных первоначальный ввод мог быть следующим:</p>
  <code>3 3</code>
  <code>4 5 6</code>
  <code>7 8 9</code>
  <code>9 10 11</code>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  int test;//количество тестов
  cin >> test;

  //каждый тест отдельно друг от друга
  for (int t = 0; t &lt; test; t++)	{
    int k;//количество элементов
    cin >> k;
    int n, m;//переменные для ответа

    //все элементы в тесте непревосходят k.
    // Сделаем частотный массив
    vector&lt;int&gt; A(k + 1);
    int tmp;
    for (int i = 0; i &lt; k; i++) {
      cin >> tmp;
      A[tmp]++;
    }
    // размер прямоугольника, который мы ищим n*m
    int mult = k - 2;
    //пробежимся по массиву
    for (int i = 1; i &lt;= k; i++) {
      if (A[i] != 0) {
        //проверим что i может быть стороной прямоугольника
        if (mult % i == 0) {
          // проверка что mult != i*i
          if (i != mult / i) {
            // находим второе число
            // если оно было в массиве то ответ найден
            if (A[mult / i] != 0) {
              n = i;
              m = mult / i;
              break;
            }
          } else {
            //если i * i == mult
            if (A[i] > 1)	{
              n = i;
              m = i;
              break;
            }
          }
        }
      }
    }
    cout &lt;&lt; n &lt;&lt; " " &lt;&lt; m &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача C. Любимая перестановка Суперультры -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Любимая перестановка Суперультры</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Суперультра, маленькая красная панда, отчаянно хочет примогемы. В своих мечтах он слышит голос, который говорит ему, что он должен решить следующую задачу, чтобы получить пожизненный запас примогемов. Помогите Суперультре!</p>

  <p>Постройте перестановку∗ p длины n так, чтобы pᵢ + pᵢ₊₁ было составным† для всех 1 ≤ i ≤ n-1. Если это невозможно, выведите -1.</p>

  <p>∗Перестановка длины n — это массив, состоящий из n различных целых чисел от 1 до n в произвольном порядке. Например, [2,3,1,5,4] является перестановкой, но [1,2,2] не является перестановкой (число 2 встречается дважды в массиве), а [1,3,4] также не является перестановкой (длина n=3, но в массиве есть 4).</p>

  <p>†Целое число x является составным, если у него есть хотя бы один другой делитель, кроме 1 и x. Например, 4 является составным, потому что 2 является делителем.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Каждый набор входных данных содержит целое число n (2 ≤ n ≤ 2⋅10⁵) — длину перестановки.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных, если невозможно построить p, выведите -1 на новой строке. В противном случае выведите n целых чисел p₁, p₂, ... , pₙ.</p>

  <h4>Пример</h4>
<pre>
2
3
8
</pre>
<pre>

</pre>
  <p>В первом примере можно показать, что любая перестановка размера 3 содержит два смежных элемента, сумма которых является простым числом. Например, в перестановке [2,3,1] сумма 2+3=5 является простым числом.</p>

  <p>Во втором примере мы можем проверить, что пример вывода верен, потому что 1+8, 8+7, 7+3, 3+6, 6+2, 2+4 и 4+5 все составные. Могут быть и другие правильные конструкции.</p>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  int test;//количество тестов
  cin >> test;

  //обработка тестов
  for (int t = 0; t &lt; test; t++) {
    //в этой задаче нужно было придумать
    // последовательность элементов утверждение:
    // если a[i] и a[i+1] четные то их сумма
    // четная и является составным числом
    // если a[i] и a[i+1] нечетные то их сумма
    // четная и является составным числом
    // давайте сначала выведем все нечетные
    // числа, а потом четные числа.
    // тогда нам придется придумать комбинацию
    // специальных чисел в середине массива
    // пусть это будет число 5 и 4 их сумма
    // дает 9 составное число
		int n;
    cin >> n;
    //утверждение при n &lt; 5 невозможно создать последовательность
    if (n &lt; 5) {
      cout &lt;&lt; "-1\n";
    } else {
      vector&lt;int&gt; A;
      vector&lt;int&gt; B;

      //массив нечетных чисел
      for (int i = 1; i &lt;= n; i += 2) {
        if (i != 5)
          A.push_back(i);
      }
      A.push_back(5);
      B.push_back(4);

      //массив четных чисел
      for (int i = 2; i &lt;= n; i += 2) {
        if (i != 4)
          B.push_back(i);
      }
      //вывод массива нечетных чисел
      for (int i = 0; i &lt; A.size(); i++) {
        cout &lt;&lt; A[i] &lt;&lt; " ";
      }
      //вывод массива четных чисел
      for (int i = 0; i &lt; B.size(); i++) {
        cout &lt;&lt; B[i] &lt;&lt; " ";
      }
      cout &lt;&lt; '\n';
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача D. Акулий серфинг -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Акулий серфинг</h3>

  <div><i>Ограничение по времени 3с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Муалани любит серфинг на своей акульей доске!</p>

  <p>Путь серфинга Муалани можно смоделировать с помощью числовой прямой. Она начинает с позиции 1, а путь заканчивается на позиции L. Когда она находится в позиции x с силой прыжка k, она может прыгнуть в любую целую позицию в интервале [x,x+k]. Изначально ее сила прыжка равна 1.</p>

  <p>Однако ее путь серфинга не совсем гладкий. На ее пути есть n препятствий. Каждое препятствие представлено отрезком [l,r], что означает, что она не может прыгнуть на любую позицию в отрезке [l,r].</p>

  <p>Также на определенных позициях на пути есть m усилений. Усиление i расположено на позиции xi и имеет значение vi. Когда Муалани находится на позиции xi, она может собрать усиление, чтобы увеличить свою силу прыжка на vi. На одной и той же позиции может быть несколько усилений. Когда она находится на позиции с несколькими усилениями, она может выбрать, взять или игнорировать каждое отдельное усиление. Ни одно усиление не находится в отрезке любого препятствия.</p>

  <p>Каково минимальное количество усилений, которые она должна собрать, чтобы достичь позиции L и завершить путь? Если завершить путь невозможно, выведите -1.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит три целых числа n, m и L (1 ≤ n, m ≤ 2⋅10⁵, 3 ≤ L ≤ 10⁹) — количество препятствий, количество усилений и позицию конца.</p>

  <p>Следующие n строк содержат по два целых числа lᵢ и rᵢ (2 ≤ lᵢ ≤ rᵢ ≤ L-1) — границы отрезка для i-го препятствия. Гарантируется, что rᵢ+1 &lt; lᵢ₊₁ для всех 1 ≤ i &lt; n (т.е. все препятствия не перекрываются, отсортированы по возрастанию позиций, и конец предыдущего препятствия не является последовательным с началом следующего препятствия).</p>

  <p>Следующие m строк содержат по два целых числа xᵢ и vᵢ (1 ≤ xᵢ, vᵢ ≤ L) — позицию и значение для i-го усиления. На одной и той же позиции x может быть несколько усилений. Гарантируется, что xᵢ ≤ xᵢ₊₁ для всех 1 ≤ i &lt; m (т.е. усиления отсортированы по неубывания позиции) и ни одно усиление не находится в отрезке любого препятствия.</p>

  <p>Гарантируется, что сумма n и сумма m по всем наборам входных данных не превышают 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите минимальное количество усилений, которые она должна собрать, чтобы достичь позиции L. Если это невозможно, выведите -1.</p>

  <h4>Пример</h4>
<pre>
4
2 5 50
7 14
30 40
2 2
3 1
3 5
18 2
22 32
4 3 50
4 6
15 18
20 26
34 38
1 2
8 2
10 2
1 4 17
10 14
1 6
1 2
1 2
16 9
1 2 10
5 9
2 3
2 2
</pre>
<pre>
4
-1
1
2
</pre>
  <p>В первом наборе входных данных она может собрать усиления 1, 2, 3 и 5, чтобы преодолеть все препятствия.</p>

 <p>Во втором наборе входных данных она не может перепрыгнуть первое препятствие.</p>

  <p>В четвертом наборе входных данных, собрав оба усиления, она сможет перепрыгнуть препятствие.</p>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;set&gt;

using namespace std;

int main() {
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  int test;
  cin >> test;
  //сложная задача на тему обработка событий или сканирующая прямая
  for (int t = 0; t &lt; test; t++) {
    //все входные параметры
    long long n, m, L;
    cin >> n >> m >> L;
    vector&lt;pair&lt;long long, long long&gt; &gt; A(n);

    for (int i = 0; i &lt; n; i++) {
      cin >> A[i].first >> A[i].second;
    }
    vector&lt;pair&lt;long long, long long&gt; &gt; B(m);
    for (int i = 0; i &lt; m; i++) {
      cin >> B[i].first >> B[i].second;
    }

    //нам требуется поддерживать правило
    // лучших улучшений для этого требуется
    // структура данных multiset
    // multiset хранит элементы всегда в отсортированном порядке
    multiset&lt;long long&gt; mst;

    long long res = 0;//ответ

    int ukA = 0;//указатель на массив А
    int ukB = 0;//указатель на массив В
    long long v = 1;//прыжок
    //невозможность перепрыгнуть отрезок (если станет false)
    bool flag = true;

    while (true) {
      // преодалели все отрезки
      if (A.size() == ukA) {
        break;
      // есть еще отрезки препятствия
      }	else {
        // есть еще улучшения прыжка
        if (B.size() != ukB) {
          // проверяем что встретим раньше улучшение или отрезок
          if (B[ukB].first &lt; A[ukA].first) {
            long long tmp;// добавляем усиленеи в multiset
            tmp = -B[ukB].second;
            mst.insert(tmp);
            ukB++;
          } else {
            //проверяем хватит ли прыжка
            if (A[ukA].second - A[ukA].first + 1 >= v) {
              //не хватает
              //нет усилений мы проиграли
              if (mst.size() == 0) {
                flag = false;
                break;
              //берем самое сильное усиление из списка которые у нас есть
              } else {
                v -= *mst.begin();
                mst.erase(mst.begin());
                res++;
              }
            } else {//силы прыжка хватило без усилений
              ukA++;
            }
          }
        } else {//нет усилений на пути
          if (A[ukA].second - A[ukA].first + 1 >= v) {
            if (mst.size() == 0) {//нет усилений мы проиграли
              flag = false;
              break;
            } else {//берем самое сильное усиление из списка которые у нас есть
              v -= *mst.begin();
              mst.erase(mst.begin());
              res++;
            }
          } else {//силы прыжка хватило без усилений
            ukA++;
          }
        }
      }
    }

    if (flag)//вывод ответа
      cout &lt;&lt; res &lt;&lt; '\n';
    else
      cout &lt;&lt; "-1\n";
  }
}
</pre>
  </details>
</article>


<!-- Задача E. Любимая двоичная строка Качины -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Любимая двоичная строка Качины</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Это интерактивная задача.</p>

  <p>Качина бросает вам вызов угадать её любимую двоичную строку∗ s длины n. Она определяет f(l,r) как количество подпоследовательностей† 01 в slsl+1…sr. Две подпоследовательности считаются различными, если они образованы путём удаления символов из разных позиций в исходной строке, даже если получившиеся подпоследовательности состоят из одних и тех же символов.</p>

  <p>Чтобы определить s, вы можете задать ей несколько вопросов. В каждом вопросе вы можете выбрать два индекса l и r (1 ≤ l &lt; r ≤ n) и спросить её о значении f(l,r).</p>

  <p>Определите и выведите s, задав Качине не более n вопросов. Однако может случиться так, что s невозможно определить. В этом случае вам нужно будет вывести IMPOSSIBLE вместо этого.</p>

  <p>Формально, s считается невозможно определить, если после того, как вы задали n вопросов, всегда существует несколько возможных строк для s, независимо от того, какие вопросы задаются. Обратите внимание, что если вы сообщите IMPOSSIBLE в то время, когда существует последовательность из не более чем n запросов, которая уникально определит двоичную строку, вы получите вердикт Неправильный ответ.</p>

  <p>∗Двоичная строка содержит только символы 0 и 1.</p>

  <p>†Последовательность a является подпоследовательностью последовательности b, если a может быть получена из b путём удаления нескольких (возможно, нуля или всех) элементов. Например, подпоследовательностями 1011101 являются 0, 1, 11111, 0111, но не 000 и не 11100.</p>

  <h4>Входные данные</h4>
  <p>Первая строка ввода содержит одно целое число t (1 ≤ t ≤ 10³) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит одно целое число n (2 ≤ n ≤ 10⁴) — длина s.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 10⁴.</p>

  <h4>Протокол взаимодействия</h4>
  <p>Чтобы задать вопрос, выведите строку в следующем формате (не включайте кавычки)</p>
  <code>«? l r» (1 ≤ l &lt; r ≤ n)</code>

  <p>Жюри вернёт целое число f(l,r).</p>

  <p>Когда вы будете готовы напечатать ответ, выведите одну строку в следующем формате</p>
  <ul>
    <li>Если s невозможно определить, выведите «! IMPOSSIBLE»</li>
    <li>В противном случае выведите «! s»</li>
  </ul>

  <p>После этого продолжайте обрабатывать следующий набор входных данных или завершите программу, если это был последний набор входных данных. Печать ответа не считается запросом.</p>

  <p>Интерактор не адаптивен, что означает, что ответ известен до того, как участник задаст запросы и не зависит от заданных участником запросов.</p>

  <p>Если ваша программа делает более n запросов для одного набора входных данных, ваша программа должна немедленно завершиться, чтобы получить вердикт Неправильный ответ. В противном случае вы можете получить произвольный вердикт, потому что ваше решение продолжит читать из закрытого потока.</p>

  <p>После печати запроса не забудьте вывести конец строки и сбросить вывод. В противном случае вы можете получить вердикт Превышен лимит бездействия. Для этого используйте:</p>
  <code>fflush(stdout) или cout.flush() в C++;</code>

  <h4>Взломы</h4>
  <p>Чтобы сделать Взлом, используйте следующий формат.</p>

  <p>Первая строка должна содержать одно целое число t (1 ≤ t ≤ 10³) – количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных должна содержать целое число n (2 ≤ n ≤ 10⁴) — длина s.</p>

  <p>Следующая строка должна содержать s, двоичную строку длины n.</p>

  <p>Сумма n по всем наборам входных данных не должна превышать 10⁴.</p>

  <h4>Пример</h4>
<pre>
2
5

4

0

1

2

2

0
</pre>
<pre>
? 1 5

? 2 4

? 4 5

? 3 5

! 01001

? 1 2

! IMPOSSIBLE
</pre>
  <h4>В первом наборе входных данных:</h4>
  <p>В первом запросе вы спрашиваете Качину о значении f(1,5), и она отвечает 4 в потоке ввода.</p>

  <p>Во втором запросе вы спрашиваете Качину о значении f(2,4). Поскольку в строке 100 нет подпоследовательностей 01, она отвечает 0 в потоке ввода.</p>

  <p>После того, как вы задали 4 вопроса, вы сообщаете 01001 как s, и это правильно.</p>

  <h4>Во втором наборе входных данных:</h4>
  <p>В первом запросе вы спрашиваете Качину о значении f(1,2), и она отвечает 0 в потоке ввода. Обратите внимание, что это единственный различный вопрос, который вы можете задать.</p>

  <p>Однако обратите внимание, что строки 00 и 11 обе имеют ответ 0, и невозможно различить между ними. Поэтому мы сообщаем IMPOSSIBLE.</p>

  <p>Обратите внимание, что этот пример служит только для демонстрации формата взаимодействия. Он не гарантирует, что предоставленные запросы являются оптимальными или однозначно определяют ответ. Тем не менее, можно показать, что существует последовательность из не более чем 5 запросов, которая однозначно определяет пример теста 1.</p>

  <details>
    <summary>Решение</summary>
<pre>
#include&lt;iostream&gt;
#include&lt;vector&gt;

using namespace std;

int main() {
  //#ifdef _DEBUG
    //freopen("input.txt", "rt", stdin);
    //freopen("output.txt", "wt", stdout);
  //#endif
  int test;
  cin >> test;
  //сложная интерактивная задача
  //заметим что нам разрешено делать n запросов
  for (int t = 0; t &lt; test; t++) {
    int n;
    cin >> n;

    vector&lt;int&gt; Res(n + 1, -1);//массив ответа
    vector&lt;int&gt; A(n + 1, 0);//массив последовательности

    //задаем кучу запросов формата 1 r.
    // Дальше мы будем узнавать информацию в позиции r
    for (int r = 2; r &lt;= n; r++) {
      int tmp;
      cout &lt;&lt; "? 1 " &lt;&lt; r &lt;&lt; '\n';
      fflush(stdout);
      cin >> tmp;
      A[r] = tmp;
    }
    bool flag = true;// проверка, что можем собрать последовательность
    if (A[n] == 0)// ситуация в которой строка либо куча 000000000000 либо 111111111111 мы не можем определить
    {
      flag = false;
    }
    for (int i = n; i > 1; i--)//пойдем собирать нашу последовательность с конца
    {
      // мы можем определить по значению двух соседей i i-1 отличаются они или нет элемент в позиции i
      if (A[i] > 0)
      {
        if (A[i] - A[i - 1] > 0) // если отличаются то мы берем 1
        {
          Res[i] = 1;
        }
        else// если не отличаются то мы берем 0
        {
          Res[i] = 0;
        }
      }
    }

    int uk = 0;// остается доопределить начало. Для этого найдем первую позицию в массиве A отличную от 0
    for (int i = 1; i &lt;= n; i++) {
      if (A[i] > 0)
      {
        uk = i;
        break;
      }
    }
    //если мы нашли позицию то мы точно можем сказать
    //что в позиции uk стоит 1 и перед ней есть какое
    //то количество 0 и 1 более того сначала стоят 1
    //а потом стоят 0 количество 0 равняется значению count
    if (uk > 0) {
      int pos = uk - 1;
      int count = A[uk];
      for (int i = pos; i >= 1; i--) {
        if (count > 0) {
          count--;
          Res[i] = 0;
        } else {
          Res[i] = 1;
        }
      }
      //как итог сформировали всю последовательность сначала ее хвост, потом голову
    }


    if (flag) {
      string otv = "! ";//формируем свой ответ как единую строку

      for (int i = 1; i &lt;= n; i++) {
        if (Res[i] == 0) {
          otv += "0";
        } else {
          otv += "1";
        }
      }
      cout &lt;&lt; otv &lt;&lt; '\n';
      fflush(stdout);
    } else {
      cout &lt;&lt; "! IMPOSSIBLE" &lt;&lt; '\n';//не смогли построить ответ
      fflush(stdout);
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача F. Пылающее Пламя -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Пылающее Пламя</h3>

  <div><i>Ограничение по времени 4с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вы получили нового ограниченного персонажа события Шилонен. Вы решаете использовать её в бою.</p>

  <p>На линии находится n врагов. i-й враг слева имеет здоровье hi и в данный момент находится на позиции xi. У Шилонен есть урон от атаки m, и вы готовы победить врагов с её помощью.</p>

  <p>У Шилонен есть мощная атака «удар по земле». Перед тем, как вы выполните какие-либо атаки, вы выбираете целое число p и размещаете Шилонен там (p может быть любой целой позицией, включая позицию с врагом в данный момент). После этого, за каждую атаку она наносит m урона врагу на позиции p (если таковой имеется), m-1 урона врагам на позициях p-1 и p+1, m-2 урона врагам на позициях p-2 и p+2, и так далее. Враги, находящиеся на расстоянии не менее m от Шилонен, не получают урона от атак.</p>

  <p>Формально, если враг находится на позиции x, она нанесет max(0,m-|p-x|) урона этому врагу за каждую атаку. Обратите внимание, что вы не можете выбрать другое p для разных атак.</p>

  <p>Среди всех возможных p выведите минимальное количество атак, которые Шилонен должна выполнить, чтобы победить как минимум k врагов. Если невозможно найти p, при котором в конечном итоге будет побеждено как минимум k
   врагов, выведите -1 вместо этого. Обратите внимание, что враг считается побежденным, если его здоровье достигает 0 или ниже.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10⁴) – количество наборов входных данных.</p>

  <p>Первая строка каждого набора содержит три целых числа n, m и k (1 ≤ k ≤ n ≤ 10⁵, 1 ≤ m ≤ 10⁹).</p>

  <p>Следующая строка содержит n целых чисел h1, h2, ... , hn (1 ≤ hi ≤ 10⁹).</p>

  <p>Последняя строка каждого набора содержит n целых чисел x1, x2, ..., xn (1 ≤ xi ≤ 10⁹, xi &lt; xi+1 для всех 1 ≤ i &lt; n)</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите целое число на новой строке, минимальное количество атак, которые должны быть выполнены, чтобы победить как минимум k врагов. Если невозможно найти p, при котором в конечном итоге будет побеждено как минимум k врагов, выведите -1 вместо этого.</p>

  <h4>Пример</h4>
<pre>
6
5 5 3
7 7 7 7 7
1 2 3 4 5
9 5 9
2 4 6 8 10 8 6 4 2
1 2 3 4 5 6 7 8 9
2 10 2
1 1
1 20
2 10 1
69696969 420420420
1 20
2 10 2
10 15
1 19
2 2 2
1000000000 1
1 3
</pre>
<pre>
2
2
-1
6969697
15
1000000000
</pre>
  <p>В первом примере оптимально выбрать p=2. За каждую атаку первый враг получает 5-|2-1|=4 урона, второй враг получает 5 урона, третий враг получает 4 урона, четвертый враг получает 3 урона, а пятый враг получает 2 урона. После 2 атак первые три врага будут побеждены. Можно показать, что невозможно победить 3 врага менее чем за 2 атаки, независимо от выбранного p.</p>

  <p>Во втором примере мы должны убить всех 9 врагов. Выбрав p=5, все девять врагов будут побеждены за 2 атаки.</p>

  <p>В третьем примере мы должны убить обоих врагов. Однако можно показать, что ни одно выбранное p не повредит обоих врагов одновременно, поэтому ответ будет -1.</p>

  <p>В четвертом примере выбор p=1 позволит нам победить первого врага за 6969697 атак.</p>

  <p>В пятом примере выбор p=10 заставит каждого врага получать 1 урон за атаку. Оба врага будут побеждены за 15 атак.</p>
</article>


<!-- Задача G. Исследование Натлана -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Исследование Натлана</h3>

  <div><i>Ограничение по времени 4с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вы исследуете потрясающий регион Натлан! Этот регион состоит из n городов, и каждый город имеет рейтинг привлекательности ai. Направленное ребро существует от города i к городу j тогда и только тогда, когда i &lt; j и gcd(ai,aj)≠1, где gcd(x,y) обозначает наибольший общий делитель (НОД) целых чисел x и y
 .</p>

  <p>Начав с города 1, ваша задача — определить общее количество различных путей, которыми вы можете добраться до города n, по модулю 998244353. Два пути различны тогда и только тогда, когда множество посещённых городов различно.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число n (2 ≤ n ≤ 2⋅10⁵) — количество городов.</p>

  <p>Вторая строка содержит n целых чисел a1, a2, ... , an (2 ≤ ai ≤ 10⁶) — привлекательность каждого города.</p>

  <h4>Выходные данные</h4>
  <p>Выведите общее количество различных путей, которыми вы можете добраться до города n, по модулю 998244353.</p>

  <h4>Пример 1</h4>
<pre>
5
2 6 3 4 6
</pre>
  <code>5</code>

  <h4>Пример 2</h4>
<pre>
5
4 196 2662 2197 121
</pre>
  <code>2</code>

  <h4>Пример 3</h4>
<pre>
7
3 6 8 9 11 12 20
</pre>
  <code>7</code>

  <h4>Пример 4</h4>
<pre>
2
2 3
</pre>
  <code>0</code>
  <p>В первом примере пять путей следующие:</p>
  <ol>
    <li>Город 1→ Город 5</li>
    <li>Город 1→ Город 2→ Город 5</li>
    <li>Город 1→ Город 2→ Город 3→ Город 5</li>
    <li>Город 1→ Город 2→ Город 4→ Город 5</li>
    <li>Город 1→ Город 4→ Город 5</li>
  </ol>
  <p>Во втором примере два пути следующие:</p>
  <ol>
    <li>Город 1→ Город 3→ Город 5</li>
    <li>Город 1→ Город 2→ Город 3→ Город 5</li>
  </ol>
</article>
