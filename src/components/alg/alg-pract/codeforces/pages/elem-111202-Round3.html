<article class="article">
  <a href="https://codeforces.com/contest/134" target="_blank">Codeforces Testing Round 3 2011-12-02</a>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

      <a href="#task1">Задача A. Среднестатистические элементы</a>
  <br><a href="#task2">Задача B. Пары чисел</a>
  <br><a href="#task3">Задача C. Обмены</a>
</article>


<!-- Задача A. Среднестатистические элементы -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Среднестатистические элементы</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Задана последовательность положительных целых чисел a1, a2, ..., an. Найдите все такие индексы i, что i-ый элемент равен среднему арифметическому всех остальных элементов (то есть всех элементов, кроме него).</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое число n (2 ≤ n ≤ 2·10⁵). Вторая строка содержит элементы последовательности a1, a2, ..., an (1 ≤ ai ≤ 1000). Все элементы — положительные целые числа.</p>

  <h4>Выходные данные</h4>
  <p>В первую строку выведите количество искомых индексов. Во вторую строку — искомые индексы в порядке возрастания. Все индексы — это целые числа от 1 до n.</p>

  <p>Если искомых элементов не существует, то первая строка выходных данных должна содержать число 0. В этом случае вторую строку можно не выводить или вывести пустую строку.</p>

  <details>
    <summary>Примеры</summary>
  <h4>Пример 1</h4>
<pre>
5
1 2 3 4 5
</pre>
<pre>
1
3
</pre>

  <h4>Пример 2</h4>
<pre>
4
50 50 50 50
</pre>
<pre>
4
1 2 3 4
</pre>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  int n;
  cin >> n;
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> A[i];
  }

  // решение
  int sum = 0;
  // находим сумму всех элементов
  for (int i = 0; i &lt; n; i++) {
    sum += A[i];
  }

  int cnt = 0;
  vector&lt;int&gt; B;
  for (int i = 0; i &lt; n; i++) {
    // проверяем сумма что делится нацело
    if (!((sum - A[i]) % (n - 1))) {
      int tmp = (sum - A[i]) / (n - 1);
      if (tmp == A[i]) {
        cnt++;
        B.push_back(i + 1);
      }
    }
  }

  // вывод результата
  cout &lt;&lt; cnt &lt;&lt; '\n';
  if (cnt) {
    for (int i = 0; i &lt; B.size(); i++) {
      cout &lt;&lt; B[i] &lt;&lt; ' ';
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача B. Пары чисел -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Пары чисел</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Допустим, мы имеем пару чисел (a, b). Мы можем получить новую пару чисел вида (a + b, b) или (a, a + b) из данной. Назовем такое действие шагом.</p>

  <p>Пусть начальная пара чисел — (1,1). Ваша задача — найти число k, наименьшее количество шагов, необходимых чтобы получить из (1,1) пару, в которой хотя бы одно число равно n.</p>

  <h4>Входные данные</h4>
  <p>Входные данные содержат единственное целое число n (1 ≤ n ≤ 10⁶).</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное число k.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>5</code>
    <code>3</code>

    <h4>Пример 2</h4>
    <code>1</code>
    <code>0</code>
    <p>Из пары (1,1) можно за три хода получить пару, содержащую 5: (1,1) → (1,2) → (3,2) → (5,2).</p>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/134/problem/B" target="_blank">Задача 134B</a>
      <br><a href="https://codeforces.com/contest/134" target="_blank">Codeforces Testing Round 3 2011-11-30</a>
    </div>

    <p>Нужно из пары (1,1) получить пару (x,n). Возможен переход (a,b) -> (a+b,b) и (a, a+b). При сложении мы должны выбрать из двух вариантов какие числа складывать.</p>
    <p>Попробуем решить обратную задачу, т.е. из пары (x,n) получим пару (1,1). Возможен переход (x,y) -> (x,y-x) и (x-y,y). При переходе у нас должно получиться натуральное число, т.е. целое число больше нуля. При вычитании у нас остается только один вариант, во втором результат будет меньше нуля.</p>
    <p>Перебираем все пары и смотрим за какое количество шагов мы из пары (x,n) придем к паре (1,1). Выберем минимальное количество шагов.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

long long cnt;

long long gcd(long long a, long long b) {
  if (b == 0) {
    if (a != 1) {
      cnt += 1'000'000;
    }
    cnt += a - 1;
    return a;
  } else {
    cnt += a / b;
    return gcd(b, a % b);
  }
}

int main() {
  long long n;
  cin >> n;
  long long min_count = 10'000'000;
  for (long long i = 1; i &lt; n; i++) {
    cnt = 0;
    gcd(n, i);
    min_count = min(min_count, cnt);
  }
  if (min_count == 10'000'000) {
    cout &lt;&lt; 0;
    return 0;
  }

  cout &lt;&lt; min_count - 1;
}
</pre>
  </details>
</article>


<!-- Задача C. Обмены -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Обмены</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>За круглым столом сидят n игроков. У всех них в сумме s карт n цветов, причем на начальный момент у первого человека карты только первого цвета, у второго — второго цвета и так далее. Они могут меняться картами, согласно следующим правилам:</p>
  <ul>
    <li>человек может отдавать в процессе обмена карту только своего цвета;</li>
    <li>игрок не может брать карту цвета, уже у него имеющегося (в частности, карты своего цвета он брать не может, независимо от того раздал он их все или нет);</li>
    <li>в процессе одного обмена пара людей обменивается картами (каждый человек отдает одну карту и получает одну карту).</li>
  </ul>
  <p>Цель всех n человек: каждый из них должен отдать все карты, которые были у него в начале (то есть все карты своего цвета). Ваша задача указать, возможна ли такая последовательность обменов. Если ответ положительный, нужно указать все обмены.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записаны целые числа n (1 ≤ n ≤ 200000) и s (1 ≤ s ≤ 200000). Вторая строка содержит n чисел — количество карт у 1-го, 2-го, ..., n-го игрока на момент начала игры. Игрок может не иметь карт вообще на момент начала игры.</p>

  <h4>Выходные данные</h4>
  <p>Выведите в первой строке «No», если такая последовательность обменов невозможна, и «Yes» в противном случае. Если ответ положительный, выведите далее число k — количество обменов. Далее в k строках опишите обмены — парой номеров меняющихся игроков. Обмены и номера в обменах выводите в любом порядке.</p>

  <details>
    <summary>Примеры</summary>
  <h4>Пример 1</h4>
<pre>
4 8
2 2 2 2
</pre>
<pre>
Yes
4
4 3
4 2
1 3
1 2
</pre>

  <h4>Пример 2</h4>
<pre>
6 12
1 1 2 2 3 3
</pre>
<pre>
Yes
6
6 5
6 4
6 3
5 4
5 3
2 1
</pre>

  <h4>Пример 3</h4>
<pre>
5 5
0 0 0 0 5
</pre>
<pre>
No
</pre>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;queue>
#include &lt;vector>

using namespace std;

int main() {
// условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // ввод данных
  int n; // число цветов
  int s; // число карт
  cin >> n >> s;
  vector&lt;int> A(n + 1); // число карт у каждого игрока
  for (int i = 1; i &lt;= n; i++) {
    cin >> A[i];
  }

  // решение
  priority_queue&lt;pair&lt;int, int> > q;
  for (int i = 1; i &lt;= n; i++) {
    if (A[i]) q.push(make_pair(A[i], i));
  }
  vector&lt;pair&lt;int, int> > ret;
  while (!q.empty()) {
    pair&lt;int, int> fu = q.top();
    q.pop();
    vector&lt;pair&lt;int, int> > tmp;
    while (fu.first > 0) {
      if (q.empty()) {
        cout &lt;&lt; "No\n";
        return 0;
      }

      pair&lt;int, int> fv = q.top();
      q.pop();
      ret.push_back(make_pair(fu.second, fv.second));
      fv.first--;
      fu.first--;
      if (fv.first > 0) {
        tmp.push_back(fv);
      }
    }
    for (int i = 0; i &lt; tmp.size(); i++) {
      q.push(tmp[i]);
    }
  }

  // вывод результата
  cout &lt;&lt; "Yes\n";
  cout &lt;&lt; ret.size() &lt;&lt; '\n';
  for (int i = 0; i &lt; ret.size(); i++) {
    cout &lt;&lt; ret[i].first &lt;&lt; ' ' &lt;&lt; ret[i].second &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>

