<article class="article">
  <a href="https://codeforces.com/contest/1352" target="_blank">Codeforces 1352 Round 640 (Div.4) 2020-05-09</a>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

      <a href="#task1">Задача A. Сумма круглых чисел</a>
  <br><a href="#task2">Задача B. Сумма слагаемых одинаковой четности</a>
  <br><a href="#task3">Задача C. K-е неделящееся на n</a>
  <br><a href="#task4">Задача D. Алиса, Боб и конфеты</a>
  <br><a href="#task5">Задача E. Особые элементы</a>
  <br><a href="#task6">Задача F. Восстановление 01-строки</a>
  <br><a href="#task7">Задача G. Особая перестановка</a>
</article>


<!-- Задача A. Сумма круглых чисел -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Сумма круглых чисел</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Положительное целое число называется круглым, если оно имеет вид d00...0. Иными словами, положительное целое число является круглым, если все его цифры, кроме самой левой (старшей), равны нулю. В частности, все числа от 1 до 9 (включительно) являются круглыми.</p>
  <p>Например, следующие числа являются круглыми: 4000, 1, 9, 800, 90. Например, следующие числа не являются круглыми: 110, 707, 222, 1001.</p>
  <p>Вам задано целое положительное число n (1 ≤ n ≤ 10⁴). Представьте число n как сумму круглых чисел, используя минимальное количество слагаемых. Иными словами, вам надо разложить заданное число n
  в сумму наименьшего количества слагаемых, каждое из которых является круглым числом.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных в тесте. Далее следуют t наборов входных данных.</p>
  <p>Каждый набор представляет собой строку, в которой записано целое число n (1 ≤ n ≤ 10⁴).</p>

  <h4>Выходные данные</h4>
  <p>Выведите t ответов на наборы входных данных. Каждый ответ должен начинаться с целого числа k — минимального количества слагаемых. Далее должны следовать k слагаемых, каждое из которых является круглым числом, а их сумма равна n. Слагаемые можно выводить в любом порядке. Если ответов несколько, то выведите любой из них.</p>

  <details>
    <summary>Пример</summary>
<pre>
5
5009
7
9876
10000
10
</pre>
<pre>
2
5000 9
1
7
4
800 70 6 9000
1
10000
1
10
</pre>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1352/problem/A" target="_blank">Задача 1352A</a>
      <br><a href="https://codeforces.com/contest/1352" target="_blank">Codeforces Round 640 (Div. 4) 2020-05-09</a>
    </div>

    <p>Максимально возможное входное число содержит 5 цифр, поэтому для отевта заведем массив на 5 элементов. Если остаток от деления на 10 равен нулю, то увеличиваем счетчик нулей на 1, иначе записываем в массив остаток от деления с числом нулей из счетчика нулей, увеличиваем число нулей на 1 и число чисел в ответе на 1.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    int n;
    cin >> n;

    // решение
    int count = 0;  // число чисел в ответе
    int zeroes = 0; // число нулей в следующем числе
    int next = 0;   // следующее число
    vector&lt;int&gt; A(5, 0);
    while (n) {
      if (n % 10 == 0) {
        zeroes++;
      } else {
        next = (n % 10) * (int)pow(10, zeroes);
        A[count] = next;
        count++;
        zeroes++;
      }
      n /= 10;
    }

    // вывод результата
    cout &lt;&lt; count &lt;&lt; '\n';
    for (int i = 0; i &lt; count; i++) {
      cout &lt;&lt; A[i] &lt;&lt; " ";
    }
    cout &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача B. Сумма слагаемых одинаковой четности -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Сумма слагаемых одинаковой четности</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Заданы два целых положительных числа n (1 ≤ n ≤ 10⁹) и k (1 ≤ k ≤ 100). Представьте число n в виде суммы k положительных целых чисел одинаковой четности (с одинаковыми остатками от деления на 2).</p>

  <p>Иными словами, найдите такие a1, a2, …, ak, что все ai > 0, n=a1+a2+…+ak и либо все ai одновременно четные, либо все ai одновременно нечетные. Если такого представления не существует, то сообщите об этом.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое число t (1 ≤ t ≤ 1000) — количество наборов входных данных в тесте. Далее записаны t
  наборов входных данных по одному в строке.</p>

  <p>Каждый набор представляет собой два целых положительных числа n (1 ≤ n ≤ 10⁹) и k (1 ≤ k ≤ 100).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите:</p>
  <ul>
    <li>YES и искомые ai, если ответ существует (если ответов несколько, то выведите любой из них);</li>
    <li>NO, если ответа не существует.</li>
  </ul>
  <p>Буквы в словах YES и NO можно выводить в любом регистре.</p>

  <details>
    <summary>Пример</summary>
<pre>
8
10 3
100 4
8 7
97 2
8 8
3 10
5 3
1000000000 9
</pre>
<pre>
YES
4 2 4
YES
55 5 5 35
NO
NO
YES
1 1 1 1 1 1 1 1
NO
YES
3 1 1
YES
111111110 111111110 111111110 111111110 111111110 111111110 111111110 111111110 111111120
</pre>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1352/problem/B" target="_blank">Задача 1352B</a>
      <br><a href="https://codeforces.com/contest/1352" target="_blank">Codeforces Round 640 (Div. 4) 2020-05-09</a>
    </div>

    <p>Для любого числа нужно попробовать два варианта.</p>
    <p>Первый вариант - разложить число x на k - 1 единичек и в конце прибавить остаток, равный x - (n -1). Если остаток нечетный, то это и будет ответ, потому что единички тоже нечетные. Если остаток четный, то нас это не устраивает и нужно пробовать второй вариант.</p>
    <p>Второй вариант - разложить число x на k - 1 двоечек и в конце прибавить остаток, равный x - 2 * (n - 1). Если остаток четный, то это и будет ответ, потому что двоечки тоже четные. Если остаток будет нечетный, то ответа не существует.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

// условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // исходное число
    int k; // число слагаемых
    cin >> n >> k;

    // решение
    // 1 вариант
    // k - 1 единичек + остаток
    int x1 = n - (k - 1); // остаток
    // 2 вариант
    // k - 1 двоечек + остаток
    int x2 = n - 2 * (k - 1); // остаток
    if (x1 > 0 && x1 % 2 == 1) {
      cout &lt;&lt; "YES" &lt;&lt; '\n';
      for (int i = 1; i &lt; k; i++) {
        cout &lt;&lt; 1 &lt;&lt; ' ';
      }
      cout &lt;&lt; x1 &lt;&lt; '\n';
    } else if (x2 > 0 && x2 % 2 == 0) {
      cout &lt;&lt; "YES" &lt;&lt; '\n';
      for (int i = 1; i &lt; k; i++) {
        cout &lt;&lt; 2 &lt;&lt; ' ';
      }
      cout &lt;&lt; x2 &lt;&lt; '\n';
    } else {
      cout &lt;&lt; "NO" &lt;&lt; '\n';
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача C. K-е неделящееся на n -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. K-е неделящееся на n</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Заданы два целых положительных числа: n и k. Выведите k-е положительное целое число, которое не делится на n.</p>

  <p>Например, если n=3, а k=7, то все числа, которые не делятся на 3, имеют вид: 1,2,4,5,7,8,10,11,13…. 7-е число среди них равно 10.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое число t (1 ≤ t ≤ 1000) — количество наборов входных данных в тесте. Далее записаны t наборов входных данных по одному в строке.</p>

  <p>Каждый набор представляет собой два целых положительных числа n (2 ≤ n ≤ 10⁹) и k (1 ≤ k ≤ 10⁹).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите k-е целое положительное число, которое не делится на n.</p>

  <details>
    <summary>Пример</summary>
<pre>
6
3 7
4 12
2 1000000000
7 97
1000000000 1000000000
2 1
</pre>
<pre>
10
15
1999999999
113
1000000001
1
</pre>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1352/problem/C" target="_blank">Задача 1352C</a>
      <br><a href="https://codeforces.com/contest/1352" target="_blank">Codeforces Round 640 (Div. 4) 2020-05-09</a>
    </div>

    <p>Неоптимальное решение это перебирать все числа, начиная с 1. Если число не делится на n, то увеличивать счетчик. Когда счетчик будет равен k, то вывести число в ответ. Сложность O(n).</p>
    <p>Оптимальное решение основано на формуле, которая считается за O(1). k-ое положительное число равно k. k-ое положительное число не делящееся на n это число сдвинутое вправо от k на (k - 1) / (n - 1).</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
// условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // делитель
    int k; // номер целого числа, не делящегося на n
    cin >> n >> k;

    // решение
    int res = k + (k - 1) / (n - 1);

    // вывод результата
    cout &lt;&lt; res &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача D. Алиса, Боб и конфеты -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Алиса, Боб и конфеты</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В ряд выложены n конфет, которые пронумерованы слева направо от 1 до n. Размер i-й конфеты равен aᵢ.</p>

  <p>Алиса и Боб играют в интересную и вкусную игру — они едят конфеты. Алиса будет есть конфеты слева направо, а Боб — справа налево. Игра заканчивается, когда все конфеты съедены.</p>

  <p>Процесс состоит из ходов. Во время хода игрок съедает одну или более конфет со своей стороны (Алиса ест слева, Боб — справа). Первый ход делает Алиса. Во время первого хода она съест 1 конфету (ее размер равен a₁). Затем каждый следующий ход стороны чередуются — то есть второй ход совершает Боб, затем Алиса, затем снова Боб и так далее.</p>

  <p>На каждом ходу игрок считает суммарный размер конфет, съеденных за текущий ход. Как только это число становится строго больше, чем суммарный размер конфет, съеденных другим игроком на предыдущем ходу, текущий игрок завершает ход. Иными словами, на очередном ходу игрок ест наименьшее возможное количество конфет, при котором сумма размеров съеденных в этот ход конфет строго больше суммы размеров конфет, которые съел другой игрок на предыдущем ходу. Если конфет недостаточно, чтобы совершить ход таким образом, то игрок доедает все оставшиеся конфеты и игра заканчивается.</p>

  <p>Например, если n=11 и a=[3,1,4,1,5,9,2,6,5,3,5], то:</p>
  <ul>
    <li>ход 1: Алиса съест одну конфету размера 3 и последовательность конфет примет вид [1,4,1,5,9,2,6,5,3,5];</li>
    <li>ход 2: на предыдущем ходу Алиса съела 3, значит, Боб должен съесть 4 или более — Боб съест одну конфету размера 5 и последовательность конфет примет вид [1,4,1,5,9,2,6,5,3];</li>
    <li>ход 3: на предыдущем ходу Боб съел 5
 , значит, Алиса должна съесть 6 или более — Алиса съест три конфеты суммарным размером 1+4+1=6 и последовательность конфет примет вид [5,9,2,6,5,3];</li>
    <li>ход 4: на предыдущем ходу Алиса съела 6, значит, Боб должен съесть 7 или более — Боб съест две конфеты суммарным размером 3+5=8 и последовательность конфет примет вид [5,9,2,6];</li>
    <li>ход 5: на предыдущем ходу Боб съел 8, значит, Алиса должна съесть 9 или более — на пятом ходу Алиса съест две конфеты суммарным размером 5+9=14 и последовательность конфет примет вид [2,6];</li>
    <li>ход 6 (последний): на предыдущем ходу Алиса съела 14, значит, Боб должен съесть 15 или более — это невозможно, поэтому Боб съест две оставшиеся конфеты и игра закончится.</li>
  </ul>
  <p>Выведите количество ходов в этой игре и два числа:</p>
  <ul>
    <li>a — суммарный размер всех конфет, съеденных Алисой за всю игру;</li>
    <li>b — суммарный размер всех конфет, съеденных Бобом за всю игру.</li>
  </ul>

  <h4>Входные данные</h4>
 <p>В первой строке записано целое число t (1 ≤ t ≤ 5000) — количество наборов входных данных. Далее следуют описания t наборов входных данных.</p>

  <p>Каждый набор состоит из двух строк. В первой строке содержится целое число n (1 ≤ n ≤ 1000) — количество конфет. Во второй строке содержится последовательность целых чисел a₁, a₂, …, aₙ (1 ≤ aᵢ ≤ 1000) — размеры конфет в порядке их расположения слева направо.</p>

  <p>Гарантируется, что сумма значений n по всем наборам входных данных в тесте не превосходит 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите три целых числа — количество ходов в игре и искомые величины a и b.</p>

  <details>
    <summary>Пример</summary>
<pre>
7
11
3 1 4 1 5 9 2 6 5 3 5
1
1000
3
1 1 1
13
1 2 3 4 5 6 7 8 9 10 11 12 13
2
2 1
6
1 1 1 1 1 1
7
1 1 1 1 1 1 1
</pre>
<pre>
6 23 21
1 1000 0
2 1 2
6 45 46
2 2 1
3 4 2
4 4 3
</pre>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1352/problem/D" target="_blank">Задача 1352D</a>
      <br><a href="https://codeforces.com/contest/1352" target="_blank">Codeforces Round 640 (Div. 4) 2020-05-09</a>
    </div>

    <p>Паттерн два указателя - левый pl и правый pr. Алиса и Боб по очереди делают ходы, пока правый pr >= pl. Подсчитываем число ходов, размер съеденных конфет.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

// условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // число конфет
    cin >> n;
    vector&lt;int&gt; A(n + 1);
    for (int i = 1; i &lt;= n; i++) {
      cin >> A[i];
    }

    // решение
    int pl = 1; // левый указатель
    int pr = n; // правый указатель
    int cnt = 0; // число ходов
    int a = 0; // размер всех конфет, которые съела Алиса
    int b = 0; // размер всех конфет, которые съел Боб
    int a_hod = 0; // размер конфет, которые съела Алиса за ход
    int b_hod = 0; // размер конфет, которые съел Боб за ход

    // пока есть конфеты
    while (pr >= pl) {

      // ход Алисы
      a_hod = 0;
      while ( (pr >= pl) && (b_hod >= a_hod) ) {
        a_hod += A[pl];
        pl++;
      }
      a += a_hod;
      cnt++;

      // ход Боба
      b_hod = 0;
      if (pr >= pl) {
        cnt++;
      }
      while ( (pr >= pl) && (a_hod >= b_hod) ) {
        b_hod += A[pr];
        pr--;
      }
      b += b_hod;

    }

    // вывод результата
    cout &lt;&lt; cnt &lt;&lt; ' ' &lt;&lt; a
         &lt;&lt; ' ' &lt;&lt; b  &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача E. Особые элементы -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Особые элементы</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 64мб</i></div>

  <p>Обратите внимание на нестандартное ограничение по памяти в этой задаче.</p>

  <p>С целью отсечения эффективных решений от неэффективных в этой задаче ограничение времени довольно строгое. Предпочтите использование компилируемых статически типизированных языков (например, C++). Если используете Python, то отсылайте решения на PyPy. Постарайтесь написать в самом деле эффективное решение.</p>

  <p>Задан массив a=[a₁, a₂, …, aₙ] (1 ≤ aᵢ ≤ n). Его элемент aᵢ называется особым, если существует такая пара индексов l и r (1 ≤ l &lt; r ≤n), что aᵢ = a<sub>l</sub> + a<sub>l+1</sub> + … + a<sub>r</sub>. Иными словами, элемент называется особым, если он представим в виде суммы двух или более подряд идущих элементов массива (не важно, особых или нет).</p>

  <p>Выведите количество особых элементов заданного массива a.</p>

  <p>Например, если n=9 и a=[3,1,4,1,5,9,2,6,5], то ответ равен 5:</p>
  <ul>
    <li>a3=4 — особый элемент, так как a3=4=a1+a2=3+1
  ;</li>
    <li>a5=5 — особый элемент, так как a5=5=a2+a3=1+4
  ;</li>
    <li>a6=9 — особый элемент, так как a6=9=a1+a2+a3+a4=3+1+4+1
  ;</li>
    <li>a8=6 — особый элемент, так как a8=6=a2+a3+a4=1+4+1;</li>
    <li>a9=5 — особый элемент, так как a9=5=a2+a3=1+4.</li>
  </ul>
  <p>Обратите внимание, что среди элементов массива a могут быть равные — если несколько элементов равны и являются особыми, то все они должны быть посчитаны в ответе.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое число t (1 ≤ t ≤ 1000) — количество наборов входных данных в тесте. Далее следуют описания t наборов входных данных.</p>

  <p>Каждый набор задается двумя строками. В первой строке записано целое число n (1 ≤ n ≤ 8000) — длина массива a. Во второй строке записаны целые числа a₁, a₂, …, aₙ (1 ≤ aᵢ ≤ n).</p>

  <p>Гарантируется, что сумма значений n по всем наборам входных данных не превосходит 8000.</p>

  <h4>Выходные данные</h4>
  <p>Выведите t чисел — количества особых элементов для каждого из заданных массивов.</p>

  <details>
    <summary>Пример</summary>
<pre>
5
9
3 1 4 1 5 9 2 6 5
3
1 1 2
5
1 1 1 1 1
8
8 7 6 5 4 3 2 1
1
1
</pre>
<pre>
5
1
0
4
0
</pre>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1352/problem/E" target="_blank">Задача 1352E</a>
      <br><a href="https://codeforces.com/contest/1352" target="_blank">Codeforces Round 640 (Div. 4) 2020-05-09</a>
    </div>

    <p>Заведем set сумм. В него будем записывать суммы соседних элементов от 1 до n. Перебираем все возможные суммы всех возможных длин и смотрим какие суммы мы можем получить. Начинаем с первого элемента входного массива, в сумме участвует два и более элементов. Поскольку элементы в массиве имеют значение от 1 до n, то сумму больше n можно уже не учитывать.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;set&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

// условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // размер массива
    cin >> n;
    vector&lt;int&gt; A(n + 1);
    for (int i = 1; i &lt;= n; i++) {
      cin >> A[i];
    }

    // решение
    int res = 0; // число особых элементов
    int pl = 1; // левый указатель
    int pr = pl + 1; // правый указатель

    // соберем set сумм
    set&lt;int&gt; Sum;

    while (pl &lt; n) {
      int sum = A[pl];
      pr = pl + 1;
      while ( (pr &lt; n + 1) && (sum + A[pr] &lt; n + 1) ) {
        sum += A[pr];
        pr++;
        Sum.insert(sum);
      }
      pl++;
    }

    // проверим элементы входного массива
    // если элемент есть в Sum, то увеличиваем res
    for (int i = 1; i &lt;= n; i++) {
      if (Sum.find(A[i]) != Sum.end()) {
        res++;
      }
    }

    // вывод результата
    cout &lt;&lt; res  &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача F. Восстановление 01-строки -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Восстановление 01-строки</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Для некоторой 01-строки s (то есть такой, что каждый символ sᵢ — это либо '0', либо '1') выписали все пары подряд идущих символов (все подстроки длины 2). Для каждой пары (подстроки длины 2) посчитали количество символов '1' (единиц) в ней.</p>

  <p>Вам заданы три числа:</p>
  <ul>
    <li>n₀ — количество пар подряд идущих символов (подстрок), в которых 0 единиц;</li>
    <li>n₁ — количество пар подряд идущих символов (подстрок), в которых 1 единица;</li>
    <li>n₂ — количество пар подряд идущих символов (подстрок), в которых 2 единицы.</li>
  </ul>
  <p>Например, для строки s=«1110011110» были бы выписаны следующие подстроки: «11», «11», «10», «00», «01», «11», «11», «11», «10». Таким образом, n₀ = 1, n₁ = 3, n₂ = 5.</p>

  <p>Ваша задача — по заданным n₀, n₁, n₂ восстановить любую подходящую 01-строку (бинарную строку) s. Гарантируется, что хотя бы одно из чисел n₀, n₁, n₂ отлично от 0. Также гарантируется, что решение существует.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое число t (1 ≤ t ≤ 1000) — количество наборов входных данных в тесте. Далее во входных данных записаны сами наборы.</p>

  <p>Каждый набор состоит из одной строки, которая содержит три целых числа n₀, n₁, n₂ (0 ≤ n₀, n₁, n₂ ≤ 100; n₀ + n₁ + n₂ > 0). Гарантируется, что ответ для заданных n₀, n₁, n₂ существует.</p>

  <h4>Выходные данные</h4>
  <p>Выведите t строк. Каждая из строк должна содержать ответ в виде 01-строки (бинарной строки) на соответствующий набор входных данных. Если возможных ответов несколько, выведите любой из них.</p>

  <details>
    <summary>Пример</summary>
<pre>
7
1 3 5
1 1 1
3 9 3
0 1 0
3 1 2
0 0 3
2 0 0
</pre>
<pre>
1110011110
0011
0110001100101011
10
0000111
1111
000
</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Создадим пустую строку s.</p>
    <p>Если есть пары 00, то запишем 0 в строку s и допишем столько нулей, сколько есть пар 00.</p>
    <p>Если есть пары 01 и строка s пустая, то запишем 0 в строку s чтобы получить первую пару 01. Если строка s уже не пустая, то она состоит из нулей и первый 0 для первой пары 01 дописывать не нужно. Будем дописывать по очереди 1 и 0 столько раз сколько есть пар 01.</p>
    <p>Если есть пары 11 и строка s пустая, то запишем 1 в строку s чтобы получить первую пару 11. Если строка s уже не пустая, то она должна заканчиваться на 1 и первую 1 для первой пары 11 дописывать не нужно. Допишем столько 1, сколько есть пар 11.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n0; // число пар без единиц
    int n1; // число пар с 1 единицей
    int n2; // число пар с 2 единицами
    cin >> n0 >> n1 >> n2;

    // решение
    string s;

    if (n0 > 0) {
      s += '0';
    }
    while (n0--) {
      s += '0';
    }

    if (n1 > 0 && s.size() == 0) {
      if (n1 % 2 == 0) {
        s += '1';
      } else {
        s += '0';
      }
    }
    while (n1--) {
      if (s[s.size() - 1] == '0') {
        s += '1';
      } else {
        s += '0';
      }
    }

    if (n2 > 0 && s.size() == 0) {
      s += '1';
      s += '1';
      n2--;
    }
    bool flag = false;
    if (n2 > 0 && s[s.size() - 1] == '0') {
      s[s.size() - 1] = '1';
      n2--;
      flag = true;
    }
    while (n2--) {
      s += '1';
    }
    if (flag) {
      s += '0';
    }


    // вывод результата
    cout &lt;&lt; s &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача G. Особая перестановка -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Особая перестановка</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Перестановкой длины n называется такой массив p = [p₁, p₂, …, pₙ], который содержит каждое число от 1 до n (включительно) и притом ровно по одному разу. Например, p = [3, 1, 4, 2, 5] — перестановка длины 5.</p>

  <p>Для заданного числа n (n ≥ 2) найдите такую перестановку p, в которой разница (то есть модуль разности) любых двух соседних элементов находится в диапазоне от 2 до 4, включительно. Формально, для перестановки p должно выполняться 2 ≤ | p<sub>i</sub> - p<sub>i+1</sub> | ≤ 4 для всех i (1 ≤ i &lt; n).</p>

  <p>Выведите любую такую перестановку для заданного значения n
  или определите, что ее не существует.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое число t (1 ≤ t ≤ 100) — количество наборов входных данных в тесте. Далее следуют описания t наборов входных данных.</p>

  <p>Каждый набор описывается единственной строкой, в которой содержится целое число n (2 ≤ n ≤ 1000).</p>

  <h4>Выходные данные</h4>
  <p>Выведите t строк. Очередная строка должна содержать -1, если для соответствующего набора входных данных искомой перестановки не существует. В противном случае выведите искомую перестановку. Если таких перестановок существует несколько, то выведите любую из них.</p>

  <details>
    <summary>Пример</summary>
<pre>
6
10
2
4
6
7
13
</pre>
<pre>
9 6 10 8 4 7 3 1 5 2
-1
3 1 4 2
5 3 6 2 4 1
5 1 3 6 2 4 7
13 9 7 11 8 4 1 3 5 2 6 10 12
</pre>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Если n &lt; 4, то такой перестановки не существует. Для остальных n выпишем сначала все нечетные числа по убыванию. Они закончатся числом 1. Потом выпишем все четные числа по возрастанию. Они начнутся с числа 2. Чтобы сохранить разность между соседними числами (от 2 до 4) поменяем местами числа 2 и 4.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
// условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // длина перестановки
    cin >> n;

    // решение
    if (n &lt; 4) {
      cout &lt;&lt; -1 &lt;&lt; '\n';
    } else {
      for (int i = n; i > 0; i--) {
        if (i % 2 == 1) {
          cout &lt;&lt; i &lt;&lt; ' ';
        }
      }
      cout &lt;&lt; 4 &lt;&lt; ' ' &lt;&lt; 2 &lt;&lt; ' ';
      for (int i = 6; i &lt;= n; i += 2) {
        cout &lt;&lt; i &lt;&lt; ' ';
      }
      cout &lt;&lt; '\n';
    }
  }

}
</pre>
  </details>
</article>

