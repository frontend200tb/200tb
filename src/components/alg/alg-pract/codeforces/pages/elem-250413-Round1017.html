<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p><a href="https://codeforces.com/group/CkAC2YcRrZ/contests" target="_blank">ЯрГУ. Кружок. Контесты</a></p>
  <p>Автор кружка Игорь Маслеников</p>
  <p><a href="https://codeforces.com/contest/2094" target="_blank">Codeforces Round 1017 (Div.4) 2025-04-13</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
        <a href="#task1">Задача A. Триппи Троппи</a>
    <br><a href="#task2">Задача B. Бобритто Бандито</a>
    <br><a href="#task3">Задача C. Брр Бррр Патапим</a>
    <br><a href="#task4">Задача D. Тунг Тунг Сахур</a>
    <br><a href="#task5">Задача E. Бонэка Амбалабу</a>
    <br><a href="#task6">Задача F. Трулимэро Труличина</a>
    <br><a href="#task7">Задача G. Шимпанзини Бананини</a>
  </p>
</article>


<!-- Задача A. Триппи Троппи -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Триппи Троппи</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Триппи Троппи живет в странном мире. Древнее название каждой страны состоит из трех слов. Первые буквы каждого слова объединяются, чтобы сформировать современное название страны.</p>

  <p>Дано древнее название страны, пожалуйста, выведите современное название.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t – количество независимых наборов входных данных (1 ≤ t ≤ 100).</p>

  <p>Следующие t строк содержат по три строки, разделенные пробелами. Каждая строка имеет длину не более 10 и содержит только строчные латинские буквы.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите строку, сформированную путем объединения первой буквы каждого слова.</p>

  <h4>Пример</h4>
<pre>
7
united states america
oh my god
i cant lie
binary indexed tree
believe in yourself
skibidi slay sigma
god bless america
</pre>
<pre>
usa
omg
icl
bit
biy
sss
gba
</pre>
</article>


<!-- Задача B. Бобритто Бандито -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Бобритто Бандито</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В родном городе Бобритто Бандито находится бесконечное количество домов на бесконечной числовой прямой, с домами на …,-2,-1,0,1,2,…. В день 0 он начал эпидемию, заразив несчастных жителей дома 0. Каждый следующий день эпидемия распространяется на ровно один здоровый дом, соседствующий с зараженным домом. Можно показать, что каждый день зараженные дома образуют непрерывный отрезок.</p>

  <p>Обозначим отрезок, начинающийся в l-м доме и заканчивающийся в r-м, как [l,r]. Вам известно, что спустя n дней оказался заражённым отрезок [l,r]. Найдите любой такой отрезок [l′,r′], что в m-й день (m≤n) мог быть заражён именно этот отрезок.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1≤t≤100) – количество независимых наборов входных данных.</p>

  <p>Единственная строка каждого набора содержит четыре целых числа n, m, l и r (1 ≤ m ≤ n ≤ 2000, -n ≤ l ≤ 0 ≤ r ≤ n, r-l = n).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите два целых числа l′ и r′ на новой строке. Если существует несколько решений, выведите любое.</p>

  <h4>Пример</h4>
<pre>
4
4 2 -2 2
4 1 0 4
3 3 -1 2
9 8 -6 3
</pre>
<pre>
-1 1
0 1
-1 2
-5 3
</pre>
</article>


<!-- Задача C. Брр Бррр Патапим -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Брр Бррр Патапим</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Брр Бррр Патапим пытается узнать секретный пароль Тирамису, который является перестановкой∗ из 2⋅n элементов. Чтобы помочь Патапиму угадать, Тирамису дал ему сетку nxn G, в которой G<sub>i,j</sub> (или элемент в i-й строке и j-м столбце сетки) содержит p<sub>i+j</sub>, или (i+j)-й элемент перестановки.</p>

  <p>Учитывая эту сетку, пожалуйста, помогите Патапиму разгадать забытый код. Гарантируется, что перестановка существует, и можно показать, что перестановка может быть определена однозначно.</p>

  <p>* Перестановка m целых чисел — это последовательность из m целых чисел, содержащая каждое из 1,2,…,m ровно один раз. Например, [1,3,2] и [2,1] являются перестановками, а [1,2,4] и [1,3,2,3] не являются.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t — количество наборов входных данных (1 ≤ t ≤ 200).</p>

  <p>Первая строка каждого набора входных данных содержит целое число n (1 ≤ n ≤ 800).</p>

  <p>Каждая из следующих n строк содержит по n целых чисел, представляющих сетку G. Первая из этих строк содержит G<sub>1,1</sub>,G<sub>1,2</sub>,…,G<sub>1,n</sub>; вторая из этих строк содержит G<sub>2,1</sub>,G<sub>2,2</sub>,…,G<sub>2,n</sub> и так далее. (1 ≤ G<sub>i,j</sub> ≤ 2⋅n).</p>

  <p>Гарантируется, что сетка кодирует действительную перестановку, и сумма n по всем наборам входных данных не превышает 800.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите 2n чисел в новой строке: p<sub>1</sub>, p<sub>2</sub>, ... , p<sub>2n</sub>.</p>

  <h4>Пример</h4>
<pre>
3
3
1 6 2
6 2 4
2 4 3
1
1
2
2 3
3 4
</pre>
<pre>
5 1 6 2 4 3
2 1
1 2 3 4
</pre>
</article>


<!-- Задача D. Тунг Тунг Сахур -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Тунг Тунг Сахур</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Перед вами стоят два барабана: левый и правый. Удар по левому можно записать как «L», а удар по правому как «R».</p>

  <p>Однако странные силы, которые правят этим миром, непостоянны: иногда удар звучит один раз, иногда он звучит дважды. Поэтому на самом деле удар по левому барабану мог прозвучать и как «L», и как «LL», а удар по правому барабану мог прозвучать и как «R», и как «RR».</p>

  <p>Последовательность совершённых ударов записали в строку p, а услышанные звуки в строку s. По данным p и s определите, правда ли, что строка s могла быть результатом ударов из строки p.</p>

  <p>Например, если p = «LR», то результатом ударов может быть любая из строк «LR», «LRR», «LLR» и «LLRR», а строки «LLLR» или «LRL» — нет.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10⁴) – количество независимых наборов входных данных.</p>

  <p>Первая строка каждого набора содержит строку p (1 ≤ |p| ≤ 2⋅10⁵), состоящую только из символов «R» и «L», |p| обозначает длину строки p.</p>

  <p>Вторая строка каждого набора содержит строку s (1 ≤ |p| ≤ |s| ≤ 2⋅10⁵), состоящую только из символов «R» и «L».</p>

  <p>Гарантируется, что сумма |s| не превышает 2⋅10⁵ по всем наборам входных данных.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите «YES», если s может быть услышанным звуком, и «NO» в противном случае. Вы можете выводить в любом регистре.</p>

  <h4>Пример</h4>
<pre>
5
R
RR
LRLR
LRLR
LR
LLLR
LLLLLRL
LLLLRRLL
LLRLRLRRL
LLLRLRRLLRRRL
</pre>
<pre>
YES
YES
NO
NO
YES
</pre>
</article>


<!-- Задача E. Бонэка Амбалабу -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Бонэка Амбалабу</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Бонэка Амбалабу предоставляет вам последовательность из n целых чисел a1,a2,…,an.</p>

  <p>Выведите максимальное значение (ak⊕a1) + (ak⊕a2) +…+ (ak⊕an) среди всех 1 ≤ k ≤ n. Обратите внимание, что ⊕ обозначает побитовую операцию XOR.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит целое число n (1 ≤ n ≤ 2⋅10⁵) — длина массива.</p>

  <p>Вторая строка каждого набора входных данных содержит n целых чисел a1, a2, ... , an (0 ≤ ai &lt; 2³⁰).</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите максимальное значение в отдельной строке.</p>

  <h4>Пример</h4>
<pre>
5
3
18 18 18
5
1 2 4 8 16
5
8 13 4 5 15
6
625 676 729 784 841 900
1
1
</pre>
<pre>
0
79
37
1555
0
</pre>
  <p>В первом наборе входных данных лучшее, что мы можем сделать, это (18⊕18)+(18⊕18)+(18⊕18)=0.</p>
  <p>Во втором наборе входных данных мы выбираем k = 5, чтобы получить (16⊕1)+(16⊕2)+(16⊕4)+(16⊕8)+(16⊕16)=79.</p>
</article>


<!-- Задача F. Трулимэро Труличина -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Трулимэро Труличина</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Труличина дает вам целые числа n, m и k. Гарантируется, что k≥2 и n⋅m≡0(modk).</p>

  <p>Выведите матрицу целых чисел размером n на m, так чтобы выполнялись все следующие критерии:</p>
  <ul>
    <li>Каждое число в матрице находится в диапазоне от 1 до k, включительно.</li>
    <li>Каждое число от 1 до k встречается в матрице одинаковое количество раз.</li>
    <li>Ни в каких двух ячейках, которые имеют общую сторону, не должно быть одинакового числа.</li>
  </ul>

  <p>Можно показать, что такая сетка всегда существует. Если существует несколько решений, выведите любое.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Единственная строка каждого набора содержит три целых числа n, m и k (2 ≤ n⋅m ≤ 2⋅10⁵, 2 ≤ k ≤ n⋅m, n⋅m ≡ 0(modk)).</p>

  <p>Гарантируется, что сумма n⋅m по всем наборам входных данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите n строк, каждая из которых содержит m чисел, которые удовлетворяют критериям. Если существует несколько решений, выведите любое.</p>

  <h4>Пример</h4>
<pre>
3
2 2 2
3 4 6
5 5 25
</pre>
<pre>
1 2
2 1
1 6 1 6
2 5 2 5
3 4 3 4
17 2 12 25 14
3 1 6 19 11
8 20 23 24 4
9 10 5 13 21
22 7 15 18 16
</pre>
</article>


<!-- Задача G. Шимпанзини Бананини -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Шимпанзини Бананини</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Шимпанзини Бананини стоит на пороге судьбоносной битвы — последней, где решится всё.</p>

  <p>Для произвольного массива b длины m обозначим риззинесс массива как</p>
  <code>∑ (от i=1 до m) bi⋅i = b1⋅1 + b2⋅2 + b3⋅3 +…+ bm⋅m</code>

  <p>Шимпанзини Бананини дарит вам пустой массив. Существует три типа операций, которые вы можете выполнить над ним.</p>
  <ol>
    <li>Выполнить циклический сдвиг массива. То есть, массив [a1,a2,…,an] становится [an,a1,a2,…,an-1].</li>
    <li>Развернуть весь массив. То есть, массив [a1,a2,…,an] становится [an,an-1,…,a1].</li>
    <li>Добавить элемент в конец массива. Массив [a1,a2,…,an] становится [a1,a2,…,an,k] после добавления k в конец массива.</li>
  </ol>

  <p>После каждой операции вас интересует вычисление риззинесса вашего массива.</p>

  <p>Обратите внимание, что все операции являются постоянными. Это означает, что каждая операция изменяет массив, и последующие операции должны применяться к текущему состоянию массива после предыдущих операций.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая строка входных данных содержит целое число q (1 ≤ q ≤ 2⋅10⁵) — количество операций, которые вы выполняете над своим массивом.</p>

  <p>Следующие q строк сначала содержат одно целое число s (1 ≤ s ≤ 3) — тип операции.</p>
  <ul>
    <li>Если s=1, то должна быть выполнена операция циклического сдвига.</li>
    <li>Если s=2, то должна быть выполнена операция разворота.</li>
    <li>Если s=3, то строка будет содержать дополнительное целое число k (1 ≤ k ≤ 10⁶), обозначающее элемент, добавляемый в конец массива.</li>
  </ul>

  <p>Гарантируется, что сумма q не превысит 2⋅10⁵ по всем наборам входных данных. Кроме того, гарантируется, что первая операция в каждом наборе входных данных будет с s=3.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите q строк, выводя риззинесс вашего массива после каждой операции.</p>

  <h4>Пример</h4>
<pre>
1
13
3 1
3 2
3 3
1
3 4
2
3 5
1
3 6
2
3 7
2
1
</pre>
<pre>
1
5
14
11
27
23
48
38
74
73
122
102
88
</pre>
  <p>Первые шесть состояний массива:</p>
  <ul>
    <li>[1]</li>
    <li>[1,2]</li>
    <li>[1,2,3]</li>
    <li>[3,1,2]</li>
    <li>[3,1,2,4]</li>
    <li>[4,2,1,3]</li>
  </ul>
</article>

