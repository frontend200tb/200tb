<article class="article">
  <a href="https://codeforces.com/contest/381" target="_blank">Codeforces 381 Round 223 (Div. 2) 2014-01-12</a>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

      <a href="#task1">Задача A. Сережа и Дима</a>
  <br><a href="#task2">Задача B. Сережа и лесенка</a>
  <br><a href="#task3">Задача C. Сережа и префиксы</a>
  <br><a href="#task4">Задача D. Сережа и дерево</a>
  <br><a href="#task5">Задача E. Сережа и скобочки</a>
</article>


<!-- Задача A. Сережа и Дима -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Сережа и Дима</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Сережа и Дима играют в игру. Правила игры очень просты. Перед игроками лежат в ряд n карточек. На каждой карточке написано число, причем все числа на карточках различны. Игроки ходят по очереди, первый ходит Сережа. На свой ход можно забрать себе одну карточку: либо самую левую карточку из ряда, либо самую правую. Игра заканчивается, когда в ряду не осталось карточек. Выигрывает тот, у кого в конце игры сумма чисел на взятых карточках больше.</p>

  <p>Сережа и Дима действуют жадно. На своем ходе, каждый из них из двух карточек выбирает ту, на которой написано большее число.</p>

  <p>Инна — подруга Сережи и Димы. Она знает какую стратегию используют ребята, поэтому хочет по изначальному состоянию игры определить, какой в конце игры будет счет. Помогите ей.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое число n (1 ≤ n ≤ 1000) — количество карточек на столе. Во второй строке через пробел перечислены числа, записанные на карточках, в порядке слева направо. Числа на карточках — различные целые числа от 1 до 1000.</p>

  <h4>Выходные данные</h4>
  <p>Выведите в единственной строке два целых числа. Первое число — это количество очков у Сережи в конце игры, второе — количество очков у Димы в конце игры.</p>

  <details>
    <summary>Примеры</summary>
  <h4>Пример 1</h4>
<pre>
4
4 1 2 10
</pre>
  <code>12 5</code>
  <p>В первом тесте Сережа возьмет карточки с числами 10 и 2, таким образом сумма Сережи 12. Дима возьмет все остальные карточки с суммой 5.</p>

  <h4>Пример 2</h4>
<pre>
7
1 2 3 4 5 6 7
</pre>
  <code>16 12</code>
  </details>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/381/problem/A" target="_blank">Задача 381A</a>
      <br><a href="https://codeforces.com/contest/381" target="_blank">Codeforces Round 223 (Div. 2) 2014-01-12</a>
    </div>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);

  // ввод данных
  int n;
  cin >> n;

  vector&lt;int&gt; A(n + 1);
  for (int i = 1; i &lt;= n; i++) {
    cin >> A[i];
  }

  // решение
  int s = 0, d = 0;
  int l = 1, r = n;

  while (r > l) {
    if (A[r] > A[l]) {
      s += A[r];
      r--;
    } else {
      s += A[l];
      l++;
    }
    if (A[r] > A[l]) {
      d += A[r];
      r--;
    } else {
      d += A[l];
      l++;
    }
  }

  if (r == l) {
    s += A[r];
  }

  // вывод результата
  cout &lt;&lt; s &lt;&lt; ' ' &lt;&lt; d;
}
</pre>
  </details>
</article>


<!-- Задача B. Сережа и лесенка -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Сережа и лесенка</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Сережа очень любит последовательности целых чисел. В особенности он любит последовательности лесенки.</p>

  <p>Последовательность a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>|a|</sub> (|a| — длина последовательности) называется лесенкой, если существует такой индекс i (1 ≤ i ≤ |a|), что выполяется соотношение:</p>
  <code>a<sub>1</sub> &lt; a<sub>2</sub> &lt; ... &lt; a<sub>i - 1</sub> &lt; a<sub>i</sub> > a<sub>i + 1</sub> > ... > a<sub>|a| - 1</sub> > a<sub>|a|</sub>.</code>

  <p>Например, последовательности [1, 2, 3, 2] и [4, 2] являются лесенками, а последовательность [3, 1, 2] — нет.</p>

  <p>У Сережи есть m карточек с числами. Он хочет выложить некоторые карточки на стол в ряд, чтобы получилась последовательность лесенка. Какое максимальное количество карточек, ему удастся выложить на стол?</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано целое m (1 ≤ m ≤ 10⁵) — количество карточек у Сережи. Во второй строке записаны m целых чисел bᵢ (1 ≤ bᵢ ≤ 5000) — числа на карточках, которые есть у Сережи.</p>

  <h4>Выходные данные</h4>
  <p>В первой строке выведите количество карточек, которое удастся выложить на стол. Во второй строке выведите саму лесенку, которая получится.</p>

  <details>
    <summary>Примеры</summary>
  <h4>Пример 1</h4>
<pre>
5
1 2 3 4 5
</pre>
<pre>
5
5 4 3 2 1
</pre>

  <h4>Пример 2</h4>
<pre>
6
1 1 2 2 3 3
</pre>
<pre>
5
1 2 3 2 1
</pre>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ввод данных
  int m;
  cin >> m;
  vector&lt;int&gt; B(m);
  for (int i = 0; i &lt; m; i++) {
    cin >> B[i];
  }

  // решение

  // собирам все числа не более 2 раз,
  vector&lt;int&gt; A(5001, 0);
  for (int i = 0; i &lt; m; i++) {
    if (A[B[i]] &lt; 2) {
      A[B[i]]++;
    }
  }

  // собираем результат от мин до макс
  vector&lt;int&gt; Res;
  for (int i = 0; i &lt; 5001; i++) {
    if (A[i] > 0) {
      Res.push_back(i);
      A[i]--;
    }
  }

  // удаляем лишний максимум
  A[Res[Res.size()-1]] = 0;

  // собираем результат от макс до мин
  for (int i = 5000; i > 0; i--) {
    if (A[i] > 0) {
      Res.push_back(i);
      A[i]--;
    }
  }

  // вывод результата
  cout &lt;&lt; Res.size() &lt;&lt; '\n';
  for (int i = 0; i &lt; Res.size(); i++) {
    cout &lt;&lt; Res[i] &lt;&lt; ' ';
  }
}
</pre>
  </details>
</article>


<!-- Задача C. Сережа и префиксы -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Сережа и префиксы</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Сережа очень любит числовые последовательности. Поэтому он решил сделать себе еще одну. Для этого он действует по следующему алгоритму.</p>

  <p>Сережа берет чистый листок бумаги. Далее он начинает выписывать последовательность в m этапов. Каждый раз он либо дописывает новое число в конец последовательности, либо берет l первых элементов текущей последовательности и дописывает их в конец c раз. Более формально, если обозначить текущую последовательность a1, a2, ..., an, то после применения описанной операции она превратится в a1, a2, ..., an[, a1, a2, ..., al] (блок, который выделен в квадратные скобки, нужно повторить c раз).</p>

  <p>Прошел день. Сережа уже построил последовательность. Теперь он хочет знать, чему равны некоторые ее элементы? Помогите Сереже.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число m (1 ≤ m ≤ 10⁵) — количество этапов для построения последовательности.</p>

  <p>Следующие m строк содержат описание этапов в порядке их следования. Первое число в строке — это тип этапа (1 или 2). Тип 1 обозначает добавление одного числа в конец последовательности, в этом случае далее в строке идет целое число xi (1 ≤ xi ≤ 10⁵) — число, которое нужно добавить. Тип 2 обозначает копирование префикса длины li в конец ci раз, в этом случае далее в строке идут два целых числа li, ci (1 ≤ li ≤ 10⁵, 1 ≤ ci ≤ 10⁴), li — длина префикса, ci — количество копирований. Гарантируется, что длина префикса li никогда не превышает текущей длины последовательности.</p>

  <p>Следующая строка содержит целое число n (1 ≤ n ≤ 10⁵) — количество элементов, которые интересуют Сережу. Следующая строка содержит номера интересующих Сережу элементов в полученной последовательности в строго возрастающем порядке. Гарантируется, что все числа строго больше нуля и не превосходят длины полученной последовательности. Считайте, что элементы итоговой последовательности пронумерованы, начиная от 1, от начала последовательности к концу.</p>

  <p>Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.</p>

  <h4>Выходные данные</h4>
  <p>Выведите интересующие Сережу элементы в порядке, в котором их номера следуют во входных данных.</p>

  <details>
    <summary>Пример</summary>
<pre>
6
1 1
1 2
2 2 1
1 3
2 5 2
1 4
16
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
</pre>
  <code>1 2 1 2 3 1 2 1 2 3 1 2 1 2 3 4</code>
  </details>
</article>


<!-- Задача D. Сережа и дерево -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Сережа и дерево</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Сережа очень любит деревья. Сегодня он придумал совершенно новый вид корневых бинарных деревьев.</p>

  <p>Новое дерево состоит из n уровней, а каждая вершина проиндексирована двумя целыми числами: номером уровня и номером вершины на текущем уровне. Корень дерева находится на уровне 1 и имеет индекс (1, 1). Далее следует псевдокод построения дерева.</p>
<pre>
//глобальные данные - целочисленные массивы cnt[], left[][], right[][]

cnt[1] = 1;
заполнить массивы left[][], right[][] значениями -1;
for(level = 1; level &lt; n; level = level + 1){
  cnt[level + 1] = 0;
  for (position = 1; position &lt;= cnt[level]; position = position + 1){
    if (значение position является степенью двойки){ // то есть 1, 2, 4, 8...
      left[level][position] = cnt[level + 1] + 1;
      right[level][position] = cnt[level + 1] + 2;
      cnt[level + 1] = cnt[level + 1] + 2;
    } else {
      right[level][position] = cnt[level + 1] + 1;
      cnt[level + 1] = cnt[level + 1] + 1;
    }
  }
}
</pre>

  <p>После выполнения псевдокода в ячейке cnt[level] хранится количество вершин на уровне level. В ячейке left[level][position] хранится номер вершины на уровне level + 1, которая является левым сыном вершины с индексом (level, position), или хранится -1, если левого сына у вершина нет. Аналогично, ячейка right[level][position] отвечает за правого сына. В примечаниях можно посмотреть, как выглядит дерево, для n = 4.</p>

  <p>Сережа любит все усложнять, поэтому сначала Сережа построил дерево, а потом для каждой вершины дерева Сережа завел пустое множество A(level, position). Далее Сережа выполняет m операций. Каждая операция имеет один из двух следующих видов:</p>
  <ul>
    <li>Формат операции «1 t l r x». Для всех вершин level, position (level = t; l ≤ position ≤ r) добавить значение x в множество A(level, position).</li>
    <li>Формат операции «2 t v». Для вершины level, position (level = t, position = v) найти объединение всех множеств вершин, находящихся в поддереве вершины (level, position). Вывести размер объединения этих множеств.</li>
  </ul>

  <p>Помогите Сереже выполнить операции. В этой задаче считается, что множество содержит в себе различные элементы как std::set в C++.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целые числа n и m (1 ≤ n, m ≤ 7000).</p>

  <p>Следующие m строк содержат описания операций. Операция первого типа задается пятью целыми числами: 1 t l r x (1 ≤ t ≤ n; 1 ≤ l ≤ r ≤ cnt[t]; 1 ≤ x ≤ 10⁶). Операция второго типа задается тремя целыми числами: 2 t v (1 ≤ t ≤ n; 1 ≤ v ≤ cnt[t]).</p>

  <h4>Выходные данные</h4>
  <p>Для каждой операции второго типа выведите ответ в отдельной строке.</p>

  <details>
    <summary>Пример</summary>
<pre>
4 5
1 4 4 7 1
1 3 1 2 2
2 1 1
2 4 1
2 3 3
</pre>
<pre>
2
0
1
</pre>
  </details>
</article>


<!-- Задача E. Сережа и скобочки -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Сережа и скобочки</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У Сережи есть скобочная последовательность s1, s2, ..., sn, или, другими словами, строка s длины n, состоящая из символов «(» и «)».</p>

  <p>Сереже нужно ответить на m запросов, каждый из которых характеризуется двумя целыми числами li, ri (1 ≤ li ≤ ri ≤ n). Ответом на i-ый запрос является длина наибольшей правильной скобочной подпоследовательности последовательности sli, sli + 1, ..., sri. Помогите Сереже ответить на все запросы.</p>

  <p>Определения подпоследовательности и правильной скобочной последовательности смотрите в примечаниях.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит последовательность символов без пробелов s1, s2, ..., sn (1 ≤ n ≤ 10⁶). Каждый символ это либо «(», либо «)». Вторая строка содержит целое число m (1 ≤ m ≤ 10⁵) количество запросов. Каждая из следующих m строк содержит пару целых чисел. В i-ой строке записаны числа li, ri (1 ≤ li ≤ ri ≤ n) — описание i-го запроса.</p>

  <h4>Выходные данные</h4>
  <p>Выведите ответ на каждый запрос в отдельной строке. Ответы выводите в порядке следования запросов во входных данных.</p>

  <details>
    <summary>Пример</summary>
<pre>
())(())(())(
7
1 1
2 3
1 2
1 12
8 12
5 11
2 10
</pre>
<pre>
0
0
2
10
4
6
6
</pre>
  <p>Подпоследовательностью длины |x| строки s = s1s2... s|s| (где |s| — длина строки s) называется строка</p>
  <code>x = sk1sk2... sk|x| (1 ≤ k1 &lt; k2 &lt; ... &lt; k|x| ≤ |s|).</code>
  <p>Правильной скобочной последовательностью называется скобочная последовательность, которую можно преобразовать в корректное арифметическое выражение путем вставок между ее символами символов «1» и «+». Например, скобочные последовательности «()()», «(())» — правильные (полученные выражения: «(1)+(1)», «((1+1)+1)»), а «)(» и «(» — нет.</p>
  <p>Для третьего запроса искомая последовательность будет «()».</p>
  <p>Для четвертого запроса искомая последовательность будет «()(())(())».</p>
  </details>
</article>

