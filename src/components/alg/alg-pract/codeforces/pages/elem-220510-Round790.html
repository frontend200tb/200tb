<article class="article">
  <a href="https://codeforces.com/contest/1676" target="_blank">Codeforces Round 790 (Div. 4) 2022-05-10</a>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

      <a href="#task1">Задача A. Счастливый?</a>
  <br><a href="#task2">Задача B. Равенство конфет</a>
  <br><a href="#task3">Задача C. Самые похожие слова</a>
  <br><a href="#task4">Задача D. X-сумма</a>
  <br><a href="#task5">Задача E. Запросы на поедание конфет</a>
  <br><a href="#task6">Задача F. Самый длинный страйк</a>
  <br><a href="#task7">Задача G. Чёрно-белые сбалансированные поддеревья</a>
  <br><a href="#task8">Задача H1. Максимизация пересечений (простая версия)</a>
  <br><a href="#task9">Задача H2. Максимизация пересечений (сложная версия)</a>
</article>


<!-- Задача A. Счастливый? -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Счастливый?</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Номер билета — это строка, которая состоит ровно из шести цифр. Номер билета является счастливым, если сумма первых трёх цифр равна сумме последних трёх цифр. Задан номер билета, проверьте счастливый он или нет. Обратите внимание, что в номере могут быть лидирующие нули.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит целое число t (1 ≤ t ≤ 10³) — количество наборов входных данных в тесте.</p>

  <p>Далее следуют описания наборов, каждый из них — это одна строка, которая содержит шесть цифр.</p>

  <h4>Выходные данные</h4>
  <p>Выведите t строк, которые содержат ответы. Выводите:</p>
  <ul>
    <li>YES, если соответствующий номер билета счастливый;</li>
    <li>NO в противном случае.</li>
  </ul>
  <p>Вы можете выводить YES и NO в любом регистре (например, строки yEs, yes, Yes и YES будут распознаны как положительный ответ).</p>

  <h4>Пример</h4>
<pre>
5
213132
973894
045207
000000
055776
</pre>
<pre>
YES
NO
YES
YES
NO
</pre>
  <p>В первом наборе входных данных примера сумма первых трёх цифр равна 2+1+3=6, сумма последних трёх цифр равна 1+3+2=6. Суммы равны. Следовательно, ответ равен «YES».</p>

  <p>Во втором наборе входных данных примера сумма первых трёх цифр равна 9+7+3=19, сумма последних трёх цифр равна 8+9+4=21. Суммы не равны. Следовательно, ответ равен «NO».</p>

  <p>В третьем наборе входных данных примера сумма первых трёх цифр равна 0+4+5=9, сумма последних трёх цифр равна 2+0+7=9. Суммы равны. Следовательно, ответ равен «YES».</p>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1676/problem/A" target="_blank">Задача 1676А</a>
      <br><a href="https://codeforces.com/contest/1676" target="_blank">Codeforces Round 790 (Div. 4) 2022-05-10</a>
    </div>

    <h4>Идея решения:</h4>
    <p>Для каждого набора входных данных:</p>
    <ol>
      <li>Разделяем номер билета на первые три цифры и последние три цифры.</li>
      <li>Вычисляем сумму первых трёх цифр и сумму последних трёх цифр.</li>
      <li>Если суммы равны, выводим "YES", иначе — "NO".</li>
    </ol>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int t;
  cin >> t;

  for (int test = 0; test &lt; t; test++) {
    int num;
    cin >> num;

    // решение
    int sum1 = 0;
    for (int i = 0; i &lt; 3; i++) {
      sum1 += num % 10;
      num /= 10;
    }
    int sum2 = 0;
    for (int i = 0; i &lt; 3; i++) {
      sum2 += num % 10;
      num /= 10;
    }

    // вывод результата
    if (sum1 == sum2) {
      cout &lt;&lt; "YES\n";
    } else {
      cout &lt;&lt; "NO\n";
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача B. Равенство конфет -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Равенство конфет</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Есть n коробок конфет, i-я коробка содержит ai конфет.</p>

  <p>У вас также есть n друзей, каждому из которых вы решили подарить коробку конфет. Вы не хотите, чтобы кто-то из друзей расстраивался, поэтому решили съесть несколько (возможно, ноль) конфет из каждой коробки так, чтобы во всех коробках было одинаковое количество конфет. Обратите внимание, что вы можете съесть разное количество конфет из разных коробок, и вы не можете добавлять конфеты ни в одну из коробок.</p>

  <p>Какое минимальное количество конфет нужно съесть, чтобы выполнить требования?</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 1000) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора содержит целое число n (1 ≤ n ≤ 50) — количество коробок конфет, которые у вас есть.</p>

  <p>Вторая строка каждого набора содержит n целых чисел a1,a2,…,an (1 ≤ ai ≤ 10⁷) — количество конфет в каждой коробке.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите единственное целое число — минимальное количество конфет, которые вам нужно съесть, чтобы выполнить требования.</p>

  <h4>Пример</h4>
<pre>
5
5
1 2 3 4 5
6
1000 1000 5 1000 1000 1000
10
1 2 3 5 1 2 7 9 13 5
3
8 8 8
1
10000000
</pre>
<pre>
10
4975
38
0
0
</pre>
  <p>В первом наборе вы можете съесть 1 конфету из второй коробки, 2 конфеты из третьей коробки, 3 конфеты из четвертой коробки и 4 конфеты из пятой коробки. Теперь распределение конфет по коробкам выглядит так: [1,1,1,1,1]. Вы съели всего 0+1+2+3+4=10 конфет, поэтому ответ равен 10.</p>
  <p>Лучший ответ для второго набора получается, если уменьшить количество конфет во всех коробках до 5. Так, вы съедите 995+995+0+995+995+995=4975 конфет.</p>
</article>


<!-- Задача C. Самые похожие слова -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Самые похожие слова</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам даны n слов одинаковой длины m, состоящие из строчных букв латинского алфавита, i-е слово обозначается si.</p>

  <p>За один ход вы можете выбрать любую позицию в любом отдельном слове и заменить букву в этой позиции на предыдущую или следующую букву в алфавитном порядке. Например:</p>
  <ul>
    <li>вы можете заменить 'e' на 'd' или на 'f';</li>
    <li>'a' может быть заменена только на 'b';</li>
    <li>'z' может быть заменена только на 'y'.</li>
  </ul>
  <p>Разница между двумя словами — это минимальное число ходов, необходимое для того, чтобы сделать их равными. Например, разница между «best» и «cost» составляет 1+10+0+0=11.</p>
  <p>Найдите минимальную разницу между si и sj такую, что (i &lt; j). Другими словами, найдите минимальную разницу по всем возможным парам из n слов.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит единственное целое число t (1 ≤ t ≤ 100) — количество наборов входных данных. Далее следуют описания наборов.</p>

  <p>Первая строка каждого набора содержит 2 целых числа n и m (2 ≤ n ≤ 50, 1 ≤ m ≤ 8) — количество слов и их длина соответственно.</p>

  <p>Затем следуют n строк, i-я из которых содержит слово si длины m, состоящее из строчных латинских букв.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно целое число — минимальную разница среди всех возможных пар заданных строк.</p>

  <h4>Пример</h4>
<pre>
6
2 4
best
cost
6 3
abb
zba
bef
cdu
ooo
zzz
2 7
aaabbbc
bbaezfe
3 2
ab
ab
ab
2 8
aaaaaaaa
zzzzzzzz
3 1
a
u
y
</pre>
<pre>
11
8
35
0
200
4
</pre>
  <p>Для второго набора входных данных можно показать, что наилучшей парой является («abb», «bef»), которая имеет разницу, равную 8, что можно получить следующим образом: заменить первый символ первой строки на 'b' за один ход, заменить второй символ второй строки на 'b' за 3 хода и заменить третий символ второй строки на 'b' за 4 хода, что в сумме дает 1+3+4=8 ходов.</p>
  <p>В третьем наборе существует только одна возможная пара, и можно показать, что минимальное количество ходов, необходимое для того, чтобы строки стали равными, равно 35.</p>
  <p>В четвертом наборе есть пара строк, которые уже равны, поэтому ответ равен 0.</p>
</article>


<!-- Задача D. X-сумма -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. X-сумма</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Дедушка Тимура подарил ему шахматную доску, чтобы он попрактиковался. Эта доска a состоит из n строк и m столбцов. На каждой клетке написано неотрицательное целое число.</p>
  <p>Задача Тимура поставить слона так, чтобы сумма на клетках, атакованных им, была максимальна. Слон атакует во всех направлениях по диагонали. Расстояние, на которое атакует слон, не ограничено. Обратите внимание, что клетка, в которой стоит слон, также считается атакованной. Помогите ему найти максимальную сумму, которую он может получить.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит число t (1 ≤ t ≤ 1000) — количество наборов входных данных в тесте. Далее следуют описания самих наборов.</p>
  <p>Первая строка каждого набора содержит два числа n и m (1 ≤ n ≤ 200, 1 ≤ m ≤ 200).</p>
  <p>Следующие n строк содержат по m целых чисел, j-й элемент i-й строки a<sub>ij</sub> — это число, записанное в j-й клетке i-й строки (0 ≤ a<sub>ij</sub> ≤ 10⁶)</p>
 <p>Гарантируется, что сумма n⋅m по всем наборам не превосходит 4⋅10⁴.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно число — максимальную сумму по всем возможным размещениям слона.</p>

  <h4>Пример</h4>
<pre>
4
4 4
1 2 2 1
2 4 2 4
2 2 3 1
2 4 2 4
2 1
1
0
3 3
1 1 1
1 1 1
1 1 1
3 3
0 1 1
1 0 1
1 1 0
</pre>
<pre>
20
1
5
3
</pre>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1676/problem/D" target="_blank">Задача 1676D</a>
      <br><a href="https://codeforces.com/contest/1676" target="_blank">Codeforces Round 790 (Div. 4) 2022-05-10</a>
    </div>

    <p>Создадим массив B размером такой же как входной массив A. В клетку B[i] будем записывать сумму из клеток массива A на диагоналях которой она находится.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // входные данные
  int t;
  cin >> t;

  while (t--) {
    int n, m;
    cin >> n >> m;

    vector&lt;vector&lt;int&gt; &gt; A(n, vector&lt;int&gt;(m));
    for (int i = 0; i &lt; n; i++) {
      for (int j = 0; j &lt; m; j++) {
        cin >> A[i][j];
      }
    }

  // решение
    vector&lt;vector&lt;int&gt; &gt; B(n, vector&lt;int&gt;(m));
    // смещение на одну клетку
    int x = 1;
    int res = 0;
    for (int i = 0; i &lt; n; i++) {
      for (int j = 0; j &lt; m; j++) {
        int sum = A[i][j];
        // влево вверх
        x = 1;
        while ((i - x >= 0) && (j - x >= 0)) {
          sum += A[i - x][j - x];
          x++;
        }
        // вправо вверх
        x = 1;
        while ((i - x >= 0) && (j + x &lt; m)) {
          sum += A[i - x][j + x];
          x++;
        }
        // вправо вниз
        x = 1;
        while ((i + x &lt; n) && (j + x &lt; m)) {
          sum += A[i + x][j + x];
          x++;
        }
        // влево вниз
        x = 1;
        while ((i + x &lt; n) && (j - x >= 0)) {
          sum += A[i + x][j - x];
          x++;
        }
        B[i][j] = sum;
        res = max(res, B[i][j]);
      }
    }

  // вывод результата
  cout &lt;&lt; res &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача E. Запросы на поедание конфет -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Запросы на поедание конфет</h3>

  <div><i>Ограничение по времени 3.5с
  <br>Ограничение по памяти 256мб</i></div>

  <p>У Тимура есть n конфет. В i-й конфете количество сахара равно a<sub>i</sub>. Так, съев i-ю конфету, Тимур потребляет количество сахара, равное a<sub>i</sub>.</p>

  <p>Тимур задаст вам q запросов о своих конфетах. Для j-го запроса вы должны ответить, какое минимальное количество конфет ему нужно съесть, чтобы потребить количество сахара, большее или равное x<sub>j</sub>. Выведите -1, если невозможно получить такое количество. Другими словами, нужно вывести минимально возможное k такое, что, съев k конфет, Тимур получит количество сахара не менее x<sub>j</sub>, или сказать, что такого k не существует.</p>

  <p>Обратите внимание, что он не может съесть одну и ту же конфету дважды, а запросы не зависят друг от друга (Тимур может использовать одну и ту же конфету в разных запросах).</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит единственное целое число t (1 ≤ t ≤ 1000)  — количество наборов входных данных. Далее следуют описания наборов.</p>

  <p>Первая строка каждого набора содержит 2 целых числа n и q (1 ≤ n, q ≤ 1.5⋅10<sup>5</sup>) — количество конфет, которые есть у Тимура и количество запросов соответственно.</p>

  <p>Вторая строка каждого набора содержит n целых чисел a<sub>1</sub>,a<sub>2</sub>,…,a<sub>n</sub> (1≤a<sub>i</sub>≤10<sup>4</sup>) — количество сахара в каждой конфете соответственно.</p>

  <p>Затем следуют q строк.</p>

  <p>Каждая из q содержит единственное целое число x<sub>j</sub> (1≤x<sub>j</sub>≤2⋅10<sup>9</sup>) — количество сахара, которое хочет получить Тимур.</p>

  <p>Гарантируется, что сумма n и сумма q по всем наборам входных данных не превосходит 1.5⋅10<sup>5</sup>.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите q строк. В j-й строке выведите количество конфет, которое нужно съесть Тимуру, чтобы получить количество сахара, большее или равное x<sub>j</sub>. Выведите -1, если получить такое количество невозможно.</p>

  <h4>Пример</h4>
<pre>
3
8 7
4 3 3 1 1 4 5 9
1
10
50
14
15
22
30
4 1
1 2 3 4
3
1 2
5
4
6
</pre>
<pre>
1
2
-1
2
3
4
8
1
1
-1
</pre>
  <p>В первом наборе входных данных примера:</p>
  <ul>
    <li>В первом запросе Тимур может съесть любую конфету, и он наберет нужное количество.</li>
    <li>Во втором запросе Тимур может получить количество не менее 10, съев 7-ю и 8-ю конфету, таким образом потребив количество сахара, равное 14.</li>
    <li>На третий запрос нет возможного ответа.</li>
    <li>В четвертом запросе Тимур может получить количество как минимум 14, съев 7-ю и 8-ю конфету, таким образом потребив количество сахара, равное 14.</li>
  </ul>

  <p>Во втором наборе входных данных примера:</p>
  <ul>
    <li>Для единственного запроса второго набора входных данных мы можем выбрать третью конфету, из которой Тимур получает количество сахара равное 3. Также можно получить тот же ответ, выбрав четвертую конфету.</li>
  </ul>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1676/problem/E" target="_blank">Задача 1676E</a>
      <br><a href="https://codeforces.com/contest/1676" target="_blank">Codeforces Round 790 (Div. 4) 2022-05-10</a>
    </div>

    <p>Создадим префикс-функцию идя по массиву в убывающем порядке</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n, q;
    cin >> n >> q;
    vector&lt;int&gt; A(n + 1);
    for (int i = 0; i &lt; n; i++) {
      cin >> A[i];
    }

    // решение
    sort(A.begin(), A.end());
    int uk = n;
    vector&lt;int&gt; Pref(n + 1);
    for (int i = 1; i &lt;= n; i++) {
      Pref[i] = Pref[i - 1] + A[uk];
      uk--;
    }

    int x, left, right, mid;
    for (int i = 0; i &lt; q; i++) {
      cin >> x;
      left = 0;
      right = n + 1;

      while (right - left > 1) {
        mid = (right + left) / 2;
        if (Pref[mid] &lt;= x) {
          left = mid;
        } else {
          right = mid;
        }
      }

      // вывод результата
      if (Pref[Pref.size() - 1] &lt; x) {
        cout &lt;&lt; "-1\n";
      } else if (Pref[left] >= x) {
        cout &lt;&lt; left &lt;&lt; "\n";
      } else {
        cout &lt;&lt; right &lt;&lt; "\n";
      }
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача F. Самый длинный страйк -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Самый длинный страйк</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Дан массив a длины n и целое число k, вам нужно найти два любых числа l и r (l ≤ r) таких, что:</p>
  <ul>
    <li>Для каждого x (l ≤ x ≤ r), x содержится в a хотя бы k раз (т.е. k или более элементов массива равны x).</li>
    <li>Значение r-l максимально среди возможных.</li>
  </ul>
  <p>Если не существует подходящих чисел, выведите -1.</p>
  <p>Например, если a=[11,11,12,13,13,14,14] и k=2, то:</p>
  <ul>
    <li>для l=12, r=14 первое условие не выполнено, так как 12 содержится менее k=2 раз.</li>
    <li>для l=13, r=14 первое условие выполнено, так как 13 содержится хотя бы k=2 раз в a и 14 содержится хотя бы k=2 раз в a.</li>
    <li>для l=11, r=11 первое условие выполнено, так как 11 содержится хотя бы k=2 раз в a.</li>
  </ul>

  <p>Пара l и r для которой выполнено первое условие и r-l максимально — это пара l=13, r=14.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит единственное целое число t (1 ≤ t ≤ 1000) — количество наборов входных данных. Затем следуют описания наборов.</p>

  <p>Первая строка каждого набора содержит целые числа n и k (1 ≤ n ≤ 2⋅10⁵, 1 ≤ k ≤ n) — длина массива a и минимальное количество раз, которое должно встретиться каждое число в диапазоне [l,r], соответственно.</p>

  <p>Затем следует единственная строка, состоящая из n целых чисел — элементов массива a (1 ≤ ai ≤ 10⁹).</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превосходит 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите 2 числа, l и r которые удовлетворяют условиям, или «-1» если таких не существует.</p>

  <p>Если ответов может быть несколько, выведите любой.</p>

  <h4>Пример</h4>
<pre>
4
7 2
11 11 12 13 13 14 14
5 1
6 3 5 2 1
6 4
4 3 4 3 3 4
14 2
1 1 2 2 2 3 3 3 3 4 4 4 4 4
</pre>
<pre>
13 14
1 3
-1
1 4
</pre>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;map&gt;

using namespace std;

int main() {
  // ускорение ввода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n, k;
    cin >> n >> k;
    vector&lt;int&gt; A(n); // входной массив
    map&lt;int, int&gt; Freq; // частотный словарь
    // соберем входной массив и частотный словарь
    for (int i = 0; i &lt; n; i++) {
      cin >> A[i];
      Freq[A[i]]++;
    }

    // соберем массив с числами которых >= k
    vector&lt;int&gt; B;
    for (auto p : Freq) {
      if (p.second >= k) {
        B.push_back(p.first);
      }
    }

    if (B.size() == 0) {
      // если чисел которых >= k нет
      cout &lt;&lt; -1 &lt;&lt; '\n';
    } else {
      int l = B[0];
      int r = B[0];
      int tmp = B[0];
      int maxlr = 0; // максимальное расстояние между l и r

      // найдем l и r
      for (int i = 1; i &lt; B.size(); i++) {

        // проверим что числа идут подряд
        if (B[i] - B[i - 1] == 1) {

          // если да, то двигаем правую границу
          if (B[i] - tmp > maxlr) {
            l = tmp;
            r = B[i];
            maxlr = B[i] - tmp;
          }
        } else {
          // если нет, то двигаем левую границу
          tmp = B[i];
        }
      }
      // вывод результата
      cout &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; '\n';
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача G. Чёрно-белые сбалансированные поддеревья -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Чёрно-белые сбалансированные поддеревья</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам дано подвешенное дерево из n вершин, пронумерованных от 1 до n. Корнем является вершина 1. Также есть строка s, задающая цвета всех вершин: если si=B, то вершина i чёрная, а если si=W, то вершина i белая.</p>

  <p>Поддерево дерева называется сбалансированным, если количество белых вершин поддерева равняется количеству чёрных вершин поддерева. Посчитайте количество сбалансированных поддеревьев.</p>

  <p>На картинке дерево при n=7, a=[1,1,2,3,3,5] и s=WBBWWBW. Поддерево вершины 3 сбалансированно.</p>

  <p>Дерево — это связный граф без циклов. Подвешенное дерево — это дерево с выбранной вершиной, которую называют корнем. В этой задаче корнем каждого дерева является вершина 1.</p>

  <p>Дерево описано массивом предков a2,…,an, содержащим n-1 число: ai — предок вершины с номером i для всех i=2,…,n. Предок вершины u это следующая вершина на простом пути от u к корню. Поддерево вершины u — это множество всех вершин, которые содержат u в пути к корню. Например на картинке выше, 7 в поддереве у 3, потому что простой путь 7→5→3→1 проходит через 3. Обратите внимание, что сама вершина входит в своё поддерево, и поддеревом корня является всё дерево.</p>

  <h4>Входные данные</h4>
  <p>Первая строка входных данных содержит число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора содержит число n (2 ≤ n ≤ 4000) — количество вершин в дереве.</p>

  <p>Вторая строка каждого набора содержит n-1 число a2, … , an (1 ≤ ai &lt; i) — родители вершин 2,…,n.</p>

  <p>Третья строка каждого набора содержит строку s длины n, состоящую из символов B и W — раскраска дерева.</p>

  <p>Гарантируется, что сумма n по всем наборам не превосходит 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно число — количество сбалансированных поддеревьев.</p>

  <h4>Пример</h4>
<pre>
3
7
1 1 2 3 3 5
WBBWWBW
2
1
BW
8
1 2 3 4 5 6 7
BWBWBWBW
</pre>
<pre>
2
1
4
</pre>
  <p>Первый пример изображён в условии. Только поддеревья вершин 2 и 3 сбалансированны.</p>
  <p>Во втором примере только поддерево вершины 1 сбалансированно.</p>
  <p>в третьем примере сбалансированны поддеревья вершин 1, 3, 5 и 7.</p>
</article>


<!-- Задача H1. Максимизация пересечений (простая версия) -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H1. Максимизация пересечений (простая версия)</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Единственная разница между двумя версиями состоит в том, что в этой версии n≤1000 и сумма значений n по всем наборам входных данных теста не превосходит 1000.</p>
  <p>Терминал — это ряд без промежутков из n равных отрезков, пронумерованных от 1 до n по порядку. Есть два терминала, один над другим.</p>
  <p>Вам дан массив a длины n. Для всех i=1,2,…,n должен быть прямой провод из некоторой точки на отрезке i верхнего терминала в некоторую точку на отрезке a<sub>i</sub> нижнего терминала. Например, на следующих рисунках показаны два возможных соединения, при n=7 и a=[4,1,4,6,7,7,5].</p>
  <p>Пересечение происходит, когда два провода имеют общую точку. На картинке выше пересечения обведены красным.</p>
  <p>Какое максимальное количество пересечений может быть при оптимальном размещении проводов?</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 1000) — количество наборов входных данных.</p>
  <p>Первая строка каждого набора содержит целое число n (1 ≤ n ≤ 1000) — длина массива.</p>
  <p>Вторая строка каждого набора содержит n целых чисел a₁,a₂, .. , aₙ (1 ≤ aᵢ ≤ n) — элементы массива.</p>
  <p>Сумма n по всем наборам входных данных не превосходит 1000.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора выведите единственное целое число — максимальное количество пересечений, при оптимальном расположении проводов.</p>

  <h4>Пример</h4>
<pre>
4
7
4 1 4 6 7 7 5
2
2 1
1
1
3
2 2 2
</pre>
<pre>
6
1
0
3
</pre>
  <p>Первый пример показан на втором рисунке в условии.</p>
  <p>Во втором примере при единственно возможном соединении появляется пересечение двух проводов, поэтому ответ равен 1.</p>
  <p>В третьем тестовом примере единственно возможное соединение состоит из одного провода, поэтому ответ равен 0.</p>

  <details>
    <summary>Решение</summary>

    <div>
      <a href="https://codeforces.com/contest/1676/problem/H1" target="_blank">Задача 1676H1</a>
      <br><a href="https://codeforces.com/contest/1676" target="_blank">Codeforces Round 790 (Div. 4) 2022-05-10</a>
    </div>

    <ul>
      <li>У нас есть два терминала: верхний и нижний.</li>
      <li>Каждый провод соединяет отрезок i на верхнем терминале с отрезком a[i] на нижнем терминале.</li>
      <li>Пересечение проводов происходит, если два провода имеют общую точку.</li>
      <li>Нам нужно найти максимальное количество пересечений при оптимальном расположении проводов.</li>
    </ul>
    <p>Максимальное количество пересечений достигается, когда провода расположены таким образом, что их порядок на нижнем терминале является обратным к порядку на верхнем терминале. То есть, если провода на верхнем терминале идут в порядке 1, 2, 3, ..., n, то на нижнем терминале они должны идти в порядке a[1], a[2], ..., a[n], и количество пересечений будет равно количеству инверсий в массиве a.</p>

    <p>Однако, если в массиве a есть повторяющиеся элементы (например, a = [2, 2, 2]), то провода, идущие в один и тот же отрезок на нижнем терминале, не пересекаются. Поэтому для таких случаев нужно учитывать, что провода, идущие в один и тот же отрезок, можно расположить так, чтобы они не пересекались.</p>

    <p>Подсчитаем количество инверсий в массиве a. Это даст нам количество пересечений, если все провода идут в разные отрезки на нижнем терминале.</p>

    <p>Если в массиве есть повторяющиеся элементы, то для каждого повторяющегося элемента x добавим количество способов расположить провода, идущие в x, так, чтобы они не пересекались. Это количество равно количеству сочетаний из k по 2, где k — количество вхождений x в массив a.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;algorithm&gt;

using namespace std;

// Функция для подсчета инверсий с использованием сортировки слиянием
long long mergeAndCount(vector&lt;int&gt;& arr, vector&lt;int&gt;& temp, int left, int mid, int right) {
  int i = left;
  int j = mid + 1;
  int k = left;
  long long invCount = 0;

  while (i &lt;= mid && j &lt;= right) {
    if (arr[i] &lt;= arr[j]) {
      temp[k++] = arr[i++];
    } else {
      temp[k++] = arr[j++];
      invCount += (mid - i + 1);
    }
  }

  while (i &lt;= mid) {
    temp[k++] = arr[i++];
  }

  while (j &lt;= right) {
    temp[k++] = arr[j++];
  }

  for (i = left; i &lt;= right; i++) {
    arr[i] = temp[i];
  }

  return invCount;
}

long long countInversions(vector&lt;int&gt;& arr, vector&lt;int&gt;& temp, int left, int right) {
  long long invCount = 0;
  if (left &lt; right) {
    int mid = (left + right) / 2;
    invCount += countInversions(arr, temp, left, mid);
    invCount += countInversions(arr, temp, mid + 1, right);
    invCount += mergeAndCount(arr, temp, left, mid, right);
  }
  return invCount;
}

long long countInversions(vector&lt;int&gt;& arr) {
  vector&lt;int&gt; temp(arr.size());
  return countInversions(arr, temp, 0, arr.size() - 1);
}

int main() {
  int t;
  cin >> t;
  while (t--) {
    int n;
    cin >> n;
    vector&lt;int&gt; a(n);
    for (int i = 0; i &lt; n; i++) {
      cin >> a[i];
    }

    // Подсчет инверсий
    long long invCount = countInversions(a);

    // Подсчет повторяющихся элементов
    map&lt;int, int&gt; freq;
    for (int x : a) {
      freq[x]++;
    }

    // Добавляем количество пересечений для повторяющихся элементов
    for (auto& [x, cnt] : freq) {
      if (cnt >= 2) {
        invCount += (long long)cnt * (cnt - 1) / 2;
      }
    }

    cout &lt;&lt; invCount &lt;&lt; endl;
  }
  return 0;
}
</pre>
  </details>
</article>


<!-- Задача H2. Максимизация пересечений (сложная  версия) -->
<article class="article">
  <div class="anchor" id="task9"></div>
  <h3>Задача H2. Максимизация пересечений (сложная  версия)</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Единственная разница между двумя версиями состоит в том, что в этой версии n ≤ 2⋅10⁵ и сумма по n по всем наборам входных данных теста не превосходит 2⋅10⁵.</p>

  <p>Терминал — это ряд из n равных отрезков, пронумерованных от 1 до n по порядку. Есть два терминала, один над другим.</p>

  <p>Вам дан массив a длины n. Для всех i=1,2,…,n должен быть прямой провод из некоторой точки на отрезке i верхнего терминала в некоторую точку на отрезке ai нижнего терминала. Например, на следующих рисунках показаны два возможных соединения, при n=7 и a=[4,1,4,6,7,7,5].</p>

  <p>Пересечение происходит, когда два провода имеют общую точку. На картинке выше пересечения обведены красным.</p>

  <p>Какое максимальное количество пересечений может быть при оптимальном размещении проводов?</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 1000) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора содержит целое число n (1 ≤ n ≤ 2⋅10⁵) — длина массива.</p>

  <p>Вторая строка каждого набора содержит n целых чисел a1, a2, … , an (1 ≤ ai ≤ n) — элементы массива.</p>

  <p>Сумма n по всем наборам входных данных не превосходит 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора выведите единственное целое число — максимальное количество пересечений, при оптимальном расположении проводов.</p>

  <h4>Пример</h4>
<pre>
4
7
4 1 4 6 7 7 5
2
2 1
1
1
3
2 2 2
</pre>
<pre>
6
1
0
3
</pre>
  <p>Первый пример показан на втором рисунке в условии.</p>
  <p>Во втором примере при единственно возможном соединении появляется пересечение двух проводов, поэтому ответ равен 1.</p>
  <p>В третьем тестовом примере единственно возможное соединение состоит из одного провода, поэтому ответ равен 0.</p>
</article>