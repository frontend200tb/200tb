<article class="article">
  <a href="https://codeforces.com/contest/2051" target="_blank">Codeforces 2051 Round 995 (Div.3) 2024-12-22</a>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

      <a href="#task1">Задача A. Подготовка к олимпиаде</a>
  <br><a href="#task2">Задача B. Путешествие</a>
  <br><a href="#task3">Задача C. Подготовка к экзамену</a>
  <br><a href="#task4">Задача D. Подсчет количества пар</a>
  <br><a href="#task5">Задача E. Лучшая цена</a>
  <br><a href="#task6">Задача F. Джокер</a>
  <br><a href="#task7">Задача G. Змейки</a>
</article>


<!-- Задача A. Подготовка к олимпиаде -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Подготовка к олимпиаде</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Монокарп и Стереокарп готовятся к олимпиаде. До олимпиады осталось n дней. Для i-го из этих дней известно, что Монокарп решит aᵢ задач в этот день, если будет тренироваться; а Стереокарп решит bᵢ задач, если будет тренироваться.</p>

  <p>Монокарп может тренироваться в любой день, в который захочет. А вот Стереокарп следит за Монокарпом и тренируется следующим образом: если в день i Монокарп тренировался, и i &lt; n, то в день (i+1) Стереокарп будет тренироваться.</p>

  <p>Монокарп хочет организовать свой процесс тренировок так, чтобы разность между количеством задач, которые решит он, и количеством задач, которые решит Стереокарп, была как можно больше. Формально, Монокарп хочет максимизировать значение (m-s), где m — количество задач, которые решит он, а s — количество задач, которые решит Стереокарп. Помогите Монокарпу определить максимально возможную вышеописанную разность.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно целое число t (1 ≤ t ≤ 10³) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора содержит одно целое число n (1 ≤ n ≤ 100).</p>

  <p>Вторая строка содержит n целых чисел a₁, a₂, ..., aₙ (1 ≤ aᵢ ≤ 100).</p>

  <p>Третья строка содержит n целых чисел b₁, b₂, ..., bₙ (1 ≤ bᵢ ≤ 100).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно целое число — максимально возможную разность между количеством задач, которые решит Монокарп, и количеством задач, которые решит Стереокарп.</p>

  <details>
    <summary>Пример</summary>
<pre>
4
2
3 2
2 1
1
5
8
3
1 1 1
2 2 2
6
8 2 5 6 2 6
8 2 7 4 3 4
</pre>
<pre>
4
5
1
16
</pre>
  <p>Разберем пример из условия:</p>
  <ul>
    <li>в первом наборе входных данных Монокарпу выгодно тренироваться оба дня, тогда Стереокарп будет тренироваться в день 2;</li>
    <li>во втором наборе входных данных Монокарпу выгодно тренироваться в единственный день, а Стереокарп не будет тренироваться вообще;</li>
    <li>в третьем наборе входных данных Монокарпу выгодно тренироваться в последний день (и только в него);</li>
    <li>в четвертом наборе входных данных Монокарпу выгодно тренироваться в дни 1,3,4,6, тогда Стереокарп будет тренироваться в дни 2,4,5.</li>
  </ul>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Монокарпу выгодно решать задачи в день i, если Стереокарп решит меньше в день i+1,	поэтому прибавляем к ответу разность задач, решенных Монокарпом в	день i, и задач, решенных Стереокарпом в следующий день, если это	условие выполняется. Монокарпу выгодно решать задачи в последний день, потому что дня после него не будет и Стереокарп больше ничего не решит</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  int t; //количество тестов
  cin >> t;

  while (t--) {
    int n, * A, * B, sum = 0;
    cin >> n;
    A = new int[n]; //массив задач, которые будет решать Монокарп
    B = new int[n]; //массив задач, которые будет решать Стереокарп

    for (int i = 0; i &lt; n; i++)
      cin >> A[i];
    for (int i = 0; i &lt; n; i++)
      cin >> B[i];
    for (int i = 0; i &lt; n - 1; i++)
      if (A[i] > B[i + 1]) sum += A[i] - B[i + 1];
		sum += A[n - 1];

		cout &lt;&lt; sum &lt;&lt; endl;
	}
}
</pre>
  </details>
</article>


<!-- Задача B. Путешествие -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Путешествие</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Монокарп решил отправиться в длинное пешее путешествие.</p>

  <p>Он решил, что в первый день пройдет a километров, во второй день пройдет b километров, в третий день пройдет c километров, в четвертый день, как и в первый, пройдет a километров, в пятый день, как и во второй, пройдет b километров, в шестой день, как и в третий, пройдет c километров, и так далее.</p>

  <p>Монокарп завершит свое путешествие в тот день, когда он суммарно преодолеет хотя бы n километров. Перед вами стоит определить номер дня, в который Монокарп завершит свое путешествие.</p>

  <h4>Входные данные</h4>
  <p>В первой строке задано одно целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Каждый набор входных данных состоит из одной строки, в которой задано четыре целых числа n, a, b, c (1 ≤ n ≤ 10⁹; 1 ≤ a, b, c ≤ 10⁶).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно целое число — номер дня, в который Монокарп суммарно преодолеет хотя бы n километров и завершит свое путешествие.</p>

  <details>
    <summary>Пример</summary>
<pre>
4
12 1 5 3
6 6 7 4
16 3 4 1
1000000000 1 1 1
</pre>
<pre>
5
1
6
1000000000
</pre>
  <p>В первом примере за первые четыре дня Монокарп преодолеет 1+5+3+1=10 километров. В пятый день Монокарп преодолеет еще 5 километров, то есть суммарно за пять дней он преодолеет 10+5=15 километров. Так как n=12, Монокарп завершит свое путешествие в пятый день.</p>

  <p>Во втором примере Монокарп за первый день преодолеет 6 километров. Так как n=6, Монокарп завершит свое путешествие в первый же день.</p>

  <p>В третьем примере Монокарп за первые шесть дней преодолеет 3+4+1+3+4+1=16 километров. Так как n=16, Монокарп завершит свое путешествие в шестой день.</p>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  int t; //количество тестов
  cin >> t;

  while (t--) {
    int n, a, b, c, den = 0;
    cin >> n >> a >> b >> c;
    // проходим максималльно возможное
    // количество полных циклов a-b-c
    den += n / (a + b + c) * 3;
    //сколько километров осталось пройти
    //если не все километры пройдены
    n %= (a + b + c);
    if (n > 0) {
      n -= a;
      //идём ещё один день, и осталось
      // на а километров меньше
      //если ещё не все километры пройдены
      den++;
      if (n > 0) {
        n -= b;
        //идём ещё один день, и осталось
        // на b километров меньше
        den++;

        /*если ещё не все километры пройдены,
        проходим ещё один день, и теперь километров не осталось,
        потому что n % (a+b+c) &lt; a+b+c, а мы отняли от этого остатка	(a+b+c) => n &lt; 0 */
        if (n > 0) den++;
      }
    }
    cout &lt;&lt; den &lt;&lt; endl;
  }
}
</pre>
  </details>
</article>


<!-- Задача C. Подготовка к экзамену -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Подготовка к экзамену</h3>

  <div><i>Ограничение по времени 1.5с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Монокарп готовится к своему первому экзамену в университете. Программа экзамена состоит из n вопросов, пронумерованных от 1 до n. На экзамене Монокарпу попадется один из m различных билетов; каждый билет состоит из ровно n-1 различных вопросов. Каждый билет i характеризуется одним числом ai, которое является индексом единственного вопроса, который отсутствует в i-м билете. Например, если n=4 и aᵢ=3, то i-й билет содержит вопросы [1,2,4].</p>

  <p>Во время экзамена Монокарп получит один из этих m
  билетов. Затем профессор заставит Монокарпа ответить на все вопросы из билета. Таким образом, Монокарп сдаст экзамен только в том случае, если он знает все вопросы из билета.</p>

  <p>Монокарп знает ответы на k вопросов q₁, q₂, ...,qₖ. Для каждого билета определите, сдаст ли Монокарп экзамен, если он получит этот билет.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Каждый набор входных данных состоит из трех строк:</p>
  <ul>
    <li>первая строка содержит три целых числа n, m и k (2 ≤ n ≤ 3⋅10⁵; 1 ≤ m, k ≤ n);</li>
    <li>вторая строка содержит m различных целых чисел a₁, a₂, ..., aₘ (1 ≤ aᵢ ≤ n; aᵢ &lt; a<sub>i+1</sub>);</li>
    <li>третья строка содержит k различных целых чисел q₁, q₂, ..., qₖ (1 ≤ qᵢ ≤ n; qᵢ &lt; q<sub>i+1</sub>).</li>
  </ul>

  <p>Дополнительные ограничения на входные данные:</p>
  <p>сумма n по всем наборам входных данных не превышает 3⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите строку из m символов. i-й символ должен быть 1, если Монокарп сдаст экзамен, если он получит i-й билет, или 0, если Монокарп не сдаст.</p>

  <details>
    <summary>Пример</summary>
<pre>
4
4 4 3
1 2 3 4
1 3 4
5 4 3
1 2 3 4
1 3 4
4 4 4
1 2 3 4
1 2 3 4
2 2 1
1 2
2
</pre>
<pre>
0100
0000
1111
10
</pre>
  <p>В первом наборе входных данных Монокарп знает вопросы [1,3,4]. Рассмотрим все билеты:</p>
  <ul>
    <li>первый билет состоит из вопросов [2,3,4]. Монокарп не знает 2-й вопрос, поэтому он не сдаст;</li>
    <li>второй билет состоит из вопросов [1,3,4]. Монокарп знает все эти вопросы, поэтому он сдаст;</li>
    <li>третий билет состоит из вопросов [1,2,4]. Монокарп не знает 2-й вопрос, поэтому он не сдаст;</li>
    <li>четвертый билет состоит из вопросов [1,2,3]. Монокарп не знает 2-й вопрос, поэтому он не сдаст.</li>
  </ul>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

void solve() {
    long long n, m, k;
    cin >> n >> m >> k;

    vector&lt;long long&gt; a(m);
    vector&lt;long long&gt; q(k);

    for (int i = 0; i &lt; m; ++i) {
        cin >> a[i];
    }

    for (int i = 0; i &lt; k; ++i) {
        cin >> q[i];
    }

    if (k &lt; n - 1) {  // Если Монокарп не знает ответ на 2 или более вопроса, то он не сможет сдать ни один билет
        for (int i = 0; i &lt; m; ++i) {
            cout &lt;&lt; 0;
        }

        cout &lt;&lt; '\n';
        return;
    }
    else if (k == n) { // Если Монокарп знает ответ на все вопросы, то он сможет сдать все билеты
        for (int i = 0; i &lt; m; ++i) {
            cout &lt;&lt; 1;
        }

        cout &lt;&lt; '\n';
        return;
    }
            // Остался случай, когда Монокарп не знает ответ ровно на один вопрос
            // Давайте найдём номер этого вопроса
            // Создадим массив пометок: used[i] == 1, если Монокарп знает ответ на этот вопрос,
    vector&lt;long long&gt; used(n + 1);
            // Иначе used[i] == 0

    for (int i = 0; i &lt; k; ++i) {
        used[q[i]] = 1;
    }

    long long cur = 0;

    for (int i = 1; i &lt;= n; ++i) {
      // Найдём номер вопроса, ответ на который Монокарп не знает
        if (!used[i]) {
          // Запомним его в cur
            cur = i;
        }
    }

    for (int i = 0; i &lt; m; ++i) {
      // Для каждого билета проверим, если в него не входит тот единственный вопрос,
        if (a[i] == cur) {
           // на который Монокарп не знает ответ, то он сможет его сдать
            cout &lt;&lt; 1;
        }
        else {
          // Иначе сдать не сможет
            cout &lt;&lt; 0;
        }
    }

    cout &lt;&lt; '\n';
}

int main() {
    ios_base::sync_with_stdio(false);  // Ускорение ввода - вывода
    cin.tie(NULL);
    cout.tie(NULL);

    int t;
    cin >> t;

    for (int i = 0; i &lt; t; ++i) {
        solve();
    }
}
</pre>
  </details>
</article>


<!-- Задача D. Подсчет количества пар -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Подсчет количества пар</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам задана последовательность a, состоящая из n целых чисел, причем i-е число последовательности равно ai. Также вам заданы два целых числа x и y (x≤y).</p>

  <p>Пара целых чисел (i,j) считается интересной, если выполняются следующие условия:</p>
  <ul>
    <li>1 ≤ i &lt; j ≤ n;</li>
    <li>если одновременно удалить из последовательности a
   числа в позициях i и j, то сумма оставшихся элементов должна быть не меньше x и не больше y.</li>
  </ul>

  <p>Перед вами стоит задача определить количество интересных пар целых чисел для заданной последовательности a.</p>

  <h4>Входные данные</h4>
  <p>В первой строке задано одно целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Каждый набор входных данных состоит из двух строк:</p>
  <ul>
    <li>в первой строке заданы три целых числа n, x, y (3 ≤ n ≤ 2⋅10⁵, 1 ≤ x ≤ y ≤ 2⋅10¹⁴);</li>
    <li>во второй строке заданы n целых чисел a₁, a₂, ..., aₙ (1 ≤ aᵢ ≤ 10⁹).</li>
  </ul>

  <p>Дополнительное ограничение на входные данные: сумма n по всем наборам входных данных не превосходит 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно целое число — количество интересных пар целых чисел для заданной последовательности a.</p>

  <details>
    <summary>Пример</summary>
<pre>
7
4 8 10
4 6 3 6
6 22 27
4 9 6 3 4 5
3 8 10
3 2 1
3 1 1
2 3 4
3 3 6
3 2 1
4 4 12
3 3 2 1
6 8 8
1 1 2 2 2 3
</pre>
<pre>
4
7
0
0
1
5
6
</pre>
  <p>В первом примере существует 4 интересных пары целых чисел:</p>
  <ol>
    <li>(1,2);</li>
    <li>(1,4);</li>
    <li>(2,3);</li>
    <li>(3,4).</li>
  </ol>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

void solve() {
    long long n, x, y;
    cin >> n >> x >> y;

    long long s = 0;
    vector&lt;long long&gt; v(n);

    for (int i = 0; i &lt; n; ++i) {
        cin >> v[i];
        // Считаем s - сумму всего массива
        s += v[i];
    }

    // Отсортируем массив, чтобы применить бинарный поиск по нему
    sort(v.begin(), v.end());
    long long ans = 0;

    // Переберём первый элемент интересной пары
    for (int i = 0; i &lt; n - 1; ++i) {
        // Второй элемент пары может лежать
        // в полуинтервале [i + 1, n), таким образом
        // мы избежим подсчёта одних и тех же пар два раза
        long long l = i + 1, r = n - 1;
        long long lb, rb;

        while (l &lt; r - 1) {
            long long m = (l + r) / 2;

            // Выражение s - v[i] - v[j] убывает,
            // при увеличении j (s не меняется,
            // v[i] мы зафиксировали в цикле),
            if (s - v[i] - v[m] >= x) {
              // так как наш массив v отсортирован по возрастанию
              l = m;
            } else {
                r = m;
            }
        }

        // Проверим, в какой из границ лежит ответ (в l или в r)
        if (s - v[i] - v[r] >= x) {
             // rb -  максимальный индекс такой, что s - v[i] - v[rb] >= x
            rb = r;
        } else if (s - v[i] - v[l] >= x) {
            rb = l;
        } else {
            // Если ни l, ни r не подходят, то положим -1, которая показывает, что интересных пар
            rb = -1;
        }                               // для данного i не существует

        l = i + 1, r = n - 1;

        while (l &lt; r - 1) {
            long long m = (l + r) / 2;

            if (s - v[i] - v[m] &lt;= y) { // Проделаем то же самое для ограничения на y
                r = m;                  // Найдём минимальный j такой, что s - v[i] - v[j] &lt;= y
            }
            else {
                l = m;
            }
        }

        if (s - v[i] - v[l] &lt;= y) {
            lb = l;
        }
        else if (s - v[i] - v[r] &lt;= y) {
            lb = r;
        }
        else {
            lb = -1;                  // Теперь у нас есть отрезок [lb, rb] такой, что все числа внутри него являются интересной
        }                             // парой к элементу v[i]

        if (lb != -1 && rb != -1) {   // Если мы смогли найти границы подходящего отрезка
            ans += max(0ll, rb - lb + 1); // Отрезок может получиться вырожденным (lb > rb), поэтому возьмём максимум из 0 и длины отрезка
        }
    }

    cout &lt;&lt; ans &lt;&lt; '\n';
}

int main() {
    // Ускорение ввода - вывода
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    int t;
    cin >> t;

    for (int i = 0; i &lt; t; ++i) {
        solve();
    }
}
</pre>
  </details>
</article>


<!-- Задача E. Лучшая цена -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Лучшая цена</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В самый крупный магазин Берляндии поступила партия елей. В магазин уже пришли n клиентов, которые хотят их купить.</p>

  <p>Перед началом продаж магазину осталось определиться с ценой за одну елку (цена одинакова для всех покупателей). Для этого у магазина есть некоторая информация о каждом клиенте.</p>

  <p>Для i-го клиента известно два целых числа aᵢ и bᵢ, которые определяют его поведение:</p>
  <ul>
    <li>если цена товара не более aᵢ, то клиент купит елку и оставит положительный отзыв;</li>
    <li>иначе, если цена товара не более bᵢ, то клиент купит елку, но оставит отрицательный отзыв;</li>
    <li>иначе клиент не будет покупать елку вообще.</li>
  </ul>

  <p>Ваша задача — посчитать максимально возможный заработок магазина, если можно получить не более k отрицательных отзывов.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора содержит два целых числа n и k (1 ≤ n ≤ 2⋅10⁵; 0 ≤ k ≤ n).</p>

  <p>Вторая строка содержит n целых чисел a₁, a₂, ..., aₙ (1 ≤ aᵢ ≤ 2⋅10⁹).</p>

  <p>Третья строка содержит n целых чисел b₁, b₂, ..., bₙ (1 ≤ bᵢ ≤ 2⋅10⁹; aᵢ &lt; bᵢ).</p>

  <p>Дополнительное ограничение на входные данные: сумма n по всем наборам входных данных не превосходит 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно целое число — максимально возможный заработок магазина, если можно получить не более k отрицательных отзывов.</p>

  <details>
    <summary>Пример</summary>
<pre>
5
2 0
2 1
3 4
1 1
2
5
3 3
1 5 2
3 6 4
4 3
2 3 2 8
3 7 3 9
3 1
2 9 5
12 14 9
</pre>
<pre>
2
5
9
14
15
</pre>
  <p>Рассмотрим пример из условия:</p>
  <ul>
    <li>в первом наборе входных данных надо поставить цену, равную 1. Тогда оба клиента купят по одной елке и не оставят ни одного отрицательного отзыва;</li>
    <li>во втором наборе входных данных надо поставить цену, равную 5. Тогда единственный клиент купит елку и оставит отрицательный отзыв;</li>
    <li>в третьем наборе входных данных надо поставить цену, равную 3. Тогда все клиенты купят по одной елке, и магазин получит два отрицательных отзыва.</li>
    <li>в четвертом наборе входных данных надо поставить цену, равную 7. Тогда два клиента купят по одной елке, и магазин получит один отрицательный отзыв.</li>
  </ul>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

void solve() {
    long long n, k;
    cin >> n >> k;

    vector&lt;long long&gt; a(n), b(n);

    for (int i = 0; i &lt; n; ++i) {
        cin >> a[i];
    }

    for (int i = 0; i &lt; n; ++i) {
        cin >> b[i];
    }

    vector&lt;pair&lt;long long, long long&gt; &gt; v;

    //  Будем хранить в массиве v пару чисел. Первое число -  значение цены (a или b), второе число равно 1, если это число a,
    //  если оно равно -1, то это значение b. Каждую пару (a, b) можно понимать как полуинтервал (a, b].
    //  Тогда негативный отзыв эквивалентен тому, что мы находимся внутри полуинтервала (a, b]

    for (int i = 0; i &lt; n; ++i) {
        v.push_back({ a[i], 1 });
        v.push_back({ b[i], -1 });
    }

    sort(v.begin(), v.end());  // Отсортируем все значения по возрастанию и применим технику сканлайна

    long long ind = 0;  // ind - индекс текущего значения в массиве v
    long long ans = 0;  // ans - ответ
    long long cnt = 0;  // cnt - количество полуинтервалов, которые заканчиваются раньше нашей позиции
                        // То есть cnt - количество покупателей, которые не купят ёлку
    long long cur = 0;  // cur - количество полуинтервалов, внутри которых мы находимся
                        // То есть cur -  количество покупателей, которые купят ёлку, но оставят негативный отзыв

    // Утверждение: оптимальная цена содержится среди значений a и b.
    // Док-во: Предположим это не так и есть оптимальная цена opt, не являющаяся значением a или b.
    // Но тогда opt + 1 не изменит ситуацию: то есть кол-во негативных отзывов не увеличится и количество покупателей, не купивших ёлку не изменится
    // Также заметим, что цена не может быть больше, чем максимальное среди значений a и b, так как в таком случае ни один покупатель ёлку не купит
    // Поэтому давайте рассмотрим все значения a и b как кандидатов на ответ

    while (ind &lt; v.size()) {
        long long tmp = v[ind].first;  // tmp - текущая рассматриваемая цена
        long long add = 0;             // add - количество полуинтервалов, внутри которых мы будем на следующем шаге
        long long addc = 0;            // addc - количество полуинтервалов, которые будут раньше нашей текущей цены на следующем шаге

        while (ind &lt; v.size() && v[ind].first == tmp) {  // Обработаем все значения, которые равны нашей цене
            if (v[ind].second == 1) {
                ++add;   // Если это начало полуинтервала (значение a), то на следующем шаге cur станет больше, увеличим add на 1
            }
            else {
                ++addc;  // Если это конец полуинтервала (значение b), то на следующем шаге cnt станет больше, увеличим addc на 1
            }

            ++ind;
        }

        --ind;  // Уменьшим ind на 1, так как в цикле мы перешли к следующей потенциальной цене, или вышли за границу массива

        if (cur &lt;= k) {                        // Если количество полуинтервалов, в которых мы находимся (т.е. количество негативных отзывов) &lt;= k,
            ans = max(ans, tmp * (n - cnt));   // то обновим ответ значением текущей цены tmp, умноженной на кол-во всех полуинтервалов, которые заканчиваются не раньше tmp
        }                                      // Таких полуинтервалов ровно n - cnt

        cur += add;   // Прибавим кол-во полуинтервалов, в которых мы стоим для следующего шага
        cur -= addc;  // Вычтем кол-во полуинтервалов, которые сейчас закончились, то есть на следюущем шаге станут строго раньше текущей цены
        cnt += addc;  // Прибавим кол-во полуинтервалов, которые закончились сейчас, то есть на следующем шаге станут строго раньше текущей цены
        ++ind;
    }

    cout &lt;&lt; ans &lt;&lt; '\n';
}

int main() {
    ios_base::sync_with_stdio(false);  // Ускорение ввода - вывода
    cin.tie(NULL);
    cout.tie(NULL);

    int t;
    cin >> t;

    for (int i = 0; i &lt; t; ++i) {
        solve();
    }
}
</pre>
  </details>
</article>


<!-- Задача F. Джокер -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Джокер</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Рассмотрим колоду из n карт. Позиции в колоде пронумерованы от 1 до n сверху вниз. На m-й позиции расположен джокер.</p>

  <p>К колоде последовательно применяются q операций. Во время i-й операции необходимо взять карту на aᵢ-й позиции и переместить её либо в начало, либо в конец колоды. Например, если колода имеет вид [2,1,3,5,4], и aᵢ = 2, то после операции колода будет [1,2,3,5,4] (карту со второй позиции перенесли в начало) или [2,3,5,4,1] (карту со второй позиции перенесли в конец).</p>

  <p>Ваша задача — посчитать количество различных позиций, в которых может находиться джокер после каждой из операций.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит одно целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора содержит три целых числа n, m и q (2 ≤ n ≤ 10⁹; 1 ≤ m ≤ n; 1 ≤ q ≤ 2⋅10⁵).</p>

  <p>Вторая строка содержит q целых чисел a₁, a₂, ... , a<sub>q</sub> (1 ≤ aᵢ ≤ n).</p>

  <p>Дополнительное ограничение на входные данные: сумма q по всем наборам входных данных не превосходит 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите q целых чисел — количество различных позиций, в которых может находиться джокер после каждой из операций.</p>

  <details>
    <summary>Пример</summary>
<pre>
5
6 5 3
1 2 3
2 1 4
2 1 1 2
5 3 1
3
3 2 4
2 1 1 1
18 15 4
13 15 1 16
</pre>
<pre>
2 3 5
2 2 2 2
2
2 3 3 3
2 4 6 8
</pre>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;unordered_set&gt;
#include &lt;unordered_map&gt;
#include &lt;queue&gt;
#include &lt;ctime&gt;
#include &lt;cassert&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;chrono&gt;
#include &lt;random&gt;
#include &lt;bitset&gt;
#include &lt;fstream&gt;
#include &lt;array&gt;
#include &lt;functional&gt;
#include &lt;stack&gt;
#include &lt;memory&gt;

using namespace std;

using ll = long long;
using ld = long double;
using vll=vector&lt;ll&gt;;

#define mp make_pair
#define debug(x) std::cerr &lt;&lt; __FUNCTION__ &lt;&lt; ":"
&lt;&lt; __LINE__ &lt;&lt; " " &lt;&lt; #x &lt;&lt; " = " &lt;&lt; x &lt;&lt; '\n';

const ll INF = 4e18;
//#pragma GCC optimize("Ofast")
//#pragma GCC target("sse,sse2,sse3,ssse3,sse4,sse4.1,sse4.2,popcnt,abm,mmx,avx,avx2,tune=native")
//#pragma GCC optimize("unroll-loops")
void solve(){
    ll n, m, q;
    cin >> n >> m >> q;
    ll have_pref = 0;
    ll have_suff = 0;
    pair&lt;ll, ll&gt; mid={-1,-1};
    vector&lt;ll&gt; ar(q);
    for (int i =0; i &lt; q; i++){
        cin >> ar[i];
    }
    // Рассмотрим два случая: 1) Джокер был выбрал первой операцией
    // 2) Джокер не был выбран первой операцией
    if (ar[0] == m){
        // Если джокер был выбрал первой операцией, то исходя из условия задачи он после этой операции будет либо на первой, либо на последней позиции
        have_suff = n;
        have_pref = 1;
        // Префикс массива это подмассив который начинается с первого элемента, например [1,2,3] префикс массива [1,2,3,4,5]
        // Суффикс массива это подмассив который начинается с последнего элемента, например [3, 4, 5] суффикс массива [1,2,3,4,5]
        // Заметим что возможные позиции джокера будут образовывать какой-то суффикс и какой-то префикс нашего массива
        cout &lt;&lt; have_pref + (n - have_suff + 1) &lt;&lt; " ";
        for (int i = 1; i &lt; q; i++){
            // Пусть пришел следующий запрос, тогда мы можем поставить его в конец и можем в начало, тем самым увеличев возможый префикс или суффикс возможных состояний позиций джокера
            if (ar[i] &lt;= have_pref){
                have_suff--;
                if (have_pref == have_suff) {
                    have_pref--;
                }
            }
            else if (ar[i] >= have_suff){
                have_pref++;
                if (have_suff == have_pref){
                    have_suff++;
                }
            }
            else {
                have_pref++;
                have_suff--;
            }
            // Не забываем что максимальная длина суффикса или префикса не превосходит длины всего массива
            have_suff = max(1LL, have_suff);
            have_pref = min(n, have_pref);
            while (have_pref >= have_suff){
                have_pref--;
            }
            cout &lt;&lt; have_pref + n - have_suff + 1 &lt;&lt; ' ';
        }
        cout &lt;&lt; '\n';
    }
    else{
        // Рассмотрим случай когда первый запрос был не на джокера
        // Тогда добавляется непрерывный подмассив состояний позиций джокера в центре(назовем его mid) и будем поддерживать его после каждой операции
        if (m > ar[0]){
            mid.first = m - 1;
            mid.second = m;
        }
        else{
            mid.first = m;
            mid.second = m + 1;
        }
        mid.second = min(n, mid.second);
        mid.first = max(1LL, mid.first);
        have_pref = 0;
        have_suff = n + 1;
        cout &lt;&lt;have_pref + n - have_suff + 1 + (mid.second - mid.first + 1) &lt;&lt; " ";
        // Здесь надо аккуратно рассмотреть случаи как изменяются подмассивы при каждой операции
        for (int i = 1; i &lt; q; i++){
            ll x = ar[i];
            if (x &lt;= have_pref){
                if (have_suff != n + 1){
                    have_suff--;
                }
                mid.first--;
                mid.second = min(n, mid.second);
                mid.first = max(1LL, mid.first);
                if (mid.first == have_pref){
                    have_pref--;
                }
                if (have_suff == mid.second){
                    have_suff++;
                }
            }
            else if (x >= have_suff){
                if (have_pref != 0){
                    have_pref++;
                }
                mid.second++;
                mid.second = min(n, mid.second);
                mid.first = max(1LL, mid.first);
                if (have_pref == mid.first){
                    have_pref--;
                }
                if (mid.second == have_suff){
                    have_suff++;
                }
            }
            else if (x >= mid.first && x &lt;= mid.second){
                have_pref++;
                have_suff--;
                if (have_pref == mid.first){
                    have_pref--;
                }
                if (mid.second == have_suff){
                    have_suff++;
                }
            }
            else{
                if (x &lt; mid.first){
                    mid.first--;
                }
                else{
                    mid.second++;
                }
                mid.second = min(n, mid.second);
                mid.first = max(1LL, mid.first);
                if (have_pref != 0){
                    have_pref++;
                }
                if (have_suff != n + 1){
                    have_suff--;
                }
                while (have_pref >= mid.first){
                    have_pref--;
                }
                while (mid.second >= have_suff){
                    have_suff++;
                }
            }
            cout &lt;&lt; have_pref + max(0LL, (n - have_suff + 1)) + (mid.second - mid.first + 1) &lt;&lt; " ";
        }
        // основная идея решения в том, что состояния позиций джокера в общем случае выглядят так: [*,*,*,*,*,.,.,.,.,.,.,*,*,*,*,*,*,.,.,.,.,.,.,.,*,*,*,*,*,*]
        // где звездочки означают возможные нахождения джокера, а точки означают что там пока джокер побывать не мог
        // далее мы аккуратно обновляем этот массив исходя из приходящих запросов.
        cout &lt;&lt; '\n';
    }

}
int main(){
    ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);
    int t;
    cin >> t;
    //t=1;

    while(t--) {
        solve();
    }

    return 0;
}
</pre>
  </details>
</article>


<!-- Задача G. Змейки -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Змейки</h3>

  <div><i>Ограничение по времени 3с
  <br>Ограничение по памяти 512мб</i></div>

  <p>Предположим, вы играете в игру, где игровое поле выглядит как полоска из 1x10⁹ квадратных ячеек, пронумерованных от 1 до 10⁹.</p>

  <p>У вас есть n змеек (пронумерованных от 1 до n), которые нужно разместить в некоторых ячейках. Изначально каждая змейка занимает ровно одну ячейку, и вы не можете разместить более одной змейки в одной ячейке. После этого начинается игра.</p>

  <p>Игра длится q секунд. Каждую секунду происходит один из двух типов событий:</p>
  <ul>
    <li>змейка sᵢ увеличивается: если змейка sᵢ занимала ячейки [l,r], она увеличивается до отрезка [l, r+1];</li>
    <li>змейка sᵢ уменьшается: если змейка sᵢ занимала ячейки [l, r], она уменьшается до отрезка [l+1, r].</li>
  </ul>

  <p>Каждую секунду происходит ровно одно из событий.</p>

  <p>Если в любой момент времени какая-либо змея наткнется на какое-либо препятствие (либо на другую змею, либо на конец полосы), вы проигрываете. В противном случае вы выигрываете со счетом, равным максимальной ячейке, занятой какой-либо змеей на данный момент.</p>

  <p>Какой минимально возможный счет вы можете получить?</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит два целых числа n и q (1 ≤ n ≤ 20; 1 ≤ q ≤ 2⋅10⁵) — количество змей и количество событий. Далее в q строках заданы описания событий — по одному на строку.</p>

  <p>В i-й строке задано</p>
  <ul>
    <li>либо «sᵢ +» (1 ≤ sᵢ ≤ n), означающее, что sᵢ-я змея увеличивается,</li>
    <li>либо «sᵢ -» (1 ≤ sᵢ ≤ n), означающее, что sᵢ-я змея уменьшается.</li>
  </ul>

  <p>Дополнительное ограничение на входные данные: заданная последовательность событий валидна, т. е. змея длиной 1 никогда не уменьшается.</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно целое число — минимально возможный счет.</p>

  <details>
    <summary>Примеры</summary>
  <h4>Пример 1</h4>
<pre>
3 6
1 +
1 -
3 +
3 -
2 +
2 -
</pre>
  <code>4</code>

  <h4>Пример 2</h4>
<pre>
5 13
5 +
3 +
5 -
2 +
4 +
3 +
5 +
5 -
2 +
3 -
3 +
3 -
2 +
</pre>
  <code>11</code>
  <p>В первом тесте оптимальная стратегия заключается в том, чтобы разместить вторую змею в ячейке 1, третью змею — в 2, а первую — в 3. Максимальная занятая ячейка — ячейка 4, и это минимально возможный результат.</p>

  <p>Во втором тесте одна из оптимальных стратегий — следующая: нужно поставить</p>
  <ul>
    <li>змейку 2 в позицию 1;</li>
    <li>змейку 3 в позицию 4;</li>
    <li>змейку 5 в позицию 6;</li>
    <li>змейку 1 в позицию 9;</li>
    <li>змейку 4 в позицию 10.</li>
  </ul>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;unordered_set&gt;
#include &lt;unordered_map&gt;
#include &lt;queue&gt;
#include &lt;ctime&gt;
#include &lt;cassert&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;chrono&gt;
#include &lt;random&gt;
#include &lt;bitset&gt;
#include &lt;fstream&gt;
#include &lt;array&gt;
#include &lt;functional&gt;
#include &lt;stack&gt;
#include &lt;memory&gt;

using namespace std;

using ll = long long;
using ld = long double;
using vll=vector&lt;ll&gt;;

#define mp make_pair
#define debug(x) std::cerr &lt;&lt; __FUNCTION__ &lt;&lt; ":"
  &lt;&lt; __LINE__ &lt;&lt; " " &lt;&lt; #x &lt;&lt; " = " &lt;&lt; x &lt;&lt; '\n';
const ll INF = 4e18;
//#pragma GCC optimize("Ofast")
//#pragma GCC target("sse,sse2,sse3,ssse3,sse4,sse4.1,sse4.2,popcnt,abm,mmx,avx,avx2,tune=native")
//#pragma GCC optimize("unroll-loops")
void solve(){
    // основная идея: динамическое программирование по подмножествам
    // основная идея таких задач, пусть у нас есть ответ для какого то подмонжества наших предметов, давайте попробуем добавить к нему новый элемент и пересчитать ответ
    ll n, q;
    cin >> n >> q;
    vector&lt;pair&lt;ll, char&gt; &gt; ops(q);
    vector&lt;vector&lt;ll&gt; &gt; mini_dist(n, vector&lt;ll&gt;(n, 0));
    vector&lt;vector&lt;pair&lt;ll, char&gt; &gt; &gt; for_this(n);
    vector&lt;ll&gt; cnt(n);
    // массив mini_dist означает минимальное расстояние на котором могут располагаться змейки перед началом игры
    // то есть если расстояние между ними будет меньше они ударятся друг об друга и мы проиграем, научимся быстро такое считать
    for (int i = 0; i &lt; q; i++){
        cin >> ops[i].first >> ops[i].second;
        ops[i].first--;
        for_this[ops[i].first].push_back({i, ops[i].second});
        if (ops[i].second == '+'){
            cnt[ops[i].first]++;
        }
    }
    // заведем массив cnt который отвечает на вопрос о том насколько вырастит змейка за всю игру, в дальнейшем это потребуется для ответа
    for (int i =0; i &lt; n; i++){
        for (int j =0; j &lt; n; j++){
            // заметим что n достаточно маленькое так что просто переберем все пары mini_dist[i][j] означает на каком минимальном расстояние могут
            // находиться змейка под номер i и змейка под номером j если змейка i будет левее
            if (i == j){
                continue;
            }
            vector&lt;pair&lt;pair&lt;ll, ll&gt;, ll&gt; &gt; buff;
            for (auto c: for_this[i]){
                buff.push_back({{c}, i});
            }
            for (auto c: for_this[j]){
                buff.push_back({{c}, j});
            }
            sort(buff.begin(), buff.end());
            // для этого выпишем по порядку те операции которые происходили с этими змейками и если левая змейка выросла то подвинем правую, а если правая змейка
            // сократилась то можно запомнить что есть дополонительное место для роста левой змейки
            ll minim = 1;
            ll now = 1;
            for (auto c: buff){
                if (c.second == i){
                    if (c.first.second == '+'){
                        now++;
                    }
                }
                else{
                    if (c.first.second == '-'){
                        now--;
                    }
                }
                minim = max(now, minim);
            }
            mini_dist[i][j] = minim;
            // сохраним эту информацию в массив mini_dist
        }
    }
    vector&lt;vector&lt;ll&gt; &gt; dp((1LL &lt;&lt; n), vector&lt;ll&gt;(n, INF));
    // массив в котором хранится ответ
    // идея такая, какое-то подможество элементов удобно представлять в виде числа, действительно, чтобы понять какое подмножество отвечает заданному числу
    // давайте просто переведем число в двочиную систему, тогда чтобы проверить что элемент входит в подмножество, которому отвечает данное число, надо проверить что на
    // i-ом месте стоит 1
    for (int i =0 ; i &lt; n; i++){
        dp[(1LL &lt;&lt; i)][i]=0;
    }
    // это так называемая база динамического программирования, если вы математик, то тут очень хорошо для понимания подходит аналогия с математической индукцией
    // в нашем случае dp[mask][i] означает ответ на задачу если мы уже поставили змейки с номерами которые соответствуют mask, а самая правая из всех поставленных
    // змеек имеет индекс i
    // здесь надо хранить ту какую змейку мы поставили в самую правую позицию для пересчета ответа когда будем ставить следующую змейку, действительно зададим себе вопрос
    // что нам может помешать когда мы ставим очередную змейку, только следующая справа змейка, а что нам сделать чтобы она нам не помешала, -ну поставить текущую змейку чтобы не было проблем
    // а ответ на этот вопрос у нас уже лежит в mini_dist
    // асимпотика данного решения будет 2^n * n^2, при заданных ограниченях этого вполне хватает
    for (int i =0; i &lt; (1LL &lt;&lt; n); i++){
        for (int j =0 ; j &lt; n; j++){
            for (int k =0 ; k &lt; n; k++){
                if (((1LL &lt;&lt; j) & i) != 0 && ((1LL &lt;&lt; k) & i) == 0){
                    dp[(1LL &lt;&lt; k) | i][k] = min(dp[(1LL &lt;&lt; k) | i][k], dp[i][j] + mini_dist[j][k]);
                }
            }
        }
    }

    ll ans = INF;
    // не забудем что в конце самая правая змейка еще вырастит вправо и так как индексация у нас с 0, а в задаче с 1, прибавим 1
    for (int i =0; i &lt; n; i++){
        // в оптимальном ответе какая - то змейка самая правая, давайте ее переберем, у нас есть оптимальный ответы когда i-ая змейка самая правая
        ans = min(ans, dp[(1LL &lt;&lt; n) - 1][i] + cnt[i] + 1);
    }
    // выводим ответ на задачу
    cout &lt;&lt; ans;
}
int main(){
    ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);
    int t;
    //cin >> t;
    t=1;
    while(t--){
        solve();
    }
    return 0;
}
</pre>
  </details>
</article>

