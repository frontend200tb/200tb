<article class="article">
  <p><a href="https://codeforces.com/contest/2123" target="_blank">Codeforces Round 1034 (Div.3) 2025-07-01</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p>
        <a href="#task1">Задача A. И снова игра на доске</a>
    <br><a href="#task2">Задача B. Турнир</a>
    <br><a href="#task3">Задача C. Минимум префикса и максимум суффикса</a>
    <br><a href="#task4">Задача D. Битва на бинарной строке</a>
    <br><a href="#task5">Задача E. Подсчет MEX</a>
    <br><a href="#task6">Задача F. Минимизировать неподвижные точки</a>
    <br><a href="#task7">Задача G. Модульная сортировка</a>
  </p>
</article>


<!-- Задача A. И снова игра на доске -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. И снова игра на доске</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Изначально на доске написаны целые числа от 0 до n-1.</p>
  <p>В одном раунде,</p>
  <ul>
    <li>Алиса выбирает целое число a на доске и стирает его;</li>
    <li>затем Боб выбирает целое число b на доске так, чтобы a+b≡3(mod4) * и стирает его.</li>
  </ul>
  <p>Раунды проходят последовательно, пока один из игроков не сможет сделать ход — первый игрок, который не сможет сделать ход, проигрывает. Определите, кто выигрывает при оптимальной игре.</p>
  <p>* Мы определяем, что x≡y(modm), когда x-y является целым кратным m.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 100)  — количество наборов входных данных.</p>

  <p>Единственная строка каждого набора входных данных содержит целое число n (1 ≤ n ≤ 100) — количество целых чисел, написанных на доске.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите в одной строке «Alice», если Алиса выигрывает при оптимальной игре, и «Bob», если Боб выигрывает при оптимальной игре.</p>

  <p>Вы можете выводить ответ в любом регистре (верхнем или нижнем). Например, строки «aLiCe», «alice», «ALICE», и «alICE» будут распознаны как «Alice».</p>

  <h4>Пример</h4>
<pre>
5
2
4
5
7
100
</pre>
<pre>
Alice
Bob
Alice
Alice
Bob
</pre>
  <p>В первом примере, предположим, Алиса выбирает 0, тогда Боб не может выбрать ни одно число, и Алиса выигрывает немедленно.</p>
  <p>Во втором примере, предположим, Алиса выбирает 0, тогда Боб может выбрать 3. Затем предположим, что Алиса выбирает 2, тогда Боб может выбрать 1. В итоге у Алисы не останется чисел, и Боб выигрывает.</p>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n;
    cin >> n;

    // решение и вывод результата
    if (n % 4) {
      cout &lt;&lt; "Alice";
    } else {
      cout &lt;&lt; "Bob";
    }
    cout &lt;&lt; '\n';
  }

}
</pre>
  </details>
</article>


<!-- Задача B. Турнир -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Турнир</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Дан массив целых чисел a1, a2, …, an. Проводится турнир с n игроками. У игрока i сила ai.</p>

  <p>Пока остаётся более k игроков:</p>
  <ul>
    <li>Два оставшихся игрока выбираются случайным образом;</li>
    <li>Игрок с меньшей силой исключается. Если выбранные игроки имеют одинаковую силу, один из них исключается случайным образом.</li>
  </ul>

  <p>Даны целые числа j и k (1 ≤ j, k ≤ n), определите, есть ли способ для игрока j стать одним из последних k оставшихся игроков.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10⁴)  — количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит три целых числа n, j и k (2 ≤ n ≤ 2⋅10⁵, 1 ≤ j, k ≤ n).</p>

  <p>Вторая строка каждого набора входных данных содержит n целых чисел, a1, a2, …, an (1 ≤ ai ≤ n).</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите в одной строке «YES», если игрок j может быть одним из последних k оставшихся игроков, и «NO» в противном случае.</p>

  <p>Вы можете выводить каждую букву в любом регистре (строчную или заглавную). Например, строки «yEs», «yes», «Yes» и «YES» будут приняты как положительный ответ.</p>

  <h4>Пример</h4>
<pre>
3
5 2 3
3 2 4 4 1
5 4 1
5 3 4 5 2
6 1 1
1 2 3 4 5 6
</pre>
<pre>
YES
YES
NO
</pre>
  <p>В первом примере предположим, что выбраны игроки 2 и 5. Тогда игрок 2 побеждает игрока 5. Теперь оставшиеся силы игроков:</p>
  <code>3	2	4	4</code>
  <p>Далее предположим, что выбраны игроки 3 и 4. Тогда игрок 3 может победить игрока 4. Теперь оставшиеся силы игроков:</p>
  <code>3	2	4</code>
  <p>Игрок 2 является одним из последних трёх оставшихся игроков.</p>
  <p>В третьем примере можно показать, что нет способа для игрока 1 стать последним оставшимся игроком.</p>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n, j, k;
    cin >> n >> j >> k;
    vector&lt;int&gt; A(n + 1);
    for (int i = 1; i &lt;= n; i++) {
      cin >> A[i];
    }

    // решение
    string ans = "YES";
    // находим максимальное число
    int maxai = A[1];
    for (int i = 2; i &lt;= n; i++) {
      if (A[i] > maxai) {
        maxai = A[i];
      }
    }

    // если k == 1 и A[j] не максимально
    // то не может
    if (k == 1 && A[j] != maxai) {
      ans = "NO";
    }

    // вывод результата
    cout &lt;&lt; ans &lt;&lt; '\n';
  }

}
</pre>
  </details>
</article>


<!-- Задача C. Минимум префикса и максимум суффикса -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Минимум префикса и максимум суффикса</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам дан массив a из различных целых чисел.</p>

  <p>В одной операции вы можете либо:</p>
  <ul>
    <li>выбрать непустой префикс∗ массива a и заменить его на его минимальное значение, или</li>
    <li>выбрать непустой суффикс† массива a и заменить его на его максимальное значение.</li>
  </ul>
  <p>Обратите внимание, что вы можете выбрать весь массив a.</p>

  <p>Для каждого элемента ai определите, существует ли последовательность операций, чтобы преобразовать a в [ai]; то есть сделать так, чтобы массив a состоял только из одного элемента, который равен ai. Выведите ваш ответ в виде двоичной строки длины n, где i-й символ равен 1, если существует последовательность, чтобы преобразовать a в [ai], и 0 в противном случае.</p>

  <p>* Префикс массива — это подмассив, состоящий из первых k
  элементов массива, для некоторого целого k.</p>
  <p>† Суффикс массива — это подмассив, состоящий из последних k
  элементов массива, для некоторого целого k.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10⁴)  — количество наборов входных данных.</p>
  <p>Первая строка каждого набора входных данных содержит одно целое число n (2 ≤ n ≤ 2⋅10⁵) — размер массива a.</p>

  <p>Вторая строка каждого набора входных данных содержит n целых чисел, a1, a2, …, an (1 ≤ ai ≤ 10⁶). Гарантируется, что все ai различны.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите двоичную строку длины n, i-й символ должен быть 1, если существует последовательность операций, как описано выше, и 0 в противном случае.</p>

  <h4>Пример</h4>
<pre>
3
6
1 3 5 4 7 2
4
13 10 12 20
7
1 2 3 4 5 6 7
</pre>
<pre>
100011
1101
1000001
</pre>
  <p>В первом примере вы можете сначала выбрать префикс длины 3. Затем массив преобразуется в</p>
  <code>1	4	7	2</code>
  <p>Далее вы можете выбрать суффикс длины 2. Затем массив преобразуется в</p>
  <code>1	4	7</code>
  <p>Наконец, вы можете выбрать префикс длины 3. Затем массив преобразуется в</p>
  <code>1</code>
  <p>Таким образом, мы видим, что возможно преобразовать a в [1].</p>
  <p>Можно показать, что невозможно преобразовать a в [3].</p>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n;
    cin >> n;
    vector&lt;int&gt; A(n + 1);
    for (int i = 1; i &lt;= n; i++) {
      cin >> A[i];
    }

    // решение
    string res(n, '0');
    // находим min и max
    int minai = A[1];
    int maxai = A[1];
    for (int i = 2; i &lt;= n; i++) {
      if (A[i] > maxai) {
        maxai = A[i];
      }
      if (minai > A[i]) {
        minai = A[i];
      }
    }

    // ставим 1
    // если это min или max
    // если слева нет меньше
    // если справа нет больше

    // соберем префиксную сумму минимумов
    // соберем суффиксную сумму максимумов
    vector&lt;int&gt; Pref(n + 1);
    vector&lt;int&gt; Suf(n + 1);
    Pref[1] = A[1];
    for (int i = 2; i &lt;= n; i++) {
      Pref[i] = min(Pref[i - 1], A[i]);
    }
    Suf[n] = A[n];
    for (int i = n - 1; i >= 1; i--) {
      Suf[i] = max(Suf[i + 1], A[i]);
    }

    for (int i = 1; i &lt;= n; i++) {
      if (A[i] == minai || A[i] == maxai) {
        res[i - 1] = '1';
      }
      if (A[i] == Pref[i]) {
        res[i - 1] = '1';
      }
      if (A[i] == Suf[i]) {
        res[i - 1] = '1';
      }
    }

    // вывод результата
    cout &lt;&lt; res &lt;&lt; '\n';
  }

}
</pre>
  </details>
</article>


<!-- Задача D. Битва на бинарной строке -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Битва на бинарной строке</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Алиса и Боб получили бинарную строку s длиной n и целое число k (1 ≤ k &lt; n).</p>

  <p>Алиса выигрывает, если ей удается преобразовать все символы строки s в нули. Если Алиса не может выиграть за конечное число ходов, то выигрывает Боб.</p>

  <p>Алиса и Боб ходят по очереди, при этом первой ходит Алиса.</p>
  <ul>
    <li>В свой ход Алиса может выбрать любую подпоследовательность∗ длиной k в строке s, а затем установить все символы в этой подпоследовательности в нули.</li>
    <li>В свой ход Боб может выбрать любую подстроку† длиной k в строке s, а затем установить все символы в этой подстроке в единицы.</li>
  </ul>

  <p>Обратите внимание, что Алиса выигрывает, если строка состоит из всех нулей в любой момент игры, включая промежутки между ходами Алисы и Боба.</p>

  <p>Определите, кто выигрывает при оптимальной игре.</p>

  <p>* Подпоследовательность строки s — это набор символов в s. Обратите внимание, что эти символы не обязательно должны быть смежными.</p>

  <p>† Подстрока строки s — это непрерывная группа символов в s. Обратите внимание, что эти символы должны быть смежными.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10⁴)  — количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит два целых числа n и k (2 ≤ n ≤ 2⋅10⁵, 1 ≤ k &lt; n).</p>

  <p>Вторая строка каждого набора входных данных содержит бинарную строку s длиной n.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите в одной строке «Alice», если Алиса выигрывает при оптимальной игре, и «Bob», если Боб выигрывает при оптимальной игре.</p>

  <p>Вы можете выводить ответ в любом регистре (верхнем или нижнем). Например, строки «aLiCe», «alice», «ALICE», и «alICE» будут распознаны как «Alice».</p>

  <h4>Пример</h4>
<pre>
6
5 2
11011
7 4
1011011
6 1
010000
4 1
1111
8 3
10110110
6 4
111111
</pre>
<pre>
Bob
Alice
Alice
Bob
Bob
Alice
</pre>
  <p>В третьем примере Алиса может выбрать подпоследовательность, состоящую из s2, превратив s в 000000. Тогда она выигрывает немедленно.</p>
  <p>В четвертом примере можно показать, что нет способа для Алисы гарантировать, что она сможет превратить s в 0000 за конечное число ходов.</p>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n, k;
    cin >> n >> k;
    string s;
    cin >> s;

    // решение
    // посчитаем число единиц
    int cnt1 = 0;
    for (int i = 0; i &lt; n; i++) {
      if (s[i] == '1') {
        cnt1++;
      }
    }

    if (cnt1 &lt;= k || n &lt; 2 * k) {
      cout &lt;&lt; "Alice\n";
    } else {
      cout &lt;&lt; "Bob\n";
    }
  }

}
</pre>
  </details>
</article>


<!-- Задача E. Подсчет MEX -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Подсчет MEX</h3>

  <div><i>Ограничение по времени 3с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Определите MEX (минимальное исключенное значение) массива как наименьшее неотрицательное целое число, отсутствующее в массиве. Например,</p>
  <ul>
    <li>MEX([2,2,1])=0, потому что 0 отсутствует в массиве.</li>
    <li>MEX([3,1,0,1])=2, потому что 0 и 1 присутствуют в массиве, но 2 отсутствует.</li>
    <li>MEX([0,3,1,2])=4, потому что 0, 1, 2 и 3 присутствуют в массиве, но 4 отсутствует.</li>
  </ul>

  <p>Вам дан массив a из n неотрицательных целых чисел.</p>

  <p>Для всех k (0 ≤ k ≤ n) подсчитайте количество возможных значений MEX(a) после удаления ровно k элементов из a.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10⁴)  — количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит одно целое число n (1 ≤ n ≤ 2⋅10⁵) — размер массива a.</p>

  <p>Вторая строка каждого набора входных данных содержит n целых чисел, a1, a2, …, an (0 ≤ ai ≤ n).</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одну строку, содержащую n+1 целых чисел — количество возможных значений MEX(a) после удаления ровно k значений, для k=0,1,…,n.</p>

  <h4>Пример</h4>
<pre>
5
5
1 0 0 1 2
6
3 2 0 4 5 1
6
1 2 0 1 3 2
4
0 3 4 1
5
0 0 0 0 0
</pre>
<pre>
1 2 4 3 2 1
1 6 5 4 3 2 1
1 3 5 4 3 2 1
1 3 3 2 1
1 1 1 1 1 1
</pre>
  <p>В первом примере рассмотрим k=1. Если вы удалите 0, то получите следующий массив:</p>
  <code>1	0	1	2</code>
  <p>Таким образом, мы получаем MEX(a)=3. В качестве альтернативы, если вы удалите 2, то получите следующий массив:</p>
  <code>1	0	0	1</code>
  <p>Таким образом, мы получаем MEX(a)=2. Можно показать, что это единственные возможные значения MEX(a) после удаления ровно одного значения. Таким образом, вывод для k=1 равен 2.</p>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;map&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

  // число тестов
  int t = 1;
  cin >> t;

  while (t--)	{
    // ввод данных
    int n;
    cin >> n;

    // создадим частотный массив
    map&lt;int, int&gt; Freq;
    for (int i = 0; i &lt; n; i++)
    {
      int x;
      cin >> x;
      Freq[x]++;
    }

    vector&lt;bool&gt; prov(n + 1);
    //проверяет есть ли все числа до i включительно
    prov[0] = Freq[0] > 0;
    for (int i = 1; i &lt;= n; i++)
      prov[i] = prov[i - 1] && (Freq[i] > 0);


    vector&lt;int&gt; res(n + 2);//здесь будет ответ
    //чтоб получить mex== x надо удалить все x из массива,
    // но не удалить хотя бы одно вхождения чисел до него
    //соответственно можем посчитать верхню
    //и нижнюю границу для удалений чтоб получить mex==x
    //для подсчета будем использовать префикс суммы
    // чтоб прибавлять 1 на отрезке [l,r]
    //нужно прибавить в позицию l удиницу
    //и вычесть ее из позиции r+1
    //после префикссуммы получим массив с прибавлениями
    //для нуля тревиально считаем
    res[Freq[0]]++;
    res[n + 1]--;
    for (int i = 1; i &lt;= n; i++)// для mex>0
    {
      if (!prov[i - 1])
        //если нет какого-то числа меньше i
        //то больше никаких mex новых не получить
        break;

      //иначе считаем возможное количество удалений по формуле выше
      res[Freq[i]]++;
      res[n - i + 1]--;

    }
    for (int i = 1; i &lt;= n; i++)
    //префикс сумма считает ответ учитывая прибавления на отрезке
    {
      res[i] += res[i - 1];
    }

    // вывод результата
    for (int i = 0; i &lt;= n; i++)
      cout &lt;&lt; res[i] &lt;&lt; ' ';
    cout &lt;&lt; endl;
  }
}
</pre>
  </details>
</article>


<!-- Задача F. Минимизировать неподвижные точки -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Минимизировать неподвижные точки</h3>

  <div><i>Ограничение по времени 3с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Назовем перестановку∗ p длины n хорошей, если gcd(pi,i)† >1 для всех 2 ≤ i ≤ n. Найдите хорошую перестановку с минимальным количеством неподвижных точек‡ среди всех хороших перестановок длины n. Если таких перестановок несколько, выведите любую из них.</p>
  <p>* Перестановка длины n — это массив, который содержит каждое целое число от 1 до n ровно один раз, в любом порядке.</p>
  <p>† gcd(x,y) обозначает наибольший общий делитель (НОД) x и y.</p>
  <p>‡ Неподвижная точка перестановки p — это индекс j (1 ≤ j ≤ n), такой что pj=j.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Единственная строка каждого набора входных данных содержит целое число n (2 ≤ n ≤ 10⁵) — длину перестановки.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите на одной строке хорошую перестановку длины n с минимальным количеством неподвижных точек.</p>

  <h4>Пример</h4>
<pre>
4
2
3
6
13
</pre>
<pre>
1 2
1 2 3
1 4 6 2 5 3
1 12 9 6 10 8 7 4 3 5 11 2 13
</pre>
  <p>В третьем примере мы строим перестановку</p>
<pre>
i   pi   gcd(pi,i)
1   1    1
2   4    2
3   6    3
4   2    2
5   5    5
6   3    3
</pre>
  <p>Тогда мы видим, что gcd(pi,i) > 1 для всех 2 ≤ i ≤ 6. Более того, мы видим, что есть только две неподвижные точки, а именно 1 и 5. Можно показать, что невозможно построить хорошую перестановку длины 6 с меньшим количеством неподвижных точек.</p>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;map&gt;


using ll = long long;
using vll = std::vector&lt;ll&gt;;
using namespace std;

//заметим что 1 всегда на первом месте иначе массив плохой
//давайте разобьем числа на группы по наибольшему простому делителю в нем
//заметим что в каждой такой группе окажется либо он сам по себе или их будет много
//сам по себе он кажется только в том случае если в перестановке только он делится на себя,тогда нам с ним уже ничего не сделать

void slove()
{
  ll n;
  cin >> n;
  vector&lt;bool&gt; prov(n+1);
  vll tmp(n + 1);
  vll pr;
  for (ll i = 2; i &lt;= n; i++)//найдем все простые в этой перестановке
  {
    if (tmp[i] == 0)
    {
      pr.push_back(i);

      for (ll j = i * i; j &lt;= n; j += i)
        tmp[j] = 1;
    }
  }
  reverse(pr.begin(), pr.end());//перевернм чтоб идти от наибольшего
  map&lt;ll,vll&gt; an;//здесь будем хранить группы
  for (auto c: pr)
  {
    for (int i = c; i &lt;= n; i += c)//проходимся по числам которые делятся на текущий простой делитель и берем только те кого не брали
    {
      if (!prov[i])
      {
        prov[i] = true;
        an[c].push_back(i);
      }
    }
    //теперь мы хотим их перемешать между собой чтоб их индексы не совпадали с ними самими
    reverse(an[c].begin(), an[c].end());//есть огромное количество вариантов ка кэт сделать, я выбрал просто перевернуть группу
    ll sz = an[c].size();
    if (sz > 1 && sz % 2 == 1)//заметим что если у нас количество элементов в группе нечетное и больше 1,то мы получим что центральный эелемент остался на своем месте
    {
      swap(an[c][sz / 2], an[c][sz / 2 - 1]);//прсто свапнем его с соедом
    }
  }
  vll ans(n + 1);
  for (auto c : pr)//теперь раставляем числа в том порядке как они находятся в группе
  {
    ll t = 0;
    for (int i = c; i &lt;= n; i += c)
    {
      if (ans[i]==0)
      {
        ans[i] = an[c][t];
        t++;
      }
    }
  }
  ans[1] = 1;
  for (int i = 1; i &lt;= n; i++)
    cout &lt;&lt; ans[i] &lt;&lt; " ";
  cout &lt;&lt; endl;
}

int main()
{
  //Fbild(1e6, mod);
  ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);
  ll t = 1;

  cin >> t;

  while (t--)
  {
    slove();
  }
}
</pre>
  </details>
</article>


<!-- Задача G. Модульная сортировка -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Модульная сортировка</h3>

  <div><i>Ограничение по времени 5с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Дано целое число m (2 ≤ m ≤ 5⋅10⁵) и массив a, состоящий из неотрицательных целых чисел, меньших m.</p>

  <p>Ответьте на запросы следующего вида:</p>
  <ul>
    <li>1 i x : присвоить ai:=x</li>
    <li>2 k : за одно действие вы можете выбрать элемент ai и присвоить ai:=(ai+k)(modm) * — определите, существует ли некоторая последовательность (возможно, из нуля) операций, чтобы сделать a неубывающим†.</li>
  </ul>

  <p>Обратите внимание, что запросы типа 2 независимы, то есть фактически эти операции не выполняются. Запросы типа 1 являются постоянными.</p>

  <p>* a(modm) определяется как уникальное целое число b, такое что 0 ≤ b &lt; m и a-b является целым кратным m.</p>

  <p>† Массив a размера n называется неубывающим, если и только если ai≤ai+1 для всех 1 ≤ i &lt; n.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит три целых числа, n, m и q (2 ≤ n ≤ 10⁵, 2 ≤ m ≤ 5⋅10⁵, 1 ≤ q ≤ 10⁵) — размер массива a, целое число m и количество запросов.</p>

  <p>Вторая строка каждого набора входных данных содержит n
  целых чисел, a1, a2, …, an (0 ≤ ai &lt; m).</p>

  <p>Затем следуют q строк. Каждая строка имеет один из двух видов:</p>
  <ul>
    <li>1 i x (1 ≤ i ≤ n, 0 ≤ x &lt; m)</li>
    <li>2 k (1 ≤ k &lt; m)</li>
  </ul>
  <p>Гарантируется, что сумма n и сумма q по всем наборам входных данных не превышают 10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого запроса типа 2 выведите в одной строке «YES», если существует некоторая последовательность (возможно, из нуля) операций, чтобы сделать a неубывающим, и «NO» в противном случае.</p>

  <p>Вы можете выводить каждую букву в любом регистре (строчную или заглавную). Например, строки «yEs», «yes», «Yes» и «YES» будут приняты как положительный ответ.</p>

  <h4>Пример</h4>
<pre>
2
7 6 6
4 5 2 2 4 1 0
2 4
1 4 5
2 4
2 3
1 7 2
2 3
8 8 3
0 1 2 3 4 5 6 7
2 4
1 3 4
2 4
</pre>
<pre>
YES
NO
NO
YES
YES
NO
</pre>
  <p>В первом примере массив изначально выглядит так:</p>
  <code>4	5	2	2	4	1	0</code>
  <p>Применив операцию дважды к a1, дважды к a2, один раз к a5, дважды к a6 и один раз к a7, массив становится:</p>
  <code>0	1	2	2	2	3	4</code>
  <p>который находится в неубывающем порядке.</p>
  <p>После второго запроса массив становится:</p>
  <code>4	5	2	5	4	1	0</code>
  <p>и можно показать, что невозможно отсортировать его с помощью операций вида ai:=(ai+4)(mod6), и также невозможно отсортировать его с помощью операций вида ai:=(ai+3)(mod6).</p>

  <details>
    <summary>Решение</summary>
<pre>
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;cmath&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;deque&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;bitset&gt;
#include&lt;iomanip&gt;

using namespace std;

int main() {
  ios_base::sync_with_stdio(0);
  cin.tie(0);
  cout.tie(0);
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif
  int test;
  cin >> test;
  for (int t = 0; t &lt; test; t++)
  {
    int n, m, q;
    cin >> n >> m >> q;
    vector&lt;int&gt; A(n);
    for (int i = 0; i &lt; n; i++)
    {
      cin >> A[i];
    }
    vector&lt;int&gt; Del;
    int count = 0;
    map&lt;int, int&gt; mp_number_del;
    for (int i = 1; i*i &lt;= m; i++)
    {
      if (m % i == 0)
      {
        Del.push_back(i);
        pair&lt;int, int&gt; tmp;
        tmp.first = i;
        tmp.second = count;
        mp_number_del.insert(tmp);
        count++;
        if(i*i!=m)
        {
          Del.push_back(m/i);
          pair&lt;int, int&gt; tmp;
          tmp.first = m/i;
          tmp.second = count;
          mp_number_del.insert(tmp);
          count++;
        }
      }
    }
    vector&lt;vector&lt;int&gt; &gt; Dp(count, vector&lt;int&gt;(n));
    vector&lt;int&gt; Otrezkov(count,1);
    for (int i = 0; i &lt; count; i++)
    {
      for (int j = 0; j &lt; n; j++)
      {
        Dp[i][j] = A[j] % Del[i];
      }
    }
    for (int i = 0; i &lt; count; i++)
    {
      for (int j = 1; j &lt; n; j++)
      {
        if (Dp[i][j - 1] > Dp[i][j])
        {
          Otrezkov[i]++;
        }
      }
    }
    int type, id, x, k;
    for (int i = 0; i &lt; q; i++)
    {
      cin >> type;
      if (type == 1)
      {
        cin >> id >> x;
        id--;
        for (int str = 0; str &lt; Del.size(); str++)
        {
          if (id != 0)
          {
            if (Dp[str][id - 1] > Dp[str][id])
            {
              Otrezkov[str]--;
            }
          }
          if (id != n-1)
          {
            if (Dp[str][id] > Dp[str][id+1])
            {
              Otrezkov[str]--;
            }
          }
          Dp[str][id] = x % Del[str];

          if (id != 0)
          {
            if (Dp[str][id - 1] > Dp[str][id])
            {
              Otrezkov[str]++;
            }
          }
          if (id != n - 1)
          {
            if (Dp[str][id] > Dp[str][id + 1])
            {
              Otrezkov[str]++;
            }
          }
        }
      }
      else
      {
        cin >> k;
        int gcd;
        int a, b;
        a = k;
        b = m;
        while (a > 0 && b > 0)
        {
          if (a > b)
            a %= b;
          else
            b %= a;
        }
        gcd = a + b;
        int str1 = mp_number_del.find(gcd)->second;
        if (Otrezkov[str1] &lt;= m / gcd)
          cout &lt;&lt; "YES\n";
        else
          cout &lt;&lt; "NO\n";
      }
    }

  }

}
</pre>
  </details>
</article>
