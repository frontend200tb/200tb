<article class="article">
  <a href="https://codeforces.com/contest/2123" target="_blank">Codeforces Round 1034 (Div.3) 2025-07-01</a>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

      <a href="#task1">Задача A. И снова игра на доске</a>
  <br><a href="#task2">Задача B. Турнир</a>
  <br><a href="#task3">Задача C. Минимум префикса и максимум суффикса</a>
  <br><a href="#task4">Задача D. Битва на бинарной строке</a>
  <br><a href="#task5">Задача E. Подсчет MEX</a>
  <br><a href="#task6">Задача F. Минимизировать неподвижные точки</a>
  <br><a href="#task7">Задача G. Модульная сортировка</a>
</article>


<!-- Задача A. И снова игра на доске -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. И снова игра на доске</h3>

  <div><i>Ограничение по времени 1с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Изначально на доске написаны целые числа от 0 до n-1.</p>
  <p>В одном раунде,</p>
  <ul>
    <li>Алиса выбирает целое число a на доске и стирает его;</li>
    <li>затем Боб выбирает целое число b на доске так, чтобы a+b≡3(mod4) * и стирает его.</li>
  </ul>
  <p>Раунды проходят последовательно, пока один из игроков не сможет сделать ход — первый игрок, который не сможет сделать ход, проигрывает. Определите, кто выигрывает при оптимальной игре.</p>
  <p>* Мы определяем, что x≡y(modm), когда x-y является целым кратным m.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 100)  — количество наборов входных данных.</p>

  <p>Единственная строка каждого набора входных данных содержит целое число n (1 ≤ n ≤ 100) — количество целых чисел, написанных на доске.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите в одной строке «Alice», если Алиса выигрывает при оптимальной игре, и «Bob», если Боб выигрывает при оптимальной игре.</p>

  <p>Вы можете выводить ответ в любом регистре (верхнем или нижнем). Например, строки «aLiCe», «alice», «ALICE», и «alICE» будут распознаны как «Alice».</p>

  <h4>Пример</h4>
<pre>
5
2
4
5
7
100
</pre>
<pre>
Alice
Bob
Alice
Alice
Bob
</pre>
  <p>В первом примере, предположим, Алиса выбирает 0, тогда Боб не может выбрать ни одно число, и Алиса выигрывает немедленно.</p>
  <p>Во втором примере, предположим, Алиса выбирает 0, тогда Боб может выбрать 3. Затем предположим, что Алиса выбирает 2, тогда Боб может выбрать 1. В итоге у Алисы не останется чисел, и Боб выигрывает.</p>

  <details>
    <summary>Решение</summary>
    <p>Если при делении n на 4 получаем остаток, то у Алисы есть возможность взять лишний нолик, а у Боба нет возможности взять соответствующее число с остатком на 3.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n;
    cin >> n;

    // решение и вывод результата
    if (n % 4) {
      cout &lt;&lt; "Alice";
    } else {
      cout &lt;&lt; "Bob";
    }
    cout &lt;&lt; '\n';
  }

}
</pre>
  </details>
</article>


<!-- Задача B. Турнир -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Турнир</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Дан массив целых чисел a1, a2, …, an. Проводится турнир с n игроками. У игрока i сила ai.</p>

  <p>Пока остаётся более k игроков:</p>
  <ul>
    <li>Два оставшихся игрока выбираются случайным образом;</li>
    <li>Игрок с меньшей силой исключается. Если выбранные игроки имеют одинаковую силу, один из них исключается случайным образом.</li>
  </ul>

  <p>Даны целые числа j и k (1 ≤ j, k ≤ n), определите, есть ли способ для игрока j стать одним из последних k оставшихся игроков.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10⁴)  — количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит три целых числа n, j и k (2 ≤ n ≤ 2⋅10⁵, 1 ≤ j, k ≤ n).</p>

  <p>Вторая строка каждого набора входных данных содержит n целых чисел, a1, a2, …, an (1 ≤ ai ≤ n).</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите в одной строке «YES», если игрок j может быть одним из последних k оставшихся игроков, и «NO» в противном случае.</p>

  <p>Вы можете выводить каждую букву в любом регистре (строчную или заглавную). Например, строки «yEs», «yes», «Yes» и «YES» будут приняты как положительный ответ.</p>

  <h4>Пример</h4>
<pre>
3
5 2 3
3 2 4 4 1
5 4 1
5 3 4 5 2
6 1 1
1 2 3 4 5 6
</pre>
<pre>
YES
YES
NO
</pre>
  <p>В первом примере предположим, что выбраны игроки 2 и 5. Тогда игрок 2 побеждает игрока 5. Теперь оставшиеся силы игроков:</p>
  <code>3	2	4	4</code>
  <p>Далее предположим, что выбраны игроки 3 и 4. Тогда игрок 3 может победить игрока 4. Теперь оставшиеся силы игроков:</p>
  <code>3	2	4</code>
  <p>Игрок 2 является одним из последних трёх оставшихся игроков.</p>
  <p>В третьем примере можно показать, что нет способа для игрока 1 стать последним оставшимся игроком.</p>

  <details>
    <summary>Решение</summary>
    <p>Если должно остаться 2 и более игрока, то ответ "YES". Если должен остаться только один игрок, то останется самый сильный.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n, j, k;
    cin >> n >> j >> k;
    vector&lt;int&gt; A(n + 1);
    for (int i = 1; i &lt;= n; i++) {
      cin >> A[i]; // сила i-го игрока
    }

    // решение
    string ans = "YES";
    // находим максимальное число
    int maxai = A[1];
    for (int i = 2; i &lt;= n; i++) {
      if (A[i] > maxai) {
        maxai = A[i];
      }
    }

    // если k == 1 и A[j] не максимально
    // то не может
    if (k == 1 && A[j] != maxai) {
      ans = "NO";
    }

    // вывод результата
    cout &lt;&lt; ans &lt;&lt; '\n';
  }

}
</pre>
  </details>
</article>


<!-- Задача C. Минимум префикса и максимум суффикса -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Минимум префикса и максимум суффикса</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам дан массив a из различных целых чисел.</p>

  <p>В одной операции вы можете либо:</p>
  <ul>
    <li>выбрать непустой префикс∗ массива a и заменить его на его минимальное значение, или</li>
    <li>выбрать непустой суффикс† массива a и заменить его на его максимальное значение.</li>
  </ul>
  <p>Обратите внимание, что вы можете выбрать весь массив a.</p>

  <p>Для каждого элемента ai определите, существует ли последовательность операций, чтобы преобразовать a в [ai]; то есть сделать так, чтобы массив a состоял только из одного элемента, который равен ai. Выведите ваш ответ в виде двоичной строки длины n, где i-й символ равен 1, если существует последовательность, чтобы преобразовать a в [ai], и 0 в противном случае.</p>

  <p>* Префикс массива — это подмассив, состоящий из первых k
  элементов массива, для некоторого целого k.</p>
  <p>† Суффикс массива — это подмассив, состоящий из последних k
  элементов массива, для некоторого целого k.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10⁴)  — количество наборов входных данных.</p>
  <p>Первая строка каждого набора входных данных содержит одно целое число n (2 ≤ n ≤ 2⋅10⁵) — размер массива a.</p>

  <p>Вторая строка каждого набора входных данных содержит n целых чисел, a1, a2, …, an (1 ≤ ai ≤ 10⁶). Гарантируется, что все ai различны.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите двоичную строку длины n, i-й символ должен быть 1, если существует последовательность операций, как описано выше, и 0 в противном случае.</p>

  <h4>Пример</h4>
<pre>
3
6
1 3 5 4 7 2
4
13 10 12 20
7
1 2 3 4 5 6 7
</pre>
<pre>
100011
1101
1000001
</pre>
  <p>В первом примере вы можете сначала выбрать префикс длины 3. Затем массив преобразуется в</p>
  <code>1	4	7	2</code>
  <p>Далее вы можете выбрать суффикс длины 2. Затем массив преобразуется в</p>
  <code>1	4	7</code>
  <p>Наконец, вы можете выбрать префикс длины 3. Затем массив преобразуется в</p>
  <code>1</code>
  <p>Таким образом, мы видим, что возможно преобразовать a в [1].</p>
  <p>Можно показать, что невозможно преобразовать a в [3].</p>

  <details>
    <summary>Решение</summary>
    <p>Преобразование массива в заданный элемент возможно только в том случае если слева от заданного элемента нет числа меньше, или справа нет числа больше. Соберем префикс минимумов и суффикс максимумов, чтобы проверять это условие для каждого числа из массива.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n;
    cin >> n;
    vector&lt;int&gt; A(n + 1);
    for (int i = 1; i &lt;= n; i++) {
      cin >> A[i];
    }

    // решение
    // строка результата
    string res(n, '0');

    // соберем префикс минимумов
    vector&lt;int&gt; Pref(n + 1);
    Pref[1] = A[1];
    for (int i = 2; i &lt;= n; i++) {
      Pref[i] = min(Pref[i - 1], A[i]);
    }

    // соберем суффикс максимумов
    vector&lt;int&gt; Suf(n + 1);
    Suf[n] = A[n];
    for (int i = n - 1; i >= 1; i--) {
      Suf[i] = max(Suf[i + 1], A[i]);
    }

    // для каждого элемента массива проверим условие
    for (int i = 1; i &lt;= n; i++) {
      if (A[i] == Pref[i] || A[i] == Suf[i]) {
        res[i - 1] = '1';
      }
    }

    // вывод результата
    cout &lt;&lt; res &lt;&lt; '\n';
  }

}
</pre>
  </details>
</article>


<!-- Задача D. Битва на бинарной строке -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Битва на бинарной строке</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Алиса и Боб получили бинарную строку s длиной n и целое число k (1 ≤ k &lt; n).</p>

  <p>Алиса выигрывает, если ей удается преобразовать все символы строки s в нули. Если Алиса не может выиграть за конечное число ходов, то выигрывает Боб.</p>

  <p>Алиса и Боб ходят по очереди, при этом первой ходит Алиса.</p>
  <ul>
    <li>В свой ход Алиса может выбрать любую подпоследовательность∗ длиной k в строке s, а затем установить все символы в этой подпоследовательности в нули.</li>
    <li>В свой ход Боб может выбрать любую подстроку† длиной k в строке s, а затем установить все символы в этой подстроке в единицы.</li>
  </ul>

  <p>Обратите внимание, что Алиса выигрывает, если строка состоит из всех нулей в любой момент игры, включая промежутки между ходами Алисы и Боба.</p>

  <p>Определите, кто выигрывает при оптимальной игре.</p>

  <p>* Подпоследовательность строки s — это набор символов в s. Обратите внимание, что эти символы не обязательно должны быть смежными.</p>

  <p>† Подстрока строки s — это непрерывная группа символов в s. Обратите внимание, что эти символы должны быть смежными.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10⁴)  — количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит два целых числа n и k (2 ≤ n ≤ 2⋅10⁵, 1 ≤ k &lt; n).</p>

  <p>Вторая строка каждого набора входных данных содержит бинарную строку s длиной n.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите в одной строке «Alice», если Алиса выигрывает при оптимальной игре, и «Bob», если Боб выигрывает при оптимальной игре.</p>

  <p>Вы можете выводить ответ в любом регистре (верхнем или нижнем). Например, строки «aLiCe», «alice», «ALICE», и «alICE» будут распознаны как «Alice».</p>

  <h4>Пример</h4>
<pre>
6
5 2
11011
7 4
1011011
6 1
010000
4 1
1111
8 3
10110110
6 4
111111
</pre>
<pre>
Bob
Alice
Alice
Bob
Bob
Alice
</pre>
  <p>В третьем примере Алиса может выбрать подпоследовательность, состоящую из s2, превратив s в 000000. Тогда она выигрывает немедленно.</p>
  <p>В четвертом примере можно показать, что нет способа для Алисы гарантировать, что она сможет превратить s в 0000 за конечное число ходов.</p>

  <details>
    <summary>Решение</summary>
    <p>Посчитаем число единиц cnt1 в бинарной строке. Если cnt1 ≤ k то выигрывает Алиса, потому что Алиса сразу преобразовывает все символы в нули. Иначе, смотрим на длину исходной строки. Если n ≥ 2 * k то выигрывает Боб, потому что боб может поочередно преобразовывать символы в единицы то из левой части массива, то из правой.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n, k;
    cin >> n >> k;
    string s;
    cin >> s;

    // решение
    // посчитаем число единиц
    int cnt1 = 0;
    for (int i = 0; i &lt; n; i++) {
      if (s[i] == '1') {
        cnt1++;
      }
    }

    // проверяем условие и выводим результат
    if (cnt1 &lt;= k || n &lt; 2 * k) {
      cout &lt;&lt; "Alice\n";
    } else {
      cout &lt;&lt; "Bob\n";
    }
  }

}
</pre>
  </details>
</article>


<!-- Задача E. Подсчет MEX -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Подсчет MEX</h3>

  <div><i>Ограничение по времени 3с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Определите MEX (минимальное исключенное значение) массива как наименьшее неотрицательное целое число, отсутствующее в массиве. Например,</p>
  <ul>
    <li>MEX([2,2,1])=0, потому что 0 отсутствует в массиве.</li>
    <li>MEX([3,1,0,1])=2, потому что 0 и 1 присутствуют в массиве, но 2 отсутствует.</li>
    <li>MEX([0,3,1,2])=4, потому что 0, 1, 2 и 3 присутствуют в массиве, но 4 отсутствует.</li>
  </ul>

  <p>Вам дан массив a из n неотрицательных целых чисел.</p>

  <p>Для всех k (0 ≤ k ≤ n) подсчитайте количество возможных значений MEX(a) после удаления ровно k элементов из a.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10⁴)  — количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит одно целое число n (1 ≤ n ≤ 2⋅10⁵) — размер массива a.</p>

  <p>Вторая строка каждого набора входных данных содержит n целых чисел, a₁, a₂, …, aₙ (0 ≤ aᵢ ≤ n).</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одну строку, содержащую n+1 целых чисел — количество возможных значений MEX(a) после удаления ровно k значений, для k=0,1,…,n.</p>

  <h4>Пример</h4>
<pre>
5
5
1 0 0 1 2
6
3 2 0 4 5 1
6
1 2 0 1 3 2
4
0 3 4 1
5
0 0 0 0 0
</pre>
<pre>
1 2 4 3 2 1
1 6 5 4 3 2 1
1 3 5 4 3 2 1
1 3 3 2 1
1 1 1 1 1 1
</pre>
  <p>В первом примере рассмотрим k=1. Если вы удалите 0, то получите следующий массив:</p>
  <code>1	0	1	2</code>
  <p>Таким образом, мы получаем MEX(a)=3. В качестве альтернативы, если вы удалите 2, то получите следующий массив:</p>
  <code>1	0	0	1</code>
  <p>Таким образом, мы получаем MEX(a)=2. Можно показать, что это единственные возможные значения MEX(a) после удаления ровно одного значения. Таким образом, вывод для k=1 равен 2.</p>

  <details>
    <summary>Решение</summary>
    <p>При k = 0 (не удаляли элементы) MEX будет один и равен исходному mex. При k = n (удалили все элементы) MEX тоже будет один и равен нулю.</p>
    <p>Посчитаем сколько раз в массиве встречается каждое число. Для этого создадим частотный словарь F, где ключ это число из входного массива, а значение это сколько раз оно встречается.</p>
    <p>Найдем максимальное число в массиве.</p>
    <p>Определим MEX исходного массива как первое минимальное число mex в частотном словаре F, которое встречается 0 раз. При удалении элементов из массива, MEX может оставаться таким же или быть меньше, то есть принимать значения от 0 до mex. Значит, количество возможных значений MEX будет от 1 до mex+1.</p>
    <p>Допустим, в частотном словаре получилось два нуля. Это значит, чтобы получить MEX = 0 нужно удалить эти два нуля, то есть удалить два или более элементов. Чтобы получить MEX = i (i ≤ mex) нужно удалить все вхождения i в исходный массив, но не удалить ни одного элемента, меньшего чем i.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // размер массива
    cin >> n;

    // создадим частотный словарь
    // ключ - число, значение - сколько раз встречается
    vector&lt;int&gt; F(n + 1, 0);
    for (int i = 0; i &lt; n; i++) {
      int x; // число от 0 до n
      cin >> x;
      F[x]++;
    }

    // патерн ключ-значение, значение-ключ
    // создадим инферсный частотный массив
    // ключ - количество чисел, значение - число
    // прибавляя, будем вычитать лишнее число с конца
    vector&lt;int&gt; invF(n + 2, 0);
    for (int i = 0; i &lt;=n; i++) {
      invF[F[i]]++;
      invF[n - i + 1]--;
      if (F[i] == 0) break;
    }

    // создадим массив для результата
    vector&lt;int&gt; Res(n + 1, 0);
    Res[0] = 1; // при удалении 0 элементов
    Res[n] = 1; // при удалении всех n элементов

    // для каждого числа от 1 до n - 1
    for (int k = 1; k &lt; n; k++) {
      Res[k] = Res[k - 1] + invF[k];
    }

    // вывод результата
    for (int i = 0; i &lt;= n; i++)
      cout &lt;&lt; Res[i] &lt;&lt; ' ';
    cout &lt;&lt; endl;
  }
}
</pre>
  </details>
</article>


<!-- Задача F. Минимизировать неподвижные точки -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Минимизировать неподвижные точки</h3>

  <div><i>Ограничение по времени 3с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Назовем перестановку∗ p длины n хорошей, если gcd(pi,i)† >1 для всех 2 ≤ i ≤ n. Найдите хорошую перестановку с минимальным количеством неподвижных точек‡ среди всех хороших перестановок длины n. Если таких перестановок несколько, выведите любую из них.</p>
  <p>* Перестановка длины n — это массив, который содержит каждое целое число от 1 до n ровно один раз, в любом порядке.</p>
  <p>† gcd(x,y) обозначает наибольший общий делитель (НОД) x и y.</p>
  <p>‡ Неподвижная точка перестановки p — это индекс j (1 ≤ j ≤ n), такой что pj=j.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Единственная строка каждого набора входных данных содержит целое число n (2 ≤ n ≤ 10⁵) — длину перестановки.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите на одной строке хорошую перестановку длины n с минимальным количеством неподвижных точек.</p>

  <h4>Пример</h4>
<pre>
4
2
3
6
13
</pre>
<pre>
1 2
1 2 3
1 4 6 2 5 3
1 12 9 6 10 8 7 4 3 5 11 2 13
</pre>
  <p>В третьем примере мы строим перестановку</p>
<pre>
i   pi   gcd(pi,i)
1   1    1
2   4    2
3   6    3
4   2    2
5   5    5
6   3    3
</pre>
  <p>Тогда мы видим, что gcd(pi,i) > 1 для всех 2 ≤ i ≤ 6. Более того, мы видим, что есть только две неподвижные точки, а именно 1 и 5. Можно показать, что невозможно построить хорошую перестановку длины 6 с меньшим количеством неподвижных точек.</p>

  <details>
    <summary>Решение</summary>
    <p>Найдем простые числа x в диапазоне от 1 до n. Будем переставлять их с числами 2*x, 3*x и т.д. которые меньше n.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;set&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // размер массива
    cin >> n;

    // соберем решето эратосфена
    vector&lt;int&gt; A(n + 1);
    A[0] = 1;
    A[1] = 1;
    for (int i = 2; i &lt;= n; i++) {
      if (A[i] == 0) {
        for (int j = 2 * i; j &lt;= n; j += i) {
          A[j] = 1;
        }
      }
    }

    // обойдем все простые и составные числа
    set&lt;int&gt; st;
    vector&lt;int&gt; Result(n + 1);
    Result[1] = 1;
    for (int i = n; i > 0; i--) {
      if (A[i] == 0) {
        if (i * 2 &lt;= n) {
          vector&lt;int&gt; Chain;
          int k = 1;

          while (i * k &lt;= n) {
            if (st.find(i * k) == st.end()) {
              Chain.push_back(i * k);
              st.insert(i * k);
            }
            k++;
          }

          Chain.push_back(i);
          // соберем результат
          for (int j = 0; j &lt; Chain.size() - 1; j++) {
            Result[Chain[j]] = Chain[j + 1];
          }
        } else {
          Result[i] = i;
        }
      }
    }

    // вывод результата
    for (int i = 1; i &lt;= n; i++) {
      cout &lt;&lt; Result[i] &lt;&lt; ' ';
    }
    cout &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача G. Модульная сортировка -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Модульная сортировка</h3>

  <div><i>Ограничение по времени 5с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Дано целое число m (2 ≤ m ≤ 5⋅10⁵) и массив a, состоящий из неотрицательных целых чисел, меньших m.</p>

  <p>Ответьте на запросы следующего вида:</p>
  <ul>
    <li>1 i x : присвоить ai:=x</li>
    <li>2 k : за одно действие вы можете выбрать элемент ai и присвоить ai:=(ai+k)(mod m) * — определите, существует ли некоторая последовательность (возможно, из нуля) операций, чтобы сделать a неубывающим†.</li>
  </ul>

  <p>Обратите внимание, что запросы типа 2 независимы, то есть фактически эти операции не выполняются. Запросы типа 1 являются постоянными.</p>

  <p>* a(modm) определяется как уникальное целое число b, такое что 0 ≤ b &lt; m и a-b является целым кратным m.</p>

  <p>† Массив a размера n называется неубывающим, если и только если ai≤ai+1 для всех 1 ≤ i &lt; n.</p>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит три целых числа, n, m и q (2 ≤ n ≤ 10⁵, 2 ≤ m ≤ 5⋅10⁵, 1 ≤ q ≤ 10⁵) — размер массива a, целое число m и количество запросов.</p>

  <p>Вторая строка каждого набора входных данных содержит n
  целых чисел, a1, a2, …, an (0 ≤ ai &lt; m).</p>

  <p>Затем следуют q строк. Каждая строка имеет один из двух видов:</p>
  <ul>
    <li>1 i x (1 ≤ i ≤ n, 0 ≤ x &lt; m)</li>
    <li>2 k (1 ≤ k &lt; m)</li>
  </ul>
  <p>Гарантируется, что сумма n и сумма q по всем наборам входных данных не превышают 10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого запроса типа 2 выведите в одной строке «YES», если существует некоторая последовательность (возможно, из нуля) операций, чтобы сделать a неубывающим, и «NO» в противном случае.</p>

  <p>Вы можете выводить каждую букву в любом регистре (строчную или заглавную). Например, строки «yEs», «yes», «Yes» и «YES» будут приняты как положительный ответ.</p>

  <h4>Пример</h4>
<pre>
2
7 6 6
4 5 2 2 4 1 0
2 4
1 4 5
2 4
2 3
1 7 2
2 3
8 8 3
0 1 2 3 4 5 6 7
2 4
1 3 4
2 4
</pre>
<pre>
YES
NO
NO
YES
YES
NO
</pre>
  <p>В первом примере массив изначально выглядит так:</p>
  <code>4	5	2	2	4	1	0</code>
  <p>Применив операцию дважды к a1, дважды к a2, один раз к a5, дважды к a6 и один раз к a7, массив становится:</p>
  <code>0	1	2	2	2	3	4</code>
  <p>который находится в неубывающем порядке.</p>
  <p>После второго запроса массив становится:</p>
  <code>4	5	2	5	4	1	0</code>
  <p>и можно показать, что невозможно отсортировать его с помощью операций вида ai:=(ai+4)(mod6), и также невозможно отсортировать его с помощью операций вида ai:=(ai+3)(mod6).</p>

  <details>
    <summary>Решение</summary>
<pre>
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;cmath&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;deque&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;bitset&gt;
#include&lt;iomanip&gt;

using namespace std;

int main() {
  ios_base::sync_with_stdio(0);
  cin.tie(0);
  cout.tie(0);
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif
  int test;
  cin >> test;
  for (int t = 0; t &lt; test; t++)
  {
    int n, m, q;
    cin >> n >> m >> q;
    vector&lt;int&gt; A(n);
    for (int i = 0; i &lt; n; i++)
    {
      cin >> A[i];
    }
    vector&lt;int&gt; Del;
    int count = 0;
    map&lt;int, int&gt; mp_number_del;
    for (int i = 1; i*i &lt;= m; i++)
    {
      if (m % i == 0)
      {
        Del.push_back(i);
        pair&lt;int, int&gt; tmp;
        tmp.first = i;
        tmp.second = count;
        mp_number_del.insert(tmp);
        count++;
        if(i*i!=m)
        {
          Del.push_back(m/i);
          pair&lt;int, int&gt; tmp;
          tmp.first = m/i;
          tmp.second = count;
          mp_number_del.insert(tmp);
          count++;
        }
      }
    }
    vector&lt;vector&lt;int&gt; &gt; Dp(count, vector&lt;int&gt;(n));
    vector&lt;int&gt; Otrezkov(count,1);
    for (int i = 0; i &lt; count; i++)
    {
      for (int j = 0; j &lt; n; j++)
      {
        Dp[i][j] = A[j] % Del[i];
      }
    }
    for (int i = 0; i &lt; count; i++)
    {
      for (int j = 1; j &lt; n; j++)
      {
        if (Dp[i][j - 1] > Dp[i][j])
        {
          Otrezkov[i]++;
        }
      }
    }
    int type, id, x, k;
    for (int i = 0; i &lt; q; i++)
    {
      cin >> type;
      if (type == 1)
      {
        cin >> id >> x;
        id--;
        for (int str = 0; str &lt; Del.size(); str++)
        {
          if (id != 0)
          {
            if (Dp[str][id - 1] > Dp[str][id])
            {
              Otrezkov[str]--;
            }
          }
          if (id != n-1)
          {
            if (Dp[str][id] > Dp[str][id+1])
            {
              Otrezkov[str]--;
            }
          }
          Dp[str][id] = x % Del[str];

          if (id != 0)
          {
            if (Dp[str][id - 1] > Dp[str][id])
            {
              Otrezkov[str]++;
            }
          }
          if (id != n - 1)
          {
            if (Dp[str][id] > Dp[str][id + 1])
            {
              Otrezkov[str]++;
            }
          }
        }
      }
      else
      {
        cin >> k;
        int gcd;
        int a, b;
        a = k;
        b = m;
        while (a > 0 && b > 0)
        {
          if (a > b)
            a %= b;
          else
            b %= a;
        }
        gcd = a + b;
        int str1 = mp_number_del.find(gcd)->second;
        if (Otrezkov[str1] &lt;= m / gcd)
          cout &lt;&lt; "YES\n";
        else
          cout &lt;&lt; "NO\n";
      }
    }

  }

}
</pre>
  </details>
</article>
