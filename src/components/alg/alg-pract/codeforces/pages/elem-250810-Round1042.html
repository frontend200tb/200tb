<article class="article">
  <a href="https://codeforces.com/contest/2131" target="_blank">Codeforces 2131 Round 1042 (Div. 3) 2025-08-10</a>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

      <a href="#task1">Задача A. Рычаг</a>
  <br><a href="#task2">Задача B. Чередующаяся последовательность</a>
  <br><a href="#task3">Задача C. Уравняй</a>
  <br><a href="#task4">Задача D. Сжатие дерева</a>
  <br><a href="#task5">Задача E. Соседний XOR</a>
  <br><a href="#task6">Задача F. Несправедливая бинарная жизнь</a>
  <br><a href="#task7">Задача G. Wafu!</a>
  <br><a href="#task8">Задача H. Взаимнопростые пары</a>
</article>


<!-- Задача A. Рычаг -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Рычаг</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>В Виртуальной Вселенной Рычаг выполняет итерации, используя два массива a и b длиной n. На каждой итерации Рычаг будет делать следующее:</p>
  <ol>
    <li>Выбрать случайный индекс i такой, что ai > bi. Затем уменьшить ai на 1. Если такого i не существует, пропустить этот шаг.</li>
    <li>Выбрать случайный индекс i такой, что ai &lt; bi. Затем увеличить ai на 1. Если такого i не существует, пропустить этот шаг.</li>
  </ol>

  <p>После каждой итерации Рычаг проверит, был ли пропущен шаг 1, и если да, то завершит свою итерацию.</p>

  <p>Вам даны два массива. Найдите количество итераций, которые выполняет Рычаг.</p>

  <h4>Входные данные</h4>
  <p>Каждый тест состоит из нескольких наборов входных данных. В первой строке находится одно целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных. Далее следует описание наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит одно целое число n (1 ≤ n ≤ 10).</p>

  <p>Вторая строка каждого набора входных данных содержит n целых чисел a1, a2, …, an (1 ≤ ai ≤ 10).</p>

  <p>Третья строка каждого набора входных данных содержит n целых чисел b1, b2, …, bn (1 ≤ bi ≤ 10).</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно целое число — количество итераций, которые выполнит Рычаг.</p>

  <details>
    <summary>Пример</summary>
<pre>
4
2
7 3
5 6
3
3 1 4
3 1 4
1
10
1
6
1 1 4 5 1 4
1 9 1 9 8 1
</pre>
<pre>
3
1
10
7
</pre>

  <p>В первой итерации Рычаг уменьшает a1 на 1 и увеличивает a2 на 1, и a становится [6,4].</p>

  <p>Во второй итерации Рычаг уменьшает a1 на 1 и увеличивает a2 на 1, и a становится [5,5].</p>

  <p>В третьей итерации Рычаг увеличивает a2 на 1, и a становится [5,6]. Поскольку не удается уменьшить элемент, итерация завершается. Таким образом, ответ равен 3.</p>

  <p>Во втором примере Рычаг ничего не делает в своей первой итерации, и, следовательно, выполняет только одну итерацию.</p>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

// условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // размер массива
    cin >> n;
    vector&lt;int&gt; A(n);
    for (int i = 0; i &lt; n; i++) {
      cin >> A[i];
    }
    vector&lt;int&gt; B(n);
    for (int i = 0; i &lt; n; i++) {
      cin >> B[i];
    }

    // решение
    int res = 1;
    // найдем пары, где A[i] > B[i]
    // будем разницу добавлять в результат
    for (int i = 0; i &lt; n; i++) {
      if (A[i] > B[i]) {
        res += A[i] - B[i];
      }
    }

    // вывод результата
    cout &lt;&lt; res &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача B. Чередующаяся последовательность -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Чередующаяся последовательность</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вам дано целое число n. Массив a длины n называется хорошим, если:</p>
  <ul>
    <li>Для всех 1 ≤ i &lt; n, ai ⋅ ai + 1 &lt; 0.</li>
    <li>Для всех подмассивов∗ из хотя бы 2 элементов, сумма всех элементов подмассива положительна†.</li>
  </ul>

  <p>Кроме того, мы говорим, что хороший массив a длины n лучше другого хорошего массива b длины n, если [|a1|,|a2|,…,|an|] лексикографически меньше‡ чем [|b1|,|b2|,…,|bn|]. Обратите внимание, |z| обозначает абсолютное значение числа z.</p>

  <p>Выведите хороший массив длины n, который лучше, чем любой другой хороший массив длины n.</p>

  <p>* Массив c является подмассивом массива d, если c может быть получен из d удалением нескольких (возможно, ни одного или всех) элементов с начала и нескольких (возможно, ни одного или всех) элементов с конца.</p>

  <p>† Число x положительно, если x > 0.</p>

  <p>‡ Последовательность a лексикографически меньше последовательности b, если и только если выполняется одно из следующего:</p>
  <ul>
    <li>a — префикс b, но a≠b; или</li>
    <li>в первой позиции, где a и b различны, в последовательности a элемент меньше, чем соответствующий элемент в b.</li>
  </ul>

  <h4>Входные данные</h4>
  <p>Первая строка содержит целое число t (1 ≤ t ≤ 500) — количество наборов входных данных.</p>

  <p>Единственная строка каждого набора входных данных содержит одно целое число n (2 ≤ n ≤ 2⋅10⁵) — длину вашего массива.</p>

  <p>Гарантируется, что сумма значений n по всем наборам входных данных не превосходит 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите n целых чисел a1, a2, …, an (-10⁹ ≤ ai ≤ 10⁹), элементы вашего массива на новой строке.</p>

  <details>
    <summary>Пример</summary>
<pre>
2
2
3
</pre>
<pre>
-1 2
-1 3 -1
</pre>
  <p>В первом наборе входных данных, поскольку a1⋅a2 = -2 &lt; 0 и a1 + a2 = 1 > 0, он удовлетворяет двум условиям. Кроме того, можно показать, что соответствующий b = [1,2] является лучше любого другого хорошего массива длины 2.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>При четном n последовательность может иметь вид  -1 3 -1 3 ... -1 2</p>
    <p>При нечетном n последовательность может иметь вид -1 3 -1 3 ... -1 3 -1</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
// условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // размер массива
    cin >> n;

    // решение
    for (int i = 0; i &lt; n - 1; i++) {
      if (i % 2 == 0) {
        cout &lt;&lt; -1 &lt;&lt; ' ';
      } else {
        cout &lt;&lt; 3 &lt;&lt; ' ';
      }
    }
    if (n % 2 == 0) {
      cout &lt;&lt; 2 &lt;&lt; '\n';
    } else {
      cout &lt;&lt; -1 &lt;&lt; '\n';
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача C. Уравняй -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Уравняй</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Даны два мультимножества S и T размером n и положительное целое число k, вы можете выполнять следующие операции любое количество раз (включая ноль) на S:</p>
  <ul>
    <li>Выберите элемент x в S и удалите одно вхождение x из S. Затем либо вставьте x+k в S, либо вставьте |x-k| в S.</li>
  </ul>

  <p>Определите, возможно ли сделать S равным T. Мультимножество S равно мультимножеству T, если каждый элемент присутствует в S и в T одинаковое число раз.</p>

  <h4>Входные данные</h4>
  <p>Каждый тест содержит несколько наборов входных данных. Первая строка содержит целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных. Описание наборов входных данных следует далее.</p>

  <p>Первая строка содержит два целых числа n и k (1 ≤ n ≤ 2⋅10⁵, 1 ≤ k ≤ 10⁹) — размер S и константа соответственно.</p>

  <p>Вторая строка содержит n целых чисел S1, S2, …, Sn (0 ≤ Si ≤ 10⁹) — элементы в S.</p>

  <p>Третья строка содержит n целых чисел T1, T2, …, Tn (0 ≤ Ti ≤ 10⁹) — элементы в T.</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите «YES», если возможно сделать S равным T, и «NO», в противном случае.</p>

  <p>Вы можете выводить ответ в любом регистре (верхнем или нижнем). Например, строки «yEs», «yes», «Yes», и «YES» будут распознаны как положительные ответы.</p>

  <details>
    <summary>Пример</summary>
<pre>
5
1 3
1
2
1 8
4
12
3 5
6 2 9
8 4 11
2 7
2 8
2 9
3 2
0 1 0
1 0 1
</pre>
<pre>
YES
YES
YES
NO
NO
</pre>
  <p>В первом наборе входных данных мы можем удалить одно вхождение 1 из S и вставить |1-k|=|1-3|=2 в S, сделав S равным T.</p>

  <p>Во втором наборе входных данных мы можем удалить одно вхождение 4 из S и вставить 4+k=4+8=12 в S, сделав S равным T.</p>

  <p>В последнем наборе входных данных мы можем показать, что невозможно сделать S равным T.</p>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;map&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

// условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    long long n, k;
    cin >> n >> k;
    map&lt;long long, long long&gt; S;
    long long tmp;
    for (int i = 0; i &lt; n; i++) {
      cin >> tmp;
      S[tmp % k]++;
    }
    map&lt;long long, long long&gt; T;
    for (int i = 0; i &lt; n; i++) {
      cin >> tmp;
      T[tmp % k]++;
    }

    // решение
    bool flag = true;
    while (S.size() > 0) {
      pair&lt;long long, long long&gt; t1 = *S.begin();
      S.erase(S.begin());
      pair&lt;long long, long long&gt; t2 = { 0,0 };
      long long h = k - t1.first;
      if (S.find(h) != S.end()) {
        t2 = *S.find(h);
        S.erase(S.find(h));
      }
      long long count1 = t1.second + t2.second;

      long long count2 = 0;
      if (T.find(t1.first) != T.end()) {
        count2 += T.find(t1.first)->second;
        T.erase(T.find(t1.first));
      }
      if (T.find(h) != T.end()) {
        count2 += T.find(h)->second;
        T.erase(T.find(h));
      }
      if (count1 != count2) {
        flag = false;
      }
    }

    // вывод результата
    if (flag) {
      cout &lt;&lt; "YES\n";
    } else {
      cout &lt;&lt; "NO\n";
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача D. Сжатие дерева -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Сжатие дерева</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Кагари готовится архивировать дерево, и она знает, что стоимость этого процесса будет зависеть от его диаметра∗
  . Чтобы сократить расходы, её цель — сначала уменьшить диаметр как можно больше. Она может выполнить следующую операцию над деревом:</p>
  <ol>
    <li>Выбрать две вершины s и t. Пусть последовательность вершин на простом пути† от s до t будет v0,v1,…,vk, где v0=s и vk=t.</li>
    <li>Удалить все рёбра вдоль пути. Другими словами, удалить рёбра (v0,v1),(v1,v2),…,(vk-1,vk).</li>
    <li>Соединить вершины v1,v2,…,vk напрямую с v0. Другими словами, добавить рёбра (v0,v1),(v0,v2),…,(v0,vk).</li>
  </ol>

  <p>Можно показать, что граф всё ещё является деревом после выполнения операции.</p>

  <p>Помогите ей определить минимальное количество операций, необходимых для достижения минимального диаметра.</p>

  <p>* Диаметр дерева — это максимальное расстояние между любой парой вершин. Расстояние измеряется количеством рёбер на уникальном простом пути, соединяющем их.</p>

  <p>† Простой путь — это путь между двумя вершинами в дереве, который не посещает ни одну вершину более одного раза. Можно показать, что простой путь между любыми двумя вершинами всегда уникален.</p>

  <h4>Входные данные</h4>
  <p>Каждый тест состоит из нескольких наборов входных данных. В первой строке находится одно целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных. Далее следует описание наборов входных данных.</p>

  <p>Первая строка каждого набора содержит одно целое число n  (2 ≤ n ≤ 2⋅10⁵) — количество вершин в дереве.</p>

  <p>Следующие n-1 строк описывают дерево. Каждая из строк содержит два целых числа u и v (1≤u,v≤n, u≠v), которые указывают на ребро между вершинами u и v. Гарантируется, что эти рёбра образуют дерево.</p>

  <p>Гарантируется, что сумма значений n по всем наборам входных данных не превосходит 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно целое число — минимальное количество операций для минимизации диаметра.</p>

  <details>
    <summary>Пример</summary>
<pre>
4
4
1 2
1 3
2 4
2
2 1
4
1 2
2 3
2 4
11
1 2
1 3
2 4
3 5
3 8
5 6
5 7
7 9
7 10
5 11
</pre>
<pre>
1
0
0
4
</pre>
  <p>В первом примере диаметр исходного дерева равен 3. Кагари может выполнить операцию на s=3 и t=4. Как показано на рисунке, операции включают следующие шаги:</p>
  <ol>
    <li>Удалить рёбра (3,1), (1,2) и (2,4).</li>
    <li>Добавить рёбра (3,1), (3,2) и (3,4).</li>
  </ol>
  <p>После операции диаметр уменьшается до 2. Можно показать, что 2 — это минимальный диаметр.</p>
  <p>Во втором примере диаметр дерева равен 1. Можно показать, что 1 уже является минимумом, поэтому Кагари не может выполнить никаких операций.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>После удаления ребер мы получим ежика, то есть граф с одной вершиной в центре и от нее расходятся ребра к остальным вершинам.Нам нужно собрать дерево - ежик. Нужно выбрать вершину, которая будет являться корнем дерева ежик. И от нее выстраивать простой путь до каждого листа. Если какой-то путь не простой, то его нужно поломать и отломленую часть подсоединить к корню.</p>
    <p>Нам нужно минимизировать количество этих действий. Поэтому мы должны подсчитать для каждой вершины сколько у нее соседей листьев, для которых эту операцию делать не надо. Определим лучшую вершину, которая станет корнем ежика.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

// условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // число вершин
    cin >> n;
    vector&lt;vector&lt;int&gt; &gt; G(n + 1); // список смежности
    vector&lt;int&gt; Level(n + 1); // степень каждой вершины
    vector&lt;int&gt; Level_list(n + 1); // число листьев у каждой вершины
    int a, b;
    for (int i = 1; i &lt; n; i++) {
      cin >> a >> b;
      G[a].push_back(b);
      G[b].push_back(a);
      Level[a]++;
      Level[b]++;
    }

    // решение
    int count_list = 0;
    for (int i = 0; i &lt;= n; i++) {
      if (Level[i] == 1) {
        count_list++;
        Level_list[G[i][0]]++;
      }
    }
    int result = n;
    for (int i = 0; i &lt;= n; i++) {
      result = min(result, count_list - Level_list[i]);
    }

    // если у дерева 3 вершины, то это уже гарантированно ежик
    // и ничего делать не надо
    if (n &lt;= 3) {
      result = 0;
    }

    // вывод результата
    cout &lt;&lt; result &lt;&lt; '\n';
  }
}
</pre>
  </details>
</article>


<!-- Задача E. Соседний XOR -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Соседний XOR</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Дан массив a длиной n. Для каждого индекса i, такого что 1 ≤ i &lt; n, вы можете выполнить следующую операцию не более одного раза:</p>

  <ul>
    <li>Присвоить ai:=ai⊕ai+1, где ⊕ обозначает операцию побитового исключающего ИЛИ.</li>
  </ul>

  <p>Вы можете выбирать индексы и выполнять операции в любом порядке.</p>

  <p>Дан другой массив b длиной n, определите, возможно ли преобразовать a в b.</p>

  <h4>Входные данные</h4>
  <p>Каждый тест состоит из нескольких наборов входных данных. В первой строке находится одно целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных. Далее следует описание наборов входных данных.</p>

  <p>Первая строка каждого набора содержит одно целое число n
  (2 ≤ n ≤ 2⋅10⁵).</p>

  <p>Вторая строка каждого набора содержит n целых чисел a1, a2, …, an (0 ≤ ai &lt; 2³⁰).</p>

  <p>Третья строка каждого набора содержит n целых чисел b1, b2, …, bn (0 ≤ bi &lt; 2³⁰).</p>

  <p>Гарантируется, что сумма значений n по всем наборам входных данных не превосходит 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого теста выведите «YES» (без кавычек), если a можно преобразовать в b; в противном случае выведите «NO». Вы можете выводить ответ в любом регистре (верхнем или нижнем). Например, строки «yEs», «yes», «Yes», и «YES» будут распознаны как положительные ответы.</p>

  <details>
    <summary>Пример</summary>
<pre>
7
5
1 2 3 4 5
3 2 7 1 5
3
0 0 1
1 0 1
3
0 0 1
0 0 0
4
0 0 1 2
1 3 3 2
6
1 1 4 5 1 4
0 5 4 5 5 4
3
0 1 2
2 3 2
2
10 10
11 10
</pre>
<pre>
YES
NO
NO
NO
YES
NO
NO
</pre>
  <p>В первом тесте вы можете выполнять операции в следующем порядке:</p>
  <ol>
    <li>Выберите индекс i=3 и присвойте a3:=a3⊕a4=7, и a становится [1,2,7,4,5].</li>
    <li>Выберите индекс i=4 и присвойте a4:=a4⊕a5=1, и a становится [1,2,7,1,5].</li>
    <li>Выберите индекс i=1 и присвойте a1:=a1⊕a2=3, и a становится [3,2,7,1,5].</li>
  </ol>
  </details>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  // ускорение ввода-вывода
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

// условная компиляция
#ifdef _DEBUG
  freopen("input.txt", "rt", stdin);
  freopen("output.txt", "wt", stdout);
#endif

  // число тестов
  int t;
  cin >> t;

  while (t--) {
    // ввод данных
    int n; // длина массива
    cin >> n;
    vector&lt;int&gt; A(n);
    for (int i = 0; i &lt; n; i++) {
      cin >> A[i];
    }
    vector&lt;int&gt; B(n);
    for (int i = 0; i &lt; n; i++) {
      cin >> B[i];
    }

    // решение
    bool flag = true;
    if (A[n - 1] != B[n - 1]) {
      flag = false;
    }
    int tmp1 = A[n - 1];
    int tmp2 = A[n - 1];
    for (int i = n - 2; i >= 0; i--) {
      if (A[i] == B[i]) {

      } else {
        if (((A[i] ^ tmp1) == B[i]) ||
          ((A[i] ^ tmp2) == B[i])) {

        } else {
          flag = false;
        }
      }
      tmp1 = A[i];
      tmp2 = B[i];
    }

    // вывод результата
    if (flag) {
      cout &lt;&lt; "YES\n";
    } else {
      cout &lt;&lt; "NO\n";
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача F. Несправедливая бинарная жизнь -->
<article class="article">
  <div class="anchor" id="task6"></div>
  <h3>Задача F. Несправедливая бинарная жизнь</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Юрию даны две бинарные строки a и b, длина каждой из которых равна n. Эти две строки динамически определяют сетку размером nxn. Пусть (i,j) обозначает ячейку в i-й строке и j-м столбце. Начальное значение ячейки (i,j) равно ai⊕bj, где ⊕ обозначает операцию побитового исключающего ИЛИ.</p>

  <p>Путешествие Юрия всегда начинается с ячейки (1,1). Из ячейки (i,j) он может перемещаться только вниз в (i+1,j) или вправо в (i,j+1). Его путешествие возможно, если существует допустимый путь, по которому все ячейки на пути, включая (1,1), имеют значение 0.</p>

  <p>Перед отправлением он может выполнить следующую операцию любое количество раз:</p>
  <ul>
    <li>Выбрать один индекс 1 ≤ i ≤ n и изменить значение либо ai, либо bi (0 становится 1, а 1 становится 0). Сетка также изменится соответственно.</li>
  </ul>

  <p>Пусть f(x,y) обозначает минимальное количество необходимых операций, чтобы Юрий мог добраться до ячейки (x,y). Вам необходимо определить сумму f(x,y) для всех 1 ≤ x, y ≤ n.</p>

  <p>Обратите внимание, что каждый из этих n2
  случаев независим, что означает, что вам нужно предполагать, что сетка находится в своем исходном состоянии в каждом случае (т.е. фактические операции не выполняются).</p>

  <h4>Входные данные</h4>
  <p>Каждый тест состоит из нескольких наборов входных данных. В первой строке находится одно целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных. Далее следует описание наборов входных данных.</p>

  <p>Первая строка каждого набора содержит одно целое число n (1≤n≤2⋅10⁵).</p>

  <p>Вторая строка каждого набора содержит бинарную строку a (|a|=n, ai∈{0,1}).</p>

  <p>Третья строка каждого набора содержит бинарную строку b (|b|=n, bi∈{0,1}).</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите одно целое число — сумму минимальных операций для всех возможных ячеек.</p>

  <details>
    <summary>Пример</summary>
<pre>
3
2
11
00
2
01
01
4
1010
1101
</pre>
<pre>
5
4
24
</pre>
  <p>В первом примере показана сетка 2x2.</p>
<pre>
11
11
</pre>

  <p>В исходном состоянии Юрий не может добраться ни до одной ячейки.</p>
  <p>Юрий может изменить a1, чтобы сетка стала:</p>
<pre>
00
11
</pre>

  <p>и Юрий может перемещаться к ячейкам (1,1) и (1,2).</p>
  <p>С другой стороны, Юрий может изменить b1, чтобы сетка стала:</p>
<pre>
01
01
</pre>

  <p>и Юрий может перемещаться к ячейкам (1,1) и (2,1).</p>
  <p>Чтобы добраться до ячейки (2,2), можно показать, что ему необходимо выполнить как минимум две операции. Например, он может изменить как a1, так и a2, чтобы сетка стала:</p>
<pre>
00
00
</pre>

  <p>Таким образом, ответ равен 1+1+1+2=5.</p>
  </details>
</article>


<!-- Задача G. Wafu! -->
<article class="article">
  <div class="anchor" id="task7"></div>
  <h3>Задача G. Wafu!</h3>

  <div><i>Ограничение по времени 3с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Чтобы улучшить свои навыки в математике, Кудрявка получает набор S, который состоит из n различных положительных целых чисел.</p>

  <p>Изначально её счёт равен 1. Она может выполнять произвольное количество следующих операций над набором, если он не пуст:</p>
  <ol>
    <li>Пусть минимальное значение в S равно m.</li>
    <li>Умножить свой счёт на m.</li>
    <li>Удалить m из S.</li>
    <li>Для каждого целого числа i, такого что 1 ≤ i &lt; m, добавить i в набор S. Можно показать, что на этом шаге дубликаты не добавляются.</li>
  </ol>

  <p>Ей очень понравилось выполнять операции, но после k операций она понимает, что забыла свой счёт. Пожалуйста, помогите ей определить свой счёт, по модулю 109+7.</p>

  <h4>Входные данные</h4>
  <p>Каждый тест состоит из нескольких наборов входных данных. В первой строке находится одно целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных. Далее следует описание наборов входных данных.</p>

  <p>Первая строка каждого набора содержит два целых числа n и k (1 ≤ n ≤ 2⋅10⁵, 1 ≤ k ≤ 10⁹).</p>

  <p>Вторая строка каждого набора содержит n целых чисел s1, s2, …, sn (1 ≤ si ≤ 10⁹, si ≠ sj) — элементы начального набора S. Гарантируется, что набор S не пуст перед выполнением каждой из k операций.</p>

  <p>Гарантируется, что сумма значений n по всем наборам входных данных не превосходит 2⋅10⁵.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных выведите целое число, указывающее ответ по модулю 10⁹+7.</p>

  <details>
    <summary>Пример</summary>
<pre>
4
2 3
1 3
3 6
5 1 4
2 100
2 100
5 15
1 2 3 4 5
</pre>
<pre>
3
24
118143737
576
</pre>
  <p>Давайте смоделируем процесс в первом примере:</p>
  <code>{1,3} -> удалить 1 -> {3} -> удалить 3, добавить 1,2 -> {1,2} -> удалить 1 -> {2}</code>
  <p>Удаленные значения: 1, 3 и 1 соответственно, так что её счёт равен 1x3x1=3.</p>

  <p>Во втором примере ответ равен 1x4x1x2x1x3=24.</p>
  </details>
</article>


<!-- Задача H. Взаимнопростые пары -->
<article class="article">
  <div class="anchor" id="task8"></div>
  <h3>Задача H. Взаимнопростые пары</h3>

  <div><i>Ограничение по времени 3с
  <br>Ограничение по памяти 256мб</i></div>


  <p>Уми дан массив a длиной n, элементы которого являются целыми числами от 1 до m. Она любит взаимно простые числа и хочет найти четыре различных индекса p, q, r, s (1 ≤ p, q, r, s ≤ n), такие что gcd(ap, aq) = 1 и gcd(ar, as) = 1 *.</p>

  <p>Если существует несколько решений, вы можете вывести любое из них.</p>

  <p>* gcd(x,y) обозначает наибольший общий делитель (НОД) чисел x и y.</p>

  <h4>Входные данные</h4>
  <p>Каждый тест состоит из нескольких наборов входных данных. В первой строке находится одно целое число t (1 ≤ t ≤ 10⁴) — количество наборов входных данных. Далее следует описание наборов входных данных.</p>

  <p>Первая строка каждого набора входных данных содержит два целых числа n и m (4 ≤ n ≤ 2⋅10⁵, 1 ≤ m ≤ 10⁶).</p>

  <p>Вторая строка каждого набора входных данных содержит n целых чисел a1, a2, …, an (1 ≤ ai ≤ m).</p>

  <p>Гарантируется, что сумма n по всем наборам входных данных не превышает 2⋅10⁵, и что сумма m по всем наборам входных данных не превышает 10⁶.</p>

  <h4>Выходные данные</h4>
  <p>Для каждого набора входных данных:</p>
  <ul>
    <li>Если такой набор из четырех различных индексов не существует, выведите одно целое число 0.</li>
    <li>В противном случае выведите четыре различных целых числа p, q, r, s (1 ≤ p, q, r, s ≤ n), которые удовлетворяют условию. Если существует несколько решений, выведите любое из них.</li>
  </ul>

  <details>
    <summary>Пример</summary>
<pre>
5
4 15
4 7 9 15
4 10
1 2 4 8
5 15
6 10 11 12 15
5 15
6 10 11 14 15
6 10000
30 238 627 1001 1495 7429
</pre>
<pre>
1 3 2 4
0
0
3 1 4 5
1 4 2 3
</pre>
  <p>В первом наборе входных данных, gcd(a1,a3)=gcd(4,9)=1, gcd(a2,a4)=gcd(7,15)=1.</p>

  <p>Во втором наборе входных данных можно показать, что такой четверки не существует.</p>
  </details>
</article>

