<article class="article">
  <a href="https://codeforces.com/contest/520" target="_blank">Codeforces 520 Round 295 (Div.2) 2015-03-02</a>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

      <a href="#task1">Задача A. Панграмма</a>
  <br><a href="#task2">Задача B. Две кнопки</a>
  <br><a href="#task3">Задача C. Выравнивание ДНК</a>
  <br><a href="#task4">Задача D. Кубики</a>
  <br><a href="#task5">Задача E. Сплошные плюсы</a>
</article>


<!-- Задача A. Панграмма -->
<article class="article">
  <div class="anchor" id="task1"></div>
  <h3>Задача A. Панграмма</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Слово или предложение на некотором языке называется панграммой, если в нем встречаются все символы алфавита этого языка хотя бы один раз. Панграммы часто используют в типографии для демонстрации шрифтов или тестирования средств вывода различных устройств.</p>

  <p>Вам дана строка, состоящая из маленьких и больших латинских букв. Проверьте, является ли эта строка панграммой. Считается, что строка содержит букву латинского алфавита, если эта буква встречается в верхнем или нижнем регистре.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано одно целое число n (1 ≤ n ≤ 100) — количество символов в строке.</p>

  <p>Во второй строке записана сама строка. Строка содержит исключительно строчные и заглавные латинские буквы.</p>

  <h4>Выходные данные</h4>
  <p>Выведите «YES», если строка является панграммой, и «NO» в противном случае.</p>

  <details>
    <summary>Примеры</summary>
  <h4>Пример 1</h4>
<pre>
12
toosmallword
</pre>
  <code>NO</code>

  <h4>Пример 2</h4>
<pre>
35
TheQuickBrownFoxJumpsOverTheLazyDog
</pre>
  <code>YES</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Переведем символы строки в нижний регистр и запишем в вектор. Сделаем сортировку векторов. Буквы будут соседние если разница между ними равна 1. Посчитаем число букв в векторе. Если ровно 26, то это панграмма</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  // входные данные
  int n;
  cin >> n;
  string s;
  cin >> s;

  // решение
  string res = "NO";
  vector&lt;char&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    A[i] = tolower(s[i]);
  }
  sort(A.begin(), A.end());
  int count = 0;
  for (int i = 1; i &lt; n; i++) {
    if (A[i] - A[i - 1] == 1) {
      count++;
    }
  }
  if (count == 25) {
    res = "YES";
  }

  // вывод результата
  cout &lt;&lt; res;
}
</pre>
  </details>
</article>


<!-- Задача B. Две кнопки -->
<article class="article">
  <div class="anchor" id="task2"></div>
  <h3>Задача B. Две кнопки</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вася нашел странное устройство. На передней панели устройства расположен дисплей, отображающий некоторое целое положительное число, а также красная и синяя кнопки. При нажатии на красную кнопку число на дисплее увеличивается в два раза. При нажатии на синюю кнопку число на дисплее уменьшается на единицу. Если в какой-то момент число перестает быть положительным, устройство ломается. Дисплей может отображать сколь угодно большие числа. Изначально на дисплее отображается число n.</p>

  <p>Вася хочет получить на дисплее число m. Какое минимальное количество нажатий ему придется совершить?</p>

  <h4>Входные данные</h4>
  <p>Первая и единственная строка ввода содержит два различных целых числа n и m, разделенных пробелом (1 ≤ n, m ≤ 10⁴).</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно число — минимальное количество нажатий на кнопки, необходимое, чтобы получить число m из числа n.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>4 6</code>
    <code>2</code>

    <h4>Пример 2</h4>
    <code>10 1</code>
    <code>9</code>

    <p>В первом примере нужно один раз нажать на синюю кнопку, и затем раз один раз на красную кнопку.</p>
    <p>Во втором примере удваивать число невыгодно, поэтому надо девять раз нажать на синюю кнопку.</p>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Развернем условие. Будем считать, что первая операция это m делить на 2, вторая операция это m + 1. Пока конечное число m больше начального числа n будем делать первую операцию если m делится нацело на 2 и вторую операцию если не делится. После этого конечное число m будет равно или меньше начального числа n. Сложим количество операций и разницу n - m.</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  // ввод данных
  int n, m;
  cin >> n >> m;

  // решение
  int red = 0;
  int blue = 0;

  while (m > n) {
    if (m % 2) {
      m++;
      blue++;
    } else {
      m /= 2;
      red++;
    }
  }

  // вывод результата
  cout &lt;&lt; blue + red + n - m;
}
</pre>
  </details>
</article>


<!-- Задача C. Выравнивание ДНК -->
<article class="article">
  <div class="anchor" id="task3"></div>
  <h3>Задача C. Выравнивание ДНК</h3>

  <div><i>Ограничение по времени 2с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вася увлекся биоинформатикой. Он собирается написать статью про похожие циклические последовательности ДНК, и поэтому он придумал новый способ определения схожести циклических последовательностей.</p>

  <p>Пусть строки s и t имеют одинаковую длину n, тогда функция h(s, t) определяется как количество позиций, в которых соответствующие символы s и t совпадают. При помощи функции h(s, t), определяется функция расстояния по Василию ρ(s, t):</p>
  <code>ρ(s, t) = h(shift(s, i), shift(t, j))</code>

  <p>где shift(s, i) — это строка s, циклически сдвинутая на i символов влево. Например,</p>
  <code>ρ("AGC", "CGT") =
  h("AGC", "CGT") + h("AGC", "GTC") + h("AGC", "TCG") +
  h("GCA", "CGT") + h("GCA", "GTC") + h("GCA", "TCG") +
  h("CAG", "CGT") + h("CAG", "GTC") + h("CAG", "TCG") =
  1 + 1 + 0 + 0 + 1 + 1 + 1 + 0 + 1 = 6</code>
  <p>Вася нашел в интернете строку s длины n. Теперь он хочет посчитать количество строк t, находящихся на максимальном расстоянии по Василию от строки s. Формально говоря, t должна удовлетворять равенству:</p>
  <code>ρ(s, t) = max ρ(s, u)</code>

  <p>Вася не смог перебрать все возможные строки для нахождения ответа, поэтому ему нужна ваша помощь. Поскольку ответ может быть очень большим, посчитайте количество подходящих строк по модулю 10⁹ + 7.</p>

  <h4>Входные данные</h4>
  <p>В первой строке ввода записано одно целое число n (1 ≤ n ≤ 10⁵).</p>

  <p>Во второй строке ввода записана одна строка длины n, состоящая из символов "ACGT".</p>

  <h4>Выходные данные</h4>
  <p>Выведите одно число — ответ по модулю 10⁹ + 7.</p>

  <details>
    <summary>Примеры</summary>
  <h4>Пример 1</h4>
<pre>
1
C
</pre>
  <code>1</code>

  <h4>Пример 2</h4>
<pre>
2
AG
</pre>
  <code>4</code>

  <h4>Пример 3</h4>
<pre>
3
TTT
</pre>
  <code>1</code>
  <p>Обратите внимание, что если для двух различных строк t1 и t2 значения ρ(s, t1) и ρ(s, t2) являются максимальными среди всех возможных строк, то обе строки необходимо учесть в итоговом количестве даже в том случае, когда одну из них можно получить циклическим сдвигом из другой.</p>

  <p>В первом примере существует ρ("C", "C") = 1, для остальных строк t длины 1 значение ρ(s, t) равно 0.</p>

  <p>Во втором примере ρ("AG", "AG") = ρ("AG", "GA") = ρ("AG", "AA") = ρ("AG", "GG") = 4.</p>

  <p>В третьем примере ρ("TTT", "TTT") = 27.</p>
  </details>
</article>


<!-- Задача D. Кубики -->
<article class="article">
  <div class="anchor" id="task4"></div>
  <h3>Задача D. Кубики</h3>

  <div><i>Ограничение по времени 3с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Как-то раз Вася с Петей собрали конструкцию из m кубиков, на каждом из которых написано число от 0 до m - 1 (каждое число встречалось ровно один раз). Введём систему координат так, что осью OX является земля, а ось OY направлена вверх. Каждый кубик задаётся координатами своего нижнего левого угла, при этом эти координаты целые для каждого кубика.</p>

  <p>Конструкция получилась устойчивой. Это значит, что для любого кубика, который не стоит на земле, есть хотя бы один кубик под ним, с которым он касается по стороне или по углу. Более формально, это значит, что для кубика с координатами (x, y) либо выполняется y = 0, либо существует кубик, имеющий координаты (x - 1, y - 1), (x, y - 1) или (x + 1, y - 1).</p>

  <p>Теперь мальчики хотят разобрать конструкцию и выложить все кубики в ряд. Очередной кубик удаляется из конструкции и кладется в ряд справа от уже положенных кубиков, при этом ребята вынимают кубики таким образом, что конструкция остаётся устойчивой. Чтобы разнообразить процесс, ребята решили поиграть в следующую игру. Ребята вынимают кубики из конструкции по очереди. Легко видеть, что после разбора конструкции цифры, написанные на кубиках, образуют число, записанное в m-ичной системе счисления (возможно, содержащее ведущий нуль). Вася хочет, чтобы полученное в результате число было наибольшим, а Петя, наоборот, старается его сделать как можно меньше. Вася ходит первым.</p>

  <p>Ваша задача — определить, какое число получится после разбора конструкции, если ребята будут действовать оптимально. Определите остаток от деления ответа на 10⁹ + 9.</p>

  <h4>Входные данные</h4>
  <p>В первой строке дано число m (2 ≤ m ≤ 10⁵).</p>

  <p>В последующих m строках даны координаты кубиков xᵢ, yᵢ (-10⁹ ≤ xᵢ ≤ 10⁹, 0 ≤ yᵢ ≤ 10⁹) в порядке следования чисел, написанных на них. Гарантируется, что исходная конструкция устойчива.</p>

  <p>Никакие два кубика не совпадают.</p>

  <h4>Выходные данные</h4>
  <p>В единственной строке выведите ответ на задачу.</p>

  <details>
    <summary>Примеры</summary>
  <h4>Пример 1</h4>
<pre>
3
2 1
1 0
0 1
</pre>
  <code>19</code>

  <h4>Пример 2</h4>
<pre>
5
0 0
0 1
0 2
0 3
0 4
</pre>
  <code>2930</code>
  </details>
</article>


<!-- E. Сплошные плюсы -->
<article class="article">
  <div class="anchor" id="task5"></div>
  <h3>Задача E. Сплошные плюсы</h3>

  <div><i>Ограничение по времени 3с
  <br>Ограничение по памяти 256мб</i></div>

  <p>Вася сидит на невыносимо скучном уроке математики. Чтобы развлечься, он выписал на листок бумаги n цифр в одну строку. После этого Вася стал выписывать разные способы поставить в строке между некоторыми цифрами плюсы («+») таким образом, чтобы получалось корректное арифметическое выражение; формально, никакие два плюса в таком разбиении не должны стоять рядом (между любыми двумя соседними плюсами должна стоять хотя бы одна цифра), и никакой плюс не может стоять в начале или в конце строки. Например, в строке 100500, способы 100500 (не ставить плюсов совсем), 1+00+500 или 10050+0 являются корректными, а способы 100++500, +1+0+0+5+0+0 или 100500+ являются некорректными.</p>

  <p>Урок был длинным, и Вася выписал все корректные способы расставить в своей строке из цифр ровно k плюсов. В этот момент его развлечение было замечено, и Вася получил задание до конца урока вычислить сумму значений всех получившихся арифметических выражений (при вычислении значения выражения ведущие нули в слагаемых следует игнорировать). Поскольку ответ может быть большим, Васе разрешили всего лишь получить остаток от деления ответа на 10⁹ + 7.</p>

  <h4>Входные данные</h4>
  <p>В первой строке записано два целых числа n и k (0 ≤ k &lt; n ≤ 10⁵).</p>

  <p>Во второй строке записана строка, состоящая из n цифр.</p>

  <h4>Выходные данные</h4>
  <p>Выведите ответ на задачу по модулю 10⁹ + 7.</p>

  <details>
    <summary>Примеры</summary>
  <h4>Пример 1</h4>
<pre>
3 1
108
</pre>
  <code>27</code>

  <h4>Пример 2</h4>
<pre>
3 2
108
</pre>
  <code>9</code>
  <p>В первом примере результат равен (1 + 08) + (10 + 8) = 27.</p>
  <p>Во втором примере результат равен 1 + 0 + 8 = 9.</p>
  </details>
</article>

