<h1>Coderun 1 Легкий уровень</h1>

<!-- Ссылки -->
<div class="article">
  <h2>Ссылки</h2>

  <p><a href="https://coderun.yandex.ru/catalog">coderun.yandex.ru</a></p>
  <p><a href="https://ru.hexlet.io/blog/posts/grokaem-algoritmy-gayd-po-algoritmam-dlya-teh-komu-slozhno-reshat-zadachi">ru.hexlet.io Грокаем алгоритмы</a></p>
  <p><a href="https://github.com/vitkarpov/coderun-solutions">github.com/vitkarpov/coderun-solutions</a></p>
</div>


<!-- Содержание -->
<div class="article">
  <h2>Содержание</h2>

  <p><a href="#task-166">166. Яндексформеры</a></p>
  <p><a href="#task-170">170. Объединение отсортированных массивов</a></p>
  <p><a href="#task-228">228. Поиск чисел в массиве с определённой суммой</a></p>
</div>


<!-- 166. Яндексформеры -->
<article class="article">
  <div class="anchor" id="task-166"></div>
  <h2>166. Яндексформеры</h2>

  <p>лёгкая - sort - algorithms - first_2023_frontend</p>

  <p><a href="https://coderun.yandex.ru/problem/yandexformers">https://coderun.yandex.ru/problem/yandexformers</a></p>

  <h4>Описание</h4>
  <p>Яндексоиды научились образовывать Гештальд. Гештальд — это когда разработчики меньшего уровня собираются в одного Яндексформера и решают большую и сложную задачу. У каждого яндексоида есть свой грейд. Грейд яндексоида - это целое число, обозначающее максимальный уровень задачи, которую сотрудник способен решить. Грейд же Яндексформера - это сумма грейдов входящих в гештальд.</p>
  <p>Проблема в том, что для Яндексформера нужен компьютер с K клавиатурами, где K — число яндексоидов в объединении. Клавиатур меньше чем Яндексоидов, поэтому необходимо определить максимально возможный уровень Яндексформера, доступного для сборки.</p>

  <h4>Например</h4>
  <p>Пусть доступны разработчики с грейдами [10,1,23,0,1], а также 2 клавиатуры. В таком случае оптимально будет объединить в гештальд разработчиков с грейдами 10 и  23 - уровень Яндексформера будет равен 33.</p>

  <h4>Формат ввода</h4>
  <p>На вход функции подаются три параметра: целое число N количество сотрудников, готовых к объединению; массив целых чисел staff список грейдов сотрудников, готовых к объединению; целое число K (1 &lt;= K &lt;= N) количество доступных клавиатур.</p>

  <h4>Формат вывода</h4>
  <p>Функция должна вернуть единственное целое число - максимально возможный уровень Яндексформера при объединении K разработчиков.</p>

  <details>
    <summary>Решение</summary>
<pre>function yandexFormers(N, staff, K) {
  let result = 0;
  // отсортировать массив по убыванию
  staffSort = staff.toSorted((a, b) => b - a);

  // взять первые K элементов
  for (i = 0; i &lt; K; i++) {
    result += staffSort[i];
  }

  return result;
}</pre>
  </details>
</article>


<!-- 170. Объединение отсортированных массивов -->
<article class="article">
  <div class="anchor" id="task-170"></div>
  <h2>170. Объединение отсортированных массивов</h2>

  <p>лёгкая - sort - algorithms - first_2023_frontend</p>

  <p><a href="https://coderun.yandex.ru/problem/merge-sorted-array">https://coderun.yandex.ru/problem/merge-sorted-array</a></p>

  <h4>Описание</h4>
  <p>Вам даны два отсортированных целочисленных массива nums1 и nums2, нужно поместить все элементы nums2 в nums1 так, чтобы элементы итогового массива остались отсортированными.</p>

  <h4>Формат ввода</h4>
  <code>[46,55,88,0,0,0,0] 3 [18,29,80,90] 4</code>

  <h4>Примечание</h4>
  <ol>
    <li>количество элементов в массивах nums1 и nums2 равны m и n соотвественно;</li>
    <li>можно считать, что в массиве nums1 зарезервированно место для всех элементов (n + m) и заполнены нулями;</li>
    <li>результат должен сохраниться в переменной nums1, результат функции явно возвращать не обязательно</li>
  </ol>

  <details>
  <summary>Решение</summary>
<pre>function merge(nums1, m, nums2, n) {
  let p1 = 0;
  let p2 = 0;
  let result = [];

  while (p1 &lt; m && p2 &lt; n) {
    if(nums1[p1] &lt; nums2[p2]) {
      result.push(nums1[p1]);
      p1++;
    } else {
      result.push(nums2[p2]);
      p2++
    }
  }

  while (p1 &lt; m) {
    result.push(nums1[p1]);
    p1++;
  }

  while (p2 &lt; n) {
    result.push(nums2[p2]);
    p2++;
  }

  nums1.splice(0, m+n, ...result);
}</pre>
  </details>
</article>


<!-- 228. Поиск чисел в массиве с определённой суммой -->
<article class="article">
  <div class="anchor" id="task-228"></div>
  <h2>228. Поиск чисел в массиве с определённой суммой</h2>

  <p>лёгкая - brute force - algorithms - first_2023_frontend</p>

  <p><a href="https://coderun.yandex.ru/problem/search-for-numbers">https://coderun.yandex.ru/problem/search-for-numbers</a></p>

  <h4>Описание</h4>
  <p>Дан массив целых чисел и целое число k. Нужно определить, есть ли в массиве два числа, сумма которых равна k .</p>

  <h4>Пример</h4>
  <code>Вход: nums = [10, 15, 3, 7], k = 17</code>
  <code>Выход: True</code>

  <details>
    <summary>Решение с помощью Двух указателей</summary>
    <p>Решение с помощью Двух указателей подходит для случая, когда массив чисел упорядочен. Если массив не упорядочен, то для его сортировки требуется дополнительная сложность O(nlogn).</p>
    <p>Сначала левый указатель указывает на начало массива, а правый на его конец. Если их сумма равна целевому значению, то мы выходим, если нет, то:</p>
    <p>если сумма больше целевого значения, то нам нужна меньшая сумма (логично, да?) и мы сдвигаем левее правый указатель</p>
    <p>если сумма меньше целевого значения, то мы сдвигаем левый указатель, чтобы её увеличить</p>
    <p>Мы получили сложность по времени O(n) и по памяти O(1).</p>

<pre>function twoNum(nums, k) {
  let result = false;
  // отсортировать массив
  numsSort = nums.toSorted((a, b) => a - b);
  let left = 0;
  let right = numsSort.length - 1;

  while (right &gt; left) {
    let sum = numsSort[left] + numsSort[right];
    if (sum === k) {
      result = true;
      break;
    } else if (sum &gt; k) {
      right--;
    } else {
      left++;
    }
  }

  return result;
}</pre>
</details>

  <details>
    <summary>Решение с помощью Словаря</summary>
    <p>Решение с помощью Словаря подходит если массив не отсортированный. Для составления словаря из массива требуется дополнительная сложность O(n). Зато доступ к ключу словаря вывполняется за время O(1).</p>
    <p>И давайте ещё одно альтернативное решение с линейной сложностью. При итерации по массиву, имея текущее значение, нам бы очень хотелось знать, есть ли в массиве значение, которое дополняет текущее до искомого. Это же суть задачи? Как мы можем найти его за линейное время? Верно, при помощи словаря.</p>
    <p>Первым делом, переносим массив в словарь, в качестве ключей — числа, а значений — их индексы. Во время второго прохода проверяем, есть ли число, которое дополняет текущее до искомого равное target-x. Если есть — отлично, если нет — идём дальше. Таким образом, имеем временную сложность O(n) и сложность по памяти O(n).</p>

<pre>function twoNum(nums, k) {
  let result = false;
  let voc = {};
  // заполняем словарь
  for (let i = 0; i &lt; nums.length; i++) {
    voc[nums[i]] = i;
  }

  // проверяем значение в словаре
  for (let i = 0; i &lt; nums.length; i++) {
    if (k - nums[i] in voc) {
      result = true;
    }
  }

  return result;
}</pre>
</details>

  <details>
    <summary>Правильное решение с помощью Словаря</summary>
    <p>Можно улучшить предыдущее решение и убрать начальное заполнение словаря.</p>
    <p>Сначала создаем пустой словарь (хэш-таблица - ключ: значение). Берем первое число из массива и смотрим в словаре нет ли такого ключа, который в сумме с первым числом давал бы число k. Словарь пока пустой и такого ключа в нем нет. Поэтому заносим первое число в словарь в виде ключа.</p>
    <p>Берем второе число из массива и смотрим в словаре, если в нем есть такой ключ, который в сумме со вторым числом давал бы число k, то возвращаем true, если нет, то заносим второе число в словарь в виде ключа и идем по массиву дальше.</p>
    <p>Если пройдем до конца массива и не найдем нужный ключ, то возвращаем false</p>
    <p>Сложность такого алгоритма по времени O(n) и по памяти O(n). Потому что пройтись по массиву это сложность по времени O(n) и по памяти O(1), поскольку дополнительная память не требуется. Доступ к словарю (запись и чтение) это сложность по времени O(1) и по памяти O(n) потому что создаем в памяти новую структуру данных из n элементов.</p>
<pre>function twoNum(nums, k) {
  let result = false;
  let voc = {};

  // для каждого элемента массива
  for (let i = 0; i &lt; nums.length; i++) {
    // проверяем если значение есть в словаре
    // то возвращаем true
    if (k - nums[i] in voc) {
      result = true;
      break;
    }
    // если значения нет в словаре
    // то заносим элемент в словарь
    voc[nums[i]] = i;
  }

  return result;
}</pre>
  </details>
</article>








