<article class="article">
  <h1>Coderun</h1>
  <p><a href="https://coderun.yandex.ru/catalog" target="_blank">coderun.yandex.ru</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

      <a href="#p1">Как решать</a>
  <br><a href="#task-1">1. Средний элемент</a>
  <br><a href="#task-166">166. Яндексформеры</a>
  <br><a href="#task-170">170. Объединение отсортированных массивов</a>
  <br><a href="#task-228">228. Поиск чисел в массиве с определённой суммой</a>
</article>


<!-- Как решать -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h2>Как решать</h2>

  <details>
    <summary>Как решать на Си</summary>
    <p>Для чтения входных данных необходимо получить их из стандартного потока ввода (stdin). Данные во входном потоке соответствуют описанному в условии формату. Обычно входные данные состоят из нескольких строк. Можно использовать несколько функций для чтения из stdin:</p>
    <ol>
      <li>scanf() -- читает данные из потока;</li>
      <li>fgets() -- читает строку из потока;</li>
      <li>gets() -- читает строку из потока до символа '\n'.</li>
    </ol>
    <p>Чтобы прочитать из строки стандартного потока:</p>
    <ol>
      <li>число
        <code>int var; scanf("%d", &var);</code></li>
      <li>строку
        <code>char svar[100]; scanf("%s", svar);</code></li>
      <li>массив чисел известной длины
<pre>
int len; scanf("%d", &len);
int* arr = (int*) malloc(len * sizeof(int));
for (int i = 0; i &lt; len; ++i) {
  scanf("%d", &arr[i]);
}
</pre>
      </li>
      <li>последовательность слов до конца файла
<pre>
char word[100];
while (scanf("%s", word) == 1) {
  // do something with word
}
</pre>
      </li>
    </ol>
    <p>Чтобы вывести результат в стандартный поток вывода (stdout), можно использовать функцию printf().</p>
    <p>Возможное решение задачи "Вычислите сумму A+B":</p>
<pre>
int a, b;
scanf("%d%d", &a, &b);
printf("%d\n", a + b);
</pre>
  </details>

  <details>
    <summary>Как решать на C++</summary>
    <p>Для чтения входных данных необходимо получить их из стандартного потока ввода (stdin). Данные во входном потоке соответствуют описанному в условии формату. Обычно входные данные состоят из нескольких строк. Можно использовать несколько методов:</p>
    <ol>
      <li>std::cin -- читает токены из потока;</li>
      <li>std::getline() -- читает одну строку из потока;</li>
      <li>scanf()/gets() -- C-функции для чтения из stdin.</li>
    </ol>
    <p>Чтобы прочитать из строки стандартного потока:</p>
    <ol>
      <li>число
        <code>int var; std::cin >> var;</code></li>
      <li>строку
        <code>std::string svar; std::cin >> svar;</code></li>
      <li>массив чисел известной длины
<pre>
std::vector&lt;int&gt; arr(len);
for (size_t i = 0; i &lt; arr.size(); ++i)
  std::cin >> arr[i];
</pre>
      </li>
      <li>последовательность слов до конца файла
<pre>
std::vector&lt;std::string&gt; sarr;
std::string word;
while (std::cin >> word) {
  sarr.push_back(word);
}
</pre>
      </li>
    </ol>
    <p>Чтобы вывести результат в стандартный поток вывода (stdout), можно использовать поток std::cout.</p>
    <p>Возможное решение задачи "Вычислите сумму A+B":</p>
<pre>
int a, b;
std::cin >> a >> b;
std::cout &lt;&lt; a + b &lt;&lt; std::endl;
</pre>
  </details>
</article>


<!-- 1. Средний элемент -->
<article class="article">
  <div class="anchor" id="task-1"></div>
  <h2>1. Средний элемент</h2>

  <details>
    <summary>Условие</summary>
    <p>лёгкая - backend</p>

    <p><a href="https://coderun.yandex.ru/problem/median-out-of-three">https://coderun.yandex.ru/problem/median-out-of-three</a></p>

    <p>Ограничение времени 1 с
    <br>Ограничение памяти 256 МБ</p>

    <p>Рассмотрим три числа a, b и c. Упорядочим их по возрастанию. Какое число будет стоять между двумя другими? Решение этой задачи на С++ могло бы выглядеть так:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  int a[3];
  for (int i = 0; i &lt; 3; ++i) cin >> a[i];
  sort(a, a + 3);
  cout &lt;&lt; a[1] &lt;&lt; endl;

  return 0;
}
</pre>

    <h4>Формат ввода</h4>
    <p>В единственной строке записаны три целых числа a, b, c (-1000 ≤ a, b, c ≤ 1000), числа разделены одиночными пробелами.</p>

    <h4>Формат вывода</h4>
    <p>Выведите число, которое будет стоять между двумя другими после упорядочивания.</p>

    <h4>Пример 1</h4>
    <code>1 2 3</code>
    <code>2</code>

    <h4>Пример 2</h4>
    <code>1000 -1000 0</code>
    <code>0</code>

    <h4>Пример 3</h4>
    <code>3 1 3</code>
    <code>3</code>
  </details>


  <details>
    <summary>Решение на Си</summary>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int cmp(const void *a, const void *b) {
  return *(int*)a - *(int*)b;
}

int main() {
  int a[3];
  for (int i = 0; i &lt; 3; i++) {
    scanf("%d", a + i);
  }
  qsort(a, 3, sizeof(int), cmp);
  printf("%d", a[1]);

  return 0;
}
</pre>
  </details>

  <details>
    <summary>Решение на C++</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  int a[3];
  for (int i = 0; i &lt; 3; ++i) cin >> a[i];
  sort(a, a + 3);
  cout &lt;&lt; a[1] &lt;&lt; endl;

	return 0;
}
</pre>
  </details>
</article>


<!-- 166. Яндексформеры -->
<article class="article">
  <div class="anchor" id="task-166"></div>
  <h2>166. Яндексформеры</h2>

  <details>
    <summary>Условие</summary>
    <p>лёгкая - sort - algorithms - first_2023_frontend</p>

    <p><a href="https://coderun.yandex.ru/problem/yandexformers">https://coderun.yandex.ru/problem/yandexformers</a></p>

    <h4>Описание</h4>
    <p>Яндексоиды научились образовывать Гештальд. Гештальд — это когда разработчики меньшего уровня собираются в одного Яндексформера и решают большую и сложную задачу. У каждого яндексоида есть свой грейд. Грейд яндексоида - это целое число, обозначающее максимальный уровень задачи, которую сотрудник способен решить. Грейд же Яндексформера - это сумма грейдов входящих в гештальд.</p>
    <p>Проблема в том, что для Яндексформера нужен компьютер с K клавиатурами, где K — число яндексоидов в объединении. Клавиатур меньше чем Яндексоидов, поэтому необходимо определить максимально возможный уровень Яндексформера, доступного для сборки.</p>

    <h4>Например</h4>
    <p>Пусть доступны разработчики с грейдами [10,1,23,0,1], а также 2 клавиатуры. В таком случае оптимально будет объединить в гештальд разработчиков с грейдами 10 и  23 - уровень Яндексформера будет равен 33.</p>

    <h4>Формат ввода</h4>
    <p>На вход функции подаются три параметра: целое число N количество сотрудников, готовых к объединению; массив целых чисел staff список грейдов сотрудников, готовых к объединению; целое число K (1 &lt;= K &lt;= N) количество доступных клавиатур.</p>

    <h4>Формат вывода</h4>
    <p>Функция должна вернуть единственное целое число - максимально возможный уровень Яндексформера при объединении K разработчиков.</p>
  </details>

  <details>
    <summary>Решение на JS</summary>
<pre>function yandexFormers(N, staff, K) {
  let result = 0;
  // отсортировать массив по убыванию
  staffSort = staff.toSorted((a, b) => b - a);

  // взять первые K элементов
  for (i = 0; i &lt; K; i++) {
    result += staffSort[i];
  }

  return result;
}</pre>
  </details>
</article>


<!-- 170. Объединение отсортированных массивов -->
<article class="article">
  <div class="anchor" id="task-170"></div>
  <h2>170. Объединение отсортированных массивов</h2>

  <details>
    <summary>Условие</summary>
    <p>лёгкая - sort - algorithms - first_2023_frontend</p>

    <p><a href="https://coderun.yandex.ru/problem/merge-sorted-array">https://coderun.yandex.ru/problem/merge-sorted-array</a></p>

    <h4>Описание</h4>
    <p>Вам даны два отсортированных целочисленных массива nums1 и nums2, нужно поместить все элементы nums2 в nums1 так, чтобы элементы итогового массива остались отсортированными.</p>

    <h4>Формат ввода</h4>
    <code>[46,55,88,0,0,0,0] 3 [18,29,80,90] 4</code>

    <h4>Примечание</h4>
    <ol>
      <li>количество элементов в массивах nums1 и nums2 равны m и n соотвественно;</li>
      <li>можно считать, что в массиве nums1 зарезервированно место для всех элементов (n + m) и заполнены нулями;</li>
      <li>результат должен сохраниться в переменной nums1, результат функции явно возвращать не обязательно</li>
    </ol>
  </details>

  <details>
  <summary>Решение на JS</summary>
<pre>function merge(nums1, m, nums2, n) {
  let p1 = 0;
  let p2 = 0;
  let result = [];

  while (p1 &lt; m && p2 &lt; n) {
    if(nums1[p1] &lt; nums2[p2]) {
      result.push(nums1[p1]);
      p1++;
    } else {
      result.push(nums2[p2]);
      p2++
    }
  }

  while (p1 &lt; m) {
    result.push(nums1[p1]);
    p1++;
  }

  while (p2 &lt; n) {
    result.push(nums2[p2]);
    p2++;
  }

  nums1.splice(0, m+n, ...result);
}</pre>
  </details>
</article>


<!-- 228. Поиск чисел в массиве с определённой суммой -->
<article class="article">
  <div class="anchor" id="task-228"></div>
  <h2>228. Поиск чисел в массиве с определённой суммой</h2>

  <details>
    <summary>Условие</summary>
    <p>лёгкая - brute force - algorithms - first_2023_frontend</p>

    <p><a href="https://coderun.yandex.ru/problem/search-for-numbers">https://coderun.yandex.ru/problem/search-for-numbers</a></p>

    <h4>Описание</h4>
    <p>Дан массив целых чисел и целое число k. Нужно определить, есть ли в массиве два числа, сумма которых равна k .</p>

    <h4>Пример</h4>
    <code>Вход: nums = [10, 15, 3, 7], k = 17</code>
    <code>Выход: True</code>
  </details>

  <details>
    <summary>Решение на JS</summary>
    <p>Решение с помощью Двух указателей подходит для случая, когда массив чисел упорядочен. Если массив не упорядочен, то для его сортировки требуется дополнительная сложность O(nlogn).</p>
    <p>Сначала левый указатель указывает на начало массива, а правый на его конец. Если их сумма равна целевому значению, то мы выходим, если нет, то:</p>
    <p>если сумма больше целевого значения, то нам нужна меньшая сумма (логично, да?) и мы сдвигаем левее правый указатель</p>
    <p>если сумма меньше целевого значения, то мы сдвигаем левый указатель, чтобы её увеличить</p>
    <p>Мы получили сложность по времени O(n) и по памяти O(1).</p>

<pre>function twoNum(nums, k) {
  let result = false;
  // отсортировать массив
  numsSort = nums.toSorted((a, b) => a - b);
  let left = 0;
  let right = numsSort.length - 1;

  while (right &gt; left) {
    let sum = numsSort[left] + numsSort[right];
    if (sum === k) {
      result = true;
      break;
    } else if (sum &gt; k) {
      right--;
    } else {
      left++;
    }
  }

  return result;
}</pre>
</details>

  <details>
    <summary>Решение с помощью Словаря</summary>
    <p>Решение с помощью Словаря подходит если массив не отсортированный. Для составления словаря из массива требуется дополнительная сложность O(n). Зато доступ к ключу словаря вывполняется за время O(1).</p>
    <p>И давайте ещё одно альтернативное решение с линейной сложностью. При итерации по массиву, имея текущее значение, нам бы очень хотелось знать, есть ли в массиве значение, которое дополняет текущее до искомого. Это же суть задачи? Как мы можем найти его за линейное время? Верно, при помощи словаря.</p>
    <p>Первым делом, переносим массив в словарь, в качестве ключей — числа, а значений — их индексы. Во время второго прохода проверяем, есть ли число, которое дополняет текущее до искомого равное target-x. Если есть — отлично, если нет — идём дальше. Таким образом, имеем временную сложность O(n) и сложность по памяти O(n).</p>

<pre>function twoNum(nums, k) {
  let result = false;
  let voc = {};
  // заполняем словарь
  for (let i = 0; i &lt; nums.length; i++) {
    voc[nums[i]] = i;
  }

  // проверяем значение в словаре
  for (let i = 0; i &lt; nums.length; i++) {
    if (k - nums[i] in voc) {
      result = true;
    }
  }

  return result;
}</pre>
</details>

  <details>
    <summary>Правильное решение с помощью Словаря</summary>
    <p>Можно улучшить предыдущее решение и убрать начальное заполнение словаря.</p>
    <p>Сначала создаем пустой словарь (хэш-таблица - ключ: значение). Берем первое число из массива и смотрим в словаре нет ли такого ключа, который в сумме с первым числом давал бы число k. Словарь пока пустой и такого ключа в нем нет. Поэтому заносим первое число в словарь в виде ключа.</p>
    <p>Берем второе число из массива и смотрим в словаре, если в нем есть такой ключ, который в сумме со вторым числом давал бы число k, то возвращаем true, если нет, то заносим второе число в словарь в виде ключа и идем по массиву дальше.</p>
    <p>Если пройдем до конца массива и не найдем нужный ключ, то возвращаем false</p>
    <p>Сложность такого алгоритма по времени O(n) и по памяти O(n). Потому что пройтись по массиву это сложность по времени O(n) и по памяти O(1), поскольку дополнительная память не требуется. Доступ к словарю (запись и чтение) это сложность по времени O(1) и по памяти O(n) потому что создаем в памяти новую структуру данных из n элементов.</p>
<pre>function twoNum(nums, k) {
  let result = false;
  let voc = {};

  // для каждого элемента массива
  for (let i = 0; i &lt; nums.length; i++) {
    // проверяем если значение есть в словаре
    // то возвращаем true
    if (k - nums[i] in voc) {
      result = true;
      break;
    }
    // если значения нет в словаре
    // то заносим элемент в словарь
    voc[nums[i]] = i;
  }

  return result;
}</pre>
  </details>
</article>








